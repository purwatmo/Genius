
master4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005e  00800100  00016f1e  00016fd2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00016f1e  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000d81  0080015e  0080015e  00017030  2**0
                  ALLOC
  3 .eeprom       00000857  00810000  00810000  00017030  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000000e0  00000000  00000000  00017887  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000274f  00000000  00000000  00017967  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00013496  00000000  00000000  0001a0b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c57  00000000  00000000  0002d54c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000dee9  00000000  00000000  0002e1a3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001210  00000000  00000000  0003c08c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005359  00000000  00000000  0003d29c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007652  00000000  00000000  000425f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006f0  00000000  00000000  00049c47  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 20 12 	jmp	0x2440	; 0x2440 <__ctors_end>
       4:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
       8:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
       c:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      10:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      14:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      18:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      1c:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      20:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      24:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      28:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      2c:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      30:	0c 94 e9 12 	jmp	0x25d2	; 0x25d2 <__vector_12>
      34:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      38:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      3c:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      40:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      44:	0c 94 98 7b 	jmp	0xf730	; 0xf730 <__vector_17>
      48:	0c 94 a2 14 	jmp	0x2944	; 0x2944 <__vector_18>
      4c:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      50:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      54:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      58:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      5c:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      60:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      64:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      68:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      6c:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      70:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      74:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      78:	0c 94 0d 3e 	jmp	0x7c1a	; 0x7c1a <__vector_30>
      7c:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      80:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      84:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      88:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__bad_interrupt>
      8c:	81 13       	cpse	r24, r17
      8e:	7f 13       	cpse	r23, r31
      90:	83 13       	cpse	r24, r19
      92:	85 13       	cpse	r24, r21
      94:	87 13       	cpse	r24, r23
      96:	89 13       	cpse	r24, r25
      98:	8b 13       	cpse	r24, r27
      9a:	8d 13       	cpse	r24, r29
      9c:	8f 13       	cpse	r24, r31
      9e:	91 13       	cpse	r25, r17
      a0:	93 13       	cpse	r25, r19
      a2:	95 13       	cpse	r25, r21
      a4:	97 13       	cpse	r25, r23
      a6:	a5 13       	cpse	r26, r21
      a8:	99 13       	cpse	r25, r25
      aa:	a5 13       	cpse	r26, r21
      ac:	9b 13       	cpse	r25, r27
      ae:	9d 13       	cpse	r25, r29
      b0:	a5 13       	cpse	r26, r21
      b2:	9f 13       	cpse	r25, r31
      b4:	a1 13       	cpse	r26, r17
      b6:	a3 13       	cpse	r26, r19
      b8:	a5 13       	cpse	r26, r21
      ba:	a5 13       	cpse	r26, r21
      bc:	99 13       	cpse	r25, r25
      be:	8b 13       	cpse	r24, r27
      c0:	a5 13       	cpse	r26, r21
      c2:	8d 13       	cpse	r24, r29
      c4:	91 13       	cpse	r25, r17
      c6:	95 13       	cpse	r25, r21
      c8:	47 53       	subi	r20, 0x37	; 55
      ca:	5f 53       	subi	r21, 0x3F	; 63
      cc:	71 53       	subi	r23, 0x31	; 49
      ce:	a6 53       	subi	r26, 0x36	; 54
      d0:	d7 53       	subi	r29, 0x37	; 55
      d2:	ed 53       	subi	r30, 0x3D	; 61
      d4:	22 54       	subi	r18, 0x42	; 66
      d6:	5c 54       	subi	r21, 0x4C	; 76
      d8:	a0 54       	subi	r26, 0x40	; 64
      da:	a8 54       	subi	r26, 0x48	; 72
      dc:	c0 54       	subi	r28, 0x40	; 64
      de:	cc 54       	subi	r28, 0x4C	; 76
      e0:	fe 54       	subi	r31, 0x4E	; 78
      e2:	3f 55       	subi	r19, 0x5F	; 95
      e4:	5c 55       	subi	r21, 0x5C	; 92
      e6:	76 55       	subi	r23, 0x56	; 86
      e8:	b6 55       	subi	r27, 0x56	; 86
      ea:	bd 53       	subi	r27, 0x3D	; 61
      ec:	78 54       	subi	r23, 0x48	; 72
      ee:	19 55       	subi	r17, 0x59	; 89
      f0:	42 54       	subi	r20, 0x42	; 66
      f2:	dc 55       	subi	r29, 0x5C	; 92
      f4:	f2 55       	subi	r31, 0x52	; 82
      f6:	f7 55       	subi	r31, 0x57	; 87
      f8:	30 56       	subi	r19, 0x60	; 96
      fa:	61 56       	subi	r22, 0x61	; 97
      fc:	a6 56       	subi	r26, 0x66	; 102
      fe:	c6 56       	subi	r28, 0x66	; 102
     100:	e4 56       	subi	r30, 0x64	; 100
     102:	1e 57       	subi	r17, 0x7E	; 126
     104:	81 57       	subi	r24, 0x71	; 113
     106:	c5 5b       	subi	r28, 0xB5	; 181
     108:	47 56       	subi	r20, 0x67	; 103
     10a:	ed 5b       	subi	r30, 0xBD	; 189
     10c:	4d 5c       	subi	r20, 0xCD	; 205
     10e:	07 5c       	subi	r16, 0xC7	; 199
     110:	32 5c       	subi	r19, 0xC2	; 194
     112:	87 5c       	subi	r24, 0xC7	; 199
     114:	67 5c       	subi	r22, 0xC7	; 199
     116:	a0 5c       	subi	r26, 0xC0	; 192
     118:	bb 5c       	subi	r27, 0xCB	; 203
     11a:	cd 5c       	subi	r28, 0xCD	; 205
     11c:	91 57       	subi	r25, 0x71	; 113
     11e:	b1 57       	subi	r27, 0x71	; 113
     120:	d8 57       	subi	r29, 0x78	; 120
     122:	e7 57       	subi	r30, 0x77	; 119
     124:	05 58       	subi	r16, 0x85	; 133
     126:	1c 58       	subi	r17, 0x8C	; 140
     128:	48 58       	subi	r20, 0x88	; 136
     12a:	5f 58       	subi	r21, 0x8F	; 143
     12c:	8b 58       	subi	r24, 0x8B	; 139
     12e:	ab 58       	subi	r26, 0x8B	; 139
     130:	dc 58       	subi	r29, 0x8C	; 140
     132:	eb 58       	subi	r30, 0x8B	; 139
     134:	44 59       	subi	r20, 0x94	; 148
     136:	bb 59       	subi	r27, 0x9B	; 155
     138:	cf 59       	subi	r28, 0x9F	; 159
     13a:	aa 5a       	subi	r26, 0xAA	; 170
     13c:	aa 5a       	subi	r26, 0xAA	; 170
     13e:	e3 59       	subi	r30, 0x93	; 147
     140:	f7 59       	subi	r31, 0x97	; 151
     142:	ff 59       	subi	r31, 0x9F	; 159
     144:	1b 5a       	subi	r17, 0xAB	; 171
     146:	2f 5a       	subi	r18, 0xAF	; 175
     148:	3c 5a       	subi	r19, 0xAC	; 172
     14a:	53 5a       	subi	r21, 0xA3	; 163
     14c:	6a 5a       	subi	r22, 0xAA	; 170
     14e:	88 5a       	subi	r24, 0xA8	; 168
     150:	ad 5a       	subi	r26, 0xAD	; 173
     152:	c4 5a       	subi	r28, 0xA4	; 164
     154:	db 5a       	subi	r29, 0xAB	; 171
     156:	f2 5a       	subi	r31, 0xA2	; 162
     158:	09 5b       	subi	r16, 0xB9	; 185
     15a:	20 5b       	subi	r18, 0xB0	; 176
     15c:	37 5b       	subi	r19, 0xB7	; 183
     15e:	4e 5b       	subi	r20, 0xBE	; 190
     160:	5d 5b       	subi	r21, 0xBD	; 189
     162:	74 5b       	subi	r23, 0xB4	; 180
     164:	97 5b       	subi	r25, 0xB7	; 183
     166:	85 8e       	std	Z+29, r8	; 0x1d
     168:	a1 8e       	std	Z+25, r10	; 0x19
     16a:	b4 8e       	std	Z+28, r11	; 0x1c
     16c:	e3 8e       	std	Z+27, r14	; 0x1b
     16e:	0c 8f       	std	Y+28, r16	; 0x1c
     170:	7f 8f       	std	Y+31, r23	; 0x1f
     172:	91 8f       	std	Z+25, r25	; 0x19
     174:	9a 8f       	std	Y+26, r25	; 0x1a
     176:	d6 8f       	std	Z+30, r29	; 0x1e
     178:	fd 8f       	std	Y+29, r31	; 0x1d
     17a:	44 90       	lpm	r4, Z+
     17c:	4e 90       	ld	r4, -X
     17e:	09 90       	ld	r0, Y+
     180:	54 90       	lpm	r5, Z+
     182:	b1 8e       	std	Z+25, r11	; 0x19
     184:	66 90       	elpm	r6, Z+
     186:	6c 90       	ld	r6, X
     188:	0e 93       	st	-X, r16
     18a:	12 93       	st	-Z, r17
     18c:	2e 93       	st	-X, r18
     18e:	2a 97       	sbiw	r28, 0x0a	; 10
     190:	2a 97       	sbiw	r28, 0x0a	; 10
     192:	2a 97       	sbiw	r28, 0x0a	; 10
     194:	2a 97       	sbiw	r28, 0x0a	; 10
     196:	80 93 2a 97 	sts	0x972A, r24
     19a:	a2 93       	st	-Z, r26
     19c:	2a 97       	sbiw	r28, 0x0a	; 10
     19e:	c1 93       	st	Z+, r28
     1a0:	4a 94       	dec	r4
     1a2:	aa 94       	dec	r10
     1a4:	ce 94 5f 93 	call	0x3126be	; 0x3126be <__data_load_end+0x2fb742>
     1a8:	2a 97       	sbiw	r28, 0x0a	; 10
     1aa:	62 94       	swap	r6
     1ac:	e6 94       	lsr	r14
     1ae:	1e 95 3b 95 	call	0x452a76	; 0x452a76 <__data_load_end+0x43bafa>
     1b2:	77 95       	ror	r23
     1b4:	87 95       	ror	r24
     1b6:	98 96       	adiw	r26, 0x28	; 40
     1b8:	a8 96       	adiw	r28, 0x28	; 40
     1ba:	ed 96       	adiw	r28, 0x3d	; 61
     1bc:	0c 97       	sbiw	r24, 0x0c	; 12
     1be:	1e 97       	sbiw	r26, 0x0e	; 14
     1c0:	24 97       	sbiw	r28, 0x04	; 4
     1c2:	26 97       	sbiw	r28, 0x06	; 6
     1c4:	21 99       	sbic	0x04, 1	; 4
     1c6:	27 99       	sbic	0x04, 7	; 4
     1c8:	2b 99       	sbic	0x05, 3	; 5
     1ca:	42 99       	sbic	0x08, 2	; 8
     1cc:	5c 99       	sbic	0x0b, 4	; 11
     1ce:	60 99       	sbic	0x0c, 0	; 12
     1d0:	8f 99       	sbic	0x11, 7	; 17
     1d2:	ae 99       	sbic	0x15, 6	; 21
     1d4:	b4 99       	sbic	0x16, 4	; 22
     1d6:	bd 99       	sbic	0x17, 5	; 23
     1d8:	c0 99       	sbic	0x18, 0	; 24
     1da:	c3 99       	sbic	0x18, 3	; 24
     1dc:	c6 99       	sbic	0x18, 6	; 24
     1de:	c9 99       	sbic	0x19, 1	; 25
     1e0:	cc 99       	sbic	0x19, 4	; 25
     1e2:	d2 99       	sbic	0x1a, 2	; 26
     1e4:	d5 99       	sbic	0x1a, 5	; 26
     1e6:	d8 99       	sbic	0x1b, 0	; 27
     1e8:	e2 99       	sbic	0x1c, 2	; 28
     1ea:	a5 9b       	sbis	0x14, 5	; 20
     1ec:	fe 9b       	sbis	0x1f, 6	; 31
     1ee:	0c 9c       	mul	r0, r12
     1f0:	54 9c       	mul	r5, r4
     1f2:	6a 9c       	mul	r6, r10
     1f4:	81 9c       	mul	r8, r1
     1f6:	aa 9c       	mul	r10, r10
     1f8:	60 9d       	mul	r22, r0
     1fa:	6e 9d       	mul	r22, r14
     1fc:	ed 9d       	mul	r30, r13
     1fe:	99 9e       	mul	r9, r25
     200:	9d 9f       	mul	r25, r29
     202:	ee 9f       	mul	r30, r30
     204:	34 a0       	ldd	r3, Z+36	; 0x24
     206:	b1 a0       	ldd	r11, Z+33	; 0x21
     208:	45 a1       	ldd	r20, Z+37	; 0x25
     20a:	eb a1       	ldd	r30, Y+35	; 0x23
     20c:	b1 a2       	std	Z+33, r11	; 0x21
     20e:	dd a2       	std	Y+37, r13	; 0x25
     210:	96 a3       	std	Z+38, r25	; 0x26
     212:	b3 a3       	std	Z+35, r27	; 0x23
     214:	c9 a4       	ldd	r12, Y+41	; 0x29
     216:	2d a4       	ldd	r2, Y+45	; 0x2d
     218:	74 a4       	ldd	r7, Z+44	; 0x2c
     21a:	6a a5       	ldd	r22, Y+42	; 0x2a
     21c:	98 a5       	ldd	r25, Y+40	; 0x28
     21e:	ad a5       	ldd	r26, Y+45	; 0x2d
     220:	d1 a4       	ldd	r13, Z+41	; 0x29
     222:	55 a5       	ldd	r21, Z+45	; 0x2d
     224:	9e a5       	ldd	r25, Y+46	; 0x2e
     226:	a6 a5       	ldd	r26, Z+46	; 0x2e
     228:	0b aa       	std	Y+51, r0	; 0x33
     22a:	0e aa       	std	Y+54, r0	; 0x36
     22c:	d0 aa       	std	Z+48, r13	; 0x30
     22e:	df aa       	std	Y+55, r13	; 0x37
     230:	12 ab       	std	Z+50, r17	; 0x32
     232:	22 ab       	std	Z+50, r18	; 0x32
     234:	50 ab       	std	Z+48, r21	; 0x30
     236:	ef aa       	std	Y+55, r14	; 0x37
     238:	fe aa       	std	Y+54, r15	; 0x36
     23a:	08 ab       	std	Y+48, r16	; 0x30
     23c:	5a ab       	std	Y+50, r21	; 0x32
     23e:	67 ab       	std	Z+55, r22	; 0x37
     240:	72 ab       	std	Z+50, r23	; 0x32
     242:	75 ab       	std	Z+53, r23	; 0x35
     244:	78 ab       	std	Y+48, r23	; 0x30
     246:	7b ab       	std	Y+51, r23	; 0x33
     248:	7e ab       	std	Y+54, r23	; 0x36
     24a:	81 ab       	std	Z+49, r24	; 0x31
     24c:	84 ab       	std	Z+52, r24	; 0x34
     24e:	87 ab       	std	Z+55, r24	; 0x37
     250:	a9 ab       	std	Y+49, r26	; 0x31
     252:	97 ab       	std	Z+55, r25	; 0x37
     254:	8a ab       	std	Y+50, r24	; 0x32
     256:	a2 ab       	std	Z+50, r26	; 0x32
     258:	ba aa       	std	Y+50, r11	; 0x32

0000025a <__logo>:
     25a:	00 00 00 01 01 01 05 09 00 00 00 11 11 11 15 15     ................
     26a:	11 00 00 00 00 10 10 10 14 12 00 0f 07 03 01 01     ................
     27a:	01 01 00 00 11 11 11 11 11 11 00 00 00 1e 1c 18     ................
     28a:	10 10 10 10 00 00 1f 1b 15 17 17 15 1b 1f 00 14     ................
     29a:	14 08 08 07 04 06 04 00                             ........

000002a2 <__c.3008>:
     2a2:	49 6e 69 74 69 61 6c 69 7a 65 2e 2e 2e 20 00        Initialize... .

000002b1 <__c.2992>:
     2b1:	57 61 74 63 68 44 6f 67 00                          WatchDog.

000002ba <__c.2990>:
     2ba:	42 72 6f 77 6e 4f 75 74 00                          BrownOut.

000002c3 <__c.2988>:
     2c3:	45 78 74 65 72 6e 61 6c 00                          External.

000002cc <__c.2986>:
     2cc:	50 6f 77 65 72 4f 6e 00                             PowerOn.

000002d4 <__prodloc>:
     2d4:	01 06 02 06 01 0d 02 0d 01 14 02 14                 ............

000002e0 <__prntloc>:
     2e0:	01 08 02 08 03 08 04 08 01 13 02 13                 ............

000002ec <__prntlmt>:
     2ec:	02 03 04 02 0f 0f                                   ......

000002f2 <__prntstr>:
     2f2:	01 01 00 00 00 00                                   ......

000002f8 <__hostloc>:
     2f8:	01 0a 02 0a 03 0a                                   ......

000002fe <MaxKeyHit>:
     2fe:	02 04 03 03 03 03 03 04 03 04                       ..........

00000308 <strDispenserName1>:
     308:	4e 2f 41 00                                         N/A.

0000030c <strDispenserName2>:
     30c:	47 69 6c 62 61 72 63 6f 00                          Gilbarco.

00000315 <strDispenserName3>:
     315:	57 61 79 6e 65 20 44 41 52 54 00                    Wayne DART.

00000320 <strDispenserName4>:
     320:	54 61 74 73 75 6e 6f 00                             Tatsuno.

00000328 <strDispenserName5>:
     328:	4c 47 00                                            LG.

0000032b <DefListDispenserName>:
     32b:	08 03 0c 03 15 03 20 03 28 03                       ...... .(.

00000335 <__c.9993>:
     335:	25 64 00                                            %d.

00000338 <__c.9991>:
     338:	54 25 2e 32 64 25 2e 32 64 25 73 25 73 25 73 25     T%.2d%.2d%s%s%s%
     348:	73 25 73 25 73 3a 00                                s%s%s:.

0000034f <__c.9942>:
     34f:	32 30 25 73 2f 25 73 2f 25 73 20 25 73 3a 25 73     20%s/%s/%s %s:%s
     35f:	3a 25 73 00                                         :%s.

00000363 <__c.9914>:
     363:	25 73 00                                            %s.

00000366 <__c.9905>:
     366:	25 73 00                                            %s.

00000369 <__c.9854>:
     369:	25 63 25 2e 32 64 3a 00                             %c%.2d:.

00000371 <__c.9833>:
     371:	43 54 53 52 50 00                                   CTSRP.

00000377 <__c.9809>:
     377:	3a 00                                               :.

00000379 <__c.9753>:
     379:	46 6d 74 54 4d 6f 6e 65 79 3a 25 73 00              FmtTMoney:%s.

00000386 <__c.9751>:
     386:	46 6d 74 4d 6f 6e 65 79 3a 25 73 00                 FmtMoney:%s.

00000392 <__c.9749>:
     392:	54 4d 6f 6e 65 79 3a 25 73 00                       TMoney:%s.

0000039c <__c.9747>:
     39c:	54 56 6f 6c 75 6d 65 3a 25 73 00                    TVolume:%s.

000003a7 <__c.9745>:
     3a7:	4d 6f 6e 65 79 3a 25 73 00                          Money:%s.

000003b0 <__c.9743>:
     3b0:	56 6f 6c 75 6d 65 3a 25 73 00                       Volume:%s.

000003ba <__c.9741>:
     3ba:	52 65 6d 6f 76 65 64 3a 25 73 00                    Removed:%s.

000003c5 <__c.9739>:
     3c5:	4d 69 6e 75 73 3a 25 73 00                          Minus:%s.

000003ce <__c.9737>:
     3ce:	52 61 77 3a 25 73 00                                Raw:%s.

000003d5 <__c.9735>:
     3d5:	46 6f 72 6d 61 74 65 64 3a 25 73 00                 Formated:%s.

000003e1 <__c.9733>:
     3e1:	25 73 00                                            %s.

000003e4 <__c.9731>:
     3e4:	25 73 00                                            %s.

000003e7 <__c.9729>:
     3e7:	25 73 00                                            %s.

000003ea <__c.9727>:
     3ea:	25 73 00                                            %s.

000003ed <__c.9725>:
     3ed:	44 61 74 61 3a 25 73 00                             Data:%s.

000003f5 <__c.9614>:
     3f5:	4e 2f 41 00                                         N/A.

000003f9 <__c.9594>:
     3f9:	25 73 00                                            %s.

000003fc <__c.9589>:
	...

000003fd <__c.9462>:
     3fd:	25 64 2e 25 73 25 73 25 73 00                       %d.%s%s%s.

00000407 <__c.9460>:
     407:	25 64 2e 25 73 25 73 25 73 25 73 25 73 00           %d.%s%s%s%s%s.

00000415 <__c.9452>:
     415:	54 4f 54 41 4c 20 25 73 25 73 00                    TOTAL %s%s.

00000420 <__c.9450>:
     420:	54 4f 54 41 4c 20 25 73 25 73 25 73 25 73 00        TOTAL %s%s%s%s.

0000042f <__c.9446>:
     42f:	25 73 25 73 00                                      %s%s.

00000434 <__c.9444>:
     434:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

0000043d <__c.9442>:
     43d:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     44d:	20 20 20 20 20 20 20 20 20 20 20 20 20 00                        .

0000045b <__c.9440>:
     45b:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     46b:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00           -------------.

00000479 <__c.9438>:
     479:	41 77 61 6c 20 3a 25 73 25 73 00                    Awal :%s%s.

00000484 <__c.9436>:
     484:	41 77 61 6c 20 3a 25 73 25 73 25 73 25 73 00        Awal :%s%s%s%s.

00000493 <__c.9434>:
     493:	41 6b 68 69 72 3a 25 73 25 73 00                    Akhir:%s%s.

0000049e <__c.9432>:
     49e:	41 6b 68 69 72 3a 25 73 25 73 25 73 25 73 00        Akhir:%s%s%s%s.

000004ad <__c.9430>:
     4ad:	50 25 64 2e 25 64 20 2d 20 25 73 20 00              P%d.%d - %s .

000004ba <__c.9428>:
     4ba:	50 25 64 2e 25 64 20 2d 20 25 73 20 25 73 20 25     P%d.%d - %s %s %
     4ca:	73 00                                               s.

000004cc <__c.9426>:
     4cc:	48 61 72 67 61 3a 20 52 70 2e 25 73 00              Harga: Rp.%s.

000004d9 <__c.9422>:
     4d9:	4e 2f 41 00                                         N/A.

000004dd <__c.9418>:
     4dd:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     4ed:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 20 20 20 20     OLUME(L)        
     4fd:	20 20 20 20 20 20 00                                      .

00000504 <__c.9416>:
     504:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     514:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 52 55 50 49     OLUME(L)    RUPI
     524:	41 48 28 52 50 29 00                                AH(RP).

0000052b <__c.9412>:
     52b:	41 6b 68 69 72 20 53 68 69 66 74 20 3a 20 25 73     Akhir Shift : %s
     53b:	20 00                                                .

0000053d <__c.9410>:
     53d:	41 77 61 6c 20 20 53 68 69 66 74 20 3a 20 25 73     Awal  Shift : %s
     54d:	20 00                                                .

0000054f <__c.9408>:
     54f:	54 65 72 6d 69 6e 61 6c 20 49 44 20 3a 20 25 2e     Terminal ID : %.
     55f:	32 64 20 20 20 20 20 20 20 20 20 20 20 20 20 20     2d              
     56f:	20 20 20 20 20 00                                        .

00000575 <__c.9406>:
     575:	20 20 20 20 20 20 20 20 4c 61 70 6f 72 61 6e 20             Laporan 
     585:	54 75 74 75 70 20 53 68 69 66 74 3a 20 25 73 20     Tutup Shift: %s 
     595:	20 20 20 20 20 00                                        .

0000059b <__c.9403>:
     59b:	25 64 00                                            %d.

0000059e <__c.9345>:
     59e:	25 73 00                                            %s.

000005a1 <__c.9340>:
     5a1:	30 00                                               0.

000005a3 <__c.9338>:
     5a3:	30 00                                               0.

000005a5 <__c.9174>:
     5a5:	25 73 00                                            %s.

000005a8 <__c.9172>:
     5a8:	25 73 00                                            %s.

000005ab <__c.9170>:
     5ab:	25 73 00                                            %s.

000005ae <__c.9168>:
     5ae:	25 73 00                                            %s.

000005b1 <__c.9166>:
     5b1:	25 73 00                                            %s.

000005b4 <__c.9080>:
     5b4:	41 2b 42 3a 25 73 00                                A+B:%s.

000005bb <__c.9078>:
     5bb:	49 6e 42 3a 25 73 00                                InB:%s.

000005c2 <__c.9074>:
     5c2:	49 6e 42 3a 5f 00                                   InB:_.

000005c8 <__c.9072>:
     5c8:	49 6e 41 3a 25 73 00                                InA:%s.

000005cf <__c.9067>:
     5cf:	49 6e 41 3a 5f 00                                   InA:_.

000005d5 <__c.9065>:
     5d5:	4f 70 65 72 61 74 69 6f 6e 20 4d 75 6c 74 69 70     Operation Multip
     5e5:	6c 79 00                                            ly.

000005e8 <__c.8936>:
     5e8:	25 73 00                                            %s.

000005eb <__c.8848>:
     5eb:	30 30 30 30 30 30 30 30 00                          00000000.

000005f4 <__c.8691>:
     5f4:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     604:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     614:	20 20 20 00                                            .

00000618 <__c.8689>:
     618:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     628:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     638:	20 20 20 00                                            .

0000063c <__c.8542>:
     63c:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     64c:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     65c:	2d 2d 00                                            --.

0000065f <__c.8539>:
     65f:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 41          Surcharge A
     66f:	6d 74 3a 20 25 73 00                                mt: %s.

00000676 <__c.8536>:
     676:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 44          Surcharge D
     686:	73 63 3a 20 25 73 00                                sc: %s.

0000068d <__c.8533>:
     68d:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     69d:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     6ad:	2d 2d 00                                            --.

000006b0 <__c.8530>:
     6b0:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     6c0:	41 20 3a 20 52 70 2e 25 73 00                       A : Rp.%s.

000006ca <__c.8527>:
     6ca:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     6da:	56 20 3a 20 25 73 20 4c 00                          V : %s L.

000006e3 <__c.8524>:
     6e3:	20 20 20 20 20 54 6f 74 61 6c 20 52 65 64 65 65          Total Redee
     6f3:	6d 20 3a 20 25 73 00                                m : %s.

000006fa <__c.8521>:
     6fa:	20 20 20 20 20 45 78 70 69 72 79 20 20 20 20 20          Expiry     
     70a:	20 20 3a 20 25 73 00                                  : %s.

00000711 <__c.8518>:
     711:	20 20 20 20 20 43 75 72 72 20 50 6f 69 6e 74 73          Curr Points
     721:	20 20 3a 20 25 73 00                                  : %s.

00000728 <__c.8515>:
     728:	20 20 20 20 20 50 72 65 76 20 50 6f 69 6e 74 73          Prev Points
     738:	20 20 3a 20 25 73 00                                  : %s.

0000073f <__c.8512>:
     73f:	20 20 20 20 20 47 61 69 6e 20 50 6f 69 6e 74 73          Gain Points
     74f:	20 20 3a 20 25 73 00                                  : %s.

00000756 <__c.8509>:
     756:	20 20 20 20 20 43 6f 72 70 20 4e 61 6d 65 20 20          Corp Name  
     766:	20 20 3a 20 25 73 00                                  : %s.

0000076d <__c.8506>:
     76d:	20 20 20 20 20 43 6f 72 70 20 49 44 20 20 20 20          Corp ID    
     77d:	20 20 3a 20 25 73 00                                  : %s.

00000784 <__c.8503>:
     784:	20 20 20 20 20 43 61 72 64 20 48 6f 6c 64 65 72          Card Holder
     794:	20 20 3a 20 25 73 20 00                               : %s .

0000079c <__c.8500>:
     79c:	20 20 20 20 20 43 61 72 64 20 49 44 20 20 20 20          Card ID    
     7ac:	20 20 3a 20 25 73 00                                  : %s.

000007b3 <__c.8497>:
     7b3:	20 20 20 20 20 20 20 20 20 4c 4f 59 41 4c 54 59              LOYALTY
     7c3:	20 49 4e 46 4f 52 4d 41 54 49 4f 4e 20 20 20 20      INFORMATION    
     7d3:	20 20 00                                              .

000007d6 <__c.8494>:
     7d6:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     7e6:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     7f6:	2d 2d 00                                            --.

000007f9 <__c.8491>:
     7f9:	20 20 20 20 2e 25 73 00                                 .%s.

00000801 <__c.8487>:
     801:	20 20 20 20 54 61 6e 64 61 20 54 61 6e 67 61 6e         Tanda Tangan
     811:	20 20 28 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f       (_____________
     821:	5f 29 00                                            _).

00000824 <__c.8482>:
     824:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     834:	20 20 20 20 20 20 00                                      .

0000083b <__c.8479>:
     83b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     84b:	20 20 20 20 20 20 00                                      .

00000852 <__c.8476>:
     852:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     862:	20 00                                                .

00000864 <__c.8474>:
     864:	20 20 00                                              .

00000867 <__c.8472>:
     867:	20 20 20 20 41 70 70 72 20 43 6f 64 65 3a 20 25         Appr Code: %
     877:	73 00                                               s.

00000879 <__c.8470>:
     879:	25 73 20 20 00                                      %s  .

0000087e <__c.8468>:
     87e:	20 20 20 20 4e 61 6d 61 20 20 20 20 20 3a 20 25         Nama     : %
     88e:	73 00                                               s.

00000890 <__c.8465>:
     890:	20 20 20 20 20 20 20 20 20 20 2a 2a 2a 20 50 55               *** PU
     8a0:	4d 50 20 54 45 53 54 20 2a 2a 2a 20 20 20 20 20     MP TEST ***     
     8b0:	20 20 00                                              .

000008b3 <__c.8463>:
     8b3:	20 20 20 20 56 6f 75 63 68 65 72 20 4e 6f 3a 20         Voucher No: 
     8c3:	25 73 00                                            %s.

000008c6 <__c.8461>:
     8c6:	20 20 20 20 4b 61 72 74 75 20 49 44 20 3a 20 25         Kartu ID : %
     8d6:	73 00                                               s.

000008d8 <__c.8458>:
     8d8:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     8e8:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     8f8:	2d 2d 00                                            --.

000008fb <__c.8455>:
     8fb:	20 20 20 20 20 20 4f 64 6f 6d 65 74 65 72 20 20           Odometer  
     90b:	20 20 3a 20 25 73 00                                  : %s.

00000912 <__c.8452>:
     912:	20 20 20 20 20 20 4e 6f 2e 50 6f 6c 69 73 69 20           No.Polisi 
     922:	20 20 3a 20 25 73 00                                  : %s.

00000929 <__c.8449>:
	...

0000092a <__c.8447>:
     92a:	20 20 20 20 20 20 4a 6d 6c 20 52 75 70 69 61 68           Jml Rupiah
     93a:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

00000944 <__c.8444>:
     944:	20 20 20 20 20 20 4a 6d 6c 20 4c 69 74 65 72 20           Jml Liter 
     954:	20 20 3a 20 25 73 20 4c 00                            : %s L.

0000095d <__c.8441>:
	...

0000095e <__c.8439>:
     95e:	20 20 20 20 20 20 48 61 72 67 61 2f 4c 20 20 20           Harga/L   
     96e:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

00000978 <__c.8436>:
     978:	20 20 20 20 20 20 50 72 6f 64 75 6b 20 20 20 20           Produk    
     988:	20 20 3a 20 25 73 00                                  : %s.

0000098f <__c.8433>:
     98f:	20 20 20 20 20 20 50 75 6c 61 75 2f 50 6f 6d 70           Pulau/Pomp
     99f:	61 20 3a 20 5b 25 73 5d 2d 25 73 00                 a : [%s]-%s.

000009ab <__c.8430>:
     9ab:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     9bb:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     9cb:	2d 2d 00                                            --.

000009ce <__c.8427>:
     9ce:	20 20 20 20 20 20 57 61 6b 74 75 3a 20 25 73 20           Waktu: %s 
     9de:	25 73 20 00                                         %s .

000009e2 <__c.8423>:
     9e2:	20 20 20 20 20 20 53 68 69 66 74 3a 20 25 73 20           Shift: %s 
     9f2:	20 4e 6f 2e 54 72 61 6e 73 3a 20 25 73 20 00         No.Trans: %s .

00000a01 <__c.8406>:
     a01:	20 00                                                .

00000a03 <__c.8404>:
     a03:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     a13:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     a23:	20 20 20 00                                            .

00000a27 <__c.8002>:
     a27:	45 72 72 6f 72 20 4e 6f 20 43 6f 6e 6e 65 63 74     Error No Connect
     a37:	69 6f 6e 00                                         ion.

00000a3b <__c.7996>:
     a3b:	50 72 6f 73 65 73 00                                Proses.

00000a42 <__c.7994>:
     a42:	53 65 6e 64 20 52 65 71 75 65 73 74 00              Send Request.

00000a4f <__c.7989>:
     a4f:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     a5f:	6e 74 65 72 00                                      nter.

00000a64 <__c.7987>:
     a64:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     a74:	6e 74 65 72 00                                      nter.

00000a79 <__c.7984>:
     a79:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     a89:	74 65 72 20 00                                      ter .

00000a8e <__c.7982>:
     a8e:	4f 64 6f 6d 65 74 65 72 3a 5f 20 00                 Odometer:_ .

00000a9a <__c.7980>:
     a9a:	50 6c 61 74 20 4e 6f 3a 20 25 73 20 00              Plat No: %s .

00000aa7 <__c.7977>:
     aa7:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ab7:	6e 74 65 72 00                                      nter.

00000abc <__c.7975>:
     abc:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     acc:	6e 74 65 72 00                                      nter.

00000ad1 <__c.7972>:
     ad1:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     ae1:	74 65 72 20 00                                      ter .

00000ae6 <__c.7970>:
     ae6:	5f 00                                               _.

00000ae8 <__c.7968>:
     ae8:	49 6e 70 75 74 20 50 6c 61 74 20 4e 6f 3a 20 00     Input Plat No: .

00000af8 <__c.7889>:
     af8:	23 29 53 61 76 65 00                                #)Save.

00000aff <__c.7887>:
     aff:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000b0c <__c.7869>:
     b0c:	23 29 53 61 76 65 00                                #)Save.

00000b13 <__c.7867>:
     b13:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000b20 <__c.7865>:
     b20:	33 29 4e 6f 74 69 66 20 3a 20 20 20 20 20 2a 29     3)Notif :     *)
     b30:	45 78 69 74 00                                      Exit.

00000b35 <__c.7863>:
     b35:	32 29 44 2f 54 20 20 20 3a 00                       2)D/T   :.

00000b3f <__c.7861>:
     b3f:	31 29 4d 6f 6e 65 79 20 3a 00                       1)Money :.

00000b49 <__c.7787>:
     b49:	34 29 43 75 74 20 3a 20 20 2a 29 45 78 69 74 00     4)Cut :  *)Exit.

00000b59 <__c.7785>:
     b59:	33 29 4c 6f 67 6f 3a 20 20 23 29 53 61 76 65 00     3)Logo:  #)Save.

00000b69 <__c.7783>:
     b69:	32 29 53 69 7a 65 3a 20 20 36 29 53 70 61 63 65     2)Size:  6)Space
     b79:	20 3a 00                                             :.

00000b7c <__c.7781>:
     b7c:	31 29 54 79 70 65 3a 20 20 35 29 53 63 72 6f 6c     1)Type:  5)Scrol
     b8c:	6c 3a 00                                            l:.

00000b8f <__c.7717>:
     b8f:	2a 29 43 61 6e 63 65 6c 20 20 20 20 20 20 23 29     *)Cancel      #)
     b9f:	53 61 76 65 00                                      Save.

00000ba4 <__c.7715>:
     ba4:	54 49 4d 45 20 3a 20 00                             TIME : .

00000bac <__c.7713>:
     bac:	44 41 54 45 20 3a 20 00                             DATE : .

00000bb4 <__c.7648>:
     bb4:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 23 29     *)Exit        #)
     bc4:	53 61 76 65 00                                      Save.

00000bc9 <__c.7646>:
     bc9:	32 29 4e 32 3a 20 20 34 29 4e 34 3a 20 20 36 29     2)N2:  4)N4:  6)
     bd9:	4e 36 3a 00                                         N6:.

00000bdd <__c.7644>:
     bdd:	31 29 4e 31 3a 20 20 33 29 4e 33 3a 20 20 35 29     1)N1:  3)N3:  5)
     bed:	4e 35 3a 00                                         N5:.

00000bf1 <__c.7642>:
     bf1:	50 72 6f 64 75 63 74 20 46 49 50 25 2e 32 64 00     Product FIP%.2d.

00000c01 <__c.7558>:
     c01:	43 6f 6d 70 6c 65 74 65 64 00                       Completed.

00000c0b <__c.7556>:
     c0b:	43 61 6e 63 65 6c 20 20 20 20 20 00                 Cancel     .

00000c17 <__c.7553>:
     c17:	49 64 5b 25 64 5d 3d 25 2e 32 64 20 20 00           Id[%d]=%.2d  .

00000c25 <__c.7550>:
     c25:	53 61 76 69 6e 67 2e 2e 00                          Saving...

00000c2e <__c.7548>:
     c2e:	2d 50 75 6d 70 49 44 2d 00                          -PumpID-.

00000c37 <__c.7544>:
     c37:	20 20 20 20 4e 6f 74 20 41 6c 6c 6f 77 65 64 20         Not Allowed 
     c47:	20 20 20 20 00                                          .

00000c4c <__c.7542>:
     c4c:	20 20 44 75 70 6c 69 63 61 74 65 20 50 75 6d 70       Duplicate Pump
     c5c:	49 44 20 20 00                                      ID  .

00000c61 <__c.7540>:
     c61:	20 20 20 20 20 20 57 61 72 6e 69 6e 67 21 20 20           Warning!  
     c71:	20 20 20 20 00                                          .

00000c76 <__c.7528>:
     c76:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     c86:	2e 32 64 00                                         .2d.

00000c8a <__c.7522>:
     c8a:	23 29 53 61 76 65 00                                #)Save.

00000c91 <__c.7520>:
     c91:	2a 29 42 61 63 6b 00                                *)Back.

00000c98 <__c.7515>:
     c98:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     ca8:	2e 32 64 00                                         .2d.

00000cac <__c.7466>:
     cac:	25 2e 32 64 00                                      %.2d.

00000cb1 <__c.7460>:
     cb1:	25 2e 32 64 00                                      %.2d.

00000cb6 <__c.7458>:
     cb6:	34 29 34 3a 20 20 20 38 29 38 3a 20 20 20 2a 29     4)4:   8)8:   *)
     cc6:	45 78 69 74 00                                      Exit.

00000ccb <__c.7456>:
     ccb:	33 29 33 3a 20 20 20 37 29 37 3a 20 20 20 23 29     3)3:   7)7:   #)
     cdb:	53 61 76 65 00                                      Save.

00000ce0 <__c.7454>:
     ce0:	32 29 32 3a 20 20 20 36 29 36 3a 00                 2)2:   6)6:.

00000cec <__c.7452>:
     cec:	31 29 31 3a 20 20 20 35 29 35 3a 00                 1)1:   5)5:.

00000cf8 <__c.7418>:
     cf8:	5b 2a 5d 45 78 69 74 20 20 5b 23 5d 43 68 61 6e     [*]Exit  [#]Chan
     d08:	67 65 20 00                                         ge .

00000d0c <__c.7416>:
     d0c:	25 64 2e 25 73 00                                   %d.%s.

00000d12 <__c.7411>:
     d12:	2d 44 69 73 70 65 6e 73 65 72 20 42 72 61 6e 64     -Dispenser Brand
     d22:	2d 00                                               -.

00000d24 <__c.7395>:
     d24:	2a 29 45 78 69 74 00                                *)Exit.

00000d2b <__c.7393>:
     d2b:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

00000d35 <__c.7391>:
     d35:	31 29 49 44 00                                      1)ID.

00000d3a <__c.7376>:
     d3a:	2a 29 45 78 69 74 00                                *)Exit.

00000d41 <__c.7371>:
     d41:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     d51:	2e 32 64 20 00                                      .2d .

00000d56 <__c.7362>:
     d56:	25 2e 32 64 00                                      %.2d.

00000d5b <__c.7161>:
     d5b:	5b 2a 5d 45 78 69 74 00                             [*]Exit.

00000d63 <__c.7159>:
     d63:	36 2e 41 63 74 3a 25 64 00                          6.Act:%d.

00000d6c <__c.7157>:
     d6c:	35 2e 44 6c 79 3a 25 64 00                          5.Dly:%d.

00000d75 <__c.7155>:
     d75:	34 2e 54 69 6d 50 6f 6f 6c 3a 25 64 00              4.TimPool:%d.

00000d82 <__c.7153>:
     d82:	33 2e 54 72 79 53 65 6e 64 3a 25 64 00              3.TrySend:%d.

00000d8f <__c.7151>:
     d8f:	32 2e 6e 4e 6f 50 75 6d 70 3a 25 64 00              2.nNoPump:%d.

00000d9c <__c.7149>:
     d9c:	31 2e 4d 61 78 50 75 6d 70 3a 25 64 00              1.MaxPump:%d.

00000da9 <__c.7090>:
     da9:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00000db6 <__c.7085>:
     db6:	43 4f 4d 25 64 3a 25 64 00                          COM%d:%d.

00000dbf <__c.7083>:
     dbf:	20 20 20 20 20 2d 42 61 75 64 72 61 74 65 2d 20          -Baudrate- 
     dcf:	20 20 20 20 00                                          .

00000dd4 <__c.7078>:
     dd4:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 00           [*]Back      .

00000de2 <__c.7076>:
     de2:	33 2e 43 4f 4d 33 3a 34 38 35 00                    3.COM3:485.

00000ded <__c.7074>:
     ded:	33 2e 43 4f 4d 33 3a 32 33 32 00                    3.COM3:232.

00000df8 <__c.7072>:
     df8:	33 2e 43 4f 4d 33 3a 54 54 4c 00                    3.COM3:TTL.

00000e03 <__c.7070>:
     e03:	32 2e 42 61 75 64 72 61 74 65 00                    2.Baudrate.

00000e0e <__c.7068>:
     e0e:	31 2e 4d 6f 64 65 3a 53 74 61 6e 64 61 6c 6f 6e     1.Mode:Standalon
     e1e:	65 00                                               e.

00000e20 <__c.7066>:
     e20:	31 2e 4d 6f 64 65 3a 53 6c 61 76 65 00              1.Mode:Slave.

00000e2d <__c.7064>:
     e2d:	31 2e 4d 6f 64 65 3a 4e 6f 6e 65 00                 1.Mode:None.

00000e39 <__c.7017>:
     e39:	49 6e 76 61 6c 69 64 20 4f 6c 64 20 50 61 73 73     Invalid Old Pass
     e49:	77 6f 72 64 00                                      word.

00000e4e <__c.7015>:
     e4e:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     e5e:	20 20 20 20 00                                          .

00000e63 <__c.7013>:
     e63:	49 6e 76 61 6c 69 64 20 4e 65 77 20 50 61 73 73     Invalid New Pass
     e73:	77 6f 72 64 00                                      word.

00000e78 <__c.7011>:
     e78:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     e88:	20 20 20 20 00                                          .

00000e8d <__c.7009>:
     e8d:	20 20 20 50 61 73 73 77 6f 72 64 20 53 61 76 65        Password Save
     e9d:	64 20 20 20 00                                      d   .

00000ea2 <__c.7007>:
     ea2:	20 20 20 20 20 43 6f 6d 70 6c 65 74 65 64 20 20          Completed  
     eb2:	20 20 20 20 00                                          .

00000eb7 <__c.7003>:
     eb7:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ec7:	6e 74 65 72 00                                      nter.

00000ecc <__c.7000>:
     ecc:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     edc:	6e 74 65 72 00                                      nter.

00000ee1 <__c.6997>:
     ee1:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ef1:	6e 74 65 72 00                                      nter.

00000ef6 <__c.6995>:
     ef6:	4e 65 77 3a 5f 00                                   New:_.

00000efc <__c.6991>:
     efc:	56 61 6c 69 64 61 74 69 6e 67 2e 2e 00              Validating...

00000f09 <__c.6987>:
     f09:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f19:	6e 74 65 72 00                                      nter.

00000f1e <__c.6984>:
     f1e:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     f2e:	6e 74 65 72 00                                      nter.

00000f33 <__c.6979>:
     f33:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f43:	6e 74 65 72 00                                      nter.

00000f48 <__c.6977>:
     f48:	4e 65 77 3a 5f 00                                   New:_.

00000f4e <__c.6973>:
     f4e:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f5e:	6e 74 65 72 00                                      nter.

00000f63 <__c.6970>:
     f63:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     f73:	6e 74 65 72 00                                      nter.

00000f78 <__c.6965>:
     f78:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f88:	6e 74 65 72 00                                      nter.

00000f8d <__c.6963>:
     f8d:	4e 65 77 3a 5f 00                                   New:_.

00000f93 <__c.6959>:
     f93:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     fa3:	6e 74 65 72 00                                      nter.

00000fa8 <__c.6957>:
     fa8:	4f 6c 64 3a 5f 00                                   Old:_.

00000fae <__c.6955>:
     fae:	2d 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 2d 00     -Administrator-.

00000fbe <__c.6953>:
     fbe:	2d 53 75 70 65 72 76 69 73 6f 72 2d 00              -Supervisor-.

00000fcb <__c.6945>:
     fcb:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00000fd8 <__c.6943>:
     fd8:	32 2e 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 00     2.Administrator.

00000fe8 <__c.6941>:
     fe8:	31 2e 53 75 70 65 72 76 69 73 6f 72 00              1.Supervisor.

00000ff5 <__c.6939>:
     ff5:	2d 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72 64     -Change Password
    1005:	2d 00                                               -.

00001007 <__c.6936>:
    1007:	53 61 76 65 64 20 00                                Saved .

0000100e <__c.6930>:
    100e:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    101e:	6e 74 65 72 00                                      nter.

00001023 <__c.6927>:
    1023:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1033:	6e 74 65 72 00                                      nter.

00001038 <__c.6922>:
    1038:	5b 2a 5d 4e 6f 20 20 20 20 5b 23 5d 59 65 73 00     [*]No    [#]Yes.

00001048 <__c.6920>:
    1048:	53 61 76 65 3f 00                                   Save?.

0000104e <__c.6918>:
    104e:	4e 65 77 20 4f 70 65 72 61 74 6f 72 3a 00           New Operator:.

0000105c <__c.6916>:
    105c:	25 73 00                                            %s.

0000105f <__c.6912>:
    105f:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    106f:	6e 74 65 72 00                                      nter.

00001074 <__c.6910>:
    1074:	4e 65 77 3a 5f 00                                   New:_.

0000107a <__c.6908>:
    107a:	4e 61 6d 65 3a 00                                   Name:.

00001080 <__c.6906>:
    1080:	25 73 00                                            %s.

00001083 <__c.6897>:
    1083:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    1093:	64 00                                               d.

00001095 <__c.6895>:
    1095:	31 2e 43 68 61 6e 67 65 20 4f 70 65 72 61 74 6f     1.Change Operato
    10a5:	72 00                                               r.

000010a7 <__c.6812>:
    10a7:	2a 29 42 61 63 6b 00                                *)Back.

000010ae <__c.6810>:
    10ae:	34 2e 53 70 61 72 61 74 6f 72 3a 25 63 20 00        4.Sparator:%c .

000010bd <__c.6808>:
    10bd:	33 2e 44 65 63 69 6d 61 6c 20 3a 25 63 20 00        3.Decimal :%c .

000010cc <__c.6806>:
    10cc:	32 2e 54 2e 4d 6f 6e 65 79 20 3a 25 64 20 00        2.T.Money :%d .

000010db <__c.6804>:
    10db:	31 2e 54 2e 56 6f 6c 75 6d 65 3a 25 64 20 20 35     1.T.Volume:%d  5
    10eb:	2e 54 65 73 74 00                                   .Test.

000010f1 <__c.6799>:
    10f1:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4e 65 78 74     [*]Back  [#]Next
	...

00001102 <__c.6797>:
    1102:	33 2e 4d 6f 6e 65 79 20 3a 25 64 00                 3.Money :%d.

0000110e <__c.6795>:
    110e:	32 2e 56 6f 6c 75 6d 65 3a 25 64 00                 2.Volume:%d.

0000111a <__c.6793>:
    111a:	31 2e 50 72 69 63 65 20 3a 25 64 00                 1.Price :%d.

00001126 <__c.6776>:
    1126:	34 29 42 72 61 6e 64 20 20 2a 29 45 78 69 74 00     4)Brand  *)Exit.

00001136 <__c.6774>:
    1136:	33 29 4c 61 62 65 6c 20 20 00                       3)Label  .

00001140 <__c.6772>:
    1140:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

0000114a <__c.6770>:
    114a:	31 29 49 44 20 20 20 20 20 00                       1)ID     .

00001154 <__c.6729>:
    1154:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    1164:	20 20 20 20 00                                          .

00001169 <__c.6727>:
    1169:	4e 65 77 3a 5f 00                                   New:_.

0000116f <__c.6725>:
    116f:	4f 6c 64 3a 25 73 00                                Old:%s.

00001176 <__c.6723>:
    1176:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    1186:	20 20 20 20 00                                          .

0000118b <__c.6721>:
    118b:	4e 65 77 3a 5f 00                                   New:_.

00001191 <__c.6719>:
    1191:	45 64 69 74 20 50 72 6f 64 75 63 74 20 4e 61 6d     Edit Product Nam
    11a1:	65 20 20 20 00                                      e   .

000011a6 <__c.6717>:
    11a6:	4f 6c 64 3a 25 73 00                                Old:%s.

000011ad <__c.6714>:
    11ad:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 00           *)Back       .

000011bb <__c.6712>:
    11bb:	32 29 25 73 00                                      2)%s.

000011c0 <__c.6710>:
    11c0:	31 29 25 73 00                                      1)%s.

000011c5 <__c.6705>:
    11c5:	2a 29 42 61 63 6b 00                                *)Back.

000011cc <__c.6700>:
    11cc:	25 64 29 25 73 00                                   %d)%s.

000011d2 <__c.6627>:
    11d2:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 20 20 20     *)Back          
    11e2:	20 20 20 20 00                                          .

000011e7 <__c.6625>:
    11e7:	33 29 50 75 6d 70 50 6f 6f 6c 69 6e 67 20 20 20     3)PumpPooling   
    11f7:	20 20 20 20 00                                          .

000011fc <__c.6623>:
    11fc:	32 29 53 79 73 74 65 6d 20 20 20 20 20 20 20 20     2)System        
    120c:	20 20 20 20 00                                          .

00001211 <__c.6621>:
    1211:	31 29 4f 70 65 72 61 74 6f 72 20 20 20 20 20 20     1)Operator      
    1221:	20 20 20 20 00                                          .

00001226 <__c.6618>:
    1226:	34 29 44 61 74 65 74 69 6d 65 20 2a 29 45 78 69     4)Datetime *)Exi
    1236:	74 20 20 20 00                                      t   .

0000123b <__c.6616>:
    123b:	33 29 44 65 63 69 6d 61 6c 20 20 37 29 4e 65 78     3)Decimal  7)Nex
    124b:	74 20 20 20 00                                      t   .

00001250 <__c.6614>:
    1250:	32 29 50 75 6d 70 20 20 20 20 20 36 29 48 6f 73     2)Pump     6)Hos
    1260:	74 20 20 20 00                                      t   .

00001265 <__c.6612>:
    1265:	31 29 50 72 6f 64 75 63 74 20 20 35 29 50 72 69     1)Product  5)Pri
    1275:	6e 74 65 72 00                                      nter.

0000127a <__c.6525>:
    127a:	2e 00                                               ..

0000127c <__c.6523>:
    127c:	25 64 00                                            %d.

0000127f <__c.6521>:
    127f:	20 20 20 00                                            .

00001283 <__c.6519>:
    1283:	2e 00                                               ..

00001285 <__c.6517>:
    1285:	25 64 00                                            %d.

00001288 <__c.6515>:
    1288:	20 20 20 00                                            .

0000128c <__c.6508>:
    128c:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    129c:	78 74 20 20 00                                      xt  .

000012a1 <__c.6506>:
    12a1:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    12b1:	2e 20 20 20 00                                      .   .

000012b6 <__c.6504>:
    12b6:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

000012c7 <__c.6502>:
    12c7:	53 65 72 76 65 72 20 49 50 00                       Server IP.

000012d1 <__c.6411>:
    12d1:	2e 00                                               ..

000012d3 <__c.6409>:
    12d3:	25 64 00                                            %d.

000012d6 <__c.6407>:
    12d6:	20 20 20 00                                            .

000012da <__c.6405>:
    12da:	2e 00                                               ..

000012dc <__c.6403>:
    12dc:	25 64 00                                            %d.

000012df <__c.6401>:
    12df:	20 20 20 00                                            .

000012e3 <__c.6394>:
    12e3:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    12f3:	78 74 20 20 00                                      xt  .

000012f8 <__c.6392>:
    12f8:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    1308:	2e 20 20 20 00                                      .   .

0000130d <__c.6390>:
    130d:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

0000131e <__c.6388>:
    131e:	43 6c 69 65 6e 74 20 49 50 00                       Client IP.

00001328 <__c.6345>:
    1328:	25 73 25 73 00                                      %s%s.

0000132d <__c.6341>:
    132d:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

0000133a <__c.6339>:
    133a:	53 61 76 65 20 46 6f 6f 74 65 72 25 64 20 3f 00     Save Footer%d ?.

0000134a <__c.6335>:
    134a:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

00001358 <__c.6333>:
    1358:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

00001366 <__c.6330>:
    1366:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

00001375 <__c.6328>:
    1375:	45 64 69 74 20 46 6f 6f 74 65 72 25 64 20 00        Edit Footer%d .

00001384 <__c.6324>:
    1384:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    1394:	20 20 20 20 00                                          .

00001399 <__c.6322>:
    1399:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    13a9:	20 20 20 20 00                                          .

000013ae <__c.6320>:
    13ae:	32 29 46 6f 6f 74 65 72 32 20 20 34 29 46 6f 6f     2)Footer2  4)Foo
    13be:	74 65 72 34 00                                      ter4.

000013c3 <__c.6318>:
    13c3:	31 29 46 6f 6f 74 65 72 31 20 20 33 29 46 6f 6f     1)Footer1  3)Foo
    13d3:	74 65 72 33 00                                      ter3.

000013d8 <__c.6286>:
    13d8:	25 73 25 73 00                                      %s%s.

000013dd <__c.6282>:
    13dd:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

000013ea <__c.6280>:
    13ea:	53 61 76 65 20 48 65 61 64 65 72 25 64 20 3f 00     Save Header%d ?.

000013fa <__c.6276>:
    13fa:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

00001408 <__c.6274>:
    1408:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

00001416 <__c.6271>:
    1416:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

00001425 <__c.6269>:
    1425:	45 64 69 74 20 48 65 61 64 65 72 25 64 20 00        Edit Header%d .

00001434 <__c.6265>:
    1434:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    1444:	20 20 20 20 00                                          .

00001449 <__c.6263>:
    1449:	33 29 48 65 61 64 65 72 33 20 20 36 29 48 65 61     3)Header3  6)Hea
    1459:	64 65 72 36 00                                      der6.

0000145e <__c.6261>:
    145e:	32 29 48 65 61 64 65 72 32 20 20 35 29 48 65 61     2)Header2  5)Hea
    146e:	64 65 72 35 00                                      der5.

00001473 <__c.6259>:
    1473:	31 29 48 65 61 64 65 72 31 20 20 34 29 48 65 61     1)Header1  4)Hea
    1483:	64 65 72 34 00                                      der4.

00001488 <__c.6216>:
    1488:	2a 29 45 78 69 74 00                                *)Exit.

0000148f <__c.6214>:
    148f:	33 29 50 61 73 73 77 6f 72 64 20 20 20 20 20 20     3)Password      
    149f:	20 20 20 20 00                                          .

000014a4 <__c.6212>:
    14a4:	32 29 46 6f 6f 74 65 72 20 20 20 20 20 20 20 20     2)Footer        
    14b4:	20 20 20 20 00                                          .

000014b9 <__c.6210>:
    14b9:	31 29 48 65 61 64 65 72 20 20 20 20 20 20 20 20     1)Header        
    14c9:	20 20 20 20 00                                          .

000014ce <__c.6208>:
    14ce:	32 29 46 6f 6f 74 65 72 20 20 20 20 35 29 53 65     2)Footer    5)Se
    14de:	72 76 65 72 00                                      rver.

000014e3 <__c.6206>:
    14e3:	31 29 48 65 61 64 65 72 20 20 20 20 34 29 43 6c     1)Header    4)Cl
    14f3:	69 65 6e 74 00                                      ient.

000014f8 <__c.6152>:
    14f8:	53 61 76 69 6e 67 20 53 68 69 66 74 44 61 74 61     Saving ShiftData
    1508:	2e 2e 20 00                                         .. .

0000150c <__c.6147>:
    150c:	25 73 20 25 73 00                                   %s %s.

00001512 <__c.6145>:
    1512:	50 72 69 6e 74 69 6e 67 20 54 6f 74 61 6c 69 7a     Printing Totaliz
    1522:	65 72 00                                            er.

00001525 <__c.6141>:
    1525:	43 61 6e 63 65 6c 00                                Cancel.

0000152c <__c.6136>:
    152c:	45 72 72 6f 72 20 2d 20 4e 6f 20 50 75 6d 70 3a     Error - No Pump:
    153c:	25 64 20 00                                         %d .

00001540 <__c.6131>:
    1540:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

0000154e <__c.6127>:
    154e:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

0000155c <__c.6125>:
    155c:	54 6f 74 61 6c 69 7a 65 72 2e 2e 00                 Totalizer...

00001568 <__c.6053>:
    1568:	2a 29 45 78 69 74 00                                *)Exit.

0000156f <__c.6051>:
    156f:	33 2e 4c 6f 63 6b 20 50 75 6d 70 20 20 00           3.Lock Pump  .

0000157d <__c.6049>:
    157d:	32 2e 43 6c 6f 73 65 20 44 61 79 20 20 00           2.Close Day  .

0000158b <__c.6047>:
    158b:	31 2e 43 6c 6f 73 65 20 53 68 69 66 74 00           1.Close Shift.

00001599 <__c.6005>:
    1599:	34 29 53 65 74 74 69 6e 67 73 20 20 20 2a 29 45     4)Settings   *)E
    15a9:	78 69 74 20 00                                      xit .

000015ae <__c.6003>:
    15ae:	33 29 43 6c 6f 73 65 44 61 79 20 20 20 20 20 20     3)CloseDay      
    15be:	20 20 20 20 00                                          .

000015c3 <__c.6001>:
    15c3:	32 29 43 6c 6f 73 65 53 68 69 66 74 20 20 20 20     2)CloseShift    
    15d3:	20 20 20 20 00                                          .

000015d8 <__c.5999>:
    15d8:	31 29 52 65 50 72 69 6e 74 20 20 20 20 20 20 20     1)RePrint       
    15e8:	20 20 20 20 00                                          .

000015ed <__c.5969>:
    15ed:	50 61 73 73 77 6f 72 64 20 52 65 73 74 6f 72 65     Password Restore
    15fd:	64 00                                               d.

000015ff <__c.5965>:
    15ff:	49 6e 76 61 6c 69 64 20 52 65 73 74 6f 72 65 20     Invalid Restore 
    160f:	20 00                                                .

00001611 <__c.5962>:
    1611:	30 30 30 30 30 00                                   00000.

00001617 <__c.5960>:
    1617:	31 31 31 31 31 00                                   11111.

0000161d <__c.5956>:
    161d:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    162d:	6e 74 65 72 00                                      nter.

00001632 <__c.5953>:
    1632:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1642:	6e 74 65 72 00                                      nter.

00001647 <__c.5946>:
    1647:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1657:	6e 74 65 72 00                                      nter.

0000165c <__c.5944>:
    165c:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    166c:	20 20 20 20 00                                          .

00001671 <__c.5942>:
    1671:	45 6e 74 65 72 20 52 65 73 74 6f 72 65 20 43 6f     Enter Restore Co
    1681:	64 65 20 20 00                                      de  .

00001686 <__c.5940>:
    1686:	4b 65 79 20 53 74 61 6d 70 3a 25 73 20 00           Key Stamp:%s .

00001694 <__c.5936>:
    1694:	49 6e 76 61 6c 69 64 20 43 6f 64 65 20 20 20 20     Invalid Code    
    16a4:	20 20 20 20 00                                          .

000016a9 <__c.5933>:
	...

000016aa <__c.5931>:
    16aa:	25 73 00                                            %s.

000016ad <__c.5929>:
    16ad:	25 73 00                                            %s.

000016b0 <__c.5926>:
    16b0:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    16c0:	6e 74 65 72 00                                      nter.

000016c5 <__c.5923>:
    16c5:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    16d5:	6e 74 65 72 00                                      nter.

000016da <__c.5916>:
	...

000016db <__c.5914>:
    16db:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    16eb:	6e 74 65 72 00                                      nter.

000016f0 <__c.5912>:
    16f0:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    1700:	20 20 20 20 00                                          .

00001705 <__c.5910>:
    1705:	45 6e 74 65 72 20 47 65 4e 69 55 73 20 43 6f 64     Enter GeNiUs Cod
    1715:	65 20 20 20 00                                      e   .

0000171a <__c.5900>:
    171a:	5b 2a 5d 45 78 69 74 20 20 20 20 20 20 20 20 20     [*]Exit         
    172a:	20 20 20 20 00                                          .

0000172f <__c.5898>:
    172f:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    173f:	64 20 20 20 00                                      d   .

00001744 <__c.5896>:
    1744:	31 2e 52 65 73 74 6f 72 65 20 50 61 73 73 77 6f     1.Restore Passwo
    1754:	72 64 20 20 00                                      rd  .

00001759 <__c.5894>:
    1759:	2d 53 79 73 74 65 6d 20 41 64 6d 69 6e 20 4c 65     -System Admin Le
    1769:	76 65 6c 2d 00                                      vel-.

0000176e <__c.5835>:
    176e:	25 73 25 73 00                                      %s%s.

00001773 <__c.5807>:
    1773:	25 73 00                                            %s.

00001776 <__c.5774>:
    1776:	25 63 00                                            %c.

00001779 <__c.5772>:
    1779:	32 30 25 73 00                                      20%s.

0000177e <__c.5750>:
    177e:	25 73 00                                            %s.

00001781 <__c.5701>:
    1781:	34 32 36 34 36 33 36 00                             4264636.

00001789 <__c.5698>:
    1789:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1799:	6e 74 65 72 00                                      nter.

0000179e <__c.5696>:
    179e:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    17ae:	6e 74 65 72 00                                      nter.

000017b3 <__c.5692>:
    17b3:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    17c3:	6e 74 65 72 00                                      nter.

000017c8 <__c.5690>:
    17c8:	5f 00                                               _.

000017ca <__c.5688>:
    17ca:	50 41 53 53 57 4f 52 44 3a 00                       PASSWORD:.

000017d4 <__c.5660>:
    17d4:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

000017e2 <__c.5583>:
    17e2:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

000017ef <__c.5581>:
    17ef:	4e 6f 20 52 65 70 6c 79 20 20 20 20 00              No Reply    .

000017fc <__c.5577>:
    17fc:	20 20 20 20 20 20 20 00                                    .

00001804 <__c.5574>:
    1804:	50 6c 65 61 73 65 20 57 61 69 74 00                 Please Wait.

00001810 <__c.5571>:
    1810:	25 73 00                                            %s.

00001813 <__c.5569>:
    1813:	50 55 4d 50 20 54 45 53 54 00                       PUMP TEST.

0000181d <__c.5566>:
    181d:	25 73 00                                            %s.

00001820 <__c.5563>:
    1820:	25 73 00                                            %s.

00001823 <__c.5561>:
    1823:	25 73 00                                            %s.

00001826 <__c.5559>:
    1826:	25 73 00                                            %s.

00001829 <__c.5555>:
    1829:	25 73 00                                            %s.

0000182c <__c.5551>:
    182c:	50 72 6f 73 65 73 00                                Proses.

00001833 <__c.5549>:
    1833:	2d 4d 4f 50 20 56 6f 75 63 68 65 72 2d 00           -MOP Voucher-.

00001841 <__c.5546>:
    1841:	50 72 6f 73 65 73 00                                Proses.

00001848 <__c.5544>:
    1848:	49 44 3a 25 73 00                                   ID:%s.

0000184e <__c.5540>:
    184e:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    185e:	69 74 00                                            it.

00001861 <__c.5538>:
    1861:	46 49 50 25 73 00                                   FIP%s.

00001867 <__c.5536>:
    1867:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001876 <__c.5527>:
    1876:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1886:	6e 74 65 72 00                                      nter.

0000188b <__c.5525>:
    188b:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    189b:	6e 74 65 72 00                                      nter.

000018a0 <__c.5522>:
    18a0:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18b0:	6e 74 65 72 00                                      nter.

000018b5 <__c.5520>:
    18b5:	53 75 72 63 68 61 72 67 65 3a 20 20 20 5f 25 00     Surcharge:   _%.

000018c5 <__c.5518>:
    18c5:	25 73 00                                            %s.

000018c8 <__c.5514>:
    18c8:	5b 2a 5d 42 61 63 6b 00                             [*]Back.

000018d0 <__c.5509>:
    18d0:	25 64 2e 25 73 00                                   %d.%s.

000018d6 <__c.5507>:
    18d6:	53 65 6c 65 63 74 20 42 61 6e 6b 00                 Select Bank.

000018e2 <__c.5502>:
    18e2:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18f2:	6e 74 65 72 00                                      nter.

000018f7 <__c.5500>:
    18f7:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1907:	6e 74 65 72 00                                      nter.

0000190c <__c.5497>:
    190c:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    191c:	6e 74 65 72 00                                      nter.

00001921 <__c.5495>:
    1921:	5f 00                                               _.

00001923 <__c.5493>:
    1923:	4b 6f 64 65 20 56 6f 75 63 68 65 72 00              Kode Voucher.

00001930 <__c.5484>:
    1930:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1940:	20 20 20 20 00                                          .

00001945 <__c.5482>:
    1945:	32 2e 42 61 6e 6b 20 20 20 20 34 2e 50 75 6d 70     2.Bank    4.Pump
    1955:	54 65 73 74 00                                      Test.

0000195a <__c.5480>:
    195a:	31 2e 41 63 63 6f 75 6e 74 20 33 2e 56 6f 75 63     1.Account 3.Vouc
    196a:	68 65 72 20 00                                      her .

0000196f <__c.5478>:
    196f:	20 20 20 53 65 6c 65 63 74 20 50 61 79 6d 65 6e        Select Paymen
    197f:	74 20 20 20 00                                      t   .

00001984 <__c.5425>:
    1984:	43 52 45 44 49 54 43 41 52 44 00                    CREDITCARD.

0000198f <__c.5419>:
    198f:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    199f:	20 20 20 20 00                                          .

000019a4 <__c.5417>:
    19a4:	32 2e 43 72 65 64 69 74 20 43 61 72 64 20 20 20     2.Credit Card   
    19b4:	20 20 20 20 00                                          .

000019b9 <__c.5415>:
    19b9:	31 2e 44 65 62 69 74 2f 46 6c 61 73 68 20 43 61     1.Debit/Flash Ca
    19c9:	72 64 20 20 00                                      rd  .

000019ce <__c.5413>:
    19ce:	53 65 6c 65 63 74 20 43 61 72 64 20 54 79 70 65     Select Card Type
	...

000019df <__c.5379>:
    19df:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

000019ed <__c.5377>:
    19ed:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

000019fb <__c.5370>:
    19fb:	50 72 65 73 73 20 41 6e 79 20 4b 65 79 00           Press Any Key.

00001a09 <__c.5368>:
    1a09:	43 6d 20 56 6f 6c 3a 25 73 00                       Cm Vol:%s.

00001a13 <__c.5366>:
    1a13:	43 4d 20 41 6d 74 3a 25 73 00                       CM Amt:%s.

00001a1d <__c.5364>:
    1a1d:	50 6f 69 6e 74 73 3a 25 73 00                       Points:%s.

00001a27 <__c.5362>:
    1a27:	25 73 3a 25 73 00                                   %s:%s.

00001a2d <__c.5355>:
    1a2d:	50 72 6f 73 65 73 00                                Proses.

00001a34 <__c.5353>:
    1a34:	49 44 3a 25 73 00                                   ID:%s.

00001a3a <__c.5349>:
    1a3a:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1a4a:	69 74 00                                            it.

00001a4d <__c.5347>:
    1a4d:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001a5c <__c.5344>:
    1a5c:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1a6c:	69 74 00                                            it.

00001a6f <__c.5342>:
    1a6f:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001a7e <__c.5340>:
    1a7e:	46 49 50 3a 25 73 00                                FIP:%s.

00001a85 <__c.5334>:
    1a85:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1a95:	20 00                                                .

00001a97 <__c.5332>:
    1a97:	32 2e 4c 6f 79 61 6c 74 79 20 55 70 64 61 74 65     2.Loyalty Update
    1aa7:	20 00                                                .

00001aa9 <__c.5330>:
    1aa9:	31 2e 45 6e 71 75 69 72 79 20 20 20 20 20 20 20     1.Enquiry       
    1ab9:	20 00                                                .

00001abb <__c.5328>:
    1abb:	20 20 4d 65 6e 75 20 4c 6f 79 61 6c 74 79 20 20       Menu Loyalty  
    1acb:	20 00                                                .

00001acd <__c.5293>:
    1acd:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001adb <__c.5291>:
    1adb:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001ae9 <__c.5285>:
    1ae9:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1af9:	69 74 00                                            it.

00001afc <__c.5283>:
    1afc:	54 61 70 20 53 75 70 65 72 76 69 73 6f 72 20 43     Tap Supervisor C
    1b0c:	61 72 64 00                                         ard.

00001b10 <__c.5281>:
    1b10:	52 65 50 72 69 6e 74 20 46 49 50 3a 25 73 20 00     RePrint FIP:%s .

00001b20 <__c.5277>:
    1b20:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    1b30:	6b 73 69 20 00                                      ksi .

00001b35 <__c.5271>:
    1b35:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001b43 <__c.5225>:
    1b43:	2a 29 45 78 69 74 00                                *)Exit.

00001b4a <__c.5223>:
    1b4a:	23 29 4f 4b 20 00                                   #)OK .

00001b50 <__c.5221>:
    1b50:	20 20 20 20 20 00                                        .

00001b56 <__c.5219>:
    1b56:	46 49 50 3a 5f 00                                   FIP:_.

00001b5c <__c.5214>:
    1b5c:	25 64 2e 50 25 73 20 7c 20 25 64 2e 50 25 73 00     %d.P%s | %d.P%s.

00001b6c <__c.5165>:
    1b6c:	30 32 25 73 25 73 25 73 25 73 25 73 25 73 25 73     02%s%s%s%s%s%s%s
	...

00001b7d <__c.5022>:
    1b7d:	30 00                                               0.

00001b7f <__c.4953>:
    1b7f:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1b8f:	20 20 20 20 00                                          .

00001b94 <__c.4948>:
    1b94:	23 25 73 00                                         #%s.

00001b98 <__c.4946>:
    1b98:	25 2e 32 64 00                                      %.2d.

00001b9d <__c.4944>:
    1b9d:	40 46 49 50 3a 00                                   @FIP:.

00001ba3 <__c.4942>:
    1ba3:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1bb3:	20 20 20 20 00                                          .

00001bb8 <__c.4938>:
    1bb8:	50 72 69 6e 74 69 6e 67 20 46 49 50 25 73 20 00     Printing FIP%s .

00001bc8 <__c.4912>:
    1bc8:	44 3a 25 64 20 43 3a 25 63 20 20 00                 D:%d C:%c  .

00001bd4 <__c.4893>:
    1bd4:	25 73 20 25 73 00                                   %s %s.

00001bda <__c.4866>:
    1bda:	4e 6f 20 50 75 6d 70 20 46 6f 75 6e 64 00           No Pump Found.

00001be8 <__c.4864>:
    1be8:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

00001bf5 <__c.4862>:
    1bf5:	50 75 6d 70 46 6f 75 6e 64 00                       PumpFound.

00001bff <__c.4860>:
    1bff:	43 6f 6e 6e 65 63 74 65 64 00                       Connected.

00001c09 <__c.4855>:
    1c09:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1c19:	20 20 20 00                                            .

00001c1d <__c.4853>:
    1c1d:	25 73 00                                            %s.

00001c20 <__c.4848>:
    1c20:	53 63 61 6e 20 50 75 6d 70 00                       Scan Pump.

00001c2a <__c.4843>:
    1c2a:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001c3b <__c.4841>:
    1c3b:	43 6f 6e 6e 65 63 74 00                             Connect.

00001c43 <__c.4839>:
    1c43:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001c54 <__c.4812>:
    1c54:	43 4f 4d 25 64 3a 25 69 20 20 20 20 20 20 20 20     COM%d:%i        
    1c64:	20 20 20 00                                            .

00001c68 <__c.4810>:
    1c68:	49 6e 69 74 69 61 6c 69 7a 65 20 43 4f 4d 20 2e     Initialize COM .
    1c78:	2e 2e 00                                            ...

00001c7b <__c.4771>:
    1c7b:	0a 47 65 4e 69 55 73 20 54 69 63 6b 65 74 20 50     .GeNiUs Ticket P
    1c8b:	72 69 6e 74 65 72 20 0a 20 56 65 72 73 69 6f 6e     rinter . Version
    1c9b:	3a 25 73 0a 20 4c 61 73 74 20 55 70 64 61 74 65     :%s. Last Update
    1cab:	20 25 73 20 0a 20 48 61 6e 69 6e 64 6f 20 41 75      %s . Hanindo Au
    1cbb:	74 6f 6d 61 74 69 6f 6e 20 53 6f 6c 75 74 69 6f     tomation Solutio
    1ccb:	6e 73 20 0a 20 77 77 77 2e 68 61 6e 69 6e 64 6f     ns . www.hanindo
    1cdb:	67 72 6f 75 70 2e 63 6f 6d 0a 0a 0a 0a 0a 0a 0a     group.com.......
    1ceb:	0a 00                                               ..

00001ced <__c.4769>:
    1ced:	30 37 2f 30 31 2f 32 30 31 31 00                    07/01/2011.

00001cf8 <__c.4767>:
    1cf8:	32 2e 33 34 00                                      2.34.

00001cfd <__c.4758>:
    1cfd:	25 73 25 73 25 73 25 73 39 38 25 2e 32 64 46 39     %s%s%s%s98%.2dF9
    1d0d:	36 38 43 46 46 42 00                                68CFFB.

00001d14 <__c.4635>:
    1d14:	46 75 65 6c 69 6e 67 20 40 46 49 50 3a 23 25 64     Fueling @FIP:#%d
	...

00001d25 <__c.4633>:
    1d25:	54 72 61 6e 73 61 6b 73 69 20 53 65 6c 65 73 61     Transaksi Selesa
    1d35:	69 00                                               i.

00001d37 <__c.4629>:
    1d37:	49 44 3a 20 25 73 00                                ID: %s.

00001d3e <__c.4627>:
    1d3e:	25 73 00                                            %s.

00001d41 <__c.4625>:
    1d41:	50 25 73 20 25 73 20 00                             P%s %s .

00001d49 <__c.4621>:
    1d49:	46 49 50 20 54 69 64 61 6b 20 53 69 61 70 20 20     FIP Tidak Siap  
    1d59:	20 20 00                                              .

00001d5c <__c.4618>:
    1d5c:	41 75 74 68 6f 72 69 73 61 73 69 20 42 65 72 68     Authorisasi Berh
    1d6c:	61 73 69 6c 00                                      asil.

00001d71 <__c.4614>:
    1d71:	41 75 74 68 6f 72 69 73 61 73 69 20 47 61 67 61     Authorisasi Gaga
    1d81:	6c 20 20 20 00                                      l   .

00001d86 <__c.4610>:
    1d86:	20 20 20 20 20 20 20 00                                    .

00001d8e <__c.4607>:
    1d8e:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1d9e:	20 20 20 20 00                                          .

00001da3 <__c.4605>:
    1da3:	4d 6f 68 6f 6e 20 54 75 6e 67 67 75 20 20 20 20     Mohon Tunggu    
    1db3:	20 20 20 20 00                                          .

00001db8 <__c.4603>:
    1db8:	25 73 00                                            %s.

00001dbb <__c.4601>:
    1dbb:	50 25 73 20 25 73 20 00                             P%s %s .

00001dc3 <__c.4598>:
    1dc3:	43 61 6e 63 65 6c 20 54 72 61 6e 73 61 63 74 69     Cancel Transacti
    1dd3:	6f 6e 20 20 00                                      on  .

00001dd8 <__c.4595>:
    1dd8:	5b 2a 5d 42 61 63 6b 20 5b 30 5d 45 53 43 20 5b     [*]Back [0]ESC [
    1de8:	23 5d 4f 4b 00                                      #]OK.

00001ded <__c.4593>:
    1ded:	25 73 20 00                                         %s .

00001df1 <__c.4591>:
    1df1:	20 46 75 6c 6c 00                                    Full.

00001df7 <__c.4589>:
    1df7:	25 73 20 20 25 73 20 00                             %s  %s .

00001dff <__c.4587>:
    1dff:	49 44 3a 20 25 73 00                                ID: %s.

00001e06 <__c.4585>:
    1e06:	25 73 20 00                                         %s .

00001e0a <__c.4581>:
    1e0a:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1e1a:	20 00                                                .

00001e1c <__c.4579>:
    1e1c:	4f 64 6f 6d 65 74 65 72 3a 5f 20 20 20 20 20 20     Odometer:_      
    1e2c:	20 00                                                .

00001e2e <__c.4577>:
    1e2e:	25 73 20 00                                         %s .

00001e32 <__c.4575>:
    1e32:	20 20 25 73 20 25 73 20 00                            %s %s .

00001e3b <__c.4573>:
    1e3b:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 41 6d 6f     Pump Product Amo
    1e4b:	75 6e 74 00                                         unt.

00001e4f <__c.4571>:
    1e4f:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 56 6f 6c     Pump Product Vol
    1e5f:	75 6d 65 00                                         ume.

00001e63 <__c.4569>:
    1e63:	20 20 54 61 6e 6b 00                                  Tank.

00001e6a <__c.4567>:
    1e6a:	20 20 25 73 20 25 73 20 00                            %s %s .

00001e73 <__c.4565>:
    1e73:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 20 20 46     Pump Product   F
    1e83:	75 6c 6c 00                                         ull.

00001e87 <__c.4562>:
    1e87:	25 73 00                                            %s.

00001e8a <__c.4559>:
    1e8a:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1e9a:	20 20 20 20 00                                          .

00001e9f <__c.4557>:
    1e9f:	5b 32 5d 41 6d 6f 75 6e 74 3a 5f 20 20 20 20 20     [2]Amount:_     
    1eaf:	20 20 20 20 00                                          .

00001eb4 <__c.4555>:
    1eb4:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1ec4:	20 20 20 20 00                                          .

00001ec9 <__c.4553>:
    1ec9:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001ed1 <__c.4551>:
    1ed1:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1ee1:	20 20 20 20 00                                          .

00001ee6 <__c.4549>:
    1ee6:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1ef6:	20 20 20 20 00                                          .

00001efb <__c.4547>:
    1efb:	5b 31 5d 56 6f 6c 75 6d 65 3a 5f 20 20 20 20 20     [1]Volume:_     
    1f0b:	20 20 20 20 00                                          .

00001f10 <__c.4545>:
    1f10:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001f18 <__c.4542>:
    1f18:	41 00                                               A.

00001f1a <__c.4540>:
    1f1a:	41 00                                               A.

00001f1c <__c.4538>:
    1f1c:	56 00                                               V.

00001f1e <__c.4535>:
    1f1e:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 4e 65     [*]Back    [#]Ne
    1f2e:	78 74 20 20 00                                      xt  .

00001f33 <__c.4533>:
    1f33:	5b 32 5d 41 6d 6f 75 6e 74 20 20 20 20 20 20 20     [2]Amount       
    1f43:	20 20 20 20 00                                          .

00001f48 <__c.4531>:
    1f48:	5b 31 5d 56 6f 6c 75 6d 65 20 20 20 20 20 20 20     [1]Volume       
    1f58:	20 20 20 20 00                                          .

00001f5d <__c.4529>:
    1f5d:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001f65 <__c.4526>:
    1f65:	25 73 00                                            %s.

00001f68 <__c.4523>:
    1f68:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1f78:	20 20 20 20 00                                          .

00001f7d <__c.4518>:
    1f7d:	20 20 20 20 20 00                                        .

00001f83 <__c.4516>:
    1f83:	25 64 2e 25 73 00                                   %d.%s.

00001f89 <__c.4514>:
    1f89:	25 73 00                                            %s.

00001f8c <__c.4512>:
    1f8c:	50 6f 6d 70 61 2d 25 73 00                          Pompa-%s.

00001f95 <__c.4509>:
    1f95:	25 2e 32 64 00                                      %.2d.

00001f9a <__c.4507>:
    1f9a:	25 2e 32 64 00                                      %.2d.

00001f9f <__c.4504>:
    1f9f:	2a 29 45 78 69 74 00                                *)Exit.

00001fa6 <__c.4502>:
    1fa6:	23 29 4f 4b 20 00                                   #)OK .

00001fac <__c.4500>:
    1fac:	20 20 20 20 20 00                                        .

00001fb2 <__c.4498>:
    1fb2:	46 49 50 3a 5f 00                                   FIP:_.

00001fb8 <__c.4493>:
    1fb8:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
    1fc8:	2e 32 64 00                                         .2d.

00001fcc <__c.4489>:
    1fcc:	5b 2a 5d 42 61 74 61 6c 20 20 20 20 20 20 20 5b     [*]Batal       [
    1fdc:	23 5d 4f 4b 00                                      #]OK.

00001fe1 <__c.4487>:
    1fe1:	25 73 20 25 73 00                                   %s %s.

00001fe7 <__c.4485>:
    1fe7:	25 73 00                                            %s.

00001fea <__c.4483>:
    1fea:	25 73 00                                            %s.

00001fed <__c.4481>:
    1fed:	25 73 00                                            %s.

00001ff0 <__c.4478>:
    1ff0:	4b 61 72 74 75 20 54 65 72 62 61 74 61 73 20 20     Kartu Terbatas  
    2000:	20 20 20 20 00                                          .

00002005 <__c.4476>:
    2005:	54 69 64 61 6b 20 54 65 72 64 61 66 74 61 72 20     Tidak Terdaftar 
    2015:	20 20 20 20 00                                          .

0000201a <__c.4473>:
    201a:	44 61 74 61 20 52 65 63 65 69 76 65 64 20 20 20     Data Received   
    202a:	20 20 20 20 00                                          .

0000202f <__c.4470>:
    202f:	54 43 50 2f 49 50 20 45 72 72 6f 72 20 20 20 20     TCP/IP Error    
    203f:	20 20 20 20 00                                          .

00002044 <__c.4468>:
    2044:	53 65 6e 64 69 6e 67 20 46 61 69 6c 65 64 20 20     Sending Failed  
    2054:	20 20 20 20 00                                          .

00002059 <__c.4465>:
    2059:	20 20 20 20 20 20 20 00                                    .

00002061 <__c.4460>:
    2061:	50 72 6f 73 65 73 00                                Proses.

00002068 <__c.4458>:
    2068:	49 44 3a 25 73 00                                   ID:%s.

0000206e <__c.4456>:
    206e:	20 20 20 4c 6f 63 61 6c 20 41 63 63 6f 75 6e 74        Local Account
    207e:	20 20 20 00                                            .

00002082 <__c.4264>:
    2082:	25 2e 32 64 00                                      %.2d.

00002087 <__c.4259>:
    2087:	45 39 34 34 35 35 31 32 00                          E9445512.

00002090 <__c.4257>:
    2090:	25 73 25 73 00                                      %s%s.

00002095 <__c.4255>:
    2095:	25 73 25 73 25 73 25 73 39 34 00                    %s%s%s%s94.

000020a0 <__c.4250>:
    20a0:	45 39 34 34 35 35 31 32 00                          E9445512.

000020a9 <__c.4248>:
    20a9:	25 73 25 73 25 73 00                                %s%s%s.

000020b0 <__c.4246>:
    20b0:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

000020b9 <__c.4244>:
    20b9:	25 73 25 73 25 73 25 73 39 32 00                    %s%s%s%s92.

000020c4 <__c.4239>:
    20c4:	45 39 34 34 35 35 31 32 00                          E9445512.

000020cd <__c.4237>:
    20cd:	25 73 25 73 00                                      %s%s.

000020d2 <__c.4235>:
    20d2:	25 73 25 73 25 73 25 73 39 30 00                    %s%s%s%s90.

000020dd <__c.4226>:
    20dd:	25 64 46 30 30 30 30 30 30 30 45 31 32 33 34 35     %dF0000000E12345
    20ed:	36 46 46 46 46 46 25 73 45 39 34 34 35 35 31 32     6FFFFF%sE9445512
	...

000020fe <__c.4224>:
    20fe:	25 73 25 73 25 64 25 73 25 73 00                    %s%s%d%s%s.

00002109 <__c.4222>:
    2109:	25 73 25 73 25 73 25 73 35 38 00                    %s%s%s%s58.

00002114 <__c.4217>:
    2114:	41 46 39 36 38 43 46 46 42 00                       AF968CFFB.

0000211e <__c.4215>:
    211e:	25 73 00                                            %s.

00002121 <__c.4213>:
    2121:	25 73 35 36 00                                      %s56.

00002126 <__c.4211>:
    2126:	25 73 25 73 25 73 00                                %s%s%s.

0000212d <__c.4206>:
    212d:	46 39 36 38 43 46 46 42 00                          F968CFFB.

00002136 <__c.4204>:
    2136:	25 73 25 73 00                                      %s%s.

0000213b <__c.4202>:
    213b:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

00002144 <__c.4200>:
    2144:	25 73 25 73 25 73 25 73 33 32 00                    %s%s%s%s32.

0000214f <__c.4195>:
    214f:	25 73 25 73 46 39 36 38 43 46 46 42 00              %s%sF968CFFB.

0000215c <__c.4193>:
    215c:	25 73 25 73 25 73 25 73 32 38 00                    %s%s%s%s28.

00002167 <__c.4188>:
    2167:	25 73 25 73 46 39 36 38 43 46 46 42 00              %s%sF968CFFB.

00002174 <__c.4186>:
    2174:	25 73 25 73 25 73 25 73 32 34 00                    %s%s%s%s24.

0000217f <__c.4181>:
    217f:	25 73 46 39 36 38 43 46 46 42 00                    %sF968CFFB.

0000218a <__c.4179>:
    218a:	25 73 25 73 25 73 25 73 32 32 00                    %s%s%s%s22.

00002195 <__c.4174>:
    2195:	25 73 25 73 25 73 25 73 31 30 46 39 36 38 43 46     %s%s%s%s10F968CF
    21a5:	46 42 00                                            FB.

000021a8 <__c.4169>:
    21a8:	25 73 25 73 25 73 25 73 30 34 25 73 31 46 39 36     %s%s%s%s04%s1F96
    21b8:	38 43 46 46 42 00                                   8CFFB.

000021be <__c.4155>:
    21be:	25 73 2e 25 73 2e 25 73 2e 25 73 00                 %s.%s.%s.%s.

000021ca <__c.4136>:
    21ca:	25 73 2e 25 73 2e 25 73 2e 25 73 00                 %s.%s.%s.%s.

000021d6 <__c.4069>:
    21d6:	25 73 20 25 73 00                                   %s %s.

000021dc <__c.4067>:
    21dc:	32 2e 33 34 00                                      2.34.

000021e1 <__c.4065>:
    21e1:	47 65 4e 69 55 73 00                                GeNiUs.

000021e8 <__c.4051>:
    21e8:	50 72 65 73 73 20 61 6e 79 20 6b 65 79 2e 2e 20     Press any key.. 
    21f8:	20 20 20 20 00                                          .

000021fd <__c.4039>:
    21fd:	5b 31 5d 53 6c 61 76 65 20 5b 32 5d 53 74 61 6e     [1]Slave [2]Stan
    220d:	64 61 6c 6f 6e 65 00                                dalone.

00002214 <__c.3960>:
    2214:	3e 00                                               >.

00002216 <__c.3955>:
    2216:	25 2e 32 64 00                                      %.2d.

0000221b <__c.3953>:
    221b:	25 2e 32 64 00                                      %.2d.

00002220 <__c.3951>:
    2220:	30 00                                               0.

00002222 <__c.3949>:
    2222:	31 00                                               1.

00002224 <__c.3941>:
    2224:	25 64 00                                            %d.

00002227 <__c.3936>:
    2227:	25 2e 32 64 00                                      %.2d.

0000222c <__c.3931>:
    222c:	25 73 00                                            %s.

0000222f <__c.3926>:
    222f:	25 73 00                                            %s.

00002232 <__c.3921>:
    2232:	25 73 00                                            %s.

00002235 <__c.3919>:
    2235:	3c 00                                               <.

00002237 <__c.3851>:
    2237:	3c 4f 4b 3e 00                                      <OK>.

0000223c <__c.3846>:
    223c:	25 64 00                                            %d.

0000223f <__c.3844>:
    223f:	25 64 00                                            %d.

00002242 <__c.3833>:
    2242:	25 64 00                                            %d.

00002245 <__c.3822>:
    2245:	3c 53 61 76 69 6e 67 3e 00                          <Saving>.

0000224e <__c.3820>:
    224e:	4c 65 6e 67 74 68 3a 25 64 00                       Length:%d.

00002258 <__c.3634>:
    2258:	25 73 00                                            %s.

0000225b <__c.3576>:
    225b:	25 73 00                                            %s.

0000225e <__c.3574>:
    225e:	25 73 00                                            %s.

00002261 <__c.3572>:
    2261:	25 73 00                                            %s.

00002264 <__c.3570>:
    2264:	25 73 00                                            %s.

00002267 <__c.3568>:
    2267:	25 2e 32 64 00                                      %.2d.

0000226c <__c.3566>:
    226c:	25 64 00                                            %d.

0000226f <__c.3564>:
    226f:	25 73 00                                            %s.

00002272 <__c.3562>:
    2272:	25 73 00                                            %s.

00002275 <__c.3560>:
    2275:	25 73 00                                            %s.

00002278 <__c.3558>:
    2278:	25 64 00                                            %d.

0000227b <__c.3556>:
    227b:	4e 2f 41 00                                         N/A.

0000227f <__c.3457>:
    227f:	25 64 00                                            %d.

00002282 <__c.3455>:
    2282:	25 73 00                                            %s.

00002285 <__c.3453>:
    2285:	25 73 00                                            %s.

00002288 <__c.3368>:
    2288:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    2298:	6b 73 69 20 00                                      ksi .

0000229d <__c.3365>:
    229d:	54 6f 74 61 6c 69 7a 65 72 41 6c 6c 20 20 20 20     TotalizerAll    
    22ad:	20 00                                                .

000022af <__c.3362>:
    22af:	43 6c 65 61 72 20 44 61 74 61 20 54 6f 74 61 6c     Clear Data Total
    22bf:	69 7a 65 72 00                                      izer.

000022c4 <__c.3350>:
    22c4:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

000022d5 <__c.3347>:
    22d5:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    22e5:	20 20 20 20 00                                          .

000022ea <__c.3344>:
    22ea:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    22fa:	20 20 20 20 00                                          .

000022ff <__c.3342>:
    22ff:	4e 6f 20 52 65 73 70 6f 6e 73 65 2e 2e 20 20 20     No Response..   
    230f:	20 20 20 20 00                                          .

00002314 <__c.3339>:
    2314:	50 6c 65 61 73 65 20 57 61 69 74 2e 2e 20 20 20     Please Wait..   
    2324:	20 20 20 20 00                                          .

00002329 <__c.3336>:
    2329:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    2339:	20 20 20 20 00                                          .

0000233e <__c.3333>:
    233e:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    234e:	6b 73 69 20 00                                      ksi .

00002353 <__c.3328>:
    2353:	53 65 64 61 6e 67 50 72 6f 73 65 73 00              SedangProses.

00002360 <__c.3325>:
    2360:	34 33 35 36 41 33 31 41 00                          4356A31A.

00002369 <__c.1750>:
    2369:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2379:	20 20 20 20 00                                          .

0000237e <__c.1748>:
    237e:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    238e:	20 20 20 20 00                                          .

00002393 <__c.1746>:
    2393:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23a3:	20 20 20 20 00                                          .

000023a8 <__c.1744>:
    23a8:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23b8:	20 20 20 20 00                                          .

000023bd <__alphanum>:
    23bd:	30 20 2e 00 00 00 31 2e 2c 3f 21 00 32 61 62 63     0 ....1.,?!.2abc
    23cd:	00 00 33 64 65 66 00 00 34 67 68 69 00 00 35 6a     ..3def..4ghi..5j
    23dd:	6b 6c 00 00 36 6d 6e 6f 00 00 37 70 71 72 73 00     kl..6mno..7pqrs.
    23ed:	38 74 75 76 00 00 39 77 78 79 7a 00 30 20 2e 00     8tuv..9wxyz.0 ..
    23fd:	00 00 31 26 40 2b 2d 00 32 41 42 43 00 00 33 44     ..1&@+-.2ABC..3D
    240d:	45 46 00 00 34 47 48 49 00 00 35 4a 4b 4c 00 00     EF..4GHI..5JKL..
    241d:	36 4d 4e 4f 00 00 37 50 51 52 53 00 38 54 55 56     6MNO..7PQRS.8TUV
    242d:	00 00 39 57 58 59 5a 00                             ..9WXYZ.

00002435 <__maxchar>:
    2435:	02 04 03 03 03 03 03 04 03 04 00                    ...........

00002440 <__ctors_end>:
    2440:	11 24       	eor	r1, r1
    2442:	1f be       	out	0x3f, r1	; 63
    2444:	cf ef       	ldi	r28, 0xFF	; 255
    2446:	d0 e1       	ldi	r29, 0x10	; 16
    2448:	de bf       	out	0x3e, r29	; 62
    244a:	cd bf       	out	0x3d, r28	; 61

0000244c <__do_copy_data>:
    244c:	11 e0       	ldi	r17, 0x01	; 1
    244e:	a0 e0       	ldi	r26, 0x00	; 0
    2450:	b1 e0       	ldi	r27, 0x01	; 1
    2452:	ee e1       	ldi	r30, 0x1E	; 30
    2454:	ff e6       	ldi	r31, 0x6F	; 111
    2456:	01 e0       	ldi	r16, 0x01	; 1
    2458:	0b bf       	out	0x3b, r16	; 59
    245a:	02 c0       	rjmp	.+4      	; 0x2460 <__do_copy_data+0x14>
    245c:	07 90       	elpm	r0, Z+
    245e:	0d 92       	st	X+, r0
    2460:	ae 35       	cpi	r26, 0x5E	; 94
    2462:	b1 07       	cpc	r27, r17
    2464:	d9 f7       	brne	.-10     	; 0x245c <__do_copy_data+0x10>

00002466 <__do_clear_bss>:
    2466:	1e e0       	ldi	r17, 0x0E	; 14
    2468:	ae e5       	ldi	r26, 0x5E	; 94
    246a:	b1 e0       	ldi	r27, 0x01	; 1
    246c:	01 c0       	rjmp	.+2      	; 0x2470 <.do_clear_bss_start>

0000246e <.do_clear_bss_loop>:
    246e:	1d 92       	st	X+, r1

00002470 <.do_clear_bss_start>:
    2470:	af 3d       	cpi	r26, 0xDF	; 223
    2472:	b1 07       	cpc	r27, r17
    2474:	e1 f7       	brne	.-8      	; 0x246e <.do_clear_bss_loop>
    2476:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <main>
    247a:	0c 94 8d b7 	jmp	0x16f1a	; 0x16f1a <_exit>

0000247e <__bad_interrupt>:
    247e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00002482 <systemOnReset>:
	};
}


void systemOnReset(){
     IsPowerOn=False;
    2482:	10 92 9a 04 	sts	0x049A, r1
     if (MCUCSR & 1){   // Power-on Reset
    2486:	04 b6       	in	r0, 0x34	; 52
    2488:	00 fe       	sbrs	r0, 0
    248a:	0b c0       	rjmp	.+22     	; 0x24a2 <systemOnReset+0x20>
         MCUCSR=0;lcd_printf(1,1,PSTR("PowerOn"));//Wiznet Blm Ready
    248c:	14 be       	out	0x34, r1	; 52
    248e:	81 e0       	ldi	r24, 0x01	; 1
    2490:	61 e0       	ldi	r22, 0x01	; 1
    2492:	4c ec       	ldi	r20, 0xCC	; 204
    2494:	52 e0       	ldi	r21, 0x02	; 2
    2496:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		 IsPowerOn=True;
    249a:	81 e0       	ldi	r24, 0x01	; 1
    249c:	80 93 9a 04 	sts	0x049A, r24
    24a0:	18 c0       	rjmp	.+48     	; 0x24d2 <systemOnReset+0x50>
         }
     else 
     if (MCUCSR & 2){   // External Reset
    24a2:	04 b6       	in	r0, 0x34	; 52
    24a4:	01 fe       	sbrs	r0, 1
    24a6:	06 c0       	rjmp	.+12     	; 0x24b4 <systemOnReset+0x32>
         MCUCSR=0;lcd_printf(1,1,PSTR("External"));
    24a8:	14 be       	out	0x34, r1	; 52
    24aa:	81 e0       	ldi	r24, 0x01	; 1
    24ac:	61 e0       	ldi	r22, 0x01	; 1
    24ae:	43 ec       	ldi	r20, 0xC3	; 195
    24b0:	52 e0       	ldi	r21, 0x02	; 2
    24b2:	0d c0       	rjmp	.+26     	; 0x24ce <systemOnReset+0x4c>
        }
     else 
     if (MCUCSR & 4){   // Brown-Out Reset
    24b4:	04 b6       	in	r0, 0x34	; 52
    24b6:	02 fe       	sbrs	r0, 2
    24b8:	06 c0       	rjmp	.+12     	; 0x24c6 <systemOnReset+0x44>
         MCUCSR=0;lcd_printf(1,1,PSTR("BrownOut"));
    24ba:	14 be       	out	0x34, r1	; 52
    24bc:	81 e0       	ldi	r24, 0x01	; 1
    24be:	61 e0       	ldi	r22, 0x01	; 1
    24c0:	4a eb       	ldi	r20, 0xBA	; 186
    24c2:	52 e0       	ldi	r21, 0x02	; 2
    24c4:	04 c0       	rjmp	.+8      	; 0x24ce <systemOnReset+0x4c>
         }
     else		  // Watchdog Reset
        {
         lcd_printf(1,1,PSTR("WatchDog"));
    24c6:	81 e0       	ldi	r24, 0x01	; 1
    24c8:	61 e0       	ldi	r22, 0x01	; 1
    24ca:	41 eb       	ldi	r20, 0xB1	; 177
    24cc:	52 e0       	ldi	r21, 0x02	; 2
    24ce:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
        };
     MCUCSR=0;		  
    24d2:	14 be       	out	0x34, r1	; 52
    24d4:	80 ee       	ldi	r24, 0xE0	; 224
    24d6:	9e e2       	ldi	r25, 0x2E	; 46
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    24d8:	20 e7       	ldi	r18, 0x70	; 112
    24da:	31 e0       	ldi	r19, 0x01	; 1
    24dc:	f9 01       	movw	r30, r18
    24de:	31 97       	sbiw	r30, 0x01	; 1
    24e0:	f1 f7       	brne	.-4      	; 0x24de <systemOnReset+0x5c>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    24e2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    24e4:	d9 f7       	brne	.-10     	; 0x24dc <systemOnReset+0x5a>
	 _delay_ms(1200);
}
    24e6:	08 95       	ret

000024e8 <SystemInit>:


void SystemInit(){
	unsigned int __delay =300;
	lcd_init();
    24e8:	0e 94 5c ac 	call	0x158b8	; 0x158b8 <lcd_init>
	lcd_clear();
    24ec:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
	BackLightTrig();
    24f0:	0e 94 e9 15 	call	0x2bd2	; 0x2bd2 <BackLightTrig>
	systemOnReset();
    24f4:	0e 94 41 12 	call	0x2482	; 0x2482 <systemOnReset>

	lcd_printf(4, 1, PSTR("Initialize... "));
    24f8:	84 e0       	ldi	r24, 0x04	; 4
    24fa:	61 e0       	ldi	r22, 0x01	; 1
    24fc:	42 ea       	ldi	r20, 0xA2	; 162
    24fe:	52 e0       	ldi	r21, 0x02	; 2
    2500:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
    2504:	88 eb       	ldi	r24, 0xB8	; 184
    2506:	9b e0       	ldi	r25, 0x0B	; 11
    2508:	20 e7       	ldi	r18, 0x70	; 112
    250a:	31 e0       	ldi	r19, 0x01	; 1
    250c:	f9 01       	movw	r30, r18
    250e:	31 97       	sbiw	r30, 0x01	; 1
    2510:	f1 f7       	brne	.-4      	; 0x250e <SystemInit+0x26>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2512:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2514:	d9 f7       	brne	.-10     	; 0x250c <SystemInit+0x24>
	_delay_ms(__delay);
	PORTA = 0XFF;		// Buffer for PORTA
    2516:	9f ef       	ldi	r25, 0xFF	; 255
    2518:	9b bb       	out	0x1b, r25	; 27
	DDRA = 0xFF;		// Pin 3 out (SS _SPI_SLAVE)
    251a:	9a bb       	out	0x1a, r25	; 26
	sbi(PORTA, 3);		// Disable SS _SPI_SLAVE
    251c:	db 9a       	sbi	0x1b, 3	; 27

	//Buzzer PORTB.5
	PORTB = 0xFF;DDRB = 0xFF;
    251e:	98 bb       	out	0x18, r25	; 24
    2520:	97 bb       	out	0x17, r25	; 23
	PORTD = 0b00001101;
    2522:	8d e0       	ldi	r24, 0x0D	; 13
    2524:	82 bb       	out	0x12, r24	; 18
    DDRD =  0b00001001;
    2526:	89 e0       	ldi	r24, 0x09	; 9
    2528:	81 bb       	out	0x11, r24	; 17

	TWBR = 0xFF;
    252a:	90 93 70 00 	sts	0x0070, r25
    //MMC
	PORTE = 0x0E;		// Buffer for PORTE
    252e:	8e e0       	ldi	r24, 0x0E	; 14
    2530:	83 b9       	out	0x03, r24	; 3
	DDRE = 0x0E;		// Pin 3 out (SS _SPI_MMC), pin 2 out (HB)
    2532:	82 b9       	out	0x02, r24	; 2
	sbi(PORTE, 3);		// Disable SS _SPI_MMC
    2534:	1b 9a       	sbi	0x03, 3	; 3
	cbi(PORTE, 2);		// HB on
    2536:	1a 98       	cbi	0x03, 2	; 3

	//Keypad
	PORTF = 0xFF;		// Buffer for PORTF
    2538:	90 93 62 00 	sts	0x0062, r25
	DDRF = 0xF0;		// 4 bit row, 4 bit column
    253c:	80 ef       	ldi	r24, 0xF0	; 240
    253e:	80 93 61 00 	sts	0x0061, r24

  	_spi_init(0,1);//Slave
    2542:	80 e0       	ldi	r24, 0x00	; 0
    2544:	61 e0       	ldi	r22, 0x01	; 1
    2546:	0e 94 54 af 	call	0x15ea8	; 0x15ea8 <_spi_init>
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    254a:	bb 9a       	sbi	0x17, 3	; 23
    254c:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    254e:	ba 98       	cbi	0x17, 2	; 23
    2550:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    2552:	b9 98       	cbi	0x17, 1	; 23
    2554:	c1 9a       	sbi	0x18, 1	; 24

	TCCR1B |= (1 << WGM12);
    2556:	8e b5       	in	r24, 0x2e	; 46
    2558:	88 60       	ori	r24, 0x08	; 8
    255a:	8e bd       	out	0x2e, r24	; 46
	TIMSK |= (1 << OCIE1A);
    255c:	87 b7       	in	r24, 0x37	; 55
    255e:	80 61       	ori	r24, 0x10	; 16
    2560:	87 bf       	out	0x37, r24	; 55
	sei();          //1/14745600=0,06781684028uS *1400 = 100uS 65535-1400+1=64136
    2562:	78 94       	sei
	OCR1A   = 15624;//49911 -->0,33847384982639 ms
    2564:	88 e0       	ldi	r24, 0x08	; 8
    2566:	9d e3       	ldi	r25, 0x3D	; 61
    2568:	9b bd       	out	0x2b, r25	; 43
    256a:	8a bd       	out	0x2a, r24	; 42
	TCCR1B |= ((1 << CS10) | (1 << CS11));
    256c:	8e b5       	in	r24, 0x2e	; 46
    256e:	83 60       	ori	r24, 0x03	; 3
    2570:	8e bd       	out	0x2e, r24	; 46

	SendSlaveCommand(SC_SLAVE,ST_NONE);
    2572:	81 e0       	ldi	r24, 0x01	; 1
    2574:	60 e0       	ldi	r22, 0x00	; 0
    2576:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
	
	InitComport();
    257a:	0e 94 50 9a 	call	0x134a0	; 0x134a0 <InitComport>
	_LIGHT_SET;
    257e:	81 e0       	ldi	r24, 0x01	; 1
    2580:	80 93 bf 03 	sts	0x03BF, r24
    2584:	10 92 c0 03 	sts	0x03C0, r1
    2588:	80 91 65 00 	lds	r24, 0x0065
    258c:	8d 7f       	andi	r24, 0xFD	; 253
    258e:	80 93 65 00 	sts	0x0065, r24
	InitPrinter();
    2592:	0e 94 ac 4b 	call	0x9758	; 0x9758 <InitPrinter>
    InitializeConnection();
    2596:	0e 94 5f 76 	call	0xecbe	; 0xecbe <InitializeConnection>
	lcd_clear(); 
    259a:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
}
    259e:	08 95       	ret

000025a0 <main>:
void SystemInit();
//void TestUserInput();

//Program Utama
int main(){
	SystemInit();
    25a0:	0e 94 74 12 	call	0x24e8	; 0x24e8 <SystemInit>
	while(1){
	//FTestChar();
	//TestUserInput();
    FMenuIdle();
    25a4:	0e 94 fa a9 	call	0x153f4	; 0x153f4 <FMenuIdle>
    25a8:	fd cf       	rjmp	.-6      	; 0x25a4 <main+0x4>

000025aa <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    25aa:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    25ac:	e1 99       	sbic	0x1c, 1	; 28
    25ae:	fe cf       	rjmp	.-4      	; 0x25ac <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    25b0:	3f bb       	out	0x1f, r19	; 31
    25b2:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    25b4:	e0 9a       	sbi	0x1c, 0	; 28
    25b6:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    25b8:	08 95       	ret

000025ba <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    25ba:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    25bc:	e1 99       	sbic	0x1c, 1	; 28
    25be:	fe cf       	rjmp	.-4      	; 0x25bc <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    25c0:	3f bb       	out	0x1f, r19	; 31
    25c2:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    25c4:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    25c6:	0f b6       	in	r0, 0x3f	; 63
    25c8:	f8 94       	cli
    25ca:	e2 9a       	sbi	0x1c, 2	; 28
    25cc:	e1 9a       	sbi	0x1c, 1	; 28
    25ce:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    25d0:	08 95       	ret

000025d2 <__vector_12>:
	  strDispenserName3,
	  strDispenserName4,
	  strDispenserName5,
};

ISR(TIMER1_COMPA_vect){//Timer Overflow 1ms
    25d2:	1f 92       	push	r1
    25d4:	0f 92       	push	r0
    25d6:	0f b6       	in	r0, 0x3f	; 63
    25d8:	0f 92       	push	r0
    25da:	11 24       	eor	r1, r1
    25dc:	2f 93       	push	r18
    25de:	6f 93       	push	r22
    25e0:	7f 93       	push	r23
    25e2:	8f 93       	push	r24
    25e4:	9f 93       	push	r25
		   __sec_sign = 1;
		 }
	}
*/
	//_light_ticker();
	if(__key_light == 1){
    25e6:	80 91 bf 03 	lds	r24, 0x03BF
    25ea:	81 30       	cpi	r24, 0x01	; 1
    25ec:	81 f4       	brne	.+32     	; 0x260e <__vector_12+0x3c>
		__key_lgtcnt++;
    25ee:	80 91 c0 03 	lds	r24, 0x03C0
    25f2:	8f 5f       	subi	r24, 0xFF	; 255
    25f4:	80 93 c0 03 	sts	0x03C0, r24
		if(__key_lgtcnt == 150){
    25f8:	86 39       	cpi	r24, 0x96	; 150
    25fa:	49 f4       	brne	.+18     	; 0x260e <__vector_12+0x3c>
		   __key_light = 0; 
    25fc:	10 92 bf 03 	sts	0x03BF, r1
		   __key_lgtcnt = 0; 
    2600:	10 92 c0 03 	sts	0x03C0, r1
		   sbi(PORTG, 1);
    2604:	80 91 65 00 	lds	r24, 0x0065
    2608:	82 60       	ori	r24, 0x02	; 2
    260a:	80 93 65 00 	sts	0x0065, r24
		   }
	}
	

	__i_timer++;
    260e:	80 91 bd 03 	lds	r24, 0x03BD
    2612:	8f 5f       	subi	r24, 0xFF	; 255
    2614:	80 93 bd 03 	sts	0x03BD, r24
	if (__i_timer > 5){
    2618:	86 30       	cpi	r24, 0x06	; 6
    261a:	30 f0       	brcs	.+12     	; 0x2628 <__vector_12+0x56>
		__i_timer = 0;
    261c:	10 92 bd 03 	sts	0x03BD, r1
		PORTE = PORTE^0x04;
    2620:	83 b1       	in	r24, 0x03	; 3
    2622:	94 e0       	ldi	r25, 0x04	; 4
    2624:	89 27       	eor	r24, r25
    2626:	83 b9       	out	0x03, r24	; 3
	}
	//Beep
	if (TimBeep>0){
    2628:	80 91 d6 01 	lds	r24, 0x01D6
    262c:	90 91 d7 01 	lds	r25, 0x01D7
    2630:	00 97       	sbiw	r24, 0x00	; 0
    2632:	41 f0       	breq	.+16     	; 0x2644 <__vector_12+0x72>
	    TimBeep--;
    2634:	01 97       	sbiw	r24, 0x01	; 1
    2636:	90 93 d7 01 	sts	0x01D7, r25
    263a:	80 93 d6 01 	sts	0x01D6, r24
		DDRB=(DDRB|0b00100000);
    263e:	bd 9a       	sbi	0x17, 5	; 23
	    PORTB=(PORTB&0b11011111);
    2640:	c5 98       	cbi	0x18, 5	; 24
    2642:	05 c0       	rjmp	.+10     	; 0x264e <__vector_12+0x7c>
	    }
	else{PORTB=(PORTB|~PORTB);
    2644:	98 b3       	in	r25, 0x18	; 24
    2646:	88 b3       	in	r24, 0x18	; 24
    2648:	80 95       	com	r24
    264a:	89 2b       	or	r24, r25
    264c:	88 bb       	out	0x18, r24	; 24
		}
    //LocalAccount
	TimLocAcc++;
    264e:	80 91 d2 01 	lds	r24, 0x01D2
    2652:	90 91 d3 01 	lds	r25, 0x01D3
    2656:	01 96       	adiw	r24, 0x01	; 1
    2658:	90 93 d3 01 	sts	0x01D3, r25
    265c:	80 93 d2 01 	sts	0x01D2, r24
	//DisplaTicker
    TimTicker++;
    2660:	80 91 a5 01 	lds	r24, 0x01A5
    2664:	8f 5f       	subi	r24, 0xFF	; 255
    2666:	80 93 a5 01 	sts	0x01A5, r24
	TimPressed++;
    266a:	20 91 a6 01 	lds	r18, 0x01A6
    266e:	2f 5f       	subi	r18, 0xFF	; 255
    2670:	20 93 a6 01 	sts	0x01A6, r18
	if ((TimPressed%5)==0){
    2674:	82 2f       	mov	r24, r18
    2676:	65 e0       	ldi	r22, 0x05	; 5
    2678:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    267c:	99 23       	and	r25, r25
    267e:	71 f4       	brne	.+28     	; 0x269c <__vector_12+0xca>
	    TimDisplay++;
    2680:	80 91 a7 01 	lds	r24, 0x01A7
    2684:	8f 5f       	subi	r24, 0xFF	; 255
    2686:	80 93 a7 01 	sts	0x01A7, r24
		TimPrintBusy++;
    268a:	80 91 cc 01 	lds	r24, 0x01CC
    268e:	90 91 cd 01 	lds	r25, 0x01CD
    2692:	01 96       	adiw	r24, 0x01	; 1
    2694:	90 93 cd 01 	sts	0x01CD, r25
    2698:	80 93 cc 01 	sts	0x01CC, r24
		//FBackLight();
	}
	if ((TimPressed%PRESSED_DELAY)==0){
    269c:	82 2f       	mov	r24, r18
    269e:	6a e0       	ldi	r22, 0x0A	; 10
    26a0:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    26a4:	99 23       	and	r25, r25
    26a6:	49 f4       	brne	.+18     	; 0x26ba <__vector_12+0xe8>
	     ProcTimeOut++;
    26a8:	80 91 d8 01 	lds	r24, 0x01D8
    26ac:	90 91 d9 01 	lds	r25, 0x01D9
    26b0:	01 96       	adiw	r24, 0x01	; 1
    26b2:	90 93 d9 01 	sts	0x01D9, r25
    26b6:	80 93 d8 01 	sts	0x01D8, r24
	}
	TimSend++;
    26ba:	80 91 a8 01 	lds	r24, 0x01A8
    26be:	90 91 a9 01 	lds	r25, 0x01A9
    26c2:	01 96       	adiw	r24, 0x01	; 1
    26c4:	90 93 a9 01 	sts	0x01A9, r25
    26c8:	80 93 a8 01 	sts	0x01A8, r24
}
    26cc:	9f 91       	pop	r25
    26ce:	8f 91       	pop	r24
    26d0:	7f 91       	pop	r23
    26d2:	6f 91       	pop	r22
    26d4:	2f 91       	pop	r18
    26d6:	0f 90       	pop	r0
    26d8:	0f be       	out	0x3f, r0	; 63
    26da:	0f 90       	pop	r0
    26dc:	1f 90       	pop	r1
    26de:	18 95       	reti

000026e0 <RePrintStandalone>:

char RePrintStandalone(char FIPAddr){
     char Result=PS_NONE;

   return Result;
}
    26e0:	86 e1       	ldi	r24, 0x16	; 22
    26e2:	08 95       	ret

000026e4 <GetPumpStatusLabel>:


char GetPumpStatusLabel(char xPumpStatus){
     char Result;

	 switch(xPumpStatus){
    26e4:	e8 2f       	mov	r30, r24
    26e6:	f0 e0       	ldi	r31, 0x00	; 0
    26e8:	ee 31       	cpi	r30, 0x1E	; 30
    26ea:	f1 05       	cpc	r31, r1
    26ec:	70 f5       	brcc	.+92     	; 0x274a <GetPumpStatusLabel+0x66>
    26ee:	ea 5b       	subi	r30, 0xBA	; 186
    26f0:	ff 4f       	sbci	r31, 0xFF	; 255
    26f2:	ee 0f       	add	r30, r30
    26f4:	ff 1f       	adc	r31, r31
    26f6:	05 90       	lpm	r0, Z+
    26f8:	f4 91       	lpm	r31, Z+
    26fa:	e0 2d       	mov	r30, r0
    26fc:	09 94       	ijmp
    26fe:	81 e3       	ldi	r24, 0x31	; 49
    2700:	08 95       	ret
    2702:	85 e4       	ldi	r24, 0x45	; 69
    2704:	08 95       	ret
    2706:	82 e3       	ldi	r24, 0x32	; 50
    2708:	08 95       	ret
	 case PUMP_ST1: 
	      Result='1';
		  break;
	 case PUMP_ST2: 
	 	  Result='2';
		  break;
    270a:	83 e3       	ldi	r24, 0x33	; 51
    270c:	08 95       	ret
     case PUMP_ST3:
	 	  Result='3';
		  break;	
    270e:	84 e3       	ldi	r24, 0x34	; 52
    2710:	08 95       	ret
	 case PUMP_ST4: 
          Result='4';
		  break;
    2712:	85 e3       	ldi	r24, 0x35	; 53
    2714:	08 95       	ret
	 case PUMP_ST5: 
	 	  Result='5';
		  break;
    2716:	89 e6       	ldi	r24, 0x69	; 105
    2718:	08 95       	ret
	 case PUMP_OFF: 
	 case PW_ONLINE:
	 	  Result='i';
		  break;
    271a:	8e e6       	ldi	r24, 0x6E	; 110
    271c:	08 95       	ret
     case PW_CALL:
	 case PUMP_CALL: 
	 	  Result='n';
		  break;     
    271e:	81 e6       	ldi	r24, 0x61	; 97
    2720:	08 95       	ret
	 case PUMP_AUTH: 
	 	  Result='a';
		  break;
    2722:	84 e6       	ldi	r24, 0x64	; 100
    2724:	08 95       	ret
     case PW_AUTHORIZED:
	 case PUMP_BUSY: 
	 	  Result='d';
		  break;
    2726:	8f e4       	ldi	r24, 0x4F	; 79
    2728:	08 95       	ret
	 case PUMP_PEOT: 
	 	  Result='O';
		  break;
    272a:	86 e4       	ldi	r24, 0x46	; 70
    272c:	08 95       	ret
     case PW_END_DELIVERY:
	 case PUMP_FEOT: 
	 	  Result='F';
		  break;
    272e:	83 e5       	ldi	r24, 0x53	; 83
    2730:	08 95       	ret
	 case PUMP_STOP: 
	 	  Result='S';
		  break;
    2732:	8d e2       	ldi	r24, 0x2D	; 45
    2734:	08 95       	ret
	 case PUMP_NONE:
	 case PW_DISCONNECT:
	 	  Result='-';
		  break;
    2736:	80 e5       	ldi	r24, 0x50	; 80
    2738:	08 95       	ret
     case PS_PRINT_READY:
	      Result='P';
 	      break;
    273a:	89 e4       	ldi	r24, 0x49	; 73
    273c:	08 95       	ret
     case PS_PRINTED:
	      Result='I';
 	      break;
    273e:	86 e5       	ldi	r24, 0x56	; 86
    2740:	08 95       	ret
     case PS_VOID:
	      Result='V';
	      break;
    2742:	84 e5       	ldi	r24, 0x54	; 84
    2744:	08 95       	ret
     case PS_TOTALIZER:
	      Result='T';
	      break;
    2746:	84 e7       	ldi	r24, 0x74	; 116
    2748:	08 95       	ret
     case PS_FINISH_TOTALIZER:
	      Result='t';
	      break;
    274a:	88 e7       	ldi	r24, 0x78	; 120
	 default:
          Result='x';
		  break;         	 
	 }
  return Result;	 
}
    274c:	08 95       	ret

0000274e <SendPoolingCommand>:
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    274e:	80 93 da 07 	sts	0x07DA, r24
	 PoolMsg=plMsg;
    2752:	60 93 fe 0d 	sts	0x0DFE, r22
     IsControlPooling=True;
    2756:	81 e0       	ldi	r24, 0x01	; 1
    2758:	80 93 97 01 	sts	0x0197, r24
}
    275c:	08 95       	ret

0000275e <ScanEDCFlow>:
	 RemZeroLead(strMsgID);
	 Result=atoi(strMsgID);
  return Result;
}

void ScanEDCFlow(char data){
    275e:	28 2f       	mov	r18, r24
static char IsEDCFlow=False,EDCMsgCode=0;
static unsigned int nFlow=0;
     char i;
     //EDC-MSG
     if (data==0x02){
    2760:	82 30       	cpi	r24, 0x02	; 2
    2762:	39 f4       	brne	.+14     	; 0x2772 <ScanEDCFlow+0x14>
	     IsEDCFlow=True;
    2764:	81 e0       	ldi	r24, 0x01	; 1
    2766:	80 93 b1 03 	sts	0x03B1, r24
		 nFlow=0;
    276a:	10 92 af 03 	sts	0x03AF, r1
    276e:	10 92 ae 03 	sts	0x03AE, r1
	 }//FillMessage
     if (IsEDCFlow==True){
    2772:	80 91 b1 03 	lds	r24, 0x03B1
    2776:	81 30       	cpi	r24, 0x01	; 1
    2778:	69 f4       	brne	.+26     	; 0x2794 <ScanEDCFlow+0x36>
	     rcv_trans[nFlow]=data;
    277a:	80 91 ae 03 	lds	r24, 0x03AE
    277e:	90 91 af 03 	lds	r25, 0x03AF
    2782:	fc 01       	movw	r30, r24
    2784:	eb 5b       	subi	r30, 0xBB	; 187
    2786:	f4 4f       	sbci	r31, 0xF4	; 244
    2788:	20 83       	st	Z, r18
		 nFlow++;
    278a:	01 96       	adiw	r24, 0x01	; 1
    278c:	90 93 af 03 	sts	0x03AF, r25
    2790:	80 93 ae 03 	sts	0x03AE, r24
	 }//CloseMessage
	 if ((data==0x03)||(nFlow>=MSG03_LENGTH)){
    2794:	23 30       	cpi	r18, 0x03	; 3
    2796:	41 f0       	breq	.+16     	; 0x27a8 <ScanEDCFlow+0x4a>
    2798:	80 91 ae 03 	lds	r24, 0x03AE
    279c:	90 91 af 03 	lds	r25, 0x03AF
    27a0:	8d 34       	cpi	r24, 0x4D	; 77
    27a2:	91 05       	cpc	r25, r1
    27a4:	08 f4       	brcc	.+2      	; 0x27a8 <ScanEDCFlow+0x4a>
    27a6:	9b c0       	rjmp	.+310    	; 0x28de <ScanEDCFlow+0x180>
	     //for(i=0;i<nFlow;i++){_uart(0,1,rcv_trans[i]);}
	     IsEDCFlow=False;
    27a8:	10 92 b1 03 	sts	0x03B1, r1
		 EDCMsgCode=((rcv_trans[1]-'0')*10)+(rcv_trans[2]-'0');
    27ac:	30 91 47 0b 	lds	r19, 0x0B47
    27b0:	30 51       	subi	r19, 0x10	; 16
    27b2:	80 91 46 0b 	lds	r24, 0x0B46
    27b6:	2a e0       	ldi	r18, 0x0A	; 10
    27b8:	82 9f       	mul	r24, r18
    27ba:	c0 01       	movw	r24, r0
    27bc:	11 24       	eor	r1, r1
    27be:	38 0f       	add	r19, r24
    27c0:	30 93 b0 03 	sts	0x03B0, r19

		 if (EDCMsgCode==0x03){
    27c4:	33 30       	cpi	r19, 0x03	; 3
    27c6:	09 f0       	breq	.+2      	; 0x27ca <ScanEDCFlow+0x6c>
    27c8:	65 c0       	rjmp	.+202    	; 0x2894 <ScanEDCFlow+0x136>
    27ca:	e8 e4       	ldi	r30, 0x48	; 72
    27cc:	fb e0       	ldi	r31, 0x0B	; 11
    27ce:	a1 eb       	ldi	r26, 0xB1	; 177
    27d0:	be e0       	ldi	r27, 0x0E	; 14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    27d2:	81 91       	ld	r24, Z+
    27d4:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    27d6:	8b e0       	ldi	r24, 0x0B	; 11
    27d8:	ee 34       	cpi	r30, 0x4E	; 78
    27da:	f8 07       	cpc	r31, r24
    27dc:	d1 f7       	brne	.-12     	; 0x27d2 <ScanEDCFlow+0x74>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    27de:	10 92 b7 0e 	sts	0x0EB7, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    27e2:	80 81       	ld	r24, Z
    27e4:	80 93 ec 09 	sts	0x09EC, r24
    27e8:	81 81       	ldd	r24, Z+1	; 0x01
    27ea:	80 93 ed 09 	sts	0x09ED, r24
	 }Dest[Length]=0;
    27ee:	10 92 ee 09 	sts	0x09EE, r1
    27f2:	32 96       	adiw	r30, 0x02	; 2
    27f4:	ad ec       	ldi	r26, 0xCD	; 205
    27f6:	be e0       	ldi	r27, 0x0E	; 14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    27f8:	81 91       	ld	r24, Z+
    27fa:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    27fc:	8b e0       	ldi	r24, 0x0B	; 11
    27fe:	ef 35       	cpi	r30, 0x5F	; 95
    2800:	f8 07       	cpc	r31, r24
    2802:	d1 f7       	brne	.-12     	; 0x27f8 <ScanEDCFlow+0x9a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2804:	10 92 dc 0e 	sts	0x0EDC, r1
    2808:	a1 eb       	ldi	r26, 0xB1	; 177
    280a:	bd e0       	ldi	r27, 0x0D	; 13
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    280c:	81 91       	ld	r24, Z+
    280e:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2810:	8b e0       	ldi	r24, 0x0B	; 11
    2812:	e2 37       	cpi	r30, 0x72	; 114
    2814:	f8 07       	cpc	r31, r24
    2816:	d1 f7       	brne	.-12     	; 0x280c <ScanEDCFlow+0xae>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2818:	10 92 c4 0d 	sts	0x0DC4, r1
    281c:	20 e0       	ldi	r18, 0x00	; 0
    281e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2820:	f9 01       	movw	r30, r18
    2822:	ec 5c       	subi	r30, 0xCC	; 204
    2824:	f5 4f       	sbci	r31, 0xF5	; 245
    2826:	d9 01       	movw	r26, r18
    2828:	ab 5b       	subi	r26, 0xBB	; 187
    282a:	b4 4f       	sbci	r27, 0xF4	; 244
    282c:	9d 96       	adiw	r26, 0x2d	; 45
    282e:	8c 91       	ld	r24, X
    2830:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2832:	2f 5f       	subi	r18, 0xFF	; 255
    2834:	3f 4f       	sbci	r19, 0xFF	; 255
    2836:	26 30       	cpi	r18, 0x06	; 6
    2838:	31 05       	cpc	r19, r1
    283a:	91 f7       	brne	.-28     	; 0x2820 <ScanEDCFlow+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    283c:	10 92 3a 0a 	sts	0x0A3A, r1
    2840:	20 e0       	ldi	r18, 0x00	; 0
    2842:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2844:	f9 01       	movw	r30, r18
    2846:	ea 57       	subi	r30, 0x7A	; 122
    2848:	f6 4f       	sbci	r31, 0xF6	; 246
    284a:	d9 01       	movw	r26, r18
    284c:	ab 5b       	subi	r26, 0xBB	; 187
    284e:	b4 4f       	sbci	r27, 0xF4	; 244
    2850:	d3 96       	adiw	r26, 0x33	; 51
    2852:	8c 91       	ld	r24, X
    2854:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2856:	2f 5f       	subi	r18, 0xFF	; 255
    2858:	3f 4f       	sbci	r19, 0xFF	; 255
    285a:	2a 30       	cpi	r18, 0x0A	; 10
    285c:	31 05       	cpc	r19, r1
    285e:	91 f7       	brne	.-28     	; 0x2844 <ScanEDCFlow+0xe6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2860:	10 92 90 09 	sts	0x0990, r1
    2864:	20 e0       	ldi	r18, 0x00	; 0
    2866:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2868:	f9 01       	movw	r30, r18
    286a:	e9 51       	subi	r30, 0x19	; 25
    286c:	f2 4f       	sbci	r31, 0xF2	; 242
    286e:	d9 01       	movw	r26, r18
    2870:	ab 5b       	subi	r26, 0xBB	; 187
    2872:	b4 4f       	sbci	r27, 0xF4	; 244
    2874:	dd 96       	adiw	r26, 0x3d	; 61
    2876:	8c 91       	ld	r24, X
    2878:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    287a:	2f 5f       	subi	r18, 0xFF	; 255
    287c:	3f 4f       	sbci	r19, 0xFF	; 255
    287e:	2e 30       	cpi	r18, 0x0E	; 14
    2880:	31 05       	cpc	r19, r1
    2882:	91 f7       	brne	.-28     	; 0x2868 <ScanEDCFlow+0x10a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2884:	10 92 f5 0d 	sts	0x0DF5, r1
             StrPosCopy(rcv_trans,strCardType,11,15);
             StrPosCopy(rcv_trans,strCardID,26,19);
             StrPosCopy(rcv_trans,strApprovalCode,45,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,51,10);
             StrPosCopy(rcv_trans,strDateTime,61,14);
		     IsEDCApproved=True;//Sending Message 92
    2888:	81 e0       	ldi	r24, 0x01	; 1
    288a:	80 93 b0 01 	sts	0x01B0, r24
			 IsPrintApprovalCode=True;
    288e:	80 93 b1 01 	sts	0x01B1, r24
    2892:	08 95       	ret
	    }else
		 if (EDCMsgCode==0x04){
    2894:	34 30       	cpi	r19, 0x04	; 4
    2896:	19 f5       	brne	.+70     	; 0x28de <ScanEDCFlow+0x180>
    2898:	e8 e4       	ldi	r30, 0x48	; 72
    289a:	fb e0       	ldi	r31, 0x0B	; 11
    289c:	a4 e3       	ldi	r26, 0x34	; 52
    289e:	ba e0       	ldi	r27, 0x0A	; 10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28a0:	81 91       	ld	r24, Z+
    28a2:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28a4:	8b e0       	ldi	r24, 0x0B	; 11
    28a6:	ee 34       	cpi	r30, 0x4E	; 78
    28a8:	f8 07       	cpc	r31, r24
    28aa:	d1 f7       	brne	.-12     	; 0x28a0 <ScanEDCFlow+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28ac:	10 92 3a 0a 	sts	0x0A3A, r1
    28b0:	a6 e8       	ldi	r26, 0x86	; 134
    28b2:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28b4:	81 91       	ld	r24, Z+
    28b6:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28b8:	8b e0       	ldi	r24, 0x0B	; 11
    28ba:	e8 35       	cpi	r30, 0x58	; 88
    28bc:	f8 07       	cpc	r31, r24
    28be:	d1 f7       	brne	.-12     	; 0x28b4 <ScanEDCFlow+0x156>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28c0:	10 92 90 09 	sts	0x0990, r1
    28c4:	a7 ee       	ldi	r26, 0xE7	; 231
    28c6:	bd e0       	ldi	r27, 0x0D	; 13
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28c8:	81 91       	ld	r24, Z+
    28ca:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28cc:	8b e0       	ldi	r24, 0x0B	; 11
    28ce:	e6 36       	cpi	r30, 0x66	; 102
    28d0:	f8 07       	cpc	r31, r24
    28d2:	d1 f7       	brne	.-12     	; 0x28c8 <ScanEDCFlow+0x16a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28d4:	10 92 f5 0d 	sts	0x0DF5, r1
	    }else
		 if (EDCMsgCode==0x04){
             StrPosCopy(rcv_trans,strApprovalCode,3,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,9,10);
             StrPosCopy(rcv_trans,strDateTime,19,14);
			 IsVoidTransaction=True;
    28d8:	81 e0       	ldi	r24, 0x01	; 1
    28da:	80 93 b2 01 	sts	0x01B2, r24
    28de:	08 95       	ret

000028e0 <ScanHiddenKeyFlow>:
	    }
    }//MSGDetection
}

void ScanHiddenKeyFlow(char KeyIn){
}
    28e0:	08 95       	ret

000028e2 <ScanRFIDFlow>:


void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
    28e2:	98 2f       	mov	r25, r24
    28e4:	e4 ec       	ldi	r30, 0xC4	; 196
    28e6:	fa e0       	ldi	r31, 0x0A	; 10
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
        strSerialFlow[19-i]=strSerialFlow[18-i];   
    28e8:	80 81       	ld	r24, Z
    28ea:	81 83       	std	Z+1, r24	; 0x01
    28ec:	31 97       	sbiw	r30, 0x01	; 1

void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
    28ee:	8a e0       	ldi	r24, 0x0A	; 10
    28f0:	e1 3b       	cpi	r30, 0xB1	; 177
    28f2:	f8 07       	cpc	r31, r24
    28f4:	c9 f7       	brne	.-14     	; 0x28e8 <ScanRFIDFlow+0x6>
        strSerialFlow[19-i]=strSerialFlow[18-i];   
	 }  strSerialFlow[0]=data;
    28f6:	9f 01       	movw	r18, r30
    28f8:	2f 5f       	subi	r18, 0xFF	; 255
    28fa:	3f 4f       	sbci	r19, 0xFF	; 255
    28fc:	91 83       	std	Z+1, r25	; 0x01
	 //Detection
	 if ((strSerialFlow[11]==0x02)&&(strSerialFlow[1]==0x0A)&&(strSerialFlow[0]==0x03)){
    28fe:	84 85       	ldd	r24, Z+12	; 0x0c
    2900:	82 30       	cpi	r24, 0x02	; 2
    2902:	f9 f4       	brne	.+62     	; 0x2942 <ScanRFIDFlow+0x60>
    2904:	80 91 b3 0a 	lds	r24, 0x0AB3
    2908:	8a 30       	cpi	r24, 0x0A	; 10
    290a:	d9 f4       	brne	.+54     	; 0x2942 <ScanRFIDFlow+0x60>
    290c:	93 30       	cpi	r25, 0x03	; 3
    290e:	c9 f4       	brne	.+50     	; 0x2942 <ScanRFIDFlow+0x60>
    2910:	f9 01       	movw	r30, r18
    2912:	3a 96       	adiw	r30, 0x0a	; 10
    2914:	ac e7       	ldi	r26, 0x7C	; 124
    2916:	be e0       	ldi	r27, 0x0E	; 14
		for(i=0;i<8;i++) strRFID[i]=strSerialFlow[10-i];
    2918:	80 81       	ld	r24, Z
    291a:	8d 93       	st	X+, r24
    291c:	31 97       	sbiw	r30, 0x01	; 1
    291e:	8a e0       	ldi	r24, 0x0A	; 10
    2920:	e4 3b       	cpi	r30, 0xB4	; 180
    2922:	f8 07       	cpc	r31, r24
    2924:	c9 f7       	brne	.-14     	; 0x2918 <ScanRFIDFlow+0x36>
        strRFID[8]=0;
    2926:	10 92 84 0e 	sts	0x0E84, r1
	    IsRFIDDetected=True;
    292a:	81 e0       	ldi	r24, 0x01	; 1
    292c:	80 93 af 01 	sts	0x01AF, r24
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    2930:	80 93 bf 03 	sts	0x03BF, r24
    2934:	10 92 c0 03 	sts	0x03C0, r1
    2938:	80 91 65 00 	lds	r24, 0x0065
    293c:	8d 7f       	andi	r24, 0xFD	; 253
    293e:	80 93 65 00 	sts	0x0065, r24
    2942:	08 95       	ret

00002944 <__vector_18>:
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
}

ISR(USART0_RX_vect){
    2944:	1f 92       	push	r1
    2946:	0f 92       	push	r0
    2948:	0f b6       	in	r0, 0x3f	; 63
    294a:	0f 92       	push	r0
    294c:	11 24       	eor	r1, r1
    294e:	8f 93       	push	r24
    2950:	9f 93       	push	r25
	char dataRX0,IsSPI=False;
	dataRX0= UDR0;
    2952:	9c b1       	in	r25, 0x0c	; 12
	//PrintBusyDetection
	if ((IsBusyIdlePrinting==True)||(IsBusyFreePrinting==True)){
    2954:	80 91 c8 01 	lds	r24, 0x01C8
    2958:	81 30       	cpi	r24, 0x01	; 1
    295a:	21 f0       	breq	.+8      	; 0x2964 <__vector_18+0x20>
    295c:	80 91 ca 01 	lds	r24, 0x01CA
    2960:	81 30       	cpi	r24, 0x01	; 1
    2962:	51 f4       	brne	.+20     	; 0x2978 <__vector_18+0x34>
	    if (dataRX0==19)IsBusyPrint=True;
    2964:	93 31       	cpi	r25, 0x13	; 19
    2966:	21 f4       	brne	.+8      	; 0x2970 <__vector_18+0x2c>
    2968:	81 e0       	ldi	r24, 0x01	; 1
    296a:	80 93 c9 01 	sts	0x01C9, r24
    296e:	04 c0       	rjmp	.+8      	; 0x2978 <__vector_18+0x34>
		else 
	    if (dataRX0==17)IsBusyPrint=False;	
    2970:	91 31       	cpi	r25, 0x11	; 17
    2972:	11 f4       	brne	.+4      	; 0x2978 <__vector_18+0x34>
    2974:	10 92 c9 01 	sts	0x01C9, r1
	}
}
    2978:	9f 91       	pop	r25
    297a:	8f 91       	pop	r24
    297c:	0f 90       	pop	r0
    297e:	0f be       	out	0x3f, r0	; 63
    2980:	0f 90       	pop	r0
    2982:	1f 90       	pop	r1
    2984:	18 95       	reti

00002986 <ScanCommand>:

char ScanCommand(char *strFlow,char *fCommand){
     char Result;
	 Result=False;
   return Result;
}
    2986:	80 e0       	ldi	r24, 0x00	; 0
    2988:	08 95       	ret

0000298a <ConfigProtocol>:
	 }
	 _uart_printf(1,1,PSTR(">"));
	 //End
}

void ConfigProtocol(char dataIn){
    298a:	28 2f       	mov	r18, r24
     static char Conflow[7];
    //Configuration Data Request 
	if ((Conflow[6]=='i')&&(Conflow[5]=='C')&&(Conflow[4]=='o')&&(Conflow[3]=='n')&&(Conflow[2]=='f')&&(Conflow[1]=='?')&&(Conflow[0]==0x0D)&&(dataIn==0x0A)){
    298c:	80 91 ac 03 	lds	r24, 0x03AC
    2990:	89 36       	cpi	r24, 0x69	; 105
    2992:	e9 f4       	brne	.+58     	; 0x29ce <ConfigProtocol+0x44>
    2994:	80 91 ab 03 	lds	r24, 0x03AB
    2998:	83 34       	cpi	r24, 0x43	; 67
    299a:	c9 f4       	brne	.+50     	; 0x29ce <ConfigProtocol+0x44>
    299c:	80 91 aa 03 	lds	r24, 0x03AA
    29a0:	8f 36       	cpi	r24, 0x6F	; 111
    29a2:	a9 f4       	brne	.+42     	; 0x29ce <ConfigProtocol+0x44>
    29a4:	80 91 a9 03 	lds	r24, 0x03A9
    29a8:	8e 36       	cpi	r24, 0x6E	; 110
    29aa:	89 f4       	brne	.+34     	; 0x29ce <ConfigProtocol+0x44>
    29ac:	80 91 a8 03 	lds	r24, 0x03A8
    29b0:	86 36       	cpi	r24, 0x66	; 102
    29b2:	69 f4       	brne	.+26     	; 0x29ce <ConfigProtocol+0x44>
    29b4:	80 91 a7 03 	lds	r24, 0x03A7
    29b8:	8f 33       	cpi	r24, 0x3F	; 63
    29ba:	49 f4       	brne	.+18     	; 0x29ce <ConfigProtocol+0x44>
    29bc:	80 91 a6 03 	lds	r24, 0x03A6
    29c0:	8d 30       	cpi	r24, 0x0D	; 13
    29c2:	29 f4       	brne	.+10     	; 0x29ce <ConfigProtocol+0x44>
    29c4:	2a 30       	cpi	r18, 0x0A	; 10
    29c6:	19 f4       	brne	.+6      	; 0x29ce <ConfigProtocol+0x44>
	     //SendConfigParamater();        
		 ConfigCommand=CC_SEND_CONFIG;
    29c8:	82 e0       	ldi	r24, 0x02	; 2
    29ca:	80 93 c6 01 	sts	0x01C6, r24
	}

	if (IsConfigFlow==True){        
    29ce:	80 91 98 01 	lds	r24, 0x0198
    29d2:	81 30       	cpi	r24, 0x01	; 1
    29d4:	69 f4       	brne	.+26     	; 0x29f0 <ConfigProtocol+0x66>
	    rcv_trans[char_count]=dataIn;
    29d6:	80 91 9c 01 	lds	r24, 0x019C
    29da:	90 91 9d 01 	lds	r25, 0x019D
    29de:	fc 01       	movw	r30, r24
    29e0:	eb 5b       	subi	r30, 0xBB	; 187
    29e2:	f4 4f       	sbci	r31, 0xF4	; 244
    29e4:	20 83       	st	Z, r18
	    char_count++; 
    29e6:	01 96       	adiw	r24, 0x01	; 1
    29e8:	90 93 9d 01 	sts	0x019D, r25
    29ec:	80 93 9c 01 	sts	0x019C, r24
	}
	if ((Conflow[0]==0x04)&&(dataIn==0x40)){
    29f0:	80 91 a6 03 	lds	r24, 0x03A6
    29f4:	84 30       	cpi	r24, 0x04	; 4
    29f6:	51 f4       	brne	.+20     	; 0x2a0c <ConfigProtocol+0x82>
    29f8:	20 34       	cpi	r18, 0x40	; 64
    29fa:	e9 f4       	brne	.+58     	; 0x2a36 <ConfigProtocol+0xac>
	     IsConfigFlow=True;
    29fc:	81 e0       	ldi	r24, 0x01	; 1
    29fe:	80 93 98 01 	sts	0x0198, r24
		 char_count=0;
    2a02:	10 92 9d 01 	sts	0x019D, r1
    2a06:	10 92 9c 01 	sts	0x019C, r1
    2a0a:	15 c0       	rjmp	.+42     	; 0x2a36 <ConfigProtocol+0xac>
	}
	//SavingData
	if ((Conflow[0]==0x05)&&(dataIn==0x50)){
    2a0c:	85 30       	cpi	r24, 0x05	; 5
    2a0e:	99 f4       	brne	.+38     	; 0x2a36 <ConfigProtocol+0xac>
    2a10:	20 35       	cpi	r18, 0x50	; 80
    2a12:	89 f4       	brne	.+34     	; 0x2a36 <ConfigProtocol+0xac>
	     transLength=char_count;
    2a14:	80 91 9c 01 	lds	r24, 0x019C
    2a18:	90 91 9d 01 	lds	r25, 0x019D
    2a1c:	90 93 9f 01 	sts	0x019F, r25
    2a20:	80 93 9e 01 	sts	0x019E, r24
		 char_count=0;
    2a24:	10 92 9d 01 	sts	0x019D, r1
    2a28:	10 92 9c 01 	sts	0x019C, r1
	     IsConfigFlow=False;
    2a2c:	10 92 98 01 	sts	0x0198, r1
		 ConfigCommand=CC_SAVE_CONFIG;
    2a30:	81 e0       	ldi	r24, 0x01	; 1
    2a32:	80 93 c6 01 	sts	0x01C6, r24
		 //SaveConfigParameter();
	}

	//Shifting
	Conflow[6]=Conflow[5];
    2a36:	80 91 ab 03 	lds	r24, 0x03AB
    2a3a:	80 93 ac 03 	sts	0x03AC, r24
	Conflow[5]=Conflow[4];
    2a3e:	80 91 aa 03 	lds	r24, 0x03AA
    2a42:	80 93 ab 03 	sts	0x03AB, r24
	Conflow[4]=Conflow[3];
    2a46:	80 91 a9 03 	lds	r24, 0x03A9
    2a4a:	80 93 aa 03 	sts	0x03AA, r24
	Conflow[3]=Conflow[2];
    2a4e:	80 91 a8 03 	lds	r24, 0x03A8
    2a52:	80 93 a9 03 	sts	0x03A9, r24
	Conflow[2]=Conflow[1];
    2a56:	80 91 a7 03 	lds	r24, 0x03A7
    2a5a:	80 93 a8 03 	sts	0x03A8, r24
	Conflow[1]=Conflow[0];
    2a5e:	80 91 a6 03 	lds	r24, 0x03A6
    2a62:	80 93 a7 03 	sts	0x03A7, r24
	Conflow[0]=dataIn;
    2a66:	20 93 a6 03 	sts	0x03A6, r18

}
    2a6a:	08 95       	ret

00002a6c <system_beep>:
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    2a6c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    2a6e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    2a70:	90 93 d7 01 	sts	0x01D7, r25
    2a74:	80 93 d6 01 	sts	0x01D6, r24
}
    2a78:	08 95       	ret

00002a7a <systemRestart>:
	 iRestart=0;
	 while(iRestart<100){
	       strRestart[iRestart]=iRestart;
	       iRestart++;	 
	 }
}
    2a7a:	08 95       	ret

00002a7c <Low>:

char Low(char X){
     char Result;
	 Result=(0x0F&X);
	 return Result;
}
    2a7c:	8f 70       	andi	r24, 0x0F	; 15
    2a7e:	08 95       	ret

00002a80 <High>:
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
	 return Result;
}
    2a80:	82 95       	swap	r24
    2a82:	8f 70       	andi	r24, 0x0F	; 15
    2a84:	08 95       	ret

00002a86 <Str>:
char Str(char H){
    2a86:	98 2f       	mov	r25, r24
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2a88:	8a 30       	cpi	r24, 0x0A	; 10
    2a8a:	10 f4       	brcc	.+4      	; 0x2a90 <Str+0xa>
    2a8c:	80 5d       	subi	r24, 0xD0	; 208
    2a8e:	08 95       	ret
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2a90:	8a 50       	subi	r24, 0x0A	; 10
    2a92:	86 30       	cpi	r24, 0x06	; 6
    2a94:	10 f0       	brcs	.+4      	; 0x2a9a <Str+0x14>
    2a96:	80 e0       	ldi	r24, 0x00	; 0
    2a98:	08 95       	ret
    2a9a:	89 2f       	mov	r24, r25
    2a9c:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}
    2a9e:	08 95       	ret

00002aa0 <charToHex>:

void charToHex(char X, char *Result){
    2aa0:	28 2f       	mov	r18, r24
    2aa2:	fb 01       	movw	r30, r22
	 Result=(0x0F&X);
	 return Result;
}
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
    2aa4:	98 2f       	mov	r25, r24
    2aa6:	92 95       	swap	r25
    2aa8:	9f 70       	andi	r25, 0x0F	; 15
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2aaa:	9a 30       	cpi	r25, 0x0A	; 10
    2aac:	18 f4       	brcc	.+6      	; 0x2ab4 <charToHex+0x14>
    2aae:	89 2f       	mov	r24, r25
    2ab0:	80 5d       	subi	r24, 0xD0	; 208
    2ab2:	08 c0       	rjmp	.+16     	; 0x2ac4 <charToHex+0x24>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2ab4:	89 2f       	mov	r24, r25
    2ab6:	8a 50       	subi	r24, 0x0A	; 10
    2ab8:	86 30       	cpi	r24, 0x06	; 6
    2aba:	10 f0       	brcs	.+4      	; 0x2ac0 <charToHex+0x20>
    2abc:	80 e0       	ldi	r24, 0x00	; 0
    2abe:	02 c0       	rjmp	.+4      	; 0x2ac4 <charToHex+0x24>
    2ac0:	89 2f       	mov	r24, r25
    2ac2:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
    2ac4:	80 83       	st	Z, r24
	lcd_print(1,1,lcdteks);
}

char Low(char X){
     char Result;
	 Result=(0x0F&X);
    2ac6:	92 2f       	mov	r25, r18
    2ac8:	9f 70       	andi	r25, 0x0F	; 15
	 Result=((X>>4)&(0x0F));
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2aca:	9a 30       	cpi	r25, 0x0A	; 10
    2acc:	18 f4       	brcc	.+6      	; 0x2ad4 <charToHex+0x34>
    2ace:	89 2f       	mov	r24, r25
    2ad0:	80 5d       	subi	r24, 0xD0	; 208
    2ad2:	08 c0       	rjmp	.+16     	; 0x2ae4 <charToHex+0x44>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2ad4:	89 2f       	mov	r24, r25
    2ad6:	8a 50       	subi	r24, 0x0A	; 10
    2ad8:	86 30       	cpi	r24, 0x06	; 6
    2ada:	10 f0       	brcs	.+4      	; 0x2ae0 <charToHex+0x40>
    2adc:	80 e0       	ldi	r24, 0x00	; 0
    2ade:	02 c0       	rjmp	.+4      	; 0x2ae4 <charToHex+0x44>
    2ae0:	89 2f       	mov	r24, r25
    2ae2:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
	 Result[1]=Str(Low(X));
    2ae4:	81 83       	std	Z+1, r24	; 0x01
	 Result[2]=0;
    2ae6:	12 82       	std	Z+2, r1	; 0x02
	 
}
    2ae8:	08 95       	ret

00002aea <strToInt>:

char strToInt(char *str){
    2aea:	fc 01       	movw	r30, r24
     char Result;
     Result=(((str[0]-'0')*10) +(str[0]-'0'));
    2aec:	80 81       	ld	r24, Z
    2aee:	2a e0       	ldi	r18, 0x0A	; 10
    2af0:	82 9f       	mul	r24, r18
    2af2:	90 01       	movw	r18, r0
    2af4:	11 24       	eor	r1, r1
    2af6:	80 51       	subi	r24, 0x10	; 16
	 return Result;
}
    2af8:	82 0f       	add	r24, r18
    2afa:	08 95       	ret

00002afc <intToStr>:

void intToStr(char X, char *str){
    2afc:	58 2f       	mov	r21, r24
    2afe:	fb 01       	movw	r30, r22
     char R,P,S;
	 R=X/100;
    2b00:	64 e6       	ldi	r22, 0x64	; 100
    2b02:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    2b06:	a8 2f       	mov	r26, r24
	 P=(X%100)/10;
    2b08:	85 2f       	mov	r24, r21
    2b0a:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    2b0e:	89 2f       	mov	r24, r25
    2b10:	6a e0       	ldi	r22, 0x0A	; 10
    2b12:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    2b16:	48 2f       	mov	r20, r24
	 S=X-(R*100)-(P*10);
    2b18:	8c e9       	ldi	r24, 0x9C	; 156
    2b1a:	9f ef       	ldi	r25, 0xFF	; 255
    2b1c:	a8 9f       	mul	r26, r24
    2b1e:	80 2d       	mov	r24, r0
    2b20:	11 24       	eor	r1, r1
    2b22:	85 0f       	add	r24, r21
    2b24:	26 ef       	ldi	r18, 0xF6	; 246
    2b26:	3f ef       	ldi	r19, 0xFF	; 255
    2b28:	42 9f       	mul	r20, r18
    2b2a:	90 2d       	mov	r25, r0
    2b2c:	11 24       	eor	r1, r1
    2b2e:	98 0f       	add	r25, r24
	 if (X>=100){
    2b30:	54 36       	cpi	r21, 0x64	; 100
    2b32:	40 f0       	brcs	.+16     	; 0x2b44 <intToStr+0x48>
	     str[0]=('0'+R);
    2b34:	a0 5d       	subi	r26, 0xD0	; 208
    2b36:	a0 83       	st	Z, r26
	     str[1]=('0'+P);
    2b38:	40 5d       	subi	r20, 0xD0	; 208
    2b3a:	41 83       	std	Z+1, r20	; 0x01
	     str[2]=('0'+S);
    2b3c:	90 5d       	subi	r25, 0xD0	; 208
    2b3e:	92 83       	std	Z+2, r25	; 0x02
	     str[3]=0;
    2b40:	13 82       	std	Z+3, r1	; 0x03
    2b42:	08 95       	ret
	 if ((X>=10)&&(X>100)){
	     str[0]=('0'+P);
	     str[1]=('0'+S);
	     str[2]=0;
	 }else 
	 if (X<=10){
    2b44:	5b 30       	cpi	r21, 0x0B	; 11
    2b46:	18 f4       	brcc	.+6      	; 0x2b4e <intToStr+0x52>
	     str[0]=('0'+S);
    2b48:	90 5d       	subi	r25, 0xD0	; 208
    2b4a:	90 83       	st	Z, r25
	     str[1]=0;
    2b4c:	11 82       	std	Z+1, r1	; 0x01
    2b4e:	08 95       	ret

00002b50 <ViewCardID>:
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;

}

void ViewCardID(){//+12345678 -->12345678
    2b50:	20 e0       	ldi	r18, 0x00	; 0
    2b52:	30 e0       	ldi	r19, 0x00	; 0
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
    2b54:	f9 01       	movw	r30, r18
    2b56:	ef 54       	subi	r30, 0x4F	; 79
    2b58:	f2 4f       	sbci	r31, 0xF2	; 242
    2b5a:	d9 01       	movw	r26, r18
    2b5c:	a4 58       	subi	r26, 0x84	; 132
    2b5e:	b1 4f       	sbci	r27, 0xF1	; 241
    2b60:	8c 91       	ld	r24, X
    2b62:	80 83       	st	Z, r24
    2b64:	2f 5f       	subi	r18, 0xFF	; 255
    2b66:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
    2b68:	28 30       	cpi	r18, 0x08	; 8
    2b6a:	31 05       	cpc	r19, r1
    2b6c:	99 f7       	brne	.-26     	; 0x2b54 <ViewCardID+0x4>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
    2b6e:	10 92 b9 0d 	sts	0x0DB9, r1
}
    2b72:	08 95       	ret

00002b74 <StringCopy>:
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
    2b74:	cf 93       	push	r28
    2b76:	df 93       	push	r29
    2b78:	db 01       	movw	r26, r22
    2b7a:	ec 01       	movw	r28, r24
    2b7c:	20 e0       	ldi	r18, 0x00	; 0
    2b7e:	30 e0       	ldi	r19, 0x00	; 0
    2b80:	07 c0       	rjmp	.+14     	; 0x2b90 <StringCopy+0x1c>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
    2b82:	fd 01       	movw	r30, r26
    2b84:	e2 0f       	add	r30, r18
    2b86:	f3 1f       	adc	r31, r19
    2b88:	89 91       	ld	r24, Y+
    2b8a:	80 83       	st	Z, r24
    2b8c:	2f 5f       	subi	r18, 0xFF	; 255
    2b8e:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2b90:	24 17       	cp	r18, r20
    2b92:	b8 f3       	brcs	.-18     	; 0x2b82 <StringCopy+0xe>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
    2b94:	a4 0f       	add	r26, r20
    2b96:	b1 1d       	adc	r27, r1
    2b98:	1c 92       	st	X, r1
}
    2b9a:	df 91       	pop	r29
    2b9c:	cf 91       	pop	r28
    2b9e:	08 95       	ret

00002ba0 <StringCopyPos>:
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
    2ba0:	cf 93       	push	r28
    2ba2:	df 93       	push	r29
    2ba4:	db 01       	movw	r26, r22
    2ba6:	ec 01       	movw	r28, r24
    2ba8:	c4 0f       	add	r28, r20
    2baa:	d1 1d       	adc	r29, r1
    2bac:	40 e0       	ldi	r20, 0x00	; 0
    2bae:	50 e0       	ldi	r21, 0x00	; 0
    2bb0:	07 c0       	rjmp	.+14     	; 0x2bc0 <StringCopyPos+0x20>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
    2bb2:	fd 01       	movw	r30, r26
    2bb4:	e4 0f       	add	r30, r20
    2bb6:	f5 1f       	adc	r31, r21
    2bb8:	89 91       	ld	r24, Y+
    2bba:	80 83       	st	Z, r24
    2bbc:	4f 5f       	subi	r20, 0xFF	; 255
    2bbe:	5f 4f       	sbci	r21, 0xFF	; 255
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2bc0:	42 17       	cp	r20, r18
    2bc2:	b8 f3       	brcs	.-18     	; 0x2bb2 <StringCopyPos+0x12>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
    2bc4:	a2 0f       	add	r26, r18
    2bc6:	b1 1d       	adc	r27, r1
    2bc8:	1c 92       	st	X, r1
}
    2bca:	df 91       	pop	r29
    2bcc:	cf 91       	pop	r28
    2bce:	08 95       	ret

00002bd0 <TestLocalAccount>:

void TestLocalAccount(){

}
    2bd0:	08 95       	ret

00002bd2 <BackLightTrig>:
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    2bd2:	81 e0       	ldi	r24, 0x01	; 1
    2bd4:	80 93 bf 03 	sts	0x03BF, r24
    2bd8:	10 92 c0 03 	sts	0x03C0, r1
    2bdc:	e5 e6       	ldi	r30, 0x65	; 101
    2bde:	f0 e0       	ldi	r31, 0x00	; 0
    2be0:	80 81       	ld	r24, Z
    2be2:	8d 7f       	andi	r24, 0xFD	; 253
    2be4:	80 83       	st	Z, r24
}
    2be6:	08 95       	ret

00002be8 <FBackLight>:

void FBackLight(){
     if (TimBackLight>0){
    2be8:	20 91 a2 01 	lds	r18, 0x01A2
    2bec:	30 91 a3 01 	lds	r19, 0x01A3
    2bf0:	21 15       	cp	r18, r1
    2bf2:	31 05       	cpc	r19, r1
    2bf4:	61 f0       	breq	.+24     	; 0x2c0e <FBackLight+0x26>
	     PORTG=PORTG&0xFD;
    2bf6:	80 91 65 00 	lds	r24, 0x0065
    2bfa:	8d 7f       	andi	r24, 0xFD	; 253
    2bfc:	80 93 65 00 	sts	0x0065, r24
	     TimBackLight--;
    2c00:	21 50       	subi	r18, 0x01	; 1
    2c02:	30 40       	sbci	r19, 0x00	; 0
    2c04:	30 93 a3 01 	sts	0x01A3, r19
    2c08:	20 93 a2 01 	sts	0x01A2, r18
    2c0c:	08 95       	ret
		 }
	 else PORTG=PORTG|0x02;
    2c0e:	80 91 65 00 	lds	r24, 0x0065
    2c12:	82 60       	ori	r24, 0x02	; 2
    2c14:	80 93 65 00 	sts	0x0065, r24
    2c18:	08 95       	ret

00002c1a <GetBaudrate>:
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2c1a:	82 30       	cpi	r24, 0x02	; 2
    2c1c:	59 f0       	breq	.+22     	; 0x2c34 <GetBaudrate+0x1a>
    2c1e:	82 30       	cpi	r24, 0x02	; 2
    2c20:	18 f0       	brcs	.+6      	; 0x2c28 <GetBaudrate+0xe>
    2c22:	83 30       	cpi	r24, 0x03	; 3
    2c24:	21 f4       	brne	.+8      	; 0x2c2e <GetBaudrate+0x14>
    2c26:	09 c0       	rjmp	.+18     	; 0x2c3a <GetBaudrate+0x20>
    2c28:	20 e8       	ldi	r18, 0x80	; 128
    2c2a:	35 e2       	ldi	r19, 0x25	; 37
    2c2c:	08 c0       	rjmp	.+16     	; 0x2c3e <GetBaudrate+0x24>
    2c2e:	20 e0       	ldi	r18, 0x00	; 0
    2c30:	30 e0       	ldi	r19, 0x00	; 0
    2c32:	05 c0       	rjmp	.+10     	; 0x2c3e <GetBaudrate+0x24>
    2c34:	20 e0       	ldi	r18, 0x00	; 0
    2c36:	3b e4       	ldi	r19, 0x4B	; 75
    2c38:	02 c0       	rjmp	.+4      	; 0x2c3e <GetBaudrate+0x24>
	 case br9600: 
	      Result=9600;
	      break;
	 case br19200:
	      Result=19200;
	      break;
    2c3a:	2b e9       	ldi	r18, 0x9B	; 155
    2c3c:	36 e1       	ldi	r19, 0x16	; 22
	 case br5787:
	      Result=5787;
     	  break;	 
	 }
   return Result;
}
    2c3e:	c9 01       	movw	r24, r18
    2c40:	08 95       	ret

00002c42 <InitMemory>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2c42:	e1 99       	sbic	0x1c, 1	; 28
    2c44:	fe cf       	rjmp	.-4      	; 0x2c42 <InitMemory>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2c46:	84 e4       	ldi	r24, 0x44	; 68
    2c48:	91 e0       	ldi	r25, 0x01	; 1
    2c4a:	9f bb       	out	0x1f, r25	; 31
    2c4c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2c4e:	e0 9a       	sbi	0x1c, 0	; 28
    2c50:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    2c52:	80 93 5f 01 	sts	0x015F, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2c56:	e1 99       	sbic	0x1c, 1	; 28
    2c58:	fe cf       	rjmp	.-4      	; 0x2c56 <InitMemory+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2c5a:	89 e4       	ldi	r24, 0x49	; 73
    2c5c:	91 e0       	ldi	r25, 0x01	; 1
    2c5e:	9f bb       	out	0x1f, r25	; 31
    2c60:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2c62:	e0 9a       	sbi	0x1c, 0	; 28
    2c64:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    2c66:	80 93 60 01 	sts	0x0160, r24
}
    2c6a:	08 95       	ret

00002c6c <InitStandalone>:
	      RunInitStandalone=False;
	      break;
	 }
  }
  */
}
    2c6c:	08 95       	ret

00002c6e <DisplayQueueFIP>:


void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}
    2c6e:	08 95       	ret

00002c70 <ShowMessage>:
	 }
}

void ShowMessage(char *Message){//Display Message on Line3
     char i;
}
    2c70:	08 95       	ret

00002c72 <CalcLRC>:

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}
    2c72:	86 27       	eor	r24, r22
    2c74:	08 95       	ret

00002c76 <systemEDC>:
}

void systemEDC(){//EDC Handler
     

}
    2c76:	08 95       	ret

00002c78 <GeniusCalc>:


char GeniusCalc(char cOption, char valA, char valB){
     char valC_H,valC_L,xValA,xValB,Result;
	 Result=0;
     switch(cOption){
    2c78:	88 23       	and	r24, r24
    2c7a:	19 f0       	breq	.+6      	; 0x2c82 <GeniusCalc+0xa>
    2c7c:	81 30       	cpi	r24, 0x01	; 1
    2c7e:	49 f5       	brne	.+82     	; 0x2cd2 <GeniusCalc+0x5a>
    2c80:	11 c0       	rjmp	.+34     	; 0x2ca4 <GeniusCalc+0x2c>
	 case G_PLUS:                  // 5 + 8 = 1 + 3 = 4
	      valC_H=(valA+valB)/10;   //  
    2c82:	26 2f       	mov	r18, r22
    2c84:	30 e0       	ldi	r19, 0x00	; 0
    2c86:	24 0f       	add	r18, r20
    2c88:	31 1d       	adc	r19, r1
		  valC_L=(valA+valB)%10;   //
	      Result=valC_H+valC_L;
    2c8a:	c9 01       	movw	r24, r18
    2c8c:	6a e0       	ldi	r22, 0x0A	; 10
    2c8e:	70 e0       	ldi	r23, 0x00	; 0
    2c90:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    2c94:	48 2f       	mov	r20, r24
    2c96:	c9 01       	movw	r24, r18
    2c98:	6a e0       	ldi	r22, 0x0A	; 10
    2c9a:	70 e0       	ldi	r23, 0x00	; 0
    2c9c:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    2ca0:	46 0f       	add	r20, r22
    2ca2:	18 c0       	rjmp	.+48     	; 0x2cd4 <GeniusCalc+0x5c>
	      break;
	 case G_MULTY:                 
	      if (valA>0)xValA=valA;
    2ca4:	66 23       	and	r22, r22
    2ca6:	09 f4       	brne	.+2      	; 0x2caa <GeniusCalc+0x32>
    2ca8:	61 e0       	ldi	r22, 0x01	; 1
		  else xValA=1;
	      if (valB>0)xValB=valB;
    2caa:	44 23       	and	r20, r20
    2cac:	09 f4       	brne	.+2      	; 0x2cb0 <GeniusCalc+0x38>
    2cae:	41 e0       	ldi	r20, 0x01	; 1
		  else xValB=1;
	      valC_H=(xValA*xValB)/10;   //  
    2cb0:	46 9f       	mul	r20, r22
    2cb2:	90 01       	movw	r18, r0
    2cb4:	11 24       	eor	r1, r1
    2cb6:	c9 01       	movw	r24, r18
    2cb8:	6a e0       	ldi	r22, 0x0A	; 10
    2cba:	70 e0       	ldi	r23, 0x00	; 0
    2cbc:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    2cc0:	46 2f       	mov	r20, r22
		  valC_L=(xValA*xValB)%10;   //
    2cc2:	c9 01       	movw	r24, r18
    2cc4:	6a e0       	ldi	r22, 0x0A	; 10
    2cc6:	70 e0       	ldi	r23, 0x00	; 0
    2cc8:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    2ccc:	64 2f       	mov	r22, r20
    2cce:	48 2f       	mov	r20, r24
    2cd0:	d8 cf       	rjmp	.-80     	; 0x2c82 <GeniusCalc+0xa>
    2cd2:	40 e0       	ldi	r20, 0x00	; 0
	 case G_MINUS:
	      
	      break;
	 }
   return Result;
}
    2cd4:	84 2f       	mov	r24, r20
    2cd6:	08 95       	ret

00002cd8 <FSubMenuAdmin>:

char FSubMenuAdmin(){
     char Result;
	 Result=MENU_DONE;
   return Result;
}
    2cd8:	81 e0       	ldi	r24, 0x01	; 1
    2cda:	08 95       	ret

00002cdc <CountNoPumpSatus>:
	      break;	 
	 } 
   return Result;
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
    2cdc:	ff 92       	push	r15
    2cde:	0f 93       	push	r16
    2ce0:	1f 93       	push	r17
    2ce2:	cf 93       	push	r28
    2ce4:	df 93       	push	r29
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2ce6:	f0 90 5f 01 	lds	r15, 0x015F
    2cea:	ec 01       	movw	r28, r24
    2cec:	00 e0       	ldi	r16, 0x00	; 0
    2cee:	10 e0       	ldi	r17, 0x00	; 0
    2cf0:	09 c0       	rjmp	.+18     	; 0x2d04 <CountNoPumpSatus+0x28>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
    2cf2:	8e e0       	ldi	r24, 0x0E	; 14
    2cf4:	0e 94 72 13 	call	0x26e4	; 0x26e4 <GetPumpStatusLabel>
    2cf8:	98 81       	ld	r25, Y
    2cfa:	98 17       	cp	r25, r24
    2cfc:	09 f4       	brne	.+2      	; 0x2d00 <CountNoPumpSatus+0x24>
		      Result++;		  
    2cfe:	1f 5f       	subi	r17, 0xFF	; 255
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2d00:	0f 5f       	subi	r16, 0xFF	; 255
    2d02:	21 96       	adiw	r28, 0x01	; 1
    2d04:	0f 15       	cp	r16, r15
    2d06:	a8 f3       	brcs	.-22     	; 0x2cf2 <CountNoPumpSatus+0x16>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    2d08:	81 2f       	mov	r24, r17
    2d0a:	df 91       	pop	r29
    2d0c:	cf 91       	pop	r28
    2d0e:	1f 91       	pop	r17
    2d10:	0f 91       	pop	r16
    2d12:	ff 90       	pop	r15
    2d14:	08 95       	ret

00002d16 <FCloseDay>:
   return Result;
}

char FCloseDay(){

}
    2d16:	08 95       	ret

00002d18 <FLockPump>:
char FLockPump(){

}
    2d18:	08 95       	ret

00002d1a <FMenuSettingPassword>:
char FMenuSettingPassword(){
     char Result;
   //_menu_password();
   Result=MENU_DONE;
   return Result;
}
    2d1a:	81 e0       	ldi	r24, 0x01	; 1
    2d1c:	08 95       	ret

00002d1e <menu_product>:
   return Result;
}

void menu_product(){

}
    2d1e:	08 95       	ret

00002d20 <IncValue>:
            lcd_print(xPos,yPos,strLabel);
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
    2d20:	fc 01       	movw	r30, r24
     if ((*Value)<MaxValue){
    2d22:	80 81       	ld	r24, Z
    2d24:	84 17       	cp	r24, r20
    2d26:	18 f4       	brcc	.+6      	; 0x2d2e <IncValue+0xe>
	     (*Value)++;
    2d28:	8f 5f       	subi	r24, 0xFF	; 255
    2d2a:	80 83       	st	Z, r24
    2d2c:	08 95       	ret
	 }else *Value=MinValue;
    2d2e:	60 83       	st	Z, r22
    2d30:	08 95       	ret

00002d32 <DecValue>:
}

void DecValue(char *Value,char MinValue,char MaxValue){
    2d32:	fc 01       	movw	r30, r24
     if ((*Value)>MinValue){
    2d34:	80 81       	ld	r24, Z
    2d36:	68 17       	cp	r22, r24
    2d38:	18 f4       	brcc	.+6      	; 0x2d40 <DecValue+0xe>
	     (*Value)--;
    2d3a:	81 50       	subi	r24, 0x01	; 1
    2d3c:	80 83       	st	Z, r24
    2d3e:	08 95       	ret
	 }else *Value=MaxValue;
    2d40:	40 83       	st	Z, r20
    2d42:	08 95       	ret

00002d44 <zeroIP>:
		 
		}

	}
}
void zeroIP(unsigned char Val,char *StrResult){
    2d44:	58 2f       	mov	r21, r24
    2d46:	fb 01       	movw	r30, r22
     unsigned char R,P,S;
	 if (Val>=100){
    2d48:	84 36       	cpi	r24, 0x64	; 100
    2d4a:	00 f1       	brcs	.+64     	; 0x2d8c <zeroIP+0x48>
	    R=(Val/100);
    2d4c:	64 e6       	ldi	r22, 0x64	; 100
    2d4e:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    2d52:	48 2f       	mov	r20, r24
        P=((Val%100)/10);
    2d54:	85 2f       	mov	r24, r21
    2d56:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    2d5a:	89 2f       	mov	r24, r25
    2d5c:	6a e0       	ldi	r22, 0x0A	; 10
    2d5e:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
		S=Val-((R*100)+(P*10)); 
        StrResult[0]='0'+R;//+(Val/100);
    2d62:	40 5d       	subi	r20, 0xD0	; 208
    2d64:	40 83       	st	Z, r20
    2d66:	40 53       	subi	r20, 0x30	; 48
	    StrResult[1]='0'+P;//+((Val%100)/10);
    2d68:	80 5d       	subi	r24, 0xD0	; 208
    2d6a:	81 83       	std	Z+1, r24	; 0x01
    2d6c:	80 53       	subi	r24, 0x30	; 48
		StrResult[2]='0'+S;//+(Val-((Val/100)*100)-((Val%100)/10));
    2d6e:	50 5d       	subi	r21, 0xD0	; 208
    2d70:	2c e9       	ldi	r18, 0x9C	; 156
    2d72:	3f ef       	ldi	r19, 0xFF	; 255
    2d74:	42 9f       	mul	r20, r18
    2d76:	40 2d       	mov	r20, r0
    2d78:	11 24       	eor	r1, r1
    2d7a:	45 0f       	add	r20, r21
    2d7c:	26 ef       	ldi	r18, 0xF6	; 246
    2d7e:	3f ef       	ldi	r19, 0xFF	; 255
    2d80:	82 9f       	mul	r24, r18
    2d82:	80 2d       	mov	r24, r0
    2d84:	11 24       	eor	r1, r1
    2d86:	84 0f       	add	r24, r20
    2d88:	82 83       	std	Z+2, r24	; 0x02
    2d8a:	10 c0       	rjmp	.+32     	; 0x2dac <zeroIP+0x68>
		StrResult[3]=0;
		}else     
	 if ((Val>=10)&&(Val<100)){
    2d8c:	8a 50       	subi	r24, 0x0A	; 10
    2d8e:	8a 35       	cpi	r24, 0x5A	; 90
    2d90:	78 f4       	brcc	.+30     	; 0x2db0 <zeroIP+0x6c>
        StrResult[0]='0';
    2d92:	80 e3       	ldi	r24, 0x30	; 48
    2d94:	80 83       	st	Z, r24
	    StrResult[1]=('0'+(Val/10));
    2d96:	85 2f       	mov	r24, r21
    2d98:	6a e0       	ldi	r22, 0x0A	; 10
    2d9a:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    2d9e:	80 5d       	subi	r24, 0xD0	; 208
    2da0:	81 83       	std	Z+1, r24	; 0x01
		StrResult[2]=('0'+(Val%10));
    2da2:	85 2f       	mov	r24, r21
    2da4:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    2da8:	90 5d       	subi	r25, 0xD0	; 208
    2daa:	92 83       	std	Z+2, r25	; 0x02
		StrResult[3]=0;
    2dac:	13 82       	std	Z+3, r1	; 0x03
    2dae:	08 95       	ret
		}
     else
	 if (Val<10){
    2db0:	5a 30       	cpi	r21, 0x0A	; 10
    2db2:	30 f4       	brcc	.+12     	; 0x2dc0 <zeroIP+0x7c>
	    StrResult[0]='0';
    2db4:	80 e3       	ldi	r24, 0x30	; 48
    2db6:	80 83       	st	Z, r24
		StrResult[1]='0';
    2db8:	81 83       	std	Z+1, r24	; 0x01
	    StrResult[2]='0'+Val;
    2dba:	50 5d       	subi	r21, 0xD0	; 208
    2dbc:	52 83       	std	Z+2, r21	; 0x02
	    StrResult[3]=0;
    2dbe:	13 82       	std	Z+3, r1	; 0x03
    2dc0:	08 95       	ret

00002dc2 <GetLocAccStatus>:


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
    2dc2:	81 30       	cpi	r24, 0x01	; 1
    2dc4:	29 f0       	breq	.+10     	; 0x2dd0 <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
    2dc6:	82 30       	cpi	r24, 0x02	; 2
    2dc8:	19 f0       	breq	.+6      	; 0x2dd0 <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
    2dca:	83 30       	cpi	r24, 0x03	; 3
    2dcc:	09 f0       	breq	.+2      	; 0x2dd0 <GetLocAccStatus+0xe>
    2dce:	80 e0       	ldi	r24, 0x00	; 0
	 return Result;
}
    2dd0:	08 95       	ret

00002dd2 <FTestRemZero>:
	     RemZeroLead(strTest);  
		 _uart_print(0,1,strTest);

	while (1){};
  #endif
}
    2dd2:	08 95       	ret

00002dd4 <StrPosCopy>:
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2dd4:	cf 93       	push	r28
    2dd6:	df 93       	push	r29
    2dd8:	eb 01       	movw	r28, r22
    2dda:	da 01       	movw	r26, r20
    2ddc:	a8 0f       	add	r26, r24
    2dde:	b9 1f       	adc	r27, r25
    2de0:	40 e0       	ldi	r20, 0x00	; 0
    2de2:	50 e0       	ldi	r21, 0x00	; 0
    2de4:	07 c0       	rjmp	.+14     	; 0x2df4 <StrPosCopy+0x20>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2de6:	fe 01       	movw	r30, r28
    2de8:	e4 0f       	add	r30, r20
    2dea:	f5 1f       	adc	r31, r21
    2dec:	8d 91       	ld	r24, X+
    2dee:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2df0:	4f 5f       	subi	r20, 0xFF	; 255
    2df2:	5f 4f       	sbci	r21, 0xFF	; 255
    2df4:	42 17       	cp	r20, r18
    2df6:	53 07       	cpc	r21, r19
    2df8:	b0 f3       	brcs	.-20     	; 0x2de6 <StrPosCopy+0x12>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2dfa:	c2 0f       	add	r28, r18
    2dfc:	d3 1f       	adc	r29, r19
    2dfe:	18 82       	st	Y, r1
}
    2e00:	df 91       	pop	r29
    2e02:	cf 91       	pop	r28
    2e04:	08 95       	ret

00002e06 <StrPosPaste>:
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2e06:	0f 93       	push	r16
    2e08:	1f 93       	push	r17
    2e0a:	cf 93       	push	r28
    2e0c:	df 93       	push	r29
    2e0e:	8c 01       	movw	r16, r24
    2e10:	db 01       	movw	r26, r22
    2e12:	eb 01       	movw	r28, r22
    2e14:	c4 0f       	add	r28, r20
    2e16:	d5 1f       	adc	r29, r21
    2e18:	60 e0       	ldi	r22, 0x00	; 0
    2e1a:	70 e0       	ldi	r23, 0x00	; 0
    2e1c:	07 c0       	rjmp	.+14     	; 0x2e2c <StrPosPaste+0x26>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    2e1e:	f8 01       	movw	r30, r16
    2e20:	e6 0f       	add	r30, r22
    2e22:	f7 1f       	adc	r31, r23
    2e24:	80 81       	ld	r24, Z
    2e26:	89 93       	st	Y+, r24
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e28:	6f 5f       	subi	r22, 0xFF	; 255
    2e2a:	7f 4f       	sbci	r23, 0xFF	; 255
    2e2c:	62 17       	cp	r22, r18
    2e2e:	73 07       	cpc	r23, r19
    2e30:	b0 f3       	brcs	.-20     	; 0x2e1e <StrPosPaste+0x18>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    2e32:	a4 0f       	add	r26, r20
    2e34:	b5 1f       	adc	r27, r21
    2e36:	a2 0f       	add	r26, r18
    2e38:	b3 1f       	adc	r27, r19
    2e3a:	1c 92       	st	X, r1
}
    2e3c:	df 91       	pop	r29
    2e3e:	cf 91       	pop	r28
    2e40:	1f 91       	pop	r17
    2e42:	0f 91       	pop	r16
    2e44:	08 95       	ret

00002e46 <CharPosCopy>:
char CharPosCopy(char *Source, unsigned int IdxSource){
    2e46:	fb 01       	movw	r30, r22
    2e48:	e8 0f       	add	r30, r24
    2e4a:	f9 1f       	adc	r31, r25
     char Result;
     Result=Source[IdxSource];
	 return Result;
}
    2e4c:	80 81       	ld	r24, Z
    2e4e:	08 95       	ret

00002e50 <procMessage00>:
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
    2e50:	80 91 45 0b 	lds	r24, 0x0B45
    2e54:	81 30       	cpi	r24, 0x01	; 1
    2e56:	51 f4       	brne	.+20     	; 0x2e6c <procMessage00+0x1c>
    2e58:	80 91 9e 01 	lds	r24, 0x019E
    2e5c:	90 91 9f 01 	lds	r25, 0x019F
    2e60:	8f 97       	sbiw	r24, 0x2f	; 47
    2e62:	21 f4       	brne	.+8      	; 0x2e6c <procMessage00+0x1c>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
    2e64:	80 91 6a 0b 	lds	r24, 0x0B6A
    2e68:	80 53       	subi	r24, 0x30	; 48
    2e6a:	08 95       	ret
    2e6c:	80 e0       	ldi	r24, 0x00	; 0
		 //sprintf(strSend,"R=%d",Result);
		 //_uart_print(0,1,strSend);
		 //*/
		 }
     return Result;
}
    2e6e:	08 95       	ret

00002e70 <procMessage09>:
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    2e70:	90 91 6c 0b 	lds	r25, 0x0B6C
    2e74:	20 e0       	ldi	r18, 0x00	; 0
    2e76:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e78:	f9 01       	movw	r30, r18
    2e7a:	e9 51       	subi	r30, 0x19	; 25
    2e7c:	f5 4f       	sbci	r31, 0xF5	; 245
    2e7e:	d9 01       	movw	r26, r18
    2e80:	ab 5b       	subi	r26, 0xBB	; 187
    2e82:	b4 4f       	sbci	r27, 0xF4	; 244
    2e84:	97 96       	adiw	r26, 0x27	; 39
    2e86:	8c 91       	ld	r24, X
    2e88:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e8a:	2f 5f       	subi	r18, 0xFF	; 255
    2e8c:	3f 4f       	sbci	r19, 0xFF	; 255
    2e8e:	24 31       	cpi	r18, 0x14	; 20
    2e90:	31 05       	cpc	r19, r1
    2e92:	91 f7       	brne	.-28     	; 0x2e78 <procMessage09+0x8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e94:	10 92 fb 0a 	sts	0x0AFB, r1
    2e98:	20 e0       	ldi	r18, 0x00	; 0
    2e9a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e9c:	f9 01       	movw	r30, r18
    2e9e:	ea 52       	subi	r30, 0x2A	; 42
    2ea0:	f6 4f       	sbci	r31, 0xF6	; 246
    2ea2:	d9 01       	movw	r26, r18
    2ea4:	ab 5b       	subi	r26, 0xBB	; 187
    2ea6:	b4 4f       	sbci	r27, 0xF4	; 244
    2ea8:	db 96       	adiw	r26, 0x3b	; 59
    2eaa:	8c 91       	ld	r24, X
    2eac:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2eae:	2f 5f       	subi	r18, 0xFF	; 255
    2eb0:	3f 4f       	sbci	r19, 0xFF	; 255
    2eb2:	24 31       	cpi	r18, 0x14	; 20
    2eb4:	31 05       	cpc	r19, r1
    2eb6:	91 f7       	brne	.-28     	; 0x2e9c <procMessage09+0x2c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2eb8:	10 92 ea 09 	sts	0x09EA, r1
    2ebc:	20 e0       	ldi	r18, 0x00	; 0
    2ebe:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ec0:	f9 01       	movw	r30, r18
    2ec2:	ef 58       	subi	r30, 0x8F	; 143
    2ec4:	f5 4f       	sbci	r31, 0xF5	; 245
    2ec6:	d9 01       	movw	r26, r18
    2ec8:	ac 56       	subi	r26, 0x6C	; 108
    2eca:	b4 4f       	sbci	r27, 0xF4	; 244
    2ecc:	8c 91       	ld	r24, X
    2ece:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ed0:	2f 5f       	subi	r18, 0xFF	; 255
    2ed2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ed4:	24 31       	cpi	r18, 0x14	; 20
    2ed6:	31 05       	cpc	r19, r1
    2ed8:	99 f7       	brne	.-26     	; 0x2ec0 <procMessage09+0x50>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2eda:	10 92 85 0a 	sts	0x0A85, r1
    2ede:	20 e0       	ldi	r18, 0x00	; 0
    2ee0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ee2:	f9 01       	movw	r30, r18
    2ee4:	ef 5f       	subi	r30, 0xFF	; 255
    2ee6:	f1 4f       	sbci	r31, 0xF1	; 241
    2ee8:	d9 01       	movw	r26, r18
    2eea:	a8 55       	subi	r26, 0x58	; 88
    2eec:	b4 4f       	sbci	r27, 0xF4	; 244
    2eee:	8c 91       	ld	r24, X
    2ef0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ef2:	2f 5f       	subi	r18, 0xFF	; 255
    2ef4:	3f 4f       	sbci	r19, 0xFF	; 255
    2ef6:	24 31       	cpi	r18, 0x14	; 20
    2ef8:	31 05       	cpc	r19, r1
    2efa:	99 f7       	brne	.-26     	; 0x2ee2 <procMessage09+0x72>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2efc:	10 92 15 0e 	sts	0x0E15, r1
       StrPosCopy(rcv_trans,strFreeMessageLine1,39,20);
       StrPosCopy(rcv_trans,strFreeMessageLine2,59,20);
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}
    2f00:	89 2f       	mov	r24, r25
    2f02:	80 53       	subi	r24, 0x30	; 48
    2f04:	08 95       	ret

00002f06 <procMessage23>:
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}

char procMessage23(){
    2f06:	20 e0       	ldi	r18, 0x00	; 0
    2f08:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f0a:	f9 01       	movw	r30, r18
    2f0c:	ef 54       	subi	r30, 0x4F	; 79
    2f0e:	f2 4f       	sbci	r31, 0xF2	; 242
    2f10:	d9 01       	movw	r26, r18
    2f12:	ab 5b       	subi	r26, 0xBB	; 187
    2f14:	b4 4f       	sbci	r27, 0xF4	; 244
    2f16:	95 96       	adiw	r26, 0x25	; 37
    2f18:	8c 91       	ld	r24, X
    2f1a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f1c:	2f 5f       	subi	r18, 0xFF	; 255
    2f1e:	3f 4f       	sbci	r19, 0xFF	; 255
    2f20:	24 31       	cpi	r18, 0x14	; 20
    2f22:	31 05       	cpc	r19, r1
    2f24:	91 f7       	brne	.-28     	; 0x2f0a <procMessage23+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f26:	10 92 c5 0d 	sts	0x0DC5, r1
    2f2a:	20 e0       	ldi	r18, 0x00	; 0
    2f2c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f2e:	f9 01       	movw	r30, r18
    2f30:	ec 5f       	subi	r30, 0xFC	; 252
    2f32:	fa 4f       	sbci	r31, 0xFA	; 250
    2f34:	d9 01       	movw	r26, r18
    2f36:	ab 5b       	subi	r26, 0xBB	; 187
    2f38:	b4 4f       	sbci	r27, 0xF4	; 244
    2f3a:	d9 96       	adiw	r26, 0x39	; 57
    2f3c:	8c 91       	ld	r24, X
    2f3e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f40:	2f 5f       	subi	r18, 0xFF	; 255
    2f42:	3f 4f       	sbci	r19, 0xFF	; 255
    2f44:	2e 31       	cpi	r18, 0x1E	; 30
    2f46:	31 05       	cpc	r19, r1
    2f48:	91 f7       	brne	.-28     	; 0x2f2e <procMessage23+0x28>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f4a:	10 92 22 05 	sts	0x0522, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f4e:	80 91 9c 0b 	lds	r24, 0x0B9C
    2f52:	80 93 ba 05 	sts	0x05BA, r24
	 }Dest[Length]=0;
    2f56:	10 92 bb 05 	sts	0x05BB, r1
    2f5a:	20 e0       	ldi	r18, 0x00	; 0
    2f5c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f5e:	f9 01       	movw	r30, r18
    2f60:	e6 57       	subi	r30, 0x76	; 118
    2f62:	f5 4f       	sbci	r31, 0xF5	; 245
    2f64:	d9 01       	movw	r26, r18
    2f66:	a3 56       	subi	r26, 0x63	; 99
    2f68:	b4 4f       	sbci	r27, 0xF4	; 244
    2f6a:	8c 91       	ld	r24, X
    2f6c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f6e:	2f 5f       	subi	r18, 0xFF	; 255
    2f70:	3f 4f       	sbci	r19, 0xFF	; 255
    2f72:	28 30       	cpi	r18, 0x08	; 8
    2f74:	31 05       	cpc	r19, r1
    2f76:	99 f7       	brne	.-26     	; 0x2f5e <procMessage23+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f78:	10 92 92 0a 	sts	0x0A92, r1
    2f7c:	20 e0       	ldi	r18, 0x00	; 0
    2f7e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f80:	f9 01       	movw	r30, r18
    2f82:	e2 55       	subi	r30, 0x52	; 82
    2f84:	fa 4f       	sbci	r31, 0xFA	; 250
    2f86:	d9 01       	movw	r26, r18
    2f88:	ab 55       	subi	r26, 0x5B	; 91
    2f8a:	b4 4f       	sbci	r27, 0xF4	; 244
    2f8c:	8c 91       	ld	r24, X
    2f8e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f90:	2f 5f       	subi	r18, 0xFF	; 255
    2f92:	3f 4f       	sbci	r19, 0xFF	; 255
    2f94:	2a 30       	cpi	r18, 0x0A	; 10
    2f96:	31 05       	cpc	r19, r1
    2f98:	99 f7       	brne	.-26     	; 0x2f80 <procMessage23+0x7a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f9a:	10 92 b8 05 	sts	0x05B8, r1
    2f9e:	20 e0       	ldi	r18, 0x00	; 0
    2fa0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fa2:	f9 01       	movw	r30, r18
    2fa4:	e8 5e       	subi	r30, 0xE8	; 232
    2fa6:	f1 4f       	sbci	r31, 0xF1	; 241
    2fa8:	d9 01       	movw	r26, r18
    2faa:	a1 55       	subi	r26, 0x51	; 81
    2fac:	b4 4f       	sbci	r27, 0xF4	; 244
    2fae:	8c 91       	ld	r24, X
    2fb0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fb2:	2f 5f       	subi	r18, 0xFF	; 255
    2fb4:	3f 4f       	sbci	r19, 0xFF	; 255
    2fb6:	2a 30       	cpi	r18, 0x0A	; 10
    2fb8:	31 05       	cpc	r19, r1
    2fba:	99 f7       	brne	.-26     	; 0x2fa2 <procMessage23+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fbc:	10 92 22 0e 	sts	0x0E22, r1
    2fc0:	20 e0       	ldi	r18, 0x00	; 0
    2fc2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fc4:	f9 01       	movw	r30, r18
    2fc6:	e9 51       	subi	r30, 0x19	; 25
    2fc8:	f2 4f       	sbci	r31, 0xF2	; 242
    2fca:	d9 01       	movw	r26, r18
    2fcc:	a7 54       	subi	r26, 0x47	; 71
    2fce:	b4 4f       	sbci	r27, 0xF4	; 244
    2fd0:	8c 91       	ld	r24, X
    2fd2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fd4:	2f 5f       	subi	r18, 0xFF	; 255
    2fd6:	3f 4f       	sbci	r19, 0xFF	; 255
    2fd8:	23 31       	cpi	r18, 0x13	; 19
    2fda:	31 05       	cpc	r19, r1
    2fdc:	99 f7       	brne	.-26     	; 0x2fc4 <procMessage23+0xbe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fde:	10 92 fa 0d 	sts	0x0DFA, r1
    2fe2:	20 e0       	ldi	r18, 0x00	; 0
    2fe4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fe6:	f9 01       	movw	r30, r18
    2fe8:	e5 52       	subi	r30, 0x25	; 37
    2fea:	f2 4f       	sbci	r31, 0xF2	; 242
    2fec:	d9 01       	movw	r26, r18
    2fee:	a4 53       	subi	r26, 0x34	; 52
    2ff0:	b4 4f       	sbci	r27, 0xF4	; 244
    2ff2:	8c 91       	ld	r24, X
    2ff4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ff6:	2f 5f       	subi	r18, 0xFF	; 255
    2ff8:	3f 4f       	sbci	r19, 0xFF	; 255
    2ffa:	27 30       	cpi	r18, 0x07	; 7
    2ffc:	31 05       	cpc	r19, r1
    2ffe:	99 f7       	brne	.-26     	; 0x2fe6 <procMessage23+0xe0>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3000:	10 92 e2 0d 	sts	0x0DE2, r1
    3004:	20 e0       	ldi	r18, 0x00	; 0
    3006:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3008:	f9 01       	movw	r30, r18
    300a:	e5 56       	subi	r30, 0x65	; 101
    300c:	fb 4f       	sbci	r31, 0xFB	; 251
    300e:	d9 01       	movw	r26, r18
    3010:	ad 52       	subi	r26, 0x2D	; 45
    3012:	b4 4f       	sbci	r27, 0xF4	; 244
    3014:	8c 91       	ld	r24, X
    3016:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3018:	2f 5f       	subi	r18, 0xFF	; 255
    301a:	3f 4f       	sbci	r19, 0xFF	; 255
    301c:	24 30       	cpi	r18, 0x04	; 4
    301e:	31 05       	cpc	r19, r1
    3020:	99 f7       	brne	.-26     	; 0x3008 <procMessage23+0x102>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3022:	10 92 9f 04 	sts	0x049F, r1
     StrPosCopy(rcv_trans,strLoyCurrMonConsumeV,106,10);
     StrPosCopy(rcv_trans,strDateTime,116,19);
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}
    3026:	80 e0       	ldi	r24, 0x00	; 0
    3028:	08 95       	ret

0000302a <procMessage81>:
_uart_print(0,1,strCardID);
*/	
     return Result;
}

char procMessage81(){// Result: HFCS0000
    302a:	cf 93       	push	r28
    302c:	df 93       	push	r29
     char Result=0,PrintCopy=0;//
	 char lcdteks[20];
	 //PrintHeader
     if ((CharPosCopy(rcv_trans,37))=='Y') Result=(Result|(1<<7));
    302e:	80 91 6a 0b 	lds	r24, 0x0B6A
    3032:	89 35       	cpi	r24, 0x59	; 89
    3034:	11 f4       	brne	.+4      	; 0x303a <procMessage81+0x10>
    3036:	90 e8       	ldi	r25, 0x80	; 128
    3038:	01 c0       	rjmp	.+2      	; 0x303c <procMessage81+0x12>
    303a:	90 e0       	ldi	r25, 0x00	; 0
     //PrintFooter
	 if ((CharPosCopy(rcv_trans,38))=='Y') Result=(Result|(1<<6));
    303c:	80 91 6b 0b 	lds	r24, 0x0B6B
    3040:	89 35       	cpi	r24, 0x59	; 89
    3042:	09 f4       	brne	.+2      	; 0x3046 <procMessage81+0x1c>
    3044:	90 64       	ori	r25, 0x40	; 64
	 //PaperCut
     if ((CharPosCopy(rcv_trans,39))=='Y') Result=(Result|(1<<5));
    3046:	80 91 6c 0b 	lds	r24, 0x0B6C
    304a:	89 35       	cpi	r24, 0x59	; 89
    304c:	09 f4       	brne	.+2      	; 0x3050 <procMessage81+0x26>
    304e:	90 62       	ori	r25, 0x20	; 32
	 //Scrool
	 Result=(Result|(1<<4));
    3050:	90 61       	ori	r25, 0x10	; 16

	 //Copies
	 PrintCopy=(CharPosCopy(rcv_trans,40)-'0');
    3052:	80 91 6d 0b 	lds	r24, 0x0B6D
    3056:	80 53       	subi	r24, 0x30	; 48
     if (PrintCopy<=16) Result=Result|PrintCopy;
    3058:	81 31       	cpi	r24, 0x11	; 17
    305a:	08 f4       	brcc	.+2      	; 0x305e <procMessage81+0x34>
    305c:	98 2b       	or	r25, r24
	 //Spooling
     StrPosCopy(rcv_trans,PrintBuffer,44,LengthMessage81);
    305e:	c0 91 a0 01 	lds	r28, 0x01A0
    3062:	d0 91 a1 01 	lds	r29, 0x01A1
    3066:	20 e0       	ldi	r18, 0x00	; 0
    3068:	30 e0       	ldi	r19, 0x00	; 0
    306a:	0b c0       	rjmp	.+22     	; 0x3082 <procMessage81+0x58>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    306c:	f9 01       	movw	r30, r18
    306e:	e1 5e       	subi	r30, 0xE1	; 225
    3070:	f9 4f       	sbci	r31, 0xF9	; 249
    3072:	d9 01       	movw	r26, r18
    3074:	ab 5b       	subi	r26, 0xBB	; 187
    3076:	b4 4f       	sbci	r27, 0xF4	; 244
    3078:	9c 96       	adiw	r26, 0x2c	; 44
    307a:	8c 91       	ld	r24, X
    307c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    307e:	2f 5f       	subi	r18, 0xFF	; 255
    3080:	3f 4f       	sbci	r19, 0xFF	; 255
    3082:	2c 17       	cp	r18, r28
    3084:	3d 07       	cpc	r19, r29
    3086:	90 f3       	brcs	.-28     	; 0x306c <procMessage81+0x42>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3088:	c1 5e       	subi	r28, 0xE1	; 225
    308a:	d9 4f       	sbci	r29, 0xF9	; 249
    308c:	18 82       	st	Y, r1
	 //sprintf(lcdteks,"cmdPrint:%d ",Result);
     //_uart_print(0,1,lcdteks);

	 //while(1){};
	 return Result;
}
    308e:	89 2f       	mov	r24, r25
    3090:	df 91       	pop	r29
    3092:	cf 91       	pop	r28
    3094:	08 95       	ret

00003096 <FillChar>:
	 if(CutType== 1) { _uart(_COM_PRINTER, 1, 0x6D);}
	 if(CutType== 2) {_uart(_COM_PRINTER, 1, 0x69);}

}

void FillChar(char *strMemory, unsigned int Length,char data){
    3096:	20 e0       	ldi	r18, 0x00	; 0
    3098:	30 e0       	ldi	r19, 0x00	; 0
    309a:	06 c0       	rjmp	.+12     	; 0x30a8 <FillChar+0x12>
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    309c:	fc 01       	movw	r30, r24
    309e:	e2 0f       	add	r30, r18
    30a0:	f3 1f       	adc	r31, r19
    30a2:	40 83       	st	Z, r20

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    30a4:	2f 5f       	subi	r18, 0xFF	; 255
    30a6:	3f 4f       	sbci	r19, 0xFF	; 255
    30a8:	26 17       	cp	r18, r22
    30aa:	37 07       	cpc	r19, r23
    30ac:	b8 f3       	brcs	.-18     	; 0x309c <FillChar+0x6>
	     strMemory[i]=data;
	 }
}
    30ae:	08 95       	ret

000030b0 <ProcMessage91>:

void ProcMessage91(){
    30b0:	20 e0       	ldi	r18, 0x00	; 0
    30b2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30b4:	f9 01       	movw	r30, r18
    30b6:	ef 54       	subi	r30, 0x4F	; 79
    30b8:	f1 4f       	sbci	r31, 0xF1	; 241
    30ba:	d9 01       	movw	r26, r18
    30bc:	ab 5b       	subi	r26, 0xBB	; 187
    30be:	b4 4f       	sbci	r27, 0xF4	; 244
    30c0:	95 96       	adiw	r26, 0x25	; 37
    30c2:	8c 91       	ld	r24, X
    30c4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    30c6:	2f 5f       	subi	r18, 0xFF	; 255
    30c8:	3f 4f       	sbci	r19, 0xFF	; 255
    30ca:	26 30       	cpi	r18, 0x06	; 6
    30cc:	31 05       	cpc	r19, r1
    30ce:	91 f7       	brne	.-28     	; 0x30b4 <ProcMessage91+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    30d0:	10 92 b7 0e 	sts	0x0EB7, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30d4:	80 91 70 0b 	lds	r24, 0x0B70
    30d8:	80 93 ec 09 	sts	0x09EC, r24
    30dc:	80 91 71 0b 	lds	r24, 0x0B71
    30e0:	80 93 ed 09 	sts	0x09ED, r24
	 }Dest[Length]=0;
    30e4:	10 92 ee 09 	sts	0x09EE, r1
    30e8:	20 e0       	ldi	r18, 0x00	; 0
    30ea:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30ec:	f9 01       	movw	r30, r18
    30ee:	ef 59       	subi	r30, 0x9F	; 159
    30f0:	f5 4f       	sbci	r31, 0xF5	; 245
    30f2:	d9 01       	movw	r26, r18
    30f4:	ab 5b       	subi	r26, 0xBB	; 187
    30f6:	b4 4f       	sbci	r27, 0xF4	; 244
    30f8:	9d 96       	adiw	r26, 0x2d	; 45
    30fa:	8c 91       	ld	r24, X
    30fc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    30fe:	2f 5f       	subi	r18, 0xFF	; 255
    3100:	3f 4f       	sbci	r19, 0xFF	; 255
    3102:	2f 30       	cpi	r18, 0x0F	; 15
    3104:	31 05       	cpc	r19, r1
    3106:	91 f7       	brne	.-28     	; 0x30ec <ProcMessage91+0x3c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3108:	10 92 70 0a 	sts	0x0A70, r1
    310c:	20 e0       	ldi	r18, 0x00	; 0
    310e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3110:	f9 01       	movw	r30, r18
    3112:	ef 52       	subi	r30, 0x2F	; 47
    3114:	f8 4f       	sbci	r31, 0xF8	; 248
    3116:	d9 01       	movw	r26, r18
    3118:	ab 5b       	subi	r26, 0xBB	; 187
    311a:	b4 4f       	sbci	r27, 0xF4	; 244
    311c:	dc 96       	adiw	r26, 0x3c	; 60
    311e:	8c 91       	ld	r24, X
    3120:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3122:	2f 5f       	subi	r18, 0xFF	; 255
    3124:	3f 4f       	sbci	r19, 0xFF	; 255
    3126:	26 30       	cpi	r18, 0x06	; 6
    3128:	31 05       	cpc	r19, r1
    312a:	91 f7       	brne	.-28     	; 0x3110 <ProcMessage91+0x60>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    312c:	10 92 d7 07 	sts	0x07D7, r1
    3130:	20 e0       	ldi	r18, 0x00	; 0
    3132:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3134:	f9 01       	movw	r30, r18
    3136:	eb 5a       	subi	r30, 0xAB	; 171
    3138:	fa 4f       	sbci	r31, 0xFA	; 250
    313a:	d9 01       	movw	r26, r18
    313c:	a9 57       	subi	r26, 0x79	; 121
    313e:	b4 4f       	sbci	r27, 0xF4	; 244
    3140:	8c 91       	ld	r24, X
    3142:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3144:	2f 5f       	subi	r18, 0xFF	; 255
    3146:	3f 4f       	sbci	r19, 0xFF	; 255
    3148:	28 30       	cpi	r18, 0x08	; 8
    314a:	31 05       	cpc	r19, r1
    314c:	99 f7       	brne	.-26     	; 0x3134 <ProcMessage91+0x84>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    314e:	10 92 5d 05 	sts	0x055D, r1
    3152:	20 e0       	ldi	r18, 0x00	; 0
    3154:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3156:	f9 01       	movw	r30, r18
    3158:	e5 52       	subi	r30, 0x25	; 37
    315a:	f2 4f       	sbci	r31, 0xF2	; 242
    315c:	d9 01       	movw	r26, r18
    315e:	a1 57       	subi	r26, 0x71	; 113
    3160:	b4 4f       	sbci	r27, 0xF4	; 244
    3162:	8c 91       	ld	r24, X
    3164:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3166:	2f 5f       	subi	r18, 0xFF	; 255
    3168:	3f 4f       	sbci	r19, 0xFF	; 255
    316a:	28 30       	cpi	r18, 0x08	; 8
    316c:	31 05       	cpc	r19, r1
    316e:	99 f7       	brne	.-26     	; 0x3156 <ProcMessage91+0xa6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3170:	10 92 e3 0d 	sts	0x0DE3, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3174:	80 91 97 0b 	lds	r24, 0x0B97
    3178:	80 93 ba 05 	sts	0x05BA, r24
	 }Dest[Length]=0;
    317c:	10 92 bb 05 	sts	0x05BB, r1
    3180:	20 e0       	ldi	r18, 0x00	; 0
    3182:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3184:	f9 01       	movw	r30, r18
    3186:	e4 52       	subi	r30, 0x24	; 36
    3188:	fb 4f       	sbci	r31, 0xFB	; 251
    318a:	d9 01       	movw	r26, r18
    318c:	a8 56       	subi	r26, 0x68	; 104
    318e:	b4 4f       	sbci	r27, 0xF4	; 244
    3190:	8c 91       	ld	r24, X
    3192:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3194:	2f 5f       	subi	r18, 0xFF	; 255
    3196:	3f 4f       	sbci	r19, 0xFF	; 255
    3198:	29 30       	cpi	r18, 0x09	; 9
    319a:	31 05       	cpc	r19, r1
    319c:	99 f7       	brne	.-26     	; 0x3184 <ProcMessage91+0xd4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    319e:	10 92 e5 04 	sts	0x04E5, r1
     StrPosCopy(rcv_trans,strPrice,60,6);
     StrPosCopy(rcv_trans,strVolume,66,8);
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}
    31a2:	08 95       	ret

000031a4 <IdentifyMessage>:
        //sprintf_P(strSerial,PSTR("RFID:%s"),strRFID);
        //_uart_print(0,1,strSerial);
	 }
}

void IdentifyMessage(char STX,unsigned int Length){
    31a4:	1f 93       	push	r17
   if (STX==0x01){
    31a6:	81 30       	cpi	r24, 0x01	; 1
    31a8:	09 f0       	breq	.+2      	; 0x31ac <IdentifyMessage+0x8>
    31aa:	5f c0       	rjmp	.+190    	; 0x326a <IdentifyMessage+0xc6>
	    if ((Length==MSG00_LENGTH)||(MsgCode==0)) IsMessage00=True;//47
    31ac:	6f 32       	cpi	r22, 0x2F	; 47
    31ae:	71 05       	cpc	r23, r1
    31b0:	21 f0       	breq	.+8      	; 0x31ba <IdentifyMessage+0x16>
    31b2:	80 91 24 01 	lds	r24, 0x0124
    31b6:	88 23       	and	r24, r24
    31b8:	21 f4       	brne	.+8      	; 0x31c2 <IdentifyMessage+0x1e>
    31ba:	81 e0       	ldi	r24, 0x01	; 1
    31bc:	80 93 b5 01 	sts	0x01B5, r24
    31c0:	4a c0       	rjmp	.+148    	; 0x3256 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG09_LENGTH)||(MsgCode==9)) IsMessage09=True;//615
    31c2:	6c 36       	cpi	r22, 0x6C	; 108
    31c4:	71 05       	cpc	r23, r1
    31c6:	11 f0       	breq	.+4      	; 0x31cc <IdentifyMessage+0x28>
    31c8:	89 30       	cpi	r24, 0x09	; 9
    31ca:	21 f4       	brne	.+8      	; 0x31d4 <IdentifyMessage+0x30>
    31cc:	81 e0       	ldi	r24, 0x01	; 1
    31ce:	80 93 ba 01 	sts	0x01BA, r24
    31d2:	41 c0       	rjmp	.+130    	; 0x3256 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG11_LENGTH)||(MsgCode==11)) IsMessage11=True;//615
    31d4:	92 e0       	ldi	r25, 0x02	; 2
    31d6:	67 36       	cpi	r22, 0x67	; 103
    31d8:	79 07       	cpc	r23, r25
    31da:	11 f0       	breq	.+4      	; 0x31e0 <IdentifyMessage+0x3c>
    31dc:	8b 30       	cpi	r24, 0x0B	; 11
    31de:	21 f4       	brne	.+8      	; 0x31e8 <IdentifyMessage+0x44>
    31e0:	81 e0       	ldi	r24, 0x01	; 1
    31e2:	80 93 b7 01 	sts	0x01B7, r24
    31e6:	37 c0       	rjmp	.+110    	; 0x3256 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG23_LENGTH)||(MsgCode==23)) IsMessage23=True;//145
    31e8:	61 39       	cpi	r22, 0x91	; 145
    31ea:	71 05       	cpc	r23, r1
    31ec:	11 f0       	breq	.+4      	; 0x31f2 <IdentifyMessage+0x4e>
    31ee:	87 31       	cpi	r24, 0x17	; 23
    31f0:	21 f4       	brne	.+8      	; 0x31fa <IdentifyMessage+0x56>
    31f2:	81 e0       	ldi	r24, 0x01	; 1
    31f4:	80 93 b9 01 	sts	0x01B9, r24
    31f8:	2e c0       	rjmp	.+92     	; 0x3256 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG57_LENGTH)||(MsgCode==57)) IsMessage57=True;//230
    31fa:	66 3e       	cpi	r22, 0xE6	; 230
    31fc:	71 05       	cpc	r23, r1
    31fe:	11 f0       	breq	.+4      	; 0x3204 <IdentifyMessage+0x60>
    3200:	89 33       	cpi	r24, 0x39	; 57
    3202:	21 f4       	brne	.+8      	; 0x320c <IdentifyMessage+0x68>
    3204:	81 e0       	ldi	r24, 0x01	; 1
    3206:	80 93 bc 01 	sts	0x01BC, r24
    320a:	25 c0       	rjmp	.+74     	; 0x3256 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG99_LENGTH)||(MsgCode==99)) IsMessage99=True;//378
    320c:	91 e0       	ldi	r25, 0x01	; 1
    320e:	68 39       	cpi	r22, 0x98	; 152
    3210:	79 07       	cpc	r23, r25
    3212:	11 f0       	breq	.+4      	; 0x3218 <IdentifyMessage+0x74>
    3214:	83 36       	cpi	r24, 0x63	; 99
    3216:	21 f4       	brne	.+8      	; 0x3220 <IdentifyMessage+0x7c>
    3218:	81 e0       	ldi	r24, 0x01	; 1
    321a:	80 93 b6 01 	sts	0x01B6, r24
    321e:	1b c0       	rjmp	.+54     	; 0x3256 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG81_LENGTH)||(MsgCode==81)) IsMessage81=True;//426
    3220:	91 e0       	ldi	r25, 0x01	; 1
    3222:	66 3b       	cpi	r22, 0xB6	; 182
    3224:	79 07       	cpc	r23, r25
    3226:	11 f0       	breq	.+4      	; 0x322c <IdentifyMessage+0x88>
    3228:	81 35       	cpi	r24, 0x51	; 81
    322a:	21 f4       	brne	.+8      	; 0x3234 <IdentifyMessage+0x90>
    322c:	81 e0       	ldi	r24, 0x01	; 1
    322e:	80 93 bd 01 	sts	0x01BD, r24
    3232:	11 c0       	rjmp	.+34     	; 0x3256 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG91_LENGTH)||(MsgCode==91)) IsMessage91=True;//426
    3234:	6c 35       	cpi	r22, 0x5C	; 92
    3236:	71 05       	cpc	r23, r1
    3238:	11 f0       	breq	.+4      	; 0x323e <IdentifyMessage+0x9a>
    323a:	8b 35       	cpi	r24, 0x5B	; 91
    323c:	21 f4       	brne	.+8      	; 0x3246 <IdentifyMessage+0xa2>
    323e:	81 e0       	ldi	r24, 0x01	; 1
    3240:	80 93 be 01 	sts	0x01BE, r24
    3244:	08 c0       	rjmp	.+16     	; 0x3256 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG21_LENGTH)||(MsgCode==21)) IsMessage21=True;//426
    3246:	66 35       	cpi	r22, 0x56	; 86
    3248:	71 05       	cpc	r23, r1
    324a:	11 f0       	breq	.+4      	; 0x3250 <IdentifyMessage+0xac>
    324c:	85 31       	cpi	r24, 0x15	; 21
    324e:	19 f4       	brne	.+6      	; 0x3256 <IdentifyMessage+0xb2>
    3250:	81 e0       	ldi	r24, 0x01	; 1
    3252:	80 93 b8 01 	sts	0x01B8, r24

        //EDC AdvanZ Respond
		if (IsMessage91==True){
    3256:	10 91 be 01 	lds	r17, 0x01BE
    325a:	11 30       	cpi	r17, 0x01	; 1
    325c:	31 f4       	brne	.+12     	; 0x326a <IdentifyMessage+0xc6>
		    IsMessage91=False;
    325e:	10 92 be 01 	sts	0x01BE, r1
		    ProcMessage91();
    3262:	0e 94 58 18 	call	0x30b0	; 0x30b0 <ProcMessage91>
			IsSendMessageEDC=True;
    3266:	10 93 ae 01 	sts	0x01AE, r17
		  }

//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  _uart_print(1,0,SerialSend);
	 }
}
    326a:	1f 91       	pop	r17
    326c:	08 95       	ret

0000326e <Tab>:

	  }
     return Result;     
}

void Tab(char *sTab, char nTab){
    326e:	fc 01       	movw	r30, r24
    3270:	dc 01       	movw	r26, r24
    3272:	80 e0       	ldi	r24, 0x00	; 0
     char i;
	 for(i=0;i<nTab;i++){
	     sTab[i]=' ';
    3274:	90 e2       	ldi	r25, 0x20	; 32
    3276:	02 c0       	rjmp	.+4      	; 0x327c <Tab+0xe>
    3278:	9d 93       	st	X+, r25
     return Result;     
}

void Tab(char *sTab, char nTab){
     char i;
	 for(i=0;i<nTab;i++){
    327a:	8f 5f       	subi	r24, 0xFF	; 255
    327c:	86 17       	cp	r24, r22
    327e:	e0 f3       	brcs	.-8      	; 0x3278 <Tab+0xa>
	     sTab[i]=' ';
	 }sTab[nTab]=0;
    3280:	e6 0f       	add	r30, r22
    3282:	f1 1d       	adc	r31, r1
    3284:	10 82       	st	Z, r1
}
    3286:	08 95       	ret

00003288 <_f_inttostr>:
}



//Old Function
void _f_inttostr(char* __string, unsigned long __value){
    3288:	6f 92       	push	r6
    328a:	7f 92       	push	r7
    328c:	8f 92       	push	r8
    328e:	9f 92       	push	r9
    3290:	af 92       	push	r10
    3292:	bf 92       	push	r11
    3294:	cf 92       	push	r12
    3296:	df 92       	push	r13
    3298:	ef 92       	push	r14
    329a:	ff 92       	push	r15
    329c:	0f 93       	push	r16
    329e:	1f 93       	push	r17
    32a0:	cf 93       	push	r28
    32a2:	df 93       	push	r29
    32a4:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
    32a6:	41 15       	cp	r20, r1
    32a8:	51 05       	cpc	r21, r1
    32aa:	61 05       	cpc	r22, r1
    32ac:	71 05       	cpc	r23, r1
    32ae:	21 f4       	brne	.+8      	; 0x32b8 <_f_inttostr+0x30>
		__string[0] = '0';
    32b0:	80 e3       	ldi	r24, 0x30	; 48
    32b2:	88 83       	st	Y, r24
		__string[1] = '\0';
    32b4:	19 82       	std	Y+1, r1	; 0x01
    32b6:	48 c0       	rjmp	.+144    	; 0x3348 <_f_inttostr+0xc0>
		return;
    32b8:	4a 01       	movw	r8, r20
    32ba:	5b 01       	movw	r10, r22
    32bc:	10 e0       	ldi	r17, 0x00	; 0
    32be:	00 e0       	ldi	r16, 0x00	; 0
    32c0:	77 24       	eor	r7, r7
    32c2:	c1 2c       	mov	r12, r1
    32c4:	9a ec       	ldi	r25, 0xCA	; 202
    32c6:	d9 2e       	mov	r13, r25
    32c8:	9a e9       	ldi	r25, 0x9A	; 154
    32ca:	e9 2e       	mov	r14, r25
    32cc:	9b e3       	ldi	r25, 0x3B	; 59
    32ce:	f9 2e       	mov	r15, r25
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
    32d0:	80 e3       	ldi	r24, 0x30	; 48
    32d2:	68 2e       	mov	r6, r24
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
    32d4:	8c 14       	cp	r8, r12
    32d6:	9d 04       	cpc	r9, r13
    32d8:	ae 04       	cpc	r10, r14
    32da:	bf 04       	cpc	r11, r15
    32dc:	d0 f0       	brcs	.+52     	; 0x3312 <_f_inttostr+0x8a>
			__tmp = (int)(__num / __devider);
    32de:	c5 01       	movw	r24, r10
    32e0:	b4 01       	movw	r22, r8
    32e2:	a7 01       	movw	r20, r14
    32e4:	96 01       	movw	r18, r12
    32e6:	0e 94 34 b7 	call	0x16e68	; 0x16e68 <__udivmodsi4>
    32ea:	12 2f       	mov	r17, r18
			__num = __num % __devider;
    32ec:	c5 01       	movw	r24, r10
    32ee:	b4 01       	movw	r22, r8
    32f0:	a7 01       	movw	r20, r14
    32f2:	96 01       	movw	r18, r12
    32f4:	0e 94 34 b7 	call	0x16e68	; 0x16e68 <__udivmodsi4>
    32f8:	ac 01       	movw	r20, r24
    32fa:	cb 01       	movw	r24, r22
    32fc:	da 01       	movw	r26, r20
    32fe:	4c 01       	movw	r8, r24
    3300:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
    3302:	fe 01       	movw	r30, r28
    3304:	e0 0f       	add	r30, r16
    3306:	f1 1d       	adc	r31, r1
    3308:	10 5d       	subi	r17, 0xD0	; 208
    330a:	10 83       	st	Z, r17
    330c:	0f 5f       	subi	r16, 0xFF	; 255
    330e:	11 e0       	ldi	r17, 0x01	; 1
    3310:	07 c0       	rjmp	.+14     	; 0x3320 <_f_inttostr+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
    3312:	11 23       	and	r17, r17
    3314:	29 f0       	breq	.+10     	; 0x3320 <_f_inttostr+0x98>
				__string[__i++] = 0x30;
    3316:	fe 01       	movw	r30, r28
    3318:	e0 0f       	add	r30, r16
    331a:	f1 1d       	adc	r31, r1
    331c:	60 82       	st	Z, r6
    331e:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
    3320:	73 94       	inc	r7
    3322:	8a e0       	ldi	r24, 0x0A	; 10
    3324:	78 16       	cp	r7, r24
    3326:	69 f0       	breq	.+26     	; 0x3342 <_f_inttostr+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
    3328:	c7 01       	movw	r24, r14
    332a:	b6 01       	movw	r22, r12
    332c:	2a e0       	ldi	r18, 0x0A	; 10
    332e:	30 e0       	ldi	r19, 0x00	; 0
    3330:	40 e0       	ldi	r20, 0x00	; 0
    3332:	50 e0       	ldi	r21, 0x00	; 0
    3334:	0e 94 34 b7 	call	0x16e68	; 0x16e68 <__udivmodsi4>
    3338:	c9 01       	movw	r24, r18
    333a:	da 01       	movw	r26, r20
    333c:	6c 01       	movw	r12, r24
    333e:	7d 01       	movw	r14, r26
    3340:	c9 cf       	rjmp	.-110    	; 0x32d4 <_f_inttostr+0x4c>
	}
	__string[__i] = '\0';
    3342:	c0 0f       	add	r28, r16
    3344:	d1 1d       	adc	r29, r1
    3346:	18 82       	st	Y, r1
}
    3348:	df 91       	pop	r29
    334a:	cf 91       	pop	r28
    334c:	1f 91       	pop	r17
    334e:	0f 91       	pop	r16
    3350:	ff 90       	pop	r15
    3352:	ef 90       	pop	r14
    3354:	df 90       	pop	r13
    3356:	cf 90       	pop	r12
    3358:	bf 90       	pop	r11
    335a:	af 90       	pop	r10
    335c:	9f 90       	pop	r9
    335e:	8f 90       	pop	r8
    3360:	7f 90       	pop	r7
    3362:	6f 90       	pop	r6
    3364:	08 95       	ret

00003366 <StrToRaw>:
			  }
		  }
	 }
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
    3366:	dc 01       	movw	r26, r24
    3368:	20 e0       	ldi	r18, 0x00	; 0
    336a:	30 e0       	ldi	r19, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    336c:	9c 91       	ld	r25, X
    336e:	90 53       	subi	r25, 0x30	; 48
    3370:	9a 30       	cpi	r25, 0x0A	; 10
    3372:	08 f0       	brcs	.+2      	; 0x3376 <StrToRaw+0x10>
    3374:	90 e0       	ldi	r25, 0x00	; 0
	 char xRaw=0;
	 for (i=0;i<6;i++){
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
    3376:	11 96       	adiw	r26, 0x01	; 1
    3378:	8c 91       	ld	r24, X
    337a:	11 97       	sbiw	r26, 0x01	; 1
    337c:	80 53       	subi	r24, 0x30	; 48
    337e:	8a 30       	cpi	r24, 0x0A	; 10
    3380:	08 f0       	brcs	.+2      	; 0x3384 <StrToRaw+0x1e>
    3382:	80 e0       	ldi	r24, 0x00	; 0
    3384:	fb 01       	movw	r30, r22
    3386:	e2 0f       	add	r30, r18
    3388:	f3 1f       	adc	r31, r19
    338a:	8f 70       	andi	r24, 0x0F	; 15
    338c:	92 95       	swap	r25
    338e:	90 7f       	andi	r25, 0xF0	; 240
    3390:	98 2b       	or	r25, r24
    3392:	90 83       	st	Z, r25
    3394:	2f 5f       	subi	r18, 0xFF	; 255
    3396:	3f 4f       	sbci	r19, 0xFF	; 255
    3398:	12 96       	adiw	r26, 0x02	; 2
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
     char i,xA,xB;                //Dest  :  12345678 
	 char xRaw=0;
	 for (i=0;i<6;i++){
    339a:	26 30       	cpi	r18, 0x06	; 6
    339c:	31 05       	cpc	r19, r1
    339e:	31 f7       	brne	.-52     	; 0x336c <StrToRaw+0x6>
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
	 }	      
}
    33a0:	08 95       	ret

000033a2 <RawToStr>:
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
    33a2:	cf 93       	push	r28
    33a4:	df 93       	push	r29
    33a6:	eb 01       	movw	r28, r22
    33a8:	db 01       	movw	r26, r22
    33aa:	20 e0       	ldi	r18, 0x00	; 0
    33ac:	30 e0       	ldi	r19, 0x00	; 0
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
    33ae:	fc 01       	movw	r30, r24
    33b0:	e2 0f       	add	r30, r18
    33b2:	f3 1f       	adc	r31, r19
    33b4:	e0 81       	ld	r30, Z
    33b6:	4e 2f       	mov	r20, r30
    33b8:	42 95       	swap	r20
    33ba:	4f 70       	andi	r20, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    33bc:	4a 30       	cpi	r20, 0x0A	; 10
    33be:	10 f0       	brcs	.+4      	; 0x33c4 <RawToStr+0x22>
    33c0:	40 e3       	ldi	r20, 0x30	; 48
    33c2:	01 c0       	rjmp	.+2      	; 0x33c6 <RawToStr+0x24>
	    Result='0'+X;
    33c4:	40 5d       	subi	r20, 0xD0	; 208
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
    33c6:	ef 70       	andi	r30, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    33c8:	ea 30       	cpi	r30, 0x0A	; 10
    33ca:	10 f0       	brcs	.+4      	; 0x33d0 <RawToStr+0x2e>
    33cc:	e0 e3       	ldi	r30, 0x30	; 48
    33ce:	01 c0       	rjmp	.+2      	; 0x33d2 <RawToStr+0x30>
	    Result='0'+X;
    33d0:	e0 5d       	subi	r30, 0xD0	; 208
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
    33d2:	4c 93       	st	X, r20
          Dest[(2*i)+1]=cB;
    33d4:	11 96       	adiw	r26, 0x01	; 1
    33d6:	ec 93       	st	X, r30
    33d8:	11 97       	sbiw	r26, 0x01	; 1
    33da:	2f 5f       	subi	r18, 0xFF	; 255
    33dc:	3f 4f       	sbci	r19, 0xFF	; 255
    33de:	12 96       	adiw	r26, 0x02	; 2
	      Dest[i]=xRaw;
	 }	      
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
    33e0:	26 30       	cpi	r18, 0x06	; 6
    33e2:	31 05       	cpc	r19, r1
    33e4:	21 f7       	brne	.-56     	; 0x33ae <RawToStr+0xc>
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
          Dest[(2*i)+1]=cB;
	 }Dest[12]=0;
    33e6:	1c 86       	std	Y+12, r1	; 0x0c
}
    33e8:	df 91       	pop	r29
    33ea:	cf 91       	pop	r28
    33ec:	08 95       	ret

000033ee <CalcMinus>:
}

char CalcMinus(char A, char B){
     signed char xC;//,xA,xB;
	 char Result;
	 if (A>=B) xC=((A-'0')-(B-'0'));
    33ee:	86 17       	cp	r24, r22
    33f0:	08 f4       	brcc	.+2      	; 0x33f4 <CalcMinus+0x6>
	 else xC=10+((A-'0')-(B-'0'));//
    33f2:	86 5f       	subi	r24, 0xF6	; 246
    33f4:	86 1b       	sub	r24, r22
	 Result='0'+xC;
  return Result;
}
    33f6:	80 5d       	subi	r24, 0xD0	; 208
    33f8:	08 95       	ret

000033fa <CalcPlus>:

char CalcPlus(char A, char B){
    33fa:	80 56       	subi	r24, 0x60	; 96
    33fc:	86 0f       	add	r24, r22
    33fe:	6a e0       	ldi	r22, 0x0A	; 10
    3400:	0e 94 00 b7 	call	0x16e00	; 0x16e00 <__divmodqi4>
     signed char xA,xB,xC;
	 char Result;
	 xC=((A-'0')+(B-'0'));
     Result='0'+(xC%10);  
   return Result;
}
    3404:	89 2f       	mov	r24, r25
    3406:	80 5d       	subi	r24, 0xD0	; 208
    3408:	08 95       	ret

0000340a <Chr>:
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    340a:	8a 30       	cpi	r24, 0x0A	; 10
    340c:	10 f0       	brcs	.+4      	; 0x3412 <Chr+0x8>
    340e:	80 e3       	ldi	r24, 0x30	; 48
    3410:	08 95       	ret
	    Result='0'+X;
    3412:	80 5d       	subi	r24, 0xD0	; 208
	 }
	return Result;
}
    3414:	08 95       	ret

00003416 <Ord>:
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    3416:	80 53       	subi	r24, 0x30	; 48
    3418:	8a 30       	cpi	r24, 0x0A	; 10
    341a:	08 f0       	brcs	.+2      	; 0x341e <Ord+0x8>
    341c:	80 e0       	ldi	r24, 0x00	; 0
	    Result=c-'0';
	 }
	return Result;
}
    341e:	08 95       	ret

00003420 <GetTabSpace>:
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
    3420:	48 2f       	mov	r20, r24
    3422:	fb 01       	movw	r30, r22
     char i,nTab;
	 if (TabLength>0){
    3424:	18 16       	cp	r1, r24
    3426:	64 f4       	brge	.+24     	; 0x3440 <GetTabSpace+0x20>
		 nTab=TabLength;//%40;
    3428:	56 2f       	mov	r21, r22
    342a:	db 01       	movw	r26, r22
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    342c:	90 e2       	ldi	r25, 0x20	; 32
    342e:	9d 93       	st	X+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    3430:	8a 2f       	mov	r24, r26
    3432:	85 1b       	sub	r24, r21
    3434:	84 17       	cp	r24, r20
    3436:	d8 f3       	brcs	.-10     	; 0x342e <GetTabSpace+0xe>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    3438:	e4 0f       	add	r30, r20
    343a:	f1 1d       	adc	r31, r1
    343c:	10 82       	st	Z, r1
    343e:	08 95       	ret
     }else{
	 strTab[0]=' ';
    3440:	80 e2       	ldi	r24, 0x20	; 32
    3442:	80 83       	st	Z, r24
	 strTab[1]=0;
    3444:	11 82       	std	Z+1, r1	; 0x01
    3446:	08 95       	ret

00003448 <GetBorderValue>:

}

char GetBorderValue(char BoderType){
     char Result=0;
	 switch (BoderType){
    3448:	86 30       	cpi	r24, 0x06	; 6
    344a:	51 f1       	breq	.+84     	; 0x34a0 <GetBorderValue+0x58>
    344c:	87 30       	cpi	r24, 0x07	; 7
    344e:	70 f4       	brcc	.+28     	; 0x346c <GetBorderValue+0x24>
    3450:	83 30       	cpi	r24, 0x03	; 3
    3452:	11 f1       	breq	.+68     	; 0x3498 <GetBorderValue+0x50>
    3454:	84 30       	cpi	r24, 0x04	; 4
    3456:	28 f4       	brcc	.+10     	; 0x3462 <GetBorderValue+0x1a>
    3458:	81 30       	cpi	r24, 0x01	; 1
    345a:	c1 f0       	breq	.+48     	; 0x348c <GetBorderValue+0x44>
    345c:	82 30       	cpi	r24, 0x02	; 2
    345e:	c1 f4       	brne	.+48     	; 0x3490 <GetBorderValue+0x48>
    3460:	19 c0       	rjmp	.+50     	; 0x3494 <GetBorderValue+0x4c>
    3462:	84 30       	cpi	r24, 0x04	; 4
    3464:	d9 f0       	breq	.+54     	; 0x349c <GetBorderValue+0x54>
    3466:	85 30       	cpi	r24, 0x05	; 5
    3468:	99 f4       	brne	.+38     	; 0x3490 <GetBorderValue+0x48>
    346a:	22 c0       	rjmp	.+68     	; 0x34b0 <GetBorderValue+0x68>
    346c:	89 30       	cpi	r24, 0x09	; 9
    346e:	f1 f0       	breq	.+60     	; 0x34ac <GetBorderValue+0x64>
    3470:	8a 30       	cpi	r24, 0x0A	; 10
    3472:	28 f4       	brcc	.+10     	; 0x347e <GetBorderValue+0x36>
    3474:	87 30       	cpi	r24, 0x07	; 7
    3476:	b1 f0       	breq	.+44     	; 0x34a4 <GetBorderValue+0x5c>
    3478:	88 30       	cpi	r24, 0x08	; 8
    347a:	51 f4       	brne	.+20     	; 0x3490 <GetBorderValue+0x48>
    347c:	15 c0       	rjmp	.+42     	; 0x34a8 <GetBorderValue+0x60>
    347e:	8b 30       	cpi	r24, 0x0B	; 11
    3480:	d9 f0       	breq	.+54     	; 0x34b8 <GetBorderValue+0x70>
    3482:	8b 30       	cpi	r24, 0x0B	; 11
    3484:	b8 f0       	brcs	.+46     	; 0x34b4 <GetBorderValue+0x6c>
    3486:	8c 30       	cpi	r24, 0x0C	; 12
    3488:	19 f4       	brne	.+6      	; 0x3490 <GetBorderValue+0x48>
    348a:	18 c0       	rjmp	.+48     	; 0x34bc <GetBorderValue+0x74>
    348c:	8a ed       	ldi	r24, 0xDA	; 218
    348e:	08 95       	ret
    3490:	80 e0       	ldi	r24, 0x00	; 0
    3492:	08 95       	ret
    3494:	82 ec       	ldi	r24, 0xC2	; 194
    3496:	08 95       	ret
		case btTopLeft: 
		     Result=0xDA;
			 break;
		case btTopCenter: 
		     Result=0xC2;
			 break;
    3498:	8f eb       	ldi	r24, 0xBF	; 191
    349a:	08 95       	ret
		case btTopRight:
		     Result=0xBF;		 
			 break;
    349c:	83 ec       	ldi	r24, 0xC3	; 195
    349e:	08 95       	ret
		case btMiddleLeft: 
			 Result=0xC3;
			 break;
    34a0:	84 eb       	ldi	r24, 0xB4	; 180
    34a2:	08 95       	ret
		case btMiddleRight: 
			 Result=0xB4;
			 break;
    34a4:	80 ec       	ldi	r24, 0xC0	; 192
    34a6:	08 95       	ret
		case btBottomLeft: 
		     Result=0xC0;
			 break;
    34a8:	81 ec       	ldi	r24, 0xC1	; 193
    34aa:	08 95       	ret
		case btBottomCenter: 
			 Result=0xC1;
			 break;
    34ac:	89 ed       	ldi	r24, 0xD9	; 217
    34ae:	08 95       	ret
		case btBottomRight: 
			 Result=0xD9;
			 break;
    34b0:	85 ec       	ldi	r24, 0xC5	; 197
    34b2:	08 95       	ret
        case btMiddleCenter:
		     Result=0xC5;
		     break;
    34b4:	83 eb       	ldi	r24, 0xB3	; 179
    34b6:	08 95       	ret
		case btVertical: 
			 Result=0xB3;
			 break;
    34b8:	84 ec       	ldi	r24, 0xC4	; 196
    34ba:	08 95       	ret
		case btHorizontal:
			 Result=0xC4;
			 break;	 
    34bc:	8d e0       	ldi	r24, 0x0D	; 13
        case btNewLine:
		     Result=0x0D;
			 break;	 
	 }
   return Result;
}
    34be:	08 95       	ret

000034c0 <InserBorder>:

void InserBorder(char BorderType, char *strPrnBuffer,char nLength,unsigned int *Pos){
    34c0:	bf 92       	push	r11
    34c2:	cf 92       	push	r12
    34c4:	df 92       	push	r13
    34c6:	ef 92       	push	r14
    34c8:	ff 92       	push	r15
    34ca:	0f 93       	push	r16
    34cc:	1f 93       	push	r17
    34ce:	cf 93       	push	r28
    34d0:	df 93       	push	r29
    34d2:	b8 2e       	mov	r11, r24
    34d4:	8b 01       	movw	r16, r22
    34d6:	e4 2e       	mov	r14, r20
    34d8:	69 01       	movw	r12, r18
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
    34da:	f9 01       	movw	r30, r18
    34dc:	c0 81       	ld	r28, Z
    34de:	d1 81       	ldd	r29, Z+1	; 0x01
    34e0:	0c 0f       	add	r16, r28
    34e2:	1d 1f       	adc	r17, r29
    34e4:	ff 24       	eor	r15, r15
    34e6:	07 c0       	rjmp	.+14     	; 0x34f6 <InserBorder+0x36>
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
	      strPrnBuffer[iPos]=GetBorderValue(BorderType);
    34e8:	8b 2d       	mov	r24, r11
    34ea:	0e 94 24 1a 	call	0x3448	; 0x3448 <GetBorderValue>
    34ee:	f8 01       	movw	r30, r16
    34f0:	81 93       	st	Z+, r24
    34f2:	8f 01       	movw	r16, r30
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
    34f4:	f3 94       	inc	r15
    34f6:	fe 14       	cp	r15, r14
    34f8:	b8 f3       	brcs	.-18     	; 0x34e8 <InserBorder+0x28>
	 //for (i=0;i<nLength;i++){
	 //     if (strPrnBuffer[i+StartPos]!=GetBorderValue(BorderType)){
//		      strPrnBuffer[i+StartPos]=GetBorderValue(BorderType);
//		  }
//	 }
     *Pos=iPos;
    34fa:	ce 0d       	add	r28, r14
    34fc:	d1 1d       	adc	r29, r1
    34fe:	f6 01       	movw	r30, r12
    3500:	d1 83       	std	Z+1, r29	; 0x01
    3502:	c0 83       	st	Z, r28
}
    3504:	df 91       	pop	r29
    3506:	cf 91       	pop	r28
    3508:	1f 91       	pop	r17
    350a:	0f 91       	pop	r16
    350c:	ff 90       	pop	r15
    350e:	ef 90       	pop	r14
    3510:	df 90       	pop	r13
    3512:	cf 90       	pop	r12
    3514:	bf 90       	pop	r11
    3516:	08 95       	ret

00003518 <GeniusSendPumpStatus>:
   return Result;
}

void GeniusSendPumpStatus(char iPumpID){
     
}
    3518:	08 95       	ret

0000351a <GeniusSendStopPump>:
void GeniusSendStopPump(char iPumpID){
}
    351a:	08 95       	ret

0000351c <GeniusSendResumePump>:
void GeniusSendResumePump(char iPumpID){
}
    351c:	08 95       	ret

0000351e <GeniusSendPumpPreset>:
void GeniusSendPumpPreset(char iPumpID){
}
    351e:	08 95       	ret

00003520 <SetIncomingTransStatus>:
	 sprintf_P(strSend,PSTR("%d"),cSum);
	 _uart_print(1,1,strSend);	 
}


void SetIncomingTransStatus(char iPumpID,char xTransStatus){
    3520:	e8 2f       	mov	r30, r24
char iStatus,xMaskA,xMaskB,xMaskC,xPumpID;
	 xPumpID=(iPumpID&0x0F);
    3522:	28 2f       	mov	r18, r24
    3524:	2f 70       	andi	r18, 0x0F	; 15
     iStatus=IncomingTransaction[xPumpID/8];
    3526:	82 2f       	mov	r24, r18
    3528:	86 95       	lsr	r24
    352a:	86 95       	lsr	r24
    352c:	86 95       	lsr	r24
    352e:	a8 2f       	mov	r26, r24
    3530:	b0 e0       	ldi	r27, 0x00	; 0
    3532:	a1 50       	subi	r26, 0x01	; 1
    3534:	b2 4f       	sbci	r27, 0xF2	; 242
    3536:	4c 91       	ld	r20, X
	 if (xTransStatus==TS_NEW){
    3538:	62 30       	cpi	r22, 0x02	; 2
    353a:	59 f4       	brne	.+22     	; 0x3552 <SetIncomingTransStatus+0x32>
	     iStatus=(iStatus|(1<<(xPumpID%8)));	 
    353c:	27 70       	andi	r18, 0x07	; 7
    353e:	81 e0       	ldi	r24, 0x01	; 1
    3540:	90 e0       	ldi	r25, 0x00	; 0
    3542:	02 c0       	rjmp	.+4      	; 0x3548 <SetIncomingTransStatus+0x28>
    3544:	88 0f       	add	r24, r24
    3546:	99 1f       	adc	r25, r25
    3548:	2a 95       	dec	r18
    354a:	e2 f7       	brpl	.-8      	; 0x3544 <SetIncomingTransStatus+0x24>
    354c:	48 2b       	or	r20, r24
		 IncomingTransaction[xPumpID/8]=iStatus;
    354e:	4c 93       	st	X, r20
    3550:	08 95       	ret
	 }else if (xTransStatus==TS_OLD){
    3552:	63 30       	cpi	r22, 0x03	; 3
    3554:	b1 f4       	brne	.+44     	; 0x3582 <SetIncomingTransStatus+0x62>
		 xMaskA=(0xFE<<(xPumpID%8));
    3556:	27 70       	andi	r18, 0x07	; 7
    3558:	8e ef       	ldi	r24, 0xFE	; 254
    355a:	90 e0       	ldi	r25, 0x00	; 0
    355c:	01 c0       	rjmp	.+2      	; 0x3560 <SetIncomingTransStatus+0x40>
    355e:	88 0f       	add	r24, r24
    3560:	2a 95       	dec	r18
    3562:	ea f7       	brpl	.-6      	; 0x355e <SetIncomingTransStatus+0x3e>
		 xMaskB=(~xMaskA)>>1;
		 xMaskC=xMaskA|xMaskB;
		 iStatus=iStatus&xMaskC;
		 IncomingTransaction[iPumpID/8]=iStatus;
    3564:	e6 95       	lsr	r30
    3566:	e6 95       	lsr	r30
    3568:	e6 95       	lsr	r30
    356a:	f0 e0       	ldi	r31, 0x00	; 0
    356c:	e1 50       	subi	r30, 0x01	; 1
    356e:	f2 4f       	sbci	r31, 0xF2	; 242
    3570:	28 2f       	mov	r18, r24
    3572:	30 e0       	ldi	r19, 0x00	; 0
    3574:	20 95       	com	r18
    3576:	30 95       	com	r19
    3578:	35 95       	asr	r19
    357a:	27 95       	ror	r18
    357c:	82 2b       	or	r24, r18
    357e:	84 23       	and	r24, r20
    3580:	80 83       	st	Z, r24
    3582:	08 95       	ret

00003584 <GetIncomingTransStatus>:
	 }
}
char GetIncomingTransStatus(char iPumpID){
     char xPumpID,Result;
	 xPumpID=(iPumpID&0x0F);
    3584:	8f 70       	andi	r24, 0x0F	; 15
	 Result=TS_NONE;
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==1){
    3586:	e8 2f       	mov	r30, r24
    3588:	e6 95       	lsr	r30
    358a:	e6 95       	lsr	r30
    358c:	e6 95       	lsr	r30
    358e:	f0 e0       	ldi	r31, 0x00	; 0
    3590:	e1 50       	subi	r30, 0x01	; 1
    3592:	f2 4f       	sbci	r31, 0xF2	; 242
    3594:	90 81       	ld	r25, Z
    3596:	29 2f       	mov	r18, r25
    3598:	30 e0       	ldi	r19, 0x00	; 0
    359a:	87 70       	andi	r24, 0x07	; 7
    359c:	02 c0       	rjmp	.+4      	; 0x35a2 <GetIncomingTransStatus+0x1e>
    359e:	35 95       	asr	r19
    35a0:	27 95       	ror	r18
    35a2:	8a 95       	dec	r24
    35a4:	e2 f7       	brpl	.-8      	; 0x359e <GetIncomingTransStatus+0x1a>
    35a6:	21 30       	cpi	r18, 0x01	; 1
    35a8:	31 05       	cpc	r19, r1
    35aa:	11 f4       	brne	.+4      	; 0x35b0 <GetIncomingTransStatus+0x2c>
    35ac:	82 e0       	ldi	r24, 0x02	; 2
    35ae:	08 95       	ret
	     Result=TS_NEW;
	 }else
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==0){
    35b0:	23 2b       	or	r18, r19
    35b2:	11 f4       	brne	.+4      	; 0x35b8 <GetIncomingTransStatus+0x34>
    35b4:	83 e0       	ldi	r24, 0x03	; 3
    35b6:	08 95       	ret
    35b8:	80 e0       	ldi	r24, 0x00	; 0
	     Result=TS_OLD;
	 }
   return Result;
}
    35ba:	08 95       	ret

000035bc <SetDispenser>:
		  }
	      break;
	 }
}

void SetDispenser(char DispType){
    35bc:	df 93       	push	r29
    35be:	cf 93       	push	r28
    35c0:	00 d0       	rcall	.+0      	; 0x35c2 <SetDispenser+0x6>
    35c2:	00 d0       	rcall	.+0      	; 0x35c4 <SetDispenser+0x8>
    35c4:	0f 92       	push	r0
    35c6:	cd b7       	in	r28, 0x3d	; 61
    35c8:	de b7       	in	r29, 0x3e	; 62
    35ca:	98 2f       	mov	r25, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    35cc:	e1 99       	sbic	0x1c, 1	; 28
    35ce:	fe cf       	rjmp	.-4      	; 0x35cc <SetDispenser+0x10>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    35d0:	27 e3       	ldi	r18, 0x37	; 55
    35d2:	31 e0       	ldi	r19, 0x01	; 1
    35d4:	3f bb       	out	0x1f, r19	; 31
    35d6:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    35d8:	e0 9a       	sbi	0x1c, 0	; 28
    35da:	8d b3       	in	r24, 0x1d	; 29
     char CurrentDispenser;
	 char i,DecimalSetting[5];
     CurrentDispenser=eeprom_read_byte(&DefDispenserBrand);
	 if (CurrentDispenser!=DispType){
    35dc:	89 17       	cp	r24, r25
    35de:	51 f0       	breq	.+20     	; 0x35f4 <SetDispenser+0x38>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    35e0:	e1 99       	sbic	0x1c, 1	; 28
    35e2:	fe cf       	rjmp	.-4      	; 0x35e0 <SetDispenser+0x24>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    35e4:	3f bb       	out	0x1f, r19	; 31
    35e6:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    35e8:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    35ea:	0f b6       	in	r0, 0x3f	; 63
    35ec:	f8 94       	cli
    35ee:	e2 9a       	sbi	0x1c, 2	; 28
    35f0:	e1 9a       	sbi	0x1c, 1	; 28
    35f2:	0f be       	out	0x3f, r0	; 63
	     eeprom_write_byte(&DefDispenserBrand,DispType);
	 }
     //Apply Setting for Pump respectively
	 switch(DispType){
    35f4:	91 30       	cpi	r25, 0x01	; 1
    35f6:	19 f0       	breq	.+6      	; 0x35fe <SetDispenser+0x42>
    35f8:	92 30       	cpi	r25, 0x02	; 2
    35fa:	71 f4       	brne	.+28     	; 0x3618 <SetDispenser+0x5c>
    35fc:	08 c0       	rjmp	.+16     	; 0x360e <SetDispenser+0x52>
	 case ST_GILBARCO:
          DecimalSetting[0]=0;//Price
    35fe:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=3;//Volume
    3600:	83 e0       	ldi	r24, 0x03	; 3
    3602:	8a 83       	std	Y+2, r24	; 0x02
		  DecimalSetting[2]=0;//Money
    3604:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    3606:	82 e0       	ldi	r24, 0x02	; 2
    3608:	8c 83       	std	Y+4, r24	; 0x04
		  DecimalSetting[4]=0;//TotalMoney 
    360a:	1d 82       	std	Y+5, r1	; 0x05
    360c:	05 c0       	rjmp	.+10     	; 0x3618 <SetDispenser+0x5c>
	      break;
	 case ST_WAYNE_DART:
          DecimalSetting[0]=0;//Price
    360e:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=2;//Volume
    3610:	9a 83       	std	Y+2, r25	; 0x02
		  DecimalSetting[2]=0;//Money
    3612:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    3614:	9c 83       	std	Y+4, r25	; 0x04
		  DecimalSetting[4]=2;//TotalMoney 
    3616:	9d 83       	std	Y+5, r25	; 0x05
    3618:	29 e3       	ldi	r18, 0x39	; 57
    361a:	30 e0       	ldi	r19, 0x00	; 0
    361c:	fe 01       	movw	r30, r28
    361e:	31 96       	adiw	r30, 0x01	; 1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3620:	e1 99       	sbic	0x1c, 1	; 28
    3622:	fe cf       	rjmp	.-4      	; 0x3620 <SetDispenser+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3624:	3f bb       	out	0x1f, r19	; 31
    3626:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3628:	e0 9a       	sbi	0x1c, 0	; 28
    362a:	8d b3       	in	r24, 0x1d	; 29
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
    362c:	90 81       	ld	r25, Z
    362e:	89 17       	cp	r24, r25
    3630:	51 f0       	breq	.+20     	; 0x3646 <SetDispenser+0x8a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3632:	e1 99       	sbic	0x1c, 1	; 28
    3634:	fe cf       	rjmp	.-4      	; 0x3632 <SetDispenser+0x76>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3636:	3f bb       	out	0x1f, r19	; 31
    3638:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    363a:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    363c:	0f b6       	in	r0, 0x3f	; 63
    363e:	f8 94       	cli
    3640:	e2 9a       	sbi	0x1c, 2	; 28
    3642:	e1 9a       	sbi	0x1c, 1	; 28
    3644:	0f be       	out	0x3f, r0	; 63
    3646:	2f 5f       	subi	r18, 0xFF	; 255
    3648:	3f 4f       	sbci	r19, 0xFF	; 255
    364a:	31 96       	adiw	r30, 0x01	; 1
		  DecimalSetting[3]=2;//TotalVolume
		  DecimalSetting[4]=2;//TotalMoney 
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
    364c:	80 e0       	ldi	r24, 0x00	; 0
    364e:	2e 33       	cpi	r18, 0x3E	; 62
    3650:	38 07       	cpc	r19, r24
    3652:	31 f7       	brne	.-52     	; 0x3620 <SetDispenser+0x64>
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
		     eeprom_write_byte(&DefDecimalPrice+i,DecimalSetting[i]);
		 }
	 }
}
    3654:	0f 90       	pop	r0
    3656:	0f 90       	pop	r0
    3658:	0f 90       	pop	r0
    365a:	0f 90       	pop	r0
    365c:	0f 90       	pop	r0
    365e:	cf 91       	pop	r28
    3660:	df 91       	pop	r29
    3662:	08 95       	ret

00003664 <ComposeDatetime>:
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}


void ComposeDatetime(char *Result){// 2010/10/01 16:27:44
    3664:	df 93       	push	r29
    3666:	cf 93       	push	r28
    3668:	cd b7       	in	r28, 0x3d	; 61
    366a:	de b7       	in	r29, 0x3e	; 62
    366c:	62 97       	sbiw	r28, 0x12	; 18
    366e:	0f b6       	in	r0, 0x3f	; 63
    3670:	f8 94       	cli
    3672:	de bf       	out	0x3e, r29	; 62
    3674:	0f be       	out	0x3f, r0	; 63
    3676:	cd bf       	out	0x3d, r28	; 61
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3678:	20 91 ea 05 	lds	r18, 0x05EA
    367c:	2f 83       	std	Y+7, r18	; 0x07
    367e:	20 91 eb 05 	lds	r18, 0x05EB
    3682:	28 87       	std	Y+8, r18	; 0x08
	 }Dest[Length]=0;
    3684:	20 91 ed 05 	lds	r18, 0x05ED
    3688:	2c 83       	std	Y+4, r18	; 0x04
    368a:	20 91 ee 05 	lds	r18, 0x05EE
    368e:	2d 83       	std	Y+5, r18	; 0x05
    3690:	20 91 f0 05 	lds	r18, 0x05F0
    3694:	29 83       	std	Y+1, r18	; 0x01
    3696:	20 91 f1 05 	lds	r18, 0x05F1
    369a:	2a 83       	std	Y+2, r18	; 0x02
    369c:	20 91 c9 0a 	lds	r18, 0x0AC9
    36a0:	2a 87       	std	Y+10, r18	; 0x0a
    36a2:	20 91 ca 0a 	lds	r18, 0x0ACA
    36a6:	2b 87       	std	Y+11, r18	; 0x0b
    36a8:	20 91 cc 0a 	lds	r18, 0x0ACC
    36ac:	2d 87       	std	Y+13, r18	; 0x0d
    36ae:	20 91 cd 0a 	lds	r18, 0x0ACD
    36b2:	2e 87       	std	Y+14, r18	; 0x0e
    36b4:	20 91 cf 0a 	lds	r18, 0x0ACF
    36b8:	28 8b       	std	Y+16, r18	; 0x10
    36ba:	20 91 d0 0a 	lds	r18, 0x0AD0
    36be:	29 8b       	std	Y+17, r18	; 0x11
    36c0:	1a 8a       	std	Y+18, r1	; 0x12
    36c2:	1f 86       	std	Y+15, r1	; 0x0f
    36c4:	1c 86       	std	Y+12, r1	; 0x0c
    36c6:	1b 82       	std	Y+3, r1	; 0x03
    36c8:	1e 82       	std	Y+6, r1	; 0x06
    36ca:	19 86       	std	Y+9, r1	; 0x09
     StrPosCopy(strSystemDate,sYear,6,2);

     StrPosCopy(strSystemTime,sHour,0,2);
     StrPosCopy(strSystemTime,sMinute,3,2);
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
    36cc:	2d b7       	in	r18, 0x3d	; 61
    36ce:	3e b7       	in	r19, 0x3e	; 62
    36d0:	20 51       	subi	r18, 0x10	; 16
    36d2:	30 40       	sbci	r19, 0x00	; 0
    36d4:	0f b6       	in	r0, 0x3f	; 63
    36d6:	f8 94       	cli
    36d8:	3e bf       	out	0x3e, r19	; 62
    36da:	0f be       	out	0x3f, r0	; 63
    36dc:	2d bf       	out	0x3d, r18	; 61
    36de:	ed b7       	in	r30, 0x3d	; 61
    36e0:	fe b7       	in	r31, 0x3e	; 62
    36e2:	31 96       	adiw	r30, 0x01	; 1
    36e4:	ad b7       	in	r26, 0x3d	; 61
    36e6:	be b7       	in	r27, 0x3e	; 62
    36e8:	12 96       	adiw	r26, 0x02	; 2
    36ea:	9c 93       	st	X, r25
    36ec:	8e 93       	st	-X, r24
    36ee:	11 97       	sbiw	r26, 0x01	; 1
    36f0:	8f e4       	ldi	r24, 0x4F	; 79
    36f2:	93 e0       	ldi	r25, 0x03	; 3
    36f4:	93 83       	std	Z+3, r25	; 0x03
    36f6:	82 83       	std	Z+2, r24	; 0x02
    36f8:	ce 01       	movw	r24, r28
    36fa:	01 96       	adiw	r24, 0x01	; 1
    36fc:	95 83       	std	Z+5, r25	; 0x05
    36fe:	84 83       	std	Z+4, r24	; 0x04
    3700:	ce 01       	movw	r24, r28
    3702:	04 96       	adiw	r24, 0x04	; 4
    3704:	97 83       	std	Z+7, r25	; 0x07
    3706:	86 83       	std	Z+6, r24	; 0x06
    3708:	ce 01       	movw	r24, r28
    370a:	07 96       	adiw	r24, 0x07	; 7
    370c:	91 87       	std	Z+9, r25	; 0x09
    370e:	80 87       	std	Z+8, r24	; 0x08
    3710:	ce 01       	movw	r24, r28
    3712:	0a 96       	adiw	r24, 0x0a	; 10
    3714:	93 87       	std	Z+11, r25	; 0x0b
    3716:	82 87       	std	Z+10, r24	; 0x0a
    3718:	ce 01       	movw	r24, r28
    371a:	0d 96       	adiw	r24, 0x0d	; 13
    371c:	95 87       	std	Z+13, r25	; 0x0d
    371e:	84 87       	std	Z+12, r24	; 0x0c
    3720:	ce 01       	movw	r24, r28
    3722:	40 96       	adiw	r24, 0x10	; 16
    3724:	97 87       	std	Z+15, r25	; 0x0f
    3726:	86 87       	std	Z+14, r24	; 0x0e
    3728:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    372c:	2d b7       	in	r18, 0x3d	; 61
    372e:	3e b7       	in	r19, 0x3e	; 62
    3730:	20 5f       	subi	r18, 0xF0	; 240
    3732:	3f 4f       	sbci	r19, 0xFF	; 255
    3734:	0f b6       	in	r0, 0x3f	; 63
    3736:	f8 94       	cli
    3738:	3e bf       	out	0x3e, r19	; 62
    373a:	0f be       	out	0x3f, r0	; 63
    373c:	2d bf       	out	0x3d, r18	; 61
}
    373e:	62 96       	adiw	r28, 0x12	; 18
    3740:	0f b6       	in	r0, 0x3f	; 63
    3742:	f8 94       	cli
    3744:	de bf       	out	0x3e, r29	; 62
    3746:	0f be       	out	0x3f, r0	; 63
    3748:	cd bf       	out	0x3d, r28	; 61
    374a:	cf 91       	pop	r28
    374c:	df 91       	pop	r29
    374e:	08 95       	ret

00003750 <leadingZero>:
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    3750:	00 d0       	rcall	.+0      	; 0x3752 <leadingZero+0x2>
    3752:	00 d0       	rcall	.+0      	; 0x3754 <leadingZero+0x4>
    3754:	00 d0       	rcall	.+0      	; 0x3756 <leadingZero+0x6>
    3756:	ed b7       	in	r30, 0x3d	; 61
    3758:	fe b7       	in	r31, 0x3e	; 62
    375a:	31 96       	adiw	r30, 0x01	; 1
    375c:	ad b7       	in	r26, 0x3d	; 61
    375e:	be b7       	in	r27, 0x3e	; 62
    3760:	12 96       	adiw	r26, 0x02	; 2
    3762:	7c 93       	st	X, r23
    3764:	6e 93       	st	-X, r22
    3766:	11 97       	sbiw	r26, 0x01	; 1
    3768:	26 e5       	ldi	r18, 0x56	; 86
    376a:	3d e0       	ldi	r19, 0x0D	; 13
    376c:	33 83       	std	Z+3, r19	; 0x03
    376e:	22 83       	std	Z+2, r18	; 0x02
    3770:	84 83       	std	Z+4, r24	; 0x04
    3772:	15 82       	std	Z+5, r1	; 0x05
    3774:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    3778:	8d b7       	in	r24, 0x3d	; 61
    377a:	9e b7       	in	r25, 0x3e	; 62
    377c:	06 96       	adiw	r24, 0x06	; 6
    377e:	0f b6       	in	r0, 0x3f	; 63
    3780:	f8 94       	cli
    3782:	9e bf       	out	0x3e, r25	; 62
    3784:	0f be       	out	0x3f, r0	; 63
    3786:	8d bf       	out	0x3d, r24	; 61

}
    3788:	08 95       	ret

0000378a <UpdateSeqNum>:
	 sprintf_P(strIFT_ID,PSTR("%.2d"),IdIFT);
	 //leadingZero(IdIFT,strIFT_ID);
}

void UpdateSeqNum(){
     if (SeqNum<100)SeqNum++;
    378a:	80 91 d1 01 	lds	r24, 0x01D1
    378e:	84 36       	cpi	r24, 0x64	; 100
    3790:	20 f4       	brcc	.+8      	; 0x379a <UpdateSeqNum+0x10>
    3792:	8f 5f       	subi	r24, 0xFF	; 255
    3794:	80 93 d1 01 	sts	0x01D1, r24
    3798:	02 c0       	rjmp	.+4      	; 0x379e <UpdateSeqNum+0x14>
	 else SeqNum=0;
    379a:	10 92 d1 01 	sts	0x01D1, r1
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    379e:	00 d0       	rcall	.+0      	; 0x37a0 <UpdateSeqNum+0x16>
    37a0:	00 d0       	rcall	.+0      	; 0x37a2 <UpdateSeqNum+0x18>
    37a2:	00 d0       	rcall	.+0      	; 0x37a4 <UpdateSeqNum+0x1a>
    37a4:	ed b7       	in	r30, 0x3d	; 61
    37a6:	fe b7       	in	r31, 0x3e	; 62
    37a8:	31 96       	adiw	r30, 0x01	; 1
    37aa:	8b ef       	ldi	r24, 0xFB	; 251
    37ac:	9d e0       	ldi	r25, 0x0D	; 13
    37ae:	ad b7       	in	r26, 0x3d	; 61
    37b0:	be b7       	in	r27, 0x3e	; 62
    37b2:	12 96       	adiw	r26, 0x02	; 2
    37b4:	9c 93       	st	X, r25
    37b6:	8e 93       	st	-X, r24
    37b8:	11 97       	sbiw	r26, 0x01	; 1
    37ba:	86 e5       	ldi	r24, 0x56	; 86
    37bc:	9d e0       	ldi	r25, 0x0D	; 13
    37be:	93 83       	std	Z+3, r25	; 0x03
    37c0:	82 83       	std	Z+2, r24	; 0x02
    37c2:	80 91 d1 01 	lds	r24, 0x01D1
    37c6:	84 83       	std	Z+4, r24	; 0x04
    37c8:	15 82       	std	Z+5, r1	; 0x05
    37ca:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    37ce:	8d b7       	in	r24, 0x3d	; 61
    37d0:	9e b7       	in	r25, 0x3e	; 62
    37d2:	06 96       	adiw	r24, 0x06	; 6
    37d4:	0f b6       	in	r0, 0x3f	; 63
    37d6:	f8 94       	cli
    37d8:	9e bf       	out	0x3e, r25	; 62
    37da:	0f be       	out	0x3f, r0	; 63
    37dc:	8d bf       	out	0x3d, r24	; 61

void UpdateSeqNum(){
     if (SeqNum<100)SeqNum++;
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 
    37de:	08 95       	ret

000037e0 <UpdateIFT_ID>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    37e0:	e1 99       	sbic	0x1c, 1	; 28
    37e2:	fe cf       	rjmp	.-4      	; 0x37e0 <UpdateIFT_ID>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    37e4:	80 e0       	ldi	r24, 0x00	; 0
    37e6:	90 e0       	ldi	r25, 0x00	; 0
    37e8:	9f bb       	out	0x1f, r25	; 31
    37ea:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    37ec:	e0 9a       	sbi	0x1c, 0	; 28
    37ee:	8d b3       	in	r24, 0x1d	; 29

void UpdateIFT_ID(){
     char IdIFT;
     //sprintf_P(strIFT_ID,PSTR("%.2d"),eeprom_read_byte(&DefIFT_ID));
	 IdIFT=(eeprom_read_byte(&DefIFT_ID)%100);
	 sprintf_P(strIFT_ID,PSTR("%.2d"),IdIFT);
    37f0:	00 d0       	rcall	.+0      	; 0x37f2 <UpdateIFT_ID+0x12>
    37f2:	00 d0       	rcall	.+0      	; 0x37f4 <UpdateIFT_ID+0x14>
    37f4:	00 d0       	rcall	.+0      	; 0x37f6 <UpdateIFT_ID+0x16>
    37f6:	ed b7       	in	r30, 0x3d	; 61
    37f8:	fe b7       	in	r31, 0x3e	; 62
    37fa:	31 96       	adiw	r30, 0x01	; 1
    37fc:	2c e1       	ldi	r18, 0x1C	; 28
    37fe:	36 e0       	ldi	r19, 0x06	; 6
    3800:	ad b7       	in	r26, 0x3d	; 61
    3802:	be b7       	in	r27, 0x3e	; 62
    3804:	12 96       	adiw	r26, 0x02	; 2
    3806:	3c 93       	st	X, r19
    3808:	2e 93       	st	-X, r18
    380a:	11 97       	sbiw	r26, 0x01	; 1
    380c:	22 e8       	ldi	r18, 0x82	; 130
    380e:	30 e2       	ldi	r19, 0x20	; 32
    3810:	33 83       	std	Z+3, r19	; 0x03
    3812:	22 83       	std	Z+2, r18	; 0x02
    3814:	64 e6       	ldi	r22, 0x64	; 100
    3816:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    381a:	94 83       	std	Z+4, r25	; 0x04
    381c:	15 82       	std	Z+5, r1	; 0x05
    381e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    3822:	8d b7       	in	r24, 0x3d	; 61
    3824:	9e b7       	in	r25, 0x3e	; 62
    3826:	06 96       	adiw	r24, 0x06	; 6
    3828:	0f b6       	in	r0, 0x3f	; 63
    382a:	f8 94       	cli
    382c:	9e bf       	out	0x3e, r25	; 62
    382e:	0f be       	out	0x3f, r0	; 63
    3830:	8d bf       	out	0x3d, r24	; 61
	 //leadingZero(IdIFT,strIFT_ID);
}
    3832:	08 95       	ret

00003834 <GetFIPAddr>:
	    Result=PPumpID[FIPAddr-1];
	 }
   return Result;
}

char GetFIPAddr(char iPumpID){
    3834:	ff 92       	push	r15
    3836:	0f 93       	push	r16
    3838:	1f 93       	push	r17
    383a:	df 93       	push	r29
    383c:	cf 93       	push	r28
    383e:	cd b7       	in	r28, 0x3d	; 61
    3840:	de b7       	in	r29, 0x3e	; 62
    3842:	28 97       	sbiw	r28, 0x08	; 8
    3844:	0f b6       	in	r0, 0x3f	; 63
    3846:	f8 94       	cli
    3848:	de bf       	out	0x3e, r29	; 62
    384a:	0f be       	out	0x3f, r0	; 63
    384c:	cd bf       	out	0x3d, r28	; 61
    384e:	f8 2e       	mov	r15, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3850:	8e 01       	movw	r16, r28
    3852:	0f 5f       	subi	r16, 0xFF	; 255
    3854:	1f 4f       	sbci	r17, 0xFF	; 255
    3856:	c8 01       	movw	r24, r16
    3858:	65 e4       	ldi	r22, 0x45	; 69
    385a:	70 e0       	ldi	r23, 0x00	; 0
    385c:	48 e0       	ldi	r20, 0x08	; 8
    385e:	50 e0       	ldi	r21, 0x00	; 0
    3860:	25 ed       	ldi	r18, 0xD5	; 213
    3862:	32 e1       	ldi	r19, 0x12	; 18
    3864:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
    3868:	f8 01       	movw	r30, r16
char i,PPumpID[8],Result;     
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    386a:	9e 01       	movw	r18, r28
    386c:	27 5f       	subi	r18, 0xF7	; 247
    386e:	3f 4f       	sbci	r19, 0xFF	; 255
    3870:	9e 2f       	mov	r25, r30
    3872:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==iPumpID){
    3874:	80 81       	ld	r24, Z
    3876:	8f 15       	cp	r24, r15
    3878:	19 f4       	brne	.+6      	; 0x3880 <GetFIPAddr+0x4c>
		     Result=i+1;
    387a:	89 2f       	mov	r24, r25
    387c:	8f 5f       	subi	r24, 0xFF	; 255
    387e:	05 c0       	rjmp	.+10     	; 0x388a <GetFIPAddr+0x56>
			 break;
    3880:	31 96       	adiw	r30, 0x01	; 1

char GetFIPAddr(char iPumpID){
char i,PPumpID[8],Result;     
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    3882:	e2 17       	cp	r30, r18
    3884:	f3 07       	cpc	r31, r19
    3886:	a1 f7       	brne	.-24     	; 0x3870 <GetFIPAddr+0x3c>
    3888:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
   return Result;
}
    388a:	28 96       	adiw	r28, 0x08	; 8
    388c:	0f b6       	in	r0, 0x3f	; 63
    388e:	f8 94       	cli
    3890:	de bf       	out	0x3e, r29	; 62
    3892:	0f be       	out	0x3f, r0	; 63
    3894:	cd bf       	out	0x3d, r28	; 61
    3896:	cf 91       	pop	r28
    3898:	df 91       	pop	r29
    389a:	1f 91       	pop	r17
    389c:	0f 91       	pop	r16
    389e:	ff 90       	pop	r15
    38a0:	08 95       	ret

000038a2 <UpdateStandaloneStatus>:
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
         lcd_print(4,1,lcdteks);
     	 }
}

void UpdateStandaloneStatus(char xPumpID,char xPumpStatus){//xPumpID: (1-16)&0x0F
    38a2:	ff 92       	push	r15
    38a4:	0f 93       	push	r16
    38a6:	1f 93       	push	r17
    38a8:	cf 93       	push	r28
    38aa:	df 93       	push	r29
    38ac:	28 2f       	mov	r18, r24
    38ae:	f6 2e       	mov	r15, r22
char strSend[20],iPumpID; //[xxxxxxxxxPx]
char iAddr;

	 if (xPumpID<16){
    38b0:	80 31       	cpi	r24, 0x10	; 16
    38b2:	08 f0       	brcs	.+2      	; 0x38b6 <UpdateStandaloneStatus+0x14>
    38b4:	4e c0       	rjmp	.+156    	; 0x3952 <UpdateStandaloneStatus+0xb0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    38b6:	e1 99       	sbic	0x1c, 1	; 28
    38b8:	fe cf       	rjmp	.-4      	; 0x38b6 <UpdateStandaloneStatus+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    38ba:	87 e3       	ldi	r24, 0x37	; 55
    38bc:	91 e0       	ldi	r25, 0x01	; 1
    38be:	9f bb       	out	0x1f, r25	; 31
    38c0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    38c2:	e0 9a       	sbi	0x1c, 0	; 28
    38c4:	8d b3       	in	r24, 0x1d	; 29
	     DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    38c6:	80 93 61 01 	sts	0x0161, r24
	     switch(DispenserBrand){
    38ca:	81 50       	subi	r24, 0x01	; 1
    38cc:	82 30       	cpi	r24, 0x02	; 2
    38ce:	08 f4       	brcc	.+2      	; 0x38d2 <UpdateStandaloneStatus+0x30>
    38d0:	82 2f       	mov	r24, r18
	     case ST_WAYNE_DART:
              iPumpID=xPumpID;
	          break;				   
	     }

		 iAddr=GetFIPAddr(iPumpID);
    38d2:	0e 94 1a 1c 	call	0x3834	; 0x3834 <GetFIPAddr>
		 if (iAddr>0){
    38d6:	88 23       	and	r24, r24
    38d8:	e1 f1       	breq	.+120    	; 0x3952 <UpdateStandaloneStatus+0xb0>
		     iAddr=iAddr-1;
			 if (strPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY)){//iFdiiiiiiiiiiiii
    38da:	81 50       	subi	r24, 0x01	; 1
    38dc:	c8 2f       	mov	r28, r24
    38de:	d0 e0       	ldi	r29, 0x00	; 0
    38e0:	80 e1       	ldi	r24, 0x10	; 16
    38e2:	0e 94 72 13 	call	0x26e4	; 0x26e4 <GetPumpStatusLabel>
    38e6:	8e 01       	movw	r16, r28
    38e8:	0e 5e       	subi	r16, 0xEE	; 238
    38ea:	1e 4f       	sbci	r17, 0xFE	; 254
    38ec:	f8 01       	movw	r30, r16
    38ee:	90 81       	ld	r25, Z
    38f0:	98 17       	cp	r25, r24
    38f2:	b1 f0       	breq	.+44     	; 0x3920 <UpdateStandaloneStatus+0x7e>
		         if (xPumpStatus!=PS_PRINT_READY)
    38f4:	f0 e1       	ldi	r31, 0x10	; 16
    38f6:	ff 16       	cp	r15, r31
    38f8:	21 f0       	breq	.+8      	; 0x3902 <UpdateStandaloneStatus+0x60>
				     CurrentPumpStatus[iAddr]=xPumpStatus;
    38fa:	fe 01       	movw	r30, r28
    38fc:	ee 59       	subi	r30, 0x9E	; 158
    38fe:	fe 4f       	sbci	r31, 0xFE	; 254
    3900:	f0 82       	st	Z, r15
			     strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    3902:	8f 2d       	mov	r24, r15
    3904:	0e 94 72 13 	call	0x26e4	; 0x26e4 <GetPumpStatusLabel>
    3908:	8e 01       	movw	r16, r28
    390a:	0e 5e       	subi	r16, 0xEE	; 238
    390c:	1e 4f       	sbci	r17, 0xFE	; 254
    390e:	f8 01       	movw	r30, r16
    3910:	80 83       	st	Z, r24
                 if (xPumpStatus==PS_FINISH_TOTALIZER)
    3912:	f5 e1       	ldi	r31, 0x15	; 21
    3914:	ff 16       	cp	r15, r31
    3916:	c1 f4       	brne	.+48     	; 0x3948 <UpdateStandaloneStatus+0xa6>
				     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    3918:	ce 59       	subi	r28, 0x9E	; 158
    391a:	de 4f       	sbci	r29, 0xFE	; 254
    391c:	88 81       	ld	r24, Y
    391e:	10 c0       	rjmp	.+32     	; 0x3940 <UpdateStandaloneStatus+0x9e>
    3920:	fe 01       	movw	r30, r28
    3922:	ee 59       	subi	r30, 0x9E	; 158
    3924:	fe 4f       	sbci	r31, 0xFE	; 254
		     }else if ((strPumpStatus[iAddr]==GetPumpStatusLabel(PS_PRINT_READY))||(xPumpStatus==PUMP_FEOT)||(xPumpStatus==PS_PRINTED)||(xPumpStatus==PS_TOTALIZER)){//P
			     if (xPumpStatus==PS_PRINTED){
    3926:	81 e1       	ldi	r24, 0x11	; 17
    3928:	f8 16       	cp	r15, r24
    392a:	11 f4       	brne	.+4      	; 0x3930 <UpdateStandaloneStatus+0x8e>
				 //New

				     //if (CurrentPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY))
			             strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    392c:	80 81       	ld	r24, Z
    392e:	08 c0       	rjmp	.+16     	; 0x3940 <UpdateStandaloneStatus+0x9e>
					 //    CurrentPumpStatus[iAddr]=PUMP_OFF;
					 //    strPumpStatus[iAddr]=GetPumpStatusLabel(PUMP_OFF);
					 //}

				  }
			     else CurrentPumpStatus[iAddr]=xPumpStatus;			 
    3930:	f0 82       	st	Z, r15
			 if (xPumpStatus==PUMP_FEOT){
    3932:	8b e0       	ldi	r24, 0x0B	; 11
    3934:	f8 16       	cp	r15, r24
    3936:	21 f0       	breq	.+8      	; 0x3940 <UpdateStandaloneStatus+0x9e>
			     CurrentPumpStatus[iAddr]=xPumpStatus;
			     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
				 }
             else if (xPumpStatus==PS_TOTALIZER){
    3938:	f4 e1       	ldi	r31, 0x14	; 20
    393a:	ff 16       	cp	r15, r31
    393c:	29 f4       	brne	.+10     	; 0x3948 <UpdateStandaloneStatus+0xa6>
			      strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    393e:	84 e1       	ldi	r24, 0x14	; 20
    3940:	0e 94 72 13 	call	0x26e4	; 0x26e4 <GetPumpStatusLabel>
    3944:	f8 01       	movw	r30, r16
    3946:	80 83       	st	Z, r24
				 }
		 }		 	     
         strPumpStatus[16]=0;
    3948:	10 92 22 01 	sts	0x0122, r1
	     IsNewPumpStatus=True;		 
    394c:	81 e0       	ldi	r24, 0x01	; 1
    394e:	80 93 11 01 	sts	0x0111, r24
		 }		 
	 }
}
    3952:	df 91       	pop	r29
    3954:	cf 91       	pop	r28
    3956:	1f 91       	pop	r17
    3958:	0f 91       	pop	r16
    395a:	ff 90       	pop	r15
    395c:	08 95       	ret

0000395e <GetPumpID>:
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
}


char GetPumpID(char FIPAddr){//Find Stored PumpID in PumpMap
    395e:	1f 93       	push	r17
    3960:	df 93       	push	r29
    3962:	cf 93       	push	r28
    3964:	cd b7       	in	r28, 0x3d	; 61
    3966:	de b7       	in	r29, 0x3e	; 62
    3968:	28 97       	sbiw	r28, 0x08	; 8
    396a:	0f b6       	in	r0, 0x3f	; 63
    396c:	f8 94       	cli
    396e:	de bf       	out	0x3e, r29	; 62
    3970:	0f be       	out	0x3f, r0	; 63
    3972:	cd bf       	out	0x3d, r28	; 61
    3974:	18 2f       	mov	r17, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3976:	ce 01       	movw	r24, r28
    3978:	01 96       	adiw	r24, 0x01	; 1
    397a:	65 e4       	ldi	r22, 0x45	; 69
    397c:	70 e0       	ldi	r23, 0x00	; 0
    397e:	48 e0       	ldi	r20, 0x08	; 8
    3980:	50 e0       	ldi	r21, 0x00	; 0
    3982:	25 ed       	ldi	r18, 0xD5	; 213
    3984:	32 e1       	ldi	r19, 0x12	; 18
    3986:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
     char PPumpID[8],Result;     
     eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 Result=0;
	 if ((FIPAddr>0) && (FIPAddr<8)){
    398a:	81 2f       	mov	r24, r17
    398c:	81 50       	subi	r24, 0x01	; 1
    398e:	87 30       	cpi	r24, 0x07	; 7
    3990:	10 f0       	brcs	.+4      	; 0x3996 <GetPumpID+0x38>
    3992:	80 e0       	ldi	r24, 0x00	; 0
    3994:	04 c0       	rjmp	.+8      	; 0x399e <GetPumpID+0x40>
	    Result=PPumpID[FIPAddr-1];
    3996:	fe 01       	movw	r30, r28
    3998:	e1 0f       	add	r30, r17
    399a:	f1 1d       	adc	r31, r1
    399c:	80 81       	ld	r24, Z
	 }
   return Result;
}
    399e:	28 96       	adiw	r28, 0x08	; 8
    39a0:	0f b6       	in	r0, 0x3f	; 63
    39a2:	f8 94       	cli
    39a4:	de bf       	out	0x3e, r29	; 62
    39a6:	0f be       	out	0x3f, r0	; 63
    39a8:	cd bf       	out	0x3d, r28	; 61
    39aa:	cf 91       	pop	r28
    39ac:	df 91       	pop	r29
    39ae:	1f 91       	pop	r17
    39b0:	08 95       	ret

000039b2 <GetTotalizerData>:
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
}



void GetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "0000000"
    39b2:	0f 93       	push	r16
    39b4:	1f 93       	push	r17
    39b6:	df 93       	push	r29
    39b8:	cf 93       	push	r28
    39ba:	00 d0       	rcall	.+0      	; 0x39bc <GetTotalizerData+0xa>
    39bc:	00 d0       	rcall	.+0      	; 0x39be <GetTotalizerData+0xc>
    39be:	00 d0       	rcall	.+0      	; 0x39c0 <GetTotalizerData+0xe>
    39c0:	cd b7       	in	r28, 0x3d	; 61
    39c2:	de b7       	in	r29, 0x3e	; 62
    39c4:	96 2f       	mov	r25, r22
     char rawValue[6],iPumpAddr,iGrade;

	 iPumpAddr=(xPumpAddr&0x0F);
    39c6:	4f 70       	andi	r20, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    39c8:	21 50       	subi	r18, 0x01	; 1
    39ca:	26 30       	cpi	r18, 0x06	; 6
    39cc:	08 f4       	brcc	.+2      	; 0x39d0 <GetTotalizerData+0x1e>
    39ce:	52 2f       	mov	r21, r18
	     iGrade=xGradeAddr-1;
     
//TotalVolume[2][16][6][6];
//GetTotalizerData(TVOLUME,TOTALIZER_LAST,PumpNum,xGrade,strLastVolume);
	 if (TType==TVOLUME)eeprom_read_block((void*) &rawValue, (const void*) &(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    39d0:	88 23       	and	r24, r24
    39d2:	d9 f4       	brne	.+54     	; 0x3a0a <GetTotalizerData+0x58>
    39d4:	64 e2       	ldi	r22, 0x24	; 36
    39d6:	46 9f       	mul	r20, r22
    39d8:	b0 01       	movw	r22, r0
    39da:	11 24       	eor	r1, r1
    39dc:	29 2f       	mov	r18, r25
    39de:	30 e0       	ldi	r19, 0x00	; 0
    39e0:	80 e2       	ldi	r24, 0x20	; 32
    39e2:	91 e0       	ldi	r25, 0x01	; 1
    39e4:	fc 01       	movw	r30, r24
    39e6:	2e 9f       	mul	r18, r30
    39e8:	c0 01       	movw	r24, r0
    39ea:	2f 9f       	mul	r18, r31
    39ec:	90 0d       	add	r25, r0
    39ee:	3e 9f       	mul	r19, r30
    39f0:	90 0d       	add	r25, r0
    39f2:	11 24       	eor	r1, r1
    39f4:	68 0f       	add	r22, r24
    39f6:	79 1f       	adc	r23, r25
    39f8:	86 e0       	ldi	r24, 0x06	; 6
    39fa:	58 9f       	mul	r21, r24
    39fc:	c0 01       	movw	r24, r0
    39fe:	11 24       	eor	r1, r1
    3a00:	68 0f       	add	r22, r24
    3a02:	79 1f       	adc	r23, r25
    3a04:	6d 53       	subi	r22, 0x3D	; 61
    3a06:	7c 4f       	sbci	r23, 0xFC	; 252
    3a08:	1c c0       	rjmp	.+56     	; 0x3a42 <GetTotalizerData+0x90>
	 else 
	 if (TType==TMONEY)eeprom_read_block((void*) &rawValue, (const void*) &(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    3a0a:	81 30       	cpi	r24, 0x01	; 1
    3a0c:	11 f5       	brne	.+68     	; 0x3a52 <GetTotalizerData+0xa0>
    3a0e:	64 e2       	ldi	r22, 0x24	; 36
    3a10:	46 9f       	mul	r20, r22
    3a12:	b0 01       	movw	r22, r0
    3a14:	11 24       	eor	r1, r1
    3a16:	29 2f       	mov	r18, r25
    3a18:	30 e0       	ldi	r19, 0x00	; 0
    3a1a:	80 e2       	ldi	r24, 0x20	; 32
    3a1c:	91 e0       	ldi	r25, 0x01	; 1
    3a1e:	fc 01       	movw	r30, r24
    3a20:	2e 9f       	mul	r18, r30
    3a22:	c0 01       	movw	r24, r0
    3a24:	2f 9f       	mul	r18, r31
    3a26:	90 0d       	add	r25, r0
    3a28:	3e 9f       	mul	r19, r30
    3a2a:	90 0d       	add	r25, r0
    3a2c:	11 24       	eor	r1, r1
    3a2e:	68 0f       	add	r22, r24
    3a30:	79 1f       	adc	r23, r25
    3a32:	86 e0       	ldi	r24, 0x06	; 6
    3a34:	58 9f       	mul	r21, r24
    3a36:	c0 01       	movw	r24, r0
    3a38:	11 24       	eor	r1, r1
    3a3a:	68 0f       	add	r22, r24
    3a3c:	79 1f       	adc	r23, r25
    3a3e:	6d 5f       	subi	r22, 0xFD	; 253
    3a40:	79 4f       	sbci	r23, 0xF9	; 249
    3a42:	ce 01       	movw	r24, r28
    3a44:	01 96       	adiw	r24, 0x01	; 1
    3a46:	46 e0       	ldi	r20, 0x06	; 6
    3a48:	50 e0       	ldi	r21, 0x00	; 0
    3a4a:	25 ed       	ldi	r18, 0xD5	; 213
    3a4c:	32 e1       	ldi	r19, 0x12	; 18
    3a4e:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
	 //Convert RawData to String 
	 RawToStr(rawValue,strValue);
    3a52:	ce 01       	movw	r24, r28
    3a54:	01 96       	adiw	r24, 0x01	; 1
    3a56:	b8 01       	movw	r22, r16
    3a58:	0e 94 d1 19 	call	0x33a2	; 0x33a2 <RawToStr>
}
    3a5c:	26 96       	adiw	r28, 0x06	; 6
    3a5e:	0f b6       	in	r0, 0x3f	; 63
    3a60:	f8 94       	cli
    3a62:	de bf       	out	0x3e, r29	; 62
    3a64:	0f be       	out	0x3f, r0	; 63
    3a66:	cd bf       	out	0x3d, r28	; 61
    3a68:	cf 91       	pop	r28
    3a6a:	df 91       	pop	r29
    3a6c:	1f 91       	pop	r17
    3a6e:	0f 91       	pop	r16
    3a70:	08 95       	ret

00003a72 <SelectMark>:
	      break;
	 }
    return Result;
}

char SelectMark(char InMark){
    3a72:	df 92       	push	r13
    3a74:	ef 92       	push	r14
    3a76:	ff 92       	push	r15
    3a78:	0f 93       	push	r16
    3a7a:	1f 93       	push	r17
    3a7c:	df 93       	push	r29
    3a7e:	cf 93       	push	r28
    3a80:	00 d0       	rcall	.+0      	; 0x3a82 <SelectMark+0x10>
    3a82:	00 d0       	rcall	.+0      	; 0x3a84 <SelectMark+0x12>
    3a84:	0f 92       	push	r0
    3a86:	cd b7       	in	r28, 0x3d	; 61
    3a88:	de b7       	in	r29, 0x3e	; 62
    3a8a:	d8 2e       	mov	r13, r24
    3a8c:	8e 01       	movw	r16, r28
    3a8e:	0f 5f       	subi	r16, 0xFF	; 255
    3a90:	1f 4f       	sbci	r17, 0xFF	; 255
    3a92:	c8 01       	movw	r24, r16
    3a94:	60 e4       	ldi	r22, 0x40	; 64
    3a96:	70 e0       	ldi	r23, 0x00	; 0
    3a98:	45 e0       	ldi	r20, 0x05	; 5
    3a9a:	50 e0       	ldi	r21, 0x00	; 0
    3a9c:	25 ed       	ldi	r18, 0xD5	; 213
    3a9e:	32 e1       	ldi	r19, 0x12	; 18
    3aa0:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
    3aa4:	ed 2d       	mov	r30, r13
    3aa6:	21 e0       	ldi	r18, 0x01	; 1
    3aa8:	30 e0       	ldi	r19, 0x00	; 0
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
    3aaa:	78 01       	movw	r14, r16
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
    3aac:	d8 01       	movw	r26, r16
    3aae:	8c 91       	ld	r24, X
    3ab0:	d8 16       	cp	r13, r24
    3ab2:	49 f4       	brne	.+18     	; 0x3ac6 <SelectMark+0x54>
		     Result=PMark[(i+1)%Length];
    3ab4:	c9 01       	movw	r24, r18
    3ab6:	65 e0       	ldi	r22, 0x05	; 5
    3ab8:	70 e0       	ldi	r23, 0x00	; 0
    3aba:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    3abe:	f7 01       	movw	r30, r14
    3ac0:	e8 0f       	add	r30, r24
    3ac2:	f9 1f       	adc	r31, r25
    3ac4:	e0 81       	ld	r30, Z
    3ac6:	0f 5f       	subi	r16, 0xFF	; 255
    3ac8:	1f 4f       	sbci	r17, 0xFF	; 255
    3aca:	2f 5f       	subi	r18, 0xFF	; 255
    3acc:	3f 4f       	sbci	r19, 0xFF	; 255
char SelectMark(char InMark){
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
    3ace:	26 30       	cpi	r18, 0x06	; 6
    3ad0:	31 05       	cpc	r19, r1
    3ad2:	61 f7       	brne	.-40     	; 0x3aac <SelectMark+0x3a>
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
	 }
     return Result;
}
    3ad4:	8e 2f       	mov	r24, r30
    3ad6:	0f 90       	pop	r0
    3ad8:	0f 90       	pop	r0
    3ada:	0f 90       	pop	r0
    3adc:	0f 90       	pop	r0
    3ade:	0f 90       	pop	r0
    3ae0:	cf 91       	pop	r28
    3ae2:	df 91       	pop	r29
    3ae4:	1f 91       	pop	r17
    3ae6:	0f 91       	pop	r16
    3ae8:	ff 90       	pop	r15
    3aea:	ef 90       	pop	r14
    3aec:	df 90       	pop	r13
    3aee:	08 95       	ret

00003af0 <UpdateServerIP>:
	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
}
void UpdateServerIP(){     
    3af0:	cf 92       	push	r12
    3af2:	df 92       	push	r13
    3af4:	ef 92       	push	r14
    3af6:	ff 92       	push	r15
    3af8:	0f 93       	push	r16
    3afa:	1f 93       	push	r17
    3afc:	df 93       	push	r29
    3afe:	cf 93       	push	r28
    3b00:	cd b7       	in	r28, 0x3d	; 61
    3b02:	de b7       	in	r29, 0x3e	; 62
    3b04:	64 97       	sbiw	r28, 0x14	; 20
    3b06:	0f b6       	in	r0, 0x3f	; 63
    3b08:	f8 94       	cli
    3b0a:	de bf       	out	0x3e, r29	; 62
    3b0c:	0f be       	out	0x3f, r0	; 63
    3b0e:	cd bf       	out	0x3d, r28	; 61
    3b10:	8e 01       	movw	r16, r28
    3b12:	0f 5f       	subi	r16, 0xFF	; 255
    3b14:	1f 4f       	sbci	r17, 0xFF	; 255
    3b16:	c8 01       	movw	r24, r16
    3b18:	6c e2       	ldi	r22, 0x2C	; 44
    3b1a:	70 e0       	ldi	r23, 0x00	; 0
    3b1c:	44 e0       	ldi	r20, 0x04	; 4
    3b1e:	50 e0       	ldi	r21, 0x00	; 0
    3b20:	25 ed       	ldi	r18, 0xD5	; 213
    3b22:	32 e1       	ldi	r19, 0x12	; 18
    3b24:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
    3b28:	78 01       	movw	r14, r16
    3b2a:	8e 01       	movw	r16, r28
    3b2c:	0b 5f       	subi	r16, 0xFB	; 251
    3b2e:	1f 4f       	sbci	r17, 0xFF	; 255
	 char strIP[4][4];
	 //192.168.016.180
     eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);

	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
    3b30:	68 01       	movw	r12, r16
    3b32:	d7 01       	movw	r26, r14
    3b34:	8d 91       	ld	r24, X+
    3b36:	7d 01       	movw	r14, r26
    3b38:	b8 01       	movw	r22, r16
    3b3a:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <zeroIP>
    3b3e:	0c 5f       	subi	r16, 0xFC	; 252
    3b40:	1f 4f       	sbci	r17, 0xFF	; 255
     char i,IP_blok[4];
	 char strIP[4][4];
	 //192.168.016.180
     eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);

	 for(i=0;i<4;i++){
    3b42:	ec 14       	cp	r14, r12
    3b44:	fd 04       	cpc	r15, r13
    3b46:	a9 f7       	brne	.-22     	; 0x3b32 <UpdateServerIP+0x42>
	     zeroIP(IP_blok[i],strIP[i]);
	 }
		 sprintf_P(strServerIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
    3b48:	ed b7       	in	r30, 0x3d	; 61
    3b4a:	fe b7       	in	r31, 0x3e	; 62
    3b4c:	3c 97       	sbiw	r30, 0x0c	; 12
    3b4e:	0f b6       	in	r0, 0x3f	; 63
    3b50:	f8 94       	cli
    3b52:	fe bf       	out	0x3e, r31	; 62
    3b54:	0f be       	out	0x3f, r0	; 63
    3b56:	ed bf       	out	0x3d, r30	; 61
    3b58:	31 96       	adiw	r30, 0x01	; 1
    3b5a:	8b e3       	ldi	r24, 0x3B	; 59
    3b5c:	9a e0       	ldi	r25, 0x0A	; 10
    3b5e:	ad b7       	in	r26, 0x3d	; 61
    3b60:	be b7       	in	r27, 0x3e	; 62
    3b62:	12 96       	adiw	r26, 0x02	; 2
    3b64:	9c 93       	st	X, r25
    3b66:	8e 93       	st	-X, r24
    3b68:	11 97       	sbiw	r26, 0x01	; 1
    3b6a:	8e eb       	ldi	r24, 0xBE	; 190
    3b6c:	91 e2       	ldi	r25, 0x21	; 33
    3b6e:	93 83       	std	Z+3, r25	; 0x03
    3b70:	82 83       	std	Z+2, r24	; 0x02
    3b72:	f5 82       	std	Z+5, r15	; 0x05
    3b74:	e4 82       	std	Z+4, r14	; 0x04
    3b76:	ce 01       	movw	r24, r28
    3b78:	09 96       	adiw	r24, 0x09	; 9
    3b7a:	97 83       	std	Z+7, r25	; 0x07
    3b7c:	86 83       	std	Z+6, r24	; 0x06
    3b7e:	ce 01       	movw	r24, r28
    3b80:	0d 96       	adiw	r24, 0x0d	; 13
    3b82:	91 87       	std	Z+9, r25	; 0x09
    3b84:	80 87       	std	Z+8, r24	; 0x08
    3b86:	ce 01       	movw	r24, r28
    3b88:	41 96       	adiw	r24, 0x11	; 17
    3b8a:	93 87       	std	Z+11, r25	; 0x0b
    3b8c:	82 87       	std	Z+10, r24	; 0x0a
    3b8e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    3b92:	ed b7       	in	r30, 0x3d	; 61
    3b94:	fe b7       	in	r31, 0x3e	; 62
    3b96:	3c 96       	adiw	r30, 0x0c	; 12
    3b98:	0f b6       	in	r0, 0x3f	; 63
    3b9a:	f8 94       	cli
    3b9c:	fe bf       	out	0x3e, r31	; 62
    3b9e:	0f be       	out	0x3f, r0	; 63
    3ba0:	ed bf       	out	0x3d, r30	; 61
}
    3ba2:	64 96       	adiw	r28, 0x14	; 20
    3ba4:	0f b6       	in	r0, 0x3f	; 63
    3ba6:	f8 94       	cli
    3ba8:	de bf       	out	0x3e, r29	; 62
    3baa:	0f be       	out	0x3f, r0	; 63
    3bac:	cd bf       	out	0x3d, r28	; 61
    3bae:	cf 91       	pop	r28
    3bb0:	df 91       	pop	r29
    3bb2:	1f 91       	pop	r17
    3bb4:	0f 91       	pop	r16
    3bb6:	ff 90       	pop	r15
    3bb8:	ef 90       	pop	r14
    3bba:	df 90       	pop	r13
    3bbc:	cf 90       	pop	r12
    3bbe:	08 95       	ret

00003bc0 <UpdateClientIP>:
	     str[0]=('0'+S);
	     str[1]=0;
	 }
}

void UpdateClientIP(){     
    3bc0:	cf 92       	push	r12
    3bc2:	df 92       	push	r13
    3bc4:	ef 92       	push	r14
    3bc6:	ff 92       	push	r15
    3bc8:	0f 93       	push	r16
    3bca:	1f 93       	push	r17
    3bcc:	df 93       	push	r29
    3bce:	cf 93       	push	r28
    3bd0:	cd b7       	in	r28, 0x3d	; 61
    3bd2:	de b7       	in	r29, 0x3e	; 62
    3bd4:	68 97       	sbiw	r28, 0x18	; 24
    3bd6:	0f b6       	in	r0, 0x3f	; 63
    3bd8:	f8 94       	cli
    3bda:	de bf       	out	0x3e, r29	; 62
    3bdc:	0f be       	out	0x3f, r0	; 63
    3bde:	cd bf       	out	0x3d, r28	; 61
    3be0:	8e 01       	movw	r16, r28
    3be2:	0f 5f       	subi	r16, 0xFF	; 255
    3be4:	1f 4f       	sbci	r17, 0xFF	; 255
    3be6:	c8 01       	movw	r24, r16
    3be8:	68 e2       	ldi	r22, 0x28	; 40
    3bea:	70 e0       	ldi	r23, 0x00	; 0
    3bec:	44 e0       	ldi	r20, 0x04	; 4
    3bee:	50 e0       	ldi	r21, 0x00	; 0
    3bf0:	25 ed       	ldi	r18, 0xD5	; 213
    3bf2:	32 e1       	ldi	r19, 0x12	; 18
    3bf4:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
    3bf8:	78 01       	movw	r14, r16
    3bfa:	8e 01       	movw	r16, r28
    3bfc:	0b 5f       	subi	r16, 0xFB	; 251
    3bfe:	1f 4f       	sbci	r17, 0xFF	; 255
	 char strIP[4][5];
	 //192.168.010.002
     eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);

	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
    3c00:	68 01       	movw	r12, r16
    3c02:	d7 01       	movw	r26, r14
    3c04:	8d 91       	ld	r24, X+
    3c06:	7d 01       	movw	r14, r26
    3c08:	b8 01       	movw	r22, r16
    3c0a:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <zeroIP>
    3c0e:	0b 5f       	subi	r16, 0xFB	; 251
    3c10:	1f 4f       	sbci	r17, 0xFF	; 255
     char i,IP_blok[4];
	 char strIP[4][5];
	 //192.168.010.002
     eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);

	 for(i=0;i<4;i++){
    3c12:	ec 14       	cp	r14, r12
    3c14:	fd 04       	cpc	r15, r13
    3c16:	a9 f7       	brne	.-22     	; 0x3c02 <UpdateClientIP+0x42>
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
    3c18:	ed b7       	in	r30, 0x3d	; 61
    3c1a:	fe b7       	in	r31, 0x3e	; 62
    3c1c:	3c 97       	sbiw	r30, 0x0c	; 12
    3c1e:	0f b6       	in	r0, 0x3f	; 63
    3c20:	f8 94       	cli
    3c22:	fe bf       	out	0x3e, r31	; 62
    3c24:	0f be       	out	0x3f, r0	; 63
    3c26:	ed bf       	out	0x3d, r30	; 61
    3c28:	31 96       	adiw	r30, 0x01	; 1
    3c2a:	8e e0       	ldi	r24, 0x0E	; 14
    3c2c:	9a e0       	ldi	r25, 0x0A	; 10
    3c2e:	ad b7       	in	r26, 0x3d	; 61
    3c30:	be b7       	in	r27, 0x3e	; 62
    3c32:	12 96       	adiw	r26, 0x02	; 2
    3c34:	9c 93       	st	X, r25
    3c36:	8e 93       	st	-X, r24
    3c38:	11 97       	sbiw	r26, 0x01	; 1
    3c3a:	8a ec       	ldi	r24, 0xCA	; 202
    3c3c:	91 e2       	ldi	r25, 0x21	; 33
    3c3e:	93 83       	std	Z+3, r25	; 0x03
    3c40:	82 83       	std	Z+2, r24	; 0x02
    3c42:	f5 82       	std	Z+5, r15	; 0x05
    3c44:	e4 82       	std	Z+4, r14	; 0x04
    3c46:	ce 01       	movw	r24, r28
    3c48:	0a 96       	adiw	r24, 0x0a	; 10
    3c4a:	97 83       	std	Z+7, r25	; 0x07
    3c4c:	86 83       	std	Z+6, r24	; 0x06
    3c4e:	ce 01       	movw	r24, r28
    3c50:	0f 96       	adiw	r24, 0x0f	; 15
    3c52:	91 87       	std	Z+9, r25	; 0x09
    3c54:	80 87       	std	Z+8, r24	; 0x08
    3c56:	ce 01       	movw	r24, r28
    3c58:	44 96       	adiw	r24, 0x14	; 20
    3c5a:	93 87       	std	Z+11, r25	; 0x0b
    3c5c:	82 87       	std	Z+10, r24	; 0x0a
    3c5e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    3c62:	ed b7       	in	r30, 0x3d	; 61
    3c64:	fe b7       	in	r31, 0x3e	; 62
    3c66:	3c 96       	adiw	r30, 0x0c	; 12
    3c68:	0f b6       	in	r0, 0x3f	; 63
    3c6a:	f8 94       	cli
    3c6c:	fe bf       	out	0x3e, r31	; 62
    3c6e:	0f be       	out	0x3f, r0	; 63
    3c70:	ed bf       	out	0x3d, r30	; 61
}
    3c72:	68 96       	adiw	r28, 0x18	; 24
    3c74:	0f b6       	in	r0, 0x3f	; 63
    3c76:	f8 94       	cli
    3c78:	de bf       	out	0x3e, r29	; 62
    3c7a:	0f be       	out	0x3f, r0	; 63
    3c7c:	cd bf       	out	0x3d, r28	; 61
    3c7e:	cf 91       	pop	r28
    3c80:	df 91       	pop	r29
    3c82:	1f 91       	pop	r17
    3c84:	0f 91       	pop	r16
    3c86:	ff 90       	pop	r15
    3c88:	ef 90       	pop	r14
    3c8a:	df 90       	pop	r13
    3c8c:	cf 90       	pop	r12
    3c8e:	08 95       	ret

00003c90 <GenerateStandaloneTransData>:

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}


char GenerateStandaloneTransData(char xPumpID, char *PNozzle){//[1,2,3..16]->[1,2,3..0]
    3c90:	cf 92       	push	r12
    3c92:	df 92       	push	r13
    3c94:	ef 92       	push	r14
    3c96:	ff 92       	push	r15
    3c98:	0f 93       	push	r16
    3c9a:	1f 93       	push	r17
    3c9c:	df 93       	push	r29
    3c9e:	cf 93       	push	r28
    3ca0:	cd b7       	in	r28, 0x3d	; 61
    3ca2:	de b7       	in	r29, 0x3e	; 62
    3ca4:	2f 97       	sbiw	r28, 0x0f	; 15
    3ca6:	0f b6       	in	r0, 0x3f	; 63
    3ca8:	f8 94       	cli
    3caa:	de bf       	out	0x3e, r29	; 62
    3cac:	0f be       	out	0x3f, r0	; 63
    3cae:	cd bf       	out	0x3d, r28	; 61
    3cb0:	e8 2e       	mov	r14, r24
    3cb2:	8b 01       	movw	r16, r22
     char Result=GS_NONE;
	 char strSend[30];
	 char FIPAddr;

	 iPumpID=(xPumpID&0x0F);
	 FIPAddr=GetFIPAddr(iPumpID);
    3cb4:	8f 70       	andi	r24, 0x0F	; 15
    3cb6:	0e 94 1a 1c 	call	0x3834	; 0x3834 <GetFIPAddr>
     if (FIPAddr>0){
    3cba:	88 23       	and	r24, r24
    3cbc:	09 f4       	brne	.+2      	; 0x3cc0 <GenerateStandaloneTransData+0x30>
    3cbe:	2d c1       	rjmp	.+602    	; 0x3f1a <GenerateStandaloneTransData+0x28a>
	     FIPAddr=FIPAddr-1;
		 iProdID=PNozzle[RecPumpData[FIPAddr].Grade];
    3cc0:	81 50       	subi	r24, 0x01	; 1
    3cc2:	c8 2e       	mov	r12, r24
    3cc4:	dd 24       	eor	r13, r13
    3cc6:	85 e3       	ldi	r24, 0x35	; 53
    3cc8:	90 e0       	ldi	r25, 0x00	; 0
    3cca:	c8 9e       	mul	r12, r24
    3ccc:	f0 01       	movw	r30, r0
    3cce:	c9 9e       	mul	r12, r25
    3cd0:	f0 0d       	add	r31, r0
    3cd2:	d8 9e       	mul	r13, r24
    3cd4:	f0 0d       	add	r31, r0
    3cd6:	11 24       	eor	r1, r1
    3cd8:	e5 52       	subi	r30, 0x25	; 37
    3cda:	f8 4f       	sbci	r31, 0xF8	; 248
    3cdc:	80 81       	ld	r24, Z
    3cde:	08 0f       	add	r16, r24
    3ce0:	11 1d       	adc	r17, r1
    3ce2:	d8 01       	movw	r26, r16
    3ce4:	2c 91       	ld	r18, X
    3ce6:	ce 01       	movw	r24, r28
    3ce8:	01 96       	adiw	r24, 0x01	; 1

		 if (iProdID>0) eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[iProdID-1],sizeof(DefProductName[iProdID-1]));
    3cea:	22 23       	and	r18, r18
    3cec:	69 f0       	breq	.+26     	; 0x3d08 <GenerateStandaloneTransData+0x78>
    3cee:	6d e0       	ldi	r22, 0x0D	; 13
    3cf0:	26 9f       	mul	r18, r22
    3cf2:	b0 01       	movw	r22, r0
    3cf4:	11 24       	eor	r1, r1
    3cf6:	62 55       	subi	r22, 0x52	; 82
    3cf8:	7f 4f       	sbci	r23, 0xFF	; 255
    3cfa:	4d e0       	ldi	r20, 0x0D	; 13
    3cfc:	50 e0       	ldi	r21, 0x00	; 0
    3cfe:	25 ed       	ldi	r18, 0xD5	; 213
    3d00:	32 e1       	ldi	r19, 0x12	; 18
    3d02:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
    3d06:	10 c0       	rjmp	.+32     	; 0x3d28 <GenerateStandaloneTransData+0x98>
		 else sprintf_P(ProductName,PSTR("N/A"));
    3d08:	00 d0       	rcall	.+0      	; 0x3d0a <GenerateStandaloneTransData+0x7a>
    3d0a:	00 d0       	rcall	.+0      	; 0x3d0c <GenerateStandaloneTransData+0x7c>
    3d0c:	ed b7       	in	r30, 0x3d	; 61
    3d0e:	fe b7       	in	r31, 0x3e	; 62
    3d10:	92 83       	std	Z+2, r25	; 0x02
    3d12:	81 83       	std	Z+1, r24	; 0x01
    3d14:	8b e7       	ldi	r24, 0x7B	; 123
    3d16:	92 e2       	ldi	r25, 0x22	; 34
    3d18:	94 83       	std	Z+4, r25	; 0x04
    3d1a:	83 83       	std	Z+3, r24	; 0x03
    3d1c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    3d20:	0f 90       	pop	r0
    3d22:	0f 90       	pop	r0
    3d24:	0f 90       	pop	r0
    3d26:	0f 90       	pop	r0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3d28:	e1 99       	sbic	0x1c, 1	; 28
    3d2a:	fe cf       	rjmp	.-4      	; 0x3d28 <GenerateStandaloneTransData+0x98>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3d2c:	80 e0       	ldi	r24, 0x00	; 0
    3d2e:	90 e0       	ldi	r25, 0x00	; 0
    3d30:	9f bb       	out	0x1f, r25	; 31
    3d32:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3d34:	e0 9a       	sbi	0x1c, 0	; 28
    3d36:	fd b2       	in	r15, 0x1d	; 29

		 TermID=eeprom_read_byte(&DefIFT_ID);

		 //Shift,TransNum,Date,Time
		 sprintf_P(strShift,PSTR("%d"),RecPumpData[FIPAddr].Shift);
    3d38:	00 d0       	rcall	.+0      	; 0x3d3a <GenerateStandaloneTransData+0xaa>
    3d3a:	00 d0       	rcall	.+0      	; 0x3d3c <GenerateStandaloneTransData+0xac>
    3d3c:	00 d0       	rcall	.+0      	; 0x3d3e <GenerateStandaloneTransData+0xae>
    3d3e:	ad b7       	in	r26, 0x3d	; 61
    3d40:	be b7       	in	r27, 0x3e	; 62
    3d42:	11 96       	adiw	r26, 0x01	; 1
    3d44:	83 e9       	ldi	r24, 0x93	; 147
    3d46:	9e e0       	ldi	r25, 0x0E	; 14
    3d48:	ed b7       	in	r30, 0x3d	; 61
    3d4a:	fe b7       	in	r31, 0x3e	; 62
    3d4c:	92 83       	std	Z+2, r25	; 0x02
    3d4e:	81 83       	std	Z+1, r24	; 0x01
    3d50:	88 e7       	ldi	r24, 0x78	; 120
    3d52:	92 e2       	ldi	r25, 0x22	; 34
    3d54:	13 96       	adiw	r26, 0x03	; 3
    3d56:	9c 93       	st	X, r25
    3d58:	8e 93       	st	-X, r24
    3d5a:	12 97       	sbiw	r26, 0x02	; 2
    3d5c:	85 e3       	ldi	r24, 0x35	; 53
    3d5e:	90 e0       	ldi	r25, 0x00	; 0
    3d60:	c8 9e       	mul	r12, r24
    3d62:	80 01       	movw	r16, r0
    3d64:	c9 9e       	mul	r12, r25
    3d66:	10 0d       	add	r17, r0
    3d68:	d8 9e       	mul	r13, r24
    3d6a:	10 0d       	add	r17, r0
    3d6c:	11 24       	eor	r1, r1
    3d6e:	f8 01       	movw	r30, r16
    3d70:	e5 52       	subi	r30, 0x25	; 37
    3d72:	f8 4f       	sbci	r31, 0xF8	; 248
    3d74:	82 81       	ldd	r24, Z+2	; 0x02
    3d76:	14 96       	adiw	r26, 0x04	; 4
    3d78:	8c 93       	st	X, r24
    3d7a:	14 97       	sbiw	r26, 0x04	; 4
    3d7c:	15 96       	adiw	r26, 0x05	; 5
    3d7e:	1c 92       	st	X, r1
    3d80:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		 sprintf_P(strTranNo,PSTR("%s"),RecPumpData[FIPAddr].strTransNum);
    3d84:	ed b7       	in	r30, 0x3d	; 61
    3d86:	fe b7       	in	r31, 0x3e	; 62
    3d88:	31 96       	adiw	r30, 0x01	; 1
    3d8a:	81 eb       	ldi	r24, 0xB1	; 177
    3d8c:	9e e0       	ldi	r25, 0x0E	; 14
    3d8e:	ad b7       	in	r26, 0x3d	; 61
    3d90:	be b7       	in	r27, 0x3e	; 62
    3d92:	12 96       	adiw	r26, 0x02	; 2
    3d94:	9c 93       	st	X, r25
    3d96:	8e 93       	st	-X, r24
    3d98:	11 97       	sbiw	r26, 0x01	; 1
    3d9a:	85 e7       	ldi	r24, 0x75	; 117
    3d9c:	92 e2       	ldi	r25, 0x22	; 34
    3d9e:	93 83       	std	Z+3, r25	; 0x03
    3da0:	82 83       	std	Z+2, r24	; 0x02
    3da2:	c8 01       	movw	r24, r16
    3da4:	82 52       	subi	r24, 0x22	; 34
    3da6:	98 4f       	sbci	r25, 0xF8	; 248
    3da8:	95 83       	std	Z+5, r25	; 0x05
    3daa:	84 83       	std	Z+4, r24	; 0x04
    3dac:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	     sprintf_P(strDate,PSTR("%s"),RecPumpData[FIPAddr].strTransDate);
    3db0:	ed b7       	in	r30, 0x3d	; 61
    3db2:	fe b7       	in	r31, 0x3e	; 62
    3db4:	31 96       	adiw	r30, 0x01	; 1
    3db6:	81 ea       	ldi	r24, 0xA1	; 161
    3db8:	99 e0       	ldi	r25, 0x09	; 9
    3dba:	ad b7       	in	r26, 0x3d	; 61
    3dbc:	be b7       	in	r27, 0x3e	; 62
    3dbe:	12 96       	adiw	r26, 0x02	; 2
    3dc0:	9c 93       	st	X, r25
    3dc2:	8e 93       	st	-X, r24
    3dc4:	11 97       	sbiw	r26, 0x01	; 1
    3dc6:	82 e7       	ldi	r24, 0x72	; 114
    3dc8:	92 e2       	ldi	r25, 0x22	; 34
    3dca:	93 83       	std	Z+3, r25	; 0x03
    3dcc:	82 83       	std	Z+2, r24	; 0x02
    3dce:	c8 01       	movw	r24, r16
    3dd0:	8b 51       	subi	r24, 0x1B	; 27
    3dd2:	98 4f       	sbci	r25, 0xF8	; 248
    3dd4:	95 83       	std	Z+5, r25	; 0x05
    3dd6:	84 83       	std	Z+4, r24	; 0x04
    3dd8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		 sprintf_P(strTime,PSTR("%s"),RecPumpData[FIPAddr].strTransTime);	 
    3ddc:	ed b7       	in	r30, 0x3d	; 61
    3dde:	fe b7       	in	r31, 0x3e	; 62
    3de0:	31 96       	adiw	r30, 0x01	; 1
    3de2:	8d e2       	ldi	r24, 0x2D	; 45
    3de4:	95 e0       	ldi	r25, 0x05	; 5
    3de6:	ad b7       	in	r26, 0x3d	; 61
    3de8:	be b7       	in	r27, 0x3e	; 62
    3dea:	12 96       	adiw	r26, 0x02	; 2
    3dec:	9c 93       	st	X, r25
    3dee:	8e 93       	st	-X, r24
    3df0:	11 97       	sbiw	r26, 0x01	; 1
    3df2:	8f e6       	ldi	r24, 0x6F	; 111
    3df4:	92 e2       	ldi	r25, 0x22	; 34
    3df6:	93 83       	std	Z+3, r25	; 0x03
    3df8:	82 83       	std	Z+2, r24	; 0x02
    3dfa:	c8 01       	movw	r24, r16
    3dfc:	82 51       	subi	r24, 0x12	; 18
    3dfe:	98 4f       	sbci	r25, 0xF8	; 248
    3e00:	95 83       	std	Z+5, r25	; 0x05
    3e02:	84 83       	std	Z+4, r24	; 0x04
    3e04:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>

	     //TermID,FIP_ID,Product
		 sprintf_P(strIslandID,PSTR("%d"),TermID);
    3e08:	ed b7       	in	r30, 0x3d	; 61
    3e0a:	fe b7       	in	r31, 0x3e	; 62
    3e0c:	31 96       	adiw	r30, 0x01	; 1
    3e0e:	8f e1       	ldi	r24, 0x1F	; 31
    3e10:	9b e0       	ldi	r25, 0x0B	; 11
    3e12:	ad b7       	in	r26, 0x3d	; 61
    3e14:	be b7       	in	r27, 0x3e	; 62
    3e16:	12 96       	adiw	r26, 0x02	; 2
    3e18:	9c 93       	st	X, r25
    3e1a:	8e 93       	st	-X, r24
    3e1c:	11 97       	sbiw	r26, 0x01	; 1
    3e1e:	8c e6       	ldi	r24, 0x6C	; 108
    3e20:	92 e2       	ldi	r25, 0x22	; 34
    3e22:	93 83       	std	Z+3, r25	; 0x03
    3e24:	82 83       	std	Z+2, r24	; 0x02
    3e26:	f4 82       	std	Z+4, r15	; 0x04
    3e28:	15 82       	std	Z+5, r1	; 0x05
    3e2a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		 sprintf_P(strFIP_ID,PSTR("%.2d"),xPumpID);
    3e2e:	ed b7       	in	r30, 0x3d	; 61
    3e30:	fe b7       	in	r31, 0x3e	; 62
    3e32:	31 96       	adiw	r30, 0x01	; 1
    3e34:	8c ee       	ldi	r24, 0xEC	; 236
    3e36:	99 e0       	ldi	r25, 0x09	; 9
    3e38:	ad b7       	in	r26, 0x3d	; 61
    3e3a:	be b7       	in	r27, 0x3e	; 62
    3e3c:	12 96       	adiw	r26, 0x02	; 2
    3e3e:	9c 93       	st	X, r25
    3e40:	8e 93       	st	-X, r24
    3e42:	11 97       	sbiw	r26, 0x01	; 1
    3e44:	87 e6       	ldi	r24, 0x67	; 103
    3e46:	92 e2       	ldi	r25, 0x22	; 34
    3e48:	93 83       	std	Z+3, r25	; 0x03
    3e4a:	82 83       	std	Z+2, r24	; 0x02
    3e4c:	e4 82       	std	Z+4, r14	; 0x04
    3e4e:	15 82       	std	Z+5, r1	; 0x05
    3e50:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	     sprintf_P(strDescription,PSTR("%s"),ProductName);
    3e54:	ed b7       	in	r30, 0x3d	; 61
    3e56:	fe b7       	in	r31, 0x3e	; 62
    3e58:	31 96       	adiw	r30, 0x01	; 1
    3e5a:	81 e6       	ldi	r24, 0x61	; 97
    3e5c:	9a e0       	ldi	r25, 0x0A	; 10
    3e5e:	ad b7       	in	r26, 0x3d	; 61
    3e60:	be b7       	in	r27, 0x3e	; 62
    3e62:	12 96       	adiw	r26, 0x02	; 2
    3e64:	9c 93       	st	X, r25
    3e66:	8e 93       	st	-X, r24
    3e68:	11 97       	sbiw	r26, 0x01	; 1
    3e6a:	84 e6       	ldi	r24, 0x64	; 100
    3e6c:	92 e2       	ldi	r25, 0x22	; 34
    3e6e:	93 83       	std	Z+3, r25	; 0x03
    3e70:	82 83       	std	Z+2, r24	; 0x02
    3e72:	ce 01       	movw	r24, r28
    3e74:	01 96       	adiw	r24, 0x01	; 1
    3e76:	95 83       	std	Z+5, r25	; 0x05
    3e78:	84 83       	std	Z+4, r24	; 0x04
    3e7a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>

		 //Price Volume Money
		 sprintf_P(strPrice,PSTR("%s"),RecPumpData[FIPAddr].Price);
    3e7e:	ed b7       	in	r30, 0x3d	; 61
    3e80:	fe b7       	in	r31, 0x3e	; 62
    3e82:	31 96       	adiw	r30, 0x01	; 1
    3e84:	81 ed       	ldi	r24, 0xD1	; 209
    3e86:	97 e0       	ldi	r25, 0x07	; 7
    3e88:	ad b7       	in	r26, 0x3d	; 61
    3e8a:	be b7       	in	r27, 0x3e	; 62
    3e8c:	12 96       	adiw	r26, 0x02	; 2
    3e8e:	9c 93       	st	X, r25
    3e90:	8e 93       	st	-X, r24
    3e92:	11 97       	sbiw	r26, 0x01	; 1
    3e94:	81 e6       	ldi	r24, 0x61	; 97
    3e96:	92 e2       	ldi	r25, 0x22	; 34
    3e98:	93 83       	std	Z+3, r25	; 0x03
    3e9a:	82 83       	std	Z+2, r24	; 0x02
    3e9c:	c8 01       	movw	r24, r16
    3e9e:	89 50       	subi	r24, 0x09	; 9
    3ea0:	98 4f       	sbci	r25, 0xF8	; 248
    3ea2:	95 83       	std	Z+5, r25	; 0x05
    3ea4:	84 83       	std	Z+4, r24	; 0x04
    3ea6:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	     sprintf_P(strVolume,PSTR("%s"),RecPumpData[FIPAddr].Volume);
    3eaa:	ed b7       	in	r30, 0x3d	; 61
    3eac:	fe b7       	in	r31, 0x3e	; 62
    3eae:	31 96       	adiw	r30, 0x01	; 1
    3eb0:	85 e5       	ldi	r24, 0x55	; 85
    3eb2:	95 e0       	ldi	r25, 0x05	; 5
    3eb4:	ad b7       	in	r26, 0x3d	; 61
    3eb6:	be b7       	in	r27, 0x3e	; 62
    3eb8:	12 96       	adiw	r26, 0x02	; 2
    3eba:	9c 93       	st	X, r25
    3ebc:	8e 93       	st	-X, r24
    3ebe:	11 97       	sbiw	r26, 0x01	; 1
    3ec0:	8e e5       	ldi	r24, 0x5E	; 94
    3ec2:	92 e2       	ldi	r25, 0x22	; 34
    3ec4:	93 83       	std	Z+3, r25	; 0x03
    3ec6:	82 83       	std	Z+2, r24	; 0x02
    3ec8:	c8 01       	movw	r24, r16
    3eca:	82 50       	subi	r24, 0x02	; 2
    3ecc:	98 4f       	sbci	r25, 0xF8	; 248
    3ece:	95 83       	std	Z+5, r25	; 0x05
    3ed0:	84 83       	std	Z+4, r24	; 0x04
    3ed2:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		 sprintf_P(strAmount,PSTR("%s"),RecPumpData[FIPAddr].Money);
    3ed6:	ed b7       	in	r30, 0x3d	; 61
    3ed8:	fe b7       	in	r31, 0x3e	; 62
    3eda:	31 96       	adiw	r30, 0x01	; 1
    3edc:	8b ed       	ldi	r24, 0xDB	; 219
    3ede:	9d e0       	ldi	r25, 0x0D	; 13
    3ee0:	ad b7       	in	r26, 0x3d	; 61
    3ee2:	be b7       	in	r27, 0x3e	; 62
    3ee4:	12 96       	adiw	r26, 0x02	; 2
    3ee6:	9c 93       	st	X, r25
    3ee8:	8e 93       	st	-X, r24
    3eea:	11 97       	sbiw	r26, 0x01	; 1
    3eec:	8b e5       	ldi	r24, 0x5B	; 91
    3eee:	92 e2       	ldi	r25, 0x22	; 34
    3ef0:	93 83       	std	Z+3, r25	; 0x03
    3ef2:	82 83       	std	Z+2, r24	; 0x02
    3ef4:	09 5f       	subi	r16, 0xF9	; 249
    3ef6:	17 4f       	sbci	r17, 0xF7	; 247
    3ef8:	15 83       	std	Z+5, r17	; 0x05
    3efa:	04 83       	std	Z+4, r16	; 0x04
    3efc:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>

		 MOPType=MOP_CASH;
    3f00:	10 92 cf 01 	sts	0x01CF, r1
	     IsPrinting=True;	 
    3f04:	81 e0       	ldi	r24, 0x01	; 1
    3f06:	80 93 c3 01 	sts	0x01C3, r24
    3f0a:	ed b7       	in	r30, 0x3d	; 61
    3f0c:	fe b7       	in	r31, 0x3e	; 62
    3f0e:	36 96       	adiw	r30, 0x06	; 6
    3f10:	0f b6       	in	r0, 0x3f	; 63
    3f12:	f8 94       	cli
    3f14:	fe bf       	out	0x3e, r31	; 62
    3f16:	0f be       	out	0x3f, r0	; 63
    3f18:	ed bf       	out	0x3d, r30	; 61
	 }
	 //ProductName	 
	 //iProdID=PNozzle[RecPumpData[iPumpID].Nozzle];
	 //BAsedOnGrade
   return Result;
}
    3f1a:	2f 96       	adiw	r28, 0x0f	; 15
    3f1c:	0f b6       	in	r0, 0x3f	; 63
    3f1e:	f8 94       	cli
    3f20:	de bf       	out	0x3e, r29	; 62
    3f22:	0f be       	out	0x3f, r0	; 63
    3f24:	cd bf       	out	0x3d, r28	; 61
    3f26:	cf 91       	pop	r28
    3f28:	df 91       	pop	r29
    3f2a:	1f 91       	pop	r17
    3f2c:	0f 91       	pop	r16
    3f2e:	ff 90       	pop	r15
    3f30:	ef 90       	pop	r14
    3f32:	df 90       	pop	r13
    3f34:	cf 90       	pop	r12
    3f36:	08 95       	ret

00003f38 <PrintStandalone>:
     char Result=PS_NONE;

   return Result;
}

char PrintStandalone(char FIPAddr,char IsReprint){
    3f38:	ef 92       	push	r14
    3f3a:	ff 92       	push	r15
    3f3c:	0f 93       	push	r16
    3f3e:	1f 93       	push	r17
    3f40:	df 93       	push	r29
    3f42:	cf 93       	push	r28
    3f44:	00 d0       	rcall	.+0      	; 0x3f46 <PrintStandalone+0xe>
    3f46:	00 d0       	rcall	.+0      	; 0x3f48 <PrintStandalone+0x10>
    3f48:	00 d0       	rcall	.+0      	; 0x3f4a <PrintStandalone+0x12>
    3f4a:	cd b7       	in	r28, 0x3d	; 61
    3f4c:	de b7       	in	r29, 0x3e	; 62
    3f4e:	f8 2e       	mov	r15, r24
    3f50:	06 2f       	mov	r16, r22
	 char LFIPAddr;
	      
	 Result=PS_NO_DATA;

//	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
	 iPumpID=GetPumpID(FIPAddr);//PPumpID[FIPAddr-1];
    3f52:	0e 94 af 1c 	call	0x395e	; 0x395e <GetPumpID>
    3f56:	e8 2e       	mov	r14, r24
     LFIPAddr=GetFIPAddr(iPumpID);
    3f58:	0e 94 1a 1c 	call	0x3834	; 0x3834 <GetFIPAddr>
    3f5c:	18 2f       	mov	r17, r24

     if (LFIPAddr>0){
    3f5e:	88 23       	and	r24, r24
    3f60:	99 f1       	breq	.+102    	; 0x3fc8 <PrintStandalone+0x90>
	     LFIPAddr=LFIPAddr-1;
	     if ((IsReprint==True)||(iPumpID>0)&&(strPumpStatus[LFIPAddr]==GetPumpStatusLabel(PS_PRINT_READY))){    	 
    3f62:	01 30       	cpi	r16, 0x01	; 1
    3f64:	69 f0       	breq	.+26     	; 0x3f80 <PrintStandalone+0x48>
    3f66:	ee 20       	and	r14, r14
    3f68:	79 f1       	breq	.+94     	; 0x3fc8 <PrintStandalone+0x90>
    3f6a:	80 e1       	ldi	r24, 0x10	; 16
    3f6c:	0e 94 72 13 	call	0x26e4	; 0x26e4 <GetPumpStatusLabel>
    3f70:	11 50       	subi	r17, 0x01	; 1
    3f72:	e1 2f       	mov	r30, r17
    3f74:	f0 e0       	ldi	r31, 0x00	; 0
    3f76:	ee 5e       	subi	r30, 0xEE	; 238
    3f78:	fe 4f       	sbci	r31, 0xFE	; 254
    3f7a:	90 81       	ld	r25, Z
    3f7c:	98 17       	cp	r25, r24
    3f7e:	21 f5       	brne	.+72     	; 0x3fc8 <PrintStandalone+0x90>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3f80:	66 e0       	ldi	r22, 0x06	; 6
    3f82:	f6 9e       	mul	r15, r22
    3f84:	b0 01       	movw	r22, r0
    3f86:	11 24       	eor	r1, r1
    3f88:	61 5b       	subi	r22, 0xB1	; 177
    3f8a:	7f 4f       	sbci	r23, 0xFF	; 255
    3f8c:	ce 01       	movw	r24, r28
    3f8e:	01 96       	adiw	r24, 0x01	; 1
    3f90:	46 e0       	ldi	r20, 0x06	; 6
    3f92:	50 e0       	ldi	r21, 0x00	; 0
    3f94:	25 ed       	ldi	r18, 0xD5	; 213
    3f96:	32 e1       	ldi	r19, 0x12	; 18
    3f98:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
		     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);		 
		     if (((ReprintReady[FIPAddr-1]==True))||(IsReprint==False)){
    3f9c:	ef 2d       	mov	r30, r15
    3f9e:	f0 e0       	ldi	r31, 0x00	; 0
    3fa0:	ef 57       	subi	r30, 0x7F	; 127
    3fa2:	fe 4f       	sbci	r31, 0xFE	; 254
    3fa4:	80 81       	ld	r24, Z
    3fa6:	81 30       	cpi	r24, 0x01	; 1
    3fa8:	19 f0       	breq	.+6      	; 0x3fb0 <PrintStandalone+0x78>
    3faa:	00 23       	and	r16, r16
    3fac:	29 f0       	breq	.+10     	; 0x3fb8 <PrintStandalone+0x80>
    3fae:	0c c0       	rjmp	.+24     	; 0x3fc8 <PrintStandalone+0x90>
			       if (IsReprint==True)IsReprintTicket=True;
    3fb0:	01 30       	cpi	r16, 0x01	; 1
    3fb2:	11 f4       	brne	.+4      	; 0x3fb8 <PrintStandalone+0x80>
    3fb4:	00 93 92 01 	sts	0x0192, r16
			       GenerateStandaloneTransData(iPumpID,PProductID);		 			   
    3fb8:	8e 2d       	mov	r24, r14
    3fba:	be 01       	movw	r22, r28
    3fbc:	6f 5f       	subi	r22, 0xFF	; 255
    3fbe:	7f 4f       	sbci	r23, 0xFF	; 255
    3fc0:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <GenerateStandaloneTransData>
    3fc4:	81 e1       	ldi	r24, 0x11	; 17
    3fc6:	01 c0       	rjmp	.+2      	; 0x3fca <PrintStandalone+0x92>
    3fc8:	82 e1       	ldi	r24, 0x12	; 18
			 }//else Result=PS_NO_DATA;
		 }
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}
    3fca:	26 96       	adiw	r28, 0x06	; 6
    3fcc:	0f b6       	in	r0, 0x3f	; 63
    3fce:	f8 94       	cli
    3fd0:	de bf       	out	0x3e, r29	; 62
    3fd2:	0f be       	out	0x3f, r0	; 63
    3fd4:	cd bf       	out	0x3d, r28	; 61
    3fd6:	cf 91       	pop	r28
    3fd8:	df 91       	pop	r29
    3fda:	1f 91       	pop	r17
    3fdc:	0f 91       	pop	r16
    3fde:	ff 90       	pop	r15
    3fe0:	ef 90       	pop	r14
    3fe2:	08 95       	ret

00003fe4 <SumChecksum>:
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}

char SumChecksum(char *strChecked){
    3fe4:	ac 01       	movw	r20, r24
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    3fe6:	dc 01       	movw	r26, r24
    3fe8:	0d 90       	ld	r0, X+
    3fea:	00 20       	and	r0, r0
    3fec:	e9 f7       	brne	.-6      	; 0x3fe8 <SumChecksum+0x4>
    3fee:	11 97       	sbiw	r26, 0x01	; 1
    3ff0:	a8 1b       	sub	r26, r24
    3ff2:	b9 0b       	sbc	r27, r25
    3ff4:	20 e0       	ldi	r18, 0x00	; 0
    3ff6:	30 e0       	ldi	r19, 0x00	; 0
    3ff8:	90 e0       	ldi	r25, 0x00	; 0
    3ffa:	06 c0       	rjmp	.+12     	; 0x4008 <SumChecksum+0x24>
	     SigmaSum=SigmaSum+strChecked[i];
    3ffc:	e4 0f       	add	r30, r20
    3ffe:	f5 1f       	adc	r31, r21
    4000:	80 81       	ld	r24, Z
    4002:	28 0f       	add	r18, r24
    4004:	31 1d       	adc	r19, r1
}

char SumChecksum(char *strChecked){
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    4006:	9f 5f       	subi	r25, 0xFF	; 255
    4008:	e9 2f       	mov	r30, r25
    400a:	f0 e0       	ldi	r31, 0x00	; 0
    400c:	ea 17       	cp	r30, r26
    400e:	fb 07       	cpc	r31, r27
    4010:	a8 f3       	brcs	.-22     	; 0x3ffc <SumChecksum+0x18>
	     SigmaSum=SigmaSum+strChecked[i];
	 }
	 Result=(SigmaSum%255);
    4012:	c9 01       	movw	r24, r18
    4014:	6f ef       	ldi	r22, 0xFF	; 255
    4016:	70 e0       	ldi	r23, 0x00	; 0
    4018:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
	 if (Result==0)Result=255;
    401c:	88 23       	and	r24, r24
    401e:	09 f4       	brne	.+2      	; 0x4022 <SumChecksum+0x3e>
    4020:	8f ef       	ldi	r24, 0xFF	; 255
   return Result;
}
    4022:	08 95       	ret

00004024 <IsGeniusCommand>:
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 _uart_print(1,1,strSend);
*/
}

char IsGeniusCommand(char GCommand){
    4024:	ff 92       	push	r15
    4026:	0f 93       	push	r16
    4028:	1f 93       	push	r17
    402a:	df 93       	push	r29
    402c:	cf 93       	push	r28
    402e:	cd b7       	in	r28, 0x3d	; 61
    4030:	de b7       	in	r29, 0x3e	; 62
    4032:	2a 97       	sbiw	r28, 0x0a	; 10
    4034:	0f b6       	in	r0, 0x3f	; 63
    4036:	f8 94       	cli
    4038:	de bf       	out	0x3e, r29	; 62
    403a:	0f be       	out	0x3f, r0	; 63
    403c:	cd bf       	out	0x3d, r28	; 61
    403e:	f8 2e       	mov	r15, r24
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
    4040:	00 d0       	rcall	.+0      	; 0x4042 <IsGeniusCommand+0x1e>
    4042:	00 d0       	rcall	.+0      	; 0x4044 <IsGeniusCommand+0x20>
    4044:	8e 01       	movw	r16, r28
    4046:	0f 5f       	subi	r16, 0xFF	; 255
    4048:	1f 4f       	sbci	r17, 0xFF	; 255
    404a:	ed b7       	in	r30, 0x3d	; 61
    404c:	fe b7       	in	r31, 0x3e	; 62
    404e:	12 83       	std	Z+2, r17	; 0x02
    4050:	01 83       	std	Z+1, r16	; 0x01
    4052:	81 e7       	ldi	r24, 0x71	; 113
    4054:	93 e0       	ldi	r25, 0x03	; 3
    4056:	94 83       	std	Z+4, r25	; 0x04
    4058:	83 83       	std	Z+3, r24	; 0x03
    405a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	 for(i=0;i<strlen(CommandList);i++){
    405e:	d8 01       	movw	r26, r16
    4060:	0d 90       	ld	r0, X+
    4062:	00 20       	and	r0, r0
    4064:	e9 f7       	brne	.-6      	; 0x4060 <IsGeniusCommand+0x3c>
    4066:	11 97       	sbiw	r26, 0x01	; 1
    4068:	a0 1b       	sub	r26, r16
    406a:	b1 0b       	sbc	r27, r17
    406c:	90 e0       	ldi	r25, 0x00	; 0
    406e:	0f 90       	pop	r0
    4070:	0f 90       	pop	r0
    4072:	0f 90       	pop	r0
    4074:	0f 90       	pop	r0
	    if (CommandList[i]==GCommand){
    4076:	98 01       	movw	r18, r16
    4078:	08 c0       	rjmp	.+16     	; 0x408a <IsGeniusCommand+0x66>
    407a:	e2 0f       	add	r30, r18
    407c:	f3 1f       	adc	r31, r19
    407e:	80 81       	ld	r24, Z
    4080:	8f 15       	cp	r24, r15
    4082:	11 f4       	brne	.+4      	; 0x4088 <IsGeniusCommand+0x64>
    4084:	81 e0       	ldi	r24, 0x01	; 1
    4086:	07 c0       	rjmp	.+14     	; 0x4096 <IsGeniusCommand+0x72>

char IsGeniusCommand(char GCommand){
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
	 for(i=0;i<strlen(CommandList);i++){
    4088:	9f 5f       	subi	r25, 0xFF	; 255
    408a:	e9 2f       	mov	r30, r25
    408c:	f0 e0       	ldi	r31, 0x00	; 0
    408e:	ea 17       	cp	r30, r26
    4090:	fb 07       	cpc	r31, r27
    4092:	98 f3       	brcs	.-26     	; 0x407a <IsGeniusCommand+0x56>
    4094:	80 e0       	ldi	r24, 0x00	; 0
		    Result=True;
			break;
			}
	 }
   return Result;	 
}
    4096:	2a 96       	adiw	r28, 0x0a	; 10
    4098:	0f b6       	in	r0, 0x3f	; 63
    409a:	f8 94       	cli
    409c:	de bf       	out	0x3e, r29	; 62
    409e:	0f be       	out	0x3f, r0	; 63
    40a0:	cd bf       	out	0x3d, r28	; 61
    40a2:	cf 91       	pop	r28
    40a4:	df 91       	pop	r29
    40a6:	1f 91       	pop	r17
    40a8:	0f 91       	pop	r16
    40aa:	ff 90       	pop	r15
    40ac:	08 95       	ret

000040ae <Pos>:
  return Result;
}
		

//Genius Protocol Version:1.0 AKR
int Pos(char *Substr, char *String){//1245:4645
    40ae:	0f 93       	push	r16
    40b0:	1f 93       	push	r17
    40b2:	cf 93       	push	r28
    40b4:	df 93       	push	r29
    40b6:	ac 01       	movw	r20, r24
    char i,j,CountMatch;
	char Length,subLen,PosFound;

	Length=strlen(String);
    40b8:	fb 01       	movw	r30, r22
    40ba:	01 90       	ld	r0, Z+
    40bc:	00 20       	and	r0, r0
    40be:	e9 f7       	brne	.-6      	; 0x40ba <Pos+0xc>
    40c0:	31 97       	sbiw	r30, 0x01	; 1
    40c2:	1e 2f       	mov	r17, r30
    40c4:	16 1b       	sub	r17, r22
	subLen=strlen(Substr);
    40c6:	fc 01       	movw	r30, r24
    40c8:	01 90       	ld	r0, Z+
    40ca:	00 20       	and	r0, r0
    40cc:	e9 f7       	brne	.-6      	; 0x40c8 <Pos+0x1a>
    40ce:	31 97       	sbiw	r30, 0x01	; 1
    40d0:	0e 2f       	mov	r16, r30
    40d2:	08 1b       	sub	r16, r24
    40d4:	db 01       	movw	r26, r22
    40d6:	60 e0       	ldi	r22, 0x00	; 0
    40d8:	18 c0       	rjmp	.+48     	; 0x410a <Pos+0x5c>
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
    40da:	9c 91       	ld	r25, X
    40dc:	fa 01       	movw	r30, r20
    40de:	80 81       	ld	r24, Z
    40e0:	98 17       	cp	r25, r24
    40e2:	89 f4       	brne	.+34     	; 0x4106 <Pos+0x58>
    40e4:	ed 01       	movw	r28, r26
    40e6:	20 e0       	ldi	r18, 0x00	; 0
    40e8:	30 e0       	ldi	r19, 0x00	; 0
    40ea:	09 c0       	rjmp	.+18     	; 0x40fe <Pos+0x50>
		    CountMatch=0;
			for(j=0;j<subLen;j++){
			    //notFound
			    if (Substr[j]==String[i+j]){
    40ec:	fa 01       	movw	r30, r20
    40ee:	e2 0f       	add	r30, r18
    40f0:	f3 1f       	adc	r31, r19
    40f2:	90 81       	ld	r25, Z
    40f4:	89 91       	ld	r24, Y+
    40f6:	2f 5f       	subi	r18, 0xFF	; 255
    40f8:	3f 4f       	sbci	r19, 0xFF	; 255
    40fa:	98 17       	cp	r25, r24
    40fc:	21 f4       	brne	.+8      	; 0x4106 <Pos+0x58>
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
		    CountMatch=0;
			for(j=0;j<subLen;j++){
    40fe:	20 17       	cp	r18, r16
    4100:	a8 f3       	brcs	.-22     	; 0x40ec <Pos+0x3e>
    4102:	86 2f       	mov	r24, r22
    4104:	05 c0       	rjmp	.+10     	; 0x4110 <Pos+0x62>
	char Length,subLen,PosFound;

	Length=strlen(String);
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
    4106:	6f 5f       	subi	r22, 0xFF	; 255
    4108:	11 96       	adiw	r26, 0x01	; 1
    410a:	61 17       	cp	r22, r17
    410c:	30 f3       	brcs	.-52     	; 0x40da <Pos+0x2c>
    410e:	81 2f       	mov	r24, r17
			    break;  
			}
		}
	}
  return  PosFound;
}
    4110:	90 e0       	ldi	r25, 0x00	; 0
    4112:	df 91       	pop	r29
    4114:	cf 91       	pop	r28
    4116:	1f 91       	pop	r17
    4118:	0f 91       	pop	r16
    411a:	08 95       	ret

0000411c <CreateReport>:
//		  }
//	 }
     *Pos=iPos;
}

void CreateReport(char *strData, char *strPrnBuffer, unsigned int *Pos){
    411c:	7f 92       	push	r7
    411e:	8f 92       	push	r8
    4120:	9f 92       	push	r9
    4122:	af 92       	push	r10
    4124:	bf 92       	push	r11
    4126:	cf 92       	push	r12
    4128:	df 92       	push	r13
    412a:	ef 92       	push	r14
    412c:	ff 92       	push	r15
    412e:	0f 93       	push	r16
    4130:	1f 93       	push	r17
    4132:	cf 93       	push	r28
    4134:	df 93       	push	r29
    4136:	5c 01       	movw	r10, r24
    4138:	6b 01       	movw	r12, r22
    413a:	4a 01       	movw	r8, r20
     unsigned int iPos,PosResult,Length;
	 char i,strSend[20];
	 Length=strlen(strData);
    413c:	ec 01       	movw	r28, r24
    413e:	09 90       	ld	r0, Y+
    4140:	00 20       	and	r0, r0
    4142:	e9 f7       	brne	.-6      	; 0x413e <CreateReport+0x22>
    4144:	21 97       	sbiw	r28, 0x01	; 1
    4146:	c8 1b       	sub	r28, r24
    4148:	d9 0b       	sbc	r29, r25
    414a:	cb 32       	cpi	r28, 0x2B	; 43
    414c:	d1 05       	cpc	r29, r1
    414e:	10 f0       	brcs	.+4      	; 0x4154 <CreateReport+0x38>
    4150:	ca e2       	ldi	r28, 0x2A	; 42
    4152:	d0 e0       	ldi	r29, 0x00	; 0
	 if (Length>BORDER_LENGTH)Length=BORDER_LENGTH;
     
	 iPos=*Pos;
    4154:	f4 01       	movw	r30, r8
    4156:	00 81       	ld	r16, Z
    4158:	11 81       	ldd	r17, Z+1	; 0x01
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    415a:	76 01       	movw	r14, r12
    415c:	e0 0e       	add	r14, r16
    415e:	f1 1e       	adc	r15, r17
    4160:	8a e0       	ldi	r24, 0x0A	; 10
    4162:	0e 94 24 1a 	call	0x3448	; 0x3448 <GetBorderValue>
    4166:	78 2e       	mov	r7, r24
    4168:	f7 01       	movw	r30, r14
    416a:	80 83       	st	Z, r24
     iPos++;
    416c:	98 01       	movw	r18, r16
    416e:	2f 5f       	subi	r18, 0xFF	; 255
    4170:	3f 4f       	sbci	r19, 0xFF	; 255
    4172:	d7 01       	movw	r26, r14
    4174:	90 e0       	ldi	r25, 0x00	; 0
    4176:	07 c0       	rjmp	.+14     	; 0x4186 <CreateReport+0x6a>

	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
    4178:	ea 0d       	add	r30, r10
    417a:	fb 1d       	adc	r31, r11
    417c:	80 81       	ld	r24, Z
    417e:	8c 93       	st	X, r24
		  iPos++;
    4180:	2f 5f       	subi	r18, 0xFF	; 255
    4182:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 iPos=*Pos;
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
     iPos++;

	 for (i=0;i<Length;i++){	      
    4184:	9f 5f       	subi	r25, 0xFF	; 255
    4186:	e9 2f       	mov	r30, r25
    4188:	f0 e0       	ldi	r31, 0x00	; 0
    418a:	11 96       	adiw	r26, 0x01	; 1
    418c:	ec 17       	cp	r30, r28
    418e:	fd 07       	cpc	r31, r29
    4190:	98 f3       	brcs	.-26     	; 0x4178 <CreateReport+0x5c>
    4192:	62 2f       	mov	r22, r18
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
    4194:	ca 32       	cpi	r28, 0x2A	; 42
    4196:	d1 05       	cpc	r29, r1
    4198:	91 f0       	breq	.+36     	; 0x41be <CreateReport+0xa2>
    419a:	f6 01       	movw	r30, r12
    419c:	e2 0f       	add	r30, r18
    419e:	f3 1f       	adc	r31, r19
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    41a0:	4a e2       	ldi	r20, 0x2A	; 42
    41a2:	50 e0       	ldi	r21, 0x00	; 0
    41a4:	4c 1b       	sub	r20, r28
    41a6:	5d 0b       	sbc	r21, r29
	          strPrnBuffer[iPos]=' ';
    41a8:	70 e2       	ldi	r23, 0x20	; 32
    41aa:	03 c0       	rjmp	.+6      	; 0x41b2 <CreateReport+0x96>
    41ac:	71 93       	st	Z+, r23
		      iPos++;
    41ae:	2f 5f       	subi	r18, 0xFF	; 255
    41b0:	3f 4f       	sbci	r19, 0xFF	; 255
	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    41b2:	82 2f       	mov	r24, r18
    41b4:	86 1b       	sub	r24, r22
    41b6:	90 e0       	ldi	r25, 0x00	; 0
    41b8:	84 17       	cp	r24, r20
    41ba:	95 07       	cpc	r25, r21
    41bc:	b8 f3       	brcs	.-18     	; 0x41ac <CreateReport+0x90>
	          strPrnBuffer[iPos]=' ';
		      iPos++;
	     }	    
	 }
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    41be:	f6 01       	movw	r30, r12
    41c0:	e2 0f       	add	r30, r18
    41c2:	f3 1f       	adc	r31, r19
    41c4:	70 82       	st	Z, r7
     iPos++;
    41c6:	c9 01       	movw	r24, r18
    41c8:	01 96       	adiw	r24, 0x01	; 1
     //PosResult=*Pos+Length;
	 strPrnBuffer[iPos]=0x0D; 
    41ca:	c8 0e       	add	r12, r24
    41cc:	d9 1e       	adc	r13, r25
    41ce:	2d e0       	ldi	r18, 0x0D	; 13
    41d0:	f6 01       	movw	r30, r12
    41d2:	20 83       	st	Z, r18
	 iPos++;

   //*Pos=PosResult+1;
   *Pos=iPos;
    41d4:	01 96       	adiw	r24, 0x01	; 1
    41d6:	f4 01       	movw	r30, r8
    41d8:	91 83       	std	Z+1, r25	; 0x01
    41da:	80 83       	st	Z, r24
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//_uart_print(0,1,strSend);
}
    41dc:	df 91       	pop	r29
    41de:	cf 91       	pop	r28
    41e0:	1f 91       	pop	r17
    41e2:	0f 91       	pop	r16
    41e4:	ff 90       	pop	r15
    41e6:	ef 90       	pop	r14
    41e8:	df 90       	pop	r13
    41ea:	cf 90       	pop	r12
    41ec:	bf 90       	pop	r11
    41ee:	af 90       	pop	r10
    41f0:	9f 90       	pop	r9
    41f2:	8f 90       	pop	r8
    41f4:	7f 90       	pop	r7
    41f6:	08 95       	ret

000041f8 <AddList>:

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
void AddList(char GradeId, char *strList){
    41f8:	38 2f       	mov	r19, r24
    41fa:	ab 01       	movw	r20, r22
     char i,iPos,Length,IsFound=False;	 
	 if ((GradeId>=1)&&((GradeId<=6))){
    41fc:	81 50       	subi	r24, 0x01	; 1
    41fe:	86 30       	cpi	r24, 0x06	; 6
    4200:	68 f5       	brcc	.+90     	; 0x425c <AddList+0x64>
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
    4202:	fb 01       	movw	r30, r22
    4204:	01 90       	ld	r0, Z+
    4206:	00 20       	and	r0, r0
    4208:	e9 f7       	brne	.-6      	; 0x4204 <AddList+0xc>
    420a:	31 97       	sbiw	r30, 0x01	; 1
    420c:	e6 1b       	sub	r30, r22
    420e:	f7 0b       	sbc	r31, r23
    4210:	7e 2f       	mov	r23, r30
	     if (Length>0){
    4212:	ee 23       	and	r30, r30
    4214:	11 f4       	brne	.+4      	; 0x421a <AddList+0x22>
    4216:	20 e0       	ldi	r18, 0x00	; 0
    4218:	14 c0       	rjmp	.+40     	; 0x4242 <AddList+0x4a>
    421a:	80 e0       	ldi	r24, 0x00	; 0
    421c:	90 e0       	ldi	r25, 0x00	; 0
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    421e:	63 2f       	mov	r22, r19
    4220:	60 5d       	subi	r22, 0xD0	; 208
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //_uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4222:	fa 01       	movw	r30, r20
    4224:	e8 0f       	add	r30, r24
    4226:	f9 1f       	adc	r31, r25
    4228:	e0 81       	ld	r30, Z
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    422a:	3a 30       	cpi	r19, 0x0A	; 10
    422c:	10 f0       	brcs	.+4      	; 0x4232 <AddList+0x3a>
    422e:	20 e3       	ldi	r18, 0x30	; 48
    4230:	01 c0       	rjmp	.+2      	; 0x4234 <AddList+0x3c>
	    Result='0'+X;
    4232:	26 2f       	mov	r18, r22
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //_uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4234:	e2 17       	cp	r30, r18
    4236:	91 f0       	breq	.+36     	; 0x425c <AddList+0x64>
    4238:	28 2f       	mov	r18, r24
    423a:	2f 5f       	subi	r18, 0xFF	; 255
    423c:	01 96       	adiw	r24, 0x01	; 1
	 if ((GradeId>=1)&&((GradeId<=6))){
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
    423e:	87 17       	cp	r24, r23
    4240:	80 f3       	brcs	.-32     	; 0x4222 <AddList+0x2a>
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4242:	62 2f       	mov	r22, r18
    4244:	70 e0       	ldi	r23, 0x00	; 0
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4246:	3a 30       	cpi	r19, 0x0A	; 10
    4248:	10 f0       	brcs	.+4      	; 0x424e <AddList+0x56>
    424a:	80 e3       	ldi	r24, 0x30	; 48
    424c:	02 c0       	rjmp	.+4      	; 0x4252 <AddList+0x5a>
	    Result='0'+X;
    424e:	83 2f       	mov	r24, r19
    4250:	80 5d       	subi	r24, 0xD0	; 208
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4252:	fa 01       	movw	r30, r20
    4254:	e6 0f       	add	r30, r22
    4256:	f7 1f       	adc	r31, r23
    4258:	80 83       	st	Z, r24
		     strList[iPos+1]=0;
    425a:	11 82       	std	Z+1, r1	; 0x01
    425c:	08 95       	ret

0000425e <ClearList>:
	 AddSpaceLag(strProductName,10);
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
    425e:	dc 01       	movw	r26, r24
    4260:	0d 90       	ld	r0, X+
    4262:	00 20       	and	r0, r0
    4264:	e9 f7       	brne	.-6      	; 0x4260 <ClearList+0x2>
    4266:	11 97       	sbiw	r26, 0x01	; 1
    4268:	a8 1b       	sub	r26, r24
    426a:	b9 0b       	sbc	r27, r25
    426c:	20 e0       	ldi	r18, 0x00	; 0
    426e:	30 e0       	ldi	r19, 0x00	; 0
    4270:	06 c0       	rjmp	.+12     	; 0x427e <ClearList+0x20>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    4272:	fc 01       	movw	r30, r24
    4274:	e2 0f       	add	r30, r18
    4276:	f3 1f       	adc	r31, r19
    4278:	10 82       	st	Z, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    427a:	2f 5f       	subi	r18, 0xFF	; 255
    427c:	3f 4f       	sbci	r19, 0xFF	; 255
    427e:	2a 17       	cp	r18, r26
    4280:	3b 07       	cpc	r19, r27
    4282:	b8 f3       	brcs	.-18     	; 0x4272 <ClearList+0x14>
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
    4284:	08 95       	ret

00004286 <CalcSegmen>:
		 */
		 CalcMultiply(strA,strB,strC);
	 }
}

void CalcSegmen(char *strMain, char cNum, char *strResult){
    4286:	6f 92       	push	r6
    4288:	7f 92       	push	r7
    428a:	8f 92       	push	r8
    428c:	9f 92       	push	r9
    428e:	bf 92       	push	r11
    4290:	cf 92       	push	r12
    4292:	df 92       	push	r13
    4294:	ef 92       	push	r14
    4296:	ff 92       	push	r15
    4298:	0f 93       	push	r16
    429a:	1f 93       	push	r17
    429c:	df 93       	push	r29
    429e:	cf 93       	push	r28
    42a0:	cd b7       	in	r28, 0x3d	; 61
    42a2:	de b7       	in	r29, 0x3e	; 62
    42a4:	64 97       	sbiw	r28, 0x14	; 20
    42a6:	0f b6       	in	r0, 0x3f	; 63
    42a8:	f8 94       	cli
    42aa:	de bf       	out	0x3e, r29	; 62
    42ac:	0f be       	out	0x3f, r0	; 63
    42ae:	cd bf       	out	0x3d, r28	; 61
    42b0:	7c 01       	movw	r14, r24
    42b2:	6a 01       	movw	r12, r20
    42b4:	bb 24       	eor	r11, r11
    42b6:	30 e0       	ldi	r19, 0x00	; 0

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    42b8:	06 2f       	mov	r16, r22
    42ba:	10 e0       	ldi	r17, 0x00	; 0
    42bc:	00 53       	subi	r16, 0x30	; 48
    42be:	10 40       	sbci	r17, 0x00	; 0
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
    42c0:	3e 01       	movw	r6, r28
    42c2:	08 94       	sec
    42c4:	61 1c       	adc	r6, r1
    42c6:	71 1c       	adc	r7, r1
		 tmpResult[i+1]=0;
    42c8:	62 e0       	ldi	r22, 0x02	; 2
    42ca:	86 2e       	mov	r8, r22
    42cc:	91 2c       	mov	r9, r1
    42ce:	8c 0e       	add	r8, r28
    42d0:	9d 1e       	adc	r9, r29
    42d2:	24 c0       	rjmp	.+72     	; 0x431c <CalcSegmen+0x96>

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    42d4:	11 97       	sbiw	r26, 0x01	; 1
    42d6:	a4 1b       	sub	r26, r20
    42d8:	b5 0b       	sbc	r27, r21
    42da:	ae 0d       	add	r26, r14
    42dc:	bf 1d       	adc	r27, r15
    42de:	8c 91       	ld	r24, X
    42e0:	90 e0       	ldi	r25, 0x00	; 0
    42e2:	c0 97       	sbiw	r24, 0x30	; 48
    42e4:	bc 01       	movw	r22, r24
    42e6:	60 9f       	mul	r22, r16
    42e8:	c0 01       	movw	r24, r0
    42ea:	61 9f       	mul	r22, r17
    42ec:	90 0d       	add	r25, r0
    42ee:	70 9f       	mul	r23, r16
    42f0:	90 0d       	add	r25, r0
    42f2:	11 24       	eor	r1, r1
    42f4:	23 2f       	mov	r18, r19
    42f6:	28 0f       	add	r18, r24
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
    42f8:	82 2f       	mov	r24, r18
    42fa:	6a e0       	ldi	r22, 0x0A	; 10
    42fc:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    4300:	38 2f       	mov	r19, r24
	     tmpResult[i]='0'+xRes;	 
    4302:	f3 01       	movw	r30, r6
    4304:	e4 0f       	add	r30, r20
    4306:	f5 1f       	adc	r31, r21
    4308:	82 2f       	mov	r24, r18
    430a:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    430e:	90 5d       	subi	r25, 0xD0	; 208
    4310:	90 83       	st	Z, r25
		 tmpResult[i+1]=0;
    4312:	48 0d       	add	r20, r8
    4314:	59 1d       	adc	r21, r9
    4316:	fa 01       	movw	r30, r20
    4318:	10 82       	st	Z, r1
	 char i,lenR,xCalc,xRes,xResNext,tmpResult[20];

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
    431a:	b3 94       	inc	r11
    431c:	4b 2d       	mov	r20, r11
    431e:	50 e0       	ldi	r21, 0x00	; 0
    4320:	d7 01       	movw	r26, r14
    4322:	0d 90       	ld	r0, X+
    4324:	00 20       	and	r0, r0
    4326:	e9 f7       	brne	.-6      	; 0x4322 <CalcSegmen+0x9c>
    4328:	11 97       	sbiw	r26, 0x01	; 1
    432a:	ae 19       	sub	r26, r14
    432c:	bf 09       	sbc	r27, r15
    432e:	4a 17       	cp	r20, r26
    4330:	5b 07       	cpc	r21, r27
    4332:	80 f2       	brcs	.-96     	; 0x42d4 <CalcSegmen+0x4e>
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
		 tmpResult[i+1]=0;
	 }
	 if (xResNext>0){
    4334:	33 23       	and	r19, r19
    4336:	89 f0       	breq	.+34     	; 0x435a <CalcSegmen+0xd4>
	     lenR=strlen(tmpResult);
    4338:	fe 01       	movw	r30, r28
    433a:	31 96       	adiw	r30, 0x01	; 1
    433c:	df 01       	movw	r26, r30
    433e:	0d 90       	ld	r0, X+
    4340:	00 20       	and	r0, r0
    4342:	e9 f7       	brne	.-6      	; 0x433e <CalcSegmen+0xb8>
    4344:	11 97       	sbiw	r26, 0x01	; 1
	     tmpResult[lenR]='0'+xResNext;
    4346:	ae 1b       	sub	r26, r30
    4348:	b0 e0       	ldi	r27, 0x00	; 0
    434a:	ea 0f       	add	r30, r26
    434c:	fb 1f       	adc	r31, r27
    434e:	30 5d       	subi	r19, 0xD0	; 208
    4350:	30 83       	st	Z, r19
		 tmpResult[lenR+1]=0;	 
    4352:	ac 0f       	add	r26, r28
    4354:	bd 1f       	adc	r27, r29
    4356:	12 96       	adiw	r26, 0x02	; 2
    4358:	1c 92       	st	X, r1
	 }
	 lenR=strlen(tmpResult);
    435a:	de 01       	movw	r26, r28
    435c:	11 96       	adiw	r26, 0x01	; 1
    435e:	fd 01       	movw	r30, r26
    4360:	01 90       	ld	r0, Z+
    4362:	00 20       	and	r0, r0
    4364:	e9 f7       	brne	.-6      	; 0x4360 <CalcSegmen+0xda>
    4366:	31 97       	sbiw	r30, 0x01	; 1
    4368:	9e 2f       	mov	r25, r30
    436a:	9a 1b       	sub	r25, r26
    436c:	a9 0f       	add	r26, r25
    436e:	b1 1d       	adc	r27, r1
    4370:	f6 01       	movw	r30, r12
    4372:	02 c0       	rjmp	.+4      	; 0x4378 <CalcSegmen+0xf2>
	 for (i=0;i<lenR;i++){
	     strResult[i]=tmpResult[lenR-1-i];
    4374:	8c 91       	ld	r24, X
    4376:	81 93       	st	Z+, r24
    4378:	11 97       	sbiw	r26, 0x01	; 1
	     lenR=strlen(tmpResult);
	     tmpResult[lenR]='0'+xResNext;
		 tmpResult[lenR+1]=0;	 
	 }
	 lenR=strlen(tmpResult);
	 for (i=0;i<lenR;i++){
    437a:	ac 17       	cp	r26, r28
    437c:	bd 07       	cpc	r27, r29
    437e:	d1 f7       	brne	.-12     	; 0x4374 <CalcSegmen+0xee>
	     strResult[i]=tmpResult[lenR-1-i];
	 }
	 strResult[lenR]=0;
    4380:	c9 0e       	add	r12, r25
    4382:	d1 1c       	adc	r13, r1
    4384:	f6 01       	movw	r30, r12
    4386:	10 82       	st	Z, r1
}
    4388:	64 96       	adiw	r28, 0x14	; 20
    438a:	0f b6       	in	r0, 0x3f	; 63
    438c:	f8 94       	cli
    438e:	de bf       	out	0x3e, r29	; 62
    4390:	0f be       	out	0x3f, r0	; 63
    4392:	cd bf       	out	0x3d, r28	; 61
    4394:	cf 91       	pop	r28
    4396:	df 91       	pop	r29
    4398:	1f 91       	pop	r17
    439a:	0f 91       	pop	r16
    439c:	ff 90       	pop	r15
    439e:	ef 90       	pop	r14
    43a0:	df 90       	pop	r13
    43a2:	cf 90       	pop	r12
    43a4:	bf 90       	pop	r11
    43a6:	9f 90       	pop	r9
    43a8:	8f 90       	pop	r8
    43aa:	7f 90       	pop	r7
    43ac:	6f 90       	pop	r6
    43ae:	08 95       	ret

000043b0 <GetMinusPos>:
		  if (KeyChar=='*')stTestCalc=tcInitData;
	      break;	 
	 }
}

char GetMinusPos(char *strNumber){
    43b0:	ac 01       	movw	r20, r24
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    43b2:	dc 01       	movw	r26, r24
    43b4:	0d 90       	ld	r0, X+
    43b6:	00 20       	and	r0, r0
    43b8:	e9 f7       	brne	.-6      	; 0x43b4 <GetMinusPos+0x4>
    43ba:	11 97       	sbiw	r26, 0x01	; 1
    43bc:	a8 1b       	sub	r26, r24
    43be:	b9 0b       	sbc	r27, r25
    43c0:	20 e0       	ldi	r18, 0x00	; 0
    43c2:	0a c0       	rjmp	.+20     	; 0x43d8 <GetMinusPos+0x28>
	     if (strNumber[i]=='-'){
    43c4:	e4 0f       	add	r30, r20
    43c6:	f5 1f       	adc	r31, r21
    43c8:	80 81       	ld	r24, Z
    43ca:	92 2f       	mov	r25, r18
    43cc:	9f 5f       	subi	r25, 0xFF	; 255
    43ce:	8d 32       	cpi	r24, 0x2D	; 45
    43d0:	11 f4       	brne	.+4      	; 0x43d6 <GetMinusPos+0x26>
		     Result=i+1;
    43d2:	89 2f       	mov	r24, r25
    43d4:	08 95       	ret
}

char GetMinusPos(char *strNumber){
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    43d6:	29 2f       	mov	r18, r25
    43d8:	e2 2f       	mov	r30, r18
    43da:	f0 e0       	ldi	r31, 0x00	; 0
    43dc:	ea 17       	cp	r30, r26
    43de:	fb 07       	cpc	r31, r27
    43e0:	88 f3       	brcs	.-30     	; 0x43c4 <GetMinusPos+0x14>
    43e2:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
  return Result;     
}
    43e4:	08 95       	ret

000043e6 <IsMinus>:

char IsMinus(char *strNumber){
char i,Result=False;
     Result=False;
	 if (GetMinusPos(strNumber)>0){
    43e6:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <GetMinusPos>
    43ea:	81 11       	cpse	r24, r1
    43ec:	81 e0       	ldi	r24, 0x01	; 1
	     Result=True;
	 }     
  return Result;
}
    43ee:	08 95       	ret

000043f0 <RemoveMinus>:

void RemoveMinus(char *strNumber){
    43f0:	cf 93       	push	r28
    43f2:	df 93       	push	r29
    43f4:	ec 01       	movw	r28, r24
     char MinPos,Length;

     if (IsMinus(strNumber)==True){
    43f6:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <IsMinus>
    43fa:	81 30       	cpi	r24, 0x01	; 1
    43fc:	19 f5       	brne	.+70     	; 0x4444 <RemoveMinus+0x54>
	     MinPos=GetMinusPos(strNumber);
    43fe:	ce 01       	movw	r24, r28
    4400:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <GetMinusPos>
		 Length=strlen(strNumber);
    4404:	de 01       	movw	r26, r28
    4406:	0d 90       	ld	r0, X+
    4408:	00 20       	and	r0, r0
    440a:	e9 f7       	brne	.-6      	; 0x4406 <RemoveMinus+0x16>
    440c:	11 97       	sbiw	r26, 0x01	; 1
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
    440e:	ac 1b       	sub	r26, r28
    4410:	b0 e0       	ldi	r27, 0x00	; 0
    4412:	90 e0       	ldi	r25, 0x00	; 0
    4414:	a8 1b       	sub	r26, r24
    4416:	b9 0b       	sbc	r27, r25
    4418:	ae 01       	movw	r20, r28
    441a:	48 0f       	add	r20, r24
    441c:	59 1f       	adc	r21, r25
    441e:	20 e0       	ldi	r18, 0x00	; 0
    4420:	30 e0       	ldi	r19, 0x00	; 0
    4422:	0a c0       	rjmp	.+20     	; 0x4438 <RemoveMinus+0x48>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4424:	be 01       	movw	r22, r28
    4426:	62 0f       	add	r22, r18
    4428:	73 1f       	adc	r23, r19
    442a:	fa 01       	movw	r30, r20
    442c:	81 91       	ld	r24, Z+
    442e:	af 01       	movw	r20, r30
    4430:	fb 01       	movw	r30, r22
    4432:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4434:	2f 5f       	subi	r18, 0xFF	; 255
    4436:	3f 4f       	sbci	r19, 0xFF	; 255
    4438:	2a 17       	cp	r18, r26
    443a:	3b 07       	cpc	r19, r27
    443c:	98 f3       	brcs	.-26     	; 0x4424 <RemoveMinus+0x34>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    443e:	ac 0f       	add	r26, r28
    4440:	bd 1f       	adc	r27, r29
    4442:	1c 92       	st	X, r1
     if (IsMinus(strNumber)==True){
	     MinPos=GetMinusPos(strNumber);
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}
    4444:	df 91       	pop	r29
    4446:	cf 91       	pop	r28
    4448:	08 95       	ret

0000444a <IsMoreThan>:
	    Result=c-'0';
	 }
	return Result;
}

char IsMoreThan(char *strA, char *strB){
    444a:	ac 01       	movw	r20, r24
    444c:	27 2f       	mov	r18, r23
     char i,LengthA,LengthB,Result=False;
	 char strSend[20];	 
     //Check Length
	 LengthA=strlen(strA);
    444e:	fc 01       	movw	r30, r24
    4450:	01 90       	ld	r0, Z+
    4452:	00 20       	and	r0, r0
    4454:	e9 f7       	brne	.-6      	; 0x4450 <IsMoreThan+0x6>
    4456:	31 97       	sbiw	r30, 0x01	; 1
    4458:	7e 2f       	mov	r23, r30
    445a:	78 1b       	sub	r23, r24
	 LengthB=strlen(strB);
    445c:	a6 2f       	mov	r26, r22
    445e:	b2 2f       	mov	r27, r18
    4460:	fd 01       	movw	r30, r26
    4462:	01 90       	ld	r0, Z+
    4464:	00 20       	and	r0, r0
    4466:	e9 f7       	brne	.-6      	; 0x4462 <IsMoreThan+0x18>
    4468:	31 97       	sbiw	r30, 0x01	; 1
    446a:	e6 1b       	sub	r30, r22
	 Result=False;
	 if (LengthA>LengthB)Result=True;
    446c:	e7 17       	cp	r30, r23
    446e:	48 f1       	brcs	.+82     	; 0x44c2 <IsMoreThan+0x78>
	 else 
	 if (LengthA==LengthB){          //456755 
    4470:	7e 17       	cp	r23, r30
    4472:	49 f5       	brne	.+82     	; 0x44c6 <IsMoreThan+0x7c>
    4474:	86 2f       	mov	r24, r22
    4476:	92 2f       	mov	r25, r18
    4478:	9c 01       	movw	r18, r24
    447a:	d9 01       	movw	r26, r18
    447c:	20 e0       	ldi	r18, 0x00	; 0
    447e:	30 e0       	ldi	r19, 0x00	; 0
    4480:	1d c0       	rjmp	.+58     	; 0x44bc <IsMoreThan+0x72>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4482:	fa 01       	movw	r30, r20
    4484:	e2 0f       	add	r30, r18
    4486:	f3 1f       	adc	r31, r19
    4488:	e0 81       	ld	r30, Z
    448a:	e0 53       	subi	r30, 0x30	; 48
    448c:	ea 30       	cpi	r30, 0x0A	; 10
    448e:	10 f0       	brcs	.+4      	; 0x4494 <IsMoreThan+0x4a>
    4490:	60 e0       	ldi	r22, 0x00	; 0
    4492:	01 c0       	rjmp	.+2      	; 0x4496 <IsMoreThan+0x4c>
    4494:	6e 2f       	mov	r22, r30
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
    4496:	8c 91       	ld	r24, X
    4498:	80 53       	subi	r24, 0x30	; 48
    449a:	8a 30       	cpi	r24, 0x0A	; 10
    449c:	10 f0       	brcs	.+4      	; 0x44a2 <IsMoreThan+0x58>
    449e:	90 e0       	ldi	r25, 0x00	; 0
    44a0:	01 c0       	rjmp	.+2      	; 0x44a4 <IsMoreThan+0x5a>
    44a2:	98 2f       	mov	r25, r24
    44a4:	96 17       	cp	r25, r22
    44a6:	68 f0       	brcs	.+26     	; 0x44c2 <IsMoreThan+0x78>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    44a8:	ea 30       	cpi	r30, 0x0A	; 10
    44aa:	08 f0       	brcs	.+2      	; 0x44ae <IsMoreThan+0x64>
    44ac:	e0 e0       	ldi	r30, 0x00	; 0
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
			     Result=True;
				 break;
			 }else if (Ord(strA[i])<Ord(strB[i])){
    44ae:	8a 30       	cpi	r24, 0x0A	; 10
    44b0:	10 f4       	brcc	.+4      	; 0x44b6 <IsMoreThan+0x6c>
    44b2:	e8 17       	cp	r30, r24
    44b4:	40 f0       	brcs	.+16     	; 0x44c6 <IsMoreThan+0x7c>
    44b6:	2f 5f       	subi	r18, 0xFF	; 255
    44b8:	3f 4f       	sbci	r19, 0xFF	; 255
    44ba:	11 96       	adiw	r26, 0x01	; 1
	 LengthB=strlen(strB);
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
    44bc:	27 17       	cp	r18, r23
    44be:	08 f3       	brcs	.-62     	; 0x4482 <IsMoreThan+0x38>
    44c0:	02 c0       	rjmp	.+4      	; 0x44c6 <IsMoreThan+0x7c>
    44c2:	81 e0       	ldi	r24, 0x01	; 1
    44c4:	08 95       	ret
    44c6:	80 e0       	ldi	r24, 0x00	; 0
				 break;
			 }			 		 
		 }
	 }
  return Result;
}
    44c8:	08 95       	ret

000044ca <IsZerroAll>:
   return Result;
}

char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
    44ca:	fc 01       	movw	r30, r24
    44cc:	01 90       	ld	r0, Z+
    44ce:	00 20       	and	r0, r0
    44d0:	e9 f7       	brne	.-6      	; 0x44cc <IsZerroAll+0x2>
    44d2:	31 97       	sbiw	r30, 0x01	; 1
    44d4:	e8 1b       	sub	r30, r24
    44d6:	dc 01       	movw	r26, r24
    44d8:	ae 0f       	add	r26, r30
    44da:	b1 1d       	adc	r27, r1
    44dc:	90 e0       	ldi	r25, 0x00	; 0
    44de:	20 e0       	ldi	r18, 0x00	; 0
    44e0:	06 c0       	rjmp	.+12     	; 0x44ee <IsZerroAll+0x24>
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
	     if (strZerro[Length-i]=='0')nZerro++;
    44e2:	8c 91       	ld	r24, X
    44e4:	80 33       	cpi	r24, 0x30	; 48
    44e6:	09 f4       	brne	.+2      	; 0x44ea <IsZerroAll+0x20>
    44e8:	2f 5f       	subi	r18, 0xFF	; 255
char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
    44ea:	9f 5f       	subi	r25, 0xFF	; 255
    44ec:	11 97       	sbiw	r26, 0x01	; 1
    44ee:	9e 17       	cp	r25, r30
    44f0:	c0 f3       	brcs	.-16     	; 0x44e2 <IsZerroAll+0x18>
    44f2:	80 e0       	ldi	r24, 0x00	; 0
    44f4:	2e 17       	cp	r18, r30
    44f6:	09 f4       	brne	.+2      	; 0x44fa <IsZerroAll+0x30>
    44f8:	81 e0       	ldi	r24, 0x01	; 1
	     if (strZerro[Length-i]=='0')nZerro++;
	 }if (nZerro==Length) Result=True;
  return Result;
}
    44fa:	08 95       	ret

000044fc <PstrCopy>:
     _uart(_COM_PRINTER, 1, 0x0D);     
     _uart(_COM_PRINTER, 1, 0x0A);

}

void PstrCopy(char *Dest,char *Source){
    44fc:	cf 93       	push	r28
    44fe:	df 93       	push	r29
    4500:	20 e0       	ldi	r18, 0x00	; 0
    4502:	08 c0       	rjmp	.+16     	; 0x4514 <PstrCopy+0x18>
     char i=0;
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
    4504:	fb 01       	movw	r30, r22
    4506:	ec 0f       	add	r30, r28
    4508:	fd 1f       	adc	r31, r29
    450a:	e4 91       	lpm	r30, Z+
    450c:	c8 0f       	add	r28, r24
    450e:	d9 1f       	adc	r29, r25
    4510:	e8 83       	st	Y, r30

}

void PstrCopy(char *Dest,char *Source){
     char i=0;
	 for(i=0;i<strlen(Source);i++){
    4512:	2f 5f       	subi	r18, 0xFF	; 255
    4514:	c2 2f       	mov	r28, r18
    4516:	d0 e0       	ldi	r29, 0x00	; 0
    4518:	fb 01       	movw	r30, r22
    451a:	01 90       	ld	r0, Z+
    451c:	00 20       	and	r0, r0
    451e:	e9 f7       	brne	.-6      	; 0x451a <PstrCopy+0x1e>
    4520:	31 97       	sbiw	r30, 0x01	; 1
    4522:	e6 1b       	sub	r30, r22
    4524:	f7 0b       	sbc	r31, r23
    4526:	ce 17       	cp	r28, r30
    4528:	df 07       	cpc	r29, r31
    452a:	60 f3       	brcs	.-40     	; 0x4504 <PstrCopy+0x8>
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}
    452c:	df 91       	pop	r29
    452e:	cf 91       	pop	r28
    4530:	08 95       	ret

00004532 <SpaceOnly>:
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}

char SpaceOnly(char *string){
    4532:	ac 01       	movw	r20, r24
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    4534:	dc 01       	movw	r26, r24
    4536:	0d 90       	ld	r0, X+
    4538:	00 20       	and	r0, r0
    453a:	e9 f7       	brne	.-6      	; 0x4536 <SpaceOnly+0x4>
    453c:	11 97       	sbiw	r26, 0x01	; 1
    453e:	a8 1b       	sub	r26, r24
    4540:	b9 0b       	sbc	r27, r25
    4542:	90 e0       	ldi	r25, 0x00	; 0
    4544:	20 e0       	ldi	r18, 0x00	; 0
    4546:	30 e0       	ldi	r19, 0x00	; 0
    4548:	09 c0       	rjmp	.+18     	; 0x455c <SpaceOnly+0x2a>
	    if(string[i]!=' ') nChar++;
    454a:	fa 01       	movw	r30, r20
    454c:	e2 0f       	add	r30, r18
    454e:	f3 1f       	adc	r31, r19
    4550:	80 81       	ld	r24, Z
    4552:	80 32       	cpi	r24, 0x20	; 32
    4554:	09 f0       	breq	.+2      	; 0x4558 <SpaceOnly+0x26>
    4556:	9f 5f       	subi	r25, 0xFF	; 255
char SpaceOnly(char *string){
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    4558:	2f 5f       	subi	r18, 0xFF	; 255
    455a:	3f 4f       	sbci	r19, 0xFF	; 255
    455c:	2a 17       	cp	r18, r26
    455e:	3b 07       	cpc	r19, r27
    4560:	a0 f3       	brcs	.-24     	; 0x454a <SpaceOnly+0x18>
    4562:	80 e0       	ldi	r24, 0x00	; 0
    4564:	99 23       	and	r25, r25
    4566:	09 f4       	brne	.+2      	; 0x456a <SpaceOnly+0x38>
    4568:	81 e0       	ldi	r24, 0x01	; 1
	 }
	 if (nChar>0) Result=False;
	 else Result=True;

	 return Result;
}
    456a:	08 95       	ret

0000456c <RemDecimal>:
	 }
}



void RemDecimal(char *strDecimal){//4500.00-->4500
    456c:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    456e:	e1 99       	sbic	0x1c, 1	; 28
    4570:	fe cf       	rjmp	.-4      	; 0x456e <RemDecimal+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4572:	8e e3       	ldi	r24, 0x3E	; 62
    4574:	90 e0       	ldi	r25, 0x00	; 0
    4576:	9f bb       	out	0x1f, r25	; 31
    4578:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    457a:	e0 9a       	sbi	0x1c, 0	; 28
    457c:	5d b3       	in	r21, 0x1d	; 29
    457e:	40 e0       	ldi	r20, 0x00	; 0
    4580:	08 c0       	rjmp	.+16     	; 0x4592 <RemDecimal+0x26>
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
	     if (strDecimal[i]==DecPointMark)
    4582:	f9 01       	movw	r30, r18
    4584:	e8 0f       	add	r30, r24
    4586:	f9 1f       	adc	r31, r25
    4588:	80 81       	ld	r24, Z
    458a:	85 17       	cp	r24, r21
    458c:	09 f4       	brne	.+2      	; 0x4590 <RemDecimal+0x24>
		     strDecimal[i]=0;
    458e:	10 82       	st	Z, r1

void RemDecimal(char *strDecimal){//4500.00-->4500
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
    4590:	4f 5f       	subi	r20, 0xFF	; 255
    4592:	84 2f       	mov	r24, r20
    4594:	90 e0       	ldi	r25, 0x00	; 0
    4596:	f9 01       	movw	r30, r18
    4598:	01 90       	ld	r0, Z+
    459a:	00 20       	and	r0, r0
    459c:	e9 f7       	brne	.-6      	; 0x4598 <RemDecimal+0x2c>
    459e:	31 97       	sbiw	r30, 0x01	; 1
    45a0:	e2 1b       	sub	r30, r18
    45a2:	f3 0b       	sbc	r31, r19
    45a4:	8e 17       	cp	r24, r30
    45a6:	9f 07       	cpc	r25, r31
    45a8:	60 f3       	brcs	.-40     	; 0x4582 <RemDecimal+0x16>
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}
    45aa:	08 95       	ret

000045ac <GetProductPrice>:
          stGenerateReport=grScanAction;
	      break;
	 }
}
//SaveTotalProduct(xGrade,strDeltaVolume,strDeltaMoney);
void GetProductPrice(char *sPrice,char xPumpID,char xNozzle){
    45ac:	cf 92       	push	r12
    45ae:	df 92       	push	r13
    45b0:	ef 92       	push	r14
    45b2:	ff 92       	push	r15
    45b4:	0f 93       	push	r16
    45b6:	1f 93       	push	r17
    45b8:	df 93       	push	r29
    45ba:	cf 93       	push	r28
    45bc:	cd b7       	in	r28, 0x3d	; 61
    45be:	de b7       	in	r29, 0x3e	; 62
    45c0:	67 97       	sbiw	r28, 0x17	; 23
    45c2:	0f b6       	in	r0, 0x3f	; 63
    45c4:	f8 94       	cli
    45c6:	de bf       	out	0x3e, r29	; 62
    45c8:	0f be       	out	0x3f, r0	; 63
    45ca:	cd bf       	out	0x3d, r28	; 61
    45cc:	7c 01       	movw	r14, r24
    45ce:	d6 2e       	mov	r13, r22
    45d0:	c4 2e       	mov	r12, r20
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
    45d2:	00 d0       	rcall	.+0      	; 0x45d4 <GetProductPrice+0x28>
    45d4:	00 d0       	rcall	.+0      	; 0x45d6 <GetProductPrice+0x2a>
    45d6:	ad b7       	in	r26, 0x3d	; 61
    45d8:	be b7       	in	r27, 0x3e	; 62
    45da:	12 96       	adiw	r26, 0x02	; 2
    45dc:	9c 93       	st	X, r25
    45de:	8e 93       	st	-X, r24
    45e0:	11 97       	sbiw	r26, 0x01	; 1
    45e2:	8c ef       	ldi	r24, 0xFC	; 252
    45e4:	93 e0       	ldi	r25, 0x03	; 3
    45e6:	14 96       	adiw	r26, 0x04	; 4
    45e8:	9c 93       	st	X, r25
    45ea:	8e 93       	st	-X, r24
    45ec:	13 97       	sbiw	r26, 0x03	; 3
    45ee:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    45f2:	0f 90       	pop	r0
    45f4:	0f 90       	pop	r0
    45f6:	0f 90       	pop	r0
    45f8:	0f 90       	pop	r0
    45fa:	8e 01       	movw	r16, r28
    45fc:	09 5f       	subi	r16, 0xF9	; 249
    45fe:	1f 4f       	sbci	r17, 0xFF	; 255
    4600:	c8 01       	movw	r24, r16
    4602:	65 e4       	ldi	r22, 0x45	; 69
    4604:	70 e0       	ldi	r23, 0x00	; 0
    4606:	48 e0       	ldi	r20, 0x08	; 8
    4608:	50 e0       	ldi	r21, 0x00	; 0
    460a:	25 ed       	ldi	r18, 0xD5	; 213
    460c:	32 e1       	ldi	r19, 0x12	; 18
    460e:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
    4612:	f8 01       	movw	r30, r16
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4614:	9e 01       	movw	r18, r28
    4616:	21 5f       	subi	r18, 0xF1	; 241
    4618:	3f 4f       	sbci	r19, 0xFF	; 255
    461a:	9e 2f       	mov	r25, r30
    461c:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==xPumpID){
    461e:	80 81       	ld	r24, Z
    4620:	8d 15       	cp	r24, r13
    4622:	11 f4       	brne	.+4      	; 0x4628 <GetProductPrice+0x7c>
    4624:	89 2f       	mov	r24, r25
    4626:	05 c0       	rjmp	.+10     	; 0x4632 <GetProductPrice+0x86>
    4628:	31 96       	adiw	r30, 0x01	; 1
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    462a:	e2 17       	cp	r30, r18
    462c:	f3 07       	cpc	r31, r19
    462e:	a9 f7       	brne	.-22     	; 0x461a <GetProductPrice+0x6e>
    4630:	80 e0       	ldi	r24, 0x00	; 0
	     if (PPumpID[i]==xPumpID){
		     iPumpID=i;
			 break;
		 }	 
	 }
	 if ((iPumpID>=0)&&(xNozzle<6)){
    4632:	b5 e0       	ldi	r27, 0x05	; 5
    4634:	bc 15       	cp	r27, r12
    4636:	08 f4       	brcc	.+2      	; 0x463a <GetProductPrice+0x8e>
    4638:	41 c0       	rjmp	.+130    	; 0x46bc <GetProductPrice+0x110>
    463a:	66 e0       	ldi	r22, 0x06	; 6
    463c:	86 9f       	mul	r24, r22
    463e:	b0 01       	movw	r22, r0
    4640:	11 24       	eor	r1, r1
    4642:	6b 5a       	subi	r22, 0xAB	; 171
    4644:	7f 4f       	sbci	r23, 0xFF	; 255
    4646:	ce 01       	movw	r24, r28
    4648:	01 96       	adiw	r24, 0x01	; 1
    464a:	46 e0       	ldi	r20, 0x06	; 6
    464c:	50 e0       	ldi	r21, 0x00	; 0
    464e:	25 ed       	ldi	r18, 0xD5	; 213
    4650:	32 e1       	ldi	r19, 0x12	; 18
    4652:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
         eeprom_read_block((void*) &PProdID,(const void*) &DefNozzleMap[iPumpID],6);
         xProductID=PProdID[xNozzle-1];
		 //Price
		 eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[xProductID-1], 9);
		 RemDecimal(strPrice);
    4656:	8e 01       	movw	r16, r28
    4658:	01 5f       	subi	r16, 0xF1	; 241
    465a:	1f 4f       	sbci	r17, 0xFF	; 255
    465c:	fe 01       	movw	r30, r28
    465e:	ec 0d       	add	r30, r12
    4660:	f1 1d       	adc	r31, r1
    4662:	60 81       	ld	r22, Z
    4664:	89 e0       	ldi	r24, 0x09	; 9
    4666:	68 9f       	mul	r22, r24
    4668:	b0 01       	movw	r22, r0
    466a:	11 24       	eor	r1, r1
    466c:	64 58       	subi	r22, 0x84	; 132
    466e:	7f 4f       	sbci	r23, 0xFF	; 255
    4670:	c8 01       	movw	r24, r16
    4672:	49 e0       	ldi	r20, 0x09	; 9
    4674:	50 e0       	ldi	r21, 0x00	; 0
    4676:	25 ed       	ldi	r18, 0xD5	; 213
    4678:	32 e1       	ldi	r19, 0x12	; 18
    467a:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
    467e:	c8 01       	movw	r24, r16
    4680:	0e 94 b6 22 	call	0x456c	; 0x456c <RemDecimal>
		 sprintf_P(sPrice,PSTR("%s"),strPrice);
    4684:	00 d0       	rcall	.+0      	; 0x4686 <GetProductPrice+0xda>
    4686:	00 d0       	rcall	.+0      	; 0x4688 <GetProductPrice+0xdc>
    4688:	00 d0       	rcall	.+0      	; 0x468a <GetProductPrice+0xde>
    468a:	ed b7       	in	r30, 0x3d	; 61
    468c:	fe b7       	in	r31, 0x3e	; 62
    468e:	31 96       	adiw	r30, 0x01	; 1
    4690:	ad b7       	in	r26, 0x3d	; 61
    4692:	be b7       	in	r27, 0x3e	; 62
    4694:	12 96       	adiw	r26, 0x02	; 2
    4696:	fc 92       	st	X, r15
    4698:	ee 92       	st	-X, r14
    469a:	11 97       	sbiw	r26, 0x01	; 1
    469c:	89 ef       	ldi	r24, 0xF9	; 249
    469e:	93 e0       	ldi	r25, 0x03	; 3
    46a0:	93 83       	std	Z+3, r25	; 0x03
    46a2:	82 83       	std	Z+2, r24	; 0x02
    46a4:	15 83       	std	Z+5, r17	; 0x05
    46a6:	04 83       	std	Z+4, r16	; 0x04
    46a8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    46ac:	ed b7       	in	r30, 0x3d	; 61
    46ae:	fe b7       	in	r31, 0x3e	; 62
    46b0:	36 96       	adiw	r30, 0x06	; 6
    46b2:	0f b6       	in	r0, 0x3f	; 63
    46b4:	f8 94       	cli
    46b6:	fe bf       	out	0x3e, r31	; 62
    46b8:	0f be       	out	0x3f, r0	; 63
    46ba:	ed bf       	out	0x3d, r30	; 61
	 }    
	 //Clear Decimal

}
    46bc:	67 96       	adiw	r28, 0x17	; 23
    46be:	0f b6       	in	r0, 0x3f	; 63
    46c0:	f8 94       	cli
    46c2:	de bf       	out	0x3e, r29	; 62
    46c4:	0f be       	out	0x3f, r0	; 63
    46c6:	cd bf       	out	0x3d, r28	; 61
    46c8:	cf 91       	pop	r28
    46ca:	df 91       	pop	r29
    46cc:	1f 91       	pop	r17
    46ce:	0f 91       	pop	r16
    46d0:	ff 90       	pop	r15
    46d2:	ef 90       	pop	r14
    46d4:	df 90       	pop	r13
    46d6:	cf 90       	pop	r12
    46d8:	08 95       	ret

000046da <FormatDate>:
	 }     
   }
}

              //Fmt:DATE_LONG_YEAR,DATE_SHORT_YEAR //0123456789    0123456789 
void FormatDate(char FmtYear, char *Date){         //2010/06/16 -> 16/06/2010
    46da:	df 93       	push	r29
    46dc:	cf 93       	push	r28
    46de:	cd b7       	in	r28, 0x3d	; 61
    46e0:	de b7       	in	r29, 0x3e	; 62
    46e2:	2b 97       	sbiw	r28, 0x0b	; 11
    46e4:	0f b6       	in	r0, 0x3f	; 63
    46e6:	f8 94       	cli
    46e8:	de bf       	out	0x3e, r29	; 62
    46ea:	0f be       	out	0x3f, r0	; 63
    46ec:	cd bf       	out	0x3d, r28	; 61
    46ee:	98 2f       	mov	r25, r24
    46f0:	9b 01       	movw	r18, r22
     char i,sDate[11];

     sDate[0]=Date[8];
    46f2:	fb 01       	movw	r30, r22
    46f4:	80 85       	ldd	r24, Z+8	; 0x08
    46f6:	89 83       	std	Y+1, r24	; 0x01
	 sDate[1]=Date[9];
    46f8:	81 85       	ldd	r24, Z+9	; 0x09
    46fa:	8a 83       	std	Y+2, r24	; 0x02
     sDate[2]=Date[7];
    46fc:	87 81       	ldd	r24, Z+7	; 0x07
    46fe:	8b 83       	std	Y+3, r24	; 0x03
	 sDate[3]=Date[5];
    4700:	85 81       	ldd	r24, Z+5	; 0x05
    4702:	8c 83       	std	Y+4, r24	; 0x04
     sDate[4]=Date[6];
    4704:	86 81       	ldd	r24, Z+6	; 0x06
    4706:	8d 83       	std	Y+5, r24	; 0x05
	 sDate[5]=Date[4];
    4708:	84 81       	ldd	r24, Z+4	; 0x04
    470a:	8e 83       	std	Y+6, r24	; 0x06
	 switch(FmtYear){
    470c:	99 23       	and	r25, r25
    470e:	19 f0       	breq	.+6      	; 0x4716 <FormatDate+0x3c>
    4710:	91 30       	cpi	r25, 0x01	; 1
    4712:	59 f4       	brne	.+22     	; 0x472a <FormatDate+0x50>
    4714:	0f c0       	rjmp	.+30     	; 0x4734 <FormatDate+0x5a>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
    4716:	fb 01       	movw	r30, r22
    4718:	80 81       	ld	r24, Z
    471a:	8f 83       	std	Y+7, r24	; 0x07
    471c:	81 81       	ldd	r24, Z+1	; 0x01
    471e:	88 87       	std	Y+8, r24	; 0x08
    4720:	82 81       	ldd	r24, Z+2	; 0x02
    4722:	89 87       	std	Y+9, r24	; 0x09
    4724:	83 81       	ldd	r24, Z+3	; 0x03
    4726:	8a 87       	std	Y+10, r24	; 0x0a
          sDate[10]=0;
    4728:	1b 86       	std	Y+11, r1	; 0x0b
    472a:	90 e0       	ldi	r25, 0x00	; 0
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
          sDate[8]=0;
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    472c:	ae 01       	movw	r20, r28
    472e:	4f 5f       	subi	r20, 0xFF	; 255
    4730:	5f 4f       	sbci	r21, 0xFF	; 255
    4732:	0f c0       	rjmp	.+30     	; 0x4752 <FormatDate+0x78>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
          sDate[10]=0;
	      break;
	 case DATE_SHORT_YEAR:
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
    4734:	fb 01       	movw	r30, r22
    4736:	82 81       	ldd	r24, Z+2	; 0x02
    4738:	8f 83       	std	Y+7, r24	; 0x07
    473a:	83 81       	ldd	r24, Z+3	; 0x03
    473c:	88 87       	std	Y+8, r24	; 0x08
          sDate[8]=0;
    473e:	19 86       	std	Y+9, r1	; 0x09
    4740:	f4 cf       	rjmp	.-24     	; 0x472a <FormatDate+0x50>
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    4742:	f9 01       	movw	r30, r18
    4744:	ea 0f       	add	r30, r26
    4746:	fb 1f       	adc	r31, r27
    4748:	a4 0f       	add	r26, r20
    474a:	b5 1f       	adc	r27, r21
    474c:	8c 91       	ld	r24, X
    474e:	80 83       	st	Z, r24
    4750:	9f 5f       	subi	r25, 0xFF	; 255
    4752:	a9 2f       	mov	r26, r25
    4754:	b0 e0       	ldi	r27, 0x00	; 0
    4756:	fa 01       	movw	r30, r20
    4758:	01 90       	ld	r0, Z+
    475a:	00 20       	and	r0, r0
    475c:	e9 f7       	brne	.-6      	; 0x4758 <FormatDate+0x7e>
    475e:	31 97       	sbiw	r30, 0x01	; 1
    4760:	e4 1b       	sub	r30, r20
    4762:	f5 0b       	sbc	r31, r21
    4764:	ae 17       	cp	r26, r30
    4766:	bf 07       	cpc	r27, r31
    4768:	60 f3       	brcs	.-40     	; 0x4742 <FormatDate+0x68>
}
    476a:	2b 96       	adiw	r28, 0x0b	; 11
    476c:	0f b6       	in	r0, 0x3f	; 63
    476e:	f8 94       	cli
    4770:	de bf       	out	0x3e, r29	; 62
    4772:	0f be       	out	0x3f, r0	; 63
    4774:	cd bf       	out	0x3d, r28	; 61
    4776:	cf 91       	pop	r28
    4778:	df 91       	pop	r29
    477a:	08 95       	ret

0000477c <RemZeroLead>:

	while (1){};
  #endif
}

void RemZeroLead(char *Zeroed){//Remove Zero Character 00001004 000050000 0 
    477c:	cf 93       	push	r28
    477e:	df 93       	push	r29
    4780:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
    4782:	fc 01       	movw	r30, r24
    4784:	01 90       	ld	r0, Z+
    4786:	00 20       	and	r0, r0
    4788:	e9 f7       	brne	.-6      	; 0x4784 <RemZeroLead+0x8>
    478a:	31 97       	sbiw	r30, 0x01	; 1
    478c:	e8 1b       	sub	r30, r24
  if ((Length>1)&&(Zeroed[0]=='0')){
    478e:	e2 30       	cpi	r30, 0x02	; 2
    4790:	d0 f1       	brcs	.+116    	; 0x4806 <RemZeroLead+0x8a>
    4792:	88 81       	ld	r24, Y
    4794:	80 33       	cpi	r24, 0x30	; 48
    4796:	b9 f5       	brne	.+110    	; 0x4806 <RemZeroLead+0x8a>
    4798:	4c 2f       	mov	r20, r28
    479a:	de 01       	movw	r26, r28
    479c:	90 e0       	ldi	r25, 0x00	; 0
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
	         if ((Zeroed[i]=='0')&&(Zeroed[i+1]=='0')&&(IsFound==False)) ZeroPos++;
    479e:	8c 91       	ld	r24, X
    47a0:	80 33       	cpi	r24, 0x30	; 48
    47a2:	69 f4       	brne	.+26     	; 0x47be <RemZeroLead+0x42>
    47a4:	11 96       	adiw	r26, 0x01	; 1
    47a6:	8c 91       	ld	r24, X
    47a8:	11 97       	sbiw	r26, 0x01	; 1
    47aa:	80 33       	cpi	r24, 0x30	; 48
    47ac:	11 f4       	brne	.+4      	; 0x47b2 <RemZeroLead+0x36>
    47ae:	9f 5f       	subi	r25, 0xFF	; 255
    47b0:	06 c0       	rjmp	.+12     	; 0x47be <RemZeroLead+0x42>
             if ((Zeroed[i]=='0')&&(Zeroed[i+1]!='0')){
			     if ((Zeroed[i+1]=='.')||(Zeroed[i+1]==','))ZeroPos--;
    47b2:	8e 32       	cpi	r24, 0x2E	; 46
    47b4:	11 f0       	breq	.+4      	; 0x47ba <RemZeroLead+0x3e>
    47b6:	8c 32       	cpi	r24, 0x2C	; 44
    47b8:	41 f4       	brne	.+16     	; 0x47ca <RemZeroLead+0x4e>
    47ba:	91 50       	subi	r25, 0x01	; 1
    47bc:	06 c0       	rjmp	.+12     	; 0x47ca <RemZeroLead+0x4e>
    47be:	11 96       	adiw	r26, 0x01	; 1
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
  if ((Length>1)&&(Zeroed[0]=='0')){
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
    47c0:	8a 2f       	mov	r24, r26
    47c2:	84 1b       	sub	r24, r20
    47c4:	8e 17       	cp	r24, r30
    47c6:	58 f3       	brcs	.-42     	; 0x479e <RemZeroLead+0x22>
    47c8:	01 c0       	rjmp	.+2      	; 0x47cc <RemZeroLead+0x50>
		         IsFound=True;
			     break;			  
			     }
	      }

		  if (IsFound==True)ZeroPos++;
    47ca:	9f 5f       	subi	r25, 0xFF	; 255
		  if (ZeroPos>=Length)ZeroPos=Length-1;
    47cc:	9e 17       	cp	r25, r30
    47ce:	10 f0       	brcs	.+4      	; 0x47d4 <RemZeroLead+0x58>
    47d0:	9e 2f       	mov	r25, r30
    47d2:	91 50       	subi	r25, 0x01	; 1
    47d4:	40 e0       	ldi	r20, 0x00	; 0
          for(i=0;i<(Length-ZeroPos);i++){
    47d6:	89 2f       	mov	r24, r25
    47d8:	90 e0       	ldi	r25, 0x00	; 0
    47da:	2e 2f       	mov	r18, r30
    47dc:	30 e0       	ldi	r19, 0x00	; 0
    47de:	28 1b       	sub	r18, r24
    47e0:	39 0b       	sbc	r19, r25
	          Zeroed[i]=Zeroed[i+ZeroPos];
    47e2:	be 01       	movw	r22, r28
    47e4:	68 0f       	add	r22, r24
    47e6:	79 1f       	adc	r23, r25
    47e8:	09 c0       	rjmp	.+18     	; 0x47fc <RemZeroLead+0x80>
    47ea:	fe 01       	movw	r30, r28
    47ec:	ea 0f       	add	r30, r26
    47ee:	fb 1f       	adc	r31, r27
    47f0:	a6 0f       	add	r26, r22
    47f2:	b7 1f       	adc	r27, r23
    47f4:	8c 91       	ld	r24, X
    47f6:	80 83       	st	Z, r24
		      Zeroed[i+1]=0;
    47f8:	11 82       	std	Z+1, r1	; 0x01
			     }
	      }

		  if (IsFound==True)ZeroPos++;
		  if (ZeroPos>=Length)ZeroPos=Length-1;
          for(i=0;i<(Length-ZeroPos);i++){
    47fa:	4f 5f       	subi	r20, 0xFF	; 255
    47fc:	a4 2f       	mov	r26, r20
    47fe:	b0 e0       	ldi	r27, 0x00	; 0
    4800:	a2 17       	cp	r26, r18
    4802:	b3 07       	cpc	r27, r19
    4804:	94 f3       	brlt	.-28     	; 0x47ea <RemZeroLead+0x6e>
	          Zeroed[i]=Zeroed[i+ZeroPos];
		      Zeroed[i+1]=0;
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}
    4806:	df 91       	pop	r29
    4808:	cf 91       	pop	r28
    480a:	08 95       	ret

0000480c <RemSpaceLead>:
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
    480c:	cf 93       	push	r28
    480e:	df 93       	push	r29
    4810:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
    4812:	fc 01       	movw	r30, r24
    4814:	01 90       	ld	r0, Z+
    4816:	00 20       	and	r0, r0
    4818:	e9 f7       	brne	.-6      	; 0x4814 <RemSpaceLead+0x8>
    481a:	31 97       	sbiw	r30, 0x01	; 1
    481c:	6e 2f       	mov	r22, r30
    481e:	68 1b       	sub	r22, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
    4820:	62 30       	cpi	r22, 0x02	; 2
    4822:	e0 f1       	brcs	.+120    	; 0x489c <RemSpaceLead+0x90>
    4824:	88 81       	ld	r24, Y
    4826:	80 32       	cpi	r24, 0x20	; 32
    4828:	c9 f5       	brne	.+114    	; 0x489c <RemSpaceLead+0x90>
    482a:	4c 2f       	mov	r20, r28
    482c:	fe 01       	movw	r30, r28
    482e:	90 e0       	ldi	r25, 0x00	; 0
    4830:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
    4832:	80 81       	ld	r24, Z
    4834:	80 32       	cpi	r24, 0x20	; 32
    4836:	41 f4       	brne	.+16     	; 0x4848 <RemSpaceLead+0x3c>
    4838:	81 81       	ldd	r24, Z+1	; 0x01
    483a:	80 32       	cpi	r24, 0x20	; 32
    483c:	21 f4       	brne	.+8      	; 0x4846 <RemSpaceLead+0x3a>
    483e:	22 23       	and	r18, r18
    4840:	19 f4       	brne	.+6      	; 0x4848 <RemSpaceLead+0x3c>
    4842:	9f 5f       	subi	r25, 0xFF	; 255
    4844:	01 c0       	rjmp	.+2      	; 0x4848 <RemSpaceLead+0x3c>
    4846:	21 e0       	ldi	r18, 0x01	; 1
    4848:	31 96       	adiw	r30, 0x01	; 1

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
    484a:	8e 2f       	mov	r24, r30
    484c:	84 1b       	sub	r24, r20
    484e:	86 17       	cp	r24, r22
    4850:	80 f3       	brcs	.-32     	; 0x4832 <RemSpaceLead+0x26>
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
    4852:	39 2f       	mov	r19, r25
    4854:	3f 5f       	subi	r19, 0xFF	; 255
    4856:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
    4858:	43 2f       	mov	r20, r19
    485a:	50 e0       	ldi	r21, 0x00	; 0
    485c:	09 c0       	rjmp	.+18     	; 0x4870 <RemSpaceLead+0x64>
    485e:	fe 01       	movw	r30, r28
    4860:	e8 0f       	add	r30, r24
    4862:	f9 1f       	adc	r31, r25
    4864:	df 01       	movw	r26, r30
    4866:	a4 0f       	add	r26, r20
    4868:	b5 1f       	adc	r27, r21
    486a:	8c 91       	ld	r24, X
    486c:	80 83       	st	Z, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
    486e:	2f 5f       	subi	r18, 0xFF	; 255
    4870:	82 2f       	mov	r24, r18
    4872:	90 e0       	ldi	r25, 0x00	; 0
    4874:	fe 01       	movw	r30, r28
    4876:	01 90       	ld	r0, Z+
    4878:	00 20       	and	r0, r0
    487a:	e9 f7       	brne	.-6      	; 0x4876 <RemSpaceLead+0x6a>
    487c:	31 97       	sbiw	r30, 0x01	; 1
    487e:	ec 1b       	sub	r30, r28
    4880:	fd 0b       	sbc	r31, r29
    4882:	8e 17       	cp	r24, r30
    4884:	9f 07       	cpc	r25, r31
    4886:	58 f3       	brcs	.-42     	; 0x485e <RemSpaceLead+0x52>
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    4888:	86 2f       	mov	r24, r22
    488a:	83 1b       	sub	r24, r19
    488c:	05 c0       	rjmp	.+10     	; 0x4898 <RemSpaceLead+0x8c>
		     Zeroed[i]=0;
    488e:	fe 01       	movw	r30, r28
    4890:	e8 0f       	add	r30, r24
    4892:	f1 1d       	adc	r31, r1
    4894:	10 82       	st	Z, r1
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    4896:	8f 5f       	subi	r24, 0xFF	; 255
    4898:	86 17       	cp	r24, r22
    489a:	c8 f3       	brcs	.-14     	; 0x488e <RemSpaceLead+0x82>
		     Zeroed[i]=0;
		 }
     }
}
    489c:	df 91       	pop	r29
    489e:	cf 91       	pop	r28
    48a0:	08 95       	ret

000048a2 <RemSpaceLag>:
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
    48a2:	0f 93       	push	r16
    48a4:	1f 93       	push	r17
    48a6:	cf 93       	push	r28
    48a8:	df 93       	push	r29
    48aa:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
    48ac:	dc 01       	movw	r26, r24
    48ae:	0d 90       	ld	r0, X+
    48b0:	00 20       	and	r0, r0
    48b2:	e9 f7       	brne	.-6      	; 0x48ae <RemSpaceLag+0xc>
    48b4:	11 97       	sbiw	r26, 0x01	; 1
    48b6:	a8 1b       	sub	r26, r24
    48b8:	b0 e0       	ldi	r27, 0x00	; 0
    48ba:	20 e0       	ldi	r18, 0x00	; 0
    48bc:	30 e0       	ldi	r19, 0x00	; 0
     for(i=0;i<(Length-1);i++){
    48be:	6a 2f       	mov	r22, r26
    48c0:	70 e0       	ldi	r23, 0x00	; 0
    48c2:	8b 01       	movw	r16, r22
    48c4:	01 50       	subi	r16, 0x01	; 1
    48c6:	10 40       	sbci	r17, 0x00	; 0
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
		      Spaced[Length-i-1]=0;
    48c8:	a1 50       	subi	r26, 0x01	; 1
    48ca:	16 c0       	rjmp	.+44     	; 0x48f8 <RemSpaceLag+0x56>
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
    48cc:	ab 01       	movw	r20, r22
    48ce:	48 1b       	sub	r20, r24
    48d0:	59 0b       	sbc	r21, r25
    48d2:	fe 01       	movw	r30, r28
    48d4:	e4 0f       	add	r30, r20
    48d6:	f5 1f       	adc	r31, r21
    48d8:	32 97       	sbiw	r30, 0x02	; 2
    48da:	80 81       	ld	r24, Z
    48dc:	80 32       	cpi	r24, 0x20	; 32
    48de:	89 f4       	brne	.+34     	; 0x4902 <RemSpaceLag+0x60>
    48e0:	fa 01       	movw	r30, r20
    48e2:	31 97       	sbiw	r30, 0x01	; 1
    48e4:	ec 0f       	add	r30, r28
    48e6:	fd 1f       	adc	r31, r29
    48e8:	2f 5f       	subi	r18, 0xFF	; 255
    48ea:	3f 4f       	sbci	r19, 0xFF	; 255
    48ec:	80 81       	ld	r24, Z
    48ee:	80 32       	cpi	r24, 0x20	; 32
    48f0:	41 f4       	brne	.+16     	; 0x4902 <RemSpaceLag+0x60>
		      Spaced[Length-i-1]=0;
    48f2:	10 82       	st	Z, r1
    48f4:	ba 2f       	mov	r27, r26
    48f6:	b2 1b       	sub	r27, r18
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
    48f8:	82 2f       	mov	r24, r18
    48fa:	90 e0       	ldi	r25, 0x00	; 0
    48fc:	80 17       	cp	r24, r16
    48fe:	91 07       	cpc	r25, r17
    4900:	2c f3       	brlt	.-54     	; 0x48cc <RemSpaceLag+0x2a>
		      Spaced[Length-i-1]=0;
			  PosSpaced=Length-i-2;
			  }
         else break;
	 }
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
    4902:	fe 01       	movw	r30, r28
    4904:	eb 0f       	add	r30, r27
    4906:	f1 1d       	adc	r31, r1
    4908:	80 81       	ld	r24, Z
    490a:	80 32       	cpi	r24, 0x20	; 32
    490c:	09 f4       	brne	.+2      	; 0x4910 <RemSpaceLag+0x6e>
    490e:	10 82       	st	Z, r1
	 if (Spaced[0]==' ')Spaced[0]=0;
    4910:	88 81       	ld	r24, Y
    4912:	80 32       	cpi	r24, 0x20	; 32
    4914:	09 f4       	brne	.+2      	; 0x4918 <RemSpaceLag+0x76>
    4916:	18 82       	st	Y, r1
	 Spaced[strlen(Spaced)]=0;
    4918:	fe 01       	movw	r30, r28
    491a:	01 90       	ld	r0, Z+
    491c:	00 20       	and	r0, r0
    491e:	e9 f7       	brne	.-6      	; 0x491a <RemSpaceLag+0x78>
    4920:	31 97       	sbiw	r30, 0x01	; 1
    4922:	ec 1b       	sub	r30, r28
    4924:	fd 0b       	sbc	r31, r29
    4926:	ec 0f       	add	r30, r28
    4928:	fd 1f       	adc	r31, r29
    492a:	10 82       	st	Z, r1
}
    492c:	df 91       	pop	r29
    492e:	cf 91       	pop	r28
    4930:	1f 91       	pop	r17
    4932:	0f 91       	pop	r16
    4934:	08 95       	ret

00004936 <procMessage57>:
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}

char procMessage57(){
    4936:	1f 93       	push	r17
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    4938:	10 91 7e 0b 	lds	r17, 0x0B7E
    493c:	20 e0       	ldi	r18, 0x00	; 0
    493e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4940:	f9 01       	movw	r30, r18
    4942:	eb 5b       	subi	r30, 0xBB	; 187
    4944:	f4 4f       	sbci	r31, 0xF4	; 244
    4946:	d9 01       	movw	r26, r18
    4948:	af 54       	subi	r26, 0x4F	; 79
    494a:	b2 4f       	sbci	r27, 0xF2	; 242
    494c:	95 96       	adiw	r26, 0x25	; 37
    494e:	8c 91       	ld	r24, X
    4950:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4952:	2f 5f       	subi	r18, 0xFF	; 255
    4954:	3f 4f       	sbci	r19, 0xFF	; 255
    4956:	24 31       	cpi	r18, 0x14	; 20
    4958:	31 05       	cpc	r19, r1
    495a:	91 f7       	brne	.-28     	; 0x4940 <procMessage57+0xa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    495c:	10 92 59 0b 	sts	0x0B59, r1
	 
	     //Card Status
		 Result=(CharPosCopy(rcv_trans,57)-'0')+1;
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
    4960:	81 eb       	ldi	r24, 0xB1	; 177
    4962:	9d e0       	ldi	r25, 0x0D	; 13
    4964:	0e 94 06 24 	call	0x480c	; 0x480c <RemSpaceLead>
    4968:	20 e0       	ldi	r18, 0x00	; 0
    496a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    496c:	f9 01       	movw	r30, r18
    496e:	ec 5f       	subi	r30, 0xFC	; 252
    4970:	fa 4f       	sbci	r31, 0xFA	; 250
    4972:	d9 01       	movw	r26, r18
    4974:	ab 5b       	subi	r26, 0xBB	; 187
    4976:	b4 4f       	sbci	r27, 0xF4	; 244
    4978:	dc 96       	adiw	r26, 0x3c	; 60
    497a:	8c 91       	ld	r24, X
    497c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    497e:	2f 5f       	subi	r18, 0xFF	; 255
    4980:	3f 4f       	sbci	r19, 0xFF	; 255
    4982:	28 32       	cpi	r18, 0x28	; 40
    4984:	31 05       	cpc	r19, r1
    4986:	91 f7       	brne	.-28     	; 0x496c <procMessage57+0x36>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4988:	10 92 2c 05 	sts	0x052C, r1
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
    498c:	84 e0       	ldi	r24, 0x04	; 4
    498e:	95 e0       	ldi	r25, 0x05	; 5
    4990:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
    4994:	20 e0       	ldi	r18, 0x00	; 0
    4996:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4998:	f9 01       	movw	r30, r18
    499a:	e5 5c       	subi	r30, 0xC5	; 197
    499c:	fa 4f       	sbci	r31, 0xFA	; 250
    499e:	d9 01       	movw	r26, r18
    49a0:	a3 52       	subi	r26, 0x23	; 35
    49a2:	b4 4f       	sbci	r27, 0xF4	; 244
    49a4:	8c 91       	ld	r24, X
    49a6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    49a8:	2f 5f       	subi	r18, 0xFF	; 255
    49aa:	3f 4f       	sbci	r19, 0xFF	; 255
    49ac:	29 31       	cpi	r18, 0x19	; 25
    49ae:	31 05       	cpc	r19, r1
    49b0:	99 f7       	brne	.-26     	; 0x4998 <procMessage57+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    49b2:	10 92 54 05 	sts	0x0554, r1
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
		 //BalanceTypePrint
		 StrPosCopy(rcv_trans,strBalanceTypePrint,154-2,25);
		 RemSpaceLag(strBalanceTypePrint);
    49b6:	8b e3       	ldi	r24, 0x3B	; 59
    49b8:	95 e0       	ldi	r25, 0x05	; 5
    49ba:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    49be:	80 91 f6 0b 	lds	r24, 0x0BF6
    49c2:	80 93 c5 04 	sts	0x04C5, r24
	 }Dest[Length]=0;
    49c6:	10 92 c6 04 	sts	0x04C6, r1
    49ca:	20 e0       	ldi	r18, 0x00	; 0
    49cc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    49ce:	f9 01       	movw	r30, r18
    49d0:	ed 5d       	subi	r30, 0xDD	; 221
    49d2:	f1 4f       	sbci	r31, 0xF1	; 241
    49d4:	d9 01       	movw	r26, r18
    49d6:	a9 50       	subi	r26, 0x09	; 9
    49d8:	b4 4f       	sbci	r27, 0xF4	; 244
    49da:	8c 91       	ld	r24, X
    49dc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    49de:	2f 5f       	subi	r18, 0xFF	; 255
    49e0:	3f 4f       	sbci	r19, 0xFF	; 255
    49e2:	2d 30       	cpi	r18, 0x0D	; 13
    49e4:	31 05       	cpc	r19, r1
    49e6:	99 f7       	brne	.-26     	; 0x49ce <procMessage57+0x98>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    49e8:	10 92 30 0e 	sts	0x0E30, r1
		 RemSpaceLag(strBalanceTypePrint);
         //BalanceTypeCode
		 StrPosCopy(rcv_trans,strBalanceCode,177,1);
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
    49ec:	83 e2       	ldi	r24, 0x23	; 35
    49ee:	9e e0       	ldi	r25, 0x0E	; 14
    49f0:	0e 94 06 24 	call	0x480c	; 0x480c <RemSpaceLead>
    49f4:	20 e0       	ldi	r18, 0x00	; 0
    49f6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    49f8:	f9 01       	movw	r30, r18
    49fa:	ee 5d       	subi	r30, 0xDE	; 222
    49fc:	f4 4f       	sbci	r31, 0xF4	; 244
    49fe:	d9 01       	movw	r26, r18
    4a00:	ac 5f       	subi	r26, 0xFC	; 252
    4a02:	b3 4f       	sbci	r27, 0xF3	; 243
    4a04:	8c 91       	ld	r24, X
    4a06:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4a08:	2f 5f       	subi	r18, 0xFF	; 255
    4a0a:	3f 4f       	sbci	r19, 0xFF	; 255
    4a0c:	2a 30       	cpi	r18, 0x0A	; 10
    4a0e:	31 05       	cpc	r19, r1
    4a10:	99 f7       	brne	.-26     	; 0x49f8 <procMessage57+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4a12:	10 92 2c 0b 	sts	0x0B2C, r1
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
    4a16:	82 e2       	ldi	r24, 0x22	; 34
    4a18:	9b e0       	ldi	r25, 0x0B	; 11
    4a1a:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
    4a1e:	20 e0       	ldi	r18, 0x00	; 0
    4a20:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4a22:	f9 01       	movw	r30, r18
    4a24:	e4 55       	subi	r30, 0x54	; 84
    4a26:	f6 4f       	sbci	r31, 0xF6	; 246
    4a28:	d9 01       	movw	r26, r18
    4a2a:	a2 5f       	subi	r26, 0xF2	; 242
    4a2c:	b3 4f       	sbci	r27, 0xF3	; 243
    4a2e:	8c 91       	ld	r24, X
    4a30:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4a32:	2f 5f       	subi	r18, 0xFF	; 255
    4a34:	3f 4f       	sbci	r19, 0xFF	; 255
    4a36:	24 31       	cpi	r18, 0x14	; 20
    4a38:	31 05       	cpc	r19, r1
    4a3a:	99 f7       	brne	.-26     	; 0x4a22 <procMessage57+0xec>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4a3c:	10 92 c0 09 	sts	0x09C0, r1
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
		 //CompName
		 StrPosCopy(rcv_trans,strCompName,203-2,20);
		 RemSpaceLag(strCompName);
    4a40:	8c ea       	ldi	r24, 0xAC	; 172
    4a42:	99 e0       	ldi	r25, 0x09	; 9
    4a44:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		 _uart_print(0,1,strCompName);
		 
_uart_print(0,1,strCardID);
*/	
     return Result;
}
    4a48:	81 2f       	mov	r24, r17
    4a4a:	8f 52       	subi	r24, 0x2F	; 47
    4a4c:	1f 91       	pop	r17
    4a4e:	08 95       	ret

00004a50 <clearString>:
	     break;
	}
  return Result;
}

void clearString(char *str){
    4a50:	20 e0       	ldi	r18, 0x00	; 0
    4a52:	30 e0       	ldi	r19, 0x00	; 0
    4a54:	06 c0       	rjmp	.+12     	; 0x4a62 <clearString+0x12>
     int i;
	 for(i=0;i<strlen(str);i++){
	    str[i]=0;
    4a56:	fc 01       	movw	r30, r24
    4a58:	e2 0f       	add	r30, r18
    4a5a:	f3 1f       	adc	r31, r19
    4a5c:	10 82       	st	Z, r1
  return Result;
}

void clearString(char *str){
     int i;
	 for(i=0;i<strlen(str);i++){
    4a5e:	2f 5f       	subi	r18, 0xFF	; 255
    4a60:	3f 4f       	sbci	r19, 0xFF	; 255
    4a62:	fc 01       	movw	r30, r24
    4a64:	01 90       	ld	r0, Z+
    4a66:	00 20       	and	r0, r0
    4a68:	e9 f7       	brne	.-6      	; 0x4a64 <clearString+0x14>
    4a6a:	31 97       	sbiw	r30, 0x01	; 1
    4a6c:	e8 1b       	sub	r30, r24
    4a6e:	f9 0b       	sbc	r31, r25
    4a70:	2e 17       	cp	r18, r30
    4a72:	3f 07       	cpc	r19, r31
    4a74:	80 f3       	brcs	.-32     	; 0x4a56 <clearString+0x6>
	    str[i]=0;
	 }
}
    4a76:	08 95       	ret

00004a78 <AddZeroLead>:
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    4a78:	bf 92       	push	r11
    4a7a:	cf 92       	push	r12
    4a7c:	df 92       	push	r13
    4a7e:	ef 92       	push	r14
    4a80:	ff 92       	push	r15
    4a82:	0f 93       	push	r16
    4a84:	1f 93       	push	r17
    4a86:	df 93       	push	r29
    4a88:	cf 93       	push	r28
    4a8a:	cd b7       	in	r28, 0x3d	; 61
    4a8c:	de b7       	in	r29, 0x3e	; 62
    4a8e:	6e 97       	sbiw	r28, 0x1e	; 30
    4a90:	0f b6       	in	r0, 0x3f	; 63
    4a92:	f8 94       	cli
    4a94:	de bf       	out	0x3e, r29	; 62
    4a96:	0f be       	out	0x3f, r0	; 63
    4a98:	cd bf       	out	0x3d, r28	; 61
    4a9a:	8c 01       	movw	r16, r24
     char i,Length,strAdded[30];
     Length=strlen(String);
    4a9c:	fc 01       	movw	r30, r24
    4a9e:	01 90       	ld	r0, Z+
    4aa0:	00 20       	and	r0, r0
    4aa2:	e9 f7       	brne	.-6      	; 0x4a9e <AddZeroLead+0x26>
    4aa4:	31 97       	sbiw	r30, 0x01	; 1
    4aa6:	2e 2f       	mov	r18, r30
    4aa8:	28 1b       	sub	r18, r24

	 if (Size>Length){
    4aaa:	26 17       	cp	r18, r22
    4aac:	e0 f5       	brcc	.+120    	; 0x4b26 <AddZeroLead+0xae>
    4aae:	7e 01       	movw	r14, r28
    4ab0:	08 94       	sec
    4ab2:	e1 1c       	adc	r14, r1
    4ab4:	f1 1c       	adc	r15, r1
    4ab6:	f7 01       	movw	r30, r14
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    4ab8:	be 2c       	mov	r11, r14
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
    4aba:	90 e3       	ldi	r25, 0x30	; 48
    4abc:	01 c0       	rjmp	.+2      	; 0x4ac0 <AddZeroLead+0x48>
    4abe:	91 93       	st	Z+, r25
void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    4ac0:	8e 2f       	mov	r24, r30
    4ac2:	8b 19       	sub	r24, r11
    4ac4:	86 17       	cp	r24, r22
    4ac6:	d8 f3       	brcs	.-10     	; 0x4abe <AddZeroLead+0x46>
	         strAdded[i]='0';
	     }strAdded[Size]=0;
    4ac8:	46 2f       	mov	r20, r22
    4aca:	50 e0       	ldi	r21, 0x00	; 0
    4acc:	ce 01       	movw	r24, r28
    4ace:	01 96       	adiw	r24, 0x01	; 1
    4ad0:	fc 01       	movw	r30, r24
    4ad2:	e4 0f       	add	r30, r20
    4ad4:	f5 1f       	adc	r31, r21
    4ad6:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    4ad8:	76 2f       	mov	r23, r22
    4ada:	72 1b       	sub	r23, r18
    4adc:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    4ade:	30 e0       	ldi	r19, 0x00	; 0
    4ae0:	24 1b       	sub	r18, r20
    4ae2:	35 0b       	sbc	r19, r21
    4ae4:	0c c0       	rjmp	.+24     	; 0x4afe <AddZeroLead+0x86>
    4ae6:	e7 2f       	mov	r30, r23
    4ae8:	f0 e0       	ldi	r31, 0x00	; 0
    4aea:	d6 01       	movw	r26, r12
    4aec:	ae 0f       	add	r26, r30
    4aee:	bf 1f       	adc	r27, r31
    4af0:	e0 0f       	add	r30, r16
    4af2:	f1 1f       	adc	r31, r17
    4af4:	e2 0f       	add	r30, r18
    4af6:	f3 1f       	adc	r31, r19
    4af8:	80 81       	ld	r24, Z
    4afa:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    4afc:	7f 5f       	subi	r23, 0xFF	; 255
    4afe:	76 17       	cp	r23, r22
    4b00:	90 f3       	brcs	.-28     	; 0x4ae6 <AddZeroLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    4b02:	4c 0d       	add	r20, r12
    4b04:	5d 1d       	adc	r21, r13
    4b06:	da 01       	movw	r26, r20
    4b08:	1c 92       	st	X, r1
    4b0a:	f8 01       	movw	r30, r16
    4b0c:	04 c0       	rjmp	.+8      	; 0x4b16 <AddZeroLead+0x9e>
	     //Zeroed
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    4b0e:	d7 01       	movw	r26, r14
    4b10:	8d 91       	ld	r24, X+
    4b12:	7d 01       	movw	r14, r26
    4b14:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Zeroed
         for(i=0;i<Size;i++){
    4b16:	8e 2d       	mov	r24, r14
    4b18:	8b 19       	sub	r24, r11
    4b1a:	86 17       	cp	r24, r22
    4b1c:	c0 f3       	brcs	.-16     	; 0x4b0e <AddZeroLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    4b1e:	06 0f       	add	r16, r22
    4b20:	11 1d       	adc	r17, r1
    4b22:	f8 01       	movw	r30, r16
    4b24:	10 82       	st	Z, r1
	 }
}
    4b26:	6e 96       	adiw	r28, 0x1e	; 30
    4b28:	0f b6       	in	r0, 0x3f	; 63
    4b2a:	f8 94       	cli
    4b2c:	de bf       	out	0x3e, r29	; 62
    4b2e:	0f be       	out	0x3f, r0	; 63
    4b30:	cd bf       	out	0x3d, r28	; 61
    4b32:	cf 91       	pop	r28
    4b34:	df 91       	pop	r29
    4b36:	1f 91       	pop	r17
    4b38:	0f 91       	pop	r16
    4b3a:	ff 90       	pop	r15
    4b3c:	ef 90       	pop	r14
    4b3e:	df 90       	pop	r13
    4b40:	cf 90       	pop	r12
    4b42:	bf 90       	pop	r11
    4b44:	08 95       	ret

00004b46 <GetTotalizerMoney>:
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
void GetTotalizerMoney(char iPumpID,char iGrade, char *Result){
    4b46:	0f 93       	push	r16
    4b48:	1f 93       	push	r17
    4b4a:	cf 93       	push	r28
    4b4c:	df 93       	push	r29
    4b4e:	18 2f       	mov	r17, r24
    4b50:	06 2f       	mov	r16, r22
    4b52:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,13); 
    4b54:	ca 01       	movw	r24, r20
    4b56:	6d e0       	ldi	r22, 0x0D	; 13
    4b58:	0e 94 3c 25 	call	0x4a78	; 0x4a78 <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4b5c:	81 2f       	mov	r24, r17
    4b5e:	0e 94 1a 1c 	call	0x3834	; 0x3834 <GetFIPAddr>
    4b62:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4b64:	88 23       	and	r24, r24
    4b66:	39 f0       	breq	.+14     	; 0x4b76 <GetTotalizerMoney+0x30>
	    FIPAddr=FIPAddr-1;
	    GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4b68:	41 50       	subi	r20, 0x01	; 1
    4b6a:	81 e0       	ldi	r24, 0x01	; 1
    4b6c:	61 e0       	ldi	r22, 0x01	; 1
    4b6e:	20 2f       	mov	r18, r16
    4b70:	8e 01       	movw	r16, r28
    4b72:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <GetTotalizerData>
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}
    4b76:	df 91       	pop	r29
    4b78:	cf 91       	pop	r28
    4b7a:	1f 91       	pop	r17
    4b7c:	0f 91       	pop	r16
    4b7e:	08 95       	ret

00004b80 <GetTotalizerVolume>:
     AddZeroLead(Result,10);
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}

void GetTotalizerVolume(char iPumpID,char iGrade,char *Result){
    4b80:	0f 93       	push	r16
    4b82:	1f 93       	push	r17
    4b84:	cf 93       	push	r28
    4b86:	df 93       	push	r29
    4b88:	18 2f       	mov	r17, r24
    4b8a:	06 2f       	mov	r16, r22
    4b8c:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,11);
    4b8e:	ca 01       	movw	r24, r20
    4b90:	6b e0       	ldi	r22, 0x0B	; 11
    4b92:	0e 94 3c 25 	call	0x4a78	; 0x4a78 <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4b96:	81 2f       	mov	r24, r17
    4b98:	0e 94 1a 1c 	call	0x3834	; 0x3834 <GetFIPAddr>
    4b9c:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4b9e:	88 23       	and	r24, r24
    4ba0:	39 f0       	breq	.+14     	; 0x4bb0 <GetTotalizerVolume+0x30>
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4ba2:	41 50       	subi	r20, 0x01	; 1
    4ba4:	80 e0       	ldi	r24, 0x00	; 0
    4ba6:	61 e0       	ldi	r22, 0x01	; 1
    4ba8:	20 2f       	mov	r18, r16
    4baa:	8e 01       	movw	r16, r28
    4bac:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <GetTotalizerData>
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
    4bb0:	df 91       	pop	r29
    4bb2:	cf 91       	pop	r28
    4bb4:	1f 91       	pop	r17
    4bb6:	0f 91       	pop	r16
    4bb8:	08 95       	ret

00004bba <GetTransactionMoney>:
void GetTransactionVolume(char iPumpID,char *Result){
     AddZeroLead(Result,10);
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
void GetTransactionMoney(char iPumpID,char *Result){
    4bba:	ef 92       	push	r14
    4bbc:	ff 92       	push	r15
    4bbe:	0f 93       	push	r16
    4bc0:	1f 93       	push	r17
    4bc2:	08 2f       	mov	r16, r24
    4bc4:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    4bc6:	cb 01       	movw	r24, r22
    4bc8:	6a e0       	ldi	r22, 0x0A	; 10
    4bca:	0e 94 3c 25 	call	0x4a78	; 0x4a78 <AddZeroLead>
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
    4bce:	00 d0       	rcall	.+0      	; 0x4bd0 <GetTransactionMoney+0x16>
    4bd0:	00 d0       	rcall	.+0      	; 0x4bd2 <GetTransactionMoney+0x18>
    4bd2:	00 d0       	rcall	.+0      	; 0x4bd4 <GetTransactionMoney+0x1a>
    4bd4:	ed b7       	in	r30, 0x3d	; 61
    4bd6:	fe b7       	in	r31, 0x3e	; 62
    4bd8:	31 96       	adiw	r30, 0x01	; 1
    4bda:	ad b7       	in	r26, 0x3d	; 61
    4bdc:	be b7       	in	r27, 0x3e	; 62
    4bde:	12 96       	adiw	r26, 0x02	; 2
    4be0:	fc 92       	st	X, r15
    4be2:	ee 92       	st	-X, r14
    4be4:	11 97       	sbiw	r26, 0x01	; 1
    4be6:	83 e6       	ldi	r24, 0x63	; 99
    4be8:	93 e0       	ldi	r25, 0x03	; 3
    4bea:	93 83       	std	Z+3, r25	; 0x03
    4bec:	82 83       	std	Z+2, r24	; 0x02
    4bee:	10 e0       	ldi	r17, 0x00	; 0
    4bf0:	0f 70       	andi	r16, 0x0F	; 15
    4bf2:	10 70       	andi	r17, 0x00	; 0
    4bf4:	85 e3       	ldi	r24, 0x35	; 53
    4bf6:	90 e0       	ldi	r25, 0x00	; 0
    4bf8:	9c 01       	movw	r18, r24
    4bfa:	02 9f       	mul	r16, r18
    4bfc:	c0 01       	movw	r24, r0
    4bfe:	03 9f       	mul	r16, r19
    4c00:	90 0d       	add	r25, r0
    4c02:	12 9f       	mul	r17, r18
    4c04:	90 0d       	add	r25, r0
    4c06:	11 24       	eor	r1, r1
    4c08:	89 5f       	subi	r24, 0xF9	; 249
    4c0a:	97 4f       	sbci	r25, 0xF7	; 247
    4c0c:	95 83       	std	Z+5, r25	; 0x05
    4c0e:	84 83       	std	Z+4, r24	; 0x04
    4c10:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    4c14:	8d b7       	in	r24, 0x3d	; 61
    4c16:	9e b7       	in	r25, 0x3e	; 62
    4c18:	06 96       	adiw	r24, 0x06	; 6
    4c1a:	0f b6       	in	r0, 0x3f	; 63
    4c1c:	f8 94       	cli
    4c1e:	9e bf       	out	0x3e, r25	; 62
    4c20:	0f be       	out	0x3f, r0	; 63
    4c22:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}
    4c24:	1f 91       	pop	r17
    4c26:	0f 91       	pop	r16
    4c28:	ff 90       	pop	r15
    4c2a:	ef 90       	pop	r14
    4c2c:	08 95       	ret

00004c2e <GetTransactionVolume>:
     }
*/
     FormatDecimal(Result,CurrentDecimal);
}

void GetTransactionVolume(char iPumpID,char *Result){
    4c2e:	ef 92       	push	r14
    4c30:	ff 92       	push	r15
    4c32:	0f 93       	push	r16
    4c34:	1f 93       	push	r17
    4c36:	08 2f       	mov	r16, r24
    4c38:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    4c3a:	cb 01       	movw	r24, r22
    4c3c:	6a e0       	ldi	r22, 0x0A	; 10
    4c3e:	0e 94 3c 25 	call	0x4a78	; 0x4a78 <AddZeroLead>
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
    4c42:	00 d0       	rcall	.+0      	; 0x4c44 <GetTransactionVolume+0x16>
    4c44:	00 d0       	rcall	.+0      	; 0x4c46 <GetTransactionVolume+0x18>
    4c46:	00 d0       	rcall	.+0      	; 0x4c48 <GetTransactionVolume+0x1a>
    4c48:	ed b7       	in	r30, 0x3d	; 61
    4c4a:	fe b7       	in	r31, 0x3e	; 62
    4c4c:	31 96       	adiw	r30, 0x01	; 1
    4c4e:	ad b7       	in	r26, 0x3d	; 61
    4c50:	be b7       	in	r27, 0x3e	; 62
    4c52:	12 96       	adiw	r26, 0x02	; 2
    4c54:	fc 92       	st	X, r15
    4c56:	ee 92       	st	-X, r14
    4c58:	11 97       	sbiw	r26, 0x01	; 1
    4c5a:	86 e6       	ldi	r24, 0x66	; 102
    4c5c:	93 e0       	ldi	r25, 0x03	; 3
    4c5e:	93 83       	std	Z+3, r25	; 0x03
    4c60:	82 83       	std	Z+2, r24	; 0x02
    4c62:	10 e0       	ldi	r17, 0x00	; 0
    4c64:	0f 70       	andi	r16, 0x0F	; 15
    4c66:	10 70       	andi	r17, 0x00	; 0
    4c68:	85 e3       	ldi	r24, 0x35	; 53
    4c6a:	90 e0       	ldi	r25, 0x00	; 0
    4c6c:	9c 01       	movw	r18, r24
    4c6e:	02 9f       	mul	r16, r18
    4c70:	c0 01       	movw	r24, r0
    4c72:	03 9f       	mul	r16, r19
    4c74:	90 0d       	add	r25, r0
    4c76:	12 9f       	mul	r17, r18
    4c78:	90 0d       	add	r25, r0
    4c7a:	11 24       	eor	r1, r1
    4c7c:	82 50       	subi	r24, 0x02	; 2
    4c7e:	98 4f       	sbci	r25, 0xF8	; 248
    4c80:	95 83       	std	Z+5, r25	; 0x05
    4c82:	84 83       	std	Z+4, r24	; 0x04
    4c84:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    4c88:	8d b7       	in	r24, 0x3d	; 61
    4c8a:	9e b7       	in	r25, 0x3e	; 62
    4c8c:	06 96       	adiw	r24, 0x06	; 6
    4c8e:	0f b6       	in	r0, 0x3f	; 63
    4c90:	f8 94       	cli
    4c92:	9e bf       	out	0x3e, r25	; 62
    4c94:	0f be       	out	0x3f, r0	; 63
    4c96:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
    4c98:	1f 91       	pop	r17
    4c9a:	0f 91       	pop	r16
    4c9c:	ff 90       	pop	r15
    4c9e:	ef 90       	pop	r14
    4ca0:	08 95       	ret

00004ca2 <AddZeroLag>:
	         String[i]=strAdded[i];
	     }String[Size]=0;
	 }
}

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
    4ca2:	cf 93       	push	r28
    4ca4:	df 93       	push	r29
    4ca6:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    4ca8:	dc 01       	movw	r26, r24
    4caa:	0d 90       	ld	r0, X+
    4cac:	00 20       	and	r0, r0
    4cae:	e9 f7       	brne	.-6      	; 0x4caa <AddZeroLag+0x8>
    4cb0:	11 97       	sbiw	r26, 0x01	; 1
    4cb2:	a8 1b       	sub	r26, r24
    4cb4:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    4cb6:	a6 17       	cp	r26, r22
    4cb8:	60 f4       	brcc	.+24     	; 0x4cd2 <AddZeroLag+0x30>
    4cba:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]='0';
    4cbc:	90 e3       	ldi	r25, 0x30	; 48
    4cbe:	fe 01       	movw	r30, r28
    4cc0:	e8 0f       	add	r30, r24
    4cc2:	f1 1d       	adc	r31, r1
    4cc4:	90 83       	st	Z, r25

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    4cc6:	8f 5f       	subi	r24, 0xFF	; 255
    4cc8:	86 17       	cp	r24, r22
    4cca:	c8 f3       	brcs	.-14     	; 0x4cbe <AddZeroLag+0x1c>
	    String[i]='0';
	 }String[Size]=0;
    4ccc:	c6 0f       	add	r28, r22
    4cce:	d1 1d       	adc	r29, r1
    4cd0:	18 82       	st	Y, r1
  }
}
    4cd2:	df 91       	pop	r29
    4cd4:	cf 91       	pop	r28
    4cd6:	08 95       	ret

00004cd8 <StrCalc>:
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    4cd8:	3f 92       	push	r3
    4cda:	4f 92       	push	r4
    4cdc:	5f 92       	push	r5
    4cde:	6f 92       	push	r6
    4ce0:	7f 92       	push	r7
    4ce2:	8f 92       	push	r8
    4ce4:	9f 92       	push	r9
    4ce6:	af 92       	push	r10
    4ce8:	bf 92       	push	r11
    4cea:	cf 92       	push	r12
    4cec:	df 92       	push	r13
    4cee:	ef 92       	push	r14
    4cf0:	ff 92       	push	r15
    4cf2:	0f 93       	push	r16
    4cf4:	1f 93       	push	r17
    4cf6:	df 93       	push	r29
    4cf8:	cf 93       	push	r28
    4cfa:	cd b7       	in	r28, 0x3d	; 61
    4cfc:	de b7       	in	r29, 0x3e	; 62
    4cfe:	c8 55       	subi	r28, 0x58	; 88
    4d00:	d0 40       	sbci	r29, 0x00	; 0
    4d02:	0f b6       	in	r0, 0x3f	; 63
    4d04:	f8 94       	cli
    4d06:	de bf       	out	0x3e, r29	; 62
    4d08:	0f be       	out	0x3f, r0	; 63
    4d0a:	cd bf       	out	0x3d, r28	; 61
    4d0c:	68 2e       	mov	r6, r24
    4d0e:	67 96       	adiw	r28, 0x17	; 23
    4d10:	7f af       	std	Y+63, r23	; 0x3f
    4d12:	6e af       	std	Y+62, r22	; 0x3e
    4d14:	67 97       	sbiw	r28, 0x17	; 23
    4d16:	69 96       	adiw	r28, 0x19	; 25
    4d18:	5f af       	std	Y+63, r21	; 0x3f
    4d1a:	4e af       	std	Y+62, r20	; 0x3e
    4d1c:	69 97       	sbiw	r28, 0x19	; 25
    4d1e:	59 01       	movw	r10, r18
    4d20:	fe 01       	movw	r30, r28
    4d22:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4d24:	ce 01       	movw	r24, r28
    4d26:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    4d28:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4d2a:	e8 17       	cp	r30, r24
    4d2c:	f9 07       	cpc	r31, r25
    4d2e:	e1 f7       	brne	.-8      	; 0x4d28 <StrCalc+0x50>
	     strMemory[i]=data;
    4d30:	ce 01       	movw	r24, r28
    4d32:	89 96       	adiw	r24, 0x29	; 41
    4d34:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4d36:	e8 17       	cp	r30, r24
    4d38:	f9 07       	cpc	r31, r25
    4d3a:	e1 f7       	brne	.-8      	; 0x4d34 <StrCalc+0x5c>
    4d3c:	fe 01       	movw	r30, r28
    4d3e:	fd 96       	adiw	r30, 0x3d	; 61
	     strMemory[i]=data;
    4d40:	cf 01       	movw	r24, r30
    4d42:	44 96       	adiw	r24, 0x14	; 20
    4d44:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4d46:	e8 17       	cp	r30, r24
    4d48:	f9 07       	cpc	r31, r25
    4d4a:	e1 f7       	brne	.-8      	; 0x4d44 <StrCalc+0x6c>
	 FillChar(tmpB,sizeof(tmpB),0);
	 FillChar(Result,sizeof(Result),0);
                                            // -5    -5     5    5
	                                        // -6 -   6 -  -6 -  6 -
                                            // -5+6   
	 sprintf_P(tmpA,PSTR("%s"),strA);       // 
    4d4c:	00 d0       	rcall	.+0      	; 0x4d4e <StrCalc+0x76>
    4d4e:	00 d0       	rcall	.+0      	; 0x4d50 <StrCalc+0x78>
    4d50:	00 d0       	rcall	.+0      	; 0x4d52 <StrCalc+0x7a>
    4d52:	ed b7       	in	r30, 0x3d	; 61
    4d54:	fe b7       	in	r31, 0x3e	; 62
    4d56:	31 96       	adiw	r30, 0x01	; 1
    4d58:	8e 01       	movw	r16, r28
    4d5a:	0f 5f       	subi	r16, 0xFF	; 255
    4d5c:	1f 4f       	sbci	r17, 0xFF	; 255
    4d5e:	ad b7       	in	r26, 0x3d	; 61
    4d60:	be b7       	in	r27, 0x3e	; 62
    4d62:	12 96       	adiw	r26, 0x02	; 2
    4d64:	1c 93       	st	X, r17
    4d66:	0e 93       	st	-X, r16
    4d68:	11 97       	sbiw	r26, 0x01	; 1
    4d6a:	81 eb       	ldi	r24, 0xB1	; 177
    4d6c:	95 e0       	ldi	r25, 0x05	; 5
    4d6e:	93 83       	std	Z+3, r25	; 0x03
    4d70:	82 83       	std	Z+2, r24	; 0x02
    4d72:	67 96       	adiw	r28, 0x17	; 23
    4d74:	2e ad       	ldd	r18, Y+62	; 0x3e
    4d76:	3f ad       	ldd	r19, Y+63	; 0x3f
    4d78:	67 97       	sbiw	r28, 0x17	; 23
    4d7a:	35 83       	std	Z+5, r19	; 0x05
    4d7c:	24 83       	std	Z+4, r18	; 0x04
    4d7e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	 sprintf_P(tmpB,PSTR("%s"),strB);  
    4d82:	ed b7       	in	r30, 0x3d	; 61
    4d84:	fe b7       	in	r31, 0x3e	; 62
    4d86:	31 96       	adiw	r30, 0x01	; 1
    4d88:	ce 01       	movw	r24, r28
    4d8a:	45 96       	adiw	r24, 0x15	; 21
    4d8c:	ad b7       	in	r26, 0x3d	; 61
    4d8e:	be b7       	in	r27, 0x3e	; 62
    4d90:	12 96       	adiw	r26, 0x02	; 2
    4d92:	9c 93       	st	X, r25
    4d94:	8e 93       	st	-X, r24
    4d96:	11 97       	sbiw	r26, 0x01	; 1
    4d98:	8e ea       	ldi	r24, 0xAE	; 174
    4d9a:	95 e0       	ldi	r25, 0x05	; 5
    4d9c:	93 83       	std	Z+3, r25	; 0x03
    4d9e:	82 83       	std	Z+2, r24	; 0x02
    4da0:	69 96       	adiw	r28, 0x19	; 25
    4da2:	2e ad       	ldd	r18, Y+62	; 0x3e
    4da4:	3f ad       	ldd	r19, Y+63	; 0x3f
    4da6:	69 97       	sbiw	r28, 0x19	; 25
    4da8:	35 83       	std	Z+5, r19	; 0x05
    4daa:	24 83       	std	Z+4, r18	; 0x04
    4dac:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>

     if (IsMinus(tmpA)==True){
    4db0:	8d b7       	in	r24, 0x3d	; 61
    4db2:	9e b7       	in	r25, 0x3e	; 62
    4db4:	06 96       	adiw	r24, 0x06	; 6
    4db6:	0f b6       	in	r0, 0x3f	; 63
    4db8:	f8 94       	cli
    4dba:	9e bf       	out	0x3e, r25	; 62
    4dbc:	0f be       	out	0x3f, r0	; 63
    4dbe:	8d bf       	out	0x3d, r24	; 61
    4dc0:	c8 01       	movw	r24, r16
    4dc2:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <IsMinus>
    4dc6:	81 30       	cpi	r24, 0x01	; 1
    4dc8:	21 f0       	breq	.+8      	; 0x4dd2 <StrCalc+0xfa>
    4dca:	65 96       	adiw	r28, 0x15	; 21
    4dcc:	1f ae       	std	Y+63, r1	; 0x3f
    4dce:	65 97       	sbiw	r28, 0x15	; 21
    4dd0:	07 c0       	rjmp	.+14     	; 0x4de0 <StrCalc+0x108>
	     RemoveMinus(tmpA);
    4dd2:	c8 01       	movw	r24, r16
    4dd4:	0e 94 f8 21 	call	0x43f0	; 0x43f0 <RemoveMinus>
    4dd8:	91 e0       	ldi	r25, 0x01	; 1
    4dda:	65 96       	adiw	r28, 0x15	; 21
    4ddc:	9f af       	std	Y+63, r25	; 0x3f
    4dde:	65 97       	sbiw	r28, 0x15	; 21
		 IsMinA=True;
	 }
     if (IsMinus(tmpB)==True){
    4de0:	8e 01       	movw	r16, r28
    4de2:	0b 5e       	subi	r16, 0xEB	; 235
    4de4:	1f 4f       	sbci	r17, 0xFF	; 255
    4de6:	c8 01       	movw	r24, r16
    4de8:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <IsMinus>
    4dec:	81 30       	cpi	r24, 0x01	; 1
    4dee:	21 f0       	breq	.+8      	; 0x4df8 <StrCalc+0x120>
    4df0:	64 96       	adiw	r28, 0x14	; 20
    4df2:	1f ae       	std	Y+63, r1	; 0x3f
    4df4:	64 97       	sbiw	r28, 0x14	; 20
    4df6:	07 c0       	rjmp	.+14     	; 0x4e06 <StrCalc+0x12e>
	     RemoveMinus(tmpB);
    4df8:	c8 01       	movw	r24, r16
    4dfa:	0e 94 f8 21 	call	0x43f0	; 0x43f0 <RemoveMinus>
    4dfe:	a1 e0       	ldi	r26, 0x01	; 1
    4e00:	64 96       	adiw	r28, 0x14	; 20
    4e02:	af af       	std	Y+63, r26	; 0x3f
    4e04:	64 97       	sbiw	r28, 0x14	; 20
		 IsMinB=True;
	 }    	

     lenA=strlen(tmpA);
    4e06:	fe 01       	movw	r30, r28
    4e08:	31 96       	adiw	r30, 0x01	; 1
    4e0a:	df 01       	movw	r26, r30
    4e0c:	0d 90       	ld	r0, X+
    4e0e:	00 20       	and	r0, r0
    4e10:	e9 f7       	brne	.-6      	; 0x4e0c <StrCalc+0x134>
    4e12:	cd 01       	movw	r24, r26
    4e14:	01 97       	sbiw	r24, 0x01	; 1
    4e16:	8e 1b       	sub	r24, r30
    4e18:	9f 0b       	sbc	r25, r31
     lenB=strlen(tmpB);
    4e1a:	de 01       	movw	r26, r28
    4e1c:	55 96       	adiw	r26, 0x15	; 21
    4e1e:	fd 01       	movw	r30, r26
    4e20:	01 90       	ld	r0, Z+
    4e22:	00 20       	and	r0, r0
    4e24:	e9 f7       	brne	.-6      	; 0x4e20 <StrCalc+0x148>
    4e26:	31 97       	sbiw	r30, 0x01	; 1
     /*
	 sprintf_P(strSend,PSTR("A:%s"),strA);	 _uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);	 _uart_print(0,1,strSend);
     */

     AddZeroLead(tmpA,FixLen+1);
    4e28:	1e 2f       	mov	r17, r30
    4e2a:	1a 1b       	sub	r17, r26
    4e2c:	18 17       	cp	r17, r24
    4e2e:	08 f4       	brcc	.+2      	; 0x4e32 <StrCalc+0x15a>
    4e30:	18 2f       	mov	r17, r24
    4e32:	1f 5f       	subi	r17, 0xFF	; 255
    4e34:	7e 01       	movw	r14, r28
    4e36:	08 94       	sec
    4e38:	e1 1c       	adc	r14, r1
    4e3a:	f1 1c       	adc	r15, r1
    4e3c:	c7 01       	movw	r24, r14
    4e3e:	61 2f       	mov	r22, r17
    4e40:	0e 94 3c 25 	call	0x4a78	; 0x4a78 <AddZeroLead>
     AddZeroLead(tmpB,FixLen+1);
    4e44:	a5 e1       	ldi	r26, 0x15	; 21
    4e46:	ca 2e       	mov	r12, r26
    4e48:	d1 2c       	mov	r13, r1
    4e4a:	cc 0e       	add	r12, r28
    4e4c:	dd 1e       	adc	r13, r29
    4e4e:	c6 01       	movw	r24, r12
    4e50:	61 2f       	mov	r22, r17
    4e52:	0e 94 3c 25 	call	0x4a78	; 0x4a78 <AddZeroLead>
	 _uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);
	 _uart_print(0,1,strSend);
	 */

     lenA=strlen(tmpA);
    4e56:	f7 01       	movw	r30, r14
    4e58:	01 90       	ld	r0, Z+
    4e5a:	00 20       	and	r0, r0
    4e5c:	e9 f7       	brne	.-6      	; 0x4e58 <StrCalc+0x180>
    4e5e:	31 97       	sbiw	r30, 0x01	; 1
    4e60:	7e 2e       	mov	r7, r30
    4e62:	7e 18       	sub	r7, r14
     lenB=strlen(tmpB);
    4e64:	f6 01       	movw	r30, r12
    4e66:	01 90       	ld	r0, Z+
    4e68:	00 20       	and	r0, r0
    4e6a:	e9 f7       	brne	.-6      	; 0x4e66 <StrCalc+0x18e>
    4e6c:	31 97       	sbiw	r30, 0x01	; 1
    4e6e:	9e 2e       	mov	r9, r30
    4e70:	9c 18       	sub	r9, r12
     IsNegative=False;
	 
	 IsNegative=False;
	 IsSwap=False;

	 if (IsMoreThan(tmpB,tmpA)==True){
    4e72:	c6 01       	movw	r24, r12
    4e74:	b7 01       	movw	r22, r14
    4e76:	0e 94 25 22 	call	0x444a	; 0x444a <IsMoreThan>
    4e7a:	81 30       	cpi	r24, 0x01	; 1
    4e7c:	11 f0       	breq	.+4      	; 0x4e82 <StrCalc+0x1aa>
    4e7e:	80 e0       	ldi	r24, 0x00	; 0
    4e80:	42 c0       	rjmp	.+132    	; 0x4f06 <StrCalc+0x22e>
	     IsSwap=True;
         sprintf_P(tmpC,PSTR("%s"),tmpA);
    4e82:	00 d0       	rcall	.+0      	; 0x4e84 <StrCalc+0x1ac>
    4e84:	00 d0       	rcall	.+0      	; 0x4e86 <StrCalc+0x1ae>
    4e86:	00 d0       	rcall	.+0      	; 0x4e88 <StrCalc+0x1b0>
    4e88:	ed b7       	in	r30, 0x3d	; 61
    4e8a:	fe b7       	in	r31, 0x3e	; 62
    4e8c:	31 96       	adiw	r30, 0x01	; 1
    4e8e:	8e 01       	movw	r16, r28
    4e90:	07 5d       	subi	r16, 0xD7	; 215
    4e92:	1f 4f       	sbci	r17, 0xFF	; 255
    4e94:	ad b7       	in	r26, 0x3d	; 61
    4e96:	be b7       	in	r27, 0x3e	; 62
    4e98:	12 96       	adiw	r26, 0x02	; 2
    4e9a:	1c 93       	st	X, r17
    4e9c:	0e 93       	st	-X, r16
    4e9e:	11 97       	sbiw	r26, 0x01	; 1
    4ea0:	8b ea       	ldi	r24, 0xAB	; 171
    4ea2:	95 e0       	ldi	r25, 0x05	; 5
    4ea4:	93 83       	std	Z+3, r25	; 0x03
    4ea6:	82 83       	std	Z+2, r24	; 0x02
    4ea8:	f5 82       	std	Z+5, r15	; 0x05
    4eaa:	e4 82       	std	Z+4, r14	; 0x04
    4eac:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		 sprintf_P(tmpA,PSTR("%s"),tmpB);
    4eb0:	ed b7       	in	r30, 0x3d	; 61
    4eb2:	fe b7       	in	r31, 0x3e	; 62
    4eb4:	31 96       	adiw	r30, 0x01	; 1
    4eb6:	ad b7       	in	r26, 0x3d	; 61
    4eb8:	be b7       	in	r27, 0x3e	; 62
    4eba:	12 96       	adiw	r26, 0x02	; 2
    4ebc:	fc 92       	st	X, r15
    4ebe:	ee 92       	st	-X, r14
    4ec0:	11 97       	sbiw	r26, 0x01	; 1
    4ec2:	88 ea       	ldi	r24, 0xA8	; 168
    4ec4:	95 e0       	ldi	r25, 0x05	; 5
    4ec6:	93 83       	std	Z+3, r25	; 0x03
    4ec8:	82 83       	std	Z+2, r24	; 0x02
    4eca:	d5 82       	std	Z+5, r13	; 0x05
    4ecc:	c4 82       	std	Z+4, r12	; 0x04
    4ece:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		 sprintf_P(tmpB,PSTR("%s"),tmpC);
    4ed2:	ed b7       	in	r30, 0x3d	; 61
    4ed4:	fe b7       	in	r31, 0x3e	; 62
    4ed6:	31 96       	adiw	r30, 0x01	; 1
    4ed8:	ad b7       	in	r26, 0x3d	; 61
    4eda:	be b7       	in	r27, 0x3e	; 62
    4edc:	12 96       	adiw	r26, 0x02	; 2
    4ede:	dc 92       	st	X, r13
    4ee0:	ce 92       	st	-X, r12
    4ee2:	11 97       	sbiw	r26, 0x01	; 1
    4ee4:	85 ea       	ldi	r24, 0xA5	; 165
    4ee6:	95 e0       	ldi	r25, 0x05	; 5
    4ee8:	93 83       	std	Z+3, r25	; 0x03
    4eea:	82 83       	std	Z+2, r24	; 0x02
    4eec:	15 83       	std	Z+5, r17	; 0x05
    4eee:	04 83       	std	Z+4, r16	; 0x04
    4ef0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    4ef4:	81 e0       	ldi	r24, 0x01	; 1
    4ef6:	ed b7       	in	r30, 0x3d	; 61
    4ef8:	fe b7       	in	r31, 0x3e	; 62
    4efa:	36 96       	adiw	r30, 0x06	; 6
    4efc:	0f b6       	in	r0, 0x3f	; 63
    4efe:	f8 94       	cli
    4f00:	fe bf       	out	0x3e, r31	; 62
    4f02:	0f be       	out	0x3f, r0	; 63
    4f04:	ed bf       	out	0x3d, r30	; 61
	 }
    
	if (TOperation==TMINUS){
    4f06:	66 20       	and	r6, r6
    4f08:	39 f5       	brne	.+78     	; 0x4f58 <StrCalc+0x280>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    4f0a:	81 30       	cpi	r24, 0x01	; 1
    4f0c:	99 f4       	brne	.+38     	; 0x4f34 <StrCalc+0x25c>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    4f0e:	65 96       	adiw	r28, 0x15	; 21
    4f10:	ff ad       	ldd	r31, Y+63	; 0x3f
    4f12:	65 97       	sbiw	r28, 0x15	; 21
    4f14:	f1 30       	cpi	r31, 0x01	; 1
    4f16:	39 f4       	brne	.+14     	; 0x4f26 <StrCalc+0x24e>
    4f18:	64 96       	adiw	r28, 0x14	; 20
    4f1a:	2f ad       	ldd	r18, Y+63	; 0x3f
    4f1c:	64 97       	sbiw	r28, 0x14	; 20
    4f1e:	21 30       	cpi	r18, 0x01	; 1
    4f20:	09 f0       	breq	.+2      	; 0x4f24 <StrCalc+0x24c>
    4f22:	9e c1       	rjmp	.+828    	; 0x5260 <StrCalc+0x588>
    4f24:	42 c0       	rjmp	.+132    	; 0x4faa <StrCalc+0x2d2>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    4f26:	64 96       	adiw	r28, 0x14	; 20
    4f28:	3f ad       	ldd	r19, Y+63	; 0x3f
    4f2a:	64 97       	sbiw	r28, 0x14	; 20
    4f2c:	31 30       	cpi	r19, 0x01	; 1
    4f2e:	09 f0       	breq	.+2      	; 0x4f32 <StrCalc+0x25a>
    4f30:	8e c1       	rjmp	.+796    	; 0x524e <StrCalc+0x576>
    4f32:	92 c1       	rjmp	.+804    	; 0x5258 <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    4f34:	65 96       	adiw	r28, 0x15	; 21
    4f36:	8f ad       	ldd	r24, Y+63	; 0x3f
    4f38:	65 97       	sbiw	r28, 0x15	; 21
    4f3a:	81 30       	cpi	r24, 0x01	; 1
    4f3c:	39 f4       	brne	.+14     	; 0x4f4c <StrCalc+0x274>
    4f3e:	64 96       	adiw	r28, 0x14	; 20
    4f40:	9f ad       	ldd	r25, Y+63	; 0x3f
    4f42:	64 97       	sbiw	r28, 0x14	; 20
    4f44:	91 30       	cpi	r25, 0x01	; 1
    4f46:	09 f0       	breq	.+2      	; 0x4f4a <StrCalc+0x272>
    4f48:	8b c1       	rjmp	.+790    	; 0x5260 <StrCalc+0x588>
    4f4a:	81 c1       	rjmp	.+770    	; 0x524e <StrCalc+0x576>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    4f4c:	64 96       	adiw	r28, 0x14	; 20
    4f4e:	af ad       	ldd	r26, Y+63	; 0x3f
    4f50:	64 97       	sbiw	r28, 0x14	; 20
    4f52:	a1 30       	cpi	r26, 0x01	; 1
    4f54:	51 f5       	brne	.+84     	; 0x4faa <StrCalc+0x2d2>
    4f56:	80 c1       	rjmp	.+768    	; 0x5258 <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
		}
	 }else
	if (TOperation==TPLUS){
    4f58:	b1 e0       	ldi	r27, 0x01	; 1
    4f5a:	6b 16       	cp	r6, r27
    4f5c:	31 f5       	brne	.+76     	; 0x4faa <StrCalc+0x2d2>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    4f5e:	81 30       	cpi	r24, 0x01	; 1
    4f60:	91 f4       	brne	.+36     	; 0x4f86 <StrCalc+0x2ae>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    4f62:	65 96       	adiw	r28, 0x15	; 21
    4f64:	ef ad       	ldd	r30, Y+63	; 0x3f
    4f66:	65 97       	sbiw	r28, 0x15	; 21
    4f68:	e1 30       	cpi	r30, 0x01	; 1
    4f6a:	31 f4       	brne	.+12     	; 0x4f78 <StrCalc+0x2a0>
    4f6c:	64 96       	adiw	r28, 0x14	; 20
    4f6e:	ff ad       	ldd	r31, Y+63	; 0x3f
    4f70:	64 97       	sbiw	r28, 0x14	; 20
    4f72:	f1 30       	cpi	r31, 0x01	; 1
    4f74:	d1 f4       	brne	.+52     	; 0x4faa <StrCalc+0x2d2>
    4f76:	74 c1       	rjmp	.+744    	; 0x5260 <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    4f78:	64 96       	adiw	r28, 0x14	; 20
    4f7a:	2f ad       	ldd	r18, Y+63	; 0x3f
    4f7c:	64 97       	sbiw	r28, 0x14	; 20
    4f7e:	21 30       	cpi	r18, 0x01	; 1
    4f80:	09 f0       	breq	.+2      	; 0x4f84 <StrCalc+0x2ac>
    4f82:	6a c1       	rjmp	.+724    	; 0x5258 <StrCalc+0x580>
    4f84:	64 c1       	rjmp	.+712    	; 0x524e <StrCalc+0x576>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TPLUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    4f86:	65 96       	adiw	r28, 0x15	; 21
    4f88:	3f ad       	ldd	r19, Y+63	; 0x3f
    4f8a:	65 97       	sbiw	r28, 0x15	; 21
    4f8c:	31 30       	cpi	r19, 0x01	; 1
    4f8e:	39 f4       	brne	.+14     	; 0x4f9e <StrCalc+0x2c6>
    4f90:	64 96       	adiw	r28, 0x14	; 20
    4f92:	8f ad       	ldd	r24, Y+63	; 0x3f
    4f94:	64 97       	sbiw	r28, 0x14	; 20
    4f96:	81 30       	cpi	r24, 0x01	; 1
    4f98:	09 f0       	breq	.+2      	; 0x4f9c <StrCalc+0x2c4>
    4f9a:	59 c1       	rjmp	.+690    	; 0x524e <StrCalc+0x576>
    4f9c:	61 c1       	rjmp	.+706    	; 0x5260 <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    4f9e:	64 96       	adiw	r28, 0x14	; 20
    4fa0:	9f ad       	ldd	r25, Y+63	; 0x3f
    4fa2:	64 97       	sbiw	r28, 0x14	; 20
    4fa4:	91 30       	cpi	r25, 0x01	; 1
    4fa6:	09 f0       	breq	.+2      	; 0x4faa <StrCalc+0x2d2>
    4fa8:	57 c1       	rjmp	.+686    	; 0x5258 <StrCalc+0x580>
   // A: 100000
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
    4faa:	62 96       	adiw	r28, 0x12	; 18
    4fac:	1f ae       	std	Y+63, r1	; 0x3f
    4fae:	62 97       	sbiw	r28, 0x12	; 18
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    4fb0:	e7 2c       	mov	r14, r7
    4fb2:	ff 24       	eor	r15, r15
    4fb4:	67 01       	movw	r12, r14
    4fb6:	08 94       	sec
    4fb8:	c1 08       	sbc	r12, r1
    4fba:	d1 08       	sbc	r13, r1
    4fbc:	ae 01       	movw	r20, r28
    4fbe:	43 5c       	subi	r20, 0xC3	; 195
    4fc0:	5f 4f       	sbci	r21, 0xFF	; 255
    4fc2:	4c 0d       	add	r20, r12
    4fc4:	5d 1d       	adc	r21, r13
    4fc6:	ce 01       	movw	r24, r28
    4fc8:	01 96       	adiw	r24, 0x01	; 1
    4fca:	8c 01       	movw	r16, r24
    4fcc:	0c 0d       	add	r16, r12
    4fce:	1d 1d       	adc	r17, r13
    4fd0:	be 01       	movw	r22, r28
    4fd2:	69 0d       	add	r22, r9
    4fd4:	71 1d       	adc	r23, r1
    4fd6:	6c 5e       	subi	r22, 0xEC	; 236
    4fd8:	7f 4f       	sbci	r23, 0xFF	; 255
    4fda:	99 24       	eor	r9, r9
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    4fdc:	2c 01       	movw	r4, r24
    4fde:	f9 e3       	ldi	r31, 0x39	; 57
    4fe0:	8f 2e       	mov	r8, r31
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    4fe2:	9a e0       	ldi	r25, 0x0A	; 10
    4fe4:	52 c0       	rjmp	.+164    	; 0x508a <StrCalc+0x3b2>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4fe6:	d8 01       	movw	r26, r16
    4fe8:	8c 91       	ld	r24, X
    4fea:	80 53       	subi	r24, 0x30	; 48
    4fec:	8a 30       	cpi	r24, 0x0A	; 10
    4fee:	10 f0       	brcs	.+4      	; 0x4ff4 <StrCalc+0x31c>
    4ff0:	20 e0       	ldi	r18, 0x00	; 0
    4ff2:	01 c0       	rjmp	.+2      	; 0x4ff6 <StrCalc+0x31e>
    4ff4:	28 2f       	mov	r18, r24
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
    4ff6:	fb 01       	movw	r30, r22
    4ff8:	30 81       	ld	r19, Z
    4ffa:	30 53       	subi	r19, 0x30	; 48
    4ffc:	3a 30       	cpi	r19, 0x0A	; 10
    4ffe:	10 f4       	brcc	.+4      	; 0x5004 <StrCalc+0x32c>
    5000:	23 17       	cp	r18, r19
    5002:	40 f0       	brcs	.+16     	; 0x5014 <StrCalc+0x33c>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5004:	8a 30       	cpi	r24, 0x0A	; 10
    5006:	08 f0       	brcs	.+2      	; 0x500a <StrCalc+0x332>
    5008:	80 e0       	ldi	r24, 0x00	; 0

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    500a:	3a 30       	cpi	r19, 0x0A	; 10
    500c:	08 f0       	brcs	.+2      	; 0x5010 <StrCalc+0x338>
    500e:	30 e0       	ldi	r19, 0x00	; 0
    5010:	83 1b       	sub	r24, r19
    5012:	2d c0       	rjmp	.+90     	; 0x506e <StrCalc+0x396>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5014:	8a 30       	cpi	r24, 0x0A	; 10
    5016:	10 f4       	brcc	.+4      	; 0x501c <StrCalc+0x344>
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
    5018:	83 17       	cp	r24, r19
    501a:	80 f5       	brcc	.+96     	; 0x507c <StrCalc+0x3a4>
    501c:	29 2d       	mov	r18, r9
    501e:	0a c0       	rjmp	.+20     	; 0x5034 <StrCalc+0x35c>
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    5020:	f6 01       	movw	r30, r12
    5022:	e2 1b       	sub	r30, r18
    5024:	f1 09       	sbc	r31, r1
    5026:	d2 01       	movw	r26, r4
    5028:	ae 0f       	add	r26, r30
    502a:	bf 1f       	adc	r27, r31
    502c:	8c 91       	ld	r24, X
    502e:	80 33       	cpi	r24, 0x30	; 48
    5030:	29 f4       	brne	.+10     	; 0x503c <StrCalc+0x364>
    5032:	8c 92       	st	X, r8
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
    5034:	2f 5f       	subi	r18, 0xFF	; 255
    5036:	27 15       	cp	r18, r7
    5038:	98 f3       	brcs	.-26     	; 0x5020 <StrCalc+0x348>
    503a:	10 c0       	rjmp	.+32     	; 0x505c <StrCalc+0x384>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    503c:	28 2f       	mov	r18, r24
    503e:	20 53       	subi	r18, 0x30	; 48
    5040:	2a 30       	cpi	r18, 0x0A	; 10
    5042:	08 f0       	brcs	.+2      	; 0x5046 <StrCalc+0x36e>
    5044:	20 e0       	ldi	r18, 0x00	; 0
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    5046:	82 2f       	mov	r24, r18
    5048:	81 50       	subi	r24, 0x01	; 1
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    504a:	8a 30       	cpi	r24, 0x0A	; 10
    504c:	10 f0       	brcs	.+4      	; 0x5052 <StrCalc+0x37a>
    504e:	80 e3       	ldi	r24, 0x30	; 48
    5050:	02 c0       	rjmp	.+4      	; 0x5056 <StrCalc+0x37e>
	    Result='0'+X;
    5052:	82 2f       	mov	r24, r18
    5054:	81 5d       	subi	r24, 0xD1	; 209
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    5056:	e4 0d       	add	r30, r4
    5058:	f5 1d       	adc	r31, r5
    505a:	80 83       	st	Z, r24
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    505c:	f8 01       	movw	r30, r16
    505e:	20 81       	ld	r18, Z
    5060:	20 53       	subi	r18, 0x30	; 48
    5062:	2a 30       	cpi	r18, 0x0A	; 10
    5064:	08 f0       	brcs	.+2      	; 0x5068 <StrCalc+0x390>
    5066:	20 e0       	ldi	r18, 0x00	; 0
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5068:	89 2f       	mov	r24, r25
    506a:	83 1b       	sub	r24, r19
    506c:	82 0f       	add	r24, r18
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    506e:	8a 30       	cpi	r24, 0x0A	; 10
    5070:	10 f0       	brcs	.+4      	; 0x5076 <StrCalc+0x39e>
    5072:	80 e3       	ldi	r24, 0x30	; 48
    5074:	01 c0       	rjmp	.+2      	; 0x5078 <StrCalc+0x3a0>
	    Result='0'+X;
    5076:	80 5d       	subi	r24, 0xD0	; 208
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5078:	da 01       	movw	r26, r20
    507a:	8c 93       	st	X, r24
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
    507c:	93 94       	inc	r9
    507e:	41 50       	subi	r20, 0x01	; 1
    5080:	50 40       	sbci	r21, 0x00	; 0
    5082:	01 50       	subi	r16, 0x01	; 1
    5084:	10 40       	sbci	r17, 0x00	; 0
    5086:	61 50       	subi	r22, 0x01	; 1
    5088:	70 40       	sbci	r23, 0x00	; 0
    508a:	97 14       	cp	r9, r7
    508c:	08 f4       	brcc	.+2      	; 0x5090 <StrCalc+0x3b8>
    508e:	ab cf       	rjmp	.-170    	; 0x4fe6 <StrCalc+0x30e>
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }
		 }Result[lenA]=0;		    
    5090:	8e 01       	movw	r16, r28
    5092:	03 5c       	subi	r16, 0xC3	; 195
    5094:	1f 4f       	sbci	r17, 0xFF	; 255
    5096:	e0 0e       	add	r14, r16
    5098:	f1 1e       	adc	r15, r17
    509a:	f7 01       	movw	r30, r14
    509c:	10 82       	st	Z, r1
       RemZeroLead(Result);
    509e:	c8 01       	movw	r24, r16
    50a0:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
    50a4:	f8 01       	movw	r30, r16
    50a6:	01 90       	ld	r0, Z+
    50a8:	00 20       	and	r0, r0
    50aa:	e9 f7       	brne	.-6      	; 0x50a6 <StrCalc+0x3ce>
    50ac:	31 97       	sbiw	r30, 0x01	; 1
    50ae:	3e 2f       	mov	r19, r30
    50b0:	30 1b       	sub	r19, r16
    50b2:	d8 01       	movw	r26, r16
    50b4:	20 e0       	ldi	r18, 0x00	; 0
    50b6:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    50b8:	4d e2       	ldi	r20, 0x2D	; 45
    50ba:	13 c0       	rjmp	.+38     	; 0x50e2 <StrCalc+0x40a>
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    50bc:	22 23       	and	r18, r18
    50be:	51 f4       	brne	.+20     	; 0x50d4 <StrCalc+0x3fc>
    50c0:	62 96       	adiw	r28, 0x12	; 18
    50c2:	ff ad       	ldd	r31, Y+63	; 0x3f
    50c4:	62 97       	sbiw	r28, 0x12	; 18
    50c6:	f1 30       	cpi	r31, 0x01	; 1
    50c8:	29 f4       	brne	.+10     	; 0x50d4 <StrCalc+0x3fc>
			     strC[iPos]='-';
    50ca:	f5 01       	movw	r30, r10
    50cc:	e9 0f       	add	r30, r25
    50ce:	f1 1d       	adc	r31, r1
    50d0:	40 83       	st	Z, r20
				 iPos++;
    50d2:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[i];
    50d4:	f5 01       	movw	r30, r10
    50d6:	e9 0f       	add	r30, r25
    50d8:	f1 1d       	adc	r31, r1
    50da:	8d 91       	ld	r24, X+
    50dc:	80 83       	st	Z, r24
			 iPos++;
    50de:	9f 5f       	subi	r25, 0xFF	; 255
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    50e0:	2f 5f       	subi	r18, 0xFF	; 255
    50e2:	23 17       	cp	r18, r19
    50e4:	58 f3       	brcs	.-42     	; 0x50bc <StrCalc+0x3e4>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[i];
			 iPos++;
		 }strC[iPos]=0;
    50e6:	f5 01       	movw	r30, r10
    50e8:	e9 0f       	add	r30, r25
    50ea:	f1 1d       	adc	r31, r1
    50ec:	10 82       	st	Z, r1
    50ee:	a0 c0       	rjmp	.+320    	; 0x5230 <StrCalc+0x558>
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
    50f0:	ed e3       	ldi	r30, 0x3D	; 61
    50f2:	ee 2e       	mov	r14, r30
    50f4:	f1 2c       	mov	r15, r1
    50f6:	ec 0e       	add	r14, r28
    50f8:	fd 1e       	adc	r15, r29
    50fa:	ae 01       	movw	r20, r28
    50fc:	49 0d       	add	r20, r9
    50fe:	51 1d       	adc	r21, r1
    5100:	4c 5e       	subi	r20, 0xEC	; 236
    5102:	5f 4f       	sbci	r21, 0xFF	; 255
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    5104:	07 2d       	mov	r16, r7
    5106:	10 e0       	ldi	r17, 0x00	; 0
    5108:	48 01       	movw	r8, r16
    510a:	08 94       	sec
    510c:	81 08       	sbc	r8, r1
    510e:	91 08       	sbc	r9, r1
    5110:	ce 01       	movw	r24, r28
    5112:	01 96       	adiw	r24, 0x01	; 1
    5114:	6c 01       	movw	r12, r24
    5116:	c8 0c       	add	r12, r8
    5118:	d9 1c       	adc	r13, r9
    511a:	30 e0       	ldi	r19, 0x00	; 0
    511c:	20 e0       	ldi	r18, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    511e:	2c 01       	movw	r4, r24
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    5120:	70 e3       	ldi	r23, 0x30	; 48
    5122:	37 2e       	mov	r3, r23
    5124:	47 c0       	rjmp	.+142    	; 0x51b4 <StrCalc+0x4dc>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5126:	d6 01       	movw	r26, r12
    5128:	9c 91       	ld	r25, X
    512a:	90 53       	subi	r25, 0x30	; 48
    512c:	9a 30       	cpi	r25, 0x0A	; 10
    512e:	08 f0       	brcs	.+2      	; 0x5132 <StrCalc+0x45a>
    5130:	90 e0       	ldi	r25, 0x00	; 0
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
		     newC=(Ord(tmpA[lenA-i-1])+Ord(tmpB[lenB-i-1]));			 
    5132:	fa 01       	movw	r30, r20
    5134:	80 81       	ld	r24, Z
    5136:	80 53       	subi	r24, 0x30	; 48
    5138:	8a 30       	cpi	r24, 0x0A	; 10
    513a:	08 f0       	brcs	.+2      	; 0x513e <StrCalc+0x466>
    513c:	80 e0       	ldi	r24, 0x00	; 0
    513e:	89 0f       	add	r24, r25
			 if (newC<10){
    5140:	8a 30       	cpi	r24, 0x0A	; 10
    5142:	18 f4       	brcc	.+6      	; 0x514a <StrCalc+0x472>
			     Result[i]=Chr(newC);
    5144:	80 5d       	subi	r24, 0xD0	; 208
    5146:	d7 01       	movw	r26, r14
    5148:	28 c0       	rjmp	.+80     	; 0x519a <StrCalc+0x4c2>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    514a:	6a e0       	ldi	r22, 0x0A	; 10
    514c:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5150:	9a 30       	cpi	r25, 0x0A	; 10
    5152:	10 f0       	brcs	.+4      	; 0x5158 <StrCalc+0x480>
    5154:	90 e3       	ldi	r25, 0x30	; 48
    5156:	01 c0       	rjmp	.+2      	; 0x515a <StrCalc+0x482>
	    Result='0'+X;
    5158:	90 5d       	subi	r25, 0xD0	; 208
			 if (newC<10){
			     Result[i]=Chr(newC);
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    515a:	f7 01       	movw	r30, r14
    515c:	90 83       	st	Z, r25
    515e:	83 2f       	mov	r24, r19
    5160:	0e c0       	rjmp	.+28     	; 0x517e <StrCalc+0x4a6>
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    5162:	d4 01       	movw	r26, r8
    5164:	a8 1b       	sub	r26, r24
    5166:	b1 09       	sbc	r27, r1
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5168:	f2 01       	movw	r30, r4
    516a:	ea 0f       	add	r30, r26
    516c:	fb 1f       	adc	r31, r27
    516e:	90 81       	ld	r25, Z
    5170:	90 53       	subi	r25, 0x30	; 48
    5172:	9a 30       	cpi	r25, 0x0A	; 10
    5174:	08 f0       	brcs	.+2      	; 0x5178 <StrCalc+0x4a0>
    5176:	79 c0       	rjmp	.+242    	; 0x526a <StrCalc+0x592>
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    5178:	99 30       	cpi	r25, 0x09	; 9
    517a:	29 f4       	brne	.+10     	; 0x5186 <StrCalc+0x4ae>
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    517c:	30 82       	st	Z, r3
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    517e:	8f 5f       	subi	r24, 0xFF	; 255
    5180:	87 15       	cp	r24, r7
    5182:	78 f3       	brcs	.-34     	; 0x5162 <StrCalc+0x48a>
    5184:	0d c0       	rjmp	.+26     	; 0x51a0 <StrCalc+0x4c8>
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    5186:	89 2f       	mov	r24, r25
    5188:	8f 5f       	subi	r24, 0xFF	; 255
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    518a:	8a 30       	cpi	r24, 0x0A	; 10
    518c:	10 f0       	brcs	.+4      	; 0x5192 <StrCalc+0x4ba>
    518e:	80 e3       	ldi	r24, 0x30	; 48
    5190:	02 c0       	rjmp	.+4      	; 0x5196 <StrCalc+0x4be>
	    Result='0'+X;
    5192:	89 2f       	mov	r24, r25
    5194:	8f 5c       	subi	r24, 0xCF	; 207
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    5196:	a4 0d       	add	r26, r4
    5198:	b5 1d       	adc	r27, r5
    519a:	8c 93       	st	X, r24
    519c:	20 e0       	ldi	r18, 0x00	; 0
    519e:	01 c0       	rjmp	.+2      	; 0x51a2 <StrCalc+0x4ca>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    51a0:	21 e0       	ldi	r18, 0x01	; 1
		 }strC[iPos]=0;
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
    51a2:	3f 5f       	subi	r19, 0xFF	; 255
    51a4:	08 94       	sec
    51a6:	e1 1c       	adc	r14, r1
    51a8:	f1 1c       	adc	r15, r1
    51aa:	41 50       	subi	r20, 0x01	; 1
    51ac:	50 40       	sbci	r21, 0x00	; 0
    51ae:	08 94       	sec
    51b0:	c1 08       	sbc	r12, r1
    51b2:	d1 08       	sbc	r13, r1
    51b4:	37 15       	cp	r19, r7
    51b6:	08 f4       	brcc	.+2      	; 0x51ba <StrCalc+0x4e2>
    51b8:	b6 cf       	rjmp	.-148    	; 0x5126 <StrCalc+0x44e>
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    51ba:	20 5d       	subi	r18, 0xD0	; 208
				 }//EndFor j                
			   }//End else
			 }//EndFor

		  //Result[lenA]==Chr(zMin); ???
		  Result[lenA]=Chr(zMin);
    51bc:	de 01       	movw	r26, r28
    51be:	dd 96       	adiw	r26, 0x3d	; 61
    51c0:	fd 01       	movw	r30, r26
    51c2:	e0 0f       	add	r30, r16
    51c4:	f1 1f       	adc	r31, r17
    51c6:	20 83       	st	Z, r18
		  Result[lenA+1]=0;
    51c8:	0c 0f       	add	r16, r28
    51ca:	1d 1f       	adc	r17, r29
    51cc:	f8 01       	movw	r30, r16
    51ce:	16 ae       	std	Z+62, r1	; 0x3e
		 FixLen=strlen(Result);
		 for(i=0;i<FixLen;i++){
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
    51d0:	fd 01       	movw	r30, r26
    51d2:	01 90       	ld	r0, Z+
    51d4:	00 20       	and	r0, r0
    51d6:	e9 f7       	brne	.-6      	; 0x51d2 <StrCalc+0x4fa>
    51d8:	31 97       	sbiw	r30, 0x01	; 1
    51da:	5e 2f       	mov	r21, r30
    51dc:	5a 1b       	sub	r21, r26
    51de:	25 2f       	mov	r18, r21
    51e0:	30 e0       	ldi	r19, 0x00	; 0
    51e2:	21 50       	subi	r18, 0x01	; 1
    51e4:	30 40       	sbci	r19, 0x00	; 0
    51e6:	2a 0f       	add	r18, r26
    51e8:	3b 1f       	adc	r19, r27
    51ea:	40 e0       	ldi	r20, 0x00	; 0
    51ec:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    51ee:	6d e2       	ldi	r22, 0x2D	; 45
    51f0:	16 c0       	rjmp	.+44     	; 0x521e <StrCalc+0x546>
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    51f2:	44 23       	and	r20, r20
    51f4:	51 f4       	brne	.+20     	; 0x520a <StrCalc+0x532>
    51f6:	63 96       	adiw	r28, 0x13	; 19
    51f8:	ff ad       	ldd	r31, Y+63	; 0x3f
    51fa:	63 97       	sbiw	r28, 0x13	; 19
    51fc:	f1 30       	cpi	r31, 0x01	; 1
    51fe:	29 f4       	brne	.+10     	; 0x520a <StrCalc+0x532>
			     strC[iPos]='-';
    5200:	f5 01       	movw	r30, r10
    5202:	e9 0f       	add	r30, r25
    5204:	f1 1d       	adc	r31, r1
    5206:	60 83       	st	Z, r22
				 iPos++;
    5208:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[FixLen-i-1];
    520a:	f5 01       	movw	r30, r10
    520c:	e9 0f       	add	r30, r25
    520e:	f1 1d       	adc	r31, r1
    5210:	d9 01       	movw	r26, r18
    5212:	8c 91       	ld	r24, X
    5214:	80 83       	st	Z, r24
			 iPos++;
    5216:	9f 5f       	subi	r25, 0xFF	; 255
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    5218:	4f 5f       	subi	r20, 0xFF	; 255
    521a:	21 50       	subi	r18, 0x01	; 1
    521c:	30 40       	sbci	r19, 0x00	; 0
    521e:	45 17       	cp	r20, r21
    5220:	40 f3       	brcs	.-48     	; 0x51f2 <StrCalc+0x51a>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[FixLen-i-1];
			 iPos++;
		 }strC[iPos]=0;
    5222:	f5 01       	movw	r30, r10
    5224:	e9 0f       	add	r30, r25
    5226:	f1 1d       	adc	r31, r1
    5228:	10 82       	st	Z, r1

       RemZeroLead(strC);
    522a:	c5 01       	movw	r24, r10
    522c:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
  //    sprintf_P(strSend,PSTR("C':%s"),strC);
//	 _uart_print(0,1,strSend);

	 }//EndIf 

	 if (TOperation==TMULTIPLY){
    5230:	b2 e0       	ldi	r27, 0x02	; 2
    5232:	6b 16       	cp	r6, r27
    5234:	e1 f4       	brne	.+56     	; 0x526e <StrCalc+0x596>
		 valA=atol(strA);
		 valB=atol(strB);
		 valC=valA*valB;		 
         ltoa(valC,strC,10);
		 */
		 CalcMultiply(strA,strB,strC);
    5236:	67 96       	adiw	r28, 0x17	; 23
    5238:	8e ad       	ldd	r24, Y+62	; 0x3e
    523a:	9f ad       	ldd	r25, Y+63	; 0x3f
    523c:	67 97       	sbiw	r28, 0x17	; 23
    523e:	69 96       	adiw	r28, 0x19	; 25
    5240:	6e ad       	ldd	r22, Y+62	; 0x3e
    5242:	7f ad       	ldd	r23, Y+63	; 0x3f
    5244:	69 97       	sbiw	r28, 0x19	; 25
    5246:	a5 01       	movw	r20, r10
    5248:	0e 94 50 29 	call	0x52a0	; 0x52a0 <CalcMultiply>
    524c:	10 c0       	rjmp	.+32     	; 0x526e <StrCalc+0x596>
	 }
}
    524e:	e1 e0       	ldi	r30, 0x01	; 1
    5250:	62 96       	adiw	r28, 0x12	; 18
    5252:	ef af       	std	Y+63, r30	; 0x3f
    5254:	62 97       	sbiw	r28, 0x12	; 18
    5256:	ac ce       	rjmp	.-680    	; 0x4fb0 <StrCalc+0x2d8>
    5258:	63 96       	adiw	r28, 0x13	; 19
    525a:	1f ae       	std	Y+63, r1	; 0x3f
    525c:	63 97       	sbiw	r28, 0x13	; 19
    525e:	48 cf       	rjmp	.-368    	; 0x50f0 <StrCalc+0x418>
    5260:	f1 e0       	ldi	r31, 0x01	; 1
    5262:	63 96       	adiw	r28, 0x13	; 19
    5264:	ff af       	std	Y+63, r31	; 0x3f
    5266:	63 97       	sbiw	r28, 0x13	; 19
    5268:	43 cf       	rjmp	.-378    	; 0x50f0 <StrCalc+0x418>
    526a:	90 e0       	ldi	r25, 0x00	; 0
    526c:	8c cf       	rjmp	.-232    	; 0x5186 <StrCalc+0x4ae>
    526e:	c8 5a       	subi	r28, 0xA8	; 168
    5270:	df 4f       	sbci	r29, 0xFF	; 255
    5272:	0f b6       	in	r0, 0x3f	; 63
    5274:	f8 94       	cli
    5276:	de bf       	out	0x3e, r29	; 62
    5278:	0f be       	out	0x3f, r0	; 63
    527a:	cd bf       	out	0x3d, r28	; 61
    527c:	cf 91       	pop	r28
    527e:	df 91       	pop	r29
    5280:	1f 91       	pop	r17
    5282:	0f 91       	pop	r16
    5284:	ff 90       	pop	r15
    5286:	ef 90       	pop	r14
    5288:	df 90       	pop	r13
    528a:	cf 90       	pop	r12
    528c:	bf 90       	pop	r11
    528e:	af 90       	pop	r10
    5290:	9f 90       	pop	r9
    5292:	8f 90       	pop	r8
    5294:	7f 90       	pop	r7
    5296:	6f 90       	pop	r6
    5298:	5f 90       	pop	r5
    529a:	4f 90       	pop	r4
    529c:	3f 90       	pop	r3
    529e:	08 95       	ret

000052a0 <CalcMultiply>:
	 }
	 strResult[lenR]=0;
}


void CalcMultiply(char *strA,char *strB,char *strC){
    52a0:	4f 92       	push	r4
    52a2:	5f 92       	push	r5
    52a4:	6f 92       	push	r6
    52a6:	7f 92       	push	r7
    52a8:	8f 92       	push	r8
    52aa:	9f 92       	push	r9
    52ac:	af 92       	push	r10
    52ae:	bf 92       	push	r11
    52b0:	cf 92       	push	r12
    52b2:	df 92       	push	r13
    52b4:	ef 92       	push	r14
    52b6:	ff 92       	push	r15
    52b8:	0f 93       	push	r16
    52ba:	1f 93       	push	r17
    52bc:	df 93       	push	r29
    52be:	cf 93       	push	r28
    52c0:	cd b7       	in	r28, 0x3d	; 61
    52c2:	de b7       	in	r29, 0x3e	; 62
    52c4:	a8 97       	sbiw	r28, 0x28	; 40
    52c6:	0f b6       	in	r0, 0x3f	; 63
    52c8:	f8 94       	cli
    52ca:	de bf       	out	0x3e, r29	; 62
    52cc:	0f be       	out	0x3f, r0	; 63
    52ce:	cd bf       	out	0x3d, r28	; 61
    52d0:	3c 01       	movw	r6, r24
    52d2:	6b 01       	movw	r12, r22
    52d4:	2a 01       	movw	r4, r20
	 
	 */
	 char i,lenB;
	 char prevSeg[20],currSeg[20];

     RemZeroLead(strA);
    52d6:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
     RemZeroLead(strB);
    52da:	c6 01       	movw	r24, r12
    52dc:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
	 lenB=strlen(strB);
    52e0:	d6 01       	movw	r26, r12
    52e2:	0d 90       	ld	r0, X+
    52e4:	00 20       	and	r0, r0
    52e6:	e9 f7       	brne	.-6      	; 0x52e2 <CalcMultiply+0x42>
    52e8:	11 97       	sbiw	r26, 0x01	; 1
    52ea:	8a 2e       	mov	r8, r26
    52ec:	8c 18       	sub	r8, r12
	 sprintf_P(prevSeg,PSTR("0"));
    52ee:	00 d0       	rcall	.+0      	; 0x52f0 <CalcMultiply+0x50>
    52f0:	00 d0       	rcall	.+0      	; 0x52f2 <CalcMultiply+0x52>
    52f2:	8e 01       	movw	r16, r28
    52f4:	0f 5f       	subi	r16, 0xFF	; 255
    52f6:	1f 4f       	sbci	r17, 0xFF	; 255
    52f8:	ad b7       	in	r26, 0x3d	; 61
    52fa:	be b7       	in	r27, 0x3e	; 62
    52fc:	12 96       	adiw	r26, 0x02	; 2
    52fe:	1c 93       	st	X, r17
    5300:	0e 93       	st	-X, r16
    5302:	11 97       	sbiw	r26, 0x01	; 1
    5304:	83 ea       	ldi	r24, 0xA3	; 163
    5306:	95 e0       	ldi	r25, 0x05	; 5
    5308:	14 96       	adiw	r26, 0x04	; 4
    530a:	9c 93       	st	X, r25
    530c:	8e 93       	st	-X, r24
    530e:	13 97       	sbiw	r26, 0x03	; 3
    5310:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	 sprintf_P(currSeg,PSTR("0"));
    5314:	b5 e1       	ldi	r27, 0x15	; 21
    5316:	eb 2e       	mov	r14, r27
    5318:	f1 2c       	mov	r15, r1
    531a:	ec 0e       	add	r14, r28
    531c:	fd 1e       	adc	r15, r29
    531e:	ed b7       	in	r30, 0x3d	; 61
    5320:	fe b7       	in	r31, 0x3e	; 62
    5322:	f2 82       	std	Z+2, r15	; 0x02
    5324:	e1 82       	std	Z+1, r14	; 0x01
    5326:	81 ea       	ldi	r24, 0xA1	; 161
    5328:	95 e0       	ldi	r25, 0x05	; 5
    532a:	94 83       	std	Z+4, r25	; 0x04
    532c:	83 83       	std	Z+3, r24	; 0x03
    532e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    5332:	bb 24       	eor	r11, r11
    5334:	0f 90       	pop	r0
    5336:	0f 90       	pop	r0
    5338:	0f 90       	pop	r0
    533a:	0f 90       	pop	r0
    533c:	a0 2e       	mov	r10, r16
    533e:	91 2e       	mov	r9, r17

	 for(i=0;i<strlen(strB);i++){
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
    5340:	08 2d       	mov	r16, r8
    5342:	10 e0       	ldi	r17, 0x00	; 0
    5344:	01 50       	subi	r16, 0x01	; 1
    5346:	10 40       	sbci	r17, 0x00	; 0
    5348:	1f c0       	rjmp	.+62     	; 0x5388 <CalcMultiply+0xe8>
    534a:	f8 01       	movw	r30, r16
    534c:	e8 1b       	sub	r30, r24
    534e:	f9 0b       	sbc	r31, r25
    5350:	ec 0d       	add	r30, r12
    5352:	fd 1d       	adc	r31, r13
    5354:	c3 01       	movw	r24, r6
    5356:	60 81       	ld	r22, Z
    5358:	a7 01       	movw	r20, r14
    535a:	0e 94 43 21 	call	0x4286	; 0x4286 <CalcSegmen>
         AddZeroLag(currSeg,strlen(currSeg)+i);
    535e:	f7 01       	movw	r30, r14
    5360:	01 90       	ld	r0, Z+
    5362:	00 20       	and	r0, r0
    5364:	e9 f7       	brne	.-6      	; 0x5360 <CalcMultiply+0xc0>
    5366:	31 97       	sbiw	r30, 0x01	; 1
    5368:	ee 19       	sub	r30, r14
    536a:	ff 09       	sbc	r31, r15
    536c:	6b 2d       	mov	r22, r11
    536e:	6e 0f       	add	r22, r30
    5370:	c7 01       	movw	r24, r14
    5372:	0e 94 51 26 	call	0x4ca2	; 0x4ca2 <AddZeroLag>
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
    5376:	81 e0       	ldi	r24, 0x01	; 1
    5378:	6a 2d       	mov	r22, r10
    537a:	79 2d       	mov	r23, r9
    537c:	a7 01       	movw	r20, r14
    537e:	2a 2d       	mov	r18, r10
    5380:	39 2d       	mov	r19, r9
    5382:	0e 94 6c 26 	call	0x4cd8	; 0x4cd8 <StrCalc>
     RemZeroLead(strB);
	 lenB=strlen(strB);
	 sprintf_P(prevSeg,PSTR("0"));
	 sprintf_P(currSeg,PSTR("0"));

	 for(i=0;i<strlen(strB);i++){
    5386:	b3 94       	inc	r11
    5388:	f6 01       	movw	r30, r12
    538a:	01 90       	ld	r0, Z+
    538c:	00 20       	and	r0, r0
    538e:	e9 f7       	brne	.-6      	; 0x538a <CalcMultiply+0xea>
    5390:	31 97       	sbiw	r30, 0x01	; 1
    5392:	ec 19       	sub	r30, r12
    5394:	fd 09       	sbc	r31, r13
    5396:	8b 2d       	mov	r24, r11
    5398:	90 e0       	ldi	r25, 0x00	; 0
    539a:	8e 17       	cp	r24, r30
    539c:	9f 07       	cpc	r25, r31
    539e:	a8 f2       	brcs	.-86     	; 0x534a <CalcMultiply+0xaa>
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
         AddZeroLag(currSeg,strlen(currSeg)+i);
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
    53a0:	00 d0       	rcall	.+0      	; 0x53a2 <CalcMultiply+0x102>
    53a2:	00 d0       	rcall	.+0      	; 0x53a4 <CalcMultiply+0x104>
    53a4:	00 d0       	rcall	.+0      	; 0x53a6 <CalcMultiply+0x106>
    53a6:	ed b7       	in	r30, 0x3d	; 61
    53a8:	fe b7       	in	r31, 0x3e	; 62
    53aa:	31 96       	adiw	r30, 0x01	; 1
    53ac:	ad b7       	in	r26, 0x3d	; 61
    53ae:	be b7       	in	r27, 0x3e	; 62
    53b0:	12 96       	adiw	r26, 0x02	; 2
    53b2:	5c 92       	st	X, r5
    53b4:	4e 92       	st	-X, r4
    53b6:	11 97       	sbiw	r26, 0x01	; 1
    53b8:	8e e9       	ldi	r24, 0x9E	; 158
    53ba:	95 e0       	ldi	r25, 0x05	; 5
    53bc:	93 83       	std	Z+3, r25	; 0x03
    53be:	82 83       	std	Z+2, r24	; 0x02
    53c0:	a4 82       	std	Z+4, r10	; 0x04
    53c2:	95 82       	std	Z+5, r9	; 0x05
    53c4:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    53c8:	ed b7       	in	r30, 0x3d	; 61
    53ca:	fe b7       	in	r31, 0x3e	; 62
    53cc:	36 96       	adiw	r30, 0x06	; 6
    53ce:	0f b6       	in	r0, 0x3f	; 63
    53d0:	f8 94       	cli
    53d2:	fe bf       	out	0x3e, r31	; 62
    53d4:	0f be       	out	0x3f, r0	; 63
    53d6:	ed bf       	out	0x3d, r30	; 61
}
    53d8:	a8 96       	adiw	r28, 0x28	; 40
    53da:	0f b6       	in	r0, 0x3f	; 63
    53dc:	f8 94       	cli
    53de:	de bf       	out	0x3e, r29	; 62
    53e0:	0f be       	out	0x3f, r0	; 63
    53e2:	cd bf       	out	0x3d, r28	; 61
    53e4:	cf 91       	pop	r28
    53e6:	df 91       	pop	r29
    53e8:	1f 91       	pop	r17
    53ea:	0f 91       	pop	r16
    53ec:	ff 90       	pop	r15
    53ee:	ef 90       	pop	r14
    53f0:	df 90       	pop	r13
    53f2:	cf 90       	pop	r12
    53f4:	bf 90       	pop	r11
    53f6:	af 90       	pop	r10
    53f8:	9f 90       	pop	r9
    53fa:	8f 90       	pop	r8
    53fc:	7f 90       	pop	r7
    53fe:	6f 90       	pop	r6
    5400:	5f 90       	pop	r5
    5402:	4f 90       	pop	r4
    5404:	08 95       	ret

00005406 <NormalizeOverflow>:
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}

void NormalizeOverflow(char *strOverflowed){
    5406:	cf 92       	push	r12
    5408:	df 92       	push	r13
    540a:	ef 92       	push	r14
    540c:	ff 92       	push	r15
    540e:	0f 93       	push	r16
    5410:	1f 93       	push	r17
    5412:	df 93       	push	r29
    5414:	cf 93       	push	r28
    5416:	cd b7       	in	r28, 0x3d	; 61
    5418:	de b7       	in	r29, 0x3e	; 62
    541a:	64 97       	sbiw	r28, 0x14	; 20
    541c:	0f b6       	in	r0, 0x3f	; 63
    541e:	f8 94       	cli
    5420:	de bf       	out	0x3e, r29	; 62
    5422:	0f be       	out	0x3f, r0	; 63
    5424:	cd bf       	out	0x3d, r28	; 61
    5426:	d8 2e       	mov	r13, r24
    5428:	c9 2e       	mov	r12, r25
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
    542a:	a8 2f       	mov	r26, r24
    542c:	b9 2f       	mov	r27, r25
    542e:	fd 01       	movw	r30, r26
    5430:	01 90       	ld	r0, Z+
    5432:	00 20       	and	r0, r0
    5434:	e9 f7       	brne	.-6      	; 0x5430 <NormalizeOverflow+0x2a>
    5436:	31 97       	sbiw	r30, 0x01	; 1
    5438:	4e 2f       	mov	r20, r30
    543a:	48 1b       	sub	r20, r24
    543c:	20 e0       	ldi	r18, 0x00	; 0
    543e:	30 e0       	ldi	r19, 0x00	; 0
    5440:	7e 01       	movw	r14, r28
    5442:	08 94       	sec
    5444:	e1 1c       	adc	r14, r1
    5446:	f1 1c       	adc	r15, r1
    5448:	04 2f       	mov	r16, r20
    544a:	10 e0       	ldi	r17, 0x00	; 0
    544c:	0e c0       	rjmp	.+28     	; 0x546a <NormalizeOverflow+0x64>
     for(i=0;i<Length;i++){//123456
	     strMaxValue[i]='0'+((Length-i)/Length);
    544e:	f7 01       	movw	r30, r14
    5450:	e2 0f       	add	r30, r18
    5452:	f3 1f       	adc	r31, r19
    5454:	c8 01       	movw	r24, r16
    5456:	82 1b       	sub	r24, r18
    5458:	93 0b       	sbc	r25, r19
    545a:	64 2f       	mov	r22, r20
    545c:	70 e0       	ldi	r23, 0x00	; 0
    545e:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    5462:	60 5d       	subi	r22, 0xD0	; 208
    5464:	60 83       	st	Z, r22
    5466:	2f 5f       	subi	r18, 0xFF	; 255
    5468:	3f 4f       	sbci	r19, 0xFF	; 255

void NormalizeOverflow(char *strOverflowed){
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
     for(i=0;i<Length;i++){//123456
    546a:	24 17       	cp	r18, r20
    546c:	80 f3       	brcs	.-32     	; 0x544e <NormalizeOverflow+0x48>
	     strMaxValue[i]='0'+((Length-i)/Length);
	 }strMaxValue[Length]=0;
    546e:	0e 0d       	add	r16, r14
    5470:	1f 1d       	adc	r17, r15
    5472:	f8 01       	movw	r30, r16
    5474:	10 82       	st	Z, r1
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
    5476:	81 e0       	ldi	r24, 0x01	; 1
    5478:	b7 01       	movw	r22, r14
    547a:	4d 2d       	mov	r20, r13
    547c:	5c 2d       	mov	r21, r12
    547e:	2d 2d       	mov	r18, r13
    5480:	3c 2d       	mov	r19, r12
    5482:	0e 94 6c 26 	call	0x4cd8	; 0x4cd8 <StrCalc>
}
    5486:	64 96       	adiw	r28, 0x14	; 20
    5488:	0f b6       	in	r0, 0x3f	; 63
    548a:	f8 94       	cli
    548c:	de bf       	out	0x3e, r29	; 62
    548e:	0f be       	out	0x3f, r0	; 63
    5490:	cd bf       	out	0x3d, r28	; 61
    5492:	cf 91       	pop	r28
    5494:	df 91       	pop	r29
    5496:	1f 91       	pop	r17
    5498:	0f 91       	pop	r16
    549a:	ff 90       	pop	r15
    549c:	ef 90       	pop	r14
    549e:	df 90       	pop	r13
    54a0:	cf 90       	pop	r12
    54a2:	08 95       	ret

000054a4 <AddSpaceLead>:
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    54a4:	bf 92       	push	r11
    54a6:	cf 92       	push	r12
    54a8:	df 92       	push	r13
    54aa:	ef 92       	push	r14
    54ac:	ff 92       	push	r15
    54ae:	0f 93       	push	r16
    54b0:	1f 93       	push	r17
    54b2:	df 93       	push	r29
    54b4:	cf 93       	push	r28
    54b6:	cd b7       	in	r28, 0x3d	; 61
    54b8:	de b7       	in	r29, 0x3e	; 62
    54ba:	e2 97       	sbiw	r28, 0x32	; 50
    54bc:	0f b6       	in	r0, 0x3f	; 63
    54be:	f8 94       	cli
    54c0:	de bf       	out	0x3e, r29	; 62
    54c2:	0f be       	out	0x3f, r0	; 63
    54c4:	cd bf       	out	0x3d, r28	; 61
    54c6:	8c 01       	movw	r16, r24
     char i,Length,strAdded[50];
     Length=strlen(String);
    54c8:	fc 01       	movw	r30, r24
    54ca:	01 90       	ld	r0, Z+
    54cc:	00 20       	and	r0, r0
    54ce:	e9 f7       	brne	.-6      	; 0x54ca <AddSpaceLead+0x26>
    54d0:	31 97       	sbiw	r30, 0x01	; 1
    54d2:	2e 2f       	mov	r18, r30
    54d4:	28 1b       	sub	r18, r24

	 if (Size>Length){
    54d6:	26 17       	cp	r18, r22
    54d8:	e0 f5       	brcc	.+120    	; 0x5552 <AddSpaceLead+0xae>
    54da:	7e 01       	movw	r14, r28
    54dc:	08 94       	sec
    54de:	e1 1c       	adc	r14, r1
    54e0:	f1 1c       	adc	r15, r1
    54e2:	f7 01       	movw	r30, r14
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    54e4:	be 2c       	mov	r11, r14
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
    54e6:	90 e2       	ldi	r25, 0x20	; 32
    54e8:	01 c0       	rjmp	.+2      	; 0x54ec <AddSpaceLead+0x48>
    54ea:	91 93       	st	Z+, r25
void AddSpaceLead(char *String,unsigned char Size){//
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    54ec:	8e 2f       	mov	r24, r30
    54ee:	8b 19       	sub	r24, r11
    54f0:	86 17       	cp	r24, r22
    54f2:	d8 f3       	brcs	.-10     	; 0x54ea <AddSpaceLead+0x46>
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
    54f4:	46 2f       	mov	r20, r22
    54f6:	50 e0       	ldi	r21, 0x00	; 0
    54f8:	ce 01       	movw	r24, r28
    54fa:	01 96       	adiw	r24, 0x01	; 1
    54fc:	fc 01       	movw	r30, r24
    54fe:	e4 0f       	add	r30, r20
    5500:	f5 1f       	adc	r31, r21
    5502:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5504:	76 2f       	mov	r23, r22
    5506:	72 1b       	sub	r23, r18
    5508:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    550a:	30 e0       	ldi	r19, 0x00	; 0
    550c:	24 1b       	sub	r18, r20
    550e:	35 0b       	sbc	r19, r21
    5510:	0c c0       	rjmp	.+24     	; 0x552a <AddSpaceLead+0x86>
    5512:	e7 2f       	mov	r30, r23
    5514:	f0 e0       	ldi	r31, 0x00	; 0
    5516:	d6 01       	movw	r26, r12
    5518:	ae 0f       	add	r26, r30
    551a:	bf 1f       	adc	r27, r31
    551c:	e0 0f       	add	r30, r16
    551e:	f1 1f       	adc	r31, r17
    5520:	e2 0f       	add	r30, r18
    5522:	f3 1f       	adc	r31, r19
    5524:	80 81       	ld	r24, Z
    5526:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5528:	7f 5f       	subi	r23, 0xFF	; 255
    552a:	76 17       	cp	r23, r22
    552c:	90 f3       	brcs	.-28     	; 0x5512 <AddSpaceLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    552e:	4c 0d       	add	r20, r12
    5530:	5d 1d       	adc	r21, r13
    5532:	da 01       	movw	r26, r20
    5534:	1c 92       	st	X, r1
    5536:	f8 01       	movw	r30, r16
    5538:	04 c0       	rjmp	.+8      	; 0x5542 <AddSpaceLead+0x9e>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    553a:	d7 01       	movw	r26, r14
    553c:	8d 91       	ld	r24, X+
    553e:	7d 01       	movw	r14, r26
    5540:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    5542:	8e 2d       	mov	r24, r14
    5544:	8b 19       	sub	r24, r11
    5546:	86 17       	cp	r24, r22
    5548:	c0 f3       	brcs	.-16     	; 0x553a <AddSpaceLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    554a:	06 0f       	add	r16, r22
    554c:	11 1d       	adc	r17, r1
    554e:	f8 01       	movw	r30, r16
    5550:	10 82       	st	Z, r1
	 }
}
    5552:	e2 96       	adiw	r28, 0x32	; 50
    5554:	0f b6       	in	r0, 0x3f	; 63
    5556:	f8 94       	cli
    5558:	de bf       	out	0x3e, r29	; 62
    555a:	0f be       	out	0x3f, r0	; 63
    555c:	cd bf       	out	0x3d, r28	; 61
    555e:	cf 91       	pop	r28
    5560:	df 91       	pop	r29
    5562:	1f 91       	pop	r17
    5564:	0f 91       	pop	r16
    5566:	ff 90       	pop	r15
    5568:	ef 90       	pop	r14
    556a:	df 90       	pop	r13
    556c:	cf 90       	pop	r12
    556e:	bf 90       	pop	r11
    5570:	08 95       	ret

00005572 <AddSpaceLag>:
	 }
}



void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
    5572:	cf 93       	push	r28
    5574:	df 93       	push	r29
    5576:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    5578:	dc 01       	movw	r26, r24
    557a:	0d 90       	ld	r0, X+
    557c:	00 20       	and	r0, r0
    557e:	e9 f7       	brne	.-6      	; 0x557a <AddSpaceLag+0x8>
    5580:	11 97       	sbiw	r26, 0x01	; 1
    5582:	a8 1b       	sub	r26, r24
    5584:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    5586:	a6 17       	cp	r26, r22
    5588:	60 f4       	brcc	.+24     	; 0x55a2 <AddSpaceLag+0x30>
    558a:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=' ';
    558c:	90 e2       	ldi	r25, 0x20	; 32
    558e:	fe 01       	movw	r30, r28
    5590:	e8 0f       	add	r30, r24
    5592:	f1 1d       	adc	r31, r1
    5594:	90 83       	st	Z, r25

void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    5596:	8f 5f       	subi	r24, 0xFF	; 255
    5598:	86 17       	cp	r24, r22
    559a:	c8 f3       	brcs	.-14     	; 0x558e <AddSpaceLag+0x1c>
	    String[i]=' ';
	 }String[Size]=0;
    559c:	c6 0f       	add	r28, r22
    559e:	d1 1d       	adc	r29, r1
    55a0:	18 82       	st	Y, r1
  }
}
    55a2:	df 91       	pop	r29
    55a4:	cf 91       	pop	r28
    55a6:	08 95       	ret

000055a8 <GetProductName>:
	 }    
	 //Clear Decimal

}

void GetProductName(char GradeId,char *strProductName){
    55a8:	0f 93       	push	r16
    55aa:	1f 93       	push	r17
    55ac:	df 93       	push	r29
    55ae:	cf 93       	push	r28
    55b0:	cd b7       	in	r28, 0x3d	; 61
    55b2:	de b7       	in	r29, 0x3e	; 62
    55b4:	2c 97       	sbiw	r28, 0x0c	; 12
    55b6:	0f b6       	in	r0, 0x3f	; 63
    55b8:	f8 94       	cli
    55ba:	de bf       	out	0x3e, r29	; 62
    55bc:	0f be       	out	0x3f, r0	; 63
    55be:	cd bf       	out	0x3d, r28	; 61
    55c0:	48 2f       	mov	r20, r24
    55c2:	8b 01       	movw	r16, r22
    55c4:	fe 01       	movw	r30, r28
    55c6:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    55c8:	9e 01       	movw	r18, r28
    55ca:	23 5f       	subi	r18, 0xF3	; 243
    55cc:	3f 4f       	sbci	r19, 0xFF	; 255
	     strMemory[i]=data;
    55ce:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    55d0:	e2 17       	cp	r30, r18
    55d2:	f3 07       	cpc	r31, r19
    55d4:	e1 f7       	brne	.-8      	; 0x55ce <GetProductName+0x26>
    55d6:	ce 01       	movw	r24, r28
    55d8:	01 96       	adiw	r24, 0x01	; 1

void GetProductName(char GradeId,char *strProductName){
char SProductName[12],i,Length;
     FillChar(SProductName,sizeof(SProductName),0); 
	 //eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
	 if (GradeId>0) eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
    55da:	44 23       	and	r20, r20
    55dc:	69 f0       	breq	.+26     	; 0x55f8 <GetProductName+0x50>
    55de:	6d e0       	ldi	r22, 0x0D	; 13
    55e0:	46 9f       	mul	r20, r22
    55e2:	b0 01       	movw	r22, r0
    55e4:	11 24       	eor	r1, r1
    55e6:	62 55       	subi	r22, 0x52	; 82
    55e8:	7f 4f       	sbci	r23, 0xFF	; 255
    55ea:	4a e0       	ldi	r20, 0x0A	; 10
    55ec:	50 e0       	ldi	r21, 0x00	; 0
    55ee:	25 ed       	ldi	r18, 0xD5	; 213
    55f0:	32 e1       	ldi	r19, 0x12	; 18
    55f2:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
    55f6:	14 c0       	rjmp	.+40     	; 0x5620 <GetProductName+0x78>
	 else sprintf_P(SProductName,PSTR("N/A"));
    55f8:	00 d0       	rcall	.+0      	; 0x55fa <GetProductName+0x52>
    55fa:	00 d0       	rcall	.+0      	; 0x55fc <GetProductName+0x54>
    55fc:	ad b7       	in	r26, 0x3d	; 61
    55fe:	be b7       	in	r27, 0x3e	; 62
    5600:	12 96       	adiw	r26, 0x02	; 2
    5602:	9c 93       	st	X, r25
    5604:	8e 93       	st	-X, r24
    5606:	11 97       	sbiw	r26, 0x01	; 1
    5608:	85 ef       	ldi	r24, 0xF5	; 245
    560a:	93 e0       	ldi	r25, 0x03	; 3
    560c:	14 96       	adiw	r26, 0x04	; 4
    560e:	9c 93       	st	X, r25
    5610:	8e 93       	st	-X, r24
    5612:	13 97       	sbiw	r26, 0x03	; 3
    5614:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    5618:	0f 90       	pop	r0
    561a:	0f 90       	pop	r0
    561c:	0f 90       	pop	r0
    561e:	0f 90       	pop	r0

     Length=strlen(SProductName);
    5620:	de 01       	movw	r26, r28
    5622:	11 96       	adiw	r26, 0x01	; 1
    5624:	fd 01       	movw	r30, r26
    5626:	01 90       	ld	r0, Z+
    5628:	00 20       	and	r0, r0
    562a:	e9 f7       	brne	.-6      	; 0x5626 <GetProductName+0x7e>
    562c:	31 97       	sbiw	r30, 0x01	; 1
    562e:	ea 1b       	sub	r30, r26
    5630:	eb 30       	cpi	r30, 0x0B	; 11
    5632:	08 f0       	brcs	.+2      	; 0x5636 <GetProductName+0x8e>
    5634:	ea e0       	ldi	r30, 0x0A	; 10
    5636:	ae 01       	movw	r20, r28
    5638:	4f 5f       	subi	r20, 0xFF	; 255
    563a:	5f 4f       	sbci	r21, 0xFF	; 255
    563c:	98 01       	movw	r18, r16
    563e:	ba 01       	movw	r22, r20
    5640:	06 c0       	rjmp	.+12     	; 0x564e <GetProductName+0xa6>
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
	     strProductName[i]=SProductName[i];
    5642:	db 01       	movw	r26, r22
    5644:	8d 91       	ld	r24, X+
    5646:	bd 01       	movw	r22, r26
    5648:	d9 01       	movw	r26, r18
    564a:	8d 93       	st	X+, r24
    564c:	9d 01       	movw	r18, r26
	 else sprintf_P(SProductName,PSTR("N/A"));

     Length=strlen(SProductName);
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
    564e:	86 2f       	mov	r24, r22
    5650:	84 1b       	sub	r24, r20
    5652:	8e 17       	cp	r24, r30
    5654:	b0 f3       	brcs	.-20     	; 0x5642 <GetProductName+0x9a>
	     strProductName[i]=SProductName[i];
	 }strProductName[Length]=0;
    5656:	c8 01       	movw	r24, r16
    5658:	8e 0f       	add	r24, r30
    565a:	91 1d       	adc	r25, r1
    565c:	fc 01       	movw	r30, r24
    565e:	10 82       	st	Z, r1

	 AddSpaceLag(strProductName,10);
    5660:	c8 01       	movw	r24, r16
    5662:	6a e0       	ldi	r22, 0x0A	; 10
    5664:	0e 94 b9 2a 	call	0x5572	; 0x5572 <AddSpaceLag>
}
    5668:	2c 96       	adiw	r28, 0x0c	; 12
    566a:	0f b6       	in	r0, 0x3f	; 63
    566c:	f8 94       	cli
    566e:	de bf       	out	0x3e, r29	; 62
    5670:	0f be       	out	0x3f, r0	; 63
    5672:	cd bf       	out	0x3d, r28	; 61
    5674:	cf 91       	pop	r28
    5676:	df 91       	pop	r29
    5678:	1f 91       	pop	r17
    567a:	0f 91       	pop	r16
    567c:	08 95       	ret

0000567e <GeniusSendLastTransaction>:
}
void GeniusSendPumpPreset(char iPumpID){
}


void GeniusSendLastTransaction(char iPumpID){
    567e:	2f 92       	push	r2
    5680:	3f 92       	push	r3
    5682:	4f 92       	push	r4
    5684:	5f 92       	push	r5
    5686:	6f 92       	push	r6
    5688:	7f 92       	push	r7
    568a:	8f 92       	push	r8
    568c:	9f 92       	push	r9
    568e:	af 92       	push	r10
    5690:	bf 92       	push	r11
    5692:	cf 92       	push	r12
    5694:	df 92       	push	r13
    5696:	ef 92       	push	r14
    5698:	ff 92       	push	r15
    569a:	0f 93       	push	r16
    569c:	1f 93       	push	r17
    569e:	df 93       	push	r29
    56a0:	cf 93       	push	r28
    56a2:	cd b7       	in	r28, 0x3d	; 61
    56a4:	de b7       	in	r29, 0x3e	; 62
    56a6:	c0 5b       	subi	r28, 0xB0	; 176
    56a8:	d0 40       	sbci	r29, 0x00	; 0
    56aa:	0f b6       	in	r0, 0x3f	; 63
    56ac:	f8 94       	cli
    56ae:	de bf       	out	0x3e, r29	; 62
    56b0:	0f be       	out	0x3f, r0	; 63
    56b2:	cd bf       	out	0x3d, r28	; 61
    56b4:	e8 2e       	mov	r14, r24
    56b6:	fe 01       	movw	r30, r28
    56b8:	37 96       	adiw	r30, 0x07	; 7

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    56ba:	ce 01       	movw	r24, r28
    56bc:	46 96       	adiw	r24, 0x16	; 22
	     strMemory[i]=data;
    56be:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    56c0:	e8 17       	cp	r30, r24
    56c2:	f9 07       	cpc	r31, r25
    56c4:	e1 f7       	brne	.-8      	; 0x56be <GeniusSendLastTransaction+0x40>
	     strMemory[i]=data;
    56c6:	ce 01       	movw	r24, r28
    56c8:	85 96       	adiw	r24, 0x25	; 37
    56ca:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    56cc:	e8 17       	cp	r30, r24
    56ce:	f9 07       	cpc	r31, r25
    56d0:	e1 f7       	brne	.-8      	; 0x56ca <GeniusSendLastTransaction+0x4c>
	     strMemory[i]=data;
    56d2:	ce 01       	movw	r24, r28
    56d4:	c4 96       	adiw	r24, 0x34	; 52
    56d6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    56d8:	e8 17       	cp	r30, r24
    56da:	f9 07       	cpc	r31, r25
    56dc:	e1 f7       	brne	.-8      	; 0x56d6 <GeniusSendLastTransaction+0x58>
	     strMemory[i]=data;
    56de:	cf 01       	movw	r24, r30
    56e0:	3f 01       	movw	r6, r30
    56e2:	0f 96       	adiw	r24, 0x0f	; 15
    56e4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    56e6:	e8 17       	cp	r30, r24
    56e8:	f9 07       	cpc	r31, r25
    56ea:	e1 f7       	brne	.-8      	; 0x56e4 <GeniusSendLastTransaction+0x66>
	 FillChar(STotalVolume,sizeof(STotalVolume),0);
	 FillChar(STotalMoney,sizeof(STotalMoney),0);
	      

	 //Generate
	 FIPAddr=GetFIPAddr(iPumpID);
    56ec:	8e 2d       	mov	r24, r14
    56ee:	0e 94 1a 1c 	call	0x3834	; 0x3834 <GetFIPAddr>
    56f2:	96 e0       	ldi	r25, 0x06	; 6
    56f4:	89 9f       	mul	r24, r25
    56f6:	b0 01       	movw	r22, r0
    56f8:	11 24       	eor	r1, r1
    56fa:	61 5b       	subi	r22, 0xB1	; 177
    56fc:	7f 4f       	sbci	r23, 0xFF	; 255
    56fe:	8e 01       	movw	r16, r28
    5700:	0f 5f       	subi	r16, 0xFF	; 255
    5702:	1f 4f       	sbci	r17, 0xFF	; 255
    5704:	c8 01       	movw	r24, r16
    5706:	46 e0       	ldi	r20, 0x06	; 6
    5708:	50 e0       	ldi	r21, 0x00	; 0
    570a:	25 ed       	ldi	r18, 0xD5	; 213
    570c:	32 e1       	ldi	r19, 0x12	; 18
    570e:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);
	 iNozzle=RecPumpData[iPumpID&0x0F].Grade;
    5712:	2e 2c       	mov	r2, r14
    5714:	33 24       	eor	r3, r3
    5716:	91 01       	movw	r18, r2
    5718:	2f 70       	andi	r18, 0x0F	; 15
    571a:	30 70       	andi	r19, 0x00	; 0
    571c:	85 e3       	ldi	r24, 0x35	; 53
    571e:	90 e0       	ldi	r25, 0x00	; 0
    5720:	28 9f       	mul	r18, r24
    5722:	f0 01       	movw	r30, r0
    5724:	29 9f       	mul	r18, r25
    5726:	f0 0d       	add	r31, r0
    5728:	38 9f       	mul	r19, r24
    572a:	f0 0d       	add	r31, r0
    572c:	11 24       	eor	r1, r1
    572e:	e5 52       	subi	r30, 0x25	; 37
    5730:	f8 4f       	sbci	r31, 0xF8	; 248
    5732:	f0 80       	ld	r15, Z
	 iProdID=PProductID[iNozzle];
    5734:	4f 2c       	mov	r4, r15
    5736:	55 24       	eor	r5, r5

	 GetProductName(iProdID,strProduct);
    5738:	04 0d       	add	r16, r4
    573a:	15 1d       	adc	r17, r5
    573c:	d8 01       	movw	r26, r16
    573e:	8c 91       	ld	r24, X
    5740:	61 e9       	ldi	r22, 0x91	; 145
    5742:	79 e0       	ldi	r23, 0x09	; 9
    5744:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <GetProductName>
	 GetTransactionVolume(iPumpID,SVolume);
    5748:	97 e0       	ldi	r25, 0x07	; 7
    574a:	89 2e       	mov	r8, r25
    574c:	91 2c       	mov	r9, r1
    574e:	8c 0e       	add	r8, r28
    5750:	9d 1e       	adc	r9, r29
    5752:	8e 2d       	mov	r24, r14
    5754:	b4 01       	movw	r22, r8
    5756:	0e 94 17 26 	call	0x4c2e	; 0x4c2e <GetTransactionVolume>
	 GetTransactionMoney(iPumpID,SMoney);
    575a:	86 e1       	ldi	r24, 0x16	; 22
    575c:	a8 2e       	mov	r10, r24
    575e:	b1 2c       	mov	r11, r1
    5760:	ac 0e       	add	r10, r28
    5762:	bd 1e       	adc	r11, r29
    5764:	8e 2d       	mov	r24, r14
    5766:	b5 01       	movw	r22, r10
    5768:	0e 94 dd 25 	call	0x4bba	; 0x4bba <GetTransactionMoney>
	 GetTotalizerVolume(iPumpID,iNozzle,STotalVolume);
    576c:	05 e2       	ldi	r16, 0x25	; 37
    576e:	c0 2e       	mov	r12, r16
    5770:	d1 2c       	mov	r13, r1
    5772:	cc 0e       	add	r12, r28
    5774:	dd 1e       	adc	r13, r29
    5776:	8e 2d       	mov	r24, r14
    5778:	6f 2d       	mov	r22, r15
    577a:	a6 01       	movw	r20, r12
    577c:	0e 94 c0 25 	call	0x4b80	; 0x4b80 <GetTotalizerVolume>
	 GetTotalizerMoney(iPumpID,iNozzle,STotalMoney);
    5780:	8e 2d       	mov	r24, r14
    5782:	6f 2d       	mov	r22, r15
    5784:	a3 01       	movw	r20, r6
    5786:	0e 94 a3 25 	call	0x4b46	; 0x4b46 <GetTotalizerMoney>
	 
     ComposeDatetime(SDatetime);
    578a:	13 e4       	ldi	r17, 0x43	; 67
    578c:	e1 2e       	mov	r14, r17
    578e:	f1 2c       	mov	r15, r1
    5790:	ec 0e       	add	r14, r28
    5792:	fd 1e       	adc	r15, r29
    5794:	c7 01       	movw	r24, r14
    5796:	0e 94 32 1b 	call	0x3664	; 0x3664 <ComposeDatetime>

	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
    579a:	ed b7       	in	r30, 0x3d	; 61
    579c:	fe b7       	in	r31, 0x3e	; 62
    579e:	74 97       	sbiw	r30, 0x14	; 20
    57a0:	0f b6       	in	r0, 0x3f	; 63
    57a2:	f8 94       	cli
    57a4:	fe bf       	out	0x3e, r31	; 62
    57a6:	0f be       	out	0x3f, r0	; 63
    57a8:	ed bf       	out	0x3d, r30	; 61
    57aa:	31 96       	adiw	r30, 0x01	; 1
    57ac:	8e 01       	movw	r16, r28
    57ae:	09 5a       	subi	r16, 0xA9	; 169
    57b0:	1f 4f       	sbci	r17, 0xFF	; 255
    57b2:	ad b7       	in	r26, 0x3d	; 61
    57b4:	be b7       	in	r27, 0x3e	; 62
    57b6:	12 96       	adiw	r26, 0x02	; 2
    57b8:	1c 93       	st	X, r17
    57ba:	0e 93       	st	-X, r16
    57bc:	11 97       	sbiw	r26, 0x01	; 1
    57be:	88 e3       	ldi	r24, 0x38	; 56
    57c0:	93 e0       	ldi	r25, 0x03	; 3
    57c2:	93 83       	std	Z+3, r25	; 0x03
    57c4:	82 83       	std	Z+2, r24	; 0x02
    57c6:	35 82       	std	Z+5, r3	; 0x05
    57c8:	24 82       	std	Z+4, r2	; 0x04
    57ca:	57 82       	std	Z+7, r5	; 0x07
    57cc:	46 82       	std	Z+6, r4	; 0x06
    57ce:	81 e9       	ldi	r24, 0x91	; 145
    57d0:	99 e0       	ldi	r25, 0x09	; 9
    57d2:	91 87       	std	Z+9, r25	; 0x09
    57d4:	80 87       	std	Z+8, r24	; 0x08
    57d6:	f3 86       	std	Z+11, r15	; 0x0b
    57d8:	e2 86       	std	Z+10, r14	; 0x0a
    57da:	95 86       	std	Z+13, r9	; 0x0d
    57dc:	84 86       	std	Z+12, r8	; 0x0c
    57de:	b7 86       	std	Z+15, r11	; 0x0f
    57e0:	a6 86       	std	Z+14, r10	; 0x0e
    57e2:	d1 8a       	std	Z+17, r13	; 0x11
    57e4:	c0 8a       	std	Z+16, r12	; 0x10
    57e6:	62 8a       	std	Z+18, r6	; 0x12
    57e8:	73 8a       	std	Z+19, r7	; 0x13
    57ea:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	 cSum=SumChecksum(strSend);
    57ee:	ad b7       	in	r26, 0x3d	; 61
    57f0:	be b7       	in	r27, 0x3e	; 62
    57f2:	54 96       	adiw	r26, 0x14	; 20
    57f4:	0f b6       	in	r0, 0x3f	; 63
    57f6:	f8 94       	cli
    57f8:	be bf       	out	0x3e, r27	; 62
    57fa:	0f be       	out	0x3f, r0	; 63
    57fc:	ad bf       	out	0x3d, r26	; 61
    57fe:	c8 01       	movw	r24, r16
    5800:	0e 94 f2 1f 	call	0x3fe4	; 0x3fe4 <SumChecksum>
    5804:	e8 2e       	mov	r14, r24
	 _uart_print(1,0,strSend);
    5806:	81 e0       	ldi	r24, 0x01	; 1
    5808:	60 e0       	ldi	r22, 0x00	; 0
    580a:	a8 01       	movw	r20, r16
    580c:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
    5810:	f8 01       	movw	r30, r16

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5812:	c8 01       	movw	r24, r16
    5814:	f9 2e       	mov	r15, r25
    5816:	ce 01       	movw	r24, r28
    5818:	8f 54       	subi	r24, 0x4F	; 79
    581a:	9f 4f       	sbci	r25, 0xFF	; 255
	     strMemory[i]=data;
    581c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    581e:	e8 17       	cp	r30, r24
    5820:	f9 07       	cpc	r31, r25
    5822:	e1 f7       	brne	.-8      	; 0x581c <GeniusSendLastTransaction+0x19e>
	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
	 cSum=SumChecksum(strSend);
	 _uart_print(1,0,strSend);
	 FillChar(strSend,sizeof(strSend),0);      
	 sprintf_P(strSend,PSTR("%d"),cSum);
    5824:	00 d0       	rcall	.+0      	; 0x5826 <GeniusSendLastTransaction+0x1a8>
    5826:	00 d0       	rcall	.+0      	; 0x5828 <GeniusSendLastTransaction+0x1aa>
    5828:	00 d0       	rcall	.+0      	; 0x582a <GeniusSendLastTransaction+0x1ac>
    582a:	ed b7       	in	r30, 0x3d	; 61
    582c:	fe b7       	in	r31, 0x3e	; 62
    582e:	31 96       	adiw	r30, 0x01	; 1
    5830:	ad b7       	in	r26, 0x3d	; 61
    5832:	be b7       	in	r27, 0x3e	; 62
    5834:	11 96       	adiw	r26, 0x01	; 1
    5836:	0c 93       	st	X, r16
    5838:	11 97       	sbiw	r26, 0x01	; 1
    583a:	12 96       	adiw	r26, 0x02	; 2
    583c:	fc 92       	st	X, r15
    583e:	85 e3       	ldi	r24, 0x35	; 53
    5840:	93 e0       	ldi	r25, 0x03	; 3
    5842:	93 83       	std	Z+3, r25	; 0x03
    5844:	82 83       	std	Z+2, r24	; 0x02
    5846:	e4 82       	std	Z+4, r14	; 0x04
    5848:	15 82       	std	Z+5, r1	; 0x05
    584a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	 _uart_print(1,1,strSend);	 
    584e:	ed b7       	in	r30, 0x3d	; 61
    5850:	fe b7       	in	r31, 0x3e	; 62
    5852:	36 96       	adiw	r30, 0x06	; 6
    5854:	0f b6       	in	r0, 0x3f	; 63
    5856:	f8 94       	cli
    5858:	fe bf       	out	0x3e, r31	; 62
    585a:	0f be       	out	0x3f, r0	; 63
    585c:	ed bf       	out	0x3d, r30	; 61
    585e:	81 e0       	ldi	r24, 0x01	; 1
    5860:	61 e0       	ldi	r22, 0x01	; 1
    5862:	40 2f       	mov	r20, r16
    5864:	5f 2d       	mov	r21, r15
    5866:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
}
    586a:	c0 55       	subi	r28, 0x50	; 80
    586c:	df 4f       	sbci	r29, 0xFF	; 255
    586e:	0f b6       	in	r0, 0x3f	; 63
    5870:	f8 94       	cli
    5872:	de bf       	out	0x3e, r29	; 62
    5874:	0f be       	out	0x3f, r0	; 63
    5876:	cd bf       	out	0x3d, r28	; 61
    5878:	cf 91       	pop	r28
    587a:	df 91       	pop	r29
    587c:	1f 91       	pop	r17
    587e:	0f 91       	pop	r16
    5880:	ff 90       	pop	r15
    5882:	ef 90       	pop	r14
    5884:	df 90       	pop	r13
    5886:	cf 90       	pop	r12
    5888:	bf 90       	pop	r11
    588a:	af 90       	pop	r10
    588c:	9f 90       	pop	r9
    588e:	8f 90       	pop	r8
    5890:	7f 90       	pop	r7
    5892:	6f 90       	pop	r6
    5894:	5f 90       	pop	r5
    5896:	4f 90       	pop	r4
    5898:	3f 90       	pop	r3
    589a:	2f 90       	pop	r2
    589c:	08 95       	ret

0000589e <systemGeniusProtocol>:

void systemGeniusProtocol(){
static char stGeniusProtocol=gpInitScan;
static char iPumpID;
	 
	 switch(stGeniusProtocol){
    589e:	80 91 dc 01 	lds	r24, 0x01DC
    58a2:	83 30       	cpi	r24, 0x03	; 3
    58a4:	71 f1       	breq	.+92     	; 0x5902 <systemGeniusProtocol+0x64>
    58a6:	84 30       	cpi	r24, 0x04	; 4
    58a8:	28 f4       	brcc	.+10     	; 0x58b4 <systemGeniusProtocol+0x16>
    58aa:	81 30       	cpi	r24, 0x01	; 1
    58ac:	81 f0       	breq	.+32     	; 0x58ce <systemGeniusProtocol+0x30>
    58ae:	82 30       	cpi	r24, 0x02	; 2
    58b0:	c0 f4       	brcc	.+48     	; 0x58e2 <systemGeniusProtocol+0x44>
    58b2:	09 c0       	rjmp	.+18     	; 0x58c6 <systemGeniusProtocol+0x28>
    58b4:	85 30       	cpi	r24, 0x05	; 5
    58b6:	09 f4       	brne	.+2      	; 0x58ba <systemGeniusProtocol+0x1c>
    58b8:	49 c0       	rjmp	.+146    	; 0x594c <systemGeniusProtocol+0xae>
    58ba:	85 30       	cpi	r24, 0x05	; 5
    58bc:	c0 f1       	brcs	.+112    	; 0x592e <systemGeniusProtocol+0x90>
    58be:	86 30       	cpi	r24, 0x06	; 6
    58c0:	09 f0       	breq	.+2      	; 0x58c4 <systemGeniusProtocol+0x26>
    58c2:	60 c0       	rjmp	.+192    	; 0x5984 <systemGeniusProtocol+0xe6>
    58c4:	4d c0       	rjmp	.+154    	; 0x5960 <systemGeniusProtocol+0xc2>
	 case gpInitScan:
	      iPumpID=1;
    58c6:	81 e0       	ldi	r24, 0x01	; 1
    58c8:	80 93 db 01 	sts	0x01DB, r24
    58cc:	46 c0       	rjmp	.+140    	; 0x595a <systemGeniusProtocol+0xbc>
          stGeniusProtocol=gpScanNewTransaction;
	      break;
	 case gpScanNewTransaction:
	      if (GetIncomingTransStatus(PumpID)==TS_NEW){
    58ce:	80 91 da 01 	lds	r24, 0x01DA
    58d2:	0e 94 c2 1a 	call	0x3584	; 0x3584 <GetIncomingTransStatus>
    58d6:	82 30       	cpi	r24, 0x02	; 2
    58d8:	09 f0       	breq	.+2      	; 0x58dc <systemGeniusProtocol+0x3e>
    58da:	54 c0       	rjmp	.+168    	; 0x5984 <systemGeniusProtocol+0xe6>
		      IsTotalizerReceived=False;
    58dc:	10 92 c5 01 	sts	0x01C5, r1
    58e0:	3c c0       	rjmp	.+120    	; 0x595a <systemGeniusProtocol+0xbc>
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
    58e2:	90 91 db 01 	lds	r25, 0x01DB
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    58e6:	85 e0       	ldi	r24, 0x05	; 5
    58e8:	80 93 da 07 	sts	0x07DA, r24
	 PoolMsg=plMsg;
    58ec:	90 93 fe 0d 	sts	0x0DFE, r25
     IsControlPooling=True;
    58f0:	81 e0       	ldi	r24, 0x01	; 1
    58f2:	80 93 97 01 	sts	0x0197, r24
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
		  TimSend=0;
    58f6:	10 92 a9 01 	sts	0x01A9, r1
    58fa:	10 92 a8 01 	sts	0x01A8, r1
		  stGeniusProtocol=gpWaitRequestedTotalizer;
    58fe:	83 e0       	ldi	r24, 0x03	; 3
    5900:	2c c0       	rjmp	.+88     	; 0x595a <systemGeniusProtocol+0xbc>
	      break;
     case gpWaitRequestedTotalizer:
	      if ((IsTotalizerReceived==True)&&(AcknoledgePump==iPumpID)){
    5902:	80 91 c5 01 	lds	r24, 0x01C5
    5906:	81 30       	cpi	r24, 0x01	; 1
    5908:	59 f4       	brne	.+22     	; 0x5920 <systemGeniusProtocol+0x82>
    590a:	90 91 17 0e 	lds	r25, 0x0E17
    590e:	80 91 db 01 	lds	r24, 0x01DB
    5912:	98 17       	cp	r25, r24
    5914:	29 f4       	brne	.+10     	; 0x5920 <systemGeniusProtocol+0x82>
		      IsTotalizerReceived=False;
    5916:	10 92 c5 01 	sts	0x01C5, r1
			  stGeniusProtocol=gpSendTransactionData;
    591a:	84 e0       	ldi	r24, 0x04	; 4
    591c:	80 93 dc 01 	sts	0x01DC, r24
		  }
	      if (TimSend>TIM_SEND*2)stGeniusProtocol=gpNextPumpScan;
    5920:	80 91 a8 01 	lds	r24, 0x01A8
    5924:	90 91 a9 01 	lds	r25, 0x01A9
    5928:	45 97       	sbiw	r24, 0x15	; 21
    592a:	60 f1       	brcs	.+88     	; 0x5984 <systemGeniusProtocol+0xe6>
    592c:	15 c0       	rjmp	.+42     	; 0x5958 <systemGeniusProtocol+0xba>
	      break;
     case gpSendTransactionData:
          GeniusSendLastTransaction(iPumpID);
    592e:	80 91 db 01 	lds	r24, 0x01DB
    5932:	0e 94 3f 2b 	call	0x567e	; 0x567e <GeniusSendLastTransaction>
		  SetIncomingTransStatus(iPumpID,TS_OLD);
    5936:	80 91 db 01 	lds	r24, 0x01DB
    593a:	63 e0       	ldi	r22, 0x03	; 3
    593c:	0e 94 90 1a 	call	0x3520	; 0x3520 <SetIncomingTransStatus>
		  
		  TimSend=0;
    5940:	10 92 a9 01 	sts	0x01A9, r1
    5944:	10 92 a8 01 	sts	0x01A8, r1
          stGeniusProtocol=gpDelayNextPumpScan;
    5948:	85 e0       	ldi	r24, 0x05	; 5
    594a:	07 c0       	rjmp	.+14     	; 0x595a <systemGeniusProtocol+0xbc>
	      break;
     case gpDelayNextPumpScan:
          if (TimSend>1)stGeniusProtocol=gpNextPumpScan;
    594c:	80 91 a8 01 	lds	r24, 0x01A8
    5950:	90 91 a9 01 	lds	r25, 0x01A9
    5954:	02 97       	sbiw	r24, 0x02	; 2
    5956:	b0 f0       	brcs	.+44     	; 0x5984 <systemGeniusProtocol+0xe6>
    5958:	86 e0       	ldi	r24, 0x06	; 6
    595a:	80 93 dc 01 	sts	0x01DC, r24
    595e:	08 95       	ret
	      break;
     case gpNextPumpScan:
          if (iPumpID<=eeprom_read_byte(&DefPoolingPumpMax)){
    5960:	20 91 db 01 	lds	r18, 0x01DB
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    5964:	e1 99       	sbic	0x1c, 1	; 28
    5966:	fe cf       	rjmp	.-4      	; 0x5964 <systemGeniusProtocol+0xc6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    5968:	84 e4       	ldi	r24, 0x44	; 68
    596a:	91 e0       	ldi	r25, 0x01	; 1
    596c:	9f bb       	out	0x1f, r25	; 31
    596e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    5970:	e0 9a       	sbi	0x1c, 0	; 28
    5972:	8d b3       	in	r24, 0x1d	; 29
    5974:	82 17       	cp	r24, r18
    5976:	30 f0       	brcs	.+12     	; 0x5984 <systemGeniusProtocol+0xe6>
		      iPumpID++;
    5978:	2f 5f       	subi	r18, 0xFF	; 255
    597a:	20 93 db 01 	sts	0x01DB, r18
              stGeniusProtocol=gpScanNewTransaction;
    597e:	81 e0       	ldi	r24, 0x01	; 1
    5980:	80 93 dc 01 	sts	0x01DC, r24
    5984:	08 95       	ret

00005986 <StrAlignCenter>:
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrAlignCenter(char *Source, unsigned int Length){
    5986:	ef 92       	push	r14
    5988:	ff 92       	push	r15
    598a:	0f 93       	push	r16
    598c:	1f 93       	push	r17
    598e:	18 2f       	mov	r17, r24
    5990:	09 2f       	mov	r16, r25
    5992:	7b 01       	movw	r14, r22
char nAddedSpace,srcLength;
     RemSpaceLag(Source);
    5994:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
	 RemSpaceLead(Source);
    5998:	81 2f       	mov	r24, r17
    599a:	90 2f       	mov	r25, r16
    599c:	0e 94 06 24 	call	0x480c	; 0x480c <RemSpaceLead>
	 srcLength=strlen(Source);
    59a0:	a1 2f       	mov	r26, r17
    59a2:	b0 2f       	mov	r27, r16
    59a4:	fd 01       	movw	r30, r26
    59a6:	01 90       	ld	r0, Z+
    59a8:	00 20       	and	r0, r0
    59aa:	e9 f7       	brne	.-6      	; 0x59a6 <StrAlignCenter+0x20>
    59ac:	31 97       	sbiw	r30, 0x01	; 1
    59ae:	e1 1b       	sub	r30, r17
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
    59b0:	c7 01       	movw	r24, r14
    59b2:	8e 1b       	sub	r24, r30
    59b4:	91 09       	sbc	r25, r1
    59b6:	96 95       	lsr	r25
    59b8:	87 95       	ror	r24
    59ba:	e8 0f       	add	r30, r24
    59bc:	81 2f       	mov	r24, r17
    59be:	90 2f       	mov	r25, r16
    59c0:	6e 2f       	mov	r22, r30
    59c2:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <AddSpaceLead>
	 AddSpaceLag(Source,Length);
    59c6:	81 2f       	mov	r24, r17
    59c8:	90 2f       	mov	r25, r16
    59ca:	6e 2d       	mov	r22, r14
    59cc:	0e 94 b9 2a 	call	0x5572	; 0x5572 <AddSpaceLag>
}
    59d0:	1f 91       	pop	r17
    59d2:	0f 91       	pop	r16
    59d4:	ff 90       	pop	r15
    59d6:	ef 90       	pop	r14
    59d8:	08 95       	ret

000059da <AddCharLead>:
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    59da:	bf 92       	push	r11
    59dc:	cf 92       	push	r12
    59de:	df 92       	push	r13
    59e0:	ef 92       	push	r14
    59e2:	ff 92       	push	r15
    59e4:	0f 93       	push	r16
    59e6:	1f 93       	push	r17
    59e8:	df 93       	push	r29
    59ea:	cf 93       	push	r28
    59ec:	cd b7       	in	r28, 0x3d	; 61
    59ee:	de b7       	in	r29, 0x3e	; 62
    59f0:	6e 97       	sbiw	r28, 0x1e	; 30
    59f2:	0f b6       	in	r0, 0x3f	; 63
    59f4:	f8 94       	cli
    59f6:	de bf       	out	0x3e, r29	; 62
    59f8:	0f be       	out	0x3f, r0	; 63
    59fa:	cd bf       	out	0x3d, r28	; 61
    59fc:	8c 01       	movw	r16, r24
    59fe:	e4 2e       	mov	r14, r20
     char i,Length,strAdded[30];
     Length=strlen(String);
    5a00:	fc 01       	movw	r30, r24
    5a02:	01 90       	ld	r0, Z+
    5a04:	00 20       	and	r0, r0
    5a06:	e9 f7       	brne	.-6      	; 0x5a02 <AddCharLead+0x28>
    5a08:	31 97       	sbiw	r30, 0x01	; 1
    5a0a:	2e 2f       	mov	r18, r30
    5a0c:	28 1b       	sub	r18, r24

	 if (Size>Length){
    5a0e:	24 17       	cp	r18, r20
    5a10:	d0 f5       	brcc	.+116    	; 0x5a86 <AddCharLead+0xac>
    5a12:	ae 01       	movw	r20, r28
    5a14:	4f 5f       	subi	r20, 0xFF	; 255
    5a16:	5f 4f       	sbci	r21, 0xFF	; 255
    5a18:	fa 01       	movw	r30, r20
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    5a1a:	b4 2e       	mov	r11, r20
    5a1c:	01 c0       	rjmp	.+2      	; 0x5a20 <AddCharLead+0x46>
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
    5a1e:	61 93       	st	Z+, r22
void AddCharLead(char *String,char CharAdded,unsigned char Size){//
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    5a20:	8e 2f       	mov	r24, r30
    5a22:	8b 19       	sub	r24, r11
    5a24:	8e 15       	cp	r24, r14
    5a26:	d8 f3       	brcs	.-10     	; 0x5a1e <AddCharLead+0x44>
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
    5a28:	6e 2d       	mov	r22, r14
    5a2a:	70 e0       	ldi	r23, 0x00	; 0
    5a2c:	ce 01       	movw	r24, r28
    5a2e:	01 96       	adiw	r24, 0x01	; 1
    5a30:	fc 01       	movw	r30, r24
    5a32:	e6 0f       	add	r30, r22
    5a34:	f7 1f       	adc	r31, r23
    5a36:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5a38:	fe 2c       	mov	r15, r14
    5a3a:	f2 1a       	sub	r15, r18
    5a3c:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    5a3e:	30 e0       	ldi	r19, 0x00	; 0
    5a40:	26 1b       	sub	r18, r22
    5a42:	37 0b       	sbc	r19, r23
    5a44:	0c c0       	rjmp	.+24     	; 0x5a5e <AddCharLead+0x84>
    5a46:	ef 2d       	mov	r30, r15
    5a48:	f0 e0       	ldi	r31, 0x00	; 0
    5a4a:	d6 01       	movw	r26, r12
    5a4c:	ae 0f       	add	r26, r30
    5a4e:	bf 1f       	adc	r27, r31
    5a50:	e0 0f       	add	r30, r16
    5a52:	f1 1f       	adc	r31, r17
    5a54:	e2 0f       	add	r30, r18
    5a56:	f3 1f       	adc	r31, r19
    5a58:	80 81       	ld	r24, Z
    5a5a:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5a5c:	f3 94       	inc	r15
    5a5e:	fe 14       	cp	r15, r14
    5a60:	90 f3       	brcs	.-28     	; 0x5a46 <AddCharLead+0x6c>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    5a62:	6c 0d       	add	r22, r12
    5a64:	7d 1d       	adc	r23, r13
    5a66:	db 01       	movw	r26, r22
    5a68:	1c 92       	st	X, r1
    5a6a:	f8 01       	movw	r30, r16
    5a6c:	04 c0       	rjmp	.+8      	; 0x5a76 <AddCharLead+0x9c>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    5a6e:	da 01       	movw	r26, r20
    5a70:	8d 91       	ld	r24, X+
    5a72:	ad 01       	movw	r20, r26
    5a74:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    5a76:	84 2f       	mov	r24, r20
    5a78:	8b 19       	sub	r24, r11
    5a7a:	8e 15       	cp	r24, r14
    5a7c:	c0 f3       	brcs	.-16     	; 0x5a6e <AddCharLead+0x94>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    5a7e:	0e 0d       	add	r16, r14
    5a80:	11 1d       	adc	r17, r1
    5a82:	f8 01       	movw	r30, r16
    5a84:	10 82       	st	Z, r1
	 }
}
    5a86:	6e 96       	adiw	r28, 0x1e	; 30
    5a88:	0f b6       	in	r0, 0x3f	; 63
    5a8a:	f8 94       	cli
    5a8c:	de bf       	out	0x3e, r29	; 62
    5a8e:	0f be       	out	0x3f, r0	; 63
    5a90:	cd bf       	out	0x3d, r28	; 61
    5a92:	cf 91       	pop	r28
    5a94:	df 91       	pop	r29
    5a96:	1f 91       	pop	r17
    5a98:	0f 91       	pop	r16
    5a9a:	ff 90       	pop	r15
    5a9c:	ef 90       	pop	r14
    5a9e:	df 90       	pop	r13
    5aa0:	cf 90       	pop	r12
    5aa2:	bf 90       	pop	r11
    5aa4:	08 95       	ret

00005aa6 <AddCharLag>:
    }
return Result;
}

//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
    5aa6:	cf 93       	push	r28
    5aa8:	df 93       	push	r29
    5aaa:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    5aac:	dc 01       	movw	r26, r24
    5aae:	0d 90       	ld	r0, X+
    5ab0:	00 20       	and	r0, r0
    5ab2:	e9 f7       	brne	.-6      	; 0x5aae <AddCharLag+0x8>
    5ab4:	11 97       	sbiw	r26, 0x01	; 1
    5ab6:	a8 1b       	sub	r26, r24
    5ab8:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    5aba:	a4 17       	cp	r26, r20
    5abc:	58 f4       	brcc	.+22     	; 0x5ad4 <AddCharLag+0x2e>
    5abe:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=CharAdded;
    5ac0:	fe 01       	movw	r30, r28
    5ac2:	e8 0f       	add	r30, r24
    5ac4:	f1 1d       	adc	r31, r1
    5ac6:	60 83       	st	Z, r22
//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    5ac8:	8f 5f       	subi	r24, 0xFF	; 255
    5aca:	84 17       	cp	r24, r20
    5acc:	c8 f3       	brcs	.-14     	; 0x5ac0 <AddCharLag+0x1a>
	    String[i]=CharAdded;
	 }String[Size]=0;
    5ace:	c4 0f       	add	r28, r20
    5ad0:	d1 1d       	adc	r29, r1
    5ad2:	18 82       	st	Y, r1
  }

}
    5ad4:	df 91       	pop	r29
    5ad6:	cf 91       	pop	r28
    5ad8:	08 95       	ret

00005ada <CountTotalizerSatus>:
		      Result++;		  
		  }	 
	 }
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
    5ada:	cf 92       	push	r12
    5adc:	df 92       	push	r13
    5ade:	ef 92       	push	r14
    5ae0:	ff 92       	push	r15
    5ae2:	0f 93       	push	r16
    5ae4:	1f 93       	push	r17
    5ae6:	cf 93       	push	r28
    5ae8:	df 93       	push	r29
    5aea:	7c 01       	movw	r14, r24
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    5aec:	dc 01       	movw	r26, r24
    5aee:	0d 90       	ld	r0, X+
    5af0:	00 20       	and	r0, r0
    5af2:	e9 f7       	brne	.-6      	; 0x5aee <CountTotalizerSatus+0x14>
    5af4:	8d 01       	movw	r16, r26
    5af6:	01 50       	subi	r16, 0x01	; 1
    5af8:	10 40       	sbci	r17, 0x00	; 0
    5afa:	08 1b       	sub	r16, r24
    5afc:	19 0b       	sbc	r17, r25
    5afe:	cc 24       	eor	r12, r12
    5b00:	dd 24       	eor	r13, r13
    5b02:	0a c0       	rjmp	.+20     	; 0x5b18 <CountTotalizerSatus+0x3e>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
    5b04:	84 e1       	ldi	r24, 0x14	; 20
    5b06:	0e 94 72 13 	call	0x26e4	; 0x26e4 <GetPumpStatusLabel>
    5b0a:	ce 0d       	add	r28, r14
    5b0c:	df 1d       	adc	r29, r15
    5b0e:	98 81       	ld	r25, Y
    5b10:	98 17       	cp	r25, r24
    5b12:	09 f4       	brne	.+2      	; 0x5b16 <CountTotalizerSatus+0x3c>
		      Result++;		  
    5b14:	d3 94       	inc	r13
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    5b16:	c3 94       	inc	r12
    5b18:	cc 2d       	mov	r28, r12
    5b1a:	d0 e0       	ldi	r29, 0x00	; 0
    5b1c:	c0 17       	cp	r28, r16
    5b1e:	d1 07       	cpc	r29, r17
    5b20:	88 f3       	brcs	.-30     	; 0x5b04 <CountTotalizerSatus+0x2a>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    5b22:	8d 2d       	mov	r24, r13
    5b24:	df 91       	pop	r29
    5b26:	cf 91       	pop	r28
    5b28:	1f 91       	pop	r17
    5b2a:	0f 91       	pop	r16
    5b2c:	ff 90       	pop	r15
    5b2e:	ef 90       	pop	r14
    5b30:	df 90       	pop	r13
    5b32:	cf 90       	pop	r12
    5b34:	08 95       	ret

00005b36 <RemoveChar>:
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif
}

void RemoveChar(char *strSource, char cRem){
    5b36:	1f 93       	push	r17
    5b38:	df 93       	push	r29
    5b3a:	cf 93       	push	r28
    5b3c:	cd b7       	in	r28, 0x3d	; 61
    5b3e:	de b7       	in	r29, 0x3e	; 62
    5b40:	64 97       	sbiw	r28, 0x14	; 20
    5b42:	0f b6       	in	r0, 0x3f	; 63
    5b44:	f8 94       	cli
    5b46:	de bf       	out	0x3e, r29	; 62
    5b48:	0f be       	out	0x3f, r0	; 63
    5b4a:	cd bf       	out	0x3d, r28	; 61
    5b4c:	16 2f       	mov	r17, r22
    5b4e:	50 e0       	ldi	r21, 0x00	; 0
    5b50:	40 e0       	ldi	r20, 0x00	; 0
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
    5b52:	be 01       	movw	r22, r28
    5b54:	6f 5f       	subi	r22, 0xFF	; 255
    5b56:	7f 4f       	sbci	r23, 0xFF	; 255
    5b58:	0c c0       	rjmp	.+24     	; 0x5b72 <RemoveChar+0x3c>

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
    5b5a:	28 0f       	add	r18, r24
    5b5c:	39 1f       	adc	r19, r25
    5b5e:	d9 01       	movw	r26, r18
    5b60:	2c 91       	ld	r18, X
    5b62:	21 17       	cp	r18, r17
    5b64:	29 f0       	breq	.+10     	; 0x5b70 <RemoveChar+0x3a>
		     sTemp[iAdd]=strSource[i];
    5b66:	fb 01       	movw	r30, r22
    5b68:	e4 0f       	add	r30, r20
    5b6a:	f1 1d       	adc	r31, r1
    5b6c:	20 83       	st	Z, r18
			 iAdd++;
    5b6e:	4f 5f       	subi	r20, 0xFF	; 255
}

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
    5b70:	5f 5f       	subi	r21, 0xFF	; 255
    5b72:	25 2f       	mov	r18, r21
    5b74:	30 e0       	ldi	r19, 0x00	; 0
    5b76:	fc 01       	movw	r30, r24
    5b78:	01 90       	ld	r0, Z+
    5b7a:	00 20       	and	r0, r0
    5b7c:	e9 f7       	brne	.-6      	; 0x5b78 <RemoveChar+0x42>
    5b7e:	31 97       	sbiw	r30, 0x01	; 1
    5b80:	e8 1b       	sub	r30, r24
    5b82:	f9 0b       	sbc	r31, r25
    5b84:	2e 17       	cp	r18, r30
    5b86:	3f 07       	cpc	r19, r31
    5b88:	40 f3       	brcs	.-48     	; 0x5b5a <RemoveChar+0x24>
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
			 iAdd++;
          }
	 }sTemp[iAdd]=0;
    5b8a:	9e 01       	movw	r18, r28
    5b8c:	2f 5f       	subi	r18, 0xFF	; 255
    5b8e:	3f 4f       	sbci	r19, 0xFF	; 255
    5b90:	f9 01       	movw	r30, r18
    5b92:	e4 0f       	add	r30, r20
    5b94:	f1 1d       	adc	r31, r1
    5b96:	10 82       	st	Z, r1
	 sprintf_P(strSource,PSTR("%s"),sTemp);
    5b98:	00 d0       	rcall	.+0      	; 0x5b9a <RemoveChar+0x64>
    5b9a:	00 d0       	rcall	.+0      	; 0x5b9c <RemoveChar+0x66>
    5b9c:	00 d0       	rcall	.+0      	; 0x5b9e <RemoveChar+0x68>
    5b9e:	ed b7       	in	r30, 0x3d	; 61
    5ba0:	fe b7       	in	r31, 0x3e	; 62
    5ba2:	31 96       	adiw	r30, 0x01	; 1
    5ba4:	ad b7       	in	r26, 0x3d	; 61
    5ba6:	be b7       	in	r27, 0x3e	; 62
    5ba8:	12 96       	adiw	r26, 0x02	; 2
    5baa:	9c 93       	st	X, r25
    5bac:	8e 93       	st	-X, r24
    5bae:	11 97       	sbiw	r26, 0x01	; 1
    5bb0:	83 e7       	ldi	r24, 0x73	; 115
    5bb2:	97 e1       	ldi	r25, 0x17	; 23
    5bb4:	93 83       	std	Z+3, r25	; 0x03
    5bb6:	82 83       	std	Z+2, r24	; 0x02
    5bb8:	35 83       	std	Z+5, r19	; 0x05
    5bba:	24 83       	std	Z+4, r18	; 0x04
    5bbc:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    5bc0:	ed b7       	in	r30, 0x3d	; 61
    5bc2:	fe b7       	in	r31, 0x3e	; 62
    5bc4:	36 96       	adiw	r30, 0x06	; 6
    5bc6:	0f b6       	in	r0, 0x3f	; 63
    5bc8:	f8 94       	cli
    5bca:	fe bf       	out	0x3e, r31	; 62
    5bcc:	0f be       	out	0x3f, r0	; 63
    5bce:	ed bf       	out	0x3d, r30	; 61
}
    5bd0:	64 96       	adiw	r28, 0x14	; 20
    5bd2:	0f b6       	in	r0, 0x3f	; 63
    5bd4:	f8 94       	cli
    5bd6:	de bf       	out	0x3e, r29	; 62
    5bd8:	0f be       	out	0x3f, r0	; 63
    5bda:	cd bf       	out	0x3d, r28	; 61
    5bdc:	cf 91       	pop	r28
    5bde:	df 91       	pop	r29
    5be0:	1f 91       	pop	r17
    5be2:	08 95       	ret

00005be4 <WrapCode>:
	      break;
	 }
   return Result;
}

void WrapCode(char *strRawCode){
    5be4:	8f 92       	push	r8
    5be6:	9f 92       	push	r9
    5be8:	bf 92       	push	r11
    5bea:	cf 92       	push	r12
    5bec:	df 92       	push	r13
    5bee:	ef 92       	push	r14
    5bf0:	ff 92       	push	r15
    5bf2:	0f 93       	push	r16
    5bf4:	1f 93       	push	r17
    5bf6:	df 93       	push	r29
    5bf8:	cf 93       	push	r28
    5bfa:	cd b7       	in	r28, 0x3d	; 61
    5bfc:	de b7       	in	r29, 0x3e	; 62
    5bfe:	2f 97       	sbiw	r28, 0x0f	; 15
    5c00:	0f b6       	in	r0, 0x3f	; 63
    5c02:	f8 94       	cli
    5c04:	de bf       	out	0x3e, r29	; 62
    5c06:	0f be       	out	0x3f, r0	; 63
    5c08:	cd bf       	out	0x3d, r28	; 61
    5c0a:	6c 01       	movw	r12, r24
    5c0c:	bb 24       	eor	r11, r11
    5c0e:	40 e0       	ldi	r20, 0x00	; 0
    5c10:	4e 01       	movw	r8, r28
    5c12:	08 94       	sec
    5c14:	81 1c       	adc	r8, r1
    5c16:	91 1c       	adc	r9, r1
    5c18:	12 c0       	rjmp	.+36     	; 0x5c3e <WrapCode+0x5a>
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
    5c1a:	86 01       	movw	r16, r12
    5c1c:	0e 0d       	add	r16, r14
    5c1e:	1f 1d       	adc	r17, r15
    5c20:	d8 01       	movw	r26, r16
    5c22:	6c 91       	ld	r22, X
    5c24:	60 53       	subi	r22, 0x30	; 48
    5c26:	80 e0       	ldi	r24, 0x00	; 0
    5c28:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <GeniusCalc>
    5c2c:	e8 0c       	add	r14, r8
    5c2e:	f9 1c       	adc	r15, r9
    5c30:	80 5d       	subi	r24, 0xD0	; 208
    5c32:	f7 01       	movw	r30, r14
    5c34:	80 83       	st	Z, r24
		  seedKey=strRawCode[i]-'0';
    5c36:	d8 01       	movw	r26, r16
    5c38:	4c 91       	ld	r20, X
    5c3a:	40 53       	subi	r20, 0x30	; 48
void WrapCode(char *strRawCode){
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
    5c3c:	b3 94       	inc	r11
    5c3e:	eb 2c       	mov	r14, r11
    5c40:	ff 24       	eor	r15, r15
    5c42:	d6 01       	movw	r26, r12
    5c44:	0d 90       	ld	r0, X+
    5c46:	00 20       	and	r0, r0
    5c48:	e9 f7       	brne	.-6      	; 0x5c44 <WrapCode+0x60>
    5c4a:	11 97       	sbiw	r26, 0x01	; 1
    5c4c:	ac 19       	sub	r26, r12
    5c4e:	bd 09       	sbc	r27, r13
    5c50:	ea 16       	cp	r14, r26
    5c52:	fb 06       	cpc	r15, r27
    5c54:	10 f3       	brcs	.-60     	; 0x5c1a <WrapCode+0x36>
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
    5c56:	a8 0d       	add	r26, r8
    5c58:	b9 1d       	adc	r27, r9
    5c5a:	1c 92       	st	X, r1
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
    5c5c:	00 d0       	rcall	.+0      	; 0x5c5e <WrapCode+0x7a>
    5c5e:	00 d0       	rcall	.+0      	; 0x5c60 <WrapCode+0x7c>
    5c60:	00 d0       	rcall	.+0      	; 0x5c62 <WrapCode+0x7e>
    5c62:	ed b7       	in	r30, 0x3d	; 61
    5c64:	fe b7       	in	r31, 0x3e	; 62
    5c66:	31 96       	adiw	r30, 0x01	; 1
    5c68:	ad b7       	in	r26, 0x3d	; 61
    5c6a:	be b7       	in	r27, 0x3e	; 62
    5c6c:	12 96       	adiw	r26, 0x02	; 2
    5c6e:	dc 92       	st	X, r13
    5c70:	ce 92       	st	-X, r12
    5c72:	11 97       	sbiw	r26, 0x01	; 1
    5c74:	8e e7       	ldi	r24, 0x7E	; 126
    5c76:	97 e1       	ldi	r25, 0x17	; 23
    5c78:	93 83       	std	Z+3, r25	; 0x03
    5c7a:	82 83       	std	Z+2, r24	; 0x02
    5c7c:	95 82       	std	Z+5, r9	; 0x05
    5c7e:	84 82       	std	Z+4, r8	; 0x04
    5c80:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    5c84:	ed b7       	in	r30, 0x3d	; 61
    5c86:	fe b7       	in	r31, 0x3e	; 62
    5c88:	36 96       	adiw	r30, 0x06	; 6
    5c8a:	0f b6       	in	r0, 0x3f	; 63
    5c8c:	f8 94       	cli
    5c8e:	fe bf       	out	0x3e, r31	; 62
    5c90:	0f be       	out	0x3f, r0	; 63
    5c92:	ed bf       	out	0x3d, r30	; 61
}
    5c94:	2f 96       	adiw	r28, 0x0f	; 15
    5c96:	0f b6       	in	r0, 0x3f	; 63
    5c98:	f8 94       	cli
    5c9a:	de bf       	out	0x3e, r29	; 62
    5c9c:	0f be       	out	0x3f, r0	; 63
    5c9e:	cd bf       	out	0x3d, r28	; 61
    5ca0:	cf 91       	pop	r28
    5ca2:	df 91       	pop	r29
    5ca4:	1f 91       	pop	r17
    5ca6:	0f 91       	pop	r16
    5ca8:	ff 90       	pop	r15
    5caa:	ef 90       	pop	r14
    5cac:	df 90       	pop	r13
    5cae:	cf 90       	pop	r12
    5cb0:	bf 90       	pop	r11
    5cb2:	9f 90       	pop	r9
    5cb4:	8f 90       	pop	r8
    5cb6:	08 95       	ret

00005cb8 <GenerateKeyStamp>:


   return Result;
}

void GenerateKeyStamp(char *sTime, char *sGCode, char *strKeyStamp){//
    5cb8:	8f 92       	push	r8
    5cba:	9f 92       	push	r9
    5cbc:	af 92       	push	r10
    5cbe:	bf 92       	push	r11
    5cc0:	df 92       	push	r13
    5cc2:	ef 92       	push	r14
    5cc4:	ff 92       	push	r15
    5cc6:	0f 93       	push	r16
    5cc8:	1f 93       	push	r17
    5cca:	df 93       	push	r29
    5ccc:	cf 93       	push	r28
    5cce:	cd b7       	in	r28, 0x3d	; 61
    5cd0:	de b7       	in	r29, 0x3e	; 62
    5cd2:	2d 97       	sbiw	r28, 0x0d	; 13
    5cd4:	0f b6       	in	r0, 0x3f	; 63
    5cd6:	f8 94       	cli
    5cd8:	de bf       	out	0x3e, r29	; 62
    5cda:	0f be       	out	0x3f, r0	; 63
    5cdc:	cd bf       	out	0x3d, r28	; 61
    5cde:	9c 01       	movw	r18, r24
    5ce0:	7b 01       	movw	r14, r22
    5ce2:	5a 01       	movw	r10, r20
	             65585577
	 */
     char seedIdx,sSeed[10],sAdd[3],i;
     
	 seedIdx=(sTime[5]-'0')%8; 
	 sAdd[0]=sGCode[seedIdx];
    5ce4:	dc 01       	movw	r26, r24
    5ce6:	15 96       	adiw	r26, 0x05	; 5
    5ce8:	8c 91       	ld	r24, X
    5cea:	90 e0       	ldi	r25, 0x00	; 0
    5cec:	c0 97       	sbiw	r24, 0x30	; 48
    5cee:	68 e0       	ldi	r22, 0x08	; 8
    5cf0:	70 e0       	ldi	r23, 0x00	; 0
    5cf2:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    5cf6:	f7 01       	movw	r30, r14
    5cf8:	e8 0f       	add	r30, r24
    5cfa:	f1 1d       	adc	r31, r1
    5cfc:	80 81       	ld	r24, Z
    5cfe:	89 83       	std	Y+1, r24	; 0x01
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
    5d00:	f9 01       	movw	r30, r18
    5d02:	86 81       	ldd	r24, Z+6	; 0x06
    5d04:	90 e0       	ldi	r25, 0x00	; 0
    5d06:	c0 97       	sbiw	r24, 0x30	; 48
    5d08:	68 e0       	ldi	r22, 0x08	; 8
    5d0a:	70 e0       	ldi	r23, 0x00	; 0
    5d0c:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    5d10:	f7 01       	movw	r30, r14
    5d12:	e8 0f       	add	r30, r24
    5d14:	f1 1d       	adc	r31, r1
    5d16:	80 81       	ld	r24, Z
    5d18:	8a 83       	std	Y+2, r24	; 0x02
	 sAdd[2]=0;
    5d1a:	1b 82       	std	Y+3, r1	; 0x03

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
    5d1c:	8d b7       	in	r24, 0x3d	; 61
    5d1e:	9e b7       	in	r25, 0x3e	; 62
    5d20:	08 97       	sbiw	r24, 0x08	; 8
    5d22:	0f b6       	in	r0, 0x3f	; 63
    5d24:	f8 94       	cli
    5d26:	9e bf       	out	0x3e, r25	; 62
    5d28:	0f be       	out	0x3f, r0	; 63
    5d2a:	8d bf       	out	0x3d, r24	; 61
    5d2c:	ed b7       	in	r30, 0x3d	; 61
    5d2e:	fe b7       	in	r31, 0x3e	; 62
    5d30:	31 96       	adiw	r30, 0x01	; 1
    5d32:	8e 01       	movw	r16, r28
    5d34:	0c 5f       	subi	r16, 0xFC	; 252
    5d36:	1f 4f       	sbci	r17, 0xFF	; 255
    5d38:	ad b7       	in	r26, 0x3d	; 61
    5d3a:	be b7       	in	r27, 0x3e	; 62
    5d3c:	12 96       	adiw	r26, 0x02	; 2
    5d3e:	1c 93       	st	X, r17
    5d40:	0e 93       	st	-X, r16
    5d42:	11 97       	sbiw	r26, 0x01	; 1
    5d44:	8e e6       	ldi	r24, 0x6E	; 110
    5d46:	97 e1       	ldi	r25, 0x17	; 23
    5d48:	93 83       	std	Z+3, r25	; 0x03
    5d4a:	82 83       	std	Z+2, r24	; 0x02
    5d4c:	35 83       	std	Z+5, r19	; 0x05
    5d4e:	24 83       	std	Z+4, r18	; 0x04
    5d50:	ce 01       	movw	r24, r28
    5d52:	01 96       	adiw	r24, 0x01	; 1
    5d54:	97 83       	std	Z+7, r25	; 0x07
    5d56:	86 83       	std	Z+6, r24	; 0x06
    5d58:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    5d5c:	dd 24       	eor	r13, r13
    5d5e:	ed b7       	in	r30, 0x3d	; 61
    5d60:	fe b7       	in	r31, 0x3e	; 62
    5d62:	38 96       	adiw	r30, 0x08	; 8
    5d64:	0f b6       	in	r0, 0x3f	; 63
    5d66:	f8 94       	cli
    5d68:	fe bf       	out	0x3e, r31	; 62
    5d6a:	0f be       	out	0x3f, r0	; 63
    5d6c:	ed bf       	out	0x3d, r30	; 61
     for(i=0;i<strlen(sGCode);i++){
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
    5d6e:	48 01       	movw	r8, r16
    5d70:	13 c0       	rjmp	.+38     	; 0x5d98 <GenerateKeyStamp+0xe0>
    5d72:	f4 01       	movw	r30, r8
    5d74:	e0 0f       	add	r30, r16
    5d76:	f1 1f       	adc	r31, r17
    5d78:	60 81       	ld	r22, Z
    5d7a:	60 53       	subi	r22, 0x30	; 48
    5d7c:	f7 01       	movw	r30, r14
    5d7e:	e0 0f       	add	r30, r16
    5d80:	f1 1f       	adc	r31, r17
    5d82:	40 81       	ld	r20, Z
    5d84:	40 53       	subi	r20, 0x30	; 48
    5d86:	81 e0       	ldi	r24, 0x01	; 1
    5d88:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <GeniusCalc>
    5d8c:	0a 0d       	add	r16, r10
    5d8e:	1b 1d       	adc	r17, r11
    5d90:	80 5d       	subi	r24, 0xD0	; 208
    5d92:	d8 01       	movw	r26, r16
    5d94:	8c 93       	st	X, r24
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
	 sAdd[2]=0;

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
     for(i=0;i<strlen(sGCode);i++){
    5d96:	d3 94       	inc	r13
    5d98:	0d 2d       	mov	r16, r13
    5d9a:	10 e0       	ldi	r17, 0x00	; 0
    5d9c:	d7 01       	movw	r26, r14
    5d9e:	0d 90       	ld	r0, X+
    5da0:	00 20       	and	r0, r0
    5da2:	e9 f7       	brne	.-6      	; 0x5d9e <GenerateKeyStamp+0xe6>
    5da4:	11 97       	sbiw	r26, 0x01	; 1
    5da6:	ae 19       	sub	r26, r14
    5da8:	bf 09       	sbc	r27, r15
    5daa:	0a 17       	cp	r16, r26
    5dac:	1b 07       	cpc	r17, r27
    5dae:	08 f3       	brcs	.-62     	; 0x5d72 <GenerateKeyStamp+0xba>
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
    5db0:	aa 0d       	add	r26, r10
    5db2:	bb 1d       	adc	r27, r11
    5db4:	1c 92       	st	X, r1
     WrapCode(strKeyStamp);
    5db6:	c5 01       	movw	r24, r10
    5db8:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <WrapCode>
}
    5dbc:	2d 96       	adiw	r28, 0x0d	; 13
    5dbe:	0f b6       	in	r0, 0x3f	; 63
    5dc0:	f8 94       	cli
    5dc2:	de bf       	out	0x3e, r29	; 62
    5dc4:	0f be       	out	0x3f, r0	; 63
    5dc6:	cd bf       	out	0x3d, r28	; 61
    5dc8:	cf 91       	pop	r28
    5dca:	df 91       	pop	r29
    5dcc:	1f 91       	pop	r17
    5dce:	0f 91       	pop	r16
    5dd0:	ff 90       	pop	r15
    5dd2:	ef 90       	pop	r14
    5dd4:	df 90       	pop	r13
    5dd6:	bf 90       	pop	r11
    5dd8:	af 90       	pop	r10
    5dda:	9f 90       	pop	r9
    5ddc:	8f 90       	pop	r8
    5dde:	08 95       	ret

00005de0 <GenerateGeniusCode>:
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
}

void GenerateGeniusCode(char *srcDate, char cSeed, char *strDestCode){
    5de0:	af 92       	push	r10
    5de2:	bf 92       	push	r11
    5de4:	cf 92       	push	r12
    5de6:	df 92       	push	r13
    5de8:	ef 92       	push	r14
    5dea:	ff 92       	push	r15
    5dec:	0f 93       	push	r16
    5dee:	1f 93       	push	r17
    5df0:	df 93       	push	r29
    5df2:	cf 93       	push	r28
    5df4:	cd b7       	in	r28, 0x3d	; 61
    5df6:	de b7       	in	r29, 0x3e	; 62
    5df8:	28 97       	sbiw	r28, 0x08	; 8
    5dfa:	0f b6       	in	r0, 0x3f	; 63
    5dfc:	f8 94       	cli
    5dfe:	de bf       	out	0x3e, r29	; 62
    5e00:	0f be       	out	0x3f, r0	; 63
    5e02:	cd bf       	out	0x3d, r28	; 61
    5e04:	7c 01       	movw	r14, r24
    5e06:	c6 2e       	mov	r12, r22
    5e08:	5a 01       	movw	r10, r20
	     WrapC ->68846545
	 */ 
	 char i,GCalcOpt,AddYear[3],SYear[5];
	 char strSend[20];

	 StrPosCopy(srcDate,AddYear,strlen(srcDate)-3,2);
    5e0a:	fc 01       	movw	r30, r24
    5e0c:	01 90       	ld	r0, Z+
    5e0e:	00 20       	and	r0, r0
    5e10:	e9 f7       	brne	.-6      	; 0x5e0c <GenerateGeniusCode+0x2c>
    5e12:	e8 1b       	sub	r30, r24
    5e14:	f9 0b       	sbc	r31, r25
    5e16:	34 97       	sbiw	r30, 0x04	; 4
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    5e18:	e8 0f       	add	r30, r24
    5e1a:	f9 1f       	adc	r31, r25
    5e1c:	80 81       	ld	r24, Z
    5e1e:	89 83       	std	Y+1, r24	; 0x01
    5e20:	81 81       	ldd	r24, Z+1	; 0x01
    5e22:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    5e24:	1b 82       	std	Y+3, r1	; 0x03
	 */ 
	 char i,GCalcOpt,AddYear[3],SYear[5];
	 char strSend[20];

	 StrPosCopy(srcDate,AddYear,strlen(srcDate)-3,2);
	 sprintf_P(SYear,PSTR("20%s"),AddYear);
    5e26:	00 d0       	rcall	.+0      	; 0x5e28 <GenerateGeniusCode+0x48>
    5e28:	00 d0       	rcall	.+0      	; 0x5e2a <GenerateGeniusCode+0x4a>
    5e2a:	00 d0       	rcall	.+0      	; 0x5e2c <GenerateGeniusCode+0x4c>
    5e2c:	ed b7       	in	r30, 0x3d	; 61
    5e2e:	fe b7       	in	r31, 0x3e	; 62
    5e30:	31 96       	adiw	r30, 0x01	; 1
    5e32:	8e 01       	movw	r16, r28
    5e34:	0c 5f       	subi	r16, 0xFC	; 252
    5e36:	1f 4f       	sbci	r17, 0xFF	; 255
    5e38:	ad b7       	in	r26, 0x3d	; 61
    5e3a:	be b7       	in	r27, 0x3e	; 62
    5e3c:	12 96       	adiw	r26, 0x02	; 2
    5e3e:	1c 93       	st	X, r17
    5e40:	0e 93       	st	-X, r16
    5e42:	11 97       	sbiw	r26, 0x01	; 1
    5e44:	89 e7       	ldi	r24, 0x79	; 121
    5e46:	97 e1       	ldi	r25, 0x17	; 23
    5e48:	93 83       	std	Z+3, r25	; 0x03
    5e4a:	82 83       	std	Z+2, r24	; 0x02
    5e4c:	ce 01       	movw	r24, r28
    5e4e:	01 96       	adiw	r24, 0x01	; 1
    5e50:	95 83       	std	Z+5, r25	; 0x05
    5e52:	84 83       	std	Z+4, r24	; 0x04
    5e54:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	 StrPosPaste(SYear,srcDate,strlen(srcDate)-2,strlen(SYear));
    5e58:	d7 01       	movw	r26, r14
    5e5a:	0d 90       	ld	r0, X+
    5e5c:	00 20       	and	r0, r0
    5e5e:	e9 f7       	brne	.-6      	; 0x5e5a <GenerateGeniusCode+0x7a>
    5e60:	9d 01       	movw	r18, r26
    5e62:	21 50       	subi	r18, 0x01	; 1
    5e64:	30 40       	sbci	r19, 0x00	; 0
    5e66:	2e 19       	sub	r18, r14
    5e68:	3f 09       	sbc	r19, r15
    5e6a:	d8 01       	movw	r26, r16
    5e6c:	0d 90       	ld	r0, X+
    5e6e:	00 20       	and	r0, r0
    5e70:	e9 f7       	brne	.-6      	; 0x5e6c <GenerateGeniusCode+0x8c>
    5e72:	11 97       	sbiw	r26, 0x01	; 1
    5e74:	a0 1b       	sub	r26, r16
    5e76:	b1 0b       	sbc	r27, r17
    5e78:	22 50       	subi	r18, 0x02	; 2
    5e7a:	30 40       	sbci	r19, 0x00	; 0
    5e7c:	b7 01       	movw	r22, r14
    5e7e:	62 0f       	add	r22, r18
    5e80:	73 1f       	adc	r23, r19
    5e82:	2e 5f       	subi	r18, 0xFE	; 254
    5e84:	3f 4f       	sbci	r19, 0xFF	; 255
    5e86:	40 e0       	ldi	r20, 0x00	; 0
    5e88:	50 e0       	ldi	r21, 0x00	; 0
    5e8a:	ed b7       	in	r30, 0x3d	; 61
    5e8c:	fe b7       	in	r31, 0x3e	; 62
    5e8e:	36 96       	adiw	r30, 0x06	; 6
    5e90:	0f b6       	in	r0, 0x3f	; 63
    5e92:	f8 94       	cli
    5e94:	fe bf       	out	0x3e, r31	; 62
    5e96:	0f be       	out	0x3f, r0	; 63
    5e98:	ed bf       	out	0x3d, r30	; 61
    5e9a:	09 c0       	rjmp	.+18     	; 0x5eae <GenerateGeniusCode+0xce>
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    5e9c:	f8 01       	movw	r30, r16
    5e9e:	e4 0f       	add	r30, r20
    5ea0:	f5 1f       	adc	r31, r21
    5ea2:	80 81       	ld	r24, Z
    5ea4:	fb 01       	movw	r30, r22
    5ea6:	81 93       	st	Z+, r24
    5ea8:	bf 01       	movw	r22, r30
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5eaa:	4f 5f       	subi	r20, 0xFF	; 255
    5eac:	5f 4f       	sbci	r21, 0xFF	; 255
    5eae:	4a 17       	cp	r20, r26
    5eb0:	5b 07       	cpc	r21, r27
    5eb2:	a0 f3       	brcs	.-24     	; 0x5e9c <GenerateGeniusCode+0xbc>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    5eb4:	ae 0d       	add	r26, r14
    5eb6:	bf 1d       	adc	r27, r15
    5eb8:	a2 0f       	add	r26, r18
    5eba:	b3 1f       	adc	r27, r19
    5ebc:	12 97       	sbiw	r26, 0x02	; 2
    5ebe:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
	        sprintf_P(strSend,PSTR("[%s]"),srcDate);
			_uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
    5ec0:	00 d0       	rcall	.+0      	; 0x5ec2 <GenerateGeniusCode+0xe2>
    5ec2:	00 d0       	rcall	.+0      	; 0x5ec4 <GenerateGeniusCode+0xe4>
    5ec4:	00 d0       	rcall	.+0      	; 0x5ec6 <GenerateGeniusCode+0xe6>
    5ec6:	ed b7       	in	r30, 0x3d	; 61
    5ec8:	fe b7       	in	r31, 0x3e	; 62
    5eca:	31 96       	adiw	r30, 0x01	; 1
    5ecc:	ad b7       	in	r26, 0x3d	; 61
    5ece:	be b7       	in	r27, 0x3e	; 62
    5ed0:	12 96       	adiw	r26, 0x02	; 2
    5ed2:	bc 92       	st	X, r11
    5ed4:	ae 92       	st	-X, r10
    5ed6:	11 97       	sbiw	r26, 0x01	; 1
    5ed8:	86 e7       	ldi	r24, 0x76	; 118
    5eda:	97 e1       	ldi	r25, 0x17	; 23
    5edc:	93 83       	std	Z+3, r25	; 0x03
    5ede:	82 83       	std	Z+2, r24	; 0x02
    5ee0:	c4 82       	std	Z+4, r12	; 0x04
    5ee2:	15 82       	std	Z+5, r1	; 0x05
    5ee4:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    5ee8:	dd 24       	eor	r13, r13
    5eea:	d3 94       	inc	r13
    5eec:	ed b7       	in	r30, 0x3d	; 61
    5eee:	fe b7       	in	r31, 0x3e	; 62
    5ef0:	36 96       	adiw	r30, 0x06	; 6
    5ef2:	0f b6       	in	r0, 0x3f	; 63
    5ef4:	f8 94       	cli
    5ef6:	fe bf       	out	0x3e, r31	; 62
    5ef8:	0f be       	out	0x3f, r0	; 63
    5efa:	ed bf       	out	0x3d, r30	; 61
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
    5efc:	f0 ed       	ldi	r31, 0xD0	; 208
    5efe:	cf 0e       	add	r12, r31
    5f00:	0f c0       	rjmp	.+30     	; 0x5f20 <GenerateGeniusCode+0x140>
    5f02:	f7 01       	movw	r30, r14
    5f04:	e0 0f       	add	r30, r16
    5f06:	f1 1f       	adc	r31, r17
    5f08:	40 81       	ld	r20, Z
    5f0a:	40 53       	subi	r20, 0x30	; 48
    5f0c:	80 e0       	ldi	r24, 0x00	; 0
    5f0e:	6c 2d       	mov	r22, r12
    5f10:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <GeniusCalc>
    5f14:	0a 0d       	add	r16, r10
    5f16:	1b 1d       	adc	r17, r11
    5f18:	80 5d       	subi	r24, 0xD0	; 208
    5f1a:	d8 01       	movw	r26, r16
    5f1c:	8c 93       	st	X, r24
			_uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
    5f1e:	d3 94       	inc	r13
    5f20:	0d 2d       	mov	r16, r13
    5f22:	10 e0       	ldi	r17, 0x00	; 0
    5f24:	d7 01       	movw	r26, r14
    5f26:	0d 90       	ld	r0, X+
    5f28:	00 20       	and	r0, r0
    5f2a:	e9 f7       	brne	.-6      	; 0x5f26 <GenerateGeniusCode+0x146>
    5f2c:	11 97       	sbiw	r26, 0x01	; 1
    5f2e:	ae 19       	sub	r26, r14
    5f30:	bf 09       	sbc	r27, r15
    5f32:	0a 17       	cp	r16, r26
    5f34:	1b 07       	cpc	r17, r27
    5f36:	28 f3       	brcs	.-54     	; 0x5f02 <GenerateGeniusCode+0x122>
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
	 }strDestCode[strlen(srcDate)]=0;
    5f38:	aa 0d       	add	r26, r10
    5f3a:	bb 1d       	adc	r27, r11
    5f3c:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
       sprintf_P(strSend,PSTR("1st:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif

	 WrapCode(strDestCode);
    5f3e:	c5 01       	movw	r24, r10
    5f40:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <WrapCode>
	 #ifdef DEBUG_GENIUS_CODE
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif
}
    5f44:	28 96       	adiw	r28, 0x08	; 8
    5f46:	0f b6       	in	r0, 0x3f	; 63
    5f48:	f8 94       	cli
    5f4a:	de bf       	out	0x3e, r29	; 62
    5f4c:	0f be       	out	0x3f, r0	; 63
    5f4e:	cd bf       	out	0x3d, r28	; 61
    5f50:	cf 91       	pop	r28
    5f52:	df 91       	pop	r29
    5f54:	1f 91       	pop	r17
    5f56:	0f 91       	pop	r16
    5f58:	ff 90       	pop	r15
    5f5a:	ef 90       	pop	r14
    5f5c:	df 90       	pop	r13
    5f5e:	cf 90       	pop	r12
    5f60:	bf 90       	pop	r11
    5f62:	af 90       	pop	r10
    5f64:	08 95       	ret

00005f66 <GeneratePrintInit>:
	IsBusyMsg11=True;
}



void GeneratePrintInit(){//Create Initialize Print 
    5f66:	cf 92       	push	r12
    5f68:	df 92       	push	r13
    5f6a:	ef 92       	push	r14
    5f6c:	ff 92       	push	r15
    5f6e:	0f 93       	push	r16
    5f70:	1f 93       	push	r17
    5f72:	df 93       	push	r29
    5f74:	cf 93       	push	r28
    5f76:	cd b7       	in	r28, 0x3d	; 61
    5f78:	de b7       	in	r29, 0x3e	; 62
    5f7a:	62 97       	sbiw	r28, 0x12	; 18
    5f7c:	0f b6       	in	r0, 0x3f	; 63
    5f7e:	f8 94       	cli
    5f80:	de bf       	out	0x3e, r29	; 62
    5f82:	0f be       	out	0x3f, r0	; 63
    5f84:	cd bf       	out	0x3d, r28	; 61
     char strVernum[6],strVerdate[12];
	 sprintf_P(strVernum,PSTR(VERSION_NUM));
    5f86:	00 d0       	rcall	.+0      	; 0x5f88 <GeneratePrintInit+0x22>
    5f88:	00 d0       	rcall	.+0      	; 0x5f8a <GeneratePrintInit+0x24>
    5f8a:	6e 01       	movw	r12, r28
    5f8c:	08 94       	sec
    5f8e:	c1 1c       	adc	r12, r1
    5f90:	d1 1c       	adc	r13, r1
    5f92:	ad b7       	in	r26, 0x3d	; 61
    5f94:	be b7       	in	r27, 0x3e	; 62
    5f96:	12 96       	adiw	r26, 0x02	; 2
    5f98:	dc 92       	st	X, r13
    5f9a:	ce 92       	st	-X, r12
    5f9c:	11 97       	sbiw	r26, 0x01	; 1
    5f9e:	88 ef       	ldi	r24, 0xF8	; 248
    5fa0:	9c e1       	ldi	r25, 0x1C	; 28
    5fa2:	14 96       	adiw	r26, 0x04	; 4
    5fa4:	9c 93       	st	X, r25
    5fa6:	8e 93       	st	-X, r24
    5fa8:	13 97       	sbiw	r26, 0x03	; 3
    5faa:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	 sprintf_P(strVerdate,PSTR(VERSION_DATE));
    5fae:	37 e0       	ldi	r19, 0x07	; 7
    5fb0:	e3 2e       	mov	r14, r19
    5fb2:	f1 2c       	mov	r15, r1
    5fb4:	ec 0e       	add	r14, r28
    5fb6:	fd 1e       	adc	r15, r29
    5fb8:	ed b7       	in	r30, 0x3d	; 61
    5fba:	fe b7       	in	r31, 0x3e	; 62
    5fbc:	f2 82       	std	Z+2, r15	; 0x02
    5fbe:	e1 82       	std	Z+1, r14	; 0x01
    5fc0:	8d ee       	ldi	r24, 0xED	; 237
    5fc2:	9c e1       	ldi	r25, 0x1C	; 28
    5fc4:	94 83       	std	Z+4, r25	; 0x04
    5fc6:	83 83       	std	Z+3, r24	; 0x03
    5fc8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
     sprintf_P(PrintBuffer,PSTR("\nGeNiUs Ticket Printer \n Version:%s\n Last Update %s \n Hanindo Automation Solutions \n www.hanindogroup.com\n\n\n\n\n\n\n\n"),strVernum,strVerdate);
    5fcc:	00 d0       	rcall	.+0      	; 0x5fce <GeneratePrintInit+0x68>
    5fce:	00 d0       	rcall	.+0      	; 0x5fd0 <GeneratePrintInit+0x6a>
    5fd0:	ed b7       	in	r30, 0x3d	; 61
    5fd2:	fe b7       	in	r31, 0x3e	; 62
    5fd4:	31 96       	adiw	r30, 0x01	; 1
    5fd6:	0f e1       	ldi	r16, 0x1F	; 31
    5fd8:	16 e0       	ldi	r17, 0x06	; 6
    5fda:	ad b7       	in	r26, 0x3d	; 61
    5fdc:	be b7       	in	r27, 0x3e	; 62
    5fde:	12 96       	adiw	r26, 0x02	; 2
    5fe0:	1c 93       	st	X, r17
    5fe2:	0e 93       	st	-X, r16
    5fe4:	11 97       	sbiw	r26, 0x01	; 1
    5fe6:	8b e7       	ldi	r24, 0x7B	; 123
    5fe8:	9c e1       	ldi	r25, 0x1C	; 28
    5fea:	93 83       	std	Z+3, r25	; 0x03
    5fec:	82 83       	std	Z+2, r24	; 0x02
    5fee:	d5 82       	std	Z+5, r13	; 0x05
    5ff0:	c4 82       	std	Z+4, r12	; 0x04
    5ff2:	f7 82       	std	Z+7, r15	; 0x07
    5ff4:	e6 82       	std	Z+6, r14	; 0x06
    5ff6:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	 _uart_print(0,1,PrintBuffer);
    5ffa:	ed b7       	in	r30, 0x3d	; 61
    5ffc:	fe b7       	in	r31, 0x3e	; 62
    5ffe:	38 96       	adiw	r30, 0x08	; 8
    6000:	0f b6       	in	r0, 0x3f	; 63
    6002:	f8 94       	cli
    6004:	fe bf       	out	0x3e, r31	; 62
    6006:	0f be       	out	0x3f, r0	; 63
    6008:	ed bf       	out	0x3d, r30	; 61
    600a:	80 e0       	ldi	r24, 0x00	; 0
    600c:	61 e0       	ldi	r22, 0x01	; 1
    600e:	a8 01       	movw	r20, r16
    6010:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	 LengthMessage81=strlen(PrintBuffer);
    6014:	f8 01       	movw	r30, r16
    6016:	01 90       	ld	r0, Z+
    6018:	00 20       	and	r0, r0
    601a:	e9 f7       	brne	.-6      	; 0x6016 <GeneratePrintInit+0xb0>
    601c:	31 97       	sbiw	r30, 0x01	; 1
    601e:	e0 1b       	sub	r30, r16
    6020:	f1 0b       	sbc	r31, r17
    6022:	f0 93 a1 01 	sts	0x01A1, r31
    6026:	e0 93 a0 01 	sts	0x01A0, r30
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    602a:	80 e3       	ldi	r24, 0x30	; 48
    602c:	80 93 cb 01 	sts	0x01CB, r24
	 IsFreePrinting=True;
    6030:	81 e0       	ldi	r24, 0x01	; 1
    6032:	80 93 bf 01 	sts	0x01BF, r24
}
    6036:	62 96       	adiw	r28, 0x12	; 18
    6038:	0f b6       	in	r0, 0x3f	; 63
    603a:	f8 94       	cli
    603c:	de bf       	out	0x3e, r29	; 62
    603e:	0f be       	out	0x3f, r0	; 63
    6040:	cd bf       	out	0x3d, r28	; 61
    6042:	cf 91       	pop	r28
    6044:	df 91       	pop	r29
    6046:	1f 91       	pop	r17
    6048:	0f 91       	pop	r16
    604a:	ff 90       	pop	r15
    604c:	ef 90       	pop	r14
    604e:	df 90       	pop	r13
    6050:	cf 90       	pop	r12
    6052:	08 95       	ret

00006054 <FormatCurrency>:
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}


void FormatCurrency(char *strCurrency){// 5000000.00 5,000,000.00
    6054:	9f 92       	push	r9
    6056:	af 92       	push	r10
    6058:	bf 92       	push	r11
    605a:	cf 92       	push	r12
    605c:	df 92       	push	r13
    605e:	ef 92       	push	r14
    6060:	ff 92       	push	r15
    6062:	0f 93       	push	r16
    6064:	1f 93       	push	r17
    6066:	df 93       	push	r29
    6068:	cf 93       	push	r28
    606a:	cd b7       	in	r28, 0x3d	; 61
    606c:	de b7       	in	r29, 0x3e	; 62
    606e:	64 97       	sbiw	r28, 0x14	; 20
    6070:	0f b6       	in	r0, 0x3f	; 63
    6072:	f8 94       	cli
    6074:	de bf       	out	0x3e, r29	; 62
    6076:	0f be       	out	0x3f, r0	; 63
    6078:	cd bf       	out	0x3d, r28	; 61
    607a:	6c 01       	movw	r12, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    607c:	e1 99       	sbic	0x1c, 1	; 28
    607e:	fe cf       	rjmp	.-4      	; 0x607c <FormatCurrency+0x28>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6080:	8f e3       	ldi	r24, 0x3F	; 63
    6082:	90 e0       	ldi	r25, 0x00	; 0
    6084:	9f bb       	out	0x1f, r25	; 31
    6086:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6088:	e0 9a       	sbi	0x1c, 0	; 28
    608a:	9d b2       	in	r9, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    608c:	e1 99       	sbic	0x1c, 1	; 28
    608e:	fe cf       	rjmp	.-4      	; 0x608c <FormatCurrency+0x38>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6090:	8e e3       	ldi	r24, 0x3E	; 62
    6092:	90 e0       	ldi	r25, 0x00	; 0
    6094:	9f bb       	out	0x1f, r25	; 31
    6096:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6098:	e0 9a       	sbi	0x1c, 0	; 28
    609a:	3d b3       	in	r19, 0x1d	; 29
	 char CurrencyMark,DecimalMark;

	 CurrencyMark=eeprom_read_byte(&DefCurrencyMark);
	 DecimalMark=eeprom_read_byte(&DefDecimalMark);

	 Length=strlen(strCurrency);//123,456
    609c:	f6 01       	movw	r30, r12
    609e:	01 90       	ld	r0, Z+
    60a0:	00 20       	and	r0, r0
    60a2:	e9 f7       	brne	.-6      	; 0x609e <FormatCurrency+0x4a>
    60a4:	31 97       	sbiw	r30, 0x01	; 1
    60a6:	ee 2e       	mov	r14, r30
    60a8:	ec 18       	sub	r14, r12
    60aa:	fe 01       	movw	r30, r28
    60ac:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    60ae:	ce 01       	movw	r24, r28
    60b0:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    60b2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    60b4:	e8 17       	cp	r30, r24
    60b6:	f9 07       	cpc	r31, r25
    60b8:	e1 f7       	brne	.-8      	; 0x60b2 <FormatCurrency+0x5e>
    60ba:	f6 01       	movw	r30, r12
    60bc:	fe 2c       	mov	r15, r14
    60be:	80 e0       	ldi	r24, 0x00	; 0
    60c0:	20 e0       	ldi	r18, 0x00	; 0
    60c2:	09 c0       	rjmp	.+18     	; 0x60d6 <FormatCurrency+0x82>
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
    60c4:	90 81       	ld	r25, Z
    60c6:	93 17       	cp	r25, r19
    60c8:	09 f4       	brne	.+2      	; 0x60cc <FormatCurrency+0x78>
    60ca:	f8 2e       	mov	r15, r24
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
    60cc:	99 15       	cp	r25, r9
    60ce:	09 f4       	brne	.+2      	; 0x60d2 <FormatCurrency+0x7e>
    60d0:	2f 5f       	subi	r18, 0xFF	; 255
	 Length=strlen(strCurrency);//123,456
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
    60d2:	8f 5f       	subi	r24, 0xFF	; 255
    60d4:	31 96       	adiw	r30, 0x01	; 1
    60d6:	8e 15       	cp	r24, r14
    60d8:	a8 f3       	brcs	.-22     	; 0x60c4 <FormatCurrency+0x70>
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
    60da:	22 23       	and	r18, r18
    60dc:	09 f0       	breq	.+2      	; 0x60e0 <FormatCurrency+0x8c>
    60de:	5e c0       	rjmp	.+188    	; 0x619c <FormatCurrency+0x148>
    60e0:	83 e0       	ldi	r24, 0x03	; 3
    60e2:	8f 15       	cp	r24, r15
    60e4:	08 f0       	brcs	.+2      	; 0x60e8 <FormatCurrency+0x94>
    60e6:	5a c0       	rjmp	.+180    	; 0x619c <FormatCurrency+0x148>
    60e8:	40 e0       	ldi	r20, 0x00	; 0
    60ea:	20 e0       	ldi	r18, 0x00	; 0
    60ec:	30 e0       	ldi	r19, 0x00	; 0
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    60ee:	af 2c       	mov	r10, r15
    60f0:	bb 24       	eor	r11, r11
		        fmtCurrency[iPos]=CurrencyMark;
    60f2:	8e 01       	movw	r16, r28
    60f4:	0f 5f       	subi	r16, 0xFF	; 255
    60f6:	1f 4f       	sbci	r17, 0xFF	; 255
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    60f8:	c5 01       	movw	r24, r10
    60fa:	82 1b       	sub	r24, r18
    60fc:	93 0b       	sbc	r25, r19
    60fe:	63 e0       	ldi	r22, 0x03	; 3
    6100:	70 e0       	ldi	r23, 0x00	; 0
    6102:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    6106:	89 2b       	or	r24, r25
    6108:	49 f4       	brne	.+18     	; 0x611c <FormatCurrency+0xc8>
    610a:	2f 15       	cp	r18, r15
    610c:	38 f4       	brcc	.+14     	; 0x611c <FormatCurrency+0xc8>
    610e:	22 23       	and	r18, r18
    6110:	29 f0       	breq	.+10     	; 0x611c <FormatCurrency+0xc8>
		        fmtCurrency[iPos]=CurrencyMark;
    6112:	f8 01       	movw	r30, r16
    6114:	e4 0f       	add	r30, r20
    6116:	f1 1d       	adc	r31, r1
    6118:	90 82       	st	Z, r9
		        iPos++;
    611a:	4f 5f       	subi	r20, 0xFF	; 255
		        }
		        fmtCurrency[iPos]=strCurrency[i];
    611c:	d8 01       	movw	r26, r16
    611e:	a4 0f       	add	r26, r20
    6120:	b1 1d       	adc	r27, r1
    6122:	f6 01       	movw	r30, r12
    6124:	e2 0f       	add	r30, r18
    6126:	f3 1f       	adc	r31, r19
    6128:	80 81       	ld	r24, Z
    612a:	8c 93       	st	X, r24
			    iPos++;
    612c:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    612e:	f8 01       	movw	r30, r16
    6130:	e4 0f       	add	r30, r20
    6132:	f1 1d       	adc	r31, r1
    6134:	10 82       	st	Z, r1
    6136:	2f 5f       	subi	r18, 0xFF	; 255
    6138:	3f 4f       	sbci	r19, 0xFF	; 255
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
    613a:	2f 15       	cp	r18, r15
    613c:	e8 f2       	brcs	.-70     	; 0x60f8 <FormatCurrency+0xa4>
    613e:	9f 2d       	mov	r25, r15
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
    6140:	9e 01       	movw	r18, r28
    6142:	2f 5f       	subi	r18, 0xFF	; 255
    6144:	3f 4f       	sbci	r19, 0xFF	; 255
    6146:	0e c0       	rjmp	.+28     	; 0x6164 <FormatCurrency+0x110>
    6148:	d9 01       	movw	r26, r18
    614a:	a4 0f       	add	r26, r20
    614c:	b1 1d       	adc	r27, r1
    614e:	f6 01       	movw	r30, r12
    6150:	e9 0f       	add	r30, r25
    6152:	f1 1d       	adc	r31, r1
    6154:	80 81       	ld	r24, Z
    6156:	8c 93       	st	X, r24
			    iPos++;
    6158:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    615a:	f9 01       	movw	r30, r18
    615c:	e4 0f       	add	r30, r20
    615e:	f1 1d       	adc	r31, r1
    6160:	10 82       	st	Z, r1
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
    6162:	9f 5f       	subi	r25, 0xFF	; 255
    6164:	9e 15       	cp	r25, r14
    6166:	80 f3       	brcs	.-32     	; 0x6148 <FormatCurrency+0xf4>
    6168:	90 e0       	ldi	r25, 0x00	; 0
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    616a:	9e 01       	movw	r18, r28
    616c:	2f 5f       	subi	r18, 0xFF	; 255
    616e:	3f 4f       	sbci	r19, 0xFF	; 255
    6170:	09 c0       	rjmp	.+18     	; 0x6184 <FormatCurrency+0x130>
	          strCurrency[i]=fmtCurrency[i];
    6172:	f6 01       	movw	r30, r12
    6174:	ea 0f       	add	r30, r26
    6176:	fb 1f       	adc	r31, r27
    6178:	a2 0f       	add	r26, r18
    617a:	b3 1f       	adc	r27, r19
    617c:	8c 91       	ld	r24, X
    617e:	80 83       	st	Z, r24
			  strCurrency[i+1]=0;
    6180:	11 82       	std	Z+1, r1	; 0x01
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    6182:	9f 5f       	subi	r25, 0xFF	; 255
    6184:	a9 2f       	mov	r26, r25
    6186:	b0 e0       	ldi	r27, 0x00	; 0
    6188:	f9 01       	movw	r30, r18
    618a:	01 90       	ld	r0, Z+
    618c:	00 20       	and	r0, r0
    618e:	e9 f7       	brne	.-6      	; 0x618a <FormatCurrency+0x136>
    6190:	31 97       	sbiw	r30, 0x01	; 1
    6192:	e2 1b       	sub	r30, r18
    6194:	f3 0b       	sbc	r31, r19
    6196:	ae 17       	cp	r26, r30
    6198:	bf 07       	cpc	r27, r31
    619a:	58 f3       	brcs	.-42     	; 0x6172 <FormatCurrency+0x11e>
	          strCurrency[i]=fmtCurrency[i];
			  strCurrency[i+1]=0;
	      }
     }      
}
    619c:	64 96       	adiw	r28, 0x14	; 20
    619e:	0f b6       	in	r0, 0x3f	; 63
    61a0:	f8 94       	cli
    61a2:	de bf       	out	0x3e, r29	; 62
    61a4:	0f be       	out	0x3f, r0	; 63
    61a6:	cd bf       	out	0x3d, r28	; 61
    61a8:	cf 91       	pop	r28
    61aa:	df 91       	pop	r29
    61ac:	1f 91       	pop	r17
    61ae:	0f 91       	pop	r16
    61b0:	ff 90       	pop	r15
    61b2:	ef 90       	pop	r14
    61b4:	df 90       	pop	r13
    61b6:	cf 90       	pop	r12
    61b8:	bf 90       	pop	r11
    61ba:	af 90       	pop	r10
    61bc:	9f 90       	pop	r9
    61be:	08 95       	ret

000061c0 <FormatDecimal>:

void TestLocalAccount(){

}

void FormatDecimal(char *strRawData, char DecimalCfg){// 9-> 0,009 0,234 123 
    61c0:	ef 92       	push	r14
    61c2:	ff 92       	push	r15
    61c4:	0f 93       	push	r16
    61c6:	1f 93       	push	r17
    61c8:	df 93       	push	r29
    61ca:	cf 93       	push	r28
    61cc:	cd b7       	in	r28, 0x3d	; 61
    61ce:	de b7       	in	r29, 0x3e	; 62
    61d0:	64 97       	sbiw	r28, 0x14	; 20
    61d2:	0f b6       	in	r0, 0x3f	; 63
    61d4:	f8 94       	cli
    61d6:	de bf       	out	0x3e, r29	; 62
    61d8:	0f be       	out	0x3f, r0	; 63
    61da:	cd bf       	out	0x3d, r28	; 61
    61dc:	8c 01       	movw	r16, r24
     char i,iPos,CommaPos,Length=0;                 //1->0,01 
	 char strDecimalFormated[20];
	 char DecPointMark;
     if (DecimalCfg>0){    
    61de:	66 23       	and	r22, r22
    61e0:	09 f4       	brne	.+2      	; 0x61e4 <FormatDecimal+0x24>
    61e2:	56 c0       	rjmp	.+172    	; 0x6290 <FormatDecimal+0xd0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    61e4:	e1 99       	sbic	0x1c, 1	; 28
    61e6:	fe cf       	rjmp	.-4      	; 0x61e4 <FormatDecimal+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    61e8:	8e e3       	ldi	r24, 0x3E	; 62
    61ea:	90 e0       	ldi	r25, 0x00	; 0
    61ec:	9f bb       	out	0x1f, r25	; 31
    61ee:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    61f0:	e0 9a       	sbi	0x1c, 0	; 28
    61f2:	ed b2       	in	r14, 0x1d	; 29
		 DecPointMark=eeprom_read_byte(&DefDecimalMark);	 
		 Length=strlen(strRawData);
    61f4:	f8 01       	movw	r30, r16
    61f6:	01 90       	ld	r0, Z+
    61f8:	00 20       	and	r0, r0
    61fa:	e9 f7       	brne	.-6      	; 0x61f6 <FormatDecimal+0x36>
    61fc:	31 97       	sbiw	r30, 0x01	; 1
    61fe:	3e 2f       	mov	r19, r30
    6200:	30 1b       	sub	r19, r16

		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
    6202:	63 17       	cp	r22, r19
    6204:	b8 f5       	brcc	.+110    	; 0x6274 <FormatDecimal+0xb4>
    6206:	f3 2e       	mov	r15, r19
    6208:	f6 1a       	sub	r15, r22
    620a:	b8 01       	movw	r22, r16
    620c:	d8 01       	movw	r26, r16
    620e:	90 e0       	ldi	r25, 0x00	; 0
    6210:	20 e0       	ldi	r18, 0x00	; 0

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
				 strDecimalFormated[iPos]=DecPointMark;
    6212:	ae 01       	movw	r20, r28
    6214:	4f 5f       	subi	r20, 0xFF	; 255
    6216:	5f 4f       	sbci	r21, 0xFF	; 255
    6218:	0e c0       	rjmp	.+28     	; 0x6236 <FormatDecimal+0x76>
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
    621a:	2f 15       	cp	r18, r15
    621c:	29 f4       	brne	.+10     	; 0x6228 <FormatDecimal+0x68>
				 strDecimalFormated[iPos]=DecPointMark;
    621e:	fa 01       	movw	r30, r20
    6220:	e9 0f       	add	r30, r25
    6222:	f1 1d       	adc	r31, r1
    6224:	e0 82       	st	Z, r14
				 iPos++;
    6226:	9f 5f       	subi	r25, 0xFF	; 255
			}
			strDecimalFormated[iPos]=strRawData[i];
    6228:	fa 01       	movw	r30, r20
    622a:	e9 0f       	add	r30, r25
    622c:	f1 1d       	adc	r31, r1
    622e:	8d 91       	ld	r24, X+
    6230:	80 83       	st	Z, r24
			//strDecimalFormated[iPos+1]=0;
			iPos++;
    6232:	9f 5f       	subi	r25, 0xFF	; 255
			 CommaPos=1;
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
    6234:	2f 5f       	subi	r18, 0xFF	; 255
    6236:	23 17       	cp	r18, r19
    6238:	80 f3       	brcs	.-32     	; 0x621a <FormatDecimal+0x5a>
				 iPos++;
			}
			strDecimalFormated[iPos]=strRawData[i];
			//strDecimalFormated[iPos+1]=0;
			iPos++;
		 }strDecimalFormated[iPos]=0;
    623a:	9e 01       	movw	r18, r28
    623c:	2f 5f       	subi	r18, 0xFF	; 255
    623e:	3f 4f       	sbci	r19, 0xFF	; 255
    6240:	f9 01       	movw	r30, r18
    6242:	e9 0f       	add	r30, r25
    6244:	f1 1d       	adc	r31, r1
    6246:	10 82       	st	Z, r1
		 
         //_uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
    6248:	f9 01       	movw	r30, r18
    624a:	01 90       	ld	r0, Z+
    624c:	00 20       	and	r0, r0
    624e:	e9 f7       	brne	.-6      	; 0x624a <FormatDecimal+0x8a>
    6250:	31 97       	sbiw	r30, 0x01	; 1
    6252:	9e 2f       	mov	r25, r30
    6254:	92 1b       	sub	r25, r18
    6256:	d9 01       	movw	r26, r18
    6258:	04 c0       	rjmp	.+8      	; 0x6262 <FormatDecimal+0xa2>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
    625a:	8d 91       	ld	r24, X+
    625c:	fb 01       	movw	r30, r22
    625e:	81 93       	st	Z+, r24
    6260:	bf 01       	movw	r22, r30
		 }strDecimalFormated[iPos]=0;
		 
         //_uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
		 for(i=0;i<Length;i++){
    6262:	8a 2f       	mov	r24, r26
    6264:	82 1b       	sub	r24, r18
    6266:	89 17       	cp	r24, r25
    6268:	c0 f3       	brcs	.-16     	; 0x625a <FormatDecimal+0x9a>
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
    626a:	09 0f       	add	r16, r25
    626c:	11 1d       	adc	r17, r1
    626e:	f8 01       	movw	r30, r16
    6270:	10 82       	st	Z, r1
    6272:	0e c0       	rjmp	.+28     	; 0x6290 <FormatDecimal+0xd0>
		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
		 else CommaPos=1;


		 if (Length<=DecimalCfg){// 123 -> 0123
			 AddZeroLead(strRawData,(DecimalCfg+1));
    6274:	6f 5f       	subi	r22, 0xFF	; 255
    6276:	c8 01       	movw	r24, r16
    6278:	0e 94 3c 25 	call	0x4a78	; 0x4a78 <AddZeroLead>
			 //AddZeroLead(strRawData,(DecimalCfg+2));
			 Length=strlen(strRawData);
    627c:	f8 01       	movw	r30, r16
    627e:	01 90       	ld	r0, Z+
    6280:	00 20       	and	r0, r0
    6282:	e9 f7       	brne	.-6      	; 0x627e <FormatDecimal+0xbe>
    6284:	31 97       	sbiw	r30, 0x01	; 1
    6286:	3e 2f       	mov	r19, r30
    6288:	30 1b       	sub	r19, r16
    628a:	ff 24       	eor	r15, r15
    628c:	f3 94       	inc	r15
    628e:	bd cf       	rjmp	.-134    	; 0x620a <FormatDecimal+0x4a>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
	 }
          //_uart_print(1,1,strRawData); 
}
    6290:	64 96       	adiw	r28, 0x14	; 20
    6292:	0f b6       	in	r0, 0x3f	; 63
    6294:	f8 94       	cli
    6296:	de bf       	out	0x3e, r29	; 62
    6298:	0f be       	out	0x3f, r0	; 63
    629a:	cd bf       	out	0x3d, r28	; 61
    629c:	cf 91       	pop	r28
    629e:	df 91       	pop	r29
    62a0:	1f 91       	pop	r17
    62a2:	0f 91       	pop	r16
    62a4:	ff 90       	pop	r15
    62a6:	ef 90       	pop	r14
    62a8:	08 95       	ret

000062aa <NormalizeDecimal>:
	 Result=(SigmaSum%255);
	 if (Result==0)Result=255;
   return Result;
}

void NormalizeDecimal(char CurrentDecimal, char NewDecimal, char *Result){// 01234567,89
    62aa:	68 2f       	mov	r22, r24
    62ac:	ca 01       	movw	r24, r20
		 StrPosCopy(Result,SResult,DeltaDec,Length-DeltaDec);
		 	           
	 
     }
*/
     FormatDecimal(Result,CurrentDecimal);
    62ae:	0e 94 e0 30 	call	0x61c0	; 0x61c0 <FormatDecimal>
}
    62b2:	08 95       	ret

000062b4 <FormatTotalizerVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatTotalizerVolume(char *strRawVolume){//96->0,96 
    62b4:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    62b6:	e1 99       	sbic	0x1c, 1	; 28
    62b8:	fe cf       	rjmp	.-4      	; 0x62b6 <FormatTotalizerVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    62ba:	8c e3       	ldi	r24, 0x3C	; 60
    62bc:	90 e0       	ldi	r25, 0x00	; 0
    62be:	9f bb       	out	0x1f, r25	; 31
    62c0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    62c2:	e0 9a       	sbi	0x1c, 0	; 28
    62c4:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    62c6:	c9 01       	movw	r24, r18
    62c8:	0e 94 e0 30 	call	0x61c0	; 0x61c0 <FormatDecimal>
}
    62cc:	08 95       	ret

000062ce <FormatTotalizerMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}

void FormatTotalizerMoney(char *strRawMoney){
    62ce:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    62d0:	e1 99       	sbic	0x1c, 1	; 28
    62d2:	fe cf       	rjmp	.-4      	; 0x62d0 <FormatTotalizerMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    62d4:	8d e3       	ldi	r24, 0x3D	; 61
    62d6:	90 e0       	ldi	r25, 0x00	; 0
    62d8:	9f bb       	out	0x1f, r25	; 31
    62da:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    62dc:	e0 9a       	sbi	0x1c, 0	; 28
    62de:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    62e0:	c9 01       	movw	r24, r18
    62e2:	0e 94 e0 30 	call	0x61c0	; 0x61c0 <FormatDecimal>
}
    62e6:	08 95       	ret

000062e8 <FormatVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatVolume(char *strRawVolume){//96->0,96 
    62e8:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    62ea:	e1 99       	sbic	0x1c, 1	; 28
    62ec:	fe cf       	rjmp	.-4      	; 0x62ea <FormatVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    62ee:	8a e3       	ldi	r24, 0x3A	; 58
    62f0:	90 e0       	ldi	r25, 0x00	; 0
    62f2:	9f bb       	out	0x1f, r25	; 31
    62f4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    62f6:	e0 9a       	sbi	0x1c, 0	; 28
    62f8:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    62fa:	c9 01       	movw	r24, r18
    62fc:	0e 94 e0 30 	call	0x61c0	; 0x61c0 <FormatDecimal>
}
    6300:	08 95       	ret

00006302 <FormatMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
}

void FormatMoney(char *strRawMoney){
    6302:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6304:	e1 99       	sbic	0x1c, 1	; 28
    6306:	fe cf       	rjmp	.-4      	; 0x6304 <FormatMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6308:	8b e3       	ldi	r24, 0x3B	; 59
    630a:	90 e0       	ldi	r25, 0x00	; 0
    630c:	9f bb       	out	0x1f, r25	; 31
    630e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6310:	e0 9a       	sbi	0x1c, 0	; 28
    6312:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    6314:	c9 01       	movw	r24, r18
    6316:	0e 94 e0 30 	call	0x61c0	; 0x61c0 <FormatDecimal>
}
    631a:	08 95       	ret

0000631c <FormatPrice>:
		 }strRawData[Length]=0;
	 }
          //_uart_print(1,1,strRawData); 
}

void FormatPrice(char *strRawPrice){
    631c:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    631e:	e1 99       	sbic	0x1c, 1	; 28
    6320:	fe cf       	rjmp	.-4      	; 0x631e <FormatPrice+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6322:	89 e3       	ldi	r24, 0x39	; 57
    6324:	90 e0       	ldi	r25, 0x00	; 0
    6326:	9f bb       	out	0x1f, r25	; 31
    6328:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    632a:	e0 9a       	sbi	0x1c, 0	; 28
    632c:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
    632e:	c9 01       	movw	r24, r18
    6330:	0e 94 e0 30 	call	0x61c0	; 0x61c0 <FormatDecimal>
}
    6334:	08 95       	ret

00006336 <systemGenerateReport>:
	 }
}

//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
//			cmdPrint=procMessage81();
void systemGenerateReport(){
    6336:	2f 92       	push	r2
    6338:	3f 92       	push	r3
    633a:	4f 92       	push	r4
    633c:	5f 92       	push	r5
    633e:	6f 92       	push	r6
    6340:	7f 92       	push	r7
    6342:	8f 92       	push	r8
    6344:	9f 92       	push	r9
    6346:	af 92       	push	r10
    6348:	bf 92       	push	r11
    634a:	cf 92       	push	r12
    634c:	df 92       	push	r13
    634e:	ef 92       	push	r14
    6350:	ff 92       	push	r15
    6352:	0f 93       	push	r16
    6354:	1f 93       	push	r17
    6356:	df 93       	push	r29
    6358:	cf 93       	push	r28
    635a:	cd b7       	in	r28, 0x3d	; 61
    635c:	de b7       	in	r29, 0x3e	; 62
    635e:	c8 5f       	subi	r28, 0xF8	; 248
    6360:	d0 40       	sbci	r29, 0x00	; 0
    6362:	0f b6       	in	r0, 0x3f	; 63
    6364:	f8 94       	cli
    6366:	de bf       	out	0x3e, r29	; 62
    6368:	0f be       	out	0x3f, r0	; 63
    636a:	cd bf       	out	0x3d, r28	; 61
	   char strTabSpace[20],strTabSpace2[20];
	   char iTotal;//,PadLength;
	   char sPrice[10],strProductPrice[20];
	   char FIPAddr;

     switch(stGenerateReport){
    636c:	10 91 14 02 	lds	r17, 0x0214
    6370:	16 30       	cpi	r17, 0x06	; 6
    6372:	09 f4       	brne	.+2      	; 0x6376 <systemGenerateReport+0x40>
    6374:	5d c2       	rjmp	.+1210   	; 0x6830 <systemGenerateReport+0x4fa>
    6376:	17 30       	cpi	r17, 0x07	; 7
    6378:	98 f4       	brcc	.+38     	; 0x63a0 <systemGenerateReport+0x6a>
    637a:	12 30       	cpi	r17, 0x02	; 2
    637c:	09 f4       	brne	.+2      	; 0x6380 <systemGenerateReport+0x4a>
    637e:	a7 c0       	rjmp	.+334    	; 0x64ce <systemGenerateReport+0x198>
    6380:	13 30       	cpi	r17, 0x03	; 3
    6382:	38 f4       	brcc	.+14     	; 0x6392 <systemGenerateReport+0x5c>
    6384:	11 23       	and	r17, r17
    6386:	31 f1       	breq	.+76     	; 0x63d4 <systemGenerateReport+0x9e>
    6388:	11 30       	cpi	r17, 0x01	; 1
    638a:	11 f0       	breq	.+4      	; 0x6390 <systemGenerateReport+0x5a>
    638c:	0c 94 b4 3c 	jmp	0x7968	; 0x7968 <systemGenerateReport+0x1632>
    6390:	2d c0       	rjmp	.+90     	; 0x63ec <systemGenerateReport+0xb6>
    6392:	14 30       	cpi	r17, 0x04	; 4
    6394:	09 f4       	brne	.+2      	; 0x6398 <systemGenerateReport+0x62>
    6396:	c8 c1       	rjmp	.+912    	; 0x6728 <systemGenerateReport+0x3f2>
    6398:	15 30       	cpi	r17, 0x05	; 5
    639a:	08 f0       	brcs	.+2      	; 0x639e <systemGenerateReport+0x68>
    639c:	4c c7       	rjmp	.+3736   	; 0x7236 <systemGenerateReport+0xf00>
    639e:	bb c1       	rjmp	.+886    	; 0x6716 <systemGenerateReport+0x3e0>
    63a0:	19 30       	cpi	r17, 0x09	; 9
    63a2:	09 f4       	brne	.+2      	; 0x63a6 <systemGenerateReport+0x70>
    63a4:	48 c7       	rjmp	.+3728   	; 0x7236 <systemGenerateReport+0xf00>
    63a6:	1a 30       	cpi	r17, 0x0A	; 10
    63a8:	40 f4       	brcc	.+16     	; 0x63ba <systemGenerateReport+0x84>
    63aa:	17 30       	cpi	r17, 0x07	; 7
    63ac:	09 f4       	brne	.+2      	; 0x63b0 <systemGenerateReport+0x7a>
    63ae:	aa c2       	rjmp	.+1364   	; 0x6904 <systemGenerateReport+0x5ce>
    63b0:	18 30       	cpi	r17, 0x08	; 8
    63b2:	11 f0       	breq	.+4      	; 0x63b8 <systemGenerateReport+0x82>
    63b4:	0c 94 b4 3c 	jmp	0x7968	; 0x7968 <systemGenerateReport+0x1632>
    63b8:	b3 c2       	rjmp	.+1382   	; 0x6920 <systemGenerateReport+0x5ea>
    63ba:	1b 30       	cpi	r17, 0x0B	; 11
    63bc:	11 f4       	brne	.+4      	; 0x63c2 <systemGenerateReport+0x8c>
    63be:	0c 94 a7 3c 	jmp	0x794e	; 0x794e <systemGenerateReport+0x1618>
    63c2:	1b 30       	cpi	r17, 0x0B	; 11
    63c4:	08 f4       	brcc	.+2      	; 0x63c8 <systemGenerateReport+0x92>
    63c6:	3e c7       	rjmp	.+3708   	; 0x7244 <systemGenerateReport+0xf0e>
    63c8:	1c 30       	cpi	r17, 0x0C	; 12
    63ca:	11 f0       	breq	.+4      	; 0x63d0 <systemGenerateReport+0x9a>
    63cc:	0c 94 b4 3c 	jmp	0x7968	; 0x7968 <systemGenerateReport+0x1632>
    63d0:	0c 94 af 3c 	jmp	0x795e	; 0x795e <systemGenerateReport+0x1628>
	 case grScanAction://Wait for Complete incoming Totalizer data	      
		  if (IsGenerateReport==True){
    63d4:	80 91 99 01 	lds	r24, 0x0199
    63d8:	81 30       	cpi	r24, 0x01	; 1
    63da:	11 f0       	breq	.+4      	; 0x63e0 <systemGenerateReport+0xaa>
    63dc:	0c 94 b4 3c 	jmp	0x7968	; 0x7968 <systemGenerateReport+0x1632>
		      IsGenerateReport=False;
    63e0:	10 92 99 01 	sts	0x0199, r1
			  IsFinishPrintingTotalizer=False;
    63e4:	10 92 9a 01 	sts	0x019A, r1
    63e8:	0c 94 ac 3c 	jmp	0x7958	; 0x7958 <systemGenerateReport+0x1622>
			  stGenerateReport=grInitData;
		  }
	      break;
	 case grInitData:
	      xPump=1;
    63ec:	10 93 13 02 	sts	0x0213, r17
		  xNozzle=1;
    63f0:	10 93 12 02 	sts	0x0212, r17
		  RepPos=0;
    63f4:	10 92 03 02 	sts	0x0203, r1
    63f8:	10 92 02 02 	sts	0x0202, r1
    63fc:	ef e1       	ldi	r30, 0x1F	; 31
    63fe:	f6 e0       	ldi	r31, 0x06	; 6
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    6400:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6402:	87 e0       	ldi	r24, 0x07	; 7
    6404:	e0 3b       	cpi	r30, 0xB0	; 176
    6406:	f8 07       	cpc	r31, r24
    6408:	d9 f7       	brne	.-10     	; 0x6400 <systemGenerateReport+0xca>
    640a:	fe 01       	movw	r30, r28
    640c:	eb 55       	subi	r30, 0x5B	; 91
    640e:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6410:	ce 01       	movw	r24, r28
    6412:	8b 50       	subi	r24, 0x0B	; 11
    6414:	9f 4f       	sbci	r25, 0xFF	; 255
    6416:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6418:	e8 17       	cp	r30, r24
    641a:	f9 07       	cpc	r31, r25
    641c:	e1 f7       	brne	.-8      	; 0x6416 <systemGenerateReport+0xe0>
    641e:	fe 01       	movw	r30, r28
    6420:	f7 96       	adiw	r30, 0x37	; 55
	     strMemory[i]=data;
    6422:	cf 01       	movw	r24, r30
    6424:	0f 96       	adiw	r24, 0x0f	; 15
    6426:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6428:	e8 17       	cp	r30, r24
    642a:	f9 07       	cpc	r31, r25
    642c:	e1 f7       	brne	.-8      	; 0x6426 <systemGenerateReport+0xf0>
    642e:	fe 01       	movw	r30, r28
    6430:	ea 5b       	subi	r30, 0xBA	; 186
    6432:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6434:	cf 01       	movw	r24, r30
    6436:	0f 96       	adiw	r24, 0x0f	; 15
    6438:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    643a:	e8 17       	cp	r30, r24
    643c:	f9 07       	cpc	r31, r25
    643e:	e1 f7       	brne	.-8      	; 0x6438 <systemGenerateReport+0x102>
    6440:	ec e4       	ldi	r30, 0x4C	; 76
    6442:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    6444:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6446:	9a e0       	ldi	r25, 0x0A	; 10
    6448:	e0 36       	cpi	r30, 0x60	; 96
    644a:	f9 07       	cpc	r31, r25
    644c:	d9 f7       	brne	.-10     	; 0x6444 <systemGenerateReport+0x10e>
    644e:	ed ef       	ldi	r30, 0xFD	; 253
    6450:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    6452:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6454:	ab e0       	ldi	r26, 0x0B	; 11
    6456:	e1 31       	cpi	r30, 0x11	; 17
    6458:	fa 07       	cpc	r31, r26
    645a:	d9 f7       	brne	.-10     	; 0x6452 <systemGenerateReport+0x11c>
    645c:	e8 e5       	ldi	r30, 0x58	; 88
    645e:	fe e0       	ldi	r31, 0x0E	; 14
	     strMemory[i]=data;
    6460:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6462:	be e0       	ldi	r27, 0x0E	; 14
    6464:	e7 36       	cpi	r30, 0x67	; 103
    6466:	fb 07       	cpc	r31, r27
    6468:	d9 f7       	brne	.-10     	; 0x6460 <systemGenerateReport+0x12a>
    646a:	ed e2       	ldi	r30, 0x2D	; 45
    646c:	fb e0       	ldi	r31, 0x0B	; 11
	     strMemory[i]=data;
    646e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6470:	8b e0       	ldi	r24, 0x0B	; 11
    6472:	ec 33       	cpi	r30, 0x3C	; 60
    6474:	f8 07       	cpc	r31, r24
    6476:	d9 f7       	brne	.-10     	; 0x646e <systemGenerateReport+0x138>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6478:	e1 99       	sbic	0x1c, 1	; 28
    647a:	fe cf       	rjmp	.-4      	; 0x6478 <systemGenerateReport+0x142>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    647c:	8f e3       	ldi	r24, 0x3F	; 63
    647e:	91 e0       	ldi	r25, 0x01	; 1
    6480:	9f bb       	out	0x1f, r25	; 31
    6482:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6484:	e0 9a       	sbi	0x1c, 0	; 28
    6486:	2d b3       	in	r18, 0x1d	; 29
		  FillChar(strTotalMoney,sizeof(strTotalMoney),0);


		  FillChar(strDeltaMoney,sizeof(strDeltaMoney),0);
		  FillChar(strDeltaVolume,sizeof(strDeltaVolume),0);
		  sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    6488:	00 d0       	rcall	.+0      	; 0x648a <systemGenerateReport+0x154>
    648a:	00 d0       	rcall	.+0      	; 0x648c <systemGenerateReport+0x156>
    648c:	00 d0       	rcall	.+0      	; 0x648e <systemGenerateReport+0x158>
    648e:	ed b7       	in	r30, 0x3d	; 61
    6490:	fe b7       	in	r31, 0x3e	; 62
    6492:	31 96       	adiw	r30, 0x01	; 1
    6494:	83 e9       	ldi	r24, 0x93	; 147
    6496:	9e e0       	ldi	r25, 0x0E	; 14
    6498:	ad b7       	in	r26, 0x3d	; 61
    649a:	be b7       	in	r27, 0x3e	; 62
    649c:	12 96       	adiw	r26, 0x02	; 2
    649e:	9c 93       	st	X, r25
    64a0:	8e 93       	st	-X, r24
    64a2:	11 97       	sbiw	r26, 0x01	; 1
    64a4:	8b e9       	ldi	r24, 0x9B	; 155
    64a6:	95 e0       	ldi	r25, 0x05	; 5
    64a8:	93 83       	std	Z+3, r25	; 0x03
    64aa:	82 83       	std	Z+2, r24	; 0x02
    64ac:	24 83       	std	Z+4, r18	; 0x04
    64ae:	15 82       	std	Z+5, r1	; 0x05
    64b0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>

          stGenerateReport=grCreateReportHeader;
    64b4:	82 e0       	ldi	r24, 0x02	; 2
    64b6:	80 93 14 02 	sts	0x0214, r24
    64ba:	ed b7       	in	r30, 0x3d	; 61
    64bc:	fe b7       	in	r31, 0x3e	; 62
    64be:	36 96       	adiw	r30, 0x06	; 6
    64c0:	0f b6       	in	r0, 0x3f	; 63
    64c2:	f8 94       	cli
    64c4:	fe bf       	out	0x3e, r31	; 62
    64c6:	0f be       	out	0x3f, r0	; 63
    64c8:	ed bf       	out	0x3d, r30	; 61
    64ca:	0c 94 b4 3c 	jmp	0x7968	; 0x7968 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    64ce:	ce 01       	movw	r24, r28
    64d0:	8b 5a       	subi	r24, 0xAB	; 171
    64d2:	9f 4f       	sbci	r25, 0xFF	; 255
    64d4:	63 e4       	ldi	r22, 0x43	; 67
    64d6:	78 e0       	ldi	r23, 0x08	; 8
    64d8:	44 e1       	ldi	r20, 0x14	; 20
    64da:	50 e0       	ldi	r21, 0x00	; 0
    64dc:	25 ed       	ldi	r18, 0xD5	; 213
    64de:	32 e1       	ldi	r19, 0x12	; 18
    64e0:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
	      break;
	 case grCreateReportHeader://Border: btTopLeft,btTopCenter,btTopRight,btMiddleLeft,btMiddleCenter,btMiddleRight,btBottomLeft,btBottomCenter,btBottomRight,btVertical,btHorizontal
		  eeprom_read_block((void*) &LastShiftDateTime, (const void*) &DefLastShiftDateTime, sizeof(DefLastShiftDateTime));
          
		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    64e4:	81 e0       	ldi	r24, 0x01	; 1
    64e6:	6f e1       	ldi	r22, 0x1F	; 31
    64e8:	76 e0       	ldi	r23, 0x06	; 6
    64ea:	41 e0       	ldi	r20, 0x01	; 1
    64ec:	22 e0       	ldi	r18, 0x02	; 2
    64ee:	32 e0       	ldi	r19, 0x02	; 2
    64f0:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    64f4:	8b e0       	ldi	r24, 0x0B	; 11
    64f6:	6f e1       	ldi	r22, 0x1F	; 31
    64f8:	76 e0       	ldi	r23, 0x06	; 6
    64fa:	4a e2       	ldi	r20, 0x2A	; 42
    64fc:	22 e0       	ldi	r18, 0x02	; 2
    64fe:	32 e0       	ldi	r19, 0x02	; 2
    6500:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    6504:	83 e0       	ldi	r24, 0x03	; 3
    6506:	6f e1       	ldi	r22, 0x1F	; 31
    6508:	76 e0       	ldi	r23, 0x06	; 6
    650a:	41 e0       	ldi	r20, 0x01	; 1
    650c:	22 e0       	ldi	r18, 0x02	; 2
    650e:	32 e0       	ldi	r19, 0x02	; 2
    6510:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    6514:	8c e0       	ldi	r24, 0x0C	; 12
    6516:	6f e1       	ldi	r22, 0x1F	; 31
    6518:	76 e0       	ldi	r23, 0x06	; 6
    651a:	41 e0       	ldi	r20, 0x01	; 1
    651c:	22 e0       	ldi	r18, 0x02	; 2
    651e:	32 e0       	ldi	r19, 0x02	; 2
    6520:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
	      sprintf_P(strReport,PSTR("        Laporan Tutup Shift: %s      "),strShift);CreateReport(strReport,PrintBuffer,&RepPos);
    6524:	00 d0       	rcall	.+0      	; 0x6526 <systemGenerateReport+0x1f0>
    6526:	00 d0       	rcall	.+0      	; 0x6528 <systemGenerateReport+0x1f2>
    6528:	00 d0       	rcall	.+0      	; 0x652a <systemGenerateReport+0x1f4>
    652a:	ed b7       	in	r30, 0x3d	; 61
    652c:	fe b7       	in	r31, 0x3e	; 62
    652e:	31 96       	adiw	r30, 0x01	; 1
    6530:	8e 01       	movw	r16, r28
    6532:	0b 55       	subi	r16, 0x5B	; 91
    6534:	1f 4f       	sbci	r17, 0xFF	; 255
    6536:	ad b7       	in	r26, 0x3d	; 61
    6538:	be b7       	in	r27, 0x3e	; 62
    653a:	12 96       	adiw	r26, 0x02	; 2
    653c:	1c 93       	st	X, r17
    653e:	0e 93       	st	-X, r16
    6540:	11 97       	sbiw	r26, 0x01	; 1
    6542:	85 e7       	ldi	r24, 0x75	; 117
    6544:	95 e0       	ldi	r25, 0x05	; 5
    6546:	93 83       	std	Z+3, r25	; 0x03
    6548:	82 83       	std	Z+2, r24	; 0x02
    654a:	83 e9       	ldi	r24, 0x93	; 147
    654c:	9e e0       	ldi	r25, 0x0E	; 14
    654e:	95 83       	std	Z+5, r25	; 0x05
    6550:	84 83       	std	Z+4, r24	; 0x04
    6552:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    6556:	ed b7       	in	r30, 0x3d	; 61
    6558:	fe b7       	in	r31, 0x3e	; 62
    655a:	36 96       	adiw	r30, 0x06	; 6
    655c:	0f b6       	in	r0, 0x3f	; 63
    655e:	f8 94       	cli
    6560:	fe bf       	out	0x3e, r31	; 62
    6562:	0f be       	out	0x3f, r0	; 63
    6564:	ed bf       	out	0x3d, r30	; 61
    6566:	c8 01       	movw	r24, r16
    6568:	6f e1       	ldi	r22, 0x1F	; 31
    656a:	76 e0       	ldi	r23, 0x06	; 6
    656c:	42 e0       	ldi	r20, 0x02	; 2
    656e:	52 e0       	ldi	r21, 0x02	; 2
    6570:	0e 94 8e 20 	call	0x411c	; 0x411c <CreateReport>
		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     
    6574:	84 e0       	ldi	r24, 0x04	; 4
    6576:	6f e1       	ldi	r22, 0x1F	; 31
    6578:	76 e0       	ldi	r23, 0x06	; 6
    657a:	41 e0       	ldi	r20, 0x01	; 1
    657c:	22 e0       	ldi	r18, 0x02	; 2
    657e:	32 e0       	ldi	r19, 0x02	; 2
    6580:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    6584:	8b e0       	ldi	r24, 0x0B	; 11
    6586:	6f e1       	ldi	r22, 0x1F	; 31
    6588:	76 e0       	ldi	r23, 0x06	; 6
    658a:	4a e2       	ldi	r20, 0x2A	; 42
    658c:	22 e0       	ldi	r18, 0x02	; 2
    658e:	32 e0       	ldi	r19, 0x02	; 2
    6590:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    6594:	86 e0       	ldi	r24, 0x06	; 6
    6596:	6f e1       	ldi	r22, 0x1F	; 31
    6598:	76 e0       	ldi	r23, 0x06	; 6
    659a:	41 e0       	ldi	r20, 0x01	; 1
    659c:	22 e0       	ldi	r18, 0x02	; 2
    659e:	32 e0       	ldi	r19, 0x02	; 2
    65a0:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    65a4:	8c e0       	ldi	r24, 0x0C	; 12
    65a6:	6f e1       	ldi	r22, 0x1F	; 31
    65a8:	76 e0       	ldi	r23, 0x06	; 6
    65aa:	41 e0       	ldi	r20, 0x01	; 1
    65ac:	22 e0       	ldi	r18, 0x02	; 2
    65ae:	32 e0       	ldi	r19, 0x02	; 2
    65b0:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    65b4:	e1 99       	sbic	0x1c, 1	; 28
    65b6:	fe cf       	rjmp	.-4      	; 0x65b4 <systemGenerateReport+0x27e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    65b8:	80 e0       	ldi	r24, 0x00	; 0
    65ba:	90 e0       	ldi	r25, 0x00	; 0
    65bc:	9f bb       	out	0x1f, r25	; 31
    65be:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    65c0:	e0 9a       	sbi	0x1c, 0	; 28
    65c2:	2d b3       	in	r18, 0x1d	; 29
	      sprintf_P(strReport,PSTR("Terminal ID : %.2d                   "),eeprom_read_byte(&DefIFT_ID));CreateReport(strReport,PrintBuffer,&RepPos);
    65c4:	00 d0       	rcall	.+0      	; 0x65c6 <systemGenerateReport+0x290>
    65c6:	00 d0       	rcall	.+0      	; 0x65c8 <systemGenerateReport+0x292>
    65c8:	00 d0       	rcall	.+0      	; 0x65ca <systemGenerateReport+0x294>
    65ca:	ed b7       	in	r30, 0x3d	; 61
    65cc:	fe b7       	in	r31, 0x3e	; 62
    65ce:	31 96       	adiw	r30, 0x01	; 1
    65d0:	8e 01       	movw	r16, r28
    65d2:	0b 55       	subi	r16, 0x5B	; 91
    65d4:	1f 4f       	sbci	r17, 0xFF	; 255
    65d6:	ad b7       	in	r26, 0x3d	; 61
    65d8:	be b7       	in	r27, 0x3e	; 62
    65da:	12 96       	adiw	r26, 0x02	; 2
    65dc:	1c 93       	st	X, r17
    65de:	0e 93       	st	-X, r16
    65e0:	11 97       	sbiw	r26, 0x01	; 1
    65e2:	8f e4       	ldi	r24, 0x4F	; 79
    65e4:	95 e0       	ldi	r25, 0x05	; 5
    65e6:	93 83       	std	Z+3, r25	; 0x03
    65e8:	82 83       	std	Z+2, r24	; 0x02
    65ea:	24 83       	std	Z+4, r18	; 0x04
    65ec:	15 82       	std	Z+5, r1	; 0x05
    65ee:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    65f2:	ed b7       	in	r30, 0x3d	; 61
    65f4:	fe b7       	in	r31, 0x3e	; 62
    65f6:	36 96       	adiw	r30, 0x06	; 6
    65f8:	0f b6       	in	r0, 0x3f	; 63
    65fa:	f8 94       	cli
    65fc:	fe bf       	out	0x3e, r31	; 62
    65fe:	0f be       	out	0x3f, r0	; 63
    6600:	ed bf       	out	0x3d, r30	; 61
    6602:	c8 01       	movw	r24, r16
    6604:	6f e1       	ldi	r22, 0x1F	; 31
    6606:	76 e0       	ldi	r23, 0x06	; 6
    6608:	42 e0       	ldi	r20, 0x02	; 2
    660a:	52 e0       	ldi	r21, 0x02	; 2
    660c:	0e 94 8e 20 	call	0x411c	; 0x411c <CreateReport>
	      sprintf_P(strReport,PSTR("Awal  Shift : %s "),LastShiftDateTime);             CreateReport(strReport,PrintBuffer,&RepPos);
    6610:	00 d0       	rcall	.+0      	; 0x6612 <systemGenerateReport+0x2dc>
    6612:	00 d0       	rcall	.+0      	; 0x6614 <systemGenerateReport+0x2de>
    6614:	00 d0       	rcall	.+0      	; 0x6616 <systemGenerateReport+0x2e0>
    6616:	ed b7       	in	r30, 0x3d	; 61
    6618:	fe b7       	in	r31, 0x3e	; 62
    661a:	31 96       	adiw	r30, 0x01	; 1
    661c:	ad b7       	in	r26, 0x3d	; 61
    661e:	be b7       	in	r27, 0x3e	; 62
    6620:	12 96       	adiw	r26, 0x02	; 2
    6622:	1c 93       	st	X, r17
    6624:	0e 93       	st	-X, r16
    6626:	11 97       	sbiw	r26, 0x01	; 1
    6628:	8d e3       	ldi	r24, 0x3D	; 61
    662a:	95 e0       	ldi	r25, 0x05	; 5
    662c:	93 83       	std	Z+3, r25	; 0x03
    662e:	82 83       	std	Z+2, r24	; 0x02
    6630:	ce 01       	movw	r24, r28
    6632:	8b 5a       	subi	r24, 0xAB	; 171
    6634:	9f 4f       	sbci	r25, 0xFF	; 255
    6636:	95 83       	std	Z+5, r25	; 0x05
    6638:	84 83       	std	Z+4, r24	; 0x04
    663a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    663e:	ed b7       	in	r30, 0x3d	; 61
    6640:	fe b7       	in	r31, 0x3e	; 62
    6642:	36 96       	adiw	r30, 0x06	; 6
    6644:	0f b6       	in	r0, 0x3f	; 63
    6646:	f8 94       	cli
    6648:	fe bf       	out	0x3e, r31	; 62
    664a:	0f be       	out	0x3f, r0	; 63
    664c:	ed bf       	out	0x3d, r30	; 61
    664e:	c8 01       	movw	r24, r16
    6650:	6f e1       	ldi	r22, 0x1F	; 31
    6652:	76 e0       	ldi	r23, 0x06	; 6
    6654:	42 e0       	ldi	r20, 0x02	; 2
    6656:	52 e0       	ldi	r21, 0x02	; 2
    6658:	0e 94 8e 20 	call	0x411c	; 0x411c <CreateReport>
	      sprintf_P(strReport,PSTR("Akhir Shift : %s "),CurrentShiftDateTime);      CreateReport(strReport,PrintBuffer,&RepPos);
    665c:	00 d0       	rcall	.+0      	; 0x665e <systemGenerateReport+0x328>
    665e:	00 d0       	rcall	.+0      	; 0x6660 <systemGenerateReport+0x32a>
    6660:	00 d0       	rcall	.+0      	; 0x6662 <systemGenerateReport+0x32c>
    6662:	ed b7       	in	r30, 0x3d	; 61
    6664:	fe b7       	in	r31, 0x3e	; 62
    6666:	31 96       	adiw	r30, 0x01	; 1
    6668:	ad b7       	in	r26, 0x3d	; 61
    666a:	be b7       	in	r27, 0x3e	; 62
    666c:	12 96       	adiw	r26, 0x02	; 2
    666e:	1c 93       	st	X, r17
    6670:	0e 93       	st	-X, r16
    6672:	11 97       	sbiw	r26, 0x01	; 1
    6674:	8b e2       	ldi	r24, 0x2B	; 43
    6676:	95 e0       	ldi	r25, 0x05	; 5
    6678:	93 83       	std	Z+3, r25	; 0x03
    667a:	82 83       	std	Z+2, r24	; 0x02
    667c:	81 ec       	ldi	r24, 0xC1	; 193
    667e:	99 e0       	ldi	r25, 0x09	; 9
    6680:	95 83       	std	Z+5, r25	; 0x05
    6682:	84 83       	std	Z+4, r24	; 0x04
    6684:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    6688:	ed b7       	in	r30, 0x3d	; 61
    668a:	fe b7       	in	r31, 0x3e	; 62
    668c:	36 96       	adiw	r30, 0x06	; 6
    668e:	0f b6       	in	r0, 0x3f	; 63
    6690:	f8 94       	cli
    6692:	fe bf       	out	0x3e, r31	; 62
    6694:	0f be       	out	0x3f, r0	; 63
    6696:	ed bf       	out	0x3d, r30	; 61
    6698:	c8 01       	movw	r24, r16
    669a:	6f e1       	ldi	r22, 0x1F	; 31
    669c:	76 e0       	ldi	r23, 0x06	; 6
    669e:	42 e0       	ldi	r20, 0x02	; 2
    66a0:	52 e0       	ldi	r21, 0x02	; 2
    66a2:	0e 94 8e 20 	call	0x411c	; 0x411c <CreateReport>
	      //sprintf_P(strReport,PSTR("Transaksi   : %s "),DeltaTransaction);      CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    66a6:	87 e0       	ldi	r24, 0x07	; 7
    66a8:	6f e1       	ldi	r22, 0x1F	; 31
    66aa:	76 e0       	ldi	r23, 0x06	; 6
    66ac:	41 e0       	ldi	r20, 0x01	; 1
    66ae:	22 e0       	ldi	r18, 0x02	; 2
    66b0:	32 e0       	ldi	r19, 0x02	; 2
    66b2:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    66b6:	8b e0       	ldi	r24, 0x0B	; 11
    66b8:	6f e1       	ldi	r22, 0x1F	; 31
    66ba:	76 e0       	ldi	r23, 0x06	; 6
    66bc:	4a e2       	ldi	r20, 0x2A	; 42
    66be:	22 e0       	ldi	r18, 0x02	; 2
    66c0:	32 e0       	ldi	r19, 0x02	; 2
    66c2:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    66c6:	89 e0       	ldi	r24, 0x09	; 9
    66c8:	6f e1       	ldi	r22, 0x1F	; 31
    66ca:	76 e0       	ldi	r23, 0x06	; 6
    66cc:	41 e0       	ldi	r20, 0x01	; 1
    66ce:	22 e0       	ldi	r18, 0x02	; 2
    66d0:	32 e0       	ldi	r19, 0x02	; 2
    66d2:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    66d6:	8c e0       	ldi	r24, 0x0C	; 12
    66d8:	6f e1       	ldi	r22, 0x1F	; 31
    66da:	76 e0       	ldi	r23, 0x06	; 6
    66dc:	41 e0       	ldi	r20, 0x01	; 1
    66de:	22 e0       	ldi	r18, 0x02	; 2
    66e0:	32 e0       	ldi	r19, 0x02	; 2
    66e2:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
		  /*
	      if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
          */
		  ClearList(GradeList);
    66e6:	84 e0       	ldi	r24, 0x04	; 4
    66e8:	92 e0       	ldi	r25, 0x02	; 2
    66ea:	0e 94 2f 21 	call	0x425e	; 0x425e <ClearList>
		  cmdPrint=0b10000000;//PrintHeader
    66ee:	80 e8       	ldi	r24, 0x80	; 128
    66f0:	80 93 cb 01 	sts	0x01CB, r24
		  LengthMessage81=RepPos+1;
    66f4:	80 91 02 02 	lds	r24, 0x0202
    66f8:	90 91 03 02 	lds	r25, 0x0203
    66fc:	01 96       	adiw	r24, 0x01	; 1
    66fe:	90 93 a1 01 	sts	0x01A1, r25
    6702:	80 93 a0 01 	sts	0x01A0, r24
		  IsFreePrinting=True;
    6706:	81 e0       	ldi	r24, 0x01	; 1
    6708:	80 93 bf 01 	sts	0x01BF, r24
          IsBusyFreePrinting=True;
    670c:	80 93 ca 01 	sts	0x01CA, r24
		  		  
          stGenerateReport=grWaitPrinted1;
    6710:	83 e0       	ldi	r24, 0x03	; 3
    6712:	0c 94 ac 3c 	jmp	0x7958	; 0x7958 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted1:
          if (IsBusyFreePrinting==False)
    6716:	80 91 ca 01 	lds	r24, 0x01CA
    671a:	88 23       	and	r24, r24
    671c:	11 f0       	breq	.+4      	; 0x6722 <systemGenerateReport+0x3ec>
    671e:	0c 94 b4 3c 	jmp	0x7968	; 0x7968 <systemGenerateReport+0x1632>
		      stGenerateReport=grGenerateLabel;//grGenerateReportData;//grFinishGenerateReport;
    6722:	84 e0       	ldi	r24, 0x04	; 4
    6724:	0c 94 ac 3c 	jmp	0x7958	; 0x7958 <systemGenerateReport+0x1622>
	      break;
     case grGenerateLabel:
          RepPos=0;
    6728:	10 92 03 02 	sts	0x0203, r1
    672c:	10 92 02 02 	sts	0x0202, r1
          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    6730:	81 e0       	ldi	r24, 0x01	; 1
    6732:	6f e1       	ldi	r22, 0x1F	; 31
    6734:	76 e0       	ldi	r23, 0x06	; 6
    6736:	41 e0       	ldi	r20, 0x01	; 1
    6738:	22 e0       	ldi	r18, 0x02	; 2
    673a:	32 e0       	ldi	r19, 0x02	; 2
    673c:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    6740:	8b e0       	ldi	r24, 0x0B	; 11
    6742:	6f e1       	ldi	r22, 0x1F	; 31
    6744:	76 e0       	ldi	r23, 0x06	; 6
    6746:	4a e2       	ldi	r20, 0x2A	; 42
    6748:	22 e0       	ldi	r18, 0x02	; 2
    674a:	32 e0       	ldi	r19, 0x02	; 2
    674c:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    6750:	83 e0       	ldi	r24, 0x03	; 3
    6752:	6f e1       	ldi	r22, 0x1F	; 31
    6754:	76 e0       	ldi	r23, 0x06	; 6
    6756:	41 e0       	ldi	r20, 0x01	; 1
    6758:	22 e0       	ldi	r18, 0x02	; 2
    675a:	32 e0       	ldi	r19, 0x02	; 2
    675c:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    6760:	8c e0       	ldi	r24, 0x0C	; 12
    6762:	6f e1       	ldi	r22, 0x1F	; 31
    6764:	76 e0       	ldi	r23, 0x06	; 6
    6766:	41 e0       	ldi	r20, 0x01	; 1
    6768:	22 e0       	ldi	r18, 0x02	; 2
    676a:	32 e0       	ldi	r19, 0x02	; 2
    676c:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6770:	e1 99       	sbic	0x1c, 1	; 28
    6772:	fe cf       	rjmp	.-4      	; 0x6770 <systemGenerateReport+0x43a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6774:	81 ec       	ldi	r24, 0xC1	; 193
    6776:	93 e0       	ldi	r25, 0x03	; 3
    6778:	9f bb       	out	0x1f, r25	; 31
    677a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    677c:	e0 9a       	sbi	0x1c, 0	; 28
    677e:	8d b3       	in	r24, 0x1d	; 29
    6780:	9e 01       	movw	r18, r28
    6782:	2b 55       	subi	r18, 0x5B	; 91
    6784:	3f 4f       	sbci	r19, 0xFF	; 255
	      if (eeprom_read_byte(&DefPrintMoney)==True)
    6786:	81 30       	cpi	r24, 0x01	; 1
    6788:	79 f4       	brne	.+30     	; 0x67a8 <systemGenerateReport+0x472>
		       sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
    678a:	00 d0       	rcall	.+0      	; 0x678c <systemGenerateReport+0x456>
    678c:	00 d0       	rcall	.+0      	; 0x678e <systemGenerateReport+0x458>
    678e:	ad b7       	in	r26, 0x3d	; 61
    6790:	be b7       	in	r27, 0x3e	; 62
    6792:	12 96       	adiw	r26, 0x02	; 2
    6794:	3c 93       	st	X, r19
    6796:	2e 93       	st	-X, r18
    6798:	11 97       	sbiw	r26, 0x01	; 1
    679a:	84 e0       	ldi	r24, 0x04	; 4
    679c:	95 e0       	ldi	r25, 0x05	; 5
    679e:	14 96       	adiw	r26, 0x04	; 4
    67a0:	9c 93       	st	X, r25
    67a2:	8e 93       	st	-X, r24
    67a4:	13 97       	sbiw	r26, 0x03	; 3
    67a6:	0a c0       	rjmp	.+20     	; 0x67bc <systemGenerateReport+0x486>
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
    67a8:	00 d0       	rcall	.+0      	; 0x67aa <systemGenerateReport+0x474>
    67aa:	00 d0       	rcall	.+0      	; 0x67ac <systemGenerateReport+0x476>
    67ac:	ed b7       	in	r30, 0x3d	; 61
    67ae:	fe b7       	in	r31, 0x3e	; 62
    67b0:	32 83       	std	Z+2, r19	; 0x02
    67b2:	21 83       	std	Z+1, r18	; 0x01
    67b4:	8d ed       	ldi	r24, 0xDD	; 221
    67b6:	94 e0       	ldi	r25, 0x04	; 4
    67b8:	94 83       	std	Z+4, r25	; 0x04
    67ba:	83 83       	std	Z+3, r24	; 0x03
    67bc:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    67c0:	0f 90       	pop	r0
    67c2:	0f 90       	pop	r0
    67c4:	0f 90       	pop	r0
    67c6:	0f 90       	pop	r0
    67c8:	ce 01       	movw	r24, r28
    67ca:	8b 55       	subi	r24, 0x5B	; 91
    67cc:	9f 4f       	sbci	r25, 0xFF	; 255
    67ce:	6f e1       	ldi	r22, 0x1F	; 31
    67d0:	76 e0       	ldi	r23, 0x06	; 6
    67d2:	42 e0       	ldi	r20, 0x02	; 2
    67d4:	52 e0       	ldi	r21, 0x02	; 2
    67d6:	0e 94 8e 20 	call	0x411c	; 0x411c <CreateReport>
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
    67da:	87 e0       	ldi	r24, 0x07	; 7
    67dc:	6f e1       	ldi	r22, 0x1F	; 31
    67de:	76 e0       	ldi	r23, 0x06	; 6
    67e0:	41 e0       	ldi	r20, 0x01	; 1
    67e2:	22 e0       	ldi	r18, 0x02	; 2
    67e4:	32 e0       	ldi	r19, 0x02	; 2
    67e6:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    67ea:	8b e0       	ldi	r24, 0x0B	; 11
    67ec:	6f e1       	ldi	r22, 0x1F	; 31
    67ee:	76 e0       	ldi	r23, 0x06	; 6
    67f0:	4a e2       	ldi	r20, 0x2A	; 42
    67f2:	22 e0       	ldi	r18, 0x02	; 2
    67f4:	32 e0       	ldi	r19, 0x02	; 2
    67f6:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    67fa:	89 e0       	ldi	r24, 0x09	; 9
    67fc:	6f e1       	ldi	r22, 0x1F	; 31
    67fe:	76 e0       	ldi	r23, 0x06	; 6
    6800:	41 e0       	ldi	r20, 0x01	; 1
    6802:	22 e0       	ldi	r18, 0x02	; 2
    6804:	32 e0       	ldi	r19, 0x02	; 2
    6806:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
          
		  cmdPrint=0b00000000;
    680a:	10 92 cb 01 	sts	0x01CB, r1
		  LengthMessage81=RepPos+1;
    680e:	80 91 02 02 	lds	r24, 0x0202
    6812:	90 91 03 02 	lds	r25, 0x0203
    6816:	01 96       	adiw	r24, 0x01	; 1
    6818:	90 93 a1 01 	sts	0x01A1, r25
    681c:	80 93 a0 01 	sts	0x01A0, r24

		  IsFreePrinting=True;
    6820:	81 e0       	ldi	r24, 0x01	; 1
    6822:	80 93 bf 01 	sts	0x01BF, r24
	      IsBusyFreePrinting=True;
    6826:	80 93 ca 01 	sts	0x01CA, r24

		  stGenerateReport=grWaitLabelPrinted;
    682a:	85 e0       	ldi	r24, 0x05	; 5
    682c:	0c 94 ac 3c 	jmp	0x7958	; 0x7958 <systemGenerateReport+0x1622>
          if (IsBusyFreePrinting==False)
		      stGenerateReport=grGenerateReportData;//grFinishGenerateReport;
	      break;
     case grGenerateReportData:
	      //Generate: PumpNum, Nozzle, Product
	      if ((xPump>=1)&&(xPump<=8)){
    6830:	80 91 13 02 	lds	r24, 0x0213
    6834:	81 50       	subi	r24, 0x01	; 1
    6836:	88 30       	cpi	r24, 0x08	; 8
    6838:	10 f0       	brcs	.+4      	; 0x683e <systemGenerateReport+0x508>
    683a:	0c 94 b4 3c 	jmp	0x7968	; 0x7968 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    683e:	ce 01       	movw	r24, r28
    6840:	07 96       	adiw	r24, 0x07	; 7
    6842:	65 e4       	ldi	r22, 0x45	; 69
    6844:	70 e0       	ldi	r23, 0x00	; 0
    6846:	48 e0       	ldi	r20, 0x08	; 8
    6848:	50 e0       	ldi	r21, 0x00	; 0
    684a:	25 ed       	ldi	r18, 0xD5	; 213
    684c:	32 e1       	ldi	r19, 0x12	; 18
    684e:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
		      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			  PumpNum=PPumpID[xPump-1];
    6852:	90 91 13 02 	lds	r25, 0x0213
    6856:	fe 01       	movw	r30, r28
    6858:	e9 0f       	add	r30, r25
    685a:	f1 1d       	adc	r31, r1
    685c:	86 81       	ldd	r24, Z+6	; 0x06
    685e:	80 93 10 02 	sts	0x0210, r24
			  if (PumpNum>0){
    6862:	88 23       	and	r24, r24
    6864:	09 f4       	brne	.+2      	; 0x6868 <systemGenerateReport+0x532>
    6866:	4b c0       	rjmp	.+150    	; 0x68fe <systemGenerateReport+0x5c8>
    6868:	91 9f       	mul	r25, r17
    686a:	b0 01       	movw	r22, r0
    686c:	11 24       	eor	r1, r1
    686e:	61 5b       	subi	r22, 0xB1	; 177
    6870:	7f 4f       	sbci	r23, 0xFF	; 255
    6872:	ce 01       	movw	r24, r28
    6874:	01 96       	adiw	r24, 0x01	; 1
    6876:	46 e0       	ldi	r20, 0x06	; 6
    6878:	50 e0       	ldi	r21, 0x00	; 0
    687a:	25 ed       	ldi	r18, 0xD5	; 213
    687c:	32 e1       	ldi	r19, 0x12	; 18
    687e:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
				  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
				  xGrade=PProductID[xNozzle-1];
    6882:	80 91 12 02 	lds	r24, 0x0212
    6886:	fe 01       	movw	r30, r28
    6888:	e8 0f       	add	r30, r24
    688a:	f1 1d       	adc	r31, r1
    688c:	80 81       	ld	r24, Z
    688e:	80 93 11 02 	sts	0x0211, r24
    6892:	61 e9       	ldi	r22, 0x91	; 145
    6894:	c6 2e       	mov	r12, r22
    6896:	69 e0       	ldi	r22, 0x09	; 9
    6898:	d6 2e       	mov	r13, r22

				  if (xGrade>0){
    689a:	88 23       	and	r24, r24
    689c:	99 f0       	breq	.+38     	; 0x68c4 <systemGenerateReport+0x58e>
				      GetProductName(xGrade,strProduct);
    689e:	b6 01       	movw	r22, r12
    68a0:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <GetProductName>
                      GradeUsed=xGrade;
    68a4:	80 91 11 02 	lds	r24, 0x0211
    68a8:	80 93 0e 02 	sts	0x020E, r24
					  xGrade=xNozzle;//
    68ac:	80 91 12 02 	lds	r24, 0x0212
    68b0:	80 93 11 02 	sts	0x0211, r24
					  PumpNozzle=xNozzle;
    68b4:	80 93 0f 02 	sts	0x020F, r24
					  xNozzle++;
    68b8:	8f 5f       	subi	r24, 0xFF	; 255
    68ba:	80 93 12 02 	sts	0x0212, r24
					  stGenerateReport=grCreateReportTotalizer;
    68be:	88 e0       	ldi	r24, 0x08	; 8
    68c0:	0c 94 ac 3c 	jmp	0x7958	; 0x7958 <systemGenerateReport+0x1622>
				  }
				  else{sprintf_P(strProduct,PSTR("N/A"));			  
    68c4:	00 d0       	rcall	.+0      	; 0x68c6 <systemGenerateReport+0x590>
    68c6:	00 d0       	rcall	.+0      	; 0x68c8 <systemGenerateReport+0x592>
    68c8:	ad b7       	in	r26, 0x3d	; 61
    68ca:	be b7       	in	r27, 0x3e	; 62
    68cc:	12 96       	adiw	r26, 0x02	; 2
    68ce:	dc 92       	st	X, r13
    68d0:	ce 92       	st	-X, r12
    68d2:	11 97       	sbiw	r26, 0x01	; 1
    68d4:	89 ed       	ldi	r24, 0xD9	; 217
    68d6:	94 e0       	ldi	r25, 0x04	; 4
    68d8:	14 96       	adiw	r26, 0x04	; 4
    68da:	9c 93       	st	X, r25
    68dc:	8e 93       	st	-X, r24
    68de:	13 97       	sbiw	r26, 0x03	; 3
    68e0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
					   xNozzle++;
    68e4:	80 91 12 02 	lds	r24, 0x0212
    68e8:	8f 5f       	subi	r24, 0xFF	; 255
    68ea:	80 93 12 02 	sts	0x0212, r24
					   if (xNozzle>6)stGenerateReport=grNextPump;
    68ee:	0f 90       	pop	r0
    68f0:	0f 90       	pop	r0
    68f2:	0f 90       	pop	r0
    68f4:	0f 90       	pop	r0
    68f6:	87 30       	cpi	r24, 0x07	; 7
    68f8:	10 f4       	brcc	.+4      	; 0x68fe <systemGenerateReport+0x5c8>
    68fa:	0c 94 b4 3c 	jmp	0x7968	; 0x7968 <systemGenerateReport+0x1632>
					  }
				}else stGenerateReport=grNextPump;
    68fe:	87 e0       	ldi	r24, 0x07	; 7
    6900:	0c 94 ac 3c 	jmp	0x7958	; 0x7958 <systemGenerateReport+0x1622>
			  }
	      break;
     case grNextPump:
	      xNozzle=1;
    6904:	81 e0       	ldi	r24, 0x01	; 1
    6906:	80 93 12 02 	sts	0x0212, r24
	      xPump++;
    690a:	80 91 13 02 	lds	r24, 0x0213
    690e:	8f 5f       	subi	r24, 0xFF	; 255
    6910:	80 93 13 02 	sts	0x0213, r24
	      if (xPump>8)stGenerateReport=grCreateReportFooter;
    6914:	89 30       	cpi	r24, 0x09	; 9
    6916:	08 f4       	brcc	.+2      	; 0x691a <systemGenerateReport+0x5e4>
    6918:	93 c4       	rjmp	.+2342   	; 0x7240 <systemGenerateReport+0xf0a>
    691a:	8a e0       	ldi	r24, 0x0A	; 10
    691c:	0c 94 ac 3c 	jmp	0x7958	; 0x7958 <systemGenerateReport+0x1622>
		  else stGenerateReport=grGenerateReportData;
	      break;
     case grCreateReportTotalizer:

          RepPos=0;
    6920:	10 92 03 02 	sts	0x0203, r1
    6924:	10 92 02 02 	sts	0x0202, r1
    6928:	ef e1       	ldi	r30, 0x1F	; 31
    692a:	f6 e0       	ldi	r31, 0x06	; 6
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    692c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    692e:	b7 e0       	ldi	r27, 0x07	; 7
    6930:	e0 3b       	cpi	r30, 0xB0	; 176
    6932:	fb 07       	cpc	r31, r27
    6934:	d9 f7       	brne	.-10     	; 0x692c <systemGenerateReport+0x5f6>
    6936:	fe 01       	movw	r30, r28
    6938:	eb 55       	subi	r30, 0x5B	; 91
    693a:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    693c:	ce 01       	movw	r24, r28
    693e:	8b 50       	subi	r24, 0x0B	; 11
    6940:	9f 4f       	sbci	r25, 0xFF	; 255
    6942:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6944:	e8 17       	cp	r30, r24
    6946:	f9 07       	cpc	r31, r25
    6948:	e1 f7       	brne	.-8      	; 0x6942 <systemGenerateReport+0x60c>
    694a:	e8 e5       	ldi	r30, 0x58	; 88
    694c:	fe e0       	ldi	r31, 0x0E	; 14
	     strMemory[i]=data;
    694e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6950:	8e e0       	ldi	r24, 0x0E	; 14
    6952:	e7 36       	cpi	r30, 0x67	; 103
    6954:	f8 07       	cpc	r31, r24
    6956:	d9 f7       	brne	.-10     	; 0x694e <systemGenerateReport+0x618>
    6958:	ed e2       	ldi	r30, 0x2D	; 45
    695a:	fb e0       	ldi	r31, 0x0B	; 11
	     strMemory[i]=data;
    695c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    695e:	9b e0       	ldi	r25, 0x0B	; 11
    6960:	ec 33       	cpi	r30, 0x3C	; 60
    6962:	f9 07       	cpc	r31, r25
    6964:	d9 f7       	brne	.-10     	; 0x695c <systemGenerateReport+0x626>
    6966:	fe 01       	movw	r30, r28
    6968:	79 96       	adiw	r30, 0x19	; 25
	     strMemory[i]=data;
    696a:	ce 01       	movw	r24, r28
    696c:	88 96       	adiw	r24, 0x28	; 40
    696e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6970:	e8 17       	cp	r30, r24
    6972:	f9 07       	cpc	r31, r25
    6974:	e1 f7       	brne	.-8      	; 0x696e <systemGenerateReport+0x638>
	     strMemory[i]=data;
    6976:	ce 01       	movw	r24, r28
    6978:	c7 96       	adiw	r24, 0x37	; 55
    697a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    697c:	e8 17       	cp	r30, r24
    697e:	f9 07       	cpc	r31, r25
    6980:	e1 f7       	brne	.-8      	; 0x697a <systemGenerateReport+0x644>
	     strMemory[i]=data;
    6982:	cf 01       	movw	r24, r30
    6984:	0f 96       	adiw	r24, 0x0f	; 15
    6986:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6988:	e8 17       	cp	r30, r24
    698a:	f9 07       	cpc	r31, r25
    698c:	e1 f7       	brne	.-8      	; 0x6986 <systemGenerateReport+0x650>
    698e:	fe 01       	movw	r30, r28
    6990:	ea 5b       	subi	r30, 0xBA	; 186
    6992:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6994:	cf 01       	movw	r24, r30
    6996:	ee 2e       	mov	r14, r30
    6998:	d9 2e       	mov	r13, r25
    699a:	0f 96       	adiw	r24, 0x0f	; 15
    699c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    699e:	e8 17       	cp	r30, r24
    69a0:	f9 07       	cpc	r31, r25
    69a2:	e1 f7       	brne	.-8      	; 0x699c <systemGenerateReport+0x666>
		  FillChar(strLastMoney,sizeof(strLastMoney),0);

		  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
		  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

          FIPAddr=GetFIPAddr(PumpNum); 
    69a4:	80 91 10 02 	lds	r24, 0x0210
    69a8:	0e 94 1a 1c 	call	0x3834	; 0x3834 <GetFIPAddr>
		  if (FIPAddr>0){
    69ac:	88 23       	and	r24, r24
    69ae:	49 f1       	breq	.+82     	; 0x6a02 <systemGenerateReport+0x6cc>
		      FIPAddr=FIPAddr-1;		  
    69b0:	f8 2e       	mov	r15, r24
    69b2:	fa 94       	dec	r15
			  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    69b4:	80 e0       	ldi	r24, 0x00	; 0
    69b6:	60 e0       	ldi	r22, 0x00	; 0
    69b8:	4f 2d       	mov	r20, r15
    69ba:	20 91 0f 02 	lds	r18, 0x020F
    69be:	8e 01       	movw	r16, r28
    69c0:	07 5e       	subi	r16, 0xE7	; 231
    69c2:	1f 4f       	sbci	r17, 0xFF	; 255
    69c4:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    69c8:	81 e0       	ldi	r24, 0x01	; 1
    69ca:	60 e0       	ldi	r22, 0x00	; 0
    69cc:	4f 2d       	mov	r20, r15
    69ce:	20 91 0f 02 	lds	r18, 0x020F
    69d2:	8e 01       	movw	r16, r28
    69d4:	08 5d       	subi	r16, 0xD8	; 216
    69d6:	1f 4f       	sbci	r17, 0xFF	; 255
    69d8:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <GetTotalizerData>

			  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    69dc:	80 e0       	ldi	r24, 0x00	; 0
    69de:	61 e0       	ldi	r22, 0x01	; 1
    69e0:	4f 2d       	mov	r20, r15
    69e2:	20 91 0f 02 	lds	r18, 0x020F
    69e6:	8e 01       	movw	r16, r28
    69e8:	09 5c       	subi	r16, 0xC9	; 201
    69ea:	1f 4f       	sbci	r17, 0xFF	; 255
    69ec:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    69f0:	81 e0       	ldi	r24, 0x01	; 1
    69f2:	61 e0       	ldi	r22, 0x01	; 1
    69f4:	4f 2d       	mov	r20, r15
    69f6:	20 91 0f 02 	lds	r18, 0x020F
    69fa:	0e 2d       	mov	r16, r14
    69fc:	1d 2d       	mov	r17, r13
    69fe:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <GetTotalizerData>
		  }

		  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    6a02:	80 e0       	ldi	r24, 0x00	; 0
    6a04:	be 01       	movw	r22, r28
    6a06:	69 5c       	subi	r22, 0xC9	; 201
    6a08:	7f 4f       	sbci	r23, 0xFF	; 255
    6a0a:	ae 01       	movw	r20, r28
    6a0c:	47 5e       	subi	r20, 0xE7	; 231
    6a0e:	5f 4f       	sbci	r21, 0xFF	; 255
    6a10:	2d e2       	ldi	r18, 0x2D	; 45
    6a12:	3b e0       	ldi	r19, 0x0B	; 11
    6a14:	0e 94 6c 26 	call	0x4cd8	; 0x4cd8 <StrCalc>

		  if (IsMinus(strDeltaVolume)==True)
    6a18:	8d e2       	ldi	r24, 0x2D	; 45
    6a1a:	9b e0       	ldi	r25, 0x0B	; 11
    6a1c:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <IsMinus>
    6a20:	81 30       	cpi	r24, 0x01	; 1
    6a22:	21 f4       	brne	.+8      	; 0x6a2c <systemGenerateReport+0x6f6>
		      NormalizeOverflow(strDeltaVolume);
    6a24:	8d e2       	ldi	r24, 0x2D	; 45
    6a26:	9b e0       	ldi	r25, 0x0B	; 11
    6a28:	0e 94 03 2a 	call	0x5406	; 0x5406 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6a2c:	e1 99       	sbic	0x1c, 1	; 28
    6a2e:	fe cf       	rjmp	.-4      	; 0x6a2c <systemGenerateReport+0x6f6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6a30:	57 e3       	ldi	r21, 0x37	; 55
    6a32:	85 2e       	mov	r8, r21
    6a34:	51 e0       	ldi	r21, 0x01	; 1
    6a36:	95 2e       	mov	r9, r21
    6a38:	9f ba       	out	0x1f, r9	; 31
    6a3a:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6a3c:	e0 9a       	sbi	0x1c, 0	; 28
    6a3e:	8d b3       	in	r24, 0x1d	; 29

		  //Calculate Wayne Estimated Total Money
		  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    6a40:	82 30       	cpi	r24, 0x02	; 2
    6a42:	79 f4       	brne	.+30     	; 0x6a62 <systemGenerateReport+0x72c>
              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    6a44:	8e 01       	movw	r16, r28
    6a46:	01 5f       	subi	r16, 0xF1	; 241
    6a48:	1f 4f       	sbci	r17, 0xFF	; 255
    6a4a:	c8 01       	movw	r24, r16
    6a4c:	60 91 10 02 	lds	r22, 0x0210
    6a50:	40 91 0f 02 	lds	r20, 0x020F
    6a54:	0e 94 d6 22 	call	0x45ac	; 0x45ac <GetProductPrice>
			  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    6a58:	82 e0       	ldi	r24, 0x02	; 2
    6a5a:	b8 01       	movw	r22, r16
    6a5c:	4d e2       	ldi	r20, 0x2D	; 45
    6a5e:	5b e0       	ldi	r21, 0x0B	; 11
    6a60:	07 c0       	rjmp	.+14     	; 0x6a70 <systemGenerateReport+0x73a>
			  
		  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    6a62:	80 e0       	ldi	r24, 0x00	; 0
    6a64:	be 01       	movw	r22, r28
    6a66:	6a 5b       	subi	r22, 0xBA	; 186
    6a68:	7f 4f       	sbci	r23, 0xFF	; 255
    6a6a:	ae 01       	movw	r20, r28
    6a6c:	48 5d       	subi	r20, 0xD8	; 216
    6a6e:	5f 4f       	sbci	r21, 0xFF	; 255
    6a70:	28 e5       	ldi	r18, 0x58	; 88
    6a72:	3e e0       	ldi	r19, 0x0E	; 14
    6a74:	0e 94 6c 26 	call	0x4cd8	; 0x4cd8 <StrCalc>

		  if (IsMinus(strDeltaMoney)==True)
    6a78:	88 e5       	ldi	r24, 0x58	; 88
    6a7a:	9e e0       	ldi	r25, 0x0E	; 14
    6a7c:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <IsMinus>
    6a80:	81 30       	cpi	r24, 0x01	; 1
    6a82:	21 f4       	brne	.+8      	; 0x6a8c <systemGenerateReport+0x756>
		      NormalizeOverflow(strDeltaMoney);
    6a84:	88 e5       	ldi	r24, 0x58	; 88
    6a86:	9e e0       	ldi	r25, 0x0E	; 14
    6a88:	0e 94 03 2a 	call	0x5406	; 0x5406 <NormalizeOverflow>

		  AddList(GradeUsed,GradeList);
    6a8c:	80 91 0e 02 	lds	r24, 0x020E
    6a90:	64 e0       	ldi	r22, 0x04	; 4
    6a92:	72 e0       	ldi	r23, 0x02	; 2
    6a94:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <AddList>
		  
		  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    6a98:	81 e0       	ldi	r24, 0x01	; 1
    6a9a:	6c e4       	ldi	r22, 0x4C	; 76
    6a9c:	7a e0       	ldi	r23, 0x0A	; 10
    6a9e:	4d e2       	ldi	r20, 0x2D	; 45
    6aa0:	5b e0       	ldi	r21, 0x0B	; 11
    6aa2:	9b 01       	movw	r18, r22
    6aa4:	0e 94 6c 26 	call	0x4cd8	; 0x4cd8 <StrCalc>
		  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    6aa8:	81 e0       	ldi	r24, 0x01	; 1
    6aaa:	6d ef       	ldi	r22, 0xFD	; 253
    6aac:	7a e0       	ldi	r23, 0x0A	; 10
    6aae:	48 e5       	ldi	r20, 0x58	; 88
    6ab0:	5e e0       	ldi	r21, 0x0E	; 14
    6ab2:	9b 01       	movw	r18, r22
    6ab4:	0e 94 6c 26 	call	0x4cd8	; 0x4cd8 <StrCalc>


		  RemZeroLead(strDeltaMoney);
    6ab8:	88 e5       	ldi	r24, 0x58	; 88
    6aba:	9e e0       	ldi	r25, 0x0E	; 14
    6abc:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
		  RemZeroLead(strCurrentMoney);
    6ac0:	46 e4       	ldi	r20, 0x46	; 70
    6ac2:	c4 2e       	mov	r12, r20
    6ac4:	d1 2c       	mov	r13, r1
    6ac6:	cc 0e       	add	r12, r28
    6ac8:	dd 1e       	adc	r13, r29
    6aca:	c6 01       	movw	r24, r12
    6acc:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
		  RemZeroLead(strLastMoney);
    6ad0:	38 e2       	ldi	r19, 0x28	; 40
    6ad2:	e3 2e       	mov	r14, r19
    6ad4:	f1 2c       	mov	r15, r1
    6ad6:	ec 0e       	add	r14, r28
    6ad8:	fd 1e       	adc	r15, r29
    6ada:	c7 01       	movw	r24, r14
    6adc:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>

          RemZeroLead(strDeltaVolume);
    6ae0:	8d e2       	ldi	r24, 0x2D	; 45
    6ae2:	9b e0       	ldi	r25, 0x0B	; 11
    6ae4:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
          RemZeroLead(strCurrentVolume);
    6ae8:	27 e3       	ldi	r18, 0x37	; 55
    6aea:	a2 2e       	mov	r10, r18
    6aec:	b1 2c       	mov	r11, r1
    6aee:	ac 0e       	add	r10, r28
    6af0:	bd 1e       	adc	r11, r29
    6af2:	c5 01       	movw	r24, r10
    6af4:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
          RemZeroLead(strLastVolume);
    6af8:	8e 01       	movw	r16, r28
    6afa:	07 5e       	subi	r16, 0xE7	; 231
    6afc:	1f 4f       	sbci	r17, 0xFF	; 255
    6afe:	c8 01       	movw	r24, r16
    6b00:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>

		  FormatTotalizerMoney(strDeltaMoney);
    6b04:	88 e5       	ldi	r24, 0x58	; 88
    6b06:	9e e0       	ldi	r25, 0x0E	; 14
    6b08:	0e 94 67 31 	call	0x62ce	; 0x62ce <FormatTotalizerMoney>
		  FormatTotalizerMoney(strCurrentMoney);
    6b0c:	c6 01       	movw	r24, r12
    6b0e:	0e 94 67 31 	call	0x62ce	; 0x62ce <FormatTotalizerMoney>
		  FormatTotalizerMoney(strLastMoney);
    6b12:	c7 01       	movw	r24, r14
    6b14:	0e 94 67 31 	call	0x62ce	; 0x62ce <FormatTotalizerMoney>

		  FormatTotalizerVolume(strDeltaVolume);
    6b18:	8d e2       	ldi	r24, 0x2D	; 45
    6b1a:	9b e0       	ldi	r25, 0x0B	; 11
    6b1c:	0e 94 5a 31 	call	0x62b4	; 0x62b4 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strLastVolume);
    6b20:	c8 01       	movw	r24, r16
    6b22:	0e 94 5a 31 	call	0x62b4	; 0x62b4 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strCurrentVolume); 
    6b26:	c5 01       	movw	r24, r10
    6b28:	0e 94 5a 31 	call	0x62b4	; 0x62b4 <FormatTotalizerVolume>

          FormatCurrency(strDeltaMoney);
    6b2c:	88 e5       	ldi	r24, 0x58	; 88
    6b2e:	9e e0       	ldi	r25, 0x0E	; 14
    6b30:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>
		  FormatCurrency(strCurrentMoney);
    6b34:	c6 01       	movw	r24, r12
    6b36:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>
		  FormatCurrency(strLastMoney);
    6b3a:	c7 01       	movw	r24, r14
    6b3c:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>

		  FormatCurrency(strDeltaVolume);		  
    6b40:	8d e2       	ldi	r24, 0x2D	; 45
    6b42:	9b e0       	ldi	r25, 0x0B	; 11
    6b44:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>
		  FormatCurrency(strLastVolume);
    6b48:	c8 01       	movw	r24, r16
    6b4a:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>
          FormatCurrency(strCurrentVolume);
    6b4e:	c5 01       	movw	r24, r10
    6b50:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>


          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    6b54:	81 e0       	ldi	r24, 0x01	; 1
    6b56:	6f e1       	ldi	r22, 0x1F	; 31
    6b58:	76 e0       	ldi	r23, 0x06	; 6
    6b5a:	41 e0       	ldi	r20, 0x01	; 1
    6b5c:	22 e0       	ldi	r18, 0x02	; 2
    6b5e:	32 e0       	ldi	r19, 0x02	; 2
    6b60:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    6b64:	8b e0       	ldi	r24, 0x0B	; 11
    6b66:	6f e1       	ldi	r22, 0x1F	; 31
    6b68:	76 e0       	ldi	r23, 0x06	; 6
    6b6a:	4a e2       	ldi	r20, 0x2A	; 42
    6b6c:	22 e0       	ldi	r18, 0x02	; 2
    6b6e:	32 e0       	ldi	r19, 0x02	; 2
    6b70:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    6b74:	83 e0       	ldi	r24, 0x03	; 3
    6b76:	6f e1       	ldi	r22, 0x1F	; 31
    6b78:	76 e0       	ldi	r23, 0x06	; 6
    6b7a:	41 e0       	ldi	r20, 0x01	; 1
    6b7c:	22 e0       	ldi	r18, 0x02	; 2
    6b7e:	32 e0       	ldi	r19, 0x02	; 2
    6b80:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    6b84:	8c e0       	ldi	r24, 0x0C	; 12
    6b86:	6f e1       	ldi	r22, 0x1F	; 31
    6b88:	76 e0       	ldi	r23, 0x06	; 6
    6b8a:	41 e0       	ldi	r20, 0x01	; 1
    6b8c:	22 e0       	ldi	r18, 0x02	; 2
    6b8e:	32 e0       	ldi	r19, 0x02	; 2
    6b90:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6b94:	e1 99       	sbic	0x1c, 1	; 28
    6b96:	fe cf       	rjmp	.-4      	; 0x6b94 <systemGenerateReport+0x85e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6b98:	9f ba       	out	0x1f, r9	; 31
    6b9a:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6b9c:	e0 9a       	sbi	0x1c, 0	; 28
    6b9e:	8d b3       	in	r24, 0x1d	; 29
    6ba0:	91 e9       	ldi	r25, 0x91	; 145
    6ba2:	c9 2e       	mov	r12, r25
    6ba4:	99 e0       	ldi	r25, 0x09	; 9
    6ba6:	d9 2e       	mov	r13, r25
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    6ba8:	82 30       	cpi	r24, 0x02	; 2
    6baa:	09 f0       	breq	.+2      	; 0x6bae <systemGenerateReport+0x878>
    6bac:	84 c0       	rjmp	.+264    	; 0x6cb6 <systemGenerateReport+0x980>
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
    6bae:	0f e0       	ldi	r16, 0x0F	; 15
    6bb0:	e0 2e       	mov	r14, r16
    6bb2:	f1 2c       	mov	r15, r1
    6bb4:	ec 0e       	add	r14, r28
    6bb6:	fd 1e       	adc	r15, r29
    6bb8:	c7 01       	movw	r24, r14
    6bba:	60 91 10 02 	lds	r22, 0x0210
    6bbe:	40 91 0f 02 	lds	r20, 0x020F
    6bc2:	0e 94 d6 22 	call	0x45ac	; 0x45ac <GetProductPrice>
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);
    6bc6:	00 d0       	rcall	.+0      	; 0x6bc8 <systemGenerateReport+0x892>
    6bc8:	00 d0       	rcall	.+0      	; 0x6bca <systemGenerateReport+0x894>
    6bca:	00 d0       	rcall	.+0      	; 0x6bcc <systemGenerateReport+0x896>
    6bcc:	ed b7       	in	r30, 0x3d	; 61
    6bce:	fe b7       	in	r31, 0x3e	; 62
    6bd0:	31 96       	adiw	r30, 0x01	; 1
    6bd2:	8e 01       	movw	r16, r28
    6bd4:	0f 56       	subi	r16, 0x6F	; 111
    6bd6:	1f 4f       	sbci	r17, 0xFF	; 255
    6bd8:	ad b7       	in	r26, 0x3d	; 61
    6bda:	be b7       	in	r27, 0x3e	; 62
    6bdc:	12 96       	adiw	r26, 0x02	; 2
    6bde:	1c 93       	st	X, r17
    6be0:	0e 93       	st	-X, r16
    6be2:	11 97       	sbiw	r26, 0x01	; 1
    6be4:	8c ec       	ldi	r24, 0xCC	; 204
    6be6:	94 e0       	ldi	r25, 0x04	; 4
    6be8:	93 83       	std	Z+3, r25	; 0x03
    6bea:	82 83       	std	Z+2, r24	; 0x02
    6bec:	f5 82       	std	Z+5, r15	; 0x05
    6bee:	e4 82       	std	Z+4, r14	; 0x04
    6bf0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
    6bf4:	d6 01       	movw	r26, r12
    6bf6:	0d 90       	ld	r0, X+
    6bf8:	00 20       	and	r0, r0
    6bfa:	e9 f7       	brne	.-6      	; 0x6bf6 <systemGenerateReport+0x8c0>
    6bfc:	11 97       	sbiw	r26, 0x01	; 1
    6bfe:	ac 19       	sub	r26, r12
    6c00:	bd 09       	sbc	r27, r13
    6c02:	f8 01       	movw	r30, r16
    6c04:	01 90       	ld	r0, Z+
    6c06:	00 20       	and	r0, r0
    6c08:	e9 f7       	brne	.-6      	; 0x6c04 <systemGenerateReport+0x8ce>
    6c0a:	31 97       	sbiw	r30, 0x01	; 1
    6c0c:	0e 1b       	sub	r16, r30
    6c0e:	0a 1b       	sub	r16, r26
    6c10:	05 5e       	subi	r16, 0xE5	; 229
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6c12:	ed b7       	in	r30, 0x3d	; 61
    6c14:	fe b7       	in	r31, 0x3e	; 62
    6c16:	36 96       	adiw	r30, 0x06	; 6
    6c18:	0f b6       	in	r0, 0x3f	; 63
    6c1a:	f8 94       	cli
    6c1c:	fe bf       	out	0x3e, r31	; 62
    6c1e:	0f be       	out	0x3f, r0	; 63
    6c20:	ed bf       	out	0x3d, r30	; 61
    6c22:	fe 01       	movw	r30, r28
    6c24:	e3 58       	subi	r30, 0x83	; 131
    6c26:	ff 4f       	sbci	r31, 0xFF	; 255
    6c28:	10 16       	cp	r1, r16
    6c2a:	74 f4       	brge	.+28     	; 0x6c48 <systemGenerateReport+0x912>
    6c2c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6c2e:	90 e2       	ldi	r25, 0x20	; 32
    6c30:	02 c0       	rjmp	.+4      	; 0x6c36 <systemGenerateReport+0x900>
    6c32:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6c34:	8f 5f       	subi	r24, 0xFF	; 255
    6c36:	80 17       	cp	r24, r16
    6c38:	e0 f3       	brcs	.-8      	; 0x6c32 <systemGenerateReport+0x8fc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6c3a:	fe 01       	movw	r30, r28
    6c3c:	e3 58       	subi	r30, 0x83	; 131
    6c3e:	ff 4f       	sbci	r31, 0xFF	; 255
    6c40:	e0 0f       	add	r30, r16
    6c42:	f1 1d       	adc	r31, r1
    6c44:	10 82       	st	Z, r1
    6c46:	03 c0       	rjmp	.+6      	; 0x6c4e <systemGenerateReport+0x918>
     }else{
	 strTab[0]=' ';
    6c48:	80 e2       	ldi	r24, 0x20	; 32
    6c4a:	80 83       	st	Z, r24
	 strTab[1]=0;
    6c4c:	11 82       	std	Z+1, r1	; 0x01
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
		      sprintf_P(strReport,PSTR("P%d.%d - %s %s %s"),PumpNum,PumpNozzle,strProduct,strTabSpace2,strProductPrice);
    6c4e:	8d b7       	in	r24, 0x3d	; 61
    6c50:	9e b7       	in	r25, 0x3e	; 62
    6c52:	0e 97       	sbiw	r24, 0x0e	; 14
    6c54:	0f b6       	in	r0, 0x3f	; 63
    6c56:	f8 94       	cli
    6c58:	9e bf       	out	0x3e, r25	; 62
    6c5a:	0f be       	out	0x3f, r0	; 63
    6c5c:	8d bf       	out	0x3d, r24	; 61
    6c5e:	ed b7       	in	r30, 0x3d	; 61
    6c60:	fe b7       	in	r31, 0x3e	; 62
    6c62:	31 96       	adiw	r30, 0x01	; 1
    6c64:	ce 01       	movw	r24, r28
    6c66:	8b 55       	subi	r24, 0x5B	; 91
    6c68:	9f 4f       	sbci	r25, 0xFF	; 255
    6c6a:	ad b7       	in	r26, 0x3d	; 61
    6c6c:	be b7       	in	r27, 0x3e	; 62
    6c6e:	12 96       	adiw	r26, 0x02	; 2
    6c70:	9c 93       	st	X, r25
    6c72:	8e 93       	st	-X, r24
    6c74:	11 97       	sbiw	r26, 0x01	; 1
    6c76:	8a eb       	ldi	r24, 0xBA	; 186
    6c78:	94 e0       	ldi	r25, 0x04	; 4
    6c7a:	93 83       	std	Z+3, r25	; 0x03
    6c7c:	82 83       	std	Z+2, r24	; 0x02
    6c7e:	80 91 10 02 	lds	r24, 0x0210
    6c82:	84 83       	std	Z+4, r24	; 0x04
    6c84:	15 82       	std	Z+5, r1	; 0x05
    6c86:	80 91 0f 02 	lds	r24, 0x020F
    6c8a:	86 83       	std	Z+6, r24	; 0x06
    6c8c:	17 82       	std	Z+7, r1	; 0x07
    6c8e:	81 e9       	ldi	r24, 0x91	; 145
    6c90:	99 e0       	ldi	r25, 0x09	; 9
    6c92:	91 87       	std	Z+9, r25	; 0x09
    6c94:	80 87       	std	Z+8, r24	; 0x08
    6c96:	ce 01       	movw	r24, r28
    6c98:	83 58       	subi	r24, 0x83	; 131
    6c9a:	9f 4f       	sbci	r25, 0xFF	; 255
    6c9c:	93 87       	std	Z+11, r25	; 0x0b
    6c9e:	82 87       	std	Z+10, r24	; 0x0a
    6ca0:	ce 01       	movw	r24, r28
    6ca2:	8f 56       	subi	r24, 0x6F	; 111
    6ca4:	9f 4f       	sbci	r25, 0xFF	; 255
    6ca6:	95 87       	std	Z+13, r25	; 0x0d
    6ca8:	84 87       	std	Z+12, r24	; 0x0c
    6caa:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    6cae:	ed b7       	in	r30, 0x3d	; 61
    6cb0:	fe b7       	in	r31, 0x3e	; 62
    6cb2:	3e 96       	adiw	r30, 0x0e	; 14
    6cb4:	27 c0       	rjmp	.+78     	; 0x6d04 <systemGenerateReport+0x9ce>
		  }
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
    6cb6:	8d b7       	in	r24, 0x3d	; 61
    6cb8:	9e b7       	in	r25, 0x3e	; 62
    6cba:	0a 97       	sbiw	r24, 0x0a	; 10
    6cbc:	0f b6       	in	r0, 0x3f	; 63
    6cbe:	f8 94       	cli
    6cc0:	9e bf       	out	0x3e, r25	; 62
    6cc2:	0f be       	out	0x3f, r0	; 63
    6cc4:	8d bf       	out	0x3d, r24	; 61
    6cc6:	ed b7       	in	r30, 0x3d	; 61
    6cc8:	fe b7       	in	r31, 0x3e	; 62
    6cca:	31 96       	adiw	r30, 0x01	; 1
    6ccc:	ce 01       	movw	r24, r28
    6cce:	8b 55       	subi	r24, 0x5B	; 91
    6cd0:	9f 4f       	sbci	r25, 0xFF	; 255
    6cd2:	ad b7       	in	r26, 0x3d	; 61
    6cd4:	be b7       	in	r27, 0x3e	; 62
    6cd6:	12 96       	adiw	r26, 0x02	; 2
    6cd8:	9c 93       	st	X, r25
    6cda:	8e 93       	st	-X, r24
    6cdc:	11 97       	sbiw	r26, 0x01	; 1
    6cde:	8d ea       	ldi	r24, 0xAD	; 173
    6ce0:	94 e0       	ldi	r25, 0x04	; 4
    6ce2:	93 83       	std	Z+3, r25	; 0x03
    6ce4:	82 83       	std	Z+2, r24	; 0x02
    6ce6:	80 91 10 02 	lds	r24, 0x0210
    6cea:	84 83       	std	Z+4, r24	; 0x04
    6cec:	15 82       	std	Z+5, r1	; 0x05
    6cee:	80 91 0f 02 	lds	r24, 0x020F
    6cf2:	86 83       	std	Z+6, r24	; 0x06
    6cf4:	17 82       	std	Z+7, r1	; 0x07
    6cf6:	d1 86       	std	Z+9, r13	; 0x09
    6cf8:	c0 86       	std	Z+8, r12	; 0x08
    6cfa:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    6cfe:	ed b7       	in	r30, 0x3d	; 61
    6d00:	fe b7       	in	r31, 0x3e	; 62
    6d02:	3a 96       	adiw	r30, 0x0a	; 10
    6d04:	0f b6       	in	r0, 0x3f	; 63
    6d06:	f8 94       	cli
    6d08:	fe bf       	out	0x3e, r31	; 62
    6d0a:	0f be       	out	0x3f, r0	; 63
    6d0c:	ed bf       	out	0x3d, r30	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    6d0e:	ce 01       	movw	r24, r28
    6d10:	8b 55       	subi	r24, 0x5B	; 91
    6d12:	9f 4f       	sbci	r25, 0xFF	; 255
    6d14:	6f e1       	ldi	r22, 0x1F	; 31
    6d16:	76 e0       	ldi	r23, 0x06	; 6
    6d18:	42 e0       	ldi	r20, 0x02	; 2
    6d1a:	52 e0       	ldi	r21, 0x02	; 2
    6d1c:	0e 94 8e 20 	call	0x411c	; 0x411c <CreateReport>
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    6d20:	84 e0       	ldi	r24, 0x04	; 4
    6d22:	6f e1       	ldi	r22, 0x1F	; 31
    6d24:	76 e0       	ldi	r23, 0x06	; 6
    6d26:	41 e0       	ldi	r20, 0x01	; 1
    6d28:	22 e0       	ldi	r18, 0x02	; 2
    6d2a:	32 e0       	ldi	r19, 0x02	; 2
    6d2c:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    6d30:	8b e0       	ldi	r24, 0x0B	; 11
    6d32:	6f e1       	ldi	r22, 0x1F	; 31
    6d34:	76 e0       	ldi	r23, 0x06	; 6
    6d36:	4a e2       	ldi	r20, 0x2A	; 42
    6d38:	22 e0       	ldi	r18, 0x02	; 2
    6d3a:	32 e0       	ldi	r19, 0x02	; 2
    6d3c:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    6d40:	86 e0       	ldi	r24, 0x06	; 6
    6d42:	6f e1       	ldi	r22, 0x1F	; 31
    6d44:	76 e0       	ldi	r23, 0x06	; 6
    6d46:	41 e0       	ldi	r20, 0x01	; 1
    6d48:	22 e0       	ldi	r18, 0x02	; 2
    6d4a:	32 e0       	ldi	r19, 0x02	; 2
    6d4c:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    6d50:	8c e0       	ldi	r24, 0x0C	; 12
    6d52:	6f e1       	ldi	r22, 0x1F	; 31
    6d54:	76 e0       	ldi	r23, 0x06	; 6
    6d56:	41 e0       	ldi	r20, 0x01	; 1
    6d58:	22 e0       	ldi	r18, 0x02	; 2
    6d5a:	32 e0       	ldi	r19, 0x02	; 2
    6d5c:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
    6d60:	de 01       	movw	r26, r28
    6d62:	d7 96       	adiw	r26, 0x37	; 55
    6d64:	fd 01       	movw	r30, r26
    6d66:	01 90       	ld	r0, Z+
    6d68:	00 20       	and	r0, r0
    6d6a:	e9 f7       	brne	.-6      	; 0x6d66 <systemGenerateReport+0xa30>
    6d6c:	9a 2f       	mov	r25, r26
    6d6e:	9e 1b       	sub	r25, r30
    6d70:	9e 5e       	subi	r25, 0xEE	; 238
    6d72:	de 01       	movw	r26, r28
    6d74:	a7 59       	subi	r26, 0x97	; 151
    6d76:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6d78:	19 16       	cp	r1, r25
    6d7a:	7c f4       	brge	.+30     	; 0x6d9a <systemGenerateReport+0xa64>
    6d7c:	fd 01       	movw	r30, r26
    6d7e:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6d80:	20 e2       	ldi	r18, 0x20	; 32
    6d82:	02 c0       	rjmp	.+4      	; 0x6d88 <systemGenerateReport+0xa52>
    6d84:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6d86:	8f 5f       	subi	r24, 0xFF	; 255
    6d88:	89 17       	cp	r24, r25
    6d8a:	e0 f3       	brcs	.-8      	; 0x6d84 <systemGenerateReport+0xa4e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6d8c:	fe 01       	movw	r30, r28
    6d8e:	e7 59       	subi	r30, 0x97	; 151
    6d90:	ff 4f       	sbci	r31, 0xFF	; 255
    6d92:	e9 0f       	add	r30, r25
    6d94:	f1 1d       	adc	r31, r1
    6d96:	10 82       	st	Z, r1
    6d98:	04 c0       	rjmp	.+8      	; 0x6da2 <systemGenerateReport+0xa6c>
     }else{
	 strTab[0]=' ';
    6d9a:	80 e2       	ldi	r24, 0x20	; 32
    6d9c:	8c 93       	st	X, r24
	 strTab[1]=0;
    6d9e:	11 96       	adiw	r26, 0x01	; 1
    6da0:	1c 92       	st	X, r1
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
		  CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
    6da2:	de 01       	movw	r26, r28
    6da4:	aa 5b       	subi	r26, 0xBA	; 186
    6da6:	bf 4f       	sbci	r27, 0xFF	; 255
    6da8:	fd 01       	movw	r30, r26
    6daa:	01 90       	ld	r0, Z+
    6dac:	00 20       	and	r0, r0
    6dae:	e9 f7       	brne	.-6      	; 0x6daa <systemGenerateReport+0xa74>
    6db0:	ae 1b       	sub	r26, r30
    6db2:	a0 5f       	subi	r26, 0xF0	; 240
    6db4:	fe 01       	movw	r30, r28
    6db6:	e3 58       	subi	r30, 0x83	; 131
    6db8:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6dba:	1a 16       	cp	r1, r26
    6dbc:	74 f4       	brge	.+28     	; 0x6dda <systemGenerateReport+0xaa4>
    6dbe:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6dc0:	90 e2       	ldi	r25, 0x20	; 32
    6dc2:	02 c0       	rjmp	.+4      	; 0x6dc8 <systemGenerateReport+0xa92>
    6dc4:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6dc6:	8f 5f       	subi	r24, 0xFF	; 255
    6dc8:	8a 17       	cp	r24, r26
    6dca:	e0 f3       	brcs	.-8      	; 0x6dc4 <systemGenerateReport+0xa8e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6dcc:	fe 01       	movw	r30, r28
    6dce:	e3 58       	subi	r30, 0x83	; 131
    6dd0:	ff 4f       	sbci	r31, 0xFF	; 255
    6dd2:	ea 0f       	add	r30, r26
    6dd4:	f1 1d       	adc	r31, r1
    6dd6:	10 82       	st	Z, r1
    6dd8:	03 c0       	rjmp	.+6      	; 0x6de0 <systemGenerateReport+0xaaa>
     }else{
	 strTab[0]=' ';
    6dda:	80 e2       	ldi	r24, 0x20	; 32
    6ddc:	80 83       	st	Z, r24
	 strTab[1]=0;
    6dde:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6de0:	e1 99       	sbic	0x1c, 1	; 28
    6de2:	fe cf       	rjmp	.-4      	; 0x6de0 <systemGenerateReport+0xaaa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6de4:	11 ec       	ldi	r17, 0xC1	; 193
    6de6:	e1 2e       	mov	r14, r17
    6de8:	13 e0       	ldi	r17, 0x03	; 3
    6dea:	f1 2e       	mov	r15, r17
    6dec:	ff ba       	out	0x1f, r15	; 31
    6dee:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6df0:	e0 9a       	sbi	0x1c, 0	; 28
    6df2:	8d b3       	in	r24, 0x1d	; 29
    6df4:	9e 01       	movw	r18, r28
    6df6:	2b 55       	subi	r18, 0x5B	; 91
    6df8:	3f 4f       	sbci	r19, 0xFF	; 255
    6dfa:	ae 01       	movw	r20, r28
    6dfc:	49 5c       	subi	r20, 0xC9	; 201
    6dfe:	5f 4f       	sbci	r21, 0xFF	; 255
    6e00:	de 01       	movw	r26, r28
    6e02:	a7 59       	subi	r26, 0x97	; 151
    6e04:	bf 4f       	sbci	r27, 0xFF	; 255
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    6e06:	81 30       	cpi	r24, 0x01	; 1
    6e08:	49 f5       	brne	.+82     	; 0x6e5c <systemGenerateReport+0xb26>
    6e0a:	8d b7       	in	r24, 0x3d	; 61
    6e0c:	9e b7       	in	r25, 0x3e	; 62
    6e0e:	0c 97       	sbiw	r24, 0x0c	; 12
    6e10:	0f b6       	in	r0, 0x3f	; 63
    6e12:	f8 94       	cli
    6e14:	9e bf       	out	0x3e, r25	; 62
    6e16:	0f be       	out	0x3f, r0	; 63
    6e18:	8d bf       	out	0x3d, r24	; 61
    6e1a:	6d b7       	in	r22, 0x3d	; 61
    6e1c:	7e b7       	in	r23, 0x3e	; 62
    6e1e:	6f 5f       	subi	r22, 0xFF	; 255
    6e20:	7f 4f       	sbci	r23, 0xFF	; 255
    6e22:	ed b7       	in	r30, 0x3d	; 61
    6e24:	fe b7       	in	r31, 0x3e	; 62
    6e26:	32 83       	std	Z+2, r19	; 0x02
    6e28:	21 83       	std	Z+1, r18	; 0x01
    6e2a:	8e e9       	ldi	r24, 0x9E	; 158
    6e2c:	94 e0       	ldi	r25, 0x04	; 4
    6e2e:	fb 01       	movw	r30, r22
    6e30:	93 83       	std	Z+3, r25	; 0x03
    6e32:	82 83       	std	Z+2, r24	; 0x02
    6e34:	b5 83       	std	Z+5, r27	; 0x05
    6e36:	a4 83       	std	Z+4, r26	; 0x04
    6e38:	57 83       	std	Z+7, r21	; 0x07
    6e3a:	46 83       	std	Z+6, r20	; 0x06
    6e3c:	ce 01       	movw	r24, r28
    6e3e:	83 58       	subi	r24, 0x83	; 131
    6e40:	9f 4f       	sbci	r25, 0xFF	; 255
    6e42:	91 87       	std	Z+9, r25	; 0x09
    6e44:	80 87       	std	Z+8, r24	; 0x08
    6e46:	ce 01       	movw	r24, r28
    6e48:	8a 5b       	subi	r24, 0xBA	; 186
    6e4a:	9f 4f       	sbci	r25, 0xFF	; 255
    6e4c:	93 87       	std	Z+11, r25	; 0x0b
    6e4e:	82 87       	std	Z+10, r24	; 0x0a
    6e50:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    6e54:	8d b7       	in	r24, 0x3d	; 61
    6e56:	9e b7       	in	r25, 0x3e	; 62
    6e58:	0c 96       	adiw	r24, 0x0c	; 12
    6e5a:	1c c0       	rjmp	.+56     	; 0x6e94 <systemGenerateReport+0xb5e>
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
    6e5c:	ed b7       	in	r30, 0x3d	; 61
    6e5e:	fe b7       	in	r31, 0x3e	; 62
    6e60:	38 97       	sbiw	r30, 0x08	; 8
    6e62:	0f b6       	in	r0, 0x3f	; 63
    6e64:	f8 94       	cli
    6e66:	fe bf       	out	0x3e, r31	; 62
    6e68:	0f be       	out	0x3f, r0	; 63
    6e6a:	ed bf       	out	0x3d, r30	; 61
    6e6c:	6d b7       	in	r22, 0x3d	; 61
    6e6e:	7e b7       	in	r23, 0x3e	; 62
    6e70:	6f 5f       	subi	r22, 0xFF	; 255
    6e72:	7f 4f       	sbci	r23, 0xFF	; 255
    6e74:	32 83       	std	Z+2, r19	; 0x02
    6e76:	21 83       	std	Z+1, r18	; 0x01
    6e78:	83 e9       	ldi	r24, 0x93	; 147
    6e7a:	94 e0       	ldi	r25, 0x04	; 4
    6e7c:	fb 01       	movw	r30, r22
    6e7e:	93 83       	std	Z+3, r25	; 0x03
    6e80:	82 83       	std	Z+2, r24	; 0x02
    6e82:	b5 83       	std	Z+5, r27	; 0x05
    6e84:	a4 83       	std	Z+4, r26	; 0x04
    6e86:	57 83       	std	Z+7, r21	; 0x07
    6e88:	46 83       	std	Z+6, r20	; 0x06
    6e8a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    6e8e:	8d b7       	in	r24, 0x3d	; 61
    6e90:	9e b7       	in	r25, 0x3e	; 62
    6e92:	08 96       	adiw	r24, 0x08	; 8
    6e94:	0f b6       	in	r0, 0x3f	; 63
    6e96:	f8 94       	cli
    6e98:	9e bf       	out	0x3e, r25	; 62
    6e9a:	0f be       	out	0x3f, r0	; 63
    6e9c:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    6e9e:	ce 01       	movw	r24, r28
    6ea0:	8b 55       	subi	r24, 0x5B	; 91
    6ea2:	9f 4f       	sbci	r25, 0xFF	; 255
    6ea4:	6f e1       	ldi	r22, 0x1F	; 31
    6ea6:	76 e0       	ldi	r23, 0x06	; 6
    6ea8:	42 e0       	ldi	r20, 0x02	; 2
    6eaa:	52 e0       	ldi	r21, 0x02	; 2
    6eac:	0e 94 8e 20 	call	0x411c	; 0x411c <CreateReport>

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
    6eb0:	de 01       	movw	r26, r28
    6eb2:	59 96       	adiw	r26, 0x19	; 25
    6eb4:	fd 01       	movw	r30, r26
    6eb6:	01 90       	ld	r0, Z+
    6eb8:	00 20       	and	r0, r0
    6eba:	e9 f7       	brne	.-6      	; 0x6eb6 <systemGenerateReport+0xb80>
    6ebc:	9a 2f       	mov	r25, r26
    6ebe:	9e 1b       	sub	r25, r30
    6ec0:	9e 5e       	subi	r25, 0xEE	; 238
    6ec2:	de 01       	movw	r26, r28
    6ec4:	a7 59       	subi	r26, 0x97	; 151
    6ec6:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6ec8:	19 16       	cp	r1, r25
    6eca:	7c f4       	brge	.+30     	; 0x6eea <systemGenerateReport+0xbb4>
    6ecc:	fd 01       	movw	r30, r26
    6ece:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6ed0:	20 e2       	ldi	r18, 0x20	; 32
    6ed2:	02 c0       	rjmp	.+4      	; 0x6ed8 <systemGenerateReport+0xba2>
    6ed4:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6ed6:	8f 5f       	subi	r24, 0xFF	; 255
    6ed8:	89 17       	cp	r24, r25
    6eda:	e0 f3       	brcs	.-8      	; 0x6ed4 <systemGenerateReport+0xb9e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6edc:	fe 01       	movw	r30, r28
    6ede:	e7 59       	subi	r30, 0x97	; 151
    6ee0:	ff 4f       	sbci	r31, 0xFF	; 255
    6ee2:	e9 0f       	add	r30, r25
    6ee4:	f1 1d       	adc	r31, r1
    6ee6:	10 82       	st	Z, r1
    6ee8:	04 c0       	rjmp	.+8      	; 0x6ef2 <systemGenerateReport+0xbbc>
     }else{
	 strTab[0]=' ';
    6eea:	80 e2       	ldi	r24, 0x20	; 32
    6eec:	8c 93       	st	X, r24
	 strTab[1]=0;
    6eee:	11 96       	adiw	r26, 0x01	; 1
    6ef0:	1c 92       	st	X, r1
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
    6ef2:	de 01       	movw	r26, r28
    6ef4:	98 96       	adiw	r26, 0x28	; 40
    6ef6:	fd 01       	movw	r30, r26
    6ef8:	01 90       	ld	r0, Z+
    6efa:	00 20       	and	r0, r0
    6efc:	e9 f7       	brne	.-6      	; 0x6ef8 <systemGenerateReport+0xbc2>
    6efe:	ae 1b       	sub	r26, r30
    6f00:	a0 5f       	subi	r26, 0xF0	; 240
    6f02:	fe 01       	movw	r30, r28
    6f04:	e3 58       	subi	r30, 0x83	; 131
    6f06:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6f08:	1a 16       	cp	r1, r26
    6f0a:	74 f4       	brge	.+28     	; 0x6f28 <systemGenerateReport+0xbf2>
    6f0c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6f0e:	90 e2       	ldi	r25, 0x20	; 32
    6f10:	02 c0       	rjmp	.+4      	; 0x6f16 <systemGenerateReport+0xbe0>
    6f12:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6f14:	8f 5f       	subi	r24, 0xFF	; 255
    6f16:	8a 17       	cp	r24, r26
    6f18:	e0 f3       	brcs	.-8      	; 0x6f12 <systemGenerateReport+0xbdc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6f1a:	fe 01       	movw	r30, r28
    6f1c:	e3 58       	subi	r30, 0x83	; 131
    6f1e:	ff 4f       	sbci	r31, 0xFF	; 255
    6f20:	ea 0f       	add	r30, r26
    6f22:	f1 1d       	adc	r31, r1
    6f24:	10 82       	st	Z, r1
    6f26:	03 c0       	rjmp	.+6      	; 0x6f2e <systemGenerateReport+0xbf8>
     }else{
	 strTab[0]=' ';
    6f28:	80 e2       	ldi	r24, 0x20	; 32
    6f2a:	80 83       	st	Z, r24
	 strTab[1]=0;
    6f2c:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6f2e:	e1 99       	sbic	0x1c, 1	; 28
    6f30:	fe cf       	rjmp	.-4      	; 0x6f2e <systemGenerateReport+0xbf8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6f32:	ff ba       	out	0x1f, r15	; 31
    6f34:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6f36:	e0 9a       	sbi	0x1c, 0	; 28
    6f38:	8d b3       	in	r24, 0x1d	; 29
    6f3a:	9e 01       	movw	r18, r28
    6f3c:	2b 55       	subi	r18, 0x5B	; 91
    6f3e:	3f 4f       	sbci	r19, 0xFF	; 255
    6f40:	ae 01       	movw	r20, r28
    6f42:	47 5e       	subi	r20, 0xE7	; 231
    6f44:	5f 4f       	sbci	r21, 0xFF	; 255
    6f46:	de 01       	movw	r26, r28
    6f48:	a7 59       	subi	r26, 0x97	; 151
    6f4a:	bf 4f       	sbci	r27, 0xFF	; 255
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("Awal :%s%s%s%s"),strTabSpace,strLastVolume,strTabSpace2,strLastMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    6f4c:	81 30       	cpi	r24, 0x01	; 1
    6f4e:	31 f5       	brne	.+76     	; 0x6f9c <systemGenerateReport+0xc66>
    6f50:	ed b7       	in	r30, 0x3d	; 61
    6f52:	fe b7       	in	r31, 0x3e	; 62
    6f54:	3c 97       	sbiw	r30, 0x0c	; 12
    6f56:	0f b6       	in	r0, 0x3f	; 63
    6f58:	f8 94       	cli
    6f5a:	fe bf       	out	0x3e, r31	; 62
    6f5c:	0f be       	out	0x3f, r0	; 63
    6f5e:	ed bf       	out	0x3d, r30	; 61
    6f60:	6d b7       	in	r22, 0x3d	; 61
    6f62:	7e b7       	in	r23, 0x3e	; 62
    6f64:	6f 5f       	subi	r22, 0xFF	; 255
    6f66:	7f 4f       	sbci	r23, 0xFF	; 255
    6f68:	32 83       	std	Z+2, r19	; 0x02
    6f6a:	21 83       	std	Z+1, r18	; 0x01
    6f6c:	84 e8       	ldi	r24, 0x84	; 132
    6f6e:	94 e0       	ldi	r25, 0x04	; 4
    6f70:	fb 01       	movw	r30, r22
    6f72:	93 83       	std	Z+3, r25	; 0x03
    6f74:	82 83       	std	Z+2, r24	; 0x02
    6f76:	b5 83       	std	Z+5, r27	; 0x05
    6f78:	a4 83       	std	Z+4, r26	; 0x04
    6f7a:	57 83       	std	Z+7, r21	; 0x07
    6f7c:	46 83       	std	Z+6, r20	; 0x06
    6f7e:	ce 01       	movw	r24, r28
    6f80:	83 58       	subi	r24, 0x83	; 131
    6f82:	9f 4f       	sbci	r25, 0xFF	; 255
    6f84:	91 87       	std	Z+9, r25	; 0x09
    6f86:	80 87       	std	Z+8, r24	; 0x08
    6f88:	ce 01       	movw	r24, r28
    6f8a:	88 96       	adiw	r24, 0x28	; 40
    6f8c:	93 87       	std	Z+11, r25	; 0x0b
    6f8e:	82 87       	std	Z+10, r24	; 0x0a
    6f90:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    6f94:	8d b7       	in	r24, 0x3d	; 61
    6f96:	9e b7       	in	r25, 0x3e	; 62
    6f98:	0c 96       	adiw	r24, 0x0c	; 12
    6f9a:	1c c0       	rjmp	.+56     	; 0x6fd4 <systemGenerateReport+0xc9e>
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
    6f9c:	ed b7       	in	r30, 0x3d	; 61
    6f9e:	fe b7       	in	r31, 0x3e	; 62
    6fa0:	38 97       	sbiw	r30, 0x08	; 8
    6fa2:	0f b6       	in	r0, 0x3f	; 63
    6fa4:	f8 94       	cli
    6fa6:	fe bf       	out	0x3e, r31	; 62
    6fa8:	0f be       	out	0x3f, r0	; 63
    6faa:	ed bf       	out	0x3d, r30	; 61
    6fac:	6d b7       	in	r22, 0x3d	; 61
    6fae:	7e b7       	in	r23, 0x3e	; 62
    6fb0:	6f 5f       	subi	r22, 0xFF	; 255
    6fb2:	7f 4f       	sbci	r23, 0xFF	; 255
    6fb4:	32 83       	std	Z+2, r19	; 0x02
    6fb6:	21 83       	std	Z+1, r18	; 0x01
    6fb8:	89 e7       	ldi	r24, 0x79	; 121
    6fba:	94 e0       	ldi	r25, 0x04	; 4
    6fbc:	fb 01       	movw	r30, r22
    6fbe:	93 83       	std	Z+3, r25	; 0x03
    6fc0:	82 83       	std	Z+2, r24	; 0x02
    6fc2:	b5 83       	std	Z+5, r27	; 0x05
    6fc4:	a4 83       	std	Z+4, r26	; 0x04
    6fc6:	57 83       	std	Z+7, r21	; 0x07
    6fc8:	46 83       	std	Z+6, r20	; 0x06
    6fca:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    6fce:	8d b7       	in	r24, 0x3d	; 61
    6fd0:	9e b7       	in	r25, 0x3e	; 62
    6fd2:	08 96       	adiw	r24, 0x08	; 8
    6fd4:	0f b6       	in	r0, 0x3f	; 63
    6fd6:	f8 94       	cli
    6fd8:	9e bf       	out	0x3e, r25	; 62
    6fda:	0f be       	out	0x3f, r0	; 63
    6fdc:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    6fde:	ce 01       	movw	r24, r28
    6fe0:	8b 55       	subi	r24, 0x5B	; 91
    6fe2:	9f 4f       	sbci	r25, 0xFF	; 255
    6fe4:	6f e1       	ldi	r22, 0x1F	; 31
    6fe6:	76 e0       	ldi	r23, 0x06	; 6
    6fe8:	42 e0       	ldi	r20, 0x02	; 2
    6fea:	52 e0       	ldi	r21, 0x02	; 2
    6fec:	0e 94 8e 20 	call	0x411c	; 0x411c <CreateReport>
    6ff0:	8e 01       	movw	r16, r28
    6ff2:	07 59       	subi	r16, 0x97	; 151
    6ff4:	1f 4f       	sbci	r17, 0xFF	; 255
    6ff6:	f8 01       	movw	r30, r16
void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6ff8:	20 e2       	ldi	r18, 0x20	; 32

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6ffa:	d8 01       	movw	r26, r16
    6ffc:	c8 01       	movw	r24, r16
    6ffe:	0c 96       	adiw	r24, 0x0c	; 12
		     strTab[i]=' ';
    7000:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7002:	e8 17       	cp	r30, r24
    7004:	f9 07       	cpc	r31, r25
    7006:	e1 f7       	brne	.-8      	; 0x7000 <systemGenerateReport+0xcca>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7008:	1c 96       	adiw	r26, 0x0c	; 12
    700a:	1c 92       	st	X, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    700c:	e1 99       	sbic	0x1c, 1	; 28
    700e:	fe cf       	rjmp	.-4      	; 0x700c <systemGenerateReport+0xcd6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7010:	ff ba       	out	0x1f, r15	; 31
    7012:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7014:	e0 9a       	sbi	0x1c, 0	; 28
    7016:	8d b3       	in	r24, 0x1d	; 29
    7018:	9e 01       	movw	r18, r28
    701a:	2b 55       	subi	r18, 0x5B	; 91
    701c:	3f 4f       	sbci	r19, 0xFF	; 255
    701e:	de 01       	movw	r26, r28
    7020:	a7 59       	subi	r26, 0x97	; 151
    7022:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace(12,strTabSpace);
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
    7024:	81 30       	cpi	r24, 0x01	; 1
    7026:	71 f4       	brne	.+28     	; 0x7044 <systemGenerateReport+0xd0e>
    7028:	00 d0       	rcall	.+0      	; 0x702a <systemGenerateReport+0xcf4>
    702a:	00 d0       	rcall	.+0      	; 0x702c <systemGenerateReport+0xcf6>
    702c:	00 d0       	rcall	.+0      	; 0x702e <systemGenerateReport+0xcf8>
    702e:	4d b7       	in	r20, 0x3d	; 61
    7030:	5e b7       	in	r21, 0x3e	; 62
    7032:	4f 5f       	subi	r20, 0xFF	; 255
    7034:	5f 4f       	sbci	r21, 0xFF	; 255
    7036:	ed b7       	in	r30, 0x3d	; 61
    7038:	fe b7       	in	r31, 0x3e	; 62
    703a:	32 83       	std	Z+2, r19	; 0x02
    703c:	21 83       	std	Z+1, r18	; 0x01
    703e:	8b e5       	ldi	r24, 0x5B	; 91
    7040:	94 e0       	ldi	r25, 0x04	; 4
    7042:	0d c0       	rjmp	.+26     	; 0x705e <systemGenerateReport+0xd28>
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);
    7044:	00 d0       	rcall	.+0      	; 0x7046 <systemGenerateReport+0xd10>
    7046:	00 d0       	rcall	.+0      	; 0x7048 <systemGenerateReport+0xd12>
    7048:	00 d0       	rcall	.+0      	; 0x704a <systemGenerateReport+0xd14>
    704a:	4d b7       	in	r20, 0x3d	; 61
    704c:	5e b7       	in	r21, 0x3e	; 62
    704e:	4f 5f       	subi	r20, 0xFF	; 255
    7050:	5f 4f       	sbci	r21, 0xFF	; 255
    7052:	ed b7       	in	r30, 0x3d	; 61
    7054:	fe b7       	in	r31, 0x3e	; 62
    7056:	32 83       	std	Z+2, r19	; 0x02
    7058:	21 83       	std	Z+1, r18	; 0x01
    705a:	8d e3       	ldi	r24, 0x3D	; 61
    705c:	94 e0       	ldi	r25, 0x04	; 4
    705e:	fa 01       	movw	r30, r20
    7060:	93 83       	std	Z+3, r25	; 0x03
    7062:	82 83       	std	Z+2, r24	; 0x02
    7064:	b5 83       	std	Z+5, r27	; 0x05
    7066:	a4 83       	std	Z+4, r26	; 0x04
    7068:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    706c:	8d b7       	in	r24, 0x3d	; 61
    706e:	9e b7       	in	r25, 0x3e	; 62
    7070:	06 96       	adiw	r24, 0x06	; 6
    7072:	0f b6       	in	r0, 0x3f	; 63
    7074:	f8 94       	cli
    7076:	9e bf       	out	0x3e, r25	; 62
    7078:	0f be       	out	0x3f, r0	; 63
    707a:	8d bf       	out	0x3d, r24	; 61
    707c:	ce 01       	movw	r24, r28
    707e:	8b 55       	subi	r24, 0x5B	; 91
    7080:	9f 4f       	sbci	r25, 0xFF	; 255
    7082:	6f e1       	ldi	r22, 0x1F	; 31
    7084:	76 e0       	ldi	r23, 0x06	; 6
    7086:	42 e0       	ldi	r20, 0x02	; 2
    7088:	52 e0       	ldi	r21, 0x02	; 2
    708a:	0e 94 8e 20 	call	0x411c	; 0x411c <CreateReport>

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
    708e:	ed e2       	ldi	r30, 0x2D	; 45
    7090:	fb e0       	ldi	r31, 0x0B	; 11
    7092:	01 90       	ld	r0, Z+
    7094:	00 20       	and	r0, r0
    7096:	e9 f7       	brne	.-6      	; 0x7092 <systemGenerateReport+0xd5c>
    7098:	31 97       	sbiw	r30, 0x01	; 1
    709a:	ed 52       	subi	r30, 0x2D	; 45
    709c:	fb 40       	sbci	r31, 0x0B	; 11
    709e:	97 e1       	ldi	r25, 0x17	; 23
    70a0:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    70a2:	19 16       	cp	r1, r25
    70a4:	84 f4       	brge	.+32     	; 0x70c6 <systemGenerateReport+0xd90>
    70a6:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    70a8:	20 e2       	ldi	r18, 0x20	; 32
    70aa:	04 c0       	rjmp	.+8      	; 0x70b4 <systemGenerateReport+0xd7e>
    70ac:	d8 01       	movw	r26, r16
    70ae:	2d 93       	st	X+, r18
    70b0:	8d 01       	movw	r16, r26

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    70b2:	8f 5f       	subi	r24, 0xFF	; 255
    70b4:	89 17       	cp	r24, r25
    70b6:	d0 f3       	brcs	.-12     	; 0x70ac <systemGenerateReport+0xd76>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    70b8:	fe 01       	movw	r30, r28
    70ba:	e7 59       	subi	r30, 0x97	; 151
    70bc:	ff 4f       	sbci	r31, 0xFF	; 255
    70be:	e9 0f       	add	r30, r25
    70c0:	f1 1d       	adc	r31, r1
    70c2:	10 82       	st	Z, r1
    70c4:	06 c0       	rjmp	.+12     	; 0x70d2 <systemGenerateReport+0xd9c>
     }else{
	 strTab[0]=' ';
    70c6:	fe 01       	movw	r30, r28
    70c8:	e7 59       	subi	r30, 0x97	; 151
    70ca:	ff 4f       	sbci	r31, 0xFF	; 255
    70cc:	80 e2       	ldi	r24, 0x20	; 32
    70ce:	80 83       	st	Z, r24
	 strTab[1]=0;
    70d0:	11 82       	std	Z+1, r1	; 0x01
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
    70d2:	e8 e5       	ldi	r30, 0x58	; 88
    70d4:	fe e0       	ldi	r31, 0x0E	; 14
    70d6:	01 90       	ld	r0, Z+
    70d8:	00 20       	and	r0, r0
    70da:	e9 f7       	brne	.-6      	; 0x70d6 <systemGenerateReport+0xda0>
    70dc:	31 97       	sbiw	r30, 0x01	; 1
    70de:	e8 55       	subi	r30, 0x58	; 88
    70e0:	fe 40       	sbci	r31, 0x0E	; 14
    70e2:	9f e0       	ldi	r25, 0x0F	; 15
    70e4:	9e 1b       	sub	r25, r30
    70e6:	fe 01       	movw	r30, r28
    70e8:	e3 58       	subi	r30, 0x83	; 131
    70ea:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    70ec:	19 16       	cp	r1, r25
    70ee:	74 f4       	brge	.+28     	; 0x710c <systemGenerateReport+0xdd6>
    70f0:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    70f2:	20 e2       	ldi	r18, 0x20	; 32
    70f4:	02 c0       	rjmp	.+4      	; 0x70fa <systemGenerateReport+0xdc4>
    70f6:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    70f8:	8f 5f       	subi	r24, 0xFF	; 255
    70fa:	89 17       	cp	r24, r25
    70fc:	e0 f3       	brcs	.-8      	; 0x70f6 <systemGenerateReport+0xdc0>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    70fe:	fe 01       	movw	r30, r28
    7100:	e3 58       	subi	r30, 0x83	; 131
    7102:	ff 4f       	sbci	r31, 0xFF	; 255
    7104:	e9 0f       	add	r30, r25
    7106:	f1 1d       	adc	r31, r1
    7108:	10 82       	st	Z, r1
    710a:	03 c0       	rjmp	.+6      	; 0x7112 <systemGenerateReport+0xddc>
     }else{
	 strTab[0]=' ';
    710c:	80 e2       	ldi	r24, 0x20	; 32
    710e:	80 83       	st	Z, r24
	 strTab[1]=0;
    7110:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7112:	e1 99       	sbic	0x1c, 1	; 28
    7114:	fe cf       	rjmp	.-4      	; 0x7112 <systemGenerateReport+0xddc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7116:	ff ba       	out	0x1f, r15	; 31
    7118:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    711a:	e0 9a       	sbi	0x1c, 0	; 28
    711c:	8d b3       	in	r24, 0x1d	; 29
    711e:	9e 01       	movw	r18, r28
    7120:	2b 55       	subi	r18, 0x5B	; 91
    7122:	3f 4f       	sbci	r19, 0xFF	; 255
    7124:	4d e2       	ldi	r20, 0x2D	; 45
    7126:	5b e0       	ldi	r21, 0x0B	; 11
    7128:	de 01       	movw	r26, r28
    712a:	a7 59       	subi	r26, 0x97	; 151
    712c:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s%s%s%s"),strTabSpace,strDeltaVolume,strTabSpace2,strDeltaMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    712e:	81 30       	cpi	r24, 0x01	; 1
    7130:	31 f5       	brne	.+76     	; 0x717e <systemGenerateReport+0xe48>
    7132:	ed b7       	in	r30, 0x3d	; 61
    7134:	fe b7       	in	r31, 0x3e	; 62
    7136:	3c 97       	sbiw	r30, 0x0c	; 12
    7138:	0f b6       	in	r0, 0x3f	; 63
    713a:	f8 94       	cli
    713c:	fe bf       	out	0x3e, r31	; 62
    713e:	0f be       	out	0x3f, r0	; 63
    7140:	ed bf       	out	0x3d, r30	; 61
    7142:	6d b7       	in	r22, 0x3d	; 61
    7144:	7e b7       	in	r23, 0x3e	; 62
    7146:	6f 5f       	subi	r22, 0xFF	; 255
    7148:	7f 4f       	sbci	r23, 0xFF	; 255
    714a:	32 83       	std	Z+2, r19	; 0x02
    714c:	21 83       	std	Z+1, r18	; 0x01
    714e:	84 e3       	ldi	r24, 0x34	; 52
    7150:	94 e0       	ldi	r25, 0x04	; 4
    7152:	fb 01       	movw	r30, r22
    7154:	93 83       	std	Z+3, r25	; 0x03
    7156:	82 83       	std	Z+2, r24	; 0x02
    7158:	b5 83       	std	Z+5, r27	; 0x05
    715a:	a4 83       	std	Z+4, r26	; 0x04
    715c:	57 83       	std	Z+7, r21	; 0x07
    715e:	46 83       	std	Z+6, r20	; 0x06
    7160:	ce 01       	movw	r24, r28
    7162:	83 58       	subi	r24, 0x83	; 131
    7164:	9f 4f       	sbci	r25, 0xFF	; 255
    7166:	91 87       	std	Z+9, r25	; 0x09
    7168:	80 87       	std	Z+8, r24	; 0x08
    716a:	88 e5       	ldi	r24, 0x58	; 88
    716c:	9e e0       	ldi	r25, 0x0E	; 14
    716e:	93 87       	std	Z+11, r25	; 0x0b
    7170:	82 87       	std	Z+10, r24	; 0x0a
    7172:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    7176:	8d b7       	in	r24, 0x3d	; 61
    7178:	9e b7       	in	r25, 0x3e	; 62
    717a:	0c 96       	adiw	r24, 0x0c	; 12
    717c:	1c c0       	rjmp	.+56     	; 0x71b6 <systemGenerateReport+0xe80>
          else sprintf_P(strReport,PSTR("%s%s"),strTabSpace,strDeltaVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    717e:	ed b7       	in	r30, 0x3d	; 61
    7180:	fe b7       	in	r31, 0x3e	; 62
    7182:	38 97       	sbiw	r30, 0x08	; 8
    7184:	0f b6       	in	r0, 0x3f	; 63
    7186:	f8 94       	cli
    7188:	fe bf       	out	0x3e, r31	; 62
    718a:	0f be       	out	0x3f, r0	; 63
    718c:	ed bf       	out	0x3d, r30	; 61
    718e:	6d b7       	in	r22, 0x3d	; 61
    7190:	7e b7       	in	r23, 0x3e	; 62
    7192:	6f 5f       	subi	r22, 0xFF	; 255
    7194:	7f 4f       	sbci	r23, 0xFF	; 255
    7196:	32 83       	std	Z+2, r19	; 0x02
    7198:	21 83       	std	Z+1, r18	; 0x01
    719a:	8f e2       	ldi	r24, 0x2F	; 47
    719c:	94 e0       	ldi	r25, 0x04	; 4
    719e:	fb 01       	movw	r30, r22
    71a0:	93 83       	std	Z+3, r25	; 0x03
    71a2:	82 83       	std	Z+2, r24	; 0x02
    71a4:	b5 83       	std	Z+5, r27	; 0x05
    71a6:	a4 83       	std	Z+4, r26	; 0x04
    71a8:	57 83       	std	Z+7, r21	; 0x07
    71aa:	46 83       	std	Z+6, r20	; 0x06
    71ac:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    71b0:	8d b7       	in	r24, 0x3d	; 61
    71b2:	9e b7       	in	r25, 0x3e	; 62
    71b4:	08 96       	adiw	r24, 0x08	; 8
    71b6:	0f b6       	in	r0, 0x3f	; 63
    71b8:	f8 94       	cli
    71ba:	9e bf       	out	0x3e, r25	; 62
    71bc:	0f be       	out	0x3f, r0	; 63
    71be:	8d bf       	out	0x3d, r24	; 61
    71c0:	ce 01       	movw	r24, r28
    71c2:	8b 55       	subi	r24, 0x5B	; 91
    71c4:	9f 4f       	sbci	r25, 0xFF	; 255
    71c6:	6f e1       	ldi	r22, 0x1F	; 31
    71c8:	76 e0       	ldi	r23, 0x06	; 6
    71ca:	42 e0       	ldi	r20, 0x02	; 2
    71cc:	52 e0       	ldi	r21, 0x02	; 2
    71ce:	0e 94 8e 20 	call	0x411c	; 0x411c <CreateReport>

          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    71d2:	87 e0       	ldi	r24, 0x07	; 7
    71d4:	6f e1       	ldi	r22, 0x1F	; 31
    71d6:	76 e0       	ldi	r23, 0x06	; 6
    71d8:	41 e0       	ldi	r20, 0x01	; 1
    71da:	22 e0       	ldi	r18, 0x02	; 2
    71dc:	32 e0       	ldi	r19, 0x02	; 2
    71de:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    71e2:	8b e0       	ldi	r24, 0x0B	; 11
    71e4:	6f e1       	ldi	r22, 0x1F	; 31
    71e6:	76 e0       	ldi	r23, 0x06	; 6
    71e8:	4a e2       	ldi	r20, 0x2A	; 42
    71ea:	22 e0       	ldi	r18, 0x02	; 2
    71ec:	32 e0       	ldi	r19, 0x02	; 2
    71ee:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    71f2:	89 e0       	ldi	r24, 0x09	; 9
    71f4:	6f e1       	ldi	r22, 0x1F	; 31
    71f6:	76 e0       	ldi	r23, 0x06	; 6
    71f8:	41 e0       	ldi	r20, 0x01	; 1
    71fa:	22 e0       	ldi	r18, 0x02	; 2
    71fc:	32 e0       	ldi	r19, 0x02	; 2
    71fe:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    7202:	8c e0       	ldi	r24, 0x0C	; 12
    7204:	6f e1       	ldi	r22, 0x1F	; 31
    7206:	76 e0       	ldi	r23, 0x06	; 6
    7208:	41 e0       	ldi	r20, 0x01	; 1
    720a:	22 e0       	ldi	r18, 0x02	; 2
    720c:	32 e0       	ldi	r19, 0x02	; 2
    720e:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>


          cmdPrint=0b00000000;
    7212:	10 92 cb 01 	sts	0x01CB, r1
		  LengthMessage81=RepPos+1;
    7216:	80 91 02 02 	lds	r24, 0x0202
    721a:	90 91 03 02 	lds	r25, 0x0203
    721e:	01 96       	adiw	r24, 0x01	; 1
    7220:	90 93 a1 01 	sts	0x01A1, r25
    7224:	80 93 a0 01 	sts	0x01A0, r24

		  IsFreePrinting=True;
    7228:	81 e0       	ldi	r24, 0x01	; 1
    722a:	80 93 bf 01 	sts	0x01BF, r24
	      IsBusyFreePrinting=True;
    722e:	80 93 ca 01 	sts	0x01CA, r24

	      stGenerateReport=grWaitPrinted2;
    7232:	89 e0       	ldi	r24, 0x09	; 9
    7234:	91 c3       	rjmp	.+1826   	; 0x7958 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted2:
	 
          if (IsBusyFreePrinting==False)stGenerateReport=grGenerateReportData;
    7236:	80 91 ca 01 	lds	r24, 0x01CA
    723a:	88 23       	and	r24, r24
    723c:	09 f0       	breq	.+2      	; 0x7240 <systemGenerateReport+0xf0a>
    723e:	94 c3       	rjmp	.+1832   	; 0x7968 <systemGenerateReport+0x1632>
    7240:	86 e0       	ldi	r24, 0x06	; 6
    7242:	8a c3       	rjmp	.+1812   	; 0x7958 <systemGenerateReport+0x1622>
	      break;
     case grCreateReportFooter:
          RepPos=0;
    7244:	10 92 03 02 	sts	0x0203, r1
    7248:	10 92 02 02 	sts	0x0202, r1
    724c:	ef e1       	ldi	r30, 0x1F	; 31
    724e:	f6 e0       	ldi	r31, 0x06	; 6
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    7250:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7252:	97 e0       	ldi	r25, 0x07	; 7
    7254:	e0 3b       	cpi	r30, 0xB0	; 176
    7256:	f9 07       	cpc	r31, r25
    7258:	d9 f7       	brne	.-10     	; 0x7250 <systemGenerateReport+0xf1a>
    725a:	fe 01       	movw	r30, r28
    725c:	eb 55       	subi	r30, 0x5B	; 91
    725e:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    7260:	ce 01       	movw	r24, r28
    7262:	8b 50       	subi	r24, 0x0B	; 11
    7264:	9f 4f       	sbci	r25, 0xFF	; 255
    7266:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7268:	e8 17       	cp	r30, r24
    726a:	f9 07       	cpc	r31, r25
    726c:	e1 f7       	brne	.-8      	; 0x7266 <systemGenerateReport+0xf30>
     case grCreateReportFooter:
          RepPos=0;
		  FillChar(PrintBuffer,sizeof(PrintBuffer),0);
		  FillChar(strReport,sizeof(strReport),0);

		  RemZeroLead(strTotalMoney);
    726e:	8d ef       	ldi	r24, 0xFD	; 253
    7270:	9a e0       	ldi	r25, 0x0A	; 10
    7272:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
		  RemZeroLead(strTotalVolume);
    7276:	0c e4       	ldi	r16, 0x4C	; 76
    7278:	1a e0       	ldi	r17, 0x0A	; 10
    727a:	c8 01       	movw	r24, r16
    727c:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>

		  FormatTotalizerMoney(strTotalMoney);
    7280:	8d ef       	ldi	r24, 0xFD	; 253
    7282:	9a e0       	ldi	r25, 0x0A	; 10
    7284:	0e 94 67 31 	call	0x62ce	; 0x62ce <FormatTotalizerMoney>
		  FormatCurrency(strTotalMoney);
    7288:	8d ef       	ldi	r24, 0xFD	; 253
    728a:	9a e0       	ldi	r25, 0x0A	; 10
    728c:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>
		  FormatTotalizerVolume(strTotalVolume);
    7290:	c8 01       	movw	r24, r16
    7292:	0e 94 5a 31 	call	0x62b4	; 0x62b4 <FormatTotalizerVolume>
		  FormatCurrency(strTotalVolume);
    7296:	c8 01       	movw	r24, r16
    7298:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>

          //Test
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    729c:	81 e0       	ldi	r24, 0x01	; 1
    729e:	6f e1       	ldi	r22, 0x1F	; 31
    72a0:	76 e0       	ldi	r23, 0x06	; 6
    72a2:	41 e0       	ldi	r20, 0x01	; 1
    72a4:	22 e0       	ldi	r18, 0x02	; 2
    72a6:	32 e0       	ldi	r19, 0x02	; 2
    72a8:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    72ac:	8b e0       	ldi	r24, 0x0B	; 11
    72ae:	6f e1       	ldi	r22, 0x1F	; 31
    72b0:	76 e0       	ldi	r23, 0x06	; 6
    72b2:	4a e2       	ldi	r20, 0x2A	; 42
    72b4:	22 e0       	ldi	r18, 0x02	; 2
    72b6:	32 e0       	ldi	r19, 0x02	; 2
    72b8:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    72bc:	83 e0       	ldi	r24, 0x03	; 3
    72be:	6f e1       	ldi	r22, 0x1F	; 31
    72c0:	76 e0       	ldi	r23, 0x06	; 6
    72c2:	41 e0       	ldi	r20, 0x01	; 1
    72c4:	22 e0       	ldi	r18, 0x02	; 2
    72c6:	32 e0       	ldi	r19, 0x02	; 2
    72c8:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    72cc:	8c e0       	ldi	r24, 0x0C	; 12
    72ce:	6f e1       	ldi	r22, 0x1F	; 31
    72d0:	76 e0       	ldi	r23, 0x06	; 6
    72d2:	41 e0       	ldi	r20, 0x01	; 1
    72d4:	22 e0       	ldi	r18, 0x02	; 2
    72d6:	32 e0       	ldi	r19, 0x02	; 2
    72d8:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
    72dc:	d8 01       	movw	r26, r16
    72de:	0d 90       	ld	r0, X+
    72e0:	00 20       	and	r0, r0
    72e2:	e9 f7       	brne	.-6      	; 0x72de <systemGenerateReport+0xfa8>
    72e4:	8d 01       	movw	r16, r26
    72e6:	01 50       	subi	r16, 0x01	; 1
    72e8:	10 40       	sbci	r17, 0x00	; 0
    72ea:	0c 54       	subi	r16, 0x4C	; 76
    72ec:	1a 40       	sbci	r17, 0x0A	; 10
    72ee:	91 e1       	ldi	r25, 0x11	; 17
    72f0:	90 1b       	sub	r25, r16
    72f2:	de 01       	movw	r26, r28
    72f4:	a7 59       	subi	r26, 0x97	; 151
    72f6:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    72f8:	19 16       	cp	r1, r25
    72fa:	7c f4       	brge	.+30     	; 0x731a <systemGenerateReport+0xfe4>
    72fc:	fd 01       	movw	r30, r26
    72fe:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7300:	20 e2       	ldi	r18, 0x20	; 32
    7302:	02 c0       	rjmp	.+4      	; 0x7308 <systemGenerateReport+0xfd2>
    7304:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7306:	8f 5f       	subi	r24, 0xFF	; 255
    7308:	89 17       	cp	r24, r25
    730a:	e0 f3       	brcs	.-8      	; 0x7304 <systemGenerateReport+0xfce>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    730c:	fe 01       	movw	r30, r28
    730e:	e7 59       	subi	r30, 0x97	; 151
    7310:	ff 4f       	sbci	r31, 0xFF	; 255
    7312:	e9 0f       	add	r30, r25
    7314:	f1 1d       	adc	r31, r1
    7316:	10 82       	st	Z, r1
    7318:	04 c0       	rjmp	.+8      	; 0x7322 <systemGenerateReport+0xfec>
     }else{
	 strTab[0]=' ';
    731a:	80 e2       	ldi	r24, 0x20	; 32
    731c:	8c 93       	st	X, r24
	 strTab[1]=0;
    731e:	11 96       	adiw	r26, 0x01	; 1
    7320:	1c 92       	st	X, r1
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    7322:	ed ef       	ldi	r30, 0xFD	; 253
    7324:	fa e0       	ldi	r31, 0x0A	; 10
    7326:	01 90       	ld	r0, Z+
    7328:	00 20       	and	r0, r0
    732a:	e9 f7       	brne	.-6      	; 0x7326 <systemGenerateReport+0xff0>
    732c:	31 97       	sbiw	r30, 0x01	; 1
    732e:	ed 5f       	subi	r30, 0xFD	; 253
    7330:	fa 40       	sbci	r31, 0x0A	; 10
    7332:	9f e0       	ldi	r25, 0x0F	; 15
    7334:	9e 1b       	sub	r25, r30
    7336:	fe 01       	movw	r30, r28
    7338:	e3 58       	subi	r30, 0x83	; 131
    733a:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    733c:	19 16       	cp	r1, r25
    733e:	74 f4       	brge	.+28     	; 0x735c <systemGenerateReport+0x1026>
    7340:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7342:	20 e2       	ldi	r18, 0x20	; 32
    7344:	02 c0       	rjmp	.+4      	; 0x734a <systemGenerateReport+0x1014>
    7346:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7348:	8f 5f       	subi	r24, 0xFF	; 255
    734a:	89 17       	cp	r24, r25
    734c:	e0 f3       	brcs	.-8      	; 0x7346 <systemGenerateReport+0x1010>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    734e:	fe 01       	movw	r30, r28
    7350:	e3 58       	subi	r30, 0x83	; 131
    7352:	ff 4f       	sbci	r31, 0xFF	; 255
    7354:	e9 0f       	add	r30, r25
    7356:	f1 1d       	adc	r31, r1
    7358:	10 82       	st	Z, r1
    735a:	03 c0       	rjmp	.+6      	; 0x7362 <systemGenerateReport+0x102c>
     }else{
	 strTab[0]=' ';
    735c:	80 e2       	ldi	r24, 0x20	; 32
    735e:	80 83       	st	Z, r24
	 strTab[1]=0;
    7360:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7362:	e1 99       	sbic	0x1c, 1	; 28
    7364:	fe cf       	rjmp	.-4      	; 0x7362 <systemGenerateReport+0x102c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7366:	e1 ec       	ldi	r30, 0xC1	; 193
    7368:	f3 e0       	ldi	r31, 0x03	; 3
    736a:	ff bb       	out	0x1f, r31	; 31
    736c:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    736e:	e0 9a       	sbi	0x1c, 0	; 28
    7370:	8d b3       	in	r24, 0x1d	; 29
    7372:	9e 01       	movw	r18, r28
    7374:	2b 55       	subi	r18, 0x5B	; 91
    7376:	3f 4f       	sbci	r19, 0xFF	; 255
    7378:	4c e4       	ldi	r20, 0x4C	; 76
    737a:	5a e0       	ldi	r21, 0x0A	; 10
    737c:	de 01       	movw	r26, r28
    737e:	a7 59       	subi	r26, 0x97	; 151
    7380:	bf 4f       	sbci	r27, 0xFF	; 255

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7382:	81 30       	cpi	r24, 0x01	; 1
    7384:	41 f5       	brne	.+80     	; 0x73d6 <systemGenerateReport+0x10a0>
    7386:	8d b7       	in	r24, 0x3d	; 61
    7388:	9e b7       	in	r25, 0x3e	; 62
    738a:	0c 97       	sbiw	r24, 0x0c	; 12
    738c:	0f b6       	in	r0, 0x3f	; 63
    738e:	f8 94       	cli
    7390:	9e bf       	out	0x3e, r25	; 62
    7392:	0f be       	out	0x3f, r0	; 63
    7394:	8d bf       	out	0x3d, r24	; 61
    7396:	6d b7       	in	r22, 0x3d	; 61
    7398:	7e b7       	in	r23, 0x3e	; 62
    739a:	6f 5f       	subi	r22, 0xFF	; 255
    739c:	7f 4f       	sbci	r23, 0xFF	; 255
    739e:	ed b7       	in	r30, 0x3d	; 61
    73a0:	fe b7       	in	r31, 0x3e	; 62
    73a2:	32 83       	std	Z+2, r19	; 0x02
    73a4:	21 83       	std	Z+1, r18	; 0x01
    73a6:	80 e2       	ldi	r24, 0x20	; 32
    73a8:	94 e0       	ldi	r25, 0x04	; 4
    73aa:	fb 01       	movw	r30, r22
    73ac:	93 83       	std	Z+3, r25	; 0x03
    73ae:	82 83       	std	Z+2, r24	; 0x02
    73b0:	b5 83       	std	Z+5, r27	; 0x05
    73b2:	a4 83       	std	Z+4, r26	; 0x04
    73b4:	57 83       	std	Z+7, r21	; 0x07
    73b6:	46 83       	std	Z+6, r20	; 0x06
    73b8:	ce 01       	movw	r24, r28
    73ba:	83 58       	subi	r24, 0x83	; 131
    73bc:	9f 4f       	sbci	r25, 0xFF	; 255
    73be:	91 87       	std	Z+9, r25	; 0x09
    73c0:	80 87       	std	Z+8, r24	; 0x08
    73c2:	8d ef       	ldi	r24, 0xFD	; 253
    73c4:	9a e0       	ldi	r25, 0x0A	; 10
    73c6:	93 87       	std	Z+11, r25	; 0x0b
    73c8:	82 87       	std	Z+10, r24	; 0x0a
    73ca:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    73ce:	8d b7       	in	r24, 0x3d	; 61
    73d0:	9e b7       	in	r25, 0x3e	; 62
    73d2:	0c 96       	adiw	r24, 0x0c	; 12
    73d4:	1c c0       	rjmp	.+56     	; 0x740e <systemGenerateReport+0x10d8>
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    73d6:	ed b7       	in	r30, 0x3d	; 61
    73d8:	fe b7       	in	r31, 0x3e	; 62
    73da:	38 97       	sbiw	r30, 0x08	; 8
    73dc:	0f b6       	in	r0, 0x3f	; 63
    73de:	f8 94       	cli
    73e0:	fe bf       	out	0x3e, r31	; 62
    73e2:	0f be       	out	0x3f, r0	; 63
    73e4:	ed bf       	out	0x3d, r30	; 61
    73e6:	6d b7       	in	r22, 0x3d	; 61
    73e8:	7e b7       	in	r23, 0x3e	; 62
    73ea:	6f 5f       	subi	r22, 0xFF	; 255
    73ec:	7f 4f       	sbci	r23, 0xFF	; 255
    73ee:	32 83       	std	Z+2, r19	; 0x02
    73f0:	21 83       	std	Z+1, r18	; 0x01
    73f2:	85 e1       	ldi	r24, 0x15	; 21
    73f4:	94 e0       	ldi	r25, 0x04	; 4
    73f6:	fb 01       	movw	r30, r22
    73f8:	93 83       	std	Z+3, r25	; 0x03
    73fa:	82 83       	std	Z+2, r24	; 0x02
    73fc:	b5 83       	std	Z+5, r27	; 0x05
    73fe:	a4 83       	std	Z+4, r26	; 0x04
    7400:	57 83       	std	Z+7, r21	; 0x07
    7402:	46 83       	std	Z+6, r20	; 0x06
    7404:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    7408:	8d b7       	in	r24, 0x3d	; 61
    740a:	9e b7       	in	r25, 0x3e	; 62
    740c:	08 96       	adiw	r24, 0x08	; 8
    740e:	0f b6       	in	r0, 0x3f	; 63
    7410:	f8 94       	cli
    7412:	9e bf       	out	0x3e, r25	; 62
    7414:	0f be       	out	0x3f, r0	; 63
    7416:	8d bf       	out	0x3d, r24	; 61
    7418:	ce 01       	movw	r24, r28
    741a:	8b 55       	subi	r24, 0x5B	; 91
    741c:	9f 4f       	sbci	r25, 0xFF	; 255
    741e:	6f e1       	ldi	r22, 0x1F	; 31
    7420:	76 e0       	ldi	r23, 0x06	; 6
    7422:	42 e0       	ldi	r20, 0x02	; 2
    7424:	52 e0       	ldi	r21, 0x02	; 2
    7426:	0e 94 8e 20 	call	0x411c	; 0x411c <CreateReport>

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      
    742a:	84 e0       	ldi	r24, 0x04	; 4
    742c:	6f e1       	ldi	r22, 0x1F	; 31
    742e:	76 e0       	ldi	r23, 0x06	; 6
    7430:	41 e0       	ldi	r20, 0x01	; 1
    7432:	22 e0       	ldi	r18, 0x02	; 2
    7434:	32 e0       	ldi	r19, 0x02	; 2
    7436:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    743a:	8b e0       	ldi	r24, 0x0B	; 11
    743c:	6f e1       	ldi	r22, 0x1F	; 31
    743e:	76 e0       	ldi	r23, 0x06	; 6
    7440:	4a e2       	ldi	r20, 0x2A	; 42
    7442:	22 e0       	ldi	r18, 0x02	; 2
    7444:	32 e0       	ldi	r19, 0x02	; 2
    7446:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    744a:	86 e0       	ldi	r24, 0x06	; 6
    744c:	6f e1       	ldi	r22, 0x1F	; 31
    744e:	76 e0       	ldi	r23, 0x06	; 6
    7450:	41 e0       	ldi	r20, 0x01	; 1
    7452:	22 e0       	ldi	r18, 0x02	; 2
    7454:	32 e0       	ldi	r19, 0x02	; 2
    7456:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    745a:	8c e0       	ldi	r24, 0x0C	; 12
    745c:	6f e1       	ldi	r22, 0x1F	; 31
    745e:	76 e0       	ldi	r23, 0x06	; 6
    7460:	41 e0       	ldi	r20, 0x01	; 1
    7462:	22 e0       	ldi	r18, 0x02	; 2
    7464:	32 e0       	ldi	r19, 0x02	; 2
    7466:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    746a:	ee 24       	eor	r14, r14

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    746c:	b8 e2       	ldi	r27, 0x28	; 40
    746e:	2b 2e       	mov	r2, r27
    7470:	31 2c       	mov	r3, r1
    7472:	2c 0e       	add	r2, r28
    7474:	3d 1e       	adc	r3, r29
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    7476:	a7 e3       	ldi	r26, 0x37	; 55
    7478:	6a 2e       	mov	r6, r26
    747a:	71 2c       	mov	r7, r1
    747c:	6c 0e       	add	r6, r28
    747e:	7d 1e       	adc	r7, r29
    7480:	d3 01       	movw	r26, r6
    7482:	1f 96       	adiw	r26, 0x0f	; 15
    7484:	cb 50       	subi	r28, 0x0B	; 11
    7486:	df 4f       	sbci	r29, 0xFF	; 255
    7488:	b9 83       	std	Y+1, r27	; 0x01
    748a:	a8 83       	st	Y, r26
    748c:	c5 5f       	subi	r28, 0xF5	; 245
    748e:	d0 40       	sbci	r29, 0x00	; 0
    7490:	f6 e4       	ldi	r31, 0x46	; 70
    7492:	4f 2e       	mov	r4, r31
    7494:	51 2c       	mov	r5, r1
    7496:	4c 0e       	add	r4, r28
    7498:	5d 1e       	adc	r5, r29
    749a:	f2 01       	movw	r30, r4
    749c:	3f 96       	adiw	r30, 0x0f	; 15
    749e:	c9 50       	subi	r28, 0x09	; 9
    74a0:	df 4f       	sbci	r29, 0xFF	; 255
    74a2:	f9 83       	std	Y+1, r31	; 0x01
    74a4:	e8 83       	st	Y, r30
    74a6:	c7 5f       	subi	r28, 0xF7	; 247
    74a8:	d0 40       	sbci	r29, 0x00	; 0
    74aa:	ed e7       	ldi	r30, 0x7D	; 125
    74ac:	8e 2e       	mov	r8, r30
    74ae:	91 2c       	mov	r9, r1
    74b0:	8c 0e       	add	r8, r28
    74b2:	9d 1e       	adc	r9, r29
    74b4:	e3 c1       	rjmp	.+966    	; 0x787c <systemGenerateReport+0x1546>
    74b6:	f5 01       	movw	r30, r10
    74b8:	ec 5f       	subi	r30, 0xFC	; 252
    74ba:	fd 4f       	sbci	r31, 0xFD	; 253
    74bc:	80 81       	ld	r24, Z
    74be:	80 53       	subi	r24, 0x30	; 48
    74c0:	8a 30       	cpi	r24, 0x0A	; 10
    74c2:	08 f0       	brcs	.+2      	; 0x74c6 <systemGenerateReport+0x1190>
    74c4:	80 e0       	ldi	r24, 0x00	; 0
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
		      xGrade=Ord(GradeList[iTotal]);
    74c6:	80 93 11 02 	sts	0x0211, r24
			  if (xGrade>0){
    74ca:	88 23       	and	r24, r24
    74cc:	09 f4       	brne	.+2      	; 0x74d0 <systemGenerateReport+0x119a>
    74ce:	d5 c1       	rjmp	.+938    	; 0x787a <systemGenerateReport+0x1544>
			      GetProductName(xGrade,strProduct);
    74d0:	61 e9       	ldi	r22, 0x91	; 145
    74d2:	79 e0       	ldi	r23, 0x09	; 9
    74d4:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <GetProductName>
    74d8:	ec e4       	ldi	r30, 0x4C	; 76
    74da:	fa e0       	ldi	r31, 0x0A	; 10
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    74dc:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    74de:	8a e0       	ldi	r24, 0x0A	; 10
    74e0:	e0 36       	cpi	r30, 0x60	; 96
    74e2:	f8 07       	cpc	r31, r24
    74e4:	d9 f7       	brne	.-10     	; 0x74dc <systemGenerateReport+0x11a6>
    74e6:	ed ef       	ldi	r30, 0xFD	; 253
    74e8:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    74ea:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    74ec:	9b e0       	ldi	r25, 0x0B	; 11
    74ee:	e1 31       	cpi	r30, 0x11	; 17
    74f0:	f9 07       	cpc	r31, r25
    74f2:	d9 f7       	brne	.-10     	; 0x74ea <systemGenerateReport+0x11b4>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    74f4:	81 e0       	ldi	r24, 0x01	; 1
    74f6:	80 93 13 02 	sts	0x0213, r24

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    74fa:	79 e1       	ldi	r23, 0x19	; 25
    74fc:	c7 2e       	mov	r12, r23
    74fe:	d1 2c       	mov	r13, r1
    7500:	cc 0e       	add	r12, r28
    7502:	dd 1e       	adc	r13, r29
    7504:	e6 c0       	rjmp	.+460    	; 0x76d2 <systemGenerateReport+0x139c>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    7506:	ce 01       	movw	r24, r28
    7508:	07 96       	adiw	r24, 0x07	; 7
    750a:	65 e4       	ldi	r22, 0x45	; 69
    750c:	70 e0       	ldi	r23, 0x00	; 0
    750e:	48 e0       	ldi	r20, 0x08	; 8
    7510:	50 e0       	ldi	r21, 0x00	; 0
    7512:	25 ed       	ldi	r18, 0xD5	; 213
    7514:	32 e1       	ldi	r19, 0x12	; 18
    7516:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
    751a:	80 91 13 02 	lds	r24, 0x0213
    751e:	fe 01       	movw	r30, r28
    7520:	e8 0f       	add	r30, r24
    7522:	f1 1d       	adc	r31, r1
    7524:	86 81       	ldd	r24, Z+6	; 0x06
    7526:	80 93 10 02 	sts	0x0210, r24
					  if (PumpNum>0){
    752a:	88 23       	and	r24, r24
    752c:	09 f4       	brne	.+2      	; 0x7530 <systemGenerateReport+0x11fa>
    752e:	cc c0       	rjmp	.+408    	; 0x76c8 <systemGenerateReport+0x1392>
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    7530:	81 e0       	ldi	r24, 0x01	; 1
    7532:	c3 c0       	rjmp	.+390    	; 0x76ba <systemGenerateReport+0x1384>
    7534:	60 91 13 02 	lds	r22, 0x0213
    7538:	a6 e0       	ldi	r26, 0x06	; 6
    753a:	6a 9f       	mul	r22, r26
    753c:	b0 01       	movw	r22, r0
    753e:	11 24       	eor	r1, r1
    7540:	61 5b       	subi	r22, 0xB1	; 177
    7542:	7f 4f       	sbci	r23, 0xFF	; 255
    7544:	ce 01       	movw	r24, r28
    7546:	01 96       	adiw	r24, 0x01	; 1
    7548:	46 e0       	ldi	r20, 0x06	; 6
    754a:	50 e0       	ldi	r21, 0x00	; 0
    754c:	25 ed       	ldi	r18, 0xD5	; 213
    754e:	32 e1       	ldi	r19, 0x12	; 18
    7550:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
							  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
							  //Found Grade
						      if (PProductID[xNozzle-1]==xGrade){
    7554:	80 91 12 02 	lds	r24, 0x0212
    7558:	fe 01       	movw	r30, r28
    755a:	e8 0f       	add	r30, r24
    755c:	f1 1d       	adc	r31, r1
    755e:	90 81       	ld	r25, Z
    7560:	80 91 11 02 	lds	r24, 0x0211
    7564:	98 17       	cp	r25, r24
    7566:	09 f0       	breq	.+2      	; 0x756a <systemGenerateReport+0x1234>
    7568:	a5 c0       	rjmp	.+330    	; 0x76b4 <systemGenerateReport+0x137e>
    756a:	e8 e5       	ldi	r30, 0x58	; 88
    756c:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    756e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7570:	be e0       	ldi	r27, 0x0E	; 14
    7572:	e7 36       	cpi	r30, 0x67	; 103
    7574:	fb 07       	cpc	r31, r27
    7576:	d9 f7       	brne	.-10     	; 0x756e <systemGenerateReport+0x1238>
    7578:	ed e2       	ldi	r30, 0x2D	; 45
    757a:	fb e0       	ldi	r31, 0x0B	; 11
	     strMemory[i]=data;
    757c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    757e:	8b e0       	ldi	r24, 0x0B	; 11
    7580:	ec 33       	cpi	r30, 0x3C	; 60
    7582:	f8 07       	cpc	r31, r24
    7584:	d9 f7       	brne	.-10     	; 0x757c <systemGenerateReport+0x1246>
    7586:	f6 01       	movw	r30, r12
	     strMemory[i]=data;
    7588:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    758a:	e2 15       	cp	r30, r2
    758c:	f3 05       	cpc	r31, r3
    758e:	e1 f7       	brne	.-8      	; 0x7588 <systemGenerateReport+0x1252>
    7590:	f1 01       	movw	r30, r2
	     strMemory[i]=data;
    7592:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7594:	e6 15       	cp	r30, r6
    7596:	f7 05       	cpc	r31, r7
    7598:	e1 f7       	brne	.-8      	; 0x7592 <systemGenerateReport+0x125c>
    759a:	f3 01       	movw	r30, r6
	     strMemory[i]=data;
    759c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    759e:	cb 50       	subi	r28, 0x0B	; 11
    75a0:	df 4f       	sbci	r29, 0xFF	; 255
    75a2:	a8 81       	ld	r26, Y
    75a4:	b9 81       	ldd	r27, Y+1	; 0x01
    75a6:	c5 5f       	subi	r28, 0xF5	; 245
    75a8:	d0 40       	sbci	r29, 0x00	; 0
    75aa:	ea 17       	cp	r30, r26
    75ac:	fb 07       	cpc	r31, r27
    75ae:	b1 f7       	brne	.-20     	; 0x759c <systemGenerateReport+0x1266>
    75b0:	f2 01       	movw	r30, r4
	     strMemory[i]=data;
    75b2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    75b4:	c9 50       	subi	r28, 0x09	; 9
    75b6:	df 4f       	sbci	r29, 0xFF	; 255
    75b8:	88 81       	ld	r24, Y
    75ba:	99 81       	ldd	r25, Y+1	; 0x01
    75bc:	c7 5f       	subi	r28, 0xF7	; 247
    75be:	d0 40       	sbci	r29, 0x00	; 0
    75c0:	e8 17       	cp	r30, r24
    75c2:	f9 07       	cpc	r31, r25
    75c4:	b1 f7       	brne	.-20     	; 0x75b2 <systemGenerateReport+0x127c>
								  FillChar(strLastVolume,sizeof(strLastVolume),0);
								  FillChar(strLastMoney,sizeof(strLastMoney),0);
								  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
								  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

								  PumpNozzle=xNozzle;
    75c6:	80 91 12 02 	lds	r24, 0x0212
    75ca:	80 93 0f 02 	sts	0x020F, r24
								  
								  FIPAddr=GetFIPAddr(PumpNum); 
    75ce:	80 91 10 02 	lds	r24, 0x0210
    75d2:	0e 94 1a 1c 	call	0x3834	; 0x3834 <GetFIPAddr>
								  if (FIPAddr>0){
    75d6:	88 23       	and	r24, r24
    75d8:	11 f1       	breq	.+68     	; 0x761e <systemGenerateReport+0x12e8>
									  FIPAddr=FIPAddr-1;							  							  							      
    75da:	f8 2e       	mov	r15, r24
    75dc:	fa 94       	dec	r15
									  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    75de:	80 e0       	ldi	r24, 0x00	; 0
    75e0:	60 e0       	ldi	r22, 0x00	; 0
    75e2:	4f 2d       	mov	r20, r15
    75e4:	20 91 0f 02 	lds	r18, 0x020F
    75e8:	86 01       	movw	r16, r12
    75ea:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    75ee:	81 e0       	ldi	r24, 0x01	; 1
    75f0:	60 e0       	ldi	r22, 0x00	; 0
    75f2:	4f 2d       	mov	r20, r15
    75f4:	20 91 0f 02 	lds	r18, 0x020F
    75f8:	81 01       	movw	r16, r2
    75fa:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <GetTotalizerData>

									  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    75fe:	80 e0       	ldi	r24, 0x00	; 0
    7600:	61 e0       	ldi	r22, 0x01	; 1
    7602:	4f 2d       	mov	r20, r15
    7604:	20 91 0f 02 	lds	r18, 0x020F
    7608:	83 01       	movw	r16, r6
    760a:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    760e:	81 e0       	ldi	r24, 0x01	; 1
    7610:	61 e0       	ldi	r22, 0x01	; 1
    7612:	4f 2d       	mov	r20, r15
    7614:	20 91 0f 02 	lds	r18, 0x020F
    7618:	82 01       	movw	r16, r4
    761a:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <GetTotalizerData>
								  }

								  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    761e:	80 e0       	ldi	r24, 0x00	; 0
    7620:	b3 01       	movw	r22, r6
    7622:	a6 01       	movw	r20, r12
    7624:	2d e2       	ldi	r18, 0x2D	; 45
    7626:	3b e0       	ldi	r19, 0x0B	; 11
    7628:	0e 94 6c 26 	call	0x4cd8	; 0x4cd8 <StrCalc>
								  if (IsMinus(strDeltaVolume)==True)
    762c:	8d e2       	ldi	r24, 0x2D	; 45
    762e:	9b e0       	ldi	r25, 0x0B	; 11
    7630:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <IsMinus>
    7634:	81 30       	cpi	r24, 0x01	; 1
    7636:	21 f4       	brne	.+8      	; 0x7640 <systemGenerateReport+0x130a>
								      NormalizeOverflow(strDeltaVolume);
    7638:	8d e2       	ldi	r24, 0x2D	; 45
    763a:	9b e0       	ldi	r25, 0x0B	; 11
    763c:	0e 94 03 2a 	call	0x5406	; 0x5406 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7640:	e1 99       	sbic	0x1c, 1	; 28
    7642:	fe cf       	rjmp	.-4      	; 0x7640 <systemGenerateReport+0x130a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7644:	a7 e3       	ldi	r26, 0x37	; 55
    7646:	b1 e0       	ldi	r27, 0x01	; 1
    7648:	bf bb       	out	0x1f, r27	; 31
    764a:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    764c:	e0 9a       	sbi	0x1c, 0	; 28
    764e:	8d b3       	in	r24, 0x1d	; 29


								  //Calculate Wayne Estimated Total Money
								  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    7650:	82 30       	cpi	r24, 0x02	; 2
    7652:	79 f4       	brne	.+30     	; 0x7672 <systemGenerateReport+0x133c>
						              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    7654:	ce 01       	movw	r24, r28
    7656:	0f 96       	adiw	r24, 0x0f	; 15
    7658:	60 91 10 02 	lds	r22, 0x0210
    765c:	40 91 0f 02 	lds	r20, 0x020F
    7660:	0e 94 d6 22 	call	0x45ac	; 0x45ac <GetProductPrice>
									  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    7664:	82 e0       	ldi	r24, 0x02	; 2
    7666:	be 01       	movw	r22, r28
    7668:	61 5f       	subi	r22, 0xF1	; 241
    766a:	7f 4f       	sbci	r23, 0xFF	; 255
    766c:	4d e2       	ldi	r20, 0x2D	; 45
    766e:	5b e0       	ldi	r21, 0x0B	; 11
    7670:	03 c0       	rjmp	.+6      	; 0x7678 <systemGenerateReport+0x1342>
								  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    7672:	80 e0       	ldi	r24, 0x00	; 0
    7674:	b2 01       	movw	r22, r4
    7676:	a1 01       	movw	r20, r2
    7678:	28 e5       	ldi	r18, 0x58	; 88
    767a:	3e e0       	ldi	r19, 0x0E	; 14
    767c:	0e 94 6c 26 	call	0x4cd8	; 0x4cd8 <StrCalc>
								  //StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
								  if (IsMinus(strDeltaMoney)==True)
    7680:	88 e5       	ldi	r24, 0x58	; 88
    7682:	9e e0       	ldi	r25, 0x0E	; 14
    7684:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <IsMinus>
    7688:	81 30       	cpi	r24, 0x01	; 1
    768a:	21 f4       	brne	.+8      	; 0x7694 <systemGenerateReport+0x135e>
								      NormalizeOverflow(strDeltaMoney);
    768c:	88 e5       	ldi	r24, 0x58	; 88
    768e:	9e e0       	ldi	r25, 0x0E	; 14
    7690:	0e 94 03 2a 	call	0x5406	; 0x5406 <NormalizeOverflow>
		  
								  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    7694:	81 e0       	ldi	r24, 0x01	; 1
    7696:	6c e4       	ldi	r22, 0x4C	; 76
    7698:	7a e0       	ldi	r23, 0x0A	; 10
    769a:	4d e2       	ldi	r20, 0x2D	; 45
    769c:	5b e0       	ldi	r21, 0x0B	; 11
    769e:	9b 01       	movw	r18, r22
    76a0:	0e 94 6c 26 	call	0x4cd8	; 0x4cd8 <StrCalc>
								  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    76a4:	81 e0       	ldi	r24, 0x01	; 1
    76a6:	6d ef       	ldi	r22, 0xFD	; 253
    76a8:	7a e0       	ldi	r23, 0x0A	; 10
    76aa:	48 e5       	ldi	r20, 0x58	; 88
    76ac:	5e e0       	ldi	r21, 0x0E	; 14
    76ae:	9b 01       	movw	r18, r22
    76b0:	0e 94 6c 26 	call	0x4cd8	; 0x4cd8 <StrCalc>

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
					  if (PumpNum>0){
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    76b4:	80 91 12 02 	lds	r24, 0x0212
    76b8:	8f 5f       	subi	r24, 0xFF	; 255
    76ba:	80 93 12 02 	sts	0x0212, r24
    76be:	80 91 12 02 	lds	r24, 0x0212
    76c2:	87 30       	cpi	r24, 0x07	; 7
    76c4:	08 f4       	brcc	.+2      	; 0x76c8 <systemGenerateReport+0x1392>
    76c6:	36 cf       	rjmp	.-404    	; 0x7534 <systemGenerateReport+0x11fe>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    76c8:	80 91 13 02 	lds	r24, 0x0213
    76cc:	8f 5f       	subi	r24, 0xFF	; 255
    76ce:	80 93 13 02 	sts	0x0213, r24
    76d2:	80 91 13 02 	lds	r24, 0x0213
    76d6:	89 30       	cpi	r24, 0x09	; 9
    76d8:	08 f4       	brcc	.+2      	; 0x76dc <systemGenerateReport+0x13a6>
    76da:	15 cf       	rjmp	.-470    	; 0x7506 <systemGenerateReport+0x11d0>
							  }
						  }
					  }				  
				  }

				  RemZeroLead(strTotalMoney);
    76dc:	8d ef       	ldi	r24, 0xFD	; 253
    76de:	9a e0       	ldi	r25, 0x0A	; 10
    76e0:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
				  RemZeroLead(strTotalVolume);
    76e4:	0c e4       	ldi	r16, 0x4C	; 76
    76e6:	1a e0       	ldi	r17, 0x0A	; 10
    76e8:	c8 01       	movw	r24, r16
    76ea:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>

				  FormatTotalizerMoney(strTotalMoney);
    76ee:	8d ef       	ldi	r24, 0xFD	; 253
    76f0:	9a e0       	ldi	r25, 0x0A	; 10
    76f2:	0e 94 67 31 	call	0x62ce	; 0x62ce <FormatTotalizerMoney>
				  FormatCurrency(strTotalMoney);
    76f6:	8d ef       	ldi	r24, 0xFD	; 253
    76f8:	9a e0       	ldi	r25, 0x0A	; 10
    76fa:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>

				  FormatTotalizerVolume(strTotalVolume);
    76fe:	c8 01       	movw	r24, r16
    7700:	0e 94 5a 31 	call	0x62b4	; 0x62b4 <FormatTotalizerVolume>
				  FormatCurrency(strTotalVolume);
    7704:	c8 01       	movw	r24, r16
    7706:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>
		          //Test
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
    770a:	e1 e9       	ldi	r30, 0x91	; 145
    770c:	f9 e0       	ldi	r31, 0x09	; 9
    770e:	01 90       	ld	r0, Z+
    7710:	00 20       	and	r0, r0
    7712:	e9 f7       	brne	.-6      	; 0x770e <systemGenerateReport+0x13d8>
    7714:	31 97       	sbiw	r30, 0x01	; 1
    7716:	e1 59       	subi	r30, 0x91	; 145
    7718:	f9 40       	sbci	r31, 0x09	; 9
    771a:	d8 01       	movw	r26, r16
    771c:	0d 90       	ld	r0, X+
    771e:	00 20       	and	r0, r0
    7720:	e9 f7       	brne	.-6      	; 0x771c <systemGenerateReport+0x13e6>
    7722:	8d 01       	movw	r16, r26
    7724:	01 50       	subi	r16, 0x01	; 1
    7726:	10 40       	sbci	r17, 0x00	; 0
    7728:	0c 54       	subi	r16, 0x4C	; 76
    772a:	1a 40       	sbci	r17, 0x0A	; 10
    772c:	8e 2f       	mov	r24, r30
    772e:	81 95       	neg	r24
    7730:	80 1b       	sub	r24, r16
    7732:	8b 5e       	subi	r24, 0xEB	; 235
    7734:	de 01       	movw	r26, r28
    7736:	a7 59       	subi	r26, 0x97	; 151
    7738:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    773a:	18 16       	cp	r1, r24
    773c:	7c f4       	brge	.+30     	; 0x775c <systemGenerateReport+0x1426>
    773e:	fd 01       	movw	r30, r26
    7740:	90 e0       	ldi	r25, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7742:	20 e2       	ldi	r18, 0x20	; 32
    7744:	02 c0       	rjmp	.+4      	; 0x774a <systemGenerateReport+0x1414>
    7746:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7748:	9f 5f       	subi	r25, 0xFF	; 255
    774a:	98 17       	cp	r25, r24
    774c:	e0 f3       	brcs	.-8      	; 0x7746 <systemGenerateReport+0x1410>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    774e:	fe 01       	movw	r30, r28
    7750:	e7 59       	subi	r30, 0x97	; 151
    7752:	ff 4f       	sbci	r31, 0xFF	; 255
    7754:	e8 0f       	add	r30, r24
    7756:	f1 1d       	adc	r31, r1
    7758:	10 82       	st	Z, r1
    775a:	04 c0       	rjmp	.+8      	; 0x7764 <systemGenerateReport+0x142e>
     }else{
	 strTab[0]=' ';
    775c:	80 e2       	ldi	r24, 0x20	; 32
    775e:	8c 93       	st	X, r24
	 strTab[1]=0;
    7760:	11 96       	adiw	r26, 0x01	; 1
    7762:	1c 92       	st	X, r1
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    7764:	ed ef       	ldi	r30, 0xFD	; 253
    7766:	fa e0       	ldi	r31, 0x0A	; 10
    7768:	01 90       	ld	r0, Z+
    776a:	00 20       	and	r0, r0
    776c:	e9 f7       	brne	.-6      	; 0x7768 <systemGenerateReport+0x1432>
    776e:	31 97       	sbiw	r30, 0x01	; 1
    7770:	ed 5f       	subi	r30, 0xFD	; 253
    7772:	fa 40       	sbci	r31, 0x0A	; 10
    7774:	9f e0       	ldi	r25, 0x0F	; 15
    7776:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7778:	19 16       	cp	r1, r25
    777a:	6c f4       	brge	.+26     	; 0x7796 <systemGenerateReport+0x1460>
    777c:	f4 01       	movw	r30, r8
    777e:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7780:	20 e2       	ldi	r18, 0x20	; 32
    7782:	02 c0       	rjmp	.+4      	; 0x7788 <systemGenerateReport+0x1452>
    7784:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7786:	8f 5f       	subi	r24, 0xFF	; 255
    7788:	89 17       	cp	r24, r25
    778a:	e0 f3       	brcs	.-8      	; 0x7784 <systemGenerateReport+0x144e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    778c:	f4 01       	movw	r30, r8
    778e:	e9 0f       	add	r30, r25
    7790:	f1 1d       	adc	r31, r1
    7792:	10 82       	st	Z, r1
    7794:	04 c0       	rjmp	.+8      	; 0x779e <systemGenerateReport+0x1468>
     }else{
	 strTab[0]=' ';
    7796:	80 e2       	ldi	r24, 0x20	; 32
    7798:	f4 01       	movw	r30, r8
    779a:	80 83       	st	Z, r24
	 strTab[1]=0;
    779c:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    779e:	e1 99       	sbic	0x1c, 1	; 28
    77a0:	fe cf       	rjmp	.-4      	; 0x779e <systemGenerateReport+0x1468>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    77a2:	81 ec       	ldi	r24, 0xC1	; 193
    77a4:	93 e0       	ldi	r25, 0x03	; 3
    77a6:	9f bb       	out	0x1f, r25	; 31
    77a8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    77aa:	e0 9a       	sbi	0x1c, 0	; 28
    77ac:	8d b3       	in	r24, 0x1d	; 29
    77ae:	9e 01       	movw	r18, r28
    77b0:	2b 55       	subi	r18, 0x5B	; 91
    77b2:	3f 4f       	sbci	r19, 0xFF	; 255
    77b4:	4c e4       	ldi	r20, 0x4C	; 76
    77b6:	5a e0       	ldi	r21, 0x0A	; 10
    77b8:	61 e9       	ldi	r22, 0x91	; 145
    77ba:	c6 2e       	mov	r12, r22
    77bc:	69 e0       	ldi	r22, 0x09	; 9
    77be:	d6 2e       	mov	r13, r22
    77c0:	de 01       	movw	r26, r28
    77c2:	a7 59       	subi	r26, 0x97	; 151
    77c4:	bf 4f       	sbci	r27, 0xFF	; 255
    77c6:	b5 01       	movw	r22, r10
    77c8:	6f 5f       	subi	r22, 0xFF	; 255
    77ca:	7f 4f       	sbci	r23, 0xFF	; 255

			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);

				  //PrintMoney
		          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%d.%s%s%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);
    77cc:	81 30       	cpi	r24, 0x01	; 1
    77ce:	39 f5       	brne	.+78     	; 0x781e <systemGenerateReport+0x14e8>
    77d0:	ed b7       	in	r30, 0x3d	; 61
    77d2:	fe b7       	in	r31, 0x3e	; 62
    77d4:	70 97       	sbiw	r30, 0x10	; 16
    77d6:	0f b6       	in	r0, 0x3f	; 63
    77d8:	f8 94       	cli
    77da:	fe bf       	out	0x3e, r31	; 62
    77dc:	0f be       	out	0x3f, r0	; 63
    77de:	ed bf       	out	0x3d, r30	; 61
    77e0:	0d b7       	in	r16, 0x3d	; 61
    77e2:	1e b7       	in	r17, 0x3e	; 62
    77e4:	0f 5f       	subi	r16, 0xFF	; 255
    77e6:	1f 4f       	sbci	r17, 0xFF	; 255
    77e8:	32 83       	std	Z+2, r19	; 0x02
    77ea:	21 83       	std	Z+1, r18	; 0x01
    77ec:	87 e0       	ldi	r24, 0x07	; 7
    77ee:	94 e0       	ldi	r25, 0x04	; 4
    77f0:	f8 01       	movw	r30, r16
    77f2:	93 83       	std	Z+3, r25	; 0x03
    77f4:	82 83       	std	Z+2, r24	; 0x02
    77f6:	75 83       	std	Z+5, r23	; 0x05
    77f8:	64 83       	std	Z+4, r22	; 0x04
    77fa:	d7 82       	std	Z+7, r13	; 0x07
    77fc:	c6 82       	std	Z+6, r12	; 0x06
    77fe:	b1 87       	std	Z+9, r27	; 0x09
    7800:	a0 87       	std	Z+8, r26	; 0x08
    7802:	53 87       	std	Z+11, r21	; 0x0b
    7804:	42 87       	std	Z+10, r20	; 0x0a
    7806:	95 86       	std	Z+13, r9	; 0x0d
    7808:	84 86       	std	Z+12, r8	; 0x0c
    780a:	8d ef       	ldi	r24, 0xFD	; 253
    780c:	9a e0       	ldi	r25, 0x0A	; 10
    780e:	97 87       	std	Z+15, r25	; 0x0f
    7810:	86 87       	std	Z+14, r24	; 0x0e
    7812:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    7816:	8d b7       	in	r24, 0x3d	; 61
    7818:	9e b7       	in	r25, 0x3e	; 62
    781a:	40 96       	adiw	r24, 0x10	; 16
    781c:	20 c0       	rjmp	.+64     	; 0x785e <systemGenerateReport+0x1528>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);
    781e:	ed b7       	in	r30, 0x3d	; 61
    7820:	fe b7       	in	r31, 0x3e	; 62
    7822:	3c 97       	sbiw	r30, 0x0c	; 12
    7824:	0f b6       	in	r0, 0x3f	; 63
    7826:	f8 94       	cli
    7828:	fe bf       	out	0x3e, r31	; 62
    782a:	0f be       	out	0x3f, r0	; 63
    782c:	ed bf       	out	0x3d, r30	; 61
    782e:	0d b7       	in	r16, 0x3d	; 61
    7830:	1e b7       	in	r17, 0x3e	; 62
    7832:	0f 5f       	subi	r16, 0xFF	; 255
    7834:	1f 4f       	sbci	r17, 0xFF	; 255
    7836:	32 83       	std	Z+2, r19	; 0x02
    7838:	21 83       	std	Z+1, r18	; 0x01
    783a:	8d ef       	ldi	r24, 0xFD	; 253
    783c:	93 e0       	ldi	r25, 0x03	; 3
    783e:	f8 01       	movw	r30, r16
    7840:	93 83       	std	Z+3, r25	; 0x03
    7842:	82 83       	std	Z+2, r24	; 0x02
    7844:	75 83       	std	Z+5, r23	; 0x05
    7846:	64 83       	std	Z+4, r22	; 0x04
    7848:	d7 82       	std	Z+7, r13	; 0x07
    784a:	c6 82       	std	Z+6, r12	; 0x06
    784c:	b1 87       	std	Z+9, r27	; 0x09
    784e:	a0 87       	std	Z+8, r26	; 0x08
    7850:	53 87       	std	Z+11, r21	; 0x0b
    7852:	42 87       	std	Z+10, r20	; 0x0a
    7854:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    7858:	8d b7       	in	r24, 0x3d	; 61
    785a:	9e b7       	in	r25, 0x3e	; 62
    785c:	0c 96       	adiw	r24, 0x0c	; 12
    785e:	0f b6       	in	r0, 0x3f	; 63
    7860:	f8 94       	cli
    7862:	9e bf       	out	0x3e, r25	; 62
    7864:	0f be       	out	0x3f, r0	; 63
    7866:	8d bf       	out	0x3d, r24	; 61

				  CreateReport(strReport,PrintBuffer,&RepPos);
    7868:	ce 01       	movw	r24, r28
    786a:	8b 55       	subi	r24, 0x5B	; 91
    786c:	9f 4f       	sbci	r25, 0xFF	; 255
    786e:	6f e1       	ldi	r22, 0x1F	; 31
    7870:	76 e0       	ldi	r23, 0x06	; 6
    7872:	42 e0       	ldi	r20, 0x02	; 2
    7874:	52 e0       	ldi	r21, 0x02	; 2
    7876:	0e 94 8e 20 	call	0x411c	; 0x411c <CreateReport>
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
    787a:	e3 94       	inc	r14
    787c:	e4 e0       	ldi	r30, 0x04	; 4
    787e:	f2 e0       	ldi	r31, 0x02	; 2
    7880:	01 90       	ld	r0, Z+
    7882:	00 20       	and	r0, r0
    7884:	e9 f7       	brne	.-6      	; 0x7880 <systemGenerateReport+0x154a>
    7886:	31 97       	sbiw	r30, 0x01	; 1
    7888:	e4 50       	subi	r30, 0x04	; 4
    788a:	f2 40       	sbci	r31, 0x02	; 2
    788c:	ae 2c       	mov	r10, r14
    788e:	bb 24       	eor	r11, r11
    7890:	ae 16       	cp	r10, r30
    7892:	bf 06       	cpc	r11, r31
    7894:	08 f4       	brcc	.+2      	; 0x7898 <systemGenerateReport+0x1562>
    7896:	0f ce       	rjmp	.-994    	; 0x74b6 <systemGenerateReport+0x1180>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);

				  CreateReport(strReport,PrintBuffer,&RepPos);
               }
		  }
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7898:	87 e0       	ldi	r24, 0x07	; 7
    789a:	6f e1       	ldi	r22, 0x1F	; 31
    789c:	76 e0       	ldi	r23, 0x06	; 6
    789e:	41 e0       	ldi	r20, 0x01	; 1
    78a0:	22 e0       	ldi	r18, 0x02	; 2
    78a2:	32 e0       	ldi	r19, 0x02	; 2
    78a4:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    78a8:	8b e0       	ldi	r24, 0x0B	; 11
    78aa:	6f e1       	ldi	r22, 0x1F	; 31
    78ac:	76 e0       	ldi	r23, 0x06	; 6
    78ae:	4a e2       	ldi	r20, 0x2A	; 42
    78b0:	22 e0       	ldi	r18, 0x02	; 2
    78b2:	32 e0       	ldi	r19, 0x02	; 2
    78b4:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    78b8:	89 e0       	ldi	r24, 0x09	; 9
    78ba:	6f e1       	ldi	r22, 0x1F	; 31
    78bc:	76 e0       	ldi	r23, 0x06	; 6
    78be:	41 e0       	ldi	r20, 0x01	; 1
    78c0:	22 e0       	ldi	r18, 0x02	; 2
    78c2:	32 e0       	ldi	r19, 0x02	; 2
    78c4:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    78c8:	8c e0       	ldi	r24, 0x0C	; 12
    78ca:	6f e1       	ldi	r22, 0x1F	; 31
    78cc:	76 e0       	ldi	r23, 0x06	; 6
    78ce:	41 e0       	ldi	r20, 0x01	; 1
    78d0:	22 e0       	ldi	r18, 0x02	; 2
    78d2:	32 e0       	ldi	r19, 0x02	; 2
    78d4:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
		  InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    78d8:	8c e0       	ldi	r24, 0x0C	; 12
    78da:	6f e1       	ldi	r22, 0x1F	; 31
    78dc:	76 e0       	ldi	r23, 0x06	; 6
    78de:	41 e0       	ldi	r20, 0x01	; 1
    78e0:	22 e0       	ldi	r18, 0x02	; 2
    78e2:	32 e0       	ldi	r19, 0x02	; 2
    78e4:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    78e8:	8c e0       	ldi	r24, 0x0C	; 12
    78ea:	6f e1       	ldi	r22, 0x1F	; 31
    78ec:	76 e0       	ldi	r23, 0x06	; 6
    78ee:	41 e0       	ldi	r20, 0x01	; 1
    78f0:	22 e0       	ldi	r18, 0x02	; 2
    78f2:	32 e0       	ldi	r19, 0x02	; 2
    78f4:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    78f8:	8c e0       	ldi	r24, 0x0C	; 12
    78fa:	6f e1       	ldi	r22, 0x1F	; 31
    78fc:	76 e0       	ldi	r23, 0x06	; 6
    78fe:	41 e0       	ldi	r20, 0x01	; 1
    7900:	22 e0       	ldi	r18, 0x02	; 2
    7902:	32 e0       	ldi	r19, 0x02	; 2
    7904:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    7908:	8c e0       	ldi	r24, 0x0C	; 12
    790a:	6f e1       	ldi	r22, 0x1F	; 31
    790c:	76 e0       	ldi	r23, 0x06	; 6
    790e:	41 e0       	ldi	r20, 0x01	; 1
    7910:	22 e0       	ldi	r18, 0x02	; 2
    7912:	32 e0       	ldi	r19, 0x02	; 2
    7914:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>
    7918:	8c e0       	ldi	r24, 0x0C	; 12
    791a:	6f e1       	ldi	r22, 0x1F	; 31
    791c:	76 e0       	ldi	r23, 0x06	; 6
    791e:	41 e0       	ldi	r20, 0x01	; 1
    7920:	22 e0       	ldi	r18, 0x02	; 2
    7922:	32 e0       	ldi	r19, 0x02	; 2
    7924:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <InserBorder>


          cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    7928:	80 e3       	ldi	r24, 0x30	; 48
    792a:	80 93 cb 01 	sts	0x01CB, r24
		  LengthMessage81=RepPos+1;
    792e:	80 91 02 02 	lds	r24, 0x0202
    7932:	90 91 03 02 	lds	r25, 0x0203
    7936:	01 96       	adiw	r24, 0x01	; 1
    7938:	90 93 a1 01 	sts	0x01A1, r25
    793c:	80 93 a0 01 	sts	0x01A0, r24
		  IsFreePrinting=True;
    7940:	81 e0       	ldi	r24, 0x01	; 1
    7942:	80 93 bf 01 	sts	0x01BF, r24
	      IsBusyFreePrinting=True; 
    7946:	80 93 ca 01 	sts	0x01CA, r24
         	       
	      stGenerateReport=grWaitPrinted3;
    794a:	8b e0       	ldi	r24, 0x0B	; 11
    794c:	05 c0       	rjmp	.+10     	; 0x7958 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted3:
          if (IsBusyFreePrinting==False)stGenerateReport=grFinishGenerateReport;
    794e:	80 91 ca 01 	lds	r24, 0x01CA
    7952:	88 23       	and	r24, r24
    7954:	49 f4       	brne	.+18     	; 0x7968 <systemGenerateReport+0x1632>
    7956:	8c e0       	ldi	r24, 0x0C	; 12
    7958:	80 93 14 02 	sts	0x0214, r24
    795c:	05 c0       	rjmp	.+10     	; 0x7968 <systemGenerateReport+0x1632>
	      break;
     case grFinishGenerateReport:
	      IsFinishPrintingTotalizer=True;
    795e:	81 e0       	ldi	r24, 0x01	; 1
    7960:	80 93 9a 01 	sts	0x019A, r24
          stGenerateReport=grScanAction;
    7964:	10 92 14 02 	sts	0x0214, r1
	      break;
	 }
}
    7968:	c8 50       	subi	r28, 0x08	; 8
    796a:	df 4f       	sbci	r29, 0xFF	; 255
    796c:	0f b6       	in	r0, 0x3f	; 63
    796e:	f8 94       	cli
    7970:	de bf       	out	0x3e, r29	; 62
    7972:	0f be       	out	0x3f, r0	; 63
    7974:	cd bf       	out	0x3d, r28	; 61
    7976:	cf 91       	pop	r28
    7978:	df 91       	pop	r29
    797a:	1f 91       	pop	r17
    797c:	0f 91       	pop	r16
    797e:	ff 90       	pop	r15
    7980:	ef 90       	pop	r14
    7982:	df 90       	pop	r13
    7984:	cf 90       	pop	r12
    7986:	bf 90       	pop	r11
    7988:	af 90       	pop	r10
    798a:	9f 90       	pop	r9
    798c:	8f 90       	pop	r8
    798e:	7f 90       	pop	r7
    7990:	6f 90       	pop	r6
    7992:	5f 90       	pop	r5
    7994:	4f 90       	pop	r4
    7996:	3f 90       	pop	r3
    7998:	2f 90       	pop	r2
    799a:	08 95       	ret

0000799c <UpdateCardID>:
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 


void UpdateCardID(){
    799c:	cf 93       	push	r28
    799e:	df 93       	push	r29
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
    79a0:	ec e7       	ldi	r30, 0x7C	; 124
    79a2:	fe e0       	ldi	r31, 0x0E	; 14
    79a4:	01 90       	ld	r0, Z+
    79a6:	00 20       	and	r0, r0
    79a8:	e9 f7       	brne	.-6      	; 0x79a4 <UpdateCardID+0x8>
    79aa:	31 97       	sbiw	r30, 0x01	; 1
    79ac:	ec 57       	subi	r30, 0x7C	; 124
    79ae:	fe 40       	sbci	r31, 0x0E	; 14
    79b0:	a1 eb       	ldi	r26, 0xB1	; 177
    79b2:	bd e0       	ldi	r27, 0x0D	; 13
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 


void UpdateCardID(){
    79b4:	f0 e0       	ldi	r31, 0x00	; 0
    79b6:	ef 01       	movw	r28, r30
    79b8:	c8 59       	subi	r28, 0x98	; 152
    79ba:	d1 4f       	sbci	r29, 0xF1	; 241
    79bc:	20 e0       	ldi	r18, 0x00	; 0
    79be:	30 e0       	ldi	r19, 0x00	; 0
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
	    if (i<(20-LengthID))strCardID[i]=' ';
    79c0:	44 e1       	ldi	r20, 0x14	; 20
    79c2:	50 e0       	ldi	r21, 0x00	; 0
    79c4:	4e 1b       	sub	r20, r30
    79c6:	5f 0b       	sbc	r21, r31
    79c8:	90 e2       	ldi	r25, 0x20	; 32
    79ca:	24 17       	cp	r18, r20
    79cc:	35 07       	cpc	r19, r21
    79ce:	14 f4       	brge	.+4      	; 0x79d4 <UpdateCardID+0x38>
    79d0:	9c 93       	st	X, r25
    79d2:	02 c0       	rjmp	.+4      	; 0x79d8 <UpdateCardID+0x3c>
		else strCardID[i]=strRFID[i-(20-LengthID)];
    79d4:	88 81       	ld	r24, Y
    79d6:	8c 93       	st	X, r24
    79d8:	2f 5f       	subi	r18, 0xFF	; 255
    79da:	3f 4f       	sbci	r19, 0xFF	; 255
    79dc:	11 96       	adiw	r26, 0x01	; 1
    79de:	21 96       	adiw	r28, 0x01	; 1


void UpdateCardID(){
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
    79e0:	24 31       	cpi	r18, 0x14	; 20
    79e2:	31 05       	cpc	r19, r1
    79e4:	91 f7       	brne	.-28     	; 0x79ca <UpdateCardID+0x2e>
	    if (i<(20-LengthID))strCardID[i]=' ';
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;
    79e6:	10 92 c5 0d 	sts	0x0DC5, r1

}
    79ea:	df 91       	pop	r29
    79ec:	cf 91       	pop	r28
    79ee:	08 95       	ret

000079f0 <GetParameter>:
	}
  return  PosFound;
}


void GetParameter(char *GFlow,char FLength,char *GCmd,char *GPumpID, char *GeniCSum){
    79f0:	8f 92       	push	r8
    79f2:	9f 92       	push	r9
    79f4:	af 92       	push	r10
    79f6:	bf 92       	push	r11
    79f8:	cf 92       	push	r12
    79fa:	df 92       	push	r13
    79fc:	ef 92       	push	r14
    79fe:	ff 92       	push	r15
    7a00:	0f 93       	push	r16
    7a02:	1f 93       	push	r17
    7a04:	df 93       	push	r29
    7a06:	cf 93       	push	r28
    7a08:	cd b7       	in	r28, 0x3d	; 61
    7a0a:	de b7       	in	r29, 0x3e	; 62
    7a0c:	a7 97       	sbiw	r28, 0x27	; 39
    7a0e:	0f b6       	in	r0, 0x3f	; 63
    7a10:	f8 94       	cli
    7a12:	de bf       	out	0x3e, r29	; 62
    7a14:	0f be       	out	0x3f, r0	; 63
    7a16:	cd bf       	out	0x3d, r28	; 61
    7a18:	79 01       	movw	r14, r18
    7a1a:	48 01       	movw	r8, r16
    7a1c:	e6 2f       	mov	r30, r22
    7a1e:	f0 e0       	ldi	r31, 0x00	; 0
    7a20:	31 97       	sbiw	r30, 0x01	; 1
    7a22:	e8 0f       	add	r30, r24
    7a24:	f9 1f       	adc	r31, r25
    7a26:	9e 01       	movw	r18, r28
    7a28:	26 5f       	subi	r18, 0xF6	; 246
    7a2a:	3f 4f       	sbci	r19, 0xFF	; 255
    7a2c:	d9 01       	movw	r26, r18
    7a2e:	03 c0       	rjmp	.+6      	; 0x7a36 <GetParameter+0x46>
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
	     SGeniusFlow[i]=GFlow[FLength-i-1];
    7a30:	80 81       	ld	r24, Z
    7a32:	8d 93       	st	X+, r24
    7a34:	31 97       	sbiw	r30, 0x01	; 1
char SGeniusFlow[30];
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
    7a36:	8a 2f       	mov	r24, r26
    7a38:	82 1b       	sub	r24, r18
    7a3a:	86 17       	cp	r24, r22
    7a3c:	c8 f3       	brcs	.-14     	; 0x7a30 <GetParameter+0x40>
	     SGeniusFlow[i]=GFlow[FLength-i-1];
	 }SGeniusFlow[FLength]=0;
    7a3e:	c6 2e       	mov	r12, r22
    7a40:	dd 24       	eor	r13, r13
    7a42:	ea e0       	ldi	r30, 0x0A	; 10
    7a44:	ae 2e       	mov	r10, r30
    7a46:	b1 2c       	mov	r11, r1
    7a48:	ac 0e       	add	r10, r28
    7a4a:	bd 1e       	adc	r11, r29
    7a4c:	f5 01       	movw	r30, r10
    7a4e:	ec 0d       	add	r30, r12
    7a50:	fd 1d       	adc	r31, r13
    7a52:	10 82       	st	Z, r1

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
    7a54:	8a 85       	ldd	r24, Y+10	; 0x0a
    7a56:	fa 01       	movw	r30, r20
    7a58:	80 83       	st	Z, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7a5a:	8b 85       	ldd	r24, Y+11	; 0x0b
    7a5c:	89 83       	std	Y+1, r24	; 0x01
    7a5e:	8c 85       	ldd	r24, Y+12	; 0x0c
    7a60:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    7a62:	1b 82       	std	Y+3, r1	; 0x03
	 }SGeniusFlow[FLength]=0;

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
	 StrPosCopy(SGeniusFlow,sPumpID,1,2);
	 xPumpID=atoi(sPumpID);
    7a64:	ce 01       	movw	r24, r28
    7a66:	01 96       	adiw	r24, 0x01	; 1
    7a68:	0e 94 bf b3 	call	0x1677e	; 0x1677e <atoi>
	 *GPumpID=xPumpID;
    7a6c:	f7 01       	movw	r30, r14
    7a6e:	80 83       	st	Z, r24
	 sprintf_P(strSub,PSTR(":"));
    7a70:	00 d0       	rcall	.+0      	; 0x7a72 <GetParameter+0x82>
    7a72:	00 d0       	rcall	.+0      	; 0x7a74 <GetParameter+0x84>
    7a74:	77 e0       	ldi	r23, 0x07	; 7
    7a76:	e7 2e       	mov	r14, r23
    7a78:	f1 2c       	mov	r15, r1
    7a7a:	ec 0e       	add	r14, r28
    7a7c:	fd 1e       	adc	r15, r29
    7a7e:	ed b7       	in	r30, 0x3d	; 61
    7a80:	fe b7       	in	r31, 0x3e	; 62
    7a82:	f2 82       	std	Z+2, r15	; 0x02
    7a84:	e1 82       	std	Z+1, r14	; 0x01
    7a86:	87 e7       	ldi	r24, 0x77	; 119
    7a88:	93 e0       	ldi	r25, 0x03	; 3
    7a8a:	94 83       	std	Z+4, r25	; 0x04
    7a8c:	83 83       	std	Z+3, r24	; 0x03
    7a8e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	 if (Pos(strSub,SGeniusFlow)<FLength){
    7a92:	0f 90       	pop	r0
    7a94:	0f 90       	pop	r0
    7a96:	0f 90       	pop	r0
    7a98:	0f 90       	pop	r0
    7a9a:	c7 01       	movw	r24, r14
    7a9c:	b5 01       	movw	r22, r10
    7a9e:	0e 94 57 20 	call	0x40ae	; 0x40ae <Pos>
    7aa2:	8c 15       	cp	r24, r12
    7aa4:	9d 05       	cpc	r25, r13
    7aa6:	4c f5       	brge	.+82     	; 0x7afa <GetParameter+0x10a>
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
    7aa8:	c7 01       	movw	r24, r14
    7aaa:	b5 01       	movw	r22, r10
    7aac:	0e 94 57 20 	call	0x40ae	; 0x40ae <Pos>
    7ab0:	8c 01       	movw	r16, r24
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
    7ab2:	c7 01       	movw	r24, r14
    7ab4:	b5 01       	movw	r22, r10
    7ab6:	0e 94 57 20 	call	0x40ae	; 0x40ae <Pos>
    7aba:	a6 01       	movw	r20, r12
    7abc:	40 1b       	sub	r20, r16
    7abe:	51 0b       	sbc	r21, r17
    7ac0:	d5 01       	movw	r26, r10
    7ac2:	a8 0f       	add	r26, r24
    7ac4:	b9 1f       	adc	r27, r25
    7ac6:	20 e0       	ldi	r18, 0x00	; 0
    7ac8:	30 e0       	ldi	r19, 0x00	; 0
    7aca:	be 01       	movw	r22, r28
    7acc:	6c 5f       	subi	r22, 0xFC	; 252
    7ace:	7f 4f       	sbci	r23, 0xFF	; 255
    7ad0:	07 c0       	rjmp	.+14     	; 0x7ae0 <GetParameter+0xf0>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7ad2:	fb 01       	movw	r30, r22
    7ad4:	e2 0f       	add	r30, r18
    7ad6:	f3 1f       	adc	r31, r19
    7ad8:	8c 91       	ld	r24, X
    7ada:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7adc:	2f 5f       	subi	r18, 0xFF	; 255
    7ade:	3f 4f       	sbci	r19, 0xFF	; 255
    7ae0:	11 96       	adiw	r26, 0x01	; 1
    7ae2:	24 17       	cp	r18, r20
    7ae4:	35 07       	cpc	r19, r21
    7ae6:	a8 f3       	brcs	.-22     	; 0x7ad2 <GetParameter+0xe2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7ae8:	46 0f       	add	r20, r22
    7aea:	57 1f       	adc	r21, r23
    7aec:	fa 01       	movw	r30, r20
    7aee:	10 82       	st	Z, r1
	 *GPumpID=xPumpID;
	 sprintf_P(strSub,PSTR(":"));
	 if (Pos(strSub,SGeniusFlow)<FLength){
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
		 xCsum=atoi(sCSum);
    7af0:	cb 01       	movw	r24, r22
    7af2:	0e 94 bf b3 	call	0x1677e	; 0x1677e <atoi>
	     *GeniCSum=xCsum;
    7af6:	f4 01       	movw	r30, r8
    7af8:	80 83       	st	Z, r24
	 sprintf_P(strSend,PSTR("%d"),xPumpID);
	 _uart_print(1,1,strSend);
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 _uart_print(1,1,strSend);
*/
}
    7afa:	a7 96       	adiw	r28, 0x27	; 39
    7afc:	0f b6       	in	r0, 0x3f	; 63
    7afe:	f8 94       	cli
    7b00:	de bf       	out	0x3e, r29	; 62
    7b02:	0f be       	out	0x3f, r0	; 63
    7b04:	cd bf       	out	0x3d, r28	; 61
    7b06:	cf 91       	pop	r28
    7b08:	df 91       	pop	r29
    7b0a:	1f 91       	pop	r17
    7b0c:	0f 91       	pop	r16
    7b0e:	ff 90       	pop	r15
    7b10:	ef 90       	pop	r14
    7b12:	df 90       	pop	r13
    7b14:	cf 90       	pop	r12
    7b16:	bf 90       	pop	r11
    7b18:	af 90       	pop	r10
    7b1a:	9f 90       	pop	r9
    7b1c:	8f 90       	pop	r8
    7b1e:	08 95       	ret

00007b20 <GeniusProtocol>:
   return Result;	 
}

//enum eGeniusProtocolCommand{GP_PUMP_STATUS,GP_PUMP_LAST_TRANSACTION,GP_PUMP_STOP,GP_PUMP_RESUME,GP_PUMP_PRESET};

void GeniusProtocol(char dataIn){
    7b20:	ff 92       	push	r15
    7b22:	0f 93       	push	r16
    7b24:	1f 93       	push	r17
    7b26:	df 93       	push	r29
    7b28:	cf 93       	push	r28
    7b2a:	cd b7       	in	r28, 0x3d	; 61
    7b2c:	de b7       	in	r29, 0x3e	; 62
    7b2e:	67 97       	sbiw	r28, 0x17	; 23
    7b30:	0f b6       	in	r0, 0x3f	; 63
    7b32:	f8 94       	cli
    7b34:	de bf       	out	0x3e, r29	; 62
    7b36:	0f be       	out	0x3f, r0	; 63
    7b38:	cd bf       	out	0x3d, r28	; 61
    7b3a:	f8 2e       	mov	r15, r24
	 char i,GeniCmd,GeniPumpID,GeniCSum;//,sCmd[7];
	 char strSend[20];

    //_uart(1,1,dataIn);

	if (dataIn==0x0D){	
    7b3c:	8d e0       	ldi	r24, 0x0D	; 13
    7b3e:	f8 16       	cp	r15, r24
    7b40:	09 f0       	breq	.+2      	; 0x7b44 <GeniusProtocol+0x24>
    7b42:	45 c0       	rjmp	.+138    	; 0x7bce <GeniusProtocol+0xae>
	    GetParameter(Geniflow,FlowLength,&GeniCmd,&GeniPumpID,&GeniCSum);
    7b44:	8f ed       	ldi	r24, 0xDF	; 223
    7b46:	91 e0       	ldi	r25, 0x01	; 1
    7b48:	60 91 de 01 	lds	r22, 0x01DE
    7b4c:	ae 01       	movw	r20, r28
    7b4e:	4f 5f       	subi	r20, 0xFF	; 255
    7b50:	5f 4f       	sbci	r21, 0xFF	; 255
    7b52:	9e 01       	movw	r18, r28
    7b54:	2e 5f       	subi	r18, 0xFE	; 254
    7b56:	3f 4f       	sbci	r19, 0xFF	; 255
    7b58:	8e 01       	movw	r16, r28
    7b5a:	0d 5f       	subi	r16, 0xFD	; 253
    7b5c:	1f 4f       	sbci	r17, 0xFF	; 255
    7b5e:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <GetParameter>
		FlowLength=0;
    7b62:	10 92 de 01 	sts	0x01DE, r1
		IsGeniusFlow=False;
    7b66:	10 92 dd 01 	sts	0x01DD, r1
		FillChar(strSend,0,sizeof(strSend));
		sprintf_P(strSend,PSTR("%c%.2d:"),GeniCmd,GeniPumpID);
    7b6a:	ad b7       	in	r26, 0x3d	; 61
    7b6c:	be b7       	in	r27, 0x3e	; 62
    7b6e:	18 97       	sbiw	r26, 0x08	; 8
    7b70:	0f b6       	in	r0, 0x3f	; 63
    7b72:	f8 94       	cli
    7b74:	be bf       	out	0x3e, r27	; 62
    7b76:	0f be       	out	0x3f, r0	; 63
    7b78:	ad bf       	out	0x3d, r26	; 61
    7b7a:	ed b7       	in	r30, 0x3d	; 61
    7b7c:	fe b7       	in	r31, 0x3e	; 62
    7b7e:	31 96       	adiw	r30, 0x01	; 1
    7b80:	8e 01       	movw	r16, r28
    7b82:	0c 5f       	subi	r16, 0xFC	; 252
    7b84:	1f 4f       	sbci	r17, 0xFF	; 255
    7b86:	12 96       	adiw	r26, 0x02	; 2
    7b88:	1c 93       	st	X, r17
    7b8a:	0e 93       	st	-X, r16
    7b8c:	11 97       	sbiw	r26, 0x01	; 1
    7b8e:	89 e6       	ldi	r24, 0x69	; 105
    7b90:	93 e0       	ldi	r25, 0x03	; 3
    7b92:	93 83       	std	Z+3, r25	; 0x03
    7b94:	82 83       	std	Z+2, r24	; 0x02
    7b96:	89 81       	ldd	r24, Y+1	; 0x01
    7b98:	84 83       	std	Z+4, r24	; 0x04
    7b9a:	15 82       	std	Z+5, r1	; 0x05
    7b9c:	8a 81       	ldd	r24, Y+2	; 0x02
    7b9e:	86 83       	std	Z+6, r24	; 0x06
    7ba0:	17 82       	std	Z+7, r1	; 0x07
    7ba2:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		//_uart_print(1,1,strSend);


		if ((SumChecksum(strSend))==GeniCSum){
    7ba6:	8d b7       	in	r24, 0x3d	; 61
    7ba8:	9e b7       	in	r25, 0x3e	; 62
    7baa:	08 96       	adiw	r24, 0x08	; 8
    7bac:	0f b6       	in	r0, 0x3f	; 63
    7bae:	f8 94       	cli
    7bb0:	9e bf       	out	0x3e, r25	; 62
    7bb2:	0f be       	out	0x3f, r0	; 63
    7bb4:	8d bf       	out	0x3d, r24	; 61
    7bb6:	c8 01       	movw	r24, r16
    7bb8:	0e 94 f2 1f 	call	0x3fe4	; 0x3fe4 <SumChecksum>
    7bbc:	9b 81       	ldd	r25, Y+3	; 0x03
    7bbe:	89 17       	cp	r24, r25
    7bc0:	31 f4       	brne	.+12     	; 0x7bce <GeniusProtocol+0xae>
		     switch(GeniCmd){
    7bc2:	89 81       	ldd	r24, Y+1	; 0x01
    7bc4:	84 35       	cpi	r24, 0x54	; 84
    7bc6:	19 f4       	brne	.+6      	; 0x7bce <GeniusProtocol+0xae>
			 case 'C'://PumpStatus
			      GeniusSendPumpStatus(GeniPumpID);
			      break;
             case 'T'://Transaction Request: T01:239<0D>
			      GeniusSendLastTransaction(GeniPumpID);
    7bc8:	8a 81       	ldd	r24, Y+2	; 0x02
    7bca:	0e 94 3f 2b 	call	0x567e	; 0x567e <GeniusSendLastTransaction>
    7bce:	e1 ef       	ldi	r30, 0xF1	; 241
    7bd0:	f1 e0       	ldi	r31, 0x01	; 1
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
	    Geniflow[i]=Geniflow[i-1];	
    7bd2:	80 81       	ld	r24, Z
    7bd4:	81 83       	std	Z+1, r24	; 0x01
    7bd6:	31 97       	sbiw	r30, 0x01	; 1
			      break;
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
    7bd8:	91 e0       	ldi	r25, 0x01	; 1
    7bda:	ee 3d       	cpi	r30, 0xDE	; 222
    7bdc:	f9 07       	cpc	r31, r25
    7bde:	c9 f7       	brne	.-14     	; 0x7bd2 <GeniusProtocol+0xb2>
	    Geniflow[i]=Geniflow[i-1];	
	}Geniflow[0]=dataIn;
    7be0:	f1 82       	std	Z+1, r15	; 0x01

	if (IsGeniusCommand(dataIn)==True)IsGeniusFlow=True;
    7be2:	8f 2d       	mov	r24, r15
    7be4:	0e 94 12 20 	call	0x4024	; 0x4024 <IsGeniusCommand>
    7be8:	81 30       	cpi	r24, 0x01	; 1
    7bea:	11 f4       	brne	.+4      	; 0x7bf0 <GeniusProtocol+0xd0>
    7bec:	80 93 dd 01 	sts	0x01DD, r24
	if (IsGeniusFlow==True)FlowLength++;
    7bf0:	80 91 dd 01 	lds	r24, 0x01DD
    7bf4:	81 30       	cpi	r24, 0x01	; 1
    7bf6:	29 f4       	brne	.+10     	; 0x7c02 <GeniusProtocol+0xe2>
    7bf8:	80 91 de 01 	lds	r24, 0x01DE
    7bfc:	8f 5f       	subi	r24, 0xFF	; 255
    7bfe:	80 93 de 01 	sts	0x01DE, r24
	Geniflow[3]=Geniflow[2];
	Geniflow[2]=Geniflow[1];
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}
    7c02:	67 96       	adiw	r28, 0x17	; 23
    7c04:	0f b6       	in	r0, 0x3f	; 63
    7c06:	f8 94       	cli
    7c08:	de bf       	out	0x3e, r29	; 62
    7c0a:	0f be       	out	0x3f, r0	; 63
    7c0c:	cd bf       	out	0x3d, r28	; 61
    7c0e:	cf 91       	pop	r28
    7c10:	df 91       	pop	r29
    7c12:	1f 91       	pop	r17
    7c14:	0f 91       	pop	r16
    7c16:	ff 90       	pop	r15
    7c18:	08 95       	ret

00007c1a <__vector_30>:
}

// NotSuccessful! 


ISR(USART1_RX_vect){
    7c1a:	1f 92       	push	r1
    7c1c:	0f 92       	push	r0
    7c1e:	0f b6       	in	r0, 0x3f	; 63
    7c20:	0f 92       	push	r0
    7c22:	0b b6       	in	r0, 0x3b	; 59
    7c24:	0f 92       	push	r0
    7c26:	11 24       	eor	r1, r1
    7c28:	1f 93       	push	r17
    7c2a:	2f 93       	push	r18
    7c2c:	3f 93       	push	r19
    7c2e:	4f 93       	push	r20
    7c30:	5f 93       	push	r21
    7c32:	6f 93       	push	r22
    7c34:	7f 93       	push	r23
    7c36:	8f 93       	push	r24
    7c38:	9f 93       	push	r25
    7c3a:	af 93       	push	r26
    7c3c:	bf 93       	push	r27
    7c3e:	ef 93       	push	r30
    7c40:	ff 93       	push	r31
	char dataTX1,serialSend[12];
	static char IsAdvanZProtocol=False;
	unsigned int i;
	dataTX1 = UDR1;
    7c42:	10 91 9c 00 	lds	r17, 0x009C

	//NewPacket
	if (IsNewPacket==True){
    7c46:	80 91 9b 01 	lds	r24, 0x019B
    7c4a:	81 30       	cpi	r24, 0x01	; 1
    7c4c:	51 f4       	brne	.+20     	; 0x7c62 <__vector_30+0x48>
	    if (dataTX1==0x01){
    7c4e:	11 30       	cpi	r17, 0x01	; 1
    7c50:	41 f4       	brne	.+16     	; 0x7c62 <__vector_30+0x48>
		    char_count=0;
    7c52:	10 92 9d 01 	sts	0x019D, r1
    7c56:	10 92 9c 01 	sts	0x019C, r1
            IsNewPacket=False;
    7c5a:	10 92 9b 01 	sts	0x019B, r1
			IsAdvanZProtocol=True;
    7c5e:	10 93 a5 03 	sts	0x03A5, r17
			}
	}
    //Save data to buffer if AdvanZ MSG
	if (IsAdvanZProtocol==True){
    7c62:	80 91 a5 03 	lds	r24, 0x03A5
    7c66:	81 30       	cpi	r24, 0x01	; 1
    7c68:	69 f4       	brne	.+26     	; 0x7c84 <__vector_30+0x6a>
	    rcv_trans[char_count]=dataTX1;
    7c6a:	80 91 9c 01 	lds	r24, 0x019C
    7c6e:	90 91 9d 01 	lds	r25, 0x019D
    7c72:	fc 01       	movw	r30, r24
    7c74:	eb 5b       	subi	r30, 0xBB	; 187
    7c76:	f4 4f       	sbci	r31, 0xF4	; 244
    7c78:	10 83       	st	Z, r17
	    char_count++; 
    7c7a:	01 96       	adiw	r24, 0x01	; 1
    7c7c:	90 93 9d 01 	sts	0x019D, r25
    7c80:	80 93 9c 01 	sts	0x019C, r24
	}

	if (dataTX1==0x02){
    7c84:	12 30       	cpi	r17, 0x02	; 2
    7c86:	b1 f5       	brne	.+108    	; 0x7cf4 <__vector_30+0xda>
		transLength=char_count;
    7c88:	60 91 9c 01 	lds	r22, 0x019C
    7c8c:	70 91 9d 01 	lds	r23, 0x019D
    7c90:	70 93 9f 01 	sts	0x019F, r23
    7c94:	60 93 9e 01 	sts	0x019E, r22
		char_count=0;
    7c98:	10 92 9d 01 	sts	0x019D, r1
    7c9c:	10 92 9c 01 	sts	0x019C, r1
		IsAdvanZProtocol=False;
    7ca0:	10 92 a5 03 	sts	0x03A5, r1

		//MessageIdentification
        if (MsgCode!=MSG_NONE)MsgCode=MSG_NONE;
	    MsgCode=((rcv_trans[35]-'0')*10)+(rcv_trans[36]-'0');
    7ca4:	20 91 69 0b 	lds	r18, 0x0B69
    7ca8:	20 51       	subi	r18, 0x10	; 16
    7caa:	80 91 68 0b 	lds	r24, 0x0B68
    7cae:	3a e0       	ldi	r19, 0x0A	; 10
    7cb0:	83 9f       	mul	r24, r19
    7cb2:	c0 01       	movw	r24, r0
    7cb4:	11 24       	eor	r1, r1
    7cb6:	28 0f       	add	r18, r24
    7cb8:	20 93 24 01 	sts	0x0124, r18
     
	    IdentifyMessage(rcv_trans[0],transLength);
    7cbc:	80 91 45 0b 	lds	r24, 0x0B45
    7cc0:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <IdentifyMessage>
		IsNewPacket=True;
    7cc4:	21 e0       	ldi	r18, 0x01	; 1
    7cc6:	20 93 9b 01 	sts	0x019B, r18

		if ((rcv_trans[35]=='8')&&(rcv_trans[36]=='1')){
    7cca:	80 91 68 0b 	lds	r24, 0x0B68
    7cce:	88 33       	cpi	r24, 0x38	; 56
    7cd0:	89 f4       	brne	.+34     	; 0x7cf4 <__vector_30+0xda>
    7cd2:	80 91 69 0b 	lds	r24, 0x0B69
    7cd6:	81 33       	cpi	r24, 0x31	; 49
    7cd8:	69 f4       	brne	.+26     	; 0x7cf4 <__vector_30+0xda>
		   LengthMessage81=transLength-12-44;
    7cda:	80 91 9e 01 	lds	r24, 0x019E
    7cde:	90 91 9f 01 	lds	r25, 0x019F
    7ce2:	c8 97       	sbiw	r24, 0x38	; 56
    7ce4:	90 93 a1 01 	sts	0x01A1, r25
    7ce8:	80 93 a0 01 	sts	0x01A0, r24
		   IsMessage81=True;
    7cec:	20 93 bd 01 	sts	0x01BD, r18
		   IsCompleteFilling=True;
    7cf0:	20 93 c0 01 	sts	0x01C0, r18
		

	}//Endif(dataTX1==0x02)

	//ConfigDetection: iConf?<0D><0A>
	if (IsNewPacket!=True)ConfigProtocol(dataTX1);
    7cf4:	80 91 9b 01 	lds	r24, 0x019B
    7cf8:	81 30       	cpi	r24, 0x01	; 1
    7cfa:	19 f0       	breq	.+6      	; 0x7d02 <__vector_30+0xe8>
    7cfc:	81 2f       	mov	r24, r17
    7cfe:	0e 94 c5 14 	call	0x298a	; 0x298a <ConfigProtocol>
	//GeniusDetection: [CMD][MSG][CSUM][0x0D]
	if ((IFType==IT_STANDALONE)&&(IsNewPacket!=True))GeniusProtocol(dataTX1);		
    7d02:	80 91 10 01 	lds	r24, 0x0110
    7d06:	82 30       	cpi	r24, 0x02	; 2
    7d08:	39 f4       	brne	.+14     	; 0x7d18 <__vector_30+0xfe>
    7d0a:	80 91 9b 01 	lds	r24, 0x019B
    7d0e:	81 30       	cpi	r24, 0x01	; 1
    7d10:	19 f0       	breq	.+6      	; 0x7d18 <__vector_30+0xfe>
    7d12:	81 2f       	mov	r24, r17
    7d14:	0e 94 90 3d 	call	0x7b20	; 0x7b20 <GeniusProtocol>
    //_uart(0,1,dataTX1);
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}
    7d18:	ff 91       	pop	r31
    7d1a:	ef 91       	pop	r30
    7d1c:	bf 91       	pop	r27
    7d1e:	af 91       	pop	r26
    7d20:	9f 91       	pop	r25
    7d22:	8f 91       	pop	r24
    7d24:	7f 91       	pop	r23
    7d26:	6f 91       	pop	r22
    7d28:	5f 91       	pop	r21
    7d2a:	4f 91       	pop	r20
    7d2c:	3f 91       	pop	r19
    7d2e:	2f 91       	pop	r18
    7d30:	1f 91       	pop	r17
    7d32:	0f 90       	pop	r0
    7d34:	0b be       	out	0x3b, r0	; 59
    7d36:	0f 90       	pop	r0
    7d38:	0f be       	out	0x3f, r0	; 63
    7d3a:	0f 90       	pop	r0
    7d3c:	1f 90       	pop	r1
    7d3e:	18 95       	reti

00007d40 <procMessage99>:
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}

char procMessage99(){//<STX>[IFT IDSeq N Srce IPDest IPMsg CodeTran NoShiftDateTimeIsland IDFIP IDProduct IDDescriptionPriceVolumeAmountMOP TypeMOP NameCard IDCard HolderBalance Type Balance MeterVolume MeterAmount Current TimePrint Count Checksum ETX
    7d40:	0f 93       	push	r16
    7d42:	1f 93       	push	r17
     char Result;
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
    7d44:	80 91 45 0b 	lds	r24, 0x0B45
    7d48:	81 30       	cpi	r24, 0x01	; 1
    7d4a:	09 f0       	breq	.+2      	; 0x7d4e <procMessage99+0xe>
    7d4c:	2e c2       	rjmp	.+1116   	; 0x81aa <procMessage99+0x46a>
    7d4e:	80 91 9e 01 	lds	r24, 0x019E
    7d52:	90 91 9f 01 	lds	r25, 0x019F
    7d56:	8a 57       	subi	r24, 0x7A	; 122
    7d58:	91 40       	sbci	r25, 0x01	; 1
    7d5a:	08 f4       	brcc	.+2      	; 0x7d5e <procMessage99+0x1e>
    7d5c:	26 c2       	rjmp	.+1100   	; 0x81aa <procMessage99+0x46a>
    7d5e:	20 e0       	ldi	r18, 0x00	; 0
    7d60:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d62:	f9 01       	movw	r30, r18
    7d64:	ef 54       	subi	r30, 0x4F	; 79
    7d66:	f1 4f       	sbci	r31, 0xF1	; 241
    7d68:	d9 01       	movw	r26, r18
    7d6a:	ab 5b       	subi	r26, 0xBB	; 187
    7d6c:	b4 4f       	sbci	r27, 0xF4	; 244
    7d6e:	95 96       	adiw	r26, 0x25	; 37
    7d70:	8c 91       	ld	r24, X
    7d72:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7d74:	2f 5f       	subi	r18, 0xFF	; 255
    7d76:	3f 4f       	sbci	r19, 0xFF	; 255
    7d78:	26 30       	cpi	r18, 0x06	; 6
    7d7a:	31 05       	cpc	r19, r1
    7d7c:	91 f7       	brne	.-28     	; 0x7d62 <procMessage99+0x22>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7d7e:	10 92 b7 0e 	sts	0x0EB7, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d82:	80 91 70 0b 	lds	r24, 0x0B70
    7d86:	80 93 93 0e 	sts	0x0E93, r24
	 }Dest[Length]=0;
    7d8a:	10 92 94 0e 	sts	0x0E94, r1
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
       StrPosCopy(rcv_trans,strTranNo,37,6);//Transaction Number
       StrPosCopy(rcv_trans,strShift,43,1);
       Shift=(CharPosCopy(rcv_trans,43)-'0');
    7d8e:	80 53       	subi	r24, 0x30	; 48
    7d90:	80 93 d0 01 	sts	0x01D0, r24
    7d94:	20 e0       	ldi	r18, 0x00	; 0
    7d96:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d98:	f9 01       	movw	r30, r18
    7d9a:	ef 55       	subi	r30, 0x5F	; 95
    7d9c:	f6 4f       	sbci	r31, 0xF6	; 246
    7d9e:	d9 01       	movw	r26, r18
    7da0:	ab 5b       	subi	r26, 0xBB	; 187
    7da2:	b4 4f       	sbci	r27, 0xF4	; 244
    7da4:	9c 96       	adiw	r26, 0x2c	; 44
    7da6:	8c 91       	ld	r24, X
    7da8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7daa:	2f 5f       	subi	r18, 0xFF	; 255
    7dac:	3f 4f       	sbci	r19, 0xFF	; 255
    7dae:	2a 30       	cpi	r18, 0x0A	; 10
    7db0:	31 05       	cpc	r19, r1
    7db2:	91 f7       	brne	.-28     	; 0x7d98 <procMessage99+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7db4:	10 92 ab 09 	sts	0x09AB, r1
    7db8:	20 e0       	ldi	r18, 0x00	; 0
    7dba:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7dbc:	f9 01       	movw	r30, r18
    7dbe:	e3 5d       	subi	r30, 0xD3	; 211
    7dc0:	fa 4f       	sbci	r31, 0xFA	; 250
    7dc2:	d9 01       	movw	r26, r18
    7dc4:	ab 5b       	subi	r26, 0xBB	; 187
    7dc6:	b4 4f       	sbci	r27, 0xF4	; 244
    7dc8:	d6 96       	adiw	r26, 0x36	; 54
    7dca:	8c 91       	ld	r24, X
    7dcc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7dce:	2f 5f       	subi	r18, 0xFF	; 255
    7dd0:	3f 4f       	sbci	r19, 0xFF	; 255
    7dd2:	28 30       	cpi	r18, 0x08	; 8
    7dd4:	31 05       	cpc	r19, r1
    7dd6:	91 f7       	brne	.-28     	; 0x7dbc <procMessage99+0x7c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7dd8:	10 92 35 05 	sts	0x0535, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7ddc:	80 91 83 0b 	lds	r24, 0x0B83
    7de0:	80 93 1f 0b 	sts	0x0B1F, r24
    7de4:	80 91 84 0b 	lds	r24, 0x0B84
    7de8:	80 93 20 0b 	sts	0x0B20, r24
	 }Dest[Length]=0;
    7dec:	10 92 21 0b 	sts	0x0B21, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7df0:	80 91 85 0b 	lds	r24, 0x0B85
    7df4:	80 93 ec 09 	sts	0x09EC, r24
    7df8:	80 91 86 0b 	lds	r24, 0x0B86
    7dfc:	80 93 ed 09 	sts	0x09ED, r24
	 }Dest[Length]=0;
    7e00:	10 92 ee 09 	sts	0x09EE, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e04:	80 91 87 0b 	lds	r24, 0x0B87
    7e08:	80 93 c6 0a 	sts	0x0AC6, r24
    7e0c:	80 91 88 0b 	lds	r24, 0x0B88
    7e10:	80 93 c7 0a 	sts	0x0AC7, r24
	 }Dest[Length]=0;
    7e14:	10 92 c8 0a 	sts	0x0AC8, r1
    7e18:	20 e0       	ldi	r18, 0x00	; 0
    7e1a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e1c:	f9 01       	movw	r30, r18
    7e1e:	ef 59       	subi	r30, 0x9F	; 159
    7e20:	f5 4f       	sbci	r31, 0xF5	; 245
    7e22:	d9 01       	movw	r26, r18
    7e24:	a7 57       	subi	r26, 0x77	; 119
    7e26:	b4 4f       	sbci	r27, 0xF4	; 244
    7e28:	8c 91       	ld	r24, X
    7e2a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e2c:	2f 5f       	subi	r18, 0xFF	; 255
    7e2e:	3f 4f       	sbci	r19, 0xFF	; 255
    7e30:	2f 30       	cpi	r18, 0x0F	; 15
    7e32:	31 05       	cpc	r19, r1
    7e34:	99 f7       	brne	.-26     	; 0x7e1c <procMessage99+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e36:	10 92 70 0a 	sts	0x0A70, r1
    7e3a:	20 e0       	ldi	r18, 0x00	; 0
    7e3c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e3e:	f9 01       	movw	r30, r18
    7e40:	ef 52       	subi	r30, 0x2F	; 47
    7e42:	f8 4f       	sbci	r31, 0xF8	; 248
    7e44:	d9 01       	movw	r26, r18
    7e46:	a8 56       	subi	r26, 0x68	; 104
    7e48:	b4 4f       	sbci	r27, 0xF4	; 244
    7e4a:	8c 91       	ld	r24, X
    7e4c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e4e:	2f 5f       	subi	r18, 0xFF	; 255
    7e50:	3f 4f       	sbci	r19, 0xFF	; 255
    7e52:	28 30       	cpi	r18, 0x08	; 8
    7e54:	31 05       	cpc	r19, r1
    7e56:	99 f7       	brne	.-26     	; 0x7e3e <procMessage99+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e58:	10 92 d9 07 	sts	0x07D9, r1
    7e5c:	20 e0       	ldi	r18, 0x00	; 0
    7e5e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e60:	f9 01       	movw	r30, r18
    7e62:	eb 5a       	subi	r30, 0xAB	; 171
    7e64:	fa 4f       	sbci	r31, 0xFA	; 250
    7e66:	d9 01       	movw	r26, r18
    7e68:	a0 56       	subi	r26, 0x60	; 96
    7e6a:	b4 4f       	sbci	r27, 0xF4	; 244
    7e6c:	8c 91       	ld	r24, X
    7e6e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e70:	2f 5f       	subi	r18, 0xFF	; 255
    7e72:	3f 4f       	sbci	r19, 0xFF	; 255
    7e74:	28 30       	cpi	r18, 0x08	; 8
    7e76:	31 05       	cpc	r19, r1
    7e78:	99 f7       	brne	.-26     	; 0x7e60 <procMessage99+0x120>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e7a:	10 92 5d 05 	sts	0x055D, r1
    7e7e:	20 e0       	ldi	r18, 0x00	; 0
    7e80:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e82:	f9 01       	movw	r30, r18
    7e84:	e5 52       	subi	r30, 0x25	; 37
    7e86:	f2 4f       	sbci	r31, 0xF2	; 242
    7e88:	d9 01       	movw	r26, r18
    7e8a:	a8 55       	subi	r26, 0x58	; 88
    7e8c:	b4 4f       	sbci	r27, 0xF4	; 244
    7e8e:	8c 91       	ld	r24, X
    7e90:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e92:	2f 5f       	subi	r18, 0xFF	; 255
    7e94:	3f 4f       	sbci	r19, 0xFF	; 255
    7e96:	2a 30       	cpi	r18, 0x0A	; 10
    7e98:	31 05       	cpc	r19, r1
    7e9a:	99 f7       	brne	.-26     	; 0x7e82 <procMessage99+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e9c:	10 92 e5 0d 	sts	0x0DE5, r1

	   //FillChar(strAmount,sizeof(strAmount),0);
       StrPosCopy(rcv_trans,strAmount,99,10);

       //StrPosCopy(rcv_trans,strMOPType,109,1);
       MOPType=(CharPosCopy(rcv_trans,109)-'0');
    7ea0:	80 91 b2 0b 	lds	r24, 0x0BB2
    7ea4:	80 53       	subi	r24, 0x30	; 48
    7ea6:	80 93 cf 01 	sts	0x01CF, r24
    7eaa:	20 e0       	ldi	r18, 0x00	; 0
    7eac:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7eae:	f9 01       	movw	r30, r18
    7eb0:	e0 55       	subi	r30, 0x50	; 80
    7eb2:	f8 4f       	sbci	r31, 0xF8	; 248
    7eb4:	d9 01       	movw	r26, r18
    7eb6:	ad 54       	subi	r26, 0x4D	; 77
    7eb8:	b4 4f       	sbci	r27, 0xF4	; 244
    7eba:	8c 91       	ld	r24, X
    7ebc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7ebe:	2f 5f       	subi	r18, 0xFF	; 255
    7ec0:	3f 4f       	sbci	r19, 0xFF	; 255
    7ec2:	24 31       	cpi	r18, 0x14	; 20
    7ec4:	31 05       	cpc	r19, r1
    7ec6:	99 f7       	brne	.-26     	; 0x7eae <procMessage99+0x16e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7ec8:	10 92 c4 07 	sts	0x07C4, r1
    7ecc:	20 e0       	ldi	r18, 0x00	; 0
    7ece:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7ed0:	f9 01       	movw	r30, r18
    7ed2:	ef 54       	subi	r30, 0x4F	; 79
    7ed4:	f2 4f       	sbci	r31, 0xF2	; 242
    7ed6:	d9 01       	movw	r26, r18
    7ed8:	a9 53       	subi	r26, 0x39	; 57
    7eda:	b4 4f       	sbci	r27, 0xF4	; 244
    7edc:	8c 91       	ld	r24, X
    7ede:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7ee0:	2f 5f       	subi	r18, 0xFF	; 255
    7ee2:	3f 4f       	sbci	r19, 0xFF	; 255
    7ee4:	24 31       	cpi	r18, 0x14	; 20
    7ee6:	31 05       	cpc	r19, r1
    7ee8:	99 f7       	brne	.-26     	; 0x7ed0 <procMessage99+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7eea:	10 92 c5 0d 	sts	0x0DC5, r1
    7eee:	20 e0       	ldi	r18, 0x00	; 0
    7ef0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7ef2:	f9 01       	movw	r30, r18
    7ef4:	ec 5f       	subi	r30, 0xFC	; 252
    7ef6:	fa 4f       	sbci	r31, 0xFA	; 250
    7ef8:	d9 01       	movw	r26, r18
    7efa:	a5 52       	subi	r26, 0x25	; 37
    7efc:	b4 4f       	sbci	r27, 0xF4	; 244
    7efe:	8c 91       	ld	r24, X
    7f00:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7f02:	2f 5f       	subi	r18, 0xFF	; 255
    7f04:	3f 4f       	sbci	r19, 0xFF	; 255
    7f06:	28 32       	cpi	r18, 0x28	; 40
    7f08:	31 05       	cpc	r19, r1
    7f0a:	99 f7       	brne	.-26     	; 0x7ef2 <procMessage99+0x1b2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f0c:	10 92 2c 05 	sts	0x052C, r1
    7f10:	20 e0       	ldi	r18, 0x00	; 0
    7f12:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f14:	f9 01       	movw	r30, r18
    7f16:	e5 5c       	subi	r30, 0xC5	; 197
    7f18:	fa 4f       	sbci	r31, 0xFA	; 250
    7f1a:	d9 01       	movw	r26, r18
    7f1c:	ad 5f       	subi	r26, 0xFD	; 253
    7f1e:	b3 4f       	sbci	r27, 0xF3	; 243
    7f20:	8c 91       	ld	r24, X
    7f22:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7f24:	2f 5f       	subi	r18, 0xFF	; 255
    7f26:	3f 4f       	sbci	r19, 0xFF	; 255
    7f28:	29 31       	cpi	r18, 0x19	; 25
    7f2a:	31 05       	cpc	r19, r1
    7f2c:	99 f7       	brne	.-26     	; 0x7f14 <procMessage99+0x1d4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f2e:	10 92 54 05 	sts	0x0554, r1
    7f32:	20 e0       	ldi	r18, 0x00	; 0
    7f34:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f36:	f9 01       	movw	r30, r18
    7f38:	ed 5d       	subi	r30, 0xDD	; 221
    7f3a:	f1 4f       	sbci	r31, 0xF1	; 241
    7f3c:	d9 01       	movw	r26, r18
    7f3e:	a4 5e       	subi	r26, 0xE4	; 228
    7f40:	b3 4f       	sbci	r27, 0xF3	; 243
    7f42:	8c 91       	ld	r24, X
    7f44:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7f46:	2f 5f       	subi	r18, 0xFF	; 255
    7f48:	3f 4f       	sbci	r19, 0xFF	; 255
    7f4a:	2d 30       	cpi	r18, 0x0D	; 13
    7f4c:	31 05       	cpc	r19, r1
    7f4e:	99 f7       	brne	.-26     	; 0x7f36 <procMessage99+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f50:	10 92 30 0e 	sts	0x0E30, r1
    7f54:	20 e0       	ldi	r18, 0x00	; 0
    7f56:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f58:	f9 01       	movw	r30, r18
    7f5a:	e4 54       	subi	r30, 0x44	; 68
    7f5c:	fa 4f       	sbci	r31, 0xFA	; 250
    7f5e:	d9 01       	movw	r26, r18
    7f60:	a7 5d       	subi	r26, 0xD7	; 215
    7f62:	b3 4f       	sbci	r27, 0xF3	; 243
    7f64:	8c 91       	ld	r24, X
    7f66:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7f68:	2f 5f       	subi	r18, 0xFF	; 255
    7f6a:	3f 4f       	sbci	r19, 0xFF	; 255
    7f6c:	2d 30       	cpi	r18, 0x0D	; 13
    7f6e:	31 05       	cpc	r19, r1
    7f70:	99 f7       	brne	.-26     	; 0x7f58 <procMessage99+0x218>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f72:	10 92 c9 05 	sts	0x05C9, r1
    7f76:	20 e0       	ldi	r18, 0x00	; 0
    7f78:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f7a:	f9 01       	movw	r30, r18
    7f7c:	ef 5e       	subi	r30, 0xEF	; 239
    7f7e:	f4 4f       	sbci	r31, 0xF4	; 244
    7f80:	d9 01       	movw	r26, r18
    7f82:	aa 5c       	subi	r26, 0xCA	; 202
    7f84:	b3 4f       	sbci	r27, 0xF3	; 243
    7f86:	8c 91       	ld	r24, X
    7f88:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7f8a:	2f 5f       	subi	r18, 0xFF	; 255
    7f8c:	3f 4f       	sbci	r19, 0xFF	; 255
    7f8e:	2d 30       	cpi	r18, 0x0D	; 13
    7f90:	31 05       	cpc	r19, r1
    7f92:	99 f7       	brne	.-26     	; 0x7f7a <procMessage99+0x23a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f94:	10 92 1e 0b 	sts	0x0B1E, r1
    7f98:	20 e0       	ldi	r18, 0x00	; 0
    7f9a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f9c:	f9 01       	movw	r30, r18
    7f9e:	e1 51       	subi	r30, 0x11	; 17
    7fa0:	f6 4f       	sbci	r31, 0xF6	; 246
    7fa2:	d9 01       	movw	r26, r18
    7fa4:	ad 5b       	subi	r26, 0xBD	; 189
    7fa6:	b3 4f       	sbci	r27, 0xF3	; 243
    7fa8:	8c 91       	ld	r24, X
    7faa:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7fac:	2f 5f       	subi	r18, 0xFF	; 255
    7fae:	3f 4f       	sbci	r19, 0xFF	; 255
    7fb0:	23 31       	cpi	r18, 0x13	; 19
    7fb2:	31 05       	cpc	r19, r1
    7fb4:	99 f7       	brne	.-26     	; 0x7f9c <procMessage99+0x25c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7fb6:	10 92 02 0a 	sts	0x0A02, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7fba:	80 91 56 0c 	lds	r24, 0x0C56
    7fbe:	80 93 ae 0e 	sts	0x0EAE, r24
    7fc2:	80 91 57 0c 	lds	r24, 0x0C57
    7fc6:	80 93 af 0e 	sts	0x0EAF, r24
	 }Dest[Length]=0;
    7fca:	10 92 b0 0e 	sts	0x0EB0, r1
    7fce:	20 e0       	ldi	r18, 0x00	; 0
    7fd0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7fd2:	f9 01       	movw	r30, r18
    7fd4:	e4 5c       	subi	r30, 0xC4	; 196
    7fd6:	f4 4f       	sbci	r31, 0xF4	; 244
    7fd8:	d9 01       	movw	r26, r18
    7fda:	a8 5a       	subi	r26, 0xA8	; 168
    7fdc:	b3 4f       	sbci	r27, 0xF3	; 243
    7fde:	8c 91       	ld	r24, X
    7fe0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7fe2:	2f 5f       	subi	r18, 0xFF	; 255
    7fe4:	3f 4f       	sbci	r19, 0xFF	; 255
    7fe6:	28 30       	cpi	r18, 0x08	; 8
    7fe8:	31 05       	cpc	r19, r1
    7fea:	99 f7       	brne	.-26     	; 0x7fd2 <procMessage99+0x292>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7fec:	10 92 44 0b 	sts	0x0B44, r1
    7ff0:	20 e0       	ldi	r18, 0x00	; 0
    7ff2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7ff4:	f9 01       	movw	r30, r18
    7ff6:	e5 56       	subi	r30, 0x65	; 101
    7ff8:	fb 4f       	sbci	r31, 0xFB	; 251
    7ffa:	d9 01       	movw	r26, r18
    7ffc:	a0 5a       	subi	r26, 0xA0	; 160
    7ffe:	b3 4f       	sbci	r27, 0xF3	; 243
    8000:	8c 91       	ld	r24, X
    8002:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8004:	2f 5f       	subi	r18, 0xFF	; 255
    8006:	3f 4f       	sbci	r19, 0xFF	; 255
    8008:	28 30       	cpi	r18, 0x08	; 8
    800a:	31 05       	cpc	r19, r1
    800c:	99 f7       	brne	.-26     	; 0x7ff4 <procMessage99+0x2b4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    800e:	10 92 a3 04 	sts	0x04A3, r1
    8012:	20 e0       	ldi	r18, 0x00	; 0
    8014:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8016:	f9 01       	movw	r30, r18
    8018:	e9 53       	subi	r30, 0x39	; 57
    801a:	fb 4f       	sbci	r31, 0xFB	; 251
    801c:	d9 01       	movw	r26, r18
    801e:	a8 59       	subi	r26, 0x98	; 152
    8020:	b3 4f       	sbci	r27, 0xF3	; 243
    8022:	8c 91       	ld	r24, X
    8024:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8026:	2f 5f       	subi	r18, 0xFF	; 255
    8028:	3f 4f       	sbci	r19, 0xFF	; 255
    802a:	24 31       	cpi	r18, 0x14	; 20
    802c:	31 05       	cpc	r19, r1
    802e:	99 f7       	brne	.-26     	; 0x8016 <procMessage99+0x2d6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8030:	10 92 db 04 	sts	0x04DB, r1
    8034:	20 e0       	ldi	r18, 0x00	; 0
    8036:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8038:	f9 01       	movw	r30, r18
    803a:	ec 55       	subi	r30, 0x5C	; 92
    803c:	fb 4f       	sbci	r31, 0xFB	; 251
    803e:	d9 01       	movw	r26, r18
    8040:	a4 58       	subi	r26, 0x84	; 132
    8042:	b3 4f       	sbci	r27, 0xF3	; 243
    8044:	8c 91       	ld	r24, X
    8046:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8048:	2f 5f       	subi	r18, 0xFF	; 255
    804a:	3f 4f       	sbci	r19, 0xFF	; 255
    804c:	2e 31       	cpi	r18, 0x1E	; 30
    804e:	31 05       	cpc	r19, r1
    8050:	99 f7       	brne	.-26     	; 0x8038 <procMessage99+0x2f8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8052:	10 92 c2 04 	sts	0x04C2, r1
    8056:	20 e0       	ldi	r18, 0x00	; 0
    8058:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    805a:	f9 01       	movw	r30, r18
    805c:	e6 57       	subi	r30, 0x76	; 118
    805e:	f5 4f       	sbci	r31, 0xF5	; 245
    8060:	d9 01       	movw	r26, r18
    8062:	a6 56       	subi	r26, 0x66	; 102
    8064:	b3 4f       	sbci	r27, 0xF3	; 243
    8066:	8c 91       	ld	r24, X
    8068:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    806a:	2f 5f       	subi	r18, 0xFF	; 255
    806c:	3f 4f       	sbci	r19, 0xFF	; 255
    806e:	28 30       	cpi	r18, 0x08	; 8
    8070:	31 05       	cpc	r19, r1
    8072:	99 f7       	brne	.-26     	; 0x805a <procMessage99+0x31a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8074:	10 92 92 0a 	sts	0x0A92, r1
    8078:	20 e0       	ldi	r18, 0x00	; 0
    807a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    807c:	f9 01       	movw	r30, r18
    807e:	e2 55       	subi	r30, 0x52	; 82
    8080:	fa 4f       	sbci	r31, 0xFA	; 250
    8082:	d9 01       	movw	r26, r18
    8084:	ae 55       	subi	r26, 0x5E	; 94
    8086:	b3 4f       	sbci	r27, 0xF3	; 243
    8088:	8c 91       	ld	r24, X
    808a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    808c:	2f 5f       	subi	r18, 0xFF	; 255
    808e:	3f 4f       	sbci	r19, 0xFF	; 255
    8090:	2a 30       	cpi	r18, 0x0A	; 10
    8092:	31 05       	cpc	r19, r1
    8094:	99 f7       	brne	.-26     	; 0x807c <procMessage99+0x33c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8096:	10 92 b8 05 	sts	0x05B8, r1
    809a:	20 e0       	ldi	r18, 0x00	; 0
    809c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    809e:	f9 01       	movw	r30, r18
    80a0:	e8 5e       	subi	r30, 0xE8	; 232
    80a2:	f1 4f       	sbci	r31, 0xF1	; 241
    80a4:	d9 01       	movw	r26, r18
    80a6:	a4 55       	subi	r26, 0x54	; 84
    80a8:	b3 4f       	sbci	r27, 0xF3	; 243
    80aa:	8c 91       	ld	r24, X
    80ac:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    80ae:	2f 5f       	subi	r18, 0xFF	; 255
    80b0:	3f 4f       	sbci	r19, 0xFF	; 255
    80b2:	2a 30       	cpi	r18, 0x0A	; 10
    80b4:	31 05       	cpc	r19, r1
    80b6:	99 f7       	brne	.-26     	; 0x809e <procMessage99+0x35e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    80b8:	10 92 22 0e 	sts	0x0E22, r1
    80bc:	20 e0       	ldi	r18, 0x00	; 0
    80be:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    80c0:	f9 01       	movw	r30, r18
    80c2:	e1 5e       	subi	r30, 0xE1	; 225
    80c4:	f5 4f       	sbci	r31, 0xF5	; 245
    80c6:	d9 01       	movw	r26, r18
    80c8:	aa 54       	subi	r26, 0x4A	; 74
    80ca:	b3 4f       	sbci	r27, 0xF3	; 243
    80cc:	8c 91       	ld	r24, X
    80ce:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    80d0:	2f 5f       	subi	r18, 0xFF	; 255
    80d2:	3f 4f       	sbci	r19, 0xFF	; 255
    80d4:	24 31       	cpi	r18, 0x14	; 20
    80d6:	31 05       	cpc	r19, r1
    80d8:	99 f7       	brne	.-26     	; 0x80c0 <procMessage99+0x380>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    80da:	10 92 33 0a 	sts	0x0A33, r1
    80de:	20 e0       	ldi	r18, 0x00	; 0
    80e0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    80e2:	f9 01       	movw	r30, r18
    80e4:	e9 55       	subi	r30, 0x59	; 89
    80e6:	f5 4f       	sbci	r31, 0xF5	; 245
    80e8:	d9 01       	movw	r26, r18
    80ea:	a6 53       	subi	r26, 0x36	; 54
    80ec:	b3 4f       	sbci	r27, 0xF3	; 243
    80ee:	8c 91       	ld	r24, X
    80f0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    80f2:	2f 5f       	subi	r18, 0xFF	; 255
    80f4:	3f 4f       	sbci	r19, 0xFF	; 255
    80f6:	2a 30       	cpi	r18, 0x0A	; 10
    80f8:	31 05       	cpc	r19, r1
    80fa:	99 f7       	brne	.-26     	; 0x80e2 <procMessage99+0x3a2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    80fc:	10 92 b1 0a 	sts	0x0AB1, r1
    8100:	20 e0       	ldi	r18, 0x00	; 0
    8102:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8104:	f9 01       	movw	r30, r18
    8106:	e6 53       	subi	r30, 0x36	; 54
    8108:	fa 4f       	sbci	r31, 0xFA	; 250
    810a:	d9 01       	movw	r26, r18
    810c:	ac 52       	subi	r26, 0x2C	; 44
    810e:	b3 4f       	sbci	r27, 0xF3	; 243
    8110:	8c 91       	ld	r24, X
    8112:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8114:	2f 5f       	subi	r18, 0xFF	; 255
    8116:	3f 4f       	sbci	r19, 0xFF	; 255
    8118:	28 30       	cpi	r18, 0x08	; 8
    811a:	31 05       	cpc	r19, r1
    811c:	99 f7       	brne	.-26     	; 0x8104 <procMessage99+0x3c4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    811e:	10 92 d2 05 	sts	0x05D2, r1
    8122:	20 e0       	ldi	r18, 0x00	; 0
    8124:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8126:	f9 01       	movw	r30, r18
    8128:	ed 55       	subi	r30, 0x5D	; 93
    812a:	f1 4f       	sbci	r31, 0xF1	; 241
    812c:	d9 01       	movw	r26, r18
    812e:	a4 52       	subi	r26, 0x24	; 36
    8130:	b3 4f       	sbci	r27, 0xF3	; 243
    8132:	8c 91       	ld	r24, X
    8134:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8136:	2f 5f       	subi	r18, 0xFF	; 255
    8138:	3f 4f       	sbci	r19, 0xFF	; 255
    813a:	2a 30       	cpi	r18, 0x0A	; 10
    813c:	31 05       	cpc	r19, r1
    813e:	99 f7       	brne	.-26     	; 0x8126 <procMessage99+0x3e6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8140:	10 92 ad 0e 	sts	0x0EAD, r1
    8144:	20 e0       	ldi	r18, 0x00	; 0
    8146:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8148:	f9 01       	movw	r30, r18
    814a:	eb 5c       	subi	r30, 0xCB	; 203
    814c:	f1 4f       	sbci	r31, 0xF1	; 241
    814e:	d9 01       	movw	r26, r18
    8150:	aa 51       	subi	r26, 0x1A	; 26
    8152:	b3 4f       	sbci	r27, 0xF3	; 243
    8154:	8c 91       	ld	r24, X
    8156:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8158:	2f 5f       	subi	r18, 0xFF	; 255
    815a:	3f 4f       	sbci	r19, 0xFF	; 255
    815c:	24 31       	cpi	r18, 0x14	; 20
    815e:	31 05       	cpc	r19, r1
    8160:	99 f7       	brne	.-26     	; 0x8148 <procMessage99+0x408>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8162:	10 92 49 0e 	sts	0x0E49, r1
    8166:	20 e0       	ldi	r18, 0x00	; 0
    8168:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    816a:	f9 01       	movw	r30, r18
    816c:	e3 50       	subi	r30, 0x03	; 3
    816e:	fa 4f       	sbci	r31, 0xFA	; 250
    8170:	d9 01       	movw	r26, r18
    8172:	a6 50       	subi	r26, 0x06	; 6
    8174:	b3 4f       	sbci	r27, 0xF3	; 243
    8176:	8c 91       	ld	r24, X
    8178:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    817a:	2f 5f       	subi	r18, 0xFF	; 255
    817c:	3f 4f       	sbci	r19, 0xFF	; 255
    817e:	2e 31       	cpi	r18, 0x1E	; 30
    8180:	31 05       	cpc	r19, r1
    8182:	99 f7       	brne	.-26     	; 0x816a <procMessage99+0x42a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8184:	10 92 1b 06 	sts	0x061B, r1
       StrPosCopy(rcv_trans,strCorporateName,437,30);
	   //


	   //FIP Detection LocalAccount Null Filling
	   if ((nLocalAccount>0)&&(LocalAccountFIP[0]==atoi(strFIP_ID))){
    8188:	80 91 a4 01 	lds	r24, 0x01A4
    818c:	88 23       	and	r24, r24
    818e:	69 f0       	breq	.+26     	; 0x81aa <procMessage99+0x46a>
    8190:	00 91 36 05 	lds	r16, 0x0536
    8194:	10 e0       	ldi	r17, 0x00	; 0
    8196:	8c ee       	ldi	r24, 0xEC	; 236
    8198:	99 e0       	ldi	r25, 0x09	; 9
    819a:	0e 94 bf b3 	call	0x1677e	; 0x1677e <atoi>
    819e:	08 17       	cp	r16, r24
    81a0:	19 07       	cpc	r17, r25
    81a2:	19 f4       	brne	.+6      	; 0x81aa <procMessage99+0x46a>
	        IsCompleteFilling=True;
    81a4:	81 e0       	ldi	r24, 0x01	; 1
    81a6:	80 93 c0 01 	sts	0x01C0, r24
	   }

	  }
     return Result;     
}
    81aa:	80 e0       	ldi	r24, 0x00	; 0
    81ac:	1f 91       	pop	r17
    81ae:	0f 91       	pop	r16
    81b0:	08 95       	ret

000081b2 <GetMessageID>:
		  }
       IsStandaloneAcknoledge=True;
	  }
}

char GetMessageID(char *strMessageFlow){
    81b2:	0f 93       	push	r16
    81b4:	1f 93       	push	r17
    81b6:	df 93       	push	r29
    81b8:	cf 93       	push	r28
    81ba:	00 d0       	rcall	.+0      	; 0x81bc <GetMessageID+0xa>
    81bc:	0f 92       	push	r0
    81be:	cd b7       	in	r28, 0x3d	; 61
    81c0:	de b7       	in	r29, 0x3e	; 62
    81c2:	fc 01       	movw	r30, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    81c4:	80 81       	ld	r24, Z
    81c6:	89 83       	std	Y+1, r24	; 0x01
    81c8:	81 81       	ldd	r24, Z+1	; 0x01
    81ca:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    81cc:	1b 82       	std	Y+3, r1	; 0x03
}

char GetMessageID(char *strMessageFlow){
     char Result,strMsgID[3];
	 StrPosCopy(strMessageFlow,strMsgID,0,2);
	 RemZeroLead(strMsgID);
    81ce:	8e 01       	movw	r16, r28
    81d0:	0f 5f       	subi	r16, 0xFF	; 255
    81d2:	1f 4f       	sbci	r17, 0xFF	; 255
    81d4:	c8 01       	movw	r24, r16
    81d6:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
	 Result=atoi(strMsgID);
    81da:	c8 01       	movw	r24, r16
    81dc:	0e 94 bf b3 	call	0x1677e	; 0x1677e <atoi>
  return Result;
}
    81e0:	0f 90       	pop	r0
    81e2:	0f 90       	pop	r0
    81e4:	0f 90       	pop	r0
    81e6:	cf 91       	pop	r28
    81e8:	df 91       	pop	r29
    81ea:	1f 91       	pop	r17
    81ec:	0f 91       	pop	r16
    81ee:	08 95       	ret

000081f0 <FTestChar>:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
	     break;
	}
}

char FTestChar(){
    81f0:	0f 93       	push	r16
    81f2:	1f 93       	push	r17
    81f4:	df 93       	push	r29
    81f6:	cf 93       	push	r28
    81f8:	cd b7       	in	r28, 0x3d	; 61
    81fa:	de b7       	in	r29, 0x3e	; 62
    81fc:	64 97       	sbiw	r28, 0x14	; 20
    81fe:	0f b6       	in	r0, 0x3f	; 63
    8200:	f8 94       	cli
    8202:	de bf       	out	0x3e, r29	; 62
    8204:	0f be       	out	0x3f, r0	; 63
    8206:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],Result;
static char i=0;
     Result=MENU_NONE;
     sprintf_P(lcdteks,PSTR("D:%d C:%c  "),i,i);
    8208:	20 91 70 03 	lds	r18, 0x0370
    820c:	8d b7       	in	r24, 0x3d	; 61
    820e:	9e b7       	in	r25, 0x3e	; 62
    8210:	08 97       	sbiw	r24, 0x08	; 8
    8212:	0f b6       	in	r0, 0x3f	; 63
    8214:	f8 94       	cli
    8216:	9e bf       	out	0x3e, r25	; 62
    8218:	0f be       	out	0x3f, r0	; 63
    821a:	8d bf       	out	0x3d, r24	; 61
    821c:	ed b7       	in	r30, 0x3d	; 61
    821e:	fe b7       	in	r31, 0x3e	; 62
    8220:	31 96       	adiw	r30, 0x01	; 1
    8222:	8e 01       	movw	r16, r28
    8224:	0f 5f       	subi	r16, 0xFF	; 255
    8226:	1f 4f       	sbci	r17, 0xFF	; 255
    8228:	ad b7       	in	r26, 0x3d	; 61
    822a:	be b7       	in	r27, 0x3e	; 62
    822c:	12 96       	adiw	r26, 0x02	; 2
    822e:	1c 93       	st	X, r17
    8230:	0e 93       	st	-X, r16
    8232:	11 97       	sbiw	r26, 0x01	; 1
    8234:	88 ec       	ldi	r24, 0xC8	; 200
    8236:	9b e1       	ldi	r25, 0x1B	; 27
    8238:	93 83       	std	Z+3, r25	; 0x03
    823a:	82 83       	std	Z+2, r24	; 0x02
    823c:	24 83       	std	Z+4, r18	; 0x04
    823e:	15 82       	std	Z+5, r1	; 0x05
    8240:	26 83       	std	Z+6, r18	; 0x06
    8242:	17 82       	std	Z+7, r1	; 0x07
    8244:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
     lcd_print(1,1,lcdteks);
    8248:	8d b7       	in	r24, 0x3d	; 61
    824a:	9e b7       	in	r25, 0x3e	; 62
    824c:	08 96       	adiw	r24, 0x08	; 8
    824e:	0f b6       	in	r0, 0x3f	; 63
    8250:	f8 94       	cli
    8252:	9e bf       	out	0x3e, r25	; 62
    8254:	0f be       	out	0x3f, r0	; 63
    8256:	8d bf       	out	0x3d, r24	; 61
    8258:	81 e0       	ldi	r24, 0x01	; 1
    825a:	61 e0       	ldi	r22, 0x01	; 1
    825c:	a8 01       	movw	r20, r16
    825e:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
	 if (i==0xFF)Result=MENU_DONE;
    8262:	20 91 70 03 	lds	r18, 0x0370
	 i++;
    8266:	2f 5f       	subi	r18, 0xFF	; 255
    8268:	20 93 70 03 	sts	0x0370, r18
    826c:	21 50       	subi	r18, 0x01	; 1
    826e:	88 ee       	ldi	r24, 0xE8	; 232
    8270:	9d ef       	ldi	r25, 0xFD	; 253
    8272:	49 e1       	ldi	r20, 0x19	; 25
    8274:	50 e0       	ldi	r21, 0x00	; 0
    8276:	fa 01       	movw	r30, r20
    8278:	31 97       	sbiw	r30, 0x01	; 1
    827a:	f1 f7       	brne	.-4      	; 0x8278 <FTestChar+0x88>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    827c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    827e:	d9 f7       	brne	.-10     	; 0x8276 <FTestChar+0x86>
    8280:	80 e0       	ldi	r24, 0x00	; 0
    8282:	2f 3f       	cpi	r18, 0xFF	; 255
    8284:	09 f4       	brne	.+2      	; 0x8288 <FTestChar+0x98>
    8286:	81 e0       	ldi	r24, 0x01	; 1
     _delay_ms(6500);
  return Result;
}
    8288:	64 96       	adiw	r28, 0x14	; 20
    828a:	0f b6       	in	r0, 0x3f	; 63
    828c:	f8 94       	cli
    828e:	de bf       	out	0x3e, r29	; 62
    8290:	0f be       	out	0x3f, r0	; 63
    8292:	cd bf       	out	0x3d, r28	; 61
    8294:	cf 91       	pop	r28
    8296:	df 91       	pop	r29
    8298:	1f 91       	pop	r17
    829a:	0f 91       	pop	r16
    829c:	08 95       	ret

0000829e <DisplayPumpStatus>:
		  break;         	 
	 }
  return Result;	 
}

void DisplayPumpStatus(){
    829e:	0f 93       	push	r16
    82a0:	1f 93       	push	r17
    82a2:	df 93       	push	r29
    82a4:	cf 93       	push	r28
    82a6:	cd b7       	in	r28, 0x3d	; 61
    82a8:	de b7       	in	r29, 0x3e	; 62
    82aa:	a8 97       	sbiw	r28, 0x28	; 40
    82ac:	0f b6       	in	r0, 0x3f	; 63
    82ae:	f8 94       	cli
    82b0:	de bf       	out	0x3e, r29	; 62
    82b2:	0f be       	out	0x3f, r0	; 63
    82b4:	cd bf       	out	0x3d, r28	; 61
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
    82b6:	80 91 11 01 	lds	r24, 0x0111
    82ba:	81 30       	cpi	r24, 0x01	; 1
    82bc:	09 f0       	breq	.+2      	; 0x82c0 <DisplayPumpStatus+0x22>
    82be:	4a c0       	rjmp	.+148    	; 0x8354 <DisplayPumpStatus+0xb6>
	     IsNewPumpStatus=False;
    82c0:	10 92 11 01 	sts	0x0111, r1
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    82c4:	80 93 bf 03 	sts	0x03BF, r24
    82c8:	10 92 c0 03 	sts	0x03C0, r1
    82cc:	80 91 65 00 	lds	r24, 0x0065
    82d0:	8d 7f       	andi	r24, 0xFD	; 253
    82d2:	80 93 65 00 	sts	0x0065, r24
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
    82d6:	80 91 5f 01 	lds	r24, 0x015F
    82da:	48 2f       	mov	r20, r24
    82dc:	50 e0       	ldi	r21, 0x00	; 0
    82de:	20 e0       	ldi	r18, 0x00	; 0
    82e0:	30 e0       	ldi	r19, 0x00	; 0
    82e2:	be 01       	movw	r22, r28
    82e4:	6f 5f       	subi	r22, 0xFF	; 255
    82e6:	7f 4f       	sbci	r23, 0xFF	; 255
    82e8:	0a c0       	rjmp	.+20     	; 0x82fe <DisplayPumpStatus+0x60>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    82ea:	fb 01       	movw	r30, r22
    82ec:	e2 0f       	add	r30, r18
    82ee:	f3 1f       	adc	r31, r19
    82f0:	d9 01       	movw	r26, r18
    82f2:	ae 5e       	subi	r26, 0xEE	; 238
    82f4:	be 4f       	sbci	r27, 0xFE	; 254
    82f6:	8c 91       	ld	r24, X
    82f8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    82fa:	2f 5f       	subi	r18, 0xFF	; 255
    82fc:	3f 4f       	sbci	r19, 0xFF	; 255
    82fe:	24 17       	cp	r18, r20
    8300:	35 07       	cpc	r19, r21
    8302:	98 f3       	brcs	.-26     	; 0x82ea <DisplayPumpStatus+0x4c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8304:	46 0f       	add	r20, r22
    8306:	57 1f       	adc	r21, r23
    8308:	da 01       	movw	r26, r20
    830a:	1c 92       	st	X, r1

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
    830c:	00 d0       	rcall	.+0      	; 0x830e <DisplayPumpStatus+0x70>
    830e:	00 d0       	rcall	.+0      	; 0x8310 <DisplayPumpStatus+0x72>
    8310:	00 d0       	rcall	.+0      	; 0x8312 <DisplayPumpStatus+0x74>
    8312:	ed b7       	in	r30, 0x3d	; 61
    8314:	fe b7       	in	r31, 0x3e	; 62
    8316:	31 96       	adiw	r30, 0x01	; 1
    8318:	8e 01       	movw	r16, r28
    831a:	0b 5e       	subi	r16, 0xEB	; 235
    831c:	1f 4f       	sbci	r17, 0xFF	; 255
    831e:	ad b7       	in	r26, 0x3d	; 61
    8320:	be b7       	in	r27, 0x3e	; 62
    8322:	12 96       	adiw	r26, 0x02	; 2
    8324:	1c 93       	st	X, r17
    8326:	0e 93       	st	-X, r16
    8328:	11 97       	sbiw	r26, 0x01	; 1
    832a:	88 e5       	ldi	r24, 0x58	; 88
    832c:	92 e2       	ldi	r25, 0x22	; 34
    832e:	93 83       	std	Z+3, r25	; 0x03
    8330:	82 83       	std	Z+2, r24	; 0x02
    8332:	75 83       	std	Z+5, r23	; 0x05
    8334:	64 83       	std	Z+4, r22	; 0x04
    8336:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
         lcd_print(4,1,lcdteks);
    833a:	ed b7       	in	r30, 0x3d	; 61
    833c:	fe b7       	in	r31, 0x3e	; 62
    833e:	36 96       	adiw	r30, 0x06	; 6
    8340:	0f b6       	in	r0, 0x3f	; 63
    8342:	f8 94       	cli
    8344:	fe bf       	out	0x3e, r31	; 62
    8346:	0f be       	out	0x3f, r0	; 63
    8348:	ed bf       	out	0x3d, r30	; 61
    834a:	84 e0       	ldi	r24, 0x04	; 4
    834c:	61 e0       	ldi	r22, 0x01	; 1
    834e:	a8 01       	movw	r20, r16
    8350:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
     	 }
}
    8354:	a8 96       	adiw	r28, 0x28	; 40
    8356:	0f b6       	in	r0, 0x3f	; 63
    8358:	f8 94       	cli
    835a:	de bf       	out	0x3e, r29	; 62
    835c:	0f be       	out	0x3f, r0	; 63
    835e:	cd bf       	out	0x3d, r28	; 61
    8360:	cf 91       	pop	r28
    8362:	df 91       	pop	r29
    8364:	1f 91       	pop	r17
    8366:	0f 91       	pop	r16
    8368:	08 95       	ret

0000836a <FViewFreeMessage>:
char FViewFreeMessage(){
static char stFreeMessage=fmInit;
       char Result=MENU_NONE;
     
	 Result=MENU_NONE;
	 switch(stFreeMessage){
    836a:	80 91 59 03 	lds	r24, 0x0359
    836e:	81 30       	cpi	r24, 0x01	; 1
    8370:	49 f0       	breq	.+18     	; 0x8384 <FViewFreeMessage+0x1a>
    8372:	81 30       	cpi	r24, 0x01	; 1
    8374:	28 f0       	brcs	.+10     	; 0x8380 <FViewFreeMessage+0x16>
    8376:	82 30       	cpi	r24, 0x02	; 2
    8378:	19 f1       	breq	.+70     	; 0x83c0 <FViewFreeMessage+0x56>
    837a:	83 30       	cpi	r24, 0x03	; 3
    837c:	71 f5       	brne	.+92     	; 0x83da <FViewFreeMessage+0x70>
    837e:	29 c0       	rjmp	.+82     	; 0x83d2 <FViewFreeMessage+0x68>
	 case fmInit:
	      stFreeMessage=fmDisplayFreeMessage;
    8380:	81 e0       	ldi	r24, 0x01	; 1
    8382:	23 c0       	rjmp	.+70     	; 0x83ca <FViewFreeMessage+0x60>
	      break;
     case fmDisplayFreeMessage:
		  lcd_clear();
    8384:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    8388:	81 e0       	ldi	r24, 0x01	; 1
    838a:	61 e0       	ldi	r22, 0x01	; 1
    838c:	47 ee       	ldi	r20, 0xE7	; 231
    838e:	5a e0       	ldi	r21, 0x0A	; 10
    8390:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    8394:	82 e0       	ldi	r24, 0x02	; 2
    8396:	61 e0       	ldi	r22, 0x01	; 1
    8398:	46 ed       	ldi	r20, 0xD6	; 214
    839a:	59 e0       	ldi	r21, 0x09	; 9
    839c:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    83a0:	83 e0       	ldi	r24, 0x03	; 3
    83a2:	61 e0       	ldi	r22, 0x01	; 1
    83a4:	41 e7       	ldi	r20, 0x71	; 113
    83a6:	5a e0       	ldi	r21, 0x0A	; 10
    83a8:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    83ac:	84 e0       	ldi	r24, 0x04	; 4
    83ae:	61 e0       	ldi	r22, 0x01	; 1
    83b0:	41 e0       	ldi	r20, 0x01	; 1
    83b2:	5e e0       	ldi	r21, 0x0E	; 14
    83b4:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
	      TimDisplay=0;
    83b8:	10 92 a7 01 	sts	0x01A7, r1
	      stFreeMessage=fmDelayViewMesage;
    83bc:	82 e0       	ldi	r24, 0x02	; 2
    83be:	05 c0       	rjmp	.+10     	; 0x83ca <FViewFreeMessage+0x60>
	      break;
	 case fmDelayViewMesage:  
	      if (TimDisplay>TIM_FREE_MESSAGE)stFreeMessage=fmFinishFreeMessage;
    83c0:	80 91 a7 01 	lds	r24, 0x01A7
    83c4:	8b 30       	cpi	r24, 0x0B	; 11
    83c6:	48 f0       	brcs	.+18     	; 0x83da <FViewFreeMessage+0x70>
    83c8:	83 e0       	ldi	r24, 0x03	; 3
    83ca:	80 93 59 03 	sts	0x0359, r24
    83ce:	80 e0       	ldi	r24, 0x00	; 0
    83d0:	08 95       	ret
	      break;
     case fmFinishFreeMessage:
          stFreeMessage=fmInit;
    83d2:	10 92 59 03 	sts	0x0359, r1
    83d6:	81 e0       	ldi	r24, 0x01	; 1
    83d8:	08 95       	ret
    83da:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;
}
    83dc:	08 95       	ret

000083de <_scr_idle>:
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
		break;
	 }
}

void _scr_idle(void){
    83de:	cf 92       	push	r12
    83e0:	df 92       	push	r13
    83e2:	ef 92       	push	r14
    83e4:	ff 92       	push	r15
    83e6:	0f 93       	push	r16
    83e8:	1f 93       	push	r17
    83ea:	df 93       	push	r29
    83ec:	cf 93       	push	r28
    83ee:	cd b7       	in	r28, 0x3d	; 61
    83f0:	de b7       	in	r29, 0x3e	; 62
    83f2:	a8 97       	sbiw	r28, 0x28	; 40
    83f4:	0f b6       	in	r0, 0x3f	; 63
    83f6:	f8 94       	cli
    83f8:	de bf       	out	0x3e, r29	; 62
    83fa:	0f be       	out	0x3f, r0	; 63
    83fc:	cd bf       	out	0x3d, r28	; 61
char strCodeName[10],strVersion[10],lcdteks[20];
    sprintf_P(strCodeName,PSTR(CODE_NAME)); 
    83fe:	00 d0       	rcall	.+0      	; 0x8400 <_scr_idle+0x22>
    8400:	00 d0       	rcall	.+0      	; 0x8402 <_scr_idle+0x24>
    8402:	6e 01       	movw	r12, r28
    8404:	08 94       	sec
    8406:	c1 1c       	adc	r12, r1
    8408:	d1 1c       	adc	r13, r1
    840a:	ad b7       	in	r26, 0x3d	; 61
    840c:	be b7       	in	r27, 0x3e	; 62
    840e:	12 96       	adiw	r26, 0x02	; 2
    8410:	dc 92       	st	X, r13
    8412:	ce 92       	st	-X, r12
    8414:	11 97       	sbiw	r26, 0x01	; 1
    8416:	81 ee       	ldi	r24, 0xE1	; 225
    8418:	91 e2       	ldi	r25, 0x21	; 33
    841a:	14 96       	adiw	r26, 0x04	; 4
    841c:	9c 93       	st	X, r25
    841e:	8e 93       	st	-X, r24
    8420:	13 97       	sbiw	r26, 0x03	; 3
    8422:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    sprintf_P(strVersion,PSTR(VERSION_NUM)); 
    8426:	fb e0       	ldi	r31, 0x0B	; 11
    8428:	ef 2e       	mov	r14, r31
    842a:	f1 2c       	mov	r15, r1
    842c:	ec 0e       	add	r14, r28
    842e:	fd 1e       	adc	r15, r29
    8430:	ed b7       	in	r30, 0x3d	; 61
    8432:	fe b7       	in	r31, 0x3e	; 62
    8434:	f2 82       	std	Z+2, r15	; 0x02
    8436:	e1 82       	std	Z+1, r14	; 0x01
    8438:	8c ed       	ldi	r24, 0xDC	; 220
    843a:	91 e2       	ldi	r25, 0x21	; 33
    843c:	94 83       	std	Z+4, r25	; 0x04
    843e:	83 83       	std	Z+3, r24	; 0x03
    8440:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    sprintf_P(lcdteks,PSTR("%s %s"),strCodeName,strVersion); 
    8444:	00 d0       	rcall	.+0      	; 0x8446 <_scr_idle+0x68>
    8446:	00 d0       	rcall	.+0      	; 0x8448 <_scr_idle+0x6a>
    8448:	ed b7       	in	r30, 0x3d	; 61
    844a:	fe b7       	in	r31, 0x3e	; 62
    844c:	31 96       	adiw	r30, 0x01	; 1
    844e:	8e 01       	movw	r16, r28
    8450:	0b 5e       	subi	r16, 0xEB	; 235
    8452:	1f 4f       	sbci	r17, 0xFF	; 255
    8454:	ad b7       	in	r26, 0x3d	; 61
    8456:	be b7       	in	r27, 0x3e	; 62
    8458:	12 96       	adiw	r26, 0x02	; 2
    845a:	1c 93       	st	X, r17
    845c:	0e 93       	st	-X, r16
    845e:	11 97       	sbiw	r26, 0x01	; 1
    8460:	86 ed       	ldi	r24, 0xD6	; 214
    8462:	91 e2       	ldi	r25, 0x21	; 33
    8464:	93 83       	std	Z+3, r25	; 0x03
    8466:	82 83       	std	Z+2, r24	; 0x02
    8468:	d5 82       	std	Z+5, r13	; 0x05
    846a:	c4 82       	std	Z+4, r12	; 0x04
    846c:	f7 82       	std	Z+7, r15	; 0x07
    846e:	e6 82       	std	Z+6, r14	; 0x06
    8470:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	lcd_clear();
    8474:	ed b7       	in	r30, 0x3d	; 61
    8476:	fe b7       	in	r31, 0x3e	; 62
    8478:	38 96       	adiw	r30, 0x08	; 8
    847a:	0f b6       	in	r0, 0x3f	; 63
    847c:	f8 94       	cli
    847e:	fe bf       	out	0x3e, r31	; 62
    8480:	0f be       	out	0x3f, r0	; 63
    8482:	ed bf       	out	0x3d, r30	; 61
    8484:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
	lcd_print(1,1,lcdteks);
    8488:	81 e0       	ldi	r24, 0x01	; 1
    848a:	61 e0       	ldi	r22, 0x01	; 1
    848c:	a8 01       	movw	r20, r16
    848e:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
}
    8492:	a8 96       	adiw	r28, 0x28	; 40
    8494:	0f b6       	in	r0, 0x3f	; 63
    8496:	f8 94       	cli
    8498:	de bf       	out	0x3e, r29	; 62
    849a:	0f be       	out	0x3f, r0	; 63
    849c:	cd bf       	out	0x3d, r28	; 61
    849e:	cf 91       	pop	r28
    84a0:	df 91       	pop	r29
    84a2:	1f 91       	pop	r17
    84a4:	0f 91       	pop	r16
    84a6:	ff 90       	pop	r15
    84a8:	ef 90       	pop	r14
    84aa:	df 90       	pop	r13
    84ac:	cf 90       	pop	r12
    84ae:	08 95       	ret

000084b0 <_scr_pump>:
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);

}
void _scr_pump(void){
    84b0:	8f 92       	push	r8
    84b2:	9f 92       	push	r9
    84b4:	af 92       	push	r10
    84b6:	bf 92       	push	r11
    84b8:	cf 92       	push	r12
    84ba:	df 92       	push	r13
    84bc:	ef 92       	push	r14
    84be:	ff 92       	push	r15
    84c0:	0f 93       	push	r16
    84c2:	1f 93       	push	r17
    84c4:	df 93       	push	r29
    84c6:	cf 93       	push	r28
    84c8:	cd b7       	in	r28, 0x3d	; 61
    84ca:	de b7       	in	r29, 0x3e	; 62
    84cc:	6c 97       	sbiw	r28, 0x1c	; 28
    84ce:	0f b6       	in	r0, 0x3f	; 63
    84d0:	f8 94       	cli
    84d2:	de bf       	out	0x3e, r29	; 62
    84d4:	0f be       	out	0x3f, r0	; 63
    84d6:	cd bf       	out	0x3d, r28	; 61
	 //char strPumpL[3],strPumpR[3];
	 char __pump_id[8];
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
    84d8:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
    84dc:	84 ec       	ldi	r24, 0xC4	; 196
    84de:	99 e0       	ldi	r25, 0x09	; 9
    84e0:	01 97       	sbiw	r24, 0x01	; 1
    84e2:	f1 f7       	brne	.-4      	; 0x84e0 <_scr_pump+0x30>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    84e4:	8e 01       	movw	r16, r28
    84e6:	0f 5f       	subi	r16, 0xFF	; 255
    84e8:	1f 4f       	sbci	r17, 0xFF	; 255
    84ea:	c8 01       	movw	r24, r16
    84ec:	65 e4       	ldi	r22, 0x45	; 69
    84ee:	70 e0       	ldi	r23, 0x00	; 0
    84f0:	48 e0       	ldi	r20, 0x08	; 8
    84f2:	50 e0       	ldi	r21, 0x00	; 0
    84f4:	25 ed       	ldi	r18, 0xD5	; 213
    84f6:	32 e1       	ldi	r19, 0x12	; 18
    84f8:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
    84fc:	78 01       	movw	r14, r16
    84fe:	01 e0       	ldi	r16, 0x01	; 1
    8500:	10 e0       	ldi	r17, 0x00	; 0
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    8502:	89 e0       	ldi	r24, 0x09	; 9
    8504:	c8 2e       	mov	r12, r24
    8506:	d1 2c       	mov	r13, r1
    8508:	cc 0e       	add	r12, r28
    850a:	dd 1e       	adc	r13, r29
    850c:	b1 e4       	ldi	r27, 0x41	; 65
    850e:	8b 2e       	mov	r8, r27
    8510:	bd e0       	ldi	r27, 0x0D	; 13
    8512:	9b 2e       	mov	r9, r27
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    8514:	a5 e0       	ldi	r26, 0x05	; 5
    8516:	aa 2e       	mov	r10, r26
    8518:	b1 2c       	mov	r11, r1
    851a:	ac 0e       	add	r10, r28
    851c:	bd 1e       	adc	r11, r29
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    851e:	8d b7       	in	r24, 0x3d	; 61
    8520:	9e b7       	in	r25, 0x3e	; 62
    8522:	0c 97       	sbiw	r24, 0x0c	; 12
    8524:	0f b6       	in	r0, 0x3f	; 63
    8526:	f8 94       	cli
    8528:	9e bf       	out	0x3e, r25	; 62
    852a:	0f be       	out	0x3f, r0	; 63
    852c:	8d bf       	out	0x3d, r24	; 61
    852e:	ed b7       	in	r30, 0x3d	; 61
    8530:	fe b7       	in	r31, 0x3e	; 62
    8532:	31 96       	adiw	r30, 0x01	; 1
    8534:	ad b7       	in	r26, 0x3d	; 61
    8536:	be b7       	in	r27, 0x3e	; 62
    8538:	12 96       	adiw	r26, 0x02	; 2
    853a:	dc 92       	st	X, r13
    853c:	ce 92       	st	-X, r12
    853e:	11 97       	sbiw	r26, 0x01	; 1
    8540:	93 82       	std	Z+3, r9	; 0x03
    8542:	82 82       	std	Z+2, r8	; 0x02
    8544:	15 83       	std	Z+5, r17	; 0x05
    8546:	04 83       	std	Z+4, r16	; 0x04
    8548:	d7 01       	movw	r26, r14
    854a:	8c 91       	ld	r24, X
    854c:	86 83       	std	Z+6, r24	; 0x06
    854e:	17 82       	std	Z+7, r1	; 0x07
    8550:	0c 5f       	subi	r16, 0xFC	; 252
    8552:	1f 4f       	sbci	r17, 0xFF	; 255
    8554:	11 87       	std	Z+9, r17	; 0x09
    8556:	00 87       	std	Z+8, r16	; 0x08
    8558:	04 50       	subi	r16, 0x04	; 4
    855a:	10 40       	sbci	r17, 0x00	; 0
    855c:	14 96       	adiw	r26, 0x04	; 4
    855e:	8c 91       	ld	r24, X
    8560:	82 87       	std	Z+10, r24	; 0x0a
    8562:	13 86       	std	Z+11, r1	; 0x0b
    8564:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			 lcd_print((i+1),1,lcdteks);
    8568:	8d b7       	in	r24, 0x3d	; 61
    856a:	9e b7       	in	r25, 0x3e	; 62
    856c:	0c 96       	adiw	r24, 0x0c	; 12
    856e:	0f b6       	in	r0, 0x3f	; 63
    8570:	f8 94       	cli
    8572:	9e bf       	out	0x3e, r25	; 62
    8574:	0f be       	out	0x3f, r0	; 63
    8576:	8d bf       	out	0x3d, r24	; 61
    8578:	80 2f       	mov	r24, r16
    857a:	61 e0       	ldi	r22, 0x01	; 1
    857c:	a6 01       	movw	r20, r12
    857e:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    8582:	08 94       	sec
    8584:	e1 1c       	adc	r14, r1
    8586:	f1 1c       	adc	r15, r1
    8588:	0f 5f       	subi	r16, 0xFF	; 255
    858a:	1f 4f       	sbci	r17, 0xFF	; 255
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    858c:	ea 14       	cp	r14, r10
    858e:	fb 04       	cpc	r15, r11
    8590:	31 f6       	brne	.-116    	; 0x851e <_scr_pump+0x6e>
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
			 lcd_print((i+1),1,lcdteks);
		}
        lcd_printf(4,15,PSTR("*)Exit"));
    8592:	84 e0       	ldi	r24, 0x04	; 4
    8594:	6f e0       	ldi	r22, 0x0F	; 15
    8596:	4a e3       	ldi	r20, 0x3A	; 58
    8598:	5d e0       	ldi	r21, 0x0D	; 13
    859a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
}
    859e:	6c 96       	adiw	r28, 0x1c	; 28
    85a0:	0f b6       	in	r0, 0x3f	; 63
    85a2:	f8 94       	cli
    85a4:	de bf       	out	0x3e, r29	; 62
    85a6:	0f be       	out	0x3f, r0	; 63
    85a8:	cd bf       	out	0x3d, r28	; 61
    85aa:	cf 91       	pop	r28
    85ac:	df 91       	pop	r29
    85ae:	1f 91       	pop	r17
    85b0:	0f 91       	pop	r16
    85b2:	ff 90       	pop	r15
    85b4:	ef 90       	pop	r14
    85b6:	df 90       	pop	r13
    85b8:	cf 90       	pop	r12
    85ba:	bf 90       	pop	r11
    85bc:	af 90       	pop	r10
    85be:	9f 90       	pop	r9
    85c0:	8f 90       	pop	r8
    85c2:	08 95       	ret

000085c4 <_menu_host>:
			lcd_print(__x, __y, __buff);
		}
	}
}

void _menu_host(void){
    85c4:	2f 92       	push	r2
    85c6:	3f 92       	push	r3
    85c8:	4f 92       	push	r4
    85ca:	5f 92       	push	r5
    85cc:	6f 92       	push	r6
    85ce:	7f 92       	push	r7
    85d0:	8f 92       	push	r8
    85d2:	9f 92       	push	r9
    85d4:	af 92       	push	r10
    85d6:	bf 92       	push	r11
    85d8:	cf 92       	push	r12
    85da:	df 92       	push	r13
    85dc:	ef 92       	push	r14
    85de:	ff 92       	push	r15
    85e0:	0f 93       	push	r16
    85e2:	1f 93       	push	r17
    85e4:	df 93       	push	r29
    85e6:	cf 93       	push	r28
    85e8:	cd b7       	in	r28, 0x3d	; 61
    85ea:	de b7       	in	r29, 0x3e	; 62
    85ec:	6d 97       	sbiw	r28, 0x1d	; 29
    85ee:	0f b6       	in	r0, 0x3f	; 63
    85f0:	f8 94       	cli
    85f2:	de bf       	out	0x3e, r29	; 62
    85f4:	0f be       	out	0x3f, r0	; 63
    85f6:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    85f8:	e1 99       	sbic	0x1c, 1	; 28
    85fa:	fe cf       	rjmp	.-4      	; 0x85f8 <_menu_host+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    85fc:	21 ec       	ldi	r18, 0xC1	; 193
    85fe:	33 e0       	ldi	r19, 0x03	; 3
    8600:	3f bb       	out	0x1f, r19	; 31
    8602:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8604:	e0 9a       	sbi	0x1c, 0	; 28
    8606:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[4];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];
	static char TermID;

	__value[0] = eeprom_read_byte(&DefPrintMoney);
    8608:	89 83       	std	Y+1, r24	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    860a:	e1 99       	sbic	0x1c, 1	; 28
    860c:	fe cf       	rjmp	.-4      	; 0x860a <_menu_host+0x46>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    860e:	f7 e3       	ldi	r31, 0x37	; 55
    8610:	2f 2e       	mov	r2, r31
    8612:	f0 e0       	ldi	r31, 0x00	; 0
    8614:	3f 2e       	mov	r3, r31
    8616:	3f ba       	out	0x1f, r3	; 31
    8618:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    861a:	e0 9a       	sbi	0x1c, 0	; 28
    861c:	8d b3       	in	r24, 0x1d	; 29
	__value[1] = eeprom_read_byte(&DefShowDateTime);
    861e:	8a 83       	std	Y+2, r24	; 0x02
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8620:	e1 99       	sbic	0x1c, 1	; 28
    8622:	fe cf       	rjmp	.-4      	; 0x8620 <_menu_host+0x5c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8624:	e8 e3       	ldi	r30, 0x38	; 56
    8626:	4e 2e       	mov	r4, r30
    8628:	e0 e0       	ldi	r30, 0x00	; 0
    862a:	5e 2e       	mov	r5, r30
    862c:	5f ba       	out	0x1f, r5	; 31
    862e:	4e ba       	out	0x1e, r4	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8630:	e0 9a       	sbi	0x1c, 0	; 28
    8632:	8d b3       	in	r24, 0x1d	; 29
	__value[2] = eeprom_read_byte(&DefNotifScreen);
    8634:	8b 83       	std	Y+3, r24	; 0x03
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8636:	e1 99       	sbic	0x1c, 1	; 28
    8638:	fe cf       	rjmp	.-4      	; 0x8636 <_menu_host+0x72>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    863a:	70 e0       	ldi	r23, 0x00	; 0
    863c:	67 2e       	mov	r6, r23
    863e:	70 e0       	ldi	r23, 0x00	; 0
    8640:	77 2e       	mov	r7, r23
    8642:	7f ba       	out	0x1f, r7	; 31
    8644:	6e ba       	out	0x1e, r6	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8646:	e0 9a       	sbi	0x1c, 0	; 28
    8648:	8d b3       	in	r24, 0x1d	; 29
	TermID= eeprom_read_byte(&DefIFT_ID);
    864a:	80 93 d1 02 	sts	0x02D1, r24


	lcd_clear();_delay_ms(10);
    864e:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
    8652:	84 ec       	ldi	r24, 0xC4	; 196
    8654:	99 e0       	ldi	r25, 0x09	; 9
    8656:	01 97       	sbiw	r24, 0x01	; 1
    8658:	f1 f7       	brne	.-4      	; 0x8656 <_menu_host+0x92>
	lcd_printf(1, 1, PSTR("1)Money :"));
    865a:	81 e0       	ldi	r24, 0x01	; 1
    865c:	61 e0       	ldi	r22, 0x01	; 1
    865e:	4f e3       	ldi	r20, 0x3F	; 63
    8660:	5b e0       	ldi	r21, 0x0B	; 11
    8662:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	lcd_printf(2, 1, PSTR("2)D/T   :"));
    8666:	82 e0       	ldi	r24, 0x02	; 2
    8668:	61 e0       	ldi	r22, 0x01	; 1
    866a:	45 e3       	ldi	r20, 0x35	; 53
    866c:	5b e0       	ldi	r21, 0x0B	; 11
    866e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
    8672:	83 e0       	ldi	r24, 0x03	; 3
    8674:	61 e0       	ldi	r22, 0x01	; 1
    8676:	40 e2       	ldi	r20, 0x20	; 32
    8678:	5b e0       	ldi	r21, 0x0B	; 11
    867a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    867e:	00 d0       	rcall	.+0      	; 0x8680 <_menu_host+0xbc>
    8680:	00 d0       	rcall	.+0      	; 0x8682 <_menu_host+0xbe>
    8682:	00 d0       	rcall	.+0      	; 0x8684 <_menu_host+0xc0>
    8684:	ed b7       	in	r30, 0x3d	; 61
    8686:	fe b7       	in	r31, 0x3e	; 62
    8688:	31 96       	adiw	r30, 0x01	; 1
    868a:	8e 01       	movw	r16, r28
    868c:	06 5f       	subi	r16, 0xF6	; 246
    868e:	1f 4f       	sbci	r17, 0xFF	; 255
    8690:	ad b7       	in	r26, 0x3d	; 61
    8692:	be b7       	in	r27, 0x3e	; 62
    8694:	12 96       	adiw	r26, 0x02	; 2
    8696:	1c 93       	st	X, r17
    8698:	0e 93       	st	-X, r16
    869a:	11 97       	sbiw	r26, 0x01	; 1
    869c:	83 e1       	ldi	r24, 0x13	; 19
    869e:	9b e0       	ldi	r25, 0x0B	; 11
    86a0:	93 83       	std	Z+3, r25	; 0x03
    86a2:	82 83       	std	Z+2, r24	; 0x02
    86a4:	80 91 d1 02 	lds	r24, 0x02D1
    86a8:	84 83       	std	Z+4, r24	; 0x04
    86aa:	15 82       	std	Z+5, r1	; 0x05
    86ac:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		 lcd_print(4, 1,lcdteks);
    86b0:	ed b7       	in	r30, 0x3d	; 61
    86b2:	fe b7       	in	r31, 0x3e	; 62
    86b4:	36 96       	adiw	r30, 0x06	; 6
    86b6:	0f b6       	in	r0, 0x3f	; 63
    86b8:	f8 94       	cli
    86ba:	fe bf       	out	0x3e, r31	; 62
    86bc:	0f be       	out	0x3f, r0	; 63
    86be:	ed bf       	out	0x3d, r30	; 61
    86c0:	84 e0       	ldi	r24, 0x04	; 4
    86c2:	61 e0       	ldi	r22, 0x01	; 1
    86c4:	a8 01       	movw	r20, r16
    86c6:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
	lcd_printf(4, 15, PSTR("#)Save"));
    86ca:	84 e0       	ldi	r24, 0x04	; 4
    86cc:	6f e0       	ldi	r22, 0x0F	; 15
    86ce:	4c e0       	ldi	r20, 0x0C	; 12
    86d0:	5b e0       	ldi	r21, 0x0B	; 11
    86d2:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
    86d6:	68 ef       	ldi	r22, 0xF8	; 248
    86d8:	e6 2e       	mov	r14, r22
    86da:	62 e0       	ldi	r22, 0x02	; 2
    86dc:	f6 2e       	mov	r15, r22
    86de:	6e 01       	movw	r12, r28
    86e0:	08 94       	sec
    86e2:	c1 1c       	adc	r12, r1
    86e4:	d1 1c       	adc	r13, r1

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
		__y = pgm_read_byte(&__hostloc[__i][1]);
		_f_inttostr(__buff, __value[__i]);
    86e6:	55 e0       	ldi	r21, 0x05	; 5
    86e8:	a5 2e       	mov	r10, r21
    86ea:	b1 2c       	mov	r11, r1
    86ec:	ac 0e       	add	r10, r28
    86ee:	bd 1e       	adc	r11, r29
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
		 lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
    86f0:	f7 01       	movw	r30, r14
    86f2:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__hostloc[__i][1]);
    86f4:	08 94       	sec
    86f6:	e1 1c       	adc	r14, r1
    86f8:	f1 1c       	adc	r15, r1
    86fa:	f7 01       	movw	r30, r14
    86fc:	14 91       	lpm	r17, Z+
		_f_inttostr(__buff, __value[__i]);
    86fe:	d6 01       	movw	r26, r12
    8700:	4d 91       	ld	r20, X+
    8702:	6d 01       	movw	r12, r26
    8704:	50 e0       	ldi	r21, 0x00	; 0
    8706:	60 e0       	ldi	r22, 0x00	; 0
    8708:	70 e0       	ldi	r23, 0x00	; 0
    870a:	c5 01       	movw	r24, r10
    870c:	0e 94 44 19 	call	0x3288	; 0x3288 <_f_inttostr>
		lcd_print(__x, __y, __buff);
    8710:	80 2f       	mov	r24, r16
    8712:	61 2f       	mov	r22, r17
    8714:	a5 01       	movw	r20, r10
    8716:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    871a:	08 94       	sec
    871c:	e1 1c       	adc	r14, r1
    871e:	f1 1c       	adc	r15, r1
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
		 lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
    8720:	be ef       	ldi	r27, 0xFE	; 254
    8722:	eb 16       	cp	r14, r27
    8724:	b2 e0       	ldi	r27, 0x02	; 2
    8726:	fb 06       	cpc	r15, r27
    8728:	19 f7       	brne	.-58     	; 0x86f0 <_menu_host+0x12c>
			lcd_print(__x, __y, __buff);
		}else
		if (__num=='4'){
		    if (TermID<=99)TermID++;
			else TermID=1;
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    872a:	4a e0       	ldi	r20, 0x0A	; 10
    872c:	a4 2e       	mov	r10, r20
    872e:	b1 2c       	mov	r11, r1
    8730:	ac 0e       	add	r10, r28
    8732:	bd 1e       	adc	r11, r29
    8734:	3f ef       	ldi	r19, 0xFF	; 255
    8736:	83 2e       	mov	r8, r19
    8738:	3a e0       	ldi	r19, 0x0A	; 10
    873a:	93 2e       	mov	r9, r19
			eeprom_write_byte(&DefNotifScreen, __value[2]);
			eeprom_write_byte(&DefIFT_ID,TermID);
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
			if(__value[__num - 0x31] == 1)
    873c:	6e 01       	movw	r12, r28
    873e:	08 94       	sec
    8740:	c1 1c       	adc	r12, r1
    8742:	d1 1c       	adc	r13, r1
				__value[__num - 0x31] = 0;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
			_f_inttostr(__buff, __value[__num - 0x31]);
    8744:	25 e0       	ldi	r18, 0x05	; 5
    8746:	e2 2e       	mov	r14, r18
    8748:	f1 2c       	mov	r15, r1
    874a:	ec 0e       	add	r14, r28
    874c:	fd 1e       	adc	r15, r29
		_f_inttostr(__buff, __value[__i]);
		lcd_print(__x, __y, __buff);
	}

	while(1){
		__key = _key_scan(1);
    874e:	81 e0       	ldi	r24, 0x01	; 1
    8750:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    8754:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    8756:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
    875a:	98 2f       	mov	r25, r24

		if(__key == _KEY_CANCEL)
    875c:	17 3e       	cpi	r17, 0xE7	; 231
    875e:	09 f4       	brne	.+2      	; 0x8762 <_menu_host+0x19e>
    8760:	95 c0       	rjmp	.+298    	; 0x888c <_menu_host+0x2c8>
			return;
		if(__key==_KEY_ENTER){
    8762:	17 3b       	cpi	r17, 0xB7	; 183
    8764:	09 f0       	breq	.+2      	; 0x8768 <_menu_host+0x1a4>
    8766:	30 c0       	rjmp	.+96     	; 0x87c8 <_menu_host+0x204>
			eeprom_write_byte(&DefPrintMoney, __value[0]);
    8768:	89 81       	ldd	r24, Y+1	; 0x01
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    876a:	e1 99       	sbic	0x1c, 1	; 28
    876c:	fe cf       	rjmp	.-4      	; 0x876a <_menu_host+0x1a6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    876e:	e1 ec       	ldi	r30, 0xC1	; 193
    8770:	f3 e0       	ldi	r31, 0x03	; 3
    8772:	ff bb       	out	0x1f, r31	; 31
    8774:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    8776:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8778:	0f b6       	in	r0, 0x3f	; 63
    877a:	f8 94       	cli
    877c:	e2 9a       	sbi	0x1c, 2	; 28
    877e:	e1 9a       	sbi	0x1c, 1	; 28
    8780:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefShowDateTime, __value[1]);
    8782:	8a 81       	ldd	r24, Y+2	; 0x02
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8784:	e1 99       	sbic	0x1c, 1	; 28
    8786:	fe cf       	rjmp	.-4      	; 0x8784 <_menu_host+0x1c0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8788:	3f ba       	out	0x1f, r3	; 31
    878a:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    878c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    878e:	0f b6       	in	r0, 0x3f	; 63
    8790:	f8 94       	cli
    8792:	e2 9a       	sbi	0x1c, 2	; 28
    8794:	e1 9a       	sbi	0x1c, 1	; 28
    8796:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefNotifScreen, __value[2]);
    8798:	8b 81       	ldd	r24, Y+3	; 0x03
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    879a:	e1 99       	sbic	0x1c, 1	; 28
    879c:	fe cf       	rjmp	.-4      	; 0x879a <_menu_host+0x1d6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    879e:	5f ba       	out	0x1f, r5	; 31
    87a0:	4e ba       	out	0x1e, r4	; 30
#endif
    EEDR = __value;
    87a2:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    87a4:	0f b6       	in	r0, 0x3f	; 63
    87a6:	f8 94       	cli
    87a8:	e2 9a       	sbi	0x1c, 2	; 28
    87aa:	e1 9a       	sbi	0x1c, 1	; 28
    87ac:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefIFT_ID,TermID);
    87ae:	80 91 d1 02 	lds	r24, 0x02D1
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    87b2:	e1 99       	sbic	0x1c, 1	; 28
    87b4:	fe cf       	rjmp	.-4      	; 0x87b2 <_menu_host+0x1ee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    87b6:	7f ba       	out	0x1f, r7	; 31
    87b8:	6e ba       	out	0x1e, r6	; 30
#endif
    EEDR = __value;
    87ba:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    87bc:	0f b6       	in	r0, 0x3f	; 63
    87be:	f8 94       	cli
    87c0:	e2 9a       	sbi	0x1c, 2	; 28
    87c2:	e1 9a       	sbi	0x1c, 1	; 28
    87c4:	0f be       	out	0x3f, r0	; 63
    87c6:	62 c0       	rjmp	.+196    	; 0x888c <_menu_host+0x2c8>
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
    87c8:	81 53       	subi	r24, 0x31	; 49
    87ca:	83 30       	cpi	r24, 0x03	; 3
    87cc:	58 f5       	brcc	.+86     	; 0x8824 <_menu_host+0x260>
			if(__value[__num - 0x31] == 1)
    87ce:	a9 2f       	mov	r26, r25
    87d0:	b0 e0       	ldi	r27, 0x00	; 0
    87d2:	d1 97       	sbiw	r26, 0x31	; 49
    87d4:	f6 01       	movw	r30, r12
    87d6:	ea 0f       	add	r30, r26
    87d8:	fb 1f       	adc	r31, r27
    87da:	80 81       	ld	r24, Z
    87dc:	81 30       	cpi	r24, 0x01	; 1
    87de:	11 f4       	brne	.+4      	; 0x87e4 <_menu_host+0x220>
				__value[__num - 0x31] = 0;
    87e0:	10 82       	st	Z, r1
    87e2:	02 c0       	rjmp	.+4      	; 0x87e8 <_menu_host+0x224>
			else
				__value[__num - 0x31]++;
    87e4:	8f 5f       	subi	r24, 0xFF	; 255
    87e6:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
    87e8:	29 2f       	mov	r18, r25
    87ea:	30 e0       	ldi	r19, 0x00	; 0
    87ec:	21 53       	subi	r18, 0x31	; 49
    87ee:	30 40       	sbci	r19, 0x00	; 0
    87f0:	22 0f       	add	r18, r18
    87f2:	33 1f       	adc	r19, r19
    87f4:	c9 01       	movw	r24, r18
    87f6:	88 50       	subi	r24, 0x08	; 8
    87f8:	9d 4f       	sbci	r25, 0xFD	; 253
    87fa:	fc 01       	movw	r30, r24
    87fc:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
    87fe:	27 50       	subi	r18, 0x07	; 7
    8800:	3d 4f       	sbci	r19, 0xFD	; 253
    8802:	f9 01       	movw	r30, r18
    8804:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __value[__num - 0x31]);
    8806:	ac 0d       	add	r26, r12
    8808:	bd 1d       	adc	r27, r13
    880a:	4c 91       	ld	r20, X
    880c:	50 e0       	ldi	r21, 0x00	; 0
    880e:	60 e0       	ldi	r22, 0x00	; 0
    8810:	70 e0       	ldi	r23, 0x00	; 0
    8812:	c7 01       	movw	r24, r14
    8814:	0e 94 44 19 	call	0x3288	; 0x3288 <_f_inttostr>
			lcd_print(__x, __y, __buff);
    8818:	80 2f       	mov	r24, r16
    881a:	61 2f       	mov	r22, r17
    881c:	a7 01       	movw	r20, r14
    881e:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    8822:	95 cf       	rjmp	.-214    	; 0x874e <_menu_host+0x18a>
		}else
		if (__num=='4'){
    8824:	94 33       	cpi	r25, 0x34	; 52
    8826:	09 f0       	breq	.+2      	; 0x882a <_menu_host+0x266>
    8828:	92 cf       	rjmp	.-220    	; 0x874e <_menu_host+0x18a>
		    if (TermID<=99)TermID++;
    882a:	80 91 d1 02 	lds	r24, 0x02D1
    882e:	84 36       	cpi	r24, 0x64	; 100
    8830:	10 f4       	brcc	.+4      	; 0x8836 <_menu_host+0x272>
    8832:	8f 5f       	subi	r24, 0xFF	; 255
    8834:	01 c0       	rjmp	.+2      	; 0x8838 <_menu_host+0x274>
			else TermID=1;
    8836:	81 e0       	ldi	r24, 0x01	; 1
    8838:	80 93 d1 02 	sts	0x02D1, r24
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    883c:	00 d0       	rcall	.+0      	; 0x883e <_menu_host+0x27a>
    883e:	00 d0       	rcall	.+0      	; 0x8840 <_menu_host+0x27c>
    8840:	00 d0       	rcall	.+0      	; 0x8842 <_menu_host+0x27e>
    8842:	ed b7       	in	r30, 0x3d	; 61
    8844:	fe b7       	in	r31, 0x3e	; 62
    8846:	31 96       	adiw	r30, 0x01	; 1
    8848:	ad b7       	in	r26, 0x3d	; 61
    884a:	be b7       	in	r27, 0x3e	; 62
    884c:	12 96       	adiw	r26, 0x02	; 2
    884e:	bc 92       	st	X, r11
    8850:	ae 92       	st	-X, r10
    8852:	11 97       	sbiw	r26, 0x01	; 1
    8854:	93 82       	std	Z+3, r9	; 0x03
    8856:	82 82       	std	Z+2, r8	; 0x02
    8858:	80 91 d1 02 	lds	r24, 0x02D1
    885c:	84 83       	std	Z+4, r24	; 0x04
    885e:	15 82       	std	Z+5, r1	; 0x05
    8860:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		 lcd_print(4, 1,lcdteks);lcd_printf(4, 15, PSTR("#)Save"));
    8864:	ed b7       	in	r30, 0x3d	; 61
    8866:	fe b7       	in	r31, 0x3e	; 62
    8868:	36 96       	adiw	r30, 0x06	; 6
    886a:	0f b6       	in	r0, 0x3f	; 63
    886c:	f8 94       	cli
    886e:	fe bf       	out	0x3e, r31	; 62
    8870:	0f be       	out	0x3f, r0	; 63
    8872:	ed bf       	out	0x3d, r30	; 61
    8874:	84 e0       	ldi	r24, 0x04	; 4
    8876:	61 e0       	ldi	r22, 0x01	; 1
    8878:	a5 01       	movw	r20, r10
    887a:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    887e:	84 e0       	ldi	r24, 0x04	; 4
    8880:	6f e0       	ldi	r22, 0x0F	; 15
    8882:	48 ef       	ldi	r20, 0xF8	; 248
    8884:	5a e0       	ldi	r21, 0x0A	; 10
    8886:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
    888a:	61 cf       	rjmp	.-318    	; 0x874e <_menu_host+0x18a>
		 
		}

	}
}
    888c:	6d 96       	adiw	r28, 0x1d	; 29
    888e:	0f b6       	in	r0, 0x3f	; 63
    8890:	f8 94       	cli
    8892:	de bf       	out	0x3e, r29	; 62
    8894:	0f be       	out	0x3f, r0	; 63
    8896:	cd bf       	out	0x3d, r28	; 61
    8898:	cf 91       	pop	r28
    889a:	df 91       	pop	r29
    889c:	1f 91       	pop	r17
    889e:	0f 91       	pop	r16
    88a0:	ff 90       	pop	r15
    88a2:	ef 90       	pop	r14
    88a4:	df 90       	pop	r13
    88a6:	cf 90       	pop	r12
    88a8:	bf 90       	pop	r11
    88aa:	af 90       	pop	r10
    88ac:	9f 90       	pop	r9
    88ae:	8f 90       	pop	r8
    88b0:	7f 90       	pop	r7
    88b2:	6f 90       	pop	r6
    88b4:	5f 90       	pop	r5
    88b6:	4f 90       	pop	r4
    88b8:	3f 90       	pop	r3
    88ba:	2f 90       	pop	r2
    88bc:	08 95       	ret

000088be <FSettingHost>:
char FSettingPrinter(){
     _menu_printer();
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
    88be:	0e 94 e2 42 	call	0x85c4	; 0x85c4 <_menu_host>
	 return MENU_DONE;
}
    88c2:	81 e0       	ldi	r24, 0x01	; 1
    88c4:	08 95       	ret

000088c6 <system_stop>:
	return Result;
}

void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
    88c6:	84 e0       	ldi	r24, 0x04	; 4
    88c8:	61 e0       	ldi	r22, 0x01	; 1
    88ca:	48 ee       	ldi	r20, 0xE8	; 232
    88cc:	51 e2       	ldi	r21, 0x21	; 33
    88ce:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    88d2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    88d4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    88d6:	85 e0       	ldi	r24, 0x05	; 5
    88d8:	90 e0       	ldi	r25, 0x00	; 0
    88da:	90 93 d7 01 	sts	0x01D7, r25
    88de:	80 93 d6 01 	sts	0x01D6, r24
void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
	 system_beep(5);
	 while(1){
		__key = _key_scan(1);
    88e2:	81 e0       	ldi	r24, 0x01	; 1
    88e4:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
		__num = _key_btn(__key);
    88e8:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
    88ec:	80 53       	subi	r24, 0x30	; 48
    88ee:	8a 30       	cpi	r24, 0x0A	; 10
    88f0:	20 f0       	brcs	.+8      	; 0x88fa <system_stop+0x34>
    88f2:	80 91 b3 01 	lds	r24, 0x01B3
    88f6:	81 30       	cpi	r24, 0x01	; 1
    88f8:	a1 f7       	brne	.-24     	; 0x88e2 <system_stop+0x1c>
    88fa:	08 95       	ret

000088fc <systemForceType>:
	 }
}

char systemForceType(){
     char Result,KeyChar;
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
    88fc:	84 e0       	ldi	r24, 0x04	; 4
    88fe:	61 e0       	ldi	r22, 0x01	; 1
    8900:	4d ef       	ldi	r20, 0xFD	; 253
    8902:	51 e2       	ldi	r21, 0x21	; 33
    8904:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    8908:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    890a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    890c:	81 e0       	ldi	r24, 0x01	; 1
    890e:	90 e0       	ldi	r25, 0x00	; 0
    8910:	90 93 d7 01 	sts	0x01D7, r25
    8914:	80 93 d6 01 	sts	0x01D6, r24
    8918:	80 e5       	ldi	r24, 0x50	; 80
    891a:	93 ec       	ldi	r25, 0xC3	; 195
    891c:	01 97       	sbiw	r24, 0x01	; 1
    891e:	f1 f7       	brne	.-4      	; 0x891c <systemForceType+0x20>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    8920:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    8922:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    8924:	82 e0       	ldi	r24, 0x02	; 2
    8926:	90 e0       	ldi	r25, 0x00	; 0
    8928:	90 93 d7 01 	sts	0x01D7, r25
    892c:	80 93 d6 01 	sts	0x01D6, r24
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
	 system_beep(1);
	 _delay_ms(200);
	 system_beep(2);
	 while(1){
	    KeyChar=_key_btn(_key_scan(1));
    8930:	81 e0       	ldi	r24, 0x01	; 1
    8932:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    8936:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
    893a:	98 2f       	mov	r25, r24
		if ((KeyChar=='1')||(KeyChar=='2')){
    893c:	81 53       	subi	r24, 0x31	; 49
    893e:	82 30       	cpi	r24, 0x02	; 2
    8940:	b8 f7       	brcc	.-18     	; 0x8930 <systemForceType+0x34>
		    Result=KeyChar;
			break;
		}
	 }
	return Result;
}
    8942:	89 2f       	mov	r24, r25
    8944:	08 95       	ret

00008946 <SetTotalizerData>:
			  }
		  }
	 }
}

void SetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "00000000"
    8946:	af 92       	push	r10
    8948:	bf 92       	push	r11
    894a:	cf 92       	push	r12
    894c:	df 92       	push	r13
    894e:	ef 92       	push	r14
    8950:	ff 92       	push	r15
    8952:	0f 93       	push	r16
    8954:	1f 93       	push	r17
    8956:	df 93       	push	r29
    8958:	cf 93       	push	r28
    895a:	cd b7       	in	r28, 0x3d	; 61
    895c:	de b7       	in	r29, 0x3e	; 62
    895e:	65 97       	sbiw	r28, 0x15	; 21
    8960:	0f b6       	in	r0, 0x3f	; 63
    8962:	f8 94       	cli
    8964:	de bf       	out	0x3e, r29	; 62
    8966:	0f be       	out	0x3f, r0	; 63
    8968:	cd bf       	out	0x3d, r28	; 61
    896a:	d8 2e       	mov	r13, r24
    896c:	c6 2e       	mov	r12, r22
    896e:	b4 2e       	mov	r11, r20
    8970:	a2 2e       	mov	r10, r18
     char rawValue[6],iPumpAddr,iGrade;
	 char strPValue[15];
	 char Idx;
	 char strSend[30];
	 //Convert String to RawData
	 if (strlen(strValue)<=12){
    8972:	d8 01       	movw	r26, r16
    8974:	0d 90       	ld	r0, X+
    8976:	00 20       	and	r0, r0
    8978:	e9 f7       	brne	.-6      	; 0x8974 <SetTotalizerData+0x2e>
    897a:	11 97       	sbiw	r26, 0x01	; 1
    897c:	a0 1b       	sub	r26, r16
    897e:	b1 0b       	sbc	r27, r17
    8980:	87 e0       	ldi	r24, 0x07	; 7
    8982:	e8 2e       	mov	r14, r24
    8984:	f1 2c       	mov	r15, r1
    8986:	ec 0e       	add	r14, r28
    8988:	fd 1e       	adc	r15, r29
    898a:	ad 30       	cpi	r26, 0x0D	; 13
    898c:	b1 05       	cpc	r27, r1
    898e:	58 f5       	brcc	.+86     	; 0x89e6 <SetTotalizerData+0xa0>
	     sprintf_P(strPValue,PSTR("%s"),strValue);
    8990:	00 d0       	rcall	.+0      	; 0x8992 <SetTotalizerData+0x4c>
    8992:	00 d0       	rcall	.+0      	; 0x8994 <SetTotalizerData+0x4e>
    8994:	00 d0       	rcall	.+0      	; 0x8996 <SetTotalizerData+0x50>
    8996:	ed b7       	in	r30, 0x3d	; 61
    8998:	fe b7       	in	r31, 0x3e	; 62
    899a:	31 96       	adiw	r30, 0x01	; 1
    899c:	ad b7       	in	r26, 0x3d	; 61
    899e:	be b7       	in	r27, 0x3e	; 62
    89a0:	12 96       	adiw	r26, 0x02	; 2
    89a2:	fc 92       	st	X, r15
    89a4:	ee 92       	st	-X, r14
    89a6:	11 97       	sbiw	r26, 0x01	; 1
    89a8:	88 ee       	ldi	r24, 0xE8	; 232
    89aa:	95 e0       	ldi	r25, 0x05	; 5
    89ac:	93 83       	std	Z+3, r25	; 0x03
    89ae:	82 83       	std	Z+2, r24	; 0x02
    89b0:	15 83       	std	Z+5, r17	; 0x05
    89b2:	04 83       	std	Z+4, r16	; 0x04
    89b4:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		 if (strlen(strPValue)<12)AddZeroLead(strPValue,12);
    89b8:	f7 01       	movw	r30, r14
    89ba:	01 90       	ld	r0, Z+
    89bc:	00 20       	and	r0, r0
    89be:	e9 f7       	brne	.-6      	; 0x89ba <SetTotalizerData+0x74>
    89c0:	31 97       	sbiw	r30, 0x01	; 1
    89c2:	ee 19       	sub	r30, r14
    89c4:	ff 09       	sbc	r31, r15
    89c6:	6d b7       	in	r22, 0x3d	; 61
    89c8:	7e b7       	in	r23, 0x3e	; 62
    89ca:	6a 5f       	subi	r22, 0xFA	; 250
    89cc:	7f 4f       	sbci	r23, 0xFF	; 255
    89ce:	0f b6       	in	r0, 0x3f	; 63
    89d0:	f8 94       	cli
    89d2:	7e bf       	out	0x3e, r23	; 62
    89d4:	0f be       	out	0x3f, r0	; 63
    89d6:	6d bf       	out	0x3d, r22	; 61
    89d8:	3c 97       	sbiw	r30, 0x0c	; 12
    89da:	a0 f4       	brcc	.+40     	; 0x8a04 <SetTotalizerData+0xbe>
    89dc:	c7 01       	movw	r24, r14
    89de:	6c e0       	ldi	r22, 0x0C	; 12
    89e0:	0e 94 3c 25 	call	0x4a78	; 0x4a78 <AddZeroLead>
    89e4:	0f c0       	rjmp	.+30     	; 0x8a04 <SetTotalizerData+0xbe>
    89e6:	8a 2f       	mov	r24, r26
    89e8:	8c 50       	subi	r24, 0x0C	; 12
    89ea:	f8 01       	movw	r30, r16
    89ec:	e8 0f       	add	r30, r24
    89ee:	f1 1d       	adc	r31, r1
    89f0:	d7 01       	movw	r26, r14
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    89f2:	9e 01       	movw	r18, r28
    89f4:	2d 5e       	subi	r18, 0xED	; 237
    89f6:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    89f8:	81 91       	ld	r24, Z+
    89fa:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    89fc:	a2 17       	cp	r26, r18
    89fe:	b3 07       	cpc	r27, r19
    8a00:	d9 f7       	brne	.-10     	; 0x89f8 <SetTotalizerData+0xb2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8a02:	1b 8a       	std	Y+19, r1	; 0x13
	 else {//Lebih dari 8: 0123456789
	     Idx=strlen(strValue)-12;
	     StrPosCopy(strValue,strPValue,Idx,12);
	 }

	 iPumpAddr=(xPumpAddr&0x0F);
    8a04:	0b 2d       	mov	r16, r11
    8a06:	0f 70       	andi	r16, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    8a08:	1a 2d       	mov	r17, r10
    8a0a:	11 50       	subi	r17, 0x01	; 1
    8a0c:	16 30       	cpi	r17, 0x06	; 6
    8a0e:	08 f0       	brcs	.+2      	; 0x8a12 <SetTotalizerData+0xcc>
    8a10:	10 e0       	ldi	r17, 0x00	; 0
	     iGrade=xGradeAddr-1;
	 StrToRaw(strPValue,rawValue);
    8a12:	ce 01       	movw	r24, r28
    8a14:	07 96       	adiw	r24, 0x07	; 7
    8a16:	7e 01       	movw	r14, r28
    8a18:	08 94       	sec
    8a1a:	e1 1c       	adc	r14, r1
    8a1c:	f1 1c       	adc	r15, r1
    8a1e:	b7 01       	movw	r22, r14
    8a20:	0e 94 b3 19 	call	0x3366	; 0x3366 <StrToRaw>

	 if (TType==TVOLUME)eeprom_write_block((const void*)&rawValue,(void*)&(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    8a24:	dd 20       	and	r13, r13
    8a26:	d9 f4       	brne	.+54     	; 0x8a5e <SetTotalizerData+0x118>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8a28:	84 e2       	ldi	r24, 0x24	; 36
    8a2a:	08 9f       	mul	r16, r24
    8a2c:	c0 01       	movw	r24, r0
    8a2e:	11 24       	eor	r1, r1
    8a30:	4c 2d       	mov	r20, r12
    8a32:	50 e0       	ldi	r21, 0x00	; 0
    8a34:	20 e2       	ldi	r18, 0x20	; 32
    8a36:	31 e0       	ldi	r19, 0x01	; 1
    8a38:	d9 01       	movw	r26, r18
    8a3a:	4a 9f       	mul	r20, r26
    8a3c:	90 01       	movw	r18, r0
    8a3e:	4b 9f       	mul	r20, r27
    8a40:	30 0d       	add	r19, r0
    8a42:	5a 9f       	mul	r21, r26
    8a44:	30 0d       	add	r19, r0
    8a46:	11 24       	eor	r1, r1
    8a48:	82 0f       	add	r24, r18
    8a4a:	93 1f       	adc	r25, r19
    8a4c:	26 e0       	ldi	r18, 0x06	; 6
    8a4e:	12 9f       	mul	r17, r18
    8a50:	90 01       	movw	r18, r0
    8a52:	11 24       	eor	r1, r1
    8a54:	82 0f       	add	r24, r18
    8a56:	93 1f       	adc	r25, r19
    8a58:	8d 53       	subi	r24, 0x3D	; 61
    8a5a:	9c 4f       	sbci	r25, 0xFC	; 252
    8a5c:	1d c0       	rjmp	.+58     	; 0x8a98 <SetTotalizerData+0x152>
	 else 
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    8a5e:	b1 e0       	ldi	r27, 0x01	; 1
    8a60:	db 16       	cp	r13, r27
    8a62:	09 f5       	brne	.+66     	; 0x8aa6 <SetTotalizerData+0x160>
    8a64:	84 e2       	ldi	r24, 0x24	; 36
    8a66:	08 9f       	mul	r16, r24
    8a68:	c0 01       	movw	r24, r0
    8a6a:	11 24       	eor	r1, r1
    8a6c:	4c 2d       	mov	r20, r12
    8a6e:	50 e0       	ldi	r21, 0x00	; 0
    8a70:	20 e2       	ldi	r18, 0x20	; 32
    8a72:	31 e0       	ldi	r19, 0x01	; 1
    8a74:	b9 01       	movw	r22, r18
    8a76:	46 9f       	mul	r20, r22
    8a78:	90 01       	movw	r18, r0
    8a7a:	47 9f       	mul	r20, r23
    8a7c:	30 0d       	add	r19, r0
    8a7e:	56 9f       	mul	r21, r22
    8a80:	30 0d       	add	r19, r0
    8a82:	11 24       	eor	r1, r1
    8a84:	82 0f       	add	r24, r18
    8a86:	93 1f       	adc	r25, r19
    8a88:	26 e0       	ldi	r18, 0x06	; 6
    8a8a:	12 9f       	mul	r17, r18
    8a8c:	90 01       	movw	r18, r0
    8a8e:	11 24       	eor	r1, r1
    8a90:	82 0f       	add	r24, r18
    8a92:	93 1f       	adc	r25, r19
    8a94:	8d 5f       	subi	r24, 0xFD	; 253
    8a96:	99 4f       	sbci	r25, 0xF9	; 249
    8a98:	b7 01       	movw	r22, r14
    8a9a:	46 e0       	ldi	r20, 0x06	; 6
    8a9c:	50 e0       	ldi	r21, 0x00	; 0
    8a9e:	2d ed       	ldi	r18, 0xDD	; 221
    8aa0:	32 e1       	ldi	r19, 0x12	; 18
    8aa2:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
}
    8aa6:	65 96       	adiw	r28, 0x15	; 21
    8aa8:	0f b6       	in	r0, 0x3f	; 63
    8aaa:	f8 94       	cli
    8aac:	de bf       	out	0x3e, r29	; 62
    8aae:	0f be       	out	0x3f, r0	; 63
    8ab0:	cd bf       	out	0x3d, r28	; 61
    8ab2:	cf 91       	pop	r28
    8ab4:	df 91       	pop	r29
    8ab6:	1f 91       	pop	r17
    8ab8:	0f 91       	pop	r16
    8aba:	ff 90       	pop	r15
    8abc:	ef 90       	pop	r14
    8abe:	df 90       	pop	r13
    8ac0:	cf 90       	pop	r12
    8ac2:	bf 90       	pop	r11
    8ac4:	af 90       	pop	r10
    8ac6:	08 95       	ret

00008ac8 <SaveTotalizerCurrentToLast>:
	 }Dest[12]=0;
}

//SetTotalizerData(TVOLUME,TOTALIZER_NOW,1,1,strVolume)

void SaveTotalizerCurrentToLast(){
    8ac8:	4f 92       	push	r4
    8aca:	5f 92       	push	r5
    8acc:	7f 92       	push	r7
    8ace:	8f 92       	push	r8
    8ad0:	9f 92       	push	r9
    8ad2:	af 92       	push	r10
    8ad4:	bf 92       	push	r11
    8ad6:	cf 92       	push	r12
    8ad8:	df 92       	push	r13
    8ada:	ef 92       	push	r14
    8adc:	ff 92       	push	r15
    8ade:	0f 93       	push	r16
    8ae0:	1f 93       	push	r17
    8ae2:	df 93       	push	r29
    8ae4:	cf 93       	push	r28
    8ae6:	cd b7       	in	r28, 0x3d	; 61
    8ae8:	de b7       	in	r29, 0x3e	; 62
    8aea:	2f 97       	sbiw	r28, 0x0f	; 15
    8aec:	0f b6       	in	r0, 0x3f	; 63
    8aee:	f8 94       	cli
    8af0:	de bf       	out	0x3e, r29	; 62
    8af2:	0f be       	out	0x3f, r0	; 63
    8af4:	cd bf       	out	0x3d, r28	; 61
    8af6:	77 24       	eor	r7, r7
    8af8:	73 94       	inc	r7
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    8afa:	4e 01       	movw	r8, r28
    8afc:	08 94       	sec
    8afe:	81 1c       	adc	r8, r1
    8b00:	91 1c       	adc	r9, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8b02:	90 e1       	ldi	r25, 0x10	; 16
    8b04:	49 2e       	mov	r4, r25
    8b06:	51 2c       	mov	r5, r1
    8b08:	4c 0e       	add	r4, r28
    8b0a:	5d 1e       	adc	r5, r29
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    8b0c:	87 2d       	mov	r24, r7
    8b0e:	0e 94 1a 1c 	call	0x3834	; 0x3834 <GetFIPAddr>
		  if (FIPAddr>0){
    8b12:	88 23       	and	r24, r24
    8b14:	91 f1       	breq	.+100    	; 0x8b7a <SaveTotalizerCurrentToLast+0xb2>
		      FIPAddr=FIPAddr-1;
    8b16:	a8 2e       	mov	r10, r24
    8b18:	aa 94       	dec	r10
    8b1a:	bb 24       	eor	r11, r11
    8b1c:	b3 94       	inc	r11
    8b1e:	2a c0       	rjmp	.+84     	; 0x8b74 <SaveTotalizerCurrentToLast+0xac>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    8b20:	f7 01       	movw	r30, r14
    8b22:	11 92       	st	Z+, r1
    8b24:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8b26:	e4 15       	cp	r30, r4
    8b28:	f5 05       	cpc	r31, r5
    8b2a:	d1 f7       	brne	.-12     	; 0x8b20 <SaveTotalizerCurrentToLast+0x58>
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    8b2c:	80 e0       	ldi	r24, 0x00	; 0
    8b2e:	61 e0       	ldi	r22, 0x01	; 1
    8b30:	4a 2d       	mov	r20, r10
    8b32:	2b 2d       	mov	r18, r11
    8b34:	84 01       	movw	r16, r8
    8b36:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <GetTotalizerData>
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    8b3a:	80 e0       	ldi	r24, 0x00	; 0
    8b3c:	60 e0       	ldi	r22, 0x00	; 0
    8b3e:	4a 2d       	mov	r20, r10
    8b40:	2b 2d       	mov	r18, r11
    8b42:	0e 94 a3 44 	call	0x8946	; 0x8946 <SetTotalizerData>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    8b46:	f6 01       	movw	r30, r12
    8b48:	11 92       	st	Z+, r1
    8b4a:	6f 01       	movw	r12, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8b4c:	ee 15       	cp	r30, r14
    8b4e:	ff 05       	cpc	r31, r15
    8b50:	d1 f7       	brne	.-12     	; 0x8b46 <SaveTotalizerCurrentToLast+0x7e>
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    8b52:	81 e0       	ldi	r24, 0x01	; 1
    8b54:	61 e0       	ldi	r22, 0x01	; 1
    8b56:	4a 2d       	mov	r20, r10
    8b58:	2b 2d       	mov	r18, r11
    8b5a:	84 01       	movw	r16, r8
    8b5c:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <GetTotalizerData>
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    8b60:	81 e0       	ldi	r24, 0x01	; 1
    8b62:	60 e0       	ldi	r22, 0x00	; 0
    8b64:	4a 2d       	mov	r20, r10
    8b66:	2b 2d       	mov	r18, r11
    8b68:	0e 94 a3 44 	call	0x8946	; 0x8946 <SetTotalizerData>
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    8b6c:	b3 94       	inc	r11
    8b6e:	f7 e0       	ldi	r31, 0x07	; 7
    8b70:	bf 16       	cp	r11, r31
    8b72:	19 f0       	breq	.+6      	; 0x8b7a <SaveTotalizerCurrentToLast+0xb2>
    8b74:	64 01       	movw	r12, r8
    8b76:	74 01       	movw	r14, r8
    8b78:	d3 cf       	rjmp	.-90     	; 0x8b20 <SaveTotalizerCurrentToLast+0x58>
void SaveTotalizerCurrentToLast(){
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
    8b7a:	73 94       	inc	r7
    8b7c:	81 e1       	ldi	r24, 0x11	; 17
    8b7e:	78 16       	cp	r7, r24
    8b80:	29 f6       	brne	.-118    	; 0x8b0c <SaveTotalizerCurrentToLast+0x44>
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    8b82:	2f 96       	adiw	r28, 0x0f	; 15
    8b84:	0f b6       	in	r0, 0x3f	; 63
    8b86:	f8 94       	cli
    8b88:	de bf       	out	0x3e, r29	; 62
    8b8a:	0f be       	out	0x3f, r0	; 63
    8b8c:	cd bf       	out	0x3d, r28	; 61
    8b8e:	cf 91       	pop	r28
    8b90:	df 91       	pop	r29
    8b92:	1f 91       	pop	r17
    8b94:	0f 91       	pop	r16
    8b96:	ff 90       	pop	r15
    8b98:	ef 90       	pop	r14
    8b9a:	df 90       	pop	r13
    8b9c:	cf 90       	pop	r12
    8b9e:	bf 90       	pop	r11
    8ba0:	af 90       	pop	r10
    8ba2:	9f 90       	pop	r9
    8ba4:	8f 90       	pop	r8
    8ba6:	7f 90       	pop	r7
    8ba8:	5f 90       	pop	r5
    8baa:	4f 90       	pop	r4
    8bac:	08 95       	ret

00008bae <ResetTotalizer>:


//-------------------Totalizer-----------------------------------------
//TAddr{TOTALIZER_LAST,TOTALIZER_NOW}
//TType:{TNONE,TVOLUME,TMONEY};
void ResetTotalizer(char TAddr){//Clear All TotalizerData;
    8bae:	af 92       	push	r10
    8bb0:	bf 92       	push	r11
    8bb2:	cf 92       	push	r12
    8bb4:	df 92       	push	r13
    8bb6:	ef 92       	push	r14
    8bb8:	ff 92       	push	r15
    8bba:	0f 93       	push	r16
    8bbc:	1f 93       	push	r17
    8bbe:	df 93       	push	r29
    8bc0:	cf 93       	push	r28
    8bc2:	cd b7       	in	r28, 0x3d	; 61
    8bc4:	de b7       	in	r29, 0x3e	; 62
    8bc6:	29 97       	sbiw	r28, 0x09	; 9
    8bc8:	0f b6       	in	r0, 0x3f	; 63
    8bca:	f8 94       	cli
    8bcc:	de bf       	out	0x3e, r29	; 62
    8bce:	0f be       	out	0x3f, r0	; 63
    8bd0:	cd bf       	out	0x3d, r28	; 61
    8bd2:	a8 2e       	mov	r10, r24
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
    8bd4:	00 d0       	rcall	.+0      	; 0x8bd6 <ResetTotalizer+0x28>
    8bd6:	00 d0       	rcall	.+0      	; 0x8bd8 <ResetTotalizer+0x2a>
    8bd8:	6e 01       	movw	r12, r28
    8bda:	08 94       	sec
    8bdc:	c1 1c       	adc	r12, r1
    8bde:	d1 1c       	adc	r13, r1
    8be0:	ed b7       	in	r30, 0x3d	; 61
    8be2:	fe b7       	in	r31, 0x3e	; 62
    8be4:	d2 82       	std	Z+2, r13	; 0x02
    8be6:	c1 82       	std	Z+1, r12	; 0x01
    8be8:	8b ee       	ldi	r24, 0xEB	; 235
    8bea:	95 e0       	ldi	r25, 0x05	; 5
    8bec:	94 83       	std	Z+4, r25	; 0x04
    8bee:	83 83       	std	Z+3, r24	; 0x03
    8bf0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    8bf4:	ee 24       	eor	r14, r14
    8bf6:	e3 94       	inc	r14
    8bf8:	0f 90       	pop	r0
    8bfa:	0f 90       	pop	r0
    8bfc:	0f 90       	pop	r0
    8bfe:	0f 90       	pop	r0
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    8c00:	8e 2d       	mov	r24, r14
    8c02:	0e 94 1a 1c 	call	0x3834	; 0x3834 <GetFIPAddr>
		  if (FIPAddr>0){
    8c06:	88 23       	and	r24, r24
    8c08:	a9 f0       	breq	.+42     	; 0x8c34 <ResetTotalizer+0x86>
		      FIPAddr=FIPAddr-1;
    8c0a:	b8 2e       	mov	r11, r24
    8c0c:	ba 94       	dec	r11
    8c0e:	ff 24       	eor	r15, r15
    8c10:	f3 94       	inc	r15
			  for(iGrade=1;iGrade<=6;iGrade++){
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
    8c12:	80 e0       	ldi	r24, 0x00	; 0
    8c14:	6a 2d       	mov	r22, r10
    8c16:	4b 2d       	mov	r20, r11
    8c18:	2f 2d       	mov	r18, r15
    8c1a:	86 01       	movw	r16, r12
    8c1c:	0e 94 a3 44 	call	0x8946	; 0x8946 <SetTotalizerData>
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
    8c20:	81 e0       	ldi	r24, 0x01	; 1
    8c22:	6a 2d       	mov	r22, r10
    8c24:	4b 2d       	mov	r20, r11
    8c26:	2f 2d       	mov	r18, r15
    8c28:	0e 94 a3 44 	call	0x8946	; 0x8946 <SetTotalizerData>
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    8c2c:	f3 94       	inc	r15
    8c2e:	f7 e0       	ldi	r31, 0x07	; 7
    8c30:	ff 16       	cp	r15, r31
    8c32:	79 f7       	brne	.-34     	; 0x8c12 <ResetTotalizer+0x64>
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
    8c34:	e3 94       	inc	r14
    8c36:	81 e1       	ldi	r24, 0x11	; 17
    8c38:	e8 16       	cp	r14, r24
    8c3a:	11 f7       	brne	.-60     	; 0x8c00 <ResetTotalizer+0x52>
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    8c3c:	29 96       	adiw	r28, 0x09	; 9
    8c3e:	0f b6       	in	r0, 0x3f	; 63
    8c40:	f8 94       	cli
    8c42:	de bf       	out	0x3e, r29	; 62
    8c44:	0f be       	out	0x3f, r0	; 63
    8c46:	cd bf       	out	0x3d, r28	; 61
    8c48:	cf 91       	pop	r28
    8c4a:	df 91       	pop	r29
    8c4c:	1f 91       	pop	r17
    8c4e:	0f 91       	pop	r16
    8c50:	ff 90       	pop	r15
    8c52:	ef 90       	pop	r14
    8c54:	df 90       	pop	r13
    8c56:	cf 90       	pop	r12
    8c58:	bf 90       	pop	r11
    8c5a:	af 90       	pop	r10
    8c5c:	08 95       	ret

00008c5e <procMessage21>:
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}

char procMessage21(){
    8c5e:	af 92       	push	r10
    8c60:	bf 92       	push	r11
    8c62:	cf 92       	push	r12
    8c64:	df 92       	push	r13
    8c66:	ef 92       	push	r14
    8c68:	ff 92       	push	r15
    8c6a:	0f 93       	push	r16
    8c6c:	1f 93       	push	r17
    8c6e:	df 93       	push	r29
    8c70:	cf 93       	push	r28
    8c72:	cd b7       	in	r28, 0x3d	; 61
    8c74:	de b7       	in	r29, 0x3e	; 62
    8c76:	2b 97       	sbiw	r28, 0x0b	; 11
    8c78:	0f b6       	in	r0, 0x3f	; 63
    8c7a:	f8 94       	cli
    8c7c:	de bf       	out	0x3e, r29	; 62
    8c7e:	0f be       	out	0x3f, r0	; 63
    8c80:	cd bf       	out	0x3d, r28	; 61
    8c82:	09 e0       	ldi	r16, 0x09	; 9
    8c84:	11 e0       	ldi	r17, 0x01	; 1
    8c86:	3a e6       	ldi	r19, 0x6A	; 106
    8c88:	e3 2e       	mov	r14, r19
    8c8a:	3b e0       	ldi	r19, 0x0B	; 11
    8c8c:	f3 2e       	mov	r15, r19
    8c8e:	6e 01       	movw	r12, r28
    8c90:	08 94       	sec
    8c92:	c1 1c       	adc	r12, r1
    8c94:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8c96:	2b e0       	ldi	r18, 0x0B	; 11
    8c98:	a2 2e       	mov	r10, r18
    8c9a:	b1 2c       	mov	r11, r1
    8c9c:	ac 0e       	add	r10, r28
    8c9e:	bd 1e       	adc	r11, r29
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}

char procMessage21(){
    8ca0:	f6 01       	movw	r30, r12
    8ca2:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8ca4:	8d 91       	ld	r24, X+
    8ca6:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8ca8:	ea 15       	cp	r30, r10
    8caa:	fb 05       	cpc	r31, r11
    8cac:	d9 f7       	brne	.-10     	; 0x8ca4 <procMessage21+0x46>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8cae:	1b 86       	std	Y+11, r1	; 0x0b
    8cb0:	c8 01       	movw	r24, r16
    8cb2:	b6 01       	movw	r22, r12
    8cb4:	4b e0       	ldi	r20, 0x0B	; 11
    8cb6:	50 e0       	ldi	r21, 0x00	; 0
    8cb8:	2d ed       	ldi	r18, 0xDD	; 221
    8cba:	32 e1       	ldi	r19, 0x12	; 18
    8cbc:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    8cc0:	05 5f       	subi	r16, 0xF5	; 245
    8cc2:	1f 4f       	sbci	r17, 0xFF	; 255
    8cc4:	8a e0       	ldi	r24, 0x0A	; 10
    8cc6:	90 e0       	ldi	r25, 0x00	; 0
    8cc8:	e8 0e       	add	r14, r24
    8cca:	f9 1e       	adc	r15, r25
}

char procMessage21(){
     char i,Result,strBankName[11];
	 Result=0;
	 for(i=0;i<4;i++){
    8ccc:	91 e0       	ldi	r25, 0x01	; 1
    8cce:	05 33       	cpi	r16, 0x35	; 53
    8cd0:	19 07       	cpc	r17, r25
    8cd2:	31 f7       	brne	.-52     	; 0x8ca0 <procMessage21+0x42>
         StrPosCopy(rcv_trans,strBankName,(37+(i*10)),10);
		 //Result=((Result<<1)|SaveToEEPROM(strBankName,DefBankName[i],11)); 
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}
    8cd4:	80 e0       	ldi	r24, 0x00	; 0
    8cd6:	2b 96       	adiw	r28, 0x0b	; 11
    8cd8:	0f b6       	in	r0, 0x3f	; 63
    8cda:	f8 94       	cli
    8cdc:	de bf       	out	0x3e, r29	; 62
    8cde:	0f be       	out	0x3f, r0	; 63
    8ce0:	cd bf       	out	0x3d, r28	; 61
    8ce2:	cf 91       	pop	r28
    8ce4:	df 91       	pop	r29
    8ce6:	1f 91       	pop	r17
    8ce8:	0f 91       	pop	r16
    8cea:	ff 90       	pop	r15
    8cec:	ef 90       	pop	r14
    8cee:	df 90       	pop	r13
    8cf0:	cf 90       	pop	r12
    8cf2:	bf 90       	pop	r11
    8cf4:	af 90       	pop	r10
    8cf6:	08 95       	ret

00008cf8 <SaveToEEPROM>:
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}

char SaveToEEPROM(char *Src,char *Dest,unsigned int Length){
    8cf8:	ef 92       	push	r14
    8cfa:	ff 92       	push	r15
    8cfc:	0f 93       	push	r16
    8cfe:	1f 93       	push	r17
    8d00:	df 93       	push	r29
    8d02:	cf 93       	push	r28
    8d04:	cd b7       	in	r28, 0x3d	; 61
    8d06:	de b7       	in	r29, 0x3e	; 62
    8d08:	ac 97       	sbiw	r28, 0x2c	; 44
    8d0a:	0f b6       	in	r0, 0x3f	; 63
    8d0c:	f8 94       	cli
    8d0e:	de bf       	out	0x3e, r29	; 62
    8d10:	0f be       	out	0x3f, r0	; 63
    8d12:	cd bf       	out	0x3d, r28	; 61
    8d14:	9a a7       	std	Y+42, r25	; 0x2a
    8d16:	89 a7       	std	Y+41, r24	; 0x29
    8d18:	7c a7       	std	Y+44, r23	; 0x2c
    8d1a:	6b a7       	std	Y+43, r22	; 0x2b
    8d1c:	7a 01       	movw	r14, r20
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8d1e:	8e 01       	movw	r16, r28
    8d20:	05 5d       	subi	r16, 0xD5	; 213
    8d22:	1f 4f       	sbci	r17, 0xFF	; 255
    8d24:	c8 01       	movw	r24, r16
    8d26:	be 01       	movw	r22, r28
    8d28:	6f 5f       	subi	r22, 0xFF	; 255
    8d2a:	7f 4f       	sbci	r23, 0xFF	; 255
    8d2c:	25 ed       	ldi	r18, 0xD5	; 213
    8d2e:	32 e1       	ldi	r19, 0x12	; 18
    8d30:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8d34:	c8 01       	movw	r24, r16
    8d36:	be 01       	movw	r22, r28
    8d38:	67 5d       	subi	r22, 0xD7	; 215
    8d3a:	7f 4f       	sbci	r23, 0xFF	; 255
    8d3c:	a7 01       	movw	r20, r14
    8d3e:	2d ed       	ldi	r18, 0xDD	; 221
    8d40:	32 e1       	ldi	r19, 0x12	; 18
    8d42:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
     char strCompare[40];
	 //Read Previous Data
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}
    8d46:	ac 96       	adiw	r28, 0x2c	; 44
    8d48:	0f b6       	in	r0, 0x3f	; 63
    8d4a:	f8 94       	cli
    8d4c:	de bf       	out	0x3e, r29	; 62
    8d4e:	0f be       	out	0x3f, r0	; 63
    8d50:	cd bf       	out	0x3d, r28	; 61
    8d52:	cf 91       	pop	r28
    8d54:	df 91       	pop	r29
    8d56:	1f 91       	pop	r17
    8d58:	0f 91       	pop	r16
    8d5a:	ff 90       	pop	r15
    8d5c:	ef 90       	pop	r14
    8d5e:	08 95       	ret

00008d60 <_menu_pumpprodinput>:
//**********************************************************************
// subrutin merubah produk
// parameter di simpan di __pump_prod
//**********************************************************************

void _menu_pumpprodinput(unsigned char __select){
    8d60:	8f 92       	push	r8
    8d62:	9f 92       	push	r9
    8d64:	af 92       	push	r10
    8d66:	bf 92       	push	r11
    8d68:	cf 92       	push	r12
    8d6a:	df 92       	push	r13
    8d6c:	ef 92       	push	r14
    8d6e:	ff 92       	push	r15
    8d70:	0f 93       	push	r16
    8d72:	1f 93       	push	r17
    8d74:	df 93       	push	r29
    8d76:	cf 93       	push	r28
    8d78:	cd b7       	in	r28, 0x3d	; 61
    8d7a:	de b7       	in	r29, 0x3e	; 62
    8d7c:	a7 97       	sbiw	r28, 0x27	; 39
    8d7e:	0f b6       	in	r0, 0x3f	; 63
    8d80:	f8 94       	cli
    8d82:	de bf       	out	0x3e, r29	; 62
    8d84:	0f be       	out	0x3f, r0	; 63
    8d86:	cd bf       	out	0x3d, r28	; 61
    8d88:	b8 2e       	mov	r11, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8d8a:	8e 01       	movw	r16, r28
    8d8c:	04 5f       	subi	r16, 0xF4	; 244
    8d8e:	1f 4f       	sbci	r17, 0xFF	; 255
    8d90:	c8 01       	movw	r24, r16
    8d92:	65 e4       	ldi	r22, 0x45	; 69
    8d94:	70 e0       	ldi	r23, 0x00	; 0
    8d96:	48 e0       	ldi	r20, 0x08	; 8
    8d98:	50 e0       	ldi	r21, 0x00	; 0
    8d9a:	25 ed       	ldi	r18, 0xD5	; 213
    8d9c:	32 e1       	ldi	r19, 0x12	; 18
    8d9e:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
	char 			__pump_prod[6],__pump_id[8];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];

	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	eeprom_read_block((void*) &__pump_prod, (const void*) &DefNozzleMap[__select], 6);
    8da2:	86 e0       	ldi	r24, 0x06	; 6
    8da4:	b8 9e       	mul	r11, r24
    8da6:	40 01       	movw	r8, r0
    8da8:	11 24       	eor	r1, r1
    8daa:	85 e5       	ldi	r24, 0x55	; 85
    8dac:	90 e0       	ldi	r25, 0x00	; 0
    8dae:	88 0e       	add	r8, r24
    8db0:	99 1e       	adc	r9, r25
    8db2:	e6 e0       	ldi	r30, 0x06	; 6
    8db4:	ce 2e       	mov	r12, r30
    8db6:	d1 2c       	mov	r13, r1
    8db8:	cc 0e       	add	r12, r28
    8dba:	dd 1e       	adc	r13, r29
    8dbc:	c6 01       	movw	r24, r12
    8dbe:	b4 01       	movw	r22, r8
    8dc0:	46 e0       	ldi	r20, 0x06	; 6
    8dc2:	50 e0       	ldi	r21, 0x00	; 0
    8dc4:	25 ed       	ldi	r18, 0xD5	; 213
    8dc6:	32 e1       	ldi	r19, 0x12	; 18
    8dc8:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>

	lcd_clear();_delay_ms(10);
    8dcc:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
    8dd0:	84 ec       	ldi	r24, 0xC4	; 196
    8dd2:	99 e0       	ldi	r25, 0x09	; 9
    8dd4:	01 97       	sbiw	r24, 0x01	; 1
    8dd6:	f1 f7       	brne	.-4      	; 0x8dd4 <_menu_pumpprodinput+0x74>
    sprintf_P(lcdteks, PSTR("Product FIP%.2d"),__pump_id[__select]);
    8dd8:	00 d0       	rcall	.+0      	; 0x8dda <_menu_pumpprodinput+0x7a>
    8dda:	00 d0       	rcall	.+0      	; 0x8ddc <_menu_pumpprodinput+0x7c>
    8ddc:	00 d0       	rcall	.+0      	; 0x8dde <_menu_pumpprodinput+0x7e>
    8dde:	ed b7       	in	r30, 0x3d	; 61
    8de0:	fe b7       	in	r31, 0x3e	; 62
    8de2:	31 96       	adiw	r30, 0x01	; 1
    8de4:	74 e1       	ldi	r23, 0x14	; 20
    8de6:	e7 2e       	mov	r14, r23
    8de8:	f1 2c       	mov	r15, r1
    8dea:	ec 0e       	add	r14, r28
    8dec:	fd 1e       	adc	r15, r29
    8dee:	ad b7       	in	r26, 0x3d	; 61
    8df0:	be b7       	in	r27, 0x3e	; 62
    8df2:	12 96       	adiw	r26, 0x02	; 2
    8df4:	fc 92       	st	X, r15
    8df6:	ee 92       	st	-X, r14
    8df8:	11 97       	sbiw	r26, 0x01	; 1
    8dfa:	81 ef       	ldi	r24, 0xF1	; 241
    8dfc:	9b e0       	ldi	r25, 0x0B	; 11
    8dfe:	93 83       	std	Z+3, r25	; 0x03
    8e00:	82 83       	std	Z+2, r24	; 0x02
    8e02:	0b 0d       	add	r16, r11
    8e04:	11 1d       	adc	r17, r1
    8e06:	d8 01       	movw	r26, r16
    8e08:	8c 91       	ld	r24, X
    8e0a:	84 83       	std	Z+4, r24	; 0x04
    8e0c:	15 82       	std	Z+5, r1	; 0x05
    8e0e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    lcd_print(1, 1,lcdteks);
    8e12:	ed b7       	in	r30, 0x3d	; 61
    8e14:	fe b7       	in	r31, 0x3e	; 62
    8e16:	36 96       	adiw	r30, 0x06	; 6
    8e18:	0f b6       	in	r0, 0x3f	; 63
    8e1a:	f8 94       	cli
    8e1c:	fe bf       	out	0x3e, r31	; 62
    8e1e:	0f be       	out	0x3f, r0	; 63
    8e20:	ed bf       	out	0x3d, r30	; 61
    8e22:	81 e0       	ldi	r24, 0x01	; 1
    8e24:	61 e0       	ldi	r22, 0x01	; 1
    8e26:	a7 01       	movw	r20, r14
    8e28:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
    8e2c:	82 e0       	ldi	r24, 0x02	; 2
    8e2e:	61 e0       	ldi	r22, 0x01	; 1
    8e30:	4d ed       	ldi	r20, 0xDD	; 221
    8e32:	5b e0       	ldi	r21, 0x0B	; 11
    8e34:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
    8e38:	83 e0       	ldi	r24, 0x03	; 3
    8e3a:	61 e0       	ldi	r22, 0x01	; 1
    8e3c:	49 ec       	ldi	r20, 0xC9	; 201
    8e3e:	5b e0       	ldi	r21, 0x0B	; 11
    8e40:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));
    8e44:	84 e0       	ldi	r24, 0x04	; 4
    8e46:	61 e0       	ldi	r22, 0x01	; 1
    8e48:	44 eb       	ldi	r20, 0xB4	; 180
    8e4a:	5b e0       	ldi	r21, 0x0B	; 11
    8e4c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
    8e50:	64 ed       	ldi	r22, 0xD4	; 212
    8e52:	e6 2e       	mov	r14, r22
    8e54:	62 e0       	ldi	r22, 0x02	; 2
    8e56:	f6 2e       	mov	r15, r22

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prodloc[__i][0]);
		__y = pgm_read_byte(&__prodloc[__i][1]);
		_f_inttostr(__buff, __pump_prod[__i]);
    8e58:	5e 01       	movw	r10, r28
    8e5a:	08 94       	sec
    8e5c:	a1 1c       	adc	r10, r1
    8e5e:	b1 1c       	adc	r11, r1
	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prodloc[__i][0]);
    8e60:	f7 01       	movw	r30, r14
    8e62:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__prodloc[__i][1]);
    8e64:	08 94       	sec
    8e66:	e1 1c       	adc	r14, r1
    8e68:	f1 1c       	adc	r15, r1
    8e6a:	f7 01       	movw	r30, r14
    8e6c:	14 91       	lpm	r17, Z+
		_f_inttostr(__buff, __pump_prod[__i]);
    8e6e:	d6 01       	movw	r26, r12
    8e70:	4d 91       	ld	r20, X+
    8e72:	6d 01       	movw	r12, r26
    8e74:	50 e0       	ldi	r21, 0x00	; 0
    8e76:	60 e0       	ldi	r22, 0x00	; 0
    8e78:	70 e0       	ldi	r23, 0x00	; 0
    8e7a:	c5 01       	movw	r24, r10
    8e7c:	0e 94 44 19 	call	0x3288	; 0x3288 <_f_inttostr>
		lcd_print(__x+1, __y, __buff);
    8e80:	80 2f       	mov	r24, r16
    8e82:	8f 5f       	subi	r24, 0xFF	; 255
    8e84:	61 2f       	mov	r22, r17
    8e86:	a5 01       	movw	r20, r10
    8e88:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    8e8c:	08 94       	sec
    8e8e:	e1 1c       	adc	r14, r1
    8e90:	f1 1c       	adc	r15, r1

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(__i = 0; __i < 6; __i++){
    8e92:	b0 ee       	ldi	r27, 0xE0	; 224
    8e94:	eb 16       	cp	r14, r27
    8e96:	b2 e0       	ldi	r27, 0x02	; 2
    8e98:	fb 06       	cpc	r15, r27
    8e9a:	11 f7       	brne	.-60     	; 0x8e60 <_menu_pumpprodinput+0x100>
		if(__key == _KEY_ENTER){
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
			if(__pump_prod[__num - '1'] == 6)
    8e9c:	56 e0       	ldi	r21, 0x06	; 6
    8e9e:	c5 2e       	mov	r12, r21
    8ea0:	d1 2c       	mov	r13, r1
    8ea2:	cc 0e       	add	r12, r28
    8ea4:	dd 1e       	adc	r13, r29
			else
				__pump_prod[__num - '1']++;

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
			_f_inttostr(__buff, __pump_prod[__num - 0x31]);
    8ea6:	7e 01       	movw	r14, r28
    8ea8:	08 94       	sec
    8eaa:	e1 1c       	adc	r14, r1
    8eac:	f1 1c       	adc	r15, r1
		lcd_print(__x+1, __y, __buff);
	}

	while(1){
		
		__key = _key_scan(1);
    8eae:	81 e0       	ldi	r24, 0x01	; 1
    8eb0:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    8eb4:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    8eb6:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
    8eba:	98 2f       	mov	r25, r24
		if(__key == _KEY_CANCEL)
    8ebc:	17 3e       	cpi	r17, 0xE7	; 231
    8ebe:	09 f4       	brne	.+2      	; 0x8ec2 <_menu_pumpprodinput+0x162>
    8ec0:	3c c0       	rjmp	.+120    	; 0x8f3a <_menu_pumpprodinput+0x1da>
			return;
		if(__key == _KEY_ENTER){
    8ec2:	17 3b       	cpi	r17, 0xB7	; 183
    8ec4:	59 f4       	brne	.+22     	; 0x8edc <_menu_pumpprodinput+0x17c>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8ec6:	c4 01       	movw	r24, r8
    8ec8:	be 01       	movw	r22, r28
    8eca:	6a 5f       	subi	r22, 0xFA	; 250
    8ecc:	7f 4f       	sbci	r23, 0xFF	; 255
    8ece:	46 e0       	ldi	r20, 0x06	; 6
    8ed0:	50 e0       	ldi	r21, 0x00	; 0
    8ed2:	2d ed       	ldi	r18, 0xDD	; 221
    8ed4:	32 e1       	ldi	r19, 0x12	; 18
    8ed6:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    8eda:	2f c0       	rjmp	.+94     	; 0x8f3a <_menu_pumpprodinput+0x1da>
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
    8edc:	81 53       	subi	r24, 0x31	; 49
    8ede:	86 30       	cpi	r24, 0x06	; 6
    8ee0:	30 f7       	brcc	.-52     	; 0x8eae <_menu_pumpprodinput+0x14e>
			if(__pump_prod[__num - '1'] == 6)
    8ee2:	a9 2f       	mov	r26, r25
    8ee4:	b0 e0       	ldi	r27, 0x00	; 0
    8ee6:	d1 97       	sbiw	r26, 0x31	; 49
    8ee8:	f6 01       	movw	r30, r12
    8eea:	ea 0f       	add	r30, r26
    8eec:	fb 1f       	adc	r31, r27
    8eee:	80 81       	ld	r24, Z
    8ef0:	86 30       	cpi	r24, 0x06	; 6
    8ef2:	11 f4       	brne	.+4      	; 0x8ef8 <_menu_pumpprodinput+0x198>
				__pump_prod[__num - '1'] = 0;
    8ef4:	10 82       	st	Z, r1
    8ef6:	02 c0       	rjmp	.+4      	; 0x8efc <_menu_pumpprodinput+0x19c>
			else
				__pump_prod[__num - '1']++;
    8ef8:	8f 5f       	subi	r24, 0xFF	; 255
    8efa:	80 83       	st	Z, r24

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
    8efc:	29 2f       	mov	r18, r25
    8efe:	30 e0       	ldi	r19, 0x00	; 0
    8f00:	21 53       	subi	r18, 0x31	; 49
    8f02:	30 40       	sbci	r19, 0x00	; 0
    8f04:	22 0f       	add	r18, r18
    8f06:	33 1f       	adc	r19, r19
    8f08:	c9 01       	movw	r24, r18
    8f0a:	8c 52       	subi	r24, 0x2C	; 44
    8f0c:	9d 4f       	sbci	r25, 0xFD	; 253
    8f0e:	fc 01       	movw	r30, r24
    8f10:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
    8f12:	2b 52       	subi	r18, 0x2B	; 43
    8f14:	3d 4f       	sbci	r19, 0xFD	; 253
    8f16:	f9 01       	movw	r30, r18
    8f18:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __pump_prod[__num - 0x31]);
    8f1a:	ac 0d       	add	r26, r12
    8f1c:	bd 1d       	adc	r27, r13
    8f1e:	4c 91       	ld	r20, X
    8f20:	50 e0       	ldi	r21, 0x00	; 0
    8f22:	60 e0       	ldi	r22, 0x00	; 0
    8f24:	70 e0       	ldi	r23, 0x00	; 0
    8f26:	c7 01       	movw	r24, r14
    8f28:	0e 94 44 19 	call	0x3288	; 0x3288 <_f_inttostr>
			lcd_print(__x+1, __y, __buff);
    8f2c:	80 2f       	mov	r24, r16
    8f2e:	8f 5f       	subi	r24, 0xFF	; 255
    8f30:	61 2f       	mov	r22, r17
    8f32:	a7 01       	movw	r20, r14
    8f34:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    8f38:	ba cf       	rjmp	.-140    	; 0x8eae <_menu_pumpprodinput+0x14e>
		}
	}
}
    8f3a:	a7 96       	adiw	r28, 0x27	; 39
    8f3c:	0f b6       	in	r0, 0x3f	; 63
    8f3e:	f8 94       	cli
    8f40:	de bf       	out	0x3e, r29	; 62
    8f42:	0f be       	out	0x3f, r0	; 63
    8f44:	cd bf       	out	0x3d, r28	; 61
    8f46:	cf 91       	pop	r28
    8f48:	df 91       	pop	r29
    8f4a:	1f 91       	pop	r17
    8f4c:	0f 91       	pop	r16
    8f4e:	ff 90       	pop	r15
    8f50:	ef 90       	pop	r14
    8f52:	df 90       	pop	r13
    8f54:	cf 90       	pop	r12
    8f56:	bf 90       	pop	r11
    8f58:	af 90       	pop	r10
    8f5a:	9f 90       	pop	r9
    8f5c:	8f 90       	pop	r8
    8f5e:	08 95       	ret

00008f60 <_menu_pumpprod>:
	       break;
	   }	   
	}
}

void _menu_pumpprod(void){
    8f60:	cf 93       	push	r28
    8f62:	df 93       	push	r29
    8f64:	c4 ec       	ldi	r28, 0xC4	; 196
    8f66:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;
	//char __pump_id[8];
	while(1){
		lcd_clear();_delay_ms(10);
    8f68:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
    8f6c:	ce 01       	movw	r24, r28
    8f6e:	01 97       	sbiw	r24, 0x01	; 1
    8f70:	f1 f7       	brne	.-4      	; 0x8f6e <_menu_pumpprod+0xe>
		_scr_pump();
    8f72:	0e 94 58 42 	call	0x84b0	; 0x84b0 <_scr_pump>
		while(1){
			__key = _key_scan(1);
    8f76:	81 e0       	ldi	r24, 0x01	; 1
    8f78:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
			if( __key == _KEY_1 || __key == _KEY_2 || __key == _KEY_3 ||
    8f7c:	8e 3e       	cpi	r24, 0xEE	; 238
    8f7e:	71 f0       	breq	.+28     	; 0x8f9c <_menu_pumpprod+0x3c>
    8f80:	8e 3d       	cpi	r24, 0xDE	; 222
    8f82:	61 f0       	breq	.+24     	; 0x8f9c <_menu_pumpprod+0x3c>
    8f84:	8e 3b       	cpi	r24, 0xBE	; 190
    8f86:	51 f0       	breq	.+20     	; 0x8f9c <_menu_pumpprod+0x3c>
    8f88:	8d 3e       	cpi	r24, 0xED	; 237
    8f8a:	41 f0       	breq	.+16     	; 0x8f9c <_menu_pumpprod+0x3c>
    8f8c:	8d 3d       	cpi	r24, 0xDD	; 221
    8f8e:	31 f0       	breq	.+12     	; 0x8f9c <_menu_pumpprod+0x3c>
    8f90:	8d 3b       	cpi	r24, 0xBD	; 189
    8f92:	21 f0       	breq	.+8      	; 0x8f9c <_menu_pumpprod+0x3c>
    8f94:	8b 3e       	cpi	r24, 0xEB	; 235
    8f96:	11 f0       	breq	.+4      	; 0x8f9c <_menu_pumpprod+0x3c>
    8f98:	8b 3d       	cpi	r24, 0xDB	; 219
    8f9a:	31 f4       	brne	.+12     	; 0x8fa8 <_menu_pumpprod+0x48>
				__key == _KEY_4 || __key == _KEY_5 || __key == _KEY_6 ||
				__key == _KEY_7 || __key == _KEY_8){
				_menu_pumpprodinput(_key_btn(__key) - 0x31);
    8f9c:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
    8fa0:	81 53       	subi	r24, 0x31	; 49
    8fa2:	0e 94 b0 46 	call	0x8d60	; 0x8d60 <_menu_pumpprodinput>
    8fa6:	e0 cf       	rjmp	.-64     	; 0x8f68 <_menu_pumpprod+0x8>
				break;
			}
			if(__key == _KEY_CANCEL)
    8fa8:	87 3e       	cpi	r24, 0xE7	; 231
    8faa:	29 f7       	brne	.-54     	; 0x8f76 <_menu_pumpprod+0x16>
				return;
		}
	}
}
    8fac:	df 91       	pop	r29
    8fae:	cf 91       	pop	r28
    8fb0:	08 95       	ret

00008fb2 <FMenuPumpLabel>:
		       break;		         
	      }
	 }     
}

void FMenuPumpLabel(){
    8fb2:	6f 92       	push	r6
    8fb4:	7f 92       	push	r7
    8fb6:	8f 92       	push	r8
    8fb8:	9f 92       	push	r9
    8fba:	af 92       	push	r10
    8fbc:	bf 92       	push	r11
    8fbe:	cf 92       	push	r12
    8fc0:	df 92       	push	r13
    8fc2:	ef 92       	push	r14
    8fc4:	ff 92       	push	r15
    8fc6:	1f 93       	push	r17
    8fc8:	df 93       	push	r29
    8fca:	cf 93       	push	r28
    8fcc:	cd b7       	in	r28, 0x3d	; 61
    8fce:	de b7       	in	r29, 0x3e	; 62
    8fd0:	2d 97       	sbiw	r28, 0x0d	; 13
    8fd2:	0f b6       	in	r0, 0x3f	; 63
    8fd4:	f8 94       	cli
    8fd6:	de bf       	out	0x3e, r29	; 62
    8fd8:	0f be       	out	0x3f, r0	; 63
    8fda:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8fdc:	86 e0       	ldi	r24, 0x06	; 6
    8fde:	c8 2e       	mov	r12, r24
    8fe0:	d1 2c       	mov	r13, r1
    8fe2:	cc 0e       	add	r12, r28
    8fe4:	dd 1e       	adc	r13, r29
    8fe6:	c6 01       	movw	r24, r12
    8fe8:	6d e4       	ldi	r22, 0x4D	; 77
    8fea:	70 e0       	ldi	r23, 0x00	; 0
    8fec:	48 e0       	ldi	r20, 0x08	; 8
    8fee:	50 e0       	ldi	r21, 0x00	; 0
    8ff0:	25 ed       	ldi	r18, 0xD5	; 213
    8ff2:	32 e1       	ldi	r19, 0x12	; 18
    8ff4:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
	char PPumpLabel[8];
	unsigned char i, xPos,yPos,KeyPressed,KeyChar,strLabel[5];
	static char MaxCountId=16;

	eeprom_read_block((void*) &PPumpLabel, (const void*) &DefPumpLabel, 8);
	MaxCountId=99;
    8ff8:	83 e6       	ldi	r24, 0x63	; 99
    8ffa:	80 93 56 01 	sts	0x0156, r24
	lcd_clear();_delay_ms(10);
    8ffe:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
    9002:	84 ec       	ldi	r24, 0xC4	; 196
    9004:	99 e0       	ldi	r25, 0x09	; 9
    9006:	01 97       	sbiw	r24, 0x01	; 1
    9008:	f1 f7       	brne	.-4      	; 0x9006 <FMenuPumpLabel+0x54>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
    900a:	81 e0       	ldi	r24, 0x01	; 1
    900c:	61 e0       	ldi	r22, 0x01	; 1
    900e:	4c ee       	ldi	r20, 0xEC	; 236
    9010:	5c e0       	ldi	r21, 0x0C	; 12
    9012:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
    9016:	82 e0       	ldi	r24, 0x02	; 2
    9018:	61 e0       	ldi	r22, 0x01	; 1
    901a:	40 ee       	ldi	r20, 0xE0	; 224
    901c:	5c e0       	ldi	r21, 0x0C	; 12
    901e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
    9022:	83 e0       	ldi	r24, 0x03	; 3
    9024:	61 e0       	ldi	r22, 0x01	; 1
    9026:	4b ec       	ldi	r20, 0xCB	; 203
    9028:	5c e0       	ldi	r21, 0x0C	; 12
    902a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    902e:	84 e0       	ldi	r24, 0x04	; 4
    9030:	61 e0       	ldi	r22, 0x01	; 1
    9032:	46 eb       	ldi	r20, 0xB6	; 182
    9034:	5c e0       	ldi	r21, 0x0C	; 12
    9036:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
    903a:	76 01       	movw	r14, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    903c:	5e 01       	movw	r10, r28
    903e:	08 94       	sec
    9040:	a1 1c       	adc	r10, r1
    9042:	b1 1c       	adc	r11, r1
    9044:	11 eb       	ldi	r17, 0xB1	; 177
    9046:	61 2e       	mov	r6, r17
    9048:	1c e0       	ldi	r17, 0x0C	; 12
    904a:	71 2e       	mov	r7, r17
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    904c:	be e0       	ldi	r27, 0x0E	; 14
    904e:	8b 2e       	mov	r8, r27
    9050:	91 2c       	mov	r9, r1
    9052:	8c 0e       	add	r8, r28
    9054:	9d 1e       	adc	r9, r29
	MaxCountId=99;
	lcd_clear();_delay_ms(10);
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    9056:	1e 2d       	mov	r17, r14
    9058:	1c 19       	sub	r17, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    905a:	00 d0       	rcall	.+0      	; 0x905c <FMenuPumpLabel+0xaa>
    905c:	00 d0       	rcall	.+0      	; 0x905e <FMenuPumpLabel+0xac>
    905e:	00 d0       	rcall	.+0      	; 0x9060 <FMenuPumpLabel+0xae>
    9060:	ed b7       	in	r30, 0x3d	; 61
    9062:	fe b7       	in	r31, 0x3e	; 62
    9064:	31 96       	adiw	r30, 0x01	; 1
    9066:	ad b7       	in	r26, 0x3d	; 61
    9068:	be b7       	in	r27, 0x3e	; 62
    906a:	12 96       	adiw	r26, 0x02	; 2
    906c:	bc 92       	st	X, r11
    906e:	ae 92       	st	-X, r10
    9070:	11 97       	sbiw	r26, 0x01	; 1
    9072:	73 82       	std	Z+3, r7	; 0x03
    9074:	62 82       	std	Z+2, r6	; 0x02
    9076:	d7 01       	movw	r26, r14
    9078:	8d 91       	ld	r24, X+
    907a:	7d 01       	movw	r14, r26
    907c:	84 83       	std	Z+4, r24	; 0x04
    907e:	15 82       	std	Z+5, r1	; 0x05
    9080:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		xPos=1+(i%4);
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
    9084:	ed b7       	in	r30, 0x3d	; 61
    9086:	fe b7       	in	r31, 0x3e	; 62
    9088:	36 96       	adiw	r30, 0x06	; 6
    908a:	0f b6       	in	r0, 0x3f	; 63
    908c:	f8 94       	cli
    908e:	fe bf       	out	0x3e, r31	; 62
    9090:	0f be       	out	0x3f, r0	; 63
    9092:	ed bf       	out	0x3d, r30	; 61
    9094:	61 2f       	mov	r22, r17
    9096:	66 95       	lsr	r22
    9098:	66 95       	lsr	r22
    909a:	66 0f       	add	r22, r22
    909c:	66 0f       	add	r22, r22
    909e:	66 0f       	add	r22, r22
    90a0:	6b 5f       	subi	r22, 0xFB	; 251
    90a2:	13 70       	andi	r17, 0x03	; 3
    90a4:	81 2f       	mov	r24, r17
    90a6:	8f 5f       	subi	r24, 0xFF	; 255
    90a8:	a5 01       	movw	r20, r10
    90aa:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    90ae:	e8 14       	cp	r14, r8
    90b0:	f9 04       	cpc	r15, r9
    90b2:	89 f6       	brne	.-94     	; 0x9056 <FMenuPumpLabel+0xa4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    90b4:	a6 e0       	ldi	r26, 0x06	; 6
    90b6:	ca 2e       	mov	r12, r26
    90b8:	d1 2c       	mov	r13, r1
    90ba:	cc 0e       	add	r12, r28
    90bc:	dd 1e       	adc	r13, r29
			   PPumpLabel[i] = 0;
			else
			   PPumpLabel[i]++;
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    90be:	7e 01       	movw	r14, r28
    90c0:	08 94       	sec
    90c2:	e1 1c       	adc	r14, r1
    90c4:	f1 1c       	adc	r15, r1
    90c6:	fc ea       	ldi	r31, 0xAC	; 172
    90c8:	af 2e       	mov	r10, r31
    90ca:	fc e0       	ldi	r31, 0x0C	; 12
    90cc:	bf 2e       	mov	r11, r31
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
	}

	while(1){
		KeyPressed = _key_scan(1);
    90ce:	81 e0       	ldi	r24, 0x01	; 1
    90d0:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    90d4:	18 2f       	mov	r17, r24
		KeyChar    = _key_btn(KeyPressed);
    90d6:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
		if(KeyPressed == _KEY_CANCEL)break;
    90da:	17 3e       	cpi	r17, 0xE7	; 231
    90dc:	09 f4       	brne	.+2      	; 0x90e0 <FMenuPumpLabel+0x12e>
    90de:	4b c0       	rjmp	.+150    	; 0x9176 <FMenuPumpLabel+0x1c4>
		else
		if(KeyPressed == _KEY_ENTER){
    90e0:	17 3b       	cpi	r17, 0xB7	; 183
    90e2:	61 f4       	brne	.+24     	; 0x90fc <FMenuPumpLabel+0x14a>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    90e4:	8d e4       	ldi	r24, 0x4D	; 77
    90e6:	90 e0       	ldi	r25, 0x00	; 0
    90e8:	be 01       	movw	r22, r28
    90ea:	6a 5f       	subi	r22, 0xFA	; 250
    90ec:	7f 4f       	sbci	r23, 0xFF	; 255
    90ee:	48 e0       	ldi	r20, 0x08	; 8
    90f0:	50 e0       	ldi	r21, 0x00	; 0
    90f2:	2d ed       	ldi	r18, 0xDD	; 221
    90f4:	32 e1       	ldi	r19, 0x12	; 18
    90f6:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    90fa:	3d c0       	rjmp	.+122    	; 0x9176 <FMenuPumpLabel+0x1c4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
    90fc:	18 2f       	mov	r17, r24
    90fe:	11 53       	subi	r17, 0x31	; 49
    9100:	18 30       	cpi	r17, 0x08	; 8
    9102:	28 f7       	brcc	.-54     	; 0x90ce <FMenuPumpLabel+0x11c>
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    9104:	a1 2f       	mov	r26, r17
    9106:	b0 e0       	ldi	r27, 0x00	; 0
    9108:	f6 01       	movw	r30, r12
    910a:	ea 0f       	add	r30, r26
    910c:	fb 1f       	adc	r31, r27
    910e:	90 81       	ld	r25, Z
    9110:	80 91 56 01 	lds	r24, 0x0156
    9114:	98 17       	cp	r25, r24
    9116:	11 f4       	brne	.+4      	; 0x911c <FMenuPumpLabel+0x16a>
			   PPumpLabel[i] = 0;
    9118:	10 82       	st	Z, r1
    911a:	02 c0       	rjmp	.+4      	; 0x9120 <FMenuPumpLabel+0x16e>
			else
			   PPumpLabel[i]++;
    911c:	9f 5f       	subi	r25, 0xFF	; 255
    911e:	90 83       	st	Z, r25
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    9120:	00 d0       	rcall	.+0      	; 0x9122 <FMenuPumpLabel+0x170>
    9122:	00 d0       	rcall	.+0      	; 0x9124 <FMenuPumpLabel+0x172>
    9124:	00 d0       	rcall	.+0      	; 0x9126 <FMenuPumpLabel+0x174>
    9126:	2d b7       	in	r18, 0x3d	; 61
    9128:	3e b7       	in	r19, 0x3e	; 62
    912a:	2f 5f       	subi	r18, 0xFF	; 255
    912c:	3f 4f       	sbci	r19, 0xFF	; 255
    912e:	ed b7       	in	r30, 0x3d	; 61
    9130:	fe b7       	in	r31, 0x3e	; 62
    9132:	f2 82       	std	Z+2, r15	; 0x02
    9134:	e1 82       	std	Z+1, r14	; 0x01
    9136:	f9 01       	movw	r30, r18
    9138:	b3 82       	std	Z+3, r11	; 0x03
    913a:	a2 82       	std	Z+2, r10	; 0x02
    913c:	ac 0d       	add	r26, r12
    913e:	bd 1d       	adc	r27, r13
    9140:	8c 91       	ld	r24, X
    9142:	84 83       	std	Z+4, r24	; 0x04
    9144:	15 82       	std	Z+5, r1	; 0x05
    9146:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
            lcd_print(xPos,yPos,strLabel);
    914a:	8d b7       	in	r24, 0x3d	; 61
    914c:	9e b7       	in	r25, 0x3e	; 62
    914e:	06 96       	adiw	r24, 0x06	; 6
    9150:	0f b6       	in	r0, 0x3f	; 63
    9152:	f8 94       	cli
    9154:	9e bf       	out	0x3e, r25	; 62
    9156:	0f be       	out	0x3f, r0	; 63
    9158:	8d bf       	out	0x3d, r24	; 61
    915a:	61 2f       	mov	r22, r17
    915c:	66 95       	lsr	r22
    915e:	66 95       	lsr	r22
    9160:	66 0f       	add	r22, r22
    9162:	66 0f       	add	r22, r22
    9164:	66 0f       	add	r22, r22
    9166:	6b 5f       	subi	r22, 0xFB	; 251
    9168:	13 70       	andi	r17, 0x03	; 3
    916a:	81 2f       	mov	r24, r17
    916c:	8f 5f       	subi	r24, 0xFF	; 255
    916e:	a7 01       	movw	r20, r14
    9170:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    9174:	ac cf       	rjmp	.-168    	; 0x90ce <FMenuPumpLabel+0x11c>
		}
	}
}
    9176:	2d 96       	adiw	r28, 0x0d	; 13
    9178:	0f b6       	in	r0, 0x3f	; 63
    917a:	f8 94       	cli
    917c:	de bf       	out	0x3e, r29	; 62
    917e:	0f be       	out	0x3f, r0	; 63
    9180:	cd bf       	out	0x3d, r28	; 61
    9182:	cf 91       	pop	r28
    9184:	df 91       	pop	r29
    9186:	1f 91       	pop	r17
    9188:	ff 90       	pop	r15
    918a:	ef 90       	pop	r14
    918c:	df 90       	pop	r13
    918e:	cf 90       	pop	r12
    9190:	bf 90       	pop	r11
    9192:	af 90       	pop	r10
    9194:	9f 90       	pop	r9
    9196:	8f 90       	pop	r8
    9198:	7f 90       	pop	r7
    919a:	6f 90       	pop	r6
    919c:	08 95       	ret

0000919e <GenerateTransactionNum>:
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    919e:	cf 92       	push	r12
    91a0:	df 92       	push	r13
    91a2:	ef 92       	push	r14
    91a4:	ff 92       	push	r15
    91a6:	0f 93       	push	r16
    91a8:	1f 93       	push	r17
    91aa:	df 93       	push	r29
    91ac:	cf 93       	push	r28
    91ae:	cd b7       	in	r28, 0x3d	; 61
    91b0:	de b7       	in	r29, 0x3e	; 62
    91b2:	27 97       	sbiw	r28, 0x07	; 7
    91b4:	0f b6       	in	r0, 0x3f	; 63
    91b6:	f8 94       	cli
    91b8:	de bf       	out	0x3e, r29	; 62
    91ba:	0f be       	out	0x3f, r0	; 63
    91bc:	cd bf       	out	0x3d, r28	; 61
    91be:	6c 01       	movw	r12, r24
    91c0:	fe 01       	movw	r30, r28
    91c2:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    91c4:	ce 01       	movw	r24, r28
    91c6:	08 96       	adiw	r24, 0x08	; 8
	     strMemory[i]=data;
    91c8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    91ca:	e8 17       	cp	r30, r24
    91cc:	f9 07       	cpc	r31, r25
    91ce:	e1 f7       	brne	.-8      	; 0x91c8 <GenerateTransactionNum+0x2a>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    91d0:	8e 01       	movw	r16, r28
    91d2:	0f 5f       	subi	r16, 0xFF	; 255
    91d4:	1f 4f       	sbci	r17, 0xFF	; 255
    91d6:	c8 01       	movw	r24, r16
    91d8:	68 e3       	ldi	r22, 0x38	; 56
    91da:	71 e0       	ldi	r23, 0x01	; 1
    91dc:	47 e0       	ldi	r20, 0x07	; 7
    91de:	50 e0       	ldi	r21, 0x00	; 0
    91e0:	25 ed       	ldi	r18, 0xD5	; 213
    91e2:	32 e1       	ldi	r19, 0x12	; 18
    91e4:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
     char i,PTransNum[7],cNum,xNum=0,xAdd=0,Length=0;
	 FillChar(PTransNum,sizeof(PTransNum),0);//"999999"->"000000"
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);
    91e8:	f8 01       	movw	r30, r16
    91ea:	01 90       	ld	r0, Z+
    91ec:	00 20       	and	r0, r0
    91ee:	e9 f7       	brne	.-6      	; 0x91ea <GenerateTransactionNum+0x4c>
    91f0:	31 97       	sbiw	r30, 0x01	; 1
    91f2:	e0 1b       	sub	r30, r16
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    91f4:	f0 e0       	ldi	r31, 0x00	; 0
    91f6:	0e 0f       	add	r16, r30
    91f8:	1f 1f       	adc	r17, r31
    91fa:	31 97       	sbiw	r30, 0x01	; 1
    91fc:	76 01       	movw	r14, r12
    91fe:	ee 0e       	add	r14, r30
    9200:	ff 1e       	adc	r15, r31
    9202:	31 96       	adiw	r30, 0x01	; 1
    9204:	61 e0       	ldi	r22, 0x01	; 1
    9206:	19 c0       	rjmp	.+50     	; 0x923a <GenerateTransactionNum+0x9c>
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
	     xNum=PTransNum[Length-i-1]-'0';		 
		 cNum='0'+((xNum+xAdd)%10);
    9208:	d8 01       	movw	r26, r16
    920a:	2c 91       	ld	r18, X
    920c:	20 53       	subi	r18, 0x30	; 48
    920e:	30 e0       	ldi	r19, 0x00	; 0
    9210:	26 0f       	add	r18, r22
    9212:	31 1d       	adc	r19, r1
    9214:	c9 01       	movw	r24, r18
    9216:	6a e0       	ldi	r22, 0x0A	; 10
    9218:	70 e0       	ldi	r23, 0x00	; 0
    921a:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    921e:	48 2f       	mov	r20, r24
    9220:	40 5d       	subi	r20, 0xD0	; 208
		 xAdd=((xNum+xAdd)/10);
    9222:	c9 01       	movw	r24, r18
    9224:	6a e0       	ldi	r22, 0x0A	; 10
    9226:	70 e0       	ldi	r23, 0x00	; 0
    9228:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
		 PTransNum[Length-i-1]=cNum;
    922c:	d8 01       	movw	r26, r16
    922e:	4c 93       	st	X, r20
		 sTransNumber[Length-i-1]=cNum;
    9230:	d7 01       	movw	r26, r14
    9232:	4c 93       	st	X, r20
    9234:	08 94       	sec
    9236:	e1 08       	sbc	r14, r1
    9238:	f1 08       	sbc	r15, r1
    923a:	01 50       	subi	r16, 0x01	; 1
    923c:	10 40       	sbci	r17, 0x00	; 0
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
    923e:	0c 17       	cp	r16, r28
    9240:	1d 07       	cpc	r17, r29
    9242:	11 f7       	brne	.-60     	; 0x9208 <GenerateTransactionNum+0x6a>
		 cNum='0'+((xNum+xAdd)%10);
		 xAdd=((xNum+xAdd)/10);
		 PTransNum[Length-i-1]=cNum;
		 sTransNumber[Length-i-1]=cNum;
	 }
	 sTransNumber[Length]=0;
    9244:	ce 0e       	add	r12, r30
    9246:	df 1e       	adc	r13, r31
    9248:	d6 01       	movw	r26, r12
    924a:	1c 92       	st	X, r1
	 PTransNum[Length]=0;
    924c:	be 01       	movw	r22, r28
    924e:	6f 5f       	subi	r22, 0xFF	; 255
    9250:	7f 4f       	sbci	r23, 0xFF	; 255
    9252:	e6 0f       	add	r30, r22
    9254:	f7 1f       	adc	r31, r23
    9256:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    9258:	88 e3       	ldi	r24, 0x38	; 56
    925a:	91 e0       	ldi	r25, 0x01	; 1
    925c:	47 e0       	ldi	r20, 0x07	; 7
    925e:	50 e0       	ldi	r21, 0x00	; 0
    9260:	2d ed       	ldi	r18, 0xDD	; 221
    9262:	32 e1       	ldi	r19, 0x12	; 18
    9264:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}
    9268:	27 96       	adiw	r28, 0x07	; 7
    926a:	0f b6       	in	r0, 0x3f	; 63
    926c:	f8 94       	cli
    926e:	de bf       	out	0x3e, r29	; 62
    9270:	0f be       	out	0x3f, r0	; 63
    9272:	cd bf       	out	0x3d, r28	; 61
    9274:	cf 91       	pop	r28
    9276:	df 91       	pop	r29
    9278:	1f 91       	pop	r17
    927a:	0f 91       	pop	r16
    927c:	ff 90       	pop	r15
    927e:	ef 90       	pop	r14
    9280:	df 90       	pop	r13
    9282:	cf 90       	pop	r12
    9284:	08 95       	ret

00009286 <_f_punctuation>:
				__string[__i++] = 0x30;
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}
void _f_punctuation(char* __string, unsigned char __mode, unsigned char __length, unsigned char __decimal){
    9286:	bf 92       	push	r11
    9288:	cf 92       	push	r12
    928a:	df 92       	push	r13
    928c:	ef 92       	push	r14
    928e:	ff 92       	push	r15
    9290:	0f 93       	push	r16
    9292:	1f 93       	push	r17
    9294:	df 93       	push	r29
    9296:	cf 93       	push	r28
    9298:	cd b7       	in	r28, 0x3d	; 61
    929a:	de b7       	in	r29, 0x3e	; 62
    929c:	2f 97       	sbiw	r28, 0x0f	; 15
    929e:	0f b6       	in	r0, 0x3f	; 63
    92a0:	f8 94       	cli
    92a2:	de bf       	out	0x3e, r29	; 62
    92a4:	0f be       	out	0x3f, r0	; 63
    92a6:	cd bf       	out	0x3d, r28	; 61
    92a8:	8c 01       	movw	r16, r24
    92aa:	c6 2e       	mov	r12, r22
    92ac:	d4 2e       	mov	r13, r20
    92ae:	62 2f       	mov	r22, r18
	char __buff[15] = {"000000000000000"};
    92b0:	de 01       	movw	r26, r28
    92b2:	11 96       	adiw	r26, 0x01	; 1
    92b4:	e0 e0       	ldi	r30, 0x00	; 0
    92b6:	f1 e0       	ldi	r31, 0x01	; 1
    92b8:	8f e0       	ldi	r24, 0x0F	; 15
    92ba:	01 90       	ld	r0, Z+
    92bc:	0d 92       	st	X+, r0
    92be:	81 50       	subi	r24, 0x01	; 1
    92c0:	e1 f7       	brne	.-8      	; 0x92ba <_f_punctuation+0x34>
	char  __point = 0,  __len;
	unsigned char __i, __ii,__counter = 0;

	__len = strlen(__string);
    92c2:	f8 01       	movw	r30, r16
    92c4:	01 90       	ld	r0, Z+
    92c6:	00 20       	and	r0, r0
    92c8:	e9 f7       	brne	.-6      	; 0x92c4 <_f_punctuation+0x3e>
    92ca:	31 97       	sbiw	r30, 0x01	; 1
    92cc:	3e 2f       	mov	r19, r30
    92ce:	30 1b       	sub	r19, r16
	if(__mode == 0){
    92d0:	cc 20       	and	r12, r12
    92d2:	11 f5       	brne	.+68     	; 0x9318 <_f_punctuation+0x92>
		__buff[__length] = '\0';
    92d4:	8d 2d       	mov	r24, r13
    92d6:	90 e0       	ldi	r25, 0x00	; 0
    92d8:	fe 01       	movw	r30, r28
    92da:	e8 0f       	add	r30, r24
    92dc:	f9 1f       	adc	r31, r25
    92de:	11 82       	std	Z+1, r1	; 0x01
		for(__i = __length, __ii = __len - 1; __i > (__length - __len); __i--, __ii--)
    92e0:	23 2f       	mov	r18, r19
    92e2:	21 50       	subi	r18, 0x01	; 1
    92e4:	4d 2d       	mov	r20, r13
    92e6:	bc 01       	movw	r22, r24
    92e8:	63 1b       	sub	r22, r19
    92ea:	71 09       	sbc	r23, r1
    92ec:	09 c0       	rjmp	.+18     	; 0x9300 <_f_punctuation+0x7a>
			__buff[__i - 1] = __string[__ii];
    92ee:	ac 0f       	add	r26, r28
    92f0:	bd 1f       	adc	r27, r29
    92f2:	f8 01       	movw	r30, r16
    92f4:	e2 0f       	add	r30, r18
    92f6:	f1 1d       	adc	r31, r1
    92f8:	80 81       	ld	r24, Z
    92fa:	8c 93       	st	X, r24
	unsigned char __i, __ii,__counter = 0;

	__len = strlen(__string);
	if(__mode == 0){
		__buff[__length] = '\0';
		for(__i = __length, __ii = __len - 1; __i > (__length - __len); __i--, __ii--)
    92fc:	41 50       	subi	r20, 0x01	; 1
    92fe:	21 50       	subi	r18, 0x01	; 1
    9300:	a4 2f       	mov	r26, r20
    9302:	b0 e0       	ldi	r27, 0x00	; 0
    9304:	6a 17       	cp	r22, r26
    9306:	7b 07       	cpc	r23, r27
    9308:	94 f3       	brlt	.-28     	; 0x92ee <_f_punctuation+0x68>
			__buff[__i - 1] = __string[__ii];
		strcpy(__string, __buff);
    930a:	c8 01       	movw	r24, r16
    930c:	be 01       	movw	r22, r28
    930e:	6f 5f       	subi	r22, 0xFF	; 255
    9310:	7f 4f       	sbci	r23, 0xFF	; 255
    9312:	0e 94 ed b3 	call	0x167da	; 0x167da <strcpy>
    9316:	90 c0       	rjmp	.+288    	; 0x9438 <_f_punctuation+0x1b2>
	}
	else{
		if(__decimal > 0){
    9318:	66 23       	and	r22, r22
    931a:	61 f1       	breq	.+88     	; 0x9374 <_f_punctuation+0xee>
    931c:	a3 2f       	mov	r26, r19
    931e:	b0 e0       	ldi	r27, 0x00	; 0
    9320:	11 97       	sbiw	r26, 0x01	; 1
    9322:	a0 0f       	add	r26, r16
    9324:	b1 1f       	adc	r27, r17
    9326:	90 e0       	ldi	r25, 0x00	; 0
    9328:	ae 01       	movw	r20, r28
    932a:	4f 5f       	subi	r20, 0xFF	; 255
    932c:	5f 4f       	sbci	r21, 0xFF	; 255
			for(__i = 0; __i < __decimal; __i++){
				if(__i < __len)
					__buff[__counter++] = __string[__len - 1 - __i];
				else
					__buff[__counter++] = '0';
    932e:	20 e3       	ldi	r18, 0x30	; 48
    9330:	0e c0       	rjmp	.+28     	; 0x934e <_f_punctuation+0xc8>
    9332:	e9 2f       	mov	r30, r25
    9334:	f0 e0       	ldi	r31, 0x00	; 0
		strcpy(__string, __buff);
	}
	else{
		if(__decimal > 0){
			for(__i = 0; __i < __decimal; __i++){
				if(__i < __len)
    9336:	93 17       	cp	r25, r19
    9338:	28 f4       	brcc	.+10     	; 0x9344 <_f_punctuation+0xbe>
					__buff[__counter++] = __string[__len - 1 - __i];
    933a:	e4 0f       	add	r30, r20
    933c:	f5 1f       	adc	r31, r21
    933e:	8c 91       	ld	r24, X
    9340:	80 83       	st	Z, r24
    9342:	03 c0       	rjmp	.+6      	; 0x934a <_f_punctuation+0xc4>
				else
					__buff[__counter++] = '0';
    9344:	e4 0f       	add	r30, r20
    9346:	f5 1f       	adc	r31, r21
    9348:	20 83       	st	Z, r18
			__buff[__i - 1] = __string[__ii];
		strcpy(__string, __buff);
	}
	else{
		if(__decimal > 0){
			for(__i = 0; __i < __decimal; __i++){
    934a:	9f 5f       	subi	r25, 0xFF	; 255
    934c:	11 97       	sbiw	r26, 0x01	; 1
    934e:	96 17       	cp	r25, r22
    9350:	80 f3       	brcs	.-32     	; 0x9332 <_f_punctuation+0xac>
				if(__i < __len)
					__buff[__counter++] = __string[__len - 1 - __i];
				else
					__buff[__counter++] = '0';
			}
			__buff[__counter++] = ',';
    9352:	de 01       	movw	r26, r28
    9354:	11 96       	adiw	r26, 0x01	; 1
    9356:	fd 01       	movw	r30, r26
    9358:	e6 0f       	add	r30, r22
    935a:	f1 1d       	adc	r31, r1
    935c:	8c e2       	ldi	r24, 0x2C	; 44
    935e:	80 83       	st	Z, r24
    9360:	56 2f       	mov	r21, r22
    9362:	5f 5f       	subi	r21, 0xFF	; 255
		}
		if(__decimal > 0 && __len <= 2)
    9364:	33 30       	cpi	r19, 0x03	; 3
    9366:	48 f4       	brcc	.+18     	; 0x937a <_f_punctuation+0xf4>
			__buff[__counter++] = '0';
    9368:	a5 0f       	add	r26, r21
    936a:	b1 1d       	adc	r27, r1
    936c:	80 e3       	ldi	r24, 0x30	; 48
    936e:	8c 93       	st	X, r24
    9370:	5f 5f       	subi	r21, 0xFF	; 255
    9372:	32 c0       	rjmp	.+100    	; 0x93d8 <_f_punctuation+0x152>
		else{
			if(__len > 1){
    9374:	32 30       	cpi	r19, 0x02	; 2
    9376:	68 f1       	brcs	.+90     	; 0x93d2 <_f_punctuation+0x14c>
    9378:	50 e0       	ldi	r21, 0x00	; 0
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
    937a:	31 50       	subi	r19, 0x01	; 1
    937c:	b3 2e       	mov	r11, r19
    937e:	b6 1a       	sub	r11, r22
    9380:	3f 5f       	subi	r19, 0xFF	; 255
    9382:	70 e0       	ldi	r23, 0x00	; 0
    9384:	40 e0       	ldi	r20, 0x00	; 0
    9386:	23 2f       	mov	r18, r19
    9388:	30 e0       	ldi	r19, 0x00	; 0
    938a:	26 1b       	sub	r18, r22
    938c:	31 09       	sbc	r19, r1
						__i++, __point++, __ii--){
					if(__point == 3){
						__point = 0;
						__buff[__counter++] = '.';
    938e:	7e 01       	movw	r14, r28
    9390:	08 94       	sec
    9392:	e1 1c       	adc	r14, r1
    9394:	f1 1c       	adc	r15, r1
    9396:	6e e2       	ldi	r22, 0x2E	; 46
    9398:	14 c0       	rjmp	.+40     	; 0x93c2 <_f_punctuation+0x13c>
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
						__i++, __point++, __ii--){
					if(__point == 3){
    939a:	73 30       	cpi	r23, 0x03	; 3
    939c:	31 f4       	brne	.+12     	; 0x93aa <_f_punctuation+0x124>
						__point = 0;
						__buff[__counter++] = '.';
    939e:	f7 01       	movw	r30, r14
    93a0:	e5 0f       	add	r30, r21
    93a2:	f1 1d       	adc	r31, r1
    93a4:	60 83       	st	Z, r22
    93a6:	5f 5f       	subi	r21, 0xFF	; 255
    93a8:	70 e0       	ldi	r23, 0x00	; 0
					}
					__buff[__counter++] = __string[__ii];
    93aa:	f7 01       	movw	r30, r14
    93ac:	e5 0f       	add	r30, r21
    93ae:	f1 1d       	adc	r31, r1
    93b0:	c8 01       	movw	r24, r16
    93b2:	8a 0f       	add	r24, r26
    93b4:	91 1d       	adc	r25, r1
    93b6:	dc 01       	movw	r26, r24
    93b8:	8c 91       	ld	r24, X
    93ba:	80 83       	st	Z, r24
    93bc:	5f 5f       	subi	r21, 0xFF	; 255
		if(__decimal > 0 && __len <= 2)
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
						__i++, __point++, __ii--){
    93be:	4f 5f       	subi	r20, 0xFF	; 255
    93c0:	7f 5f       	subi	r23, 0xFF	; 255
    93c2:	ab 2d       	mov	r26, r11
    93c4:	a4 1b       	sub	r26, r20
		}
		if(__decimal > 0 && __len <= 2)
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
    93c6:	84 2f       	mov	r24, r20
    93c8:	90 e0       	ldi	r25, 0x00	; 0
    93ca:	82 17       	cp	r24, r18
    93cc:	93 07       	cpc	r25, r19
    93ce:	2c f3       	brlt	.-54     	; 0x939a <_f_punctuation+0x114>
    93d0:	03 c0       	rjmp	.+6      	; 0x93d8 <_f_punctuation+0x152>
					}
					__buff[__counter++] = __string[__ii];
				}
			}
			else
				__buff[__counter++] = '0';
    93d2:	80 e3       	ldi	r24, 0x30	; 48
    93d4:	89 83       	std	Y+1, r24	; 0x01
    93d6:	51 e0       	ldi	r21, 0x01	; 1
		}
		if(__mode == 1){
    93d8:	91 e0       	ldi	r25, 0x01	; 1
    93da:	c9 16       	cp	r12, r25
    93dc:	79 f4       	brne	.+30     	; 0x93fc <_f_punctuation+0x176>
    93de:	fe 01       	movw	r30, r28
    93e0:	31 96       	adiw	r30, 0x01	; 1
    93e2:	e5 0f       	add	r30, r21
    93e4:	f1 1d       	adc	r31, r1
    93e6:	d8 01       	movw	r26, r16
    93e8:	02 c0       	rjmp	.+4      	; 0x93ee <_f_punctuation+0x168>
			for(__i = 0; __i < __counter; __i++)
				__string[__i] = __buff[__counter - 1 - __i];
    93ea:	80 81       	ld	r24, Z
    93ec:	8d 93       	st	X+, r24
    93ee:	31 97       	sbiw	r30, 0x01	; 1
			}
			else
				__buff[__counter++] = '0';
		}
		if(__mode == 1){
			for(__i = 0; __i < __counter; __i++)
    93f0:	ec 17       	cp	r30, r28
    93f2:	fd 07       	cpc	r31, r29
    93f4:	d1 f7       	brne	.-12     	; 0x93ea <_f_punctuation+0x164>
				__string[__i] = __buff[__counter - 1 - __i];
			__string[__counter] = '\0';
    93f6:	05 0f       	add	r16, r21
    93f8:	11 1d       	adc	r17, r1
    93fa:	1c c0       	rjmp	.+56     	; 0x9434 <_f_punctuation+0x1ae>
		}
		if(__mode == 2){
    93fc:	f2 e0       	ldi	r31, 0x02	; 2
    93fe:	cf 16       	cp	r12, r31
    9400:	d9 f4       	brne	.+54     	; 0x9438 <_f_punctuation+0x1b2>
    9402:	f8 01       	movw	r30, r16
    9404:	80 e0       	ldi	r24, 0x00	; 0
			for(__i = 0; __i < __length; __i++)
				__string[__i] = 0x20;
    9406:	90 e2       	ldi	r25, 0x20	; 32
    9408:	02 c0       	rjmp	.+4      	; 0x940e <_f_punctuation+0x188>
    940a:	91 93       	st	Z+, r25
			for(__i = 0; __i < __counter; __i++)
				__string[__i] = __buff[__counter - 1 - __i];
			__string[__counter] = '\0';
		}
		if(__mode == 2){
			for(__i = 0; __i < __length; __i++)
    940c:	8f 5f       	subi	r24, 0xFF	; 255
    940e:	8d 15       	cp	r24, r13
    9410:	e0 f3       	brcs	.-8      	; 0x940a <_f_punctuation+0x184>
				__string[__i] = 0x20;
			for(__i = 0, __ii = __length - 1; __i < __counter; __i++, __ii--)
    9412:	de 01       	movw	r26, r28
    9414:	11 96       	adiw	r26, 0x01	; 1
    9416:	9d 2d       	mov	r25, r13
    9418:	91 50       	subi	r25, 0x01	; 1
    941a:	29 2f       	mov	r18, r25
    941c:	25 1b       	sub	r18, r21
    941e:	06 c0       	rjmp	.+12     	; 0x942c <_f_punctuation+0x1a6>
				__string[__ii] = __buff[__i];
    9420:	f8 01       	movw	r30, r16
    9422:	e9 0f       	add	r30, r25
    9424:	f1 1d       	adc	r31, r1
    9426:	8d 91       	ld	r24, X+
    9428:	80 83       	st	Z, r24
			__string[__counter] = '\0';
		}
		if(__mode == 2){
			for(__i = 0; __i < __length; __i++)
				__string[__i] = 0x20;
			for(__i = 0, __ii = __length - 1; __i < __counter; __i++, __ii--)
    942a:	91 50       	subi	r25, 0x01	; 1
    942c:	92 17       	cp	r25, r18
    942e:	c1 f7       	brne	.-16     	; 0x9420 <_f_punctuation+0x19a>
				__string[__ii] = __buff[__i];
			__string[__length] = '\0';
    9430:	0d 0d       	add	r16, r13
    9432:	11 1d       	adc	r17, r1
    9434:	f8 01       	movw	r30, r16
    9436:	10 82       	st	Z, r1
		}
	}
}
    9438:	2f 96       	adiw	r28, 0x0f	; 15
    943a:	0f b6       	in	r0, 0x3f	; 63
    943c:	f8 94       	cli
    943e:	de bf       	out	0x3e, r29	; 62
    9440:	0f be       	out	0x3f, r0	; 63
    9442:	cd bf       	out	0x3d, r28	; 61
    9444:	cf 91       	pop	r28
    9446:	df 91       	pop	r29
    9448:	1f 91       	pop	r17
    944a:	0f 91       	pop	r16
    944c:	ff 90       	pop	r15
    944e:	ef 90       	pop	r14
    9450:	df 90       	pop	r13
    9452:	cf 90       	pop	r12
    9454:	bf 90       	pop	r11
    9456:	08 95       	ret

00009458 <_menu_printer>:
}

//*************************************************************************
//  ngeset printer

void _menu_printer(void){
    9458:	2f 92       	push	r2
    945a:	3f 92       	push	r3
    945c:	4f 92       	push	r4
    945e:	5f 92       	push	r5
    9460:	6f 92       	push	r6
    9462:	7f 92       	push	r7
    9464:	8f 92       	push	r8
    9466:	9f 92       	push	r9
    9468:	af 92       	push	r10
    946a:	bf 92       	push	r11
    946c:	cf 92       	push	r12
    946e:	df 92       	push	r13
    9470:	ef 92       	push	r14
    9472:	ff 92       	push	r15
    9474:	0f 93       	push	r16
    9476:	1f 93       	push	r17
    9478:	df 93       	push	r29
    947a:	cf 93       	push	r28
    947c:	cd b7       	in	r28, 0x3d	; 61
    947e:	de b7       	in	r29, 0x3e	; 62
    9480:	2c 97       	sbiw	r28, 0x0c	; 12
    9482:	0f b6       	in	r0, 0x3f	; 63
    9484:	f8 94       	cli
    9486:	de bf       	out	0x3e, r29	; 62
    9488:	0f be       	out	0x3f, r0	; 63
    948a:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    948c:	e1 99       	sbic	0x1c, 1	; 28
    948e:	fe cf       	rjmp	.-4      	; 0x948c <_menu_printer+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9490:	80 e3       	ldi	r24, 0x30	; 48
    9492:	90 e0       	ldi	r25, 0x00	; 0
    9494:	9f bb       	out	0x1f, r25	; 31
    9496:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9498:	e0 9a       	sbi	0x1c, 0	; 28
    949a:	5d b3       	in	r21, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    949c:	e1 99       	sbic	0x1c, 1	; 28
    949e:	fe cf       	rjmp	.-4      	; 0x949c <_menu_printer+0x44>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    94a0:	e5 e3       	ldi	r30, 0x35	; 53
    94a2:	f0 e0       	ldi	r31, 0x00	; 0
    94a4:	ff bb       	out	0x1f, r31	; 31
    94a6:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    94a8:	e0 9a       	sbi	0x1c, 0	; 28
    94aa:	4d b3       	in	r20, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    94ac:	e1 99       	sbic	0x1c, 1	; 28
    94ae:	fe cf       	rjmp	.-4      	; 0x94ac <_menu_printer+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    94b0:	84 e3       	ldi	r24, 0x34	; 52
    94b2:	90 e0       	ldi	r25, 0x00	; 0
    94b4:	9f bb       	out	0x1f, r25	; 31
    94b6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    94b8:	e0 9a       	sbi	0x1c, 0	; 28
    94ba:	3d b3       	in	r19, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    94bc:	e1 99       	sbic	0x1c, 1	; 28
    94be:	fe cf       	rjmp	.-4      	; 0x94bc <_menu_printer+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    94c0:	e3 e3       	ldi	r30, 0x33	; 51
    94c2:	f0 e0       	ldi	r31, 0x00	; 0
    94c4:	ff bb       	out	0x1f, r31	; 31
    94c6:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    94c8:	e0 9a       	sbi	0x1c, 0	; 28
    94ca:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    94cc:	e1 99       	sbic	0x1c, 1	; 28
    94ce:	fe cf       	rjmp	.-4      	; 0x94cc <_menu_printer+0x74>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    94d0:	71 e3       	ldi	r23, 0x31	; 49
    94d2:	27 2e       	mov	r2, r23
    94d4:	70 e0       	ldi	r23, 0x00	; 0
    94d6:	37 2e       	mov	r3, r23
    94d8:	3f ba       	out	0x1f, r3	; 31
    94da:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    94dc:	e0 9a       	sbi	0x1c, 0	; 28
    94de:	9d b3       	in	r25, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    94e0:	e1 99       	sbic	0x1c, 1	; 28
    94e2:	fe cf       	rjmp	.-4      	; 0x94e0 <_menu_printer+0x88>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    94e4:	62 e3       	ldi	r22, 0x32	; 50
    94e6:	46 2e       	mov	r4, r22
    94e8:	60 e0       	ldi	r22, 0x00	; 0
    94ea:	56 2e       	mov	r5, r22
    94ec:	5f ba       	out	0x1f, r5	; 31
    94ee:	4e ba       	out	0x1e, r4	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    94f0:	e0 9a       	sbi	0x1c, 0	; 28
    94f2:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[6];
	char	__i, __x, __y, __lmt, __start, __key, __num, __buff[6];
//	char lcdteks[20];

	__value[0] = eeprom_read_byte(&DefPrinterType);
    94f4:	59 83       	std	Y+1, r21	; 0x01
	__value[1] = eeprom_read_byte(&DefPrintSize);
    94f6:	4a 83       	std	Y+2, r20	; 0x02
	__value[2] = eeprom_read_byte(&DefPrintLogo);
    94f8:	3b 83       	std	Y+3, r19	; 0x03
	__value[3] = eeprom_read_byte(&DefPrintAutoCut);
    94fa:	2c 83       	std	Y+4, r18	; 0x04
	__value[4] = eeprom_read_byte(&DefPrintScrollEnd);
    94fc:	9d 83       	std	Y+5, r25	; 0x05
	__value[5] = eeprom_read_byte(&DefPrintScrollSpace);
    94fe:	8e 83       	std	Y+6, r24	; 0x06

	lcd_clear();
    9500:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
    9504:	81 e0       	ldi	r24, 0x01	; 1
    9506:	61 e0       	ldi	r22, 0x01	; 1
    9508:	4c e7       	ldi	r20, 0x7C	; 124
    950a:	5b e0       	ldi	r21, 0x0B	; 11
    950c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
    9510:	82 e0       	ldi	r24, 0x02	; 2
    9512:	61 e0       	ldi	r22, 0x01	; 1
    9514:	49 e6       	ldi	r20, 0x69	; 105
    9516:	5b e0       	ldi	r21, 0x0B	; 11
    9518:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
    951c:	83 e0       	ldi	r24, 0x03	; 3
    951e:	61 e0       	ldi	r22, 0x01	; 1
    9520:	49 e5       	ldi	r20, 0x59	; 89
    9522:	5b e0       	ldi	r21, 0x0B	; 11
    9524:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));
    9528:	84 e0       	ldi	r24, 0x04	; 4
    952a:	61 e0       	ldi	r22, 0x01	; 1
    952c:	49 e4       	ldi	r20, 0x49	; 73
    952e:	5b e0       	ldi	r21, 0x0B	; 11
    9530:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
    9534:	00 ee       	ldi	r16, 0xE0	; 224
    9536:	12 e0       	ldi	r17, 0x02	; 2
    9538:	4e 01       	movw	r8, r28
    953a:	08 94       	sec
    953c:	81 1c       	adc	r8, r1
    953e:	91 1c       	adc	r9, r1
    9540:	74 01       	movw	r14, r8

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
		__y = pgm_read_byte(&__prntloc[__i][1]);
		_f_inttostr(__buff, __value[__i]);
    9542:	37 e0       	ldi	r19, 0x07	; 7
    9544:	c3 2e       	mov	r12, r19
    9546:	d1 2c       	mov	r13, r1
    9548:	cc 0e       	add	r12, r28
    954a:	dd 1e       	adc	r13, r29
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
    954c:	f8 01       	movw	r30, r16
    954e:	a4 90       	lpm	r10, Z+
		__y = pgm_read_byte(&__prntloc[__i][1]);
    9550:	0f 5f       	subi	r16, 0xFF	; 255
    9552:	1f 4f       	sbci	r17, 0xFF	; 255
    9554:	f8 01       	movw	r30, r16
    9556:	b4 90       	lpm	r11, Z+
    9558:	01 50       	subi	r16, 0x01	; 1
    955a:	10 40       	sbci	r17, 0x00	; 0
		_f_inttostr(__buff, __value[__i]);
    955c:	f7 01       	movw	r30, r14
    955e:	40 81       	ld	r20, Z
    9560:	50 e0       	ldi	r21, 0x00	; 0
    9562:	60 e0       	ldi	r22, 0x00	; 0
    9564:	70 e0       	ldi	r23, 0x00	; 0
    9566:	c6 01       	movw	r24, r12
    9568:	0e 94 44 19 	call	0x3288	; 0x3288 <_f_inttostr>
		if(__i == 4)_f_punctuation(__buff, 0, 2, 0);
    956c:	8e 2d       	mov	r24, r14
    956e:	88 19       	sub	r24, r8
    9570:	84 30       	cpi	r24, 0x04	; 4
    9572:	31 f4       	brne	.+12     	; 0x9580 <_menu_printer+0x128>
    9574:	c6 01       	movw	r24, r12
    9576:	60 e0       	ldi	r22, 0x00	; 0
    9578:	42 e0       	ldi	r20, 0x02	; 2
    957a:	20 e0       	ldi	r18, 0x00	; 0
    957c:	0e 94 43 49 	call	0x9286	; 0x9286 <_f_punctuation>
		lcd_print(__x, __y, __buff);
    9580:	8a 2d       	mov	r24, r10
    9582:	6b 2d       	mov	r22, r11
    9584:	a6 01       	movw	r20, r12
    9586:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    958a:	0e 5f       	subi	r16, 0xFE	; 254
    958c:	1f 4f       	sbci	r17, 0xFF	; 255
    958e:	08 94       	sec
    9590:	e1 1c       	adc	r14, r1
    9592:	f1 1c       	adc	r15, r1
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
    9594:	f2 e0       	ldi	r31, 0x02	; 2
    9596:	0c 3e       	cpi	r16, 0xEC	; 236
    9598:	1f 07       	cpc	r17, r31
    959a:	c1 f6       	brne	.-80     	; 0x954c <_menu_printer+0xf4>

		}
		if(__num >= 0x31 && __num <= 0x36){
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
			if(__value[__num - 0x31] == __lmt)
    959c:	3e 01       	movw	r6, r28
    959e:	08 94       	sec
    95a0:	61 1c       	adc	r6, r1
    95a2:	71 1c       	adc	r7, r1
				__value[__num - 0x31] = __start;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
			_f_inttostr(__buff, __value[__num - 0x31]);
    95a4:	27 e0       	ldi	r18, 0x07	; 7
    95a6:	c2 2e       	mov	r12, r18
    95a8:	d1 2c       	mov	r13, r1
    95aa:	cc 0e       	add	r12, r28
    95ac:	dd 1e       	adc	r13, r29
		__key = _key_scan(1);
		__num = _key_btn(__key);
		if(__key == _KEY_CANCEL)
			return;
		if(__key==_KEY_ENTER){
			eeprom_write_byte(&DefPrinterType, __value[0]);
    95ae:	89 80       	ldd	r8, Y+1	; 0x01
			eeprom_write_byte(&DefPrintSize, __value[1]);
    95b0:	9a 80       	ldd	r9, Y+2	; 0x02
			eeprom_write_byte(&DefPrintLogo, __value[2]);
    95b2:	ab 80       	ldd	r10, Y+3	; 0x03
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
    95b4:	bc 80       	ldd	r11, Y+4	; 0x04
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
    95b6:	ed 80       	ldd	r14, Y+5	; 0x05
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);
    95b8:	fe 80       	ldd	r15, Y+6	; 0x06
	}
    //sprintf_P(lcdteks,PSTR("6)Space :%.2d"),__value[5]);
	//lcd_print(2,10,lcdteks);

	while(1){	
		__key = _key_scan(1);
    95ba:	81 e0       	ldi	r24, 0x01	; 1
    95bc:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    95c0:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    95c2:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
    95c6:	08 2f       	mov	r16, r24
		if(__key == _KEY_CANCEL)
    95c8:	17 3e       	cpi	r17, 0xE7	; 231
    95ca:	09 f4       	brne	.+2      	; 0x95ce <_menu_printer+0x176>
    95cc:	85 c0       	rjmp	.+266    	; 0x96d8 <_menu_printer+0x280>
			return;
		if(__key==_KEY_ENTER){
    95ce:	17 3b       	cpi	r17, 0xB7	; 183
    95d0:	09 f0       	breq	.+2      	; 0x95d4 <_menu_printer+0x17c>
    95d2:	44 c0       	rjmp	.+136    	; 0x965c <_menu_printer+0x204>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    95d4:	e1 99       	sbic	0x1c, 1	; 28
    95d6:	fe cf       	rjmp	.-4      	; 0x95d4 <_menu_printer+0x17c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    95d8:	80 e3       	ldi	r24, 0x30	; 48
    95da:	90 e0       	ldi	r25, 0x00	; 0
    95dc:	9f bb       	out	0x1f, r25	; 31
    95de:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    95e0:	8d ba       	out	0x1d, r8	; 29

    __asm__ __volatile__ (
    95e2:	0f b6       	in	r0, 0x3f	; 63
    95e4:	f8 94       	cli
    95e6:	e2 9a       	sbi	0x1c, 2	; 28
    95e8:	e1 9a       	sbi	0x1c, 1	; 28
    95ea:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    95ec:	e1 99       	sbic	0x1c, 1	; 28
    95ee:	fe cf       	rjmp	.-4      	; 0x95ec <_menu_printer+0x194>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    95f0:	e5 e3       	ldi	r30, 0x35	; 53
    95f2:	f0 e0       	ldi	r31, 0x00	; 0
    95f4:	ff bb       	out	0x1f, r31	; 31
    95f6:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    95f8:	9d ba       	out	0x1d, r9	; 29

    __asm__ __volatile__ (
    95fa:	0f b6       	in	r0, 0x3f	; 63
    95fc:	f8 94       	cli
    95fe:	e2 9a       	sbi	0x1c, 2	; 28
    9600:	e1 9a       	sbi	0x1c, 1	; 28
    9602:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9604:	e1 99       	sbic	0x1c, 1	; 28
    9606:	fe cf       	rjmp	.-4      	; 0x9604 <_menu_printer+0x1ac>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9608:	84 e3       	ldi	r24, 0x34	; 52
    960a:	90 e0       	ldi	r25, 0x00	; 0
    960c:	9f bb       	out	0x1f, r25	; 31
    960e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    9610:	ad ba       	out	0x1d, r10	; 29

    __asm__ __volatile__ (
    9612:	0f b6       	in	r0, 0x3f	; 63
    9614:	f8 94       	cli
    9616:	e2 9a       	sbi	0x1c, 2	; 28
    9618:	e1 9a       	sbi	0x1c, 1	; 28
    961a:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    961c:	e1 99       	sbic	0x1c, 1	; 28
    961e:	fe cf       	rjmp	.-4      	; 0x961c <_menu_printer+0x1c4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9620:	e3 e3       	ldi	r30, 0x33	; 51
    9622:	f0 e0       	ldi	r31, 0x00	; 0
    9624:	ff bb       	out	0x1f, r31	; 31
    9626:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    9628:	bd ba       	out	0x1d, r11	; 29

    __asm__ __volatile__ (
    962a:	0f b6       	in	r0, 0x3f	; 63
    962c:	f8 94       	cli
    962e:	e2 9a       	sbi	0x1c, 2	; 28
    9630:	e1 9a       	sbi	0x1c, 1	; 28
    9632:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9634:	e1 99       	sbic	0x1c, 1	; 28
    9636:	fe cf       	rjmp	.-4      	; 0x9634 <_menu_printer+0x1dc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9638:	3f ba       	out	0x1f, r3	; 31
    963a:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    963c:	ed ba       	out	0x1d, r14	; 29

    __asm__ __volatile__ (
    963e:	0f b6       	in	r0, 0x3f	; 63
    9640:	f8 94       	cli
    9642:	e2 9a       	sbi	0x1c, 2	; 28
    9644:	e1 9a       	sbi	0x1c, 1	; 28
    9646:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9648:	e1 99       	sbic	0x1c, 1	; 28
    964a:	fe cf       	rjmp	.-4      	; 0x9648 <_menu_printer+0x1f0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    964c:	5f ba       	out	0x1f, r5	; 31
    964e:	4e ba       	out	0x1e, r4	; 30
#endif
    EEDR = __value;
    9650:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
    9652:	0f b6       	in	r0, 0x3f	; 63
    9654:	f8 94       	cli
    9656:	e2 9a       	sbi	0x1c, 2	; 28
    9658:	e1 9a       	sbi	0x1c, 1	; 28
    965a:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);

		}
		if(__num >= 0x31 && __num <= 0x36){
    965c:	80 2f       	mov	r24, r16
    965e:	81 53       	subi	r24, 0x31	; 49
    9660:	86 30       	cpi	r24, 0x06	; 6
    9662:	08 f0       	brcs	.+2      	; 0x9666 <_menu_printer+0x20e>
    9664:	aa cf       	rjmp	.-172    	; 0x95ba <_menu_printer+0x162>
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
    9666:	a0 2f       	mov	r26, r16
    9668:	b0 e0       	ldi	r27, 0x00	; 0
    966a:	d1 97       	sbiw	r26, 0x31	; 49
    966c:	fd 01       	movw	r30, r26
    966e:	e4 51       	subi	r30, 0x14	; 20
    9670:	fd 4f       	sbci	r31, 0xFD	; 253
    9672:	24 91       	lpm	r18, Z+
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
    9674:	fd 01       	movw	r30, r26
    9676:	ee 50       	subi	r30, 0x0E	; 14
    9678:	fd 4f       	sbci	r31, 0xFD	; 253
    967a:	94 91       	lpm	r25, Z+
			if(__value[__num - 0x31] == __lmt)
    967c:	f3 01       	movw	r30, r6
    967e:	ea 0f       	add	r30, r26
    9680:	fb 1f       	adc	r31, r27
    9682:	80 81       	ld	r24, Z
    9684:	82 17       	cp	r24, r18
    9686:	11 f4       	brne	.+4      	; 0x968c <_menu_printer+0x234>
				__value[__num - 0x31] = __start;
    9688:	90 83       	st	Z, r25
    968a:	02 c0       	rjmp	.+4      	; 0x9690 <_menu_printer+0x238>
			else
				__value[__num - 0x31]++;
    968c:	8f 5f       	subi	r24, 0xFF	; 255
    968e:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
    9690:	9d 01       	movw	r18, r26
    9692:	22 0f       	add	r18, r18
    9694:	33 1f       	adc	r19, r19
    9696:	c9 01       	movw	r24, r18
    9698:	80 52       	subi	r24, 0x20	; 32
    969a:	9d 4f       	sbci	r25, 0xFD	; 253
    969c:	fc 01       	movw	r30, r24
    969e:	f4 90       	lpm	r15, Z+
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
    96a0:	2f 51       	subi	r18, 0x1F	; 31
    96a2:	3d 4f       	sbci	r19, 0xFD	; 253
    96a4:	f9 01       	movw	r30, r18
    96a6:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __value[__num - 0x31]);
    96a8:	a6 0d       	add	r26, r6
    96aa:	b7 1d       	adc	r27, r7
    96ac:	4c 91       	ld	r20, X
    96ae:	50 e0       	ldi	r21, 0x00	; 0
    96b0:	60 e0       	ldi	r22, 0x00	; 0
    96b2:	70 e0       	ldi	r23, 0x00	; 0
    96b4:	c6 01       	movw	r24, r12
    96b6:	0e 94 44 19 	call	0x3288	; 0x3288 <_f_inttostr>
			if((__num == 0x35)||(__num == 0x36))
    96ba:	05 53       	subi	r16, 0x35	; 53
    96bc:	02 30       	cpi	r16, 0x02	; 2
    96be:	30 f4       	brcc	.+12     	; 0x96cc <_menu_printer+0x274>
				_f_punctuation(__buff, 0, 2, 0);
    96c0:	c6 01       	movw	r24, r12
    96c2:	60 e0       	ldi	r22, 0x00	; 0
    96c4:	42 e0       	ldi	r20, 0x02	; 2
    96c6:	20 e0       	ldi	r18, 0x00	; 0
    96c8:	0e 94 43 49 	call	0x9286	; 0x9286 <_f_punctuation>
			lcd_print(__x, __y, __buff);
    96cc:	8f 2d       	mov	r24, r15
    96ce:	61 2f       	mov	r22, r17
    96d0:	a6 01       	movw	r20, r12
    96d2:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    96d6:	6b cf       	rjmp	.-298    	; 0x95ae <_menu_printer+0x156>
		}
	}
}
    96d8:	2c 96       	adiw	r28, 0x0c	; 12
    96da:	0f b6       	in	r0, 0x3f	; 63
    96dc:	f8 94       	cli
    96de:	de bf       	out	0x3e, r29	; 62
    96e0:	0f be       	out	0x3f, r0	; 63
    96e2:	cd bf       	out	0x3d, r28	; 61
    96e4:	cf 91       	pop	r28
    96e6:	df 91       	pop	r29
    96e8:	1f 91       	pop	r17
    96ea:	0f 91       	pop	r16
    96ec:	ff 90       	pop	r15
    96ee:	ef 90       	pop	r14
    96f0:	df 90       	pop	r13
    96f2:	cf 90       	pop	r12
    96f4:	bf 90       	pop	r11
    96f6:	af 90       	pop	r10
    96f8:	9f 90       	pop	r9
    96fa:	8f 90       	pop	r8
    96fc:	7f 90       	pop	r7
    96fe:	6f 90       	pop	r6
    9700:	5f 90       	pop	r5
    9702:	4f 90       	pop	r4
    9704:	3f 90       	pop	r3
    9706:	2f 90       	pop	r2
    9708:	08 95       	ret

0000970a <FSettingPrinter>:
char FSettingDatetime(){
     _menu_datetime();
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
    970a:	0e 94 2c 4a 	call	0x9458	; 0x9458 <_menu_printer>
	 return MENU_DONE;
}
    970e:	81 e0       	ldi	r24, 0x01	; 1
    9710:	08 95       	ret

00009712 <SendPrint>:
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}

void SendPrint(char xSend,char xSendLead){
    9712:	1f 93       	push	r17
    9714:	18 2f       	mov	r17, r24
static char zSend;     
	 if (xSend==0x19){
    9716:	89 31       	cpi	r24, 0x19	; 25
    9718:	59 f4       	brne	.+22     	; 0x9730 <SendPrint+0x1e>
	     if (zSend==xSendLead)_uart(_COM_PRINTER,1,xSendLead);
    971a:	40 91 89 02 	lds	r20, 0x0289
    971e:	46 17       	cp	r20, r22
    9720:	19 f4       	brne	.+6      	; 0x9728 <SendPrint+0x16>
    9722:	80 e0       	ldi	r24, 0x00	; 0
    9724:	61 e0       	ldi	r22, 0x01	; 1
    9726:	07 c0       	rjmp	.+14     	; 0x9736 <SendPrint+0x24>
		 else _uart(_COM_PRINTER,1,' ');	 
    9728:	80 e0       	ldi	r24, 0x00	; 0
    972a:	61 e0       	ldi	r22, 0x01	; 1
    972c:	40 e2       	ldi	r20, 0x20	; 32
    972e:	03 c0       	rjmp	.+6      	; 0x9736 <SendPrint+0x24>
	 } 
	 else _uart(_COM_PRINTER,1,xSend);
    9730:	80 e0       	ldi	r24, 0x00	; 0
    9732:	61 e0       	ldi	r22, 0x01	; 1
    9734:	41 2f       	mov	r20, r17
    9736:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	 zSend=xSend;
    973a:	10 93 89 02 	sts	0x0289, r17
}
    973e:	1f 91       	pop	r17
    9740:	08 95       	ret

00009742 <CarriegeReturn>:
	      break;	 
	 }
}

void CarriegeReturn(){
     _uart(_COM_PRINTER, 1, 0x0D);     
    9742:	80 e0       	ldi	r24, 0x00	; 0
    9744:	61 e0       	ldi	r22, 0x01	; 1
    9746:	4d e0       	ldi	r20, 0x0D	; 13
    9748:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
     _uart(_COM_PRINTER, 1, 0x0A);
    974c:	80 e0       	ldi	r24, 0x00	; 0
    974e:	61 e0       	ldi	r22, 0x01	; 1
    9750:	4a e0       	ldi	r20, 0x0A	; 10
    9752:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>

}
    9756:	08 95       	ret

00009758 <InitPrinter>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9758:	e1 99       	sbic	0x1c, 1	; 28
    975a:	fe cf       	rjmp	.-4      	; 0x9758 <InitPrinter>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    975c:	80 e3       	ldi	r24, 0x30	; 48
    975e:	90 e0       	ldi	r25, 0x00	; 0
    9760:	9f bb       	out	0x1f, r25	; 31
    9762:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9764:	e0 9a       	sbi	0x1c, 0	; 28
    9766:	8d b3       	in	r24, 0x1d	; 29
void InitPrinter(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
    //Custom Printer TG02
	//Density Lowest: 1D 7C 00
	if (PrinterType==PT_CUSTOM_TG02){
    9768:	81 30       	cpi	r24, 0x01	; 1
    976a:	71 f5       	brne	.+92     	; 0x97c8 <InitPrinter+0x70>
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x7C);_uart(_COM_PRINTER, 1, 0x00);
    976c:	80 e0       	ldi	r24, 0x00	; 0
    976e:	61 e0       	ldi	r22, 0x01	; 1
    9770:	4d e1       	ldi	r20, 0x1D	; 29
    9772:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    9776:	80 e0       	ldi	r24, 0x00	; 0
    9778:	61 e0       	ldi	r22, 0x01	; 1
    977a:	4c e7       	ldi	r20, 0x7C	; 124
    977c:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    9780:	80 e0       	ldi	r24, 0x00	; 0
    9782:	61 e0       	ldi	r22, 0x01	; 1
    9784:	40 e0       	ldi	r20, 0x00	; 0
    9786:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
		//Double Strike ON : 1B 47 01
		_uart(_COM_PRINTER, 1, 0x1B);_uart(_COM_PRINTER, 1, 0x47);_uart(_COM_PRINTER, 1, 0x01);
    978a:	80 e0       	ldi	r24, 0x00	; 0
    978c:	61 e0       	ldi	r22, 0x01	; 1
    978e:	4b e1       	ldi	r20, 0x1B	; 27
    9790:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    9794:	80 e0       	ldi	r24, 0x00	; 0
    9796:	61 e0       	ldi	r22, 0x01	; 1
    9798:	47 e4       	ldi	r20, 0x47	; 71
    979a:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    979e:	80 e0       	ldi	r24, 0x00	; 0
    97a0:	61 e0       	ldi	r22, 0x01	; 1
    97a2:	41 e0       	ldi	r20, 0x01	; 1
    97a4:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x01);   
    97a8:	80 e0       	ldi	r24, 0x00	; 0
    97aa:	61 e0       	ldi	r22, 0x01	; 1
    97ac:	4d e1       	ldi	r20, 0x1D	; 29
    97ae:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    97b2:	80 e0       	ldi	r24, 0x00	; 0
    97b4:	61 e0       	ldi	r22, 0x01	; 1
    97b6:	41 e2       	ldi	r20, 0x21	; 33
    97b8:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    97bc:	80 e0       	ldi	r24, 0x00	; 0
    97be:	61 e0       	ldi	r22, 0x01	; 1
    97c0:	41 e0       	ldi	r20, 0x01	; 1
    97c2:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    97c6:	08 95       	ret
		}
    else
	if (PrinterType==PT_CUSTOM_CUBE){
    97c8:	82 30       	cpi	r24, 0x02	; 2
    97ca:	69 f5       	brne	.+90     	; 0x9826 <InitPrinter+0xce>
        //Print Density 0%
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x7C);_uart(_COM_PRINTER, 1, 0x04);
    97cc:	80 e0       	ldi	r24, 0x00	; 0
    97ce:	61 e0       	ldi	r22, 0x01	; 1
    97d0:	4d e1       	ldi	r20, 0x1D	; 29
    97d2:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    97d6:	80 e0       	ldi	r24, 0x00	; 0
    97d8:	61 e0       	ldi	r22, 0x01	; 1
    97da:	4c e7       	ldi	r20, 0x7C	; 124
    97dc:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    97e0:	80 e0       	ldi	r24, 0x00	; 0
    97e2:	61 e0       	ldi	r22, 0x01	; 1
    97e4:	44 e0       	ldi	r20, 0x04	; 4
    97e6:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
		//Double Strike OFF : 1B 47 00
		_uart(_COM_PRINTER, 1, 0x1B);_uart(_COM_PRINTER, 1, 0x47);_uart(_COM_PRINTER, 1, 0x00);
    97ea:	80 e0       	ldi	r24, 0x00	; 0
    97ec:	61 e0       	ldi	r22, 0x01	; 1
    97ee:	4b e1       	ldi	r20, 0x1B	; 27
    97f0:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    97f4:	80 e0       	ldi	r24, 0x00	; 0
    97f6:	61 e0       	ldi	r22, 0x01	; 1
    97f8:	47 e4       	ldi	r20, 0x47	; 71
    97fa:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    97fe:	80 e0       	ldi	r24, 0x00	; 0
    9800:	61 e0       	ldi	r22, 0x01	; 1
    9802:	40 e0       	ldi	r20, 0x00	; 0
    9804:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);   
    9808:	80 e0       	ldi	r24, 0x00	; 0
    980a:	61 e0       	ldi	r22, 0x01	; 1
    980c:	4d e1       	ldi	r20, 0x1D	; 29
    980e:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    9812:	80 e0       	ldi	r24, 0x00	; 0
    9814:	61 e0       	ldi	r22, 0x01	; 1
    9816:	41 e2       	ldi	r20, 0x21	; 33
    9818:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    981c:	80 e0       	ldi	r24, 0x00	; 0
    981e:	61 e0       	ldi	r22, 0x01	; 1
    9820:	40 e0       	ldi	r20, 0x00	; 0
    9822:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    9826:	08 95       	ret

00009828 <PrintNormalHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9828:	e1 99       	sbic	0x1c, 1	; 28
    982a:	fe cf       	rjmp	.-4      	; 0x9828 <PrintNormalHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    982c:	80 e3       	ldi	r24, 0x30	; 48
    982e:	90 e0       	ldi	r25, 0x00	; 0
    9830:	9f bb       	out	0x1f, r25	; 31
    9832:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9834:	e0 9a       	sbi	0x1c, 0	; 28
    9836:	8d b3       	in	r24, 0x1d	; 29
}

void PrintNormalHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    9838:	82 30       	cpi	r24, 0x02	; 2
    983a:	79 f4       	brne	.+30     	; 0x985a <PrintNormalHeight+0x32>
	     _uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);
    983c:	80 e0       	ldi	r24, 0x00	; 0
    983e:	61 e0       	ldi	r22, 0x01	; 1
    9840:	4d e1       	ldi	r20, 0x1D	; 29
    9842:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    9846:	80 e0       	ldi	r24, 0x00	; 0
    9848:	61 e0       	ldi	r22, 0x01	; 1
    984a:	41 e2       	ldi	r20, 0x21	; 33
    984c:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    9850:	80 e0       	ldi	r24, 0x00	; 0
    9852:	61 e0       	ldi	r22, 0x01	; 1
    9854:	40 e0       	ldi	r20, 0x00	; 0
    9856:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    985a:	08 95       	ret

0000985c <PrintDoubleHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    985c:	e1 99       	sbic	0x1c, 1	; 28
    985e:	fe cf       	rjmp	.-4      	; 0x985c <PrintDoubleHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9860:	80 e3       	ldi	r24, 0x30	; 48
    9862:	90 e0       	ldi	r25, 0x00	; 0
    9864:	9f bb       	out	0x1f, r25	; 31
    9866:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9868:	e0 9a       	sbi	0x1c, 0	; 28
    986a:	8d b3       	in	r24, 0x1d	; 29
//void SetPrinterCharacterWidth

void PrintDoubleHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    986c:	82 30       	cpi	r24, 0x02	; 2
    986e:	79 f4       	brne	.+30     	; 0x988e <PrintDoubleHeight+0x32>
	     _uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x01);
    9870:	80 e0       	ldi	r24, 0x00	; 0
    9872:	61 e0       	ldi	r22, 0x01	; 1
    9874:	4d e1       	ldi	r20, 0x1D	; 29
    9876:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    987a:	80 e0       	ldi	r24, 0x00	; 0
    987c:	61 e0       	ldi	r22, 0x01	; 1
    987e:	41 e2       	ldi	r20, 0x21	; 33
    9880:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    9884:	80 e0       	ldi	r24, 0x00	; 0
    9886:	61 e0       	ldi	r22, 0x01	; 1
    9888:	41 e0       	ldi	r20, 0x01	; 1
    988a:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    988e:	08 95       	ret

00009890 <PaperCut>:

	 return Result;
}


void PaperCut(){
    9890:	1f 93       	push	r17
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9892:	e1 99       	sbic	0x1c, 1	; 28
    9894:	fe cf       	rjmp	.-4      	; 0x9892 <PaperCut+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9896:	83 e3       	ldi	r24, 0x33	; 51
    9898:	90 e0       	ldi	r25, 0x00	; 0
    989a:	9f bb       	out	0x1f, r25	; 31
    989c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    989e:	e0 9a       	sbi	0x1c, 0	; 28
    98a0:	1d b3       	in	r17, 0x1d	; 29
     char CutType;
     CutType= eeprom_read_byte(&DefPrintAutoCut);
     _uart(_COM_PRINTER, 1, 0x1B);
    98a2:	80 e0       	ldi	r24, 0x00	; 0
    98a4:	61 e0       	ldi	r22, 0x01	; 1
    98a6:	4b e1       	ldi	r20, 0x1B	; 27
    98a8:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	 if(CutType== 1) { _uart(_COM_PRINTER, 1, 0x6D);}
    98ac:	11 30       	cpi	r17, 0x01	; 1
    98ae:	21 f4       	brne	.+8      	; 0x98b8 <PaperCut+0x28>
    98b0:	80 e0       	ldi	r24, 0x00	; 0
    98b2:	61 e0       	ldi	r22, 0x01	; 1
    98b4:	4d e6       	ldi	r20, 0x6D	; 109
    98b6:	05 c0       	rjmp	.+10     	; 0x98c2 <PaperCut+0x32>
	 if(CutType== 2) {_uart(_COM_PRINTER, 1, 0x69);}
    98b8:	12 30       	cpi	r17, 0x02	; 2
    98ba:	29 f4       	brne	.+10     	; 0x98c6 <PaperCut+0x36>
    98bc:	80 e0       	ldi	r24, 0x00	; 0
    98be:	61 e0       	ldi	r22, 0x01	; 1
    98c0:	49 e6       	ldi	r20, 0x69	; 105
    98c2:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>

}
    98c6:	1f 91       	pop	r17
    98c8:	08 95       	ret

000098ca <sendMessage98>:
		        break;
	       }//EndSwitch
return Result;
}

void sendMessage98(char PumpID){
    98ca:	ff 92       	push	r15
    98cc:	0f 93       	push	r16
    98ce:	1f 93       	push	r17
    98d0:	df 93       	push	r29
    98d2:	cf 93       	push	r28
    98d4:	cd b7       	in	r28, 0x3d	; 61
    98d6:	de b7       	in	r29, 0x3e	; 62
    98d8:	ea 97       	sbiw	r28, 0x3a	; 58
    98da:	0f b6       	in	r0, 0x3f	; 63
    98dc:	f8 94       	cli
    98de:	de bf       	out	0x3e, r29	; 62
    98e0:	0f be       	out	0x3f, r0	; 63
    98e2:	cd bf       	out	0x3d, r28	; 61
    98e4:	f8 2e       	mov	r15, r24
	char __pump_id[8];
	char strSend[50];
	char xFIP_ID;
	
	_uart(1, 1,0x01);
    98e6:	81 e0       	ldi	r24, 0x01	; 1
    98e8:	61 e0       	ldi	r22, 0x01	; 1
    98ea:	41 e0       	ldi	r20, 0x01	; 1
    98ec:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    UpdateIFT_ID(); //ReadIFT_ID
    98f0:	0e 94 f0 1b 	call	0x37e0	; 0x37e0 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    98f4:	0e 94 c5 1b 	call	0x378a	; 0x378a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    98f8:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    98fc:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateServerIP>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9900:	ce 01       	movw	r24, r28
    9902:	01 96       	adiw	r24, 0x01	; 1
    9904:	65 e4       	ldi	r22, 0x45	; 69
    9906:	70 e0       	ldi	r23, 0x00	; 0
    9908:	48 e0       	ldi	r20, 0x08	; 8
    990a:	50 e0       	ldi	r21, 0x00	; 0
    990c:	25 ed       	ldi	r18, 0xD5	; 213
    990e:	32 e1       	ldi	r19, 0x12	; 18
    9910:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	xFIP_ID=__pump_id[PumpID-1];
	//if (xFIP_ID>16)xFIP_ID=16;
	sprintf_P(strSend,PSTR("%s%s%s%s98%.2dF968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,xFIP_ID);
    9914:	8d b7       	in	r24, 0x3d	; 61
    9916:	9e b7       	in	r25, 0x3e	; 62
    9918:	0e 97       	sbiw	r24, 0x0e	; 14
    991a:	0f b6       	in	r0, 0x3f	; 63
    991c:	f8 94       	cli
    991e:	9e bf       	out	0x3e, r25	; 62
    9920:	0f be       	out	0x3f, r0	; 63
    9922:	8d bf       	out	0x3d, r24	; 61
    9924:	ad b7       	in	r26, 0x3d	; 61
    9926:	be b7       	in	r27, 0x3e	; 62
    9928:	11 96       	adiw	r26, 0x01	; 1
    992a:	8e 01       	movw	r16, r28
    992c:	07 5f       	subi	r16, 0xF7	; 247
    992e:	1f 4f       	sbci	r17, 0xFF	; 255
    9930:	ed b7       	in	r30, 0x3d	; 61
    9932:	fe b7       	in	r31, 0x3e	; 62
    9934:	12 83       	std	Z+2, r17	; 0x02
    9936:	01 83       	std	Z+1, r16	; 0x01
    9938:	8d ef       	ldi	r24, 0xFD	; 253
    993a:	9c e1       	ldi	r25, 0x1C	; 28
    993c:	13 96       	adiw	r26, 0x03	; 3
    993e:	9c 93       	st	X, r25
    9940:	8e 93       	st	-X, r24
    9942:	12 97       	sbiw	r26, 0x02	; 2
    9944:	8c e1       	ldi	r24, 0x1C	; 28
    9946:	96 e0       	ldi	r25, 0x06	; 6
    9948:	15 96       	adiw	r26, 0x05	; 5
    994a:	9c 93       	st	X, r25
    994c:	8e 93       	st	-X, r24
    994e:	14 97       	sbiw	r26, 0x04	; 4
    9950:	8b ef       	ldi	r24, 0xFB	; 251
    9952:	9d e0       	ldi	r25, 0x0D	; 13
    9954:	17 96       	adiw	r26, 0x07	; 7
    9956:	9c 93       	st	X, r25
    9958:	8e 93       	st	-X, r24
    995a:	16 97       	sbiw	r26, 0x06	; 6
    995c:	8e e0       	ldi	r24, 0x0E	; 14
    995e:	9a e0       	ldi	r25, 0x0A	; 10
    9960:	19 96       	adiw	r26, 0x09	; 9
    9962:	9c 93       	st	X, r25
    9964:	8e 93       	st	-X, r24
    9966:	18 97       	sbiw	r26, 0x08	; 8
    9968:	8b e3       	ldi	r24, 0x3B	; 59
    996a:	9a e0       	ldi	r25, 0x0A	; 10
    996c:	1b 96       	adiw	r26, 0x0b	; 11
    996e:	9c 93       	st	X, r25
    9970:	8e 93       	st	-X, r24
    9972:	1a 97       	sbiw	r26, 0x0a	; 10
    9974:	fe 01       	movw	r30, r28
    9976:	ef 0d       	add	r30, r15
    9978:	f1 1d       	adc	r31, r1
    997a:	80 81       	ld	r24, Z
    997c:	1c 96       	adiw	r26, 0x0c	; 12
    997e:	8c 93       	st	X, r24
    9980:	1c 97       	sbiw	r26, 0x0c	; 12
    9982:	1d 96       	adiw	r26, 0x0d	; 13
    9984:	1c 92       	st	X, r1
    9986:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	_uart_print(1, 0,strSend);
    998a:	8d b7       	in	r24, 0x3d	; 61
    998c:	9e b7       	in	r25, 0x3e	; 62
    998e:	0e 96       	adiw	r24, 0x0e	; 14
    9990:	0f b6       	in	r0, 0x3f	; 63
    9992:	f8 94       	cli
    9994:	9e bf       	out	0x3e, r25	; 62
    9996:	0f be       	out	0x3f, r0	; 63
    9998:	8d bf       	out	0x3d, r24	; 61
    999a:	81 e0       	ldi	r24, 0x01	; 1
    999c:	60 e0       	ldi	r22, 0x00	; 0
    999e:	a8 01       	movw	r20, r16
    99a0:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	_uart(1, 1,0x02);
    99a4:	81 e0       	ldi	r24, 0x01	; 1
    99a6:	61 e0       	ldi	r22, 0x01	; 1
    99a8:	42 e0       	ldi	r20, 0x02	; 2
    99aa:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	IsBusyMsg11=True;
    99ae:	81 e0       	ldi	r24, 0x01	; 1
    99b0:	80 93 c4 01 	sts	0x01C4, r24
}
    99b4:	ea 96       	adiw	r28, 0x3a	; 58
    99b6:	0f b6       	in	r0, 0x3f	; 63
    99b8:	f8 94       	cli
    99ba:	de bf       	out	0x3e, r29	; 62
    99bc:	0f be       	out	0x3f, r0	; 63
    99be:	cd bf       	out	0x3d, r28	; 61
    99c0:	cf 91       	pop	r28
    99c2:	df 91       	pop	r29
    99c4:	1f 91       	pop	r17
    99c6:	0f 91       	pop	r16
    99c8:	ff 90       	pop	r15
    99ca:	08 95       	ret

000099cc <sendMessage94>:
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage94(){//Void Transaction Message
    99cc:	0f 93       	push	r16
    99ce:	1f 93       	push	r17
    99d0:	df 93       	push	r29
    99d2:	cf 93       	push	r28
    99d4:	cd b7       	in	r28, 0x3d	; 61
    99d6:	de b7       	in	r29, 0x3e	; 62
    99d8:	c0 55       	subi	r28, 0x50	; 80
    99da:	d0 40       	sbci	r29, 0x00	; 0
    99dc:	0f b6       	in	r0, 0x3f	; 63
    99de:	f8 94       	cli
    99e0:	de bf       	out	0x3e, r29	; 62
    99e2:	0f be       	out	0x3f, r0	; 63
    99e4:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    99e6:	81 e0       	ldi	r24, 0x01	; 1
    99e8:	61 e0       	ldi	r22, 0x01	; 1
    99ea:	41 e0       	ldi	r20, 0x01	; 1
    99ec:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    99f0:	0e 94 f0 1b 	call	0x37e0	; 0x37e0 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    99f4:	0e 94 c5 1b 	call	0x378a	; 0x378a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    99f8:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    99fc:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s94"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9a00:	8d b7       	in	r24, 0x3d	; 61
    9a02:	9e b7       	in	r25, 0x3e	; 62
    9a04:	0c 97       	sbiw	r24, 0x0c	; 12
    9a06:	0f b6       	in	r0, 0x3f	; 63
    9a08:	f8 94       	cli
    9a0a:	9e bf       	out	0x3e, r25	; 62
    9a0c:	0f be       	out	0x3f, r0	; 63
    9a0e:	8d bf       	out	0x3d, r24	; 61
    9a10:	ed b7       	in	r30, 0x3d	; 61
    9a12:	fe b7       	in	r31, 0x3e	; 62
    9a14:	31 96       	adiw	r30, 0x01	; 1
    9a16:	8e 01       	movw	r16, r28
    9a18:	0f 5f       	subi	r16, 0xFF	; 255
    9a1a:	1f 4f       	sbci	r17, 0xFF	; 255
    9a1c:	ad b7       	in	r26, 0x3d	; 61
    9a1e:	be b7       	in	r27, 0x3e	; 62
    9a20:	12 96       	adiw	r26, 0x02	; 2
    9a22:	1c 93       	st	X, r17
    9a24:	0e 93       	st	-X, r16
    9a26:	11 97       	sbiw	r26, 0x01	; 1
    9a28:	85 e9       	ldi	r24, 0x95	; 149
    9a2a:	90 e2       	ldi	r25, 0x20	; 32
    9a2c:	93 83       	std	Z+3, r25	; 0x03
    9a2e:	82 83       	std	Z+2, r24	; 0x02
    9a30:	8c e1       	ldi	r24, 0x1C	; 28
    9a32:	96 e0       	ldi	r25, 0x06	; 6
    9a34:	95 83       	std	Z+5, r25	; 0x05
    9a36:	84 83       	std	Z+4, r24	; 0x04
    9a38:	8b ef       	ldi	r24, 0xFB	; 251
    9a3a:	9d e0       	ldi	r25, 0x0D	; 13
    9a3c:	97 83       	std	Z+7, r25	; 0x07
    9a3e:	86 83       	std	Z+6, r24	; 0x06
    9a40:	8e e0       	ldi	r24, 0x0E	; 14
    9a42:	9a e0       	ldi	r25, 0x0A	; 10
    9a44:	91 87       	std	Z+9, r25	; 0x09
    9a46:	80 87       	std	Z+8, r24	; 0x08
    9a48:	8b e3       	ldi	r24, 0x3B	; 59
    9a4a:	9a e0       	ldi	r25, 0x0A	; 10
    9a4c:	93 87       	std	Z+11, r25	; 0x0b
    9a4e:	82 87       	std	Z+10, r24	; 0x0a
    9a50:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    9a54:	ed b7       	in	r30, 0x3d	; 61
    9a56:	fe b7       	in	r31, 0x3e	; 62
    9a58:	3c 96       	adiw	r30, 0x0c	; 12
    9a5a:	0f b6       	in	r0, 0x3f	; 63
    9a5c:	f8 94       	cli
    9a5e:	fe bf       	out	0x3e, r31	; 62
    9a60:	0f be       	out	0x3f, r0	; 63
    9a62:	ed bf       	out	0x3d, r30	; 61
    9a64:	81 e0       	ldi	r24, 0x01	; 1
    9a66:	60 e0       	ldi	r22, 0x00	; 0
    9a68:	a8 01       	movw	r20, r16
    9a6a:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s"),strInvoiceNumber,strDateTime);
    9a6e:	8d b7       	in	r24, 0x3d	; 61
    9a70:	9e b7       	in	r25, 0x3e	; 62
    9a72:	08 97       	sbiw	r24, 0x08	; 8
    9a74:	0f b6       	in	r0, 0x3f	; 63
    9a76:	f8 94       	cli
    9a78:	9e bf       	out	0x3e, r25	; 62
    9a7a:	0f be       	out	0x3f, r0	; 63
    9a7c:	8d bf       	out	0x3d, r24	; 61
    9a7e:	ed b7       	in	r30, 0x3d	; 61
    9a80:	fe b7       	in	r31, 0x3e	; 62
    9a82:	31 96       	adiw	r30, 0x01	; 1
    9a84:	ad b7       	in	r26, 0x3d	; 61
    9a86:	be b7       	in	r27, 0x3e	; 62
    9a88:	12 96       	adiw	r26, 0x02	; 2
    9a8a:	1c 93       	st	X, r17
    9a8c:	0e 93       	st	-X, r16
    9a8e:	11 97       	sbiw	r26, 0x01	; 1
    9a90:	80 e9       	ldi	r24, 0x90	; 144
    9a92:	90 e2       	ldi	r25, 0x20	; 32
    9a94:	93 83       	std	Z+3, r25	; 0x03
    9a96:	82 83       	std	Z+2, r24	; 0x02
    9a98:	86 e8       	ldi	r24, 0x86	; 134
    9a9a:	99 e0       	ldi	r25, 0x09	; 9
    9a9c:	95 83       	std	Z+5, r25	; 0x05
    9a9e:	84 83       	std	Z+4, r24	; 0x04
    9aa0:	87 ee       	ldi	r24, 0xE7	; 231
    9aa2:	9d e0       	ldi	r25, 0x0D	; 13
    9aa4:	97 83       	std	Z+7, r25	; 0x07
    9aa6:	86 83       	std	Z+6, r24	; 0x06
    9aa8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    9aac:	ed b7       	in	r30, 0x3d	; 61
    9aae:	fe b7       	in	r31, 0x3e	; 62
    9ab0:	38 96       	adiw	r30, 0x08	; 8
    9ab2:	0f b6       	in	r0, 0x3f	; 63
    9ab4:	f8 94       	cli
    9ab6:	fe bf       	out	0x3e, r31	; 62
    9ab8:	0f be       	out	0x3f, r0	; 63
    9aba:	ed bf       	out	0x3d, r30	; 61
    9abc:	81 e0       	ldi	r24, 0x01	; 1
    9abe:	60 e0       	ldi	r22, 0x00	; 0
    9ac0:	a8 01       	movw	r20, r16
    9ac2:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	sprintf_P(strSend,PSTR("E9445512"));
    9ac6:	00 d0       	rcall	.+0      	; 0x9ac8 <sendMessage94+0xfc>
    9ac8:	00 d0       	rcall	.+0      	; 0x9aca <sendMessage94+0xfe>
    9aca:	ad b7       	in	r26, 0x3d	; 61
    9acc:	be b7       	in	r27, 0x3e	; 62
    9ace:	12 96       	adiw	r26, 0x02	; 2
    9ad0:	1c 93       	st	X, r17
    9ad2:	0e 93       	st	-X, r16
    9ad4:	11 97       	sbiw	r26, 0x01	; 1
    9ad6:	87 e8       	ldi	r24, 0x87	; 135
    9ad8:	90 e2       	ldi	r25, 0x20	; 32
    9ada:	14 96       	adiw	r26, 0x04	; 4
    9adc:	9c 93       	st	X, r25
    9ade:	8e 93       	st	-X, r24
    9ae0:	13 97       	sbiw	r26, 0x03	; 3
    9ae2:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
    9ae6:	0f 90       	pop	r0
    9ae8:	0f 90       	pop	r0
    9aea:	0f 90       	pop	r0
    9aec:	0f 90       	pop	r0
    9aee:	81 e0       	ldi	r24, 0x01	; 1
    9af0:	60 e0       	ldi	r22, 0x00	; 0
    9af2:	a8 01       	movw	r20, r16
    9af4:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	_uart(1, 1,0x02);
    9af8:	81 e0       	ldi	r24, 0x01	; 1
    9afa:	61 e0       	ldi	r22, 0x01	; 1
    9afc:	42 e0       	ldi	r20, 0x02	; 2
    9afe:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
}
    9b02:	c0 5b       	subi	r28, 0xB0	; 176
    9b04:	df 4f       	sbci	r29, 0xFF	; 255
    9b06:	0f b6       	in	r0, 0x3f	; 63
    9b08:	f8 94       	cli
    9b0a:	de bf       	out	0x3e, r29	; 62
    9b0c:	0f be       	out	0x3f, r0	; 63
    9b0e:	cd bf       	out	0x3d, r28	; 61
    9b10:	cf 91       	pop	r28
    9b12:	df 91       	pop	r29
    9b14:	1f 91       	pop	r17
    9b16:	0f 91       	pop	r16
    9b18:	08 95       	ret

00009b1a <sendMessage92>:
	sprintf_P(strSend,PSTR("E9445512"));
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage92(){
    9b1a:	0f 93       	push	r16
    9b1c:	1f 93       	push	r17
    9b1e:	df 93       	push	r29
    9b20:	cf 93       	push	r28
    9b22:	cd b7       	in	r28, 0x3d	; 61
    9b24:	de b7       	in	r29, 0x3e	; 62
    9b26:	c0 55       	subi	r28, 0x50	; 80
    9b28:	d0 40       	sbci	r29, 0x00	; 0
    9b2a:	0f b6       	in	r0, 0x3f	; 63
    9b2c:	f8 94       	cli
    9b2e:	de bf       	out	0x3e, r29	; 62
    9b30:	0f be       	out	0x3f, r0	; 63
    9b32:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9b34:	81 e0       	ldi	r24, 0x01	; 1
    9b36:	61 e0       	ldi	r22, 0x01	; 1
    9b38:	41 e0       	ldi	r20, 0x01	; 1
    9b3a:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9b3e:	0e 94 f0 1b 	call	0x37e0	; 0x37e0 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9b42:	0e 94 c5 1b 	call	0x378a	; 0x378a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9b46:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9b4a:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s92"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9b4e:	8d b7       	in	r24, 0x3d	; 61
    9b50:	9e b7       	in	r25, 0x3e	; 62
    9b52:	0c 97       	sbiw	r24, 0x0c	; 12
    9b54:	0f b6       	in	r0, 0x3f	; 63
    9b56:	f8 94       	cli
    9b58:	9e bf       	out	0x3e, r25	; 62
    9b5a:	0f be       	out	0x3f, r0	; 63
    9b5c:	8d bf       	out	0x3d, r24	; 61
    9b5e:	ed b7       	in	r30, 0x3d	; 61
    9b60:	fe b7       	in	r31, 0x3e	; 62
    9b62:	31 96       	adiw	r30, 0x01	; 1
    9b64:	8e 01       	movw	r16, r28
    9b66:	0f 5f       	subi	r16, 0xFF	; 255
    9b68:	1f 4f       	sbci	r17, 0xFF	; 255
    9b6a:	ad b7       	in	r26, 0x3d	; 61
    9b6c:	be b7       	in	r27, 0x3e	; 62
    9b6e:	12 96       	adiw	r26, 0x02	; 2
    9b70:	1c 93       	st	X, r17
    9b72:	0e 93       	st	-X, r16
    9b74:	11 97       	sbiw	r26, 0x01	; 1
    9b76:	89 eb       	ldi	r24, 0xB9	; 185
    9b78:	90 e2       	ldi	r25, 0x20	; 32
    9b7a:	93 83       	std	Z+3, r25	; 0x03
    9b7c:	82 83       	std	Z+2, r24	; 0x02
    9b7e:	8c e1       	ldi	r24, 0x1C	; 28
    9b80:	96 e0       	ldi	r25, 0x06	; 6
    9b82:	95 83       	std	Z+5, r25	; 0x05
    9b84:	84 83       	std	Z+4, r24	; 0x04
    9b86:	8b ef       	ldi	r24, 0xFB	; 251
    9b88:	9d e0       	ldi	r25, 0x0D	; 13
    9b8a:	97 83       	std	Z+7, r25	; 0x07
    9b8c:	86 83       	std	Z+6, r24	; 0x06
    9b8e:	8e e0       	ldi	r24, 0x0E	; 14
    9b90:	9a e0       	ldi	r25, 0x0A	; 10
    9b92:	91 87       	std	Z+9, r25	; 0x09
    9b94:	80 87       	std	Z+8, r24	; 0x08
    9b96:	8b e3       	ldi	r24, 0x3B	; 59
    9b98:	9a e0       	ldi	r25, 0x0A	; 10
    9b9a:	93 87       	std	Z+11, r25	; 0x0b
    9b9c:	82 87       	std	Z+10, r24	; 0x0a
    9b9e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    9ba2:	ed b7       	in	r30, 0x3d	; 61
    9ba4:	fe b7       	in	r31, 0x3e	; 62
    9ba6:	3c 96       	adiw	r30, 0x0c	; 12
    9ba8:	0f b6       	in	r0, 0x3f	; 63
    9baa:	f8 94       	cli
    9bac:	fe bf       	out	0x3e, r31	; 62
    9bae:	0f be       	out	0x3f, r0	; 63
    9bb0:	ed bf       	out	0x3d, r30	; 61
    9bb2:	81 e0       	ldi	r24, 0x01	; 1
    9bb4:	60 e0       	ldi	r22, 0x00	; 0
    9bb6:	a8 01       	movw	r20, r16
    9bb8:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s%s%s"),strTranNo,strFIP_ID,strCardType,strCardID);
    9bbc:	8d b7       	in	r24, 0x3d	; 61
    9bbe:	9e b7       	in	r25, 0x3e	; 62
    9bc0:	0c 97       	sbiw	r24, 0x0c	; 12
    9bc2:	0f b6       	in	r0, 0x3f	; 63
    9bc4:	f8 94       	cli
    9bc6:	9e bf       	out	0x3e, r25	; 62
    9bc8:	0f be       	out	0x3f, r0	; 63
    9bca:	8d bf       	out	0x3d, r24	; 61
    9bcc:	ed b7       	in	r30, 0x3d	; 61
    9bce:	fe b7       	in	r31, 0x3e	; 62
    9bd0:	31 96       	adiw	r30, 0x01	; 1
    9bd2:	ad b7       	in	r26, 0x3d	; 61
    9bd4:	be b7       	in	r27, 0x3e	; 62
    9bd6:	12 96       	adiw	r26, 0x02	; 2
    9bd8:	1c 93       	st	X, r17
    9bda:	0e 93       	st	-X, r16
    9bdc:	11 97       	sbiw	r26, 0x01	; 1
    9bde:	80 eb       	ldi	r24, 0xB0	; 176
    9be0:	90 e2       	ldi	r25, 0x20	; 32
    9be2:	93 83       	std	Z+3, r25	; 0x03
    9be4:	82 83       	std	Z+2, r24	; 0x02
    9be6:	81 eb       	ldi	r24, 0xB1	; 177
    9be8:	9e e0       	ldi	r25, 0x0E	; 14
    9bea:	95 83       	std	Z+5, r25	; 0x05
    9bec:	84 83       	std	Z+4, r24	; 0x04
    9bee:	8c ee       	ldi	r24, 0xEC	; 236
    9bf0:	99 e0       	ldi	r25, 0x09	; 9
    9bf2:	97 83       	std	Z+7, r25	; 0x07
    9bf4:	86 83       	std	Z+6, r24	; 0x06
    9bf6:	8d ec       	ldi	r24, 0xCD	; 205
    9bf8:	9e e0       	ldi	r25, 0x0E	; 14
    9bfa:	91 87       	std	Z+9, r25	; 0x09
    9bfc:	80 87       	std	Z+8, r24	; 0x08
    9bfe:	81 eb       	ldi	r24, 0xB1	; 177
    9c00:	9d e0       	ldi	r25, 0x0D	; 13
    9c02:	93 87       	std	Z+11, r25	; 0x0b
    9c04:	82 87       	std	Z+10, r24	; 0x0a
    9c06:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    9c0a:	ed b7       	in	r30, 0x3d	; 61
    9c0c:	fe b7       	in	r31, 0x3e	; 62
    9c0e:	3c 96       	adiw	r30, 0x0c	; 12
    9c10:	0f b6       	in	r0, 0x3f	; 63
    9c12:	f8 94       	cli
    9c14:	fe bf       	out	0x3e, r31	; 62
    9c16:	0f be       	out	0x3f, r0	; 63
    9c18:	ed bf       	out	0x3d, r30	; 61
    9c1a:	81 e0       	ldi	r24, 0x01	; 1
    9c1c:	60 e0       	ldi	r22, 0x00	; 0
    9c1e:	a8 01       	movw	r20, r16
    9c20:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s%s"),strApprovalCode,strInvoiceNumber,strDateTime);
    9c24:	8d b7       	in	r24, 0x3d	; 61
    9c26:	9e b7       	in	r25, 0x3e	; 62
    9c28:	0a 97       	sbiw	r24, 0x0a	; 10
    9c2a:	0f b6       	in	r0, 0x3f	; 63
    9c2c:	f8 94       	cli
    9c2e:	9e bf       	out	0x3e, r25	; 62
    9c30:	0f be       	out	0x3f, r0	; 63
    9c32:	8d bf       	out	0x3d, r24	; 61
    9c34:	ed b7       	in	r30, 0x3d	; 61
    9c36:	fe b7       	in	r31, 0x3e	; 62
    9c38:	31 96       	adiw	r30, 0x01	; 1
    9c3a:	ad b7       	in	r26, 0x3d	; 61
    9c3c:	be b7       	in	r27, 0x3e	; 62
    9c3e:	12 96       	adiw	r26, 0x02	; 2
    9c40:	1c 93       	st	X, r17
    9c42:	0e 93       	st	-X, r16
    9c44:	11 97       	sbiw	r26, 0x01	; 1
    9c46:	89 ea       	ldi	r24, 0xA9	; 169
    9c48:	90 e2       	ldi	r25, 0x20	; 32
    9c4a:	93 83       	std	Z+3, r25	; 0x03
    9c4c:	82 83       	std	Z+2, r24	; 0x02
    9c4e:	84 e3       	ldi	r24, 0x34	; 52
    9c50:	9a e0       	ldi	r25, 0x0A	; 10
    9c52:	95 83       	std	Z+5, r25	; 0x05
    9c54:	84 83       	std	Z+4, r24	; 0x04
    9c56:	86 e8       	ldi	r24, 0x86	; 134
    9c58:	99 e0       	ldi	r25, 0x09	; 9
    9c5a:	97 83       	std	Z+7, r25	; 0x07
    9c5c:	86 83       	std	Z+6, r24	; 0x06
    9c5e:	87 ee       	ldi	r24, 0xE7	; 231
    9c60:	9d e0       	ldi	r25, 0x0D	; 13
    9c62:	91 87       	std	Z+9, r25	; 0x09
    9c64:	80 87       	std	Z+8, r24	; 0x08
    9c66:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    9c6a:	ed b7       	in	r30, 0x3d	; 61
    9c6c:	fe b7       	in	r31, 0x3e	; 62
    9c6e:	3a 96       	adiw	r30, 0x0a	; 10
    9c70:	0f b6       	in	r0, 0x3f	; 63
    9c72:	f8 94       	cli
    9c74:	fe bf       	out	0x3e, r31	; 62
    9c76:	0f be       	out	0x3f, r0	; 63
    9c78:	ed bf       	out	0x3d, r30	; 61
    9c7a:	81 e0       	ldi	r24, 0x01	; 1
    9c7c:	60 e0       	ldi	r22, 0x00	; 0
    9c7e:	a8 01       	movw	r20, r16
    9c80:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("E9445512"));
    9c84:	00 d0       	rcall	.+0      	; 0x9c86 <sendMessage92+0x16c>
    9c86:	00 d0       	rcall	.+0      	; 0x9c88 <sendMessage92+0x16e>
    9c88:	ad b7       	in	r26, 0x3d	; 61
    9c8a:	be b7       	in	r27, 0x3e	; 62
    9c8c:	12 96       	adiw	r26, 0x02	; 2
    9c8e:	1c 93       	st	X, r17
    9c90:	0e 93       	st	-X, r16
    9c92:	11 97       	sbiw	r26, 0x01	; 1
    9c94:	80 ea       	ldi	r24, 0xA0	; 160
    9c96:	90 e2       	ldi	r25, 0x20	; 32
    9c98:	14 96       	adiw	r26, 0x04	; 4
    9c9a:	9c 93       	st	X, r25
    9c9c:	8e 93       	st	-X, r24
    9c9e:	13 97       	sbiw	r26, 0x03	; 3
    9ca0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
    9ca4:	0f 90       	pop	r0
    9ca6:	0f 90       	pop	r0
    9ca8:	0f 90       	pop	r0
    9caa:	0f 90       	pop	r0
    9cac:	81 e0       	ldi	r24, 0x01	; 1
    9cae:	60 e0       	ldi	r22, 0x00	; 0
    9cb0:	a8 01       	movw	r20, r16
    9cb2:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	_uart(1, 1,0x02);
    9cb6:	81 e0       	ldi	r24, 0x01	; 1
    9cb8:	61 e0       	ldi	r22, 0x01	; 1
    9cba:	42 e0       	ldi	r20, 0x02	; 2
    9cbc:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
}
    9cc0:	c0 5b       	subi	r28, 0xB0	; 176
    9cc2:	df 4f       	sbci	r29, 0xFF	; 255
    9cc4:	0f b6       	in	r0, 0x3f	; 63
    9cc6:	f8 94       	cli
    9cc8:	de bf       	out	0x3e, r29	; 62
    9cca:	0f be       	out	0x3f, r0	; 63
    9ccc:	cd bf       	out	0x3d, r28	; 61
    9cce:	cf 91       	pop	r28
    9cd0:	df 91       	pop	r29
    9cd2:	1f 91       	pop	r17
    9cd4:	0f 91       	pop	r16
    9cd6:	08 95       	ret

00009cd8 <sendMessage90>:
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage90(){
    9cd8:	0f 93       	push	r16
    9cda:	1f 93       	push	r17
    9cdc:	df 93       	push	r29
    9cde:	cf 93       	push	r28
    9ce0:	cd b7       	in	r28, 0x3d	; 61
    9ce2:	de b7       	in	r29, 0x3e	; 62
    9ce4:	c0 55       	subi	r28, 0x50	; 80
    9ce6:	d0 40       	sbci	r29, 0x00	; 0
    9ce8:	0f b6       	in	r0, 0x3f	; 63
    9cea:	f8 94       	cli
    9cec:	de bf       	out	0x3e, r29	; 62
    9cee:	0f be       	out	0x3f, r0	; 63
    9cf0:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9cf2:	81 e0       	ldi	r24, 0x01	; 1
    9cf4:	61 e0       	ldi	r22, 0x01	; 1
    9cf6:	41 e0       	ldi	r20, 0x01	; 1
    9cf8:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9cfc:	0e 94 f0 1b 	call	0x37e0	; 0x37e0 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9d00:	0e 94 c5 1b 	call	0x378a	; 0x378a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9d04:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9d08:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s90"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9d0c:	8d b7       	in	r24, 0x3d	; 61
    9d0e:	9e b7       	in	r25, 0x3e	; 62
    9d10:	0c 97       	sbiw	r24, 0x0c	; 12
    9d12:	0f b6       	in	r0, 0x3f	; 63
    9d14:	f8 94       	cli
    9d16:	9e bf       	out	0x3e, r25	; 62
    9d18:	0f be       	out	0x3f, r0	; 63
    9d1a:	8d bf       	out	0x3d, r24	; 61
    9d1c:	ed b7       	in	r30, 0x3d	; 61
    9d1e:	fe b7       	in	r31, 0x3e	; 62
    9d20:	31 96       	adiw	r30, 0x01	; 1
    9d22:	8e 01       	movw	r16, r28
    9d24:	0f 5f       	subi	r16, 0xFF	; 255
    9d26:	1f 4f       	sbci	r17, 0xFF	; 255
    9d28:	ad b7       	in	r26, 0x3d	; 61
    9d2a:	be b7       	in	r27, 0x3e	; 62
    9d2c:	12 96       	adiw	r26, 0x02	; 2
    9d2e:	1c 93       	st	X, r17
    9d30:	0e 93       	st	-X, r16
    9d32:	11 97       	sbiw	r26, 0x01	; 1
    9d34:	82 ed       	ldi	r24, 0xD2	; 210
    9d36:	90 e2       	ldi	r25, 0x20	; 32
    9d38:	93 83       	std	Z+3, r25	; 0x03
    9d3a:	82 83       	std	Z+2, r24	; 0x02
    9d3c:	8c e1       	ldi	r24, 0x1C	; 28
    9d3e:	96 e0       	ldi	r25, 0x06	; 6
    9d40:	95 83       	std	Z+5, r25	; 0x05
    9d42:	84 83       	std	Z+4, r24	; 0x04
    9d44:	8b ef       	ldi	r24, 0xFB	; 251
    9d46:	9d e0       	ldi	r25, 0x0D	; 13
    9d48:	97 83       	std	Z+7, r25	; 0x07
    9d4a:	86 83       	std	Z+6, r24	; 0x06
    9d4c:	8e e0       	ldi	r24, 0x0E	; 14
    9d4e:	9a e0       	ldi	r25, 0x0A	; 10
    9d50:	91 87       	std	Z+9, r25	; 0x09
    9d52:	80 87       	std	Z+8, r24	; 0x08
    9d54:	8b e3       	ldi	r24, 0x3B	; 59
    9d56:	9a e0       	ldi	r25, 0x0A	; 10
    9d58:	93 87       	std	Z+11, r25	; 0x0b
    9d5a:	82 87       	std	Z+10, r24	; 0x0a
    9d5c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    9d60:	ed b7       	in	r30, 0x3d	; 61
    9d62:	fe b7       	in	r31, 0x3e	; 62
    9d64:	3c 96       	adiw	r30, 0x0c	; 12
    9d66:	0f b6       	in	r0, 0x3f	; 63
    9d68:	f8 94       	cli
    9d6a:	fe bf       	out	0x3e, r31	; 62
    9d6c:	0f be       	out	0x3f, r0	; 63
    9d6e:	ed bf       	out	0x3d, r30	; 61
    9d70:	81 e0       	ldi	r24, 0x01	; 1
    9d72:	60 e0       	ldi	r22, 0x00	; 0
    9d74:	a8 01       	movw	r20, r16
    9d76:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strRef1);
    9d7a:	8d b7       	in	r24, 0x3d	; 61
    9d7c:	9e b7       	in	r25, 0x3e	; 62
    9d7e:	08 97       	sbiw	r24, 0x08	; 8
    9d80:	0f b6       	in	r0, 0x3f	; 63
    9d82:	f8 94       	cli
    9d84:	9e bf       	out	0x3e, r25	; 62
    9d86:	0f be       	out	0x3f, r0	; 63
    9d88:	8d bf       	out	0x3d, r24	; 61
    9d8a:	ed b7       	in	r30, 0x3d	; 61
    9d8c:	fe b7       	in	r31, 0x3e	; 62
    9d8e:	31 96       	adiw	r30, 0x01	; 1
    9d90:	ad b7       	in	r26, 0x3d	; 61
    9d92:	be b7       	in	r27, 0x3e	; 62
    9d94:	12 96       	adiw	r26, 0x02	; 2
    9d96:	1c 93       	st	X, r17
    9d98:	0e 93       	st	-X, r16
    9d9a:	11 97       	sbiw	r26, 0x01	; 1
    9d9c:	8d ec       	ldi	r24, 0xCD	; 205
    9d9e:	90 e2       	ldi	r25, 0x20	; 32
    9da0:	93 83       	std	Z+3, r25	; 0x03
    9da2:	82 83       	std	Z+2, r24	; 0x02
    9da4:	8c ee       	ldi	r24, 0xEC	; 236
    9da6:	99 e0       	ldi	r25, 0x09	; 9
    9da8:	95 83       	std	Z+5, r25	; 0x05
    9daa:	84 83       	std	Z+4, r24	; 0x04
    9dac:	88 eb       	ldi	r24, 0xB8	; 184
    9dae:	9e e0       	ldi	r25, 0x0E	; 14
    9db0:	97 83       	std	Z+7, r25	; 0x07
    9db2:	86 83       	std	Z+6, r24	; 0x06
    9db4:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    9db8:	ed b7       	in	r30, 0x3d	; 61
    9dba:	fe b7       	in	r31, 0x3e	; 62
    9dbc:	38 96       	adiw	r30, 0x08	; 8
    9dbe:	0f b6       	in	r0, 0x3f	; 63
    9dc0:	f8 94       	cli
    9dc2:	fe bf       	out	0x3e, r31	; 62
    9dc4:	0f be       	out	0x3f, r0	; 63
    9dc6:	ed bf       	out	0x3d, r30	; 61
    9dc8:	81 e0       	ldi	r24, 0x01	; 1
    9dca:	60 e0       	ldi	r22, 0x00	; 0
    9dcc:	a8 01       	movw	r20, r16
    9dce:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	sprintf_P(strSend,PSTR("E9445512"));
    9dd2:	00 d0       	rcall	.+0      	; 0x9dd4 <sendMessage90+0xfc>
    9dd4:	00 d0       	rcall	.+0      	; 0x9dd6 <sendMessage90+0xfe>
    9dd6:	ad b7       	in	r26, 0x3d	; 61
    9dd8:	be b7       	in	r27, 0x3e	; 62
    9dda:	12 96       	adiw	r26, 0x02	; 2
    9ddc:	1c 93       	st	X, r17
    9dde:	0e 93       	st	-X, r16
    9de0:	11 97       	sbiw	r26, 0x01	; 1
    9de2:	84 ec       	ldi	r24, 0xC4	; 196
    9de4:	90 e2       	ldi	r25, 0x20	; 32
    9de6:	14 96       	adiw	r26, 0x04	; 4
    9de8:	9c 93       	st	X, r25
    9dea:	8e 93       	st	-X, r24
    9dec:	13 97       	sbiw	r26, 0x03	; 3
    9dee:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    9df2:	0f 90       	pop	r0
    9df4:	0f 90       	pop	r0
    9df6:	0f 90       	pop	r0
    9df8:	0f 90       	pop	r0
    9dfa:	81 e0       	ldi	r24, 0x01	; 1
    9dfc:	60 e0       	ldi	r22, 0x00	; 0
    9dfe:	a8 01       	movw	r20, r16
    9e00:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	_uart(1, 1,0x02);
    9e04:	81 e0       	ldi	r24, 0x01	; 1
    9e06:	61 e0       	ldi	r22, 0x01	; 1
    9e08:	42 e0       	ldi	r20, 0x02	; 2
    9e0a:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
}
    9e0e:	c0 5b       	subi	r28, 0xB0	; 176
    9e10:	df 4f       	sbci	r29, 0xFF	; 255
    9e12:	0f b6       	in	r0, 0x3f	; 63
    9e14:	f8 94       	cli
    9e16:	de bf       	out	0x3e, r29	; 62
    9e18:	0f be       	out	0x3f, r0	; 63
    9e1a:	cd bf       	out	0x3d, r28	; 61
    9e1c:	cf 91       	pop	r28
    9e1e:	df 91       	pop	r29
    9e20:	1f 91       	pop	r17
    9e22:	0f 91       	pop	r16
    9e24:	08 95       	ret

00009e26 <sendMessage58>:

	_uart_printf(1,0,PSTR("AF968CFFB"));
	_uart(1, 1,0x02);
}

void sendMessage58(){
    9e26:	cf 92       	push	r12
    9e28:	df 92       	push	r13
    9e2a:	ef 92       	push	r14
    9e2c:	ff 92       	push	r15
    9e2e:	0f 93       	push	r16
    9e30:	1f 93       	push	r17
    9e32:	df 93       	push	r29
    9e34:	cf 93       	push	r28
    9e36:	cd b7       	in	r28, 0x3d	; 61
    9e38:	de b7       	in	r29, 0x3e	; 62
    9e3a:	c0 55       	subi	r28, 0x50	; 80
    9e3c:	d0 40       	sbci	r29, 0x00	; 0
    9e3e:	0f b6       	in	r0, 0x3f	; 63
    9e40:	f8 94       	cli
    9e42:	de bf       	out	0x3e, r29	; 62
    9e44:	0f be       	out	0x3f, r0	; 63
    9e46:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9e48:	81 e0       	ldi	r24, 0x01	; 1
    9e4a:	61 e0       	ldi	r22, 0x01	; 1
    9e4c:	41 e0       	ldi	r20, 0x01	; 1
    9e4e:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9e52:	0e 94 f0 1b 	call	0x37e0	; 0x37e0 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9e56:	0e 94 c5 1b 	call	0x378a	; 0x378a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9e5a:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9e5e:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateServerIP>
	UpdateCardID();  //ReadCardID
    9e62:	0e 94 ce 3c 	call	0x799c	; 0x799c <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%s%s%s58"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9e66:	8d b7       	in	r24, 0x3d	; 61
    9e68:	9e b7       	in	r25, 0x3e	; 62
    9e6a:	0c 97       	sbiw	r24, 0x0c	; 12
    9e6c:	0f b6       	in	r0, 0x3f	; 63
    9e6e:	f8 94       	cli
    9e70:	9e bf       	out	0x3e, r25	; 62
    9e72:	0f be       	out	0x3f, r0	; 63
    9e74:	8d bf       	out	0x3d, r24	; 61
    9e76:	ed b7       	in	r30, 0x3d	; 61
    9e78:	fe b7       	in	r31, 0x3e	; 62
    9e7a:	31 96       	adiw	r30, 0x01	; 1
    9e7c:	8e 01       	movw	r16, r28
    9e7e:	0f 5f       	subi	r16, 0xFF	; 255
    9e80:	1f 4f       	sbci	r17, 0xFF	; 255
    9e82:	ad b7       	in	r26, 0x3d	; 61
    9e84:	be b7       	in	r27, 0x3e	; 62
    9e86:	12 96       	adiw	r26, 0x02	; 2
    9e88:	1c 93       	st	X, r17
    9e8a:	0e 93       	st	-X, r16
    9e8c:	11 97       	sbiw	r26, 0x01	; 1
    9e8e:	89 e0       	ldi	r24, 0x09	; 9
    9e90:	91 e2       	ldi	r25, 0x21	; 33
    9e92:	93 83       	std	Z+3, r25	; 0x03
    9e94:	82 83       	std	Z+2, r24	; 0x02
    9e96:	8c e1       	ldi	r24, 0x1C	; 28
    9e98:	96 e0       	ldi	r25, 0x06	; 6
    9e9a:	95 83       	std	Z+5, r25	; 0x05
    9e9c:	84 83       	std	Z+4, r24	; 0x04
    9e9e:	8b ef       	ldi	r24, 0xFB	; 251
    9ea0:	9d e0       	ldi	r25, 0x0D	; 13
    9ea2:	97 83       	std	Z+7, r25	; 0x07
    9ea4:	86 83       	std	Z+6, r24	; 0x06
    9ea6:	8e e0       	ldi	r24, 0x0E	; 14
    9ea8:	9a e0       	ldi	r25, 0x0A	; 10
    9eaa:	91 87       	std	Z+9, r25	; 0x09
    9eac:	80 87       	std	Z+8, r24	; 0x08
    9eae:	8b e3       	ldi	r24, 0x3B	; 59
    9eb0:	9a e0       	ldi	r25, 0x0A	; 10
    9eb2:	93 87       	std	Z+11, r25	; 0x0b
    9eb4:	82 87       	std	Z+10, r24	; 0x0a
    9eb6:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    9eba:	8d b7       	in	r24, 0x3d	; 61
    9ebc:	9e b7       	in	r25, 0x3e	; 62
    9ebe:	0c 96       	adiw	r24, 0x0c	; 12
    9ec0:	0f b6       	in	r0, 0x3f	; 63
    9ec2:	f8 94       	cli
    9ec4:	9e bf       	out	0x3e, r25	; 62
    9ec6:	0f be       	out	0x3f, r0	; 63
    9ec8:	8d bf       	out	0x3d, r24	; 61
    9eca:	81 e0       	ldi	r24, 0x01	; 1
    9ecc:	60 e0       	ldi	r22, 0x00	; 0
    9ece:	a8 01       	movw	r20, r16
    9ed0:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	AddSpaceLead(strBalanceValue,13);
    9ed4:	fa e4       	ldi	r31, 0x4A	; 74
    9ed6:	ef 2e       	mov	r14, r31
    9ed8:	fe e0       	ldi	r31, 0x0E	; 14
    9eda:	ff 2e       	mov	r15, r31
    9edc:	c7 01       	movw	r24, r14
    9ede:	6d e0       	ldi	r22, 0x0D	; 13
    9ee0:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <AddSpaceLead>
	AddSpaceLead(strOdometer,10);
    9ee4:	e3 ef       	ldi	r30, 0xF3	; 243
    9ee6:	ce 2e       	mov	r12, r30
    9ee8:	e5 e0       	ldi	r30, 0x05	; 5
    9eea:	de 2e       	mov	r13, r30
    9eec:	c6 01       	movw	r24, r12
    9eee:	6a e0       	ldi	r22, 0x0A	; 10
    9ef0:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <AddSpaceLead>
	sprintf_P(strSend,PSTR("%s%s%d%s%s"),strCardID,strFIP_ID,NozzleID,strBalanceType,strBalanceValue);
    9ef4:	ad b7       	in	r26, 0x3d	; 61
    9ef6:	be b7       	in	r27, 0x3e	; 62
    9ef8:	1e 97       	sbiw	r26, 0x0e	; 14
    9efa:	0f b6       	in	r0, 0x3f	; 63
    9efc:	f8 94       	cli
    9efe:	be bf       	out	0x3e, r27	; 62
    9f00:	0f be       	out	0x3f, r0	; 63
    9f02:	ad bf       	out	0x3d, r26	; 61
    9f04:	ed b7       	in	r30, 0x3d	; 61
    9f06:	fe b7       	in	r31, 0x3e	; 62
    9f08:	31 96       	adiw	r30, 0x01	; 1
    9f0a:	12 96       	adiw	r26, 0x02	; 2
    9f0c:	1c 93       	st	X, r17
    9f0e:	0e 93       	st	-X, r16
    9f10:	11 97       	sbiw	r26, 0x01	; 1
    9f12:	8e ef       	ldi	r24, 0xFE	; 254
    9f14:	90 e2       	ldi	r25, 0x20	; 32
    9f16:	93 83       	std	Z+3, r25	; 0x03
    9f18:	82 83       	std	Z+2, r24	; 0x02
    9f1a:	81 eb       	ldi	r24, 0xB1	; 177
    9f1c:	9d e0       	ldi	r25, 0x0D	; 13
    9f1e:	95 83       	std	Z+5, r25	; 0x05
    9f20:	84 83       	std	Z+4, r24	; 0x04
    9f22:	8c ee       	ldi	r24, 0xEC	; 236
    9f24:	99 e0       	ldi	r25, 0x09	; 9
    9f26:	97 83       	std	Z+7, r25	; 0x07
    9f28:	86 83       	std	Z+6, r24	; 0x06
    9f2a:	80 91 a0 09 	lds	r24, 0x09A0
    9f2e:	80 87       	std	Z+8, r24	; 0x08
    9f30:	11 86       	std	Z+9, r1	; 0x09
    9f32:	83 ed       	ldi	r24, 0xD3	; 211
    9f34:	95 e0       	ldi	r25, 0x05	; 5
    9f36:	93 87       	std	Z+11, r25	; 0x0b
    9f38:	82 87       	std	Z+10, r24	; 0x0a
    9f3a:	f5 86       	std	Z+13, r15	; 0x0d
    9f3c:	e4 86       	std	Z+12, r14	; 0x0c
    9f3e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    9f42:	8d b7       	in	r24, 0x3d	; 61
    9f44:	9e b7       	in	r25, 0x3e	; 62
    9f46:	0e 96       	adiw	r24, 0x0e	; 14
    9f48:	0f b6       	in	r0, 0x3f	; 63
    9f4a:	f8 94       	cli
    9f4c:	9e bf       	out	0x3e, r25	; 62
    9f4e:	0f be       	out	0x3f, r0	; 63
    9f50:	8d bf       	out	0x3d, r24	; 61
    9f52:	81 e0       	ldi	r24, 0x01	; 1
    9f54:	60 e0       	ldi	r22, 0x00	; 0
    9f56:	a8 01       	movw	r20, r16
    9f58:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>

	CardType=0;
    9f5c:	10 92 b9 05 	sts	0x05B9, r1
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    9f60:	ad b7       	in	r26, 0x3d	; 61
    9f62:	be b7       	in	r27, 0x3e	; 62
    9f64:	18 97       	sbiw	r26, 0x08	; 8
    9f66:	0f b6       	in	r0, 0x3f	; 63
    9f68:	f8 94       	cli
    9f6a:	be bf       	out	0x3e, r27	; 62
    9f6c:	0f be       	out	0x3f, r0	; 63
    9f6e:	ad bf       	out	0x3d, r26	; 61
    9f70:	ed b7       	in	r30, 0x3d	; 61
    9f72:	fe b7       	in	r31, 0x3e	; 62
    9f74:	31 96       	adiw	r30, 0x01	; 1
    9f76:	12 96       	adiw	r26, 0x02	; 2
    9f78:	1c 93       	st	X, r17
    9f7a:	0e 93       	st	-X, r16
    9f7c:	11 97       	sbiw	r26, 0x01	; 1
    9f7e:	8d ed       	ldi	r24, 0xDD	; 221
    9f80:	90 e2       	ldi	r25, 0x20	; 32
    9f82:	93 83       	std	Z+3, r25	; 0x03
    9f84:	82 83       	std	Z+2, r24	; 0x02
    9f86:	15 82       	std	Z+5, r1	; 0x05
    9f88:	14 82       	std	Z+4, r1	; 0x04
    9f8a:	d7 82       	std	Z+7, r13	; 0x07
    9f8c:	c6 82       	std	Z+6, r12	; 0x06
    9f8e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    9f92:	8d b7       	in	r24, 0x3d	; 61
    9f94:	9e b7       	in	r25, 0x3e	; 62
    9f96:	08 96       	adiw	r24, 0x08	; 8
    9f98:	0f b6       	in	r0, 0x3f	; 63
    9f9a:	f8 94       	cli
    9f9c:	9e bf       	out	0x3e, r25	; 62
    9f9e:	0f be       	out	0x3f, r0	; 63
    9fa0:	8d bf       	out	0x3d, r24	; 61
    9fa2:	81 e0       	ldi	r24, 0x01	; 1
    9fa4:	60 e0       	ldi	r22, 0x00	; 0
    9fa6:	a8 01       	movw	r20, r16
    9fa8:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	_uart(1, 1,0x02);
    9fac:	81 e0       	ldi	r24, 0x01	; 1
    9fae:	61 e0       	ldi	r22, 0x01	; 1
    9fb0:	42 e0       	ldi	r20, 0x02	; 2
    9fb2:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
}
    9fb6:	c0 5b       	subi	r28, 0xB0	; 176
    9fb8:	df 4f       	sbci	r29, 0xFF	; 255
    9fba:	0f b6       	in	r0, 0x3f	; 63
    9fbc:	f8 94       	cli
    9fbe:	de bf       	out	0x3e, r29	; 62
    9fc0:	0f be       	out	0x3f, r0	; 63
    9fc2:	cd bf       	out	0x3d, r28	; 61
    9fc4:	cf 91       	pop	r28
    9fc6:	df 91       	pop	r29
    9fc8:	1f 91       	pop	r17
    9fca:	0f 91       	pop	r16
    9fcc:	ff 90       	pop	r15
    9fce:	ef 90       	pop	r14
    9fd0:	df 90       	pop	r13
    9fd2:	cf 90       	pop	r12
    9fd4:	08 95       	ret

00009fd6 <sendMessage32>:
	_uart(1, 1,0x02);
}



void sendMessage32(){//Msg32: <01>[ID][Seq][SrcIP][DestIP][MsgCode][FIP][PaymentType][Ref1][Ref2][Ref3][Ref4]<02>
    9fd6:	0f 93       	push	r16
    9fd8:	1f 93       	push	r17
    9fda:	df 93       	push	r29
    9fdc:	cf 93       	push	r28
    9fde:	cd b7       	in	r28, 0x3d	; 61
    9fe0:	de b7       	in	r29, 0x3e	; 62
    9fe2:	c0 55       	subi	r28, 0x50	; 80
    9fe4:	d0 40       	sbci	r29, 0x00	; 0
    9fe6:	0f b6       	in	r0, 0x3f	; 63
    9fe8:	f8 94       	cli
    9fea:	de bf       	out	0x3e, r29	; 62
    9fec:	0f be       	out	0x3f, r0	; 63
    9fee:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	UpdateIFT_ID(); //ReadIFT_ID
    9ff0:	0e 94 f0 1b 	call	0x37e0	; 0x37e0 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9ff4:	0e 94 c5 1b 	call	0x378a	; 0x378a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9ff8:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9ffc:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateServerIP>
	_uart(1, 1,0x01);
    a000:	81 e0       	ldi	r24, 0x01	; 1
    a002:	61 e0       	ldi	r22, 0x01	; 1
    a004:	41 e0       	ldi	r20, 0x01	; 1
    a006:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	sprintf_P(strSend,PSTR("%s%s%s%s32"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a00a:	8d b7       	in	r24, 0x3d	; 61
    a00c:	9e b7       	in	r25, 0x3e	; 62
    a00e:	0c 97       	sbiw	r24, 0x0c	; 12
    a010:	0f b6       	in	r0, 0x3f	; 63
    a012:	f8 94       	cli
    a014:	9e bf       	out	0x3e, r25	; 62
    a016:	0f be       	out	0x3f, r0	; 63
    a018:	8d bf       	out	0x3d, r24	; 61
    a01a:	ed b7       	in	r30, 0x3d	; 61
    a01c:	fe b7       	in	r31, 0x3e	; 62
    a01e:	31 96       	adiw	r30, 0x01	; 1
    a020:	8e 01       	movw	r16, r28
    a022:	0f 5f       	subi	r16, 0xFF	; 255
    a024:	1f 4f       	sbci	r17, 0xFF	; 255
    a026:	ad b7       	in	r26, 0x3d	; 61
    a028:	be b7       	in	r27, 0x3e	; 62
    a02a:	12 96       	adiw	r26, 0x02	; 2
    a02c:	1c 93       	st	X, r17
    a02e:	0e 93       	st	-X, r16
    a030:	11 97       	sbiw	r26, 0x01	; 1
    a032:	84 e4       	ldi	r24, 0x44	; 68
    a034:	91 e2       	ldi	r25, 0x21	; 33
    a036:	93 83       	std	Z+3, r25	; 0x03
    a038:	82 83       	std	Z+2, r24	; 0x02
    a03a:	8c e1       	ldi	r24, 0x1C	; 28
    a03c:	96 e0       	ldi	r25, 0x06	; 6
    a03e:	95 83       	std	Z+5, r25	; 0x05
    a040:	84 83       	std	Z+4, r24	; 0x04
    a042:	8b ef       	ldi	r24, 0xFB	; 251
    a044:	9d e0       	ldi	r25, 0x0D	; 13
    a046:	97 83       	std	Z+7, r25	; 0x07
    a048:	86 83       	std	Z+6, r24	; 0x06
    a04a:	8e e0       	ldi	r24, 0x0E	; 14
    a04c:	9a e0       	ldi	r25, 0x0A	; 10
    a04e:	91 87       	std	Z+9, r25	; 0x09
    a050:	80 87       	std	Z+8, r24	; 0x08
    a052:	8b e3       	ldi	r24, 0x3B	; 59
    a054:	9a e0       	ldi	r25, 0x0A	; 10
    a056:	93 87       	std	Z+11, r25	; 0x0b
    a058:	82 87       	std	Z+10, r24	; 0x0a
    a05a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    a05e:	ed b7       	in	r30, 0x3d	; 61
    a060:	fe b7       	in	r31, 0x3e	; 62
    a062:	3c 96       	adiw	r30, 0x0c	; 12
    a064:	0f b6       	in	r0, 0x3f	; 63
    a066:	f8 94       	cli
    a068:	fe bf       	out	0x3e, r31	; 62
    a06a:	0f be       	out	0x3f, r0	; 63
    a06c:	ed bf       	out	0x3d, r30	; 61
    a06e:	81 e0       	ldi	r24, 0x01	; 1
    a070:	60 e0       	ldi	r22, 0x00	; 0
    a072:	a8 01       	movw	r20, r16
    a074:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s%s%s"),strFIP_ID,strPaymentType,strRef1,strRef2);
    a078:	8d b7       	in	r24, 0x3d	; 61
    a07a:	9e b7       	in	r25, 0x3e	; 62
    a07c:	0c 97       	sbiw	r24, 0x0c	; 12
    a07e:	0f b6       	in	r0, 0x3f	; 63
    a080:	f8 94       	cli
    a082:	9e bf       	out	0x3e, r25	; 62
    a084:	0f be       	out	0x3f, r0	; 63
    a086:	8d bf       	out	0x3d, r24	; 61
    a088:	ed b7       	in	r30, 0x3d	; 61
    a08a:	fe b7       	in	r31, 0x3e	; 62
    a08c:	31 96       	adiw	r30, 0x01	; 1
    a08e:	ad b7       	in	r26, 0x3d	; 61
    a090:	be b7       	in	r27, 0x3e	; 62
    a092:	12 96       	adiw	r26, 0x02	; 2
    a094:	1c 93       	st	X, r17
    a096:	0e 93       	st	-X, r16
    a098:	11 97       	sbiw	r26, 0x01	; 1
    a09a:	8b e3       	ldi	r24, 0x3B	; 59
    a09c:	91 e2       	ldi	r25, 0x21	; 33
    a09e:	93 83       	std	Z+3, r25	; 0x03
    a0a0:	82 83       	std	Z+2, r24	; 0x02
    a0a2:	8c ee       	ldi	r24, 0xEC	; 236
    a0a4:	99 e0       	ldi	r25, 0x09	; 9
    a0a6:	95 83       	std	Z+5, r25	; 0x05
    a0a8:	84 83       	std	Z+4, r24	; 0x04
    a0aa:	83 e8       	ldi	r24, 0x83	; 131
    a0ac:	99 e0       	ldi	r25, 0x09	; 9
    a0ae:	97 83       	std	Z+7, r25	; 0x07
    a0b0:	86 83       	std	Z+6, r24	; 0x06
    a0b2:	88 eb       	ldi	r24, 0xB8	; 184
    a0b4:	9e e0       	ldi	r25, 0x0E	; 14
    a0b6:	91 87       	std	Z+9, r25	; 0x09
    a0b8:	80 87       	std	Z+8, r24	; 0x08
    a0ba:	86 ec       	ldi	r24, 0xC6	; 198
    a0bc:	9d e0       	ldi	r25, 0x0D	; 13
    a0be:	93 87       	std	Z+11, r25	; 0x0b
    a0c0:	82 87       	std	Z+10, r24	; 0x0a
    a0c2:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    a0c6:	ed b7       	in	r30, 0x3d	; 61
    a0c8:	fe b7       	in	r31, 0x3e	; 62
    a0ca:	3c 96       	adiw	r30, 0x0c	; 12
    a0cc:	0f b6       	in	r0, 0x3f	; 63
    a0ce:	f8 94       	cli
    a0d0:	fe bf       	out	0x3e, r31	; 62
    a0d2:	0f be       	out	0x3f, r0	; 63
    a0d4:	ed bf       	out	0x3d, r30	; 61
    a0d6:	81 e0       	ldi	r24, 0x01	; 1
    a0d8:	60 e0       	ldi	r22, 0x00	; 0
    a0da:	a8 01       	movw	r20, r16
    a0dc:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s"),strRef3,strRef4);
    a0e0:	8d b7       	in	r24, 0x3d	; 61
    a0e2:	9e b7       	in	r25, 0x3e	; 62
    a0e4:	08 97       	sbiw	r24, 0x08	; 8
    a0e6:	0f b6       	in	r0, 0x3f	; 63
    a0e8:	f8 94       	cli
    a0ea:	9e bf       	out	0x3e, r25	; 62
    a0ec:	0f be       	out	0x3f, r0	; 63
    a0ee:	8d bf       	out	0x3d, r24	; 61
    a0f0:	ed b7       	in	r30, 0x3d	; 61
    a0f2:	fe b7       	in	r31, 0x3e	; 62
    a0f4:	31 96       	adiw	r30, 0x01	; 1
    a0f6:	ad b7       	in	r26, 0x3d	; 61
    a0f8:	be b7       	in	r27, 0x3e	; 62
    a0fa:	12 96       	adiw	r26, 0x02	; 2
    a0fc:	1c 93       	st	X, r17
    a0fe:	0e 93       	st	-X, r16
    a100:	11 97       	sbiw	r26, 0x01	; 1
    a102:	86 e3       	ldi	r24, 0x36	; 54
    a104:	91 e2       	ldi	r25, 0x21	; 33
    a106:	93 83       	std	Z+3, r25	; 0x03
    a108:	82 83       	std	Z+2, r24	; 0x02
    a10a:	82 ed       	ldi	r24, 0xD2	; 210
    a10c:	9a e0       	ldi	r25, 0x0A	; 10
    a10e:	95 83       	std	Z+5, r25	; 0x05
    a110:	84 83       	std	Z+4, r24	; 0x04
    a112:	85 ed       	ldi	r24, 0xD5	; 213
    a114:	95 e0       	ldi	r25, 0x05	; 5
    a116:	97 83       	std	Z+7, r25	; 0x07
    a118:	86 83       	std	Z+6, r24	; 0x06
    a11a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    a11e:	ed b7       	in	r30, 0x3d	; 61
    a120:	fe b7       	in	r31, 0x3e	; 62
    a122:	38 96       	adiw	r30, 0x08	; 8
    a124:	0f b6       	in	r0, 0x3f	; 63
    a126:	f8 94       	cli
    a128:	fe bf       	out	0x3e, r31	; 62
    a12a:	0f be       	out	0x3f, r0	; 63
    a12c:	ed bf       	out	0x3d, r30	; 61
    a12e:	81 e0       	ldi	r24, 0x01	; 1
    a130:	60 e0       	ldi	r22, 0x00	; 0
    a132:	a8 01       	movw	r20, r16
    a134:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	sprintf_P(strSend,PSTR("F968CFFB"));
    a138:	00 d0       	rcall	.+0      	; 0xa13a <sendMessage32+0x164>
    a13a:	00 d0       	rcall	.+0      	; 0xa13c <sendMessage32+0x166>
    a13c:	ad b7       	in	r26, 0x3d	; 61
    a13e:	be b7       	in	r27, 0x3e	; 62
    a140:	12 96       	adiw	r26, 0x02	; 2
    a142:	1c 93       	st	X, r17
    a144:	0e 93       	st	-X, r16
    a146:	11 97       	sbiw	r26, 0x01	; 1
    a148:	8d e2       	ldi	r24, 0x2D	; 45
    a14a:	91 e2       	ldi	r25, 0x21	; 33
    a14c:	14 96       	adiw	r26, 0x04	; 4
    a14e:	9c 93       	st	X, r25
    a150:	8e 93       	st	-X, r24
    a152:	13 97       	sbiw	r26, 0x03	; 3
    a154:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    a158:	0f 90       	pop	r0
    a15a:	0f 90       	pop	r0
    a15c:	0f 90       	pop	r0
    a15e:	0f 90       	pop	r0
    a160:	81 e0       	ldi	r24, 0x01	; 1
    a162:	60 e0       	ldi	r22, 0x00	; 0
    a164:	a8 01       	movw	r20, r16
    a166:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	_uart(1, 1,0x02);
    a16a:	81 e0       	ldi	r24, 0x01	; 1
    a16c:	61 e0       	ldi	r22, 0x01	; 1
    a16e:	42 e0       	ldi	r20, 0x02	; 2
    a170:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>

}
    a174:	c0 5b       	subi	r28, 0xB0	; 176
    a176:	df 4f       	sbci	r29, 0xFF	; 255
    a178:	0f b6       	in	r0, 0x3f	; 63
    a17a:	f8 94       	cli
    a17c:	de bf       	out	0x3e, r29	; 62
    a17e:	0f be       	out	0x3f, r0	; 63
    a180:	cd bf       	out	0x3d, r28	; 61
    a182:	cf 91       	pop	r28
    a184:	df 91       	pop	r29
    a186:	1f 91       	pop	r17
    a188:	0f 91       	pop	r16
    a18a:	08 95       	ret

0000a18c <sendMessage28>:
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage28(){//Msg28: <01>[0103192.168.016.070192.168.016.18024[FIP][CardID]F968CFFB]<02>
    a18c:	0f 93       	push	r16
    a18e:	1f 93       	push	r17
    a190:	df 93       	push	r29
    a192:	cf 93       	push	r28
    a194:	cd b7       	in	r28, 0x3d	; 61
    a196:	de b7       	in	r29, 0x3e	; 62
    a198:	ec 97       	sbiw	r28, 0x3c	; 60
    a19a:	0f b6       	in	r0, 0x3f	; 63
    a19c:	f8 94       	cli
    a19e:	de bf       	out	0x3e, r29	; 62
    a1a0:	0f be       	out	0x3f, r0	; 63
    a1a2:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a1a4:	81 e0       	ldi	r24, 0x01	; 1
    a1a6:	61 e0       	ldi	r22, 0x01	; 1
    a1a8:	41 e0       	ldi	r20, 0x01	; 1
    a1aa:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a1ae:	0e 94 f0 1b 	call	0x37e0	; 0x37e0 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a1b2:	0e 94 c5 1b 	call	0x378a	; 0x378a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a1b6:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a1ba:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s28"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a1be:	8d b7       	in	r24, 0x3d	; 61
    a1c0:	9e b7       	in	r25, 0x3e	; 62
    a1c2:	0c 97       	sbiw	r24, 0x0c	; 12
    a1c4:	0f b6       	in	r0, 0x3f	; 63
    a1c6:	f8 94       	cli
    a1c8:	9e bf       	out	0x3e, r25	; 62
    a1ca:	0f be       	out	0x3f, r0	; 63
    a1cc:	8d bf       	out	0x3d, r24	; 61
    a1ce:	ed b7       	in	r30, 0x3d	; 61
    a1d0:	fe b7       	in	r31, 0x3e	; 62
    a1d2:	31 96       	adiw	r30, 0x01	; 1
    a1d4:	8e 01       	movw	r16, r28
    a1d6:	0f 5f       	subi	r16, 0xFF	; 255
    a1d8:	1f 4f       	sbci	r17, 0xFF	; 255
    a1da:	ad b7       	in	r26, 0x3d	; 61
    a1dc:	be b7       	in	r27, 0x3e	; 62
    a1de:	12 96       	adiw	r26, 0x02	; 2
    a1e0:	1c 93       	st	X, r17
    a1e2:	0e 93       	st	-X, r16
    a1e4:	11 97       	sbiw	r26, 0x01	; 1
    a1e6:	8c e5       	ldi	r24, 0x5C	; 92
    a1e8:	91 e2       	ldi	r25, 0x21	; 33
    a1ea:	93 83       	std	Z+3, r25	; 0x03
    a1ec:	82 83       	std	Z+2, r24	; 0x02
    a1ee:	8c e1       	ldi	r24, 0x1C	; 28
    a1f0:	96 e0       	ldi	r25, 0x06	; 6
    a1f2:	95 83       	std	Z+5, r25	; 0x05
    a1f4:	84 83       	std	Z+4, r24	; 0x04
    a1f6:	8b ef       	ldi	r24, 0xFB	; 251
    a1f8:	9d e0       	ldi	r25, 0x0D	; 13
    a1fa:	97 83       	std	Z+7, r25	; 0x07
    a1fc:	86 83       	std	Z+6, r24	; 0x06
    a1fe:	8e e0       	ldi	r24, 0x0E	; 14
    a200:	9a e0       	ldi	r25, 0x0A	; 10
    a202:	91 87       	std	Z+9, r25	; 0x09
    a204:	80 87       	std	Z+8, r24	; 0x08
    a206:	8b e3       	ldi	r24, 0x3B	; 59
    a208:	9a e0       	ldi	r25, 0x0A	; 10
    a20a:	93 87       	std	Z+11, r25	; 0x0b
    a20c:	82 87       	std	Z+10, r24	; 0x0a
    a20e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    a212:	8d b7       	in	r24, 0x3d	; 61
    a214:	9e b7       	in	r25, 0x3e	; 62
    a216:	0c 96       	adiw	r24, 0x0c	; 12
    a218:	0f b6       	in	r0, 0x3f	; 63
    a21a:	f8 94       	cli
    a21c:	9e bf       	out	0x3e, r25	; 62
    a21e:	0f be       	out	0x3f, r0	; 63
    a220:	8d bf       	out	0x3d, r24	; 61
    a222:	81 e0       	ldi	r24, 0x01	; 1
    a224:	60 e0       	ldi	r22, 0x00	; 0
    a226:	a8 01       	movw	r20, r16
    a228:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	UpdateCardID();
    a22c:	0e 94 ce 3c 	call	0x799c	; 0x799c <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strFIP_ID,strCardID);
    a230:	ad b7       	in	r26, 0x3d	; 61
    a232:	be b7       	in	r27, 0x3e	; 62
    a234:	18 97       	sbiw	r26, 0x08	; 8
    a236:	0f b6       	in	r0, 0x3f	; 63
    a238:	f8 94       	cli
    a23a:	be bf       	out	0x3e, r27	; 62
    a23c:	0f be       	out	0x3f, r0	; 63
    a23e:	ad bf       	out	0x3d, r26	; 61
    a240:	ed b7       	in	r30, 0x3d	; 61
    a242:	fe b7       	in	r31, 0x3e	; 62
    a244:	31 96       	adiw	r30, 0x01	; 1
    a246:	12 96       	adiw	r26, 0x02	; 2
    a248:	1c 93       	st	X, r17
    a24a:	0e 93       	st	-X, r16
    a24c:	11 97       	sbiw	r26, 0x01	; 1
    a24e:	8f e4       	ldi	r24, 0x4F	; 79
    a250:	91 e2       	ldi	r25, 0x21	; 33
    a252:	93 83       	std	Z+3, r25	; 0x03
    a254:	82 83       	std	Z+2, r24	; 0x02
    a256:	8c ee       	ldi	r24, 0xEC	; 236
    a258:	99 e0       	ldi	r25, 0x09	; 9
    a25a:	95 83       	std	Z+5, r25	; 0x05
    a25c:	84 83       	std	Z+4, r24	; 0x04
    a25e:	81 eb       	ldi	r24, 0xB1	; 177
    a260:	9d e0       	ldi	r25, 0x0D	; 13
    a262:	97 83       	std	Z+7, r25	; 0x07
    a264:	86 83       	std	Z+6, r24	; 0x06
    a266:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    a26a:	8d b7       	in	r24, 0x3d	; 61
    a26c:	9e b7       	in	r25, 0x3e	; 62
    a26e:	08 96       	adiw	r24, 0x08	; 8
    a270:	0f b6       	in	r0, 0x3f	; 63
    a272:	f8 94       	cli
    a274:	9e bf       	out	0x3e, r25	; 62
    a276:	0f be       	out	0x3f, r0	; 63
    a278:	8d bf       	out	0x3d, r24	; 61
    a27a:	81 e0       	ldi	r24, 0x01	; 1
    a27c:	60 e0       	ldi	r22, 0x00	; 0
    a27e:	a8 01       	movw	r20, r16
    a280:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	_uart(1, 1,0x02);
    a284:	81 e0       	ldi	r24, 0x01	; 1
    a286:	61 e0       	ldi	r22, 0x01	; 1
    a288:	42 e0       	ldi	r20, 0x02	; 2
    a28a:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
}
    a28e:	ec 96       	adiw	r28, 0x3c	; 60
    a290:	0f b6       	in	r0, 0x3f	; 63
    a292:	f8 94       	cli
    a294:	de bf       	out	0x3e, r29	; 62
    a296:	0f be       	out	0x3f, r0	; 63
    a298:	cd bf       	out	0x3d, r28	; 61
    a29a:	cf 91       	pop	r28
    a29c:	df 91       	pop	r29
    a29e:	1f 91       	pop	r17
    a2a0:	0f 91       	pop	r16
    a2a2:	08 95       	ret

0000a2a4 <sendMessage24>:
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage24(){//Msg24: <01>[0103192.168.016.070192.168.016.18022[CardID]F968CFFB]<02>
    a2a4:	0f 93       	push	r16
    a2a6:	1f 93       	push	r17
    a2a8:	df 93       	push	r29
    a2aa:	cf 93       	push	r28
    a2ac:	cd b7       	in	r28, 0x3d	; 61
    a2ae:	de b7       	in	r29, 0x3e	; 62
    a2b0:	ec 97       	sbiw	r28, 0x3c	; 60
    a2b2:	0f b6       	in	r0, 0x3f	; 63
    a2b4:	f8 94       	cli
    a2b6:	de bf       	out	0x3e, r29	; 62
    a2b8:	0f be       	out	0x3f, r0	; 63
    a2ba:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a2bc:	81 e0       	ldi	r24, 0x01	; 1
    a2be:	61 e0       	ldi	r22, 0x01	; 1
    a2c0:	41 e0       	ldi	r20, 0x01	; 1
    a2c2:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a2c6:	0e 94 f0 1b 	call	0x37e0	; 0x37e0 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a2ca:	0e 94 c5 1b 	call	0x378a	; 0x378a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a2ce:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a2d2:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s24"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a2d6:	8d b7       	in	r24, 0x3d	; 61
    a2d8:	9e b7       	in	r25, 0x3e	; 62
    a2da:	0c 97       	sbiw	r24, 0x0c	; 12
    a2dc:	0f b6       	in	r0, 0x3f	; 63
    a2de:	f8 94       	cli
    a2e0:	9e bf       	out	0x3e, r25	; 62
    a2e2:	0f be       	out	0x3f, r0	; 63
    a2e4:	8d bf       	out	0x3d, r24	; 61
    a2e6:	ed b7       	in	r30, 0x3d	; 61
    a2e8:	fe b7       	in	r31, 0x3e	; 62
    a2ea:	31 96       	adiw	r30, 0x01	; 1
    a2ec:	8e 01       	movw	r16, r28
    a2ee:	0f 5f       	subi	r16, 0xFF	; 255
    a2f0:	1f 4f       	sbci	r17, 0xFF	; 255
    a2f2:	ad b7       	in	r26, 0x3d	; 61
    a2f4:	be b7       	in	r27, 0x3e	; 62
    a2f6:	12 96       	adiw	r26, 0x02	; 2
    a2f8:	1c 93       	st	X, r17
    a2fa:	0e 93       	st	-X, r16
    a2fc:	11 97       	sbiw	r26, 0x01	; 1
    a2fe:	84 e7       	ldi	r24, 0x74	; 116
    a300:	91 e2       	ldi	r25, 0x21	; 33
    a302:	93 83       	std	Z+3, r25	; 0x03
    a304:	82 83       	std	Z+2, r24	; 0x02
    a306:	8c e1       	ldi	r24, 0x1C	; 28
    a308:	96 e0       	ldi	r25, 0x06	; 6
    a30a:	95 83       	std	Z+5, r25	; 0x05
    a30c:	84 83       	std	Z+4, r24	; 0x04
    a30e:	8b ef       	ldi	r24, 0xFB	; 251
    a310:	9d e0       	ldi	r25, 0x0D	; 13
    a312:	97 83       	std	Z+7, r25	; 0x07
    a314:	86 83       	std	Z+6, r24	; 0x06
    a316:	8e e0       	ldi	r24, 0x0E	; 14
    a318:	9a e0       	ldi	r25, 0x0A	; 10
    a31a:	91 87       	std	Z+9, r25	; 0x09
    a31c:	80 87       	std	Z+8, r24	; 0x08
    a31e:	8b e3       	ldi	r24, 0x3B	; 59
    a320:	9a e0       	ldi	r25, 0x0A	; 10
    a322:	93 87       	std	Z+11, r25	; 0x0b
    a324:	82 87       	std	Z+10, r24	; 0x0a
    a326:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    a32a:	8d b7       	in	r24, 0x3d	; 61
    a32c:	9e b7       	in	r25, 0x3e	; 62
    a32e:	0c 96       	adiw	r24, 0x0c	; 12
    a330:	0f b6       	in	r0, 0x3f	; 63
    a332:	f8 94       	cli
    a334:	9e bf       	out	0x3e, r25	; 62
    a336:	0f be       	out	0x3f, r0	; 63
    a338:	8d bf       	out	0x3d, r24	; 61
    a33a:	81 e0       	ldi	r24, 0x01	; 1
    a33c:	60 e0       	ldi	r22, 0x00	; 0
    a33e:	a8 01       	movw	r20, r16
    a340:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	UpdateCardID();
    a344:	0e 94 ce 3c 	call	0x799c	; 0x799c <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    a348:	ad b7       	in	r26, 0x3d	; 61
    a34a:	be b7       	in	r27, 0x3e	; 62
    a34c:	18 97       	sbiw	r26, 0x08	; 8
    a34e:	0f b6       	in	r0, 0x3f	; 63
    a350:	f8 94       	cli
    a352:	be bf       	out	0x3e, r27	; 62
    a354:	0f be       	out	0x3f, r0	; 63
    a356:	ad bf       	out	0x3d, r26	; 61
    a358:	ed b7       	in	r30, 0x3d	; 61
    a35a:	fe b7       	in	r31, 0x3e	; 62
    a35c:	31 96       	adiw	r30, 0x01	; 1
    a35e:	12 96       	adiw	r26, 0x02	; 2
    a360:	1c 93       	st	X, r17
    a362:	0e 93       	st	-X, r16
    a364:	11 97       	sbiw	r26, 0x01	; 1
    a366:	87 e6       	ldi	r24, 0x67	; 103
    a368:	91 e2       	ldi	r25, 0x21	; 33
    a36a:	93 83       	std	Z+3, r25	; 0x03
    a36c:	82 83       	std	Z+2, r24	; 0x02
    a36e:	81 eb       	ldi	r24, 0xB1	; 177
    a370:	9d e0       	ldi	r25, 0x0D	; 13
    a372:	95 83       	std	Z+5, r25	; 0x05
    a374:	84 83       	std	Z+4, r24	; 0x04
    a376:	8c ee       	ldi	r24, 0xEC	; 236
    a378:	99 e0       	ldi	r25, 0x09	; 9
    a37a:	97 83       	std	Z+7, r25	; 0x07
    a37c:	86 83       	std	Z+6, r24	; 0x06
    a37e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    a382:	8d b7       	in	r24, 0x3d	; 61
    a384:	9e b7       	in	r25, 0x3e	; 62
    a386:	08 96       	adiw	r24, 0x08	; 8
    a388:	0f b6       	in	r0, 0x3f	; 63
    a38a:	f8 94       	cli
    a38c:	9e bf       	out	0x3e, r25	; 62
    a38e:	0f be       	out	0x3f, r0	; 63
    a390:	8d bf       	out	0x3d, r24	; 61
    a392:	81 e0       	ldi	r24, 0x01	; 1
    a394:	60 e0       	ldi	r22, 0x00	; 0
    a396:	a8 01       	movw	r20, r16
    a398:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	_uart(1, 1,0x02);
    a39c:	81 e0       	ldi	r24, 0x01	; 1
    a39e:	61 e0       	ldi	r22, 0x01	; 1
    a3a0:	42 e0       	ldi	r20, 0x02	; 2
    a3a2:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
}
    a3a6:	ec 96       	adiw	r28, 0x3c	; 60
    a3a8:	0f b6       	in	r0, 0x3f	; 63
    a3aa:	f8 94       	cli
    a3ac:	de bf       	out	0x3e, r29	; 62
    a3ae:	0f be       	out	0x3f, r0	; 63
    a3b0:	cd bf       	out	0x3d, r28	; 61
    a3b2:	cf 91       	pop	r28
    a3b4:	df 91       	pop	r29
    a3b6:	1f 91       	pop	r17
    a3b8:	0f 91       	pop	r16
    a3ba:	08 95       	ret

0000a3bc <sendMessage22>:
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
	IsNewPacket=True;
}

void sendMessage22(){//Msg22: <01>[0103192.168.016.070192.168.016.18022[CardID]F968CFFB]<02>
    a3bc:	0f 93       	push	r16
    a3be:	1f 93       	push	r17
    a3c0:	df 93       	push	r29
    a3c2:	cf 93       	push	r28
    a3c4:	cd b7       	in	r28, 0x3d	; 61
    a3c6:	de b7       	in	r29, 0x3e	; 62
    a3c8:	ec 97       	sbiw	r28, 0x3c	; 60
    a3ca:	0f b6       	in	r0, 0x3f	; 63
    a3cc:	f8 94       	cli
    a3ce:	de bf       	out	0x3e, r29	; 62
    a3d0:	0f be       	out	0x3f, r0	; 63
    a3d2:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a3d4:	81 e0       	ldi	r24, 0x01	; 1
    a3d6:	61 e0       	ldi	r22, 0x01	; 1
    a3d8:	41 e0       	ldi	r20, 0x01	; 1
    a3da:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a3de:	0e 94 f0 1b 	call	0x37e0	; 0x37e0 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a3e2:	0e 94 c5 1b 	call	0x378a	; 0x378a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a3e6:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a3ea:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s22"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a3ee:	8d b7       	in	r24, 0x3d	; 61
    a3f0:	9e b7       	in	r25, 0x3e	; 62
    a3f2:	0c 97       	sbiw	r24, 0x0c	; 12
    a3f4:	0f b6       	in	r0, 0x3f	; 63
    a3f6:	f8 94       	cli
    a3f8:	9e bf       	out	0x3e, r25	; 62
    a3fa:	0f be       	out	0x3f, r0	; 63
    a3fc:	8d bf       	out	0x3d, r24	; 61
    a3fe:	ed b7       	in	r30, 0x3d	; 61
    a400:	fe b7       	in	r31, 0x3e	; 62
    a402:	31 96       	adiw	r30, 0x01	; 1
    a404:	8e 01       	movw	r16, r28
    a406:	0f 5f       	subi	r16, 0xFF	; 255
    a408:	1f 4f       	sbci	r17, 0xFF	; 255
    a40a:	ad b7       	in	r26, 0x3d	; 61
    a40c:	be b7       	in	r27, 0x3e	; 62
    a40e:	12 96       	adiw	r26, 0x02	; 2
    a410:	1c 93       	st	X, r17
    a412:	0e 93       	st	-X, r16
    a414:	11 97       	sbiw	r26, 0x01	; 1
    a416:	8a e8       	ldi	r24, 0x8A	; 138
    a418:	91 e2       	ldi	r25, 0x21	; 33
    a41a:	93 83       	std	Z+3, r25	; 0x03
    a41c:	82 83       	std	Z+2, r24	; 0x02
    a41e:	8c e1       	ldi	r24, 0x1C	; 28
    a420:	96 e0       	ldi	r25, 0x06	; 6
    a422:	95 83       	std	Z+5, r25	; 0x05
    a424:	84 83       	std	Z+4, r24	; 0x04
    a426:	8b ef       	ldi	r24, 0xFB	; 251
    a428:	9d e0       	ldi	r25, 0x0D	; 13
    a42a:	97 83       	std	Z+7, r25	; 0x07
    a42c:	86 83       	std	Z+6, r24	; 0x06
    a42e:	8e e0       	ldi	r24, 0x0E	; 14
    a430:	9a e0       	ldi	r25, 0x0A	; 10
    a432:	91 87       	std	Z+9, r25	; 0x09
    a434:	80 87       	std	Z+8, r24	; 0x08
    a436:	8b e3       	ldi	r24, 0x3B	; 59
    a438:	9a e0       	ldi	r25, 0x0A	; 10
    a43a:	93 87       	std	Z+11, r25	; 0x0b
    a43c:	82 87       	std	Z+10, r24	; 0x0a
    a43e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    a442:	8d b7       	in	r24, 0x3d	; 61
    a444:	9e b7       	in	r25, 0x3e	; 62
    a446:	0c 96       	adiw	r24, 0x0c	; 12
    a448:	0f b6       	in	r0, 0x3f	; 63
    a44a:	f8 94       	cli
    a44c:	9e bf       	out	0x3e, r25	; 62
    a44e:	0f be       	out	0x3f, r0	; 63
    a450:	8d bf       	out	0x3d, r24	; 61
    a452:	81 e0       	ldi	r24, 0x01	; 1
    a454:	60 e0       	ldi	r22, 0x00	; 0
    a456:	a8 01       	movw	r20, r16
    a458:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	UpdateCardID();
    a45c:	0e 94 ce 3c 	call	0x799c	; 0x799c <UpdateCardID>
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    a460:	00 d0       	rcall	.+0      	; 0xa462 <sendMessage22+0xa6>
    a462:	00 d0       	rcall	.+0      	; 0xa464 <sendMessage22+0xa8>
    a464:	00 d0       	rcall	.+0      	; 0xa466 <sendMessage22+0xaa>
    a466:	ed b7       	in	r30, 0x3d	; 61
    a468:	fe b7       	in	r31, 0x3e	; 62
    a46a:	31 96       	adiw	r30, 0x01	; 1
    a46c:	ad b7       	in	r26, 0x3d	; 61
    a46e:	be b7       	in	r27, 0x3e	; 62
    a470:	12 96       	adiw	r26, 0x02	; 2
    a472:	1c 93       	st	X, r17
    a474:	0e 93       	st	-X, r16
    a476:	11 97       	sbiw	r26, 0x01	; 1
    a478:	8f e7       	ldi	r24, 0x7F	; 127
    a47a:	91 e2       	ldi	r25, 0x21	; 33
    a47c:	93 83       	std	Z+3, r25	; 0x03
    a47e:	82 83       	std	Z+2, r24	; 0x02
    a480:	81 eb       	ldi	r24, 0xB1	; 177
    a482:	9d e0       	ldi	r25, 0x0D	; 13
    a484:	95 83       	std	Z+5, r25	; 0x05
    a486:	84 83       	std	Z+4, r24	; 0x04
    a488:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    a48c:	8d b7       	in	r24, 0x3d	; 61
    a48e:	9e b7       	in	r25, 0x3e	; 62
    a490:	06 96       	adiw	r24, 0x06	; 6
    a492:	0f b6       	in	r0, 0x3f	; 63
    a494:	f8 94       	cli
    a496:	9e bf       	out	0x3e, r25	; 62
    a498:	0f be       	out	0x3f, r0	; 63
    a49a:	8d bf       	out	0x3d, r24	; 61
    a49c:	81 e0       	ldi	r24, 0x01	; 1
    a49e:	60 e0       	ldi	r22, 0x00	; 0
    a4a0:	a8 01       	movw	r20, r16
    a4a2:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	_uart(1, 1,0x02);
    a4a6:	81 e0       	ldi	r24, 0x01	; 1
    a4a8:	61 e0       	ldi	r22, 0x01	; 1
    a4aa:	42 e0       	ldi	r20, 0x02	; 2
    a4ac:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
}
    a4b0:	ec 96       	adiw	r28, 0x3c	; 60
    a4b2:	0f b6       	in	r0, 0x3f	; 63
    a4b4:	f8 94       	cli
    a4b6:	de bf       	out	0x3e, r29	; 62
    a4b8:	0f be       	out	0x3f, r0	; 63
    a4ba:	cd bf       	out	0x3d, r28	; 61
    a4bc:	cf 91       	pop	r28
    a4be:	df 91       	pop	r29
    a4c0:	1f 91       	pop	r17
    a4c2:	0f 91       	pop	r16
    a4c4:	08 95       	ret

0000a4c6 <sendMessage10>:
     _uart_print(1, 0,strSend);
	 _uart(1, 1,0x02);
}

/*Subrutine Msg10*/
void sendMessage10(){//Msg10: <01>[0103192.168.016.070192.168.016.18010F968CFFB]<02>
    a4c6:	0f 93       	push	r16
    a4c8:	1f 93       	push	r17
    a4ca:	df 93       	push	r29
    a4cc:	cf 93       	push	r28
    a4ce:	cd b7       	in	r28, 0x3d	; 61
    a4d0:	de b7       	in	r29, 0x3e	; 62
    a4d2:	ec 97       	sbiw	r28, 0x3c	; 60
    a4d4:	0f b6       	in	r0, 0x3f	; 63
    a4d6:	f8 94       	cli
    a4d8:	de bf       	out	0x3e, r29	; 62
    a4da:	0f be       	out	0x3f, r0	; 63
    a4dc:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a4de:	81 e0       	ldi	r24, 0x01	; 1
    a4e0:	61 e0       	ldi	r22, 0x01	; 1
    a4e2:	41 e0       	ldi	r20, 0x01	; 1
    a4e4:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a4e8:	0e 94 f0 1b 	call	0x37e0	; 0x37e0 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a4ec:	0e 94 c5 1b 	call	0x378a	; 0x378a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a4f0:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a4f4:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s10F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a4f8:	8d b7       	in	r24, 0x3d	; 61
    a4fa:	9e b7       	in	r25, 0x3e	; 62
    a4fc:	0c 97       	sbiw	r24, 0x0c	; 12
    a4fe:	0f b6       	in	r0, 0x3f	; 63
    a500:	f8 94       	cli
    a502:	9e bf       	out	0x3e, r25	; 62
    a504:	0f be       	out	0x3f, r0	; 63
    a506:	8d bf       	out	0x3d, r24	; 61
    a508:	ed b7       	in	r30, 0x3d	; 61
    a50a:	fe b7       	in	r31, 0x3e	; 62
    a50c:	31 96       	adiw	r30, 0x01	; 1
    a50e:	8e 01       	movw	r16, r28
    a510:	0f 5f       	subi	r16, 0xFF	; 255
    a512:	1f 4f       	sbci	r17, 0xFF	; 255
    a514:	ad b7       	in	r26, 0x3d	; 61
    a516:	be b7       	in	r27, 0x3e	; 62
    a518:	12 96       	adiw	r26, 0x02	; 2
    a51a:	1c 93       	st	X, r17
    a51c:	0e 93       	st	-X, r16
    a51e:	11 97       	sbiw	r26, 0x01	; 1
    a520:	85 e9       	ldi	r24, 0x95	; 149
    a522:	91 e2       	ldi	r25, 0x21	; 33
    a524:	93 83       	std	Z+3, r25	; 0x03
    a526:	82 83       	std	Z+2, r24	; 0x02
    a528:	8c e1       	ldi	r24, 0x1C	; 28
    a52a:	96 e0       	ldi	r25, 0x06	; 6
    a52c:	95 83       	std	Z+5, r25	; 0x05
    a52e:	84 83       	std	Z+4, r24	; 0x04
    a530:	8b ef       	ldi	r24, 0xFB	; 251
    a532:	9d e0       	ldi	r25, 0x0D	; 13
    a534:	97 83       	std	Z+7, r25	; 0x07
    a536:	86 83       	std	Z+6, r24	; 0x06
    a538:	8e e0       	ldi	r24, 0x0E	; 14
    a53a:	9a e0       	ldi	r25, 0x0A	; 10
    a53c:	91 87       	std	Z+9, r25	; 0x09
    a53e:	80 87       	std	Z+8, r24	; 0x08
    a540:	8b e3       	ldi	r24, 0x3B	; 59
    a542:	9a e0       	ldi	r25, 0x0A	; 10
    a544:	93 87       	std	Z+11, r25	; 0x0b
    a546:	82 87       	std	Z+10, r24	; 0x0a
    a548:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
    a54c:	8d b7       	in	r24, 0x3d	; 61
    a54e:	9e b7       	in	r25, 0x3e	; 62
    a550:	0c 96       	adiw	r24, 0x0c	; 12
    a552:	0f b6       	in	r0, 0x3f	; 63
    a554:	f8 94       	cli
    a556:	9e bf       	out	0x3e, r25	; 62
    a558:	0f be       	out	0x3f, r0	; 63
    a55a:	8d bf       	out	0x3d, r24	; 61
    a55c:	81 e0       	ldi	r24, 0x01	; 1
    a55e:	60 e0       	ldi	r22, 0x00	; 0
    a560:	a8 01       	movw	r20, r16
    a562:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	_uart(1, 1,0x02);
    a566:	81 e0       	ldi	r24, 0x01	; 1
    a568:	61 e0       	ldi	r22, 0x01	; 1
    a56a:	42 e0       	ldi	r20, 0x02	; 2
    a56c:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	IsNewPacket=True;
    a570:	81 e0       	ldi	r24, 0x01	; 1
    a572:	80 93 9b 01 	sts	0x019B, r24
}
    a576:	ec 96       	adiw	r28, 0x3c	; 60
    a578:	0f b6       	in	r0, 0x3f	; 63
    a57a:	f8 94       	cli
    a57c:	de bf       	out	0x3e, r29	; 62
    a57e:	0f be       	out	0x3f, r0	; 63
    a580:	cd bf       	out	0x3d, r28	; 61
    a582:	cf 91       	pop	r28
    a584:	df 91       	pop	r29
    a586:	1f 91       	pop	r17
    a588:	0f 91       	pop	r16
    a58a:	08 95       	ret

0000a58c <sendMessage04>:
	 }
		 sprintf_P(strServerIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
}

/*Subrutine Msg04*/
void sendMessage04(){   //      <STX>[IFTID][Seq][No][SrceIP][DestIP][MsgCode][ReceiptNo][Value][Checksum][ETX]
    a58c:	0f 93       	push	r16
    a58e:	1f 93       	push	r17
    a590:	df 93       	push	r29
    a592:	cf 93       	push	r28
    a594:	cd b7       	in	r28, 0x3d	; 61
    a596:	de b7       	in	r29, 0x3e	; 62
    a598:	ec 97       	sbiw	r28, 0x3c	; 60
    a59a:	0f b6       	in	r0, 0x3f	; 63
    a59c:	f8 94       	cli
    a59e:	de bf       	out	0x3e, r29	; 62
    a5a0:	0f be       	out	0x3f, r0	; 63
    a5a2:	cd bf       	out	0x3d, r28	; 61
                        //Msg04: <01>[01][03][192.168.000.101][192.168.000.001][04][000001]0F968CFFB]<02>
	 char strSend[60];
	 _uart(1, 1,0x01);
    a5a4:	81 e0       	ldi	r24, 0x01	; 1
    a5a6:	61 e0       	ldi	r22, 0x01	; 1
    a5a8:	41 e0       	ldi	r20, 0x01	; 1
    a5aa:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	 UpdateIFT_ID(); //ReadIFT_ID
    a5ae:	0e 94 f0 1b 	call	0x37e0	; 0x37e0 <UpdateIFT_ID>
	 UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a5b2:	0e 94 c5 1b 	call	0x378a	; 0x378a <UpdateSeqNum>
	 UpdateClientIP();//ReadSourceIP
    a5b6:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <UpdateClientIP>
	 UpdateServerIP();//ReadDestIP
    a5ba:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateServerIP>
	 //strTranNo = strReceiptNum
	 sprintf_P(strSend,PSTR("%s%s%s%s04%s1F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,strTranNo);
    a5be:	8d b7       	in	r24, 0x3d	; 61
    a5c0:	9e b7       	in	r25, 0x3e	; 62
    a5c2:	0e 97       	sbiw	r24, 0x0e	; 14
    a5c4:	0f b6       	in	r0, 0x3f	; 63
    a5c6:	f8 94       	cli
    a5c8:	9e bf       	out	0x3e, r25	; 62
    a5ca:	0f be       	out	0x3f, r0	; 63
    a5cc:	8d bf       	out	0x3d, r24	; 61
    a5ce:	ed b7       	in	r30, 0x3d	; 61
    a5d0:	fe b7       	in	r31, 0x3e	; 62
    a5d2:	31 96       	adiw	r30, 0x01	; 1
    a5d4:	8e 01       	movw	r16, r28
    a5d6:	0f 5f       	subi	r16, 0xFF	; 255
    a5d8:	1f 4f       	sbci	r17, 0xFF	; 255
    a5da:	ad b7       	in	r26, 0x3d	; 61
    a5dc:	be b7       	in	r27, 0x3e	; 62
    a5de:	12 96       	adiw	r26, 0x02	; 2
    a5e0:	1c 93       	st	X, r17
    a5e2:	0e 93       	st	-X, r16
    a5e4:	11 97       	sbiw	r26, 0x01	; 1
    a5e6:	88 ea       	ldi	r24, 0xA8	; 168
    a5e8:	91 e2       	ldi	r25, 0x21	; 33
    a5ea:	93 83       	std	Z+3, r25	; 0x03
    a5ec:	82 83       	std	Z+2, r24	; 0x02
    a5ee:	8c e1       	ldi	r24, 0x1C	; 28
    a5f0:	96 e0       	ldi	r25, 0x06	; 6
    a5f2:	95 83       	std	Z+5, r25	; 0x05
    a5f4:	84 83       	std	Z+4, r24	; 0x04
    a5f6:	8b ef       	ldi	r24, 0xFB	; 251
    a5f8:	9d e0       	ldi	r25, 0x0D	; 13
    a5fa:	97 83       	std	Z+7, r25	; 0x07
    a5fc:	86 83       	std	Z+6, r24	; 0x06
    a5fe:	8e e0       	ldi	r24, 0x0E	; 14
    a600:	9a e0       	ldi	r25, 0x0A	; 10
    a602:	91 87       	std	Z+9, r25	; 0x09
    a604:	80 87       	std	Z+8, r24	; 0x08
    a606:	8b e3       	ldi	r24, 0x3B	; 59
    a608:	9a e0       	ldi	r25, 0x0A	; 10
    a60a:	93 87       	std	Z+11, r25	; 0x0b
    a60c:	82 87       	std	Z+10, r24	; 0x0a
    a60e:	81 eb       	ldi	r24, 0xB1	; 177
    a610:	9e e0       	ldi	r25, 0x0E	; 14
    a612:	95 87       	std	Z+13, r25	; 0x0d
    a614:	84 87       	std	Z+12, r24	; 0x0c
    a616:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
     _uart_print(1, 0,strSend);
    a61a:	8d b7       	in	r24, 0x3d	; 61
    a61c:	9e b7       	in	r25, 0x3e	; 62
    a61e:	0e 96       	adiw	r24, 0x0e	; 14
    a620:	0f b6       	in	r0, 0x3f	; 63
    a622:	f8 94       	cli
    a624:	9e bf       	out	0x3e, r25	; 62
    a626:	0f be       	out	0x3f, r0	; 63
    a628:	8d bf       	out	0x3d, r24	; 61
    a62a:	81 e0       	ldi	r24, 0x01	; 1
    a62c:	60 e0       	ldi	r22, 0x00	; 0
    a62e:	a8 01       	movw	r20, r16
    a630:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	 _uart(1, 1,0x02);
    a634:	81 e0       	ldi	r24, 0x01	; 1
    a636:	61 e0       	ldi	r22, 0x01	; 1
    a638:	42 e0       	ldi	r20, 0x02	; 2
    a63a:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
}
    a63e:	ec 96       	adiw	r28, 0x3c	; 60
    a640:	0f b6       	in	r0, 0x3f	; 63
    a642:	f8 94       	cli
    a644:	de bf       	out	0x3e, r29	; 62
    a646:	0f be       	out	0x3f, r0	; 63
    a648:	cd bf       	out	0x3d, r28	; 61
    a64a:	cf 91       	pop	r28
    a64c:	df 91       	pop	r29
    a64e:	1f 91       	pop	r17
    a650:	0f 91       	pop	r16
    a652:	08 95       	ret

0000a654 <FreePrinting>:
	 } 
	 else _uart(_COM_PRINTER,1,xSend);
	 zSend=xSend;
}

void FreePrinting(){
    a654:	0f 93       	push	r16
    a656:	1f 93       	push	r17
static char iPrinted=0,iHeader=0,iFooter=0,PrintCopy=0,iMargin=0,iScroll=0,nScroll=0;
static char strHeader[41];
static unsigned int iSend=0,LSend=0,iLoop=0;

     //Normalize FreePrintIdleState
     if ((IsFreePrinting==True)&&(stFreePrinting!=fpInit)){
    a658:	20 91 bf 01 	lds	r18, 0x01BF
    a65c:	21 30       	cpi	r18, 0x01	; 1
    a65e:	31 f4       	brne	.+12     	; 0xa66c <FreePrinting+0x18>
    a660:	80 91 25 01 	lds	r24, 0x0125
    a664:	81 30       	cpi	r24, 0x01	; 1
    a666:	11 f0       	breq	.+4      	; 0xa66c <FreePrinting+0x18>
	     stFreePrinting=fpInit;
    a668:	20 93 25 01 	sts	0x0125, r18
	 }

	 switch (stFreePrinting){
    a66c:	80 91 25 01 	lds	r24, 0x0125
    a670:	90 e0       	ldi	r25, 0x00	; 0
    a672:	fc 01       	movw	r30, r24
    a674:	31 97       	sbiw	r30, 0x01	; 1
    a676:	e5 31       	cpi	r30, 0x15	; 21
    a678:	f1 05       	cpc	r31, r1
    a67a:	08 f0       	brcs	.+2      	; 0xa67e <FreePrinting+0x2a>
    a67c:	7e c2       	rjmp	.+1276   	; 0xab7a <FreePrinting+0x526>
    a67e:	ec 59       	subi	r30, 0x9C	; 156
    a680:	ff 4f       	sbci	r31, 0xFF	; 255
    a682:	ee 0f       	add	r30, r30
    a684:	ff 1f       	adc	r31, r31
    a686:	05 90       	lpm	r0, Z+
    a688:	f4 91       	lpm	r31, Z+
    a68a:	e0 2d       	mov	r30, r0
    a68c:	09 94       	ijmp
     case fpInit:
	      //_uart_printf(0,1,PSTR("fpInit"));
	      if (IsFreePrinting==True){
    a68e:	21 30       	cpi	r18, 0x01	; 1
    a690:	09 f0       	breq	.+2      	; 0xa694 <FreePrinting+0x40>
    a692:	73 c2       	rjmp	.+1254   	; 0xab7a <FreePrinting+0x526>
		      IsFreePrinting=False;
    a694:	10 92 bf 01 	sts	0x01BF, r1
			  IsBusyFreePrinting=True;
    a698:	20 93 ca 01 	sts	0x01CA, r18
			  IsBusyPrint=False;
    a69c:	10 92 c9 01 	sts	0x01C9, r1
			  iPrinted=0,iFooter=0;
    a6a0:	10 92 88 02 	sts	0x0288, r1
    a6a4:	10 92 86 02 	sts	0x0286, r1

			  PrintCopy=(cmdPrint&0x0F);
    a6a8:	80 91 cb 01 	lds	r24, 0x01CB
    a6ac:	8f 70       	andi	r24, 0x0F	; 15
    a6ae:	80 93 85 02 	sts	0x0285, r24

			  //cmdPrint=cmdPrint|0b00100000;
			  //PrintCopy=2;

			  stFreePrinting=fpInitHeader;
    a6b2:	82 e0       	ldi	r24, 0x02	; 2
    a6b4:	80 93 25 01 	sts	0x0125, r24
			  InitPrinter();
    a6b8:	0e 94 ac 4b 	call	0x9758	; 0x9758 <InitPrinter>
    a6bc:	5e c2       	rjmp	.+1212   	; 0xab7a <FreePrinting+0x526>
			  }
	      break;
     case fpInitHeader:
	      //_uart_printf(0,1,PSTR("fpInitHeader"));
		  iHeader=0;
    a6be:	10 92 87 02 	sts	0x0287, r1
	      if (((cmdPrint&0b10000000)>>7)==1){
    a6c2:	80 91 cb 01 	lds	r24, 0x01CB
    a6c6:	88 1f       	adc	r24, r24
    a6c8:	88 27       	eor	r24, r24
    a6ca:	88 1f       	adc	r24, r24
    a6cc:	90 e0       	ldi	r25, 0x00	; 0
    a6ce:	81 30       	cpi	r24, 0x01	; 1
    a6d0:	91 05       	cpc	r25, r1
    a6d2:	21 f1       	breq	.+72     	; 0xa71c <FreePrinting+0xc8>
		      stFreePrinting=fpLoadHeader;
			  }
		  else
	      if (((cmdPrint&0b10000000)>>7)==0) stFreePrinting=fpInitMessage;	      
    a6d4:	89 2b       	or	r24, r25
    a6d6:	09 f0       	breq	.+2      	; 0xa6da <FreePrinting+0x86>
    a6d8:	50 c2       	rjmp	.+1184   	; 0xab7a <FreePrinting+0x526>
    a6da:	85 e0       	ldi	r24, 0x05	; 5
    a6dc:	80 93 25 01 	sts	0x0125, r24
    a6e0:	4c c2       	rjmp	.+1176   	; 0xab7a <FreePrinting+0x526>
    a6e2:	60 91 87 02 	lds	r22, 0x0287
    a6e6:	89 e2       	ldi	r24, 0x29	; 41
    a6e8:	68 9f       	mul	r22, r24
    a6ea:	b0 01       	movw	r22, r0
    a6ec:	11 24       	eor	r1, r1
    a6ee:	69 5d       	subi	r22, 0xD9	; 217
    a6f0:	7d 4f       	sbci	r23, 0xFD	; 253
    a6f2:	89 e5       	ldi	r24, 0x59	; 89
    a6f4:	92 e0       	ldi	r25, 0x02	; 2
    a6f6:	48 e2       	ldi	r20, 0x28	; 40
    a6f8:	50 e0       	ldi	r21, 0x00	; 0
    a6fa:	25 ed       	ldi	r18, 0xD5	; 213
    a6fc:	32 e1       	ldi	r19, 0x12	; 18
    a6fe:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
	      break;
     case fpLoadHeader:
	      //_uart_printf(0,1,PSTR("fpLoadHeader"));
          //Header 1
	      eeprom_read_block((void*) &strHeader, (const void*) &DefHeaderFooter[iHeader], 40);
		  iHeader++;
    a702:	00 91 87 02 	lds	r16, 0x0287
    a706:	0f 5f       	subi	r16, 0xFF	; 255
    a708:	00 93 87 02 	sts	0x0287, r16
		  if (iHeader<6){
    a70c:	06 30       	cpi	r16, 0x06	; 6
    a70e:	28 f7       	brcc	.-54     	; 0xa6da <FreePrinting+0x86>
		      if (SpaceOnly(strHeader)==True){
    a710:	89 e5       	ldi	r24, 0x59	; 89
    a712:	92 e0       	ldi	r25, 0x02	; 2
    a714:	0e 94 99 22 	call	0x4532	; 0x4532 <SpaceOnly>
    a718:	81 30       	cpi	r24, 0x01	; 1
    a71a:	11 f4       	brne	.+4      	; 0xa720 <FreePrinting+0xcc>
			      stFreePrinting=fpLoadHeader;
    a71c:	83 e0       	ldi	r24, 0x03	; 3
    a71e:	de cf       	rjmp	.-68     	; 0xa6dc <FreePrinting+0x88>
				  }	      
			  else{
			      stFreePrinting=fpPrintHeader;
    a720:	84 e0       	ldi	r24, 0x04	; 4
    a722:	80 93 25 01 	sts	0x0125, r24
			      iSend=0;
    a726:	10 92 58 02 	sts	0x0258, r1
    a72a:	10 92 57 02 	sts	0x0257, r1
				  iLoop=0;
    a72e:	10 92 54 02 	sts	0x0254, r1
    a732:	10 92 53 02 	sts	0x0253, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    a736:	01 30       	cpi	r16, 0x01	; 1
    a738:	19 f4       	brne	.+6      	; 0xa740 <FreePrinting+0xec>
    a73a:	0e 94 2e 4c 	call	0x985c	; 0x985c <PrintDoubleHeight>
    a73e:	1d c2       	rjmp	.+1082   	; 0xab7a <FreePrinting+0x526>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    a740:	02 30       	cpi	r16, 0x02	; 2
    a742:	09 f0       	breq	.+2      	; 0xa746 <FreePrinting+0xf2>
    a744:	1a c2       	rjmp	.+1076   	; 0xab7a <FreePrinting+0x526>
    a746:	0e 94 14 4c 	call	0x9828	; 0x9828 <PrintNormalHeight>
    a74a:	17 c2       	rjmp	.+1070   	; 0xab7a <FreePrinting+0x526>
		  {stFreePrinting=fpInitMessage;
		  }
	      break;
     case fpPrintHeader:
	      //_uart_printf(0,1,PSTR("fpPrintHeader"));
		  if (iSend<40){
    a74c:	80 91 57 02 	lds	r24, 0x0257
    a750:	90 91 58 02 	lds	r25, 0x0258
    a754:	88 97       	sbiw	r24, 0x28	; 40
    a756:	78 f4       	brcc	.+30     	; 0xa776 <FreePrinting+0x122>
		      iLoop++;
    a758:	80 91 53 02 	lds	r24, 0x0253
    a75c:	90 91 54 02 	lds	r25, 0x0254
    a760:	01 96       	adiw	r24, 0x01	; 1
    a762:	90 93 54 02 	sts	0x0254, r25
    a766:	80 93 53 02 	sts	0x0253, r24
			  if ((iLoop%PRINT_DELAY)==0){
			     //_uart(_COM_PRINTER,1,strHeader[iSend]);
		         //iSend++;
				 TimPrintBusy=0;
    a76a:	10 92 cd 01 	sts	0x01CD, r1
    a76e:	10 92 cc 01 	sts	0x01CC, r1
				 stFreePrinting=fpCheckPrintStatusHeader;
    a772:	82 e1       	ldi	r24, 0x12	; 18
    a774:	b3 cf       	rjmp	.-154    	; 0xa6dc <FreePrinting+0x88>
				 }
			  }
          else{ 
		     stFreePrinting=fpLoadHeader;
    a776:	83 e0       	ldi	r24, 0x03	; 3
    a778:	57 c1       	rjmp	.+686    	; 0xaa28 <FreePrinting+0x3d4>
			 CarriegeReturn();
		  }
	      break;

     case fpCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    a77a:	80 91 c9 01 	lds	r24, 0x01C9
    a77e:	88 23       	and	r24, r24
    a780:	09 f0       	breq	.+2      	; 0xa784 <FreePrinting+0x130>
    a782:	71 c1       	rjmp	.+738    	; 0xaa66 <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    a784:	e0 91 57 02 	lds	r30, 0x0257
    a788:	f0 91 58 02 	lds	r31, 0x0258
    a78c:	e7 5a       	subi	r30, 0xA7	; 167
    a78e:	fd 4f       	sbci	r31, 0xFD	; 253
    a790:	61 e0       	ldi	r22, 0x01	; 1
    a792:	40 81       	ld	r20, Z
    a794:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
		      iSend++;
    a798:	80 91 57 02 	lds	r24, 0x0257
    a79c:	90 91 58 02 	lds	r25, 0x0258
    a7a0:	01 96       	adiw	r24, 0x01	; 1
    a7a2:	90 93 58 02 	sts	0x0258, r25
    a7a6:	80 93 57 02 	sts	0x0257, r24
		      stFreePrinting=fpPrintHeader;
    a7aa:	84 e0       	ldi	r24, 0x04	; 4
    a7ac:	5a c1       	rjmp	.+692    	; 0xaa62 <FreePrinting+0x40e>
			  }
	      break;

     case fpInitMessage:
	      //_uart_printf(0,1,PSTR("fpInitMessage"));
	      iSend=0;iLoop=0;
    a7ae:	10 92 58 02 	sts	0x0258, r1
    a7b2:	10 92 57 02 	sts	0x0257, r1
    a7b6:	10 92 54 02 	sts	0x0254, r1
    a7ba:	10 92 53 02 	sts	0x0253, r1
          stFreePrinting=fpPrintMessage; 
    a7be:	08 e0       	ldi	r16, 0x08	; 8
    a7c0:	00 93 25 01 	sts	0x0125, r16
		  CarriegeReturn();
    a7c4:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		  if (iPrinted>0) stFreePrinting=fpInitDuplicate;
    a7c8:	80 91 88 02 	lds	r24, 0x0288
    a7cc:	88 23       	and	r24, r24
    a7ce:	11 f0       	breq	.+4      	; 0xa7d4 <FreePrinting+0x180>
    a7d0:	86 e0       	ldi	r24, 0x06	; 6
    a7d2:	84 cf       	rjmp	.-248    	; 0xa6dc <FreePrinting+0x88>
		  else stFreePrinting=fpPrintMessage; 
    a7d4:	00 93 25 01 	sts	0x0125, r16
    a7d8:	d0 c1       	rjmp	.+928    	; 0xab7a <FreePrinting+0x526>
	      break;
     case fpInitDuplicate:
	      //_uart_printf(0,1,PSTR("fpInitDuplicate"));
          if (iPrinted>0)sprintf_P(strHeader,PSTR("             DUPLICATE COPY        "));
    a7da:	80 91 88 02 	lds	r24, 0x0288
    a7de:	29 e5       	ldi	r18, 0x59	; 89
    a7e0:	32 e0       	ldi	r19, 0x02	; 2
    a7e2:	88 23       	and	r24, r24
    a7e4:	49 f0       	breq	.+18     	; 0xa7f8 <FreePrinting+0x1a4>
    a7e6:	00 d0       	rcall	.+0      	; 0xa7e8 <FreePrinting+0x194>
    a7e8:	00 d0       	rcall	.+0      	; 0xa7ea <FreePrinting+0x196>
    a7ea:	ed b7       	in	r30, 0x3d	; 61
    a7ec:	fe b7       	in	r31, 0x3e	; 62
    a7ee:	32 83       	std	Z+2, r19	; 0x02
    a7f0:	21 83       	std	Z+1, r18	; 0x01
    a7f2:	88 e1       	ldi	r24, 0x18	; 24
    a7f4:	96 e0       	ldi	r25, 0x06	; 6
    a7f6:	08 c0       	rjmp	.+16     	; 0xa808 <FreePrinting+0x1b4>
          else           sprintf_P(strHeader,PSTR("                                   "));
    a7f8:	00 d0       	rcall	.+0      	; 0xa7fa <FreePrinting+0x1a6>
    a7fa:	00 d0       	rcall	.+0      	; 0xa7fc <FreePrinting+0x1a8>
    a7fc:	ed b7       	in	r30, 0x3d	; 61
    a7fe:	fe b7       	in	r31, 0x3e	; 62
    a800:	32 83       	std	Z+2, r19	; 0x02
    a802:	21 83       	std	Z+1, r18	; 0x01
    a804:	84 ef       	ldi	r24, 0xF4	; 244
    a806:	95 e0       	ldi	r25, 0x05	; 5
    a808:	94 83       	std	Z+4, r25	; 0x04
    a80a:	83 83       	std	Z+3, r24	; 0x03
    a80c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    a810:	0f 90       	pop	r0
    a812:	0f 90       	pop	r0
    a814:	0f 90       	pop	r0
    a816:	0f 90       	pop	r0
		  iSend=0;
    a818:	10 92 58 02 	sts	0x0258, r1
    a81c:	10 92 57 02 	sts	0x0257, r1
		  iLoop=0;
    a820:	10 92 54 02 	sts	0x0254, r1
    a824:	10 92 53 02 	sts	0x0253, r1
		  LSend=strlen(strHeader);
    a828:	e9 e5       	ldi	r30, 0x59	; 89
    a82a:	f2 e0       	ldi	r31, 0x02	; 2
    a82c:	01 90       	ld	r0, Z+
    a82e:	00 20       	and	r0, r0
    a830:	e9 f7       	brne	.-6      	; 0xa82c <FreePrinting+0x1d8>
    a832:	31 97       	sbiw	r30, 0x01	; 1
    a834:	e9 55       	subi	r30, 0x59	; 89
    a836:	f2 40       	sbci	r31, 0x02	; 2
    a838:	f0 93 56 02 	sts	0x0256, r31
    a83c:	e0 93 55 02 	sts	0x0255, r30
          stFreePrinting=fpPrintDuplicate; 
    a840:	87 e0       	ldi	r24, 0x07	; 7
    a842:	4c cf       	rjmp	.-360    	; 0xa6dc <FreePrinting+0x88>
	      break;
     case fpPrintDuplicate:
	      //_uart_printf(0,1,PSTR("fpPrintDuplicate"));
		  if (iSend<LSend){
    a844:	20 91 57 02 	lds	r18, 0x0257
    a848:	30 91 58 02 	lds	r19, 0x0258
    a84c:	80 91 55 02 	lds	r24, 0x0255
    a850:	90 91 56 02 	lds	r25, 0x0256
    a854:	28 17       	cp	r18, r24
    a856:	39 07       	cpc	r19, r25
    a858:	78 f4       	brcc	.+30     	; 0xa878 <FreePrinting+0x224>
		      iLoop++;
    a85a:	80 91 53 02 	lds	r24, 0x0253
    a85e:	90 91 54 02 	lds	r25, 0x0254
    a862:	01 96       	adiw	r24, 0x01	; 1
    a864:	90 93 54 02 	sts	0x0254, r25
    a868:	80 93 53 02 	sts	0x0253, r24
			  if((iLoop%PRINT_DELAY)==0){
			     //_uart(_COM_PRINTER,1,strHeader[iSend]);
				 //iSend++;
				 TimPrintBusy=0;
    a86c:	10 92 cd 01 	sts	0x01CD, r1
    a870:	10 92 cc 01 	sts	0x01CC, r1
                 stFreePrinting=fpCheckPrintStatusDuplicate;
    a874:	85 e1       	ldi	r24, 0x15	; 21
    a876:	32 cf       	rjmp	.-412    	; 0xa6dc <FreePrinting+0x88>
				 }
			  }
          else {
		     iSend=0;
    a878:	10 92 58 02 	sts	0x0258, r1
    a87c:	10 92 57 02 	sts	0x0257, r1
		     stFreePrinting=fpPrintMessage;
    a880:	88 e0       	ldi	r24, 0x08	; 8
    a882:	d2 c0       	rjmp	.+420    	; 0xaa28 <FreePrinting+0x3d4>
			 CarriegeReturn();	      
			 }
	      break;
     case fpCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    a884:	80 91 c9 01 	lds	r24, 0x01C9
    a888:	88 23       	and	r24, r24
    a88a:	09 f0       	breq	.+2      	; 0xa88e <FreePrinting+0x23a>
    a88c:	ec c0       	rjmp	.+472    	; 0xaa66 <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    a88e:	e0 91 57 02 	lds	r30, 0x0257
    a892:	f0 91 58 02 	lds	r31, 0x0258
    a896:	e7 5a       	subi	r30, 0xA7	; 167
    a898:	fd 4f       	sbci	r31, 0xFD	; 253
    a89a:	61 e0       	ldi	r22, 0x01	; 1
    a89c:	40 81       	ld	r20, Z
    a89e:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
		      iSend++;
    a8a2:	80 91 57 02 	lds	r24, 0x0257
    a8a6:	90 91 58 02 	lds	r25, 0x0258
    a8aa:	01 96       	adiw	r24, 0x01	; 1
    a8ac:	90 93 58 02 	sts	0x0258, r25
    a8b0:	80 93 57 02 	sts	0x0257, r24
		      stFreePrinting=fpPrintDuplicate;
    a8b4:	87 e0       	ldi	r24, 0x07	; 7
    a8b6:	d5 c0       	rjmp	.+426    	; 0xaa62 <FreePrinting+0x40e>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;

     case fpPrintMessage:
		  if (iSend<LengthMessage81){
    a8b8:	20 91 57 02 	lds	r18, 0x0257
    a8bc:	30 91 58 02 	lds	r19, 0x0258
    a8c0:	80 91 a0 01 	lds	r24, 0x01A0
    a8c4:	90 91 a1 01 	lds	r25, 0x01A1
    a8c8:	28 17       	cp	r18, r24
    a8ca:	39 07       	cpc	r19, r25
    a8cc:	78 f4       	brcc	.+30     	; 0xa8ec <FreePrinting+0x298>
		      iLoop++;
    a8ce:	80 91 53 02 	lds	r24, 0x0253
    a8d2:	90 91 54 02 	lds	r25, 0x0254
    a8d6:	01 96       	adiw	r24, 0x01	; 1
    a8d8:	90 93 54 02 	sts	0x0254, r25
    a8dc:	80 93 53 02 	sts	0x0253, r24
			  if((iLoop%PRINT_DELAY)==0){
			     TimPrintBusy=0;
    a8e0:	10 92 cd 01 	sts	0x01CD, r1
    a8e4:	10 92 cc 01 	sts	0x01CC, r1
				 stFreePrinting=fpCheckPrintStatusMessage;
    a8e8:	83 e1       	ldi	r24, 0x13	; 19
    a8ea:	f8 ce       	rjmp	.-528    	; 0xa6dc <FreePrinting+0x88>
				 }
			  }
          else stFreePrinting=fpInitFooter;
    a8ec:	8b e0       	ldi	r24, 0x0B	; 11
    a8ee:	f6 ce       	rjmp	.-532    	; 0xa6dc <FreePrinting+0x88>
	      break;
     
     case fpCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    a8f0:	80 91 c9 01 	lds	r24, 0x01C9
    a8f4:	88 23       	and	r24, r24
    a8f6:	09 f0       	breq	.+2      	; 0xa8fa <FreePrinting+0x2a6>
    a8f8:	b6 c0       	rjmp	.+364    	; 0xaa66 <FreePrinting+0x412>
              if ((PrintBuffer[iSend]!=0x0D)||(PrintBuffer[iSend]!=0x0A))
			      SendPrint(PrintBuffer[iSend],PrintBuffer[iSend+1]);
    a8fa:	e0 91 57 02 	lds	r30, 0x0257
    a8fe:	f0 91 58 02 	lds	r31, 0x0258
    a902:	e1 5e       	subi	r30, 0xE1	; 225
    a904:	f9 4f       	sbci	r31, 0xF9	; 249
    a906:	80 81       	ld	r24, Z
    a908:	61 81       	ldd	r22, Z+1	; 0x01
    a90a:	0e 94 89 4b 	call	0x9712	; 0x9712 <SendPrint>
			     // _uart(_COM_PRINTER,1,PrintBuffer[iSend]);
              if ((PrintBuffer[iSend]==0x0D)||(PrintBuffer[iSend+1]==0x0A))
    a90e:	e0 91 57 02 	lds	r30, 0x0257
    a912:	f0 91 58 02 	lds	r31, 0x0258
    a916:	e1 5e       	subi	r30, 0xE1	; 225
    a918:	f9 4f       	sbci	r31, 0xF9	; 249
    a91a:	80 81       	ld	r24, Z
    a91c:	8d 30       	cpi	r24, 0x0D	; 13
    a91e:	19 f0       	breq	.+6      	; 0xa926 <FreePrinting+0x2d2>
    a920:	81 81       	ldd	r24, Z+1	; 0x01
    a922:	8a 30       	cpi	r24, 0x0A	; 10
    a924:	11 f4       	brne	.+4      	; 0xa92a <FreePrinting+0x2d6>
			     CarriegeReturn();
    a926:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
             iSend++;
    a92a:	80 91 57 02 	lds	r24, 0x0257
    a92e:	90 91 58 02 	lds	r25, 0x0258
    a932:	01 96       	adiw	r24, 0x01	; 1
    a934:	90 93 58 02 	sts	0x0258, r25
    a938:	80 93 57 02 	sts	0x0257, r24
		     stFreePrinting=fpPrintMessage;
    a93c:	88 e0       	ldi	r24, 0x08	; 8
    a93e:	91 c0       	rjmp	.+290    	; 0xaa62 <FreePrinting+0x40e>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;
     //SpaceAdded
	 case fpInitSpace:
	      iLoop=0;
    a940:	10 92 54 02 	sts	0x0254, r1
    a944:	10 92 53 02 	sts	0x0253, r1
		  iMargin=0;
    a948:	10 92 84 02 	sts	0x0284, r1
		  stFreePrinting=fpPrintMargin;
    a94c:	8a e0       	ldi	r24, 0x0A	; 10
    a94e:	c6 ce       	rjmp	.-628    	; 0xa6dc <FreePrinting+0x88>
	      break;
	 case fpPrintMargin:
		  if (iMargin<PRINT_MARGIN){
    a950:	80 91 84 02 	lds	r24, 0x0284
    a954:	85 30       	cpi	r24, 0x05	; 5
    a956:	90 f4       	brcc	.+36     	; 0xa97c <FreePrinting+0x328>
		      iMargin++;
    a958:	8f 5f       	subi	r24, 0xFF	; 255
    a95a:	80 93 84 02 	sts	0x0284, r24
		      iLoop++;
    a95e:	80 91 53 02 	lds	r24, 0x0253
    a962:	90 91 54 02 	lds	r25, 0x0254
    a966:	01 96       	adiw	r24, 0x01	; 1
    a968:	90 93 54 02 	sts	0x0254, r25
    a96c:	80 93 53 02 	sts	0x0253, r24
	          if ((iLoop%PRINT_DELAY)==0)_uart(_COM_PRINTER,1,' ');
    a970:	80 e0       	ldi	r24, 0x00	; 0
    a972:	61 e0       	ldi	r22, 0x01	; 1
    a974:	40 e2       	ldi	r20, 0x20	; 32
    a976:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    a97a:	ff c0       	rjmp	.+510    	; 0xab7a <FreePrinting+0x526>
			 }
          else stFreePrinting=fpPrintMessage;
    a97c:	88 e0       	ldi	r24, 0x08	; 8
    a97e:	ae ce       	rjmp	.-676    	; 0xa6dc <FreePrinting+0x88>
	      break;
     case fpInitFooter:
	      //_uart_printf(0,1,PSTR("fpInitFooter"));
          if (((cmdPrint&0b01000000)>>6)==1){
    a980:	80 91 cb 01 	lds	r24, 0x01CB
    a984:	86 ff       	sbrs	r24, 6
    a986:	06 c0       	rjmp	.+12     	; 0xa994 <FreePrinting+0x340>
		      stFreePrinting=fpLoadFooter;
    a988:	8c e0       	ldi	r24, 0x0C	; 12
    a98a:	80 93 25 01 	sts	0x0125, r24
			  iFooter=0;
    a98e:	10 92 86 02 	sts	0x0286, r1
    a992:	f3 c0       	rjmp	.+486    	; 0xab7a <FreePrinting+0x526>
			  }
		  else
	      if (((cmdPrint&0b01000000)>>6)==0) stFreePrinting=fpPaperCut;//fpInitScroll;	                
    a994:	80 e1       	ldi	r24, 0x10	; 16
    a996:	a2 ce       	rjmp	.-700    	; 0xa6dc <FreePrinting+0x88>
    a998:	60 91 86 02 	lds	r22, 0x0286
    a99c:	89 e2       	ldi	r24, 0x29	; 41
    a99e:	68 9f       	mul	r22, r24
    a9a0:	b0 01       	movw	r22, r0
    a9a2:	11 24       	eor	r1, r1
    a9a4:	63 5e       	subi	r22, 0xE3	; 227
    a9a6:	7c 4f       	sbci	r23, 0xFC	; 252
    a9a8:	89 e5       	ldi	r24, 0x59	; 89
    a9aa:	92 e0       	ldi	r25, 0x02	; 2
    a9ac:	48 e2       	ldi	r20, 0x28	; 40
    a9ae:	50 e0       	ldi	r21, 0x00	; 0
    a9b0:	25 ed       	ldi	r18, 0xD5	; 213
    a9b2:	32 e1       	ldi	r19, 0x12	; 18
    a9b4:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
	      break;
     case fpLoadFooter:
	 	  //_uart_printf(0,1,PSTR("fpLoadFooter"));
          //Footer 1
	      eeprom_read_block((void*) &strHeader, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    a9b8:	80 91 86 02 	lds	r24, 0x0286
    a9bc:	8f 5f       	subi	r24, 0xFF	; 255
    a9be:	80 93 86 02 	sts	0x0286, r24
		  if (iFooter<4){
    a9c2:	84 30       	cpi	r24, 0x04	; 4
    a9c4:	90 f4       	brcc	.+36     	; 0xa9ea <FreePrinting+0x396>
		      if (SpaceOnly(strHeader)==True){
    a9c6:	89 e5       	ldi	r24, 0x59	; 89
    a9c8:	92 e0       	ldi	r25, 0x02	; 2
    a9ca:	0e 94 99 22 	call	0x4532	; 0x4532 <SpaceOnly>
    a9ce:	81 30       	cpi	r24, 0x01	; 1
    a9d0:	11 f4       	brne	.+4      	; 0xa9d6 <FreePrinting+0x382>
			      stFreePrinting=fpLoadFooter;
    a9d2:	8c e0       	ldi	r24, 0x0C	; 12
    a9d4:	83 ce       	rjmp	.-762    	; 0xa6dc <FreePrinting+0x88>
				  }
			  else{
			      iSend=0;
    a9d6:	10 92 58 02 	sts	0x0258, r1
    a9da:	10 92 57 02 	sts	0x0257, r1
				  iLoop=0;
    a9de:	10 92 54 02 	sts	0x0254, r1
    a9e2:	10 92 53 02 	sts	0x0253, r1
				  stFreePrinting=fpPrintFooter;
    a9e6:	8d e0       	ldi	r24, 0x0D	; 13
    a9e8:	79 ce       	rjmp	.-782    	; 0xa6dc <FreePrinting+0x88>
			      }
		  }else{
		    CarriegeReturn();
    a9ea:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			iPrinted++;
    a9ee:	80 91 88 02 	lds	r24, 0x0288
    a9f2:	8f 5f       	subi	r24, 0xFF	; 255
    a9f4:	80 93 88 02 	sts	0x0288, r24

			//if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_CUBE){
			    stFreePrinting=fpInitScroll;
    a9f8:	8e e0       	ldi	r24, 0x0E	; 14
    a9fa:	70 ce       	rjmp	.-800    	; 0xa6dc <FreePrinting+0x88>
			//}else stFreePrinting=fpPaperCut;

			}
	      break;
     case fpPrintFooter:
		  if (iSend<40){
    a9fc:	80 91 57 02 	lds	r24, 0x0257
    aa00:	90 91 58 02 	lds	r25, 0x0258
    aa04:	88 97       	sbiw	r24, 0x28	; 40
    aa06:	78 f4       	brcc	.+30     	; 0xaa26 <FreePrinting+0x3d2>
		      iLoop++;
    aa08:	80 91 53 02 	lds	r24, 0x0253
    aa0c:	90 91 54 02 	lds	r25, 0x0254
    aa10:	01 96       	adiw	r24, 0x01	; 1
    aa12:	90 93 54 02 	sts	0x0254, r25
    aa16:	80 93 53 02 	sts	0x0253, r24
			  if((iLoop%PRINT_DELAY)==0){
		        //_uart(_COM_PRINTER,1,strHeader[iSend]);
		        //iSend++;
				TimPrintBusy=0;
    aa1a:	10 92 cd 01 	sts	0x01CD, r1
    aa1e:	10 92 cc 01 	sts	0x01CC, r1
				stFreePrinting=fpCheckPrintStatusFooter;
    aa22:	84 e1       	ldi	r24, 0x14	; 20
    aa24:	5b ce       	rjmp	.-842    	; 0xa6dc <FreePrinting+0x88>
				}
			  }
          else {
		      stFreePrinting=fpLoadFooter;
    aa26:	8c e0       	ldi	r24, 0x0C	; 12
    aa28:	80 93 25 01 	sts	0x0125, r24
			  CarriegeReturn();
    aa2c:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
    aa30:	a4 c0       	rjmp	.+328    	; 0xab7a <FreePrinting+0x526>
			  }
	      break;
     
	 case fpCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    aa32:	80 91 c9 01 	lds	r24, 0x01C9
    aa36:	88 23       	and	r24, r24
    aa38:	b1 f4       	brne	.+44     	; 0xaa66 <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    aa3a:	e0 91 57 02 	lds	r30, 0x0257
    aa3e:	f0 91 58 02 	lds	r31, 0x0258
    aa42:	e7 5a       	subi	r30, 0xA7	; 167
    aa44:	fd 4f       	sbci	r31, 0xFD	; 253
    aa46:	61 e0       	ldi	r22, 0x01	; 1
    aa48:	40 81       	ld	r20, Z
    aa4a:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
		      iSend++;
    aa4e:	80 91 57 02 	lds	r24, 0x0257
    aa52:	90 91 58 02 	lds	r25, 0x0258
    aa56:	01 96       	adiw	r24, 0x01	; 1
    aa58:	90 93 58 02 	sts	0x0258, r25
    aa5c:	80 93 57 02 	sts	0x0257, r24
		      stFreePrinting=fpPrintFooter;
    aa60:	8d e0       	ldi	r24, 0x0D	; 13
    aa62:	80 93 25 01 	sts	0x0125, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    aa66:	80 91 cc 01 	lds	r24, 0x01CC
    aa6a:	90 91 cd 01 	lds	r25, 0x01CD
    aa6e:	0b 97       	sbiw	r24, 0x0b	; 11
    aa70:	0c f4       	brge	.+2      	; 0xaa74 <FreePrinting+0x420>
    aa72:	83 c0       	rjmp	.+262    	; 0xab7a <FreePrinting+0x526>
		      IsPrintERROR=True;
    aa74:	81 e0       	ldi	r24, 0x01	; 1
    aa76:	80 93 c7 01 	sts	0x01C7, r24
		      stFreePrinting=fpFinishFreePrinting;
    aa7a:	81 e1       	ldi	r24, 0x11	; 17
    aa7c:	2f ce       	rjmp	.-930    	; 0xa6dc <FreePrinting+0x88>
			  }
	      break;

     case fpInitScroll:
	      iScroll=0;
    aa7e:	10 92 83 02 	sts	0x0283, r1
		  iSend=0;
    aa82:	10 92 58 02 	sts	0x0258, r1
    aa86:	10 92 57 02 	sts	0x0257, r1
		  if (iPrinted<PrintCopy)
    aa8a:	90 91 88 02 	lds	r25, 0x0288
    aa8e:	80 91 85 02 	lds	r24, 0x0285
    aa92:	98 17       	cp	r25, r24
    aa94:	28 f4       	brcc	.+10     	; 0xaaa0 <FreePrinting+0x44c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    aa96:	e1 99       	sbic	0x1c, 1	; 28
    aa98:	fe cf       	rjmp	.-4      	; 0xaa96 <FreePrinting+0x442>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    aa9a:	82 e3       	ldi	r24, 0x32	; 50
    aa9c:	90 e0       	ldi	r25, 0x00	; 0
    aa9e:	04 c0       	rjmp	.+8      	; 0xaaa8 <FreePrinting+0x454>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    aaa0:	e1 99       	sbic	0x1c, 1	; 28
    aaa2:	fe cf       	rjmp	.-4      	; 0xaaa0 <FreePrinting+0x44c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    aaa4:	81 e3       	ldi	r24, 0x31	; 49
    aaa6:	90 e0       	ldi	r25, 0x00	; 0
    aaa8:	9f bb       	out	0x1f, r25	; 31
    aaaa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    aaac:	e0 9a       	sbi	0x1c, 0	; 28
    aaae:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  else if (iPrinted>=PrintCopy)
		  	  nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    aab0:	80 93 82 02 	sts	0x0282, r24

          stFreePrinting=fpScrollPaper;
    aab4:	8f e0       	ldi	r24, 0x0F	; 15
    aab6:	12 ce       	rjmp	.-988    	; 0xa6dc <FreePrinting+0x88>
	      break;
     case fpScrollPaper:
	      if (iScroll>nScroll)stFreePrinting=fpPaperCut;
    aab8:	90 91 83 02 	lds	r25, 0x0283
    aabc:	80 91 82 02 	lds	r24, 0x0282
    aac0:	89 17       	cp	r24, r25
    aac2:	18 f4       	brcc	.+6      	; 0xaaca <FreePrinting+0x476>
    aac4:	80 e1       	ldi	r24, 0x10	; 16
    aac6:	80 93 25 01 	sts	0x0125, r24
		  iSend++;
    aaca:	80 91 57 02 	lds	r24, 0x0257
    aace:	90 91 58 02 	lds	r25, 0x0258
    aad2:	01 96       	adiw	r24, 0x01	; 1
    aad4:	90 93 58 02 	sts	0x0258, r25
    aad8:	80 93 57 02 	sts	0x0257, r24
		  if (iSend%PRINT_DELAY==0){
		      CarriegeReturn();
    aadc:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			  iScroll++;
    aae0:	80 91 83 02 	lds	r24, 0x0283
    aae4:	8f 5f       	subi	r24, 0xFF	; 255
    aae6:	80 93 83 02 	sts	0x0283, r24
    aaea:	47 c0       	rjmp	.+142    	; 0xab7a <FreePrinting+0x526>
			  }
	      break;
     case fpPaperCut:
		  //_uart_printf(0,1,PSTR("fpPaperCut"));
		  //iPrinted++;
          if (iPrinted<PrintCopy){
    aaec:	90 91 88 02 	lds	r25, 0x0288
    aaf0:	80 91 85 02 	lds	r24, 0x0285
    aaf4:	98 17       	cp	r25, r24
    aaf6:	20 f4       	brcc	.+8      	; 0xab00 <FreePrinting+0x4ac>
		      CarriegeReturn();
    aaf8:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
              stFreePrinting=fpInitHeader;
    aafc:	82 e0       	ldi	r24, 0x02	; 2
    aafe:	07 c0       	rjmp	.+14     	; 0xab0e <FreePrinting+0x4ba>
			  }
          else{
		      if (IFType==IT_SLAVE)sendMessage04();
    ab00:	80 91 10 01 	lds	r24, 0x0110
    ab04:	81 30       	cpi	r24, 0x01	; 1
    ab06:	11 f4       	brne	.+4      	; 0xab0c <FreePrinting+0x4b8>
    ab08:	0e 94 c6 52 	call	0xa58c	; 0xa58c <sendMessage04>
		      stFreePrinting=fpFinishFreePrinting;
    ab0c:	81 e1       	ldi	r24, 0x11	; 17
    ab0e:	80 93 25 01 	sts	0x0125, r24
			  }

		  if (((cmdPrint&0b00100000)>>5)==1){
    ab12:	80 91 cb 01 	lds	r24, 0x01CB
    ab16:	85 ff       	sbrs	r24, 5
    ab18:	30 c0       	rjmp	.+96     	; 0xab7a <FreePrinting+0x526>
		      if (iPrinted==0){
    ab1a:	80 91 88 02 	lds	r24, 0x0288
    ab1e:	88 23       	and	r24, r24
    ab20:	31 f4       	brne	.+12     	; 0xab2e <FreePrinting+0x4da>
			      CarriegeReturn();_delay_ms(50);
    ab22:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
    ab26:	84 ed       	ldi	r24, 0xD4	; 212
    ab28:	90 e3       	ldi	r25, 0x30	; 48
    ab2a:	01 97       	sbiw	r24, 0x01	; 1
    ab2c:	f1 f7       	brne	.-4      	; 0xab2a <FreePrinting+0x4d6>
				 }
              //HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
		      if ((iPrinted==PrintCopy)){
    ab2e:	90 91 88 02 	lds	r25, 0x0288
    ab32:	80 91 85 02 	lds	r24, 0x0285
    ab36:	98 17       	cp	r25, r24
    ab38:	b1 f4       	brne	.+44     	; 0xab66 <FreePrinting+0x512>
			      // if (((cmdPrint&0b00010000)>>4)==1){
				       CarriegeReturn();_delay_ms(50);
    ab3a:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
    ab3e:	04 ed       	ldi	r16, 0xD4	; 212
    ab40:	10 e3       	ldi	r17, 0x30	; 48
    ab42:	c8 01       	movw	r24, r16
    ab44:	01 97       	sbiw	r24, 0x01	; 1
    ab46:	f1 f7       	brne	.-4      	; 0xab44 <FreePrinting+0x4f0>
					   CarriegeReturn();_delay_ms(50);
    ab48:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
    ab4c:	c8 01       	movw	r24, r16
    ab4e:	01 97       	sbiw	r24, 0x01	; 1
    ab50:	f1 f7       	brne	.-4      	; 0xab4e <FreePrinting+0x4fa>
					   CarriegeReturn();_delay_ms(50);
    ab52:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
    ab56:	c8 01       	movw	r24, r16
    ab58:	01 97       	sbiw	r24, 0x01	; 1
    ab5a:	f1 f7       	brne	.-4      	; 0xab58 <FreePrinting+0x504>
					   CarriegeReturn();_delay_ms(50);
    ab5c:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
    ab60:	c8 01       	movw	r24, r16
    ab62:	01 97       	sbiw	r24, 0x01	; 1
    ab64:	f1 f7       	brne	.-4      	; 0xab62 <FreePrinting+0x50e>
				   //}
				 }
		      PaperCut();
    ab66:	0e 94 48 4c 	call	0x9890	; 0x9890 <PaperCut>
    ab6a:	07 c0       	rjmp	.+14     	; 0xab7a <FreePrinting+0x526>
		   }
	      break;
     case fpFinishFreePrinting:
	 	  //_uart_printf(0,1,PSTR("fpFinished"));
		  IsBusyFreePrinting=False;
    ab6c:	10 92 ca 01 	sts	0x01CA, r1
	      stFreePrinting=fpInit;
    ab70:	81 e0       	ldi	r24, 0x01	; 1
    ab72:	80 93 25 01 	sts	0x0125, r24
		  iPrinted=0;
    ab76:	10 92 88 02 	sts	0x0288, r1
	      break;
	 }//EndCase
}
    ab7a:	1f 91       	pop	r17
    ab7c:	0f 91       	pop	r16
    ab7e:	08 95       	ret

0000ab80 <PrintIdle>:
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);   
		}
}

void PrintIdle(){
    ab80:	cf 93       	push	r28
    ab82:	df 93       	push	r29
		_uart_print(1,1,strSend);
	 }
	 #endif

     //Normalize PrintIdleState
     if ((IsPrinting==True)&&(stPrintIdle!=piIdle)){
    ab84:	80 91 c3 01 	lds	r24, 0x01C3
    ab88:	81 30       	cpi	r24, 0x01	; 1
    ab8a:	31 f4       	brne	.+12     	; 0xab98 <PrintIdle+0x18>
    ab8c:	80 91 c6 02 	lds	r24, 0x02C6
    ab90:	88 23       	and	r24, r24
    ab92:	11 f0       	breq	.+4      	; 0xab98 <PrintIdle+0x18>
	     stPrintIdle=piIdle;
    ab94:	10 92 c6 02 	sts	0x02C6, r1
	 }

     switch(stPrintIdle){
    ab98:	80 91 c6 02 	lds	r24, 0x02C6
    ab9c:	e8 2f       	mov	r30, r24
    ab9e:	f0 e0       	ldi	r31, 0x00	; 0
    aba0:	e5 31       	cpi	r30, 0x15	; 21
    aba2:	f1 05       	cpc	r31, r1
    aba4:	08 f0       	brcs	.+2      	; 0xaba8 <PrintIdle+0x28>
    aba6:	0f c7       	rjmp	.+3614   	; 0xb9c6 <PrintIdle+0xe46>
    aba8:	e7 58       	subi	r30, 0x87	; 135
    abaa:	ff 4f       	sbci	r31, 0xFF	; 255
    abac:	ee 0f       	add	r30, r30
    abae:	ff 1f       	adc	r31, r31
    abb0:	05 90       	lpm	r0, Z+
    abb2:	f4 91       	lpm	r31, Z+
    abb4:	e0 2d       	mov	r30, r0
    abb6:	09 94       	ijmp
	 case piIdle:
	      if (IsPrinting==True){
    abb8:	80 91 c3 01 	lds	r24, 0x01C3
    abbc:	81 30       	cpi	r24, 0x01	; 1
    abbe:	09 f0       	breq	.+2      	; 0xabc2 <PrintIdle+0x42>
    abc0:	02 c7       	rjmp	.+3588   	; 0xb9c6 <PrintIdle+0xe46>
		      IsPrinting=False;
    abc2:	10 92 c3 01 	sts	0x01C3, r1
			  IsBusyIdlePrinting=True;
    abc6:	80 93 c8 01 	sts	0x01C8, r24
			  IsBusyPrint=False;
    abca:	10 92 c9 01 	sts	0x01C9, r1
			  iPrinted=0;
    abce:	10 92 8b 02 	sts	0x028B, r1
			  PrintCopy=0;
    abd2:	10 92 8a 02 	sts	0x028A, r1
		      stPrintIdle=piInit;
    abd6:	80 93 c6 02 	sts	0x02C6, r24
			  InitPrinter();
    abda:	0e 94 ac 4b 	call	0x9758	; 0x9758 <InitPrinter>
			  IsSignedField=False;
    abde:	10 92 92 02 	sts	0x0292, r1
    abe2:	f1 c6       	rjmp	.+3554   	; 0xb9c6 <PrintIdle+0xe46>
			  }
	      break;
	 case piInit:
	      iHeader=0;
    abe4:	10 92 c5 02 	sts	0x02C5, r1
		  CarriegeReturn();
    abe8:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
    abec:	1d c0       	rjmp	.+58     	; 0xac28 <PrintIdle+0xa8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    abee:	60 91 c5 02 	lds	r22, 0x02C5
    abf2:	89 e2       	ldi	r24, 0x29	; 41
    abf4:	68 9f       	mul	r22, r24
    abf6:	b0 01       	movw	r22, r0
    abf8:	11 24       	eor	r1, r1
    abfa:	69 5d       	subi	r22, 0xD9	; 217
    abfc:	7d 4f       	sbci	r23, 0xFD	; 253
    abfe:	85 e9       	ldi	r24, 0x95	; 149
    ac00:	92 e0       	ldi	r25, 0x02	; 2
    ac02:	49 e2       	ldi	r20, 0x29	; 41
    ac04:	50 e0       	ldi	r21, 0x00	; 0
    ac06:	25 ed       	ldi	r18, 0xD5	; 213
    ac08:	32 e1       	ldi	r19, 0x12	; 18
    ac0a:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
		  stPrintIdle=piLoadHeader;
	      break;
     case piLoadHeader:
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[iHeader], sizeof(DefHeaderFooter[iHeader]));
		  iHeader++;
    ac0e:	80 91 c5 02 	lds	r24, 0x02C5
    ac12:	8f 5f       	subi	r24, 0xFF	; 255
    ac14:	80 93 c5 02 	sts	0x02C5, r24
		  if (iHeader<6){
    ac18:	86 30       	cpi	r24, 0x06	; 6
    ac1a:	00 f5       	brcc	.+64     	; 0xac5c <PrintIdle+0xdc>
		      if (SpaceOnly(strPrint)==True){
    ac1c:	85 e9       	ldi	r24, 0x95	; 149
    ac1e:	92 e0       	ldi	r25, 0x02	; 2
    ac20:	0e 94 99 22 	call	0x4532	; 0x4532 <SpaceOnly>
    ac24:	81 30       	cpi	r24, 0x01	; 1
    ac26:	11 f4       	brne	.+4      	; 0xac2c <PrintIdle+0xac>
			      stPrintIdle=piLoadHeader;
    ac28:	82 e0       	ldi	r24, 0x02	; 2
    ac2a:	a2 c6       	rjmp	.+3396   	; 0xb970 <PrintIdle+0xdf0>
				  }	      
			  else{
			      stPrintIdle=piPrintHeader;
    ac2c:	83 e0       	ldi	r24, 0x03	; 3
    ac2e:	80 93 c6 02 	sts	0x02C6, r24
			      iSend=0;
    ac32:	10 92 91 02 	sts	0x0291, r1
    ac36:	10 92 90 02 	sts	0x0290, r1
				  iLoop=0;
    ac3a:	10 92 8d 02 	sts	0x028D, r1
    ac3e:	10 92 8c 02 	sts	0x028C, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    ac42:	80 91 c5 02 	lds	r24, 0x02C5
    ac46:	81 30       	cpi	r24, 0x01	; 1
    ac48:	19 f4       	brne	.+6      	; 0xac50 <PrintIdle+0xd0>
    ac4a:	0e 94 2e 4c 	call	0x985c	; 0x985c <PrintDoubleHeight>
    ac4e:	bb c6       	rjmp	.+3446   	; 0xb9c6 <PrintIdle+0xe46>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    ac50:	82 30       	cpi	r24, 0x02	; 2
    ac52:	09 f0       	breq	.+2      	; 0xac56 <PrintIdle+0xd6>
    ac54:	b8 c6       	rjmp	.+3440   	; 0xb9c6 <PrintIdle+0xe46>
    ac56:	0e 94 14 4c 	call	0x9828	; 0x9828 <PrintNormalHeight>
    ac5a:	b5 c6       	rjmp	.+3434   	; 0xb9c6 <PrintIdle+0xe46>
			   }
		  }else{stPrintIdle=piInitDuplicate; //stPrintIdle=piInitMessage;//
    ac5c:	84 e0       	ldi	r24, 0x04	; 4
    ac5e:	88 c6       	rjmp	.+3344   	; 0xb970 <PrintIdle+0xdf0>
		        //else stPrintIdle=piInitMessage;
		  }
	      break;
	 case piPrintHeader:
		  if (iSend<40){
    ac60:	80 91 90 02 	lds	r24, 0x0290
    ac64:	90 91 91 02 	lds	r25, 0x0291
    ac68:	88 97       	sbiw	r24, 0x28	; 40
    ac6a:	78 f4       	brcc	.+30     	; 0xac8a <PrintIdle+0x10a>
		      iLoop++;
    ac6c:	80 91 8c 02 	lds	r24, 0x028C
    ac70:	90 91 8d 02 	lds	r25, 0x028D
    ac74:	01 96       	adiw	r24, 0x01	; 1
    ac76:	90 93 8d 02 	sts	0x028D, r25
    ac7a:	80 93 8c 02 	sts	0x028C, r24
			  if ((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    ac7e:	10 92 cd 01 	sts	0x01CD, r1
    ac82:	10 92 cc 01 	sts	0x01CC, r1
				 stPrintIdle=piCheckPrintStatusHeader;
    ac86:	8b e0       	ldi	r24, 0x0B	; 11
    ac88:	73 c6       	rjmp	.+3302   	; 0xb970 <PrintIdle+0xdf0>
				 }
			  }
          else{ 
		     stPrintIdle=piLoadHeader;
    ac8a:	82 e0       	ldi	r24, 0x02	; 2
    ac8c:	01 c6       	rjmp	.+3074   	; 0xb890 <PrintIdle+0xd10>
			 CarriegeReturn();
		  }
	      break;
     case piCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    ac8e:	80 91 c9 01 	lds	r24, 0x01C9
    ac92:	88 23       	and	r24, r24
    ac94:	09 f0       	breq	.+2      	; 0xac98 <PrintIdle+0x118>
    ac96:	62 c6       	rjmp	.+3268   	; 0xb95c <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    ac98:	e0 91 90 02 	lds	r30, 0x0290
    ac9c:	f0 91 91 02 	lds	r31, 0x0291
    aca0:	eb 56       	subi	r30, 0x6B	; 107
    aca2:	fd 4f       	sbci	r31, 0xFD	; 253
    aca4:	61 e0       	ldi	r22, 0x01	; 1
    aca6:	40 81       	ld	r20, Z
    aca8:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
		      iSend++;
    acac:	80 91 90 02 	lds	r24, 0x0290
    acb0:	90 91 91 02 	lds	r25, 0x0291
    acb4:	01 96       	adiw	r24, 0x01	; 1
    acb6:	90 93 91 02 	sts	0x0291, r25
    acba:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintHeader;
    acbe:	83 e0       	ldi	r24, 0x03	; 3
    acc0:	4b c6       	rjmp	.+3222   	; 0xb958 <PrintIdle+0xdd8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitDuplicate:
          if ((iPrinted>0)||(IsReprintTicket==True)){
    acc2:	80 91 8b 02 	lds	r24, 0x028B
    acc6:	88 23       	and	r24, r24
    acc8:	21 f4       	brne	.+8      	; 0xacd2 <PrintIdle+0x152>
    acca:	80 91 92 01 	lds	r24, 0x0192
    acce:	81 30       	cpi	r24, 0x01	; 1
    acd0:	a9 f4       	brne	.+42     	; 0xacfc <PrintIdle+0x17c>
		      IsReprintTicket=False;
    acd2:	10 92 92 01 	sts	0x0192, r1
		      CarriegeReturn(); 
    acd6:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		      sprintf_P(strPrint,PSTR("             DUPLICATE COPY        "));
    acda:	00 d0       	rcall	.+0      	; 0xacdc <PrintIdle+0x15c>
    acdc:	00 d0       	rcall	.+0      	; 0xacde <PrintIdle+0x15e>
    acde:	85 e9       	ldi	r24, 0x95	; 149
    ace0:	92 e0       	ldi	r25, 0x02	; 2
    ace2:	ad b7       	in	r26, 0x3d	; 61
    ace4:	be b7       	in	r27, 0x3e	; 62
    ace6:	12 96       	adiw	r26, 0x02	; 2
    ace8:	9c 93       	st	X, r25
    acea:	8e 93       	st	-X, r24
    acec:	11 97       	sbiw	r26, 0x01	; 1
    acee:	83 e0       	ldi	r24, 0x03	; 3
    acf0:	9a e0       	ldi	r25, 0x0A	; 10
    acf2:	14 96       	adiw	r26, 0x04	; 4
    acf4:	9c 93       	st	X, r25
    acf6:	8e 93       	st	-X, r24
    acf8:	13 97       	sbiw	r26, 0x03	; 3
    acfa:	0c c0       	rjmp	.+24     	; 0xad14 <PrintIdle+0x194>
		      }
          else{           sprintf_P(strPrint,PSTR(" "));
    acfc:	00 d0       	rcall	.+0      	; 0xacfe <PrintIdle+0x17e>
    acfe:	00 d0       	rcall	.+0      	; 0xad00 <PrintIdle+0x180>
    ad00:	85 e9       	ldi	r24, 0x95	; 149
    ad02:	92 e0       	ldi	r25, 0x02	; 2
    ad04:	ed b7       	in	r30, 0x3d	; 61
    ad06:	fe b7       	in	r31, 0x3e	; 62
    ad08:	92 83       	std	Z+2, r25	; 0x02
    ad0a:	81 83       	std	Z+1, r24	; 0x01
    ad0c:	81 e0       	ldi	r24, 0x01	; 1
    ad0e:	9a e0       	ldi	r25, 0x0A	; 10
    ad10:	94 83       	std	Z+4, r25	; 0x04
    ad12:	83 83       	std	Z+3, r24	; 0x03
    ad14:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    ad18:	0f 90       	pop	r0
    ad1a:	0f 90       	pop	r0
    ad1c:	0f 90       	pop	r0
    ad1e:	0f 90       	pop	r0
		      }
		  iSend=0;
    ad20:	10 92 91 02 	sts	0x0291, r1
    ad24:	10 92 90 02 	sts	0x0290, r1
		  iLoop=0;
    ad28:	10 92 8d 02 	sts	0x028D, r1
    ad2c:	10 92 8c 02 	sts	0x028C, r1
		  LSend=strlen(strPrint);
    ad30:	e5 e9       	ldi	r30, 0x95	; 149
    ad32:	f2 e0       	ldi	r31, 0x02	; 2
    ad34:	01 90       	ld	r0, Z+
    ad36:	00 20       	and	r0, r0
    ad38:	e9 f7       	brne	.-6      	; 0xad34 <PrintIdle+0x1b4>
    ad3a:	31 97       	sbiw	r30, 0x01	; 1
    ad3c:	e5 59       	subi	r30, 0x95	; 149
    ad3e:	f2 40       	sbci	r31, 0x02	; 2
    ad40:	f0 93 8f 02 	sts	0x028F, r31
    ad44:	e0 93 8e 02 	sts	0x028E, r30
          stPrintIdle=piPrintDuplicate; 
    ad48:	85 e0       	ldi	r24, 0x05	; 5
    ad4a:	12 c6       	rjmp	.+3108   	; 0xb970 <PrintIdle+0xdf0>
	      break;
     case piPrintDuplicate:
		  if (iSend<LSend){
    ad4c:	20 91 90 02 	lds	r18, 0x0290
    ad50:	30 91 91 02 	lds	r19, 0x0291
    ad54:	80 91 8e 02 	lds	r24, 0x028E
    ad58:	90 91 8f 02 	lds	r25, 0x028F
    ad5c:	28 17       	cp	r18, r24
    ad5e:	39 07       	cpc	r19, r25
    ad60:	78 f4       	brcc	.+30     	; 0xad80 <PrintIdle+0x200>
		      iLoop++;
    ad62:	80 91 8c 02 	lds	r24, 0x028C
    ad66:	90 91 8d 02 	lds	r25, 0x028D
    ad6a:	01 96       	adiw	r24, 0x01	; 1
    ad6c:	90 93 8d 02 	sts	0x028D, r25
    ad70:	80 93 8c 02 	sts	0x028C, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    ad74:	10 92 cd 01 	sts	0x01CD, r1
    ad78:	10 92 cc 01 	sts	0x01CC, r1
                 stPrintIdle=piCheckPrintStatusDuplicate;
    ad7c:	86 e0       	ldi	r24, 0x06	; 6
    ad7e:	f8 c5       	rjmp	.+3056   	; 0xb970 <PrintIdle+0xdf0>
				 }
			  }
          else {
		     iSend=0;
    ad80:	10 92 91 02 	sts	0x0291, r1
    ad84:	10 92 90 02 	sts	0x0290, r1
		     stPrintIdle=piInitMessage;
    ad88:	87 e0       	ldi	r24, 0x07	; 7
    ad8a:	f2 c5       	rjmp	.+3044   	; 0xb970 <PrintIdle+0xdf0>
			 }
	      break;
     case piCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    ad8c:	80 91 c9 01 	lds	r24, 0x01C9
    ad90:	88 23       	and	r24, r24
    ad92:	09 f0       	breq	.+2      	; 0xad96 <PrintIdle+0x216>
    ad94:	e3 c5       	rjmp	.+3014   	; 0xb95c <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    ad96:	e0 91 90 02 	lds	r30, 0x0290
    ad9a:	f0 91 91 02 	lds	r31, 0x0291
    ad9e:	eb 56       	subi	r30, 0x6B	; 107
    ada0:	fd 4f       	sbci	r31, 0xFD	; 253
    ada2:	61 e0       	ldi	r22, 0x01	; 1
    ada4:	40 81       	ld	r20, Z
    ada6:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
    adaa:	84 ec       	ldi	r24, 0xC4	; 196
    adac:	99 e0       	ldi	r25, 0x09	; 9
    adae:	01 97       	sbiw	r24, 0x01	; 1
    adb0:	f1 f7       	brne	.-4      	; 0xadae <PrintIdle+0x22e>
			  _delay_ms(10);
		      iSend++;
    adb2:	80 91 90 02 	lds	r24, 0x0290
    adb6:	90 91 91 02 	lds	r25, 0x0291
    adba:	01 96       	adiw	r24, 0x01	; 1
    adbc:	90 93 91 02 	sts	0x0291, r25
    adc0:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintDuplicate;
    adc4:	85 e0       	ldi	r24, 0x05	; 5
    adc6:	c8 c5       	rjmp	.+2960   	; 0xb958 <PrintIdle+0xdd8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitMessage:
	      iSend=0;iLoop=0;
    adc8:	10 92 91 02 	sts	0x0291, r1
    adcc:	10 92 90 02 	sts	0x0290, r1
    add0:	10 92 8d 02 	sts	0x028D, r1
    add4:	10 92 8c 02 	sts	0x028C, r1
		  iMessage=0;
    add8:	10 92 94 02 	sts	0x0294, r1
		  switch(MOPType){
    addc:	80 91 cf 01 	lds	r24, 0x01CF
    ade0:	83 30       	cpi	r24, 0x03	; 3
    ade2:	81 f0       	breq	.+32     	; 0xae04 <PrintIdle+0x284>
    ade4:	84 30       	cpi	r24, 0x04	; 4
    ade6:	28 f4       	brcc	.+10     	; 0xadf2 <PrintIdle+0x272>
    ade8:	81 30       	cpi	r24, 0x01	; 1
    adea:	61 f0       	breq	.+24     	; 0xae04 <PrintIdle+0x284>
    adec:	82 30       	cpi	r24, 0x02	; 2
    adee:	40 f4       	brcc	.+16     	; 0xae00 <PrintIdle+0x280>
    adf0:	10 c0       	rjmp	.+32     	; 0xae12 <PrintIdle+0x292>
    adf2:	88 30       	cpi	r24, 0x08	; 8
    adf4:	49 f0       	breq	.+18     	; 0xae08 <PrintIdle+0x288>
    adf6:	89 30       	cpi	r24, 0x09	; 9
    adf8:	61 f0       	breq	.+24     	; 0xae12 <PrintIdle+0x292>
    adfa:	87 30       	cpi	r24, 0x07	; 7
    adfc:	51 f4       	brne	.+20     	; 0xae12 <PrintIdle+0x292>
    adfe:	02 c0       	rjmp	.+4      	; 0xae04 <PrintIdle+0x284>
		  case MOP_CASH:
		       MessageLine=10;
			   PrintCopy=1;
		       break;
          case MOP_CREDIT_CARD:
		       MessageLine=10;
    ae00:	8a e0       	ldi	r24, 0x0A	; 10
    ae02:	03 c0       	rjmp	.+6      	; 0xae0a <PrintIdle+0x28a>
          case MOP_LOCAL_ACCOUNT:
		       MessageLine=20;
			   PrintCopy=2;
		       break;
          case MOP_VOUCHER:
		       MessageLine=20;
    ae04:	84 e1       	ldi	r24, 0x14	; 20
    ae06:	01 c0       	rjmp	.+2      	; 0xae0a <PrintIdle+0x28a>
			   PrintCopy=2;
		       break;
          case MOP_PUMP_TEST:
		       MessageLine=12;
    ae08:	8c e0       	ldi	r24, 0x0C	; 12
    ae0a:	80 93 93 02 	sts	0x0293, r24
			   PrintCopy=2;
    ae0e:	82 e0       	ldi	r24, 0x02	; 2
    ae10:	04 c0       	rjmp	.+8      	; 0xae1a <PrintIdle+0x29a>
          case MOP_VOID_CARD:
		       MessageLine=10;
			   PrintCopy=1;
		       break;          
          default:
		       MessageLine=10;
    ae12:	8a e0       	ldi	r24, 0x0A	; 10
    ae14:	80 93 93 02 	sts	0x0293, r24
			   PrintCopy=1;
    ae18:	81 e0       	ldi	r24, 0x01	; 1
    ae1a:	80 93 8a 02 	sts	0x028A, r24
		       break; 
		  }
		  //LoyaltyDetection
          if ((strlen(strLoyCardID)>0)&&(SpaceOnly(strLoyCardID)==False)){
    ae1e:	80 91 c7 04 	lds	r24, 0x04C7
    ae22:	88 23       	and	r24, r24
    ae24:	49 f0       	breq	.+18     	; 0xae38 <PrintIdle+0x2b8>
    ae26:	87 ec       	ldi	r24, 0xC7	; 199
    ae28:	94 e0       	ldi	r25, 0x04	; 4
    ae2a:	0e 94 99 22 	call	0x4532	; 0x4532 <SpaceOnly>
    ae2e:	88 23       	and	r24, r24
    ae30:	19 f4       	brne	.+6      	; 0xae38 <PrintIdle+0x2b8>
		       MessageLine=33;
    ae32:	81 e2       	ldi	r24, 0x21	; 33
    ae34:	80 93 93 02 	sts	0x0293, r24
		  }
          //stPrintIdle=piLoadMessage;
		  stPrintIdle=piFormatingMessage;
    ae38:	88 e0       	ldi	r24, 0x08	; 8
    ae3a:	9a c5       	rjmp	.+2868   	; 0xb970 <PrintIdle+0xdf0>
	      break;
     case piFormatingMessage:
	      if (iPrinted==0){
    ae3c:	80 91 8b 02 	lds	r24, 0x028B
    ae40:	88 23       	and	r24, r24
    ae42:	09 f0       	breq	.+2      	; 0xae46 <PrintIdle+0x2c6>
    ae44:	c8 c4       	rjmp	.+2448   	; 0xb7d6 <PrintIdle+0xc56>

		      FormatDate(DATE_LONG_YEAR,strDate);
    ae46:	61 ea       	ldi	r22, 0xA1	; 161
    ae48:	79 e0       	ldi	r23, 0x09	; 9
    ae4a:	0e 94 6d 23 	call	0x46da	; 0x46da <FormatDate>
              RemZeroLead(strIslandID);
    ae4e:	8f e1       	ldi	r24, 0x1F	; 31
    ae50:	9b e0       	ldi	r25, 0x0B	; 11
    ae52:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
			  RemZeroLead(strFIP_ID);
    ae56:	8c ee       	ldi	r24, 0xEC	; 236
    ae58:	99 e0       	ldi	r25, 0x09	; 9
    ae5a:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
		      RemZeroLead(strPrice);              
    ae5e:	81 ed       	ldi	r24, 0xD1	; 209
    ae60:	97 e0       	ldi	r25, 0x07	; 7
    ae62:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
              if (IFType==IT_SLAVE)
    ae66:	80 91 10 01 	lds	r24, 0x0110
    ae6a:	81 30       	cpi	r24, 0x01	; 1
    ae6c:	21 f4       	brne	.+8      	; 0xae76 <PrintIdle+0x2f6>
			      RemZeroLead(strVolume);
    ae6e:	85 e5       	ldi	r24, 0x55	; 85
    ae70:	95 e0       	ldi	r25, 0x05	; 5
    ae72:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
              RemZeroLead(strAmount);
    ae76:	8b ed       	ldi	r24, 0xDB	; 219
    ae78:	9d e0       	ldi	r25, 0x0D	; 13
    ae7a:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>

			  RemDecimal(strPrice);
    ae7e:	81 ed       	ldi	r24, 0xD1	; 209
    ae80:	97 e0       	ldi	r25, 0x07	; 7
    ae82:	0e 94 b6 22 	call	0x456c	; 0x456c <RemDecimal>
			  RemDecimal(strAmount);
    ae86:	8b ed       	ldi	r24, 0xDB	; 219
    ae88:	9d e0       	ldi	r25, 0x0D	; 13
    ae8a:	0e 94 b6 22 	call	0x456c	; 0x456c <RemDecimal>
	  
			  FormatCurrency(strPrice);
    ae8e:	81 ed       	ldi	r24, 0xD1	; 209
    ae90:	97 e0       	ldi	r25, 0x07	; 7
    ae92:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>
			  FormatCurrency(strAmount);
    ae96:	8b ed       	ldi	r24, 0xDB	; 219
    ae98:	9d e0       	ldi	r25, 0x0D	; 13
    ae9a:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>
              if (IFType==IT_SLAVE){
    ae9e:	80 91 10 01 	lds	r24, 0x0110
    aea2:	81 30       	cpi	r24, 0x01	; 1
    aea4:	09 f0       	breq	.+2      	; 0xaea8 <PrintIdle+0x328>
    aea6:	97 c4       	rjmp	.+2350   	; 0xb7d6 <PrintIdle+0xc56>
		          RemSpaceLag(strCardID);
    aea8:	81 eb       	ldi	r24, 0xB1	; 177
    aeaa:	9d e0       	ldi	r25, 0x0D	; 13
    aeac:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		          RemSpaceLag(strCardHolder);
    aeb0:	84 e0       	ldi	r24, 0x04	; 4
    aeb2:	95 e0       	ldi	r25, 0x05	; 5
    aeb4:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		          RemSpaceLag(strMOPName);
    aeb8:	80 eb       	ldi	r24, 0xB0	; 176
    aeba:	97 e0       	ldi	r25, 0x07	; 7
    aebc:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		          RemSpaceLag(strLoyCardHolder);
    aec0:	84 ea       	ldi	r24, 0xA4	; 164
    aec2:	94 e0       	ldi	r25, 0x04	; 4
    aec4:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		          RemSpaceLag(strCorporateID);
    aec8:	85 e3       	ldi	r24, 0x35	; 53
    aeca:	9e e0       	ldi	r25, 0x0E	; 14
    aecc:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		          RemSpaceLag(strCorporateName);
    aed0:	8d ef       	ldi	r24, 0xFD	; 253
    aed2:	95 e0       	ldi	r25, 0x05	; 5
    aed4:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		          RemSpaceLag(strLoyRedeemPoints);
    aed8:	8a ec       	ldi	r24, 0xCA	; 202
    aeda:	95 e0       	ldi	r25, 0x05	; 5
    aedc:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		          RemSpaceLag(strLoyCurrMonConsumeV);
    aee0:	88 e1       	ldi	r24, 0x18	; 24
    aee2:	9e e0       	ldi	r25, 0x0E	; 14
    aee4:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
				  RemSpaceLag(strLoyCurrMonConsumeA);
    aee8:	8e ea       	ldi	r24, 0xAE	; 174
    aeea:	95 e0       	ldi	r25, 0x05	; 5
    aeec:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		          FormatCurrency(strLoyCurrMonConsumeV);              
    aef0:	88 e1       	ldi	r24, 0x18	; 24
    aef2:	9e e0       	ldi	r25, 0x0E	; 14
    aef4:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>
		          FormatCurrency(strLoyCurrMonConsumeA);
    aef8:	8e ea       	ldi	r24, 0xAE	; 174
    aefa:	95 e0       	ldi	r25, 0x05	; 5
    aefc:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>
    af00:	6a c4       	rjmp	.+2260   	; 0xb7d6 <PrintIdle+0xc56>
			   }
		  }
          stPrintIdle=piLoadMessage;
	      break;
     case piLoadMessage:
	      switch(iMessage){
    af02:	80 91 94 02 	lds	r24, 0x0294
    af06:	e8 2f       	mov	r30, r24
    af08:	f0 e0       	ldi	r31, 0x00	; 0
    af0a:	e5 32       	cpi	r30, 0x25	; 37
    af0c:	f1 05       	cpc	r31, r1
    af0e:	08 f0       	brcs	.+2      	; 0xaf12 <PrintIdle+0x392>
    af10:	26 c4       	rjmp	.+2124   	; 0xb75e <PrintIdle+0xbde>
    af12:	e2 57       	subi	r30, 0x72	; 114
    af14:	ff 4f       	sbci	r31, 0xFF	; 255
    af16:	ee 0f       	add	r30, r30
    af18:	ff 1f       	adc	r31, r31
    af1a:	05 90       	lpm	r0, Z+
    af1c:	f4 91       	lpm	r31, Z+
    af1e:	e0 2d       	mov	r30, r0
    af20:	09 94       	ijmp
		  case 0:
		       CarriegeReturn();
    af22:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Shift: %s  No.Trans: %s "),strShift,strTranNo);
    af26:	8d b7       	in	r24, 0x3d	; 61
    af28:	9e b7       	in	r25, 0x3e	; 62
    af2a:	08 97       	sbiw	r24, 0x08	; 8
    af2c:	0f b6       	in	r0, 0x3f	; 63
    af2e:	f8 94       	cli
    af30:	9e bf       	out	0x3e, r25	; 62
    af32:	0f be       	out	0x3f, r0	; 63
    af34:	8d bf       	out	0x3d, r24	; 61
    af36:	ed b7       	in	r30, 0x3d	; 61
    af38:	fe b7       	in	r31, 0x3e	; 62
    af3a:	31 96       	adiw	r30, 0x01	; 1
    af3c:	85 e9       	ldi	r24, 0x95	; 149
    af3e:	92 e0       	ldi	r25, 0x02	; 2
    af40:	ad b7       	in	r26, 0x3d	; 61
    af42:	be b7       	in	r27, 0x3e	; 62
    af44:	12 96       	adiw	r26, 0x02	; 2
    af46:	9c 93       	st	X, r25
    af48:	8e 93       	st	-X, r24
    af4a:	11 97       	sbiw	r26, 0x01	; 1
    af4c:	82 ee       	ldi	r24, 0xE2	; 226
    af4e:	99 e0       	ldi	r25, 0x09	; 9
    af50:	93 83       	std	Z+3, r25	; 0x03
    af52:	82 83       	std	Z+2, r24	; 0x02
    af54:	83 e9       	ldi	r24, 0x93	; 147
    af56:	9e e0       	ldi	r25, 0x0E	; 14
    af58:	95 83       	std	Z+5, r25	; 0x05
    af5a:	84 83       	std	Z+4, r24	; 0x04
    af5c:	81 eb       	ldi	r24, 0xB1	; 177
    af5e:	9e e0       	ldi	r25, 0x0E	; 14
    af60:	1f c0       	rjmp	.+62     	; 0xafa0 <PrintIdle+0x420>
		       break;
		  case 1:
		       //FormatDate(strDate);
			   CarriegeReturn();
    af62:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Waktu: %s %s "),strDate,strTime);
    af66:	8d b7       	in	r24, 0x3d	; 61
    af68:	9e b7       	in	r25, 0x3e	; 62
    af6a:	08 97       	sbiw	r24, 0x08	; 8
    af6c:	0f b6       	in	r0, 0x3f	; 63
    af6e:	f8 94       	cli
    af70:	9e bf       	out	0x3e, r25	; 62
    af72:	0f be       	out	0x3f, r0	; 63
    af74:	8d bf       	out	0x3d, r24	; 61
    af76:	ed b7       	in	r30, 0x3d	; 61
    af78:	fe b7       	in	r31, 0x3e	; 62
    af7a:	31 96       	adiw	r30, 0x01	; 1
    af7c:	85 e9       	ldi	r24, 0x95	; 149
    af7e:	92 e0       	ldi	r25, 0x02	; 2
    af80:	ad b7       	in	r26, 0x3d	; 61
    af82:	be b7       	in	r27, 0x3e	; 62
    af84:	12 96       	adiw	r26, 0x02	; 2
    af86:	9c 93       	st	X, r25
    af88:	8e 93       	st	-X, r24
    af8a:	11 97       	sbiw	r26, 0x01	; 1
    af8c:	8e ec       	ldi	r24, 0xCE	; 206
    af8e:	99 e0       	ldi	r25, 0x09	; 9
    af90:	93 83       	std	Z+3, r25	; 0x03
    af92:	82 83       	std	Z+2, r24	; 0x02
    af94:	81 ea       	ldi	r24, 0xA1	; 161
    af96:	99 e0       	ldi	r25, 0x09	; 9
    af98:	95 83       	std	Z+5, r25	; 0x05
    af9a:	84 83       	std	Z+4, r24	; 0x04
    af9c:	8d e2       	ldi	r24, 0x2D	; 45
    af9e:	95 e0       	ldi	r25, 0x05	; 5
    afa0:	97 83       	std	Z+7, r25	; 0x07
    afa2:	86 83       	std	Z+6, r24	; 0x06
    afa4:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    afa8:	ed b7       	in	r30, 0x3d	; 61
    afaa:	fe b7       	in	r31, 0x3e	; 62
    afac:	38 96       	adiw	r30, 0x08	; 8
    afae:	b9 c3       	rjmp	.+1906   	; 0xb722 <PrintIdle+0xba2>
		       break;
		  case 2:
		       CarriegeReturn();
    afb0:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    afb4:	00 d0       	rcall	.+0      	; 0xafb6 <PrintIdle+0x436>
    afb6:	00 d0       	rcall	.+0      	; 0xafb8 <PrintIdle+0x438>
    afb8:	85 e9       	ldi	r24, 0x95	; 149
    afba:	92 e0       	ldi	r25, 0x02	; 2
    afbc:	ad b7       	in	r26, 0x3d	; 61
    afbe:	be b7       	in	r27, 0x3e	; 62
    afc0:	12 96       	adiw	r26, 0x02	; 2
    afc2:	9c 93       	st	X, r25
    afc4:	8e 93       	st	-X, r24
    afc6:	11 97       	sbiw	r26, 0x01	; 1
    afc8:	8b ea       	ldi	r24, 0xAB	; 171
    afca:	99 e0       	ldi	r25, 0x09	; 9
    afcc:	be c3       	rjmp	.+1916   	; 0xb74a <PrintIdle+0xbca>
		       break;
		  case 3:
		       CarriegeReturn();
    afce:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			   //RemZeroLead(strIslandID);
			   //RemZeroLead(strFIP_ID);
		       sprintf_P(strPrint,PSTR("      Pulau/Pompa : [%s]-%s"),strIslandID,strFIP_ID);
    afd2:	ed b7       	in	r30, 0x3d	; 61
    afd4:	fe b7       	in	r31, 0x3e	; 62
    afd6:	38 97       	sbiw	r30, 0x08	; 8
    afd8:	0f b6       	in	r0, 0x3f	; 63
    afda:	f8 94       	cli
    afdc:	fe bf       	out	0x3e, r31	; 62
    afde:	0f be       	out	0x3f, r0	; 63
    afe0:	ed bf       	out	0x3d, r30	; 61
    afe2:	31 96       	adiw	r30, 0x01	; 1
    afe4:	85 e9       	ldi	r24, 0x95	; 149
    afe6:	92 e0       	ldi	r25, 0x02	; 2
    afe8:	ad b7       	in	r26, 0x3d	; 61
    afea:	be b7       	in	r27, 0x3e	; 62
    afec:	12 96       	adiw	r26, 0x02	; 2
    afee:	9c 93       	st	X, r25
    aff0:	8e 93       	st	-X, r24
    aff2:	11 97       	sbiw	r26, 0x01	; 1
    aff4:	8f e8       	ldi	r24, 0x8F	; 143
    aff6:	99 e0       	ldi	r25, 0x09	; 9
    aff8:	93 83       	std	Z+3, r25	; 0x03
    affa:	82 83       	std	Z+2, r24	; 0x02
    affc:	8f e1       	ldi	r24, 0x1F	; 31
    affe:	9b e0       	ldi	r25, 0x0B	; 11
    b000:	95 83       	std	Z+5, r25	; 0x05
    b002:	84 83       	std	Z+4, r24	; 0x04
    b004:	8c ee       	ldi	r24, 0xEC	; 236
    b006:	99 e0       	ldi	r25, 0x09	; 9
    b008:	cb cf       	rjmp	.-106    	; 0xafa0 <PrintIdle+0x420>
		       break;
		  case 4:
		       CarriegeReturn();
    b00a:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Produk      : %s"),strDescription);
    b00e:	00 d0       	rcall	.+0      	; 0xb010 <PrintIdle+0x490>
    b010:	00 d0       	rcall	.+0      	; 0xb012 <PrintIdle+0x492>
    b012:	00 d0       	rcall	.+0      	; 0xb014 <PrintIdle+0x494>
    b014:	ed b7       	in	r30, 0x3d	; 61
    b016:	fe b7       	in	r31, 0x3e	; 62
    b018:	31 96       	adiw	r30, 0x01	; 1
    b01a:	85 e9       	ldi	r24, 0x95	; 149
    b01c:	92 e0       	ldi	r25, 0x02	; 2
    b01e:	ad b7       	in	r26, 0x3d	; 61
    b020:	be b7       	in	r27, 0x3e	; 62
    b022:	12 96       	adiw	r26, 0x02	; 2
    b024:	9c 93       	st	X, r25
    b026:	8e 93       	st	-X, r24
    b028:	11 97       	sbiw	r26, 0x01	; 1
    b02a:	88 e7       	ldi	r24, 0x78	; 120
    b02c:	99 e0       	ldi	r25, 0x09	; 9
    b02e:	93 83       	std	Z+3, r25	; 0x03
    b030:	82 83       	std	Z+2, r24	; 0x02
    b032:	81 e6       	ldi	r24, 0x61	; 97
    b034:	9a e0       	ldi	r25, 0x0A	; 10
    b036:	6e c3       	rjmp	.+1756   	; 0xb714 <PrintIdle+0xb94>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b038:	e1 99       	sbic	0x1c, 1	; 28
    b03a:	fe cf       	rjmp	.-4      	; 0xb038 <PrintIdle+0x4b8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b03c:	81 ec       	ldi	r24, 0xC1	; 193
    b03e:	93 e0       	ldi	r25, 0x03	; 3
    b040:	9f bb       	out	0x1f, r25	; 31
    b042:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b044:	e0 9a       	sbi	0x1c, 0	; 28
    b046:	8d b3       	in	r24, 0x1d	; 29
    b048:	c5 e9       	ldi	r28, 0x95	; 149
    b04a:	d2 e0       	ldi	r29, 0x02	; 2
		       break;
		  case 5:
		       //RemZeroLead(strPrice);
               //FormatCurrency(strPrice);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    b04c:	81 30       	cpi	r24, 0x01	; 1
    b04e:	a9 f4       	brne	.+42     	; 0xb07a <PrintIdle+0x4fa>
			   	   CarriegeReturn();
    b050:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Harga/L     : Rp.%s"),strPrice);
    b054:	00 d0       	rcall	.+0      	; 0xb056 <PrintIdle+0x4d6>
    b056:	00 d0       	rcall	.+0      	; 0xb058 <PrintIdle+0x4d8>
    b058:	00 d0       	rcall	.+0      	; 0xb05a <PrintIdle+0x4da>
    b05a:	ed b7       	in	r30, 0x3d	; 61
    b05c:	fe b7       	in	r31, 0x3e	; 62
    b05e:	31 96       	adiw	r30, 0x01	; 1
    b060:	ad b7       	in	r26, 0x3d	; 61
    b062:	be b7       	in	r27, 0x3e	; 62
    b064:	12 96       	adiw	r26, 0x02	; 2
    b066:	dc 93       	st	X, r29
    b068:	ce 93       	st	-X, r28
    b06a:	11 97       	sbiw	r26, 0x01	; 1
    b06c:	8e e5       	ldi	r24, 0x5E	; 94
    b06e:	99 e0       	ldi	r25, 0x09	; 9
    b070:	93 83       	std	Z+3, r25	; 0x03
    b072:	82 83       	std	Z+2, r24	; 0x02
    b074:	81 ed       	ldi	r24, 0xD1	; 209
    b076:	97 e0       	ldi	r25, 0x07	; 7
    b078:	4d c3       	rjmp	.+1690   	; 0xb714 <PrintIdle+0xb94>
			   }else sprintf_P(strPrint,PSTR(""));
    b07a:	00 d0       	rcall	.+0      	; 0xb07c <PrintIdle+0x4fc>
    b07c:	00 d0       	rcall	.+0      	; 0xb07e <PrintIdle+0x4fe>
    b07e:	ad b7       	in	r26, 0x3d	; 61
    b080:	be b7       	in	r27, 0x3e	; 62
    b082:	12 96       	adiw	r26, 0x02	; 2
    b084:	dc 93       	st	X, r29
    b086:	ce 93       	st	-X, r28
    b088:	11 97       	sbiw	r26, 0x01	; 1
    b08a:	8d e5       	ldi	r24, 0x5D	; 93
    b08c:	99 e0       	ldi	r25, 0x09	; 9
    b08e:	5d c3       	rjmp	.+1722   	; 0xb74a <PrintIdle+0xbca>

		       break;
		  case 6:
		       //RemZeroLead(strVolume);
		       CarriegeReturn();
    b090:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Jml Liter   : %s L"),strVolume);
    b094:	00 d0       	rcall	.+0      	; 0xb096 <PrintIdle+0x516>
    b096:	00 d0       	rcall	.+0      	; 0xb098 <PrintIdle+0x518>
    b098:	00 d0       	rcall	.+0      	; 0xb09a <PrintIdle+0x51a>
    b09a:	ed b7       	in	r30, 0x3d	; 61
    b09c:	fe b7       	in	r31, 0x3e	; 62
    b09e:	31 96       	adiw	r30, 0x01	; 1
    b0a0:	85 e9       	ldi	r24, 0x95	; 149
    b0a2:	92 e0       	ldi	r25, 0x02	; 2
    b0a4:	ad b7       	in	r26, 0x3d	; 61
    b0a6:	be b7       	in	r27, 0x3e	; 62
    b0a8:	12 96       	adiw	r26, 0x02	; 2
    b0aa:	9c 93       	st	X, r25
    b0ac:	8e 93       	st	-X, r24
    b0ae:	11 97       	sbiw	r26, 0x01	; 1
    b0b0:	84 e4       	ldi	r24, 0x44	; 68
    b0b2:	99 e0       	ldi	r25, 0x09	; 9
    b0b4:	93 83       	std	Z+3, r25	; 0x03
    b0b6:	82 83       	std	Z+2, r24	; 0x02
    b0b8:	85 e5       	ldi	r24, 0x55	; 85
    b0ba:	95 e0       	ldi	r25, 0x05	; 5
    b0bc:	2b c3       	rjmp	.+1622   	; 0xb714 <PrintIdle+0xb94>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b0be:	e1 99       	sbic	0x1c, 1	; 28
    b0c0:	fe cf       	rjmp	.-4      	; 0xb0be <PrintIdle+0x53e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b0c2:	81 ec       	ldi	r24, 0xC1	; 193
    b0c4:	93 e0       	ldi	r25, 0x03	; 3
    b0c6:	9f bb       	out	0x1f, r25	; 31
    b0c8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b0ca:	e0 9a       	sbi	0x1c, 0	; 28
    b0cc:	8d b3       	in	r24, 0x1d	; 29
    b0ce:	c5 e9       	ldi	r28, 0x95	; 149
    b0d0:	d2 e0       	ldi	r29, 0x02	; 2
		       break;
		  case 7:
		       //RemZeroLead(strAmount);		       
			   //FormatCurrency(strAmount);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    b0d2:	81 30       	cpi	r24, 0x01	; 1
    b0d4:	a9 f4       	brne	.+42     	; 0xb100 <PrintIdle+0x580>
			   	   CarriegeReturn();
    b0d6:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Jml Rupiah  : Rp.%s"),strAmount);
    b0da:	00 d0       	rcall	.+0      	; 0xb0dc <PrintIdle+0x55c>
    b0dc:	00 d0       	rcall	.+0      	; 0xb0de <PrintIdle+0x55e>
    b0de:	00 d0       	rcall	.+0      	; 0xb0e0 <PrintIdle+0x560>
    b0e0:	ed b7       	in	r30, 0x3d	; 61
    b0e2:	fe b7       	in	r31, 0x3e	; 62
    b0e4:	31 96       	adiw	r30, 0x01	; 1
    b0e6:	ad b7       	in	r26, 0x3d	; 61
    b0e8:	be b7       	in	r27, 0x3e	; 62
    b0ea:	12 96       	adiw	r26, 0x02	; 2
    b0ec:	dc 93       	st	X, r29
    b0ee:	ce 93       	st	-X, r28
    b0f0:	11 97       	sbiw	r26, 0x01	; 1
    b0f2:	8a e2       	ldi	r24, 0x2A	; 42
    b0f4:	99 e0       	ldi	r25, 0x09	; 9
    b0f6:	93 83       	std	Z+3, r25	; 0x03
    b0f8:	82 83       	std	Z+2, r24	; 0x02
    b0fa:	8b ed       	ldi	r24, 0xDB	; 219
    b0fc:	9d e0       	ldi	r25, 0x0D	; 13
    b0fe:	0a c3       	rjmp	.+1556   	; 0xb714 <PrintIdle+0xb94>
			   }else sprintf_P(strPrint,PSTR(""));
    b100:	00 d0       	rcall	.+0      	; 0xb102 <PrintIdle+0x582>
    b102:	00 d0       	rcall	.+0      	; 0xb104 <PrintIdle+0x584>
    b104:	ad b7       	in	r26, 0x3d	; 61
    b106:	be b7       	in	r27, 0x3e	; 62
    b108:	12 96       	adiw	r26, 0x02	; 2
    b10a:	dc 93       	st	X, r29
    b10c:	ce 93       	st	-X, r28
    b10e:	11 97       	sbiw	r26, 0x01	; 1
    b110:	89 e2       	ldi	r24, 0x29	; 41
    b112:	99 e0       	ldi	r25, 0x09	; 9
    b114:	1a c3       	rjmp	.+1588   	; 0xb74a <PrintIdle+0xbca>

		       break;
		  case 8:
		       if ((strlen(strLicPlate)>0)&&(SpaceOnly(strLicPlate)==False)){
    b116:	c2 e2       	ldi	r28, 0x22	; 34
    b118:	db e0       	ldi	r29, 0x0B	; 11
    b11a:	80 91 22 0b 	lds	r24, 0x0B22
    b11e:	88 23       	and	r24, r24
    b120:	09 f4       	brne	.+2      	; 0xb124 <PrintIdle+0x5a4>
    b122:	18 c2       	rjmp	.+1072   	; 0xb554 <PrintIdle+0x9d4>
    b124:	ce 01       	movw	r24, r28
    b126:	0e 94 99 22 	call	0x4532	; 0x4532 <SpaceOnly>
    b12a:	88 23       	and	r24, r24
    b12c:	09 f0       	breq	.+2      	; 0xb130 <PrintIdle+0x5b0>
    b12e:	12 c2       	rjmp	.+1060   	; 0xb554 <PrintIdle+0x9d4>
			       CarriegeReturn();
    b130:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      No.Polisi   : %s"),strLicPlate);
    b134:	00 d0       	rcall	.+0      	; 0xb136 <PrintIdle+0x5b6>
    b136:	00 d0       	rcall	.+0      	; 0xb138 <PrintIdle+0x5b8>
    b138:	00 d0       	rcall	.+0      	; 0xb13a <PrintIdle+0x5ba>
    b13a:	ed b7       	in	r30, 0x3d	; 61
    b13c:	fe b7       	in	r31, 0x3e	; 62
    b13e:	31 96       	adiw	r30, 0x01	; 1
    b140:	85 e9       	ldi	r24, 0x95	; 149
    b142:	92 e0       	ldi	r25, 0x02	; 2
    b144:	ad b7       	in	r26, 0x3d	; 61
    b146:	be b7       	in	r27, 0x3e	; 62
    b148:	12 96       	adiw	r26, 0x02	; 2
    b14a:	9c 93       	st	X, r25
    b14c:	8e 93       	st	-X, r24
    b14e:	11 97       	sbiw	r26, 0x01	; 1
    b150:	82 e1       	ldi	r24, 0x12	; 18
    b152:	99 e0       	ldi	r25, 0x09	; 9
    b154:	1f c0       	rjmp	.+62     	; 0xb194 <PrintIdle+0x614>
                   ClearMem(strLicPlate);
				   }
               else ClearMem(strPrint);
		       break;
		  case 9:
		       if ((strlen(strOdometer)>0)&&(SpaceOnly(strOdometer)==False)){
    b156:	c3 ef       	ldi	r28, 0xF3	; 243
    b158:	d5 e0       	ldi	r29, 0x05	; 5
    b15a:	80 91 f3 05 	lds	r24, 0x05F3
    b15e:	88 23       	and	r24, r24
    b160:	09 f4       	brne	.+2      	; 0xb164 <PrintIdle+0x5e4>
    b162:	f8 c1       	rjmp	.+1008   	; 0xb554 <PrintIdle+0x9d4>
    b164:	ce 01       	movw	r24, r28
    b166:	0e 94 99 22 	call	0x4532	; 0x4532 <SpaceOnly>
    b16a:	88 23       	and	r24, r24
    b16c:	09 f0       	breq	.+2      	; 0xb170 <PrintIdle+0x5f0>
    b16e:	f2 c1       	rjmp	.+996    	; 0xb554 <PrintIdle+0x9d4>
			       CarriegeReturn();
    b170:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("      Odometer    : %s"),strOdometer);
    b174:	00 d0       	rcall	.+0      	; 0xb176 <PrintIdle+0x5f6>
    b176:	00 d0       	rcall	.+0      	; 0xb178 <PrintIdle+0x5f8>
    b178:	00 d0       	rcall	.+0      	; 0xb17a <PrintIdle+0x5fa>
    b17a:	ed b7       	in	r30, 0x3d	; 61
    b17c:	fe b7       	in	r31, 0x3e	; 62
    b17e:	31 96       	adiw	r30, 0x01	; 1
    b180:	85 e9       	ldi	r24, 0x95	; 149
    b182:	92 e0       	ldi	r25, 0x02	; 2
    b184:	ad b7       	in	r26, 0x3d	; 61
    b186:	be b7       	in	r27, 0x3e	; 62
    b188:	12 96       	adiw	r26, 0x02	; 2
    b18a:	9c 93       	st	X, r25
    b18c:	8e 93       	st	-X, r24
    b18e:	11 97       	sbiw	r26, 0x01	; 1
    b190:	8b ef       	ldi	r24, 0xFB	; 251
    b192:	98 e0       	ldi	r25, 0x08	; 8
    b194:	93 83       	std	Z+3, r25	; 0x03
    b196:	82 83       	std	Z+2, r24	; 0x02
    b198:	d5 83       	std	Z+5, r29	; 0x05
    b19a:	c4 83       	std	Z+4, r28	; 0x04
    b19c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
				   ClearMem(strOdometer);
    b1a0:	ed b7       	in	r30, 0x3d	; 61
    b1a2:	fe b7       	in	r31, 0x3e	; 62
    b1a4:	36 96       	adiw	r30, 0x06	; 6
    b1a6:	0f b6       	in	r0, 0x3f	; 63
    b1a8:	f8 94       	cli
    b1aa:	fe bf       	out	0x3e, r31	; 62
    b1ac:	0f be       	out	0x3f, r0	; 63
    b1ae:	ed bf       	out	0x3d, r30	; 61
    b1b0:	ce 01       	movw	r24, r28
    b1b2:	0e 94 7b ad 	call	0x15af6	; 0x15af6 <ClearMem>
    b1b6:	d3 c2       	rjmp	.+1446   	; 0xb75e <PrintIdle+0xbde>
			   }else ClearMem(strPrint);
		       break;
		  case 10:
		       CarriegeReturn();
    b1b8:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b1bc:	00 d0       	rcall	.+0      	; 0xb1be <PrintIdle+0x63e>
    b1be:	00 d0       	rcall	.+0      	; 0xb1c0 <PrintIdle+0x640>
    b1c0:	85 e9       	ldi	r24, 0x95	; 149
    b1c2:	92 e0       	ldi	r25, 0x02	; 2
    b1c4:	ad b7       	in	r26, 0x3d	; 61
    b1c6:	be b7       	in	r27, 0x3e	; 62
    b1c8:	12 96       	adiw	r26, 0x02	; 2
    b1ca:	9c 93       	st	X, r25
    b1cc:	8e 93       	st	-X, r24
    b1ce:	11 97       	sbiw	r26, 0x01	; 1
    b1d0:	88 ed       	ldi	r24, 0xD8	; 216
    b1d2:	98 e0       	ldi	r25, 0x08	; 8
    b1d4:	ba c2       	rjmp	.+1396   	; 0xb74a <PrintIdle+0xbca>
		       break;
          //ChangeMOPPrint
		  case 11:
			   if ((MOPType==MOP_LOCAL_ACCOUNT)||(MOPType==MOP_DEBIT_CARD)||(MOPType==MOP_LOYALTY_LOCAL_ACCOUNT)){
    b1d6:	80 91 cf 01 	lds	r24, 0x01CF
    b1da:	81 30       	cpi	r24, 0x01	; 1
    b1dc:	21 f0       	breq	.+8      	; 0xb1e6 <PrintIdle+0x666>
    b1de:	83 30       	cpi	r24, 0x03	; 3
    b1e0:	11 f0       	breq	.+4      	; 0xb1e6 <PrintIdle+0x666>
    b1e2:	86 30       	cpi	r24, 0x06	; 6
    b1e4:	b9 f4       	brne	.+46     	; 0xb214 <PrintIdle+0x694>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    b1e6:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Kartu ID : %s"),strCardID);
    b1ea:	00 d0       	rcall	.+0      	; 0xb1ec <PrintIdle+0x66c>
    b1ec:	00 d0       	rcall	.+0      	; 0xb1ee <PrintIdle+0x66e>
    b1ee:	00 d0       	rcall	.+0      	; 0xb1f0 <PrintIdle+0x670>
    b1f0:	ed b7       	in	r30, 0x3d	; 61
    b1f2:	fe b7       	in	r31, 0x3e	; 62
    b1f4:	31 96       	adiw	r30, 0x01	; 1
    b1f6:	85 e9       	ldi	r24, 0x95	; 149
    b1f8:	92 e0       	ldi	r25, 0x02	; 2
    b1fa:	ad b7       	in	r26, 0x3d	; 61
    b1fc:	be b7       	in	r27, 0x3e	; 62
    b1fe:	12 96       	adiw	r26, 0x02	; 2
    b200:	9c 93       	st	X, r25
    b202:	8e 93       	st	-X, r24
    b204:	11 97       	sbiw	r26, 0x01	; 1
    b206:	86 ec       	ldi	r24, 0xC6	; 198
    b208:	98 e0       	ldi	r25, 0x08	; 8
    b20a:	93 83       	std	Z+3, r25	; 0x03
    b20c:	82 83       	std	Z+2, r24	; 0x02
    b20e:	81 eb       	ldi	r24, 0xB1	; 177
    b210:	9d e0       	ldi	r25, 0x0D	; 13
    b212:	18 c0       	rjmp	.+48     	; 0xb244 <PrintIdle+0x6c4>
				   IsSignedField=True;
				   }
	           else
			   if (MOPType==MOP_VOUCHER){
    b214:	87 30       	cpi	r24, 0x07	; 7
    b216:	f1 f4       	brne	.+60     	; 0xb254 <PrintIdle+0x6d4>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    b218:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Voucher No: %s"),strVoucherNum);
    b21c:	00 d0       	rcall	.+0      	; 0xb21e <PrintIdle+0x69e>
    b21e:	00 d0       	rcall	.+0      	; 0xb220 <PrintIdle+0x6a0>
    b220:	00 d0       	rcall	.+0      	; 0xb222 <PrintIdle+0x6a2>
    b222:	ed b7       	in	r30, 0x3d	; 61
    b224:	fe b7       	in	r31, 0x3e	; 62
    b226:	31 96       	adiw	r30, 0x01	; 1
    b228:	85 e9       	ldi	r24, 0x95	; 149
    b22a:	92 e0       	ldi	r25, 0x02	; 2
    b22c:	ad b7       	in	r26, 0x3d	; 61
    b22e:	be b7       	in	r27, 0x3e	; 62
    b230:	12 96       	adiw	r26, 0x02	; 2
    b232:	9c 93       	st	X, r25
    b234:	8e 93       	st	-X, r24
    b236:	11 97       	sbiw	r26, 0x01	; 1
    b238:	83 eb       	ldi	r24, 0xB3	; 179
    b23a:	98 e0       	ldi	r25, 0x08	; 8
    b23c:	93 83       	std	Z+3, r25	; 0x03
    b23e:	82 83       	std	Z+2, r24	; 0x02
    b240:	87 e6       	ldi	r24, 0x67	; 103
    b242:	9e e0       	ldi	r25, 0x0E	; 14
    b244:	95 83       	std	Z+5, r25	; 0x05
    b246:	84 83       	std	Z+4, r24	; 0x04
    b248:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
				   IsSignedField=True;
    b24c:	81 e0       	ldi	r24, 0x01	; 1
    b24e:	80 93 92 02 	sts	0x0292, r24
    b252:	64 c2       	rjmp	.+1224   	; 0xb71c <PrintIdle+0xb9c>
    b254:	c5 e9       	ldi	r28, 0x95	; 149
    b256:	d2 e0       	ldi	r29, 0x02	; 2
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b258:	88 30       	cpi	r24, 0x08	; 8
    b25a:	09 f0       	breq	.+2      	; 0xb25e <PrintIdle+0x6de>
    b25c:	a9 cf       	rjmp	.-174    	; 0xb1b0 <PrintIdle+0x630>
			       CarriegeReturn();
    b25e:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("          *** PUMP TEST ***       "));
    b262:	00 d0       	rcall	.+0      	; 0xb264 <PrintIdle+0x6e4>
    b264:	00 d0       	rcall	.+0      	; 0xb266 <PrintIdle+0x6e6>
    b266:	ad b7       	in	r26, 0x3d	; 61
    b268:	be b7       	in	r27, 0x3e	; 62
    b26a:	12 96       	adiw	r26, 0x02	; 2
    b26c:	dc 93       	st	X, r29
    b26e:	ce 93       	st	-X, r28
    b270:	11 97       	sbiw	r26, 0x01	; 1
    b272:	80 e9       	ldi	r24, 0x90	; 144
    b274:	98 e0       	ldi	r25, 0x08	; 8
    b276:	14 96       	adiw	r26, 0x04	; 4
    b278:	9c 93       	st	X, r25
    b27a:	8e 93       	st	-X, r24
    b27c:	13 97       	sbiw	r26, 0x03	; 3
    b27e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
				   IsSignedField=False;
    b282:	10 92 92 02 	sts	0x0292, r1
    b286:	67 c2       	rjmp	.+1230   	; 0xb756 <PrintIdle+0xbd6>
				   }
               else ClearMem(strPrint);
		       break;
          case 12:
			   if (MOPType==MOP_LOCAL_ACCOUNT) {
    b288:	80 91 cf 01 	lds	r24, 0x01CF
    b28c:	81 30       	cpi	r24, 0x01	; 1
    b28e:	99 f4       	brne	.+38     	; 0xb2b6 <PrintIdle+0x736>
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    b290:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Nama     : %s"),strCardHolder);
    b294:	00 d0       	rcall	.+0      	; 0xb296 <PrintIdle+0x716>
    b296:	00 d0       	rcall	.+0      	; 0xb298 <PrintIdle+0x718>
    b298:	00 d0       	rcall	.+0      	; 0xb29a <PrintIdle+0x71a>
    b29a:	ed b7       	in	r30, 0x3d	; 61
    b29c:	fe b7       	in	r31, 0x3e	; 62
    b29e:	31 96       	adiw	r30, 0x01	; 1
    b2a0:	85 e9       	ldi	r24, 0x95	; 149
    b2a2:	92 e0       	ldi	r25, 0x02	; 2
    b2a4:	ad b7       	in	r26, 0x3d	; 61
    b2a6:	be b7       	in	r27, 0x3e	; 62
    b2a8:	12 96       	adiw	r26, 0x02	; 2
    b2aa:	9c 93       	st	X, r25
    b2ac:	8e 93       	st	-X, r24
    b2ae:	11 97       	sbiw	r26, 0x01	; 1
    b2b0:	8e e7       	ldi	r24, 0x7E	; 126
    b2b2:	98 e0       	ldi	r25, 0x08	; 8
    b2b4:	3a c0       	rjmp	.+116    	; 0xb32a <PrintIdle+0x7aa>
				   }
               else 
               if (MOPType==MOP_DEBIT_CARD) {//EDCApprovalCode
    b2b6:	83 30       	cpi	r24, 0x03	; 3
    b2b8:	e9 f5       	brne	.+122    	; 0xb334 <PrintIdle+0x7b4>
			       if (IsPrintApprovalCode==True){
    b2ba:	80 91 b1 01 	lds	r24, 0x01B1
    b2be:	81 30       	cpi	r24, 0x01	; 1
    b2c0:	11 f5       	brne	.+68     	; 0xb306 <PrintIdle+0x786>
				       IsPrintApprovalCode=False;
    b2c2:	10 92 b1 01 	sts	0x01B1, r1
					   FillChar(strCardHolder,0,sizeof(strCardHolder));
					   sprintf_P(strCardHolder,PSTR("%s  "),strApprovalCode);
    b2c6:	00 d0       	rcall	.+0      	; 0xb2c8 <PrintIdle+0x748>
    b2c8:	00 d0       	rcall	.+0      	; 0xb2ca <PrintIdle+0x74a>
    b2ca:	00 d0       	rcall	.+0      	; 0xb2cc <PrintIdle+0x74c>
    b2cc:	ed b7       	in	r30, 0x3d	; 61
    b2ce:	fe b7       	in	r31, 0x3e	; 62
    b2d0:	31 96       	adiw	r30, 0x01	; 1
    b2d2:	84 e0       	ldi	r24, 0x04	; 4
    b2d4:	95 e0       	ldi	r25, 0x05	; 5
    b2d6:	ad b7       	in	r26, 0x3d	; 61
    b2d8:	be b7       	in	r27, 0x3e	; 62
    b2da:	12 96       	adiw	r26, 0x02	; 2
    b2dc:	9c 93       	st	X, r25
    b2de:	8e 93       	st	-X, r24
    b2e0:	11 97       	sbiw	r26, 0x01	; 1
    b2e2:	89 e7       	ldi	r24, 0x79	; 121
    b2e4:	98 e0       	ldi	r25, 0x08	; 8
    b2e6:	93 83       	std	Z+3, r25	; 0x03
    b2e8:	82 83       	std	Z+2, r24	; 0x02
    b2ea:	84 e3       	ldi	r24, 0x34	; 52
    b2ec:	9a e0       	ldi	r25, 0x0A	; 10
    b2ee:	95 83       	std	Z+5, r25	; 0x05
    b2f0:	84 83       	std	Z+4, r24	; 0x04
    b2f2:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    b2f6:	ed b7       	in	r30, 0x3d	; 61
    b2f8:	fe b7       	in	r31, 0x3e	; 62
    b2fa:	36 96       	adiw	r30, 0x06	; 6
    b2fc:	0f b6       	in	r0, 0x3f	; 63
    b2fe:	f8 94       	cli
    b300:	fe bf       	out	0x3e, r31	; 62
    b302:	0f be       	out	0x3f, r0	; 63
    b304:	ed bf       	out	0x3d, r30	; 61
				   }
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    b306:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Appr Code: %s"),strCardHolder);
    b30a:	00 d0       	rcall	.+0      	; 0xb30c <PrintIdle+0x78c>
    b30c:	00 d0       	rcall	.+0      	; 0xb30e <PrintIdle+0x78e>
    b30e:	00 d0       	rcall	.+0      	; 0xb310 <PrintIdle+0x790>
    b310:	ed b7       	in	r30, 0x3d	; 61
    b312:	fe b7       	in	r31, 0x3e	; 62
    b314:	31 96       	adiw	r30, 0x01	; 1
    b316:	85 e9       	ldi	r24, 0x95	; 149
    b318:	92 e0       	ldi	r25, 0x02	; 2
    b31a:	ad b7       	in	r26, 0x3d	; 61
    b31c:	be b7       	in	r27, 0x3e	; 62
    b31e:	12 96       	adiw	r26, 0x02	; 2
    b320:	9c 93       	st	X, r25
    b322:	8e 93       	st	-X, r24
    b324:	11 97       	sbiw	r26, 0x01	; 1
    b326:	87 e6       	ldi	r24, 0x67	; 103
    b328:	98 e0       	ldi	r25, 0x08	; 8
    b32a:	93 83       	std	Z+3, r25	; 0x03
    b32c:	82 83       	std	Z+2, r24	; 0x02
    b32e:	84 e0       	ldi	r24, 0x04	; 4
    b330:	95 e0       	ldi	r25, 0x05	; 5
    b332:	f0 c1       	rjmp	.+992    	; 0xb714 <PrintIdle+0xb94>
				   }
               else
			   if (MOPType==MOP_VOUCHER){
    b334:	87 30       	cpi	r24, 0x07	; 7
    b336:	79 f4       	brne	.+30     	; 0xb356 <PrintIdle+0x7d6>
			       CarriegeReturn();
    b338:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("  "));
    b33c:	00 d0       	rcall	.+0      	; 0xb33e <PrintIdle+0x7be>
    b33e:	00 d0       	rcall	.+0      	; 0xb340 <PrintIdle+0x7c0>
    b340:	85 e9       	ldi	r24, 0x95	; 149
    b342:	92 e0       	ldi	r25, 0x02	; 2
    b344:	ad b7       	in	r26, 0x3d	; 61
    b346:	be b7       	in	r27, 0x3e	; 62
    b348:	12 96       	adiw	r26, 0x02	; 2
    b34a:	9c 93       	st	X, r25
    b34c:	8e 93       	st	-X, r24
    b34e:	11 97       	sbiw	r26, 0x01	; 1
    b350:	84 e6       	ldi	r24, 0x64	; 100
    b352:	98 e0       	ldi	r25, 0x08	; 8
    b354:	fa c1       	rjmp	.+1012   	; 0xb74a <PrintIdle+0xbca>
    b356:	c5 e9       	ldi	r28, 0x95	; 149
    b358:	d2 e0       	ldi	r29, 0x02	; 2
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b35a:	88 30       	cpi	r24, 0x08	; 8
    b35c:	09 f0       	breq	.+2      	; 0xb360 <PrintIdle+0x7e0>
    b35e:	28 cf       	rjmp	.-432    	; 0xb1b0 <PrintIdle+0x630>
			       CarriegeReturn();
    b360:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                 "));
    b364:	00 d0       	rcall	.+0      	; 0xb366 <PrintIdle+0x7e6>
    b366:	00 d0       	rcall	.+0      	; 0xb368 <PrintIdle+0x7e8>
    b368:	ed b7       	in	r30, 0x3d	; 61
    b36a:	fe b7       	in	r31, 0x3e	; 62
    b36c:	d2 83       	std	Z+2, r29	; 0x02
    b36e:	c1 83       	std	Z+1, r28	; 0x01
    b370:	82 e5       	ldi	r24, 0x52	; 82
    b372:	98 e0       	ldi	r25, 0x08	; 8
    b374:	25 c0       	rjmp	.+74     	; 0xb3c0 <PrintIdle+0x840>
				   }
               else ClearMem(strPrint);
		       break;
          case 13:
		       if (IsSignedField==True){
    b376:	80 91 92 02 	lds	r24, 0x0292
    b37a:	c5 e9       	ldi	r28, 0x95	; 149
    b37c:	d2 e0       	ldi	r29, 0x02	; 2
    b37e:	81 30       	cpi	r24, 0x01	; 1
    b380:	09 f0       	breq	.+2      	; 0xb384 <PrintIdle+0x804>
    b382:	16 cf       	rjmp	.-468    	; 0xb1b0 <PrintIdle+0x630>
			       CarriegeReturn();
    b384:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b388:	00 d0       	rcall	.+0      	; 0xb38a <PrintIdle+0x80a>
    b38a:	00 d0       	rcall	.+0      	; 0xb38c <PrintIdle+0x80c>
    b38c:	ad b7       	in	r26, 0x3d	; 61
    b38e:	be b7       	in	r27, 0x3e	; 62
    b390:	12 96       	adiw	r26, 0x02	; 2
    b392:	dc 93       	st	X, r29
    b394:	ce 93       	st	-X, r28
    b396:	11 97       	sbiw	r26, 0x01	; 1
    b398:	8b e3       	ldi	r24, 0x3B	; 59
    b39a:	98 e0       	ldi	r25, 0x08	; 8
    b39c:	d6 c1       	rjmp	.+940    	; 0xb74a <PrintIdle+0xbca>
               }else ClearMem(strPrint);
		       break;
          case 14:
		       if (IsSignedField==True){
    b39e:	80 91 92 02 	lds	r24, 0x0292
    b3a2:	c5 e9       	ldi	r28, 0x95	; 149
    b3a4:	d2 e0       	ldi	r29, 0x02	; 2
    b3a6:	81 30       	cpi	r24, 0x01	; 1
    b3a8:	09 f0       	breq	.+2      	; 0xb3ac <PrintIdle+0x82c>
    b3aa:	02 cf       	rjmp	.-508    	; 0xb1b0 <PrintIdle+0x630>
			       CarriegeReturn();
    b3ac:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b3b0:	00 d0       	rcall	.+0      	; 0xb3b2 <PrintIdle+0x832>
    b3b2:	00 d0       	rcall	.+0      	; 0xb3b4 <PrintIdle+0x834>
    b3b4:	ed b7       	in	r30, 0x3d	; 61
    b3b6:	fe b7       	in	r31, 0x3e	; 62
    b3b8:	d2 83       	std	Z+2, r29	; 0x02
    b3ba:	c1 83       	std	Z+1, r28	; 0x01
    b3bc:	84 e2       	ldi	r24, 0x24	; 36
    b3be:	98 e0       	ldi	r25, 0x08	; 8
    b3c0:	94 83       	std	Z+4, r25	; 0x04
    b3c2:	83 83       	std	Z+3, r24	; 0x03
    b3c4:	c6 c1       	rjmp	.+908    	; 0xb752 <PrintIdle+0xbd2>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 17:
		       if (IsSignedField==True){
    b3c6:	80 91 92 02 	lds	r24, 0x0292
    b3ca:	c5 e9       	ldi	r28, 0x95	; 149
    b3cc:	d2 e0       	ldi	r29, 0x02	; 2
    b3ce:	81 30       	cpi	r24, 0x01	; 1
    b3d0:	09 f0       	breq	.+2      	; 0xb3d4 <PrintIdle+0x854>
    b3d2:	ee ce       	rjmp	.-548    	; 0xb1b0 <PrintIdle+0x630>
			       CarriegeReturn();
    b3d4:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Tanda Tangan  (______________)"));
    b3d8:	00 d0       	rcall	.+0      	; 0xb3da <PrintIdle+0x85a>
    b3da:	00 d0       	rcall	.+0      	; 0xb3dc <PrintIdle+0x85c>
    b3dc:	ad b7       	in	r26, 0x3d	; 61
    b3de:	be b7       	in	r27, 0x3e	; 62
    b3e0:	12 96       	adiw	r26, 0x02	; 2
    b3e2:	dc 93       	st	X, r29
    b3e4:	ce 93       	st	-X, r28
    b3e6:	11 97       	sbiw	r26, 0x01	; 1
    b3e8:	81 e0       	ldi	r24, 0x01	; 1
    b3ea:	98 e0       	ldi	r25, 0x08	; 8
    b3ec:	ae c1       	rjmp	.+860    	; 0xb74a <PrintIdle+0xbca>
               }else ClearMem(strPrint);
		       break;
          case 18:
		       if (IsSignedField==True){
    b3ee:	80 91 92 02 	lds	r24, 0x0292
    b3f2:	81 30       	cpi	r24, 0x01	; 1
    b3f4:	09 f0       	breq	.+2      	; 0xb3f8 <PrintIdle+0x878>
    b3f6:	ae c0       	rjmp	.+348    	; 0xb554 <PrintIdle+0x9d4>
			       IsSignedField=False;
    b3f8:	10 92 92 02 	sts	0x0292, r1
    b3fc:	ab c0       	rjmp	.+342    	; 0xb554 <PrintIdle+0x9d4>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 19://PrintMOP Name
		       if (MOPType!=MOP_CASH){
    b3fe:	80 91 cf 01 	lds	r24, 0x01CF
    b402:	c5 e9       	ldi	r28, 0x95	; 149
    b404:	d2 e0       	ldi	r29, 0x02	; 2
    b406:	88 23       	and	r24, r24
    b408:	09 f4       	brne	.+2      	; 0xb40c <PrintIdle+0x88c>
    b40a:	d2 ce       	rjmp	.-604    	; 0xb1b0 <PrintIdle+0x630>
			       CarriegeReturn();
    b40c:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			       //RemSpaceLag(strMOPName);
			       sprintf_P(strPrint,PSTR("    .%s"),strMOPName);
    b410:	00 d0       	rcall	.+0      	; 0xb412 <PrintIdle+0x892>
    b412:	00 d0       	rcall	.+0      	; 0xb414 <PrintIdle+0x894>
    b414:	00 d0       	rcall	.+0      	; 0xb416 <PrintIdle+0x896>
    b416:	ed b7       	in	r30, 0x3d	; 61
    b418:	fe b7       	in	r31, 0x3e	; 62
    b41a:	31 96       	adiw	r30, 0x01	; 1
    b41c:	ad b7       	in	r26, 0x3d	; 61
    b41e:	be b7       	in	r27, 0x3e	; 62
    b420:	12 96       	adiw	r26, 0x02	; 2
    b422:	dc 93       	st	X, r29
    b424:	ce 93       	st	-X, r28
    b426:	11 97       	sbiw	r26, 0x01	; 1
    b428:	89 ef       	ldi	r24, 0xF9	; 249
    b42a:	97 e0       	ldi	r25, 0x07	; 7
    b42c:	93 83       	std	Z+3, r25	; 0x03
    b42e:	82 83       	std	Z+2, r24	; 0x02
    b430:	80 eb       	ldi	r24, 0xB0	; 176
    b432:	97 e0       	ldi	r25, 0x07	; 7
    b434:	6f c1       	rjmp	.+734    	; 0xb714 <PrintIdle+0xb94>
			   }else ClearMem(strPrint);
		       break;
		  case 20:
		       if (MOPType!=MOP_CASH){
    b436:	80 91 cf 01 	lds	r24, 0x01CF
    b43a:	c5 e9       	ldi	r28, 0x95	; 149
    b43c:	d2 e0       	ldi	r29, 0x02	; 2
    b43e:	88 23       	and	r24, r24
    b440:	09 f4       	brne	.+2      	; 0xb444 <PrintIdle+0x8c4>
    b442:	b6 ce       	rjmp	.-660    	; 0xb1b0 <PrintIdle+0x630>
			       CarriegeReturn();
    b444:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("    ------------------------------"));
    b448:	00 d0       	rcall	.+0      	; 0xb44a <PrintIdle+0x8ca>
    b44a:	00 d0       	rcall	.+0      	; 0xb44c <PrintIdle+0x8cc>
    b44c:	ad b7       	in	r26, 0x3d	; 61
    b44e:	be b7       	in	r27, 0x3e	; 62
    b450:	12 96       	adiw	r26, 0x02	; 2
    b452:	dc 93       	st	X, r29
    b454:	ce 93       	st	-X, r28
    b456:	11 97       	sbiw	r26, 0x01	; 1
    b458:	86 ed       	ldi	r24, 0xD6	; 214
    b45a:	97 e0       	ldi	r25, 0x07	; 7
    b45c:	76 c1       	rjmp	.+748    	; 0xb74a <PrintIdle+0xbca>
			   }else ClearMem(strPrint);
		       break;          
          //Loyalty
		  case 21:
		       CarriegeReturn();
    b45e:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("         LOYALTY INFORMATION      "));
    b462:	00 d0       	rcall	.+0      	; 0xb464 <PrintIdle+0x8e4>
    b464:	00 d0       	rcall	.+0      	; 0xb466 <PrintIdle+0x8e6>
    b466:	85 e9       	ldi	r24, 0x95	; 149
    b468:	92 e0       	ldi	r25, 0x02	; 2
    b46a:	ed b7       	in	r30, 0x3d	; 61
    b46c:	fe b7       	in	r31, 0x3e	; 62
    b46e:	92 83       	std	Z+2, r25	; 0x02
    b470:	81 83       	std	Z+1, r24	; 0x01
    b472:	83 eb       	ldi	r24, 0xB3	; 179
    b474:	97 e0       	ldi	r25, 0x07	; 7
    b476:	a4 cf       	rjmp	.-184    	; 0xb3c0 <PrintIdle+0x840>
		       break; 			            
		  case 22:
		       CarriegeReturn();
    b478:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Card ID      : %s"),strLoyCardID);
    b47c:	00 d0       	rcall	.+0      	; 0xb47e <PrintIdle+0x8fe>
    b47e:	00 d0       	rcall	.+0      	; 0xb480 <PrintIdle+0x900>
    b480:	00 d0       	rcall	.+0      	; 0xb482 <PrintIdle+0x902>
    b482:	ed b7       	in	r30, 0x3d	; 61
    b484:	fe b7       	in	r31, 0x3e	; 62
    b486:	31 96       	adiw	r30, 0x01	; 1
    b488:	85 e9       	ldi	r24, 0x95	; 149
    b48a:	92 e0       	ldi	r25, 0x02	; 2
    b48c:	ad b7       	in	r26, 0x3d	; 61
    b48e:	be b7       	in	r27, 0x3e	; 62
    b490:	12 96       	adiw	r26, 0x02	; 2
    b492:	9c 93       	st	X, r25
    b494:	8e 93       	st	-X, r24
    b496:	11 97       	sbiw	r26, 0x01	; 1
    b498:	8c e9       	ldi	r24, 0x9C	; 156
    b49a:	97 e0       	ldi	r25, 0x07	; 7
    b49c:	93 83       	std	Z+3, r25	; 0x03
    b49e:	82 83       	std	Z+2, r24	; 0x02
    b4a0:	87 ec       	ldi	r24, 0xC7	; 199
    b4a2:	94 e0       	ldi	r25, 0x04	; 4
    b4a4:	37 c1       	rjmp	.+622    	; 0xb714 <PrintIdle+0xb94>
		       break;
		  case 23:
		       CarriegeReturn();
    b4a6:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			   //RemSpaceLag(strLoyCardHolder);
		       sprintf_P(strPrint,PSTR("     Card Holder  : %s "),strLoyCardHolder);
    b4aa:	00 d0       	rcall	.+0      	; 0xb4ac <PrintIdle+0x92c>
    b4ac:	00 d0       	rcall	.+0      	; 0xb4ae <PrintIdle+0x92e>
    b4ae:	00 d0       	rcall	.+0      	; 0xb4b0 <PrintIdle+0x930>
    b4b0:	ed b7       	in	r30, 0x3d	; 61
    b4b2:	fe b7       	in	r31, 0x3e	; 62
    b4b4:	31 96       	adiw	r30, 0x01	; 1
    b4b6:	85 e9       	ldi	r24, 0x95	; 149
    b4b8:	92 e0       	ldi	r25, 0x02	; 2
    b4ba:	ad b7       	in	r26, 0x3d	; 61
    b4bc:	be b7       	in	r27, 0x3e	; 62
    b4be:	12 96       	adiw	r26, 0x02	; 2
    b4c0:	9c 93       	st	X, r25
    b4c2:	8e 93       	st	-X, r24
    b4c4:	11 97       	sbiw	r26, 0x01	; 1
    b4c6:	84 e8       	ldi	r24, 0x84	; 132
    b4c8:	97 e0       	ldi	r25, 0x07	; 7
    b4ca:	93 83       	std	Z+3, r25	; 0x03
    b4cc:	82 83       	std	Z+2, r24	; 0x02
    b4ce:	84 ea       	ldi	r24, 0xA4	; 164
    b4d0:	94 e0       	ldi	r25, 0x04	; 4
    b4d2:	20 c1       	rjmp	.+576    	; 0xb714 <PrintIdle+0xb94>
		       break;
		  case 24:
		       if ((strlen(strCorporateID)>0)&&(SpaceOnly(strCorporateID)==False)){
    b4d4:	c5 e3       	ldi	r28, 0x35	; 53
    b4d6:	de e0       	ldi	r29, 0x0E	; 14
    b4d8:	80 91 35 0e 	lds	r24, 0x0E35
    b4dc:	88 23       	and	r24, r24
    b4de:	d1 f1       	breq	.+116    	; 0xb554 <PrintIdle+0x9d4>
    b4e0:	ce 01       	movw	r24, r28
    b4e2:	0e 94 99 22 	call	0x4532	; 0x4532 <SpaceOnly>
    b4e6:	88 23       	and	r24, r24
    b4e8:	a9 f5       	brne	.+106    	; 0xb554 <PrintIdle+0x9d4>
		           CarriegeReturn();
    b4ea:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
				   //RemSpaceLag(strCorporateID);
		           sprintf_P(strPrint,PSTR("     Corp ID      : %s"),strCorporateID);
    b4ee:	00 d0       	rcall	.+0      	; 0xb4f0 <PrintIdle+0x970>
    b4f0:	00 d0       	rcall	.+0      	; 0xb4f2 <PrintIdle+0x972>
    b4f2:	00 d0       	rcall	.+0      	; 0xb4f4 <PrintIdle+0x974>
    b4f4:	ed b7       	in	r30, 0x3d	; 61
    b4f6:	fe b7       	in	r31, 0x3e	; 62
    b4f8:	31 96       	adiw	r30, 0x01	; 1
    b4fa:	85 e9       	ldi	r24, 0x95	; 149
    b4fc:	92 e0       	ldi	r25, 0x02	; 2
    b4fe:	ad b7       	in	r26, 0x3d	; 61
    b500:	be b7       	in	r27, 0x3e	; 62
    b502:	12 96       	adiw	r26, 0x02	; 2
    b504:	9c 93       	st	X, r25
    b506:	8e 93       	st	-X, r24
    b508:	11 97       	sbiw	r26, 0x01	; 1
    b50a:	8d e6       	ldi	r24, 0x6D	; 109
    b50c:	97 e0       	ldi	r25, 0x07	; 7
    b50e:	1d c0       	rjmp	.+58     	; 0xb54a <PrintIdle+0x9ca>
			   }else ClearMem(strPrint);
		       break;
		  case 25:
		       if ((strlen(strCorporateName)>0)&&(SpaceOnly(strCorporateName)==False)){
    b510:	cd ef       	ldi	r28, 0xFD	; 253
    b512:	d5 e0       	ldi	r29, 0x05	; 5
    b514:	80 91 fd 05 	lds	r24, 0x05FD
    b518:	88 23       	and	r24, r24
    b51a:	e1 f0       	breq	.+56     	; 0xb554 <PrintIdle+0x9d4>
    b51c:	ce 01       	movw	r24, r28
    b51e:	0e 94 99 22 	call	0x4532	; 0x4532 <SpaceOnly>
    b522:	88 23       	and	r24, r24
    b524:	b9 f4       	brne	.+46     	; 0xb554 <PrintIdle+0x9d4>
		           CarriegeReturn();
    b526:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
				   //RemSpaceLag(strCorporateName);
		           sprintf_P(strPrint,PSTR("     Corp Name    : %s"),strCorporateName);
    b52a:	00 d0       	rcall	.+0      	; 0xb52c <PrintIdle+0x9ac>
    b52c:	00 d0       	rcall	.+0      	; 0xb52e <PrintIdle+0x9ae>
    b52e:	00 d0       	rcall	.+0      	; 0xb530 <PrintIdle+0x9b0>
    b530:	ed b7       	in	r30, 0x3d	; 61
    b532:	fe b7       	in	r31, 0x3e	; 62
    b534:	31 96       	adiw	r30, 0x01	; 1
    b536:	85 e9       	ldi	r24, 0x95	; 149
    b538:	92 e0       	ldi	r25, 0x02	; 2
    b53a:	ad b7       	in	r26, 0x3d	; 61
    b53c:	be b7       	in	r27, 0x3e	; 62
    b53e:	12 96       	adiw	r26, 0x02	; 2
    b540:	9c 93       	st	X, r25
    b542:	8e 93       	st	-X, r24
    b544:	11 97       	sbiw	r26, 0x01	; 1
    b546:	86 e5       	ldi	r24, 0x56	; 86
    b548:	97 e0       	ldi	r25, 0x07	; 7
    b54a:	93 83       	std	Z+3, r25	; 0x03
    b54c:	82 83       	std	Z+2, r24	; 0x02
    b54e:	d5 83       	std	Z+5, r29	; 0x05
    b550:	c4 83       	std	Z+4, r28	; 0x04
    b552:	e2 c0       	rjmp	.+452    	; 0xb718 <PrintIdle+0xb98>
			   }else ClearMem(strPrint);
    b554:	85 e9       	ldi	r24, 0x95	; 149
    b556:	92 e0       	ldi	r25, 0x02	; 2
    b558:	2c ce       	rjmp	.-936    	; 0xb1b2 <PrintIdle+0x632>
		       break;
		  case 26:
		       CarriegeReturn();
    b55a:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Gain Points  : %s"),strGainPoints);
    b55e:	00 d0       	rcall	.+0      	; 0xb560 <PrintIdle+0x9e0>
    b560:	00 d0       	rcall	.+0      	; 0xb562 <PrintIdle+0x9e2>
    b562:	00 d0       	rcall	.+0      	; 0xb564 <PrintIdle+0x9e4>
    b564:	ed b7       	in	r30, 0x3d	; 61
    b566:	fe b7       	in	r31, 0x3e	; 62
    b568:	31 96       	adiw	r30, 0x01	; 1
    b56a:	85 e9       	ldi	r24, 0x95	; 149
    b56c:	92 e0       	ldi	r25, 0x02	; 2
    b56e:	ad b7       	in	r26, 0x3d	; 61
    b570:	be b7       	in	r27, 0x3e	; 62
    b572:	12 96       	adiw	r26, 0x02	; 2
    b574:	9c 93       	st	X, r25
    b576:	8e 93       	st	-X, r24
    b578:	11 97       	sbiw	r26, 0x01	; 1
    b57a:	8f e3       	ldi	r24, 0x3F	; 63
    b57c:	97 e0       	ldi	r25, 0x07	; 7
    b57e:	93 83       	std	Z+3, r25	; 0x03
    b580:	82 83       	std	Z+2, r24	; 0x02
    b582:	8b e9       	ldi	r24, 0x9B	; 155
    b584:	94 e0       	ldi	r25, 0x04	; 4
    b586:	c6 c0       	rjmp	.+396    	; 0xb714 <PrintIdle+0xb94>
		       break;
		  case 27:
		       CarriegeReturn();
    b588:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Prev Points  : %s"),strPrevPoints);
    b58c:	00 d0       	rcall	.+0      	; 0xb58e <PrintIdle+0xa0e>
    b58e:	00 d0       	rcall	.+0      	; 0xb590 <PrintIdle+0xa10>
    b590:	00 d0       	rcall	.+0      	; 0xb592 <PrintIdle+0xa12>
    b592:	ed b7       	in	r30, 0x3d	; 61
    b594:	fe b7       	in	r31, 0x3e	; 62
    b596:	31 96       	adiw	r30, 0x01	; 1
    b598:	85 e9       	ldi	r24, 0x95	; 149
    b59a:	92 e0       	ldi	r25, 0x02	; 2
    b59c:	ad b7       	in	r26, 0x3d	; 61
    b59e:	be b7       	in	r27, 0x3e	; 62
    b5a0:	12 96       	adiw	r26, 0x02	; 2
    b5a2:	9c 93       	st	X, r25
    b5a4:	8e 93       	st	-X, r24
    b5a6:	11 97       	sbiw	r26, 0x01	; 1
    b5a8:	88 e2       	ldi	r24, 0x28	; 40
    b5aa:	97 e0       	ldi	r25, 0x07	; 7
    b5ac:	93 83       	std	Z+3, r25	; 0x03
    b5ae:	82 83       	std	Z+2, r24	; 0x02
    b5b0:	8c e3       	ldi	r24, 0x3C	; 60
    b5b2:	9b e0       	ldi	r25, 0x0B	; 11
    b5b4:	af c0       	rjmp	.+350    	; 0xb714 <PrintIdle+0xb94>
		       break;
		  case 28:
		       CarriegeReturn();
    b5b6:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Curr Points  : %s"),strLoyCurrentPoints);
    b5ba:	00 d0       	rcall	.+0      	; 0xb5bc <PrintIdle+0xa3c>
    b5bc:	00 d0       	rcall	.+0      	; 0xb5be <PrintIdle+0xa3e>
    b5be:	00 d0       	rcall	.+0      	; 0xb5c0 <PrintIdle+0xa40>
    b5c0:	ed b7       	in	r30, 0x3d	; 61
    b5c2:	fe b7       	in	r31, 0x3e	; 62
    b5c4:	31 96       	adiw	r30, 0x01	; 1
    b5c6:	85 e9       	ldi	r24, 0x95	; 149
    b5c8:	92 e0       	ldi	r25, 0x02	; 2
    b5ca:	ad b7       	in	r26, 0x3d	; 61
    b5cc:	be b7       	in	r27, 0x3e	; 62
    b5ce:	12 96       	adiw	r26, 0x02	; 2
    b5d0:	9c 93       	st	X, r25
    b5d2:	8e 93       	st	-X, r24
    b5d4:	11 97       	sbiw	r26, 0x01	; 1
    b5d6:	81 e1       	ldi	r24, 0x11	; 17
    b5d8:	97 e0       	ldi	r25, 0x07	; 7
    b5da:	93 83       	std	Z+3, r25	; 0x03
    b5dc:	82 83       	std	Z+2, r24	; 0x02
    b5de:	8a e8       	ldi	r24, 0x8A	; 138
    b5e0:	9a e0       	ldi	r25, 0x0A	; 10
    b5e2:	98 c0       	rjmp	.+304    	; 0xb714 <PrintIdle+0xb94>
		       break;
		  case 29:
		       CarriegeReturn();
    b5e4:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Expiry       : %s"),strLoyExpiry);
    b5e8:	00 d0       	rcall	.+0      	; 0xb5ea <PrintIdle+0xa6a>
    b5ea:	00 d0       	rcall	.+0      	; 0xb5ec <PrintIdle+0xa6c>
    b5ec:	00 d0       	rcall	.+0      	; 0xb5ee <PrintIdle+0xa6e>
    b5ee:	ed b7       	in	r30, 0x3d	; 61
    b5f0:	fe b7       	in	r31, 0x3e	; 62
    b5f2:	31 96       	adiw	r30, 0x01	; 1
    b5f4:	85 e9       	ldi	r24, 0x95	; 149
    b5f6:	92 e0       	ldi	r25, 0x02	; 2
    b5f8:	ad b7       	in	r26, 0x3d	; 61
    b5fa:	be b7       	in	r27, 0x3e	; 62
    b5fc:	12 96       	adiw	r26, 0x02	; 2
    b5fe:	9c 93       	st	X, r25
    b600:	8e 93       	st	-X, r24
    b602:	11 97       	sbiw	r26, 0x01	; 1
    b604:	8a ef       	ldi	r24, 0xFA	; 250
    b606:	96 e0       	ldi	r25, 0x06	; 6
    b608:	93 83       	std	Z+3, r25	; 0x03
    b60a:	82 83       	std	Z+2, r24	; 0x02
    b60c:	83 ea       	ldi	r24, 0xA3	; 163
    b60e:	9e e0       	ldi	r25, 0x0E	; 14
    b610:	81 c0       	rjmp	.+258    	; 0xb714 <PrintIdle+0xb94>
		       break;
		  case 30:
		       CarriegeReturn();
    b612:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			   //RemSpaceLag(strLoyRedeemPoints);
		       sprintf_P(strPrint,PSTR("     Total Redeem : %s"),strLoyRedeemPoints);
    b616:	00 d0       	rcall	.+0      	; 0xb618 <PrintIdle+0xa98>
    b618:	00 d0       	rcall	.+0      	; 0xb61a <PrintIdle+0xa9a>
    b61a:	00 d0       	rcall	.+0      	; 0xb61c <PrintIdle+0xa9c>
    b61c:	ed b7       	in	r30, 0x3d	; 61
    b61e:	fe b7       	in	r31, 0x3e	; 62
    b620:	31 96       	adiw	r30, 0x01	; 1
    b622:	85 e9       	ldi	r24, 0x95	; 149
    b624:	92 e0       	ldi	r25, 0x02	; 2
    b626:	ad b7       	in	r26, 0x3d	; 61
    b628:	be b7       	in	r27, 0x3e	; 62
    b62a:	12 96       	adiw	r26, 0x02	; 2
    b62c:	9c 93       	st	X, r25
    b62e:	8e 93       	st	-X, r24
    b630:	11 97       	sbiw	r26, 0x01	; 1
    b632:	83 ee       	ldi	r24, 0xE3	; 227
    b634:	96 e0       	ldi	r25, 0x06	; 6
    b636:	93 83       	std	Z+3, r25	; 0x03
    b638:	82 83       	std	Z+2, r24	; 0x02
    b63a:	8a ec       	ldi	r24, 0xCA	; 202
    b63c:	95 e0       	ldi	r25, 0x05	; 5
    b63e:	6a c0       	rjmp	.+212    	; 0xb714 <PrintIdle+0xb94>
		       break;
		  case 31:
		       CarriegeReturn();
    b640:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeV);
			   //FormatCurrency(strLoyCurrMonConsumeV);
		       sprintf_P(strPrint,PSTR("     Month Cons V : %s L"),strLoyCurrMonConsumeV);
    b644:	00 d0       	rcall	.+0      	; 0xb646 <PrintIdle+0xac6>
    b646:	00 d0       	rcall	.+0      	; 0xb648 <PrintIdle+0xac8>
    b648:	00 d0       	rcall	.+0      	; 0xb64a <PrintIdle+0xaca>
    b64a:	ed b7       	in	r30, 0x3d	; 61
    b64c:	fe b7       	in	r31, 0x3e	; 62
    b64e:	31 96       	adiw	r30, 0x01	; 1
    b650:	85 e9       	ldi	r24, 0x95	; 149
    b652:	92 e0       	ldi	r25, 0x02	; 2
    b654:	ad b7       	in	r26, 0x3d	; 61
    b656:	be b7       	in	r27, 0x3e	; 62
    b658:	12 96       	adiw	r26, 0x02	; 2
    b65a:	9c 93       	st	X, r25
    b65c:	8e 93       	st	-X, r24
    b65e:	11 97       	sbiw	r26, 0x01	; 1
    b660:	8a ec       	ldi	r24, 0xCA	; 202
    b662:	96 e0       	ldi	r25, 0x06	; 6
    b664:	93 83       	std	Z+3, r25	; 0x03
    b666:	82 83       	std	Z+2, r24	; 0x02
    b668:	88 e1       	ldi	r24, 0x18	; 24
    b66a:	9e e0       	ldi	r25, 0x0E	; 14
    b66c:	53 c0       	rjmp	.+166    	; 0xb714 <PrintIdle+0xb94>
		       break;
		  case 32:
		       CarriegeReturn();
    b66e:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeA);
			   //FormatCurrency(strLoyCurrMonConsumeA);
		       sprintf_P(strPrint,PSTR("     Month Cons A : Rp.%s"),strLoyCurrMonConsumeA);
    b672:	00 d0       	rcall	.+0      	; 0xb674 <PrintIdle+0xaf4>
    b674:	00 d0       	rcall	.+0      	; 0xb676 <PrintIdle+0xaf6>
    b676:	00 d0       	rcall	.+0      	; 0xb678 <PrintIdle+0xaf8>
    b678:	ed b7       	in	r30, 0x3d	; 61
    b67a:	fe b7       	in	r31, 0x3e	; 62
    b67c:	31 96       	adiw	r30, 0x01	; 1
    b67e:	85 e9       	ldi	r24, 0x95	; 149
    b680:	92 e0       	ldi	r25, 0x02	; 2
    b682:	ad b7       	in	r26, 0x3d	; 61
    b684:	be b7       	in	r27, 0x3e	; 62
    b686:	12 96       	adiw	r26, 0x02	; 2
    b688:	9c 93       	st	X, r25
    b68a:	8e 93       	st	-X, r24
    b68c:	11 97       	sbiw	r26, 0x01	; 1
    b68e:	80 eb       	ldi	r24, 0xB0	; 176
    b690:	96 e0       	ldi	r25, 0x06	; 6
    b692:	93 83       	std	Z+3, r25	; 0x03
    b694:	82 83       	std	Z+2, r24	; 0x02
    b696:	8e ea       	ldi	r24, 0xAE	; 174
    b698:	95 e0       	ldi	r25, 0x05	; 5
    b69a:	3c c0       	rjmp	.+120    	; 0xb714 <PrintIdle+0xb94>
		       break;
		  case 33://EndOfLoyalty
		       CarriegeReturn();
    b69c:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b6a0:	00 d0       	rcall	.+0      	; 0xb6a2 <PrintIdle+0xb22>
    b6a2:	00 d0       	rcall	.+0      	; 0xb6a4 <PrintIdle+0xb24>
    b6a4:	85 e9       	ldi	r24, 0x95	; 149
    b6a6:	92 e0       	ldi	r25, 0x02	; 2
    b6a8:	ad b7       	in	r26, 0x3d	; 61
    b6aa:	be b7       	in	r27, 0x3e	; 62
    b6ac:	12 96       	adiw	r26, 0x02	; 2
    b6ae:	9c 93       	st	X, r25
    b6b0:	8e 93       	st	-X, r24
    b6b2:	11 97       	sbiw	r26, 0x01	; 1
    b6b4:	8d e8       	ldi	r24, 0x8D	; 141
    b6b6:	96 e0       	ldi	r25, 0x06	; 6
    b6b8:	48 c0       	rjmp	.+144    	; 0xb74a <PrintIdle+0xbca>
		       break;
		  case 34:
		       CarriegeReturn();
    b6ba:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Dsc: %s"),strSurchargeDesc);
    b6be:	00 d0       	rcall	.+0      	; 0xb6c0 <PrintIdle+0xb40>
    b6c0:	00 d0       	rcall	.+0      	; 0xb6c2 <PrintIdle+0xb42>
    b6c2:	00 d0       	rcall	.+0      	; 0xb6c4 <PrintIdle+0xb44>
    b6c4:	ed b7       	in	r30, 0x3d	; 61
    b6c6:	fe b7       	in	r31, 0x3e	; 62
    b6c8:	31 96       	adiw	r30, 0x01	; 1
    b6ca:	85 e9       	ldi	r24, 0x95	; 149
    b6cc:	92 e0       	ldi	r25, 0x02	; 2
    b6ce:	ad b7       	in	r26, 0x3d	; 61
    b6d0:	be b7       	in	r27, 0x3e	; 62
    b6d2:	12 96       	adiw	r26, 0x02	; 2
    b6d4:	9c 93       	st	X, r25
    b6d6:	8e 93       	st	-X, r24
    b6d8:	11 97       	sbiw	r26, 0x01	; 1
    b6da:	86 e7       	ldi	r24, 0x76	; 118
    b6dc:	96 e0       	ldi	r25, 0x06	; 6
    b6de:	93 83       	std	Z+3, r25	; 0x03
    b6e0:	82 83       	std	Z+2, r24	; 0x02
    b6e2:	8f e1       	ldi	r24, 0x1F	; 31
    b6e4:	9a e0       	ldi	r25, 0x0A	; 10
    b6e6:	16 c0       	rjmp	.+44     	; 0xb714 <PrintIdle+0xb94>
		       break;
		  case 35:
		       CarriegeReturn();
    b6e8:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Amt: %s"),strSurchargeAmount);
    b6ec:	00 d0       	rcall	.+0      	; 0xb6ee <PrintIdle+0xb6e>
    b6ee:	00 d0       	rcall	.+0      	; 0xb6f0 <PrintIdle+0xb70>
    b6f0:	00 d0       	rcall	.+0      	; 0xb6f2 <PrintIdle+0xb72>
    b6f2:	ed b7       	in	r30, 0x3d	; 61
    b6f4:	fe b7       	in	r31, 0x3e	; 62
    b6f6:	31 96       	adiw	r30, 0x01	; 1
    b6f8:	85 e9       	ldi	r24, 0x95	; 149
    b6fa:	92 e0       	ldi	r25, 0x02	; 2
    b6fc:	ad b7       	in	r26, 0x3d	; 61
    b6fe:	be b7       	in	r27, 0x3e	; 62
    b700:	12 96       	adiw	r26, 0x02	; 2
    b702:	9c 93       	st	X, r25
    b704:	8e 93       	st	-X, r24
    b706:	11 97       	sbiw	r26, 0x01	; 1
    b708:	8f e5       	ldi	r24, 0x5F	; 95
    b70a:	96 e0       	ldi	r25, 0x06	; 6
    b70c:	93 83       	std	Z+3, r25	; 0x03
    b70e:	82 83       	std	Z+2, r24	; 0x02
    b710:	87 ea       	ldi	r24, 0xA7	; 167
    b712:	9a e0       	ldi	r25, 0x0A	; 10
    b714:	95 83       	std	Z+5, r25	; 0x05
    b716:	84 83       	std	Z+4, r24	; 0x04
    b718:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    b71c:	ed b7       	in	r30, 0x3d	; 61
    b71e:	fe b7       	in	r31, 0x3e	; 62
    b720:	36 96       	adiw	r30, 0x06	; 6
    b722:	0f b6       	in	r0, 0x3f	; 63
    b724:	f8 94       	cli
    b726:	fe bf       	out	0x3e, r31	; 62
    b728:	0f be       	out	0x3f, r0	; 63
    b72a:	ed bf       	out	0x3d, r30	; 61
    b72c:	18 c0       	rjmp	.+48     	; 0xb75e <PrintIdle+0xbde>
		       break;
		  case 36:
		       CarriegeReturn();
    b72e:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b732:	00 d0       	rcall	.+0      	; 0xb734 <PrintIdle+0xbb4>
    b734:	00 d0       	rcall	.+0      	; 0xb736 <PrintIdle+0xbb6>
    b736:	85 e9       	ldi	r24, 0x95	; 149
    b738:	92 e0       	ldi	r25, 0x02	; 2
    b73a:	ad b7       	in	r26, 0x3d	; 61
    b73c:	be b7       	in	r27, 0x3e	; 62
    b73e:	12 96       	adiw	r26, 0x02	; 2
    b740:	9c 93       	st	X, r25
    b742:	8e 93       	st	-X, r24
    b744:	11 97       	sbiw	r26, 0x01	; 1
    b746:	8c e3       	ldi	r24, 0x3C	; 60
    b748:	96 e0       	ldi	r25, 0x06	; 6
    b74a:	14 96       	adiw	r26, 0x04	; 4
    b74c:	9c 93       	st	X, r25
    b74e:	8e 93       	st	-X, r24
    b750:	13 97       	sbiw	r26, 0x03	; 3
    b752:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    b756:	0f 90       	pop	r0
    b758:	0f 90       	pop	r0
    b75a:	0f 90       	pop	r0
    b75c:	0f 90       	pop	r0
		       break;
		  }
		  iLoop=0;iSend=0;LSend=strlen(strPrint);
    b75e:	10 92 8d 02 	sts	0x028D, r1
    b762:	10 92 8c 02 	sts	0x028C, r1
    b766:	10 92 91 02 	sts	0x0291, r1
    b76a:	10 92 90 02 	sts	0x0290, r1
    b76e:	e5 e9       	ldi	r30, 0x95	; 149
    b770:	f2 e0       	ldi	r31, 0x02	; 2
    b772:	01 90       	ld	r0, Z+
    b774:	00 20       	and	r0, r0
    b776:	e9 f7       	brne	.-6      	; 0xb772 <PrintIdle+0xbf2>
    b778:	31 97       	sbiw	r30, 0x01	; 1
    b77a:	e5 59       	subi	r30, 0x95	; 149
    b77c:	f2 40       	sbci	r31, 0x02	; 2
    b77e:	f0 93 8f 02 	sts	0x028F, r31
    b782:	e0 93 8e 02 	sts	0x028E, r30
          stPrintIdle=piPrintMessage;
    b786:	8a e0       	ldi	r24, 0x0A	; 10
    b788:	f3 c0       	rjmp	.+486    	; 0xb970 <PrintIdle+0xdf0>
	      break;
     case piPrintMessage:
	      if (iSend<LSend){
    b78a:	20 91 90 02 	lds	r18, 0x0290
    b78e:	30 91 91 02 	lds	r19, 0x0291
    b792:	80 91 8e 02 	lds	r24, 0x028E
    b796:	90 91 8f 02 	lds	r25, 0x028F
    b79a:	28 17       	cp	r18, r24
    b79c:	39 07       	cpc	r19, r25
    b79e:	78 f4       	brcc	.+30     	; 0xb7be <PrintIdle+0xc3e>
		      iLoop++;
    b7a0:	80 91 8c 02 	lds	r24, 0x028C
    b7a4:	90 91 8d 02 	lds	r25, 0x028D
    b7a8:	01 96       	adiw	r24, 0x01	; 1
    b7aa:	90 93 8d 02 	sts	0x028D, r25
    b7ae:	80 93 8c 02 	sts	0x028C, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    b7b2:	10 92 cd 01 	sts	0x01CD, r1
    b7b6:	10 92 cc 01 	sts	0x01CC, r1
				 stPrintIdle=piCheckPrintStatusMessage;
    b7ba:	8c e0       	ldi	r24, 0x0C	; 12
    b7bc:	d9 c0       	rjmp	.+434    	; 0xb970 <PrintIdle+0xdf0>
				 }
			  }
          else{iMessage++;
    b7be:	80 91 94 02 	lds	r24, 0x0294
    b7c2:	8f 5f       	subi	r24, 0xFF	; 255
    b7c4:	80 93 94 02 	sts	0x0294, r24
		      if (iMessage>MessageLine){
    b7c8:	90 91 93 02 	lds	r25, 0x0293
    b7cc:	98 17       	cp	r25, r24
    b7ce:	18 f4       	brcc	.+6      	; 0xb7d6 <PrintIdle+0xc56>
			      iFooter=0;
    b7d0:	10 92 c4 02 	sts	0x02C4, r1
    b7d4:	5c c0       	rjmp	.+184    	; 0xb88e <PrintIdle+0xd0e>
				  stPrintIdle=piLoadFooter;
				  CarriegeReturn();
			  }
			  else stPrintIdle=piLoadMessage;
    b7d6:	89 e0       	ldi	r24, 0x09	; 9
    b7d8:	cb c0       	rjmp	.+406    	; 0xb970 <PrintIdle+0xdf0>
			  }
	      break;
     case piCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    b7da:	80 91 c9 01 	lds	r24, 0x01C9
    b7de:	88 23       	and	r24, r24
    b7e0:	09 f0       	breq	.+2      	; 0xb7e4 <PrintIdle+0xc64>
    b7e2:	bc c0       	rjmp	.+376    	; 0xb95c <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    b7e4:	e0 91 90 02 	lds	r30, 0x0290
    b7e8:	f0 91 91 02 	lds	r31, 0x0291
    b7ec:	eb 56       	subi	r30, 0x6B	; 107
    b7ee:	fd 4f       	sbci	r31, 0xFD	; 253
    b7f0:	61 e0       	ldi	r22, 0x01	; 1
    b7f2:	40 81       	ld	r20, Z
    b7f4:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
		      iSend++;
    b7f8:	80 91 90 02 	lds	r24, 0x0290
    b7fc:	90 91 91 02 	lds	r25, 0x0291
    b800:	01 96       	adiw	r24, 0x01	; 1
    b802:	90 93 91 02 	sts	0x0291, r25
    b806:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintMessage;
    b80a:	8a e0       	ldi	r24, 0x0A	; 10
    b80c:	a5 c0       	rjmp	.+330    	; 0xb958 <PrintIdle+0xdd8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    b80e:	60 91 c4 02 	lds	r22, 0x02C4
    b812:	89 e2       	ldi	r24, 0x29	; 41
    b814:	68 9f       	mul	r22, r24
    b816:	b0 01       	movw	r22, r0
    b818:	11 24       	eor	r1, r1
    b81a:	63 5e       	subi	r22, 0xE3	; 227
    b81c:	7c 4f       	sbci	r23, 0xFC	; 252
    b81e:	85 e9       	ldi	r24, 0x95	; 149
    b820:	92 e0       	ldi	r25, 0x02	; 2
    b822:	48 e2       	ldi	r20, 0x28	; 40
    b824:	50 e0       	ldi	r21, 0x00	; 0
    b826:	25 ed       	ldi	r18, 0xD5	; 213
    b828:	32 e1       	ldi	r19, 0x12	; 18
    b82a:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
	      break;
		       
     case piLoadFooter:
	      FillChar(strPrint,0,sizeof(strPrint));
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    b82e:	80 91 c4 02 	lds	r24, 0x02C4
    b832:	8f 5f       	subi	r24, 0xFF	; 255
    b834:	80 93 c4 02 	sts	0x02C4, r24
		  if (iFooter<=4){
    b838:	85 30       	cpi	r24, 0x05	; 5
    b83a:	90 f4       	brcc	.+36     	; 0xb860 <PrintIdle+0xce0>
		      if (SpaceOnly(strPrint)==True){
    b83c:	85 e9       	ldi	r24, 0x95	; 149
    b83e:	92 e0       	ldi	r25, 0x02	; 2
    b840:	0e 94 99 22 	call	0x4532	; 0x4532 <SpaceOnly>
    b844:	81 30       	cpi	r24, 0x01	; 1
    b846:	11 f4       	brne	.+4      	; 0xb84c <PrintIdle+0xccc>
			      stPrintIdle=piLoadFooter;
    b848:	8e e0       	ldi	r24, 0x0E	; 14
    b84a:	92 c0       	rjmp	.+292    	; 0xb970 <PrintIdle+0xdf0>
				  }
			  else{
			      iSend=0;
    b84c:	10 92 91 02 	sts	0x0291, r1
    b850:	10 92 90 02 	sts	0x0290, r1
				  iLoop=0;
    b854:	10 92 8d 02 	sts	0x028D, r1
    b858:	10 92 8c 02 	sts	0x028C, r1
				  stPrintIdle=piPrintFooter;
    b85c:	8f e0       	ldi	r24, 0x0F	; 15
    b85e:	88 c0       	rjmp	.+272    	; 0xb970 <PrintIdle+0xdf0>
				  //RemSpaceLag(strPrint);
				  //CarriegeReturn();
			      }
		  }else{stPrintIdle=piInitScroll;
    b860:	81 e1       	ldi	r24, 0x11	; 17
    b862:	86 c0       	rjmp	.+268    	; 0xb970 <PrintIdle+0xdf0>
		        //iPrinted++;
			}
	      break;
     case piPrintFooter:
		  if (iSend<40){
    b864:	80 91 90 02 	lds	r24, 0x0290
    b868:	90 91 91 02 	lds	r25, 0x0291
    b86c:	88 97       	sbiw	r24, 0x28	; 40
    b86e:	78 f4       	brcc	.+30     	; 0xb88e <PrintIdle+0xd0e>
		      iLoop++;
    b870:	80 91 8c 02 	lds	r24, 0x028C
    b874:	90 91 8d 02 	lds	r25, 0x028D
    b878:	01 96       	adiw	r24, 0x01	; 1
    b87a:	90 93 8d 02 	sts	0x028D, r25
    b87e:	80 93 8c 02 	sts	0x028C, r24
			  if((iLoop%PRINT_DELAY)==0){
				TimPrintBusy=0;
    b882:	10 92 cd 01 	sts	0x01CD, r1
    b886:	10 92 cc 01 	sts	0x01CC, r1
				stPrintIdle=piCheckPrintStatusFooter;
    b88a:	8d e0       	ldi	r24, 0x0D	; 13
    b88c:	71 c0       	rjmp	.+226    	; 0xb970 <PrintIdle+0xdf0>
				}
			  }
          else {
		      stPrintIdle=piLoadFooter;
    b88e:	8e e0       	ldi	r24, 0x0E	; 14
    b890:	80 93 c6 02 	sts	0x02C6, r24
			  CarriegeReturn();
    b894:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
    b898:	96 c0       	rjmp	.+300    	; 0xb9c6 <PrintIdle+0xe46>
			  }
	      break;
     case piCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    b89a:	80 91 c9 01 	lds	r24, 0x01C9
    b89e:	88 23       	and	r24, r24
    b8a0:	09 f0       	breq	.+2      	; 0xb8a4 <PrintIdle+0xd24>
    b8a2:	5c c0       	rjmp	.+184    	; 0xb95c <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    b8a4:	e0 91 90 02 	lds	r30, 0x0290
    b8a8:	f0 91 91 02 	lds	r31, 0x0291
    b8ac:	eb 56       	subi	r30, 0x6B	; 107
    b8ae:	fd 4f       	sbci	r31, 0xFD	; 253
    b8b0:	61 e0       	ldi	r22, 0x01	; 1
    b8b2:	40 81       	ld	r20, Z
    b8b4:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
		      iSend++;
    b8b8:	80 91 90 02 	lds	r24, 0x0290
    b8bc:	90 91 91 02 	lds	r25, 0x0291
    b8c0:	01 96       	adiw	r24, 0x01	; 1
    b8c2:	90 93 91 02 	sts	0x0291, r25
    b8c6:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintFooter;
    b8ca:	8f e0       	ldi	r24, 0x0F	; 15
    b8cc:	45 c0       	rjmp	.+138    	; 0xb958 <PrintIdle+0xdd8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitScroll:
	      iPrinted++;
    b8ce:	90 91 8b 02 	lds	r25, 0x028B
    b8d2:	9f 5f       	subi	r25, 0xFF	; 255
    b8d4:	90 93 8b 02 	sts	0x028B, r25
		  iScroll=0;
    b8d8:	10 92 c3 02 	sts	0x02C3, r1
		  iLoop=0;
    b8dc:	10 92 8d 02 	sts	0x028D, r1
    b8e0:	10 92 8c 02 	sts	0x028C, r1
		  if (iPrinted<PrintCopy){
    b8e4:	80 91 8a 02 	lds	r24, 0x028A
    b8e8:	98 17       	cp	r25, r24
    b8ea:	28 f4       	brcc	.+10     	; 0xb8f6 <PrintIdle+0xd76>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b8ec:	e1 99       	sbic	0x1c, 1	; 28
    b8ee:	fe cf       	rjmp	.-4      	; 0xb8ec <PrintIdle+0xd6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b8f0:	82 e3       	ldi	r24, 0x32	; 50
    b8f2:	90 e0       	ldi	r25, 0x00	; 0
    b8f4:	04 c0       	rjmp	.+8      	; 0xb8fe <PrintIdle+0xd7e>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b8f6:	e1 99       	sbic	0x1c, 1	; 28
    b8f8:	fe cf       	rjmp	.-4      	; 0xb8f6 <PrintIdle+0xd76>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b8fa:	81 e3       	ldi	r24, 0x31	; 49
    b8fc:	90 e0       	ldi	r25, 0x00	; 0
    b8fe:	9f bb       	out	0x1f, r25	; 31
    b900:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b902:	e0 9a       	sbi	0x1c, 0	; 28
    b904:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  }else if (iPrinted>=PrintCopy){		  	  
		      nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    b906:	80 93 c2 02 	sts	0x02C2, r24
		  if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_TG02){
		      _uart_printf(0,1,PSTR("----Scrolled2-----"));

		      stPrintIdle=piPaperCut;
		  }*/
          stPrintIdle=piScrollPaper;              
    b90a:	80 e1       	ldi	r24, 0x10	; 16
    b90c:	31 c0       	rjmp	.+98     	; 0xb970 <PrintIdle+0xdf0>
	      break;
     case piScrollPaper:
	      iLoop++;
    b90e:	80 91 8c 02 	lds	r24, 0x028C
    b912:	90 91 8d 02 	lds	r25, 0x028D
    b916:	01 96       	adiw	r24, 0x01	; 1
    b918:	90 93 8d 02 	sts	0x028D, r25
    b91c:	80 93 8c 02 	sts	0x028C, r24
		  if (iLoop%PRINT_DELAY==0){
			  TimPrintBusy=0;
    b920:	10 92 cd 01 	sts	0x01CD, r1
    b924:	10 92 cc 01 	sts	0x01CC, r1
			  stPrintIdle=piCheckPrintStatusScroll;
    b928:	82 e1       	ldi	r24, 0x12	; 18
    b92a:	80 93 c6 02 	sts	0x02C6, r24
			  }
	      if (iScroll>nScroll)stPrintIdle=piPaperCut;
    b92e:	90 91 c3 02 	lds	r25, 0x02C3
    b932:	80 91 c2 02 	lds	r24, 0x02C2
    b936:	89 17       	cp	r24, r25
    b938:	08 f0       	brcs	.+2      	; 0xb93c <PrintIdle+0xdbc>
    b93a:	45 c0       	rjmp	.+138    	; 0xb9c6 <PrintIdle+0xe46>
    b93c:	83 e1       	ldi	r24, 0x13	; 19
    b93e:	18 c0       	rjmp	.+48     	; 0xb970 <PrintIdle+0xdf0>
	      break;
     case piCheckPrintStatusScroll:
	      if (IsBusyPrint==False){
    b940:	80 91 c9 01 	lds	r24, 0x01C9
    b944:	88 23       	and	r24, r24
    b946:	51 f4       	brne	.+20     	; 0xb95c <PrintIdle+0xddc>
		      iScroll++;
    b948:	80 91 c3 02 	lds	r24, 0x02C3
    b94c:	8f 5f       	subi	r24, 0xFF	; 255
    b94e:	80 93 c3 02 	sts	0x02C3, r24
		      CarriegeReturn();
    b952:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		      stPrintIdle=piScrollPaper;
    b956:	80 e1       	ldi	r24, 0x10	; 16
    b958:	80 93 c6 02 	sts	0x02C6, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    b95c:	80 91 cc 01 	lds	r24, 0x01CC
    b960:	90 91 cd 01 	lds	r25, 0x01CD
    b964:	0b 97       	sbiw	r24, 0x0b	; 11
    b966:	7c f1       	brlt	.+94     	; 0xb9c6 <PrintIdle+0xe46>
		      IsPrintERROR=True;
    b968:	81 e0       	ldi	r24, 0x01	; 1
    b96a:	80 93 c7 01 	sts	0x01C7, r24
		      stPrintIdle=piFinishPrintIdle;
    b96e:	84 e1       	ldi	r24, 0x14	; 20
    b970:	80 93 c6 02 	sts	0x02C6, r24
    b974:	28 c0       	rjmp	.+80     	; 0xb9c6 <PrintIdle+0xe46>
	      break;
     case piPaperCut:
	      //sprintf_P(strSend,PSTR("i:%d Copy:%d"),iPrinted,PrintCopy);
		  //_uart_print(0,1,strSend);

          if (iPrinted>=PrintCopy){
    b976:	90 91 8b 02 	lds	r25, 0x028B
    b97a:	80 91 8a 02 	lds	r24, 0x028A
    b97e:	98 17       	cp	r25, r24
    b980:	10 f0       	brcs	.+4      	; 0xb986 <PrintIdle+0xe06>
		      stPrintIdle=piFinishPrintIdle;
    b982:	84 e1       	ldi	r24, 0x14	; 20
    b984:	05 c0       	rjmp	.+10     	; 0xb990 <PrintIdle+0xe10>
			  }
		  else {CarriegeReturn();
    b986:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		        CarriegeReturn();
    b98a:	0e 94 a1 4b 	call	0x9742	; 0x9742 <CarriegeReturn>
		        stPrintIdle=piInit;
    b98e:	81 e0       	ldi	r24, 0x01	; 1
    b990:	80 93 c6 02 	sts	0x02C6, r24
		       }
		  PaperCut();
    b994:	0e 94 48 4c 	call	0x9890	; 0x9890 <PaperCut>
    b998:	16 c0       	rjmp	.+44     	; 0xb9c6 <PrintIdle+0xe46>
	      break;
     case piFinishPrintIdle:	      
	      switch(IFType){
    b99a:	80 91 10 01 	lds	r24, 0x0110
    b99e:	81 30       	cpi	r24, 0x01	; 1
    b9a0:	19 f0       	breq	.+6      	; 0xb9a8 <PrintIdle+0xe28>
    b9a2:	82 30       	cpi	r24, 0x02	; 2
    b9a4:	61 f4       	brne	.+24     	; 0xb9be <PrintIdle+0xe3e>
    b9a6:	03 c0       	rjmp	.+6      	; 0xb9ae <PrintIdle+0xe2e>
		  case IT_SLAVE:
		       sendMessage04();
    b9a8:	0e 94 c6 52 	call	0xa58c	; 0xa58c <sendMessage04>
    b9ac:	08 c0       	rjmp	.+16     	; 0xb9be <PrintIdle+0xe3e>
		       break;
		  case IT_STANDALONE:
		  
		       UpdateStandaloneStatus((atoi(strFIP_ID)&0x0F),PS_PRINTED);
    b9ae:	8c ee       	ldi	r24, 0xEC	; 236
    b9b0:	99 e0       	ldi	r25, 0x09	; 9
    b9b2:	0e 94 bf b3 	call	0x1677e	; 0x1677e <atoi>
    b9b6:	8f 70       	andi	r24, 0x0F	; 15
    b9b8:	61 e1       	ldi	r22, 0x11	; 17
    b9ba:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <UpdateStandaloneStatus>
			   //strPumpStatus[FIPAddr]=GetPumpStatusLabel(PUMP_OFF);			   
			   //IsNewPumpStatus=True;//UpdateDisplay

		       break;
		  }
		  IsBusyIdlePrinting=False;
    b9be:	10 92 c8 01 	sts	0x01C8, r1
          stPrintIdle=piIdle;
    b9c2:	10 92 c6 02 	sts	0x02C6, r1
	      break;	 
	 }
}
    b9c6:	df 91       	pop	r29
    b9c8:	cf 91       	pop	r28
    b9ca:	08 95       	ret

0000b9cc <systemPrinting>:
     

}

void systemPrinting(){
	 FreePrinting();
    b9cc:	0e 94 2a 53 	call	0xa654	; 0xa654 <FreePrinting>
	 PrintIdle();
    b9d0:	0e 94 c0 55 	call	0xab80	; 0xab80 <PrintIdle>
}
    b9d4:	08 95       	ret

0000b9d6 <procMessage11>:
}




void procMessage11(){
    b9d6:	af 92       	push	r10
    b9d8:	bf 92       	push	r11
    b9da:	cf 92       	push	r12
    b9dc:	df 92       	push	r13
    b9de:	ef 92       	push	r14
    b9e0:	ff 92       	push	r15
    b9e2:	0f 93       	push	r16
    b9e4:	1f 93       	push	r17
    b9e6:	df 93       	push	r29
    b9e8:	cf 93       	push	r28
    b9ea:	cd b7       	in	r28, 0x3d	; 61
    b9ec:	de b7       	in	r29, 0x3e	; 62
    b9ee:	c5 55       	subi	r28, 0x55	; 85
    b9f0:	d0 40       	sbci	r29, 0x00	; 0
    b9f2:	0f b6       	in	r0, 0x3f	; 63
    b9f4:	f8 94       	cli
    b9f6:	de bf       	out	0x3e, r29	; 62
    b9f8:	0f be       	out	0x3f, r0	; 63
    b9fa:	cd bf       	out	0x3d, r28	; 61
    b9fc:	20 e0       	ldi	r18, 0x00	; 0
    b9fe:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    ba00:	ae 01       	movw	r20, r28
    ba02:	46 5f       	subi	r20, 0xF6	; 246
    ba04:	5f 4f       	sbci	r21, 0xFF	; 255
    ba06:	fa 01       	movw	r30, r20
    ba08:	e2 0f       	add	r30, r18
    ba0a:	f3 1f       	adc	r31, r19
    ba0c:	d9 01       	movw	r26, r18
    ba0e:	ab 5b       	subi	r26, 0xBB	; 187
    ba10:	b4 4f       	sbci	r27, 0xF4	; 244
    ba12:	9b 96       	adiw	r26, 0x2b	; 43
    ba14:	8c 91       	ld	r24, X
    ba16:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ba18:	2f 5f       	subi	r18, 0xFF	; 255
    ba1a:	3f 4f       	sbci	r19, 0xFF	; 255
    ba1c:	2a 30       	cpi	r18, 0x0A	; 10
    ba1e:	31 05       	cpc	r19, r1
    ba20:	91 f7       	brne	.-28     	; 0xba06 <procMessage11+0x30>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ba22:	fa 01       	movw	r30, r20
    ba24:	12 86       	std	Z+10, r1	; 0x0a
     char buffHeader[41];
	 char strProductName[13],strProductPrice[9],strTime[12],strDate[10];

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
    ba26:	81 e0       	ldi	r24, 0x01	; 1
    ba28:	ba 01       	movw	r22, r20
    ba2a:	0e 94 6d 23 	call	0x46da	; 0x46da <FormatDate>
    ba2e:	20 e0       	ldi	r18, 0x00	; 0
    ba30:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    ba32:	ae 01       	movw	r20, r28
    ba34:	4c 5e       	subi	r20, 0xEC	; 236
    ba36:	5f 4f       	sbci	r21, 0xFF	; 255
    ba38:	fa 01       	movw	r30, r20
    ba3a:	e2 0f       	add	r30, r18
    ba3c:	f3 1f       	adc	r31, r19
    ba3e:	d9 01       	movw	r26, r18
    ba40:	ab 5b       	subi	r26, 0xBB	; 187
    ba42:	b4 4f       	sbci	r27, 0xF4	; 244
    ba44:	d6 96       	adiw	r26, 0x36	; 54
    ba46:	8c 91       	ld	r24, X
    ba48:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ba4a:	2f 5f       	subi	r18, 0xFF	; 255
    ba4c:	3f 4f       	sbci	r19, 0xFF	; 255
    ba4e:	28 30       	cpi	r18, 0x08	; 8
    ba50:	31 05       	cpc	r19, r1
    ba52:	91 f7       	brne	.-28     	; 0xba38 <procMessage11+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ba54:	1c 8e       	std	Y+28, r1	; 0x1c

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
	 StrPosCopy(rcv_trans,strTime,54,8);
	 _datetime(_DATETIME_WRITE,strDate,strTime);
    ba56:	81 e0       	ldi	r24, 0x01	; 1
    ba58:	be 01       	movw	r22, r28
    ba5a:	66 5f       	subi	r22, 0xF6	; 246
    ba5c:	7f 4f       	sbci	r23, 0xFF	; 255
    ba5e:	0e 94 4b b1 	call	0x16296	; 0x16296 <_datetime>
	  
     clearString(buffHeader);
    ba62:	8e 01       	movw	r16, r28
    ba64:	03 5d       	subi	r16, 0xD3	; 211
    ba66:	1f 4f       	sbci	r17, 0xFF	; 255
    ba68:	c8 01       	movw	r24, r16
    ba6a:	0e 94 28 25 	call	0x4a50	; 0x4a50 <clearString>
    ba6e:	20 e0       	ldi	r18, 0x00	; 0
    ba70:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    ba72:	f8 01       	movw	r30, r16
    ba74:	e2 0f       	add	r30, r18
    ba76:	f3 1f       	adc	r31, r19
    ba78:	d9 01       	movw	r26, r18
    ba7a:	ab 5b       	subi	r26, 0xBB	; 187
    ba7c:	b4 4f       	sbci	r27, 0xF4	; 244
    ba7e:	de 96       	adiw	r26, 0x3e	; 62
    ba80:	8c 91       	ld	r24, X
    ba82:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ba84:	2f 5f       	subi	r18, 0xFF	; 255
    ba86:	3f 4f       	sbci	r19, 0xFF	; 255
    ba88:	28 32       	cpi	r18, 0x28	; 40
    ba8a:	31 05       	cpc	r19, r1
    ba8c:	91 f7       	brne	.-28     	; 0xba72 <procMessage11+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ba8e:	fe 01       	movw	r30, r28
    ba90:	eb 5a       	subi	r30, 0xAB	; 171
    ba92:	ff 4f       	sbci	r31, 0xFF	; 255
    ba94:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    ba96:	87 e2       	ldi	r24, 0x27	; 39
    ba98:	92 e0       	ldi	r25, 0x02	; 2
    ba9a:	b8 01       	movw	r22, r16
    ba9c:	48 e2       	ldi	r20, 0x28	; 40
    ba9e:	50 e0       	ldi	r21, 0x00	; 0
    baa0:	2d ed       	ldi	r18, 0xDD	; 221
    baa2:	32 e1       	ldi	r19, 0x12	; 18
    baa4:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    baa8:	20 e0       	ldi	r18, 0x00	; 0
    baaa:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    baac:	be 01       	movw	r22, r28
    baae:	63 5d       	subi	r22, 0xD3	; 211
    bab0:	7f 4f       	sbci	r23, 0xFF	; 255
    bab2:	fb 01       	movw	r30, r22
    bab4:	e2 0f       	add	r30, r18
    bab6:	f3 1f       	adc	r31, r19
    bab8:	d9 01       	movw	r26, r18
    baba:	a5 55       	subi	r26, 0x55	; 85
    babc:	b4 4f       	sbci	r27, 0xF4	; 244
    babe:	8c 91       	ld	r24, X
    bac0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bac2:	2f 5f       	subi	r18, 0xFF	; 255
    bac4:	3f 4f       	sbci	r19, 0xFF	; 255
    bac6:	28 32       	cpi	r18, 0x28	; 40
    bac8:	31 05       	cpc	r19, r1
    baca:	99 f7       	brne	.-26     	; 0xbab2 <procMessage11+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bacc:	fe 01       	movw	r30, r28
    bace:	eb 5a       	subi	r30, 0xAB	; 171
    bad0:	ff 4f       	sbci	r31, 0xFF	; 255
    bad2:	10 82       	st	Z, r1
    bad4:	80 e5       	ldi	r24, 0x50	; 80
    bad6:	92 e0       	ldi	r25, 0x02	; 2
    bad8:	48 e2       	ldi	r20, 0x28	; 40
    bada:	50 e0       	ldi	r21, 0x00	; 0
    badc:	2d ed       	ldi	r18, 0xDD	; 221
    bade:	32 e1       	ldi	r19, 0x12	; 18
    bae0:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    bae4:	20 e0       	ldi	r18, 0x00	; 0
    bae6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bae8:	be 01       	movw	r22, r28
    baea:	63 5d       	subi	r22, 0xD3	; 211
    baec:	7f 4f       	sbci	r23, 0xFF	; 255
    baee:	fb 01       	movw	r30, r22
    baf0:	e2 0f       	add	r30, r18
    baf2:	f3 1f       	adc	r31, r19
    baf4:	d9 01       	movw	r26, r18
    baf6:	ad 52       	subi	r26, 0x2D	; 45
    baf8:	b4 4f       	sbci	r27, 0xF4	; 244
    bafa:	8c 91       	ld	r24, X
    bafc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bafe:	2f 5f       	subi	r18, 0xFF	; 255
    bb00:	3f 4f       	sbci	r19, 0xFF	; 255
    bb02:	28 32       	cpi	r18, 0x28	; 40
    bb04:	31 05       	cpc	r19, r1
    bb06:	99 f7       	brne	.-26     	; 0xbaee <procMessage11+0x118>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bb08:	fe 01       	movw	r30, r28
    bb0a:	eb 5a       	subi	r30, 0xAB	; 171
    bb0c:	ff 4f       	sbci	r31, 0xFF	; 255
    bb0e:	10 82       	st	Z, r1
    bb10:	89 e7       	ldi	r24, 0x79	; 121
    bb12:	92 e0       	ldi	r25, 0x02	; 2
    bb14:	48 e2       	ldi	r20, 0x28	; 40
    bb16:	50 e0       	ldi	r21, 0x00	; 0
    bb18:	2d ed       	ldi	r18, 0xDD	; 221
    bb1a:	32 e1       	ldi	r19, 0x12	; 18
    bb1c:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    bb20:	20 e0       	ldi	r18, 0x00	; 0
    bb22:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bb24:	be 01       	movw	r22, r28
    bb26:	63 5d       	subi	r22, 0xD3	; 211
    bb28:	7f 4f       	sbci	r23, 0xFF	; 255
    bb2a:	fb 01       	movw	r30, r22
    bb2c:	e2 0f       	add	r30, r18
    bb2e:	f3 1f       	adc	r31, r19
    bb30:	d9 01       	movw	r26, r18
    bb32:	a5 50       	subi	r26, 0x05	; 5
    bb34:	b4 4f       	sbci	r27, 0xF4	; 244
    bb36:	8c 91       	ld	r24, X
    bb38:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bb3a:	2f 5f       	subi	r18, 0xFF	; 255
    bb3c:	3f 4f       	sbci	r19, 0xFF	; 255
    bb3e:	28 32       	cpi	r18, 0x28	; 40
    bb40:	31 05       	cpc	r19, r1
    bb42:	99 f7       	brne	.-26     	; 0xbb2a <procMessage11+0x154>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bb44:	fe 01       	movw	r30, r28
    bb46:	eb 5a       	subi	r30, 0xAB	; 171
    bb48:	ff 4f       	sbci	r31, 0xFF	; 255
    bb4a:	10 82       	st	Z, r1
    bb4c:	82 ea       	ldi	r24, 0xA2	; 162
    bb4e:	92 e0       	ldi	r25, 0x02	; 2
    bb50:	48 e2       	ldi	r20, 0x28	; 40
    bb52:	50 e0       	ldi	r21, 0x00	; 0
    bb54:	2d ed       	ldi	r18, 0xDD	; 221
    bb56:	32 e1       	ldi	r19, 0x12	; 18
    bb58:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    bb5c:	20 e0       	ldi	r18, 0x00	; 0
    bb5e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bb60:	be 01       	movw	r22, r28
    bb62:	63 5d       	subi	r22, 0xD3	; 211
    bb64:	7f 4f       	sbci	r23, 0xFF	; 255
    bb66:	fb 01       	movw	r30, r22
    bb68:	e2 0f       	add	r30, r18
    bb6a:	f3 1f       	adc	r31, r19
    bb6c:	d9 01       	movw	r26, r18
    bb6e:	ad 5d       	subi	r26, 0xDD	; 221
    bb70:	b3 4f       	sbci	r27, 0xF3	; 243
    bb72:	8c 91       	ld	r24, X
    bb74:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bb76:	2f 5f       	subi	r18, 0xFF	; 255
    bb78:	3f 4f       	sbci	r19, 0xFF	; 255
    bb7a:	28 32       	cpi	r18, 0x28	; 40
    bb7c:	31 05       	cpc	r19, r1
    bb7e:	99 f7       	brne	.-26     	; 0xbb66 <procMessage11+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bb80:	fe 01       	movw	r30, r28
    bb82:	eb 5a       	subi	r30, 0xAB	; 171
    bb84:	ff 4f       	sbci	r31, 0xFF	; 255
    bb86:	10 82       	st	Z, r1
    bb88:	8b ec       	ldi	r24, 0xCB	; 203
    bb8a:	92 e0       	ldi	r25, 0x02	; 2
    bb8c:	48 e2       	ldi	r20, 0x28	; 40
    bb8e:	50 e0       	ldi	r21, 0x00	; 0
    bb90:	2d ed       	ldi	r18, 0xDD	; 221
    bb92:	32 e1       	ldi	r19, 0x12	; 18
    bb94:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    bb98:	20 e0       	ldi	r18, 0x00	; 0
    bb9a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bb9c:	be 01       	movw	r22, r28
    bb9e:	63 5d       	subi	r22, 0xD3	; 211
    bba0:	7f 4f       	sbci	r23, 0xFF	; 255
    bba2:	fb 01       	movw	r30, r22
    bba4:	e2 0f       	add	r30, r18
    bba6:	f3 1f       	adc	r31, r19
    bba8:	d9 01       	movw	r26, r18
    bbaa:	a5 5b       	subi	r26, 0xB5	; 181
    bbac:	b3 4f       	sbci	r27, 0xF3	; 243
    bbae:	8c 91       	ld	r24, X
    bbb0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bbb2:	2f 5f       	subi	r18, 0xFF	; 255
    bbb4:	3f 4f       	sbci	r19, 0xFF	; 255
    bbb6:	28 32       	cpi	r18, 0x28	; 40
    bbb8:	31 05       	cpc	r19, r1
    bbba:	99 f7       	brne	.-26     	; 0xbba2 <procMessage11+0x1cc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bbbc:	fe 01       	movw	r30, r28
    bbbe:	eb 5a       	subi	r30, 0xAB	; 171
    bbc0:	ff 4f       	sbci	r31, 0xFF	; 255
    bbc2:	10 82       	st	Z, r1
    bbc4:	84 ef       	ldi	r24, 0xF4	; 244
    bbc6:	92 e0       	ldi	r25, 0x02	; 2
    bbc8:	48 e2       	ldi	r20, 0x28	; 40
    bbca:	50 e0       	ldi	r21, 0x00	; 0
    bbcc:	2d ed       	ldi	r18, 0xDD	; 221
    bbce:	32 e1       	ldi	r19, 0x12	; 18
    bbd0:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    bbd4:	20 e0       	ldi	r18, 0x00	; 0
    bbd6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bbd8:	be 01       	movw	r22, r28
    bbda:	63 5d       	subi	r22, 0xD3	; 211
    bbdc:	7f 4f       	sbci	r23, 0xFF	; 255
    bbde:	fb 01       	movw	r30, r22
    bbe0:	e2 0f       	add	r30, r18
    bbe2:	f3 1f       	adc	r31, r19
    bbe4:	d9 01       	movw	r26, r18
    bbe6:	ad 58       	subi	r26, 0x8D	; 141
    bbe8:	b3 4f       	sbci	r27, 0xF3	; 243
    bbea:	8c 91       	ld	r24, X
    bbec:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bbee:	2f 5f       	subi	r18, 0xFF	; 255
    bbf0:	3f 4f       	sbci	r19, 0xFF	; 255
    bbf2:	28 32       	cpi	r18, 0x28	; 40
    bbf4:	31 05       	cpc	r19, r1
    bbf6:	99 f7       	brne	.-26     	; 0xbbde <procMessage11+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bbf8:	fe 01       	movw	r30, r28
    bbfa:	eb 5a       	subi	r30, 0xAB	; 171
    bbfc:	ff 4f       	sbci	r31, 0xFF	; 255
    bbfe:	10 82       	st	Z, r1
    bc00:	8d e1       	ldi	r24, 0x1D	; 29
    bc02:	93 e0       	ldi	r25, 0x03	; 3
    bc04:	48 e2       	ldi	r20, 0x28	; 40
    bc06:	50 e0       	ldi	r21, 0x00	; 0
    bc08:	2d ed       	ldi	r18, 0xDD	; 221
    bc0a:	32 e1       	ldi	r19, 0x12	; 18
    bc0c:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    bc10:	20 e0       	ldi	r18, 0x00	; 0
    bc12:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bc14:	be 01       	movw	r22, r28
    bc16:	63 5d       	subi	r22, 0xD3	; 211
    bc18:	7f 4f       	sbci	r23, 0xFF	; 255
    bc1a:	fb 01       	movw	r30, r22
    bc1c:	e2 0f       	add	r30, r18
    bc1e:	f3 1f       	adc	r31, r19
    bc20:	d9 01       	movw	r26, r18
    bc22:	a5 56       	subi	r26, 0x65	; 101
    bc24:	b3 4f       	sbci	r27, 0xF3	; 243
    bc26:	8c 91       	ld	r24, X
    bc28:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bc2a:	2f 5f       	subi	r18, 0xFF	; 255
    bc2c:	3f 4f       	sbci	r19, 0xFF	; 255
    bc2e:	28 32       	cpi	r18, 0x28	; 40
    bc30:	31 05       	cpc	r19, r1
    bc32:	99 f7       	brne	.-26     	; 0xbc1a <procMessage11+0x244>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bc34:	fe 01       	movw	r30, r28
    bc36:	eb 5a       	subi	r30, 0xAB	; 171
    bc38:	ff 4f       	sbci	r31, 0xFF	; 255
    bc3a:	10 82       	st	Z, r1
    bc3c:	86 e4       	ldi	r24, 0x46	; 70
    bc3e:	93 e0       	ldi	r25, 0x03	; 3
    bc40:	48 e2       	ldi	r20, 0x28	; 40
    bc42:	50 e0       	ldi	r21, 0x00	; 0
    bc44:	2d ed       	ldi	r18, 0xDD	; 221
    bc46:	32 e1       	ldi	r19, 0x12	; 18
    bc48:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    bc4c:	20 e0       	ldi	r18, 0x00	; 0
    bc4e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bc50:	be 01       	movw	r22, r28
    bc52:	63 5d       	subi	r22, 0xD3	; 211
    bc54:	7f 4f       	sbci	r23, 0xFF	; 255
    bc56:	fb 01       	movw	r30, r22
    bc58:	e2 0f       	add	r30, r18
    bc5a:	f3 1f       	adc	r31, r19
    bc5c:	d9 01       	movw	r26, r18
    bc5e:	ad 53       	subi	r26, 0x3D	; 61
    bc60:	b3 4f       	sbci	r27, 0xF3	; 243
    bc62:	8c 91       	ld	r24, X
    bc64:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bc66:	2f 5f       	subi	r18, 0xFF	; 255
    bc68:	3f 4f       	sbci	r19, 0xFF	; 255
    bc6a:	28 32       	cpi	r18, 0x28	; 40
    bc6c:	31 05       	cpc	r19, r1
    bc6e:	99 f7       	brne	.-26     	; 0xbc56 <procMessage11+0x280>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bc70:	fe 01       	movw	r30, r28
    bc72:	eb 5a       	subi	r30, 0xAB	; 171
    bc74:	ff 4f       	sbci	r31, 0xFF	; 255
    bc76:	10 82       	st	Z, r1
    bc78:	8f e6       	ldi	r24, 0x6F	; 111
    bc7a:	93 e0       	ldi	r25, 0x03	; 3
    bc7c:	48 e2       	ldi	r20, 0x28	; 40
    bc7e:	50 e0       	ldi	r21, 0x00	; 0
    bc80:	2d ed       	ldi	r18, 0xDD	; 221
    bc82:	32 e1       	ldi	r19, 0x12	; 18
    bc84:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    bc88:	20 e0       	ldi	r18, 0x00	; 0
    bc8a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bc8c:	be 01       	movw	r22, r28
    bc8e:	63 5d       	subi	r22, 0xD3	; 211
    bc90:	7f 4f       	sbci	r23, 0xFF	; 255
    bc92:	fb 01       	movw	r30, r22
    bc94:	e2 0f       	add	r30, r18
    bc96:	f3 1f       	adc	r31, r19
    bc98:	d9 01       	movw	r26, r18
    bc9a:	a5 51       	subi	r26, 0x15	; 21
    bc9c:	b3 4f       	sbci	r27, 0xF3	; 243
    bc9e:	8c 91       	ld	r24, X
    bca0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bca2:	2f 5f       	subi	r18, 0xFF	; 255
    bca4:	3f 4f       	sbci	r19, 0xFF	; 255
    bca6:	28 32       	cpi	r18, 0x28	; 40
    bca8:	31 05       	cpc	r19, r1
    bcaa:	99 f7       	brne	.-26     	; 0xbc92 <procMessage11+0x2bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bcac:	fe 01       	movw	r30, r28
    bcae:	eb 5a       	subi	r30, 0xAB	; 171
    bcb0:	ff 4f       	sbci	r31, 0xFF	; 255
    bcb2:	10 82       	st	Z, r1
    bcb4:	88 e9       	ldi	r24, 0x98	; 152
    bcb6:	93 e0       	ldi	r25, 0x03	; 3
    bcb8:	48 e2       	ldi	r20, 0x28	; 40
    bcba:	50 e0       	ldi	r21, 0x00	; 0
    bcbc:	2d ed       	ldi	r18, 0xDD	; 221
    bcbe:	32 e1       	ldi	r19, 0x12	; 18
    bcc0:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    bcc4:	0b eb       	ldi	r16, 0xBB	; 187
    bcc6:	10 e0       	ldi	r17, 0x00	; 0
    bcc8:	2b e2       	ldi	r18, 0x2B	; 43
    bcca:	e2 2e       	mov	r14, r18
    bccc:	2d e0       	ldi	r18, 0x0D	; 13
    bcce:	f2 2e       	mov	r15, r18
    bcd0:	90 e2       	ldi	r25, 0x20	; 32
    bcd2:	c9 2e       	mov	r12, r25
    bcd4:	d1 2c       	mov	r13, r1
    bcd6:	cc 0e       	add	r12, r28
    bcd8:	dd 1e       	adc	r13, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bcda:	8c e2       	ldi	r24, 0x2C	; 44
    bcdc:	a8 2e       	mov	r10, r24
    bcde:	b1 2c       	mov	r11, r1
    bce0:	ac 0e       	add	r10, r28
    bce2:	bd 1e       	adc	r11, r29
    bce4:	f6 01       	movw	r30, r12
    bce6:	d7 01       	movw	r26, r14
	    Dest[i]=Source[IdxSource+i];
    bce8:	8d 91       	ld	r24, X+
    bcea:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bcec:	ea 15       	cp	r30, r10
    bcee:	fb 05       	cpc	r31, r11
    bcf0:	d9 f7       	brne	.-10     	; 0xbce8 <procMessage11+0x312>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bcf2:	1c a6       	std	Y+44, r1	; 0x2c
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
    bcf4:	c6 01       	movw	r24, r12
    bcf6:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
    bcfa:	c8 01       	movw	r24, r16
    bcfc:	b6 01       	movw	r22, r12
    bcfe:	4c e0       	ldi	r20, 0x0C	; 12
    bd00:	50 e0       	ldi	r21, 0x00	; 0
    bd02:	2d ed       	ldi	r18, 0xDD	; 221
    bd04:	32 e1       	ldi	r19, 0x12	; 18
    bd06:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    bd0a:	03 5f       	subi	r16, 0xF3	; 243
    bd0c:	1f 4f       	sbci	r17, 0xFF	; 255
    bd0e:	8c e0       	ldi	r24, 0x0C	; 12
    bd10:	90 e0       	ldi	r25, 0x00	; 0
    bd12:	e8 0e       	add	r14, r24
    bd14:	f9 1e       	adc	r15, r25
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    bd16:	91 e0       	ldi	r25, 0x01	; 1
    bd18:	09 30       	cpi	r16, 0x09	; 9
    bd1a:	19 07       	cpc	r17, r25
    bd1c:	19 f7       	brne	.-58     	; 0xbce4 <procMessage11+0x30e>
    bd1e:	05 e8       	ldi	r16, 0x85	; 133
    bd20:	10 e0       	ldi	r17, 0x00	; 0
    bd22:	b3 e7       	ldi	r27, 0x73	; 115
    bd24:	eb 2e       	mov	r14, r27
    bd26:	bd e0       	ldi	r27, 0x0D	; 13
    bd28:	fb 2e       	mov	r15, r27
    bd2a:	6e 01       	movw	r12, r28
    bd2c:	08 94       	sec
    bd2e:	c1 1c       	adc	r12, r1
    bd30:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd32:	a9 e0       	ldi	r26, 0x09	; 9
    bd34:	aa 2e       	mov	r10, r26
    bd36:	b1 2c       	mov	r11, r1
    bd38:	ac 0e       	add	r10, r28
    bd3a:	bd 1e       	adc	r11, r29
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    bd3c:	f6 01       	movw	r30, r12
    bd3e:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bd40:	8d 91       	ld	r24, X+
    bd42:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd44:	ea 15       	cp	r30, r10
    bd46:	fb 05       	cpc	r31, r11
    bd48:	d9 f7       	brne	.-10     	; 0xbd40 <procMessage11+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bd4a:	19 86       	std	Y+9, r1	; 0x09
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
        StrPosCopy(rcv_trans,strProductPrice,(558+(i*8)),8);
		RemSpaceLag(strProductPrice);
    bd4c:	c6 01       	movw	r24, r12
    bd4e:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		RemZeroLead(strProductPrice);
    bd52:	c6 01       	movw	r24, r12
    bd54:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
		RemDecimal(strProductPrice);
    bd58:	c6 01       	movw	r24, r12
    bd5a:	0e 94 b6 22 	call	0x456c	; 0x456c <RemDecimal>
    bd5e:	c8 01       	movw	r24, r16
    bd60:	b6 01       	movw	r22, r12
    bd62:	48 e0       	ldi	r20, 0x08	; 8
    bd64:	50 e0       	ldi	r21, 0x00	; 0
    bd66:	2d ed       	ldi	r18, 0xDD	; 221
    bd68:	32 e1       	ldi	r19, 0x12	; 18
    bd6a:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
    bd6e:	07 5f       	subi	r16, 0xF7	; 247
    bd70:	1f 4f       	sbci	r17, 0xFF	; 255
    bd72:	e8 e0       	ldi	r30, 0x08	; 8
    bd74:	f0 e0       	ldi	r31, 0x00	; 0
    bd76:	ee 0e       	add	r14, r30
    bd78:	ff 1e       	adc	r15, r31
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
    bd7a:	f0 e0       	ldi	r31, 0x00	; 0
    bd7c:	0b 3b       	cpi	r16, 0xBB	; 187
    bd7e:	1f 07       	cpc	r17, r31
    bd80:	e9 f6       	brne	.-70     	; 0xbd3c <procMessage11+0x366>
		RemSpaceLag(strProductPrice);
		RemZeroLead(strProductPrice);
		RemDecimal(strProductPrice);
        eeprom_write_block((const void*) &strProductPrice, (void*) &DefProductPrice[i], 8);
	 }
}
    bd82:	cb 5a       	subi	r28, 0xAB	; 171
    bd84:	df 4f       	sbci	r29, 0xFF	; 255
    bd86:	0f b6       	in	r0, 0x3f	; 63
    bd88:	f8 94       	cli
    bd8a:	de bf       	out	0x3e, r29	; 62
    bd8c:	0f be       	out	0x3f, r0	; 63
    bd8e:	cd bf       	out	0x3d, r28	; 61
    bd90:	cf 91       	pop	r28
    bd92:	df 91       	pop	r29
    bd94:	1f 91       	pop	r17
    bd96:	0f 91       	pop	r16
    bd98:	ff 90       	pop	r15
    bd9a:	ef 90       	pop	r14
    bd9c:	df 90       	pop	r13
    bd9e:	cf 90       	pop	r12
    bda0:	bf 90       	pop	r11
    bda2:	af 90       	pop	r10
    bda4:	08 95       	ret

0000bda6 <FCloseShift>:
	 }
  return Result;
}


char FCloseShift(char ShiftType){//SHIFT_NONE,NEW_SHIFT,CONTINUE_SHIFT
    bda6:	df 92       	push	r13
    bda8:	ef 92       	push	r14
    bdaa:	ff 92       	push	r15
    bdac:	0f 93       	push	r16
    bdae:	1f 93       	push	r17
    bdb0:	df 93       	push	r29
    bdb2:	cf 93       	push	r28
    bdb4:	cd b7       	in	r28, 0x3d	; 61
    bdb6:	de b7       	in	r29, 0x3e	; 62
    bdb8:	64 97       	sbiw	r28, 0x14	; 20
    bdba:	0f b6       	in	r0, 0x3f	; 63
    bdbc:	f8 94       	cli
    bdbe:	de bf       	out	0x3e, r29	; 62
    bdc0:	0f be       	out	0x3f, r0	; 63
    bdc2:	cd bf       	out	0x3d, r28	; 61
    bdc4:	18 2f       	mov	r17, r24
	 char KeyPressed;
	 char FIPAddr;


	 Result=MENU_NONE;
	 switch(stCloseShift){
    bdc6:	80 91 20 03 	lds	r24, 0x0320
    bdca:	87 30       	cpi	r24, 0x07	; 7
    bdcc:	09 f4       	brne	.+2      	; 0xbdd0 <FCloseShift+0x2a>
    bdce:	a6 c1       	rjmp	.+844    	; 0xc11c <FCloseShift+0x376>
    bdd0:	88 30       	cpi	r24, 0x08	; 8
    bdd2:	78 f4       	brcc	.+30     	; 0xbdf2 <FCloseShift+0x4c>
    bdd4:	84 30       	cpi	r24, 0x04	; 4
    bdd6:	09 f4       	brne	.+2      	; 0xbdda <FCloseShift+0x34>
    bdd8:	68 c0       	rjmp	.+208    	; 0xbeaa <FCloseShift+0x104>
    bdda:	85 30       	cpi	r24, 0x05	; 5
    bddc:	18 f4       	brcc	.+6      	; 0xbde4 <FCloseShift+0x3e>
    bdde:	88 23       	and	r24, r24
    bde0:	c1 f0       	breq	.+48     	; 0xbe12 <FCloseShift+0x6c>
    bde2:	22 c2       	rjmp	.+1092   	; 0xc228 <FCloseShift+0x482>
    bde4:	85 30       	cpi	r24, 0x05	; 5
    bde6:	09 f4       	brne	.+2      	; 0xbdea <FCloseShift+0x44>
    bde8:	a6 c0       	rjmp	.+332    	; 0xbf36 <FCloseShift+0x190>
    bdea:	86 30       	cpi	r24, 0x06	; 6
    bdec:	09 f0       	breq	.+2      	; 0xbdf0 <FCloseShift+0x4a>
    bdee:	1c c2       	rjmp	.+1080   	; 0xc228 <FCloseShift+0x482>
    bdf0:	a8 c0       	rjmp	.+336    	; 0xbf42 <FCloseShift+0x19c>
    bdf2:	8a 30       	cpi	r24, 0x0A	; 10
    bdf4:	09 f4       	brne	.+2      	; 0xbdf8 <FCloseShift+0x52>
    bdf6:	d6 c1       	rjmp	.+940    	; 0xc1a4 <FCloseShift+0x3fe>
    bdf8:	8b 30       	cpi	r24, 0x0B	; 11
    bdfa:	20 f4       	brcc	.+8      	; 0xbe04 <FCloseShift+0x5e>
    bdfc:	88 30       	cpi	r24, 0x08	; 8
    bdfe:	09 f0       	breq	.+2      	; 0xbe02 <FCloseShift+0x5c>
    be00:	13 c2       	rjmp	.+1062   	; 0xc228 <FCloseShift+0x482>
    be02:	92 c1       	rjmp	.+804    	; 0xc128 <FCloseShift+0x382>
    be04:	8b 30       	cpi	r24, 0x0B	; 11
    be06:	09 f4       	brne	.+2      	; 0xbe0a <FCloseShift+0x64>
    be08:	0b c2       	rjmp	.+1046   	; 0xc220 <FCloseShift+0x47a>
    be0a:	8c 30       	cpi	r24, 0x0C	; 12
    be0c:	09 f0       	breq	.+2      	; 0xbe10 <FCloseShift+0x6a>
    be0e:	0c c2       	rjmp	.+1048   	; 0xc228 <FCloseShift+0x482>
    be10:	d2 c1       	rjmp	.+932    	; 0xc1b6 <FCloseShift+0x410>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    be12:	e1 99       	sbic	0x1c, 1	; 28
    be14:	fe cf       	rjmp	.-4      	; 0xbe12 <FCloseShift+0x6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    be16:	89 e4       	ldi	r24, 0x49	; 73
    be18:	91 e0       	ldi	r25, 0x01	; 1
    be1a:	9f bb       	out	0x1f, r25	; 31
    be1c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    be1e:	e0 9a       	sbi	0x1c, 0	; 28
    be20:	8d b3       	in	r24, 0x1d	; 29
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
    be22:	80 93 60 01 	sts	0x0160, r24
		  IsPumpBusy=False;
    be26:	10 92 1f 03 	sts	0x031F, r1
    be2a:	ff 24       	eor	r15, r15
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
    be2c:	dd 24       	eor	r13, r13
    be2e:	d3 94       	inc	r13
    be30:	36 c0       	rjmp	.+108    	; 0xbe9e <FCloseShift+0xf8>
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
		       if ((strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_NONE))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_OFF))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_BUSY)))
    be32:	0f 2d       	mov	r16, r15
    be34:	10 e0       	ldi	r17, 0x00	; 0
    be36:	f8 01       	movw	r30, r16
    be38:	ee 5e       	subi	r30, 0xEE	; 238
    be3a:	fe 4f       	sbci	r31, 0xFE	; 254
    be3c:	e0 80       	ld	r14, Z
    be3e:	8e e0       	ldi	r24, 0x0E	; 14
    be40:	0e 94 72 13 	call	0x26e4	; 0x26e4 <GetPumpStatusLabel>
    be44:	e8 16       	cp	r14, r24
    be46:	81 f0       	breq	.+32     	; 0xbe68 <FCloseShift+0xc2>
    be48:	86 e0       	ldi	r24, 0x06	; 6
    be4a:	0e 94 72 13 	call	0x26e4	; 0x26e4 <GetPumpStatusLabel>
    be4e:	e8 16       	cp	r14, r24
    be50:	59 f0       	breq	.+22     	; 0xbe68 <FCloseShift+0xc2>
    be52:	89 e0       	ldi	r24, 0x09	; 9
    be54:	0e 94 72 13 	call	0x26e4	; 0x26e4 <GetPumpStatusLabel>
    be58:	e8 16       	cp	r14, r24
    be5a:	31 f0       	breq	.+12     	; 0xbe68 <FCloseShift+0xc2>
				    UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    be5c:	8f 2d       	mov	r24, r15
    be5e:	0e 94 af 1c 	call	0x395e	; 0x395e <GetPumpID>
    be62:	66 e0       	ldi	r22, 0x06	; 6
    be64:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <UpdateStandaloneStatus>
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    be68:	84 e1       	ldi	r24, 0x14	; 20
    be6a:	0e 94 72 13 	call	0x26e4	; 0x26e4 <GetPumpStatusLabel>
    be6e:	f8 01       	movw	r30, r16
    be70:	ee 5e       	subi	r30, 0xEE	; 238
    be72:	fe 4f       	sbci	r31, 0xFE	; 254
    be74:	90 81       	ld	r25, Z
    be76:	98 17       	cp	r25, r24
    be78:	31 f4       	brne	.+12     	; 0xbe86 <FCloseShift+0xe0>
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    be7a:	8f 2d       	mov	r24, r15
    be7c:	0e 94 af 1c 	call	0x395e	; 0x395e <GetPumpID>
    be80:	66 e0       	ldi	r22, 0x06	; 6
    be82:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <UpdateStandaloneStatus>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
    be86:	89 e0       	ldi	r24, 0x09	; 9
    be88:	0e 94 72 13 	call	0x26e4	; 0x26e4 <GetPumpStatusLabel>
    be8c:	0e 5e       	subi	r16, 0xEE	; 238
    be8e:	1e 4f       	sbci	r17, 0xFE	; 254
    be90:	d8 01       	movw	r26, r16
    be92:	9c 91       	ld	r25, X
    be94:	98 17       	cp	r25, r24
    be96:	11 f4       	brne	.+4      	; 0xbe9c <FCloseShift+0xf6>
			       IsPumpBusy=True;
    be98:	d0 92 1f 03 	sts	0x031F, r13
	 switch(stCloseShift){
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
    be9c:	f3 94       	inc	r15
    be9e:	80 91 60 01 	lds	r24, 0x0160
    bea2:	f8 16       	cp	r15, r24
    bea4:	30 f2       	brcs	.-116    	; 0xbe32 <FCloseShift+0x8c>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
			   }

          stCloseShift=csSendTotalizerALL;
    bea6:	84 e0       	ldi	r24, 0x04	; 4
    bea8:	b8 c1       	rjmp	.+880    	; 0xc21a <FCloseShift+0x474>
			  */
	      break;
     case csWaitPumpLocked:	     
	      break;
     case csSendTotalizerALL:
	      lcd_clear();
    beaa:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("Totalizer.."));
    beae:	81 e0       	ldi	r24, 0x01	; 1
    beb0:	61 e0       	ldi	r22, 0x01	; 1
    beb2:	4c e5       	ldi	r20, 0x5C	; 92
    beb4:	55 e1       	ldi	r21, 0x15	; 21
    beb6:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  
		  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    beba:	00 91 60 01 	lds	r16, 0x0160
    bebe:	10 e0       	ldi	r17, 0x00	; 0
    bec0:	82 e1       	ldi	r24, 0x12	; 18
    bec2:	91 e0       	ldi	r25, 0x01	; 1
    bec4:	0e 94 6d 2d 	call	0x5ada	; 0x5ada <CountTotalizerSatus>
    bec8:	00 d0       	rcall	.+0      	; 0xbeca <FCloseShift+0x124>
    beca:	00 d0       	rcall	.+0      	; 0xbecc <FCloseShift+0x126>
    becc:	00 d0       	rcall	.+0      	; 0xbece <FCloseShift+0x128>
    bece:	ed b7       	in	r30, 0x3d	; 61
    bed0:	fe b7       	in	r31, 0x3e	; 62
    bed2:	31 96       	adiw	r30, 0x01	; 1
    bed4:	7e 01       	movw	r14, r28
    bed6:	08 94       	sec
    bed8:	e1 1c       	adc	r14, r1
    beda:	f1 1c       	adc	r15, r1
    bedc:	ad b7       	in	r26, 0x3d	; 61
    bede:	be b7       	in	r27, 0x3e	; 62
    bee0:	12 96       	adiw	r26, 0x02	; 2
    bee2:	fc 92       	st	X, r15
    bee4:	ee 92       	st	-X, r14
    bee6:	11 97       	sbiw	r26, 0x01	; 1
    bee8:	2e e4       	ldi	r18, 0x4E	; 78
    beea:	35 e1       	ldi	r19, 0x15	; 21
    beec:	33 83       	std	Z+3, r19	; 0x03
    beee:	22 83       	std	Z+2, r18	; 0x02
    bef0:	08 1b       	sub	r16, r24
    bef2:	11 09       	sbc	r17, r1
    bef4:	15 83       	std	Z+5, r17	; 0x05
    bef6:	04 83       	std	Z+4, r16	; 0x04
    bef8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(2,1,lcdteks);
    befc:	ed b7       	in	r30, 0x3d	; 61
    befe:	fe b7       	in	r31, 0x3e	; 62
    bf00:	36 96       	adiw	r30, 0x06	; 6
    bf02:	0f b6       	in	r0, 0x3f	; 63
    bf04:	f8 94       	cli
    bf06:	fe bf       	out	0x3e, r31	; 62
    bf08:	0f be       	out	0x3f, r0	; 63
    bf0a:	ed bf       	out	0x3d, r30	; 61
    bf0c:	82 e0       	ldi	r24, 0x02	; 2
    bf0e:	61 e0       	ldi	r22, 0x01	; 1
    bf10:	a7 01       	movw	r20, r14
    bf12:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>


          IsNewPumpStatus=True;
    bf16:	11 e0       	ldi	r17, 0x01	; 1
    bf18:	10 93 11 01 	sts	0x0111, r17
		  DisplayPumpStatus(); 
    bf1c:	0e 94 4f 41 	call	0x829e	; 0x829e <DisplayPumpStatus>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    bf20:	95 e0       	ldi	r25, 0x05	; 5
    bf22:	90 93 da 07 	sts	0x07DA, r25
	 PoolMsg=plMsg;
    bf26:	82 e1       	ldi	r24, 0x12	; 18
    bf28:	80 93 fe 0d 	sts	0x0DFE, r24
     IsControlPooling=True;
    bf2c:	10 93 97 01 	sts	0x0197, r17
          IsNewPumpStatus=True;
		  DisplayPumpStatus(); 
		  //SendCommand
	      //SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);          
		  SendPoolingCommand(SC_TOTALIZER,PUMP_ALL);
		  stCloseShift=csDisplayPumpStatus;
    bf30:	90 93 20 03 	sts	0x0320, r25
    bf34:	79 c1       	rjmp	.+754    	; 0xc228 <FCloseShift+0x482>
	      break;
     case csDisplayPumpStatus:
		  DisplayPumpStatus(); 
    bf36:	0e 94 4f 41 	call	0x829e	; 0x829e <DisplayPumpStatus>
		  TimDisplay=0;         
    bf3a:	10 92 a7 01 	sts	0x01A7, r1
          stCloseShift=csWaitTotalizerComplete;
    bf3e:	86 e0       	ldi	r24, 0x06	; 6
    bf40:	6c c1       	rjmp	.+728    	; 0xc21a <FCloseShift+0x474>
	      break;
     case csWaitTotalizerComplete:
	      KeyPressed=_key_scan(1);
    bf42:	81 e0       	ldi	r24, 0x01	; 1
    bf44:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    bf48:	d8 2e       	mov	r13, r24
		  if (IsNewPumpStatus==True){
    bf4a:	80 91 11 01 	lds	r24, 0x0111
    bf4e:	81 30       	cpi	r24, 0x01	; 1
    bf50:	89 f5       	brne	.+98     	; 0xbfb4 <FCloseShift+0x20e>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    bf52:	00 91 60 01 	lds	r16, 0x0160
    bf56:	10 e0       	ldi	r17, 0x00	; 0
    bf58:	82 e1       	ldi	r24, 0x12	; 18
    bf5a:	91 e0       	ldi	r25, 0x01	; 1
    bf5c:	0e 94 6d 2d 	call	0x5ada	; 0x5ada <CountTotalizerSatus>
    bf60:	00 d0       	rcall	.+0      	; 0xbf62 <FCloseShift+0x1bc>
    bf62:	00 d0       	rcall	.+0      	; 0xbf64 <FCloseShift+0x1be>
    bf64:	00 d0       	rcall	.+0      	; 0xbf66 <FCloseShift+0x1c0>
    bf66:	ed b7       	in	r30, 0x3d	; 61
    bf68:	fe b7       	in	r31, 0x3e	; 62
    bf6a:	31 96       	adiw	r30, 0x01	; 1
    bf6c:	7e 01       	movw	r14, r28
    bf6e:	08 94       	sec
    bf70:	e1 1c       	adc	r14, r1
    bf72:	f1 1c       	adc	r15, r1
    bf74:	ad b7       	in	r26, 0x3d	; 61
    bf76:	be b7       	in	r27, 0x3e	; 62
    bf78:	12 96       	adiw	r26, 0x02	; 2
    bf7a:	fc 92       	st	X, r15
    bf7c:	ee 92       	st	-X, r14
    bf7e:	11 97       	sbiw	r26, 0x01	; 1
    bf80:	20 e4       	ldi	r18, 0x40	; 64
    bf82:	35 e1       	ldi	r19, 0x15	; 21
    bf84:	33 83       	std	Z+3, r19	; 0x03
    bf86:	22 83       	std	Z+2, r18	; 0x02
    bf88:	08 1b       	sub	r16, r24
    bf8a:	11 09       	sbc	r17, r1
    bf8c:	15 83       	std	Z+5, r17	; 0x05
    bf8e:	04 83       	std	Z+4, r16	; 0x04
    bf90:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			  lcd_print(2,1,lcdteks);
    bf94:	ed b7       	in	r30, 0x3d	; 61
    bf96:	fe b7       	in	r31, 0x3e	; 62
    bf98:	36 96       	adiw	r30, 0x06	; 6
    bf9a:	0f b6       	in	r0, 0x3f	; 63
    bf9c:	f8 94       	cli
    bf9e:	fe bf       	out	0x3e, r31	; 62
    bfa0:	0f be       	out	0x3f, r0	; 63
    bfa2:	ed bf       	out	0x3d, r30	; 61
    bfa4:	82 e0       	ldi	r24, 0x02	; 2
    bfa6:	61 e0       	ldi	r22, 0x01	; 1
    bfa8:	a7 01       	movw	r20, r14
    bfaa:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  	  stCloseShift=csDisplayPumpStatus;	 
    bfae:	85 e0       	ldi	r24, 0x05	; 5
    bfb0:	80 93 20 03 	sts	0x0320, r24
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
    bfb4:	82 e1       	ldi	r24, 0x12	; 18
    bfb6:	91 e0       	ldi	r25, 0x01	; 1
    bfb8:	0e 94 6d 2d 	call	0x5ada	; 0x5ada <CountTotalizerSatus>
    bfbc:	90 91 60 01 	lds	r25, 0x0160
    bfc0:	89 17       	cp	r24, r25
    bfc2:	a0 f0       	brcs	.+40     	; 0xbfec <FCloseShift+0x246>
    bfc4:	80 91 a7 01 	lds	r24, 0x01A7
    bfc8:	86 30       	cpi	r24, 0x06	; 6
    bfca:	80 f0       	brcs	.+32     	; 0xbfec <FCloseShift+0x246>
    bfcc:	10 e0       	ldi	r17, 0x00	; 0
    bfce:	07 c0       	rjmp	.+14     	; 0xbfde <FCloseShift+0x238>
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    bfd0:	81 2f       	mov	r24, r17
    bfd2:	0e 94 af 1c 	call	0x395e	; 0x395e <GetPumpID>
    bfd6:	66 e0       	ldi	r22, 0x06	; 6
    bfd8:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <UpdateStandaloneStatus>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
			  lcd_print(2,1,lcdteks);
		  	  stCloseShift=csDisplayPumpStatus;	 
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
    bfdc:	1f 5f       	subi	r17, 0xFF	; 255
    bfde:	80 91 60 01 	lds	r24, 0x0160
    bfe2:	18 17       	cp	r17, r24
    bfe4:	a8 f3       	brcs	.-22     	; 0xbfd0 <FCloseShift+0x22a>
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);

		      stCloseShift=csGenerateReport;		      
    bfe6:	88 e0       	ldi	r24, 0x08	; 8
    bfe8:	80 93 20 03 	sts	0x0320, r24
			  }
          //sprintf_P(lcdteks,PSTR("TimSend:%d"),TimDisplay);
		  //lcd_print(3,1,lcdteks);

          if ((TimDisplay>15)&&(IsPumpBusy!=True)){
    bfec:	80 91 a7 01 	lds	r24, 0x01A7
    bff0:	80 31       	cpi	r24, 0x10	; 16
    bff2:	08 f4       	brcc	.+2      	; 0xbff6 <FCloseShift+0x250>
    bff4:	67 c0       	rjmp	.+206    	; 0xc0c4 <FCloseShift+0x31e>
    bff6:	80 91 1f 03 	lds	r24, 0x031F
    bffa:	81 30       	cpi	r24, 0x01	; 1
    bffc:	09 f4       	brne	.+2      	; 0xc000 <FCloseShift+0x25a>
    bffe:	62 c0       	rjmp	.+196    	; 0xc0c4 <FCloseShift+0x31e>
		      if(CountNoPumpSatus(strPumpStatus)>=eeprom_read_byte(&DefActivePump)){
    c000:	82 e1       	ldi	r24, 0x12	; 18
    c002:	91 e0       	ldi	r25, 0x01	; 1
    c004:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <CountNoPumpSatus>
    c008:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c00a:	e1 99       	sbic	0x1c, 1	; 28
    c00c:	fe cf       	rjmp	.-4      	; 0xc00a <FCloseShift+0x264>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c00e:	89 e4       	ldi	r24, 0x49	; 73
    c010:	91 e0       	ldi	r25, 0x01	; 1
    c012:	9f bb       	out	0x1f, r25	; 31
    c014:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c016:	e0 9a       	sbi	0x1c, 0	; 28
    c018:	8d b3       	in	r24, 0x1d	; 29
    c01a:	28 17       	cp	r18, r24
    c01c:	08 f4       	brcc	.+2      	; 0xc020 <FCloseShift+0x27a>
    c01e:	52 c0       	rjmp	.+164    	; 0xc0c4 <FCloseShift+0x31e>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
    c020:	00 91 60 01 	lds	r16, 0x0160
    c024:	10 e0       	ldi	r17, 0x00	; 0
    c026:	82 e1       	ldi	r24, 0x12	; 18
    c028:	91 e0       	ldi	r25, 0x01	; 1
    c02a:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <CountNoPumpSatus>
    c02e:	00 d0       	rcall	.+0      	; 0xc030 <FCloseShift+0x28a>
    c030:	00 d0       	rcall	.+0      	; 0xc032 <FCloseShift+0x28c>
    c032:	00 d0       	rcall	.+0      	; 0xc034 <FCloseShift+0x28e>
    c034:	ed b7       	in	r30, 0x3d	; 61
    c036:	fe b7       	in	r31, 0x3e	; 62
    c038:	31 96       	adiw	r30, 0x01	; 1
    c03a:	7e 01       	movw	r14, r28
    c03c:	08 94       	sec
    c03e:	e1 1c       	adc	r14, r1
    c040:	f1 1c       	adc	r15, r1
    c042:	ad b7       	in	r26, 0x3d	; 61
    c044:	be b7       	in	r27, 0x3e	; 62
    c046:	12 96       	adiw	r26, 0x02	; 2
    c048:	fc 92       	st	X, r15
    c04a:	ee 92       	st	-X, r14
    c04c:	11 97       	sbiw	r26, 0x01	; 1
    c04e:	2c e2       	ldi	r18, 0x2C	; 44
    c050:	35 e1       	ldi	r19, 0x15	; 21
    c052:	33 83       	std	Z+3, r19	; 0x03
    c054:	22 83       	std	Z+2, r18	; 0x02
    c056:	08 1b       	sub	r16, r24
    c058:	11 09       	sbc	r17, r1
    c05a:	15 83       	std	Z+5, r17	; 0x05
    c05c:	04 83       	std	Z+4, r16	; 0x04
    c05e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    c062:	ed b7       	in	r30, 0x3d	; 61
    c064:	fe b7       	in	r31, 0x3e	; 62
    c066:	36 96       	adiw	r30, 0x06	; 6
    c068:	0f b6       	in	r0, 0x3f	; 63
    c06a:	f8 94       	cli
    c06c:	fe bf       	out	0x3e, r31	; 62
    c06e:	0f be       	out	0x3f, r0	; 63
    c070:	ed bf       	out	0x3d, r30	; 61
    c072:	83 e0       	ldi	r24, 0x03	; 3
    c074:	61 e0       	ldi	r22, 0x01	; 1
    c076:	a7 01       	movw	r20, r14
    c078:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    c07c:	10 e0       	ldi	r17, 0x00	; 0
    c07e:	11 c0       	rjmp	.+34     	; 0xc0a2 <FCloseShift+0x2fc>
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    c080:	84 e1       	ldi	r24, 0x14	; 20
    c082:	0e 94 72 13 	call	0x26e4	; 0x26e4 <GetPumpStatusLabel>
    c086:	e1 2f       	mov	r30, r17
    c088:	f0 e0       	ldi	r31, 0x00	; 0
    c08a:	ee 5e       	subi	r30, 0xEE	; 238
    c08c:	fe 4f       	sbci	r31, 0xFE	; 254
    c08e:	90 81       	ld	r25, Z
    c090:	98 17       	cp	r25, r24
    c092:	31 f4       	brne	.+12     	; 0xc0a0 <FCloseShift+0x2fa>
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c094:	81 2f       	mov	r24, r17
    c096:	0e 94 af 1c 	call	0x395e	; 0x395e <GetPumpID>
    c09a:	66 e0       	ldi	r22, 0x06	; 6
    c09c:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <UpdateStandaloneStatus>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
			  lcd_print(3,1,lcdteks);
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
    c0a0:	1f 5f       	subi	r17, 0xFF	; 255
    c0a2:	80 91 60 01 	lds	r24, 0x0160
    c0a6:	18 17       	cp	r17, r24
    c0a8:	58 f3       	brcs	.-42     	; 0xc080 <FCloseShift+0x2da>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c0aa:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c0ac:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c0ae:	81 e0       	ldi	r24, 0x01	; 1
    c0b0:	90 e0       	ldi	r25, 0x00	; 0
    c0b2:	90 93 d7 01 	sts	0x01D7, r25
    c0b6:	80 93 d6 01 	sts	0x01D6, r24
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
			  }

			  system_beep(1);
			  TimDisplay=0;
    c0ba:	10 92 a7 01 	sts	0x01A7, r1
			  stCloseShift=csNoPumpFound;		     
    c0be:	87 e0       	ldi	r24, 0x07	; 7
    c0c0:	80 93 20 03 	sts	0x0320, r24
			  }			  
		  }
		  if (KeyPressed==_KEY_CANCEL){
    c0c4:	f7 ee       	ldi	r31, 0xE7	; 231
    c0c6:	df 16       	cp	r13, r31
    c0c8:	09 f0       	breq	.+2      	; 0xc0cc <FCloseShift+0x326>
    c0ca:	ae c0       	rjmp	.+348    	; 0xc228 <FCloseShift+0x482>
			  sprintf_P(lcdteks,PSTR("Cancel"));
    c0cc:	00 d0       	rcall	.+0      	; 0xc0ce <FCloseShift+0x328>
    c0ce:	00 d0       	rcall	.+0      	; 0xc0d0 <FCloseShift+0x32a>
    c0d0:	8e 01       	movw	r16, r28
    c0d2:	0f 5f       	subi	r16, 0xFF	; 255
    c0d4:	1f 4f       	sbci	r17, 0xFF	; 255
    c0d6:	ad b7       	in	r26, 0x3d	; 61
    c0d8:	be b7       	in	r27, 0x3e	; 62
    c0da:	12 96       	adiw	r26, 0x02	; 2
    c0dc:	1c 93       	st	X, r17
    c0de:	0e 93       	st	-X, r16
    c0e0:	11 97       	sbiw	r26, 0x01	; 1
    c0e2:	85 e2       	ldi	r24, 0x25	; 37
    c0e4:	95 e1       	ldi	r25, 0x15	; 21
    c0e6:	14 96       	adiw	r26, 0x04	; 4
    c0e8:	9c 93       	st	X, r25
    c0ea:	8e 93       	st	-X, r24
    c0ec:	13 97       	sbiw	r26, 0x03	; 3
    c0ee:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    c0f2:	0f 90       	pop	r0
    c0f4:	0f 90       	pop	r0
    c0f6:	0f 90       	pop	r0
    c0f8:	0f 90       	pop	r0
    c0fa:	83 e0       	ldi	r24, 0x03	; 3
    c0fc:	61 e0       	ldi	r22, 0x01	; 1
    c0fe:	a8 01       	movw	r20, r16
    c100:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c104:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c106:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c108:	81 e0       	ldi	r24, 0x01	; 1
    c10a:	90 e0       	ldi	r25, 0x00	; 0
    c10c:	90 93 d7 01 	sts	0x01D7, r25
    c110:	80 93 d6 01 	sts	0x01D6, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
			  sprintf_P(lcdteks,PSTR("Cancel"));
			  lcd_print(3,1,lcdteks);
			  system_beep(1);
			  TimDisplay=0;
    c114:	10 92 a7 01 	sts	0x01A7, r1
			  stCloseShift=csNoPumpFound;		     		  
    c118:	87 e0       	ldi	r24, 0x07	; 7
    c11a:	7f c0       	rjmp	.+254    	; 0xc21a <FCloseShift+0x474>
		  }
	      break;
     case csNoPumpFound:
	      if (TimDisplay>TIM_DISPLAY){
    c11c:	80 91 a7 01 	lds	r24, 0x01A7
    c120:	8b 30       	cpi	r24, 0x0B	; 11
    c122:	08 f4       	brcc	.+2      	; 0xc126 <FCloseShift+0x380>
    c124:	81 c0       	rjmp	.+258    	; 0xc228 <FCloseShift+0x482>
    c126:	78 c0       	rjmp	.+240    	; 0xc218 <FCloseShift+0x472>
		      stCloseShift=csFinishCloseShift;
		  }	      
	      break;
     case csGenerateReport:
		  lcd_printf(1,1,PSTR("Printing Totalizer"));
    c128:	81 e0       	ldi	r24, 0x01	; 1
    c12a:	61 e0       	ldi	r22, 0x01	; 1
    c12c:	42 e1       	ldi	r20, 0x12	; 18
    c12e:	55 e1       	ldi	r21, 0x15	; 21
    c130:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          _datetime(0, strSystemDate, strSystemTime);
    c134:	0a ee       	ldi	r16, 0xEA	; 234
    c136:	15 e0       	ldi	r17, 0x05	; 5
    c138:	39 ec       	ldi	r19, 0xC9	; 201
    c13a:	e3 2e       	mov	r14, r19
    c13c:	3a e0       	ldi	r19, 0x0A	; 10
    c13e:	f3 2e       	mov	r15, r19
    c140:	80 e0       	ldi	r24, 0x00	; 0
    c142:	b8 01       	movw	r22, r16
    c144:	a7 01       	movw	r20, r14
    c146:	0e 94 4b b1 	call	0x16296	; 0x16296 <_datetime>
		  sprintf_P(CurrentShiftDateTime,PSTR("%s %s"),strSystemDate,strSystemTime);
    c14a:	ed b7       	in	r30, 0x3d	; 61
    c14c:	fe b7       	in	r31, 0x3e	; 62
    c14e:	38 97       	sbiw	r30, 0x08	; 8
    c150:	0f b6       	in	r0, 0x3f	; 63
    c152:	f8 94       	cli
    c154:	fe bf       	out	0x3e, r31	; 62
    c156:	0f be       	out	0x3f, r0	; 63
    c158:	ed bf       	out	0x3d, r30	; 61
    c15a:	31 96       	adiw	r30, 0x01	; 1
    c15c:	81 ec       	ldi	r24, 0xC1	; 193
    c15e:	99 e0       	ldi	r25, 0x09	; 9
    c160:	ad b7       	in	r26, 0x3d	; 61
    c162:	be b7       	in	r27, 0x3e	; 62
    c164:	12 96       	adiw	r26, 0x02	; 2
    c166:	9c 93       	st	X, r25
    c168:	8e 93       	st	-X, r24
    c16a:	11 97       	sbiw	r26, 0x01	; 1
    c16c:	8c e0       	ldi	r24, 0x0C	; 12
    c16e:	95 e1       	ldi	r25, 0x15	; 21
    c170:	93 83       	std	Z+3, r25	; 0x03
    c172:	82 83       	std	Z+2, r24	; 0x02
    c174:	15 83       	std	Z+5, r17	; 0x05
    c176:	04 83       	std	Z+4, r16	; 0x04
    c178:	f7 82       	std	Z+7, r15	; 0x07
    c17a:	e6 82       	std	Z+6, r14	; 0x06
    c17c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  IsGenerateReport=True;
    c180:	81 e0       	ldi	r24, 0x01	; 1
    c182:	80 93 99 01 	sts	0x0199, r24
		  IsFinishPrintingTotalizer=False;
    c186:	10 92 9a 01 	sts	0x019A, r1
		  stCloseShift=csWaitPrintTotalizerComplete;
    c18a:	8a e0       	ldi	r24, 0x0A	; 10
    c18c:	80 93 20 03 	sts	0x0320, r24
    c190:	80 e0       	ldi	r24, 0x00	; 0
    c192:	ed b7       	in	r30, 0x3d	; 61
    c194:	fe b7       	in	r31, 0x3e	; 62
    c196:	38 96       	adiw	r30, 0x08	; 8
    c198:	0f b6       	in	r0, 0x3f	; 63
    c19a:	f8 94       	cli
    c19c:	fe bf       	out	0x3e, r31	; 62
    c19e:	0f be       	out	0x3f, r0	; 63
    c1a0:	ed bf       	out	0x3d, r30	; 61
    c1a2:	43 c0       	rjmp	.+134    	; 0xc22a <FCloseShift+0x484>
	      break;
     case csWaitTotalizerALL:
	      break;
     case csWaitPrintTotalizerComplete:
	      if (IsFinishPrintingTotalizer==True){
    c1a4:	80 91 9a 01 	lds	r24, 0x019A
    c1a8:	81 30       	cpi	r24, 0x01	; 1
    c1aa:	09 f0       	breq	.+2      	; 0xc1ae <FCloseShift+0x408>
    c1ac:	3d c0       	rjmp	.+122    	; 0xc228 <FCloseShift+0x482>
		      IsFinishPrintingTotalizer=False;
    c1ae:	10 92 9a 01 	sts	0x019A, r1
		      stCloseShift=csDumpShift;
    c1b2:	8c e0       	ldi	r24, 0x0C	; 12
    c1b4:	32 c0       	rjmp	.+100    	; 0xc21a <FCloseShift+0x474>
		  }
	      break;
     case csDumpShift://Increment CurrentShift save Current to Last
		  lcd_printf(1,1,PSTR("Saving ShiftData.. "));
    c1b6:	81 e0       	ldi	r24, 0x01	; 1
    c1b8:	61 e0       	ldi	r22, 0x01	; 1
    c1ba:	48 ef       	ldi	r20, 0xF8	; 248
    c1bc:	54 e1       	ldi	r21, 0x14	; 20
    c1be:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	      if (ShiftType==CONTINUE_SHIFT)//Shift=Shift+1
    c1c2:	12 30       	cpi	r17, 0x02	; 2
    c1c4:	71 f4       	brne	.+28     	; 0xc1e2 <FCloseShift+0x43c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c1c6:	e1 99       	sbic	0x1c, 1	; 28
    c1c8:	fe cf       	rjmp	.-4      	; 0xc1c6 <FCloseShift+0x420>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c1ca:	2f e3       	ldi	r18, 0x3F	; 63
    c1cc:	31 e0       	ldi	r19, 0x01	; 1
    c1ce:	3f bb       	out	0x1f, r19	; 31
    c1d0:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c1d2:	e0 9a       	sbi	0x1c, 0	; 28
    c1d4:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c1d6:	e1 99       	sbic	0x1c, 1	; 28
    c1d8:	fe cf       	rjmp	.-4      	; 0xc1d6 <FCloseShift+0x430>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c1da:	3f bb       	out	0x1f, r19	; 31
    c1dc:	2e bb       	out	0x1e, r18	; 30
		      eeprom_write_byte(&DefShift,eeprom_read_byte(&DefShift)+1);	 
    c1de:	8f 5f       	subi	r24, 0xFF	; 255
    c1e0:	09 c0       	rjmp	.+18     	; 0xc1f4 <FCloseShift+0x44e>
          else if (ShiftType==NEW_SHIFT)//Shift=1
    c1e2:	11 30       	cpi	r17, 0x01	; 1
    c1e4:	69 f4       	brne	.+26     	; 0xc200 <FCloseShift+0x45a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c1e6:	e1 99       	sbic	0x1c, 1	; 28
    c1e8:	fe cf       	rjmp	.-4      	; 0xc1e6 <FCloseShift+0x440>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c1ea:	8f e3       	ldi	r24, 0x3F	; 63
    c1ec:	91 e0       	ldi	r25, 0x01	; 1
    c1ee:	9f bb       	out	0x1f, r25	; 31
    c1f0:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    c1f2:	81 e0       	ldi	r24, 0x01	; 1
    c1f4:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    c1f6:	0f b6       	in	r0, 0x3f	; 63
    c1f8:	f8 94       	cli
    c1fa:	e2 9a       	sbi	0x1c, 2	; 28
    c1fc:	e1 9a       	sbi	0x1c, 1	; 28
    c1fe:	0f be       	out	0x3f, r0	; 63
		      eeprom_write_byte(&DefShift,1);	 

          SaveTotalizerCurrentToLast();
    c200:	0e 94 64 45 	call	0x8ac8	; 0x8ac8 <SaveTotalizerCurrentToLast>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    c204:	83 e4       	ldi	r24, 0x43	; 67
    c206:	98 e0       	ldi	r25, 0x08	; 8
    c208:	61 ec       	ldi	r22, 0xC1	; 193
    c20a:	79 e0       	ldi	r23, 0x09	; 9
    c20c:	44 e1       	ldi	r20, 0x14	; 20
    c20e:	50 e0       	ldi	r21, 0x00	; 0
    c210:	2d ed       	ldi	r18, 0xDD	; 221
    c212:	32 e1       	ldi	r19, 0x12	; 18
    c214:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
          eeprom_write_block((const void*) &CurrentShiftDateTime, (void*) &DefLastShiftDateTime,sizeof(DefLastShiftDateTime));
		  stCloseShift=csFinishCloseShift;
    c218:	8b e0       	ldi	r24, 0x0B	; 11
    c21a:	80 93 20 03 	sts	0x0320, r24
    c21e:	04 c0       	rjmp	.+8      	; 0xc228 <FCloseShift+0x482>
	      break;
     case csFinishCloseShift:
          stCloseShift=csInitCloseShift;
    c220:	10 92 20 03 	sts	0x0320, r1
    c224:	81 e0       	ldi	r24, 0x01	; 1
    c226:	01 c0       	rjmp	.+2      	; 0xc22a <FCloseShift+0x484>
    c228:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 //_uart_printf(0,1,PSTR("Close Shift"));	
   return Result;
}
    c22a:	64 96       	adiw	r28, 0x14	; 20
    c22c:	0f b6       	in	r0, 0x3f	; 63
    c22e:	f8 94       	cli
    c230:	de bf       	out	0x3e, r29	; 62
    c232:	0f be       	out	0x3f, r0	; 63
    c234:	cd bf       	out	0x3d, r28	; 61
    c236:	cf 91       	pop	r28
    c238:	df 91       	pop	r29
    c23a:	1f 91       	pop	r17
    c23c:	0f 91       	pop	r16
    c23e:	ff 90       	pop	r15
    c240:	ef 90       	pop	r14
    c242:	df 90       	pop	r13
    c244:	08 95       	ret

0000c246 <FMenuShift>:
     char SubMenu,KeyChar,KeyPressed;

     char Result;

Result=MENU_NONE;
     switch(stMenuShift){
    c246:	80 91 21 03 	lds	r24, 0x0321
    c24a:	82 30       	cpi	r24, 0x02	; 2
    c24c:	09 f4       	brne	.+2      	; 0xc250 <FMenuShift+0xa>
    c24e:	48 c0       	rjmp	.+144    	; 0xc2e0 <FMenuShift+0x9a>
    c250:	83 30       	cpi	r24, 0x03	; 3
    c252:	30 f4       	brcc	.+12     	; 0xc260 <FMenuShift+0x1a>
    c254:	88 23       	and	r24, r24
    c256:	69 f0       	breq	.+26     	; 0xc272 <FMenuShift+0x2c>
    c258:	81 30       	cpi	r24, 0x01	; 1
    c25a:	09 f0       	breq	.+2      	; 0xc25e <FMenuShift+0x18>
    c25c:	50 c0       	rjmp	.+160    	; 0xc2fe <FMenuShift+0xb8>
    c25e:	25 c0       	rjmp	.+74     	; 0xc2aa <FMenuShift+0x64>
    c260:	84 30       	cpi	r24, 0x04	; 4
    c262:	09 f4       	brne	.+2      	; 0xc266 <FMenuShift+0x20>
    c264:	4c c0       	rjmp	.+152    	; 0xc2fe <FMenuShift+0xb8>
    c266:	84 30       	cpi	r24, 0x04	; 4
    c268:	e8 f1       	brcs	.+122    	; 0xc2e4 <FMenuShift+0x9e>
    c26a:	85 30       	cpi	r24, 0x05	; 5
    c26c:	09 f0       	breq	.+2      	; 0xc270 <FMenuShift+0x2a>
    c26e:	47 c0       	rjmp	.+142    	; 0xc2fe <FMenuShift+0xb8>
    c270:	42 c0       	rjmp	.+132    	; 0xc2f6 <FMenuShift+0xb0>
	 case msInitMenuShift:
	      lcd_clear();
    c272:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Close Shift"));
    c276:	81 e0       	ldi	r24, 0x01	; 1
    c278:	61 e0       	ldi	r22, 0x01	; 1
    c27a:	4b e8       	ldi	r20, 0x8B	; 139
    c27c:	55 e1       	ldi	r21, 0x15	; 21
    c27e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Close Day  "));
    c282:	82 e0       	ldi	r24, 0x02	; 2
    c284:	61 e0       	ldi	r22, 0x01	; 1
    c286:	4d e7       	ldi	r20, 0x7D	; 125
    c288:	55 e1       	ldi	r21, 0x15	; 21
    c28a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(3,1,PSTR("3.Lock Pump  "));
    c28e:	83 e0       	ldi	r24, 0x03	; 3
    c290:	61 e0       	ldi	r22, 0x01	; 1
    c292:	4f e6       	ldi	r20, 0x6F	; 111
    c294:	55 e1       	ldi	r21, 0x15	; 21
    c296:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit"));
    c29a:	84 e0       	ldi	r24, 0x04	; 4
    c29c:	61 e0       	ldi	r22, 0x01	; 1
    c29e:	48 e6       	ldi	r20, 0x68	; 104
    c2a0:	55 e1       	ldi	r21, 0x15	; 21
    c2a2:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  stMenuShift=msSelectShift;
    c2a6:	81 e0       	ldi	r24, 0x01	; 1
    c2a8:	18 c0       	rjmp	.+48     	; 0xc2da <FMenuShift+0x94>
	      break;
     case msSelectShift:
          KeyPressed=_key_scan(1);
    c2aa:	81 e0       	ldi	r24, 0x01	; 1
    c2ac:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    c2b0:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
          switch(KeyChar){
    c2b4:	82 33       	cpi	r24, 0x32	; 50
    c2b6:	61 f0       	breq	.+24     	; 0xc2d0 <FMenuShift+0x8a>
    c2b8:	83 33       	cpi	r24, 0x33	; 51
    c2ba:	28 f4       	brcc	.+10     	; 0xc2c6 <FMenuShift+0x80>
    c2bc:	8a 32       	cpi	r24, 0x2A	; 42
    c2be:	61 f0       	breq	.+24     	; 0xc2d8 <FMenuShift+0x92>
    c2c0:	81 33       	cpi	r24, 0x31	; 49
    c2c2:	e9 f4       	brne	.+58     	; 0xc2fe <FMenuShift+0xb8>
    c2c4:	03 c0       	rjmp	.+6      	; 0xc2cc <FMenuShift+0x86>
    c2c6:	83 33       	cpi	r24, 0x33	; 51
    c2c8:	d1 f4       	brne	.+52     	; 0xc2fe <FMenuShift+0xb8>
    c2ca:	04 c0       	rjmp	.+8      	; 0xc2d4 <FMenuShift+0x8e>
		  case '1':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseShift;
    c2cc:	82 e0       	ldi	r24, 0x02	; 2
    c2ce:	05 c0       	rjmp	.+10     	; 0xc2da <FMenuShift+0x94>
		       break; 
		  case '2':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseDay;
    c2d0:	83 e0       	ldi	r24, 0x03	; 3
    c2d2:	03 c0       	rjmp	.+6      	; 0xc2da <FMenuShift+0x94>
		       break; 
		  case '3':
		       SubMenu=MENU_NONE;
		       stMenuShift=msLockPump;
    c2d4:	84 e0       	ldi	r24, 0x04	; 4
    c2d6:	01 c0       	rjmp	.+2      	; 0xc2da <FMenuShift+0x94>
		       break; 
		  case '*':
		       stMenuShift=msExitShift;
    c2d8:	85 e0       	ldi	r24, 0x05	; 5
    c2da:	80 93 21 03 	sts	0x0321, r24
    c2de:	09 c0       	rjmp	.+18     	; 0xc2f2 <FMenuShift+0xac>
		       break; 			   		  
		  }
		  break;
     case msCloseShift:
	      SubMenu=FCloseShift(CONTINUE_SHIFT);
    c2e0:	82 e0       	ldi	r24, 0x02	; 2
    c2e2:	01 c0       	rjmp	.+2      	; 0xc2e6 <FMenuShift+0xa0>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
		  //IsGenerateReport=True;		  
	      break;
     case msCloseDay:
	      SubMenu=FCloseShift(NEW_SHIFT);
    c2e4:	81 e0       	ldi	r24, 0x01	; 1
    c2e6:	0e 94 d3 5e 	call	0xbda6	; 0xbda6 <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
    c2ea:	81 30       	cpi	r24, 0x01	; 1
    c2ec:	41 f4       	brne	.+16     	; 0xc2fe <FMenuShift+0xb8>
    c2ee:	10 92 21 03 	sts	0x0321, r1
    c2f2:	80 e0       	ldi	r24, 0x00	; 0
    c2f4:	08 95       	ret
     case msLockPump:
	      SubMenu=FLockPump();
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
	      break;
     case msExitShift:
          stMenuShift=msInitMenuShift;
    c2f6:	10 92 21 03 	sts	0x0321, r1
    c2fa:	81 e0       	ldi	r24, 0x01	; 1
    c2fc:	08 95       	ret
    c2fe:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 } 
   return Result;
}
    c300:	08 95       	ret

0000c302 <DisplayDateTime>:

void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}

void DisplayDateTime(){
    c302:	cf 92       	push	r12
    c304:	df 92       	push	r13
    c306:	ef 92       	push	r14
    c308:	ff 92       	push	r15
    c30a:	0f 93       	push	r16
    c30c:	1f 93       	push	r17
    c30e:	df 93       	push	r29
    c310:	cf 93       	push	r28
    c312:	cd b7       	in	r28, 0x3d	; 61
    c314:	de b7       	in	r29, 0x3e	; 62
    c316:	64 97       	sbiw	r28, 0x14	; 20
    c318:	0f b6       	in	r0, 0x3f	; 63
    c31a:	f8 94       	cli
    c31c:	de bf       	out	0x3e, r29	; 62
    c31e:	0f be       	out	0x3f, r0	; 63
    c320:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20];
	 _datetime(0, strSystemDate, strSystemTime);
    c322:	5a ee       	ldi	r21, 0xEA	; 234
    c324:	e5 2e       	mov	r14, r21
    c326:	55 e0       	ldi	r21, 0x05	; 5
    c328:	f5 2e       	mov	r15, r21
    c32a:	49 ec       	ldi	r20, 0xC9	; 201
    c32c:	c4 2e       	mov	r12, r20
    c32e:	4a e0       	ldi	r20, 0x0A	; 10
    c330:	d4 2e       	mov	r13, r20
    c332:	80 e0       	ldi	r24, 0x00	; 0
    c334:	b7 01       	movw	r22, r14
    c336:	a6 01       	movw	r20, r12
    c338:	0e 94 4b b1 	call	0x16296	; 0x16296 <_datetime>
	 sprintf_P(lcdteks,PSTR("%s %s"),strSystemDate,strSystemTime);
    c33c:	8d b7       	in	r24, 0x3d	; 61
    c33e:	9e b7       	in	r25, 0x3e	; 62
    c340:	08 97       	sbiw	r24, 0x08	; 8
    c342:	0f b6       	in	r0, 0x3f	; 63
    c344:	f8 94       	cli
    c346:	9e bf       	out	0x3e, r25	; 62
    c348:	0f be       	out	0x3f, r0	; 63
    c34a:	8d bf       	out	0x3d, r24	; 61
    c34c:	ed b7       	in	r30, 0x3d	; 61
    c34e:	fe b7       	in	r31, 0x3e	; 62
    c350:	31 96       	adiw	r30, 0x01	; 1
    c352:	8e 01       	movw	r16, r28
    c354:	0f 5f       	subi	r16, 0xFF	; 255
    c356:	1f 4f       	sbci	r17, 0xFF	; 255
    c358:	ad b7       	in	r26, 0x3d	; 61
    c35a:	be b7       	in	r27, 0x3e	; 62
    c35c:	12 96       	adiw	r26, 0x02	; 2
    c35e:	1c 93       	st	X, r17
    c360:	0e 93       	st	-X, r16
    c362:	11 97       	sbiw	r26, 0x01	; 1
    c364:	84 ed       	ldi	r24, 0xD4	; 212
    c366:	9b e1       	ldi	r25, 0x1B	; 27
    c368:	93 83       	std	Z+3, r25	; 0x03
    c36a:	82 83       	std	Z+2, r24	; 0x02
    c36c:	f5 82       	std	Z+5, r15	; 0x05
    c36e:	e4 82       	std	Z+4, r14	; 0x04
    c370:	d7 82       	std	Z+7, r13	; 0x07
    c372:	c6 82       	std	Z+6, r12	; 0x06
    c374:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	 lcd_print(2, 1, lcdteks);
    c378:	8d b7       	in	r24, 0x3d	; 61
    c37a:	9e b7       	in	r25, 0x3e	; 62
    c37c:	08 96       	adiw	r24, 0x08	; 8
    c37e:	0f b6       	in	r0, 0x3f	; 63
    c380:	f8 94       	cli
    c382:	9e bf       	out	0x3e, r25	; 62
    c384:	0f be       	out	0x3f, r0	; 63
    c386:	8d bf       	out	0x3d, r24	; 61
    c388:	82 e0       	ldi	r24, 0x02	; 2
    c38a:	61 e0       	ldi	r22, 0x01	; 1
    c38c:	a8 01       	movw	r20, r16
    c38e:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
}
    c392:	64 96       	adiw	r28, 0x14	; 20
    c394:	0f b6       	in	r0, 0x3f	; 63
    c396:	f8 94       	cli
    c398:	de bf       	out	0x3e, r29	; 62
    c39a:	0f be       	out	0x3f, r0	; 63
    c39c:	cd bf       	out	0x3d, r28	; 61
    c39e:	cf 91       	pop	r28
    c3a0:	df 91       	pop	r29
    c3a2:	1f 91       	pop	r17
    c3a4:	0f 91       	pop	r16
    c3a6:	ff 90       	pop	r15
    c3a8:	ef 90       	pop	r14
    c3aa:	df 90       	pop	r13
    c3ac:	cf 90       	pop	r12
    c3ae:	08 95       	ret

0000c3b0 <_menu_datetime>:
		}
	}
}


void _menu_datetime(void){
    c3b0:	8f 92       	push	r8
    c3b2:	9f 92       	push	r9
    c3b4:	af 92       	push	r10
    c3b6:	bf 92       	push	r11
    c3b8:	cf 92       	push	r12
    c3ba:	df 92       	push	r13
    c3bc:	ef 92       	push	r14
    c3be:	ff 92       	push	r15
    c3c0:	0f 93       	push	r16
    c3c2:	1f 93       	push	r17
    c3c4:	df 93       	push	r29
    c3c6:	cf 93       	push	r28
    c3c8:	cd b7       	in	r28, 0x3d	; 61
    c3ca:	de b7       	in	r29, 0x3e	; 62
    c3cc:	c2 54       	subi	r28, 0x42	; 66
    c3ce:	d0 40       	sbci	r29, 0x00	; 0
    c3d0:	0f b6       	in	r0, 0x3f	; 63
    c3d2:	f8 94       	cli
    c3d4:	de bf       	out	0x3e, r29	; 62
    c3d6:	0f be       	out	0x3f, r0	; 63
    c3d8:	cd bf       	out	0x3d, r28	; 61
	char	__key, __chr;
	char	__date[9];
	char	__time[9];
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};
    c3da:	de 01       	movw	r26, r28
    c3dc:	53 96       	adiw	r26, 0x13	; 19
    c3de:	e6 e2       	ldi	r30, 0x26	; 38
    c3e0:	f1 e0       	ldi	r31, 0x01	; 1
    c3e2:	80 e3       	ldi	r24, 0x30	; 48
    c3e4:	01 90       	ld	r0, Z+
    c3e6:	0d 92       	st	X+, r0
    c3e8:	81 50       	subi	r24, 0x01	; 1
    c3ea:	e1 f7       	brne	.-8      	; 0xc3e4 <_menu_datetime+0x34>

	_datetime(_DATETIME_READ, __date, __time);
    c3ec:	8e 01       	movw	r16, r28
    c3ee:	0f 5f       	subi	r16, 0xFF	; 255
    c3f0:	1f 4f       	sbci	r17, 0xFF	; 255
    c3f2:	b8 01       	movw	r22, r16
    c3f4:	ae 01       	movw	r20, r28
    c3f6:	46 5f       	subi	r20, 0xF6	; 246
    c3f8:	5f 4f       	sbci	r21, 0xFF	; 255
    c3fa:	0e 94 4b b1 	call	0x16296	; 0x16296 <_datetime>
    c3fe:	e5 e1       	ldi	r30, 0x15	; 21
    c400:	8e 2e       	mov	r8, r30
    c402:	91 2c       	mov	r9, r1
    c404:	8c 0e       	add	r8, r28
    c406:	9d 1e       	adc	r9, r29
    c408:	d4 01       	movw	r26, r8
    c40a:	20 e0       	ldi	r18, 0x00	; 0
    c40c:	30 e0       	ldi	r19, 0x00	; 0
    c40e:	40 e0       	ldi	r20, 0x00	; 0
    c410:	50 e0       	ldi	r21, 0x00	; 0
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
    c412:	22 30       	cpi	r18, 0x02	; 2
    c414:	31 05       	cpc	r19, r1
    c416:	19 f0       	breq	.+6      	; 0xc41e <_menu_datetime+0x6e>
    c418:	24 30       	cpi	r18, 0x04	; 4
    c41a:	31 05       	cpc	r19, r1
    c41c:	11 f4       	brne	.+4      	; 0xc422 <_menu_datetime+0x72>
			__ii++;
    c41e:	4f 5f       	subi	r20, 0xFF	; 255
    c420:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __date[__ii];
    c422:	f8 01       	movw	r30, r16
    c424:	e4 0f       	add	r30, r20
    c426:	f5 1f       	adc	r31, r21
    c428:	80 81       	ld	r24, Z
    c42a:	8c 93       	st	X, r24
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};

	_datetime(_DATETIME_READ, __date, __time);
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    c42c:	2f 5f       	subi	r18, 0xFF	; 255
    c42e:	3f 4f       	sbci	r19, 0xFF	; 255
    c430:	14 96       	adiw	r26, 0x04	; 4
    c432:	26 30       	cpi	r18, 0x06	; 6
    c434:	31 05       	cpc	r19, r1
    c436:	19 f0       	breq	.+6      	; 0xc43e <_menu_datetime+0x8e>
    c438:	4f 5f       	subi	r20, 0xFF	; 255
    c43a:	5f 4f       	sbci	r21, 0xFF	; 255
    c43c:	ea cf       	rjmp	.-44     	; 0xc412 <_menu_datetime+0x62>
    c43e:	7d e2       	ldi	r23, 0x2D	; 45
    c440:	a7 2e       	mov	r10, r23
    c442:	b1 2c       	mov	r11, r1
    c444:	ac 0e       	add	r10, r28
    c446:	bd 1e       	adc	r11, r29
    c448:	d5 01       	movw	r26, r10
    c44a:	40 e0       	ldi	r20, 0x00	; 0
    c44c:	50 e0       	ldi	r21, 0x00	; 0
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
    c44e:	6a e0       	ldi	r22, 0x0A	; 10
    c450:	e6 2e       	mov	r14, r22
    c452:	f1 2c       	mov	r15, r1
    c454:	ec 0e       	add	r14, r28
    c456:	fd 1e       	adc	r15, r29
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
    c458:	28 30       	cpi	r18, 0x08	; 8
    c45a:	31 05       	cpc	r19, r1
    c45c:	19 f0       	breq	.+6      	; 0xc464 <_menu_datetime+0xb4>
    c45e:	2a 30       	cpi	r18, 0x0A	; 10
    c460:	31 05       	cpc	r19, r1
    c462:	11 f4       	brne	.+4      	; 0xc468 <_menu_datetime+0xb8>
			__ii++;
    c464:	4f 5f       	subi	r20, 0xFF	; 255
    c466:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __time[__ii];
    c468:	f7 01       	movw	r30, r14
    c46a:	e4 0f       	add	r30, r20
    c46c:	f5 1f       	adc	r31, r21
    c46e:	80 81       	ld	r24, Z
    c470:	8c 93       	st	X, r24
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    c472:	2f 5f       	subi	r18, 0xFF	; 255
    c474:	3f 4f       	sbci	r19, 0xFF	; 255
    c476:	14 96       	adiw	r26, 0x04	; 4
    c478:	2c 30       	cpi	r18, 0x0C	; 12
    c47a:	31 05       	cpc	r19, r1
    c47c:	19 f0       	breq	.+6      	; 0xc484 <_menu_datetime+0xd4>
    c47e:	4f 5f       	subi	r20, 0xFF	; 255
    c480:	5f 4f       	sbci	r21, 0xFF	; 255
    c482:	ea cf       	rjmp	.-44     	; 0xc458 <_menu_datetime+0xa8>
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
	}

	lcd_clear();_delay_ms(10);
    c484:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
    c488:	84 ec       	ldi	r24, 0xC4	; 196
    c48a:	99 e0       	ldi	r25, 0x09	; 9
    c48c:	01 97       	sbiw	r24, 0x01	; 1
    c48e:	f1 f7       	brne	.-4      	; 0xc48c <_menu_datetime+0xdc>
	lcd_printf(1, 1, PSTR("DATE : "));
    c490:	81 e0       	ldi	r24, 0x01	; 1
    c492:	61 e0       	ldi	r22, 0x01	; 1
    c494:	4c ea       	ldi	r20, 0xAC	; 172
    c496:	5b e0       	ldi	r21, 0x0B	; 11
    c498:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	lcd_printf(2, 1, PSTR("TIME : "));
    c49c:	82 e0       	ldi	r24, 0x02	; 2
    c49e:	61 e0       	ldi	r22, 0x01	; 1
    c4a0:	44 ea       	ldi	r20, 0xA4	; 164
    c4a2:	5b e0       	ldi	r21, 0x0B	; 11
    c4a4:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	lcd_print(1, 8, __date);
    c4a8:	81 e0       	ldi	r24, 0x01	; 1
    c4aa:	68 e0       	ldi	r22, 0x08	; 8
    c4ac:	8e 01       	movw	r16, r28
    c4ae:	0f 5f       	subi	r16, 0xFF	; 255
    c4b0:	1f 4f       	sbci	r17, 0xFF	; 255
    c4b2:	a8 01       	movw	r20, r16
    c4b4:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
	lcd_print(2, 8, __time);
    c4b8:	82 e0       	ldi	r24, 0x02	; 2
    c4ba:	68 e0       	ldi	r22, 0x08	; 8
    c4bc:	a7 01       	movw	r20, r14
    c4be:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
	lcd_printf(4, 1, PSTR("*)Cancel      #)Save"));
    c4c2:	84 e0       	ldi	r24, 0x04	; 4
    c4c4:	61 e0       	ldi	r22, 0x01	; 1
    c4c6:	4f e8       	ldi	r20, 0x8F	; 143
    c4c8:	5b e0       	ldi	r21, 0x0B	; 11
    c4ca:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>

	__i = 0;
	lcd_xy(__map[__i][0], __map[__i][1]);
    c4ce:	8b 89       	ldd	r24, Y+19	; 0x13
    c4d0:	6c 89       	ldd	r22, Y+20	; 0x14
    c4d2:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
	CURSOR_SHOW;
    c4d6:	8f e0       	ldi	r24, 0x0F	; 15
    c4d8:	0e 94 33 ac 	call	0x15866	; 0x15866 <lcd_command>
    c4dc:	ee 24       	eor	r14, r14
    c4de:	ff 24       	eor	r15, r15
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    c4e0:	68 01       	movw	r12, r16
	lcd_xy(__map[__i][0], __map[__i][1]);
	CURSOR_SHOW;

	while(1){
		
		__key = _key_scan(1);
    c4e2:	81 e0       	ldi	r24, 0x01	; 1
    c4e4:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    c4e8:	18 2f       	mov	r17, r24
		__chr = _key_btn(__key);
    c4ea:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
    c4ee:	48 2f       	mov	r20, r24
		if(__chr >= 0x30 && __chr <= 0x39){
    c4f0:	80 53       	subi	r24, 0x30	; 48
    c4f2:	8a 30       	cpi	r24, 0x0A	; 10
    c4f4:	08 f0       	brcs	.+2      	; 0xc4f8 <_menu_datetime+0x148>
    c4f6:	72 c0       	rjmp	.+228    	; 0xc5dc <_menu_datetime+0x22c>
			if(__i == 0 || __i == 2 || __i == 6 || __i == 8 || __i == 10){
    c4f8:	e1 14       	cp	r14, r1
    c4fa:	f1 04       	cpc	r15, r1
    c4fc:	81 f0       	breq	.+32     	; 0xc51e <_menu_datetime+0x16e>
    c4fe:	82 e0       	ldi	r24, 0x02	; 2
    c500:	e8 16       	cp	r14, r24
    c502:	f1 04       	cpc	r15, r1
    c504:	61 f0       	breq	.+24     	; 0xc51e <_menu_datetime+0x16e>
    c506:	96 e0       	ldi	r25, 0x06	; 6
    c508:	e9 16       	cp	r14, r25
    c50a:	f1 04       	cpc	r15, r1
    c50c:	41 f0       	breq	.+16     	; 0xc51e <_menu_datetime+0x16e>
    c50e:	a8 e0       	ldi	r26, 0x08	; 8
    c510:	ea 16       	cp	r14, r26
    c512:	f1 04       	cpc	r15, r1
    c514:	21 f0       	breq	.+8      	; 0xc51e <_menu_datetime+0x16e>
    c516:	ba e0       	ldi	r27, 0x0A	; 10
    c518:	eb 16       	cp	r14, r27
    c51a:	f1 04       	cpc	r15, r1
    c51c:	81 f4       	brne	.+32     	; 0xc53e <_menu_datetime+0x18e>
				if((__chr - 0x30) <= __map[__i][3])
    c51e:	84 2f       	mov	r24, r20
    c520:	90 e0       	ldi	r25, 0x00	; 0
    c522:	c0 97       	sbiw	r24, 0x30	; 48
    c524:	f7 01       	movw	r30, r14
    c526:	ee 0f       	add	r30, r30
    c528:	ff 1f       	adc	r31, r31
    c52a:	ee 0f       	add	r30, r30
    c52c:	ff 1f       	adc	r31, r31
    c52e:	ec 0d       	add	r30, r12
    c530:	fd 1d       	adc	r31, r13
    c532:	25 89       	ldd	r18, Z+21	; 0x15
    c534:	30 e0       	ldi	r19, 0x00	; 0
    c536:	28 17       	cp	r18, r24
    c538:	39 07       	cpc	r19, r25
    c53a:	84 f5       	brge	.+96     	; 0xc59c <_menu_datetime+0x1ec>
    c53c:	4f c0       	rjmp	.+158    	; 0xc5dc <_menu_datetime+0x22c>
					goto CETAK;
				else
					goto LEWAT;
			}
			if(__i == 1){
    c53e:	81 e0       	ldi	r24, 0x01	; 1
    c540:	e8 16       	cp	r14, r24
    c542:	f1 04       	cpc	r15, r1
    c544:	61 f4       	brne	.+24     	; 0xc55e <_menu_datetime+0x1ae>
				if((__map[0][2] - 0x30) < __map[0][3])
    c546:	2d 89       	ldd	r18, Y+21	; 0x15
    c548:	30 e0       	ldi	r19, 0x00	; 0
    c54a:	2f 52       	subi	r18, 0x2F	; 47
    c54c:	30 40       	sbci	r19, 0x00	; 0
    c54e:	8e 89       	ldd	r24, Y+22	; 0x16
    c550:	90 e0       	ldi	r25, 0x00	; 0
    c552:	82 17       	cp	r24, r18
    c554:	93 07       	cpc	r25, r19
    c556:	14 f5       	brge	.+68     	; 0xc59c <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[0][2] - 0x30) >= __map[0][3]){
					if(__chr < 0x32)
    c558:	42 33       	cpi	r20, 0x32	; 50
    c55a:	00 f1       	brcs	.+64     	; 0xc59c <_menu_datetime+0x1ec>
    c55c:	3f c0       	rjmp	.+126    	; 0xc5dc <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 3){
    c55e:	93 e0       	ldi	r25, 0x03	; 3
    c560:	e9 16       	cp	r14, r25
    c562:	f1 04       	cpc	r15, r1
    c564:	61 f4       	brne	.+24     	; 0xc57e <_menu_datetime+0x1ce>
				if((__map[2][2] - 0x30) < __map[2][3])
    c566:	2d 8d       	ldd	r18, Y+29	; 0x1d
    c568:	30 e0       	ldi	r19, 0x00	; 0
    c56a:	2f 52       	subi	r18, 0x2F	; 47
    c56c:	30 40       	sbci	r19, 0x00	; 0
    c56e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    c570:	90 e0       	ldi	r25, 0x00	; 0
    c572:	82 17       	cp	r24, r18
    c574:	93 07       	cpc	r25, r19
    c576:	94 f4       	brge	.+36     	; 0xc59c <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[2][2] - 0x30) >= __map[2][3]){
					if(__chr < 0x33)
    c578:	43 33       	cpi	r20, 0x33	; 51
    c57a:	80 f0       	brcs	.+32     	; 0xc59c <_menu_datetime+0x1ec>
    c57c:	2f c0       	rjmp	.+94     	; 0xc5dc <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 7){
    c57e:	a7 e0       	ldi	r26, 0x07	; 7
    c580:	ea 16       	cp	r14, r26
    c582:	f1 04       	cpc	r15, r1
    c584:	59 f4       	brne	.+22     	; 0xc59c <_menu_datetime+0x1ec>
				if((__map[6][2] - 0x30) < __map[6][3])
    c586:	2d a5       	ldd	r18, Y+45	; 0x2d
    c588:	30 e0       	ldi	r19, 0x00	; 0
    c58a:	2f 52       	subi	r18, 0x2F	; 47
    c58c:	30 40       	sbci	r19, 0x00	; 0
    c58e:	8e a5       	ldd	r24, Y+46	; 0x2e
    c590:	90 e0       	ldi	r25, 0x00	; 0
    c592:	82 17       	cp	r24, r18
    c594:	93 07       	cpc	r25, r19
    c596:	14 f4       	brge	.+4      	; 0xc59c <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[6][2] - 0x30) >= __map[6][3]){
					if(__chr < 0x34)
    c598:	44 33       	cpi	r20, 0x34	; 52
    c59a:	00 f5       	brcc	.+64     	; 0xc5dc <_menu_datetime+0x22c>
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    c59c:	f7 01       	movw	r30, r14
    c59e:	ee 0f       	add	r30, r30
    c5a0:	ff 1f       	adc	r31, r31
    c5a2:	ee 0f       	add	r30, r30
    c5a4:	ff 1f       	adc	r31, r31
    c5a6:	ec 0d       	add	r30, r12
    c5a8:	fd 1d       	adc	r31, r13
    c5aa:	44 8b       	std	Z+20, r20	; 0x14
			_lcd(__chr);
    c5ac:	84 2f       	mov	r24, r20
    c5ae:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
			__i++;
    c5b2:	08 94       	sec
    c5b4:	e1 1c       	adc	r14, r1
    c5b6:	f1 1c       	adc	r15, r1
    c5b8:	bc e0       	ldi	r27, 0x0C	; 12
    c5ba:	eb 16       	cp	r14, r27
    c5bc:	f1 04       	cpc	r15, r1
    c5be:	1c f0       	brlt	.+6      	; 0xc5c6 <_menu_datetime+0x216>
    c5c0:	bb e0       	ldi	r27, 0x0B	; 11
    c5c2:	eb 2e       	mov	r14, r27
    c5c4:	f1 2c       	mov	r15, r1
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
    c5c6:	f7 01       	movw	r30, r14
    c5c8:	ee 0f       	add	r30, r30
    c5ca:	ff 1f       	adc	r31, r31
    c5cc:	ee 0f       	add	r30, r30
    c5ce:	ff 1f       	adc	r31, r31
    c5d0:	ec 0d       	add	r30, r12
    c5d2:	fd 1d       	adc	r31, r13
    c5d4:	82 89       	ldd	r24, Z+18	; 0x12
    c5d6:	63 89       	ldd	r22, Z+19	; 0x13
    c5d8:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
LEWAT:		;
		}
		if(__key == _KEY_SHIFT){
    c5dc:	1b 37       	cpi	r17, 0x7B	; 123
    c5de:	59 f4       	brne	.+22     	; 0xc5f6 <_menu_datetime+0x246>
			__i++;
    c5e0:	08 94       	sec
    c5e2:	e1 1c       	adc	r14, r1
    c5e4:	f1 1c       	adc	r15, r1
    c5e6:	8c e0       	ldi	r24, 0x0C	; 12
    c5e8:	e8 16       	cp	r14, r24
    c5ea:	f1 04       	cpc	r15, r1
    c5ec:	6c f0       	brlt	.+26     	; 0xc608 <_menu_datetime+0x258>
    c5ee:	7b e0       	ldi	r23, 0x0B	; 11
    c5f0:	e7 2e       	mov	r14, r23
    c5f2:	f1 2c       	mov	r15, r1
    c5f4:	09 c0       	rjmp	.+18     	; 0xc608 <_menu_datetime+0x258>
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CLEAR){
    c5f6:	17 37       	cpi	r17, 0x77	; 119
    c5f8:	99 f4       	brne	.+38     	; 0xc620 <_menu_datetime+0x270>
			__i--;
    c5fa:	08 94       	sec
    c5fc:	e1 08       	sbc	r14, r1
    c5fe:	f1 08       	sbc	r15, r1
    c600:	f7 fe       	sbrs	r15, 7
    c602:	02 c0       	rjmp	.+4      	; 0xc608 <_menu_datetime+0x258>
    c604:	ee 24       	eor	r14, r14
    c606:	ff 24       	eor	r15, r15
			if(__i <= 0)
				__i = 0;
			lcd_xy(__map[__i][0], __map[__i][1]);
    c608:	f7 01       	movw	r30, r14
    c60a:	ee 0f       	add	r30, r30
    c60c:	ff 1f       	adc	r31, r31
    c60e:	ee 0f       	add	r30, r30
    c610:	ff 1f       	adc	r31, r31
    c612:	ec 0d       	add	r30, r12
    c614:	fd 1d       	adc	r31, r13
    c616:	82 89       	ldd	r24, Z+18	; 0x12
    c618:	63 89       	ldd	r22, Z+19	; 0x13
    c61a:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
    c61e:	61 cf       	rjmp	.-318    	; 0xc4e2 <_menu_datetime+0x132>
		}
		if(__key == _KEY_CANCEL)
    c620:	17 3e       	cpi	r17, 0xE7	; 231
    c622:	09 f4       	brne	.+2      	; 0xc626 <_menu_datetime+0x276>
    c624:	49 c0       	rjmp	.+146    	; 0xc6b8 <_menu_datetime+0x308>
			break;
		if(__key == _KEY_ENTER){
    c626:	17 3b       	cpi	r17, 0xB7	; 183
    c628:	09 f0       	breq	.+2      	; 0xc62c <_menu_datetime+0x27c>
    c62a:	5b cf       	rjmp	.-330    	; 0xc4e2 <_menu_datetime+0x132>
    c62c:	20 e0       	ldi	r18, 0x00	; 0
    c62e:	30 e0       	ldi	r19, 0x00	; 0
    c630:	40 e0       	ldi	r20, 0x00	; 0
    c632:	50 e0       	ldi	r21, 0x00	; 0
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
    c634:	be 01       	movw	r22, r28
    c636:	6f 5f       	subi	r22, 0xFF	; 255
    c638:	7f 4f       	sbci	r23, 0xFF	; 255
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
    c63a:	22 30       	cpi	r18, 0x02	; 2
    c63c:	31 05       	cpc	r19, r1
    c63e:	19 f0       	breq	.+6      	; 0xc646 <_menu_datetime+0x296>
    c640:	24 30       	cpi	r18, 0x04	; 4
    c642:	31 05       	cpc	r19, r1
    c644:	11 f4       	brne	.+4      	; 0xc64a <_menu_datetime+0x29a>
					__ii++;
    c646:	4f 5f       	subi	r20, 0xFF	; 255
    c648:	5f 4f       	sbci	r21, 0xFF	; 255
				__date[__ii] = __map[__i][2];
    c64a:	fb 01       	movw	r30, r22
    c64c:	e4 0f       	add	r30, r20
    c64e:	f5 1f       	adc	r31, r21
    c650:	d4 01       	movw	r26, r8
    c652:	8c 91       	ld	r24, X
    c654:	80 83       	st	Z, r24
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    c656:	2f 5f       	subi	r18, 0xFF	; 255
    c658:	3f 4f       	sbci	r19, 0xFF	; 255
    c65a:	84 e0       	ldi	r24, 0x04	; 4
    c65c:	90 e0       	ldi	r25, 0x00	; 0
    c65e:	88 0e       	add	r8, r24
    c660:	99 1e       	adc	r9, r25
    c662:	26 30       	cpi	r18, 0x06	; 6
    c664:	31 05       	cpc	r19, r1
    c666:	19 f0       	breq	.+6      	; 0xc66e <_menu_datetime+0x2be>
    c668:	4f 5f       	subi	r20, 0xFF	; 255
    c66a:	5f 4f       	sbci	r21, 0xFF	; 255
    c66c:	e6 cf       	rjmp	.-52     	; 0xc63a <_menu_datetime+0x28a>
    c66e:	60 e0       	ldi	r22, 0x00	; 0
    c670:	70 e0       	ldi	r23, 0x00	; 0
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
    c672:	ae 01       	movw	r20, r28
    c674:	46 5f       	subi	r20, 0xF6	; 246
    c676:	5f 4f       	sbci	r21, 0xFF	; 255
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
    c678:	28 30       	cpi	r18, 0x08	; 8
    c67a:	31 05       	cpc	r19, r1
    c67c:	19 f0       	breq	.+6      	; 0xc684 <_menu_datetime+0x2d4>
    c67e:	2a 30       	cpi	r18, 0x0A	; 10
    c680:	31 05       	cpc	r19, r1
    c682:	11 f4       	brne	.+4      	; 0xc688 <_menu_datetime+0x2d8>
					__ii++;
    c684:	6f 5f       	subi	r22, 0xFF	; 255
    c686:	7f 4f       	sbci	r23, 0xFF	; 255
				__time[__ii] = __map[__i][2];
    c688:	fa 01       	movw	r30, r20
    c68a:	e6 0f       	add	r30, r22
    c68c:	f7 1f       	adc	r31, r23
    c68e:	d5 01       	movw	r26, r10
    c690:	8c 91       	ld	r24, X
    c692:	80 83       	st	Z, r24
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    c694:	2f 5f       	subi	r18, 0xFF	; 255
    c696:	3f 4f       	sbci	r19, 0xFF	; 255
    c698:	84 e0       	ldi	r24, 0x04	; 4
    c69a:	90 e0       	ldi	r25, 0x00	; 0
    c69c:	a8 0e       	add	r10, r24
    c69e:	b9 1e       	adc	r11, r25
    c6a0:	2c 30       	cpi	r18, 0x0C	; 12
    c6a2:	31 05       	cpc	r19, r1
    c6a4:	19 f0       	breq	.+6      	; 0xc6ac <_menu_datetime+0x2fc>
    c6a6:	6f 5f       	subi	r22, 0xFF	; 255
    c6a8:	7f 4f       	sbci	r23, 0xFF	; 255
    c6aa:	e6 cf       	rjmp	.-52     	; 0xc678 <_menu_datetime+0x2c8>
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
			}
			_datetime(_DATETIME_WRITE, __date, __time);
    c6ac:	81 e0       	ldi	r24, 0x01	; 1
    c6ae:	be 01       	movw	r22, r28
    c6b0:	6f 5f       	subi	r22, 0xFF	; 255
    c6b2:	7f 4f       	sbci	r23, 0xFF	; 255
    c6b4:	0e 94 4b b1 	call	0x16296	; 0x16296 <_datetime>
			break;
		}
	}
	CURSOR_HIDE;
    c6b8:	8c e0       	ldi	r24, 0x0C	; 12
    c6ba:	0e 94 33 ac 	call	0x15866	; 0x15866 <lcd_command>
}
    c6be:	ce 5b       	subi	r28, 0xBE	; 190
    c6c0:	df 4f       	sbci	r29, 0xFF	; 255
    c6c2:	0f b6       	in	r0, 0x3f	; 63
    c6c4:	f8 94       	cli
    c6c6:	de bf       	out	0x3e, r29	; 62
    c6c8:	0f be       	out	0x3f, r0	; 63
    c6ca:	cd bf       	out	0x3d, r28	; 61
    c6cc:	cf 91       	pop	r28
    c6ce:	df 91       	pop	r29
    c6d0:	1f 91       	pop	r17
    c6d2:	0f 91       	pop	r16
    c6d4:	ff 90       	pop	r15
    c6d6:	ef 90       	pop	r14
    c6d8:	df 90       	pop	r13
    c6da:	cf 90       	pop	r12
    c6dc:	bf 90       	pop	r11
    c6de:	af 90       	pop	r10
    c6e0:	9f 90       	pop	r9
    c6e2:	8f 90       	pop	r8
    c6e4:	08 95       	ret

0000c6e6 <FSettingDatetime>:
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
    c6e6:	0e 94 d8 61 	call	0xc3b0	; 0xc3b0 <_menu_datetime>
     return MENU_DONE;
}
    c6ea:	81 e0       	ldi	r24, 0x01	; 1
    c6ec:	08 95       	ret

0000c6ee <menu_FIP>:
	 }
  return Result;
}


char menu_FIP(char *xFIP,char *sFIPUsed){
    c6ee:	4f 92       	push	r4
    c6f0:	5f 92       	push	r5
    c6f2:	6f 92       	push	r6
    c6f4:	7f 92       	push	r7
    c6f6:	8f 92       	push	r8
    c6f8:	9f 92       	push	r9
    c6fa:	af 92       	push	r10
    c6fc:	bf 92       	push	r11
    c6fe:	cf 92       	push	r12
    c700:	df 92       	push	r13
    c702:	ef 92       	push	r14
    c704:	ff 92       	push	r15
    c706:	0f 93       	push	r16
    c708:	1f 93       	push	r17
    c70a:	df 93       	push	r29
    c70c:	cf 93       	push	r28
    c70e:	cd b7       	in	r28, 0x3d	; 61
    c710:	de b7       	in	r29, 0x3e	; 62
    c712:	a2 97       	sbiw	r28, 0x22	; 34
    c714:	0f b6       	in	r0, 0x3f	; 63
    c716:	f8 94       	cli
    c718:	de bf       	out	0x3e, r29	; 62
    c71a:	0f be       	out	0x3f, r0	; 63
    c71c:	cd bf       	out	0x3d, r28	; 61
    c71e:	7c 01       	movw	r14, r24
    c720:	8b 01       	movw	r16, r22
       char Result=FIP_NONE;
       char FIP[8],strPumpL[3],strPumpR[3],lcdteks[20];
static char KeyPressed=0,KeyChar,KeyCharLast=' ',FIP_Used=0;
static unsigned int iLoop;

       switch(stEnterFIP){
    c722:	80 91 58 03 	lds	r24, 0x0358
    c726:	81 30       	cpi	r24, 0x01	; 1
    c728:	09 f4       	brne	.+2      	; 0xc72c <menu_FIP+0x3e>
    c72a:	cf c0       	rjmp	.+414    	; 0xc8ca <menu_FIP+0x1dc>
    c72c:	81 30       	cpi	r24, 0x01	; 1
    c72e:	20 f0       	brcs	.+8      	; 0xc738 <menu_FIP+0x4a>
    c730:	82 30       	cpi	r24, 0x02	; 2
    c732:	09 f0       	breq	.+2      	; 0xc736 <menu_FIP+0x48>
    c734:	55 c1       	rjmp	.+682    	; 0xc9e0 <menu_FIP+0x2f2>
    c736:	52 c1       	rjmp	.+676    	; 0xc9dc <menu_FIP+0x2ee>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    c738:	8e 01       	movw	r16, r28
    c73a:	09 5f       	subi	r16, 0xF9	; 249
    c73c:	1f 4f       	sbci	r17, 0xFF	; 255
    c73e:	c8 01       	movw	r24, r16
    c740:	65 e4       	ldi	r22, 0x45	; 69
    c742:	70 e0       	ldi	r23, 0x00	; 0
    c744:	48 e0       	ldi	r20, 0x08	; 8
    c746:	50 e0       	ldi	r21, 0x00	; 0
    c748:	25 ed       	ldi	r18, 0xD5	; 213
    c74a:	32 e1       	ldi	r19, 0x12	; 18
    c74c:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
    c750:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
    c754:	f8 01       	movw	r30, r16
    c756:	20 e0       	ldi	r18, 0x00	; 0
    c758:	30 e0       	ldi	r19, 0x00	; 0
    c75a:	07 c0       	rjmp	.+14     	; 0xc76a <menu_FIP+0x7c>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
    c75c:	80 81       	ld	r24, Z
    c75e:	84 36       	cpi	r24, 0x64	; 100
    c760:	08 f0       	brcs	.+2      	; 0xc764 <menu_FIP+0x76>
    c762:	10 82       	st	Z, r1
    c764:	2f 5f       	subi	r18, 0xFF	; 255
    c766:	3f 4f       	sbci	r19, 0xFF	; 255
    c768:	31 96       	adiw	r30, 0x01	; 1

       switch(stEnterFIP){
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
    c76a:	28 30       	cpi	r18, 0x08	; 8
    c76c:	31 05       	cpc	r19, r1
    c76e:	b0 f3       	brcs	.-20     	; 0xc75c <menu_FIP+0x6e>
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    c770:	10 92 54 03 	sts	0x0354, r1
    c774:	10 92 53 03 	sts	0x0353, r1
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    c778:	5e 01       	movw	r10, r28
    c77a:	08 94       	sec
    c77c:	a1 1c       	adc	r10, r1
    c77e:	b1 1c       	adc	r11, r1
    c780:	06 e5       	ldi	r16, 0x56	; 86
    c782:	c0 2e       	mov	r12, r16
    c784:	0d e0       	ldi	r16, 0x0D	; 13
    c786:	d0 2e       	mov	r13, r16
    c788:	17 e0       	ldi	r17, 0x07	; 7
    c78a:	41 2e       	mov	r4, r17
    c78c:	51 2c       	mov	r5, r1
    c78e:	4c 0e       	add	r4, r28
    c790:	5d 1e       	adc	r5, r29
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    c792:	b4 e0       	ldi	r27, 0x04	; 4
    c794:	eb 2e       	mov	r14, r27
    c796:	f1 2c       	mov	r15, r1
    c798:	ec 0e       	add	r14, r28
    c79a:	fd 1e       	adc	r15, r29
    c79c:	ab e0       	ldi	r26, 0x0B	; 11
    c79e:	6a 2e       	mov	r6, r26
    c7a0:	71 2c       	mov	r7, r1
    c7a2:	6c 0e       	add	r6, r28
    c7a4:	7d 1e       	adc	r7, r29
    c7a6:	8e 01       	movw	r16, r28
    c7a8:	01 5f       	subi	r16, 0xF1	; 241
    c7aa:	1f 4f       	sbci	r17, 0xFF	; 255
    c7ac:	fc e5       	ldi	r31, 0x5C	; 92
    c7ae:	8f 2e       	mov	r8, r31
    c7b0:	fb e1       	ldi	r31, 0x1B	; 27
    c7b2:	9f 2e       	mov	r9, r31
    c7b4:	64 c0       	rjmp	.+200    	; 0xc87e <menu_FIP+0x190>
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    c7b6:	00 d0       	rcall	.+0      	; 0xc7b8 <menu_FIP+0xca>
    c7b8:	00 d0       	rcall	.+0      	; 0xc7ba <menu_FIP+0xcc>
    c7ba:	00 d0       	rcall	.+0      	; 0xc7bc <menu_FIP+0xce>
    c7bc:	2d b7       	in	r18, 0x3d	; 61
    c7be:	3e b7       	in	r19, 0x3e	; 62
    c7c0:	2f 5f       	subi	r18, 0xFF	; 255
    c7c2:	3f 4f       	sbci	r19, 0xFF	; 255
    c7c4:	ed b7       	in	r30, 0x3d	; 61
    c7c6:	fe b7       	in	r31, 0x3e	; 62
    c7c8:	b2 82       	std	Z+2, r11	; 0x02
    c7ca:	a1 82       	std	Z+1, r10	; 0x01
    c7cc:	f9 01       	movw	r30, r18
    c7ce:	d3 82       	std	Z+3, r13	; 0x03
    c7d0:	c2 82       	std	Z+2, r12	; 0x02
    c7d2:	a4 0d       	add	r26, r4
    c7d4:	b5 1d       	adc	r27, r5
    c7d6:	8c 91       	ld	r24, X
    c7d8:	84 83       	std	Z+4, r24	; 0x04
    c7da:	15 82       	std	Z+5, r1	; 0x05
    c7dc:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    c7e0:	ad b7       	in	r26, 0x3d	; 61
    c7e2:	be b7       	in	r27, 0x3e	; 62
    c7e4:	11 96       	adiw	r26, 0x01	; 1
    c7e6:	ed b7       	in	r30, 0x3d	; 61
    c7e8:	fe b7       	in	r31, 0x3e	; 62
    c7ea:	f2 82       	std	Z+2, r15	; 0x02
    c7ec:	e1 82       	std	Z+1, r14	; 0x01
    c7ee:	13 96       	adiw	r26, 0x03	; 3
    c7f0:	dc 92       	st	X, r13
    c7f2:	ce 92       	st	-X, r12
    c7f4:	12 97       	sbiw	r26, 0x02	; 2
    c7f6:	e0 91 53 03 	lds	r30, 0x0353
    c7fa:	f0 91 54 03 	lds	r31, 0x0354
    c7fe:	e6 0d       	add	r30, r6
    c800:	f7 1d       	adc	r31, r7
    c802:	80 81       	ld	r24, Z
    c804:	14 96       	adiw	r26, 0x04	; 4
    c806:	8c 93       	st	X, r24
    c808:	14 97       	sbiw	r26, 0x04	; 4
    c80a:	15 96       	adiw	r26, 0x05	; 5
    c80c:	1c 92       	st	X, r1
    c80e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    c812:	80 91 53 03 	lds	r24, 0x0353
    c816:	90 91 54 03 	lds	r25, 0x0354
    c81a:	00 d0       	rcall	.+0      	; 0xc81c <menu_FIP+0x12e>
    c81c:	00 d0       	rcall	.+0      	; 0xc81e <menu_FIP+0x130>
    c81e:	00 d0       	rcall	.+0      	; 0xc820 <menu_FIP+0x132>
    c820:	ed b7       	in	r30, 0x3d	; 61
    c822:	fe b7       	in	r31, 0x3e	; 62
    c824:	31 96       	adiw	r30, 0x01	; 1
    c826:	ad b7       	in	r26, 0x3d	; 61
    c828:	be b7       	in	r27, 0x3e	; 62
    c82a:	12 96       	adiw	r26, 0x02	; 2
    c82c:	1c 93       	st	X, r17
    c82e:	0e 93       	st	-X, r16
    c830:	11 97       	sbiw	r26, 0x01	; 1
    c832:	93 82       	std	Z+3, r9	; 0x03
    c834:	82 82       	std	Z+2, r8	; 0x02
    c836:	01 96       	adiw	r24, 0x01	; 1
    c838:	95 83       	std	Z+5, r25	; 0x05
    c83a:	84 83       	std	Z+4, r24	; 0x04
    c83c:	b7 82       	std	Z+7, r11	; 0x07
    c83e:	a6 82       	std	Z+6, r10	; 0x06
    c840:	04 96       	adiw	r24, 0x04	; 4
    c842:	91 87       	std	Z+9, r25	; 0x09
    c844:	80 87       	std	Z+8, r24	; 0x08
    c846:	f3 86       	std	Z+11, r15	; 0x0b
    c848:	e2 86       	std	Z+10, r14	; 0x0a
    c84a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
                //sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
			    lcd_print((iLoop+1),1,lcdteks);
    c84e:	ed b7       	in	r30, 0x3d	; 61
    c850:	fe b7       	in	r31, 0x3e	; 62
    c852:	3c 96       	adiw	r30, 0x0c	; 12
    c854:	0f b6       	in	r0, 0x3f	; 63
    c856:	f8 94       	cli
    c858:	fe bf       	out	0x3e, r31	; 62
    c85a:	0f be       	out	0x3f, r0	; 63
    c85c:	ed bf       	out	0x3d, r30	; 61
    c85e:	80 91 53 03 	lds	r24, 0x0353
    c862:	8f 5f       	subi	r24, 0xFF	; 255
    c864:	61 e0       	ldi	r22, 0x01	; 1
    c866:	a8 01       	movw	r20, r16
    c868:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    c86c:	80 91 53 03 	lds	r24, 0x0353
    c870:	90 91 54 03 	lds	r25, 0x0354
    c874:	01 96       	adiw	r24, 0x01	; 1
    c876:	90 93 54 03 	sts	0x0354, r25
    c87a:	80 93 53 03 	sts	0x0353, r24
    c87e:	a0 91 53 03 	lds	r26, 0x0353
    c882:	b0 91 54 03 	lds	r27, 0x0354
    c886:	a4 30       	cpi	r26, 0x04	; 4
    c888:	b1 05       	cpc	r27, r1
    c88a:	08 f4       	brcc	.+2      	; 0xc88e <menu_FIP+0x1a0>
    c88c:	94 cf       	rjmp	.-216    	; 0xc7b6 <menu_FIP+0xc8>
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
                //sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
			    lcd_print((iLoop+1),1,lcdteks);
			}
		    lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
    c88e:	81 e0       	ldi	r24, 0x01	; 1
    c890:	6f e0       	ldi	r22, 0x0F	; 15
    c892:	46 e5       	ldi	r20, 0x56	; 86
    c894:	5b e1       	ldi	r21, 0x1B	; 27
    c896:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		    lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
    c89a:	82 e0       	ldi	r24, 0x02	; 2
    c89c:	6f e0       	ldi	r22, 0x0F	; 15
    c89e:	40 e5       	ldi	r20, 0x50	; 80
    c8a0:	5b e1       	ldi	r21, 0x1B	; 27
    c8a2:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		    lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
    c8a6:	83 e0       	ldi	r24, 0x03	; 3
    c8a8:	6f e0       	ldi	r22, 0x0F	; 15
    c8aa:	4a e4       	ldi	r20, 0x4A	; 74
    c8ac:	5b e1       	ldi	r21, 0x1B	; 27
    c8ae:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	        lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
    c8b2:	84 e0       	ldi	r24, 0x04	; 4
    c8b4:	6f e0       	ldi	r22, 0x0F	; 15
    c8b6:	43 e4       	ldi	r20, 0x43	; 67
    c8b8:	5b e1       	ldi	r21, 0x1B	; 27
    c8ba:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		    iLoop=0;
    c8be:	10 92 54 03 	sts	0x0354, r1
    c8c2:	10 92 53 03 	sts	0x0353, r1
		    stEnterFIP=efFIPInput;
    c8c6:	81 e0       	ldi	r24, 0x01	; 1
    c8c8:	86 c0       	rjmp	.+268    	; 0xc9d6 <menu_FIP+0x2e8>
	        break;
	   case efFIPInput:
		    iLoop++;
    c8ca:	80 91 53 03 	lds	r24, 0x0353
    c8ce:	90 91 54 03 	lds	r25, 0x0354
    c8d2:	01 96       	adiw	r24, 0x01	; 1
    c8d4:	90 93 54 03 	sts	0x0354, r25
    c8d8:	80 93 53 03 	sts	0x0353, r24
		    KeyPressed=_key_scan(1);
    c8dc:	81 e0       	ldi	r24, 0x01	; 1
    c8de:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    c8e2:	80 93 57 03 	sts	0x0357, r24
		    KeyChar=_key_btn(KeyPressed);
    c8e6:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
    c8ea:	98 2f       	mov	r25, r24
    c8ec:	80 93 56 03 	sts	0x0356, r24
		    if ((KeyChar>='1')&&(KeyChar<='8')){
    c8f0:	81 53       	subi	r24, 0x31	; 49
    c8f2:	88 30       	cpi	r24, 0x08	; 8
    c8f4:	60 f4       	brcc	.+24     	; 0xc90e <menu_FIP+0x220>
		 	     if (KeyCharLast!=KeyChar){
    c8f6:	80 91 5a 01 	lds	r24, 0x015A
    c8fa:	89 17       	cp	r24, r25
    c8fc:	41 f0       	breq	.+16     	; 0xc90e <menu_FIP+0x220>
				     KeyCharLast=KeyChar;
    c8fe:	90 93 5a 01 	sts	0x015A, r25
				     iLoop=1000;
    c902:	88 ee       	ldi	r24, 0xE8	; 232
    c904:	93 e0       	ldi	r25, 0x03	; 3
    c906:	90 93 54 03 	sts	0x0354, r25
    c90a:	80 93 53 03 	sts	0x0353, r24
                 }
		    }
 		    if ((iLoop%2000)==0){
    c90e:	80 91 53 03 	lds	r24, 0x0353
    c912:	90 91 54 03 	lds	r25, 0x0354
    c916:	60 ed       	ldi	r22, 0xD0	; 208
    c918:	77 e0       	ldi	r23, 0x07	; 7
    c91a:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
    c91e:	89 2b       	or	r24, r25
    c920:	39 f4       	brne	.+14     	; 0xc930 <menu_FIP+0x242>
		        lcd_xy(1,19);_lcd('_'); 
    c922:	81 e0       	ldi	r24, 0x01	; 1
    c924:	63 e1       	ldi	r22, 0x13	; 19
    c926:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
    c92a:	8f e5       	ldi	r24, 0x5F	; 95
    c92c:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
			   }
           if ((iLoop%2000)==1000){
    c930:	80 91 53 03 	lds	r24, 0x0353
    c934:	90 91 54 03 	lds	r25, 0x0354
    c938:	60 ed       	ldi	r22, 0xD0	; 208
    c93a:	77 e0       	ldi	r23, 0x07	; 7
    c93c:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
    c940:	88 5e       	subi	r24, 0xE8	; 232
    c942:	93 40       	sbci	r25, 0x03	; 3
    c944:	41 f4       	brne	.+16     	; 0xc956 <menu_FIP+0x268>
			    lcd_xy(1,19);_lcd(KeyCharLast); 
    c946:	81 e0       	ldi	r24, 0x01	; 1
    c948:	63 e1       	ldi	r22, 0x13	; 19
    c94a:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
    c94e:	80 91 5a 01 	lds	r24, 0x015A
    c952:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
			   }

		   if (((KeyChar>='1')&&(KeyChar<='8'))||(KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')){ 
    c956:	80 91 56 03 	lds	r24, 0x0356
    c95a:	81 53       	subi	r24, 0x31	; 49
    c95c:	88 30       	cpi	r24, 0x08	; 8
    c95e:	40 f0       	brcs	.+16     	; 0xc970 <menu_FIP+0x282>
    c960:	80 91 57 03 	lds	r24, 0x0357
    c964:	87 3b       	cpi	r24, 0xB7	; 183
    c966:	a1 f5       	brne	.+104    	; 0xc9d0 <menu_FIP+0x2e2>
    c968:	80 91 5a 01 	lds	r24, 0x015A
    c96c:	80 32       	cpi	r24, 0x20	; 32
    c96e:	c1 f1       	breq	.+112    	; 0xc9e0 <menu_FIP+0x2f2>
		         FIP_Used=FIP[KeyCharLast-'1'];
    c970:	80 91 5a 01 	lds	r24, 0x015A
    c974:	fe 01       	movw	r30, r28
    c976:	ba 97       	sbiw	r30, 0x2a	; 42
    c978:	e8 0f       	add	r30, r24
    c97a:	f1 1d       	adc	r31, r1
    c97c:	20 81       	ld	r18, Z
    c97e:	20 93 55 03 	sts	0x0355, r18
				 if (FIP_Used<=99){
    c982:	24 36       	cpi	r18, 0x64	; 100
    c984:	00 f5       	brcc	.+64     	; 0xc9c6 <menu_FIP+0x2d8>
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    c986:	00 d0       	rcall	.+0      	; 0xc988 <menu_FIP+0x29a>
    c988:	00 d0       	rcall	.+0      	; 0xc98a <menu_FIP+0x29c>
    c98a:	00 d0       	rcall	.+0      	; 0xc98c <menu_FIP+0x29e>
    c98c:	ed b7       	in	r30, 0x3d	; 61
    c98e:	fe b7       	in	r31, 0x3e	; 62
    c990:	31 96       	adiw	r30, 0x01	; 1
    c992:	ad b7       	in	r26, 0x3d	; 61
    c994:	be b7       	in	r27, 0x3e	; 62
    c996:	12 96       	adiw	r26, 0x02	; 2
    c998:	1c 93       	st	X, r17
    c99a:	0e 93       	st	-X, r16
    c99c:	11 97       	sbiw	r26, 0x01	; 1
    c99e:	86 e5       	ldi	r24, 0x56	; 86
    c9a0:	9d e0       	ldi	r25, 0x0D	; 13
    c9a2:	93 83       	std	Z+3, r25	; 0x03
    c9a4:	82 83       	std	Z+2, r24	; 0x02
    c9a6:	24 83       	std	Z+4, r18	; 0x04
    c9a8:	15 82       	std	Z+5, r1	; 0x05
    c9aa:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		   if (((KeyChar>='1')&&(KeyChar<='8'))||(KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')){ 
		         FIP_Used=FIP[KeyCharLast-'1'];
				 if (FIP_Used<=99){
                    leadingZero(FIP_Used,sFIPUsed);
					 //sprintf_P(sFIPUsed,PSTR("%.2d"),FIP_Used);
					 xFIP[0]=FIP_Used;
    c9ae:	80 91 55 03 	lds	r24, 0x0355
    c9b2:	f7 01       	movw	r30, r14
    c9b4:	80 83       	st	Z, r24
    c9b6:	8d b7       	in	r24, 0x3d	; 61
    c9b8:	9e b7       	in	r25, 0x3e	; 62
    c9ba:	06 96       	adiw	r24, 0x06	; 6
    c9bc:	0f b6       	in	r0, 0x3f	; 63
    c9be:	f8 94       	cli
    c9c0:	9e bf       	out	0x3e, r25	; 62
    c9c2:	0f be       	out	0x3f, r0	; 63
    c9c4:	8d bf       	out	0x3d, r24	; 61
					 }
				 Result=FIP_DONE;
                 stEnterFIP=efExitFIPInput;
    c9c6:	82 e0       	ldi	r24, 0x02	; 2
    c9c8:	80 93 58 03 	sts	0x0358, r24
    c9cc:	80 e0       	ldi	r24, 0x00	; 0
    c9ce:	09 c0       	rjmp	.+18     	; 0xc9e2 <menu_FIP+0x2f4>
		   }
		   else
		   if (KeyPressed==_KEY_CANCEL){
    c9d0:	87 3e       	cpi	r24, 0xE7	; 231
    c9d2:	31 f4       	brne	.+12     	; 0xc9e0 <menu_FIP+0x2f2>
               Result=FIP_CANCEL;
			   stEnterFIP=efExitFIPInput;
    c9d4:	82 e0       	ldi	r24, 0x02	; 2
    c9d6:	80 93 58 03 	sts	0x0358, r24
    c9da:	03 c0       	rjmp	.+6      	; 0xc9e2 <menu_FIP+0x2f4>
		   }
	       break;
      case efExitFIPInput:
           stEnterFIP=efInit;
    c9dc:	10 92 58 03 	sts	0x0358, r1
    c9e0:	81 e0       	ldi	r24, 0x01	; 1
	       break;
	 }
return Result;
}
    c9e2:	a2 96       	adiw	r28, 0x22	; 34
    c9e4:	0f b6       	in	r0, 0x3f	; 63
    c9e6:	f8 94       	cli
    c9e8:	de bf       	out	0x3e, r29	; 62
    c9ea:	0f be       	out	0x3f, r0	; 63
    c9ec:	cd bf       	out	0x3d, r28	; 61
    c9ee:	cf 91       	pop	r28
    c9f0:	df 91       	pop	r29
    c9f2:	1f 91       	pop	r17
    c9f4:	0f 91       	pop	r16
    c9f6:	ff 90       	pop	r15
    c9f8:	ef 90       	pop	r14
    c9fa:	df 90       	pop	r13
    c9fc:	cf 90       	pop	r12
    c9fe:	bf 90       	pop	r11
    ca00:	af 90       	pop	r10
    ca02:	9f 90       	pop	r9
    ca04:	8f 90       	pop	r8
    ca06:	7f 90       	pop	r7
    ca08:	6f 90       	pop	r6
    ca0a:	5f 90       	pop	r5
    ca0c:	4f 90       	pop	r4
    ca0e:	08 95       	ret

0000ca10 <FMenuEDCTransaction>:
	      break;
	 }
	 return Result;
}

char FMenuEDCTransaction(){
    ca10:	0f 93       	push	r16
    ca12:	1f 93       	push	r17
static char KeyPressed=0,FIP_Used=0,FIPResult;
       char lcdteks[20],Result=MENU_NONE;
//static unsigned int iLoop=0;

Result=MENU_NONE;
	 switch(stEtransaction){
    ca14:	80 91 4b 03 	lds	r24, 0x034B
    ca18:	85 30       	cpi	r24, 0x05	; 5
    ca1a:	09 f4       	brne	.+2      	; 0xca1e <FMenuEDCTransaction+0xe>
    ca1c:	9f c0       	rjmp	.+318    	; 0xcb5c <FMenuEDCTransaction+0x14c>
    ca1e:	86 30       	cpi	r24, 0x06	; 6
    ca20:	90 f4       	brcc	.+36     	; 0xca46 <FMenuEDCTransaction+0x36>
    ca22:	82 30       	cpi	r24, 0x02	; 2
    ca24:	09 f4       	brne	.+2      	; 0xca28 <FMenuEDCTransaction+0x18>
    ca26:	57 c0       	rjmp	.+174    	; 0xcad6 <FMenuEDCTransaction+0xc6>
    ca28:	83 30       	cpi	r24, 0x03	; 3
    ca2a:	30 f4       	brcc	.+12     	; 0xca38 <FMenuEDCTransaction+0x28>
    ca2c:	88 23       	and	r24, r24
    ca2e:	f1 f0       	breq	.+60     	; 0xca6c <FMenuEDCTransaction+0x5c>
    ca30:	81 30       	cpi	r24, 0x01	; 1
    ca32:	09 f0       	breq	.+2      	; 0xca36 <FMenuEDCTransaction+0x26>
    ca34:	dd c0       	rjmp	.+442    	; 0xcbf0 <FMenuEDCTransaction+0x1e0>
    ca36:	36 c0       	rjmp	.+108    	; 0xcaa4 <FMenuEDCTransaction+0x94>
    ca38:	83 30       	cpi	r24, 0x03	; 3
    ca3a:	09 f4       	brne	.+2      	; 0xca3e <FMenuEDCTransaction+0x2e>
    ca3c:	5e c0       	rjmp	.+188    	; 0xcafa <FMenuEDCTransaction+0xea>
    ca3e:	84 30       	cpi	r24, 0x04	; 4
    ca40:	09 f0       	breq	.+2      	; 0xca44 <FMenuEDCTransaction+0x34>
    ca42:	d6 c0       	rjmp	.+428    	; 0xcbf0 <FMenuEDCTransaction+0x1e0>
    ca44:	83 c0       	rjmp	.+262    	; 0xcb4c <FMenuEDCTransaction+0x13c>
    ca46:	88 30       	cpi	r24, 0x08	; 8
    ca48:	09 f4       	brne	.+2      	; 0xca4c <FMenuEDCTransaction+0x3c>
    ca4a:	c2 c0       	rjmp	.+388    	; 0xcbd0 <FMenuEDCTransaction+0x1c0>
    ca4c:	89 30       	cpi	r24, 0x09	; 9
    ca4e:	38 f4       	brcc	.+14     	; 0xca5e <FMenuEDCTransaction+0x4e>
    ca50:	86 30       	cpi	r24, 0x06	; 6
    ca52:	09 f4       	brne	.+2      	; 0xca56 <FMenuEDCTransaction+0x46>
    ca54:	98 c0       	rjmp	.+304    	; 0xcb86 <FMenuEDCTransaction+0x176>
    ca56:	87 30       	cpi	r24, 0x07	; 7
    ca58:	09 f0       	breq	.+2      	; 0xca5c <FMenuEDCTransaction+0x4c>
    ca5a:	ca c0       	rjmp	.+404    	; 0xcbf0 <FMenuEDCTransaction+0x1e0>
    ca5c:	96 c0       	rjmp	.+300    	; 0xcb8a <FMenuEDCTransaction+0x17a>
    ca5e:	89 30       	cpi	r24, 0x09	; 9
    ca60:	09 f4       	brne	.+2      	; 0xca64 <FMenuEDCTransaction+0x54>
    ca62:	bc c0       	rjmp	.+376    	; 0xcbdc <FMenuEDCTransaction+0x1cc>
    ca64:	8a 30       	cpi	r24, 0x0A	; 10
    ca66:	09 f0       	breq	.+2      	; 0xca6a <FMenuEDCTransaction+0x5a>
    ca68:	c3 c0       	rjmp	.+390    	; 0xcbf0 <FMenuEDCTransaction+0x1e0>
    ca6a:	be c0       	rjmp	.+380    	; 0xcbe8 <FMenuEDCTransaction+0x1d8>
	 case etInit:
	      lcd_clear();
    ca6c:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Card Type"));
    ca70:	81 e0       	ldi	r24, 0x01	; 1
    ca72:	61 e0       	ldi	r22, 0x01	; 1
    ca74:	4e ec       	ldi	r20, 0xCE	; 206
    ca76:	59 e1       	ldi	r21, 0x19	; 25
    ca78:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          lcd_printf(1,1,PSTR("1.Debit/Flash Card  "));
    ca7c:	81 e0       	ldi	r24, 0x01	; 1
    ca7e:	61 e0       	ldi	r22, 0x01	; 1
    ca80:	49 eb       	ldi	r20, 0xB9	; 185
    ca82:	59 e1       	ldi	r21, 0x19	; 25
    ca84:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Credit Card       "));
    ca88:	82 e0       	ldi	r24, 0x02	; 2
    ca8a:	61 e0       	ldi	r22, 0x01	; 1
    ca8c:	44 ea       	ldi	r20, 0xA4	; 164
    ca8e:	59 e1       	ldi	r21, 0x19	; 25
    ca90:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
    ca94:	84 e0       	ldi	r24, 0x04	; 4
    ca96:	61 e0       	ldi	r22, 0x01	; 1
    ca98:	4f e8       	ldi	r20, 0x8F	; 143
    ca9a:	59 e1       	ldi	r21, 0x19	; 25
    ca9c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  stEtransaction=etInputEDC;
    caa0:	81 e0       	ldi	r24, 0x01	; 1
    caa2:	6e c0       	rjmp	.+220    	; 0xcb80 <FMenuEDCTransaction+0x170>
	      break;
     case etInputEDC:
	 	  KeyPressed=_key_scan(1);
    caa4:	81 e0       	ldi	r24, 0x01	; 1
    caa6:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    caaa:	80 93 49 03 	sts	0x0349, r24
		  KeyChar=_key_btn(KeyPressed);
    caae:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
    cab2:	98 2f       	mov	r25, r24
    cab4:	80 93 4a 03 	sts	0x034A, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
    cab8:	81 53       	subi	r24, 0x31	; 49
    caba:	82 30       	cpi	r24, 0x02	; 2
    cabc:	30 f4       	brcc	.+12     	; 0xcaca <FMenuEDCTransaction+0xba>
		       EDCType=KeyChar-'0';
    cabe:	90 53       	subi	r25, 0x30	; 48
    cac0:	90 93 60 0a 	sts	0x0A60, r25
		       stEtransaction=etSelectFIP;
    cac4:	82 e0       	ldi	r24, 0x02	; 2
    cac6:	80 93 4b 03 	sts	0x034B, r24
		     }
		  if (KeyPressed==_KEY_CANCEL)stEtransaction=etExitEDCTransaction;
    caca:	80 91 49 03 	lds	r24, 0x0349
    cace:	87 3e       	cpi	r24, 0xE7	; 231
    cad0:	09 f0       	breq	.+2      	; 0xcad4 <FMenuEDCTransaction+0xc4>
    cad2:	8e c0       	rjmp	.+284    	; 0xcbf0 <FMenuEDCTransaction+0x1e0>
    cad4:	87 c0       	rjmp	.+270    	; 0xcbe4 <FMenuEDCTransaction+0x1d4>
	      break;
	 case etSelectFIP:
	      FIPResult=menu_FIP(FIP_Used,strFIP_ID);
    cad6:	80 e0       	ldi	r24, 0x00	; 0
    cad8:	90 e0       	ldi	r25, 0x00	; 0
    cada:	6c ee       	ldi	r22, 0xEC	; 236
    cadc:	79 e0       	ldi	r23, 0x09	; 9
    cade:	0e 94 77 63 	call	0xc6ee	; 0xc6ee <menu_FIP>
    cae2:	80 93 48 03 	sts	0x0348, r24
		  if (FIPResult==FIP_DONE)stEtransaction=etInitMessage90;
    cae6:	88 23       	and	r24, r24
    cae8:	11 f4       	brne	.+4      	; 0xcaee <FMenuEDCTransaction+0xde>
    caea:	83 e0       	ldi	r24, 0x03	; 3
    caec:	49 c0       	rjmp	.+146    	; 0xcb80 <FMenuEDCTransaction+0x170>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
    caee:	82 30       	cpi	r24, 0x02	; 2
    caf0:	09 f0       	breq	.+2      	; 0xcaf4 <FMenuEDCTransaction+0xe4>
    caf2:	7e c0       	rjmp	.+252    	; 0xcbf0 <FMenuEDCTransaction+0x1e0>
    caf4:	10 92 4b 03 	sts	0x034B, r1
    caf8:	7b c0       	rjmp	.+246    	; 0xcbf0 <FMenuEDCTransaction+0x1e0>
    cafa:	e8 eb       	ldi	r30, 0xB8	; 184
    cafc:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    cafe:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    cb00:	8e e0       	ldi	r24, 0x0E	; 14
    cb02:	ed 3c       	cpi	r30, 0xCD	; 205
    cb04:	f8 07       	cpc	r31, r24
    cb06:	d9 f7       	brne	.-10     	; 0xcafe <FMenuEDCTransaction+0xee>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
	      break;
     case etInitMessage90:
	      FillChar(strRef1,sizeof(strRef1),0);
	      if (EDCType==1){
    cb08:	80 91 60 0a 	lds	r24, 0x0A60
    cb0c:	81 30       	cpi	r24, 0x01	; 1
    cb0e:	19 f4       	brne	.+6      	; 0xcb16 <FMenuEDCTransaction+0x106>
		      AddSpaceLag(strRef1,20);
    cb10:	cf 01       	movw	r24, r30
    cb12:	45 97       	sbiw	r24, 0x15	; 21
    cb14:	16 c0       	rjmp	.+44     	; 0xcb42 <FMenuEDCTransaction+0x132>
          }
		  else
	      if (EDCType==2){
    cb16:	82 30       	cpi	r24, 0x02	; 2
    cb18:	b9 f4       	brne	.+46     	; 0xcb48 <FMenuEDCTransaction+0x138>
		      sprintf_P(strRef1,PSTR("CREDITCARD"));
    cb1a:	00 d0       	rcall	.+0      	; 0xcb1c <FMenuEDCTransaction+0x10c>
    cb1c:	00 d0       	rcall	.+0      	; 0xcb1e <FMenuEDCTransaction+0x10e>
    cb1e:	8f 01       	movw	r16, r30
    cb20:	05 51       	subi	r16, 0x15	; 21
    cb22:	10 40       	sbci	r17, 0x00	; 0
    cb24:	ed b7       	in	r30, 0x3d	; 61
    cb26:	fe b7       	in	r31, 0x3e	; 62
    cb28:	12 83       	std	Z+2, r17	; 0x02
    cb2a:	01 83       	std	Z+1, r16	; 0x01
    cb2c:	84 e8       	ldi	r24, 0x84	; 132
    cb2e:	99 e1       	ldi	r25, 0x19	; 25
    cb30:	94 83       	std	Z+4, r25	; 0x04
    cb32:	83 83       	std	Z+3, r24	; 0x03
    cb34:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			  AddSpaceLag(strRef1,20);
    cb38:	0f 90       	pop	r0
    cb3a:	0f 90       	pop	r0
    cb3c:	0f 90       	pop	r0
    cb3e:	0f 90       	pop	r0
    cb40:	c8 01       	movw	r24, r16
    cb42:	64 e1       	ldi	r22, 0x14	; 20
    cb44:	0e 94 b9 2a 	call	0x5572	; 0x5572 <AddSpaceLag>
		  }	 
	      stEtransaction=etSendingMessage90;
    cb48:	84 e0       	ldi	r24, 0x04	; 4
    cb4a:	1a c0       	rjmp	.+52     	; 0xcb80 <FMenuEDCTransaction+0x170>
	      break;
     case etSendingMessage90:
          sendMessage90();
    cb4c:	0e 94 6c 4e 	call	0x9cd8	; 0x9cd8 <sendMessage90>
		  TimSend=0;
    cb50:	10 92 a9 01 	sts	0x01A9, r1
    cb54:	10 92 a8 01 	sts	0x01A8, r1
          stEtransaction=etWaitReply;
    cb58:	85 e0       	ldi	r24, 0x05	; 5
    cb5a:	12 c0       	rjmp	.+36     	; 0xcb80 <FMenuEDCTransaction+0x170>
	      break;
     case etWaitReply:
	      if (TimSend>TIM_SEND*2)stEtransaction=etNoConnection;
    cb5c:	80 91 a8 01 	lds	r24, 0x01A8
    cb60:	90 91 a9 01 	lds	r25, 0x01A9
    cb64:	45 97       	sbiw	r24, 0x15	; 21
    cb66:	18 f0       	brcs	.+6      	; 0xcb6e <FMenuEDCTransaction+0x15e>
    cb68:	88 e0       	ldi	r24, 0x08	; 8
    cb6a:	80 93 4b 03 	sts	0x034B, r24
		  if ((IsMessage91==True)||(IsMessage09==True))
    cb6e:	80 91 be 01 	lds	r24, 0x01BE
    cb72:	81 30       	cpi	r24, 0x01	; 1
    cb74:	21 f0       	breq	.+8      	; 0xcb7e <FMenuEDCTransaction+0x16e>
    cb76:	80 91 ba 01 	lds	r24, 0x01BA
    cb7a:	81 30       	cpi	r24, 0x01	; 1
    cb7c:	c9 f5       	brne	.+114    	; 0xcbf0 <FMenuEDCTransaction+0x1e0>
		       stEtransaction=etSuccesEDC;
    cb7e:	86 e0       	ldi	r24, 0x06	; 6
    cb80:	80 93 4b 03 	sts	0x034B, r24
    cb84:	35 c0       	rjmp	.+106    	; 0xcbf0 <FMenuEDCTransaction+0x1e0>
	      break;
     case etSuccesEDC:
	      stEtransaction=etDisplayFreeMessage;
    cb86:	87 e0       	ldi	r24, 0x07	; 7
    cb88:	fb cf       	rjmp	.-10     	; 0xcb80 <FMenuEDCTransaction+0x170>
	      break;
     case etDisplayFreeMessage:
	      if (IsMessage09==True){
    cb8a:	80 91 ba 01 	lds	r24, 0x01BA
    cb8e:	81 30       	cpi	r24, 0x01	; 1
    cb90:	19 f5       	brne	.+70     	; 0xcbd8 <FMenuEDCTransaction+0x1c8>
		      IsMessage09=False;
    cb92:	10 92 ba 01 	sts	0x01BA, r1
	          procMessage09();
    cb96:	0e 94 38 17 	call	0x2e70	; 0x2e70 <procMessage09>
		      lcd_clear();
    cb9a:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		      lcd_print(1,1,strFreeMessageLine1);
    cb9e:	81 e0       	ldi	r24, 0x01	; 1
    cba0:	61 e0       	ldi	r22, 0x01	; 1
    cba2:	47 ee       	ldi	r20, 0xE7	; 231
    cba4:	5a e0       	ldi	r21, 0x0A	; 10
    cba6:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		      lcd_print(2,1,strFreeMessageLine2);
    cbaa:	82 e0       	ldi	r24, 0x02	; 2
    cbac:	61 e0       	ldi	r22, 0x01	; 1
    cbae:	46 ed       	ldi	r20, 0xD6	; 214
    cbb0:	59 e0       	ldi	r21, 0x09	; 9
    cbb2:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		      lcd_print(3,1,strFreeMessageLine3);
    cbb6:	83 e0       	ldi	r24, 0x03	; 3
    cbb8:	61 e0       	ldi	r22, 0x01	; 1
    cbba:	41 e7       	ldi	r20, 0x71	; 113
    cbbc:	5a e0       	ldi	r21, 0x0A	; 10
    cbbe:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			  lcd_print(4,1,strFreeMessageLine4);
    cbc2:	84 e0       	ldi	r24, 0x04	; 4
    cbc4:	61 e0       	ldi	r22, 0x01	; 1
    cbc6:	41 e0       	ldi	r20, 0x01	; 1
    cbc8:	5e e0       	ldi	r21, 0x0E	; 14
    cbca:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    cbce:	02 c0       	rjmp	.+4      	; 0xcbd4 <FMenuEDCTransaction+0x1c4>
			  TimDisplay=0;
			  }
		  stEtransaction=etDelayExit;
	      break;
     case etNoConnection:
	      lcd_clear();
    cbd0:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  TimDisplay=0;
    cbd4:	10 92 a7 01 	sts	0x01A7, r1
		  stEtransaction=etDelayExit;
    cbd8:	89 e0       	ldi	r24, 0x09	; 9
    cbda:	d2 cf       	rjmp	.-92     	; 0xcb80 <FMenuEDCTransaction+0x170>
	      break;
     case etDelayExit:
	      if (TimDisplay>8)stEtransaction=etExitEDCTransaction;
    cbdc:	80 91 a7 01 	lds	r24, 0x01A7
    cbe0:	89 30       	cpi	r24, 0x09	; 9
    cbe2:	30 f0       	brcs	.+12     	; 0xcbf0 <FMenuEDCTransaction+0x1e0>
    cbe4:	8a e0       	ldi	r24, 0x0A	; 10
    cbe6:	cc cf       	rjmp	.-104    	; 0xcb80 <FMenuEDCTransaction+0x170>
	      break;
     case etExitEDCTransaction:
	      stEtransaction=etInit;
    cbe8:	10 92 4b 03 	sts	0x034B, r1
    cbec:	81 e0       	ldi	r24, 0x01	; 1
    cbee:	01 c0       	rjmp	.+2      	; 0xcbf2 <FMenuEDCTransaction+0x1e2>
    cbf0:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    cbf2:	1f 91       	pop	r17
    cbf4:	0f 91       	pop	r16
    cbf6:	08 95       	ret

0000cbf8 <FMenuLoyalty>:
	      break;
	 }
  return Result;
}

char FMenuLoyalty(){
    cbf8:	cf 92       	push	r12
    cbfa:	df 92       	push	r13
    cbfc:	ef 92       	push	r14
    cbfe:	ff 92       	push	r15
    cc00:	0f 93       	push	r16
    cc02:	1f 93       	push	r17
    cc04:	df 93       	push	r29
    cc06:	cf 93       	push	r28
    cc08:	cd b7       	in	r28, 0x3d	; 61
    cc0a:	de b7       	in	r29, 0x3e	; 62
    cc0c:	64 97       	sbiw	r28, 0x14	; 20
    cc0e:	0f b6       	in	r0, 0x3f	; 63
    cc10:	f8 94       	cli
    cc12:	de bf       	out	0x3e, r29	; 62
    cc14:	0f be       	out	0x3f, r0	; 63
    cc16:	cd bf       	out	0x3d, r28	; 61
       char FIPResult,FIP_USED;
	   char Result=MENU_NONE;
	   char KeyChar;

     Result=MENU_NONE;
	 switch(stLoyalty){
    cc18:	00 91 4f 03 	lds	r16, 0x034F
    cc1c:	07 30       	cpi	r16, 0x07	; 7
    cc1e:	09 f4       	brne	.+2      	; 0xcc22 <FMenuLoyalty+0x2a>
    cc20:	08 c1       	rjmp	.+528    	; 0xce32 <FMenuLoyalty+0x23a>
    cc22:	08 30       	cpi	r16, 0x08	; 8
    cc24:	98 f4       	brcc	.+38     	; 0xcc4c <FMenuLoyalty+0x54>
    cc26:	03 30       	cpi	r16, 0x03	; 3
    cc28:	09 f4       	brne	.+2      	; 0xcc2c <FMenuLoyalty+0x34>
    cc2a:	5d c0       	rjmp	.+186    	; 0xcce6 <FMenuLoyalty+0xee>
    cc2c:	04 30       	cpi	r16, 0x04	; 4
    cc2e:	38 f4       	brcc	.+14     	; 0xcc3e <FMenuLoyalty+0x46>
    cc30:	01 30       	cpi	r16, 0x01	; 1
    cc32:	09 f4       	brne	.+2      	; 0xcc36 <FMenuLoyalty+0x3e>
    cc34:	42 c0       	rjmp	.+132    	; 0xccba <FMenuLoyalty+0xc2>
    cc36:	02 30       	cpi	r16, 0x02	; 2
    cc38:	08 f0       	brcs	.+2      	; 0xcc3c <FMenuLoyalty+0x44>
    cc3a:	63 c0       	rjmp	.+198    	; 0xcd02 <FMenuLoyalty+0x10a>
    cc3c:	20 c0       	rjmp	.+64     	; 0xcc7e <FMenuLoyalty+0x86>
    cc3e:	05 30       	cpi	r16, 0x05	; 5
    cc40:	09 f4       	brne	.+2      	; 0xcc44 <FMenuLoyalty+0x4c>
    cc42:	a4 c0       	rjmp	.+328    	; 0xcd8c <FMenuLoyalty+0x194>
    cc44:	06 30       	cpi	r16, 0x06	; 6
    cc46:	08 f0       	brcs	.+2      	; 0xcc4a <FMenuLoyalty+0x52>
    cc48:	be c0       	rjmp	.+380    	; 0xcdc6 <FMenuLoyalty+0x1ce>
    cc4a:	8e c0       	rjmp	.+284    	; 0xcd68 <FMenuLoyalty+0x170>
    cc4c:	0b 30       	cpi	r16, 0x0B	; 11
    cc4e:	09 f4       	brne	.+2      	; 0xcc52 <FMenuLoyalty+0x5a>
    cc50:	3e c1       	rjmp	.+636    	; 0xcece <FMenuLoyalty+0x2d6>
    cc52:	0c 30       	cpi	r16, 0x0C	; 12
    cc54:	38 f4       	brcc	.+14     	; 0xcc64 <FMenuLoyalty+0x6c>
    cc56:	09 30       	cpi	r16, 0x09	; 9
    cc58:	09 f4       	brne	.+2      	; 0xcc5c <FMenuLoyalty+0x64>
    cc5a:	f6 c0       	rjmp	.+492    	; 0xce48 <FMenuLoyalty+0x250>
    cc5c:	0a 30       	cpi	r16, 0x0A	; 10
    cc5e:	08 f0       	brcs	.+2      	; 0xcc62 <FMenuLoyalty+0x6a>
    cc60:	18 c1       	rjmp	.+560    	; 0xce92 <FMenuLoyalty+0x29a>
    cc62:	ea c0       	rjmp	.+468    	; 0xce38 <FMenuLoyalty+0x240>
    cc64:	0d 30       	cpi	r16, 0x0D	; 13
    cc66:	09 f4       	brne	.+2      	; 0xcc6a <FMenuLoyalty+0x72>
    cc68:	f6 c1       	rjmp	.+1004   	; 0xd056 <FMenuLoyalty+0x45e>
    cc6a:	0d 30       	cpi	r16, 0x0D	; 13
    cc6c:	08 f4       	brcc	.+2      	; 0xcc70 <FMenuLoyalty+0x78>
    cc6e:	ff c1       	rjmp	.+1022   	; 0xd06e <FMenuLoyalty+0x476>
    cc70:	0e 30       	cpi	r16, 0x0E	; 14
    cc72:	09 f4       	brne	.+2      	; 0xcc76 <FMenuLoyalty+0x7e>
    cc74:	0e c2       	rjmp	.+1052   	; 0xd092 <FMenuLoyalty+0x49a>
    cc76:	0f 30       	cpi	r16, 0x0F	; 15
    cc78:	09 f0       	breq	.+2      	; 0xcc7c <FMenuLoyalty+0x84>
    cc7a:	17 c2       	rjmp	.+1070   	; 0xd0aa <FMenuLoyalty+0x4b2>
    cc7c:	10 c2       	rjmp	.+1056   	; 0xd09e <FMenuLoyalty+0x4a6>
	 case mlInit:
	      lcd_clear();
    cc7e:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("  Menu Loyalty   "));
    cc82:	81 e0       	ldi	r24, 0x01	; 1
    cc84:	61 e0       	ldi	r22, 0x01	; 1
    cc86:	4b eb       	ldi	r20, 0xBB	; 187
    cc88:	5a e1       	ldi	r21, 0x1A	; 26
    cc8a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          lcd_printf(1,1,PSTR("1.Enquiry        "));
    cc8e:	81 e0       	ldi	r24, 0x01	; 1
    cc90:	61 e0       	ldi	r22, 0x01	; 1
    cc92:	49 ea       	ldi	r20, 0xA9	; 169
    cc94:	5a e1       	ldi	r21, 0x1A	; 26
    cc96:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Loyalty Update "));
    cc9a:	82 e0       	ldi	r24, 0x02	; 2
    cc9c:	61 e0       	ldi	r22, 0x01	; 1
    cc9e:	47 e9       	ldi	r20, 0x97	; 151
    cca0:	5a e1       	ldi	r21, 0x1A	; 26
    cca2:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back          "));
    cca6:	84 e0       	ldi	r24, 0x04	; 4
    cca8:	61 e0       	ldi	r22, 0x01	; 1
    ccaa:	45 e8       	ldi	r20, 0x85	; 133
    ccac:	5a e1       	ldi	r21, 0x1A	; 26
    ccae:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  IsLoyaltyUpdate=False;
    ccb2:	10 92 4c 03 	sts	0x034C, r1
		  stLoyalty=mlLoyaltySelect;
    ccb6:	81 e0       	ldi	r24, 0x01	; 1
    ccb8:	0a c0       	rjmp	.+20     	; 0xccce <FMenuLoyalty+0xd6>
	      break;
	 case mlLoyaltySelect:
	 	  KeyPressed=_key_scan(1);
    ccba:	81 e0       	ldi	r24, 0x01	; 1
    ccbc:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    ccc0:	80 93 4e 03 	sts	0x034E, r24
		  if (KeyPressed==_KEY_1){
    ccc4:	8e 3e       	cpi	r24, 0xEE	; 238
    ccc6:	31 f4       	brne	.+12     	; 0xccd4 <FMenuLoyalty+0xdc>
		      IsLoyaltyUpdate=False;
    ccc8:	10 92 4c 03 	sts	0x034C, r1
		      stLoyalty=mlShowEnquiry;
    cccc:	84 e0       	ldi	r24, 0x04	; 4
    ccce:	80 93 4f 03 	sts	0x034F, r24
    ccd2:	eb c1       	rjmp	.+982    	; 0xd0aa <FMenuLoyalty+0x4b2>
			  }
		  else
		  if (KeyPressed==_KEY_2){
    ccd4:	8e 3d       	cpi	r24, 0xDE	; 222
    ccd6:	19 f4       	brne	.+6      	; 0xccde <FMenuLoyalty+0xe6>
		      IsLoyaltyUpdate=True;
    ccd8:	00 93 4c 03 	sts	0x034C, r16
    ccdc:	6b c0       	rjmp	.+214    	; 0xcdb4 <FMenuLoyalty+0x1bc>
			  stLoyalty=mlSelectFIP;
			  }
		  if (KeyPressed==_KEY_CANCEL)stLoyalty=mlExitLoyalty;
    ccde:	87 3e       	cpi	r24, 0xE7	; 231
    cce0:	09 f4       	brne	.+2      	; 0xcce4 <FMenuLoyalty+0xec>
    cce2:	db c1       	rjmp	.+950    	; 0xd09a <FMenuLoyalty+0x4a2>
    cce4:	e2 c1       	rjmp	.+964    	; 0xd0aa <FMenuLoyalty+0x4b2>
	      break;
     case mlSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
    cce6:	8d e4       	ldi	r24, 0x4D	; 77
    cce8:	93 e0       	ldi	r25, 0x03	; 3
    ccea:	6c ee       	ldi	r22, 0xEC	; 236
    ccec:	79 e0       	ldi	r23, 0x09	; 9
    ccee:	0e 94 77 63 	call	0xc6ee	; 0xc6ee <menu_FIP>
		  if (FIPResult==FIP_DONE)stLoyalty=mlUpdateLoyalty;
    ccf2:	88 23       	and	r24, r24
    ccf4:	11 f4       	brne	.+4      	; 0xccfa <FMenuLoyalty+0x102>
    ccf6:	82 e0       	ldi	r24, 0x02	; 2
    ccf8:	ea cf       	rjmp	.-44     	; 0xccce <FMenuLoyalty+0xd6>
		  else
		  if (FIPResult==FIP_CANCEL)stLoyalty=mlInit;
    ccfa:	82 30       	cpi	r24, 0x02	; 2
    ccfc:	09 f0       	breq	.+2      	; 0xcd00 <FMenuLoyalty+0x108>
    ccfe:	d5 c1       	rjmp	.+938    	; 0xd0aa <FMenuLoyalty+0x4b2>
    cd00:	5b c0       	rjmp	.+182    	; 0xcdb8 <FMenuLoyalty+0x1c0>
	      break;
     case mlUpdateLoyalty: 
	      lcd_clear();
    cd02:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("FIP:%s"),strFIP_ID);
    cd06:	00 d0       	rcall	.+0      	; 0xcd08 <FMenuLoyalty+0x110>
    cd08:	00 d0       	rcall	.+0      	; 0xcd0a <FMenuLoyalty+0x112>
    cd0a:	00 d0       	rcall	.+0      	; 0xcd0c <FMenuLoyalty+0x114>
    cd0c:	ed b7       	in	r30, 0x3d	; 61
    cd0e:	fe b7       	in	r31, 0x3e	; 62
    cd10:	31 96       	adiw	r30, 0x01	; 1
    cd12:	8e 01       	movw	r16, r28
    cd14:	0f 5f       	subi	r16, 0xFF	; 255
    cd16:	1f 4f       	sbci	r17, 0xFF	; 255
    cd18:	ad b7       	in	r26, 0x3d	; 61
    cd1a:	be b7       	in	r27, 0x3e	; 62
    cd1c:	12 96       	adiw	r26, 0x02	; 2
    cd1e:	1c 93       	st	X, r17
    cd20:	0e 93       	st	-X, r16
    cd22:	11 97       	sbiw	r26, 0x01	; 1
    cd24:	8e e7       	ldi	r24, 0x7E	; 126
    cd26:	9a e1       	ldi	r25, 0x1A	; 26
    cd28:	93 83       	std	Z+3, r25	; 0x03
    cd2a:	82 83       	std	Z+2, r24	; 0x02
    cd2c:	8c ee       	ldi	r24, 0xEC	; 236
    cd2e:	99 e0       	ldi	r25, 0x09	; 9
    cd30:	95 83       	std	Z+5, r25	; 0x05
    cd32:	84 83       	std	Z+4, r24	; 0x04
    cd34:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    cd38:	8d b7       	in	r24, 0x3d	; 61
    cd3a:	9e b7       	in	r25, 0x3e	; 62
    cd3c:	06 96       	adiw	r24, 0x06	; 6
    cd3e:	0f b6       	in	r0, 0x3f	; 63
    cd40:	f8 94       	cli
    cd42:	9e bf       	out	0x3e, r25	; 62
    cd44:	0f be       	out	0x3f, r0	; 63
    cd46:	8d bf       	out	0x3d, r24	; 61
    cd48:	81 e0       	ldi	r24, 0x01	; 1
    cd4a:	61 e0       	ldi	r22, 0x01	; 1
    cd4c:	4f e6       	ldi	r20, 0x6F	; 111
    cd4e:	5a e1       	ldi	r21, 0x1A	; 26
    cd50:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_print(2,1,lcdteks);
    cd54:	82 e0       	ldi	r24, 0x02	; 2
    cd56:	61 e0       	ldi	r22, 0x01	; 1
    cd58:	a8 01       	movw	r20, r16
    cd5a:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    cd5e:	84 e0       	ldi	r24, 0x04	; 4
    cd60:	61 e0       	ldi	r22, 0x01	; 1
    cd62:	4c e5       	ldi	r20, 0x5C	; 92
    cd64:	5a e1       	ldi	r21, 0x1A	; 26
    cd66:	0c c0       	rjmp	.+24     	; 0xcd80 <FMenuLoyalty+0x188>
		  IsRFIDDetected=False;
	      stLoyalty=mlInputRFID;
	      break;
	 case mlShowEnquiry:
	      lcd_clear();
    cd68:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    cd6c:	81 e0       	ldi	r24, 0x01	; 1
    cd6e:	61 e0       	ldi	r22, 0x01	; 1
    cd70:	4d e4       	ldi	r20, 0x4D	; 77
    cd72:	5a e1       	ldi	r21, 0x1A	; 26
    cd74:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    cd78:	84 e0       	ldi	r24, 0x04	; 4
    cd7a:	61 e0       	ldi	r22, 0x01	; 1
    cd7c:	4a e3       	ldi	r20, 0x3A	; 58
    cd7e:	5a e1       	ldi	r21, 0x1A	; 26
    cd80:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  IsRFIDDetected=False;
    cd84:	10 92 af 01 	sts	0x01AF, r1
		  stLoyalty=mlInputRFID;
    cd88:	85 e0       	ldi	r24, 0x05	; 5
    cd8a:	a1 cf       	rjmp	.-190    	; 0xccce <FMenuLoyalty+0xd6>
	      break;
     case mlInputRFID:
	      if (IsRFIDDetected==True){
    cd8c:	80 91 af 01 	lds	r24, 0x01AF
    cd90:	81 30       	cpi	r24, 0x01	; 1
    cd92:	29 f4       	brne	.+10     	; 0xcd9e <FMenuLoyalty+0x1a6>
		      IsRFIDDetected=False;
    cd94:	10 92 af 01 	sts	0x01AF, r1
		      stLoyalty=mlShowProsesRFID;
    cd98:	86 e0       	ldi	r24, 0x06	; 6
    cd9a:	80 93 4f 03 	sts	0x034F, r24
		  }
	 	  KeyPressed=_key_scan(1);
    cd9e:	81 e0       	ldi	r24, 0x01	; 1
    cda0:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    cda4:	80 93 4e 03 	sts	0x034E, r24
		  if (KeyPressed==_KEY_CANCEL){
    cda8:	87 3e       	cpi	r24, 0xE7	; 231
    cdaa:	49 f4       	brne	.+18     	; 0xcdbe <FMenuLoyalty+0x1c6>
		      if (IsLoyaltyUpdate==True)
    cdac:	80 91 4c 03 	lds	r24, 0x034C
    cdb0:	81 30       	cpi	r24, 0x01	; 1
    cdb2:	11 f4       	brne	.+4      	; 0xcdb8 <FMenuLoyalty+0x1c0>
			       stLoyalty=mlSelectFIP;
    cdb4:	83 e0       	ldi	r24, 0x03	; 3
    cdb6:	8b cf       	rjmp	.-234    	; 0xccce <FMenuLoyalty+0xd6>
			  else stLoyalty=mlInit;
    cdb8:	10 92 4f 03 	sts	0x034F, r1
    cdbc:	76 c1       	rjmp	.+748    	; 0xd0aa <FMenuLoyalty+0x4b2>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stLoyalty=mlExitLoyalty;
    cdbe:	87 3b       	cpi	r24, 0xB7	; 183
    cdc0:	09 f0       	breq	.+2      	; 0xcdc4 <FMenuLoyalty+0x1cc>
    cdc2:	73 c1       	rjmp	.+742    	; 0xd0aa <FMenuLoyalty+0x4b2>
    cdc4:	6a c1       	rjmp	.+724    	; 0xd09a <FMenuLoyalty+0x4a2>
	      break;
     case mlShowProsesRFID:
	      lcd_clear();
    cdc6:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("ID:%s"),strRFID);
    cdca:	00 d0       	rcall	.+0      	; 0xcdcc <FMenuLoyalty+0x1d4>
    cdcc:	00 d0       	rcall	.+0      	; 0xcdce <FMenuLoyalty+0x1d6>
    cdce:	00 d0       	rcall	.+0      	; 0xcdd0 <FMenuLoyalty+0x1d8>
    cdd0:	ed b7       	in	r30, 0x3d	; 61
    cdd2:	fe b7       	in	r31, 0x3e	; 62
    cdd4:	31 96       	adiw	r30, 0x01	; 1
    cdd6:	8e 01       	movw	r16, r28
    cdd8:	0f 5f       	subi	r16, 0xFF	; 255
    cdda:	1f 4f       	sbci	r17, 0xFF	; 255
    cddc:	ad b7       	in	r26, 0x3d	; 61
    cdde:	be b7       	in	r27, 0x3e	; 62
    cde0:	12 96       	adiw	r26, 0x02	; 2
    cde2:	1c 93       	st	X, r17
    cde4:	0e 93       	st	-X, r16
    cde6:	11 97       	sbiw	r26, 0x01	; 1
    cde8:	84 e3       	ldi	r24, 0x34	; 52
    cdea:	9a e1       	ldi	r25, 0x1A	; 26
    cdec:	93 83       	std	Z+3, r25	; 0x03
    cdee:	82 83       	std	Z+2, r24	; 0x02
    cdf0:	8c e7       	ldi	r24, 0x7C	; 124
    cdf2:	9e e0       	ldi	r25, 0x0E	; 14
    cdf4:	95 83       	std	Z+5, r25	; 0x05
    cdf6:	84 83       	std	Z+4, r24	; 0x04
    cdf8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print (1,1,lcdteks);	      
    cdfc:	8d b7       	in	r24, 0x3d	; 61
    cdfe:	9e b7       	in	r25, 0x3e	; 62
    ce00:	06 96       	adiw	r24, 0x06	; 6
    ce02:	0f b6       	in	r0, 0x3f	; 63
    ce04:	f8 94       	cli
    ce06:	9e bf       	out	0x3e, r25	; 62
    ce08:	0f be       	out	0x3f, r0	; 63
    ce0a:	8d bf       	out	0x3d, r24	; 61
    ce0c:	81 e0       	ldi	r24, 0x01	; 1
    ce0e:	61 e0       	ldi	r22, 0x01	; 1
    ce10:	a8 01       	movw	r20, r16
    ce12:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_printf(2,1,PSTR("Proses"));	      
    ce16:	82 e0       	ldi	r24, 0x02	; 2
    ce18:	61 e0       	ldi	r22, 0x01	; 1
    ce1a:	4d e2       	ldi	r20, 0x2D	; 45
    ce1c:	5a e1       	ldi	r21, 0x1A	; 26
    ce1e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  if (IsLoyaltyUpdate==True)stLoyalty=mlSendMessage24;
    ce22:	80 91 4c 03 	lds	r24, 0x034C
    ce26:	81 30       	cpi	r24, 0x01	; 1
    ce28:	11 f4       	brne	.+4      	; 0xce2e <FMenuLoyalty+0x236>
    ce2a:	88 e0       	ldi	r24, 0x08	; 8
    ce2c:	50 cf       	rjmp	.-352    	; 0xccce <FMenuLoyalty+0xd6>
		  else stLoyalty=mlSendMessage22;
    ce2e:	87 e0       	ldi	r24, 0x07	; 7
    ce30:	4e cf       	rjmp	.-356    	; 0xccce <FMenuLoyalty+0xd6>
	      break;
     case mlSendMessage22:
	      sendMessage22();
    ce32:	0e 94 de 51 	call	0xa3bc	; 0xa3bc <sendMessage22>
    ce36:	02 c0       	rjmp	.+4      	; 0xce3c <FMenuLoyalty+0x244>
		  TimSend=0;		  
          stLoyalty=mlWaitReply;
	      break;
     case mlSendMessage24:
	      sendMessage24();
    ce38:	0e 94 52 51 	call	0xa2a4	; 0xa2a4 <sendMessage24>
		  TimSend=0;		  
    ce3c:	10 92 a9 01 	sts	0x01A9, r1
    ce40:	10 92 a8 01 	sts	0x01A8, r1
          stLoyalty=mlWaitReply;
    ce44:	89 e0       	ldi	r24, 0x09	; 9
    ce46:	43 cf       	rjmp	.-378    	; 0xccce <FMenuLoyalty+0xd6>
	      break;
     case mlWaitReply:
	      if (TimSend>(TIM_SEND*3))
    ce48:	80 91 a8 01 	lds	r24, 0x01A8
    ce4c:	90 91 a9 01 	lds	r25, 0x01A9
    ce50:	4f 97       	sbiw	r24, 0x1f	; 31
    ce52:	18 f0       	brcs	.+6      	; 0xce5a <FMenuLoyalty+0x262>
		      stLoyalty=mlNoConnection;
    ce54:	8c e0       	ldi	r24, 0x0C	; 12
    ce56:	80 93 4f 03 	sts	0x034F, r24
	      if (IsMessage23==True){
    ce5a:	80 91 b9 01 	lds	r24, 0x01B9
    ce5e:	81 30       	cpi	r24, 0x01	; 1
    ce60:	39 f4       	brne	.+14     	; 0xce70 <FMenuLoyalty+0x278>
		      IsMessage23=False;
    ce62:	10 92 b9 01 	sts	0x01B9, r1
			  procMessage23();
    ce66:	0e 94 83 17 	call	0x2f06	; 0x2f06 <procMessage23>
			  stLoyalty=mlDispEnquiry;
    ce6a:	8b e0       	ldi	r24, 0x0B	; 11
    ce6c:	80 93 4f 03 	sts	0x034F, r24
		  }
	      if (IsMessage09==True){
    ce70:	80 91 ba 01 	lds	r24, 0x01BA
    ce74:	81 30       	cpi	r24, 0x01	; 1
    ce76:	39 f4       	brne	.+14     	; 0xce86 <FMenuLoyalty+0x28e>
		      IsMessage09=False;
    ce78:	10 92 ba 01 	sts	0x01BA, r1
	          procMessage09();
    ce7c:	0e 94 38 17 	call	0x2e70	; 0x2e70 <procMessage09>
              stLoyalty=mlDisplayFreeMessage;
    ce80:	8a e0       	ldi	r24, 0x0A	; 10
    ce82:	80 93 4f 03 	sts	0x034F, r24
		  }
	      if (IsMessage99==True){
    ce86:	80 91 b6 01 	lds	r24, 0x01B6
    ce8a:	81 30       	cpi	r24, 0x01	; 1
    ce8c:	09 f0       	breq	.+2      	; 0xce90 <FMenuLoyalty+0x298>
    ce8e:	0d c1       	rjmp	.+538    	; 0xd0aa <FMenuLoyalty+0x4b2>
    ce90:	1c c0       	rjmp	.+56     	; 0xceca <FMenuLoyalty+0x2d2>
              stLoyalty=mlDelayExitLoyalty;
		  }
	      break;
     case mlDisplayFreeMessage:
		  lcd_clear();
    ce92:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    ce96:	81 e0       	ldi	r24, 0x01	; 1
    ce98:	61 e0       	ldi	r22, 0x01	; 1
    ce9a:	47 ee       	ldi	r20, 0xE7	; 231
    ce9c:	5a e0       	ldi	r21, 0x0A	; 10
    ce9e:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    cea2:	82 e0       	ldi	r24, 0x02	; 2
    cea4:	61 e0       	ldi	r22, 0x01	; 1
    cea6:	46 ed       	ldi	r20, 0xD6	; 214
    cea8:	59 e0       	ldi	r21, 0x09	; 9
    ceaa:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    ceae:	83 e0       	ldi	r24, 0x03	; 3
    ceb0:	61 e0       	ldi	r22, 0x01	; 1
    ceb2:	41 e7       	ldi	r20, 0x71	; 113
    ceb4:	5a e0       	ldi	r21, 0x0A	; 10
    ceb6:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    ceba:	84 e0       	ldi	r24, 0x04	; 4
    cebc:	61 e0       	ldi	r22, 0x01	; 1
    cebe:	41 e0       	ldi	r20, 0x01	; 1
    cec0:	5e e0       	ldi	r21, 0x0E	; 14
    cec2:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  TimDisplay=0;
    cec6:	10 92 a7 01 	sts	0x01A7, r1
		  stLoyalty=mlDelayExitLoyalty;
    ceca:	8e e0       	ldi	r24, 0x0E	; 14
    cecc:	00 cf       	rjmp	.-512    	; 0xccce <FMenuLoyalty+0xd6>
	      break;
     case mlDispEnquiry:	      
	      lcd_clear();
    cece:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  RemSpaceLag(strCardID);RemSpaceLag(strCardHolder);
    ced2:	21 eb       	ldi	r18, 0xB1	; 177
    ced4:	c2 2e       	mov	r12, r18
    ced6:	2d e0       	ldi	r18, 0x0D	; 13
    ced8:	d2 2e       	mov	r13, r18
    ceda:	c6 01       	movw	r24, r12
    cedc:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
    cee0:	94 e0       	ldi	r25, 0x04	; 4
    cee2:	e9 2e       	mov	r14, r25
    cee4:	95 e0       	ldi	r25, 0x05	; 5
    cee6:	f9 2e       	mov	r15, r25
    cee8:	c7 01       	movw	r24, r14
    ceea:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("%s:%s"),strCardID,strCardHolder);
    ceee:	ad b7       	in	r26, 0x3d	; 61
    cef0:	be b7       	in	r27, 0x3e	; 62
    cef2:	18 97       	sbiw	r26, 0x08	; 8
    cef4:	0f b6       	in	r0, 0x3f	; 63
    cef6:	f8 94       	cli
    cef8:	be bf       	out	0x3e, r27	; 62
    cefa:	0f be       	out	0x3f, r0	; 63
    cefc:	ad bf       	out	0x3d, r26	; 61
    cefe:	ed b7       	in	r30, 0x3d	; 61
    cf00:	fe b7       	in	r31, 0x3e	; 62
    cf02:	31 96       	adiw	r30, 0x01	; 1
    cf04:	8e 01       	movw	r16, r28
    cf06:	0f 5f       	subi	r16, 0xFF	; 255
    cf08:	1f 4f       	sbci	r17, 0xFF	; 255
    cf0a:	12 96       	adiw	r26, 0x02	; 2
    cf0c:	1c 93       	st	X, r17
    cf0e:	0e 93       	st	-X, r16
    cf10:	11 97       	sbiw	r26, 0x01	; 1
    cf12:	87 e2       	ldi	r24, 0x27	; 39
    cf14:	9a e1       	ldi	r25, 0x1A	; 26
    cf16:	93 83       	std	Z+3, r25	; 0x03
    cf18:	82 83       	std	Z+2, r24	; 0x02
    cf1a:	d5 82       	std	Z+5, r13	; 0x05
    cf1c:	c4 82       	std	Z+4, r12	; 0x04
    cf1e:	f7 82       	std	Z+7, r15	; 0x07
    cf20:	e6 82       	std	Z+6, r14	; 0x06
    cf22:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(1,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    cf26:	8d b7       	in	r24, 0x3d	; 61
    cf28:	9e b7       	in	r25, 0x3e	; 62
    cf2a:	08 96       	adiw	r24, 0x08	; 8
    cf2c:	0f b6       	in	r0, 0x3f	; 63
    cf2e:	f8 94       	cli
    cf30:	9e bf       	out	0x3e, r25	; 62
    cf32:	0f be       	out	0x3f, r0	; 63
    cf34:	8d bf       	out	0x3d, r24	; 61
    cf36:	81 e0       	ldi	r24, 0x01	; 1
    cf38:	61 e0       	ldi	r22, 0x01	; 1
    cf3a:	a8 01       	movw	r20, r16
    cf3c:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    cf40:	8a e8       	ldi	r24, 0x8A	; 138
    cf42:	e8 2e       	mov	r14, r24
    cf44:	8a e0       	ldi	r24, 0x0A	; 10
    cf46:	f8 2e       	mov	r15, r24
    cf48:	c7 01       	movw	r24, r14
    cf4a:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Points:%s"),strLoyCurrentPoints);
    cf4e:	00 d0       	rcall	.+0      	; 0xcf50 <FMenuLoyalty+0x358>
    cf50:	00 d0       	rcall	.+0      	; 0xcf52 <FMenuLoyalty+0x35a>
    cf52:	00 d0       	rcall	.+0      	; 0xcf54 <FMenuLoyalty+0x35c>
    cf54:	ed b7       	in	r30, 0x3d	; 61
    cf56:	fe b7       	in	r31, 0x3e	; 62
    cf58:	31 96       	adiw	r30, 0x01	; 1
    cf5a:	ad b7       	in	r26, 0x3d	; 61
    cf5c:	be b7       	in	r27, 0x3e	; 62
    cf5e:	12 96       	adiw	r26, 0x02	; 2
    cf60:	1c 93       	st	X, r17
    cf62:	0e 93       	st	-X, r16
    cf64:	11 97       	sbiw	r26, 0x01	; 1
    cf66:	8d e1       	ldi	r24, 0x1D	; 29
    cf68:	9a e1       	ldi	r25, 0x1A	; 26
    cf6a:	93 83       	std	Z+3, r25	; 0x03
    cf6c:	82 83       	std	Z+2, r24	; 0x02
    cf6e:	f5 82       	std	Z+5, r15	; 0x05
    cf70:	e4 82       	std	Z+4, r14	; 0x04
    cf72:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(2,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    cf76:	8d b7       	in	r24, 0x3d	; 61
    cf78:	9e b7       	in	r25, 0x3e	; 62
    cf7a:	06 96       	adiw	r24, 0x06	; 6
    cf7c:	0f b6       	in	r0, 0x3f	; 63
    cf7e:	f8 94       	cli
    cf80:	9e bf       	out	0x3e, r25	; 62
    cf82:	0f be       	out	0x3f, r0	; 63
    cf84:	8d bf       	out	0x3d, r24	; 61
    cf86:	82 e0       	ldi	r24, 0x02	; 2
    cf88:	61 e0       	ldi	r22, 0x01	; 1
    cf8a:	a8 01       	movw	r20, r16
    cf8c:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    cf90:	c7 01       	movw	r24, r14
    cf92:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("CM Amt:%s"),strLoyCurrMonConsumeA);
    cf96:	00 d0       	rcall	.+0      	; 0xcf98 <FMenuLoyalty+0x3a0>
    cf98:	00 d0       	rcall	.+0      	; 0xcf9a <FMenuLoyalty+0x3a2>
    cf9a:	00 d0       	rcall	.+0      	; 0xcf9c <FMenuLoyalty+0x3a4>
    cf9c:	ed b7       	in	r30, 0x3d	; 61
    cf9e:	fe b7       	in	r31, 0x3e	; 62
    cfa0:	31 96       	adiw	r30, 0x01	; 1
    cfa2:	ad b7       	in	r26, 0x3d	; 61
    cfa4:	be b7       	in	r27, 0x3e	; 62
    cfa6:	12 96       	adiw	r26, 0x02	; 2
    cfa8:	1c 93       	st	X, r17
    cfaa:	0e 93       	st	-X, r16
    cfac:	11 97       	sbiw	r26, 0x01	; 1
    cfae:	83 e1       	ldi	r24, 0x13	; 19
    cfb0:	9a e1       	ldi	r25, 0x1A	; 26
    cfb2:	93 83       	std	Z+3, r25	; 0x03
    cfb4:	82 83       	std	Z+2, r24	; 0x02
    cfb6:	8e ea       	ldi	r24, 0xAE	; 174
    cfb8:	95 e0       	ldi	r25, 0x05	; 5
    cfba:	95 83       	std	Z+5, r25	; 0x05
    cfbc:	84 83       	std	Z+4, r24	; 0x04
    cfbe:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(3,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    cfc2:	8d b7       	in	r24, 0x3d	; 61
    cfc4:	9e b7       	in	r25, 0x3e	; 62
    cfc6:	06 96       	adiw	r24, 0x06	; 6
    cfc8:	0f b6       	in	r0, 0x3f	; 63
    cfca:	f8 94       	cli
    cfcc:	9e bf       	out	0x3e, r25	; 62
    cfce:	0f be       	out	0x3f, r0	; 63
    cfd0:	8d bf       	out	0x3d, r24	; 61
    cfd2:	83 e0       	ldi	r24, 0x03	; 3
    cfd4:	61 e0       	ldi	r22, 0x01	; 1
    cfd6:	a8 01       	movw	r20, r16
    cfd8:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    cfdc:	c7 01       	movw	r24, r14
    cfde:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Cm Vol:%s"),strLoyCurrMonConsumeV);
    cfe2:	00 d0       	rcall	.+0      	; 0xcfe4 <FMenuLoyalty+0x3ec>
    cfe4:	00 d0       	rcall	.+0      	; 0xcfe6 <FMenuLoyalty+0x3ee>
    cfe6:	00 d0       	rcall	.+0      	; 0xcfe8 <FMenuLoyalty+0x3f0>
    cfe8:	ed b7       	in	r30, 0x3d	; 61
    cfea:	fe b7       	in	r31, 0x3e	; 62
    cfec:	31 96       	adiw	r30, 0x01	; 1
    cfee:	ad b7       	in	r26, 0x3d	; 61
    cff0:	be b7       	in	r27, 0x3e	; 62
    cff2:	12 96       	adiw	r26, 0x02	; 2
    cff4:	1c 93       	st	X, r17
    cff6:	0e 93       	st	-X, r16
    cff8:	11 97       	sbiw	r26, 0x01	; 1
    cffa:	89 e0       	ldi	r24, 0x09	; 9
    cffc:	9a e1       	ldi	r25, 0x1A	; 26
    cffe:	93 83       	std	Z+3, r25	; 0x03
    d000:	82 83       	std	Z+2, r24	; 0x02
    d002:	88 e1       	ldi	r24, 0x18	; 24
    d004:	9e e0       	ldi	r25, 0x0E	; 14
    d006:	95 83       	std	Z+5, r25	; 0x05
    d008:	84 83       	std	Z+4, r24	; 0x04
    d00a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(4,1,lcdteks);
    d00e:	8d b7       	in	r24, 0x3d	; 61
    d010:	9e b7       	in	r25, 0x3e	; 62
    d012:	06 96       	adiw	r24, 0x06	; 6
    d014:	0f b6       	in	r0, 0x3f	; 63
    d016:	f8 94       	cli
    d018:	9e bf       	out	0x3e, r25	; 62
    d01a:	0f be       	out	0x3f, r0	; 63
    d01c:	8d bf       	out	0x3d, r24	; 61
    d01e:	84 e0       	ldi	r24, 0x04	; 4
    d020:	61 e0       	ldi	r22, 0x01	; 1
    d022:	a8 01       	movw	r20, r16
    d024:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  TimDisplay=0;
    d028:	10 92 a7 01 	sts	0x01A7, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    d02c:	e1 99       	sbic	0x1c, 1	; 28
    d02e:	fe cf       	rjmp	.-4      	; 0xd02c <FMenuLoyalty+0x434>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    d030:	88 e3       	ldi	r24, 0x38	; 56
    d032:	90 e0       	ldi	r25, 0x00	; 0
    d034:	9f bb       	out	0x1f, r25	; 31
    d036:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    d038:	e0 9a       	sbi	0x1c, 0	; 28
    d03a:	8d b3       	in	r24, 0x1d	; 29

		  if (eeprom_read_byte(&DefNotifScreen)==1) {
    d03c:	81 30       	cpi	r24, 0x01	; 1
    d03e:	09 f0       	breq	.+2      	; 0xd042 <FMenuLoyalty+0x44a>
    d040:	44 cf       	rjmp	.-376    	; 0xceca <FMenuLoyalty+0x2d2>
		      stLoyalty=mlPressAnyKey;
    d042:	8d e0       	ldi	r24, 0x0D	; 13
    d044:	80 93 4f 03 	sts	0x034F, r24
			  lcd_printf(2,1,PSTR("Press Any Key"));
    d048:	82 e0       	ldi	r24, 0x02	; 2
    d04a:	61 e0       	ldi	r22, 0x01	; 1
    d04c:	4b ef       	ldi	r20, 0xFB	; 251
    d04e:	59 e1       	ldi	r21, 0x19	; 25
    d050:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
    d054:	2a c0       	rjmp	.+84     	; 0xd0aa <FMenuLoyalty+0x4b2>
          } else stLoyalty=mlDelayExitLoyalty;
		  break;
     case mlPressAnyKey:
	      KeyPressed=_key_scan(1);
    d056:	81 e0       	ldi	r24, 0x01	; 1
    d058:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    d05c:	80 93 4e 03 	sts	0x034E, r24
	      KeyChar=_key_btn(KeyPressed);
    d060:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
	      switch(KeyChar){		  
    d064:	83 32       	cpi	r24, 0x23	; 35
    d066:	c9 f0       	breq	.+50     	; 0xd09a <FMenuLoyalty+0x4a2>
    d068:	8a 32       	cpi	r24, 0x2A	; 42
    d06a:	f9 f4       	brne	.+62     	; 0xd0aa <FMenuLoyalty+0x4b2>
    d06c:	16 c0       	rjmp	.+44     	; 0xd09a <FMenuLoyalty+0x4a2>
               stLoyalty=mlExitLoyalty;
		       break;		  
		  }
	      break;
     case mlNoConnection:
	      lcd_clear();
    d06e:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
    d072:	82 e0       	ldi	r24, 0x02	; 2
    d074:	61 e0       	ldi	r22, 0x01	; 1
    d076:	4d ee       	ldi	r20, 0xED	; 237
    d078:	59 e1       	ldi	r21, 0x19	; 25
    d07a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
    d07e:	83 e0       	ldi	r24, 0x03	; 3
    d080:	61 e0       	ldi	r22, 0x01	; 1
    d082:	4f ed       	ldi	r20, 0xDF	; 223
    d084:	59 e1       	ldi	r21, 0x19	; 25
    d086:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  TimDisplay=5;
    d08a:	85 e0       	ldi	r24, 0x05	; 5
    d08c:	80 93 a7 01 	sts	0x01A7, r24
    d090:	1c cf       	rjmp	.-456    	; 0xceca <FMenuLoyalty+0x2d2>
		  stLoyalty=mlDelayExitLoyalty;
	      break;
     case mlDelayExitLoyalty:
          if(TimDisplay>=10)stLoyalty=mlExitLoyalty;
    d092:	80 91 a7 01 	lds	r24, 0x01A7
    d096:	8a 30       	cpi	r24, 0x0A	; 10
    d098:	40 f0       	brcs	.+16     	; 0xd0aa <FMenuLoyalty+0x4b2>
    d09a:	8f e0       	ldi	r24, 0x0F	; 15
    d09c:	18 ce       	rjmp	.-976    	; 0xccce <FMenuLoyalty+0xd6>
	      break;
	 case mlExitLoyalty:
	      lcd_clear();
    d09e:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
	      stLoyalty=mlInit;
    d0a2:	10 92 4f 03 	sts	0x034F, r1
    d0a6:	81 e0       	ldi	r24, 0x01	; 1
    d0a8:	01 c0       	rjmp	.+2      	; 0xd0ac <FMenuLoyalty+0x4b4>
    d0aa:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 return Result;
}
    d0ac:	64 96       	adiw	r28, 0x14	; 20
    d0ae:	0f b6       	in	r0, 0x3f	; 63
    d0b0:	f8 94       	cli
    d0b2:	de bf       	out	0x3e, r29	; 62
    d0b4:	0f be       	out	0x3f, r0	; 63
    d0b6:	cd bf       	out	0x3d, r28	; 61
    d0b8:	cf 91       	pop	r28
    d0ba:	df 91       	pop	r29
    d0bc:	1f 91       	pop	r17
    d0be:	0f 91       	pop	r16
    d0c0:	ff 90       	pop	r15
    d0c2:	ef 90       	pop	r14
    d0c4:	df 90       	pop	r13
    d0c6:	cf 90       	pop	r12
    d0c8:	08 95       	ret

0000d0ca <ValidateRestoreCode>:
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
     WrapCode(strKeyStamp);
}

char ValidateRestoreCode(char *sKeyStamp, char *sRestoreCode){//==RC_VALID
    d0ca:	ef 92       	push	r14
    d0cc:	ff 92       	push	r15
    d0ce:	0f 93       	push	r16
    d0d0:	1f 93       	push	r17
    d0d2:	cf 93       	push	r28
    d0d4:	df 93       	push	r29
    d0d6:	ec 01       	movw	r28, r24
    d0d8:	7b 01       	movw	r14, r22

	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //_uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
    d0da:	08 81       	ld	r16, Y
    d0dc:	00 53       	subi	r16, 0x30	; 48
    d0de:	10 e0       	ldi	r17, 0x00	; 0
    d0e0:	04 c0       	rjmp	.+8      	; 0xd0ea <ValidateRestoreCode+0x20>
	 for (i=0;i<nSum;i++){
         WrapCode(sKeyStamp);
    d0e2:	ce 01       	movw	r24, r28
    d0e4:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <WrapCode>
	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //_uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
	 for (i=0;i<nSum;i++){
    d0e8:	1f 5f       	subi	r17, 0xFF	; 255
    d0ea:	10 17       	cp	r17, r16
    d0ec:	d0 f3       	brcs	.-12     	; 0xd0e2 <ValidateRestoreCode+0x18>
	 //_uart_print(1,1,strSend);
     
	 //sprintf_P(strSend,PSTR("WrapStamp:%s"),sRestoreCode);
	 //_uart_print(1,1,strSend);

	 if (strcmp(sKeyStamp,sRestoreCode)==0)
    d0ee:	ce 01       	movw	r24, r28
    d0f0:	b7 01       	movw	r22, r14
    d0f2:	0e 94 e4 b3 	call	0x167c8	; 0x167c8 <strcmp>
    d0f6:	00 97       	sbiw	r24, 0x00	; 0
    d0f8:	11 f0       	breq	.+4      	; 0xd0fe <ValidateRestoreCode+0x34>
    d0fa:	82 e0       	ldi	r24, 0x02	; 2
    d0fc:	01 c0       	rjmp	.+2      	; 0xd100 <ValidateRestoreCode+0x36>
    d0fe:	81 e0       	ldi	r24, 0x01	; 1
	     Result=RC_VALID;	 
     else Result=RC_INVALID;

   return Result;
}
    d100:	df 91       	pop	r29
    d102:	cf 91       	pop	r28
    d104:	1f 91       	pop	r17
    d106:	0f 91       	pop	r16
    d108:	ff 90       	pop	r15
    d10a:	ef 90       	pop	r14
    d10c:	08 95       	ret

0000d10e <ValidateGeniusCode>:
          }
	 }sTemp[iAdd]=0;
	 sprintf_P(strSource,PSTR("%s"),sTemp);
}

char ValidateGeniusCode(char *sDate, char *sGenCode){//==GC_VALID
    d10e:	ef 92       	push	r14
    d110:	ff 92       	push	r15
    d112:	0f 93       	push	r16
    d114:	1f 93       	push	r17
    d116:	df 93       	push	r29
    d118:	cf 93       	push	r28
    d11a:	cd b7       	in	r28, 0x3d	; 61
    d11c:	de b7       	in	r29, 0x3e	; 62
    d11e:	2a 97       	sbiw	r28, 0x0a	; 10
    d120:	0f b6       	in	r0, 0x3f	; 63
    d122:	f8 94       	cli
    d124:	de bf       	out	0x3e, r29	; 62
    d126:	0f be       	out	0x3f, r0	; 63
    d128:	cd bf       	out	0x3d, r28	; 61
    d12a:	7b 01       	movw	r14, r22

         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("[%s]"),sGenCode); 
         _uart_print(1,1,strSend);
		 #endif
	 if (strlen(sGenCode)==8){//Length musti  8
    d12c:	fb 01       	movw	r30, r22
    d12e:	01 90       	ld	r0, Z+
    d130:	00 20       	and	r0, r0
    d132:	e9 f7       	brne	.-6      	; 0xd12e <ValidateGeniusCode+0x20>
    d134:	39 97       	sbiw	r30, 0x09	; 9
    d136:	e6 17       	cp	r30, r22
    d138:	f7 07       	cpc	r31, r23
    d13a:	11 f0       	breq	.+4      	; 0xd140 <ValidateGeniusCode+0x32>
    d13c:	80 e0       	ldi	r24, 0x00	; 0
    d13e:	11 c0       	rjmp	.+34     	; 0xd162 <ValidateGeniusCode+0x54>
	     //sDate: 05012001		 
		 GenerateGeniusCode(sDate,sGenCode[0],sAutoGen);
    d140:	fb 01       	movw	r30, r22
    d142:	60 81       	ld	r22, Z
    d144:	8e 01       	movw	r16, r28
    d146:	0f 5f       	subi	r16, 0xFF	; 255
    d148:	1f 4f       	sbci	r17, 0xFF	; 255
    d14a:	a8 01       	movw	r20, r16
    d14c:	0e 94 f0 2e 	call	0x5de0	; 0x5de0 <GenerateGeniusCode>
         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("%s|%s"),sAutoGen,sGenCode); 
         _uart_print(1,1,strSend);
		 #endif

         if (strcmp(sAutoGen,sGenCode)==0)
    d150:	c8 01       	movw	r24, r16
    d152:	b7 01       	movw	r22, r14
    d154:	0e 94 e4 b3 	call	0x167c8	; 0x167c8 <strcmp>
    d158:	00 97       	sbiw	r24, 0x00	; 0
    d15a:	11 f0       	breq	.+4      	; 0xd160 <ValidateGeniusCode+0x52>
    d15c:	82 e0       	ldi	r24, 0x02	; 2
    d15e:	01 c0       	rjmp	.+2      	; 0xd162 <ValidateGeniusCode+0x54>
    d160:	81 e0       	ldi	r24, 0x01	; 1
         else Result=GC_INVALID;
	 }


   return Result;
}
    d162:	2a 96       	adiw	r28, 0x0a	; 10
    d164:	0f b6       	in	r0, 0x3f	; 63
    d166:	f8 94       	cli
    d168:	de bf       	out	0x3e, r29	; 62
    d16a:	0f be       	out	0x3f, r0	; 63
    d16c:	cd bf       	out	0x3d, r28	; 61
    d16e:	cf 91       	pop	r28
    d170:	df 91       	pop	r29
    d172:	1f 91       	pop	r17
    d174:	0f 91       	pop	r16
    d176:	ff 90       	pop	r15
    d178:	ef 90       	pop	r14
    d17a:	08 95       	ret

0000d17c <FMenuSettingServerIP>:
		       break;     
		  }//EndSwitch	 
    return Result;
}

char FMenuSettingServerIP(){
    d17c:	0f 93       	push	r16
    d17e:	1f 93       	push	r17
    d180:	df 93       	push	r29
    d182:	cf 93       	push	r28
    d184:	cd b7       	in	r28, 0x3d	; 61
    d186:	de b7       	in	r29, 0x3e	; 62
    d188:	64 97       	sbiw	r28, 0x14	; 20
    d18a:	0f b6       	in	r0, 0x3f	; 63
    d18c:	f8 94       	cli
    d18e:	de bf       	out	0x3e, r29	; 62
    d190:	0f be       	out	0x3f, r0	; 63
    d192:	cd bf       	out	0x3d, r28	; 61
     //Server IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
	 Result=MENU_NONE;
    d194:	10 92 01 03 	sts	0x0301, r1
     switch(stClientIP){
    d198:	80 91 58 01 	lds	r24, 0x0158
    d19c:	82 30       	cpi	r24, 0x02	; 2
    d19e:	09 f4       	brne	.+2      	; 0xd1a2 <FMenuSettingServerIP+0x26>
    d1a0:	7b c0       	rjmp	.+246    	; 0xd298 <FMenuSettingServerIP+0x11c>
    d1a2:	83 30       	cpi	r24, 0x03	; 3
    d1a4:	20 f4       	brcc	.+8      	; 0xd1ae <FMenuSettingServerIP+0x32>
    d1a6:	81 30       	cpi	r24, 0x01	; 1
    d1a8:	09 f0       	breq	.+2      	; 0xd1ac <FMenuSettingServerIP+0x30>
    d1aa:	65 c2       	rjmp	.+1226   	; 0xd676 <FMenuSettingServerIP+0x4fa>
    d1ac:	07 c0       	rjmp	.+14     	; 0xd1bc <FMenuSettingServerIP+0x40>
    d1ae:	83 30       	cpi	r24, 0x03	; 3
    d1b0:	09 f4       	brne	.+2      	; 0xd1b4 <FMenuSettingServerIP+0x38>
    d1b2:	5c c2       	rjmp	.+1208   	; 0xd66c <FMenuSettingServerIP+0x4f0>
    d1b4:	84 30       	cpi	r24, 0x04	; 4
    d1b6:	09 f0       	breq	.+2      	; 0xd1ba <FMenuSettingServerIP+0x3e>
    d1b8:	5e c2       	rjmp	.+1212   	; 0xd676 <FMenuSettingServerIP+0x4fa>
    d1ba:	4a c2       	rjmp	.+1172   	; 0xd650 <FMenuSettingServerIP+0x4d4>
		  case cipInit:
			   lcd_clear();
    d1bc:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
	           lcd_printf(1,1,PSTR("Server IP"));
    d1c0:	81 e0       	ldi	r24, 0x01	; 1
    d1c2:	61 e0       	ldi	r22, 0x01	; 1
    d1c4:	47 ec       	ldi	r20, 0xC7	; 199
    d1c6:	52 e1       	ldi	r21, 0x12	; 18
    d1c8:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d1cc:	88 ef       	ldi	r24, 0xF8	; 248
    d1ce:	92 e0       	ldi	r25, 0x02	; 2
    d1d0:	6c e2       	ldi	r22, 0x2C	; 44
    d1d2:	70 e0       	ldi	r23, 0x00	; 0
    d1d4:	44 e0       	ldi	r20, 0x04	; 4
    d1d6:	50 e0       	ldi	r21, 0x00	; 0
    d1d8:	25 ed       	ldi	r18, 0xD5	; 213
    d1da:	32 e1       	ldi	r19, 0x12	; 18
    d1dc:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    d1e0:	8d b7       	in	r24, 0x3d	; 61
    d1e2:	9e b7       	in	r25, 0x3e	; 62
    d1e4:	0c 97       	sbiw	r24, 0x0c	; 12
    d1e6:	0f b6       	in	r0, 0x3f	; 63
    d1e8:	f8 94       	cli
    d1ea:	9e bf       	out	0x3e, r25	; 62
    d1ec:	0f be       	out	0x3f, r0	; 63
    d1ee:	8d bf       	out	0x3d, r24	; 61
    d1f0:	ed b7       	in	r30, 0x3d	; 61
    d1f2:	fe b7       	in	r31, 0x3e	; 62
    d1f4:	31 96       	adiw	r30, 0x01	; 1
    d1f6:	8e 01       	movw	r16, r28
    d1f8:	0f 5f       	subi	r16, 0xFF	; 255
    d1fa:	1f 4f       	sbci	r17, 0xFF	; 255
    d1fc:	ad b7       	in	r26, 0x3d	; 61
    d1fe:	be b7       	in	r27, 0x3e	; 62
    d200:	12 96       	adiw	r26, 0x02	; 2
    d202:	1c 93       	st	X, r17
    d204:	0e 93       	st	-X, r16
    d206:	11 97       	sbiw	r26, 0x01	; 1
    d208:	86 eb       	ldi	r24, 0xB6	; 182
    d20a:	92 e1       	ldi	r25, 0x12	; 18
    d20c:	93 83       	std	Z+3, r25	; 0x03
    d20e:	82 83       	std	Z+2, r24	; 0x02
    d210:	80 91 f8 02 	lds	r24, 0x02F8
    d214:	84 83       	std	Z+4, r24	; 0x04
    d216:	15 82       	std	Z+5, r1	; 0x05
    d218:	80 91 f9 02 	lds	r24, 0x02F9
    d21c:	86 83       	std	Z+6, r24	; 0x06
    d21e:	17 82       	std	Z+7, r1	; 0x07
    d220:	80 91 fa 02 	lds	r24, 0x02FA
    d224:	80 87       	std	Z+8, r24	; 0x08
    d226:	11 86       	std	Z+9, r1	; 0x09
    d228:	80 91 fb 02 	lds	r24, 0x02FB
    d22c:	82 87       	std	Z+10, r24	; 0x0a
    d22e:	13 86       	std	Z+11, r1	; 0x0b
    d230:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    d234:	ed b7       	in	r30, 0x3d	; 61
    d236:	fe b7       	in	r31, 0x3e	; 62
    d238:	3c 96       	adiw	r30, 0x0c	; 12
    d23a:	0f b6       	in	r0, 0x3f	; 63
    d23c:	f8 94       	cli
    d23e:	fe bf       	out	0x3e, r31	; 62
    d240:	0f be       	out	0x3f, r0	; 63
    d242:	ed bf       	out	0x3d, r30	; 61
    d244:	82 e0       	ldi	r24, 0x02	; 2
    d246:	61 e0       	ldi	r22, 0x01	; 1
    d248:	a8 01       	movw	r20, r16
    d24a:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    d24e:	83 e0       	ldi	r24, 0x03	; 3
    d250:	61 e0       	ldi	r22, 0x01	; 1
    d252:	41 ea       	ldi	r20, 0xA1	; 161
    d254:	52 e1       	ldi	r21, 0x12	; 18
    d256:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    d25a:	84 e0       	ldi	r24, 0x04	; 4
    d25c:	61 e0       	ldi	r22, 0x01	; 1
    d25e:	4c e8       	ldi	r20, 0x8C	; 140
    d260:	52 e1       	ldi	r21, 0x12	; 18
    d262:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
               iLoop=0;
    d266:	10 92 f7 02 	sts	0x02F7, r1
    d26a:	10 92 f6 02 	sts	0x02F6, r1
			   y=3,x=8;
    d26e:	83 e0       	ldi	r24, 0x03	; 3
    d270:	80 93 fe 02 	sts	0x02FE, r24
    d274:	88 e0       	ldi	r24, 0x08	; 8
    d276:	80 93 ff 02 	sts	0x02FF, r24
			   iInput=0; iBlok=0;
    d27a:	10 92 fd 02 	sts	0x02FD, r1
    d27e:	10 92 f5 02 	sts	0x02F5, r1
    d282:	10 92 f4 02 	sts	0x02F4, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d286:	80 e3       	ldi	r24, 0x30	; 48
    d288:	80 93 03 03 	sts	0x0303, r24
    d28c:	80 93 04 03 	sts	0x0304, r24
    d290:	80 93 05 03 	sts	0x0305, r24
			   stClientIP=cipInputIP; 
    d294:	82 e0       	ldi	r24, 0x02	; 2
    d296:	e7 c1       	rjmp	.+974    	; 0xd666 <FMenuSettingServerIP+0x4ea>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    d298:	80 91 f6 02 	lds	r24, 0x02F6
    d29c:	90 91 f7 02 	lds	r25, 0x02F7
    d2a0:	01 96       	adiw	r24, 0x01	; 1
    d2a2:	90 93 f7 02 	sts	0x02F7, r25
    d2a6:	80 93 f6 02 	sts	0x02F6, r24
			   if ((iLoop%2000)==0){
    d2aa:	60 ed       	ldi	r22, 0xD0	; 208
    d2ac:	77 e0       	ldi	r23, 0x07	; 7
    d2ae:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
    d2b2:	89 2b       	or	r24, r25
    d2b4:	81 f4       	brne	.+32     	; 0xd2d6 <FMenuSettingServerIP+0x15a>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    d2b6:	80 91 f4 02 	lds	r24, 0x02F4
    d2ba:	90 91 f5 02 	lds	r25, 0x02F5
    d2be:	88 0f       	add	r24, r24
    d2c0:	99 1f       	adc	r25, r25
    d2c2:	88 0f       	add	r24, r24
    d2c4:	99 1f       	adc	r25, r25
    d2c6:	60 91 ff 02 	lds	r22, 0x02FF
    d2ca:	68 0f       	add	r22, r24
    d2cc:	80 91 fe 02 	lds	r24, 0x02FE
    d2d0:	4f e5       	ldi	r20, 0x5F	; 95
    d2d2:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    d2d6:	80 91 f6 02 	lds	r24, 0x02F6
    d2da:	90 91 f7 02 	lds	r25, 0x02F7
    d2de:	60 ed       	ldi	r22, 0xD0	; 208
    d2e0:	77 e0       	ldi	r23, 0x07	; 7
    d2e2:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
    d2e6:	88 5e       	subi	r24, 0xE8	; 232
    d2e8:	93 40       	sbci	r25, 0x03	; 3
    d2ea:	81 f4       	brne	.+32     	; 0xd30c <FMenuSettingServerIP+0x190>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    d2ec:	80 91 f4 02 	lds	r24, 0x02F4
    d2f0:	90 91 f5 02 	lds	r25, 0x02F5
    d2f4:	88 0f       	add	r24, r24
    d2f6:	99 1f       	adc	r25, r25
    d2f8:	88 0f       	add	r24, r24
    d2fa:	99 1f       	adc	r25, r25
    d2fc:	60 91 ff 02 	lds	r22, 0x02FF
    d300:	68 0f       	add	r22, r24
    d302:	80 91 fe 02 	lds	r24, 0x02FE
    d306:	40 e2       	ldi	r20, 0x20	; 32
    d308:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    d30c:	81 e0       	ldi	r24, 0x01	; 1
    d30e:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    d312:	80 93 fc 02 	sts	0x02FC, r24
			   keyChar=_key_btn(keyPressed);
    d316:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
    d31a:	28 2f       	mov	r18, r24
    d31c:	80 93 00 03 	sts	0x0300, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    d320:	80 53       	subi	r24, 0x30	; 48
    d322:	8a 30       	cpi	r24, 0x0A	; 10
    d324:	08 f0       	brcs	.+2      	; 0xd328 <FMenuSettingServerIP+0x1ac>
    d326:	d6 c0       	rjmp	.+428    	; 0xd4d4 <FMenuSettingServerIP+0x358>
    d328:	80 e5       	ldi	r24, 0x50	; 80
    d32a:	93 ec       	ldi	r25, 0xC3	; 195
    d32c:	01 97       	sbiw	r24, 0x01	; 1
    d32e:	f1 f7       	brne	.-4      	; 0xd32c <FMenuSettingServerIP+0x1b0>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    d330:	80 91 fd 02 	lds	r24, 0x02FD
    d334:	e8 2f       	mov	r30, r24
    d336:	f0 e0       	ldi	r31, 0x00	; 0
    d338:	ed 5f       	subi	r30, 0xFD	; 253
    d33a:	fc 4f       	sbci	r31, 0xFC	; 252
    d33c:	20 83       	st	Z, r18
				   iInput++;                    
    d33e:	8f 5f       	subi	r24, 0xFF	; 255
    d340:	80 93 fd 02 	sts	0x02FD, r24
				   for (i=1;i<(iInput+1);i++){
    d344:	81 e0       	ldi	r24, 0x01	; 1
    d346:	1c c0       	rjmp	.+56     	; 0xd380 <FMenuSettingServerIP+0x204>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    d348:	80 91 ff 02 	lds	r24, 0x02FF
    d34c:	68 0f       	add	r22, r24
    d34e:	63 50       	subi	r22, 0x03	; 3
    d350:	80 91 f4 02 	lds	r24, 0x02F4
    d354:	90 91 f5 02 	lds	r25, 0x02F5
    d358:	88 0f       	add	r24, r24
    d35a:	99 1f       	adc	r25, r25
    d35c:	88 0f       	add	r24, r24
    d35e:	99 1f       	adc	r25, r25
    d360:	68 0f       	add	r22, r24
    d362:	80 91 fe 02 	lds	r24, 0x02FE
    d366:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
    d36a:	e0 91 02 03 	lds	r30, 0x0302
    d36e:	f0 e0       	ldi	r31, 0x00	; 0
    d370:	ee 5f       	subi	r30, 0xFE	; 254
    d372:	fc 4f       	sbci	r31, 0xFC	; 252
    d374:	80 81       	ld	r24, Z
    d376:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    d37a:	80 91 02 03 	lds	r24, 0x0302
    d37e:	8f 5f       	subi	r24, 0xFF	; 255
    d380:	80 93 02 03 	sts	0x0302, r24
    d384:	70 91 fd 02 	lds	r23, 0x02FD
    d388:	60 91 02 03 	lds	r22, 0x0302
    d38c:	27 2f       	mov	r18, r23
    d38e:	30 e0       	ldi	r19, 0x00	; 0
    d390:	86 2f       	mov	r24, r22
    d392:	90 e0       	ldi	r25, 0x00	; 0
    d394:	28 17       	cp	r18, r24
    d396:	39 07       	cpc	r19, r25
    d398:	bc f6       	brge	.-82     	; 0xd348 <FMenuSettingServerIP+0x1cc>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    d39a:	73 30       	cpi	r23, 0x03	; 3
    d39c:	08 f4       	brcc	.+2      	; 0xd3a0 <FMenuSettingServerIP+0x224>
    d39e:	91 c0       	rjmp	.+290    	; 0xd4c2 <FMenuSettingServerIP+0x346>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d3a0:	40 91 f4 02 	lds	r20, 0x02F4
    d3a4:	50 91 f5 02 	lds	r21, 0x02F5
    d3a8:	fa 01       	movw	r30, r20
    d3aa:	e8 50       	subi	r30, 0x08	; 8
    d3ac:	fd 4f       	sbci	r31, 0xFD	; 253
    d3ae:	20 91 05 03 	lds	r18, 0x0305
    d3b2:	20 5d       	subi	r18, 0xD0	; 208
    d3b4:	80 91 03 03 	lds	r24, 0x0303
    d3b8:	34 e6       	ldi	r19, 0x64	; 100
    d3ba:	83 9f       	mul	r24, r19
    d3bc:	c0 01       	movw	r24, r0
    d3be:	11 24       	eor	r1, r1
    d3c0:	28 0f       	add	r18, r24
    d3c2:	80 91 04 03 	lds	r24, 0x0304
    d3c6:	3a e0       	ldi	r19, 0x0A	; 10
    d3c8:	83 9f       	mul	r24, r19
    d3ca:	c0 01       	movw	r24, r0
    d3cc:	11 24       	eor	r1, r1
    d3ce:	28 0f       	add	r18, r24
    d3d0:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d3d2:	80 e3       	ldi	r24, 0x30	; 48
    d3d4:	80 93 03 03 	sts	0x0303, r24
    d3d8:	80 93 04 03 	sts	0x0304, r24
    d3dc:	80 93 05 03 	sts	0x0305, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    d3e0:	44 0f       	add	r20, r20
    d3e2:	55 1f       	adc	r21, r21
    d3e4:	44 0f       	add	r20, r20
    d3e6:	55 1f       	adc	r21, r21
    d3e8:	60 91 ff 02 	lds	r22, 0x02FF
    d3ec:	64 0f       	add	r22, r20
    d3ee:	67 1b       	sub	r22, r23
    d3f0:	80 91 fe 02 	lds	r24, 0x02FE
    d3f4:	48 e8       	ldi	r20, 0x88	; 136
    d3f6:	52 e1       	ldi	r21, 0x12	; 18
    d3f8:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d3fc:	00 d0       	rcall	.+0      	; 0xd3fe <FMenuSettingServerIP+0x282>
    d3fe:	00 d0       	rcall	.+0      	; 0xd400 <FMenuSettingServerIP+0x284>
    d400:	00 d0       	rcall	.+0      	; 0xd402 <FMenuSettingServerIP+0x286>
    d402:	ad b7       	in	r26, 0x3d	; 61
    d404:	be b7       	in	r27, 0x3e	; 62
    d406:	11 96       	adiw	r26, 0x01	; 1
    d408:	8e 01       	movw	r16, r28
    d40a:	0f 5f       	subi	r16, 0xFF	; 255
    d40c:	1f 4f       	sbci	r17, 0xFF	; 255
    d40e:	ed b7       	in	r30, 0x3d	; 61
    d410:	fe b7       	in	r31, 0x3e	; 62
    d412:	12 83       	std	Z+2, r17	; 0x02
    d414:	01 83       	std	Z+1, r16	; 0x01
    d416:	85 e8       	ldi	r24, 0x85	; 133
    d418:	92 e1       	ldi	r25, 0x12	; 18
    d41a:	13 96       	adiw	r26, 0x03	; 3
    d41c:	9c 93       	st	X, r25
    d41e:	8e 93       	st	-X, r24
    d420:	12 97       	sbiw	r26, 0x02	; 2
    d422:	e0 91 f4 02 	lds	r30, 0x02F4
    d426:	f0 91 f5 02 	lds	r31, 0x02F5
    d42a:	e8 50       	subi	r30, 0x08	; 8
    d42c:	fd 4f       	sbci	r31, 0xFD	; 253
    d42e:	80 81       	ld	r24, Z
    d430:	14 96       	adiw	r26, 0x04	; 4
    d432:	8c 93       	st	X, r24
    d434:	14 97       	sbiw	r26, 0x04	; 4
    d436:	15 96       	adiw	r26, 0x05	; 5
    d438:	1c 92       	st	X, r1
    d43a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d43e:	f8 01       	movw	r30, r16
    d440:	01 90       	ld	r0, Z+
    d442:	00 20       	and	r0, r0
    d444:	e9 f7       	brne	.-6      	; 0xd440 <FMenuSettingServerIP+0x2c4>
    d446:	31 97       	sbiw	r30, 0x01	; 1
    d448:	e0 1b       	sub	r30, r16
    d44a:	f1 0b       	sbc	r31, r17
    d44c:	8d b7       	in	r24, 0x3d	; 61
    d44e:	9e b7       	in	r25, 0x3e	; 62
    d450:	06 96       	adiw	r24, 0x06	; 6
    d452:	0f b6       	in	r0, 0x3f	; 63
    d454:	f8 94       	cli
    d456:	9e bf       	out	0x3e, r25	; 62
    d458:	0f be       	out	0x3f, r0	; 63
    d45a:	8d bf       	out	0x3d, r24	; 61
    d45c:	60 91 ff 02 	lds	r22, 0x02FF
    d460:	6f 5f       	subi	r22, 0xFF	; 255
    d462:	80 91 f4 02 	lds	r24, 0x02F4
    d466:	90 91 f5 02 	lds	r25, 0x02F5
    d46a:	88 0f       	add	r24, r24
    d46c:	99 1f       	adc	r25, r25
    d46e:	88 0f       	add	r24, r24
    d470:	99 1f       	adc	r25, r25
    d472:	68 0f       	add	r22, r24
    d474:	6e 1b       	sub	r22, r30
    d476:	80 91 fe 02 	lds	r24, 0x02FE
    d47a:	a8 01       	movw	r20, r16
    d47c:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d480:	80 91 f4 02 	lds	r24, 0x02F4
    d484:	90 91 f5 02 	lds	r25, 0x02F5
    d488:	00 97       	sbiw	r24, 0x00	; 0
    d48a:	81 f0       	breq	.+32     	; 0xd4ac <FMenuSettingServerIP+0x330>
    d48c:	60 91 ff 02 	lds	r22, 0x02FF
    d490:	6f 5f       	subi	r22, 0xFF	; 255
    d492:	81 50       	subi	r24, 0x01	; 1
    d494:	90 4c       	sbci	r25, 0xC0	; 192
    d496:	88 0f       	add	r24, r24
    d498:	99 1f       	adc	r25, r25
    d49a:	88 0f       	add	r24, r24
    d49c:	99 1f       	adc	r25, r25
    d49e:	68 0f       	add	r22, r24
    d4a0:	80 91 fe 02 	lds	r24, 0x02FE
    d4a4:	43 e8       	ldi	r20, 0x83	; 131
    d4a6:	52 e1       	ldi	r21, 0x12	; 18
    d4a8:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
					   iInput=0;
    d4ac:	10 92 fd 02 	sts	0x02FD, r1
					   iBlok++;
    d4b0:	80 91 f4 02 	lds	r24, 0x02F4
    d4b4:	90 91 f5 02 	lds	r25, 0x02F5
    d4b8:	01 96       	adiw	r24, 0x01	; 1
    d4ba:	90 93 f5 02 	sts	0x02F5, r25
    d4be:	80 93 f4 02 	sts	0x02F4, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    d4c2:	80 91 f4 02 	lds	r24, 0x02F4
    d4c6:	90 91 f5 02 	lds	r25, 0x02F5
    d4ca:	04 97       	sbiw	r24, 0x04	; 4
    d4cc:	18 f0       	brcs	.+6      	; 0xd4d4 <FMenuSettingServerIP+0x358>
    d4ce:	84 e0       	ldi	r24, 0x04	; 4
    d4d0:	80 93 58 01 	sts	0x0158, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    d4d4:	80 91 fc 02 	lds	r24, 0x02FC
    d4d8:	87 3e       	cpi	r24, 0xE7	; 231
    d4da:	09 f4       	brne	.+2      	; 0xd4de <FMenuSettingServerIP+0x362>
    d4dc:	c3 c0       	rjmp	.+390    	; 0xd664 <FMenuSettingServerIP+0x4e8>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    d4de:	87 3b       	cpi	r24, 0xB7	; 183
    d4e0:	09 f0       	breq	.+2      	; 0xd4e4 <FMenuSettingServerIP+0x368>
    d4e2:	c9 c0       	rjmp	.+402    	; 0xd676 <FMenuSettingServerIP+0x4fa>
			       //NextInput
			       if (iBlok<4){
    d4e4:	40 91 f4 02 	lds	r20, 0x02F4
    d4e8:	50 91 f5 02 	lds	r21, 0x02F5
    d4ec:	44 30       	cpi	r20, 0x04	; 4
    d4ee:	51 05       	cpc	r21, r1
    d4f0:	08 f0       	brcs	.+2      	; 0xd4f4 <FMenuSettingServerIP+0x378>
    d4f2:	a6 c0       	rjmp	.+332    	; 0xd640 <FMenuSettingServerIP+0x4c4>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    d4f4:	80 91 fd 02 	lds	r24, 0x02FD
    d4f8:	81 30       	cpi	r24, 0x01	; 1
    d4fa:	41 f4       	brne	.+16     	; 0xd50c <FMenuSettingServerIP+0x390>
    d4fc:	fa 01       	movw	r30, r20
    d4fe:	e8 50       	subi	r30, 0x08	; 8
    d500:	fd 4f       	sbci	r31, 0xFD	; 253
    d502:	80 91 03 03 	lds	r24, 0x0303
    d506:	80 53       	subi	r24, 0x30	; 48
    d508:	80 83       	st	Z, r24
    d50a:	22 c0       	rjmp	.+68     	; 0xd550 <FMenuSettingServerIP+0x3d4>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    d50c:	82 30       	cpi	r24, 0x02	; 2
    d50e:	49 f4       	brne	.+18     	; 0xd522 <FMenuSettingServerIP+0x3a6>
    d510:	fa 01       	movw	r30, r20
    d512:	e8 50       	subi	r30, 0x08	; 8
    d514:	fd 4f       	sbci	r31, 0xFD	; 253
    d516:	20 91 04 03 	lds	r18, 0x0304
    d51a:	20 51       	subi	r18, 0x10	; 16
    d51c:	80 91 03 03 	lds	r24, 0x0303
    d520:	11 c0       	rjmp	.+34     	; 0xd544 <FMenuSettingServerIP+0x3c8>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d522:	83 30       	cpi	r24, 0x03	; 3
    d524:	a9 f4       	brne	.+42     	; 0xd550 <FMenuSettingServerIP+0x3d4>
    d526:	fa 01       	movw	r30, r20
    d528:	e8 50       	subi	r30, 0x08	; 8
    d52a:	fd 4f       	sbci	r31, 0xFD	; 253
    d52c:	20 91 05 03 	lds	r18, 0x0305
    d530:	20 5d       	subi	r18, 0xD0	; 208
    d532:	80 91 03 03 	lds	r24, 0x0303
    d536:	34 e6       	ldi	r19, 0x64	; 100
    d538:	83 9f       	mul	r24, r19
    d53a:	c0 01       	movw	r24, r0
    d53c:	11 24       	eor	r1, r1
    d53e:	28 0f       	add	r18, r24
    d540:	80 91 04 03 	lds	r24, 0x0304
    d544:	3a e0       	ldi	r19, 0x0A	; 10
    d546:	83 9f       	mul	r24, r19
    d548:	c0 01       	movw	r24, r0
    d54a:	11 24       	eor	r1, r1
    d54c:	28 0f       	add	r18, r24
    d54e:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d550:	80 e3       	ldi	r24, 0x30	; 48
    d552:	80 93 03 03 	sts	0x0303, r24
    d556:	80 93 04 03 	sts	0x0304, r24
    d55a:	80 93 05 03 	sts	0x0305, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    d55e:	60 91 ff 02 	lds	r22, 0x02FF
    d562:	63 50       	subi	r22, 0x03	; 3
    d564:	44 0f       	add	r20, r20
    d566:	55 1f       	adc	r21, r21
    d568:	44 0f       	add	r20, r20
    d56a:	55 1f       	adc	r21, r21
    d56c:	64 0f       	add	r22, r20
    d56e:	80 91 fe 02 	lds	r24, 0x02FE
    d572:	4f e7       	ldi	r20, 0x7F	; 127
    d574:	52 e1       	ldi	r21, 0x12	; 18
    d576:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d57a:	00 d0       	rcall	.+0      	; 0xd57c <FMenuSettingServerIP+0x400>
    d57c:	00 d0       	rcall	.+0      	; 0xd57e <FMenuSettingServerIP+0x402>
    d57e:	00 d0       	rcall	.+0      	; 0xd580 <FMenuSettingServerIP+0x404>
    d580:	ad b7       	in	r26, 0x3d	; 61
    d582:	be b7       	in	r27, 0x3e	; 62
    d584:	11 96       	adiw	r26, 0x01	; 1
    d586:	8e 01       	movw	r16, r28
    d588:	0f 5f       	subi	r16, 0xFF	; 255
    d58a:	1f 4f       	sbci	r17, 0xFF	; 255
    d58c:	ed b7       	in	r30, 0x3d	; 61
    d58e:	fe b7       	in	r31, 0x3e	; 62
    d590:	12 83       	std	Z+2, r17	; 0x02
    d592:	01 83       	std	Z+1, r16	; 0x01
    d594:	8c e7       	ldi	r24, 0x7C	; 124
    d596:	92 e1       	ldi	r25, 0x12	; 18
    d598:	13 96       	adiw	r26, 0x03	; 3
    d59a:	9c 93       	st	X, r25
    d59c:	8e 93       	st	-X, r24
    d59e:	12 97       	sbiw	r26, 0x02	; 2
    d5a0:	e0 91 f4 02 	lds	r30, 0x02F4
    d5a4:	f0 91 f5 02 	lds	r31, 0x02F5
    d5a8:	e8 50       	subi	r30, 0x08	; 8
    d5aa:	fd 4f       	sbci	r31, 0xFD	; 253
    d5ac:	80 81       	ld	r24, Z
    d5ae:	14 96       	adiw	r26, 0x04	; 4
    d5b0:	8c 93       	st	X, r24
    d5b2:	14 97       	sbiw	r26, 0x04	; 4
    d5b4:	15 96       	adiw	r26, 0x05	; 5
    d5b6:	1c 92       	st	X, r1
    d5b8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d5bc:	f8 01       	movw	r30, r16
    d5be:	01 90       	ld	r0, Z+
    d5c0:	00 20       	and	r0, r0
    d5c2:	e9 f7       	brne	.-6      	; 0xd5be <FMenuSettingServerIP+0x442>
    d5c4:	31 97       	sbiw	r30, 0x01	; 1
    d5c6:	e0 1b       	sub	r30, r16
    d5c8:	f1 0b       	sbc	r31, r17
    d5ca:	8d b7       	in	r24, 0x3d	; 61
    d5cc:	9e b7       	in	r25, 0x3e	; 62
    d5ce:	06 96       	adiw	r24, 0x06	; 6
    d5d0:	0f b6       	in	r0, 0x3f	; 63
    d5d2:	f8 94       	cli
    d5d4:	9e bf       	out	0x3e, r25	; 62
    d5d6:	0f be       	out	0x3f, r0	; 63
    d5d8:	8d bf       	out	0x3d, r24	; 61
    d5da:	60 91 ff 02 	lds	r22, 0x02FF
    d5de:	6f 5f       	subi	r22, 0xFF	; 255
    d5e0:	80 91 f4 02 	lds	r24, 0x02F4
    d5e4:	90 91 f5 02 	lds	r25, 0x02F5
    d5e8:	88 0f       	add	r24, r24
    d5ea:	99 1f       	adc	r25, r25
    d5ec:	88 0f       	add	r24, r24
    d5ee:	99 1f       	adc	r25, r25
    d5f0:	68 0f       	add	r22, r24
    d5f2:	6e 1b       	sub	r22, r30
    d5f4:	80 91 fe 02 	lds	r24, 0x02FE
    d5f8:	a8 01       	movw	r20, r16
    d5fa:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d5fe:	80 91 f4 02 	lds	r24, 0x02F4
    d602:	90 91 f5 02 	lds	r25, 0x02F5
    d606:	00 97       	sbiw	r24, 0x00	; 0
    d608:	81 f0       	breq	.+32     	; 0xd62a <FMenuSettingServerIP+0x4ae>
    d60a:	60 91 ff 02 	lds	r22, 0x02FF
    d60e:	6f 5f       	subi	r22, 0xFF	; 255
    d610:	81 50       	subi	r24, 0x01	; 1
    d612:	90 4c       	sbci	r25, 0xC0	; 192
    d614:	88 0f       	add	r24, r24
    d616:	99 1f       	adc	r25, r25
    d618:	88 0f       	add	r24, r24
    d61a:	99 1f       	adc	r25, r25
    d61c:	68 0f       	add	r22, r24
    d61e:	80 91 fe 02 	lds	r24, 0x02FE
    d622:	4a e7       	ldi	r20, 0x7A	; 122
    d624:	52 e1       	ldi	r21, 0x12	; 18
    d626:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				       iInput=0;
    d62a:	10 92 fd 02 	sts	0x02FD, r1
					   iBlok++;	   
    d62e:	80 91 f4 02 	lds	r24, 0x02F4
    d632:	90 91 f5 02 	lds	r25, 0x02F5
    d636:	01 96       	adiw	r24, 0x01	; 1
    d638:	90 93 f5 02 	sts	0x02F5, r25
    d63c:	80 93 f4 02 	sts	0x02F4, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    d640:	80 91 f4 02 	lds	r24, 0x02F4
    d644:	90 91 f5 02 	lds	r25, 0x02F5
    d648:	04 97       	sbiw	r24, 0x04	; 4
    d64a:	a8 f0       	brcs	.+42     	; 0xd676 <FMenuSettingServerIP+0x4fa>
    d64c:	84 e0       	ldi	r24, 0x04	; 4
    d64e:	0b c0       	rjmp	.+22     	; 0xd666 <FMenuSettingServerIP+0x4ea>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    d650:	8c e2       	ldi	r24, 0x2C	; 44
    d652:	90 e0       	ldi	r25, 0x00	; 0
    d654:	68 ef       	ldi	r22, 0xF8	; 248
    d656:	72 e0       	ldi	r23, 0x02	; 2
    d658:	44 e0       	ldi	r20, 0x04	; 4
    d65a:	50 e0       	ldi	r21, 0x00	; 0
    d65c:	2d ed       	ldi	r18, 0xDD	; 221
    d65e:	32 e1       	ldi	r19, 0x12	; 18
    d660:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
			   }
		       break;
          case cipStoreIPblok:
		       //UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefServerIP,4);
			   stClientIP=cipExit;
    d664:	83 e0       	ldi	r24, 0x03	; 3
    d666:	80 93 58 01 	sts	0x0158, r24
    d66a:	05 c0       	rjmp	.+10     	; 0xd676 <FMenuSettingServerIP+0x4fa>
		       break; 
          case cipExit://Cancel IPConfig
			   stClientIP=cipInit;
    d66c:	81 e0       	ldi	r24, 0x01	; 1
    d66e:	80 93 58 01 	sts	0x0158, r24
			   Result=MENU_DONE;
    d672:	80 93 01 03 	sts	0x0301, r24
		       break;     
		  }//EndSwitch	 
	return Result;
}
    d676:	80 91 01 03 	lds	r24, 0x0301
    d67a:	64 96       	adiw	r28, 0x14	; 20
    d67c:	0f b6       	in	r0, 0x3f	; 63
    d67e:	f8 94       	cli
    d680:	de bf       	out	0x3e, r29	; 62
    d682:	0f be       	out	0x3f, r0	; 63
    d684:	cd bf       	out	0x3d, r28	; 61
    d686:	cf 91       	pop	r28
    d688:	df 91       	pop	r29
    d68a:	1f 91       	pop	r17
    d68c:	0f 91       	pop	r16
    d68e:	08 95       	ret

0000d690 <FMenuSettingClientIP>:





char FMenuSettingClientIP(){
    d690:	0f 93       	push	r16
    d692:	1f 93       	push	r17
    d694:	df 93       	push	r29
    d696:	cf 93       	push	r28
    d698:	cd b7       	in	r28, 0x3d	; 61
    d69a:	de b7       	in	r29, 0x3e	; 62
    d69c:	64 97       	sbiw	r28, 0x14	; 20
    d69e:	0f b6       	in	r0, 0x3f	; 63
    d6a0:	f8 94       	cli
    d6a2:	de bf       	out	0x3e, r29	; 62
    d6a4:	0f be       	out	0x3f, r0	; 63
    d6a6:	cd bf       	out	0x3d, r28	; 61
     //Client IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
     Result=MENU_NONE;
    d6a8:	10 92 13 03 	sts	0x0313, r1
	 switch(stClientIP){
    d6ac:	80 91 59 01 	lds	r24, 0x0159
    d6b0:	82 30       	cpi	r24, 0x02	; 2
    d6b2:	09 f4       	brne	.+2      	; 0xd6b6 <FMenuSettingClientIP+0x26>
    d6b4:	7b c0       	rjmp	.+246    	; 0xd7ac <FMenuSettingClientIP+0x11c>
    d6b6:	83 30       	cpi	r24, 0x03	; 3
    d6b8:	20 f4       	brcc	.+8      	; 0xd6c2 <FMenuSettingClientIP+0x32>
    d6ba:	81 30       	cpi	r24, 0x01	; 1
    d6bc:	09 f0       	breq	.+2      	; 0xd6c0 <FMenuSettingClientIP+0x30>
    d6be:	65 c2       	rjmp	.+1226   	; 0xdb8a <FMenuSettingClientIP+0x4fa>
    d6c0:	07 c0       	rjmp	.+14     	; 0xd6d0 <FMenuSettingClientIP+0x40>
    d6c2:	83 30       	cpi	r24, 0x03	; 3
    d6c4:	09 f4       	brne	.+2      	; 0xd6c8 <FMenuSettingClientIP+0x38>
    d6c6:	5c c2       	rjmp	.+1208   	; 0xdb80 <FMenuSettingClientIP+0x4f0>
    d6c8:	84 30       	cpi	r24, 0x04	; 4
    d6ca:	09 f0       	breq	.+2      	; 0xd6ce <FMenuSettingClientIP+0x3e>
    d6cc:	5e c2       	rjmp	.+1212   	; 0xdb8a <FMenuSettingClientIP+0x4fa>
    d6ce:	4a c2       	rjmp	.+1172   	; 0xdb64 <FMenuSettingClientIP+0x4d4>
		  case cipInit:
			   lcd_clear();
    d6d0:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
	           lcd_printf(1,1,PSTR("Client IP"));
    d6d4:	81 e0       	ldi	r24, 0x01	; 1
    d6d6:	61 e0       	ldi	r22, 0x01	; 1
    d6d8:	4e e1       	ldi	r20, 0x1E	; 30
    d6da:	53 e1       	ldi	r21, 0x13	; 19
    d6dc:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d6e0:	8a e0       	ldi	r24, 0x0A	; 10
    d6e2:	93 e0       	ldi	r25, 0x03	; 3
    d6e4:	68 e2       	ldi	r22, 0x28	; 40
    d6e6:	70 e0       	ldi	r23, 0x00	; 0
    d6e8:	44 e0       	ldi	r20, 0x04	; 4
    d6ea:	50 e0       	ldi	r21, 0x00	; 0
    d6ec:	25 ed       	ldi	r18, 0xD5	; 213
    d6ee:	32 e1       	ldi	r19, 0x12	; 18
    d6f0:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    d6f4:	8d b7       	in	r24, 0x3d	; 61
    d6f6:	9e b7       	in	r25, 0x3e	; 62
    d6f8:	0c 97       	sbiw	r24, 0x0c	; 12
    d6fa:	0f b6       	in	r0, 0x3f	; 63
    d6fc:	f8 94       	cli
    d6fe:	9e bf       	out	0x3e, r25	; 62
    d700:	0f be       	out	0x3f, r0	; 63
    d702:	8d bf       	out	0x3d, r24	; 61
    d704:	ed b7       	in	r30, 0x3d	; 61
    d706:	fe b7       	in	r31, 0x3e	; 62
    d708:	31 96       	adiw	r30, 0x01	; 1
    d70a:	8e 01       	movw	r16, r28
    d70c:	0f 5f       	subi	r16, 0xFF	; 255
    d70e:	1f 4f       	sbci	r17, 0xFF	; 255
    d710:	ad b7       	in	r26, 0x3d	; 61
    d712:	be b7       	in	r27, 0x3e	; 62
    d714:	12 96       	adiw	r26, 0x02	; 2
    d716:	1c 93       	st	X, r17
    d718:	0e 93       	st	-X, r16
    d71a:	11 97       	sbiw	r26, 0x01	; 1
    d71c:	8d e0       	ldi	r24, 0x0D	; 13
    d71e:	93 e1       	ldi	r25, 0x13	; 19
    d720:	93 83       	std	Z+3, r25	; 0x03
    d722:	82 83       	std	Z+2, r24	; 0x02
    d724:	80 91 0a 03 	lds	r24, 0x030A
    d728:	84 83       	std	Z+4, r24	; 0x04
    d72a:	15 82       	std	Z+5, r1	; 0x05
    d72c:	80 91 0b 03 	lds	r24, 0x030B
    d730:	86 83       	std	Z+6, r24	; 0x06
    d732:	17 82       	std	Z+7, r1	; 0x07
    d734:	80 91 0c 03 	lds	r24, 0x030C
    d738:	80 87       	std	Z+8, r24	; 0x08
    d73a:	11 86       	std	Z+9, r1	; 0x09
    d73c:	80 91 0d 03 	lds	r24, 0x030D
    d740:	82 87       	std	Z+10, r24	; 0x0a
    d742:	13 86       	std	Z+11, r1	; 0x0b
    d744:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    d748:	ed b7       	in	r30, 0x3d	; 61
    d74a:	fe b7       	in	r31, 0x3e	; 62
    d74c:	3c 96       	adiw	r30, 0x0c	; 12
    d74e:	0f b6       	in	r0, 0x3f	; 63
    d750:	f8 94       	cli
    d752:	fe bf       	out	0x3e, r31	; 62
    d754:	0f be       	out	0x3f, r0	; 63
    d756:	ed bf       	out	0x3d, r30	; 61
    d758:	82 e0       	ldi	r24, 0x02	; 2
    d75a:	61 e0       	ldi	r22, 0x01	; 1
    d75c:	a8 01       	movw	r20, r16
    d75e:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    d762:	83 e0       	ldi	r24, 0x03	; 3
    d764:	61 e0       	ldi	r22, 0x01	; 1
    d766:	48 ef       	ldi	r20, 0xF8	; 248
    d768:	52 e1       	ldi	r21, 0x12	; 18
    d76a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    d76e:	84 e0       	ldi	r24, 0x04	; 4
    d770:	61 e0       	ldi	r22, 0x01	; 1
    d772:	43 ee       	ldi	r20, 0xE3	; 227
    d774:	52 e1       	ldi	r21, 0x12	; 18
    d776:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
               iLoop=0;
    d77a:	10 92 09 03 	sts	0x0309, r1
    d77e:	10 92 08 03 	sts	0x0308, r1
			   y=3,x=8;
    d782:	83 e0       	ldi	r24, 0x03	; 3
    d784:	80 93 10 03 	sts	0x0310, r24
    d788:	88 e0       	ldi	r24, 0x08	; 8
    d78a:	80 93 11 03 	sts	0x0311, r24
			   iInput=0; iBlok=0;
    d78e:	10 92 0f 03 	sts	0x030F, r1
    d792:	10 92 07 03 	sts	0x0307, r1
    d796:	10 92 06 03 	sts	0x0306, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d79a:	80 e3       	ldi	r24, 0x30	; 48
    d79c:	80 93 15 03 	sts	0x0315, r24
    d7a0:	80 93 16 03 	sts	0x0316, r24
    d7a4:	80 93 17 03 	sts	0x0317, r24
			   stClientIP=cipInputIP; 
    d7a8:	82 e0       	ldi	r24, 0x02	; 2
    d7aa:	e7 c1       	rjmp	.+974    	; 0xdb7a <FMenuSettingClientIP+0x4ea>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    d7ac:	80 91 08 03 	lds	r24, 0x0308
    d7b0:	90 91 09 03 	lds	r25, 0x0309
    d7b4:	01 96       	adiw	r24, 0x01	; 1
    d7b6:	90 93 09 03 	sts	0x0309, r25
    d7ba:	80 93 08 03 	sts	0x0308, r24
			   if ((iLoop%2000)==0){
    d7be:	60 ed       	ldi	r22, 0xD0	; 208
    d7c0:	77 e0       	ldi	r23, 0x07	; 7
    d7c2:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
    d7c6:	89 2b       	or	r24, r25
    d7c8:	81 f4       	brne	.+32     	; 0xd7ea <FMenuSettingClientIP+0x15a>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    d7ca:	80 91 06 03 	lds	r24, 0x0306
    d7ce:	90 91 07 03 	lds	r25, 0x0307
    d7d2:	88 0f       	add	r24, r24
    d7d4:	99 1f       	adc	r25, r25
    d7d6:	88 0f       	add	r24, r24
    d7d8:	99 1f       	adc	r25, r25
    d7da:	60 91 11 03 	lds	r22, 0x0311
    d7de:	68 0f       	add	r22, r24
    d7e0:	80 91 10 03 	lds	r24, 0x0310
    d7e4:	4f e5       	ldi	r20, 0x5F	; 95
    d7e6:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    d7ea:	80 91 08 03 	lds	r24, 0x0308
    d7ee:	90 91 09 03 	lds	r25, 0x0309
    d7f2:	60 ed       	ldi	r22, 0xD0	; 208
    d7f4:	77 e0       	ldi	r23, 0x07	; 7
    d7f6:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
    d7fa:	88 5e       	subi	r24, 0xE8	; 232
    d7fc:	93 40       	sbci	r25, 0x03	; 3
    d7fe:	81 f4       	brne	.+32     	; 0xd820 <FMenuSettingClientIP+0x190>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    d800:	80 91 06 03 	lds	r24, 0x0306
    d804:	90 91 07 03 	lds	r25, 0x0307
    d808:	88 0f       	add	r24, r24
    d80a:	99 1f       	adc	r25, r25
    d80c:	88 0f       	add	r24, r24
    d80e:	99 1f       	adc	r25, r25
    d810:	60 91 11 03 	lds	r22, 0x0311
    d814:	68 0f       	add	r22, r24
    d816:	80 91 10 03 	lds	r24, 0x0310
    d81a:	40 e2       	ldi	r20, 0x20	; 32
    d81c:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    d820:	81 e0       	ldi	r24, 0x01	; 1
    d822:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    d826:	80 93 0e 03 	sts	0x030E, r24
			   keyChar=_key_btn(keyPressed);
    d82a:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
    d82e:	28 2f       	mov	r18, r24
    d830:	80 93 12 03 	sts	0x0312, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    d834:	80 53       	subi	r24, 0x30	; 48
    d836:	8a 30       	cpi	r24, 0x0A	; 10
    d838:	08 f0       	brcs	.+2      	; 0xd83c <FMenuSettingClientIP+0x1ac>
    d83a:	d6 c0       	rjmp	.+428    	; 0xd9e8 <FMenuSettingClientIP+0x358>
    d83c:	80 e5       	ldi	r24, 0x50	; 80
    d83e:	93 ec       	ldi	r25, 0xC3	; 195
    d840:	01 97       	sbiw	r24, 0x01	; 1
    d842:	f1 f7       	brne	.-4      	; 0xd840 <FMenuSettingClientIP+0x1b0>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    d844:	80 91 0f 03 	lds	r24, 0x030F
    d848:	e8 2f       	mov	r30, r24
    d84a:	f0 e0       	ldi	r31, 0x00	; 0
    d84c:	eb 5e       	subi	r30, 0xEB	; 235
    d84e:	fc 4f       	sbci	r31, 0xFC	; 252
    d850:	20 83       	st	Z, r18
				   iInput++;                    
    d852:	8f 5f       	subi	r24, 0xFF	; 255
    d854:	80 93 0f 03 	sts	0x030F, r24
				   for (i=1;i<(iInput+1);i++){
    d858:	81 e0       	ldi	r24, 0x01	; 1
    d85a:	1c c0       	rjmp	.+56     	; 0xd894 <FMenuSettingClientIP+0x204>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    d85c:	80 91 11 03 	lds	r24, 0x0311
    d860:	68 0f       	add	r22, r24
    d862:	63 50       	subi	r22, 0x03	; 3
    d864:	80 91 06 03 	lds	r24, 0x0306
    d868:	90 91 07 03 	lds	r25, 0x0307
    d86c:	88 0f       	add	r24, r24
    d86e:	99 1f       	adc	r25, r25
    d870:	88 0f       	add	r24, r24
    d872:	99 1f       	adc	r25, r25
    d874:	68 0f       	add	r22, r24
    d876:	80 91 10 03 	lds	r24, 0x0310
    d87a:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
    d87e:	e0 91 14 03 	lds	r30, 0x0314
    d882:	f0 e0       	ldi	r31, 0x00	; 0
    d884:	ec 5e       	subi	r30, 0xEC	; 236
    d886:	fc 4f       	sbci	r31, 0xFC	; 252
    d888:	80 81       	ld	r24, Z
    d88a:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    d88e:	80 91 14 03 	lds	r24, 0x0314
    d892:	8f 5f       	subi	r24, 0xFF	; 255
    d894:	80 93 14 03 	sts	0x0314, r24
    d898:	70 91 0f 03 	lds	r23, 0x030F
    d89c:	60 91 14 03 	lds	r22, 0x0314
    d8a0:	27 2f       	mov	r18, r23
    d8a2:	30 e0       	ldi	r19, 0x00	; 0
    d8a4:	86 2f       	mov	r24, r22
    d8a6:	90 e0       	ldi	r25, 0x00	; 0
    d8a8:	28 17       	cp	r18, r24
    d8aa:	39 07       	cpc	r19, r25
    d8ac:	bc f6       	brge	.-82     	; 0xd85c <FMenuSettingClientIP+0x1cc>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    d8ae:	73 30       	cpi	r23, 0x03	; 3
    d8b0:	08 f4       	brcc	.+2      	; 0xd8b4 <FMenuSettingClientIP+0x224>
    d8b2:	91 c0       	rjmp	.+290    	; 0xd9d6 <FMenuSettingClientIP+0x346>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d8b4:	40 91 06 03 	lds	r20, 0x0306
    d8b8:	50 91 07 03 	lds	r21, 0x0307
    d8bc:	fa 01       	movw	r30, r20
    d8be:	e6 5f       	subi	r30, 0xF6	; 246
    d8c0:	fc 4f       	sbci	r31, 0xFC	; 252
    d8c2:	20 91 17 03 	lds	r18, 0x0317
    d8c6:	20 5d       	subi	r18, 0xD0	; 208
    d8c8:	80 91 15 03 	lds	r24, 0x0315
    d8cc:	34 e6       	ldi	r19, 0x64	; 100
    d8ce:	83 9f       	mul	r24, r19
    d8d0:	c0 01       	movw	r24, r0
    d8d2:	11 24       	eor	r1, r1
    d8d4:	28 0f       	add	r18, r24
    d8d6:	80 91 16 03 	lds	r24, 0x0316
    d8da:	3a e0       	ldi	r19, 0x0A	; 10
    d8dc:	83 9f       	mul	r24, r19
    d8de:	c0 01       	movw	r24, r0
    d8e0:	11 24       	eor	r1, r1
    d8e2:	28 0f       	add	r18, r24
    d8e4:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d8e6:	80 e3       	ldi	r24, 0x30	; 48
    d8e8:	80 93 15 03 	sts	0x0315, r24
    d8ec:	80 93 16 03 	sts	0x0316, r24
    d8f0:	80 93 17 03 	sts	0x0317, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    d8f4:	44 0f       	add	r20, r20
    d8f6:	55 1f       	adc	r21, r21
    d8f8:	44 0f       	add	r20, r20
    d8fa:	55 1f       	adc	r21, r21
    d8fc:	60 91 11 03 	lds	r22, 0x0311
    d900:	64 0f       	add	r22, r20
    d902:	67 1b       	sub	r22, r23
    d904:	80 91 10 03 	lds	r24, 0x0310
    d908:	4f ed       	ldi	r20, 0xDF	; 223
    d90a:	52 e1       	ldi	r21, 0x12	; 18
    d90c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d910:	00 d0       	rcall	.+0      	; 0xd912 <FMenuSettingClientIP+0x282>
    d912:	00 d0       	rcall	.+0      	; 0xd914 <FMenuSettingClientIP+0x284>
    d914:	00 d0       	rcall	.+0      	; 0xd916 <FMenuSettingClientIP+0x286>
    d916:	ad b7       	in	r26, 0x3d	; 61
    d918:	be b7       	in	r27, 0x3e	; 62
    d91a:	11 96       	adiw	r26, 0x01	; 1
    d91c:	8e 01       	movw	r16, r28
    d91e:	0f 5f       	subi	r16, 0xFF	; 255
    d920:	1f 4f       	sbci	r17, 0xFF	; 255
    d922:	ed b7       	in	r30, 0x3d	; 61
    d924:	fe b7       	in	r31, 0x3e	; 62
    d926:	12 83       	std	Z+2, r17	; 0x02
    d928:	01 83       	std	Z+1, r16	; 0x01
    d92a:	8c ed       	ldi	r24, 0xDC	; 220
    d92c:	92 e1       	ldi	r25, 0x12	; 18
    d92e:	13 96       	adiw	r26, 0x03	; 3
    d930:	9c 93       	st	X, r25
    d932:	8e 93       	st	-X, r24
    d934:	12 97       	sbiw	r26, 0x02	; 2
    d936:	e0 91 06 03 	lds	r30, 0x0306
    d93a:	f0 91 07 03 	lds	r31, 0x0307
    d93e:	e6 5f       	subi	r30, 0xF6	; 246
    d940:	fc 4f       	sbci	r31, 0xFC	; 252
    d942:	80 81       	ld	r24, Z
    d944:	14 96       	adiw	r26, 0x04	; 4
    d946:	8c 93       	st	X, r24
    d948:	14 97       	sbiw	r26, 0x04	; 4
    d94a:	15 96       	adiw	r26, 0x05	; 5
    d94c:	1c 92       	st	X, r1
    d94e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d952:	f8 01       	movw	r30, r16
    d954:	01 90       	ld	r0, Z+
    d956:	00 20       	and	r0, r0
    d958:	e9 f7       	brne	.-6      	; 0xd954 <FMenuSettingClientIP+0x2c4>
    d95a:	31 97       	sbiw	r30, 0x01	; 1
    d95c:	e0 1b       	sub	r30, r16
    d95e:	f1 0b       	sbc	r31, r17
    d960:	8d b7       	in	r24, 0x3d	; 61
    d962:	9e b7       	in	r25, 0x3e	; 62
    d964:	06 96       	adiw	r24, 0x06	; 6
    d966:	0f b6       	in	r0, 0x3f	; 63
    d968:	f8 94       	cli
    d96a:	9e bf       	out	0x3e, r25	; 62
    d96c:	0f be       	out	0x3f, r0	; 63
    d96e:	8d bf       	out	0x3d, r24	; 61
    d970:	60 91 11 03 	lds	r22, 0x0311
    d974:	6f 5f       	subi	r22, 0xFF	; 255
    d976:	80 91 06 03 	lds	r24, 0x0306
    d97a:	90 91 07 03 	lds	r25, 0x0307
    d97e:	88 0f       	add	r24, r24
    d980:	99 1f       	adc	r25, r25
    d982:	88 0f       	add	r24, r24
    d984:	99 1f       	adc	r25, r25
    d986:	68 0f       	add	r22, r24
    d988:	6e 1b       	sub	r22, r30
    d98a:	80 91 10 03 	lds	r24, 0x0310
    d98e:	a8 01       	movw	r20, r16
    d990:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d994:	80 91 06 03 	lds	r24, 0x0306
    d998:	90 91 07 03 	lds	r25, 0x0307
    d99c:	00 97       	sbiw	r24, 0x00	; 0
    d99e:	81 f0       	breq	.+32     	; 0xd9c0 <FMenuSettingClientIP+0x330>
    d9a0:	60 91 11 03 	lds	r22, 0x0311
    d9a4:	6f 5f       	subi	r22, 0xFF	; 255
    d9a6:	81 50       	subi	r24, 0x01	; 1
    d9a8:	90 4c       	sbci	r25, 0xC0	; 192
    d9aa:	88 0f       	add	r24, r24
    d9ac:	99 1f       	adc	r25, r25
    d9ae:	88 0f       	add	r24, r24
    d9b0:	99 1f       	adc	r25, r25
    d9b2:	68 0f       	add	r22, r24
    d9b4:	80 91 10 03 	lds	r24, 0x0310
    d9b8:	4a ed       	ldi	r20, 0xDA	; 218
    d9ba:	52 e1       	ldi	r21, 0x12	; 18
    d9bc:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
					   iInput=0;
    d9c0:	10 92 0f 03 	sts	0x030F, r1
					   iBlok++;
    d9c4:	80 91 06 03 	lds	r24, 0x0306
    d9c8:	90 91 07 03 	lds	r25, 0x0307
    d9cc:	01 96       	adiw	r24, 0x01	; 1
    d9ce:	90 93 07 03 	sts	0x0307, r25
    d9d2:	80 93 06 03 	sts	0x0306, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    d9d6:	80 91 06 03 	lds	r24, 0x0306
    d9da:	90 91 07 03 	lds	r25, 0x0307
    d9de:	04 97       	sbiw	r24, 0x04	; 4
    d9e0:	18 f0       	brcs	.+6      	; 0xd9e8 <FMenuSettingClientIP+0x358>
    d9e2:	84 e0       	ldi	r24, 0x04	; 4
    d9e4:	80 93 59 01 	sts	0x0159, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    d9e8:	80 91 0e 03 	lds	r24, 0x030E
    d9ec:	87 3e       	cpi	r24, 0xE7	; 231
    d9ee:	09 f4       	brne	.+2      	; 0xd9f2 <FMenuSettingClientIP+0x362>
    d9f0:	c3 c0       	rjmp	.+390    	; 0xdb78 <FMenuSettingClientIP+0x4e8>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    d9f2:	87 3b       	cpi	r24, 0xB7	; 183
    d9f4:	09 f0       	breq	.+2      	; 0xd9f8 <FMenuSettingClientIP+0x368>
    d9f6:	c9 c0       	rjmp	.+402    	; 0xdb8a <FMenuSettingClientIP+0x4fa>
			       //NextInput
			       if (iBlok<4){
    d9f8:	40 91 06 03 	lds	r20, 0x0306
    d9fc:	50 91 07 03 	lds	r21, 0x0307
    da00:	44 30       	cpi	r20, 0x04	; 4
    da02:	51 05       	cpc	r21, r1
    da04:	08 f0       	brcs	.+2      	; 0xda08 <FMenuSettingClientIP+0x378>
    da06:	a6 c0       	rjmp	.+332    	; 0xdb54 <FMenuSettingClientIP+0x4c4>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    da08:	80 91 0f 03 	lds	r24, 0x030F
    da0c:	81 30       	cpi	r24, 0x01	; 1
    da0e:	41 f4       	brne	.+16     	; 0xda20 <FMenuSettingClientIP+0x390>
    da10:	fa 01       	movw	r30, r20
    da12:	e6 5f       	subi	r30, 0xF6	; 246
    da14:	fc 4f       	sbci	r31, 0xFC	; 252
    da16:	80 91 15 03 	lds	r24, 0x0315
    da1a:	80 53       	subi	r24, 0x30	; 48
    da1c:	80 83       	st	Z, r24
    da1e:	22 c0       	rjmp	.+68     	; 0xda64 <FMenuSettingClientIP+0x3d4>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    da20:	82 30       	cpi	r24, 0x02	; 2
    da22:	49 f4       	brne	.+18     	; 0xda36 <FMenuSettingClientIP+0x3a6>
    da24:	fa 01       	movw	r30, r20
    da26:	e6 5f       	subi	r30, 0xF6	; 246
    da28:	fc 4f       	sbci	r31, 0xFC	; 252
    da2a:	20 91 16 03 	lds	r18, 0x0316
    da2e:	20 51       	subi	r18, 0x10	; 16
    da30:	80 91 15 03 	lds	r24, 0x0315
    da34:	11 c0       	rjmp	.+34     	; 0xda58 <FMenuSettingClientIP+0x3c8>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    da36:	83 30       	cpi	r24, 0x03	; 3
    da38:	a9 f4       	brne	.+42     	; 0xda64 <FMenuSettingClientIP+0x3d4>
    da3a:	fa 01       	movw	r30, r20
    da3c:	e6 5f       	subi	r30, 0xF6	; 246
    da3e:	fc 4f       	sbci	r31, 0xFC	; 252
    da40:	20 91 17 03 	lds	r18, 0x0317
    da44:	20 5d       	subi	r18, 0xD0	; 208
    da46:	80 91 15 03 	lds	r24, 0x0315
    da4a:	34 e6       	ldi	r19, 0x64	; 100
    da4c:	83 9f       	mul	r24, r19
    da4e:	c0 01       	movw	r24, r0
    da50:	11 24       	eor	r1, r1
    da52:	28 0f       	add	r18, r24
    da54:	80 91 16 03 	lds	r24, 0x0316
    da58:	3a e0       	ldi	r19, 0x0A	; 10
    da5a:	83 9f       	mul	r24, r19
    da5c:	c0 01       	movw	r24, r0
    da5e:	11 24       	eor	r1, r1
    da60:	28 0f       	add	r18, r24
    da62:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    da64:	80 e3       	ldi	r24, 0x30	; 48
    da66:	80 93 15 03 	sts	0x0315, r24
    da6a:	80 93 16 03 	sts	0x0316, r24
    da6e:	80 93 17 03 	sts	0x0317, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    da72:	60 91 11 03 	lds	r22, 0x0311
    da76:	63 50       	subi	r22, 0x03	; 3
    da78:	44 0f       	add	r20, r20
    da7a:	55 1f       	adc	r21, r21
    da7c:	44 0f       	add	r20, r20
    da7e:	55 1f       	adc	r21, r21
    da80:	64 0f       	add	r22, r20
    da82:	80 91 10 03 	lds	r24, 0x0310
    da86:	46 ed       	ldi	r20, 0xD6	; 214
    da88:	52 e1       	ldi	r21, 0x12	; 18
    da8a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    da8e:	00 d0       	rcall	.+0      	; 0xda90 <FMenuSettingClientIP+0x400>
    da90:	00 d0       	rcall	.+0      	; 0xda92 <FMenuSettingClientIP+0x402>
    da92:	00 d0       	rcall	.+0      	; 0xda94 <FMenuSettingClientIP+0x404>
    da94:	ad b7       	in	r26, 0x3d	; 61
    da96:	be b7       	in	r27, 0x3e	; 62
    da98:	11 96       	adiw	r26, 0x01	; 1
    da9a:	8e 01       	movw	r16, r28
    da9c:	0f 5f       	subi	r16, 0xFF	; 255
    da9e:	1f 4f       	sbci	r17, 0xFF	; 255
    daa0:	ed b7       	in	r30, 0x3d	; 61
    daa2:	fe b7       	in	r31, 0x3e	; 62
    daa4:	12 83       	std	Z+2, r17	; 0x02
    daa6:	01 83       	std	Z+1, r16	; 0x01
    daa8:	83 ed       	ldi	r24, 0xD3	; 211
    daaa:	92 e1       	ldi	r25, 0x12	; 18
    daac:	13 96       	adiw	r26, 0x03	; 3
    daae:	9c 93       	st	X, r25
    dab0:	8e 93       	st	-X, r24
    dab2:	12 97       	sbiw	r26, 0x02	; 2
    dab4:	e0 91 06 03 	lds	r30, 0x0306
    dab8:	f0 91 07 03 	lds	r31, 0x0307
    dabc:	e6 5f       	subi	r30, 0xF6	; 246
    dabe:	fc 4f       	sbci	r31, 0xFC	; 252
    dac0:	80 81       	ld	r24, Z
    dac2:	14 96       	adiw	r26, 0x04	; 4
    dac4:	8c 93       	st	X, r24
    dac6:	14 97       	sbiw	r26, 0x04	; 4
    dac8:	15 96       	adiw	r26, 0x05	; 5
    daca:	1c 92       	st	X, r1
    dacc:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    dad0:	f8 01       	movw	r30, r16
    dad2:	01 90       	ld	r0, Z+
    dad4:	00 20       	and	r0, r0
    dad6:	e9 f7       	brne	.-6      	; 0xdad2 <FMenuSettingClientIP+0x442>
    dad8:	31 97       	sbiw	r30, 0x01	; 1
    dada:	e0 1b       	sub	r30, r16
    dadc:	f1 0b       	sbc	r31, r17
    dade:	8d b7       	in	r24, 0x3d	; 61
    dae0:	9e b7       	in	r25, 0x3e	; 62
    dae2:	06 96       	adiw	r24, 0x06	; 6
    dae4:	0f b6       	in	r0, 0x3f	; 63
    dae6:	f8 94       	cli
    dae8:	9e bf       	out	0x3e, r25	; 62
    daea:	0f be       	out	0x3f, r0	; 63
    daec:	8d bf       	out	0x3d, r24	; 61
    daee:	60 91 11 03 	lds	r22, 0x0311
    daf2:	6f 5f       	subi	r22, 0xFF	; 255
    daf4:	80 91 06 03 	lds	r24, 0x0306
    daf8:	90 91 07 03 	lds	r25, 0x0307
    dafc:	88 0f       	add	r24, r24
    dafe:	99 1f       	adc	r25, r25
    db00:	88 0f       	add	r24, r24
    db02:	99 1f       	adc	r25, r25
    db04:	68 0f       	add	r22, r24
    db06:	6e 1b       	sub	r22, r30
    db08:	80 91 10 03 	lds	r24, 0x0310
    db0c:	a8 01       	movw	r20, r16
    db0e:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    db12:	80 91 06 03 	lds	r24, 0x0306
    db16:	90 91 07 03 	lds	r25, 0x0307
    db1a:	00 97       	sbiw	r24, 0x00	; 0
    db1c:	81 f0       	breq	.+32     	; 0xdb3e <FMenuSettingClientIP+0x4ae>
    db1e:	60 91 11 03 	lds	r22, 0x0311
    db22:	6f 5f       	subi	r22, 0xFF	; 255
    db24:	81 50       	subi	r24, 0x01	; 1
    db26:	90 4c       	sbci	r25, 0xC0	; 192
    db28:	88 0f       	add	r24, r24
    db2a:	99 1f       	adc	r25, r25
    db2c:	88 0f       	add	r24, r24
    db2e:	99 1f       	adc	r25, r25
    db30:	68 0f       	add	r22, r24
    db32:	80 91 10 03 	lds	r24, 0x0310
    db36:	41 ed       	ldi	r20, 0xD1	; 209
    db38:	52 e1       	ldi	r21, 0x12	; 18
    db3a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				       iInput=0;
    db3e:	10 92 0f 03 	sts	0x030F, r1
					   iBlok++;	   
    db42:	80 91 06 03 	lds	r24, 0x0306
    db46:	90 91 07 03 	lds	r25, 0x0307
    db4a:	01 96       	adiw	r24, 0x01	; 1
    db4c:	90 93 07 03 	sts	0x0307, r25
    db50:	80 93 06 03 	sts	0x0306, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    db54:	80 91 06 03 	lds	r24, 0x0306
    db58:	90 91 07 03 	lds	r25, 0x0307
    db5c:	04 97       	sbiw	r24, 0x04	; 4
    db5e:	a8 f0       	brcs	.+42     	; 0xdb8a <FMenuSettingClientIP+0x4fa>
    db60:	84 e0       	ldi	r24, 0x04	; 4
    db62:	0b c0       	rjmp	.+22     	; 0xdb7a <FMenuSettingClientIP+0x4ea>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    db64:	88 e2       	ldi	r24, 0x28	; 40
    db66:	90 e0       	ldi	r25, 0x00	; 0
    db68:	6a e0       	ldi	r22, 0x0A	; 10
    db6a:	73 e0       	ldi	r23, 0x03	; 3
    db6c:	44 e0       	ldi	r20, 0x04	; 4
    db6e:	50 e0       	ldi	r21, 0x00	; 0
    db70:	2d ed       	ldi	r18, 0xDD	; 221
    db72:	32 e1       	ldi	r19, 0x12	; 18
    db74:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
			   }
		       break;
          case cipStoreIPblok://UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefClientIP,4);
			   stClientIP=cipExit;
    db78:	83 e0       	ldi	r24, 0x03	; 3
    db7a:	80 93 59 01 	sts	0x0159, r24
    db7e:	05 c0       	rjmp	.+10     	; 0xdb8a <FMenuSettingClientIP+0x4fa>
		       break; 
          case cipExit://Cancel IPConfig
		       stClientIP=cipInit;
    db80:	81 e0       	ldi	r24, 0x01	; 1
    db82:	80 93 59 01 	sts	0x0159, r24
		       Result=MENU_DONE;
    db86:	80 93 13 03 	sts	0x0313, r24
		       break;     
		  }//EndSwitch	 
    return Result;
}
    db8a:	80 91 13 03 	lds	r24, 0x0313
    db8e:	64 96       	adiw	r28, 0x14	; 20
    db90:	0f b6       	in	r0, 0x3f	; 63
    db92:	f8 94       	cli
    db94:	de bf       	out	0x3e, r29	; 62
    db96:	0f be       	out	0x3f, r0	; 63
    db98:	cd bf       	out	0x3d, r28	; 61
    db9a:	cf 91       	pop	r28
    db9c:	df 91       	pop	r29
    db9e:	1f 91       	pop	r17
    dba0:	0f 91       	pop	r16
    dba2:	08 95       	ret

0000dba4 <DisplayStandaloneSequence>:
	 i++;
     _delay_ms(6500);
  return Result;
}

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
    dba4:	df 93       	push	r29
    dba6:	cf 93       	push	r28
    dba8:	cd b7       	in	r28, 0x3d	; 61
    dbaa:	de b7       	in	r29, 0x3e	; 62
    dbac:	28 97       	sbiw	r28, 0x08	; 8
    dbae:	0f b6       	in	r0, 0x3f	; 63
    dbb0:	f8 94       	cli
    dbb2:	de bf       	out	0x3e, r29	; 62
    dbb4:	0f be       	out	0x3f, r0	; 63
    dbb6:	cd bf       	out	0x3d, r28	; 61
    dbb8:	58 2f       	mov	r21, r24
	 MapSequence[3]='/';
	 MapSequence[4]='-';
	 MapSequence[5]=164;//0x5C;
	 MapSequence[6]='|';
	 MapSequence[7]='/';
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    dbba:	80 91 96 01 	lds	r24, 0x0196
    dbbe:	88 23       	and	r24, r24
    dbc0:	a1 f4       	brne	.+40     	; 0xdbea <DisplayStandaloneSequence+0x46>

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
     char MapSequence[8];

     //sprintf_P(MapSequence,PSTR("-\|/-|/"));
	 MapSequence[0]='-';
    dbc2:	3d e2       	ldi	r19, 0x2D	; 45
    dbc4:	39 83       	std	Y+1, r19	; 0x01
	 MapSequence[1]='`';//0x5C;
    dbc6:	80 e6       	ldi	r24, 0x60	; 96
    dbc8:	8a 83       	std	Y+2, r24	; 0x02
	 MapSequence[2]='|';
    dbca:	2c e7       	ldi	r18, 0x7C	; 124
    dbcc:	2b 83       	std	Y+3, r18	; 0x03
	 MapSequence[3]='/';
    dbce:	9f e2       	ldi	r25, 0x2F	; 47
    dbd0:	9c 83       	std	Y+4, r25	; 0x04
	 MapSequence[4]='-';
    dbd2:	3d 83       	std	Y+5, r19	; 0x05
	 MapSequence[5]=164;//0x5C;
    dbd4:	84 ea       	ldi	r24, 0xA4	; 164
    dbd6:	8e 83       	std	Y+6, r24	; 0x06
	 MapSequence[6]='|';
    dbd8:	2f 83       	std	Y+7, r18	; 0x07
	 MapSequence[7]='/';
    dbda:	98 87       	std	Y+8, r25	; 0x08
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    dbdc:	47 70       	andi	r20, 0x07	; 7
    dbde:	fe 01       	movw	r30, r28
    dbe0:	e4 0f       	add	r30, r20
    dbe2:	f1 1d       	adc	r31, r1
    dbe4:	85 2f       	mov	r24, r21
    dbe6:	41 81       	ldd	r20, Z+1	; 0x01
    dbe8:	08 c0       	rjmp	.+16     	; 0xdbfa <DisplayStandaloneSequence+0x56>
	 else if (IsPoolingRestarted==True){
    dbea:	80 91 96 01 	lds	r24, 0x0196
    dbee:	81 30       	cpi	r24, 0x01	; 1
    dbf0:	31 f4       	brne	.+12     	; 0xdbfe <DisplayStandaloneSequence+0x5a>
	          IsPoolingRestarted=False;
    dbf2:	10 92 96 01 	sts	0x0196, r1
	          lcd_put(x,y,'X');     
    dbf6:	85 2f       	mov	r24, r21
    dbf8:	48 e5       	ldi	r20, 0x58	; 88
    dbfa:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
			  }

}
    dbfe:	28 96       	adiw	r28, 0x08	; 8
    dc00:	0f b6       	in	r0, 0x3f	; 63
    dc02:	f8 94       	cli
    dc04:	de bf       	out	0x3e, r29	; 62
    dc06:	0f be       	out	0x3f, r0	; 63
    dc08:	cd bf       	out	0x3d, r28	; 61
    dc0a:	cf 91       	pop	r28
    dc0c:	df 91       	pop	r29
    dc0e:	08 95       	ret

0000dc10 <FSettingPumpPooling>:
	      break;
	 }
     return Result;
}

char FSettingPumpPooling(){//Parameter: PumpCount,
    dc10:	0f 93       	push	r16
    dc12:	1f 93       	push	r17
    dc14:	df 93       	push	r29
    dc16:	cf 93       	push	r28
    dc18:	cd b7       	in	r28, 0x3d	; 61
    dc1a:	de b7       	in	r29, 0x3e	; 62
    dc1c:	6a 97       	sbiw	r28, 0x1a	; 26
    dc1e:	0f b6       	in	r0, 0x3f	; 63
    dc20:	f8 94       	cli
    dc22:	de bf       	out	0x3e, r29	; 62
    dc24:	0f be       	out	0x3f, r0	; 63
    dc26:	cd bf       	out	0x3d, r28	; 61
static char stPumpPooling=ppInitMenu;
char i,lcdteks[20];
char KeyChar,Addr=0,PPoolingSetting[6];
     Result=MENU_NONE;

     switch(stPumpPooling){
    dc28:	80 91 df 02 	lds	r24, 0x02DF
    dc2c:	82 30       	cpi	r24, 0x02	; 2
    dc2e:	09 f4       	brne	.+2      	; 0xdc32 <FSettingPumpPooling+0x22>
    dc30:	1b c1       	rjmp	.+566    	; 0xde68 <FSettingPumpPooling+0x258>
    dc32:	83 30       	cpi	r24, 0x03	; 3
    dc34:	30 f4       	brcc	.+12     	; 0xdc42 <FSettingPumpPooling+0x32>
    dc36:	88 23       	and	r24, r24
    dc38:	59 f0       	breq	.+22     	; 0xdc50 <FSettingPumpPooling+0x40>
    dc3a:	81 30       	cpi	r24, 0x01	; 1
    dc3c:	09 f0       	breq	.+2      	; 0xdc40 <FSettingPumpPooling+0x30>
    dc3e:	1b c2       	rjmp	.+1078   	; 0xe076 <FSettingPumpPooling+0x466>
    dc40:	09 c1       	rjmp	.+530    	; 0xde54 <FSettingPumpPooling+0x244>
    dc42:	83 30       	cpi	r24, 0x03	; 3
    dc44:	09 f4       	brne	.+2      	; 0xdc48 <FSettingPumpPooling+0x38>
    dc46:	06 c2       	rjmp	.+1036   	; 0xe054 <FSettingPumpPooling+0x444>
    dc48:	84 30       	cpi	r24, 0x04	; 4
    dc4a:	09 f0       	breq	.+2      	; 0xdc4e <FSettingPumpPooling+0x3e>
    dc4c:	14 c2       	rjmp	.+1064   	; 0xe076 <FSettingPumpPooling+0x466>
    dc4e:	0f c2       	rjmp	.+1054   	; 0xe06e <FSettingPumpPooling+0x45e>
	 case ppInitMenu:
          lcd_clear();
    dc50:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
    dc54:	20 e0       	ldi	r18, 0x00	; 0
    dc56:	30 e0       	ldi	r19, 0x00	; 0
		  for (i=0;i<6;i++){
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
    dc58:	ae 01       	movw	r20, r28
    dc5a:	4f 5f       	subi	r20, 0xFF	; 255
    dc5c:	5f 4f       	sbci	r21, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    dc5e:	e1 99       	sbic	0x1c, 1	; 28
    dc60:	fe cf       	rjmp	.-4      	; 0xdc5e <FSettingPumpPooling+0x4e>
    dc62:	c9 01       	movw	r24, r18
    dc64:	8c 5b       	subi	r24, 0xBC	; 188
    dc66:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    dc68:	9f bb       	out	0x1f, r25	; 31
    dc6a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    dc6c:	e0 9a       	sbi	0x1c, 0	; 28
    dc6e:	8d b3       	in	r24, 0x1d	; 29
    dc70:	fa 01       	movw	r30, r20
    dc72:	e2 0f       	add	r30, r18
    dc74:	f3 1f       	adc	r31, r19
    dc76:	80 83       	st	Z, r24
    dc78:	2f 5f       	subi	r18, 0xFF	; 255
    dc7a:	3f 4f       	sbci	r19, 0xFF	; 255
     Result=MENU_NONE;

     switch(stPumpPooling){
	 case ppInitMenu:
          lcd_clear();
		  for (i=0;i<6;i++){
    dc7c:	26 30       	cpi	r18, 0x06	; 6
    dc7e:	31 05       	cpc	r19, r1
    dc80:	71 f7       	brne	.-36     	; 0xdc5e <FSettingPumpPooling+0x4e>
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
		  }

		  sprintf_P(lcdteks,PSTR("1.MaxPump:%d"),PPoolingSetting[0]);lcd_print(1,1,lcdteks);
    dc82:	00 d0       	rcall	.+0      	; 0xdc84 <FSettingPumpPooling+0x74>
    dc84:	00 d0       	rcall	.+0      	; 0xdc86 <FSettingPumpPooling+0x76>
    dc86:	00 d0       	rcall	.+0      	; 0xdc88 <FSettingPumpPooling+0x78>
    dc88:	ed b7       	in	r30, 0x3d	; 61
    dc8a:	fe b7       	in	r31, 0x3e	; 62
    dc8c:	31 96       	adiw	r30, 0x01	; 1
    dc8e:	8e 01       	movw	r16, r28
    dc90:	09 5f       	subi	r16, 0xF9	; 249
    dc92:	1f 4f       	sbci	r17, 0xFF	; 255
    dc94:	ad b7       	in	r26, 0x3d	; 61
    dc96:	be b7       	in	r27, 0x3e	; 62
    dc98:	12 96       	adiw	r26, 0x02	; 2
    dc9a:	1c 93       	st	X, r17
    dc9c:	0e 93       	st	-X, r16
    dc9e:	11 97       	sbiw	r26, 0x01	; 1
    dca0:	8c e9       	ldi	r24, 0x9C	; 156
    dca2:	9d e0       	ldi	r25, 0x0D	; 13
    dca4:	93 83       	std	Z+3, r25	; 0x03
    dca6:	82 83       	std	Z+2, r24	; 0x02
    dca8:	89 81       	ldd	r24, Y+1	; 0x01
    dcaa:	84 83       	std	Z+4, r24	; 0x04
    dcac:	15 82       	std	Z+5, r1	; 0x05
    dcae:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    dcb2:	ed b7       	in	r30, 0x3d	; 61
    dcb4:	fe b7       	in	r31, 0x3e	; 62
    dcb6:	36 96       	adiw	r30, 0x06	; 6
    dcb8:	0f b6       	in	r0, 0x3f	; 63
    dcba:	f8 94       	cli
    dcbc:	fe bf       	out	0x3e, r31	; 62
    dcbe:	0f be       	out	0x3f, r0	; 63
    dcc0:	ed bf       	out	0x3d, r30	; 61
    dcc2:	81 e0       	ldi	r24, 0x01	; 1
    dcc4:	61 e0       	ldi	r22, 0x01	; 1
    dcc6:	a8 01       	movw	r20, r16
    dcc8:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
          sprintf_P(lcdteks,PSTR("2.nNoPump:%d"),PPoolingSetting[1]);lcd_print(2,1,lcdteks);
    dccc:	00 d0       	rcall	.+0      	; 0xdcce <FSettingPumpPooling+0xbe>
    dcce:	00 d0       	rcall	.+0      	; 0xdcd0 <FSettingPumpPooling+0xc0>
    dcd0:	00 d0       	rcall	.+0      	; 0xdcd2 <FSettingPumpPooling+0xc2>
    dcd2:	ed b7       	in	r30, 0x3d	; 61
    dcd4:	fe b7       	in	r31, 0x3e	; 62
    dcd6:	31 96       	adiw	r30, 0x01	; 1
    dcd8:	ad b7       	in	r26, 0x3d	; 61
    dcda:	be b7       	in	r27, 0x3e	; 62
    dcdc:	12 96       	adiw	r26, 0x02	; 2
    dcde:	1c 93       	st	X, r17
    dce0:	0e 93       	st	-X, r16
    dce2:	11 97       	sbiw	r26, 0x01	; 1
    dce4:	8f e8       	ldi	r24, 0x8F	; 143
    dce6:	9d e0       	ldi	r25, 0x0D	; 13
    dce8:	93 83       	std	Z+3, r25	; 0x03
    dcea:	82 83       	std	Z+2, r24	; 0x02
    dcec:	8a 81       	ldd	r24, Y+2	; 0x02
    dcee:	84 83       	std	Z+4, r24	; 0x04
    dcf0:	15 82       	std	Z+5, r1	; 0x05
    dcf2:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    dcf6:	ed b7       	in	r30, 0x3d	; 61
    dcf8:	fe b7       	in	r31, 0x3e	; 62
    dcfa:	36 96       	adiw	r30, 0x06	; 6
    dcfc:	0f b6       	in	r0, 0x3f	; 63
    dcfe:	f8 94       	cli
    dd00:	fe bf       	out	0x3e, r31	; 62
    dd02:	0f be       	out	0x3f, r0	; 63
    dd04:	ed bf       	out	0x3d, r30	; 61
    dd06:	82 e0       	ldi	r24, 0x02	; 2
    dd08:	61 e0       	ldi	r22, 0x01	; 1
    dd0a:	a8 01       	movw	r20, r16
    dd0c:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
          sprintf_P(lcdteks,PSTR("3.TrySend:%d"),PPoolingSetting[2]);lcd_print(3,1,lcdteks);
    dd10:	00 d0       	rcall	.+0      	; 0xdd12 <FSettingPumpPooling+0x102>
    dd12:	00 d0       	rcall	.+0      	; 0xdd14 <FSettingPumpPooling+0x104>
    dd14:	00 d0       	rcall	.+0      	; 0xdd16 <FSettingPumpPooling+0x106>
    dd16:	ed b7       	in	r30, 0x3d	; 61
    dd18:	fe b7       	in	r31, 0x3e	; 62
    dd1a:	31 96       	adiw	r30, 0x01	; 1
    dd1c:	ad b7       	in	r26, 0x3d	; 61
    dd1e:	be b7       	in	r27, 0x3e	; 62
    dd20:	12 96       	adiw	r26, 0x02	; 2
    dd22:	1c 93       	st	X, r17
    dd24:	0e 93       	st	-X, r16
    dd26:	11 97       	sbiw	r26, 0x01	; 1
    dd28:	82 e8       	ldi	r24, 0x82	; 130
    dd2a:	9d e0       	ldi	r25, 0x0D	; 13
    dd2c:	93 83       	std	Z+3, r25	; 0x03
    dd2e:	82 83       	std	Z+2, r24	; 0x02
    dd30:	8b 81       	ldd	r24, Y+3	; 0x03
    dd32:	84 83       	std	Z+4, r24	; 0x04
    dd34:	15 82       	std	Z+5, r1	; 0x05
    dd36:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    dd3a:	ed b7       	in	r30, 0x3d	; 61
    dd3c:	fe b7       	in	r31, 0x3e	; 62
    dd3e:	36 96       	adiw	r30, 0x06	; 6
    dd40:	0f b6       	in	r0, 0x3f	; 63
    dd42:	f8 94       	cli
    dd44:	fe bf       	out	0x3e, r31	; 62
    dd46:	0f be       	out	0x3f, r0	; 63
    dd48:	ed bf       	out	0x3d, r30	; 61
    dd4a:	83 e0       	ldi	r24, 0x03	; 3
    dd4c:	61 e0       	ldi	r22, 0x01	; 1
    dd4e:	a8 01       	movw	r20, r16
    dd50:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
          sprintf_P(lcdteks,PSTR("4.TimPool:%d"),PPoolingSetting[3]);lcd_print(4,1,lcdteks);
    dd54:	00 d0       	rcall	.+0      	; 0xdd56 <FSettingPumpPooling+0x146>
    dd56:	00 d0       	rcall	.+0      	; 0xdd58 <FSettingPumpPooling+0x148>
    dd58:	00 d0       	rcall	.+0      	; 0xdd5a <FSettingPumpPooling+0x14a>
    dd5a:	ed b7       	in	r30, 0x3d	; 61
    dd5c:	fe b7       	in	r31, 0x3e	; 62
    dd5e:	31 96       	adiw	r30, 0x01	; 1
    dd60:	ad b7       	in	r26, 0x3d	; 61
    dd62:	be b7       	in	r27, 0x3e	; 62
    dd64:	12 96       	adiw	r26, 0x02	; 2
    dd66:	1c 93       	st	X, r17
    dd68:	0e 93       	st	-X, r16
    dd6a:	11 97       	sbiw	r26, 0x01	; 1
    dd6c:	85 e7       	ldi	r24, 0x75	; 117
    dd6e:	9d e0       	ldi	r25, 0x0D	; 13
    dd70:	93 83       	std	Z+3, r25	; 0x03
    dd72:	82 83       	std	Z+2, r24	; 0x02
    dd74:	8c 81       	ldd	r24, Y+4	; 0x04
    dd76:	84 83       	std	Z+4, r24	; 0x04
    dd78:	15 82       	std	Z+5, r1	; 0x05
    dd7a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    dd7e:	ed b7       	in	r30, 0x3d	; 61
    dd80:	fe b7       	in	r31, 0x3e	; 62
    dd82:	36 96       	adiw	r30, 0x06	; 6
    dd84:	0f b6       	in	r0, 0x3f	; 63
    dd86:	f8 94       	cli
    dd88:	fe bf       	out	0x3e, r31	; 62
    dd8a:	0f be       	out	0x3f, r0	; 63
    dd8c:	ed bf       	out	0x3d, r30	; 61
    dd8e:	84 e0       	ldi	r24, 0x04	; 4
    dd90:	61 e0       	ldi	r22, 0x01	; 1
    dd92:	a8 01       	movw	r20, r16
    dd94:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
          sprintf_P(lcdteks,PSTR("5.Dly:%d"),PPoolingSetting[4]);lcd_print(1,13,lcdteks);
    dd98:	00 d0       	rcall	.+0      	; 0xdd9a <FSettingPumpPooling+0x18a>
    dd9a:	00 d0       	rcall	.+0      	; 0xdd9c <FSettingPumpPooling+0x18c>
    dd9c:	00 d0       	rcall	.+0      	; 0xdd9e <FSettingPumpPooling+0x18e>
    dd9e:	ed b7       	in	r30, 0x3d	; 61
    dda0:	fe b7       	in	r31, 0x3e	; 62
    dda2:	31 96       	adiw	r30, 0x01	; 1
    dda4:	ad b7       	in	r26, 0x3d	; 61
    dda6:	be b7       	in	r27, 0x3e	; 62
    dda8:	12 96       	adiw	r26, 0x02	; 2
    ddaa:	1c 93       	st	X, r17
    ddac:	0e 93       	st	-X, r16
    ddae:	11 97       	sbiw	r26, 0x01	; 1
    ddb0:	8c e6       	ldi	r24, 0x6C	; 108
    ddb2:	9d e0       	ldi	r25, 0x0D	; 13
    ddb4:	93 83       	std	Z+3, r25	; 0x03
    ddb6:	82 83       	std	Z+2, r24	; 0x02
    ddb8:	8d 81       	ldd	r24, Y+5	; 0x05
    ddba:	84 83       	std	Z+4, r24	; 0x04
    ddbc:	15 82       	std	Z+5, r1	; 0x05
    ddbe:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    ddc2:	ed b7       	in	r30, 0x3d	; 61
    ddc4:	fe b7       	in	r31, 0x3e	; 62
    ddc6:	36 96       	adiw	r30, 0x06	; 6
    ddc8:	0f b6       	in	r0, 0x3f	; 63
    ddca:	f8 94       	cli
    ddcc:	fe bf       	out	0x3e, r31	; 62
    ddce:	0f be       	out	0x3f, r0	; 63
    ddd0:	ed bf       	out	0x3d, r30	; 61
    ddd2:	81 e0       	ldi	r24, 0x01	; 1
    ddd4:	6d e0       	ldi	r22, 0x0D	; 13
    ddd6:	a8 01       	movw	r20, r16
    ddd8:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
          sprintf_P(lcdteks,PSTR("6.Act:%d"),PPoolingSetting[5]);lcd_print(2,13,lcdteks);
    dddc:	00 d0       	rcall	.+0      	; 0xddde <FSettingPumpPooling+0x1ce>
    ddde:	00 d0       	rcall	.+0      	; 0xdde0 <FSettingPumpPooling+0x1d0>
    dde0:	00 d0       	rcall	.+0      	; 0xdde2 <FSettingPumpPooling+0x1d2>
    dde2:	ed b7       	in	r30, 0x3d	; 61
    dde4:	fe b7       	in	r31, 0x3e	; 62
    dde6:	31 96       	adiw	r30, 0x01	; 1
    dde8:	ad b7       	in	r26, 0x3d	; 61
    ddea:	be b7       	in	r27, 0x3e	; 62
    ddec:	12 96       	adiw	r26, 0x02	; 2
    ddee:	1c 93       	st	X, r17
    ddf0:	0e 93       	st	-X, r16
    ddf2:	11 97       	sbiw	r26, 0x01	; 1
    ddf4:	83 e6       	ldi	r24, 0x63	; 99
    ddf6:	9d e0       	ldi	r25, 0x0D	; 13
    ddf8:	93 83       	std	Z+3, r25	; 0x03
    ddfa:	82 83       	std	Z+2, r24	; 0x02
    ddfc:	8e 81       	ldd	r24, Y+6	; 0x06
    ddfe:	84 83       	std	Z+4, r24	; 0x04
    de00:	15 82       	std	Z+5, r1	; 0x05
    de02:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    de06:	ed b7       	in	r30, 0x3d	; 61
    de08:	fe b7       	in	r31, 0x3e	; 62
    de0a:	36 96       	adiw	r30, 0x06	; 6
    de0c:	0f b6       	in	r0, 0x3f	; 63
    de0e:	f8 94       	cli
    de10:	fe bf       	out	0x3e, r31	; 62
    de12:	0f be       	out	0x3f, r0	; 63
    de14:	ed bf       	out	0x3d, r30	; 61
    de16:	82 e0       	ldi	r24, 0x02	; 2
    de18:	6d e0       	ldi	r22, 0x0D	; 13
    de1a:	a8 01       	movw	r20, r16
    de1c:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
          sprintf_P(lcdteks,PSTR("[*]Exit"));lcd_print(4,13,lcdteks);
    de20:	00 d0       	rcall	.+0      	; 0xde22 <FSettingPumpPooling+0x212>
    de22:	00 d0       	rcall	.+0      	; 0xde24 <FSettingPumpPooling+0x214>
    de24:	ad b7       	in	r26, 0x3d	; 61
    de26:	be b7       	in	r27, 0x3e	; 62
    de28:	12 96       	adiw	r26, 0x02	; 2
    de2a:	1c 93       	st	X, r17
    de2c:	0e 93       	st	-X, r16
    de2e:	11 97       	sbiw	r26, 0x01	; 1
    de30:	8b e5       	ldi	r24, 0x5B	; 91
    de32:	9d e0       	ldi	r25, 0x0D	; 13
    de34:	14 96       	adiw	r26, 0x04	; 4
    de36:	9c 93       	st	X, r25
    de38:	8e 93       	st	-X, r24
    de3a:	13 97       	sbiw	r26, 0x03	; 3
    de3c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    de40:	0f 90       	pop	r0
    de42:	0f 90       	pop	r0
    de44:	0f 90       	pop	r0
    de46:	0f 90       	pop	r0
    de48:	84 e0       	ldi	r24, 0x04	; 4
    de4a:	6d e0       	ldi	r22, 0x0D	; 13
    de4c:	a8 01       	movw	r20, r16
    de4e:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    de52:	08 c0       	rjmp	.+16     	; 0xde64 <FSettingPumpPooling+0x254>

          stPumpPooling=ppPoolingSettingInput;
	      break;
     case ppDisplaySequence:
          IsNewPoolingSequence=False;
    de54:	10 92 94 01 	sts	0x0194, r1
		  DisplayStandaloneSequence(3,14,iSequencePooling);
    de58:	83 e0       	ldi	r24, 0x03	; 3
    de5a:	6e e0       	ldi	r22, 0x0E	; 14
    de5c:	40 91 93 01 	lds	r20, 0x0193
    de60:	0e 94 d2 6d 	call	0xdba4	; 0xdba4 <DisplayStandaloneSequence>
          stPumpPooling=ppPoolingSettingInput;
    de64:	82 e0       	ldi	r24, 0x02	; 2
    de66:	f3 c0       	rjmp	.+486    	; 0xe04e <FSettingPumpPooling+0x43e>
	      break;
     case ppPoolingSettingInput:
	      if(IsNewPoolingSequence==True)stPumpPooling=ppDisplaySequence;
    de68:	80 91 94 01 	lds	r24, 0x0194
    de6c:	81 30       	cpi	r24, 0x01	; 1
    de6e:	11 f4       	brne	.+4      	; 0xde74 <FSettingPumpPooling+0x264>
    de70:	80 93 df 02 	sts	0x02DF, r24

          KeyChar=_key_btn(_key_scan(1));
    de74:	81 e0       	ldi	r24, 0x01	; 1
    de76:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    de7a:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    de7e:	48 2f       	mov	r20, r24
    de80:	41 53       	subi	r20, 0x31	; 49
    de82:	46 30       	cpi	r20, 0x06	; 6
    de84:	10 f0       	brcs	.+4      	; 0xde8a <FSettingPumpPooling+0x27a>
    de86:	40 e0       	ldi	r20, 0x00	; 0
    de88:	06 c0       	rjmp	.+12     	; 0xde96 <FSettingPumpPooling+0x286>
		      Addr=KeyChar-'1';
			  TimSend=0;
    de8a:	10 92 a9 01 	sts	0x01A9, r1
    de8e:	10 92 a8 01 	sts	0x01A8, r1
			  IsStandaloneAcknoledge=False;
    de92:	10 92 95 01 	sts	0x0195, r1
          }
		  switch(KeyChar){
    de96:	83 33       	cpi	r24, 0x33	; 51
    de98:	09 f4       	brne	.+2      	; 0xde9c <FSettingPumpPooling+0x28c>
    de9a:	67 c0       	rjmp	.+206    	; 0xdf6a <FSettingPumpPooling+0x35a>
    de9c:	84 33       	cpi	r24, 0x34	; 52
    de9e:	48 f4       	brcc	.+18     	; 0xdeb2 <FSettingPumpPooling+0x2a2>
    dea0:	81 33       	cpi	r24, 0x31	; 49
    dea2:	89 f0       	breq	.+34     	; 0xdec6 <FSettingPumpPooling+0x2b6>
    dea4:	82 33       	cpi	r24, 0x32	; 50
    dea6:	08 f0       	brcs	.+2      	; 0xdeaa <FSettingPumpPooling+0x29a>
    dea8:	3d c0       	rjmp	.+122    	; 0xdf24 <FSettingPumpPooling+0x314>
    deaa:	8a 32       	cpi	r24, 0x2A	; 42
    deac:	09 f0       	breq	.+2      	; 0xdeb0 <FSettingPumpPooling+0x2a0>
    deae:	e3 c0       	rjmp	.+454    	; 0xe076 <FSettingPumpPooling+0x466>
    deb0:	cd c0       	rjmp	.+410    	; 0xe04c <FSettingPumpPooling+0x43c>
    deb2:	85 33       	cpi	r24, 0x35	; 53
    deb4:	09 f4       	brne	.+2      	; 0xdeb8 <FSettingPumpPooling+0x2a8>
    deb6:	91 c0       	rjmp	.+290    	; 0xdfda <FSettingPumpPooling+0x3ca>
    deb8:	85 33       	cpi	r24, 0x35	; 53
    deba:	08 f4       	brcc	.+2      	; 0xdebe <FSettingPumpPooling+0x2ae>
    debc:	78 c0       	rjmp	.+240    	; 0xdfae <FSettingPumpPooling+0x39e>
    debe:	86 33       	cpi	r24, 0x36	; 54
    dec0:	09 f0       	breq	.+2      	; 0xdec4 <FSettingPumpPooling+0x2b4>
    dec2:	d9 c0       	rjmp	.+434    	; 0xe076 <FSettingPumpPooling+0x466>
    dec4:	a0 c0       	rjmp	.+320    	; 0xe006 <FSettingPumpPooling+0x3f6>
		  case '1'://MaxPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%17);
    dec6:	24 2f       	mov	r18, r20
    dec8:	30 e0       	ldi	r19, 0x00	; 0
    deca:	fe 01       	movw	r30, r28
    decc:	31 96       	adiw	r30, 0x01	; 1
    dece:	e2 0f       	add	r30, r18
    ded0:	f3 1f       	adc	r31, r19
    ded2:	80 81       	ld	r24, Z
    ded4:	90 e0       	ldi	r25, 0x00	; 0
    ded6:	01 96       	adiw	r24, 0x01	; 1
    ded8:	61 e1       	ldi	r22, 0x11	; 17
    deda:	70 e0       	ldi	r23, 0x00	; 0
    dedc:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    dee0:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    dee2:	88 23       	and	r24, r24
    dee4:	11 f4       	brne	.+4      	; 0xdeea <FSettingPumpPooling+0x2da>
    dee6:	81 e0       	ldi	r24, 0x01	; 1
    dee8:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
    deea:	2c 0f       	add	r18, r28
    deec:	3d 1f       	adc	r19, r29
    deee:	f9 01       	movw	r30, r18
    def0:	21 81       	ldd	r18, Z+1	; 0x01
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    def2:	85 e1       	ldi	r24, 0x15	; 21
    def4:	80 93 da 07 	sts	0x07DA, r24
	 PoolMsg=plMsg;
    def8:	20 93 fe 0d 	sts	0x0DFE, r18
     IsControlPooling=True;
    defc:	81 e0       	ldi	r24, 0x01	; 1
    defe:	80 93 97 01 	sts	0x0197, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    df02:	e1 99       	sbic	0x1c, 1	; 28
    df04:	fe cf       	rjmp	.-4      	; 0xdf02 <FSettingPumpPooling+0x2f2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    df06:	84 2f       	mov	r24, r20
    df08:	90 e0       	ldi	r25, 0x00	; 0
    df0a:	8c 5b       	subi	r24, 0xBC	; 188
    df0c:	9e 4f       	sbci	r25, 0xFE	; 254
    df0e:	9f bb       	out	0x1f, r25	; 31
    df10:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    df12:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    df14:	0f b6       	in	r0, 0x3f	; 63
    df16:	f8 94       	cli
    df18:	e2 9a       	sbi	0x1c, 2	; 28
    df1a:	e1 9a       	sbi	0x1c, 1	; 28
    df1c:	0f be       	out	0x3f, r0	; 63
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   PumpCountMax=PPoolingSetting[Addr];
    df1e:	20 93 5f 01 	sts	0x015F, r18
    df22:	21 c0       	rjmp	.+66     	; 0xdf66 <FSettingPumpPooling+0x356>
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '2'://NoPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    df24:	fe 01       	movw	r30, r28
    df26:	e4 0f       	add	r30, r20
    df28:	f1 1d       	adc	r31, r1
    df2a:	81 81       	ldd	r24, Z+1	; 0x01
    df2c:	90 e0       	ldi	r25, 0x00	; 0
    df2e:	01 96       	adiw	r24, 0x01	; 1
    df30:	65 e1       	ldi	r22, 0x15	; 21
    df32:	70 e0       	ldi	r23, 0x00	; 0
    df34:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    df38:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    df3a:	84 e1       	ldi	r24, 0x14	; 20
    df3c:	80 93 da 07 	sts	0x07DA, r24
	 PoolMsg=plMsg;
    df40:	20 93 fe 0d 	sts	0x0DFE, r18
     IsControlPooling=True;
    df44:	81 e0       	ldi	r24, 0x01	; 1
    df46:	80 93 97 01 	sts	0x0197, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    df4a:	e1 99       	sbic	0x1c, 1	; 28
    df4c:	fe cf       	rjmp	.-4      	; 0xdf4a <FSettingPumpPooling+0x33a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    df4e:	84 2f       	mov	r24, r20
    df50:	90 e0       	ldi	r25, 0x00	; 0
    df52:	8c 5b       	subi	r24, 0xBC	; 188
    df54:	9e 4f       	sbci	r25, 0xFE	; 254
    df56:	9f bb       	out	0x1f, r25	; 31
    df58:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    df5a:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    df5c:	0f b6       	in	r0, 0x3f	; 63
    df5e:	f8 94       	cli
    df60:	e2 9a       	sbi	0x1c, 2	; 28
    df62:	e1 9a       	sbi	0x1c, 1	; 28
    df64:	0f be       	out	0x3f, r0	; 63
			   //SendSlaveCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
    df66:	83 e0       	ldi	r24, 0x03	; 3
    df68:	72 c0       	rjmp	.+228    	; 0xe04e <FSettingPumpPooling+0x43e>
		       break;
		  case '3'://TrySend
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    df6a:	24 2f       	mov	r18, r20
    df6c:	30 e0       	ldi	r19, 0x00	; 0
    df6e:	fe 01       	movw	r30, r28
    df70:	31 96       	adiw	r30, 0x01	; 1
    df72:	e2 0f       	add	r30, r18
    df74:	f3 1f       	adc	r31, r19
    df76:	80 81       	ld	r24, Z
    df78:	90 e0       	ldi	r25, 0x00	; 0
    df7a:	01 96       	adiw	r24, 0x01	; 1
    df7c:	65 e1       	ldi	r22, 0x15	; 21
    df7e:	70 e0       	ldi	r23, 0x00	; 0
    df80:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    df84:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    df86:	88 23       	and	r24, r24
    df88:	11 f4       	brne	.+4      	; 0xdf8e <FSettingPumpPooling+0x37e>
    df8a:	81 e0       	ldi	r24, 0x01	; 1
    df8c:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
    df8e:	2c 0f       	add	r18, r28
    df90:	3d 1f       	adc	r19, r29
    df92:	d9 01       	movw	r26, r18
    df94:	11 96       	adiw	r26, 0x01	; 1
    df96:	2c 91       	ld	r18, X
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    df98:	86 e1       	ldi	r24, 0x16	; 22
    df9a:	80 93 da 07 	sts	0x07DA, r24
	 PoolMsg=plMsg;
    df9e:	20 93 fe 0d 	sts	0x0DFE, r18
     IsControlPooling=True;
    dfa2:	81 e0       	ldi	r24, 0x01	; 1
    dfa4:	80 93 97 01 	sts	0x0197, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    dfa8:	e1 99       	sbic	0x1c, 1	; 28
    dfaa:	fe cf       	rjmp	.-4      	; 0xdfa8 <FSettingPumpPooling+0x398>
    dfac:	d0 cf       	rjmp	.-96     	; 0xdf4e <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '4'://TimPool
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    dfae:	fe 01       	movw	r30, r28
    dfb0:	e4 0f       	add	r30, r20
    dfb2:	f1 1d       	adc	r31, r1
    dfb4:	81 81       	ldd	r24, Z+1	; 0x01
    dfb6:	90 e0       	ldi	r25, 0x00	; 0
    dfb8:	01 96       	adiw	r24, 0x01	; 1
    dfba:	65 e1       	ldi	r22, 0x15	; 21
    dfbc:	70 e0       	ldi	r23, 0x00	; 0
    dfbe:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    dfc2:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    dfc4:	87 e1       	ldi	r24, 0x17	; 23
    dfc6:	80 93 da 07 	sts	0x07DA, r24
	 PoolMsg=plMsg;
    dfca:	20 93 fe 0d 	sts	0x0DFE, r18
     IsControlPooling=True;
    dfce:	81 e0       	ldi	r24, 0x01	; 1
    dfd0:	80 93 97 01 	sts	0x0197, r24
    dfd4:	e1 99       	sbic	0x1c, 1	; 28
    dfd6:	fe cf       	rjmp	.-4      	; 0xdfd4 <FSettingPumpPooling+0x3c4>
    dfd8:	ba cf       	rjmp	.-140    	; 0xdf4e <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '5'://DelayNextPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%41); 
    dfda:	fe 01       	movw	r30, r28
    dfdc:	e4 0f       	add	r30, r20
    dfde:	f1 1d       	adc	r31, r1
    dfe0:	81 81       	ldd	r24, Z+1	; 0x01
    dfe2:	90 e0       	ldi	r25, 0x00	; 0
    dfe4:	01 96       	adiw	r24, 0x01	; 1
    dfe6:	69 e2       	ldi	r22, 0x29	; 41
    dfe8:	70 e0       	ldi	r23, 0x00	; 0
    dfea:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    dfee:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    dff0:	88 e1       	ldi	r24, 0x18	; 24
    dff2:	80 93 da 07 	sts	0x07DA, r24
	 PoolMsg=plMsg;
    dff6:	20 93 fe 0d 	sts	0x0DFE, r18
     IsControlPooling=True;
    dffa:	81 e0       	ldi	r24, 0x01	; 1
    dffc:	80 93 97 01 	sts	0x0197, r24
    e000:	e1 99       	sbic	0x1c, 1	; 28
    e002:	fe cf       	rjmp	.-4      	; 0xe000 <FSettingPumpPooling+0x3f0>
    e004:	a4 cf       	rjmp	.-184    	; 0xdf4e <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
               stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '6'://ActivePump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%(1+eeprom_read_byte(&DefPoolingPumpMax))); 			       
    e006:	fe 01       	movw	r30, r28
    e008:	e4 0f       	add	r30, r20
    e00a:	f1 1d       	adc	r31, r1
    e00c:	21 81       	ldd	r18, Z+1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e00e:	e1 99       	sbic	0x1c, 1	; 28
    e010:	fe cf       	rjmp	.-4      	; 0xe00e <FSettingPumpPooling+0x3fe>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e012:	84 e4       	ldi	r24, 0x44	; 68
    e014:	91 e0       	ldi	r25, 0x01	; 1
    e016:	9f bb       	out	0x1f, r25	; 31
    e018:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e01a:	e0 9a       	sbi	0x1c, 0	; 28
    e01c:	6d b3       	in	r22, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e01e:	e1 99       	sbic	0x1c, 1	; 28
    e020:	fe cf       	rjmp	.-4      	; 0xe01e <FSettingPumpPooling+0x40e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e022:	84 2f       	mov	r24, r20
    e024:	90 e0       	ldi	r25, 0x00	; 0
    e026:	8c 5b       	subi	r24, 0xBC	; 188
    e028:	9e 4f       	sbci	r25, 0xFE	; 254
    e02a:	9f bb       	out	0x1f, r25	; 31
    e02c:	8e bb       	out	0x1e, r24	; 30
    e02e:	82 2f       	mov	r24, r18
    e030:	90 e0       	ldi	r25, 0x00	; 0
    e032:	70 e0       	ldi	r23, 0x00	; 0
    e034:	6f 5f       	subi	r22, 0xFF	; 255
    e036:	7f 4f       	sbci	r23, 0xFF	; 255
    e038:	01 96       	adiw	r24, 0x01	; 1
    e03a:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
#endif
    EEDR = __value;
    e03e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    e040:	0f b6       	in	r0, 0x3f	; 63
    e042:	f8 94       	cli
    e044:	e2 9a       	sbi	0x1c, 2	; 28
    e046:	e1 9a       	sbi	0x1c, 1	; 28
    e048:	0f be       	out	0x3f, r0	; 63
    e04a:	0e c0       	rjmp	.+28     	; 0xe068 <FSettingPumpPooling+0x458>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   stPumpPooling=ppInitMenu;
		       break;
		  case '*'://Exit
		       stPumpPooling=ppExitSettingPooling;		            
    e04c:	84 e0       	ldi	r24, 0x04	; 4
    e04e:	80 93 df 02 	sts	0x02DF, r24
    e052:	11 c0       	rjmp	.+34     	; 0xe076 <FSettingPumpPooling+0x466>
		       break;
		  }  
	      break;
     case ppWaitPoolingRespond:	    
	      if ((IsStandaloneAcknoledge==True)||(TimSend>5))stPumpPooling=ppInitMenu;
    e054:	80 91 95 01 	lds	r24, 0x0195
    e058:	81 30       	cpi	r24, 0x01	; 1
    e05a:	31 f0       	breq	.+12     	; 0xe068 <FSettingPumpPooling+0x458>
    e05c:	80 91 a8 01 	lds	r24, 0x01A8
    e060:	90 91 a9 01 	lds	r25, 0x01A9
    e064:	06 97       	sbiw	r24, 0x06	; 6
    e066:	38 f0       	brcs	.+14     	; 0xe076 <FSettingPumpPooling+0x466>
    e068:	10 92 df 02 	sts	0x02DF, r1
    e06c:	04 c0       	rjmp	.+8      	; 0xe076 <FSettingPumpPooling+0x466>
	      break;
     case ppExitSettingPooling:
          stPumpPooling=ppInitMenu;
    e06e:	10 92 df 02 	sts	0x02DF, r1
    e072:	81 e0       	ldi	r24, 0x01	; 1
    e074:	01 c0       	rjmp	.+2      	; 0xe078 <FSettingPumpPooling+0x468>
    e076:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
    }
return Result;
}
    e078:	6a 96       	adiw	r28, 0x1a	; 26
    e07a:	0f b6       	in	r0, 0x3f	; 63
    e07c:	f8 94       	cli
    e07e:	de bf       	out	0x3e, r29	; 62
    e080:	0f be       	out	0x3f, r0	; 63
    e082:	cd bf       	out	0x3d, r28	; 61
    e084:	cf 91       	pop	r28
    e086:	df 91       	pop	r29
    e088:	1f 91       	pop	r17
    e08a:	0f 91       	pop	r16
    e08c:	08 95       	ret

0000e08e <DisplayTicker>:
	 lcd_print(2, 1, lcdteks);
}

void DisplayTicker(){
static char stDisplayTicker=tiRight;
	switch(stDisplayTicker){
    e08e:	80 91 71 03 	lds	r24, 0x0371
    e092:	81 30       	cpi	r24, 0x01	; 1
    e094:	81 f0       	breq	.+32     	; 0xe0b6 <DisplayTicker+0x28>
    e096:	81 30       	cpi	r24, 0x01	; 1
    e098:	28 f0       	brcs	.+10     	; 0xe0a4 <DisplayTicker+0x16>
    e09a:	82 30       	cpi	r24, 0x02	; 2
    e09c:	91 f0       	breq	.+36     	; 0xe0c2 <DisplayTicker+0x34>
    e09e:	83 30       	cpi	r24, 0x03	; 3
    e0a0:	09 f5       	brne	.+66     	; 0xe0e4 <DisplayTicker+0x56>
    e0a2:	1a c0       	rjmp	.+52     	; 0xe0d8 <DisplayTicker+0x4a>
	case tiRight:
	     lcd_put(4, 1, '>');
    e0a4:	84 e0       	ldi	r24, 0x04	; 4
    e0a6:	61 e0       	ldi	r22, 0x01	; 1
    e0a8:	4e e3       	ldi	r20, 0x3E	; 62
    e0aa:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
		 TimTicker=0;
    e0ae:	10 92 a5 01 	sts	0x01A5, r1
         stDisplayTicker=tiDelayRight;
    e0b2:	81 e0       	ldi	r24, 0x01	; 1
    e0b4:	0e c0       	rjmp	.+28     	; 0xe0d2 <DisplayTicker+0x44>
	break;
	case tiDelayRight:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiLeft;	     
    e0b6:	80 91 a5 01 	lds	r24, 0x01A5
    e0ba:	8b 30       	cpi	r24, 0x0B	; 11
    e0bc:	98 f0       	brcs	.+38     	; 0xe0e4 <DisplayTicker+0x56>
    e0be:	82 e0       	ldi	r24, 0x02	; 2
    e0c0:	08 c0       	rjmp	.+16     	; 0xe0d2 <DisplayTicker+0x44>
	     break;
	case tiLeft:
	     lcd_put(4, 1, '<');
    e0c2:	84 e0       	ldi	r24, 0x04	; 4
    e0c4:	61 e0       	ldi	r22, 0x01	; 1
    e0c6:	4c e3       	ldi	r20, 0x3C	; 60
    e0c8:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
         TimTicker=0;
    e0cc:	10 92 a5 01 	sts	0x01A5, r1
         stDisplayTicker=tiDelayLeft;
    e0d0:	83 e0       	ldi	r24, 0x03	; 3
    e0d2:	80 93 71 03 	sts	0x0371, r24
    e0d6:	08 95       	ret
	break;
	case tiDelayLeft:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
    e0d8:	80 91 a5 01 	lds	r24, 0x01A5
    e0dc:	8b 30       	cpi	r24, 0x0B	; 11
    e0de:	10 f0       	brcs	.+4      	; 0xe0e4 <DisplayTicker+0x56>
    e0e0:	10 92 71 03 	sts	0x0371, r1
    e0e4:	08 95       	ret

0000e0e6 <DisplayIdle>:
	          lcd_put(x,y,'X');     
			  }

}

void DisplayIdle(){
    e0e6:	6f 92       	push	r6
    e0e8:	7f 92       	push	r7
    e0ea:	8f 92       	push	r8
    e0ec:	9f 92       	push	r9
    e0ee:	af 92       	push	r10
    e0f0:	bf 92       	push	r11
    e0f2:	cf 92       	push	r12
    e0f4:	df 92       	push	r13
    e0f6:	ff 92       	push	r15
    e0f8:	0f 93       	push	r16
    e0fa:	1f 93       	push	r17
    e0fc:	df 93       	push	r29
    e0fe:	cf 93       	push	r28
    e100:	cd b7       	in	r28, 0x3d	; 61
    e102:	de b7       	in	r29, 0x3e	; 62
    e104:	67 97       	sbiw	r28, 0x17	; 23
    e106:	0f b6       	in	r0, 0x3f	; 63
    e108:	f8 94       	cli
    e10a:	de bf       	out	0x3e, r29	; 62
    e10c:	0f be       	out	0x3f, r0	; 63
    e10e:	cd bf       	out	0x3d, r28	; 61
static unsigned int iLoopDisplayIdle=0;
static char stDispIdle=diScan;
     char i,iDisp;
     char lcdteks[20],sFIP[3];

     iLoopDisplayIdle++;
    e110:	80 91 6e 03 	lds	r24, 0x036E
    e114:	90 91 6f 03 	lds	r25, 0x036F
    e118:	01 96       	adiw	r24, 0x01	; 1
    e11a:	90 93 6f 03 	sts	0x036F, r25
    e11e:	80 93 6e 03 	sts	0x036E, r24
     //Setting DateTime ON

	if ((iLoopDisplayIdle%50)==0){
    e122:	62 e3       	ldi	r22, 0x32	; 50
    e124:	70 e0       	ldi	r23, 0x00	; 0
    e126:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
    e12a:	89 2b       	or	r24, r25
    e12c:	29 f5       	brne	.+74     	; 0xe178 <DisplayIdle+0x92>
	   if (IFType==IT_STANDALONE)DisplayPumpStatus();
    e12e:	80 91 10 01 	lds	r24, 0x0110
    e132:	82 30       	cpi	r24, 0x02	; 2
    e134:	11 f4       	brne	.+4      	; 0xe13a <DisplayIdle+0x54>
    e136:	0e 94 4f 41 	call	0x829e	; 0x829e <DisplayPumpStatus>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e13a:	e1 99       	sbic	0x1c, 1	; 28
    e13c:	fe cf       	rjmp	.-4      	; 0xe13a <DisplayIdle+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e13e:	87 e3       	ldi	r24, 0x37	; 55
    e140:	90 e0       	ldi	r25, 0x00	; 0
    e142:	9f bb       	out	0x1f, r25	; 31
    e144:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e146:	e0 9a       	sbi	0x1c, 0	; 28
    e148:	8d b3       	in	r24, 0x1d	; 29
	   if(eeprom_read_byte(&DefShowDateTime)) DisplayDateTime();
    e14a:	88 23       	and	r24, r24
    e14c:	19 f0       	breq	.+6      	; 0xe154 <DisplayIdle+0x6e>
    e14e:	0e 94 81 61 	call	0xc302	; 0xc302 <DisplayDateTime>
    e152:	02 c0       	rjmp	.+4      	; 0xe158 <DisplayIdle+0x72>
       else DisplayTicker();
    e154:	0e 94 47 70 	call	0xe08e	; 0xe08e <DisplayTicker>
	   //Display Standalone Sequnece
	   
	   if((IFType==IT_STANDALONE)&&(IsNewPoolingSequence==True)){
    e158:	80 91 10 01 	lds	r24, 0x0110
    e15c:	82 30       	cpi	r24, 0x02	; 2
    e15e:	61 f4       	brne	.+24     	; 0xe178 <DisplayIdle+0x92>
    e160:	80 91 94 01 	lds	r24, 0x0194
    e164:	81 30       	cpi	r24, 0x01	; 1
    e166:	41 f4       	brne	.+16     	; 0xe178 <DisplayIdle+0x92>
	       IsNewPoolingSequence=False;
    e168:	10 92 94 01 	sts	0x0194, r1
		   DisplayStandaloneSequence(4,18,iSequencePooling);
    e16c:	84 e0       	ldi	r24, 0x04	; 4
    e16e:	62 e1       	ldi	r22, 0x12	; 18
    e170:	40 91 93 01 	lds	r20, 0x0193
    e174:	0e 94 d2 6d 	call	0xdba4	; 0xdba4 <DisplayStandaloneSequence>

	 }
     //DisplayPumpStatus Standalone Mode

	 //Display Printing FIP
	 switch (stDispIdle){
    e178:	f0 90 6d 03 	lds	r15, 0x036D
    e17c:	ff 20       	and	r15, r15
    e17e:	29 f0       	breq	.+10     	; 0xe18a <DisplayIdle+0xa4>
    e180:	81 e0       	ldi	r24, 0x01	; 1
    e182:	f8 16       	cp	r15, r24
    e184:	09 f0       	breq	.+2      	; 0xe188 <DisplayIdle+0xa2>
    e186:	58 c0       	rjmp	.+176    	; 0xe238 <DisplayIdle+0x152>
    e188:	2f c0       	rjmp	.+94     	; 0xe1e8 <DisplayIdle+0x102>
	 case diScan:
	      if (IsBusyIdlePrinting==True){
    e18a:	f0 90 c8 01 	lds	r15, 0x01C8
    e18e:	91 e0       	ldi	r25, 0x01	; 1
    e190:	f9 16       	cp	r15, r25
    e192:	09 f0       	breq	.+2      	; 0xe196 <DisplayIdle+0xb0>
    e194:	51 c0       	rjmp	.+162    	; 0xe238 <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("Printing FIP%s "),strFIP_ID);
    e196:	00 d0       	rcall	.+0      	; 0xe198 <DisplayIdle+0xb2>
    e198:	00 d0       	rcall	.+0      	; 0xe19a <DisplayIdle+0xb4>
    e19a:	00 d0       	rcall	.+0      	; 0xe19c <DisplayIdle+0xb6>
    e19c:	ed b7       	in	r30, 0x3d	; 61
    e19e:	fe b7       	in	r31, 0x3e	; 62
    e1a0:	31 96       	adiw	r30, 0x01	; 1
    e1a2:	8e 01       	movw	r16, r28
    e1a4:	0c 5f       	subi	r16, 0xFC	; 252
    e1a6:	1f 4f       	sbci	r17, 0xFF	; 255
    e1a8:	ad b7       	in	r26, 0x3d	; 61
    e1aa:	be b7       	in	r27, 0x3e	; 62
    e1ac:	12 96       	adiw	r26, 0x02	; 2
    e1ae:	1c 93       	st	X, r17
    e1b0:	0e 93       	st	-X, r16
    e1b2:	11 97       	sbiw	r26, 0x01	; 1
    e1b4:	88 eb       	ldi	r24, 0xB8	; 184
    e1b6:	9b e1       	ldi	r25, 0x1B	; 27
    e1b8:	93 83       	std	Z+3, r25	; 0x03
    e1ba:	82 83       	std	Z+2, r24	; 0x02
    e1bc:	8c ee       	ldi	r24, 0xEC	; 236
    e1be:	99 e0       	ldi	r25, 0x09	; 9
    e1c0:	95 83       	std	Z+5, r25	; 0x05
    e1c2:	84 83       	std	Z+4, r24	; 0x04
    e1c4:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    e1c8:	ed b7       	in	r30, 0x3d	; 61
    e1ca:	fe b7       	in	r31, 0x3e	; 62
    e1cc:	36 96       	adiw	r30, 0x06	; 6
    e1ce:	0f b6       	in	r0, 0x3f	; 63
    e1d0:	f8 94       	cli
    e1d2:	fe bf       	out	0x3e, r31	; 62
    e1d4:	0f be       	out	0x3f, r0	; 63
    e1d6:	ed bf       	out	0x3d, r30	; 61
    e1d8:	83 e0       	ldi	r24, 0x03	; 3
    e1da:	61 e0       	ldi	r22, 0x01	; 1
    e1dc:	a8 01       	movw	r20, r16
    e1de:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			   stDispIdle=diWaitNoBusy;
    e1e2:	f0 92 6d 03 	sts	0x036D, r15
    e1e6:	28 c0       	rjmp	.+80     	; 0xe238 <DisplayIdle+0x152>
		  }         
	      break;
     case diWaitNoBusy:
	      if (IsBusyIdlePrinting==False){
    e1e8:	80 91 c8 01 	lds	r24, 0x01C8
    e1ec:	88 23       	and	r24, r24
    e1ee:	21 f5       	brne	.+72     	; 0xe238 <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("                    "));
    e1f0:	00 d0       	rcall	.+0      	; 0xe1f2 <DisplayIdle+0x10c>
    e1f2:	00 d0       	rcall	.+0      	; 0xe1f4 <DisplayIdle+0x10e>
    e1f4:	8e 01       	movw	r16, r28
    e1f6:	0c 5f       	subi	r16, 0xFC	; 252
    e1f8:	1f 4f       	sbci	r17, 0xFF	; 255
    e1fa:	ad b7       	in	r26, 0x3d	; 61
    e1fc:	be b7       	in	r27, 0x3e	; 62
    e1fe:	12 96       	adiw	r26, 0x02	; 2
    e200:	1c 93       	st	X, r17
    e202:	0e 93       	st	-X, r16
    e204:	11 97       	sbiw	r26, 0x01	; 1
    e206:	83 ea       	ldi	r24, 0xA3	; 163
    e208:	9b e1       	ldi	r25, 0x1B	; 27
    e20a:	14 96       	adiw	r26, 0x04	; 4
    e20c:	9c 93       	st	X, r25
    e20e:	8e 93       	st	-X, r24
    e210:	13 97       	sbiw	r26, 0x03	; 3
    e212:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    e216:	0f 90       	pop	r0
    e218:	0f 90       	pop	r0
    e21a:	0f 90       	pop	r0
    e21c:	0f 90       	pop	r0
    e21e:	83 e0       	ldi	r24, 0x03	; 3
    e220:	61 e0       	ldi	r22, 0x01	; 1
    e222:	a8 01       	movw	r20, r16
    e224:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			   stDispIdle=diScan;
    e228:	10 92 6d 03 	sts	0x036D, r1
			   if (nLocalAccount>0)IsViewFillingFIP=True;
    e22c:	80 91 a4 01 	lds	r24, 0x01A4
    e230:	88 23       	and	r24, r24
    e232:	11 f0       	breq	.+4      	; 0xe238 <DisplayIdle+0x152>
    e234:	f0 92 ad 01 	sts	0x01AD, r15
		  }
	      break;     
	 }
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
    e238:	80 91 ad 01 	lds	r24, 0x01AD
    e23c:	81 30       	cpi	r24, 0x01	; 1
    e23e:	09 f0       	breq	.+2      	; 0xe242 <DisplayIdle+0x15c>
    e240:	69 c0       	rjmp	.+210    	; 0xe314 <DisplayIdle+0x22e>
	     IsViewFillingFIP=False;
    e242:	10 92 ad 01 	sts	0x01AD, r1
		 if (nLocalAccount>0){
    e246:	80 91 a4 01 	lds	r24, 0x01A4
    e24a:	88 23       	and	r24, r24
    e24c:	09 f4       	brne	.+2      	; 0xe250 <DisplayIdle+0x16a>
    e24e:	5c c0       	rjmp	.+184    	; 0xe308 <DisplayIdle+0x222>
		     lcd_printf(3,1,PSTR("@FIP:"));
    e250:	83 e0       	ldi	r24, 0x03	; 3
    e252:	61 e0       	ldi	r22, 0x01	; 1
    e254:	4d e9       	ldi	r20, 0x9D	; 157
    e256:	5b e1       	ldi	r21, 0x1B	; 27
    e258:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
    e25c:	ff 24       	eor	r15, r15
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    e25e:	5e 01       	movw	r10, r28
    e260:	08 94       	sec
    e262:	a1 1c       	adc	r10, r1
    e264:	b1 1c       	adc	r11, r1
    e266:	38 e9       	ldi	r19, 0x98	; 152
    e268:	63 2e       	mov	r6, r19
    e26a:	3b e1       	ldi	r19, 0x1B	; 27
    e26c:	73 2e       	mov	r7, r19
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    e26e:	24 e0       	ldi	r18, 0x04	; 4
    e270:	c2 2e       	mov	r12, r18
    e272:	d1 2c       	mov	r13, r1
    e274:	cc 0e       	add	r12, r28
    e276:	dd 1e       	adc	r13, r29
    e278:	94 e9       	ldi	r25, 0x94	; 148
    e27a:	89 2e       	mov	r8, r25
    e27c:	9b e1       	ldi	r25, 0x1B	; 27
    e27e:	99 2e       	mov	r9, r25
    e280:	3d c0       	rjmp	.+122    	; 0xe2fc <DisplayIdle+0x216>
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    e282:	0f 2d       	mov	r16, r15
    e284:	10 e0       	ldi	r17, 0x00	; 0
    e286:	00 d0       	rcall	.+0      	; 0xe288 <DisplayIdle+0x1a2>
    e288:	00 d0       	rcall	.+0      	; 0xe28a <DisplayIdle+0x1a4>
    e28a:	00 d0       	rcall	.+0      	; 0xe28c <DisplayIdle+0x1a6>
    e28c:	ad b7       	in	r26, 0x3d	; 61
    e28e:	be b7       	in	r27, 0x3e	; 62
    e290:	11 96       	adiw	r26, 0x01	; 1
    e292:	ed b7       	in	r30, 0x3d	; 61
    e294:	fe b7       	in	r31, 0x3e	; 62
    e296:	b2 82       	std	Z+2, r11	; 0x02
    e298:	a1 82       	std	Z+1, r10	; 0x01
    e29a:	13 96       	adiw	r26, 0x03	; 3
    e29c:	7c 92       	st	X, r7
    e29e:	6e 92       	st	-X, r6
    e2a0:	12 97       	sbiw	r26, 0x02	; 2
    e2a2:	f8 01       	movw	r30, r16
    e2a4:	ea 5c       	subi	r30, 0xCA	; 202
    e2a6:	fa 4f       	sbci	r31, 0xFA	; 250
    e2a8:	80 81       	ld	r24, Z
    e2aa:	14 96       	adiw	r26, 0x04	; 4
    e2ac:	8c 93       	st	X, r24
    e2ae:	14 97       	sbiw	r26, 0x04	; 4
    e2b0:	15 96       	adiw	r26, 0x05	; 5
    e2b2:	1c 92       	st	X, r1
    e2b4:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    e2b8:	ed b7       	in	r30, 0x3d	; 61
    e2ba:	fe b7       	in	r31, 0x3e	; 62
    e2bc:	31 96       	adiw	r30, 0x01	; 1
    e2be:	ad b7       	in	r26, 0x3d	; 61
    e2c0:	be b7       	in	r27, 0x3e	; 62
    e2c2:	12 96       	adiw	r26, 0x02	; 2
    e2c4:	dc 92       	st	X, r13
    e2c6:	ce 92       	st	-X, r12
    e2c8:	11 97       	sbiw	r26, 0x01	; 1
    e2ca:	93 82       	std	Z+3, r9	; 0x03
    e2cc:	82 82       	std	Z+2, r8	; 0x02
    e2ce:	b5 82       	std	Z+5, r11	; 0x05
    e2d0:	a4 82       	std	Z+4, r10	; 0x04
    e2d2:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			      lcd_print(3,6+(iDisp*3),lcdteks);
    e2d6:	ed b7       	in	r30, 0x3d	; 61
    e2d8:	fe b7       	in	r31, 0x3e	; 62
    e2da:	36 96       	adiw	r30, 0x06	; 6
    e2dc:	0f b6       	in	r0, 0x3f	; 63
    e2de:	f8 94       	cli
    e2e0:	fe bf       	out	0x3e, r31	; 62
    e2e2:	0f be       	out	0x3f, r0	; 63
    e2e4:	ed bf       	out	0x3d, r30	; 61
    e2e6:	b8 01       	movw	r22, r16
    e2e8:	66 0f       	add	r22, r22
    e2ea:	77 1f       	adc	r23, r23
    e2ec:	60 0f       	add	r22, r16
    e2ee:	71 1f       	adc	r23, r17
    e2f0:	6a 5f       	subi	r22, 0xFA	; 250
    e2f2:	83 e0       	ldi	r24, 0x03	; 3
    e2f4:	a6 01       	movw	r20, r12
    e2f6:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
    e2fa:	f3 94       	inc	r15
    e2fc:	80 91 a4 01 	lds	r24, 0x01A4
    e300:	f8 16       	cp	r15, r24
    e302:	08 f4       	brcc	.+2      	; 0xe306 <DisplayIdle+0x220>
    e304:	be cf       	rjmp	.-132    	; 0xe282 <DisplayIdle+0x19c>
    e306:	06 c0       	rjmp	.+12     	; 0xe314 <DisplayIdle+0x22e>
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
			      lcd_print(3,6+(iDisp*3),lcdteks);
		     }
		 }else{
		 lcd_printf(3,1,PSTR("                    "));
    e308:	83 e0       	ldi	r24, 0x03	; 3
    e30a:	61 e0       	ldi	r22, 0x01	; 1
    e30c:	4f e7       	ldi	r20, 0x7F	; 127
    e30e:	5b e1       	ldi	r21, 0x1B	; 27
    e310:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		 }    
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
    e314:	80 91 c0 01 	lds	r24, 0x01C0
    e318:	81 30       	cpi	r24, 0x01	; 1
    e31a:	c1 f4       	brne	.+48     	; 0xe34c <DisplayIdle+0x266>
	     IsCompleteFilling=False;
    e31c:	10 92 c0 01 	sts	0x01C0, r1
	     if (nLocalAccount>0){
    e320:	90 91 a4 01 	lds	r25, 0x01A4
    e324:	99 23       	and	r25, r25
    e326:	91 f0       	breq	.+36     	; 0xe34c <DisplayIdle+0x266>
    e328:	e6 e3       	ldi	r30, 0x36	; 54
    e32a:	f5 e0       	ldi	r31, 0x05	; 5
			 for(i=0;i<nLocalAccount;i++){//Shift data
    e32c:	29 2f       	mov	r18, r25
    e32e:	30 e0       	ldi	r19, 0x00	; 0
    e330:	2e 0f       	add	r18, r30
    e332:	3f 1f       	adc	r19, r31
    e334:	02 c0       	rjmp	.+4      	; 0xe33a <DisplayIdle+0x254>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
    e336:	81 81       	ldd	r24, Z+1	; 0x01
    e338:	81 93       	st	Z+, r24
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
	     IsCompleteFilling=False;
	     if (nLocalAccount>0){
			 for(i=0;i<nLocalAccount;i++){//Shift data
    e33a:	e2 17       	cp	r30, r18
    e33c:	f3 07       	cpc	r31, r19
    e33e:	d9 f7       	brne	.-10     	; 0xe336 <DisplayIdle+0x250>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
			 }
			 nLocalAccount--;
    e340:	91 50       	subi	r25, 0x01	; 1
    e342:	90 93 a4 01 	sts	0x01A4, r25
             IsViewFillingFIP=True; 
    e346:	81 e0       	ldi	r24, 0x01	; 1
    e348:	80 93 ad 01 	sts	0x01AD, r24
		 }
	 }
}
    e34c:	67 96       	adiw	r28, 0x17	; 23
    e34e:	0f b6       	in	r0, 0x3f	; 63
    e350:	f8 94       	cli
    e352:	de bf       	out	0x3e, r29	; 62
    e354:	0f be       	out	0x3f, r0	; 63
    e356:	cd bf       	out	0x3d, r28	; 61
    e358:	cf 91       	pop	r28
    e35a:	df 91       	pop	r29
    e35c:	1f 91       	pop	r17
    e35e:	0f 91       	pop	r16
    e360:	ff 90       	pop	r15
    e362:	df 90       	pop	r13
    e364:	cf 90       	pop	r12
    e366:	bf 90       	pop	r11
    e368:	af 90       	pop	r10
    e36a:	9f 90       	pop	r9
    e36c:	8f 90       	pop	r8
    e36e:	7f 90       	pop	r7
    e370:	6f 90       	pop	r6
    e372:	08 95       	ret

0000e374 <systemMaster>:
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
}

void systemMaster(){
  	_spi_init(1, 0);         //Master
    e374:	81 e0       	ldi	r24, 0x01	; 1
    e376:	60 e0       	ldi	r22, 0x00	; 0
    e378:	0e 94 54 af 	call	0x15ea8	; 0x15ea8 <_spi_init>
    _spi_enable(_SPI_SLAVE); //Enable SS 
    e37c:	81 e0       	ldi	r24, 0x01	; 1
    e37e:	0e 94 67 af 	call	0x15ece	; 0x15ece <_spi_enable>
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
    e382:	bb 98       	cbi	0x17, 3	; 23
    e384:	c3 9a       	sbi	0x18, 3	; 24
	sbi(DDRB,2);             //MOSI Output
    e386:	ba 9a       	sbi	0x17, 2	; 23
}
    e388:	08 95       	ret

0000e38a <systemSlave>:




void systemSlave(){
    _spi_enable(_SPI_NONE);	
    e38a:	80 e0       	ldi	r24, 0x00	; 0
    e38c:	0e 94 67 af 	call	0x15ece	; 0x15ece <_spi_enable>
  	_spi_init(0, 1);         //Slave
    e390:	80 e0       	ldi	r24, 0x00	; 0
    e392:	61 e0       	ldi	r22, 0x01	; 1
    e394:	0e 94 54 af 	call	0x15ea8	; 0x15ea8 <_spi_init>
	sbi(DDRB,3);             //MISO Output
    e398:	bb 9a       	sbi	0x17, 3	; 23
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    e39a:	bb 9a       	sbi	0x17, 3	; 23
    e39c:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    e39e:	ba 98       	cbi	0x17, 2	; 23
    e3a0:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    e3a2:	b9 98       	cbi	0x17, 1	; 23
    e3a4:	c1 9a       	sbi	0x18, 1	; 24
}
    e3a6:	08 95       	ret

0000e3a8 <EDCSendByte>:
    _spi_enable(_SPI_SLAVE); //Enable SS 
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
	sbi(DDRB,2);             //MOSI Output
}

void EDCSendByte(char EDCData){
    e3a8:	1f 93       	push	r17
    e3aa:	18 2f       	mov	r17, r24
     systemMaster();	 
    e3ac:	0e 94 ba 71 	call	0xe374	; 0xe374 <systemMaster>
     _spi(EDCData);
    e3b0:	81 2f       	mov	r24, r17
    e3b2:	0e 94 7e af 	call	0x15efc	; 0x15efc <_spi>
     systemSlave();
    e3b6:	0e 94 c5 71 	call	0xe38a	; 0xe38a <systemSlave>
}
    e3ba:	1f 91       	pop	r17
    e3bc:	08 95       	ret

0000e3be <SendEDCMessage>:
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}

void SendEDCMessage(){
    e3be:	cf 92       	push	r12
    e3c0:	df 92       	push	r13
    e3c2:	ef 92       	push	r14
    e3c4:	ff 92       	push	r15
    e3c6:	0f 93       	push	r16
    e3c8:	1f 93       	push	r17
    e3ca:	df 93       	push	r29
    e3cc:	cf 93       	push	r28
    e3ce:	cd b7       	in	r28, 0x3d	; 61
    e3d0:	de b7       	in	r29, 0x3e	; 62
    e3d2:	ec 97       	sbiw	r28, 0x3c	; 60
    e3d4:	0f b6       	in	r0, 0x3f	; 63
    e3d6:	f8 94       	cli
    e3d8:	de bf       	out	0x3e, r29	; 62
    e3da:	0f be       	out	0x3f, r0	; 63
    e3dc:	cd bf       	out	0x3d, r28	; 61

     //GenerateData
	 //sprintf_P(strAmount,PSTR("%d"),100);//Testing Only
	 //AddZeroLead(strAmount,8);
	 //_uart_printf(0,0,PSTR("StrStatus:"));_uart_print(0,1,strStatus);
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     
    e3de:	8d b7       	in	r24, 0x3d	; 61
    e3e0:	9e b7       	in	r25, 0x3e	; 62
    e3e2:	42 97       	sbiw	r24, 0x12	; 18
    e3e4:	0f b6       	in	r0, 0x3f	; 63
    e3e6:	f8 94       	cli
    e3e8:	9e bf       	out	0x3e, r25	; 62
    e3ea:	0f be       	out	0x3f, r0	; 63
    e3ec:	8d bf       	out	0x3d, r24	; 61
    e3ee:	ed b7       	in	r30, 0x3d	; 61
    e3f0:	fe b7       	in	r31, 0x3e	; 62
    e3f2:	31 96       	adiw	r30, 0x01	; 1
    e3f4:	8e 01       	movw	r16, r28
    e3f6:	0f 5f       	subi	r16, 0xFF	; 255
    e3f8:	1f 4f       	sbci	r17, 0xFF	; 255
    e3fa:	ad b7       	in	r26, 0x3d	; 61
    e3fc:	be b7       	in	r27, 0x3e	; 62
    e3fe:	12 96       	adiw	r26, 0x02	; 2
    e400:	1c 93       	st	X, r17
    e402:	0e 93       	st	-X, r16
    e404:	11 97       	sbiw	r26, 0x01	; 1
    e406:	8c e6       	ldi	r24, 0x6C	; 108
    e408:	9b e1       	ldi	r25, 0x1B	; 27
    e40a:	93 83       	std	Z+3, r25	; 0x03
    e40c:	82 83       	std	Z+2, r24	; 0x02
    e40e:	81 eb       	ldi	r24, 0xB1	; 177
    e410:	9e e0       	ldi	r25, 0x0E	; 14
    e412:	95 83       	std	Z+5, r25	; 0x05
    e414:	84 83       	std	Z+4, r24	; 0x04
    e416:	8c ee       	ldi	r24, 0xEC	; 236
    e418:	99 e0       	ldi	r25, 0x09	; 9
    e41a:	97 83       	std	Z+7, r25	; 0x07
    e41c:	86 83       	std	Z+6, r24	; 0x06
    e41e:	81 e6       	ldi	r24, 0x61	; 97
    e420:	9a e0       	ldi	r25, 0x0A	; 10
    e422:	91 87       	std	Z+9, r25	; 0x09
    e424:	80 87       	std	Z+8, r24	; 0x08
    e426:	81 ed       	ldi	r24, 0xD1	; 209
    e428:	97 e0       	ldi	r25, 0x07	; 7
    e42a:	93 87       	std	Z+11, r25	; 0x0b
    e42c:	82 87       	std	Z+10, r24	; 0x0a
    e42e:	85 e5       	ldi	r24, 0x55	; 85
    e430:	95 e0       	ldi	r25, 0x05	; 5
    e432:	95 87       	std	Z+13, r25	; 0x0d
    e434:	84 87       	std	Z+12, r24	; 0x0c
    e436:	8b ed       	ldi	r24, 0xDB	; 219
    e438:	9d e0       	ldi	r25, 0x0D	; 13
    e43a:	97 87       	std	Z+15, r25	; 0x0f
    e43c:	86 87       	std	Z+14, r24	; 0x0e
    e43e:	8a eb       	ldi	r24, 0xBA	; 186
    e440:	95 e0       	ldi	r25, 0x05	; 5
    e442:	91 8b       	std	Z+17, r25	; 0x11
    e444:	80 8b       	std	Z+16, r24	; 0x10
    e446:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
    e44a:	8d b7       	in	r24, 0x3d	; 61
    e44c:	9e b7       	in	r25, 0x3e	; 62
    e44e:	42 96       	adiw	r24, 0x12	; 18
    e450:	0f b6       	in	r0, 0x3f	; 63
    e452:	f8 94       	cli
    e454:	9e bf       	out	0x3e, r25	; 62
    e456:	0f be       	out	0x3f, r0	; 63
    e458:	8d bf       	out	0x3d, r24	; 61
    e45a:	82 e0       	ldi	r24, 0x02	; 2
    e45c:	0e 94 d4 71 	call	0xe3a8	; 0xe3a8 <EDCSendByte>
    e460:	ff 24       	eor	r15, r15
    e462:	52 e0       	ldi	r21, 0x02	; 2
    e464:	e5 2e       	mov	r14, r21
    e466:	44 ec       	ldi	r20, 0xC4	; 196
    e468:	c4 2e       	mov	r12, r20
    e46a:	49 e0       	ldi	r20, 0x09	; 9
    e46c:	d4 2e       	mov	r13, r20
    e46e:	0a c0       	rjmp	.+20     	; 0xe484 <SendEDCMessage+0xc6>
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
    e470:	a0 0f       	add	r26, r16
    e472:	b1 1f       	adc	r27, r17
    e474:	8c 91       	ld	r24, X
     systemSlave();
}

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
    e476:	e8 26       	eor	r14, r24
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
    e478:	0e 94 d4 71 	call	0xe3a8	; 0xe3a8 <EDCSendByte>
    e47c:	c6 01       	movw	r24, r12
    e47e:	01 97       	sbiw	r24, 0x01	; 1
    e480:	f1 f7       	brne	.-4      	; 0xe47e <SendEDCMessage+0xc0>
	 //_uart_printf(0,0,PSTR("StrStatus:"));_uart_print(0,1,strStatus);
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
    e482:	f3 94       	inc	r15
    e484:	f8 01       	movw	r30, r16
    e486:	01 90       	ld	r0, Z+
    e488:	00 20       	and	r0, r0
    e48a:	e9 f7       	brne	.-6      	; 0xe486 <SendEDCMessage+0xc8>
    e48c:	31 97       	sbiw	r30, 0x01	; 1
    e48e:	e0 1b       	sub	r30, r16
    e490:	f1 0b       	sbc	r31, r17
    e492:	af 2d       	mov	r26, r15
    e494:	b0 e0       	ldi	r27, 0x00	; 0
    e496:	ae 17       	cp	r26, r30
    e498:	bf 07       	cpc	r27, r31
    e49a:	50 f3       	brcs	.-44     	; 0xe470 <SendEDCMessage+0xb2>
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
		  //_uart(0,1,SerialEDC[i]);
		  _delay_ms(10);//min:8
	 }
     EDCSendByte(0x03);
    e49c:	83 e0       	ldi	r24, 0x03	; 3
    e49e:	0e 94 d4 71 	call	0xe3a8	; 0xe3a8 <EDCSendByte>
	 xCRC=CalcLRC(xCRC,0x03);	      
	 EDCSendByte(xCRC);
    e4a2:	83 e0       	ldi	r24, 0x03	; 3
    e4a4:	8e 25       	eor	r24, r14
    e4a6:	0e 94 d4 71 	call	0xe3a8	; 0xe3a8 <EDCSendByte>
}
    e4aa:	ec 96       	adiw	r28, 0x3c	; 60
    e4ac:	0f b6       	in	r0, 0x3f	; 63
    e4ae:	f8 94       	cli
    e4b0:	de bf       	out	0x3e, r29	; 62
    e4b2:	0f be       	out	0x3f, r0	; 63
    e4b4:	cd bf       	out	0x3d, r28	; 61
    e4b6:	cf 91       	pop	r28
    e4b8:	df 91       	pop	r29
    e4ba:	1f 91       	pop	r17
    e4bc:	0f 91       	pop	r16
    e4be:	ff 90       	pop	r15
    e4c0:	ef 90       	pop	r14
    e4c2:	df 90       	pop	r13
    e4c4:	cf 90       	pop	r12
    e4c6:	08 95       	ret

0000e4c8 <SendSlaveCommand>:
void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
	 PoolMsg=plMsg;
     IsControlPooling=True;
}
void SendSlaveCommand(char SlaveCommand,char SlaveMessage){     
    e4c8:	0f 93       	push	r16
    e4ca:	1f 93       	push	r17
    e4cc:	18 2f       	mov	r17, r24
    e4ce:	06 2f       	mov	r16, r22
	 systemMaster();
    e4d0:	0e 94 ba 71 	call	0xe374	; 0xe374 <systemMaster>
	 _spi(0x05);
    e4d4:	85 e0       	ldi	r24, 0x05	; 5
    e4d6:	0e 94 7e af 	call	0x15efc	; 0x15efc <_spi>
	 _spi(SlaveCommand);
    e4da:	81 2f       	mov	r24, r17
    e4dc:	0e 94 7e af 	call	0x15efc	; 0x15efc <_spi>
	 _spi(SlaveMessage);
    e4e0:	80 2f       	mov	r24, r16
    e4e2:	0e 94 7e af 	call	0x15efc	; 0x15efc <_spi>
	 _spi(0x06);
    e4e6:	86 e0       	ldi	r24, 0x06	; 6
    e4e8:	0e 94 7e af 	call	0x15efc	; 0x15efc <_spi>
	 systemSlave();
    e4ec:	0e 94 c5 71 	call	0xe38a	; 0xe38a <systemSlave>
}
    e4f0:	1f 91       	pop	r17
    e4f2:	0f 91       	pop	r16
    e4f4:	08 95       	ret

0000e4f6 <FSettingPumpID>:
     if ((*Value)>MinValue){
	     (*Value)--;
	 }else *Value=MaxValue;
}

char FSettingPumpID(){
    e4f6:	9f 92       	push	r9
    e4f8:	af 92       	push	r10
    e4fa:	bf 92       	push	r11
    e4fc:	cf 92       	push	r12
    e4fe:	df 92       	push	r13
    e500:	ef 92       	push	r14
    e502:	ff 92       	push	r15
    e504:	0f 93       	push	r16
    e506:	1f 93       	push	r17
    e508:	df 93       	push	r29
    e50a:	cf 93       	push	r28
    e50c:	cd b7       	in	r28, 0x3d	; 61
    e50e:	de b7       	in	r29, 0x3e	; 62
    e510:	64 97       	sbiw	r28, 0x14	; 20
    e512:	0f b6       	in	r0, 0x3f	; 63
    e514:	f8 94       	cli
    e516:	de bf       	out	0x3e, r29	; 62
    e518:	0f be       	out	0x3f, r0	; 63
    e51a:	cd bf       	out	0x3d, r28	; 61
	 char iLoop,Result,KeyChar,KeyPressed,i,j,CheckPump;
	 char lcdteks[20];
	 static char Idx,PPumpId[8],MsgPumpId,PumpCount;
     
	 Result=MENU_NONE;
	 switch (stMenuPumpID){
    e51c:	80 91 de 02 	lds	r24, 0x02DE
    e520:	85 30       	cpi	r24, 0x05	; 5
    e522:	09 f4       	brne	.+2      	; 0xe526 <FSettingPumpID+0x30>
    e524:	88 c1       	rjmp	.+784    	; 0xe836 <FSettingPumpID+0x340>
    e526:	86 30       	cpi	r24, 0x06	; 6
    e528:	90 f4       	brcc	.+36     	; 0xe54e <FSettingPumpID+0x58>
    e52a:	82 30       	cpi	r24, 0x02	; 2
    e52c:	09 f4       	brne	.+2      	; 0xe530 <FSettingPumpID+0x3a>
    e52e:	8f c0       	rjmp	.+286    	; 0xe64e <FSettingPumpID+0x158>
    e530:	83 30       	cpi	r24, 0x03	; 3
    e532:	30 f4       	brcc	.+12     	; 0xe540 <FSettingPumpID+0x4a>
    e534:	88 23       	and	r24, r24
    e536:	f1 f0       	breq	.+60     	; 0xe574 <FSettingPumpID+0x7e>
    e538:	81 30       	cpi	r24, 0x01	; 1
    e53a:	09 f0       	breq	.+2      	; 0xe53e <FSettingPumpID+0x48>
    e53c:	73 c2       	rjmp	.+1254   	; 0xea24 <FSettingPumpID+0x52e>
    e53e:	2d c0       	rjmp	.+90     	; 0xe59a <FSettingPumpID+0xa4>
    e540:	83 30       	cpi	r24, 0x03	; 3
    e542:	09 f4       	brne	.+2      	; 0xe546 <FSettingPumpID+0x50>
    e544:	51 c1       	rjmp	.+674    	; 0xe7e8 <FSettingPumpID+0x2f2>
    e546:	84 30       	cpi	r24, 0x04	; 4
    e548:	09 f0       	breq	.+2      	; 0xe54c <FSettingPumpID+0x56>
    e54a:	6c c2       	rjmp	.+1240   	; 0xea24 <FSettingPumpID+0x52e>
    e54c:	6d c1       	rjmp	.+730    	; 0xe828 <FSettingPumpID+0x332>
    e54e:	88 30       	cpi	r24, 0x08	; 8
    e550:	09 f4       	brne	.+2      	; 0xe554 <FSettingPumpID+0x5e>
    e552:	fc c1       	rjmp	.+1016   	; 0xe94c <FSettingPumpID+0x456>
    e554:	89 30       	cpi	r24, 0x09	; 9
    e556:	38 f4       	brcc	.+14     	; 0xe566 <FSettingPumpID+0x70>
    e558:	86 30       	cpi	r24, 0x06	; 6
    e55a:	09 f4       	brne	.+2      	; 0xe55e <FSettingPumpID+0x68>
    e55c:	9b c1       	rjmp	.+822    	; 0xe894 <FSettingPumpID+0x39e>
    e55e:	87 30       	cpi	r24, 0x07	; 7
    e560:	09 f0       	breq	.+2      	; 0xe564 <FSettingPumpID+0x6e>
    e562:	60 c2       	rjmp	.+1216   	; 0xea24 <FSettingPumpID+0x52e>
    e564:	45 c2       	rjmp	.+1162   	; 0xe9f0 <FSettingPumpID+0x4fa>
    e566:	89 30       	cpi	r24, 0x09	; 9
    e568:	09 f4       	brne	.+2      	; 0xe56c <FSettingPumpID+0x76>
    e56a:	4a c2       	rjmp	.+1172   	; 0xea00 <FSettingPumpID+0x50a>
    e56c:	8a 30       	cpi	r24, 0x0A	; 10
    e56e:	09 f0       	breq	.+2      	; 0xe572 <FSettingPumpID+0x7c>
    e570:	59 c2       	rjmp	.+1202   	; 0xea24 <FSettingPumpID+0x52e>
    e572:	4c c2       	rjmp	.+1176   	; 0xea0c <FSettingPumpID+0x516>
	 case mpInitPumpId:	      
	      //Disable PumpPooling
		  if (IFType==IT_STANDALONE)SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    e574:	80 91 10 01 	lds	r24, 0x0110
    e578:	82 30       	cpi	r24, 0x02	; 2
    e57a:	21 f4       	brne	.+8      	; 0xe584 <FSettingPumpID+0x8e>
    e57c:	8f e1       	ldi	r24, 0x1F	; 31
    e57e:	60 e0       	ldi	r22, 0x00	; 0
    e580:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    e584:	84 ed       	ldi	r24, 0xD4	; 212
    e586:	92 e0       	ldi	r25, 0x02	; 2
    e588:	65 e4       	ldi	r22, 0x45	; 69
    e58a:	70 e0       	ldi	r23, 0x00	; 0
    e58c:	48 e0       	ldi	r20, 0x08	; 8
    e58e:	50 e0       	ldi	r21, 0x00	; 0
    e590:	25 ed       	ldi	r18, 0xD5	; 213
    e592:	32 e1       	ldi	r19, 0x12	; 18
    e594:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
    e598:	4c c1       	rjmp	.+664    	; 0xe832 <FSettingPumpID+0x33c>
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
    e59a:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
    e59e:	b4 ed       	ldi	r27, 0xD4	; 212
    e5a0:	eb 2e       	mov	r14, r27
    e5a2:	b2 e0       	ldi	r27, 0x02	; 2
    e5a4:	fb 2e       	mov	r15, r27
    e5a6:	01 e0       	ldi	r16, 0x01	; 1
    e5a8:	10 e0       	ldi	r17, 0x00	; 0
		  for (iLoop=0;iLoop<4;iLoop++){
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    e5aa:	6e 01       	movw	r12, r28
    e5ac:	08 94       	sec
    e5ae:	c1 1c       	adc	r12, r1
    e5b0:	d1 1c       	adc	r13, r1
    e5b2:	a8 e9       	ldi	r26, 0x98	; 152
    e5b4:	aa 2e       	mov	r10, r26
    e5b6:	ac e0       	ldi	r26, 0x0C	; 12
    e5b8:	ba 2e       	mov	r11, r26
    e5ba:	8d b7       	in	r24, 0x3d	; 61
    e5bc:	9e b7       	in	r25, 0x3e	; 62
    e5be:	0c 97       	sbiw	r24, 0x0c	; 12
    e5c0:	0f b6       	in	r0, 0x3f	; 63
    e5c2:	f8 94       	cli
    e5c4:	9e bf       	out	0x3e, r25	; 62
    e5c6:	0f be       	out	0x3f, r0	; 63
    e5c8:	8d bf       	out	0x3d, r24	; 61
    e5ca:	ed b7       	in	r30, 0x3d	; 61
    e5cc:	fe b7       	in	r31, 0x3e	; 62
    e5ce:	31 96       	adiw	r30, 0x01	; 1
    e5d0:	ad b7       	in	r26, 0x3d	; 61
    e5d2:	be b7       	in	r27, 0x3e	; 62
    e5d4:	12 96       	adiw	r26, 0x02	; 2
    e5d6:	dc 92       	st	X, r13
    e5d8:	ce 92       	st	-X, r12
    e5da:	11 97       	sbiw	r26, 0x01	; 1
    e5dc:	b3 82       	std	Z+3, r11	; 0x03
    e5de:	a2 82       	std	Z+2, r10	; 0x02
    e5e0:	15 83       	std	Z+5, r17	; 0x05
    e5e2:	04 83       	std	Z+4, r16	; 0x04
    e5e4:	d7 01       	movw	r26, r14
    e5e6:	8c 91       	ld	r24, X
    e5e8:	86 83       	std	Z+6, r24	; 0x06
    e5ea:	17 82       	std	Z+7, r1	; 0x07
    e5ec:	0c 5f       	subi	r16, 0xFC	; 252
    e5ee:	1f 4f       	sbci	r17, 0xFF	; 255
    e5f0:	11 87       	std	Z+9, r17	; 0x09
    e5f2:	00 87       	std	Z+8, r16	; 0x08
    e5f4:	04 50       	subi	r16, 0x04	; 4
    e5f6:	10 40       	sbci	r17, 0x00	; 0
    e5f8:	14 96       	adiw	r26, 0x04	; 4
    e5fa:	8c 91       	ld	r24, X
    e5fc:	82 87       	std	Z+10, r24	; 0x0a
    e5fe:	13 86       	std	Z+11, r1	; 0x0b
    e600:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			  lcd_print((iLoop+1),1,lcdteks);
    e604:	ed b7       	in	r30, 0x3d	; 61
    e606:	fe b7       	in	r31, 0x3e	; 62
    e608:	3c 96       	adiw	r30, 0x0c	; 12
    e60a:	0f b6       	in	r0, 0x3f	; 63
    e60c:	f8 94       	cli
    e60e:	fe bf       	out	0x3e, r31	; 62
    e610:	0f be       	out	0x3f, r0	; 63
    e612:	ed bf       	out	0x3d, r30	; 61
    e614:	80 2f       	mov	r24, r16
    e616:	61 e0       	ldi	r22, 0x01	; 1
    e618:	a6 01       	movw	r20, r12
    e61a:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    e61e:	08 94       	sec
    e620:	e1 1c       	adc	r14, r1
    e622:	f1 1c       	adc	r15, r1
    e624:	0f 5f       	subi	r16, 0xFF	; 255
    e626:	1f 4f       	sbci	r17, 0xFF	; 255
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
		  for (iLoop=0;iLoop<4;iLoop++){
    e628:	f8 ed       	ldi	r31, 0xD8	; 216
    e62a:	ef 16       	cp	r14, r31
    e62c:	f2 e0       	ldi	r31, 0x02	; 2
    e62e:	ff 06       	cpc	r15, r31
    e630:	21 f6       	brne	.-120    	; 0xe5ba <FSettingPumpID+0xc4>
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
			  lcd_print((iLoop+1),1,lcdteks);
          }
          lcd_printf(3,15,PSTR("*)Back"));
    e632:	83 e0       	ldi	r24, 0x03	; 3
    e634:	6f e0       	ldi	r22, 0x0F	; 15
    e636:	41 e9       	ldi	r20, 0x91	; 145
    e638:	5c e0       	ldi	r21, 0x0C	; 12
    e63a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	      lcd_printf(4,15,PSTR("#)Save"));
    e63e:	84 e0       	ldi	r24, 0x04	; 4
    e640:	6f e0       	ldi	r22, 0x0F	; 15
    e642:	4a e8       	ldi	r20, 0x8A	; 138
    e644:	5c e0       	ldi	r21, 0x0C	; 12
    e646:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          stMenuPumpID=mpSelectInput;
    e64a:	82 e0       	ldi	r24, 0x02	; 2
    e64c:	d6 c1       	rjmp	.+940    	; 0xe9fa <FSettingPumpID+0x504>
	      break;
     case mpSelectInput:
	      KeyPressed=_key_scan(1);
    e64e:	81 e0       	ldi	r24, 0x01	; 1
    e650:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    e654:	98 2e       	mov	r9, r24
	      KeyChar=_key_btn(KeyPressed);
    e656:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
    e65a:	98 2f       	mov	r25, r24
          if ((KeyChar>='1') && (KeyChar<='8')){
    e65c:	81 53       	subi	r24, 0x31	; 49
    e65e:	88 30       	cpi	r24, 0x08	; 8
    e660:	08 f0       	brcs	.+2      	; 0xe664 <FSettingPumpID+0x16e>
    e662:	85 c0       	rjmp	.+266    	; 0xe76e <FSettingPumpID+0x278>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
    e664:	80 91 10 01 	lds	r24, 0x0110
    e668:	81 30       	cpi	r24, 0x01	; 1
    e66a:	19 f0       	breq	.+6      	; 0xe672 <FSettingPumpID+0x17c>
    e66c:	82 30       	cpi	r24, 0x02	; 2
    e66e:	a1 f5       	brne	.+104    	; 0xe6d8 <FSettingPumpID+0x1e2>
    e670:	17 c0       	rjmp	.+46     	; 0xe6a0 <FSettingPumpID+0x1aa>
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
    e672:	80 91 dd 02 	lds	r24, 0x02DD
    e676:	88 23       	and	r24, r24
    e678:	41 f4       	brne	.+16     	; 0xe68a <FSettingPumpID+0x194>
    e67a:	e9 2f       	mov	r30, r25
    e67c:	f0 e0       	ldi	r31, 0x00	; 0
    e67e:	ed 55       	subi	r30, 0x5D	; 93
    e680:	fd 4f       	sbci	r31, 0xFD	; 253
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    e682:	80 81       	ld	r24, Z
    e684:	83 36       	cpi	r24, 0x63	; 99
    e686:	c8 f4       	brcc	.+50     	; 0xe6ba <FSettingPumpID+0x1c4>
    e688:	16 c0       	rjmp	.+44     	; 0xe6b6 <FSettingPumpID+0x1c0>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
    e68a:	81 30       	cpi	r24, 0x01	; 1
    e68c:	29 f5       	brne	.+74     	; 0xe6d8 <FSettingPumpID+0x1e2>
    e68e:	e9 2f       	mov	r30, r25
    e690:	f0 e0       	ldi	r31, 0x00	; 0
    e692:	ed 55       	subi	r30, 0x5D	; 93
    e694:	fd 4f       	sbci	r31, 0xFD	; 253
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    e696:	80 81       	ld	r24, Z
    e698:	88 23       	and	r24, r24
    e69a:	d1 f4       	brne	.+52     	; 0xe6d0 <FSettingPumpID+0x1da>
	     (*Value)--;
	 }else *Value=MaxValue;
    e69c:	83 e6       	ldi	r24, 0x63	; 99
    e69e:	1b c0       	rjmp	.+54     	; 0xe6d6 <FSettingPumpID+0x1e0>
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
    e6a0:	80 91 dd 02 	lds	r24, 0x02DD
    e6a4:	88 23       	and	r24, r24
    e6a6:	59 f4       	brne	.+22     	; 0xe6be <FSettingPumpID+0x1c8>
    e6a8:	e9 2f       	mov	r30, r25
    e6aa:	f0 e0       	ldi	r31, 0x00	; 0
    e6ac:	ed 55       	subi	r30, 0x5D	; 93
    e6ae:	fd 4f       	sbci	r31, 0xFD	; 253
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    e6b0:	80 81       	ld	r24, Z
    e6b2:	80 31       	cpi	r24, 0x10	; 16
    e6b4:	10 f4       	brcc	.+4      	; 0xe6ba <FSettingPumpID+0x1c4>
	     (*Value)++;
    e6b6:	8f 5f       	subi	r24, 0xFF	; 255
    e6b8:	0e c0       	rjmp	.+28     	; 0xe6d6 <FSettingPumpID+0x1e0>
	 }else *Value=MinValue;
    e6ba:	10 82       	st	Z, r1
    e6bc:	0d c0       	rjmp	.+26     	; 0xe6d8 <FSettingPumpID+0x1e2>
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
    e6be:	81 30       	cpi	r24, 0x01	; 1
    e6c0:	59 f4       	brne	.+22     	; 0xe6d8 <FSettingPumpID+0x1e2>
    e6c2:	e9 2f       	mov	r30, r25
    e6c4:	f0 e0       	ldi	r31, 0x00	; 0
    e6c6:	ed 55       	subi	r30, 0x5D	; 93
    e6c8:	fd 4f       	sbci	r31, 0xFD	; 253
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    e6ca:	80 81       	ld	r24, Z
    e6cc:	88 23       	and	r24, r24
    e6ce:	11 f0       	breq	.+4      	; 0xe6d4 <FSettingPumpID+0x1de>
	     (*Value)--;
    e6d0:	81 50       	subi	r24, 0x01	; 1
    e6d2:	01 c0       	rjmp	.+2      	; 0xe6d6 <FSettingPumpID+0x1e0>
	 }else *Value=MaxValue;
    e6d4:	80 e1       	ldi	r24, 0x10	; 16
    e6d6:	80 83       	st	Z, r24
    e6d8:	f4 ed       	ldi	r31, 0xD4	; 212
    e6da:	ef 2e       	mov	r14, r31
    e6dc:	f2 e0       	ldi	r31, 0x02	; 2
    e6de:	ff 2e       	mov	r15, r31
    e6e0:	01 e0       	ldi	r16, 0x01	; 1
    e6e2:	10 e0       	ldi	r17, 0x00	; 0
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    e6e4:	6e 01       	movw	r12, r28
    e6e6:	08 94       	sec
    e6e8:	c1 1c       	adc	r12, r1
    e6ea:	d1 1c       	adc	r13, r1
    e6ec:	e6 e7       	ldi	r30, 0x76	; 118
    e6ee:	ae 2e       	mov	r10, r30
    e6f0:	ec e0       	ldi	r30, 0x0C	; 12
    e6f2:	be 2e       	mov	r11, r30
    e6f4:	8d b7       	in	r24, 0x3d	; 61
    e6f6:	9e b7       	in	r25, 0x3e	; 62
    e6f8:	0c 97       	sbiw	r24, 0x0c	; 12
    e6fa:	0f b6       	in	r0, 0x3f	; 63
    e6fc:	f8 94       	cli
    e6fe:	9e bf       	out	0x3e, r25	; 62
    e700:	0f be       	out	0x3f, r0	; 63
    e702:	8d bf       	out	0x3d, r24	; 61
    e704:	ed b7       	in	r30, 0x3d	; 61
    e706:	fe b7       	in	r31, 0x3e	; 62
    e708:	31 96       	adiw	r30, 0x01	; 1
    e70a:	ad b7       	in	r26, 0x3d	; 61
    e70c:	be b7       	in	r27, 0x3e	; 62
    e70e:	12 96       	adiw	r26, 0x02	; 2
    e710:	dc 92       	st	X, r13
    e712:	ce 92       	st	-X, r12
    e714:	11 97       	sbiw	r26, 0x01	; 1
    e716:	b3 82       	std	Z+3, r11	; 0x03
    e718:	a2 82       	std	Z+2, r10	; 0x02
    e71a:	15 83       	std	Z+5, r17	; 0x05
    e71c:	04 83       	std	Z+4, r16	; 0x04
    e71e:	d7 01       	movw	r26, r14
    e720:	8c 91       	ld	r24, X
    e722:	86 83       	std	Z+6, r24	; 0x06
    e724:	17 82       	std	Z+7, r1	; 0x07
    e726:	0c 5f       	subi	r16, 0xFC	; 252
    e728:	1f 4f       	sbci	r17, 0xFF	; 255
    e72a:	11 87       	std	Z+9, r17	; 0x09
    e72c:	00 87       	std	Z+8, r16	; 0x08
    e72e:	04 50       	subi	r16, 0x04	; 4
    e730:	10 40       	sbci	r17, 0x00	; 0
    e732:	14 96       	adiw	r26, 0x04	; 4
    e734:	8c 91       	ld	r24, X
    e736:	82 87       	std	Z+10, r24	; 0x0a
    e738:	13 86       	std	Z+11, r1	; 0x0b
    e73a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
				  lcd_print((iLoop+1),1,lcdteks);
    e73e:	ed b7       	in	r30, 0x3d	; 61
    e740:	fe b7       	in	r31, 0x3e	; 62
    e742:	3c 96       	adiw	r30, 0x0c	; 12
    e744:	0f b6       	in	r0, 0x3f	; 63
    e746:	f8 94       	cli
    e748:	fe bf       	out	0x3e, r31	; 62
    e74a:	0f be       	out	0x3f, r0	; 63
    e74c:	ed bf       	out	0x3d, r30	; 61
    e74e:	80 2f       	mov	r24, r16
    e750:	61 e0       	ldi	r22, 0x01	; 1
    e752:	a6 01       	movw	r20, r12
    e754:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    e758:	08 94       	sec
    e75a:	e1 1c       	adc	r14, r1
    e75c:	f1 1c       	adc	r15, r1
    e75e:	0f 5f       	subi	r16, 0xFF	; 255
    e760:	1f 4f       	sbci	r17, 0xFF	; 255
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
    e762:	f8 ed       	ldi	r31, 0xD8	; 216
    e764:	ef 16       	cp	r14, r31
    e766:	f2 e0       	ldi	r31, 0x02	; 2
    e768:	ff 06       	cpc	r15, r31
    e76a:	21 f6       	brne	.-120    	; 0xe6f4 <FSettingPumpID+0x1fe>
    e76c:	2b c0       	rjmp	.+86     	; 0xe7c4 <FSettingPumpID+0x2ce>
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
    e76e:	93 32       	cpi	r25, 0x23	; 35
    e770:	21 f5       	brne	.+72     	; 0xe7ba <FSettingPumpID+0x2c4>
    e772:	40 e0       	ldi	r20, 0x00	; 0
    e774:	20 e0       	ldi	r18, 0x00	; 0
    e776:	30 e0       	ldi	r19, 0x00	; 0
    e778:	52 2f       	mov	r21, r18
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
    e77a:	f9 01       	movw	r30, r18
    e77c:	ec 52       	subi	r30, 0x2C	; 44
    e77e:	fd 4f       	sbci	r31, 0xFD	; 253
    e780:	e0 81       	ld	r30, Z
				   if (CheckPump>0){
    e782:	ee 23       	and	r30, r30
    e784:	69 f0       	breq	.+26     	; 0xe7a0 <FSettingPumpID+0x2aa>
    e786:	a4 ed       	ldi	r26, 0xD4	; 212
    e788:	b2 e0       	ldi	r27, 0x02	; 2
    e78a:	90 e0       	ldi	r25, 0x00	; 0
				      for(j=0;j<8;j++){					      
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
    e78c:	59 17       	cp	r21, r25
    e78e:	21 f0       	breq	.+8      	; 0xe798 <FSettingPumpID+0x2a2>
    e790:	8c 91       	ld	r24, X
    e792:	e8 17       	cp	r30, r24
    e794:	09 f4       	brne	.+2      	; 0xe798 <FSettingPumpID+0x2a2>
						       PumpCount++;
    e796:	4f 5f       	subi	r20, 0xFF	; 255
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
				   if (CheckPump>0){
				      for(j=0;j<8;j++){					      
    e798:	9f 5f       	subi	r25, 0xFF	; 255
    e79a:	11 96       	adiw	r26, 0x01	; 1
    e79c:	98 30       	cpi	r25, 0x08	; 8
    e79e:	b1 f7       	brne	.-20     	; 0xe78c <FSettingPumpID+0x296>
    e7a0:	2f 5f       	subi	r18, 0xFF	; 255
    e7a2:	3f 4f       	sbci	r19, 0xFF	; 255
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
    e7a4:	28 30       	cpi	r18, 0x08	; 8
    e7a6:	31 05       	cpc	r19, r1
    e7a8:	39 f7       	brne	.-50     	; 0xe778 <FSettingPumpID+0x282>
    e7aa:	40 93 d2 02 	sts	0x02D2, r20
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
						       PumpCount++;
					  }
				    }				     
				  }			       			  			  
			  if (PumpCount>0) stMenuPumpID=mpSaveFailed;
    e7ae:	44 23       	and	r20, r20
    e7b0:	11 f0       	breq	.+4      	; 0xe7b6 <FSettingPumpID+0x2c0>
    e7b2:	83 e0       	ldi	r24, 0x03	; 3
    e7b4:	05 c0       	rjmp	.+10     	; 0xe7c0 <FSettingPumpID+0x2ca>
			  else stMenuPumpID=mpSavingPumpId;
    e7b6:	85 e0       	ldi	r24, 0x05	; 5
    e7b8:	03 c0       	rjmp	.+6      	; 0xe7c0 <FSettingPumpID+0x2ca>
		  }	
		  else if (KeyChar=='*'){
    e7ba:	9a 32       	cpi	r25, 0x2A	; 42
    e7bc:	19 f4       	brne	.+6      	; 0xe7c4 <FSettingPumpID+0x2ce>
		      stMenuPumpID=mpExitPumpId;
    e7be:	8a e0       	ldi	r24, 0x0A	; 10
    e7c0:	80 93 de 02 	sts	0x02DE, r24
		  }
		  if (KeyPressed==_KEY_SHIFT){
    e7c4:	8b e7       	ldi	r24, 0x7B	; 123
    e7c6:	98 16       	cp	r9, r24
    e7c8:	09 f0       	breq	.+2      	; 0xe7cc <FSettingPumpID+0x2d6>
    e7ca:	2c c1       	rjmp	.+600    	; 0xea24 <FSettingPumpID+0x52e>
		      if (IsShift==False)IsShift=True;
    e7cc:	80 91 dd 02 	lds	r24, 0x02DD
    e7d0:	88 23       	and	r24, r24
    e7d2:	21 f4       	brne	.+8      	; 0xe7dc <FSettingPumpID+0x2e6>
    e7d4:	81 e0       	ldi	r24, 0x01	; 1
    e7d6:	80 93 dd 02 	sts	0x02DD, r24
    e7da:	24 c1       	rjmp	.+584    	; 0xea24 <FSettingPumpID+0x52e>
			  else
			  if (IsShift==True)IsShift=False;
    e7dc:	81 30       	cpi	r24, 0x01	; 1
    e7de:	09 f0       	breq	.+2      	; 0xe7e2 <FSettingPumpID+0x2ec>
    e7e0:	21 c1       	rjmp	.+578    	; 0xea24 <FSettingPumpID+0x52e>
    e7e2:	10 92 dd 02 	sts	0x02DD, r1
    e7e6:	1e c1       	rjmp	.+572    	; 0xea24 <FSettingPumpID+0x52e>
		  }
	      break;
     case mpSaveFailed:
	      lcd_clear();
    e7e8:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("      Warning!      "));
    e7ec:	81 e0       	ldi	r24, 0x01	; 1
    e7ee:	61 e0       	ldi	r22, 0x01	; 1
    e7f0:	41 e6       	ldi	r20, 0x61	; 97
    e7f2:	5c e0       	ldi	r21, 0x0C	; 12
    e7f4:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
    e7f8:	82 e0       	ldi	r24, 0x02	; 2
    e7fa:	61 e0       	ldi	r22, 0x01	; 1
    e7fc:	4c e4       	ldi	r20, 0x4C	; 76
    e7fe:	5c e0       	ldi	r21, 0x0C	; 12
    e800:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
    e804:	83 e0       	ldi	r24, 0x03	; 3
    e806:	61 e0       	ldi	r22, 0x01	; 1
    e808:	47 e3       	ldi	r20, 0x37	; 55
    e80a:	5c e0       	ldi	r21, 0x0C	; 12
    e80c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    e810:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    e812:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    e814:	82 e0       	ldi	r24, 0x02	; 2
    e816:	90 e0       	ldi	r25, 0x00	; 0
    e818:	90 93 d7 01 	sts	0x01D7, r25
    e81c:	80 93 d6 01 	sts	0x01D6, r24
	      lcd_clear();
		  lcd_printf(1,1,PSTR("      Warning!      "));
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
		  system_beep(2);
	      TimDisplay=0;
    e820:	10 92 a7 01 	sts	0x01A7, r1
	      stMenuPumpID=mpDisplayFailed;
    e824:	84 e0       	ldi	r24, 0x04	; 4
    e826:	e9 c0       	rjmp	.+466    	; 0xe9fa <FSettingPumpID+0x504>
          break;	 
     case mpDisplayFailed:
	      if (TimDisplay>6) stMenuPumpID=mpDisplayPumpId;
    e828:	80 91 a7 01 	lds	r24, 0x01A7
    e82c:	87 30       	cpi	r24, 0x07	; 7
    e82e:	08 f4       	brcc	.+2      	; 0xe832 <FSettingPumpID+0x33c>
    e830:	f9 c0       	rjmp	.+498    	; 0xea24 <FSettingPumpID+0x52e>
    e832:	81 e0       	ldi	r24, 0x01	; 1
    e834:	e2 c0       	rjmp	.+452    	; 0xe9fa <FSettingPumpID+0x504>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    e836:	85 e4       	ldi	r24, 0x45	; 69
    e838:	90 e0       	ldi	r25, 0x00	; 0
    e83a:	64 ed       	ldi	r22, 0xD4	; 212
    e83c:	72 e0       	ldi	r23, 0x02	; 2
    e83e:	48 e0       	ldi	r20, 0x08	; 8
    e840:	50 e0       	ldi	r21, 0x00	; 0
    e842:	2d ed       	ldi	r18, 0xDD	; 221
    e844:	32 e1       	ldi	r19, 0x12	; 18
    e846:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
	      break;
     case mpSavingPumpId:
	      eeprom_write_block((const void*) &PPumpId, (void*) &DefPumpMap, 8);
		  if (IFType==IT_STANDALONE){
    e84a:	80 91 10 01 	lds	r24, 0x0110
    e84e:	82 30       	cpi	r24, 0x02	; 2
    e850:	e9 f4       	brne	.+58     	; 0xe88c <FSettingPumpID+0x396>
		      //SendConfig to Slave
			  lcd_clear();
    e852:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
              lcd_printf(1,1,PSTR("-PumpID-"));
    e856:	81 e0       	ldi	r24, 0x01	; 1
    e858:	61 e0       	ldi	r22, 0x01	; 1
    e85a:	4e e2       	ldi	r20, 0x2E	; 46
    e85c:	5c e0       	ldi	r21, 0x0C	; 12
    e85e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
              lcd_printf(2,1,PSTR("Saving.."));
    e862:	82 e0       	ldi	r24, 0x02	; 2
    e864:	61 e0       	ldi	r22, 0x01	; 1
    e866:	45 e2       	ldi	r20, 0x25	; 37
    e868:	5c e0       	ldi	r21, 0x0C	; 12
    e86a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			  Idx=0;
    e86e:	10 92 dc 02 	sts	0x02DC, r1
			  PumpCount=0;
    e872:	10 92 d2 02 	sts	0x02D2, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    e876:	84 ed       	ldi	r24, 0xD4	; 212
    e878:	92 e0       	ldi	r25, 0x02	; 2
    e87a:	65 e4       	ldi	r22, 0x45	; 69
    e87c:	70 e0       	ldi	r23, 0x00	; 0
    e87e:	48 e0       	ldi	r20, 0x08	; 8
    e880:	50 e0       	ldi	r21, 0x00	; 0
    e882:	25 ed       	ldi	r18, 0xD5	; 213
    e884:	32 e1       	ldi	r19, 0x12	; 18
    e886:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
    e88a:	b6 c0       	rjmp	.+364    	; 0xe9f8 <FSettingPumpID+0x502>
              eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
              stMenuPumpID=mpSendConfigToSlave;
		  }else if (IFType==IT_SLAVE){
    e88c:	81 30       	cpi	r24, 0x01	; 1
    e88e:	09 f0       	breq	.+2      	; 0xe892 <FSettingPumpID+0x39c>
    e890:	c9 c0       	rjmp	.+402    	; 0xea24 <FSettingPumpID+0x52e>
    e892:	ba c0       	rjmp	.+372    	; 0xea08 <FSettingPumpID+0x512>
		      //SendConfig to Slave              
              stMenuPumpID=mpExitPumpId;
		  }
	      break;
     case mpSendConfigToSlave:
	      IsStandaloneAcknoledge=False;
    e894:	10 92 95 01 	sts	0x0195, r1
	      if (PPumpId[Idx]!=0){
    e898:	90 91 dc 02 	lds	r25, 0x02DC
    e89c:	29 2f       	mov	r18, r25
    e89e:	30 e0       	ldi	r19, 0x00	; 0
    e8a0:	f9 01       	movw	r30, r18
    e8a2:	ec 52       	subi	r30, 0x2C	; 44
    e8a4:	fd 4f       	sbci	r31, 0xFD	; 253
    e8a6:	60 81       	ld	r22, Z
    e8a8:	66 23       	and	r22, r22
    e8aa:	81 f0       	breq	.+32     	; 0xe8cc <FSettingPumpID+0x3d6>
		      PumpCount++;
    e8ac:	80 91 d2 02 	lds	r24, 0x02D2
    e8b0:	8f 5f       	subi	r24, 0xFF	; 255
    e8b2:	80 93 d2 02 	sts	0x02D2, r24
		      MsgPumpId=((Idx<<4)|(0x0F&PPumpId[Idx]));//[Idx][PumpId]
    e8b6:	6f 70       	andi	r22, 0x0F	; 15
    e8b8:	74 e0       	ldi	r23, 0x04	; 4
    e8ba:	22 0f       	add	r18, r18
    e8bc:	33 1f       	adc	r19, r19
    e8be:	7a 95       	dec	r23
    e8c0:	e1 f7       	brne	.-8      	; 0xe8ba <FSettingPumpID+0x3c4>
    e8c2:	62 2b       	or	r22, r18
    e8c4:	60 93 d3 02 	sts	0x02D3, r22
	         //SendPoolingCommand(SC_SET_PUMPID,MsgPumpId);
			  SendSlaveCommand(SC_SET_PUMPID,MsgPumpId);
    e8c8:	8d e1       	ldi	r24, 0x1D	; 29
    e8ca:	02 c0       	rjmp	.+4      	; 0xe8d0 <FSettingPumpID+0x3da>
		  }else SendSlaveCommand(SC_CLEAR_PUMPID,Idx);//SendPoolingCommand(SC_CLEAR_PUMPID,Idx);
    e8cc:	8e e1       	ldi	r24, 0x1E	; 30
    e8ce:	69 2f       	mov	r22, r25
    e8d0:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
		  sprintf_P(lcdteks,PSTR("Id[%d]=%.2d  "),Idx+1,PPumpId[Idx]);
    e8d4:	e0 91 dc 02 	lds	r30, 0x02DC
    e8d8:	f0 e0       	ldi	r31, 0x00	; 0
    e8da:	ad b7       	in	r26, 0x3d	; 61
    e8dc:	be b7       	in	r27, 0x3e	; 62
    e8de:	18 97       	sbiw	r26, 0x08	; 8
    e8e0:	0f b6       	in	r0, 0x3f	; 63
    e8e2:	f8 94       	cli
    e8e4:	be bf       	out	0x3e, r27	; 62
    e8e6:	0f be       	out	0x3f, r0	; 63
    e8e8:	ad bf       	out	0x3d, r26	; 61
    e8ea:	2d b7       	in	r18, 0x3d	; 61
    e8ec:	3e b7       	in	r19, 0x3e	; 62
    e8ee:	2f 5f       	subi	r18, 0xFF	; 255
    e8f0:	3f 4f       	sbci	r19, 0xFF	; 255
    e8f2:	8e 01       	movw	r16, r28
    e8f4:	0f 5f       	subi	r16, 0xFF	; 255
    e8f6:	1f 4f       	sbci	r17, 0xFF	; 255
    e8f8:	12 96       	adiw	r26, 0x02	; 2
    e8fa:	1c 93       	st	X, r17
    e8fc:	0e 93       	st	-X, r16
    e8fe:	11 97       	sbiw	r26, 0x01	; 1
    e900:	87 e1       	ldi	r24, 0x17	; 23
    e902:	9c e0       	ldi	r25, 0x0C	; 12
    e904:	d9 01       	movw	r26, r18
    e906:	13 96       	adiw	r26, 0x03	; 3
    e908:	9c 93       	st	X, r25
    e90a:	8e 93       	st	-X, r24
    e90c:	12 97       	sbiw	r26, 0x02	; 2
    e90e:	31 96       	adiw	r30, 0x01	; 1
    e910:	15 96       	adiw	r26, 0x05	; 5
    e912:	fc 93       	st	X, r31
    e914:	ee 93       	st	-X, r30
    e916:	14 97       	sbiw	r26, 0x04	; 4
    e918:	31 97       	sbiw	r30, 0x01	; 1
    e91a:	ec 52       	subi	r30, 0x2C	; 44
    e91c:	fd 4f       	sbci	r31, 0xFD	; 253
    e91e:	80 81       	ld	r24, Z
    e920:	16 96       	adiw	r26, 0x06	; 6
    e922:	8c 93       	st	X, r24
    e924:	16 97       	sbiw	r26, 0x06	; 6
    e926:	17 96       	adiw	r26, 0x07	; 7
    e928:	1c 92       	st	X, r1
    e92a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(3,1,lcdteks);
    e92e:	ed b7       	in	r30, 0x3d	; 61
    e930:	fe b7       	in	r31, 0x3e	; 62
    e932:	38 96       	adiw	r30, 0x08	; 8
    e934:	0f b6       	in	r0, 0x3f	; 63
    e936:	f8 94       	cli
    e938:	fe bf       	out	0x3e, r31	; 62
    e93a:	0f be       	out	0x3f, r0	; 63
    e93c:	ed bf       	out	0x3d, r30	; 61
    e93e:	83 e0       	ldi	r24, 0x03	; 3
    e940:	61 e0       	ldi	r22, 0x01	; 1
    e942:	a8 01       	movw	r20, r16
    e944:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
          stMenuPumpID=mpWaitSlaveReply;
    e948:	88 e0       	ldi	r24, 0x08	; 8
    e94a:	57 c0       	rjmp	.+174    	; 0xe9fa <FSettingPumpID+0x504>
	      break;
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
    e94c:	81 e0       	ldi	r24, 0x01	; 1
    e94e:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
	      KeyChar=_key_btn(KeyPressed);
    e952:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
		  if (KeyChar=='*'){
    e956:	8a 32       	cpi	r24, 0x2A	; 42
    e958:	99 f4       	brne	.+38     	; 0xe980 <FSettingPumpID+0x48a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    e95a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    e95c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    e95e:	82 e0       	ldi	r24, 0x02	; 2
    e960:	90 e0       	ldi	r25, 0x00	; 0
    e962:	90 93 d7 01 	sts	0x01D7, r25
    e966:	80 93 d6 01 	sts	0x01D6, r24
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
	      KeyChar=_key_btn(KeyPressed);
		  if (KeyChar=='*'){
		      system_beep(2);
		      lcd_printf(2,1,PSTR("Cancel     "));
    e96a:	82 e0       	ldi	r24, 0x02	; 2
    e96c:	61 e0       	ldi	r22, 0x01	; 1
    e96e:	4b e0       	ldi	r20, 0x0B	; 11
    e970:	5c e0       	ldi	r21, 0x0C	; 12
    e972:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			  TimDisplay=0;
    e976:	10 92 a7 01 	sts	0x01A7, r1
		      stMenuPumpID=mpDelayExitPumpId;
    e97a:	89 e0       	ldi	r24, 0x09	; 9
    e97c:	80 93 de 02 	sts	0x02DE, r24
			  }
          if (IsStandaloneAcknoledge==True){
    e980:	80 91 95 01 	lds	r24, 0x0195
    e984:	81 30       	cpi	r24, 0x01	; 1
    e986:	09 f0       	breq	.+2      	; 0xe98a <FSettingPumpID+0x494>
    e988:	4d c0       	rjmp	.+154    	; 0xea24 <FSettingPumpID+0x52e>
		      Idx++;
    e98a:	80 91 dc 02 	lds	r24, 0x02DC
    e98e:	8f 5f       	subi	r24, 0xFF	; 255
    e990:	80 93 dc 02 	sts	0x02DC, r24
		      if (Idx<8){//Finish, Send MaxPumpCount
    e994:	88 30       	cpi	r24, 0x08	; 8
    e996:	10 f5       	brcc	.+68     	; 0xe9dc <FSettingPumpID+0x4e6>
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
    e998:	20 91 d2 02 	lds	r18, 0x02D2
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e99c:	e1 99       	sbic	0x1c, 1	; 28
    e99e:	fe cf       	rjmp	.-4      	; 0xe99c <FSettingPumpID+0x4a6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e9a0:	84 e4       	ldi	r24, 0x44	; 68
    e9a2:	91 e0       	ldi	r25, 0x01	; 1
    e9a4:	9f bb       	out	0x1f, r25	; 31
    e9a6:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    e9a8:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    e9aa:	0f b6       	in	r0, 0x3f	; 63
    e9ac:	f8 94       	cli
    e9ae:	e2 9a       	sbi	0x1c, 2	; 28
    e9b0:	e1 9a       	sbi	0x1c, 1	; 28
    e9b2:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e9b4:	e1 99       	sbic	0x1c, 1	; 28
    e9b6:	fe cf       	rjmp	.-4      	; 0xe9b4 <FSettingPumpID+0x4be>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e9b8:	9f bb       	out	0x1f, r25	; 31
    e9ba:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e9bc:	e0 9a       	sbi	0x1c, 0	; 28
    e9be:	9d b3       	in	r25, 0x1d	; 29
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    e9c0:	90 93 5f 01 	sts	0x015F, r25
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e9c4:	85 e1       	ldi	r24, 0x15	; 21
    e9c6:	80 93 da 07 	sts	0x07DA, r24
	 PoolMsg=plMsg;
    e9ca:	90 93 fe 0d 	sts	0x0DFE, r25
     IsControlPooling=True;
    e9ce:	81 e0       	ldi	r24, 0x01	; 1
    e9d0:	80 93 97 01 	sts	0x0197, r24
		      Idx++;
		      if (Idx<8){//Finish, Send MaxPumpCount
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
                  SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PumpCountMax);
			      TimDisplay=0;		 
    e9d4:	10 92 a7 01 	sts	0x01A7, r1
				  stMenuPumpID=mpDelaySaveConfig;
    e9d8:	87 e0       	ldi	r24, 0x07	; 7
    e9da:	0f c0       	rjmp	.+30     	; 0xe9fa <FSettingPumpID+0x504>
			  }else{lcd_printf(2,1,PSTR("Completed"));
    e9dc:	82 e0       	ldi	r24, 0x02	; 2
    e9de:	61 e0       	ldi	r22, 0x01	; 1
    e9e0:	41 e0       	ldi	r20, 0x01	; 1
    e9e2:	5c e0       	ldi	r21, 0x0C	; 12
    e9e4:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
					TimDisplay=0;
    e9e8:	10 92 a7 01 	sts	0x01A7, r1
				    stMenuPumpID=mpDelayExitPumpId;
    e9ec:	89 e0       	ldi	r24, 0x09	; 9
    e9ee:	05 c0       	rjmp	.+10     	; 0xe9fa <FSettingPumpID+0x504>
				   }
			  }		  
	      break;
     case mpDelaySaveConfig:
	      if (TimDisplay>2)stMenuPumpID=mpSendConfigToSlave;
    e9f0:	80 91 a7 01 	lds	r24, 0x01A7
    e9f4:	83 30       	cpi	r24, 0x03	; 3
    e9f6:	b0 f0       	brcs	.+44     	; 0xea24 <FSettingPumpID+0x52e>
    e9f8:	86 e0       	ldi	r24, 0x06	; 6
    e9fa:	80 93 de 02 	sts	0x02DE, r24
    e9fe:	12 c0       	rjmp	.+36     	; 0xea24 <FSettingPumpID+0x52e>
	      break;
     case mpDelayExitPumpId:
	      if (TimDisplay>8)stMenuPumpID=mpExitPumpId;
    ea00:	80 91 a7 01 	lds	r24, 0x01A7
    ea04:	89 30       	cpi	r24, 0x09	; 9
    ea06:	70 f0       	brcs	.+28     	; 0xea24 <FSettingPumpID+0x52e>
    ea08:	8a e0       	ldi	r24, 0x0A	; 10
    ea0a:	f7 cf       	rjmp	.-18     	; 0xe9fa <FSettingPumpID+0x504>
	      break;
     case mpExitPumpId:
	      if (IFType==IT_STANDALONE)
    ea0c:	80 91 10 01 	lds	r24, 0x0110
    ea10:	82 30       	cpi	r24, 0x02	; 2
    ea12:	21 f4       	brne	.+8      	; 0xea1c <FSettingPumpID+0x526>
		      SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    ea14:	80 e2       	ldi	r24, 0x20	; 32
    ea16:	60 e0       	ldi	r22, 0x00	; 0
    ea18:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
	      Result=MENU_DONE;
          stMenuPumpID=mpInitPumpId;
    ea1c:	10 92 de 02 	sts	0x02DE, r1
    ea20:	81 e0       	ldi	r24, 0x01	; 1
    ea22:	01 c0       	rjmp	.+2      	; 0xea26 <FSettingPumpID+0x530>
    ea24:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
    ea26:	64 96       	adiw	r28, 0x14	; 20
    ea28:	0f b6       	in	r0, 0x3f	; 63
    ea2a:	f8 94       	cli
    ea2c:	de bf       	out	0x3e, r29	; 62
    ea2e:	0f be       	out	0x3f, r0	; 63
    ea30:	cd bf       	out	0x3d, r28	; 61
    ea32:	cf 91       	pop	r28
    ea34:	df 91       	pop	r29
    ea36:	1f 91       	pop	r17
    ea38:	0f 91       	pop	r16
    ea3a:	ff 90       	pop	r15
    ea3c:	ef 90       	pop	r14
    ea3e:	df 90       	pop	r13
    ea40:	cf 90       	pop	r12
    ea42:	bf 90       	pop	r11
    ea44:	af 90       	pop	r10
    ea46:	9f 90       	pop	r9
    ea48:	08 95       	ret

0000ea4a <_menu_pumpid>:

void _menu_pumpid(void){
	while(1){
	   if (FSettingPumpID()==MENU_DONE){
    ea4a:	0e 94 7b 72 	call	0xe4f6	; 0xe4f6 <FSettingPumpID>
    ea4e:	81 30       	cpi	r24, 0x01	; 1
    ea50:	e1 f7       	brne	.-8      	; 0xea4a <_menu_pumpid>
	       break;
	   }	   
	}
}
    ea52:	08 95       	ret

0000ea54 <_menu_pump>:
        lcd_printf(4,15,PSTR("*)Exit"));
}



void _menu_pump(void){
    ea54:	cf 93       	push	r28
    ea56:	df 93       	push	r29
    ea58:	c4 ec       	ldi	r28, 0xC4	; 196
    ea5a:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;

	while(1){
		lcd_clear();_delay_ms(10);
    ea5c:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
    ea60:	ce 01       	movw	r24, r28
    ea62:	01 97       	sbiw	r24, 0x01	; 1
    ea64:	f1 f7       	brne	.-4      	; 0xea62 <_menu_pump+0xe>
		lcd_printf(1, 1, PSTR("1)ID"));
    ea66:	81 e0       	ldi	r24, 0x01	; 1
    ea68:	61 e0       	ldi	r22, 0x01	; 1
    ea6a:	45 e3       	ldi	r20, 0x35	; 53
    ea6c:	5d e0       	ldi	r21, 0x0D	; 13
    ea6e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Product"));
    ea72:	82 e0       	ldi	r24, 0x02	; 2
    ea74:	61 e0       	ldi	r22, 0x01	; 1
    ea76:	4b e2       	ldi	r20, 0x2B	; 43
    ea78:	5d e0       	ldi	r21, 0x0D	; 13
    ea7a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    ea7e:	84 e0       	ldi	r24, 0x04	; 4
    ea80:	61 e0       	ldi	r22, 0x01	; 1
    ea82:	44 e2       	ldi	r20, 0x24	; 36
    ea84:	5d e0       	ldi	r21, 0x0D	; 13
    ea86:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>

		while(1){
			__key = _key_scan(1);
    ea8a:	81 e0       	ldi	r24, 0x01	; 1
    ea8c:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
			if(__key == _KEY_CANCEL)
    ea90:	87 3e       	cpi	r24, 0xE7	; 231
    ea92:	51 f0       	breq	.+20     	; 0xeaa8 <_menu_pump+0x54>
				return;
			if(__key == _KEY_1){
    ea94:	8e 3e       	cpi	r24, 0xEE	; 238
    ea96:	19 f4       	brne	.+6      	; 0xea9e <_menu_pump+0x4a>
				_menu_pumpid();
    ea98:	0e 94 25 75 	call	0xea4a	; 0xea4a <_menu_pumpid>
    ea9c:	df cf       	rjmp	.-66     	; 0xea5c <_menu_pump+0x8>
				break;
			}
			if(__key == _KEY_2){
    ea9e:	8e 3d       	cpi	r24, 0xDE	; 222
    eaa0:	a1 f7       	brne	.-24     	; 0xea8a <_menu_pump+0x36>
				_menu_pumpprod();
    eaa2:	0e 94 b0 47 	call	0x8f60	; 0x8f60 <_menu_pumpprod>
    eaa6:	da cf       	rjmp	.-76     	; 0xea5c <_menu_pump+0x8>
				break;
			}
		}
	}
}
    eaa8:	df 91       	pop	r29
    eaaa:	cf 91       	pop	r28
    eaac:	08 95       	ret

0000eaae <FMenuPumpType>:





void FMenuPumpType(){
    eaae:	cf 92       	push	r12
    eab0:	df 92       	push	r13
    eab2:	ef 92       	push	r14
    eab4:	ff 92       	push	r15
    eab6:	0f 93       	push	r16
    eab8:	1f 93       	push	r17
    eaba:	df 93       	push	r29
    eabc:	cf 93       	push	r28
    eabe:	cd b7       	in	r28, 0x3d	; 61
    eac0:	de b7       	in	r29, 0x3e	; 62
    eac2:	a8 97       	sbiw	r28, 0x28	; 40
    eac4:	0f b6       	in	r0, 0x3f	; 63
    eac6:	f8 94       	cli
    eac8:	de bf       	out	0x3e, r29	; 62
    eaca:	0f be       	out	0x3f, r0	; 63
    eacc:	cd bf       	out	0x3d, r28	; 61
     stPumpType=ptInitMenu;
	 IsRunPumpType=True;
	 while(IsRunPumpType==True){
		  switch(stPumpType){
		  case ptInitMenu:
		       lcd_clear();
    eace:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
			   lcd_printf(1,1,PSTR("-Dispenser Brand-"));
    ead2:	81 e0       	ldi	r24, 0x01	; 1
    ead4:	61 e0       	ldi	r22, 0x01	; 1
    ead6:	42 e1       	ldi	r20, 0x12	; 18
    ead8:	5d e0       	ldi	r21, 0x0D	; 13
    eada:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    eade:	e1 99       	sbic	0x1c, 1	; 28
    eae0:	fe cf       	rjmp	.-4      	; 0xeade <FMenuPumpType+0x30>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eae2:	87 e3       	ldi	r24, 0x37	; 55
    eae4:	91 e0       	ldi	r25, 0x01	; 1
    eae6:	9f bb       	out	0x1f, r25	; 31
    eae8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    eaea:	e0 9a       	sbi	0x1c, 0	; 28
    eaec:	0d b3       	in	r16, 0x1d	; 29
			   IdxType=eeprom_read_byte(&DefDispenserBrand);
			   //Brand Selection
			   if (IdxType>=3) IdxType=0;
    eaee:	03 30       	cpi	r16, 0x03	; 3
    eaf0:	08 f0       	brcs	.+2      	; 0xeaf4 <FMenuPumpType+0x46>
    eaf2:	00 e0       	ldi	r16, 0x00	; 0
               strcpy_P(DispenserBrandName,(PGM_P)pgm_read_word(&(DefListDispenserName[IdxType])));
    eaf4:	10 e0       	ldi	r17, 0x00	; 0
    eaf6:	f8 01       	movw	r30, r16
    eaf8:	ee 0f       	add	r30, r30
    eafa:	ff 1f       	adc	r31, r31
    eafc:	e5 5d       	subi	r30, 0xD5	; 213
    eafe:	fc 4f       	sbci	r31, 0xFC	; 252
    eb00:	65 91       	lpm	r22, Z+
    eb02:	74 91       	lpm	r23, Z+
    eb04:	85 e1       	ldi	r24, 0x15	; 21
    eb06:	c8 2e       	mov	r12, r24
    eb08:	d1 2c       	mov	r13, r1
    eb0a:	cc 0e       	add	r12, r28
    eb0c:	dd 1e       	adc	r13, r29
    eb0e:	c6 01       	movw	r24, r12
    eb10:	0e 94 dd b3 	call	0x167ba	; 0x167ba <strcpy_P>
			   sprintf_P(lcdteks,PSTR("%d.%s"),IdxType+1,DispenserBrandName);
    eb14:	8d b7       	in	r24, 0x3d	; 61
    eb16:	9e b7       	in	r25, 0x3e	; 62
    eb18:	08 97       	sbiw	r24, 0x08	; 8
    eb1a:	0f b6       	in	r0, 0x3f	; 63
    eb1c:	f8 94       	cli
    eb1e:	9e bf       	out	0x3e, r25	; 62
    eb20:	0f be       	out	0x3f, r0	; 63
    eb22:	8d bf       	out	0x3d, r24	; 61
    eb24:	ed b7       	in	r30, 0x3d	; 61
    eb26:	fe b7       	in	r31, 0x3e	; 62
    eb28:	31 96       	adiw	r30, 0x01	; 1
    eb2a:	7e 01       	movw	r14, r28
    eb2c:	08 94       	sec
    eb2e:	e1 1c       	adc	r14, r1
    eb30:	f1 1c       	adc	r15, r1
    eb32:	ad b7       	in	r26, 0x3d	; 61
    eb34:	be b7       	in	r27, 0x3e	; 62
    eb36:	12 96       	adiw	r26, 0x02	; 2
    eb38:	fc 92       	st	X, r15
    eb3a:	ee 92       	st	-X, r14
    eb3c:	11 97       	sbiw	r26, 0x01	; 1
    eb3e:	8c e0       	ldi	r24, 0x0C	; 12
    eb40:	9d e0       	ldi	r25, 0x0D	; 13
    eb42:	93 83       	std	Z+3, r25	; 0x03
    eb44:	82 83       	std	Z+2, r24	; 0x02
    eb46:	0f 5f       	subi	r16, 0xFF	; 255
    eb48:	1f 4f       	sbci	r17, 0xFF	; 255
    eb4a:	15 83       	std	Z+5, r17	; 0x05
    eb4c:	04 83       	std	Z+4, r16	; 0x04
    eb4e:	d7 82       	std	Z+7, r13	; 0x07
    eb50:	c6 82       	std	Z+6, r12	; 0x06
    eb52:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			   lcd_print(2,1,lcdteks);
    eb56:	8d b7       	in	r24, 0x3d	; 61
    eb58:	9e b7       	in	r25, 0x3e	; 62
    eb5a:	08 96       	adiw	r24, 0x08	; 8
    eb5c:	0f b6       	in	r0, 0x3f	; 63
    eb5e:	f8 94       	cli
    eb60:	9e bf       	out	0x3e, r25	; 62
    eb62:	0f be       	out	0x3f, r0	; 63
    eb64:	8d bf       	out	0x3d, r24	; 61
    eb66:	82 e0       	ldi	r24, 0x02	; 2
    eb68:	61 e0       	ldi	r22, 0x01	; 1
    eb6a:	a7 01       	movw	r20, r14
    eb6c:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Exit  [#]Change "));
    eb70:	84 e0       	ldi	r24, 0x04	; 4
    eb72:	61 e0       	ldi	r22, 0x01	; 1
    eb74:	48 ef       	ldi	r20, 0xF8	; 248
    eb76:	5c e0       	ldi	r21, 0x0C	; 12
    eb78:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			   if (IFType==IT_STANDALONE)
    eb7c:	80 91 10 01 	lds	r24, 0x0110
    eb80:	82 30       	cpi	r24, 0x02	; 2
    eb82:	21 f4       	brne	.+8      	; 0xeb8c <FMenuPumpType+0xde>
			       SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    eb84:	8f e1       	ldi	r24, 0x1F	; 31
    eb86:	60 e0       	ldi	r22, 0x00	; 0
    eb88:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
			   stPumpType=ptSelectBrand;
	 		   break;
          case ptSelectBrand:
		       KeyPressed = _key_scan(1);
    eb8c:	81 e0       	ldi	r24, 0x01	; 1
    eb8e:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
		       KeyChar    = _key_btn(KeyPressed);
    eb92:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>

			   if (KeyChar=='#'){
    eb96:	83 32       	cpi	r24, 0x23	; 35
    eb98:	09 f0       	breq	.+2      	; 0xeb9c <FMenuPumpType+0xee>
    eb9a:	2d c0       	rjmp	.+90     	; 0xebf6 <FMenuPumpType+0x148>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    eb9c:	e1 99       	sbic	0x1c, 1	; 28
    eb9e:	fe cf       	rjmp	.-4      	; 0xeb9c <FMenuPumpType+0xee>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eba0:	07 e3       	ldi	r16, 0x37	; 55
    eba2:	11 e0       	ldi	r17, 0x01	; 1
    eba4:	1f bb       	out	0x1f, r17	; 31
    eba6:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    eba8:	e0 9a       	sbi	0x1c, 0	; 28
    ebaa:	8d b3       	in	r24, 0x1d	; 29
			       DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
				   if (DispenserBrand<ST_WAYNE_DART)
    ebac:	82 30       	cpi	r24, 0x02	; 2
    ebae:	20 f4       	brcc	.+8      	; 0xebb8 <FMenuPumpType+0x10a>
				        DispenserBrand++;
    ebb0:	8f 5f       	subi	r24, 0xFF	; 255
    ebb2:	80 93 61 01 	sts	0x0161, r24
    ebb6:	02 c0       	rjmp	.+4      	; 0xebbc <FMenuPumpType+0x10e>
				   else DispenserBrand=ST_NONE;
    ebb8:	10 92 61 01 	sts	0x0161, r1
                   //Apply DecimalSetting  
				   SetDispenser(DispenserBrand);
    ebbc:	80 91 61 01 	lds	r24, 0x0161
    ebc0:	0e 94 de 1a 	call	0x35bc	; 0x35bc <SetDispenser>

			       eeprom_write_byte(&DefDispenserBrand,DispenserBrand);
    ebc4:	80 91 61 01 	lds	r24, 0x0161
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ebc8:	e1 99       	sbic	0x1c, 1	; 28
    ebca:	fe cf       	rjmp	.-4      	; 0xebc8 <FMenuPumpType+0x11a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ebcc:	1f bb       	out	0x1f, r17	; 31
    ebce:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    ebd0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    ebd2:	0f b6       	in	r0, 0x3f	; 63
    ebd4:	f8 94       	cli
    ebd6:	e2 9a       	sbi	0x1c, 2	; 28
    ebd8:	e1 9a       	sbi	0x1c, 1	; 28
    ebda:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ebdc:	e1 99       	sbic	0x1c, 1	; 28
    ebde:	fe cf       	rjmp	.-4      	; 0xebdc <FMenuPumpType+0x12e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ebe0:	1f bb       	out	0x1f, r17	; 31
    ebe2:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ebe4:	e0 9a       	sbi	0x1c, 0	; 28
    ebe6:	6d b3       	in	r22, 0x1d	; 29
				   //SendPoolingCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
				   SendSlaveCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
    ebe8:	8c e1       	ldi	r24, 0x1C	; 28
    ebea:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
				   IsSetPumpType=True;//False;
    ebee:	81 e0       	ldi	r24, 0x01	; 1
    ebf0:	80 93 23 01 	sts	0x0123, r24
    ebf4:	0c c0       	rjmp	.+24     	; 0xec0e <FMenuPumpType+0x160>
			       stPumpType=ptUpdated;			   
			   }else
			   if (KeyChar=='*'){
    ebf6:	8a 32       	cpi	r24, 0x2A	; 42
    ebf8:	09 f0       	breq	.+2      	; 0xebfc <FMenuPumpType+0x14e>
    ebfa:	c8 cf       	rjmp	.-112    	; 0xeb8c <FMenuPumpType+0xde>
			       IsRunPumpType=False;
				   if (IFType==IT_STANDALONE)SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    ebfc:	80 91 10 01 	lds	r24, 0x0110
    ec00:	82 30       	cpi	r24, 0x02	; 2
    ec02:	51 f4       	brne	.+20     	; 0xec18 <FMenuPumpType+0x16a>
    ec04:	80 e2       	ldi	r24, 0x20	; 32
    ec06:	60 e0       	ldi	r22, 0x00	; 0
    ec08:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
    ec0c:	05 c0       	rjmp	.+10     	; 0xec18 <FMenuPumpType+0x16a>
			   }
		       break;
          case ptUpdated:
		       if (IsSetPumpType==True){
    ec0e:	80 91 23 01 	lds	r24, 0x0123
    ec12:	81 30       	cpi	r24, 0x01	; 1
    ec14:	e1 f7       	brne	.-8      	; 0xec0e <FMenuPumpType+0x160>
    ec16:	5b cf       	rjmp	.-330    	; 0xeace <FMenuPumpType+0x20>
			       stPumpType=ptInitMenu;
			   }
		       break;		         
	      }
	 }     
}
    ec18:	a8 96       	adiw	r28, 0x28	; 40
    ec1a:	0f b6       	in	r0, 0x3f	; 63
    ec1c:	f8 94       	cli
    ec1e:	de bf       	out	0x3e, r29	; 62
    ec20:	0f be       	out	0x3f, r0	; 63
    ec22:	cd bf       	out	0x3d, r28	; 61
    ec24:	cf 91       	pop	r28
    ec26:	df 91       	pop	r29
    ec28:	1f 91       	pop	r17
    ec2a:	0f 91       	pop	r16
    ec2c:	ff 90       	pop	r15
    ec2e:	ef 90       	pop	r14
    ec30:	df 90       	pop	r13
    ec32:	cf 90       	pop	r12
    ec34:	08 95       	ret

0000ec36 <FSettingPump>:
   return Result;
}

char FSettingPump(){
	 char __key,Result;
		lcd_clear();_delay_ms(10);
    ec36:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
    ec3a:	84 ec       	ldi	r24, 0xC4	; 196
    ec3c:	99 e0       	ldi	r25, 0x09	; 9
    ec3e:	01 97       	sbiw	r24, 0x01	; 1
    ec40:	f1 f7       	brne	.-4      	; 0xec3e <FSettingPump+0x8>
		lcd_printf(1,1, PSTR("1)ID     "));
    ec42:	81 e0       	ldi	r24, 0x01	; 1
    ec44:	61 e0       	ldi	r22, 0x01	; 1
    ec46:	4a e4       	ldi	r20, 0x4A	; 74
    ec48:	51 e1       	ldi	r21, 0x11	; 17
    ec4a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		lcd_printf(2,1, PSTR("2)Product"));
    ec4e:	82 e0       	ldi	r24, 0x02	; 2
    ec50:	61 e0       	ldi	r22, 0x01	; 1
    ec52:	40 e4       	ldi	r20, 0x40	; 64
    ec54:	51 e1       	ldi	r21, 0x11	; 17
    ec56:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		if (IFType==IT_STANDALONE){
    ec5a:	80 91 10 01 	lds	r24, 0x0110
    ec5e:	82 30       	cpi	r24, 0x02	; 2
    ec60:	61 f4       	brne	.+24     	; 0xec7a <FSettingPump+0x44>
		    lcd_printf(3,1, PSTR("3)Label  "));
    ec62:	83 e0       	ldi	r24, 0x03	; 3
    ec64:	61 e0       	ldi	r22, 0x01	; 1
    ec66:	46 e3       	ldi	r20, 0x36	; 54
    ec68:	51 e1       	ldi	r21, 0x11	; 17
    ec6a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		    lcd_printf(4,1, PSTR("4)Brand  *)Exit"));
    ec6e:	84 e0       	ldi	r24, 0x04	; 4
    ec70:	61 e0       	ldi	r22, 0x01	; 1
    ec72:	46 e2       	ldi	r20, 0x26	; 38
    ec74:	51 e1       	ldi	r21, 0x11	; 17
    ec76:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		}

		while(1){
			__key = _key_scan(1);
    ec7a:	81 e0       	ldi	r24, 0x01	; 1
    ec7c:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
			if(__key == _KEY_CANCEL)
    ec80:	87 3e       	cpi	r24, 0xE7	; 231
    ec82:	d9 f0       	breq	.+54     	; 0xecba <FSettingPump+0x84>
				break;
			if(__key == _KEY_1){
    ec84:	8e 3e       	cpi	r24, 0xEE	; 238
    ec86:	19 f4       	brne	.+6      	; 0xec8e <FSettingPump+0x58>
				_menu_pumpid();
    ec88:	0e 94 25 75 	call	0xea4a	; 0xea4a <_menu_pumpid>
    ec8c:	16 c0       	rjmp	.+44     	; 0xecba <FSettingPump+0x84>
				break;
			}
			if(__key == _KEY_2){
    ec8e:	8e 3d       	cpi	r24, 0xDE	; 222
    ec90:	19 f4       	brne	.+6      	; 0xec98 <FSettingPump+0x62>
				_menu_pumpprod();
    ec92:	0e 94 b0 47 	call	0x8f60	; 0x8f60 <_menu_pumpprod>
    ec96:	11 c0       	rjmp	.+34     	; 0xecba <FSettingPump+0x84>
				break;
			}

			if((__key == _KEY_3)&&(IFType==IT_STANDALONE)){
    ec98:	8e 3b       	cpi	r24, 0xBE	; 190
    ec9a:	39 f4       	brne	.+14     	; 0xecaa <FSettingPump+0x74>
    ec9c:	80 91 10 01 	lds	r24, 0x0110
    eca0:	82 30       	cpi	r24, 0x02	; 2
    eca2:	59 f7       	brne	.-42     	; 0xec7a <FSettingPump+0x44>
			    FMenuPumpLabel();
    eca4:	0e 94 d9 47 	call	0x8fb2	; 0x8fb2 <FMenuPumpLabel>
    eca8:	08 c0       	rjmp	.+16     	; 0xecba <FSettingPump+0x84>
				break;
			}
			if((__key == _KEY_4)&&(IFType==IT_STANDALONE)){
    ecaa:	8d 3e       	cpi	r24, 0xED	; 237
    ecac:	31 f7       	brne	.-52     	; 0xec7a <FSettingPump+0x44>
    ecae:	80 91 10 01 	lds	r24, 0x0110
    ecb2:	82 30       	cpi	r24, 0x02	; 2
    ecb4:	11 f7       	brne	.-60     	; 0xec7a <FSettingPump+0x44>
			    FMenuPumpType();
    ecb6:	0e 94 57 75 	call	0xeaae	; 0xeaae <FMenuPumpType>

		}

	Result=MENU_DONE;
	return Result;
}
    ecba:	81 e0       	ldi	r24, 0x01	; 1
    ecbc:	08 95       	ret

0000ecbe <InitializeConnection>:
void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
	 ActivePump=eeprom_read_byte(&DefActivePump);
}

void InitializeConnection(){
    ecbe:	af 92       	push	r10
    ecc0:	bf 92       	push	r11
    ecc2:	cf 92       	push	r12
    ecc4:	df 92       	push	r13
    ecc6:	ef 92       	push	r14
    ecc8:	ff 92       	push	r15
    ecca:	0f 93       	push	r16
    eccc:	1f 93       	push	r17
    ecce:	df 93       	push	r29
    ecd0:	cf 93       	push	r28
    ecd2:	cd b7       	in	r28, 0x3d	; 61
    ecd4:	de b7       	in	r29, 0x3e	; 62
    ecd6:	64 97       	sbiw	r28, 0x14	; 20
    ecd8:	0f b6       	in	r0, 0x3f	; 63
    ecda:	f8 94       	cli
    ecdc:	de bf       	out	0x3e, r29	; 62
    ecde:	0f be       	out	0x3f, r0	; 63
    ece0:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ece2:	e1 99       	sbic	0x1c, 1	; 28
    ece4:	fe cf       	rjmp	.-4      	; 0xece2 <InitializeConnection+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ece6:	46 e3       	ldi	r20, 0x36	; 54
    ece8:	a4 2e       	mov	r10, r20
    ecea:	41 e0       	ldi	r20, 0x01	; 1
    ecec:	b4 2e       	mov	r11, r20
    ecee:	bf ba       	out	0x1f, r11	; 31
    ecf0:	ae ba       	out	0x1e, r10	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ecf2:	e0 9a       	sbi	0x1c, 0	; 28
    ecf4:	9d b3       	in	r25, 0x1d	; 29
	unsigned int tConnect=0;
	char ForceType=IT_NONE,iCon=0,iTry=0;
	char lcdteks[20];
	IFType=eeprom_read_byte(&DefInitIFT);
    ecf6:	90 93 10 01 	sts	0x0110, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ecfa:	e1 99       	sbic	0x1c, 1	; 28
    ecfc:	fe cf       	rjmp	.-4      	; 0xecfa <InitializeConnection+0x3c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ecfe:	37 e3       	ldi	r19, 0x37	; 55
    ed00:	c3 2e       	mov	r12, r19
    ed02:	31 e0       	ldi	r19, 0x01	; 1
    ed04:	d3 2e       	mov	r13, r19
    ed06:	df ba       	out	0x1f, r13	; 31
    ed08:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ed0a:	e0 9a       	sbi	0x1c, 0	; 28
    ed0c:	8d b3       	in	r24, 0x1d	; 29
	DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    ed0e:	80 93 61 01 	sts	0x0161, r24

	//SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);

    //Send Msg10
	if  (IFType==IT_SLAVE){
    ed12:	91 30       	cpi	r25, 0x01	; 1
    ed14:	09 f0       	breq	.+2      	; 0xed18 <InitializeConnection+0x5a>
    ed16:	59 c0       	rjmp	.+178    	; 0xedca <InitializeConnection+0x10c>
	     SendSlaveCommand(SC_SLAVE,ST_NONE);
    ed18:	81 e0       	ldi	r24, 0x01	; 1
    ed1a:	60 e0       	ldi	r22, 0x00	; 0
    ed1c:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
		 char_count=0;
    ed20:	10 92 9d 01 	sts	0x019D, r1
    ed24:	10 92 9c 01 	sts	0x019C, r1
		 if (IsPowerOn==True){
    ed28:	80 91 9a 04 	lds	r24, 0x049A
    ed2c:	81 30       	cpi	r24, 0x01	; 1
    ed2e:	59 f4       	brne	.+22     	; 0xed46 <InitializeConnection+0x88>
		     IsPowerOn=False;
    ed30:	10 92 9a 04 	sts	0x049A, r1
    ed34:	80 e5       	ldi	r24, 0x50	; 80
    ed36:	93 ec       	ldi	r25, 0xC3	; 195
    ed38:	29 e1       	ldi	r18, 0x19	; 25
    ed3a:	30 e0       	ldi	r19, 0x00	; 0
    ed3c:	f9 01       	movw	r30, r18
    ed3e:	31 97       	sbiw	r30, 0x01	; 1
    ed40:	f1 f7       	brne	.-4      	; 0xed3e <InitializeConnection+0x80>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    ed42:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    ed44:	d9 f7       	brne	.-10     	; 0xed3c <InitializeConnection+0x7e>
		     _delay_ms(5000);
			 }
         sendMessage10();
    ed46:	0e 94 63 52 	call	0xa4c6	; 0xa4c6 <sendMessage10>
         lcd_printf(4,1,PSTR("Connect         "));
    ed4a:	84 e0       	ldi	r24, 0x04	; 4
    ed4c:	61 e0       	ldi	r22, 0x01	; 1
    ed4e:	43 e4       	ldi	r20, 0x43	; 67
    ed50:	5c e1       	ldi	r21, 0x1C	; 28
    ed52:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		 lcd_printf(4,1,PSTR("Connect"));
    ed56:	84 e0       	ldi	r24, 0x04	; 4
    ed58:	61 e0       	ldi	r22, 0x01	; 1
    ed5a:	4b e3       	ldi	r20, 0x3B	; 59
    ed5c:	5c e1       	ldi	r21, 0x1C	; 28
    ed5e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
    ed62:	10 92 b7 01 	sts	0x01B7, r1
    ed66:	ee 24       	eor	r14, r14
    ed68:	ff 24       	eor	r15, r15
    ed6a:	10 e0       	ldi	r17, 0x00	; 0
    ed6c:	00 e0       	ldi	r16, 0x00	; 0
    ed6e:	29 c0       	rjmp	.+82     	; 0xedc2 <InitializeConnection+0x104>
		  //SlaveIdentification		  
		 while (IsMessage11==False){
		        lcd_put(4,(8+iCon),'.');
    ed70:	61 2f       	mov	r22, r17
    ed72:	68 5f       	subi	r22, 0xF8	; 248
    ed74:	84 e0       	ldi	r24, 0x04	; 4
    ed76:	4e e2       	ldi	r20, 0x2E	; 46
    ed78:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
                tConnect++;
    ed7c:	08 94       	sec
    ed7e:	e1 1c       	adc	r14, r1
    ed80:	f1 1c       	adc	r15, r1
			    if ((tConnect%800)==0)iCon++;
    ed82:	c7 01       	movw	r24, r14
    ed84:	60 e2       	ldi	r22, 0x20	; 32
    ed86:	73 e0       	ldi	r23, 0x03	; 3
    ed88:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
    ed8c:	89 2b       	or	r24, r25
    ed8e:	09 f4       	brne	.+2      	; 0xed92 <InitializeConnection+0xd4>
    ed90:	1f 5f       	subi	r17, 0xFF	; 255
			    if (iCon>8){
    ed92:	19 30       	cpi	r17, 0x09	; 9
    ed94:	70 f0       	brcs	.+28     	; 0xedb2 <InitializeConnection+0xf4>
			        lcd_printf(4,1,PSTR("Connect         "));
    ed96:	84 e0       	ldi	r24, 0x04	; 4
    ed98:	61 e0       	ldi	r22, 0x01	; 1
    ed9a:	4a e2       	ldi	r20, 0x2A	; 42
    ed9c:	5c e1       	ldi	r21, 0x1C	; 28
    ed9e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				    sendMessage10();
    eda2:	0e 94 63 52 	call	0xa4c6	; 0xa4c6 <sendMessage10>
				    SendSlaveCommand(SC_SLAVE,ST_NONE);
    eda6:	81 e0       	ldi	r24, 0x01	; 1
    eda8:	60 e0       	ldi	r22, 0x00	; 0
    edaa:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
			        iCon=0;
				    iTry++;}
    edae:	0f 5f       	subi	r16, 0xFF	; 255
    edb0:	10 e0       	ldi	r17, 0x00	; 0
			    if (iTry>3){
    edb2:	04 30       	cpi	r16, 0x04	; 4
    edb4:	30 f0       	brcs	.+12     	; 0xedc2 <InitializeConnection+0x104>
			        //IsErrorTCPIP=True;
				    IsAdvanzStartupInfo=False;		
    edb6:	10 92 c1 01 	sts	0x01C1, r1
					IFType=IT_STANDALONE;
    edba:	82 e0       	ldi	r24, 0x02	; 2
    edbc:	80 93 10 01 	sts	0x0110, r24
    edc0:	04 c0       	rjmp	.+8      	; 0xedca <InitializeConnection+0x10c>
         lcd_printf(4,1,PSTR("Connect         "));
		 lcd_printf(4,1,PSTR("Connect"));
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
		  //SlaveIdentification		  
		 while (IsMessage11==False){
    edc2:	80 91 b7 01 	lds	r24, 0x01B7
    edc6:	88 23       	and	r24, r24
    edc8:	99 f2       	breq	.-90     	; 0xed70 <InitializeConnection+0xb2>
				    break;
			    }
            }//EndWhile
		}

	if (IFType==IT_STANDALONE){
    edca:	80 91 10 01 	lds	r24, 0x0110
    edce:	82 30       	cpi	r24, 0x02	; 2
    edd0:	09 f0       	breq	.+2      	; 0xedd4 <InitializeConnection+0x116>
    edd2:	72 c0       	rjmp	.+228    	; 0xeeb8 <InitializeConnection+0x1fa>
        IsStandAloneDetected=False;		
    edd4:	10 92 b3 01 	sts	0x01B3, r1
		SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    edd8:	60 91 61 01 	lds	r22, 0x0161
    eddc:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
		tConnect=0,iCon=0,iTry=0;
	    lcd_clear();
    ede0:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
	    lcd_printf(1,1,PSTR("Scan Pump"));
    ede4:	81 e0       	ldi	r24, 0x01	; 1
    ede6:	61 e0       	ldi	r22, 0x01	; 1
    ede8:	40 e2       	ldi	r20, 0x20	; 32
    edea:	5c e1       	ldi	r21, 0x1C	; 28
    edec:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    edf0:	e1 99       	sbic	0x1c, 1	; 28
    edf2:	fe cf       	rjmp	.-4      	; 0xedf0 <InitializeConnection+0x132>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    edf4:	df ba       	out	0x1f, r13	; 31
    edf6:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    edf8:	e0 9a       	sbi	0x1c, 0	; 28
    edfa:	8d b3       	in	r24, 0x1d	; 29
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
    edfc:	e8 2f       	mov	r30, r24
    edfe:	f0 e0       	ldi	r31, 0x00	; 0
    ee00:	ee 0f       	add	r30, r30
    ee02:	ff 1f       	adc	r31, r31
    ee04:	e5 5d       	subi	r30, 0xD5	; 213
    ee06:	fc 4f       	sbci	r31, 0xFC	; 252
    ee08:	65 91       	lpm	r22, Z+
    ee0a:	74 91       	lpm	r23, Z+
    ee0c:	8e 01       	movw	r16, r28
    ee0e:	0f 5f       	subi	r16, 0xFF	; 255
    ee10:	1f 4f       	sbci	r17, 0xFF	; 255
    ee12:	c8 01       	movw	r24, r16
    ee14:	0e 94 dd b3 	call	0x167ba	; 0x167ba <strcpy_P>
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
    ee18:	00 d0       	rcall	.+0      	; 0xee1a <InitializeConnection+0x15c>
    ee1a:	00 d0       	rcall	.+0      	; 0xee1c <InitializeConnection+0x15e>
    ee1c:	00 d0       	rcall	.+0      	; 0xee1e <InitializeConnection+0x160>
    ee1e:	ed b7       	in	r30, 0x3d	; 61
    ee20:	fe b7       	in	r31, 0x3e	; 62
    ee22:	31 96       	adiw	r30, 0x01	; 1
    ee24:	ad b7       	in	r26, 0x3d	; 61
    ee26:	be b7       	in	r27, 0x3e	; 62
    ee28:	12 96       	adiw	r26, 0x02	; 2
    ee2a:	1c 93       	st	X, r17
    ee2c:	0e 93       	st	-X, r16
    ee2e:	11 97       	sbiw	r26, 0x01	; 1
    ee30:	8d e1       	ldi	r24, 0x1D	; 29
    ee32:	9c e1       	ldi	r25, 0x1C	; 28
    ee34:	93 83       	std	Z+3, r25	; 0x03
    ee36:	82 83       	std	Z+2, r24	; 0x02
    ee38:	15 83       	std	Z+5, r17	; 0x05
    ee3a:	04 83       	std	Z+4, r16	; 0x04
    ee3c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	    lcd_print(2,1,lcdteks);
    ee40:	8d b7       	in	r24, 0x3d	; 61
    ee42:	9e b7       	in	r25, 0x3e	; 62
    ee44:	06 96       	adiw	r24, 0x06	; 6
    ee46:	0f b6       	in	r0, 0x3f	; 63
    ee48:	f8 94       	cli
    ee4a:	9e bf       	out	0x3e, r25	; 62
    ee4c:	0f be       	out	0x3f, r0	; 63
    ee4e:	8d bf       	out	0x3d, r24	; 61
    ee50:	82 e0       	ldi	r24, 0x02	; 2
    ee52:	61 e0       	ldi	r22, 0x01	; 1
    ee54:	a8 01       	movw	r20, r16
    ee56:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
    ee5a:	00 e0       	ldi	r16, 0x00	; 0
    ee5c:	10 e0       	ldi	r17, 0x00	; 0
    ee5e:	ff 24       	eor	r15, r15
    ee60:	dd 24       	eor	r13, r13
    ee62:	26 c0       	rjmp	.+76     	; 0xeeb0 <InitializeConnection+0x1f2>

	    while (IsStandAloneDetected==False){
		       lcd_put(4,(1+iCon),'.');
    ee64:	ef 2c       	mov	r14, r15
    ee66:	e3 94       	inc	r14
    ee68:	84 e0       	ldi	r24, 0x04	; 4
    ee6a:	6e 2d       	mov	r22, r14
    ee6c:	4e e2       	ldi	r20, 0x2E	; 46
    ee6e:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
		       tConnect++;
    ee72:	0f 5f       	subi	r16, 0xFF	; 255
    ee74:	1f 4f       	sbci	r17, 0xFF	; 255
		       if ((tConnect%100)==0)iCon++;
    ee76:	c8 01       	movw	r24, r16
    ee78:	64 e6       	ldi	r22, 0x64	; 100
    ee7a:	70 e0       	ldi	r23, 0x00	; 0
    ee7c:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
    ee80:	89 2b       	or	r24, r25
    ee82:	09 f4       	brne	.+2      	; 0xee86 <InitializeConnection+0x1c8>
    ee84:	fe 2c       	mov	r15, r14
		       if (iCon>16){
    ee86:	90 e1       	ldi	r25, 0x10	; 16
    ee88:	9f 15       	cp	r25, r15
    ee8a:	78 f4       	brcc	.+30     	; 0xeeaa <InitializeConnection+0x1ec>
			       lcd_printf(4,1,PSTR("                   "));
    ee8c:	84 e0       	ldi	r24, 0x04	; 4
    ee8e:	61 e0       	ldi	r22, 0x01	; 1
    ee90:	49 e0       	ldi	r20, 0x09	; 9
    ee92:	5c e1       	ldi	r21, 0x1C	; 28
    ee94:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				   //IsStandaloneAcknoledge=False;
		           SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    ee98:	82 e0       	ldi	r24, 0x02	; 2
    ee9a:	60 91 61 01 	lds	r22, 0x0161
    ee9e:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
                   //InitStandalone();

			       DisplayPumpStatus();
    eea2:	0e 94 4f 41 	call	0x829e	; 0x829e <DisplayPumpStatus>
			       iCon=0;
			       iTry++;}
    eea6:	d3 94       	inc	r13
    eea8:	ff 24       	eor	r15, r15
		           if (iTry>3) break; 
    eeaa:	a3 e0       	ldi	r26, 0x03	; 3
    eeac:	ad 15       	cp	r26, r13
    eeae:	20 f0       	brcs	.+8      	; 0xeeb8 <InitializeConnection+0x1fa>
	    lcd_printf(1,1,PSTR("Scan Pump"));
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
	    lcd_print(2,1,lcdteks);

	    while (IsStandAloneDetected==False){
    eeb0:	80 91 b3 01 	lds	r24, 0x01B3
    eeb4:	88 23       	and	r24, r24
    eeb6:	b1 f2       	breq	.-84     	; 0xee64 <InitializeConnection+0x1a6>
			       iCon=0;
			       iTry++;}
		           if (iTry>3) break; 
	    }
	}//EndIf
	if(IsMessage11==True){
    eeb8:	80 91 b7 01 	lds	r24, 0x01B7
    eebc:	81 30       	cpi	r24, 0x01	; 1
    eebe:	b9 f4       	brne	.+46     	; 0xeeee <InitializeConnection+0x230>
	   lcd_printf(4,1,PSTR("Connected"));
    eec0:	84 e0       	ldi	r24, 0x04	; 4
    eec2:	61 e0       	ldi	r22, 0x01	; 1
    eec4:	4f ef       	ldi	r20, 0xFF	; 255
    eec6:	5b e1       	ldi	r21, 0x1B	; 27
    eec8:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    eecc:	e1 99       	sbic	0x1c, 1	; 28
    eece:	fe cf       	rjmp	.-4      	; 0xeecc <InitializeConnection+0x20e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eed0:	bf ba       	out	0x1f, r11	; 31
    eed2:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    eed4:	11 e0       	ldi	r17, 0x01	; 1
    eed6:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    eed8:	0f b6       	in	r0, 0x3f	; 63
    eeda:	f8 94       	cli
    eedc:	e2 9a       	sbi	0x1c, 2	; 28
    eede:	e1 9a       	sbi	0x1c, 1	; 28
    eee0:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_SLAVE);
	   IFType=IT_SLAVE;
    eee2:	10 93 10 01 	sts	0x0110, r17
	   //IsErrorTCPIP=False;
	   procMessage11();
    eee6:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <procMessage11>
	   IsAdvanzStartupInfo=True;
    eeea:	10 93 c1 01 	sts	0x01C1, r17
	}
	if(IsStandAloneDetected==True){
    eeee:	80 91 b3 01 	lds	r24, 0x01B3
    eef2:	81 30       	cpi	r24, 0x01	; 1
    eef4:	99 f4       	brne	.+38     	; 0xef1c <InitializeConnection+0x25e>
	   lcd_printf(4,1,PSTR("PumpFound"));
    eef6:	84 e0       	ldi	r24, 0x04	; 4
    eef8:	61 e0       	ldi	r22, 0x01	; 1
    eefa:	45 ef       	ldi	r20, 0xF5	; 245
    eefc:	5b e1       	ldi	r21, 0x1B	; 27
    eefe:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ef02:	e1 99       	sbic	0x1c, 1	; 28
    ef04:	fe cf       	rjmp	.-4      	; 0xef02 <InitializeConnection+0x244>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ef06:	bf ba       	out	0x1f, r11	; 31
    ef08:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    ef0a:	82 e0       	ldi	r24, 0x02	; 2
    ef0c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    ef0e:	0f b6       	in	r0, 0x3f	; 63
    ef10:	f8 94       	cli
    ef12:	e2 9a       	sbi	0x1c, 2	; 28
    ef14:	e1 9a       	sbi	0x1c, 1	; 28
    ef16:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_STANDALONE);
	   IFType=IT_STANDALONE;
    ef18:	80 93 10 01 	sts	0x0110, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ef1c:	e1 99       	sbic	0x1c, 1	; 28
    ef1e:	fe cf       	rjmp	.-4      	; 0xef1c <InitializeConnection+0x25e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ef20:	85 e3       	ldi	r24, 0x35	; 53
    ef22:	91 e0       	ldi	r25, 0x01	; 1
    ef24:	9f bb       	out	0x1f, r25	; 31
    ef26:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ef28:	e0 9a       	sbi	0x1c, 0	; 28
    ef2a:	8d b3       	in	r24, 0x1d	; 29
	}
	//PrintStatus
	if (eeprom_read_byte(&DefPrintInitialize)==True)GeneratePrintInit();
    ef2c:	81 30       	cpi	r24, 0x01	; 1
    ef2e:	11 f4       	brne	.+4      	; 0xef34 <InitializeConnection+0x276>
    ef30:	0e 94 b3 2f 	call	0x5f66	; 0x5f66 <GeneratePrintInit>
	if ((IsStandAloneDetected==False)&&(IsMessage11==False)){		
    ef34:	80 91 b3 01 	lds	r24, 0x01B3
    ef38:	88 23       	and	r24, r24
    ef3a:	09 f0       	breq	.+2      	; 0xef3e <InitializeConnection+0x280>
    ef3c:	38 c0       	rjmp	.+112    	; 0xefae <InitializeConnection+0x2f0>
    ef3e:	80 91 b7 01 	lds	r24, 0x01B7
    ef42:	88 23       	and	r24, r24
    ef44:	09 f0       	breq	.+2      	; 0xef48 <InitializeConnection+0x28a>
    ef46:	33 c0       	rjmp	.+102    	; 0xefae <InitializeConnection+0x2f0>
		 lcd_printf(2,1,PSTR("TCP/IP Error"));
    ef48:	82 e0       	ldi	r24, 0x02	; 2
    ef4a:	61 e0       	ldi	r22, 0x01	; 1
    ef4c:	48 ee       	ldi	r20, 0xE8	; 232
    ef4e:	5b e1       	ldi	r21, 0x1B	; 27
    ef50:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		 lcd_printf(3,1,PSTR("No Pump Found"));
    ef54:	83 e0       	ldi	r24, 0x03	; 3
    ef56:	61 e0       	ldi	r22, 0x01	; 1
    ef58:	4a ed       	ldi	r20, 0xDA	; 218
    ef5a:	5b e1       	ldi	r21, 0x1B	; 27
    ef5c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
    ef60:	80 e2       	ldi	r24, 0x20	; 32
    ef62:	9e e4       	ldi	r25, 0x4E	; 78
    ef64:	29 e1       	ldi	r18, 0x19	; 25
    ef66:	30 e0       	ldi	r19, 0x00	; 0
    ef68:	f9 01       	movw	r30, r18
    ef6a:	31 97       	sbiw	r30, 0x01	; 1
    ef6c:	f1 f7       	brne	.-4      	; 0xef6a <InitializeConnection+0x2ac>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    ef6e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    ef70:	d9 f7       	brne	.-10     	; 0xef68 <InitializeConnection+0x2aa>
		 _delay_ms(2000);
		 ForceType=systemForceType();
    ef72:	0e 94 7e 44 	call	0x88fc	; 0x88fc <systemForceType>
		 if (ForceType=='1'){
    ef76:	81 33       	cpi	r24, 0x31	; 49
    ef78:	29 f4       	brne	.+10     	; 0xef84 <InitializeConnection+0x2c6>
		     IFType=IT_SLAVE;
    ef7a:	81 e0       	ldi	r24, 0x01	; 1
    ef7c:	80 93 10 01 	sts	0x0110, r24
			 SendSlaveCommand(SC_SLAVE,ST_NONE);
    ef80:	60 e0       	ldi	r22, 0x00	; 0
    ef82:	07 c0       	rjmp	.+14     	; 0xef92 <InitializeConnection+0x2d4>
         }
		 else
		 if (ForceType=='2'){
    ef84:	82 33       	cpi	r24, 0x32	; 50
    ef86:	39 f4       	brne	.+14     	; 0xef96 <InitializeConnection+0x2d8>
		     IFType=IT_STANDALONE;
    ef88:	82 e0       	ldi	r24, 0x02	; 2
    ef8a:	80 93 10 01 	sts	0x0110, r24
			 SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    ef8e:	60 91 61 01 	lds	r22, 0x0161
    ef92:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>

			 //SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,eeprom_read_byte(&DefPoolingPumpMax));

			 //InitStandalone();
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
    ef96:	80 91 10 01 	lds	r24, 0x0110
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ef9a:	e1 99       	sbic	0x1c, 1	; 28
    ef9c:	fe cf       	rjmp	.-4      	; 0xef9a <InitializeConnection+0x2dc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ef9e:	bf ba       	out	0x1f, r11	; 31
    efa0:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    efa2:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    efa4:	0f b6       	in	r0, 0x3f	; 63
    efa6:	f8 94       	cli
    efa8:	e2 9a       	sbi	0x1c, 2	; 28
    efaa:	e1 9a       	sbi	0x1c, 1	; 28
    efac:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    efae:	e1 99       	sbic	0x1c, 1	; 28
    efb0:	fe cf       	rjmp	.-4      	; 0xefae <InitializeConnection+0x2f0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    efb2:	84 e4       	ldi	r24, 0x44	; 68
    efb4:	91 e0       	ldi	r25, 0x01	; 1
    efb6:	9f bb       	out	0x1f, r25	; 31
    efb8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    efba:	e0 9a       	sbi	0x1c, 0	; 28
    efbc:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    efbe:	80 93 5f 01 	sts	0x015F, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    efc2:	e1 99       	sbic	0x1c, 1	; 28
    efc4:	fe cf       	rjmp	.-4      	; 0xefc2 <InitializeConnection+0x304>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    efc6:	89 e4       	ldi	r24, 0x49	; 73
    efc8:	91 e0       	ldi	r25, 0x01	; 1
    efca:	9f bb       	out	0x1f, r25	; 31
    efcc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    efce:	e0 9a       	sbi	0x1c, 0	; 28
    efd0:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    efd2:	80 93 60 01 	sts	0x0160, r24
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
	}
	InitMemory();
	//SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
}
    efd6:	64 96       	adiw	r28, 0x14	; 20
    efd8:	0f b6       	in	r0, 0x3f	; 63
    efda:	f8 94       	cli
    efdc:	de bf       	out	0x3e, r29	; 62
    efde:	0f be       	out	0x3f, r0	; 63
    efe0:	cd bf       	out	0x3d, r28	; 61
    efe2:	cf 91       	pop	r28
    efe4:	df 91       	pop	r29
    efe6:	1f 91       	pop	r17
    efe8:	0f 91       	pop	r16
    efea:	ff 90       	pop	r15
    efec:	ef 90       	pop	r14
    efee:	df 90       	pop	r13
    eff0:	cf 90       	pop	r12
    eff2:	bf 90       	pop	r11
    eff4:	af 90       	pop	r10
    eff6:	08 95       	ret

0000eff8 <StoreStandaloneTransData>:
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
}
         
			                                         //      STX     MSGID  PumpID              6        8        8
void StoreStandaloneTransData(char *strRawTransData){//  [0x50,0x05]  01      01      1       004500   00000200  00000012 [0x06,0x60] = 24
    eff8:	2f 92       	push	r2
    effa:	3f 92       	push	r3
    effc:	4f 92       	push	r4
    effe:	5f 92       	push	r5
    f000:	6f 92       	push	r6
    f002:	7f 92       	push	r7
    f004:	8f 92       	push	r8
    f006:	9f 92       	push	r9
    f008:	af 92       	push	r10
    f00a:	bf 92       	push	r11
    f00c:	cf 92       	push	r12
    f00e:	df 92       	push	r13
    f010:	ef 92       	push	r14
    f012:	ff 92       	push	r15
    f014:	0f 93       	push	r16
    f016:	1f 93       	push	r17
    f018:	df 93       	push	r29
    f01a:	cf 93       	push	r28
    f01c:	cd b7       	in	r28, 0x3d	; 61
    f01e:	de b7       	in	r29, 0x3e	; 62
    f020:	e1 97       	sbiw	r28, 0x31	; 49
    f022:	0f b6       	in	r0, 0x3f	; 63
    f024:	f8 94       	cli
    f026:	de bf       	out	0x3e, r29	; 62
    f028:	0f be       	out	0x3f, r0	; 63
    f02a:	cd bf       	out	0x3d, r28	; 61
    f02c:	7c 01       	movw	r14, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f02e:	dc 01       	movw	r26, r24
    f030:	12 96       	adiw	r26, 0x02	; 2
    f032:	8c 91       	ld	r24, X
    f034:	12 97       	sbiw	r26, 0x02	; 2
    f036:	89 83       	std	Y+1, r24	; 0x01
    f038:	13 96       	adiw	r26, 0x03	; 3
    f03a:	8c 91       	ld	r24, X
    f03c:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    f03e:	1b 82       	std	Y+3, r1	; 0x03
	 char strSend[30];
	 char TransDigit;
	 char FIPAddr;
      
	 StrPosCopy(strRawTransData,strPumpID,2,2);
	 RemZeroLead(strPumpID);
    f040:	8e 01       	movw	r16, r28
    f042:	0f 5f       	subi	r16, 0xFF	; 255
    f044:	1f 4f       	sbci	r17, 0xFF	; 255
    f046:	c8 01       	movw	r24, r16
    f048:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
	 iPumpID=atoi(strPumpID); 
    f04c:	c8 01       	movw	r24, r16
    f04e:	0e 94 bf b3 	call	0x1677e	; 0x1677e <atoi>
    f052:	38 2e       	mov	r3, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    f054:	0e 94 1a 1c 	call	0x3834	; 0x3834 <GetFIPAddr>
    f058:	d8 2e       	mov	r13, r24
	 if (FIPAddr>0){
    f05a:	88 23       	and	r24, r24
    f05c:	09 f4       	brne	.+2      	; 0xf060 <StoreStandaloneTransData+0x68>
    f05e:	1a c2       	rjmp	.+1076   	; 0xf494 <StoreStandaloneTransData+0x49c>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    f060:	f7 01       	movw	r30, r14
    f062:	f4 81       	ldd	r31, Z+4	; 0x04
    f064:	f9 ab       	std	Y+49, r31	; 0x31

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f066:	d7 01       	movw	r26, r14
    f068:	15 96       	adiw	r26, 0x05	; 5
    f06a:	2c 90       	ld	r2, X
    f06c:	e4 e0       	ldi	r30, 0x04	; 4
    f06e:	8e 2e       	mov	r8, r30
    f070:	91 2c       	mov	r9, r1
    f072:	8c 0e       	add	r8, r28
    f074:	9d 1e       	adc	r9, r29
    f076:	f4 01       	movw	r30, r8
    f078:	ce 01       	movw	r24, r28
    f07a:	0b 96       	adiw	r24, 0x0b	; 11
	     strMemory[i]=data;
    f07c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f07e:	e8 17       	cp	r30, r24
    f080:	f9 07       	cpc	r31, r25
    f082:	e1 f7       	brne	.-8      	; 0xf07c <StoreStandaloneTransData+0x84>
    f084:	7d e1       	ldi	r23, 0x1D	; 29
    f086:	67 2e       	mov	r6, r23
    f088:	71 2c       	mov	r7, r1
    f08a:	6c 0e       	add	r6, r28
    f08c:	7d 1e       	adc	r7, r29
    f08e:	93 01       	movw	r18, r6
	     strMemory[i]=data;
    f090:	ce 01       	movw	r24, r28
    f092:	87 96       	adiw	r24, 0x27	; 39
    f094:	f9 01       	movw	r30, r18
    f096:	11 92       	st	Z+, r1
    f098:	9f 01       	movw	r18, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f09a:	e8 17       	cp	r30, r24
    f09c:	f9 07       	cpc	r31, r25
    f09e:	d1 f7       	brne	.-12     	; 0xf094 <StoreStandaloneTransData+0x9c>
    f0a0:	2f 01       	movw	r4, r30
	     strMemory[i]=data;
    f0a2:	ce 01       	movw	r24, r28
    f0a4:	c1 96       	adiw	r24, 0x31	; 49
    f0a6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f0a8:	e8 17       	cp	r30, r24
    f0aa:	f9 07       	cpc	r31, r25
    f0ac:	e1 f7       	brne	.-8      	; 0xf0a6 <StoreStandaloneTransData+0xae>
    f0ae:	a7 01       	movw	r20, r14
    f0b0:	d7 01       	movw	r26, r14
    f0b2:	f4 01       	movw	r30, r8
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f0b4:	be 01       	movw	r22, r28
    f0b6:	66 5f       	subi	r22, 0xF6	; 246
    f0b8:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f0ba:	16 96       	adiw	r26, 0x06	; 6
    f0bc:	8c 91       	ld	r24, X
    f0be:	16 97       	sbiw	r26, 0x06	; 6
    f0c0:	81 93       	st	Z+, r24
    f0c2:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f0c4:	e6 17       	cp	r30, r22
    f0c6:	f7 07       	cpc	r31, r23
    f0c8:	c1 f7       	brne	.-16     	; 0xf0ba <StoreStandaloneTransData+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f0ca:	1a 86       	std	Y+10, r1	; 0x0a
    f0cc:	d7 01       	movw	r26, r14
    f0ce:	f3 01       	movw	r30, r6
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f0d0:	be 01       	movw	r22, r28
    f0d2:	6b 5d       	subi	r22, 0xDB	; 219
    f0d4:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f0d6:	1c 96       	adiw	r26, 0x0c	; 12
    f0d8:	8c 91       	ld	r24, X
    f0da:	1c 97       	sbiw	r26, 0x0c	; 12
    f0dc:	81 93       	st	Z+, r24
    f0de:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f0e0:	e6 17       	cp	r30, r22
    f0e2:	f7 07       	cpc	r31, r23
    f0e4:	c1 f7       	brne	.-16     	; 0xf0d6 <StoreStandaloneTransData+0xde>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f0e6:	1d a2       	std	Y+37, r1	; 0x25
    f0e8:	f9 01       	movw	r30, r18
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f0ea:	be 01       	movw	r22, r28
    f0ec:	69 5d       	subi	r22, 0xD9	; 217
    f0ee:	7f 4f       	sbci	r23, 0xFF	; 255
    f0f0:	9e 01       	movw	r18, r28
    f0f2:	21 5d       	subi	r18, 0xD1	; 209
    f0f4:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f0f6:	da 01       	movw	r26, r20
    f0f8:	54 96       	adiw	r26, 0x14	; 20
    f0fa:	8c 91       	ld	r24, X
    f0fc:	81 93       	st	Z+, r24
    f0fe:	4f 5f       	subi	r20, 0xFF	; 255
    f100:	5f 4f       	sbci	r21, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f102:	e2 17       	cp	r30, r18
    f104:	f3 07       	cpc	r31, r19
    f106:	b9 f7       	brne	.-18     	; 0xf0f6 <StoreStandaloneTransData+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f108:	1f a6       	std	Y+47, r1	; 0x2f
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    f10a:	f7 01       	movw	r30, r14
    f10c:	84 8d       	ldd	r24, Z+28	; 0x1c
    f10e:	80 53       	subi	r24, 0x30	; 48
    f110:	8a 30       	cpi	r24, 0x0A	; 10
    f112:	98 f4       	brcc	.+38     	; 0xf13a <StoreStandaloneTransData+0x142>

		 TransDigit=Ord(CharPosCopy(strRawTransData,28));
		 //Normalize7Digit
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //_uart_print(1,1,strSend);
		 if  (TransDigit==8){
    f114:	88 30       	cpi	r24, 0x08	; 8
    f116:	89 f4       	brne	.+34     	; 0xf13a <StoreStandaloneTransData+0x142>
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
    f118:	fb 01       	movw	r30, r22
    f11a:	01 90       	ld	r0, Z+
    f11c:	00 20       	and	r0, r0
    f11e:	e9 f7       	brne	.-6      	; 0xf11a <StoreStandaloneTransData+0x122>
    f120:	e6 1b       	sub	r30, r22
    f122:	f7 0b       	sbc	r31, r23
    f124:	32 97       	sbiw	r30, 0x02	; 2
    f126:	80 e0       	ldi	r24, 0x00	; 0
    f128:	90 e0       	ldi	r25, 0x00	; 0
    f12a:	01 c0       	rjmp	.+2      	; 0xf12e <StoreStandaloneTransData+0x136>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f12c:	01 96       	adiw	r24, 0x01	; 1
    f12e:	8e 17       	cp	r24, r30
    f130:	9f 07       	cpc	r25, r31
    f132:	e0 f3       	brcs	.-8      	; 0xf12c <StoreStandaloneTransData+0x134>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f134:	ec 0f       	add	r30, r28
    f136:	fd 1f       	adc	r31, r29
    f138:	17 a2       	std	Z+39, r1	; 0x27
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //_uart_print(1,1,strSend);
		 if  (TransDigit==8){
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
		 }
		 RemZeroLead(strPPU);
    f13a:	64 e0       	ldi	r22, 0x04	; 4
    f13c:	e6 2e       	mov	r14, r22
    f13e:	f1 2c       	mov	r15, r1
    f140:	ec 0e       	add	r14, r28
    f142:	fd 1e       	adc	r15, r29
    f144:	c7 01       	movw	r24, r14
    f146:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
		 RemZeroLead(strPVolume);
    f14a:	5d e1       	ldi	r21, 0x1D	; 29
    f14c:	a5 2e       	mov	r10, r21
    f14e:	b1 2c       	mov	r11, r1
    f150:	ac 0e       	add	r10, r28
    f152:	bd 1e       	adc	r11, r29
    f154:	c5 01       	movw	r24, r10
    f156:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
		 RemZeroLead(strPMoney);
    f15a:	8e 01       	movw	r16, r28
    f15c:	09 5d       	subi	r16, 0xD9	; 217
    f15e:	1f 4f       	sbci	r17, 0xFF	; 255
    f160:	c8 01       	movw	r24, r16
    f162:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
		 //sprintf_P(strSend,PSTR("Money: %s"),strPMoney);
		 //_uart_print(1,1,strSend);


		 //Void Detection
		 if (atoi(strPMoney)==0)TransactionStatus=TS_VOID;
    f166:	c8 01       	movw	r24, r16
    f168:	0e 94 bf b3 	call	0x1677e	; 0x1677e <atoi>
    f16c:	89 2b       	or	r24, r25
    f16e:	09 f0       	breq	.+2      	; 0xf172 <StoreStandaloneTransData+0x17a>
    f170:	46 c1       	rjmp	.+652    	; 0xf3fe <StoreStandaloneTransData+0x406>
		 else TransactionStatus=TS_NEW;
		 
		 if (TransactionStatus==TS_VOID){//RejectData
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
    f172:	83 2d       	mov	r24, r3
    f174:	8f 70       	andi	r24, 0x0F	; 15
    f176:	63 e1       	ldi	r22, 0x13	; 19
    f178:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <UpdateStandaloneStatus>
    f17c:	8b c1       	rjmp	.+790    	; 0xf494 <StoreStandaloneTransData+0x49c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f17e:	e1 99       	sbic	0x1c, 1	; 28
    f180:	fe cf       	rjmp	.-4      	; 0xf17e <StoreStandaloneTransData+0x186>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f182:	8f e3       	ldi	r24, 0x3F	; 63
    f184:	91 e0       	ldi	r25, 0x01	; 1
    f186:	9f bb       	out	0x1f, r25	; 31
    f188:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f18a:	e0 9a       	sbi	0x1c, 0	; 28
    f18c:	2d b3       	in	r18, 0x1d	; 29
			 //_uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    f18e:	00 d0       	rcall	.+0      	; 0xf190 <StoreStandaloneTransData+0x198>
    f190:	00 d0       	rcall	.+0      	; 0xf192 <StoreStandaloneTransData+0x19a>
    f192:	00 d0       	rcall	.+0      	; 0xf194 <StoreStandaloneTransData+0x19c>
    f194:	ed b7       	in	r30, 0x3d	; 61
    f196:	fe b7       	in	r31, 0x3e	; 62
    f198:	31 96       	adiw	r30, 0x01	; 1
    f19a:	83 e9       	ldi	r24, 0x93	; 147
    f19c:	9e e0       	ldi	r25, 0x0E	; 14
    f19e:	ad b7       	in	r26, 0x3d	; 61
    f1a0:	be b7       	in	r27, 0x3e	; 62
    f1a2:	12 96       	adiw	r26, 0x02	; 2
    f1a4:	9c 93       	st	X, r25
    f1a6:	8e 93       	st	-X, r24
    f1a8:	11 97       	sbiw	r26, 0x01	; 1
    f1aa:	8f e7       	ldi	r24, 0x7F	; 127
    f1ac:	92 e2       	ldi	r25, 0x22	; 34
    f1ae:	93 83       	std	Z+3, r25	; 0x03
    f1b0:	82 83       	std	Z+2, r24	; 0x02
    f1b2:	24 83       	std	Z+4, r18	; 0x04
    f1b4:	15 82       	std	Z+5, r1	; 0x05
    f1b6:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
    f1ba:	e1 eb       	ldi	r30, 0xB1	; 177
    f1bc:	fe e0       	ldi	r31, 0x0E	; 14
    f1be:	df 01       	movw	r26, r30
    f1c0:	0d 90       	ld	r0, X+
    f1c2:	00 20       	and	r0, r0
    f1c4:	e9 f7       	brne	.-6      	; 0xf1c0 <StoreStandaloneTransData+0x1c8>
    f1c6:	9d 01       	movw	r18, r26
    f1c8:	21 50       	subi	r18, 0x01	; 1
    f1ca:	30 40       	sbci	r19, 0x00	; 0
    f1cc:	2e 1b       	sub	r18, r30
    f1ce:	3f 0b       	sbc	r19, r31
    f1d0:	85 e3       	ldi	r24, 0x35	; 53
    f1d2:	90 e0       	ldi	r25, 0x00	; 0
    f1d4:	c8 9e       	mul	r12, r24
    f1d6:	d0 01       	movw	r26, r0
    f1d8:	c9 9e       	mul	r12, r25
    f1da:	b0 0d       	add	r27, r0
    f1dc:	d8 9e       	mul	r13, r24
    f1de:	b0 0d       	add	r27, r0
    f1e0:	11 24       	eor	r1, r1
    f1e2:	a2 52       	subi	r26, 0x22	; 34
    f1e4:	b8 4f       	sbci	r27, 0xF8	; 248
    f1e6:	4d b7       	in	r20, 0x3d	; 61
    f1e8:	5e b7       	in	r21, 0x3e	; 62
    f1ea:	4a 5f       	subi	r20, 0xFA	; 250
    f1ec:	5f 4f       	sbci	r21, 0xFF	; 255
    f1ee:	0f b6       	in	r0, 0x3f	; 63
    f1f0:	f8 94       	cli
    f1f2:	5e bf       	out	0x3e, r21	; 62
    f1f4:	0f be       	out	0x3f, r0	; 63
    f1f6:	4d bf       	out	0x3d, r20	; 61
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f1f8:	a9 01       	movw	r20, r18
    f1fa:	4e 0f       	add	r20, r30
    f1fc:	5f 1f       	adc	r21, r31
    f1fe:	02 c0       	rjmp	.+4      	; 0xf204 <StoreStandaloneTransData+0x20c>
	    Dest[i]=Source[IdxSource+i];
    f200:	81 91       	ld	r24, Z+
    f202:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f204:	e4 17       	cp	r30, r20
    f206:	f5 07       	cpc	r31, r21
    f208:	d9 f7       	brne	.-10     	; 0xf200 <StoreStandaloneTransData+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f20a:	85 e3       	ldi	r24, 0x35	; 53
    f20c:	90 e0       	ldi	r25, 0x00	; 0
    f20e:	dc 01       	movw	r26, r24
    f210:	ca 9e       	mul	r12, r26
    f212:	c0 01       	movw	r24, r0
    f214:	cb 9e       	mul	r12, r27
    f216:	90 0d       	add	r25, r0
    f218:	da 9e       	mul	r13, r26
    f21a:	90 0d       	add	r25, r0
    f21c:	11 24       	eor	r1, r1
    f21e:	fc 01       	movw	r30, r24
    f220:	e5 52       	subi	r30, 0x25	; 37
    f222:	f8 4f       	sbci	r31, 0xF8	; 248
    f224:	e2 0f       	add	r30, r18
    f226:	f3 1f       	adc	r31, r19
    f228:	13 82       	std	Z+3, r1	; 0x03
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
    f22a:	fe 01       	movw	r30, r28
    f22c:	3b 96       	adiw	r30, 0x0b	; 11
    f22e:	df 01       	movw	r26, r30
    f230:	0d 90       	ld	r0, X+
    f232:	00 20       	and	r0, r0
    f234:	e9 f7       	brne	.-6      	; 0xf230 <StoreStandaloneTransData+0x238>
    f236:	11 97       	sbiw	r26, 0x01	; 1
    f238:	ae 1b       	sub	r26, r30
    f23a:	bf 0b       	sbc	r27, r31
    f23c:	bf 01       	movw	r22, r30
    f23e:	9c 01       	movw	r18, r24
    f240:	2b 51       	subi	r18, 0x1B	; 27
    f242:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f244:	af 01       	movw	r20, r30
    f246:	4a 0f       	add	r20, r26
    f248:	5b 1f       	adc	r21, r27
    f24a:	06 c0       	rjmp	.+12     	; 0xf258 <StoreStandaloneTransData+0x260>
	    Dest[i]=Source[IdxSource+i];
    f24c:	fb 01       	movw	r30, r22
    f24e:	81 91       	ld	r24, Z+
    f250:	bf 01       	movw	r22, r30
    f252:	f9 01       	movw	r30, r18
    f254:	81 93       	st	Z+, r24
    f256:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f258:	64 17       	cp	r22, r20
    f25a:	75 07       	cpc	r23, r21
    f25c:	b9 f7       	brne	.-18     	; 0xf24c <StoreStandaloneTransData+0x254>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f25e:	85 e3       	ldi	r24, 0x35	; 53
    f260:	90 e0       	ldi	r25, 0x00	; 0
    f262:	9c 01       	movw	r18, r24
    f264:	c2 9e       	mul	r12, r18
    f266:	c0 01       	movw	r24, r0
    f268:	c3 9e       	mul	r12, r19
    f26a:	90 0d       	add	r25, r0
    f26c:	d2 9e       	mul	r13, r18
    f26e:	90 0d       	add	r25, r0
    f270:	11 24       	eor	r1, r1
    f272:	fc 01       	movw	r30, r24
    f274:	e5 52       	subi	r30, 0x25	; 37
    f276:	f8 4f       	sbci	r31, 0xF8	; 248
    f278:	ea 0f       	add	r30, r26
    f27a:	fb 1f       	adc	r31, r27
    f27c:	12 86       	std	Z+10, r1	; 0x0a
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
    f27e:	fe 01       	movw	r30, r28
    f280:	74 96       	adiw	r30, 0x14	; 20
    f282:	df 01       	movw	r26, r30
    f284:	0d 90       	ld	r0, X+
    f286:	00 20       	and	r0, r0
    f288:	e9 f7       	brne	.-6      	; 0xf284 <StoreStandaloneTransData+0x28c>
    f28a:	11 97       	sbiw	r26, 0x01	; 1
    f28c:	ae 1b       	sub	r26, r30
    f28e:	bf 0b       	sbc	r27, r31
    f290:	bf 01       	movw	r22, r30
    f292:	9c 01       	movw	r18, r24
    f294:	22 51       	subi	r18, 0x12	; 18
    f296:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f298:	af 01       	movw	r20, r30
    f29a:	4a 0f       	add	r20, r26
    f29c:	5b 1f       	adc	r21, r27
    f29e:	06 c0       	rjmp	.+12     	; 0xf2ac <StoreStandaloneTransData+0x2b4>
	    Dest[i]=Source[IdxSource+i];
    f2a0:	fb 01       	movw	r30, r22
    f2a2:	81 91       	ld	r24, Z+
    f2a4:	bf 01       	movw	r22, r30
    f2a6:	f9 01       	movw	r30, r18
    f2a8:	81 93       	st	Z+, r24
    f2aa:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f2ac:	64 17       	cp	r22, r20
    f2ae:	75 07       	cpc	r23, r21
    f2b0:	b9 f7       	brne	.-18     	; 0xf2a0 <StoreStandaloneTransData+0x2a8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f2b2:	85 e3       	ldi	r24, 0x35	; 53
    f2b4:	90 e0       	ldi	r25, 0x00	; 0
    f2b6:	c8 9e       	mul	r12, r24
    f2b8:	70 01       	movw	r14, r0
    f2ba:	c9 9e       	mul	r12, r25
    f2bc:	f0 0c       	add	r15, r0
    f2be:	d8 9e       	mul	r13, r24
    f2c0:	f0 0c       	add	r15, r0
    f2c2:	11 24       	eor	r1, r1
    f2c4:	87 01       	movw	r16, r14
    f2c6:	05 52       	subi	r16, 0x25	; 37
    f2c8:	18 4f       	sbci	r17, 0xF8	; 248
    f2ca:	a0 0f       	add	r26, r16
    f2cc:	b1 1f       	adc	r27, r17
    f2ce:	53 96       	adiw	r26, 0x13	; 19
    f2d0:	1c 92       	st	X, r1
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
			 //Grade Nozzle Shift
			 RecPumpData[FIPAddr].Grade=PGrade;
    f2d2:	f0 ed       	ldi	r31, 0xD0	; 208
    f2d4:	2f 0e       	add	r2, r31
    f2d6:	d8 01       	movw	r26, r16
    f2d8:	2c 92       	st	X, r2
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
    f2da:	b9 a9       	ldd	r27, Y+49	; 0x31
    f2dc:	b0 53       	subi	r27, 0x30	; 48
    f2de:	f8 01       	movw	r30, r16
    f2e0:	b1 83       	std	Z+1, r27	; 0x01
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
    f2e2:	83 e9       	ldi	r24, 0x93	; 147
    f2e4:	9e e0       	ldi	r25, 0x0E	; 14
    f2e6:	0e 94 bf b3 	call	0x1677e	; 0x1677e <atoi>
    f2ea:	d8 01       	movw	r26, r16
    f2ec:	12 96       	adiw	r26, 0x02	; 2
    f2ee:	8c 93       	st	X, r24
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
    f2f0:	fe 01       	movw	r30, r28
    f2f2:	34 96       	adiw	r30, 0x04	; 4
    f2f4:	df 01       	movw	r26, r30
    f2f6:	0d 90       	ld	r0, X+
    f2f8:	00 20       	and	r0, r0
    f2fa:	e9 f7       	brne	.-6      	; 0xf2f6 <StoreStandaloneTransData+0x2fe>
    f2fc:	11 97       	sbiw	r26, 0x01	; 1
    f2fe:	ae 1b       	sub	r26, r30
    f300:	bf 0b       	sbc	r27, r31
    f302:	97 01       	movw	r18, r14
    f304:	29 50       	subi	r18, 0x09	; 9
    f306:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f308:	af 01       	movw	r20, r30
    f30a:	4a 0f       	add	r20, r26
    f30c:	5b 1f       	adc	r21, r27
    f30e:	06 c0       	rjmp	.+12     	; 0xf31c <StoreStandaloneTransData+0x324>
	    Dest[i]=Source[IdxSource+i];
    f310:	f4 01       	movw	r30, r8
    f312:	81 91       	ld	r24, Z+
    f314:	4f 01       	movw	r8, r30
    f316:	f9 01       	movw	r30, r18
    f318:	81 93       	st	Z+, r24
    f31a:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f31c:	84 16       	cp	r8, r20
    f31e:	95 06       	cpc	r9, r21
    f320:	b9 f7       	brne	.-18     	; 0xf310 <StoreStandaloneTransData+0x318>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f322:	85 e3       	ldi	r24, 0x35	; 53
    f324:	90 e0       	ldi	r25, 0x00	; 0
    f326:	9c 01       	movw	r18, r24
    f328:	c2 9e       	mul	r12, r18
    f32a:	c0 01       	movw	r24, r0
    f32c:	c3 9e       	mul	r12, r19
    f32e:	90 0d       	add	r25, r0
    f330:	d2 9e       	mul	r13, r18
    f332:	90 0d       	add	r25, r0
    f334:	11 24       	eor	r1, r1
    f336:	fc 01       	movw	r30, r24
    f338:	e5 52       	subi	r30, 0x25	; 37
    f33a:	f8 4f       	sbci	r31, 0xF8	; 248
    f33c:	ea 0f       	add	r30, r26
    f33e:	fb 1f       	adc	r31, r27
    f340:	14 8e       	std	Z+28, r1	; 0x1c
			 RecPumpData[FIPAddr].Grade=PGrade;
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
    f342:	fe 01       	movw	r30, r28
    f344:	7d 96       	adiw	r30, 0x1d	; 29
    f346:	df 01       	movw	r26, r30
    f348:	0d 90       	ld	r0, X+
    f34a:	00 20       	and	r0, r0
    f34c:	e9 f7       	brne	.-6      	; 0xf348 <StoreStandaloneTransData+0x350>
    f34e:	11 97       	sbiw	r26, 0x01	; 1
    f350:	ae 1b       	sub	r26, r30
    f352:	bf 0b       	sbc	r27, r31
    f354:	9c 01       	movw	r18, r24
    f356:	22 50       	subi	r18, 0x02	; 2
    f358:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f35a:	af 01       	movw	r20, r30
    f35c:	4a 0f       	add	r20, r26
    f35e:	5b 1f       	adc	r21, r27
    f360:	06 c0       	rjmp	.+12     	; 0xf36e <StoreStandaloneTransData+0x376>
	    Dest[i]=Source[IdxSource+i];
    f362:	f3 01       	movw	r30, r6
    f364:	81 91       	ld	r24, Z+
    f366:	3f 01       	movw	r6, r30
    f368:	f9 01       	movw	r30, r18
    f36a:	81 93       	st	Z+, r24
    f36c:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f36e:	64 16       	cp	r6, r20
    f370:	75 06       	cpc	r7, r21
    f372:	b9 f7       	brne	.-18     	; 0xf362 <StoreStandaloneTransData+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f374:	85 e3       	ldi	r24, 0x35	; 53
    f376:	90 e0       	ldi	r25, 0x00	; 0
    f378:	9c 01       	movw	r18, r24
    f37a:	c2 9e       	mul	r12, r18
    f37c:	c0 01       	movw	r24, r0
    f37e:	c3 9e       	mul	r12, r19
    f380:	90 0d       	add	r25, r0
    f382:	d2 9e       	mul	r13, r18
    f384:	90 0d       	add	r25, r0
    f386:	11 24       	eor	r1, r1
    f388:	fc 01       	movw	r30, r24
    f38a:	e5 52       	subi	r30, 0x25	; 37
    f38c:	f8 4f       	sbci	r31, 0xF8	; 248
    f38e:	ea 0f       	add	r30, r26
    f390:	fb 1f       	adc	r31, r27
    f392:	13 a2       	std	Z+35, r1	; 0x23
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));
    f394:	fe 01       	movw	r30, r28
    f396:	b7 96       	adiw	r30, 0x27	; 39
    f398:	df 01       	movw	r26, r30
    f39a:	0d 90       	ld	r0, X+
    f39c:	00 20       	and	r0, r0
    f39e:	e9 f7       	brne	.-6      	; 0xf39a <StoreStandaloneTransData+0x3a2>
    f3a0:	11 97       	sbiw	r26, 0x01	; 1
    f3a2:	ae 1b       	sub	r26, r30
    f3a4:	bf 0b       	sbc	r27, r31
    f3a6:	9c 01       	movw	r18, r24
    f3a8:	29 5f       	subi	r18, 0xF9	; 249
    f3aa:	37 4f       	sbci	r19, 0xF7	; 247
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3ac:	af 01       	movw	r20, r30
    f3ae:	4a 0f       	add	r20, r26
    f3b0:	5b 1f       	adc	r21, r27
    f3b2:	06 c0       	rjmp	.+12     	; 0xf3c0 <StoreStandaloneTransData+0x3c8>
	    Dest[i]=Source[IdxSource+i];
    f3b4:	f2 01       	movw	r30, r4
    f3b6:	81 91       	ld	r24, Z+
    f3b8:	2f 01       	movw	r4, r30
    f3ba:	f9 01       	movw	r30, r18
    f3bc:	81 93       	st	Z+, r24
    f3be:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3c0:	44 16       	cp	r4, r20
    f3c2:	55 06       	cpc	r5, r21
    f3c4:	b9 f7       	brne	.-18     	; 0xf3b4 <StoreStandaloneTransData+0x3bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f3c6:	85 e3       	ldi	r24, 0x35	; 53
    f3c8:	90 e0       	ldi	r25, 0x00	; 0
    f3ca:	c8 9e       	mul	r12, r24
    f3cc:	f0 01       	movw	r30, r0
    f3ce:	c9 9e       	mul	r12, r25
    f3d0:	f0 0d       	add	r31, r0
    f3d2:	d8 9e       	mul	r13, r24
    f3d4:	f0 0d       	add	r31, r0
    f3d6:	11 24       	eor	r1, r1
    f3d8:	e5 52       	subi	r30, 0x25	; 37
    f3da:	f8 4f       	sbci	r31, 0xF8	; 248
    f3dc:	ea 0f       	add	r30, r26
    f3de:	fb 1f       	adc	r31, r27
    f3e0:	14 a6       	std	Z+44, r1	; 0x2c
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));

			 UpdateStandaloneStatus((iPumpID&0x0F),PS_PRINT_READY);
    f3e2:	83 2d       	mov	r24, r3
    f3e4:	8f 70       	andi	r24, 0x0F	; 15
    f3e6:	60 e1       	ldi	r22, 0x10	; 16
    f3e8:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <UpdateStandaloneStatus>
			 
			 SetIncomingTransStatus(iPumpID,TS_NEW);		 
    f3ec:	83 2d       	mov	r24, r3
    f3ee:	62 e0       	ldi	r22, 0x02	; 2
    f3f0:	0e 94 90 1a 	call	0x3520	; 0x3520 <SetIncomingTransStatus>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
    f3f4:	8b e0       	ldi	r24, 0x0B	; 11
    f3f6:	63 2d       	mov	r22, r3
    f3f8:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
    f3fc:	4b c0       	rjmp	.+150    	; 0xf494 <StoreStandaloneTransData+0x49c>
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
		 }
		 else 
		 if (TransactionStatus=TS_NEW){ 
			 //Update ReprintReady
			 ReprintReady[FIPAddr]=True;//Ready for Printing
    f3fe:	da 94       	dec	r13
    f400:	cd 2c       	mov	r12, r13
    f402:	dd 24       	eor	r13, r13
    f404:	f6 01       	movw	r30, r12
    f406:	ee 57       	subi	r30, 0x7E	; 126
    f408:	fe 4f       	sbci	r31, 0xFE	; 254
    f40a:	81 e0       	ldi	r24, 0x01	; 1
    f40c:	80 83       	st	Z, r24
			  
			 FormatPrice(strPPU);
    f40e:	c7 01       	movw	r24, r14
    f410:	0e 94 8e 31 	call	0x631c	; 0x631c <FormatPrice>
			 FormatMoney(strPMoney);
    f414:	c8 01       	movw	r24, r16
    f416:	0e 94 81 31 	call	0x6302	; 0x6302 <FormatMoney>
			 FormatVolume(strPVolume);
    f41a:	c5 01       	movw	r24, r10
    f41c:	0e 94 74 31 	call	0x62e8	; 0x62e8 <FormatVolume>

			 //_uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
    f420:	81 eb       	ldi	r24, 0xB1	; 177
    f422:	9e e0       	ldi	r25, 0x0E	; 14
    f424:	0e 94 cf 48 	call	0x919e	; 0x919e <GenerateTransactionNum>
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
    f428:	00 d0       	rcall	.+0      	; 0xf42a <StoreStandaloneTransData+0x432>
    f42a:	00 d0       	rcall	.+0      	; 0xf42c <StoreStandaloneTransData+0x434>
    f42c:	00 d0       	rcall	.+0      	; 0xf42e <StoreStandaloneTransData+0x436>
    f42e:	ed b7       	in	r30, 0x3d	; 61
    f430:	fe b7       	in	r31, 0x3e	; 62
    f432:	31 96       	adiw	r30, 0x01	; 1
    f434:	ce 01       	movw	r24, r28
    f436:	0b 96       	adiw	r24, 0x0b	; 11
    f438:	ad b7       	in	r26, 0x3d	; 61
    f43a:	be b7       	in	r27, 0x3e	; 62
    f43c:	12 96       	adiw	r26, 0x02	; 2
    f43e:	9c 93       	st	X, r25
    f440:	8e 93       	st	-X, r24
    f442:	11 97       	sbiw	r26, 0x01	; 1
    f444:	85 e8       	ldi	r24, 0x85	; 133
    f446:	92 e2       	ldi	r25, 0x22	; 34
    f448:	93 83       	std	Z+3, r25	; 0x03
    f44a:	82 83       	std	Z+2, r24	; 0x02
    f44c:	8a ee       	ldi	r24, 0xEA	; 234
    f44e:	95 e0       	ldi	r25, 0x05	; 5
    f450:	95 83       	std	Z+5, r25	; 0x05
    f452:	84 83       	std	Z+4, r24	; 0x04
    f454:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
    f458:	ed b7       	in	r30, 0x3d	; 61
    f45a:	fe b7       	in	r31, 0x3e	; 62
    f45c:	31 96       	adiw	r30, 0x01	; 1
    f45e:	ce 01       	movw	r24, r28
    f460:	44 96       	adiw	r24, 0x14	; 20
    f462:	ad b7       	in	r26, 0x3d	; 61
    f464:	be b7       	in	r27, 0x3e	; 62
    f466:	12 96       	adiw	r26, 0x02	; 2
    f468:	9c 93       	st	X, r25
    f46a:	8e 93       	st	-X, r24
    f46c:	11 97       	sbiw	r26, 0x01	; 1
    f46e:	82 e8       	ldi	r24, 0x82	; 130
    f470:	92 e2       	ldi	r25, 0x22	; 34
    f472:	93 83       	std	Z+3, r25	; 0x03
    f474:	82 83       	std	Z+2, r24	; 0x02
    f476:	89 ec       	ldi	r24, 0xC9	; 201
    f478:	9a e0       	ldi	r25, 0x0A	; 10
    f47a:	95 83       	std	Z+5, r25	; 0x05
    f47c:	84 83       	std	Z+4, r24	; 0x04
    f47e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    f482:	ed b7       	in	r30, 0x3d	; 61
    f484:	fe b7       	in	r31, 0x3e	; 62
    f486:	36 96       	adiw	r30, 0x06	; 6
    f488:	0f b6       	in	r0, 0x3f	; 63
    f48a:	f8 94       	cli
    f48c:	fe bf       	out	0x3e, r31	; 62
    f48e:	0f be       	out	0x3f, r0	; 63
    f490:	ed bf       	out	0x3d, r30	; 61
    f492:	75 ce       	rjmp	.-790    	; 0xf17e <StoreStandaloneTransData+0x186>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
		 }		 
	 }    
     //_uart_print(0,1,strRawTransData);
}
    f494:	e1 96       	adiw	r28, 0x31	; 49
    f496:	0f b6       	in	r0, 0x3f	; 63
    f498:	f8 94       	cli
    f49a:	de bf       	out	0x3e, r29	; 62
    f49c:	0f be       	out	0x3f, r0	; 63
    f49e:	cd bf       	out	0x3d, r28	; 61
    f4a0:	cf 91       	pop	r28
    f4a2:	df 91       	pop	r29
    f4a4:	1f 91       	pop	r17
    f4a6:	0f 91       	pop	r16
    f4a8:	ff 90       	pop	r15
    f4aa:	ef 90       	pop	r14
    f4ac:	df 90       	pop	r13
    f4ae:	cf 90       	pop	r12
    f4b0:	bf 90       	pop	r11
    f4b2:	af 90       	pop	r10
    f4b4:	9f 90       	pop	r9
    f4b6:	8f 90       	pop	r8
    f4b8:	7f 90       	pop	r7
    f4ba:	6f 90       	pop	r6
    f4bc:	5f 90       	pop	r5
    f4be:	4f 90       	pop	r4
    f4c0:	3f 90       	pop	r3
    f4c2:	2f 90       	pop	r2
    f4c4:	08 95       	ret

0000f4c6 <StoreStandaloneTotalizerData>:
	  systemEDC();
	  systemConfigProtocol();
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}

void StoreStandaloneTotalizerData(char *strRawTransData){//Sending FlowSPI_Protocol <STX>   [MsgID][PumpID][Volume1][Amount1][Volume2][Amount2][Volume3][Amount3][Volume4][Amount4][Volume5][Amount5][Volume6][Amount6]<ETX>
    f4c6:	2f 92       	push	r2
    f4c8:	3f 92       	push	r3
    f4ca:	4f 92       	push	r4
    f4cc:	5f 92       	push	r5
    f4ce:	7f 92       	push	r7
    f4d0:	8f 92       	push	r8
    f4d2:	9f 92       	push	r9
    f4d4:	af 92       	push	r10
    f4d6:	bf 92       	push	r11
    f4d8:	cf 92       	push	r12
    f4da:	df 92       	push	r13
    f4dc:	ef 92       	push	r14
    f4de:	ff 92       	push	r15
    f4e0:	0f 93       	push	r16
    f4e2:	1f 93       	push	r17
    f4e4:	df 93       	push	r29
    f4e6:	cf 93       	push	r28
    f4e8:	cd b7       	in	r28, 0x3d	; 61
    f4ea:	de b7       	in	r29, 0x3e	; 62
    f4ec:	a1 97       	sbiw	r28, 0x21	; 33
    f4ee:	0f b6       	in	r0, 0x3f	; 63
    f4f0:	f8 94       	cli
    f4f2:	de bf       	out	0x3e, r29	; 62
    f4f4:	0f be       	out	0x3f, r0	; 63
    f4f6:	cd bf       	out	0x3d, r28	; 61
    f4f8:	8c 01       	movw	r16, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f4fa:	fc 01       	movw	r30, r24
    f4fc:	82 81       	ldd	r24, Z+2	; 0x02
    f4fe:	89 83       	std	Y+1, r24	; 0x01
    f500:	83 81       	ldd	r24, Z+3	; 0x03
    f502:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    f504:	1b 82       	std	Y+3, r1	; 0x03
	 //    _uart(1,1,strRawTransData[i]); 
	 // }

     StrPosCopy(strRawTransData,strPumpID,2,2);
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
    f506:	ce 01       	movw	r24, r28
    f508:	01 96       	adiw	r24, 0x01	; 1
    f50a:	0e 94 bf b3 	call	0x1677e	; 0x1677e <atoi>
    f50e:	c8 2e       	mov	r12, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    f510:	0e 94 1a 1c 	call	0x3834	; 0x3834 <GetFIPAddr>
	 if (FIPAddr>0){
    f514:	88 23       	and	r24, r24
    f516:	09 f4       	brne	.+2      	; 0xf51a <StoreStandaloneTotalizerData+0x54>
    f518:	44 c0       	rjmp	.+136    	; 0xf5a2 <StoreStandaloneTotalizerData+0xdc>
	     FIPAddr=FIPAddr-1;
    f51a:	78 2e       	mov	r7, r24
    f51c:	7a 94       	dec	r7
    f51e:	80 e1       	ldi	r24, 0x10	; 16
    f520:	e8 2e       	mov	r14, r24
    f522:	f1 2c       	mov	r15, r1
    f524:	e0 0e       	add	r14, r16
    f526:	f1 1e       	adc	r15, r17
    f528:	dd 24       	eor	r13, r13
    f52a:	d3 94       	inc	r13
    f52c:	14 e0       	ldi	r17, 0x04	; 4
    f52e:	81 2e       	mov	r8, r17
    f530:	91 2c       	mov	r9, r1
    f532:	8c 0e       	add	r8, r28
    f534:	9d 1e       	adc	r9, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f536:	b0 e1       	ldi	r27, 0x10	; 16
    f538:	2b 2e       	mov	r2, r27
    f53a:	31 2c       	mov	r3, r1
    f53c:	2c 0e       	add	r2, r28
    f53e:	3d 1e       	adc	r3, r29
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f540:	a3 e1       	ldi	r26, 0x13	; 19
    f542:	aa 2e       	mov	r10, r26
    f544:	b1 2c       	mov	r11, r1
    f546:	ac 0e       	add	r10, r28
    f548:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f54a:	ff e1       	ldi	r31, 0x1F	; 31
    f54c:	4f 2e       	mov	r4, r31
    f54e:	51 2c       	mov	r5, r1
    f550:	4c 0e       	add	r4, r28
    f552:	5d 1e       	adc	r5, r29
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
	 
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
    f554:	d7 01       	movw	r26, r14
    f556:	1c 97       	sbiw	r26, 0x0c	; 12
    f558:	f4 01       	movw	r30, r8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f55a:	8d 91       	ld	r24, X+
    f55c:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f55e:	e2 15       	cp	r30, r2
    f560:	f3 05       	cpc	r31, r3
    f562:	d9 f7       	brne	.-10     	; 0xf55a <StoreStandaloneTotalizerData+0x94>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f564:	18 8a       	std	Y+16, r1	; 0x10
    f566:	f5 01       	movw	r30, r10
    f568:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f56a:	8d 91       	ld	r24, X+
    f56c:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f56e:	e4 15       	cp	r30, r4
    f570:	f5 05       	cpc	r31, r5
    f572:	d9 f7       	brne	.-10     	; 0xf56a <StoreStandaloneTotalizerData+0xa4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f574:	1f 8e       	std	Y+31, r1	; 0x1f

		 for (iGrade=1;iGrade<=6;iGrade++){          
			  StrPosCopy(strRawTransData,strGVolume,(4+((iGrade-1)*24)),12);
			  StrPosCopy(strRawTransData,strGMoney,(16+((iGrade-1)*24)),12);
			  
			  SetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strGVolume);
    f576:	80 e0       	ldi	r24, 0x00	; 0
    f578:	61 e0       	ldi	r22, 0x01	; 1
    f57a:	47 2d       	mov	r20, r7
    f57c:	2d 2d       	mov	r18, r13
    f57e:	84 01       	movw	r16, r8
    f580:	0e 94 a3 44 	call	0x8946	; 0x8946 <SetTotalizerData>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
    f584:	81 e0       	ldi	r24, 0x01	; 1
    f586:	61 e0       	ldi	r22, 0x01	; 1
    f588:	47 2d       	mov	r20, r7
    f58a:	2d 2d       	mov	r18, r13
    f58c:	85 01       	movw	r16, r10
    f58e:	0e 94 a3 44 	call	0x8946	; 0x8946 <SetTotalizerData>
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
		 //_uart_printf(1,1,PSTR("Totalizer:"));

		 for (iGrade=1;iGrade<=6;iGrade++){          
    f592:	d3 94       	inc	r13
    f594:	88 e1       	ldi	r24, 0x18	; 24
    f596:	90 e0       	ldi	r25, 0x00	; 0
    f598:	e8 0e       	add	r14, r24
    f59a:	f9 1e       	adc	r15, r25
    f59c:	97 e0       	ldi	r25, 0x07	; 7
    f59e:	d9 16       	cp	r13, r25
    f5a0:	c9 f6       	brne	.-78     	; 0xf554 <StoreStandaloneTotalizerData+0x8e>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
			  //sprintf_P(strSend,PSTR("Nozzle:%d Volume:%s Money:%s"),iGrade,strGVolume,strGMoney);
			  //_uart_print(0,1,strSend);
		 }	
	}
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
    f5a2:	8d e0       	ldi	r24, 0x0D	; 13
    f5a4:	6c 2d       	mov	r22, r12
    f5a6:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
    f5aa:	8c 2d       	mov	r24, r12
    f5ac:	8f 70       	andi	r24, 0x0F	; 15
    f5ae:	64 e1       	ldi	r22, 0x14	; 20
    f5b0:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <UpdateStandaloneStatus>
}
    f5b4:	a1 96       	adiw	r28, 0x21	; 33
    f5b6:	0f b6       	in	r0, 0x3f	; 63
    f5b8:	f8 94       	cli
    f5ba:	de bf       	out	0x3e, r29	; 62
    f5bc:	0f be       	out	0x3f, r0	; 63
    f5be:	cd bf       	out	0x3d, r28	; 61
    f5c0:	cf 91       	pop	r28
    f5c2:	df 91       	pop	r29
    f5c4:	1f 91       	pop	r17
    f5c6:	0f 91       	pop	r16
    f5c8:	ff 90       	pop	r15
    f5ca:	ef 90       	pop	r14
    f5cc:	df 90       	pop	r13
    f5ce:	cf 90       	pop	r12
    f5d0:	bf 90       	pop	r11
    f5d2:	af 90       	pop	r10
    f5d4:	9f 90       	pop	r9
    f5d6:	8f 90       	pop	r8
    f5d8:	7f 90       	pop	r7
    f5da:	5f 90       	pop	r5
    f5dc:	4f 90       	pop	r4
    f5de:	3f 90       	pop	r3
    f5e0:	2f 90       	pop	r2
    f5e2:	08 95       	ret

0000f5e4 <ScanStandaloneFlow>:
	 _spi(SlaveMessage);
	 _spi(0x06);
	 systemSlave();
}

void ScanStandaloneFlow(char data){  //<STX>[PumpID][STA]<ETX> --> 0x07 0xF1 0xF2 0x08
    f5e4:	0f 93       	push	r16
    f5e6:	1f 93       	push	r17
    f5e8:	08 2f       	mov	r16, r24

      DataPumpID=0;
      DataPumpStatus=0;
	  MixData=0;
      //Shift data
      zDataFlow[4]=zDataFlow[3];
    f5ea:	80 91 b7 03 	lds	r24, 0x03B7
    f5ee:	80 93 b8 03 	sts	0x03B8, r24
	  zDataFlow[3]=zDataFlow[2];
    f5f2:	80 91 b6 03 	lds	r24, 0x03B6
    f5f6:	80 93 b7 03 	sts	0x03B7, r24
	  zDataFlow[2]=zDataFlow[1];
    f5fa:	80 91 b5 03 	lds	r24, 0x03B5
    f5fe:	80 93 b6 03 	sts	0x03B6, r24
      zDataFlow[1]=zDataFlow[0];
    f602:	90 91 b4 03 	lds	r25, 0x03B4
    f606:	90 93 b5 03 	sts	0x03B5, r25
      zDataFlow[0]=data;
    f60a:	00 93 b4 03 	sts	0x03B4, r16

      //Scan UpdatedPumpStatus Flow
	  //<STX>[ID][STA]<ETX>: 0x07[ID STA]0x08
	  if((zDataFlow[2]==0x07)&&(zDataFlow[0]==0x08)){
    f60e:	87 30       	cpi	r24, 0x07	; 7
    f610:	79 f4       	brne	.+30     	; 0xf630 <ScanStandaloneFlow+0x4c>
    f612:	08 30       	cpi	r16, 0x08	; 8
    f614:	69 f4       	brne	.+26     	; 0xf630 <ScanStandaloneFlow+0x4c>
          MixData=zDataFlow[1];
	      DataPumpID=((MixData&0xF0)>>4);
		  DataPumpStatus=(MixData&0x0F);
    f616:	19 2f       	mov	r17, r25
    f618:	1f 70       	andi	r17, 0x0F	; 15
		  UpdateStandaloneStatus(DataPumpID,DataPumpStatus);
    f61a:	89 2f       	mov	r24, r25
    f61c:	82 95       	swap	r24
    f61e:	8f 70       	andi	r24, 0x0F	; 15
    f620:	61 2f       	mov	r22, r17
    f622:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <UpdateStandaloneStatus>
		  if (DataPumpStatus!=PUMP_NONE)IsStandAloneDetected=True;
    f626:	1e 30       	cpi	r17, 0x0E	; 14
    f628:	19 f0       	breq	.+6      	; 0xf630 <ScanStandaloneFlow+0x4c>
    f62a:	81 e0       	ldi	r24, 0x01	; 1
    f62c:	80 93 b3 01 	sts	0x01B3, r24
		  //sprintf_P(strSend,PSTR("PS:%d Id:%d"),MixData,DataPumpID);
		  //_uart_print(0,1,strSend);
	  }

	  //Scan Transaction Completion FEOT
	  if (IsStandaloneTrans==True){
    f630:	80 91 b4 01 	lds	r24, 0x01B4
    f634:	81 30       	cpi	r24, 0x01	; 1
    f636:	69 f4       	brne	.+26     	; 0xf652 <ScanStandaloneFlow+0x6e>
	      strStandReceived[iFlow]=data;
    f638:	80 91 b2 03 	lds	r24, 0x03B2
    f63c:	90 91 b3 03 	lds	r25, 0x03B3
    f640:	fc 01       	movw	r30, r24
    f642:	ea 51       	subi	r30, 0x1A	; 26
    f644:	fb 4f       	sbci	r31, 0xFB	; 251
    f646:	00 83       	st	Z, r16
		  iFlow++;
    f648:	01 96       	adiw	r24, 0x01	; 1
    f64a:	90 93 b3 03 	sts	0x03B3, r25
    f64e:	80 93 b2 03 	sts	0x03B2, r24
	  }
	  if((zDataFlow[1]==0x05)&&(zDataFlow[0]==0x50)){
    f652:	80 91 b5 03 	lds	r24, 0x03B5
    f656:	85 30       	cpi	r24, 0x05	; 5
    f658:	61 f4       	brne	.+24     	; 0xf672 <ScanStandaloneFlow+0x8e>
    f65a:	80 91 b4 03 	lds	r24, 0x03B4
    f65e:	80 35       	cpi	r24, 0x50	; 80
    f660:	41 f5       	brne	.+80     	; 0xf6b2 <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=True;
    f662:	81 e0       	ldi	r24, 0x01	; 1
    f664:	80 93 b4 01 	sts	0x01B4, r24
		  iFlow=0;
    f668:	10 92 b3 03 	sts	0x03B3, r1
    f66c:	10 92 b2 03 	sts	0x03B2, r1
    f670:	20 c0       	rjmp	.+64     	; 0xf6b2 <ScanStandaloneFlow+0xce>
	  }
	  if((zDataFlow[1]==0x06)&&(zDataFlow[0]==0x60)){
    f672:	86 30       	cpi	r24, 0x06	; 6
    f674:	f1 f4       	brne	.+60     	; 0xf6b2 <ScanStandaloneFlow+0xce>
    f676:	80 91 b4 03 	lds	r24, 0x03B4
    f67a:	80 36       	cpi	r24, 0x60	; 96
    f67c:	d1 f4       	brne	.+52     	; 0xf6b2 <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=False;
    f67e:	10 92 b4 01 	sts	0x01B4, r1
	      strStandReceived[iFlow]=0;
    f682:	e0 91 b2 03 	lds	r30, 0x03B2
    f686:	f0 91 b3 03 	lds	r31, 0x03B3
    f68a:	ea 51       	subi	r30, 0x1A	; 26
    f68c:	fb 4f       	sbci	r31, 0xFB	; 251
    f68e:	10 82       	st	Z, r1

		  //_uart_print(1,1,strStandReceived);

		  MsgIDx=GetMessageID(strStandReceived);
    f690:	86 ee       	ldi	r24, 0xE6	; 230
    f692:	94 e0       	ldi	r25, 0x04	; 4
    f694:	0e 94 d9 40 	call	0x81b2	; 0x81b2 <GetMessageID>
          if (MsgIDx==0x01)StoreStandaloneTransData(strStandReceived);
    f698:	81 30       	cpi	r24, 0x01	; 1
    f69a:	29 f4       	brne	.+10     	; 0xf6a6 <ScanStandaloneFlow+0xc2>
    f69c:	86 ee       	ldi	r24, 0xE6	; 230
    f69e:	94 e0       	ldi	r25, 0x04	; 4
    f6a0:	0e 94 fc 77 	call	0xeff8	; 0xeff8 <StoreStandaloneTransData>
    f6a4:	06 c0       	rjmp	.+12     	; 0xf6b2 <ScanStandaloneFlow+0xce>
		  else
          if (MsgIDx==0x02)StoreStandaloneTotalizerData(strStandReceived);
    f6a6:	82 30       	cpi	r24, 0x02	; 2
    f6a8:	21 f4       	brne	.+8      	; 0xf6b2 <ScanStandaloneFlow+0xce>
    f6aa:	86 ee       	ldi	r24, 0xE6	; 230
    f6ac:	94 e0       	ldi	r25, 0x04	; 4
    f6ae:	0e 94 63 7a 	call	0xf4c6	; 0xf4c6 <StoreStandaloneTotalizerData>
	  }
	  //AcknoledgeCommand
	  if ((zDataFlow[3]==0x09)&&(zDataFlow[0]==0x0A)){
    f6b2:	80 91 b7 03 	lds	r24, 0x03B7
    f6b6:	89 30       	cpi	r24, 0x09	; 9
    f6b8:	c1 f5       	brne	.+112    	; 0xf72a <ScanStandaloneFlow+0x146>
    f6ba:	80 91 b4 03 	lds	r24, 0x03B4
    f6be:	8a 30       	cpi	r24, 0x0A	; 10
    f6c0:	a1 f5       	brne	.+104    	; 0xf72a <ScanStandaloneFlow+0x146>
	      
	      AcknoledgePump=zDataFlow[1];
    f6c2:	90 91 b5 03 	lds	r25, 0x03B5
    f6c6:	90 93 17 0e 	sts	0x0E17, r25
	      AcknoledgeCommand=zDataFlow[2];	  
    f6ca:	80 91 b6 03 	lds	r24, 0x03B6
    f6ce:	80 93 d0 07 	sts	0x07D0, r24
		  switch(AcknoledgeCommand){
    f6d2:	89 31       	cpi	r24, 0x19	; 25
    f6d4:	51 f0       	breq	.+20     	; 0xf6ea <ScanStandaloneFlow+0x106>
    f6d6:	8a 31       	cpi	r24, 0x1A	; 26
    f6d8:	18 f4       	brcc	.+6      	; 0xf6e0 <ScanStandaloneFlow+0xfc>
    f6da:	85 30       	cpi	r24, 0x05	; 5
    f6dc:	19 f5       	brne	.+70     	; 0xf724 <ScanStandaloneFlow+0x140>
    f6de:	17 c0       	rjmp	.+46     	; 0xf70e <ScanStandaloneFlow+0x12a>
    f6e0:	8a 31       	cpi	r24, 0x1A	; 26
    f6e2:	c9 f0       	breq	.+50     	; 0xf716 <ScanStandaloneFlow+0x132>
    f6e4:	8c 31       	cpi	r24, 0x1C	; 28
    f6e6:	f1 f4       	brne	.+60     	; 0xf724 <ScanStandaloneFlow+0x140>
    f6e8:	1a c0       	rjmp	.+52     	; 0xf71e <ScanStandaloneFlow+0x13a>
		  case SC_LIVE_SEQUENCE:
		       iSequencePooling=AcknoledgePump;
    f6ea:	90 93 93 01 	sts	0x0193, r25
			   IsNewPoolingSequence=True;
    f6ee:	81 e0       	ldi	r24, 0x01	; 1
    f6f0:	80 93 94 01 	sts	0x0194, r24
			   //SendPoolingCommand()
			   if (IsControlPooling==True){
    f6f4:	80 91 97 01 	lds	r24, 0x0197
    f6f8:	81 30       	cpi	r24, 0x01	; 1
    f6fa:	a1 f4       	brne	.+40     	; 0xf724 <ScanStandaloneFlow+0x140>
			       IsControlPooling=False;
    f6fc:	10 92 97 01 	sts	0x0197, r1
				   SendSlaveCommand(PoolCmd,PoolMsg);
    f700:	80 91 da 07 	lds	r24, 0x07DA
    f704:	60 91 fe 0d 	lds	r22, 0x0DFE
    f708:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
    f70c:	0b c0       	rjmp	.+22     	; 0xf724 <ScanStandaloneFlow+0x140>
                }
		       break;
          case SC_TOTALIZER:
		       IsTotalizerReceived=True;
    f70e:	81 e0       	ldi	r24, 0x01	; 1
    f710:	80 93 c5 01 	sts	0x01C5, r24
    f714:	07 c0       	rjmp	.+14     	; 0xf724 <ScanStandaloneFlow+0x140>
		       break;
		  case SC_POOL_RESTARTED:
		       IsPoolingRestarted=True;
    f716:	81 e0       	ldi	r24, 0x01	; 1
    f718:	80 93 96 01 	sts	0x0196, r24
    f71c:	03 c0       	rjmp	.+6      	; 0xf724 <ScanStandaloneFlow+0x140>
		       break;
          case SC_SET_PUMP_TYPE:
		       IsSetPumpType=True;
    f71e:	81 e0       	ldi	r24, 0x01	; 1
    f720:	80 93 23 01 	sts	0x0123, r24
		       break;
		  }
       IsStandaloneAcknoledge=True;
    f724:	81 e0       	ldi	r24, 0x01	; 1
    f726:	80 93 95 01 	sts	0x0195, r24
	  }
}
    f72a:	1f 91       	pop	r17
    f72c:	0f 91       	pop	r16
    f72e:	08 95       	ret

0000f730 <__vector_17>:
//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  _uart_print(1,0,SerialSend);
	 }
}

ISR(SPI_STC_vect){
    f730:	1f 92       	push	r1
    f732:	0f 92       	push	r0
    f734:	0f b6       	in	r0, 0x3f	; 63
    f736:	0f 92       	push	r0
    f738:	0b b6       	in	r0, 0x3b	; 59
    f73a:	0f 92       	push	r0
    f73c:	11 24       	eor	r1, r1
    f73e:	1f 93       	push	r17
    f740:	2f 93       	push	r18
    f742:	3f 93       	push	r19
    f744:	4f 93       	push	r20
    f746:	5f 93       	push	r21
    f748:	6f 93       	push	r22
    f74a:	7f 93       	push	r23
    f74c:	8f 93       	push	r24
    f74e:	9f 93       	push	r25
    f750:	af 93       	push	r26
    f752:	bf 93       	push	r27
    f754:	ef 93       	push	r30
    f756:	ff 93       	push	r31
char dataSPI;
//char Reply=0;
    //_uart(0,1,SPDR);
	dataSPI=SPDR;
    f758:	1f b1       	in	r17, 0x0f	; 15
	ScanRFIDFlow(dataSPI);
    f75a:	81 2f       	mov	r24, r17
    f75c:	0e 94 71 14 	call	0x28e2	; 0x28e2 <ScanRFIDFlow>
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
    f760:	80 91 10 01 	lds	r24, 0x0110
    f764:	81 30       	cpi	r24, 0x01	; 1
    f766:	21 f4       	brne	.+8      	; 0xf770 <__vector_17+0x40>
    f768:	81 2f       	mov	r24, r17
    f76a:	0e 94 af 13 	call	0x275e	; 0x275e <ScanEDCFlow>
    f76e:	05 c0       	rjmp	.+10     	; 0xf77a <__vector_17+0x4a>
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
    f770:	82 30       	cpi	r24, 0x02	; 2
    f772:	19 f4       	brne	.+6      	; 0xf77a <__vector_17+0x4a>
    f774:	81 2f       	mov	r24, r17
    f776:	0e 94 f2 7a 	call	0xf5e4	; 0xf5e4 <ScanStandaloneFlow>
}
    f77a:	ff 91       	pop	r31
    f77c:	ef 91       	pop	r30
    f77e:	bf 91       	pop	r27
    f780:	af 91       	pop	r26
    f782:	9f 91       	pop	r25
    f784:	8f 91       	pop	r24
    f786:	7f 91       	pop	r23
    f788:	6f 91       	pop	r22
    f78a:	5f 91       	pop	r21
    f78c:	4f 91       	pop	r20
    f78e:	3f 91       	pop	r19
    f790:	2f 91       	pop	r18
    f792:	1f 91       	pop	r17
    f794:	0f 90       	pop	r0
    f796:	0b be       	out	0x3b, r0	; 59
    f798:	0f 90       	pop	r0
    f79a:	0f be       	out	0x3f, r0	; 63
    f79c:	0f 90       	pop	r0
    f79e:	1f 90       	pop	r1
    f7a0:	18 95       	reti

0000f7a2 <UserInput>:
void ShowMessage(char *Message){//Display Message on Line3
     char i;
}


char UserInput(char TypeUI,char xPos, char yPos,char *strResult, unsigned int MaxValue, char MaxLength){
    f7a2:	8f 92       	push	r8
    f7a4:	9f 92       	push	r9
    f7a6:	af 92       	push	r10
    f7a8:	bf 92       	push	r11
    f7aa:	cf 92       	push	r12
    f7ac:	df 92       	push	r13
    f7ae:	ef 92       	push	r14
    f7b0:	ff 92       	push	r15
    f7b2:	0f 93       	push	r16
    f7b4:	1f 93       	push	r17
    f7b6:	cf 93       	push	r28
    f7b8:	df 93       	push	r29
    f7ba:	f8 2e       	mov	r15, r24
    f7bc:	96 2e       	mov	r9, r22
    f7be:	d4 2e       	mov	r13, r20
    f7c0:	e9 01       	movw	r28, r18
    f7c2:	58 01       	movw	r10, r16
    f7c4:	8e 2c       	mov	r8, r14
	 static char iHit=0,IsShifted=False,IsSameKey=False,IsNextKey=False,IsNewKey=False,IsFirst=False;//,KeyByte=0;
	 static unsigned int iLoop=0,KeyTimeout;//,TimerPressed=0,NewKeyTimeout;
	        unsigned int NumbValue=0;
	 char KeyPressed=0,KeyChar=0,iDisp=0;
     Result=USER_NONE;
	 switch(stUserInput){// 100 ->199 500 90
    f7c6:	10 91 6b 03 	lds	r17, 0x036B
    f7ca:	12 30       	cpi	r17, 0x02	; 2
    f7cc:	09 f4       	brne	.+2      	; 0xf7d0 <UserInput+0x2e>
    f7ce:	2c c2       	rjmp	.+1112   	; 0xfc28 <UserInput+0x486>
    f7d0:	13 30       	cpi	r17, 0x03	; 3
    f7d2:	30 f4       	brcc	.+12     	; 0xf7e0 <UserInput+0x3e>
    f7d4:	11 23       	and	r17, r17
    f7d6:	59 f0       	breq	.+22     	; 0xf7ee <UserInput+0x4c>
    f7d8:	11 30       	cpi	r17, 0x01	; 1
    f7da:	09 f0       	breq	.+2      	; 0xf7de <UserInput+0x3c>
    f7dc:	f5 c2       	rjmp	.+1514   	; 0xfdc8 <UserInput+0x626>
    f7de:	2c c0       	rjmp	.+88     	; 0xf838 <UserInput+0x96>
    f7e0:	13 30       	cpi	r17, 0x03	; 3
    f7e2:	09 f4       	brne	.+2      	; 0xf7e6 <UserInput+0x44>
    f7e4:	76 c2       	rjmp	.+1260   	; 0xfcd2 <UserInput+0x530>
    f7e6:	14 30       	cpi	r17, 0x04	; 4
    f7e8:	09 f0       	breq	.+2      	; 0xf7ec <UserInput+0x4a>
    f7ea:	ee c2       	rjmp	.+1500   	; 0xfdc8 <UserInput+0x626>
    f7ec:	ef c2       	rjmp	.+1502   	; 0xfdcc <UserInput+0x62a>
	 case uiInit:
	      iLoop=0;
    f7ee:	10 92 5d 03 	sts	0x035D, r1
    f7f2:	10 92 5c 03 	sts	0x035C, r1
		  stUserInput=uiInput;
		  xChar=xPos;yChar=yPos;
    f7f6:	60 93 6a 03 	sts	0x036A, r22
    f7fa:	40 93 69 03 	sts	0x0369, r20
          iValuePos=0;
    f7fe:	10 92 68 03 	sts	0x0368, r1
		  KeyTimeout=0;
    f802:	10 92 5b 03 	sts	0x035B, r1
    f806:	10 92 5a 03 	sts	0x035A, r1
		  IsSameKey=False;
    f80a:	10 92 61 03 	sts	0x0361, r1
		  IsNextKey=False;
    f80e:	10 92 60 03 	sts	0x0360, r1
		  IsNewKey=False;
    f812:	10 92 5f 03 	sts	0x035F, r1
		  IsShifted=True;
    f816:	91 e0       	ldi	r25, 0x01	; 1
    f818:	90 93 62 03 	sts	0x0362, r25
		  zKeyChar=' ';
    f81c:	80 e2       	ldi	r24, 0x20	; 32
    f81e:	80 93 67 03 	sts	0x0367, r24
		  iHit=0;
    f822:	10 92 63 03 	sts	0x0363, r1
		  IsFirst=False;
    f826:	10 92 5e 03 	sts	0x035E, r1
		  IsDelete=False;
    f82a:	10 92 64 03 	sts	0x0364, r1
		  Result=USER_NO_DATA;
		  stUserInput=uiInput;
    f82e:	90 93 6b 03 	sts	0x036B, r25
    f832:	35 e0       	ldi	r19, 0x05	; 5
    f834:	e3 2e       	mov	r14, r19
    f836:	ce c2       	rjmp	.+1436   	; 0xfdd4 <UserInput+0x632>
	      break;
	 case uiInput:
	      KeyPressed=_key_scan(1);                  //  _  ABC DEF GHI JKL MNO PQRS TUV WXYZ
    f838:	81 e0       	ldi	r24, 0x01	; 1
    f83a:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
    f83e:	c8 2e       	mov	r12, r24
		  KeyChar= _key_btn(KeyPressed);            //  1   2   3   4   5   6   7    8   9
    f840:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
    f844:	e8 2e       	mov	r14, r24
		  if (KeyPressed==_KEY_SHIFT){
    f846:	2b e7       	ldi	r18, 0x7B	; 123
    f848:	c2 16       	cp	r12, r18
    f84a:	59 f4       	brne	.+22     	; 0xf862 <UserInput+0xc0>
		      if (IsShifted==False)IsShifted=True;
    f84c:	80 91 62 03 	lds	r24, 0x0362
    f850:	88 23       	and	r24, r24
    f852:	19 f4       	brne	.+6      	; 0xf85a <UserInput+0xb8>
    f854:	10 93 62 03 	sts	0x0362, r17
    f858:	04 c0       	rjmp	.+8      	; 0xf862 <UserInput+0xc0>
			  else
		      if (IsShifted==True)IsShifted=False;
    f85a:	81 30       	cpi	r24, 0x01	; 1
    f85c:	11 f4       	brne	.+4      	; 0xf862 <UserInput+0xc0>
    f85e:	10 92 62 03 	sts	0x0362, r1
			  }
          
		  if (IsSameKey==True){
    f862:	80 91 61 03 	lds	r24, 0x0361
    f866:	81 30       	cpi	r24, 0x01	; 1
    f868:	e9 f4       	brne	.+58     	; 0xf8a4 <UserInput+0x102>
		      KeyTimeout++;
    f86a:	80 91 5a 03 	lds	r24, 0x035A
    f86e:	90 91 5b 03 	lds	r25, 0x035B
    f872:	01 96       	adiw	r24, 0x01	; 1
    f874:	90 93 5b 03 	sts	0x035B, r25
    f878:	80 93 5a 03 	sts	0x035A, r24
              if (KeyTimeout>1000){
    f87c:	89 5e       	subi	r24, 0xE9	; 233
    f87e:	93 40       	sbci	r25, 0x03	; 3
    f880:	88 f0       	brcs	.+34     	; 0xf8a4 <UserInput+0x102>
			      if (TypeUI==UI_ALPHANUM_PASSWORD)lcd_put(xChar,yChar,'*');
    f882:	f5 e0       	ldi	r31, 0x05	; 5
    f884:	ff 16       	cp	r15, r31
    f886:	39 f4       	brne	.+14     	; 0xf896 <UserInput+0xf4>
    f888:	80 91 6a 03 	lds	r24, 0x036A
    f88c:	60 91 69 03 	lds	r22, 0x0369
    f890:	4a e2       	ldi	r20, 0x2A	; 42
    f892:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>

		          IsNextKey=True;
    f896:	81 e0       	ldi	r24, 0x01	; 1
    f898:	80 93 60 03 	sts	0x0360, r24
				  iLoop=0;
    f89c:	10 92 5d 03 	sts	0x035D, r1
    f8a0:	10 92 5c 03 	sts	0x035C, r1
			     }
              }
 
 		  //if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<=MaxLength))||(IsNextKey==True)){
		  if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<MaxLength))||(IsNextKey==True)){
    f8a4:	8e 2d       	mov	r24, r14
    f8a6:	80 53       	subi	r24, 0x30	; 48
    f8a8:	8a 30       	cpi	r24, 0x0A	; 10
    f8aa:	20 f4       	brcc	.+8      	; 0xf8b4 <UserInput+0x112>
    f8ac:	80 91 68 03 	lds	r24, 0x0368
    f8b0:	88 15       	cp	r24, r8
    f8b2:	40 f0       	brcs	.+16     	; 0xf8c4 <UserInput+0x122>
    f8b4:	80 91 60 03 	lds	r24, 0x0360
    f8b8:	81 30       	cpi	r24, 0x01	; 1
    f8ba:	21 f0       	breq	.+8      	; 0xf8c4 <UserInput+0x122>
    f8bc:	ee 24       	eor	r14, r14
    f8be:	00 e0       	ldi	r16, 0x00	; 0
    f8c0:	10 e0       	ldi	r17, 0x00	; 0
    f8c2:	be c0       	rjmp	.+380    	; 0xfa40 <UserInput+0x29e>
    f8c4:	84 e2       	ldi	r24, 0x24	; 36
    f8c6:	94 ef       	ldi	r25, 0xF4	; 244
    f8c8:	01 97       	sbiw	r24, 0x01	; 1
    f8ca:	f1 f7       	brne	.-4      	; 0xf8c8 <UserInput+0x126>
		       _delay_ms(250);
		       strResult[iValuePos]=KeyChar;
    f8cc:	80 91 68 03 	lds	r24, 0x0368
    f8d0:	fe 01       	movw	r30, r28
    f8d2:	e8 0f       	add	r30, r24
    f8d4:	f1 1d       	adc	r31, r1
    f8d6:	e0 82       	st	Z, r14
		       strResult[iValuePos+1]=0;
    f8d8:	11 82       	std	Z+1, r1	; 0x01

			   if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)) 
    f8da:	8f 2d       	mov	r24, r15
    f8dc:	81 50       	subi	r24, 0x01	; 1
    f8de:	82 30       	cpi	r24, 0x02	; 2
    f8e0:	30 f0       	brcs	.+12     	; 0xf8ee <UserInput+0x14c>
    f8e2:	24 e0       	ldi	r18, 0x04	; 4
    f8e4:	f2 16       	cp	r15, r18
    f8e6:	19 f0       	breq	.+6      	; 0xf8ee <UserInput+0x14c>
    f8e8:	00 e0       	ldi	r16, 0x00	; 0
    f8ea:	10 e0       	ldi	r17, 0x00	; 0
    f8ec:	04 c0       	rjmp	.+8      	; 0xf8f6 <UserInput+0x154>
			        NumbValue=atoi(strResult);
    f8ee:	ce 01       	movw	r24, r28
    f8f0:	0e 94 bf b3 	call	0x1677e	; 0x1677e <atoi>
    f8f4:	8c 01       	movw	r16, r24
			   else NumbValue=0;
				
			   if ((TypeUI==UI_ALPHANUM_R)||(TypeUI==UI_ALPHANUM_PASSWORD)){
    f8f6:	83 e0       	ldi	r24, 0x03	; 3
    f8f8:	f8 16       	cp	r15, r24
    f8fa:	21 f0       	breq	.+8      	; 0xf904 <UserInput+0x162>
    f8fc:	e5 e0       	ldi	r30, 0x05	; 5
    f8fe:	fe 16       	cp	r15, r30
    f900:	09 f0       	breq	.+2      	; 0xf904 <UserInput+0x162>
    f902:	63 c0       	rjmp	.+198    	; 0xf9ca <UserInput+0x228>
			       if (KeyChar!=zKeyChar){
    f904:	80 91 67 03 	lds	r24, 0x0367
    f908:	e8 16       	cp	r14, r24
    f90a:	71 f0       	breq	.+28     	; 0xf928 <UserInput+0x186>
					   IsSameKey=False;
    f90c:	10 92 61 03 	sts	0x0361, r1
					   IsNewKey=True;
    f910:	81 e0       	ldi	r24, 0x01	; 1
    f912:	80 93 5f 03 	sts	0x035F, r24
				       iHit=0;
    f916:	10 92 63 03 	sts	0x0363, r1
					   iLoop=1000;
    f91a:	88 ee       	ldi	r24, 0xE8	; 232
    f91c:	93 e0       	ldi	r25, 0x03	; 3
    f91e:	90 93 5d 03 	sts	0x035D, r25
    f922:	80 93 5c 03 	sts	0x035C, r24
    f926:	51 c0       	rjmp	.+162    	; 0xf9ca <UserInput+0x228>
				   }
                   else{
				   if (IsNewKey==True){
    f928:	80 91 5f 03 	lds	r24, 0x035F
    f92c:	81 30       	cpi	r24, 0x01	; 1
    f92e:	71 f4       	brne	.+28     	; 0xf94c <UserInput+0x1aa>
					   IsNewKey=False;
    f930:	10 92 5f 03 	sts	0x035F, r1
					   yChar--;
    f934:	80 91 69 03 	lds	r24, 0x0369
    f938:	81 50       	subi	r24, 0x01	; 1
    f93a:	80 93 69 03 	sts	0x0369, r24
					   if (iValuePos>0) iValuePos--;
    f93e:	80 91 68 03 	lds	r24, 0x0368
    f942:	88 23       	and	r24, r24
    f944:	19 f0       	breq	.+6      	; 0xf94c <UserInput+0x1aa>
    f946:	81 50       	subi	r24, 0x01	; 1
    f948:	80 93 68 03 	sts	0x0368, r24
					   }
				   KeyTimeout=0;
    f94c:	10 92 5b 03 	sts	0x035B, r1
    f950:	10 92 5a 03 	sts	0x035A, r1
				   IsSameKey=True;
    f954:	81 e0       	ldi	r24, 0x01	; 1
    f956:	80 93 61 03 	sts	0x0361, r24
				   if (iHit<pgm_read_byte(&MaxKeyHit[(zKeyChar-'0')])) iHit++;
    f95a:	80 91 63 03 	lds	r24, 0x0363
    f95e:	e0 91 67 03 	lds	r30, 0x0367
    f962:	f0 e0       	ldi	r31, 0x00	; 0
    f964:	e2 53       	subi	r30, 0x32	; 50
    f966:	fd 4f       	sbci	r31, 0xFD	; 253
    f968:	e4 91       	lpm	r30, Z+
    f96a:	8e 17       	cp	r24, r30
    f96c:	20 f4       	brcc	.+8      	; 0xf976 <UserInput+0x1d4>
    f96e:	8f 5f       	subi	r24, 0xFF	; 255
    f970:	80 93 63 03 	sts	0x0363, r24
    f974:	02 c0       	rjmp	.+4      	; 0xf97a <UserInput+0x1d8>
                   else iHit=0;
    f976:	10 92 63 03 	sts	0x0363, r1
				   iLoop=1000;
    f97a:	88 ee       	ldi	r24, 0xE8	; 232
    f97c:	93 e0       	ldi	r25, 0x03	; 3
    f97e:	90 93 5d 03 	sts	0x035D, r25
    f982:	80 93 5c 03 	sts	0x035C, r24

                   zAlphaChar=AlphaChar;
    f986:	80 91 65 03 	lds	r24, 0x0365
    f98a:	80 93 66 03 	sts	0x0366, r24
			       AlphaChar=_table_alphanum(IsShifted,KeyPressed,iHit);			   
    f98e:	80 91 62 03 	lds	r24, 0x0362
    f992:	6c 2d       	mov	r22, r12
    f994:	40 91 63 03 	lds	r20, 0x0363
    f998:	0e 94 33 ae 	call	0x15c66	; 0x15c66 <_table_alphanum>
    f99c:	80 93 65 03 	sts	0x0365, r24
                   
				   if (IsNextKey==True){
    f9a0:	80 91 60 03 	lds	r24, 0x0360
    f9a4:	81 30       	cpi	r24, 0x01	; 1
    f9a6:	41 f4       	brne	.+16     	; 0xf9b8 <UserInput+0x216>
                       AlphaChar=zAlphaChar;       
    f9a8:	80 91 66 03 	lds	r24, 0x0366
    f9ac:	80 93 65 03 	sts	0x0365, r24
					   IsNextKey=False;
    f9b0:	10 92 60 03 	sts	0x0360, r1
					   IsSameKey=False;
    f9b4:	10 92 61 03 	sts	0x0361, r1
				   }   
				   strResult[iValuePos]=AlphaChar;
    f9b8:	80 91 68 03 	lds	r24, 0x0368
    f9bc:	fe 01       	movw	r30, r28
    f9be:	e8 0f       	add	r30, r24
    f9c0:	f1 1d       	adc	r31, r1
    f9c2:	80 91 65 03 	lds	r24, 0x0365
    f9c6:	80 83       	st	Z, r24
		           strResult[iValuePos+1]=0;
    f9c8:	11 82       	std	Z+1, r1	; 0x01
				 }//endElse 
				 
			   }//EndAlphaNum

			 if (TypeUI==UI_NUMBER_L){
    f9ca:	f2 e0       	ldi	r31, 0x02	; 2
    f9cc:	ff 16       	cp	r15, r31
    f9ce:	71 f4       	brne	.+28     	; 0xf9ec <UserInput+0x24a>
			    if ((NumbValue<=MaxValue)||(MaxValue==0)){
    f9d0:	a0 16       	cp	r10, r16
    f9d2:	b1 06       	cpc	r11, r17
    f9d4:	18 f4       	brcc	.+6      	; 0xf9dc <UserInput+0x23a>
    f9d6:	a1 14       	cp	r10, r1
    f9d8:	b1 04       	cpc	r11, r1
    f9da:	71 f5       	brne	.+92     	; 0xfa38 <UserInput+0x296>
				     iValuePos++;
    f9dc:	80 91 68 03 	lds	r24, 0x0368
    f9e0:	8f 5f       	subi	r24, 0xFF	; 255
    f9e2:	80 93 68 03 	sts	0x0368, r24
					 stUserInput=uiInputDisp;
    f9e6:	83 e0       	ldi	r24, 0x03	; 3
    f9e8:	80 93 6b 03 	sts	0x036B, r24
				} 
			 }
  
			   if ((NumbValue<=MaxValue)||(MaxValue==0)){
    f9ec:	a0 16       	cp	r10, r16
    f9ee:	b1 06       	cpc	r11, r17
    f9f0:	18 f4       	brcc	.+6      	; 0xf9f8 <UserInput+0x256>
    f9f2:	a1 14       	cp	r10, r1
    f9f4:	b1 04       	cpc	r11, r1
    f9f6:	01 f5       	brne	.+64     	; 0xfa38 <UserInput+0x296>
			       if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    f9f8:	21 e0       	ldi	r18, 0x01	; 1
    f9fa:	f2 16       	cp	r15, r18
    f9fc:	49 f0       	breq	.+18     	; 0xfa10 <UserInput+0x26e>
    f9fe:	83 e0       	ldi	r24, 0x03	; 3
    fa00:	f8 16       	cp	r15, r24
    fa02:	31 f0       	breq	.+12     	; 0xfa10 <UserInput+0x26e>
    fa04:	e4 e0       	ldi	r30, 0x04	; 4
    fa06:	fe 16       	cp	r15, r30
    fa08:	19 f0       	breq	.+6      	; 0xfa10 <UserInput+0x26e>
    fa0a:	f5 e0       	ldi	r31, 0x05	; 5
    fa0c:	ff 16       	cp	r15, r31
    fa0e:	a1 f4       	brne	.+40     	; 0xfa38 <UserInput+0x296>
				       (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
				      if (IsSameKey==False){
    fa10:	80 91 61 03 	lds	r24, 0x0361
    fa14:	88 23       	and	r24, r24
    fa16:	69 f4       	brne	.+26     	; 0xfa32 <UserInput+0x290>
					      IsFirst=True;
    fa18:	81 e0       	ldi	r24, 0x01	; 1
    fa1a:	80 93 5e 03 	sts	0x035E, r24
					      iValuePos++;
    fa1e:	80 91 68 03 	lds	r24, 0x0368
    fa22:	8f 5f       	subi	r24, 0xFF	; 255
    fa24:	80 93 68 03 	sts	0x0368, r24
						  //FullEntry
						  if (iValuePos==MaxLength)Result=USER_FULL_ENTRY;
					      yChar++;
    fa28:	80 91 69 03 	lds	r24, 0x0369
    fa2c:	8f 5f       	subi	r24, 0xFF	; 255
    fa2e:	80 93 69 03 	sts	0x0369, r24
						  //yChar=(yChar+1;//Max Display

						  }
                  stUserInput=uiInputDisp;
    fa32:	83 e0       	ldi	r24, 0x03	; 3
    fa34:	80 93 6b 03 	sts	0x036B, r24
				  }
			   }
              zKeyChar=KeyChar;
    fa38:	e0 92 67 03 	sts	0x0367, r14
    fa3c:	24 e0       	ldi	r18, 0x04	; 4
    fa3e:	e2 2e       	mov	r14, r18
             Result=USER_ENTRY;
             }//EndKeyChar
			 
                 
              if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)){
    fa40:	2f 2d       	mov	r18, r15
    fa42:	21 50       	subi	r18, 0x01	; 1
    fa44:	22 30       	cpi	r18, 0x02	; 2
    fa46:	18 f0       	brcs	.+6      	; 0xfa4e <UserInput+0x2ac>
    fa48:	84 e0       	ldi	r24, 0x04	; 4
    fa4a:	f8 16       	cp	r15, r24
    fa4c:	89 f4       	brne	.+34     	; 0xfa70 <UserInput+0x2ce>
                   if((NumbValue>MaxValue)||(iValuePos==MaxLength)){
    fa4e:	a0 16       	cp	r10, r16
    fa50:	b1 06       	cpc	r11, r17
    fa52:	20 f0       	brcs	.+8      	; 0xfa5c <UserInput+0x2ba>
    fa54:	80 91 68 03 	lds	r24, 0x0368
    fa58:	88 15       	cp	r24, r8
    fa5a:	51 f4       	brne	.+20     	; 0xfa70 <UserInput+0x2ce>
			           if (MaxValue>0)system_beep(1);
    fa5c:	ab 28       	or	r10, r11
    fa5e:	41 f0       	breq	.+16     	; 0xfa70 <UserInput+0x2ce>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    fa60:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    fa62:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    fa64:	81 e0       	ldi	r24, 0x01	; 1
    fa66:	90 e0       	ldi	r25, 0x00	; 0
    fa68:	90 93 d7 01 	sts	0x01D7, r25
    fa6c:	80 93 d6 01 	sts	0x01D6, r24
			           if (MaxValue>0)system_beep(1);
				   }
                 }
		  
		  //CANCEL OK
		  if (KeyPressed==_KEY_CANCEL){
    fa70:	e7 ee       	ldi	r30, 0xE7	; 231
    fa72:	ce 16       	cp	r12, r30
    fa74:	71 f4       	brne	.+28     	; 0xfa92 <UserInput+0x2f0>
		      if (iValuePos>0){
    fa76:	80 91 68 03 	lds	r24, 0x0368
    fa7a:	88 23       	and	r24, r24
    fa7c:	41 f0       	breq	.+16     	; 0xfa8e <UserInput+0x2ec>
			      iLoop=1999;
    fa7e:	8f ec       	ldi	r24, 0xCF	; 207
    fa80:	97 e0       	ldi	r25, 0x07	; 7
    fa82:	90 93 5d 03 	sts	0x035D, r25
    fa86:	80 93 5c 03 	sts	0x035C, r24
				  stUserInput=uiClearDisplay;
    fa8a:	82 e0       	ldi	r24, 0x02	; 2
    fa8c:	26 c0       	rjmp	.+76     	; 0xfada <UserInput+0x338>
				  }
			  else{
			      UserInputResult=USER_CANCEL;
    fa8e:	81 e0       	ldi	r24, 0x01	; 1
    fa90:	21 c0       	rjmp	.+66     	; 0xfad4 <UserInput+0x332>
			      stUserInput=uiFinished;
				  }
		  }
		  else {
		  if (KeyPressed==_KEY_ENTER){
    fa92:	f7 eb       	ldi	r31, 0xB7	; 183
    fa94:	cf 16       	cp	r12, r31
    fa96:	19 f5       	brne	.+70     	; 0xfade <UserInput+0x33c>
		      strResult[iValuePos]=0;
    fa98:	80 91 68 03 	lds	r24, 0x0368
    fa9c:	fe 01       	movw	r30, r28
    fa9e:	e8 0f       	add	r30, r24
    faa0:	f1 1d       	adc	r31, r1
    faa2:	10 82       	st	Z, r1
			  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)){
    faa4:	22 30       	cpi	r18, 0x02	; 2
    faa6:	a8 f4       	brcc	.+42     	; 0xfad2 <UserInput+0x330>
			       if (iValuePos==0)sprintf_P(strResult,PSTR("0"));
    faa8:	88 23       	and	r24, r24
    faaa:	81 f4       	brne	.+32     	; 0xfacc <UserInput+0x32a>
    faac:	00 d0       	rcall	.+0      	; 0xfaae <UserInput+0x30c>
    faae:	00 d0       	rcall	.+0      	; 0xfab0 <UserInput+0x30e>
    fab0:	ed b7       	in	r30, 0x3d	; 61
    fab2:	fe b7       	in	r31, 0x3e	; 62
    fab4:	d2 83       	std	Z+2, r29	; 0x02
    fab6:	c1 83       	std	Z+1, r28	; 0x01
    fab8:	8d e7       	ldi	r24, 0x7D	; 125
    faba:	9b e1       	ldi	r25, 0x1B	; 27
    fabc:	94 83       	std	Z+4, r25	; 0x04
    fabe:	83 83       	std	Z+3, r24	; 0x03
    fac0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    fac4:	0f 90       	pop	r0
    fac6:	0f 90       	pop	r0
    fac8:	0f 90       	pop	r0
    faca:	0f 90       	pop	r0
			       RemZeroLead(strResult);
    facc:	ce 01       	movw	r24, r28
    face:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
				  }
		      UserInputResult=USER_OK;
    fad2:	83 e0       	ldi	r24, 0x03	; 3
    fad4:	80 93 6c 03 	sts	0x036C, r24
		      stUserInput=uiFinished;
    fad8:	84 e0       	ldi	r24, 0x04	; 4
    fada:	80 93 6b 03 	sts	0x036B, r24
			  }
		  }//EndElse

		  if ((iLoop%2000)==0){
    fade:	80 91 5c 03 	lds	r24, 0x035C
    fae2:	90 91 5d 03 	lds	r25, 0x035D
    fae6:	60 ed       	ldi	r22, 0xD0	; 208
    fae8:	77 e0       	ldi	r23, 0x07	; 7
    faea:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
    faee:	89 2b       	or	r24, r25
    faf0:	09 f0       	breq	.+2      	; 0xfaf4 <UserInput+0x352>
    faf2:	4b c0       	rjmp	.+150    	; 0xfb8a <UserInput+0x3e8>
		      if (IsSameKey==True)
    faf4:	80 91 61 03 	lds	r24, 0x0361
    faf8:	81 30       	cpi	r24, 0x01	; 1
    fafa:	c9 f4       	brne	.+50     	; 0xfb2e <UserInput+0x38c>
			      //lcd_put(xChar,yChar,AlphaChar); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),AlphaChar); 
    fafc:	20 91 68 03 	lds	r18, 0x0368
    fb00:	82 2f       	mov	r24, r18
    fb02:	90 e0       	ldi	r25, 0x00	; 0
    fb04:	01 97       	sbiw	r24, 0x01	; 1
    fb06:	8d 0d       	add	r24, r13
    fb08:	91 1d       	adc	r25, r1
    fb0a:	64 e1       	ldi	r22, 0x14	; 20
    fb0c:	70 e0       	ldi	r23, 0x00	; 0
    fb0e:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    fb12:	36 2f       	mov	r19, r22
    fb14:	82 2f       	mov	r24, r18
    fb16:	64 e1       	ldi	r22, 0x14	; 20
    fb18:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    fb1c:	6d 2d       	mov	r22, r13
    fb1e:	69 0f       	add	r22, r25
    fb20:	89 2d       	mov	r24, r9
    fb22:	83 0f       	add	r24, r19
    fb24:	40 91 65 03 	lds	r20, 0x0365
    fb28:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
    fb2c:	2e c0       	rjmp	.+92     	; 0xfb8a <UserInput+0x3e8>
			  else {
			      if((TypeUI==UI_ALPHANUM_PASSWORD)&&(iValuePos>0))lcd_put(xChar,yChar-1,'*'); 
    fb2e:	f5 e0       	ldi	r31, 0x05	; 5
    fb30:	ff 16       	cp	r15, r31
    fb32:	61 f4       	brne	.+24     	; 0xfb4c <UserInput+0x3aa>
    fb34:	80 91 68 03 	lds	r24, 0x0368
    fb38:	88 23       	and	r24, r24
    fb3a:	41 f0       	breq	.+16     	; 0xfb4c <UserInput+0x3aa>
    fb3c:	60 91 69 03 	lds	r22, 0x0369
    fb40:	61 50       	subi	r22, 0x01	; 1
    fb42:	80 91 6a 03 	lds	r24, 0x036A
    fb46:	4a e2       	ldi	r20, 0x2A	; 42
    fb48:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
			      //lcd_put(xChar,yChar,'_'); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),'_'); 
    fb4c:	20 91 68 03 	lds	r18, 0x0368
    fb50:	82 2f       	mov	r24, r18
    fb52:	90 e0       	ldi	r25, 0x00	; 0
    fb54:	01 97       	sbiw	r24, 0x01	; 1
    fb56:	8d 0d       	add	r24, r13
    fb58:	91 1d       	adc	r25, r1
    fb5a:	64 e1       	ldi	r22, 0x14	; 20
    fb5c:	70 e0       	ldi	r23, 0x00	; 0
    fb5e:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    fb62:	36 2f       	mov	r19, r22
    fb64:	82 2f       	mov	r24, r18
    fb66:	64 e1       	ldi	r22, 0x14	; 20
    fb68:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    fb6c:	6d 2d       	mov	r22, r13
    fb6e:	69 0f       	add	r22, r25
    fb70:	89 2d       	mov	r24, r9
    fb72:	83 0f       	add	r24, r19
    fb74:	4f e5       	ldi	r20, 0x5F	; 95
    fb76:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>

				  if (IsFirst==True){
    fb7a:	80 91 5e 03 	lds	r24, 0x035E
    fb7e:	81 30       	cpi	r24, 0x01	; 1
    fb80:	21 f4       	brne	.+8      	; 0xfb8a <UserInput+0x3e8>
				      IsFirst=False;
    fb82:	10 92 5e 03 	sts	0x035E, r1
				      zKeyChar=0;
    fb86:	10 92 67 03 	sts	0x0367, r1
					  }
				  }
			  }
          if ((iLoop%2000)==1000){
    fb8a:	80 91 5c 03 	lds	r24, 0x035C
    fb8e:	90 91 5d 03 	lds	r25, 0x035D
    fb92:	60 ed       	ldi	r22, 0xD0	; 208
    fb94:	77 e0       	ldi	r23, 0x07	; 7
    fb96:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
    fb9a:	88 5e       	subi	r24, 0xE8	; 232
    fb9c:	93 40       	sbci	r25, 0x03	; 3
    fb9e:	d1 f5       	brne	.+116    	; 0xfc14 <UserInput+0x472>
		      if (IsSameKey==True){
    fba0:	80 91 61 03 	lds	r24, 0x0361
    fba4:	81 30       	cpi	r24, 0x01	; 1
    fba6:	f9 f4       	brne	.+62     	; 0xfbe6 <UserInput+0x444>
			      if (TypeUI!=UI_NUM_PASSWORD)
    fba8:	84 e0       	ldi	r24, 0x04	; 4
    fbaa:	f8 16       	cp	r15, r24
    fbac:	b1 f0       	breq	.+44     	; 0xfbda <UserInput+0x438>
				       //lcd_put(xChar,yChar,AlphaChar); 
					   lcd_put(xPos+((yPos+iValuePos-1)/20),yChar%21,AlphaChar); 
    fbae:	80 91 68 03 	lds	r24, 0x0368
    fbb2:	90 e0       	ldi	r25, 0x00	; 0
    fbb4:	01 97       	sbiw	r24, 0x01	; 1
    fbb6:	8d 0d       	add	r24, r13
    fbb8:	91 1d       	adc	r25, r1
    fbba:	64 e1       	ldi	r22, 0x14	; 20
    fbbc:	70 e0       	ldi	r23, 0x00	; 0
    fbbe:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    fbc2:	26 2f       	mov	r18, r22
    fbc4:	80 91 69 03 	lds	r24, 0x0369
    fbc8:	65 e1       	ldi	r22, 0x15	; 21
    fbca:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    fbce:	89 2d       	mov	r24, r9
    fbd0:	82 0f       	add	r24, r18
    fbd2:	69 2f       	mov	r22, r25
    fbd4:	40 91 65 03 	lds	r20, 0x0365
    fbd8:	1b c0       	rjmp	.+54     	; 0xfc10 <UserInput+0x46e>
					   
				  else lcd_put(xChar,yChar,'*'); 
    fbda:	80 91 6a 03 	lds	r24, 0x036A
    fbde:	60 91 69 03 	lds	r22, 0x0369
    fbe2:	4a e2       	ldi	r20, 0x2A	; 42
    fbe4:	15 c0       	rjmp	.+42     	; 0xfc10 <UserInput+0x46e>
			  }
			  //else lcd_put(xChar,yChar,' '); 
			  else lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); 			  
    fbe6:	20 91 68 03 	lds	r18, 0x0368
    fbea:	82 2f       	mov	r24, r18
    fbec:	90 e0       	ldi	r25, 0x00	; 0
    fbee:	01 97       	sbiw	r24, 0x01	; 1
    fbf0:	8d 0d       	add	r24, r13
    fbf2:	91 1d       	adc	r25, r1
    fbf4:	64 e1       	ldi	r22, 0x14	; 20
    fbf6:	70 e0       	ldi	r23, 0x00	; 0
    fbf8:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    fbfc:	36 2f       	mov	r19, r22
    fbfe:	82 2f       	mov	r24, r18
    fc00:	64 e1       	ldi	r22, 0x14	; 20
    fc02:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    fc06:	d9 0e       	add	r13, r25
    fc08:	89 2d       	mov	r24, r9
    fc0a:	83 0f       	add	r24, r19
    fc0c:	6d 2d       	mov	r22, r13
    fc0e:	40 e2       	ldi	r20, 0x20	; 32
    fc10:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
			  }
          iLoop++;
    fc14:	80 91 5c 03 	lds	r24, 0x035C
    fc18:	90 91 5d 03 	lds	r25, 0x035D
    fc1c:	01 96       	adiw	r24, 0x01	; 1
    fc1e:	90 93 5d 03 	sts	0x035D, r25
    fc22:	80 93 5c 03 	sts	0x035C, r24
    fc26:	d6 c0       	rjmp	.+428    	; 0xfdd4 <UserInput+0x632>
          break;
     case uiClearDisplay:
          if (TypeUI==UI_NUMBER_L){
    fc28:	e2 e0       	ldi	r30, 0x02	; 2
    fc2a:	8e 17       	cp	r24, r30
    fc2c:	99 f4       	brne	.+38     	; 0xfc54 <UserInput+0x4b2>
		      lcd_put(xChar,(yChar-iValuePos),' '); // 123_ 1_
    fc2e:	60 91 69 03 	lds	r22, 0x0369
    fc32:	80 91 68 03 	lds	r24, 0x0368
    fc36:	68 1b       	sub	r22, r24
    fc38:	80 91 6a 03 	lds	r24, 0x036A
    fc3c:	40 e2       	ldi	r20, 0x20	; 32
    fc3e:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
		      strResult[iValuePos]=0;
    fc42:	80 91 68 03 	lds	r24, 0x0368
    fc46:	c8 0f       	add	r28, r24
    fc48:	d1 1d       	adc	r29, r1
    fc4a:	18 82       	st	Y, r1
		      iValuePos--;
    fc4c:	81 50       	subi	r24, 0x01	; 1
    fc4e:	80 93 68 03 	sts	0x0368, r24
    fc52:	33 c0       	rjmp	.+102    	; 0xfcba <UserInput+0x518>
			  }
          else
		  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    fc54:	f1 e0       	ldi	r31, 0x01	; 1
    fc56:	8f 17       	cp	r24, r31
    fc58:	49 f0       	breq	.+18     	; 0xfc6c <UserInput+0x4ca>
    fc5a:	23 e0       	ldi	r18, 0x03	; 3
    fc5c:	82 17       	cp	r24, r18
    fc5e:	31 f0       	breq	.+12     	; 0xfc6c <UserInput+0x4ca>
    fc60:	84 e0       	ldi	r24, 0x04	; 4
    fc62:	f8 16       	cp	r15, r24
    fc64:	19 f0       	breq	.+6      	; 0xfc6c <UserInput+0x4ca>
    fc66:	e5 e0       	ldi	r30, 0x05	; 5
    fc68:	fe 16       	cp	r15, r30
    fc6a:	39 f5       	brne	.+78     	; 0xfcba <UserInput+0x518>
		      (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
		      //lcd_put(xChar,yChar,' '); // 123_ 1_
			  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); // 123_ 1_
    fc6c:	20 91 68 03 	lds	r18, 0x0368
    fc70:	82 2f       	mov	r24, r18
    fc72:	90 e0       	ldi	r25, 0x00	; 0
    fc74:	01 97       	sbiw	r24, 0x01	; 1
    fc76:	8d 0d       	add	r24, r13
    fc78:	91 1d       	adc	r25, r1
    fc7a:	64 e1       	ldi	r22, 0x14	; 20
    fc7c:	70 e0       	ldi	r23, 0x00	; 0
    fc7e:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    fc82:	36 2f       	mov	r19, r22
    fc84:	82 2f       	mov	r24, r18
    fc86:	64 e1       	ldi	r22, 0x14	; 20
    fc88:	0e 94 f4 b6 	call	0x16de8	; 0x16de8 <__udivmodqi4>
    fc8c:	d9 0e       	add	r13, r25
    fc8e:	89 2d       	mov	r24, r9
    fc90:	83 0f       	add	r24, r19
    fc92:	6d 2d       	mov	r22, r13
    fc94:	40 e2       	ldi	r20, 0x20	; 32
    fc96:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
			  
		      strResult[iValuePos]=0;
    fc9a:	80 91 68 03 	lds	r24, 0x0368
    fc9e:	c8 0f       	add	r28, r24
    fca0:	d1 1d       	adc	r29, r1
    fca2:	18 82       	st	Y, r1
		      iValuePos--;
    fca4:	81 50       	subi	r24, 0x01	; 1
    fca6:	80 93 68 03 	sts	0x0368, r24
			  yChar--;
    fcaa:	80 91 69 03 	lds	r24, 0x0369
    fcae:	81 50       	subi	r24, 0x01	; 1
    fcb0:	80 93 69 03 	sts	0x0369, r24
			  IsDelete=True;
    fcb4:	81 e0       	ldi	r24, 0x01	; 1
    fcb6:	80 93 64 03 	sts	0x0364, r24
		  }
		  if (iValuePos==0)Result=USER_NO_DATA;		  
    fcba:	80 91 68 03 	lds	r24, 0x0368
    fcbe:	88 23       	and	r24, r24
    fcc0:	19 f4       	brne	.+6      	; 0xfcc8 <UserInput+0x526>
    fcc2:	95 e0       	ldi	r25, 0x05	; 5
    fcc4:	e9 2e       	mov	r14, r25
    fcc6:	01 c0       	rjmp	.+2      	; 0xfcca <UserInput+0x528>
    fcc8:	ee 24       	eor	r14, r14
		  stUserInput=uiInputDisp;//Redraw
    fcca:	83 e0       	ldi	r24, 0x03	; 3
    fccc:	80 93 6b 03 	sts	0x036B, r24
    fcd0:	81 c0       	rjmp	.+258    	; 0xfdd4 <UserInput+0x632>
	      break;      
     case uiInputDisp:
	      if(TypeUI==UI_ALPHANUM_PASSWORD){
    fcd2:	f5 e0       	ldi	r31, 0x05	; 5
    fcd4:	8f 17       	cp	r24, r31
    fcd6:	19 f5       	brne	.+70     	; 0xfd1e <UserInput+0x57c>
			  if (iValuePos>0){
    fcd8:	80 91 68 03 	lds	r24, 0x0368
    fcdc:	88 23       	and	r24, r24
    fcde:	a9 f0       	breq	.+42     	; 0xfd0a <UserInput+0x568>
                  lcd_put(xChar,(yChar-2),'*');
    fce0:	60 91 69 03 	lds	r22, 0x0369
    fce4:	62 50       	subi	r22, 0x02	; 2
    fce6:	80 91 6a 03 	lds	r24, 0x036A
    fcea:	4a e2       	ldi	r20, 0x2A	; 42
    fcec:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
			      if (IsDelete==True){
    fcf0:	80 91 64 03 	lds	r24, 0x0364
    fcf4:	60 91 69 03 	lds	r22, 0x0369
    fcf8:	81 30       	cpi	r24, 0x01	; 1
    fcfa:	71 f0       	breq	.+28     	; 0xfd18 <UserInput+0x576>
				      IsDelete=False;
			          lcd_put(xChar,(yChar-1),'*');
			          }
				  else lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
    fcfc:	61 50       	subi	r22, 0x01	; 1
    fcfe:	80 91 68 03 	lds	r24, 0x0368
    fd02:	c8 0f       	add	r28, r24
    fd04:	d1 1d       	adc	r29, r1
    fd06:	21 97       	sbiw	r28, 0x01	; 1
    fd08:	4d c0       	rjmp	.+154    	; 0xfda4 <UserInput+0x602>
			      }
			  else{ if(IsDelete==True){
    fd0a:	80 91 64 03 	lds	r24, 0x0364
    fd0e:	60 91 69 03 	lds	r22, 0x0369
    fd12:	81 30       	cpi	r24, 0x01	; 1
    fd14:	09 f0       	breq	.+2      	; 0xfd18 <UserInput+0x576>
    fd16:	45 c0       	rjmp	.+138    	; 0xfda2 <UserInput+0x600>
			           IsDelete=False;
    fd18:	10 92 64 03 	sts	0x0364, r1
    fd1c:	4c c0       	rjmp	.+152    	; 0xfdb6 <UserInput+0x614>
					   lcd_put(xChar,(yChar-1),'*');
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
    fd1e:	22 e0       	ldi	r18, 0x02	; 2
    fd20:	82 17       	cp	r24, r18
    fd22:	a1 f4       	brne	.+40     	; 0xfd4c <UserInput+0x5aa>
    fd24:	10 e0       	ldi	r17, 0x00	; 0
    fd26:	0d c0       	rjmp	.+26     	; 0xfd42 <UserInput+0x5a0>
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
    fd28:	60 91 69 03 	lds	r22, 0x0369
    fd2c:	68 1b       	sub	r22, r24
    fd2e:	61 0f       	add	r22, r17
    fd30:	fe 01       	movw	r30, r28
    fd32:	e1 0f       	add	r30, r17
    fd34:	f1 1d       	adc	r31, r1
    fd36:	80 91 6a 03 	lds	r24, 0x036A
    fd3a:	40 81       	ld	r20, Z
    fd3c:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
    fd40:	1f 5f       	subi	r17, 0xFF	; 255
    fd42:	80 91 68 03 	lds	r24, 0x0368
    fd46:	18 17       	cp	r17, r24
    fd48:	78 f3       	brcs	.-34     	; 0xfd28 <UserInput+0x586>
    fd4a:	3b c0       	rjmp	.+118    	; 0xfdc2 <UserInput+0x620>
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
		      }
		  }else
	      if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)){
    fd4c:	81 e0       	ldi	r24, 0x01	; 1
    fd4e:	f8 16       	cp	r15, r24
    fd50:	19 f0       	breq	.+6      	; 0xfd58 <UserInput+0x5b6>
    fd52:	e3 e0       	ldi	r30, 0x03	; 3
    fd54:	fe 16       	cp	r15, r30
    fd56:	51 f5       	brne	.+84     	; 0xfdac <UserInput+0x60a>
		      
			  //if (iValuePos>0) lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
			  if (iValuePos>0) lcd_put(xPos+((yPos+iValuePos-1)/21),yPos+((iValuePos-1)%20),strResult[iValuePos-1]);			  
    fd58:	20 91 68 03 	lds	r18, 0x0368
    fd5c:	4d 2d       	mov	r20, r13
    fd5e:	50 e0       	ldi	r21, 0x00	; 0
    fd60:	22 23       	and	r18, r18
    fd62:	c1 f0       	breq	.+48     	; 0xfd94 <UserInput+0x5f2>
    fd64:	30 e0       	ldi	r19, 0x00	; 0
    fd66:	f9 01       	movw	r30, r18
    fd68:	31 97       	sbiw	r30, 0x01	; 1
    fd6a:	cf 01       	movw	r24, r30
    fd6c:	84 0f       	add	r24, r20
    fd6e:	95 1f       	adc	r25, r21
    fd70:	65 e1       	ldi	r22, 0x15	; 21
    fd72:	70 e0       	ldi	r23, 0x00	; 0
    fd74:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    fd78:	46 2f       	mov	r20, r22
    fd7a:	cf 01       	movw	r24, r30
    fd7c:	64 e1       	ldi	r22, 0x14	; 20
    fd7e:	70 e0       	ldi	r23, 0x00	; 0
    fd80:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
    fd84:	d8 0e       	add	r13, r24
    fd86:	c2 0f       	add	r28, r18
    fd88:	d3 1f       	adc	r29, r19
    fd8a:	21 97       	sbiw	r28, 0x01	; 1
    fd8c:	89 2d       	mov	r24, r9
    fd8e:	84 0f       	add	r24, r20
    fd90:	6d 2d       	mov	r22, r13
    fd92:	0a c0       	rjmp	.+20     	; 0xfda8 <UserInput+0x606>
			  else{ if ((yChar-1)>=yPos)lcd_put(xChar,(yChar-1),strResult[iValuePos]);
    fd94:	60 91 69 03 	lds	r22, 0x0369
    fd98:	86 2f       	mov	r24, r22
    fd9a:	90 e0       	ldi	r25, 0x00	; 0
    fd9c:	48 17       	cp	r20, r24
    fd9e:	59 07       	cpc	r21, r25
    fda0:	84 f4       	brge	.+32     	; 0xfdc2 <UserInput+0x620>
    fda2:	61 50       	subi	r22, 0x01	; 1
    fda4:	80 91 6a 03 	lds	r24, 0x036A
    fda8:	48 81       	ld	r20, Y
    fdaa:	09 c0       	rjmp	.+18     	; 0xfdbe <UserInput+0x61c>
			  }
		  }else
		  //DisplayAsterik *
		  if (TypeUI==UI_NUM_PASSWORD){
    fdac:	f4 e0       	ldi	r31, 0x04	; 4
    fdae:	ff 16       	cp	r15, r31
    fdb0:	41 f4       	brne	.+16     	; 0xfdc2 <UserInput+0x620>
		      lcd_put(xChar,(yChar-1),'*');
    fdb2:	60 91 69 03 	lds	r22, 0x0369
    fdb6:	61 50       	subi	r22, 0x01	; 1
    fdb8:	80 91 6a 03 	lds	r24, 0x036A
    fdbc:	4a e2       	ldi	r20, 0x2A	; 42
    fdbe:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
		  }

          stUserInput=uiInput;
    fdc2:	81 e0       	ldi	r24, 0x01	; 1
    fdc4:	80 93 6b 03 	sts	0x036B, r24
    fdc8:	ee 24       	eor	r14, r14
    fdca:	04 c0       	rjmp	.+8      	; 0xfdd4 <UserInput+0x632>
	      break;	 
     case uiFinished:
	      Result=UserInputResult;
    fdcc:	e0 90 6c 03 	lds	r14, 0x036C
	      stUserInput=uiInit;
    fdd0:	10 92 6b 03 	sts	0x036B, r1
	      break;
	 }
	 return Result;
}
    fdd4:	8e 2d       	mov	r24, r14
    fdd6:	df 91       	pop	r29
    fdd8:	cf 91       	pop	r28
    fdda:	1f 91       	pop	r17
    fddc:	0f 91       	pop	r16
    fdde:	ff 90       	pop	r15
    fde0:	ef 90       	pop	r14
    fde2:	df 90       	pop	r13
    fde4:	cf 90       	pop	r12
    fde6:	bf 90       	pop	r11
    fde8:	af 90       	pop	r10
    fdea:	9f 90       	pop	r9
    fdec:	8f 90       	pop	r8
    fdee:	08 95       	ret

0000fdf0 <TestUserInput>:
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//_uart_print(0,1,strSend);
}


char TestUserInput(){
    fdf0:	6f 92       	push	r6
    fdf2:	7f 92       	push	r7
    fdf4:	8f 92       	push	r8
    fdf6:	9f 92       	push	r9
    fdf8:	af 92       	push	r10
    fdfa:	bf 92       	push	r11
    fdfc:	cf 92       	push	r12
    fdfe:	df 92       	push	r13
    fe00:	ef 92       	push	r14
    fe02:	ff 92       	push	r15
    fe04:	0f 93       	push	r16
    fe06:	1f 93       	push	r17
    fe08:	df 93       	push	r29
    fe0a:	cf 93       	push	r28
    fe0c:	cd b7       	in	r28, 0x3d	; 61
    fe0e:	de b7       	in	r29, 0x3e	; 62
    fe10:	ce 56       	subi	r28, 0x6E	; 110
    fe12:	d0 40       	sbci	r29, 0x00	; 0
    fe14:	0f b6       	in	r0, 0x3f	; 63
    fe16:	f8 94       	cli
    fe18:	de bf       	out	0x3e, r29	; 62
    fe1a:	0f be       	out	0x3f, r0	; 63
    fe1c:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],strSend[30];
char SVolume[15],SMoney[15],STotalVolume[15],STotalMoney[15];
char Result;

char uiResult;
	uiResult=UserInput(UI_ALPHANUM_R,2,1,strNumber,0,10);
    fe1e:	e3 ef       	ldi	r30, 0xF3	; 243
    fe20:	6e 2e       	mov	r6, r30
    fe22:	e1 e0       	ldi	r30, 0x01	; 1
    fe24:	7e 2e       	mov	r7, r30
    fe26:	83 e0       	ldi	r24, 0x03	; 3
    fe28:	62 e0       	ldi	r22, 0x02	; 2
    fe2a:	41 e0       	ldi	r20, 0x01	; 1
    fe2c:	93 01       	movw	r18, r6
    fe2e:	00 e0       	ldi	r16, 0x00	; 0
    fe30:	10 e0       	ldi	r17, 0x00	; 0
    fe32:	7a e0       	ldi	r23, 0x0A	; 10
    fe34:	e7 2e       	mov	r14, r23
    fe36:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
	Result=MENU_NONE;
    if (uiResult==USER_OK){
    fe3a:	83 30       	cpi	r24, 0x03	; 3
    fe3c:	09 f0       	breq	.+2      	; 0xfe40 <TestUserInput+0x50>
    fe3e:	ed c1       	rjmp	.+986    	; 0x1021a <TestUserInput+0x42a>
	    sprintf_P(lcdteks,PSTR("Data:%s"),strNumber);
    fe40:	00 d0       	rcall	.+0      	; 0xfe42 <TestUserInput+0x52>
    fe42:	00 d0       	rcall	.+0      	; 0xfe44 <TestUserInput+0x54>
    fe44:	00 d0       	rcall	.+0      	; 0xfe46 <TestUserInput+0x56>
    fe46:	ed b7       	in	r30, 0x3d	; 61
    fe48:	fe b7       	in	r31, 0x3e	; 62
    fe4a:	31 96       	adiw	r30, 0x01	; 1
    fe4c:	8e 01       	movw	r16, r28
    fe4e:	03 5c       	subi	r16, 0xC3	; 195
    fe50:	1f 4f       	sbci	r17, 0xFF	; 255
    fe52:	ad b7       	in	r26, 0x3d	; 61
    fe54:	be b7       	in	r27, 0x3e	; 62
    fe56:	12 96       	adiw	r26, 0x02	; 2
    fe58:	1c 93       	st	X, r17
    fe5a:	0e 93       	st	-X, r16
    fe5c:	11 97       	sbiw	r26, 0x01	; 1
    fe5e:	8d ee       	ldi	r24, 0xED	; 237
    fe60:	93 e0       	ldi	r25, 0x03	; 3
    fe62:	93 83       	std	Z+3, r25	; 0x03
    fe64:	82 83       	std	Z+2, r24	; 0x02
    fe66:	75 82       	std	Z+5, r7	; 0x05
    fe68:	64 82       	std	Z+4, r6	; 0x04
    fe6a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	   lcd_print(3,1,lcdteks);
    fe6e:	8d b7       	in	r24, 0x3d	; 61
    fe70:	9e b7       	in	r25, 0x3e	; 62
    fe72:	06 96       	adiw	r24, 0x06	; 6
    fe74:	0f b6       	in	r0, 0x3f	; 63
    fe76:	f8 94       	cli
    fe78:	9e bf       	out	0x3e, r25	; 62
    fe7a:	0f be       	out	0x3f, r0	; 63
    fe7c:	8d bf       	out	0x3d, r24	; 61
    fe7e:	83 e0       	ldi	r24, 0x03	; 3
    fe80:	61 e0       	ldi	r22, 0x01	; 1
    fe82:	a8 01       	movw	r20, r16
    fe84:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
	   //FormatCurrency(strNumber);
	   //FormatMoney(strNumber);
	   //RemZeroLead(strNumber);
	   sprintf_P(SVolume,PSTR("%s"),strNumber);
    fe88:	00 d0       	rcall	.+0      	; 0xfe8a <TestUserInput+0x9a>
    fe8a:	00 d0       	rcall	.+0      	; 0xfe8c <TestUserInput+0x9c>
    fe8c:	00 d0       	rcall	.+0      	; 0xfe8e <TestUserInput+0x9e>
    fe8e:	ed b7       	in	r30, 0x3d	; 61
    fe90:	fe b7       	in	r31, 0x3e	; 62
    fe92:	31 96       	adiw	r30, 0x01	; 1
    fe94:	7e 01       	movw	r14, r28
    fe96:	08 94       	sec
    fe98:	e1 1c       	adc	r14, r1
    fe9a:	f1 1c       	adc	r15, r1
    fe9c:	ad b7       	in	r26, 0x3d	; 61
    fe9e:	be b7       	in	r27, 0x3e	; 62
    fea0:	12 96       	adiw	r26, 0x02	; 2
    fea2:	fc 92       	st	X, r15
    fea4:	ee 92       	st	-X, r14
    fea6:	11 97       	sbiw	r26, 0x01	; 1
    fea8:	8a ee       	ldi	r24, 0xEA	; 234
    feaa:	93 e0       	ldi	r25, 0x03	; 3
    feac:	93 83       	std	Z+3, r25	; 0x03
    feae:	82 83       	std	Z+2, r24	; 0x02
    feb0:	75 82       	std	Z+5, r7	; 0x05
    feb2:	64 82       	std	Z+4, r6	; 0x04
    feb4:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	   sprintf_P(SMoney,PSTR("%s"),strNumber);
    feb8:	ed b7       	in	r30, 0x3d	; 61
    feba:	fe b7       	in	r31, 0x3e	; 62
    febc:	31 96       	adiw	r30, 0x01	; 1
    febe:	60 e1       	ldi	r22, 0x10	; 16
    fec0:	a6 2e       	mov	r10, r22
    fec2:	b1 2c       	mov	r11, r1
    fec4:	ac 0e       	add	r10, r28
    fec6:	bd 1e       	adc	r11, r29
    fec8:	ad b7       	in	r26, 0x3d	; 61
    feca:	be b7       	in	r27, 0x3e	; 62
    fecc:	12 96       	adiw	r26, 0x02	; 2
    fece:	bc 92       	st	X, r11
    fed0:	ae 92       	st	-X, r10
    fed2:	11 97       	sbiw	r26, 0x01	; 1
    fed4:	87 ee       	ldi	r24, 0xE7	; 231
    fed6:	93 e0       	ldi	r25, 0x03	; 3
    fed8:	93 83       	std	Z+3, r25	; 0x03
    feda:	82 83       	std	Z+2, r24	; 0x02
    fedc:	75 82       	std	Z+5, r7	; 0x05
    fede:	64 82       	std	Z+4, r6	; 0x04
    fee0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	   sprintf_P(STotalVolume,PSTR("%s"),strNumber);
    fee4:	ed b7       	in	r30, 0x3d	; 61
    fee6:	fe b7       	in	r31, 0x3e	; 62
    fee8:	31 96       	adiw	r30, 0x01	; 1
    feea:	5f e1       	ldi	r21, 0x1F	; 31
    feec:	85 2e       	mov	r8, r21
    feee:	91 2c       	mov	r9, r1
    fef0:	8c 0e       	add	r8, r28
    fef2:	9d 1e       	adc	r9, r29
    fef4:	ad b7       	in	r26, 0x3d	; 61
    fef6:	be b7       	in	r27, 0x3e	; 62
    fef8:	12 96       	adiw	r26, 0x02	; 2
    fefa:	9c 92       	st	X, r9
    fefc:	8e 92       	st	-X, r8
    fefe:	11 97       	sbiw	r26, 0x01	; 1
    ff00:	84 ee       	ldi	r24, 0xE4	; 228
    ff02:	93 e0       	ldi	r25, 0x03	; 3
    ff04:	93 83       	std	Z+3, r25	; 0x03
    ff06:	82 83       	std	Z+2, r24	; 0x02
    ff08:	75 82       	std	Z+5, r7	; 0x05
    ff0a:	64 82       	std	Z+4, r6	; 0x04
    ff0c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	   sprintf_P(STotalMoney,PSTR("%s"),strNumber);
    ff10:	ed b7       	in	r30, 0x3d	; 61
    ff12:	fe b7       	in	r31, 0x3e	; 62
    ff14:	31 96       	adiw	r30, 0x01	; 1
    ff16:	4e e2       	ldi	r20, 0x2E	; 46
    ff18:	c4 2e       	mov	r12, r20
    ff1a:	d1 2c       	mov	r13, r1
    ff1c:	cc 0e       	add	r12, r28
    ff1e:	dd 1e       	adc	r13, r29
    ff20:	ad b7       	in	r26, 0x3d	; 61
    ff22:	be b7       	in	r27, 0x3e	; 62
    ff24:	12 96       	adiw	r26, 0x02	; 2
    ff26:	dc 92       	st	X, r13
    ff28:	ce 92       	st	-X, r12
    ff2a:	11 97       	sbiw	r26, 0x01	; 1
    ff2c:	81 ee       	ldi	r24, 0xE1	; 225
    ff2e:	93 e0       	ldi	r25, 0x03	; 3
    ff30:	93 83       	std	Z+3, r25	; 0x03
    ff32:	82 83       	std	Z+2, r24	; 0x02
    ff34:	75 82       	std	Z+5, r7	; 0x05
    ff36:	64 82       	std	Z+4, r6	; 0x04
    ff38:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>

	   sprintf_P(lcdteks,PSTR("Formated:%s"),strNumber);
    ff3c:	ed b7       	in	r30, 0x3d	; 61
    ff3e:	fe b7       	in	r31, 0x3e	; 62
    ff40:	31 96       	adiw	r30, 0x01	; 1
    ff42:	ad b7       	in	r26, 0x3d	; 61
    ff44:	be b7       	in	r27, 0x3e	; 62
    ff46:	12 96       	adiw	r26, 0x02	; 2
    ff48:	1c 93       	st	X, r17
    ff4a:	0e 93       	st	-X, r16
    ff4c:	11 97       	sbiw	r26, 0x01	; 1
    ff4e:	85 ed       	ldi	r24, 0xD5	; 213
    ff50:	93 e0       	ldi	r25, 0x03	; 3
    ff52:	93 83       	std	Z+3, r25	; 0x03
    ff54:	82 83       	std	Z+2, r24	; 0x02
    ff56:	75 82       	std	Z+5, r7	; 0x05
    ff58:	64 82       	std	Z+4, r6	; 0x04
    ff5a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
       lcd_print(4,1,lcdteks);
    ff5e:	8d b7       	in	r24, 0x3d	; 61
    ff60:	9e b7       	in	r25, 0x3e	; 62
    ff62:	06 96       	adiw	r24, 0x06	; 6
    ff64:	0f b6       	in	r0, 0x3f	; 63
    ff66:	f8 94       	cli
    ff68:	9e bf       	out	0x3e, r25	; 62
    ff6a:	0f be       	out	0x3f, r0	; 63
    ff6c:	8d bf       	out	0x3d, r24	; 61
    ff6e:	84 e0       	ldi	r24, 0x04	; 4
    ff70:	61 e0       	ldi	r22, 0x01	; 1
    ff72:	a8 01       	movw	r20, r16
    ff74:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
	   sprintf_P(strSend,PSTR("Raw:%s"),strNumber);
    ff78:	00 d0       	rcall	.+0      	; 0xff7a <TestUserInput+0x18a>
    ff7a:	00 d0       	rcall	.+0      	; 0xff7c <TestUserInput+0x18c>
    ff7c:	00 d0       	rcall	.+0      	; 0xff7e <TestUserInput+0x18e>
    ff7e:	ed b7       	in	r30, 0x3d	; 61
    ff80:	fe b7       	in	r31, 0x3e	; 62
    ff82:	31 96       	adiw	r30, 0x01	; 1
    ff84:	8e 01       	movw	r16, r28
    ff86:	0f 5a       	subi	r16, 0xAF	; 175
    ff88:	1f 4f       	sbci	r17, 0xFF	; 255
    ff8a:	ad b7       	in	r26, 0x3d	; 61
    ff8c:	be b7       	in	r27, 0x3e	; 62
    ff8e:	12 96       	adiw	r26, 0x02	; 2
    ff90:	1c 93       	st	X, r17
    ff92:	0e 93       	st	-X, r16
    ff94:	11 97       	sbiw	r26, 0x01	; 1
    ff96:	8e ec       	ldi	r24, 0xCE	; 206
    ff98:	93 e0       	ldi	r25, 0x03	; 3
    ff9a:	93 83       	std	Z+3, r25	; 0x03
    ff9c:	82 83       	std	Z+2, r24	; 0x02
    ff9e:	75 82       	std	Z+5, r7	; 0x05
    ffa0:	64 82       	std	Z+4, r6	; 0x04
    ffa2:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	   _uart_print(0,1,strSend);
    ffa6:	8d b7       	in	r24, 0x3d	; 61
    ffa8:	9e b7       	in	r25, 0x3e	; 62
    ffaa:	06 96       	adiw	r24, 0x06	; 6
    ffac:	0f b6       	in	r0, 0x3f	; 63
    ffae:	f8 94       	cli
    ffb0:	9e bf       	out	0x3e, r25	; 62
    ffb2:	0f be       	out	0x3f, r0	; 63
    ffb4:	8d bf       	out	0x3d, r24	; 61
    ffb6:	80 e0       	ldi	r24, 0x00	; 0
    ffb8:	61 e0       	ldi	r22, 0x01	; 1
    ffba:	a8 01       	movw	r20, r16
    ffbc:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>

	   RemoveMinus(strNumber);
    ffc0:	c3 01       	movw	r24, r6
    ffc2:	0e 94 f8 21 	call	0x43f0	; 0x43f0 <RemoveMinus>

	   sprintf_P(strSend,PSTR("Minus:%s"),strNumber);
    ffc6:	00 d0       	rcall	.+0      	; 0xffc8 <TestUserInput+0x1d8>
    ffc8:	00 d0       	rcall	.+0      	; 0xffca <TestUserInput+0x1da>
    ffca:	00 d0       	rcall	.+0      	; 0xffcc <TestUserInput+0x1dc>
    ffcc:	ed b7       	in	r30, 0x3d	; 61
    ffce:	fe b7       	in	r31, 0x3e	; 62
    ffd0:	31 96       	adiw	r30, 0x01	; 1
    ffd2:	ad b7       	in	r26, 0x3d	; 61
    ffd4:	be b7       	in	r27, 0x3e	; 62
    ffd6:	12 96       	adiw	r26, 0x02	; 2
    ffd8:	1c 93       	st	X, r17
    ffda:	0e 93       	st	-X, r16
    ffdc:	11 97       	sbiw	r26, 0x01	; 1
    ffde:	85 ec       	ldi	r24, 0xC5	; 197
    ffe0:	93 e0       	ldi	r25, 0x03	; 3
    ffe2:	93 83       	std	Z+3, r25	; 0x03
    ffe4:	82 83       	std	Z+2, r24	; 0x02
    ffe6:	75 82       	std	Z+5, r7	; 0x05
    ffe8:	64 82       	std	Z+4, r6	; 0x04
    ffea:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	   _uart_print(0,1,strSend);
    ffee:	8d b7       	in	r24, 0x3d	; 61
    fff0:	9e b7       	in	r25, 0x3e	; 62
    fff2:	06 96       	adiw	r24, 0x06	; 6
    fff4:	0f b6       	in	r0, 0x3f	; 63
    fff6:	f8 94       	cli
    fff8:	9e bf       	out	0x3e, r25	; 62
    fffa:	0f be       	out	0x3f, r0	; 63
    fffc:	8d bf       	out	0x3d, r24	; 61
    fffe:	80 e0       	ldi	r24, 0x00	; 0
   10000:	61 e0       	ldi	r22, 0x01	; 1
   10002:	a8 01       	movw	r20, r16
   10004:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>

       
	   RemZeroLead(strNumber);
   10008:	c3 01       	movw	r24, r6
   1000a:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
	   sprintf_P(strSend,PSTR("Removed:%s"),strNumber);
   1000e:	00 d0       	rcall	.+0      	; 0x10010 <TestUserInput+0x220>
   10010:	00 d0       	rcall	.+0      	; 0x10012 <TestUserInput+0x222>
   10012:	00 d0       	rcall	.+0      	; 0x10014 <TestUserInput+0x224>
   10014:	ed b7       	in	r30, 0x3d	; 61
   10016:	fe b7       	in	r31, 0x3e	; 62
   10018:	31 96       	adiw	r30, 0x01	; 1
   1001a:	ad b7       	in	r26, 0x3d	; 61
   1001c:	be b7       	in	r27, 0x3e	; 62
   1001e:	12 96       	adiw	r26, 0x02	; 2
   10020:	1c 93       	st	X, r17
   10022:	0e 93       	st	-X, r16
   10024:	11 97       	sbiw	r26, 0x01	; 1
   10026:	8a eb       	ldi	r24, 0xBA	; 186
   10028:	93 e0       	ldi	r25, 0x03	; 3
   1002a:	93 83       	std	Z+3, r25	; 0x03
   1002c:	82 83       	std	Z+2, r24	; 0x02
   1002e:	75 82       	std	Z+5, r7	; 0x05
   10030:	64 82       	std	Z+4, r6	; 0x04
   10032:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	   _uart_print(0,1,strSend);
   10036:	8d b7       	in	r24, 0x3d	; 61
   10038:	9e b7       	in	r25, 0x3e	; 62
   1003a:	06 96       	adiw	r24, 0x06	; 6
   1003c:	0f b6       	in	r0, 0x3f	; 63
   1003e:	f8 94       	cli
   10040:	9e bf       	out	0x3e, r25	; 62
   10042:	0f be       	out	0x3f, r0	; 63
   10044:	8d bf       	out	0x3d, r24	; 61
   10046:	80 e0       	ldi	r24, 0x00	; 0
   10048:	61 e0       	ldi	r22, 0x01	; 1
   1004a:	a8 01       	movw	r20, r16
   1004c:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>

RemZeroLead(SVolume);
   10050:	c7 01       	movw	r24, r14
   10052:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
RemZeroLead(SMoney);
   10056:	c5 01       	movw	r24, r10
   10058:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
RemZeroLead(STotalVolume);
   1005c:	c4 01       	movw	r24, r8
   1005e:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
RemZeroLead(STotalMoney);
   10062:	c6 01       	movw	r24, r12
   10064:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
       
	   
	   FormatVolume(SVolume); 
   10068:	c7 01       	movw	r24, r14
   1006a:	0e 94 74 31 	call	0x62e8	; 0x62e8 <FormatVolume>
	   FormatMoney(SMoney);
   1006e:	c5 01       	movw	r24, r10
   10070:	0e 94 81 31 	call	0x6302	; 0x6302 <FormatMoney>
	   FormatTotalizerMoney(STotalVolume);
   10074:	c4 01       	movw	r24, r8
   10076:	0e 94 67 31 	call	0x62ce	; 0x62ce <FormatTotalizerMoney>
	   FormatTotalizerVolume(STotalMoney);
   1007a:	c6 01       	movw	r24, r12
   1007c:	0e 94 5a 31 	call	0x62b4	; 0x62b4 <FormatTotalizerVolume>

	   sprintf_P(strSend,PSTR("Volume:%s"),SVolume);
   10080:	00 d0       	rcall	.+0      	; 0x10082 <TestUserInput+0x292>
   10082:	00 d0       	rcall	.+0      	; 0x10084 <TestUserInput+0x294>
   10084:	00 d0       	rcall	.+0      	; 0x10086 <TestUserInput+0x296>
   10086:	ed b7       	in	r30, 0x3d	; 61
   10088:	fe b7       	in	r31, 0x3e	; 62
   1008a:	31 96       	adiw	r30, 0x01	; 1
   1008c:	ad b7       	in	r26, 0x3d	; 61
   1008e:	be b7       	in	r27, 0x3e	; 62
   10090:	12 96       	adiw	r26, 0x02	; 2
   10092:	1c 93       	st	X, r17
   10094:	0e 93       	st	-X, r16
   10096:	11 97       	sbiw	r26, 0x01	; 1
   10098:	80 eb       	ldi	r24, 0xB0	; 176
   1009a:	93 e0       	ldi	r25, 0x03	; 3
   1009c:	93 83       	std	Z+3, r25	; 0x03
   1009e:	82 83       	std	Z+2, r24	; 0x02
   100a0:	f5 82       	std	Z+5, r15	; 0x05
   100a2:	e4 82       	std	Z+4, r14	; 0x04
   100a4:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	   _uart_print(0,1,strSend);
   100a8:	8d b7       	in	r24, 0x3d	; 61
   100aa:	9e b7       	in	r25, 0x3e	; 62
   100ac:	06 96       	adiw	r24, 0x06	; 6
   100ae:	0f b6       	in	r0, 0x3f	; 63
   100b0:	f8 94       	cli
   100b2:	9e bf       	out	0x3e, r25	; 62
   100b4:	0f be       	out	0x3f, r0	; 63
   100b6:	8d bf       	out	0x3d, r24	; 61
   100b8:	80 e0       	ldi	r24, 0x00	; 0
   100ba:	61 e0       	ldi	r22, 0x01	; 1
   100bc:	a8 01       	movw	r20, r16
   100be:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	   sprintf_P(strSend,PSTR("Money:%s"),SMoney);
   100c2:	00 d0       	rcall	.+0      	; 0x100c4 <TestUserInput+0x2d4>
   100c4:	00 d0       	rcall	.+0      	; 0x100c6 <TestUserInput+0x2d6>
   100c6:	00 d0       	rcall	.+0      	; 0x100c8 <TestUserInput+0x2d8>
   100c8:	ed b7       	in	r30, 0x3d	; 61
   100ca:	fe b7       	in	r31, 0x3e	; 62
   100cc:	31 96       	adiw	r30, 0x01	; 1
   100ce:	ad b7       	in	r26, 0x3d	; 61
   100d0:	be b7       	in	r27, 0x3e	; 62
   100d2:	12 96       	adiw	r26, 0x02	; 2
   100d4:	1c 93       	st	X, r17
   100d6:	0e 93       	st	-X, r16
   100d8:	11 97       	sbiw	r26, 0x01	; 1
   100da:	87 ea       	ldi	r24, 0xA7	; 167
   100dc:	93 e0       	ldi	r25, 0x03	; 3
   100de:	93 83       	std	Z+3, r25	; 0x03
   100e0:	82 83       	std	Z+2, r24	; 0x02
   100e2:	b5 82       	std	Z+5, r11	; 0x05
   100e4:	a4 82       	std	Z+4, r10	; 0x04
   100e6:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	   _uart_print(0,1,strSend);
   100ea:	8d b7       	in	r24, 0x3d	; 61
   100ec:	9e b7       	in	r25, 0x3e	; 62
   100ee:	06 96       	adiw	r24, 0x06	; 6
   100f0:	0f b6       	in	r0, 0x3f	; 63
   100f2:	f8 94       	cli
   100f4:	9e bf       	out	0x3e, r25	; 62
   100f6:	0f be       	out	0x3f, r0	; 63
   100f8:	8d bf       	out	0x3d, r24	; 61
   100fa:	80 e0       	ldi	r24, 0x00	; 0
   100fc:	61 e0       	ldi	r22, 0x01	; 1
   100fe:	a8 01       	movw	r20, r16
   10100:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	   sprintf_P(strSend,PSTR("TVolume:%s"),STotalVolume);
   10104:	00 d0       	rcall	.+0      	; 0x10106 <TestUserInput+0x316>
   10106:	00 d0       	rcall	.+0      	; 0x10108 <TestUserInput+0x318>
   10108:	00 d0       	rcall	.+0      	; 0x1010a <TestUserInput+0x31a>
   1010a:	ed b7       	in	r30, 0x3d	; 61
   1010c:	fe b7       	in	r31, 0x3e	; 62
   1010e:	31 96       	adiw	r30, 0x01	; 1
   10110:	ad b7       	in	r26, 0x3d	; 61
   10112:	be b7       	in	r27, 0x3e	; 62
   10114:	12 96       	adiw	r26, 0x02	; 2
   10116:	1c 93       	st	X, r17
   10118:	0e 93       	st	-X, r16
   1011a:	11 97       	sbiw	r26, 0x01	; 1
   1011c:	8c e9       	ldi	r24, 0x9C	; 156
   1011e:	93 e0       	ldi	r25, 0x03	; 3
   10120:	93 83       	std	Z+3, r25	; 0x03
   10122:	82 83       	std	Z+2, r24	; 0x02
   10124:	95 82       	std	Z+5, r9	; 0x05
   10126:	84 82       	std	Z+4, r8	; 0x04
   10128:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	   _uart_print(0,1,strSend);
   1012c:	8d b7       	in	r24, 0x3d	; 61
   1012e:	9e b7       	in	r25, 0x3e	; 62
   10130:	06 96       	adiw	r24, 0x06	; 6
   10132:	0f b6       	in	r0, 0x3f	; 63
   10134:	f8 94       	cli
   10136:	9e bf       	out	0x3e, r25	; 62
   10138:	0f be       	out	0x3f, r0	; 63
   1013a:	8d bf       	out	0x3d, r24	; 61
   1013c:	80 e0       	ldi	r24, 0x00	; 0
   1013e:	61 e0       	ldi	r22, 0x01	; 1
   10140:	a8 01       	movw	r20, r16
   10142:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	   sprintf_P(strSend,PSTR("TMoney:%s"),STotalMoney);
   10146:	00 d0       	rcall	.+0      	; 0x10148 <TestUserInput+0x358>
   10148:	00 d0       	rcall	.+0      	; 0x1014a <TestUserInput+0x35a>
   1014a:	00 d0       	rcall	.+0      	; 0x1014c <TestUserInput+0x35c>
   1014c:	ed b7       	in	r30, 0x3d	; 61
   1014e:	fe b7       	in	r31, 0x3e	; 62
   10150:	31 96       	adiw	r30, 0x01	; 1
   10152:	ad b7       	in	r26, 0x3d	; 61
   10154:	be b7       	in	r27, 0x3e	; 62
   10156:	12 96       	adiw	r26, 0x02	; 2
   10158:	1c 93       	st	X, r17
   1015a:	0e 93       	st	-X, r16
   1015c:	11 97       	sbiw	r26, 0x01	; 1
   1015e:	82 e9       	ldi	r24, 0x92	; 146
   10160:	93 e0       	ldi	r25, 0x03	; 3
   10162:	93 83       	std	Z+3, r25	; 0x03
   10164:	82 83       	std	Z+2, r24	; 0x02
   10166:	d5 82       	std	Z+5, r13	; 0x05
   10168:	c4 82       	std	Z+4, r12	; 0x04
   1016a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	   _uart_print(0,1,strSend);
   1016e:	8d b7       	in	r24, 0x3d	; 61
   10170:	9e b7       	in	r25, 0x3e	; 62
   10172:	06 96       	adiw	r24, 0x06	; 6
   10174:	0f b6       	in	r0, 0x3f	; 63
   10176:	f8 94       	cli
   10178:	9e bf       	out	0x3e, r25	; 62
   1017a:	0f be       	out	0x3f, r0	; 63
   1017c:	8d bf       	out	0x3d, r24	; 61
   1017e:	80 e0       	ldi	r24, 0x00	; 0
   10180:	61 e0       	ldi	r22, 0x01	; 1
   10182:	a8 01       	movw	r20, r16
   10184:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>

	   FormatCurrency(SMoney);
   10188:	c5 01       	movw	r24, r10
   1018a:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>
	   FormatCurrency(STotalMoney);
   1018e:	c6 01       	movw	r24, r12
   10190:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>
    
	   sprintf_P(strSend,PSTR("FmtMoney:%s"),SMoney);
   10194:	00 d0       	rcall	.+0      	; 0x10196 <TestUserInput+0x3a6>
   10196:	00 d0       	rcall	.+0      	; 0x10198 <TestUserInput+0x3a8>
   10198:	00 d0       	rcall	.+0      	; 0x1019a <TestUserInput+0x3aa>
   1019a:	ed b7       	in	r30, 0x3d	; 61
   1019c:	fe b7       	in	r31, 0x3e	; 62
   1019e:	31 96       	adiw	r30, 0x01	; 1
   101a0:	ad b7       	in	r26, 0x3d	; 61
   101a2:	be b7       	in	r27, 0x3e	; 62
   101a4:	12 96       	adiw	r26, 0x02	; 2
   101a6:	1c 93       	st	X, r17
   101a8:	0e 93       	st	-X, r16
   101aa:	11 97       	sbiw	r26, 0x01	; 1
   101ac:	86 e8       	ldi	r24, 0x86	; 134
   101ae:	93 e0       	ldi	r25, 0x03	; 3
   101b0:	93 83       	std	Z+3, r25	; 0x03
   101b2:	82 83       	std	Z+2, r24	; 0x02
   101b4:	b5 82       	std	Z+5, r11	; 0x05
   101b6:	a4 82       	std	Z+4, r10	; 0x04
   101b8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	   _uart_print(0,1,strSend);
   101bc:	8d b7       	in	r24, 0x3d	; 61
   101be:	9e b7       	in	r25, 0x3e	; 62
   101c0:	06 96       	adiw	r24, 0x06	; 6
   101c2:	0f b6       	in	r0, 0x3f	; 63
   101c4:	f8 94       	cli
   101c6:	9e bf       	out	0x3e, r25	; 62
   101c8:	0f be       	out	0x3f, r0	; 63
   101ca:	8d bf       	out	0x3d, r24	; 61
   101cc:	80 e0       	ldi	r24, 0x00	; 0
   101ce:	61 e0       	ldi	r22, 0x01	; 1
   101d0:	a8 01       	movw	r20, r16
   101d2:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	   sprintf_P(strSend,PSTR("FmtTMoney:%s"),STotalMoney);
   101d6:	00 d0       	rcall	.+0      	; 0x101d8 <TestUserInput+0x3e8>
   101d8:	00 d0       	rcall	.+0      	; 0x101da <TestUserInput+0x3ea>
   101da:	00 d0       	rcall	.+0      	; 0x101dc <TestUserInput+0x3ec>
   101dc:	ed b7       	in	r30, 0x3d	; 61
   101de:	fe b7       	in	r31, 0x3e	; 62
   101e0:	31 96       	adiw	r30, 0x01	; 1
   101e2:	ad b7       	in	r26, 0x3d	; 61
   101e4:	be b7       	in	r27, 0x3e	; 62
   101e6:	12 96       	adiw	r26, 0x02	; 2
   101e8:	1c 93       	st	X, r17
   101ea:	0e 93       	st	-X, r16
   101ec:	11 97       	sbiw	r26, 0x01	; 1
   101ee:	89 e7       	ldi	r24, 0x79	; 121
   101f0:	93 e0       	ldi	r25, 0x03	; 3
   101f2:	93 83       	std	Z+3, r25	; 0x03
   101f4:	82 83       	std	Z+2, r24	; 0x02
   101f6:	d5 82       	std	Z+5, r13	; 0x05
   101f8:	c4 82       	std	Z+4, r12	; 0x04
   101fa:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	   _uart_print(0,1,strSend);
   101fe:	8d b7       	in	r24, 0x3d	; 61
   10200:	9e b7       	in	r25, 0x3e	; 62
   10202:	06 96       	adiw	r24, 0x06	; 6
   10204:	0f b6       	in	r0, 0x3f	; 63
   10206:	f8 94       	cli
   10208:	9e bf       	out	0x3e, r25	; 62
   1020a:	0f be       	out	0x3f, r0	; 63
   1020c:	8d bf       	out	0x3d, r24	; 61
   1020e:	80 e0       	ldi	r24, 0x00	; 0
   10210:	61 e0       	ldi	r22, 0x01	; 1
   10212:	a8 01       	movw	r20, r16
   10214:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
   10218:	02 c0       	rjmp	.+4      	; 0x1021e <TestUserInput+0x42e>


   	
	}else    
	if (uiResult==USER_CANCEL){
   1021a:	81 30       	cpi	r24, 0x01	; 1
   1021c:	11 f0       	breq	.+4      	; 0x10222 <TestUserInput+0x432>
   1021e:	80 e0       	ldi	r24, 0x00	; 0
   10220:	0b c0       	rjmp	.+22     	; 0x10238 <TestUserInput+0x448>
	   lcd_clear();
   10222:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
   10226:	fe 01       	movw	r30, r28
   10228:	fd 96       	adiw	r30, 0x3d	; 61

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   1022a:	cf 01       	movw	r24, r30
   1022c:	0f 96       	adiw	r24, 0x0f	; 15
	     strMemory[i]=data;
   1022e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10230:	e8 17       	cp	r30, r24
   10232:	f9 07       	cpc	r31, r25
   10234:	e1 f7       	brne	.-8      	; 0x1022e <TestUserInput+0x43e>
   10236:	81 e0       	ldi	r24, 0x01	; 1
       Result=MENU_DONE;   
	   //lcd_printf(1,1,PSTR("InputNumber:"));
       //lcd_printf(2,1,PSTR("_         "));
	}
  return Result;
}
   10238:	c2 59       	subi	r28, 0x92	; 146
   1023a:	df 4f       	sbci	r29, 0xFF	; 255
   1023c:	0f b6       	in	r0, 0x3f	; 63
   1023e:	f8 94       	cli
   10240:	de bf       	out	0x3e, r29	; 62
   10242:	0f be       	out	0x3f, r0	; 63
   10244:	cd bf       	out	0x3d, r28	; 61
   10246:	cf 91       	pop	r28
   10248:	df 91       	pop	r29
   1024a:	1f 91       	pop	r17
   1024c:	0f 91       	pop	r16
   1024e:	ff 90       	pop	r15
   10250:	ef 90       	pop	r14
   10252:	df 90       	pop	r13
   10254:	cf 90       	pop	r12
   10256:	bf 90       	pop	r11
   10258:	af 90       	pop	r10
   1025a:	9f 90       	pop	r9
   1025c:	8f 90       	pop	r8
   1025e:	7f 90       	pop	r7
   10260:	6f 90       	pop	r6
   10262:	08 95       	ret

00010264 <FSettingDec>:

	Result=MENU_DONE;
	return Result;
}

char FSettingDec(){
   10264:	df 92       	push	r13
   10266:	ef 92       	push	r14
   10268:	ff 92       	push	r15
   1026a:	0f 93       	push	r16
   1026c:	1f 93       	push	r17
   1026e:	df 93       	push	r29
   10270:	cf 93       	push	r28
   10272:	cd b7       	in	r28, 0x3d	; 61
   10274:	de b7       	in	r29, 0x3e	; 62
   10276:	64 97       	sbiw	r28, 0x14	; 20
   10278:	0f b6       	in	r0, 0x3f	; 63
   1027a:	f8 94       	cli
   1027c:	de bf       	out	0x3e, r29	; 62
   1027e:	0f be       	out	0x3f, r0	; 63
   10280:	cd bf       	out	0x3d, r28	; 61
static char stSettingDecimal=sdInitDisplay;
     char PDecimalConfig[4],Addr,KeyChar,Result;
	 char lcdteks[20];

     Result=MENU_NONE;
	 switch(stSettingDecimal){
   10282:	80 91 e3 02 	lds	r24, 0x02E3
   10286:	82 30       	cpi	r24, 0x02	; 2
   10288:	09 f4       	brne	.+2      	; 0x1028c <FSettingDec+0x28>
   1028a:	c7 c0       	rjmp	.+398    	; 0x1041a <FSettingDec+0x1b6>
   1028c:	83 30       	cpi	r24, 0x03	; 3
   1028e:	30 f4       	brcc	.+12     	; 0x1029c <FSettingDec+0x38>
   10290:	88 23       	and	r24, r24
   10292:	71 f0       	breq	.+28     	; 0x102b0 <FSettingDec+0x4c>
   10294:	81 30       	cpi	r24, 0x01	; 1
   10296:	09 f0       	breq	.+2      	; 0x1029a <FSettingDec+0x36>
   10298:	c3 c1       	rjmp	.+902    	; 0x10620 <FSettingDec+0x3bc>
   1029a:	92 c0       	rjmp	.+292    	; 0x103c0 <FSettingDec+0x15c>
   1029c:	84 30       	cpi	r24, 0x04	; 4
   1029e:	09 f4       	brne	.+2      	; 0x102a2 <FSettingDec+0x3e>
   102a0:	b3 c1       	rjmp	.+870    	; 0x10608 <FSettingDec+0x3a4>
   102a2:	84 30       	cpi	r24, 0x04	; 4
   102a4:	08 f4       	brcc	.+2      	; 0x102a8 <FSettingDec+0x44>
   102a6:	68 c1       	rjmp	.+720    	; 0x10578 <FSettingDec+0x314>
   102a8:	85 30       	cpi	r24, 0x05	; 5
   102aa:	09 f0       	breq	.+2      	; 0x102ae <FSettingDec+0x4a>
   102ac:	b9 c1       	rjmp	.+882    	; 0x10620 <FSettingDec+0x3bc>
   102ae:	b4 c1       	rjmp	.+872    	; 0x10618 <FSettingDec+0x3b4>
	 case sdInitDisplay:
	      lcd_clear();         //"12345678901234567890
   102b0:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   102b4:	e1 99       	sbic	0x1c, 1	; 28
   102b6:	fe cf       	rjmp	.-4      	; 0x102b4 <FSettingDec+0x50>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   102b8:	89 e3       	ldi	r24, 0x39	; 57
   102ba:	90 e0       	ldi	r25, 0x00	; 0
   102bc:	9f bb       	out	0x1f, r25	; 31
   102be:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   102c0:	e0 9a       	sbi	0x1c, 0	; 28
   102c2:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   102c4:	e1 99       	sbic	0x1c, 1	; 28
   102c6:	fe cf       	rjmp	.-4      	; 0x102c4 <FSettingDec+0x60>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   102c8:	8a e3       	ldi	r24, 0x3A	; 58
   102ca:	90 e0       	ldi	r25, 0x00	; 0
   102cc:	9f bb       	out	0x1f, r25	; 31
   102ce:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   102d0:	e0 9a       	sbi	0x1c, 0	; 28
   102d2:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   102d4:	e1 99       	sbic	0x1c, 1	; 28
   102d6:	fe cf       	rjmp	.-4      	; 0x102d4 <FSettingDec+0x70>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   102d8:	8b e3       	ldi	r24, 0x3B	; 59
   102da:	90 e0       	ldi	r25, 0x00	; 0
   102dc:	9f bb       	out	0x1f, r25	; 31
   102de:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   102e0:	e0 9a       	sbi	0x1c, 0	; 28
   102e2:	fd b2       	in	r15, 0x1d	; 29
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalPrice);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalVolume);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMoney);

		  sprintf_P(lcdteks,PSTR("1.Price :%d"),PDecimalConfig[0]);
   102e4:	00 d0       	rcall	.+0      	; 0x102e6 <FSettingDec+0x82>
   102e6:	00 d0       	rcall	.+0      	; 0x102e8 <FSettingDec+0x84>
   102e8:	00 d0       	rcall	.+0      	; 0x102ea <FSettingDec+0x86>
   102ea:	ed b7       	in	r30, 0x3d	; 61
   102ec:	fe b7       	in	r31, 0x3e	; 62
   102ee:	31 96       	adiw	r30, 0x01	; 1
   102f0:	8e 01       	movw	r16, r28
   102f2:	0f 5f       	subi	r16, 0xFF	; 255
   102f4:	1f 4f       	sbci	r17, 0xFF	; 255
   102f6:	ad b7       	in	r26, 0x3d	; 61
   102f8:	be b7       	in	r27, 0x3e	; 62
   102fa:	12 96       	adiw	r26, 0x02	; 2
   102fc:	1c 93       	st	X, r17
   102fe:	0e 93       	st	-X, r16
   10300:	11 97       	sbiw	r26, 0x01	; 1
   10302:	8a e1       	ldi	r24, 0x1A	; 26
   10304:	91 e1       	ldi	r25, 0x11	; 17
   10306:	93 83       	std	Z+3, r25	; 0x03
   10308:	82 83       	std	Z+2, r24	; 0x02
   1030a:	24 83       	std	Z+4, r18	; 0x04
   1030c:	15 82       	std	Z+5, r1	; 0x05
   1030e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   10312:	8d b7       	in	r24, 0x3d	; 61
   10314:	9e b7       	in	r25, 0x3e	; 62
   10316:	06 96       	adiw	r24, 0x06	; 6
   10318:	0f b6       	in	r0, 0x3f	; 63
   1031a:	f8 94       	cli
   1031c:	9e bf       	out	0x3e, r25	; 62
   1031e:	0f be       	out	0x3f, r0	; 63
   10320:	8d bf       	out	0x3d, r24	; 61
   10322:	81 e0       	ldi	r24, 0x01	; 1
   10324:	61 e0       	ldi	r22, 0x01	; 1
   10326:	a8 01       	movw	r20, r16
   10328:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.Volume:%d"),PDecimalConfig[1]);
   1032c:	00 d0       	rcall	.+0      	; 0x1032e <FSettingDec+0xca>
   1032e:	00 d0       	rcall	.+0      	; 0x10330 <FSettingDec+0xcc>
   10330:	00 d0       	rcall	.+0      	; 0x10332 <FSettingDec+0xce>
   10332:	ed b7       	in	r30, 0x3d	; 61
   10334:	fe b7       	in	r31, 0x3e	; 62
   10336:	31 96       	adiw	r30, 0x01	; 1
   10338:	ad b7       	in	r26, 0x3d	; 61
   1033a:	be b7       	in	r27, 0x3e	; 62
   1033c:	12 96       	adiw	r26, 0x02	; 2
   1033e:	1c 93       	st	X, r17
   10340:	0e 93       	st	-X, r16
   10342:	11 97       	sbiw	r26, 0x01	; 1
   10344:	8e e0       	ldi	r24, 0x0E	; 14
   10346:	91 e1       	ldi	r25, 0x11	; 17
   10348:	93 83       	std	Z+3, r25	; 0x03
   1034a:	82 83       	std	Z+2, r24	; 0x02
   1034c:	e4 82       	std	Z+4, r14	; 0x04
   1034e:	15 82       	std	Z+5, r1	; 0x05
   10350:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   10354:	8d b7       	in	r24, 0x3d	; 61
   10356:	9e b7       	in	r25, 0x3e	; 62
   10358:	06 96       	adiw	r24, 0x06	; 6
   1035a:	0f b6       	in	r0, 0x3f	; 63
   1035c:	f8 94       	cli
   1035e:	9e bf       	out	0x3e, r25	; 62
   10360:	0f be       	out	0x3f, r0	; 63
   10362:	8d bf       	out	0x3d, r24	; 61
   10364:	82 e0       	ldi	r24, 0x02	; 2
   10366:	61 e0       	ldi	r22, 0x01	; 1
   10368:	a8 01       	movw	r20, r16
   1036a:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Money :%d"),PDecimalConfig[2]);
   1036e:	00 d0       	rcall	.+0      	; 0x10370 <FSettingDec+0x10c>
   10370:	00 d0       	rcall	.+0      	; 0x10372 <FSettingDec+0x10e>
   10372:	00 d0       	rcall	.+0      	; 0x10374 <FSettingDec+0x110>
   10374:	ed b7       	in	r30, 0x3d	; 61
   10376:	fe b7       	in	r31, 0x3e	; 62
   10378:	31 96       	adiw	r30, 0x01	; 1
   1037a:	ad b7       	in	r26, 0x3d	; 61
   1037c:	be b7       	in	r27, 0x3e	; 62
   1037e:	12 96       	adiw	r26, 0x02	; 2
   10380:	1c 93       	st	X, r17
   10382:	0e 93       	st	-X, r16
   10384:	11 97       	sbiw	r26, 0x01	; 1
   10386:	82 e0       	ldi	r24, 0x02	; 2
   10388:	91 e1       	ldi	r25, 0x11	; 17
   1038a:	93 83       	std	Z+3, r25	; 0x03
   1038c:	82 83       	std	Z+2, r24	; 0x02
   1038e:	f4 82       	std	Z+4, r15	; 0x04
   10390:	15 82       	std	Z+5, r1	; 0x05
   10392:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   10396:	8d b7       	in	r24, 0x3d	; 61
   10398:	9e b7       	in	r25, 0x3e	; 62
   1039a:	06 96       	adiw	r24, 0x06	; 6
   1039c:	0f b6       	in	r0, 0x3f	; 63
   1039e:	f8 94       	cli
   103a0:	9e bf       	out	0x3e, r25	; 62
   103a2:	0f be       	out	0x3f, r0	; 63
   103a4:	8d bf       	out	0x3d, r24	; 61
   103a6:	83 e0       	ldi	r24, 0x03	; 3
   103a8:	61 e0       	ldi	r22, 0x01	; 1
   103aa:	a8 01       	movw	r20, r16
   103ac:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]Back  [#]Next"));
   103b0:	84 e0       	ldi	r24, 0x04	; 4
   103b2:	61 e0       	ldi	r22, 0x01	; 1
   103b4:	41 ef       	ldi	r20, 0xF1	; 241
   103b6:	50 e1       	ldi	r21, 0x10	; 16
   103b8:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  stSettingDecimal=sdSelectKey1;
   103bc:	81 e0       	ldi	r24, 0x01	; 1
   103be:	29 c1       	rjmp	.+594    	; 0x10612 <FSettingDec+0x3ae>
		  break;
     case sdSelectKey1:
          KeyChar=_key_btn(_key_scan(1));
   103c0:	81 e0       	ldi	r24, 0x01	; 1
   103c2:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   103c6:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='3')){
   103ca:	98 2f       	mov	r25, r24
   103cc:	91 53       	subi	r25, 0x31	; 49
   103ce:	93 30       	cpi	r25, 0x03	; 3
   103d0:	e0 f4       	brcc	.+56     	; 0x1040a <FSettingDec+0x1a6>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalPrice+Addr);
   103d2:	29 2f       	mov	r18, r25
   103d4:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   103d6:	e1 99       	sbic	0x1c, 1	; 28
   103d8:	fe cf       	rjmp	.-4      	; 0x103d6 <FSettingDec+0x172>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   103da:	c9 01       	movw	r24, r18
   103dc:	87 5c       	subi	r24, 0xC7	; 199
   103de:	9f 4f       	sbci	r25, 0xFF	; 255
   103e0:	9f bb       	out	0x1f, r25	; 31
   103e2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   103e4:	e0 9a       	sbi	0x1c, 0	; 28
   103e6:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   103e8:	e1 99       	sbic	0x1c, 1	; 28
   103ea:	fe cf       	rjmp	.-4      	; 0x103e8 <FSettingDec+0x184>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   103ec:	27 5c       	subi	r18, 0xC7	; 199
   103ee:	3f 4f       	sbci	r19, 0xFF	; 255
   103f0:	3f bb       	out	0x1f, r19	; 31
   103f2:	2e bb       	out	0x1e, r18	; 30
			  PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
   103f4:	90 e0       	ldi	r25, 0x00	; 0
   103f6:	01 96       	adiw	r24, 0x01	; 1
   103f8:	83 70       	andi	r24, 0x03	; 3
   103fa:	90 70       	andi	r25, 0x00	; 0
#endif
    EEDR = __value;
   103fc:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   103fe:	0f b6       	in	r0, 0x3f	; 63
   10400:	f8 94       	cli
   10402:	e2 9a       	sbi	0x1c, 2	; 28
   10404:	e1 9a       	sbi	0x1c, 1	; 28
   10406:	0f be       	out	0x3f, r0	; 63
   10408:	f6 c0       	rjmp	.+492    	; 0x105f6 <FSettingDec+0x392>

			  eeprom_write_byte(&DefDecimalPrice+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay;
		  }else if (KeyChar=='*') stSettingDecimal=sdExitSettingDecimal;
   1040a:	8a 32       	cpi	r24, 0x2A	; 42
   1040c:	11 f4       	brne	.+4      	; 0x10412 <FSettingDec+0x1ae>
   1040e:	85 e0       	ldi	r24, 0x05	; 5
   10410:	00 c1       	rjmp	.+512    	; 0x10612 <FSettingDec+0x3ae>
		  else if (KeyChar=='#') stSettingDecimal=sdInitDisplay2;
   10412:	83 32       	cpi	r24, 0x23	; 35
   10414:	09 f0       	breq	.+2      	; 0x10418 <FSettingDec+0x1b4>
   10416:	04 c1       	rjmp	.+520    	; 0x10620 <FSettingDec+0x3bc>
   10418:	fb c0       	rjmp	.+502    	; 0x10610 <FSettingDec+0x3ac>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1041a:	e1 99       	sbic	0x1c, 1	; 28
   1041c:	fe cf       	rjmp	.-4      	; 0x1041a <FSettingDec+0x1b6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1041e:	8c e3       	ldi	r24, 0x3C	; 60
   10420:	90 e0       	ldi	r25, 0x00	; 0
   10422:	9f bb       	out	0x1f, r25	; 31
   10424:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10426:	e0 9a       	sbi	0x1c, 0	; 28
   10428:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1042a:	e1 99       	sbic	0x1c, 1	; 28
   1042c:	fe cf       	rjmp	.-4      	; 0x1042a <FSettingDec+0x1c6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1042e:	8d e3       	ldi	r24, 0x3D	; 61
   10430:	90 e0       	ldi	r25, 0x00	; 0
   10432:	9f bb       	out	0x1f, r25	; 31
   10434:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10436:	e0 9a       	sbi	0x1c, 0	; 28
   10438:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1043a:	e1 99       	sbic	0x1c, 1	; 28
   1043c:	fe cf       	rjmp	.-4      	; 0x1043a <FSettingDec+0x1d6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1043e:	8e e3       	ldi	r24, 0x3E	; 62
   10440:	90 e0       	ldi	r25, 0x00	; 0
   10442:	9f bb       	out	0x1f, r25	; 31
   10444:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10446:	e0 9a       	sbi	0x1c, 0	; 28
   10448:	dd b2       	in	r13, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1044a:	e1 99       	sbic	0x1c, 1	; 28
   1044c:	fe cf       	rjmp	.-4      	; 0x1044a <FSettingDec+0x1e6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1044e:	8f e3       	ldi	r24, 0x3F	; 63
   10450:	90 e0       	ldi	r25, 0x00	; 0
   10452:	9f bb       	out	0x1f, r25	; 31
   10454:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10456:	e0 9a       	sbi	0x1c, 0	; 28
   10458:	fd b2       	in	r15, 0x1d	; 29
     case sdInitDisplay2:
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalTotalVolume);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalTotalMoney);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMark);
		  PDecimalConfig[3]=eeprom_read_byte(&DefCurrencyMark);
		  sprintf_P(lcdteks,PSTR("1.T.Volume:%d  5.Test"),PDecimalConfig[0]);
   1045a:	00 d0       	rcall	.+0      	; 0x1045c <FSettingDec+0x1f8>
   1045c:	00 d0       	rcall	.+0      	; 0x1045e <FSettingDec+0x1fa>
   1045e:	00 d0       	rcall	.+0      	; 0x10460 <FSettingDec+0x1fc>
   10460:	ed b7       	in	r30, 0x3d	; 61
   10462:	fe b7       	in	r31, 0x3e	; 62
   10464:	31 96       	adiw	r30, 0x01	; 1
   10466:	8e 01       	movw	r16, r28
   10468:	0f 5f       	subi	r16, 0xFF	; 255
   1046a:	1f 4f       	sbci	r17, 0xFF	; 255
   1046c:	ad b7       	in	r26, 0x3d	; 61
   1046e:	be b7       	in	r27, 0x3e	; 62
   10470:	12 96       	adiw	r26, 0x02	; 2
   10472:	1c 93       	st	X, r17
   10474:	0e 93       	st	-X, r16
   10476:	11 97       	sbiw	r26, 0x01	; 1
   10478:	8b ed       	ldi	r24, 0xDB	; 219
   1047a:	90 e1       	ldi	r25, 0x10	; 16
   1047c:	93 83       	std	Z+3, r25	; 0x03
   1047e:	82 83       	std	Z+2, r24	; 0x02
   10480:	24 83       	std	Z+4, r18	; 0x04
   10482:	15 82       	std	Z+5, r1	; 0x05
   10484:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   10488:	8d b7       	in	r24, 0x3d	; 61
   1048a:	9e b7       	in	r25, 0x3e	; 62
   1048c:	06 96       	adiw	r24, 0x06	; 6
   1048e:	0f b6       	in	r0, 0x3f	; 63
   10490:	f8 94       	cli
   10492:	9e bf       	out	0x3e, r25	; 62
   10494:	0f be       	out	0x3f, r0	; 63
   10496:	8d bf       	out	0x3d, r24	; 61
   10498:	81 e0       	ldi	r24, 0x01	; 1
   1049a:	61 e0       	ldi	r22, 0x01	; 1
   1049c:	a8 01       	movw	r20, r16
   1049e:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.T.Money :%d "),PDecimalConfig[1]);
   104a2:	00 d0       	rcall	.+0      	; 0x104a4 <FSettingDec+0x240>
   104a4:	00 d0       	rcall	.+0      	; 0x104a6 <FSettingDec+0x242>
   104a6:	00 d0       	rcall	.+0      	; 0x104a8 <FSettingDec+0x244>
   104a8:	ed b7       	in	r30, 0x3d	; 61
   104aa:	fe b7       	in	r31, 0x3e	; 62
   104ac:	31 96       	adiw	r30, 0x01	; 1
   104ae:	ad b7       	in	r26, 0x3d	; 61
   104b0:	be b7       	in	r27, 0x3e	; 62
   104b2:	12 96       	adiw	r26, 0x02	; 2
   104b4:	1c 93       	st	X, r17
   104b6:	0e 93       	st	-X, r16
   104b8:	11 97       	sbiw	r26, 0x01	; 1
   104ba:	8c ec       	ldi	r24, 0xCC	; 204
   104bc:	90 e1       	ldi	r25, 0x10	; 16
   104be:	93 83       	std	Z+3, r25	; 0x03
   104c0:	82 83       	std	Z+2, r24	; 0x02
   104c2:	e4 82       	std	Z+4, r14	; 0x04
   104c4:	15 82       	std	Z+5, r1	; 0x05
   104c6:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   104ca:	8d b7       	in	r24, 0x3d	; 61
   104cc:	9e b7       	in	r25, 0x3e	; 62
   104ce:	06 96       	adiw	r24, 0x06	; 6
   104d0:	0f b6       	in	r0, 0x3f	; 63
   104d2:	f8 94       	cli
   104d4:	9e bf       	out	0x3e, r25	; 62
   104d6:	0f be       	out	0x3f, r0	; 63
   104d8:	8d bf       	out	0x3d, r24	; 61
   104da:	82 e0       	ldi	r24, 0x02	; 2
   104dc:	61 e0       	ldi	r22, 0x01	; 1
   104de:	a8 01       	movw	r20, r16
   104e0:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Decimal :%c "),PDecimalConfig[2]);
   104e4:	00 d0       	rcall	.+0      	; 0x104e6 <FSettingDec+0x282>
   104e6:	00 d0       	rcall	.+0      	; 0x104e8 <FSettingDec+0x284>
   104e8:	00 d0       	rcall	.+0      	; 0x104ea <FSettingDec+0x286>
   104ea:	ed b7       	in	r30, 0x3d	; 61
   104ec:	fe b7       	in	r31, 0x3e	; 62
   104ee:	31 96       	adiw	r30, 0x01	; 1
   104f0:	ad b7       	in	r26, 0x3d	; 61
   104f2:	be b7       	in	r27, 0x3e	; 62
   104f4:	12 96       	adiw	r26, 0x02	; 2
   104f6:	1c 93       	st	X, r17
   104f8:	0e 93       	st	-X, r16
   104fa:	11 97       	sbiw	r26, 0x01	; 1
   104fc:	8d eb       	ldi	r24, 0xBD	; 189
   104fe:	90 e1       	ldi	r25, 0x10	; 16
   10500:	93 83       	std	Z+3, r25	; 0x03
   10502:	82 83       	std	Z+2, r24	; 0x02
   10504:	d4 82       	std	Z+4, r13	; 0x04
   10506:	15 82       	std	Z+5, r1	; 0x05
   10508:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   1050c:	8d b7       	in	r24, 0x3d	; 61
   1050e:	9e b7       	in	r25, 0x3e	; 62
   10510:	06 96       	adiw	r24, 0x06	; 6
   10512:	0f b6       	in	r0, 0x3f	; 63
   10514:	f8 94       	cli
   10516:	9e bf       	out	0x3e, r25	; 62
   10518:	0f be       	out	0x3f, r0	; 63
   1051a:	8d bf       	out	0x3d, r24	; 61
   1051c:	83 e0       	ldi	r24, 0x03	; 3
   1051e:	61 e0       	ldi	r22, 0x01	; 1
   10520:	a8 01       	movw	r20, r16
   10522:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  sprintf_P(lcdteks,PSTR("4.Sparator:%c "),PDecimalConfig[3]);
   10526:	00 d0       	rcall	.+0      	; 0x10528 <FSettingDec+0x2c4>
   10528:	00 d0       	rcall	.+0      	; 0x1052a <FSettingDec+0x2c6>
   1052a:	00 d0       	rcall	.+0      	; 0x1052c <FSettingDec+0x2c8>
   1052c:	ed b7       	in	r30, 0x3d	; 61
   1052e:	fe b7       	in	r31, 0x3e	; 62
   10530:	31 96       	adiw	r30, 0x01	; 1
   10532:	ad b7       	in	r26, 0x3d	; 61
   10534:	be b7       	in	r27, 0x3e	; 62
   10536:	12 96       	adiw	r26, 0x02	; 2
   10538:	1c 93       	st	X, r17
   1053a:	0e 93       	st	-X, r16
   1053c:	11 97       	sbiw	r26, 0x01	; 1
   1053e:	8e ea       	ldi	r24, 0xAE	; 174
   10540:	90 e1       	ldi	r25, 0x10	; 16
   10542:	93 83       	std	Z+3, r25	; 0x03
   10544:	82 83       	std	Z+2, r24	; 0x02
   10546:	f4 82       	std	Z+4, r15	; 0x04
   10548:	15 82       	std	Z+5, r1	; 0x05
   1054a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(4,1,lcdteks);
   1054e:	8d b7       	in	r24, 0x3d	; 61
   10550:	9e b7       	in	r25, 0x3e	; 62
   10552:	06 96       	adiw	r24, 0x06	; 6
   10554:	0f b6       	in	r0, 0x3f	; 63
   10556:	f8 94       	cli
   10558:	9e bf       	out	0x3e, r25	; 62
   1055a:	0f be       	out	0x3f, r0	; 63
   1055c:	8d bf       	out	0x3d, r24	; 61
   1055e:	84 e0       	ldi	r24, 0x04	; 4
   10560:	61 e0       	ldi	r22, 0x01	; 1
   10562:	a8 01       	movw	r20, r16
   10564:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_printf(4,14,PSTR("*)Back"));
   10568:	84 e0       	ldi	r24, 0x04	; 4
   1056a:	6e e0       	ldi	r22, 0x0E	; 14
   1056c:	47 ea       	ldi	r20, 0xA7	; 167
   1056e:	50 e1       	ldi	r21, 0x10	; 16
   10570:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	      stSettingDecimal=sdSelectKey2;
   10574:	83 e0       	ldi	r24, 0x03	; 3
   10576:	4d c0       	rjmp	.+154    	; 0x10612 <FSettingDec+0x3ae>
	      break;
     case sdSelectKey2:
          KeyChar=_key_btn(_key_scan(1));
   10578:	81 e0       	ldi	r24, 0x01	; 1
   1057a:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   1057e:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   10582:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
   10584:	98 2f       	mov	r25, r24
   10586:	91 53       	subi	r25, 0x31	; 49
   10588:	92 30       	cpi	r25, 0x02	; 2
   1058a:	b0 f4       	brcc	.+44     	; 0x105b8 <FSettingDec+0x354>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
   1058c:	29 2f       	mov	r18, r25
   1058e:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10590:	e1 99       	sbic	0x1c, 1	; 28
   10592:	fe cf       	rjmp	.-4      	; 0x10590 <FSettingDec+0x32c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10594:	c9 01       	movw	r24, r18
   10596:	84 5c       	subi	r24, 0xC4	; 196
   10598:	9f 4f       	sbci	r25, 0xFF	; 255
   1059a:	9f bb       	out	0x1f, r25	; 31
   1059c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1059e:	e0 9a       	sbi	0x1c, 0	; 28
   105a0:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   105a2:	e1 99       	sbic	0x1c, 1	; 28
   105a4:	fe cf       	rjmp	.-4      	; 0x105a2 <FSettingDec+0x33e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   105a6:	24 5c       	subi	r18, 0xC4	; 196
   105a8:	3f 4f       	sbci	r19, 0xFF	; 255
   105aa:	3f bb       	out	0x1f, r19	; 31
   105ac:	2e bb       	out	0x1e, r18	; 30
		      PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
   105ae:	90 e0       	ldi	r25, 0x00	; 0
   105b0:	01 96       	adiw	r24, 0x01	; 1
   105b2:	83 70       	andi	r24, 0x03	; 3
   105b4:	90 70       	andi	r25, 0x00	; 0
   105b6:	16 c0       	rjmp	.+44     	; 0x105e4 <FSettingDec+0x380>

			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if ((KeyChar>='3')&&(KeyChar<='4')){
   105b8:	83 53       	subi	r24, 0x33	; 51
   105ba:	82 30       	cpi	r24, 0x02	; 2
   105bc:	d0 f4       	brcc	.+52     	; 0x105f2 <FSettingDec+0x38e>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
   105be:	09 2f       	mov	r16, r25
   105c0:	10 e0       	ldi	r17, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   105c2:	e1 99       	sbic	0x1c, 1	; 28
   105c4:	fe cf       	rjmp	.-4      	; 0x105c2 <FSettingDec+0x35e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   105c6:	c8 01       	movw	r24, r16
   105c8:	84 5c       	subi	r24, 0xC4	; 196
   105ca:	9f 4f       	sbci	r25, 0xFF	; 255
   105cc:	9f bb       	out	0x1f, r25	; 31
   105ce:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   105d0:	e0 9a       	sbi	0x1c, 0	; 28
   105d2:	8d b3       	in	r24, 0x1d	; 29
			  PDecimalConfig[Addr]=SelectMark(PDecimalConfig[Addr]);
   105d4:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <SelectMark>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   105d8:	e1 99       	sbic	0x1c, 1	; 28
   105da:	fe cf       	rjmp	.-4      	; 0x105d8 <FSettingDec+0x374>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   105dc:	04 5c       	subi	r16, 0xC4	; 196
   105de:	1f 4f       	sbci	r17, 0xFF	; 255
   105e0:	1f bb       	out	0x1f, r17	; 31
   105e2:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   105e4:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   105e6:	0f b6       	in	r0, 0x3f	; 63
   105e8:	f8 94       	cli
   105ea:	e2 9a       	sbi	0x1c, 2	; 28
   105ec:	e1 9a       	sbi	0x1c, 1	; 28
   105ee:	0f be       	out	0x3f, r0	; 63
   105f0:	0f c0       	rjmp	.+30     	; 0x10610 <FSettingDec+0x3ac>
			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if (KeyChar=='*') stSettingDecimal=sdInitDisplay;
   105f2:	2a 32       	cpi	r18, 0x2A	; 42
   105f4:	19 f4       	brne	.+6      	; 0x105fc <FSettingDec+0x398>
   105f6:	10 92 e3 02 	sts	0x02E3, r1
   105fa:	12 c0       	rjmp	.+36     	; 0x10620 <FSettingDec+0x3bc>
		  else if (KeyChar=='5'){
   105fc:	25 33       	cpi	r18, 0x35	; 53
   105fe:	81 f4       	brne	.+32     	; 0x10620 <FSettingDec+0x3bc>
		          lcd_clear();
   10600:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		          stSettingDecimal=sdTestInput;
   10604:	84 e0       	ldi	r24, 0x04	; 4
   10606:	05 c0       	rjmp	.+10     	; 0x10612 <FSettingDec+0x3ae>
				  }
          break;
     case sdTestInput:
	      if (TestUserInput()==MENU_DONE)stSettingDecimal=sdInitDisplay2;
   10608:	0e 94 f8 7e 	call	0xfdf0	; 0xfdf0 <TestUserInput>
   1060c:	81 30       	cpi	r24, 0x01	; 1
   1060e:	41 f4       	brne	.+16     	; 0x10620 <FSettingDec+0x3bc>
   10610:	82 e0       	ldi	r24, 0x02	; 2
   10612:	80 93 e3 02 	sts	0x02E3, r24
   10616:	04 c0       	rjmp	.+8      	; 0x10620 <FSettingDec+0x3bc>
	      break;
	 case sdExitSettingDecimal:
          stSettingDecimal=sdInitDisplay;
   10618:	10 92 e3 02 	sts	0x02E3, r1
   1061c:	81 e0       	ldi	r24, 0x01	; 1
   1061e:	01 c0       	rjmp	.+2      	; 0x10622 <FSettingDec+0x3be>
   10620:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
    return Result;
}
   10622:	64 96       	adiw	r28, 0x14	; 20
   10624:	0f b6       	in	r0, 0x3f	; 63
   10626:	f8 94       	cli
   10628:	de bf       	out	0x3e, r29	; 62
   1062a:	0f be       	out	0x3f, r0	; 63
   1062c:	cd bf       	out	0x3d, r28	; 61
   1062e:	cf 91       	pop	r28
   10630:	df 91       	pop	r29
   10632:	1f 91       	pop	r17
   10634:	0f 91       	pop	r16
   10636:	ff 90       	pop	r15
   10638:	ef 90       	pop	r14
   1063a:	df 90       	pop	r13
   1063c:	08 95       	ret

0001063e <FTestCalculation>:
	 }
  return Result;
}


void FTestCalculation(){
   1063e:	cf 92       	push	r12
   10640:	df 92       	push	r13
   10642:	ef 92       	push	r14
   10644:	ff 92       	push	r15
   10646:	0f 93       	push	r16
   10648:	1f 93       	push	r17
   1064a:	df 93       	push	r29
   1064c:	cf 93       	push	r28
   1064e:	cd b7       	in	r28, 0x3d	; 61
   10650:	de b7       	in	r29, 0x3e	; 62
   10652:	64 97       	sbiw	r28, 0x14	; 20
   10654:	0f b6       	in	r0, 0x3f	; 63
   10656:	f8 94       	cli
   10658:	de bf       	out	0x3e, r29	; 62
   1065a:	0f be       	out	0x3f, r0	; 63
   1065c:	cd bf       	out	0x3d, r28	; 61
static char stTestCalc=tcInitData,uiResult=USER_NONE;
static char InputA[20],InputB[20],OutputC[20];
     char lcdteks[20],KeyChar;
     
	 switch(stTestCalc){
   1065e:	80 91 52 02 	lds	r24, 0x0252
   10662:	82 30       	cpi	r24, 0x02	; 2
   10664:	09 f4       	brne	.+2      	; 0x10668 <FTestCalculation+0x2a>
   10666:	4b c0       	rjmp	.+150    	; 0x106fe <FTestCalculation+0xc0>
   10668:	83 30       	cpi	r24, 0x03	; 3
   1066a:	30 f4       	brcc	.+12     	; 0x10678 <FTestCalculation+0x3a>
   1066c:	88 23       	and	r24, r24
   1066e:	71 f0       	breq	.+28     	; 0x1068c <FTestCalculation+0x4e>
   10670:	81 30       	cpi	r24, 0x01	; 1
   10672:	09 f0       	breq	.+2      	; 0x10676 <FTestCalculation+0x38>
   10674:	e7 c0       	rjmp	.+462    	; 0x10844 <FTestCalculation+0x206>
   10676:	2f c0       	rjmp	.+94     	; 0x106d6 <FTestCalculation+0x98>
   10678:	84 30       	cpi	r24, 0x04	; 4
   1067a:	09 f4       	brne	.+2      	; 0x1067e <FTestCalculation+0x40>
   1067c:	82 c0       	rjmp	.+260    	; 0x10782 <FTestCalculation+0x144>
   1067e:	84 30       	cpi	r24, 0x04	; 4
   10680:	08 f4       	brcc	.+2      	; 0x10684 <FTestCalculation+0x46>
   10682:	6d c0       	rjmp	.+218    	; 0x1075e <FTestCalculation+0x120>
   10684:	85 30       	cpi	r24, 0x05	; 5
   10686:	09 f0       	breq	.+2      	; 0x1068a <FTestCalculation+0x4c>
   10688:	dd c0       	rjmp	.+442    	; 0x10844 <FTestCalculation+0x206>
   1068a:	d1 c0       	rjmp	.+418    	; 0x1082e <FTestCalculation+0x1f0>
	 case tcInitData:
	      lcd_clear();
   1068c:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("Operation Multiply"));
   10690:	81 e0       	ldi	r24, 0x01	; 1
   10692:	61 e0       	ldi	r22, 0x01	; 1
   10694:	45 ed       	ldi	r20, 0xD5	; 213
   10696:	55 e0       	ldi	r21, 0x05	; 5
   10698:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2,1,PSTR("InA:_"));
   1069c:	82 e0       	ldi	r24, 0x02	; 2
   1069e:	61 e0       	ldi	r22, 0x01	; 1
   106a0:	4f ec       	ldi	r20, 0xCF	; 207
   106a2:	55 e0       	ldi	r21, 0x05	; 5
   106a4:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   106a8:	ad e3       	ldi	r26, 0x3D	; 61
   106aa:	b2 e0       	ldi	r27, 0x02	; 2
   106ac:	fd 01       	movw	r30, r26
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   106ae:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   106b0:	82 e0       	ldi	r24, 0x02	; 2
   106b2:	e1 35       	cpi	r30, 0x51	; 81
   106b4:	f8 07       	cpc	r31, r24
   106b6:	d9 f7       	brne	.-10     	; 0x106ae <FTestCalculation+0x70>
   106b8:	74 97       	sbiw	r30, 0x14	; 20
	     strMemory[i]=data;
   106ba:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   106bc:	92 e0       	ldi	r25, 0x02	; 2
   106be:	e1 35       	cpi	r30, 0x51	; 81
   106c0:	f9 07       	cpc	r31, r25
   106c2:	d9 f7       	brne	.-10     	; 0x106ba <FTestCalculation+0x7c>
	     strMemory[i]=data;
   106c4:	1d 92       	st	X+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   106c6:	82 e0       	ldi	r24, 0x02	; 2
   106c8:	a1 35       	cpi	r26, 0x51	; 81
   106ca:	b8 07       	cpc	r27, r24
   106cc:	d9 f7       	brne	.-10     	; 0x106c4 <FTestCalculation+0x86>
		  lcd_printf(2,1,PSTR("InA:_"));
		  FillChar(InputA,sizeof(InputA),0);
		  FillChar(InputA,sizeof(InputB),0);
		  FillChar(InputA,sizeof(OutputC),0);

		  uiResult=USER_NONE;
   106ce:	10 92 51 02 	sts	0x0251, r1
          stTestCalc=tcInputA;
   106d2:	81 e0       	ldi	r24, 0x01	; 1
   106d4:	11 c0       	rjmp	.+34     	; 0x106f8 <FTestCalculation+0xba>
	      break;
     case tcInputA:
	      uiResult=UserInput(UI_ALPHANUM_R,2,5,InputA,0,15);
   106d6:	83 e0       	ldi	r24, 0x03	; 3
   106d8:	62 e0       	ldi	r22, 0x02	; 2
   106da:	45 e0       	ldi	r20, 0x05	; 5
   106dc:	2d e3       	ldi	r18, 0x3D	; 61
   106de:	32 e0       	ldi	r19, 0x02	; 2
   106e0:	00 e0       	ldi	r16, 0x00	; 0
   106e2:	10 e0       	ldi	r17, 0x00	; 0
   106e4:	9f e0       	ldi	r25, 0x0F	; 15
   106e6:	e9 2e       	mov	r14, r25
   106e8:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
   106ec:	80 93 51 02 	sts	0x0251, r24
	      if (uiResult==USER_OK)stTestCalc=tcDispInputA;
   106f0:	83 30       	cpi	r24, 0x03	; 3
   106f2:	09 f0       	breq	.+2      	; 0x106f6 <FTestCalculation+0xb8>
   106f4:	a7 c0       	rjmp	.+334    	; 0x10844 <FTestCalculation+0x206>
   106f6:	82 e0       	ldi	r24, 0x02	; 2
   106f8:	80 93 52 02 	sts	0x0252, r24
   106fc:	a3 c0       	rjmp	.+326    	; 0x10844 <FTestCalculation+0x206>
	      break;
     case tcDispInputA:
	      sprintf_P(lcdteks,PSTR("InA:%s"),InputA);
   106fe:	00 d0       	rcall	.+0      	; 0x10700 <FTestCalculation+0xc2>
   10700:	00 d0       	rcall	.+0      	; 0x10702 <FTestCalculation+0xc4>
   10702:	00 d0       	rcall	.+0      	; 0x10704 <FTestCalculation+0xc6>
   10704:	ed b7       	in	r30, 0x3d	; 61
   10706:	fe b7       	in	r31, 0x3e	; 62
   10708:	31 96       	adiw	r30, 0x01	; 1
   1070a:	8e 01       	movw	r16, r28
   1070c:	0f 5f       	subi	r16, 0xFF	; 255
   1070e:	1f 4f       	sbci	r17, 0xFF	; 255
   10710:	ad b7       	in	r26, 0x3d	; 61
   10712:	be b7       	in	r27, 0x3e	; 62
   10714:	12 96       	adiw	r26, 0x02	; 2
   10716:	1c 93       	st	X, r17
   10718:	0e 93       	st	-X, r16
   1071a:	11 97       	sbiw	r26, 0x01	; 1
   1071c:	88 ec       	ldi	r24, 0xC8	; 200
   1071e:	95 e0       	ldi	r25, 0x05	; 5
   10720:	93 83       	std	Z+3, r25	; 0x03
   10722:	82 83       	std	Z+2, r24	; 0x02
   10724:	8d e3       	ldi	r24, 0x3D	; 61
   10726:	92 e0       	ldi	r25, 0x02	; 2
   10728:	95 83       	std	Z+5, r25	; 0x05
   1072a:	84 83       	std	Z+4, r24	; 0x04
   1072c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   10730:	8d b7       	in	r24, 0x3d	; 61
   10732:	9e b7       	in	r25, 0x3e	; 62
   10734:	06 96       	adiw	r24, 0x06	; 6
   10736:	0f b6       	in	r0, 0x3f	; 63
   10738:	f8 94       	cli
   1073a:	9e bf       	out	0x3e, r25	; 62
   1073c:	0f be       	out	0x3f, r0	; 63
   1073e:	8d bf       	out	0x3d, r24	; 61
   10740:	82 e0       	ldi	r24, 0x02	; 2
   10742:	61 e0       	ldi	r22, 0x01	; 1
   10744:	a8 01       	movw	r20, r16
   10746:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_printf(3,1,PSTR("InB:_"));
   1074a:	83 e0       	ldi	r24, 0x03	; 3
   1074c:	61 e0       	ldi	r22, 0x01	; 1
   1074e:	42 ec       	ldi	r20, 0xC2	; 194
   10750:	55 e0       	ldi	r21, 0x05	; 5
   10752:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  uiResult=USER_NONE;
   10756:	10 92 51 02 	sts	0x0251, r1
          stTestCalc=tcInputB;
   1075a:	83 e0       	ldi	r24, 0x03	; 3
   1075c:	cd cf       	rjmp	.-102    	; 0x106f8 <FTestCalculation+0xba>
	      break;
     case tcInputB:
	 	  uiResult=UserInput(UI_ALPHANUM_R,3,5,InputB,0,15);
   1075e:	83 e0       	ldi	r24, 0x03	; 3
   10760:	63 e0       	ldi	r22, 0x03	; 3
   10762:	45 e0       	ldi	r20, 0x05	; 5
   10764:	29 e2       	ldi	r18, 0x29	; 41
   10766:	32 e0       	ldi	r19, 0x02	; 2
   10768:	00 e0       	ldi	r16, 0x00	; 0
   1076a:	10 e0       	ldi	r17, 0x00	; 0
   1076c:	bf e0       	ldi	r27, 0x0F	; 15
   1076e:	eb 2e       	mov	r14, r27
   10770:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
   10774:	80 93 51 02 	sts	0x0251, r24
	      if (uiResult==USER_OK)stTestCalc=tcCalcualte;
   10778:	83 30       	cpi	r24, 0x03	; 3
   1077a:	09 f0       	breq	.+2      	; 0x1077e <FTestCalculation+0x140>
   1077c:	63 c0       	rjmp	.+198    	; 0x10844 <FTestCalculation+0x206>
   1077e:	84 e0       	ldi	r24, 0x04	; 4
   10780:	bb cf       	rjmp	.-138    	; 0x106f8 <FTestCalculation+0xba>
	      break;
     case tcCalcualte:
	      sprintf_P(lcdteks,PSTR("InB:%s"),InputB);
   10782:	00 d0       	rcall	.+0      	; 0x10784 <FTestCalculation+0x146>
   10784:	00 d0       	rcall	.+0      	; 0x10786 <FTestCalculation+0x148>
   10786:	00 d0       	rcall	.+0      	; 0x10788 <FTestCalculation+0x14a>
   10788:	ed b7       	in	r30, 0x3d	; 61
   1078a:	fe b7       	in	r31, 0x3e	; 62
   1078c:	31 96       	adiw	r30, 0x01	; 1
   1078e:	8e 01       	movw	r16, r28
   10790:	0f 5f       	subi	r16, 0xFF	; 255
   10792:	1f 4f       	sbci	r17, 0xFF	; 255
   10794:	ad b7       	in	r26, 0x3d	; 61
   10796:	be b7       	in	r27, 0x3e	; 62
   10798:	12 96       	adiw	r26, 0x02	; 2
   1079a:	1c 93       	st	X, r17
   1079c:	0e 93       	st	-X, r16
   1079e:	11 97       	sbiw	r26, 0x01	; 1
   107a0:	8b eb       	ldi	r24, 0xBB	; 187
   107a2:	95 e0       	ldi	r25, 0x05	; 5
   107a4:	93 83       	std	Z+3, r25	; 0x03
   107a6:	82 83       	std	Z+2, r24	; 0x02
   107a8:	a9 e2       	ldi	r26, 0x29	; 41
   107aa:	ea 2e       	mov	r14, r26
   107ac:	a2 e0       	ldi	r26, 0x02	; 2
   107ae:	fa 2e       	mov	r15, r26
   107b0:	f5 82       	std	Z+5, r15	; 0x05
   107b2:	e4 82       	std	Z+4, r14	; 0x04
   107b4:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   107b8:	8d b7       	in	r24, 0x3d	; 61
   107ba:	9e b7       	in	r25, 0x3e	; 62
   107bc:	06 96       	adiw	r24, 0x06	; 6
   107be:	0f b6       	in	r0, 0x3f	; 63
   107c0:	f8 94       	cli
   107c2:	9e bf       	out	0x3e, r25	; 62
   107c4:	0f be       	out	0x3f, r0	; 63
   107c6:	8d bf       	out	0x3d, r24	; 61
   107c8:	83 e0       	ldi	r24, 0x03	; 3
   107ca:	61 e0       	ldi	r22, 0x01	; 1
   107cc:	a8 01       	movw	r20, r16
   107ce:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  //StrCalc(TMINUS,InputA,InputB,OutputC);
		  //StrCalc(TPLUS,InputA,InputB,OutputC);
		  StrCalc(TMULTIPLY,InputA,InputB,OutputC);
   107d2:	f5 e1       	ldi	r31, 0x15	; 21
   107d4:	cf 2e       	mov	r12, r31
   107d6:	f2 e0       	ldi	r31, 0x02	; 2
   107d8:	df 2e       	mov	r13, r31
   107da:	82 e0       	ldi	r24, 0x02	; 2
   107dc:	6d e3       	ldi	r22, 0x3D	; 61
   107de:	72 e0       	ldi	r23, 0x02	; 2
   107e0:	a7 01       	movw	r20, r14
   107e2:	96 01       	movw	r18, r12
   107e4:	0e 94 6c 26 	call	0x4cd8	; 0x4cd8 <StrCalc>
	      sprintf_P(lcdteks,PSTR("A+B:%s"),OutputC);
   107e8:	00 d0       	rcall	.+0      	; 0x107ea <FTestCalculation+0x1ac>
   107ea:	00 d0       	rcall	.+0      	; 0x107ec <FTestCalculation+0x1ae>
   107ec:	00 d0       	rcall	.+0      	; 0x107ee <FTestCalculation+0x1b0>
   107ee:	ed b7       	in	r30, 0x3d	; 61
   107f0:	fe b7       	in	r31, 0x3e	; 62
   107f2:	31 96       	adiw	r30, 0x01	; 1
   107f4:	ad b7       	in	r26, 0x3d	; 61
   107f6:	be b7       	in	r27, 0x3e	; 62
   107f8:	12 96       	adiw	r26, 0x02	; 2
   107fa:	1c 93       	st	X, r17
   107fc:	0e 93       	st	-X, r16
   107fe:	11 97       	sbiw	r26, 0x01	; 1
   10800:	84 eb       	ldi	r24, 0xB4	; 180
   10802:	95 e0       	ldi	r25, 0x05	; 5
   10804:	93 83       	std	Z+3, r25	; 0x03
   10806:	82 83       	std	Z+2, r24	; 0x02
   10808:	d5 82       	std	Z+5, r13	; 0x05
   1080a:	c4 82       	std	Z+4, r12	; 0x04
   1080c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(4,1,lcdteks);
   10810:	8d b7       	in	r24, 0x3d	; 61
   10812:	9e b7       	in	r25, 0x3e	; 62
   10814:	06 96       	adiw	r24, 0x06	; 6
   10816:	0f b6       	in	r0, 0x3f	; 63
   10818:	f8 94       	cli
   1081a:	9e bf       	out	0x3e, r25	; 62
   1081c:	0f be       	out	0x3f, r0	; 63
   1081e:	8d bf       	out	0x3d, r24	; 61
   10820:	84 e0       	ldi	r24, 0x04	; 4
   10822:	61 e0       	ldi	r22, 0x01	; 1
   10824:	a8 01       	movw	r20, r16
   10826:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
          stTestCalc=tcWaitEnter;
   1082a:	85 e0       	ldi	r24, 0x05	; 5
   1082c:	65 cf       	rjmp	.-310    	; 0x106f8 <FTestCalculation+0xba>
	      break;
     case tcWaitEnter:
	      KeyChar= _key_btn(_key_scan(1));       
   1082e:	81 e0       	ldi	r24, 0x01	; 1
   10830:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   10834:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
		  if (KeyChar=='#')stTestCalc=tcInitData;
   10838:	83 32       	cpi	r24, 0x23	; 35
   1083a:	11 f0       	breq	.+4      	; 0x10840 <FTestCalculation+0x202>
		  else
		  if (KeyChar=='*')stTestCalc=tcInitData;
   1083c:	8a 32       	cpi	r24, 0x2A	; 42
   1083e:	11 f4       	brne	.+4      	; 0x10844 <FTestCalculation+0x206>
   10840:	10 92 52 02 	sts	0x0252, r1
	      break;	 
	 }
}
   10844:	64 96       	adiw	r28, 0x14	; 20
   10846:	0f b6       	in	r0, 0x3f	; 63
   10848:	f8 94       	cli
   1084a:	de bf       	out	0x3e, r29	; 62
   1084c:	0f be       	out	0x3f, r0	; 63
   1084e:	cd bf       	out	0x3d, r28	; 61
   10850:	cf 91       	pop	r28
   10852:	df 91       	pop	r29
   10854:	1f 91       	pop	r17
   10856:	0f 91       	pop	r16
   10858:	ff 90       	pop	r15
   1085a:	ef 90       	pop	r14
   1085c:	df 90       	pop	r13
   1085e:	cf 90       	pop	r12
   10860:	08 95       	ret

00010862 <FMenuTicket>:
	    StrResult[2]='0'+Val;
	    StrResult[3]=0;
		}   
}

char FMenuTicket(){
   10862:	ef 92       	push	r14
   10864:	0f 93       	push	r16
   10866:	1f 93       	push	r17
   10868:	df 93       	push	r29
   1086a:	cf 93       	push	r28
   1086c:	cd b7       	in	r28, 0x3d	; 61
   1086e:	de b7       	in	r29, 0x3e	; 62
   10870:	64 97       	sbiw	r28, 0x14	; 20
   10872:	0f b6       	in	r0, 0x3f	; 63
   10874:	f8 94       	cli
   10876:	de bf       	out	0x3e, r29	; 62
   10878:	0f be       	out	0x3f, r0	; 63
   1087a:	cd bf       	out	0x3d, r28	; 61
static char uiResult=USER_NONE,iPos,iSend,KeyPressed,KeyChar,FIP_Used,zFIP_Used;
static unsigned int iLoop=0;
     char Result=MENU_NONE,lcdteks[20];

    Result=MENU_NONE;   
    switch(stMenuTicket){
   1087c:	80 91 d0 02 	lds	r24, 0x02D0
   10880:	86 30       	cpi	r24, 0x06	; 6
   10882:	09 f4       	brne	.+2      	; 0x10886 <FMenuTicket+0x24>
   10884:	c8 c0       	rjmp	.+400    	; 0x10a16 <FMenuTicket+0x1b4>
   10886:	87 30       	cpi	r24, 0x07	; 7
   10888:	90 f4       	brcc	.+36     	; 0x108ae <FMenuTicket+0x4c>
   1088a:	82 30       	cpi	r24, 0x02	; 2
   1088c:	09 f4       	brne	.+2      	; 0x10890 <FMenuTicket+0x2e>
   1088e:	3f c0       	rjmp	.+126    	; 0x1090e <FMenuTicket+0xac>
   10890:	83 30       	cpi	r24, 0x03	; 3
   10892:	30 f4       	brcc	.+12     	; 0x108a0 <FMenuTicket+0x3e>
   10894:	88 23       	and	r24, r24
   10896:	09 f1       	breq	.+66     	; 0x108da <FMenuTicket+0x78>
   10898:	81 30       	cpi	r24, 0x01	; 1
   1089a:	09 f0       	breq	.+2      	; 0x1089e <FMenuTicket+0x3c>
   1089c:	33 c1       	rjmp	.+614    	; 0x10b04 <FMenuTicket+0x2a2>
   1089e:	1f c0       	rjmp	.+62     	; 0x108de <FMenuTicket+0x7c>
   108a0:	84 30       	cpi	r24, 0x04	; 4
   108a2:	09 f4       	brne	.+2      	; 0x108a6 <FMenuTicket+0x44>
   108a4:	8d c0       	rjmp	.+282    	; 0x109c0 <FMenuTicket+0x15e>
   108a6:	85 30       	cpi	r24, 0x05	; 5
   108a8:	08 f0       	brcs	.+2      	; 0x108ac <FMenuTicket+0x4a>
   108aa:	af c0       	rjmp	.+350    	; 0x10a0a <FMenuTicket+0x1a8>
   108ac:	51 c0       	rjmp	.+162    	; 0x10950 <FMenuTicket+0xee>
   108ae:	89 30       	cpi	r24, 0x09	; 9
   108b0:	09 f4       	brne	.+2      	; 0x108b4 <FMenuTicket+0x52>
   108b2:	03 c1       	rjmp	.+518    	; 0x10aba <FMenuTicket+0x258>
   108b4:	8a 30       	cpi	r24, 0x0A	; 10
   108b6:	38 f4       	brcc	.+14     	; 0x108c6 <FMenuTicket+0x64>
   108b8:	87 30       	cpi	r24, 0x07	; 7
   108ba:	09 f4       	brne	.+2      	; 0x108be <FMenuTicket+0x5c>
   108bc:	df c0       	rjmp	.+446    	; 0x10a7c <FMenuTicket+0x21a>
   108be:	88 30       	cpi	r24, 0x08	; 8
   108c0:	09 f0       	breq	.+2      	; 0x108c4 <FMenuTicket+0x62>
   108c2:	20 c1       	rjmp	.+576    	; 0x10b04 <FMenuTicket+0x2a2>
   108c4:	cb c0       	rjmp	.+406    	; 0x10a5c <FMenuTicket+0x1fa>
   108c6:	8b 30       	cpi	r24, 0x0B	; 11
   108c8:	09 f4       	brne	.+2      	; 0x108cc <FMenuTicket+0x6a>
   108ca:	fd c0       	rjmp	.+506    	; 0x10ac6 <FMenuTicket+0x264>
   108cc:	8b 30       	cpi	r24, 0x0B	; 11
   108ce:	08 f4       	brcc	.+2      	; 0x108d2 <FMenuTicket+0x70>
   108d0:	13 c1       	rjmp	.+550    	; 0x10af8 <FMenuTicket+0x296>
   108d2:	8c 30       	cpi	r24, 0x0C	; 12
   108d4:	09 f0       	breq	.+2      	; 0x108d8 <FMenuTicket+0x76>
   108d6:	16 c1       	rjmp	.+556    	; 0x10b04 <FMenuTicket+0x2a2>
   108d8:	11 c1       	rjmp	.+546    	; 0x10afc <FMenuTicket+0x29a>
	case mtInit:
		 stMenuTicket=mtPlatNo;
   108da:	81 e0       	ldi	r24, 0x01	; 1
   108dc:	81 c0       	rjmp	.+258    	; 0x109e0 <FMenuTicket+0x17e>
	     break;
    case mtPlatNo:
	     lcd_clear();
   108de:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
	     lcd_printf(1,1,PSTR("Input Plat No: "));
   108e2:	81 e0       	ldi	r24, 0x01	; 1
   108e4:	61 e0       	ldi	r22, 0x01	; 1
   108e6:	48 ee       	ldi	r20, 0xE8	; 232
   108e8:	5a e0       	ldi	r21, 0x0A	; 10
   108ea:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	     lcd_printf(2,1,PSTR("_"));
   108ee:	82 e0       	ldi	r24, 0x02	; 2
   108f0:	61 e0       	ldi	r22, 0x01	; 1
   108f2:	46 ee       	ldi	r20, 0xE6	; 230
   108f4:	5a e0       	ldi	r21, 0x0A	; 10
   108f6:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   108fa:	84 e0       	ldi	r24, 0x04	; 4
   108fc:	61 e0       	ldi	r22, 0x01	; 1
   108fe:	41 ed       	ldi	r20, 0xD1	; 209
   10900:	5a e0       	ldi	r21, 0x0A	; 10
   10902:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		 uiResult=USER_NONE;
   10906:	10 92 cf 02 	sts	0x02CF, r1
		 stMenuTicket=mtInputPlatNo;
   1090a:	82 e0       	ldi	r24, 0x02	; 2
   1090c:	69 c0       	rjmp	.+210    	; 0x109e0 <FMenuTicket+0x17e>
	     break;
    case mtInputPlatNo:
	     uiResult=UserInput(UI_ALPHANUM_R,2,1,strLicPlate,0,10);
   1090e:	83 e0       	ldi	r24, 0x03	; 3
   10910:	62 e0       	ldi	r22, 0x02	; 2
   10912:	41 e0       	ldi	r20, 0x01	; 1
   10914:	22 e2       	ldi	r18, 0x22	; 34
   10916:	3b e0       	ldi	r19, 0x0B	; 11
   10918:	00 e0       	ldi	r16, 0x00	; 0
   1091a:	10 e0       	ldi	r17, 0x00	; 0
   1091c:	7a e0       	ldi	r23, 0x0A	; 10
   1091e:	e7 2e       	mov	r14, r23
   10920:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
   10924:	80 93 cf 02 	sts	0x02CF, r24
		 if (uiResult==USER_OK)stMenuTicket=mtOdometer;
   10928:	83 30       	cpi	r24, 0x03	; 3
   1092a:	09 f4       	brne	.+2      	; 0x1092e <FMenuTicket+0xcc>
   1092c:	59 c0       	rjmp	.+178    	; 0x109e0 <FMenuTicket+0x17e>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtExitMenuTicket;
   1092e:	81 30       	cpi	r24, 0x01	; 1
   10930:	09 f4       	brne	.+2      	; 0x10934 <FMenuTicket+0xd2>
   10932:	e2 c0       	rjmp	.+452    	; 0x10af8 <FMenuTicket+0x296>
         else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10934:	84 30       	cpi	r24, 0x04	; 4
   10936:	21 f4       	brne	.+8      	; 0x10940 <FMenuTicket+0xde>
   10938:	61 e0       	ldi	r22, 0x01	; 1
   1093a:	4c eb       	ldi	r20, 0xBC	; 188
   1093c:	5a e0       	ldi	r21, 0x0A	; 10
   1093e:	62 c0       	rjmp	.+196    	; 0x10a04 <FMenuTicket+0x1a2>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10940:	85 30       	cpi	r24, 0x05	; 5
   10942:	09 f0       	breq	.+2      	; 0x10946 <FMenuTicket+0xe4>
   10944:	df c0       	rjmp	.+446    	; 0x10b04 <FMenuTicket+0x2a2>
   10946:	84 e0       	ldi	r24, 0x04	; 4
   10948:	61 e0       	ldi	r22, 0x01	; 1
   1094a:	47 ea       	ldi	r20, 0xA7	; 167
   1094c:	5a e0       	ldi	r21, 0x0A	; 10
   1094e:	5a c0       	rjmp	.+180    	; 0x10a04 <FMenuTicket+0x1a2>
	     break;
    case mtOdometer:
	     lcd_clear();
   10950:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		 sprintf_P(lcdteks,PSTR("Plat No: %s "),strLicPlate);
   10954:	00 d0       	rcall	.+0      	; 0x10956 <FMenuTicket+0xf4>
   10956:	00 d0       	rcall	.+0      	; 0x10958 <FMenuTicket+0xf6>
   10958:	00 d0       	rcall	.+0      	; 0x1095a <FMenuTicket+0xf8>
   1095a:	ed b7       	in	r30, 0x3d	; 61
   1095c:	fe b7       	in	r31, 0x3e	; 62
   1095e:	31 96       	adiw	r30, 0x01	; 1
   10960:	8e 01       	movw	r16, r28
   10962:	0f 5f       	subi	r16, 0xFF	; 255
   10964:	1f 4f       	sbci	r17, 0xFF	; 255
   10966:	ad b7       	in	r26, 0x3d	; 61
   10968:	be b7       	in	r27, 0x3e	; 62
   1096a:	12 96       	adiw	r26, 0x02	; 2
   1096c:	1c 93       	st	X, r17
   1096e:	0e 93       	st	-X, r16
   10970:	11 97       	sbiw	r26, 0x01	; 1
   10972:	8a e9       	ldi	r24, 0x9A	; 154
   10974:	9a e0       	ldi	r25, 0x0A	; 10
   10976:	93 83       	std	Z+3, r25	; 0x03
   10978:	82 83       	std	Z+2, r24	; 0x02
   1097a:	82 e2       	ldi	r24, 0x22	; 34
   1097c:	9b e0       	ldi	r25, 0x0B	; 11
   1097e:	95 83       	std	Z+5, r25	; 0x05
   10980:	84 83       	std	Z+4, r24	; 0x04
   10982:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	     lcd_print(1,1,lcdteks);
   10986:	8d b7       	in	r24, 0x3d	; 61
   10988:	9e b7       	in	r25, 0x3e	; 62
   1098a:	06 96       	adiw	r24, 0x06	; 6
   1098c:	0f b6       	in	r0, 0x3f	; 63
   1098e:	f8 94       	cli
   10990:	9e bf       	out	0x3e, r25	; 62
   10992:	0f be       	out	0x3f, r0	; 63
   10994:	8d bf       	out	0x3d, r24	; 61
   10996:	81 e0       	ldi	r24, 0x01	; 1
   10998:	61 e0       	ldi	r22, 0x01	; 1
   1099a:	a8 01       	movw	r20, r16
   1099c:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
	     lcd_printf(2,1,PSTR("Odometer:_ "));
   109a0:	82 e0       	ldi	r24, 0x02	; 2
   109a2:	61 e0       	ldi	r22, 0x01	; 1
   109a4:	4e e8       	ldi	r20, 0x8E	; 142
   109a6:	5a e0       	ldi	r21, 0x0A	; 10
   109a8:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   109ac:	84 e0       	ldi	r24, 0x04	; 4
   109ae:	61 e0       	ldi	r22, 0x01	; 1
   109b0:	49 e7       	ldi	r20, 0x79	; 121
   109b2:	5a e0       	ldi	r21, 0x0A	; 10
   109b4:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		 uiResult=USER_NONE;
   109b8:	10 92 cf 02 	sts	0x02CF, r1
		 stMenuTicket=mtInputOdometer;
   109bc:	84 e0       	ldi	r24, 0x04	; 4
   109be:	10 c0       	rjmp	.+32     	; 0x109e0 <FMenuTicket+0x17e>
	     break;
    case mtInputOdometer:
	     uiResult=UserInput(UI_NUMBER_R,2,10,strOdometer,0,10);
   109c0:	81 e0       	ldi	r24, 0x01	; 1
   109c2:	62 e0       	ldi	r22, 0x02	; 2
   109c4:	4a e0       	ldi	r20, 0x0A	; 10
   109c6:	23 ef       	ldi	r18, 0xF3	; 243
   109c8:	35 e0       	ldi	r19, 0x05	; 5
   109ca:	00 e0       	ldi	r16, 0x00	; 0
   109cc:	10 e0       	ldi	r17, 0x00	; 0
   109ce:	5a e0       	ldi	r21, 0x0A	; 10
   109d0:	e5 2e       	mov	r14, r21
   109d2:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
   109d6:	80 93 cf 02 	sts	0x02CF, r24
		 if (uiResult==USER_OK)stMenuTicket=mtFIP;
   109da:	83 30       	cpi	r24, 0x03	; 3
   109dc:	21 f4       	brne	.+8      	; 0x109e6 <FMenuTicket+0x184>
   109de:	85 e0       	ldi	r24, 0x05	; 5
   109e0:	80 93 d0 02 	sts	0x02D0, r24
   109e4:	8f c0       	rjmp	.+286    	; 0x10b04 <FMenuTicket+0x2a2>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtPlatNo;
   109e6:	81 30       	cpi	r24, 0x01	; 1
   109e8:	d9 f3       	breq	.-10     	; 0x109e0 <FMenuTicket+0x17e>
		 else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   109ea:	84 30       	cpi	r24, 0x04	; 4
   109ec:	21 f4       	brne	.+8      	; 0x109f6 <FMenuTicket+0x194>
   109ee:	61 e0       	ldi	r22, 0x01	; 1
   109f0:	44 e6       	ldi	r20, 0x64	; 100
   109f2:	5a e0       	ldi	r21, 0x0A	; 10
   109f4:	07 c0       	rjmp	.+14     	; 0x10a04 <FMenuTicket+0x1a2>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   109f6:	85 30       	cpi	r24, 0x05	; 5
   109f8:	09 f0       	breq	.+2      	; 0x109fc <FMenuTicket+0x19a>
   109fa:	84 c0       	rjmp	.+264    	; 0x10b04 <FMenuTicket+0x2a2>
   109fc:	84 e0       	ldi	r24, 0x04	; 4
   109fe:	61 e0       	ldi	r22, 0x01	; 1
   10a00:	4f e4       	ldi	r20, 0x4F	; 79
   10a02:	5a e0       	ldi	r21, 0x0A	; 10
   10a04:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   10a08:	7d c0       	rjmp	.+250    	; 0x10b04 <FMenuTicket+0x2a2>
	     break;
    case mtFIP:
	     lcd_clear();
   10a0a:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		 _scr_pump();
   10a0e:	0e 94 58 42 	call	0x84b0	; 0x84b0 <_scr_pump>
		 stMenuTicket=mtInputFIP;
   10a12:	86 e0       	ldi	r24, 0x06	; 6
   10a14:	e5 cf       	rjmp	.-54     	; 0x109e0 <FMenuTicket+0x17e>
	     break;
    case mtInputFIP:
	     KeyPressed=_key_scan(1);
   10a16:	81 e0       	ldi	r24, 0x01	; 1
   10a18:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   10a1c:	80 93 cc 02 	sts	0x02CC, r24
		 KeyChar=_key_btn(KeyPressed);
   10a20:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   10a24:	80 93 cb 02 	sts	0x02CB, r24
		 if ((KeyChar>='1')&&(KeyChar<='8')){
   10a28:	81 53       	subi	r24, 0x31	; 49
   10a2a:	88 30       	cpi	r24, 0x08	; 8
   10a2c:	40 f4       	brcc	.+16     	; 0x10a3e <FMenuTicket+0x1dc>
		     FIP_Used=KeyChar-'0';
   10a2e:	8f 5f       	subi	r24, 0xFF	; 255
   10a30:	80 93 ca 02 	sts	0x02CA, r24
			 zFIP_Used=FIP_Used;
   10a34:	80 93 c9 02 	sts	0x02C9, r24
		     stMenuTicket=mtSendMsg98;
   10a38:	87 e0       	ldi	r24, 0x07	; 7
   10a3a:	80 93 d0 02 	sts	0x02D0, r24
		 }
		 if (KeyPressed==_KEY_CANCEL){
   10a3e:	80 91 cc 02 	lds	r24, 0x02CC
   10a42:	87 3e       	cpi	r24, 0xE7	; 231
   10a44:	11 f4       	brne	.+4      	; 0x10a4a <FMenuTicket+0x1e8>
             stMenuTicket=mtOdometer;
   10a46:	83 e0       	ldi	r24, 0x03	; 3
   10a48:	cb cf       	rjmp	.-106    	; 0x109e0 <FMenuTicket+0x17e>
		 }else
		 if (KeyPressed==_KEY_ENTER){
   10a4a:	87 3b       	cpi	r24, 0xB7	; 183
   10a4c:	09 f0       	breq	.+2      	; 0x10a50 <FMenuTicket+0x1ee>
   10a4e:	5a c0       	rjmp	.+180    	; 0x10b04 <FMenuTicket+0x2a2>
		     FIP_Used=zFIP_Used;
   10a50:	80 91 c9 02 	lds	r24, 0x02C9
   10a54:	80 93 ca 02 	sts	0x02CA, r24
             stMenuTicket=mtInitWaitMessage99;
   10a58:	88 e0       	ldi	r24, 0x08	; 8
   10a5a:	c2 cf       	rjmp	.-124    	; 0x109e0 <FMenuTicket+0x17e>
		 }
	     break;	
    case mtInitWaitMessage99:
	     lcd_clear();
   10a5c:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		 lcd_printf(2,1,PSTR("Send Request"));
   10a60:	82 e0       	ldi	r24, 0x02	; 2
   10a62:	61 e0       	ldi	r22, 0x01	; 1
   10a64:	42 e4       	ldi	r20, 0x42	; 66
   10a66:	5a e0       	ldi	r21, 0x0A	; 10
   10a68:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		 lcd_printf(3,1,PSTR("Proses"));
   10a6c:	83 e0       	ldi	r24, 0x03	; 3
   10a6e:	61 e0       	ldi	r22, 0x01	; 1
   10a70:	4b e3       	ldi	r20, 0x3B	; 59
   10a72:	5a e0       	ldi	r21, 0x0A	; 10
   10a74:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
         stMenuTicket=mtSendMsg98;
   10a78:	87 e0       	ldi	r24, 0x07	; 7
   10a7a:	b2 cf       	rjmp	.-156    	; 0x109e0 <FMenuTicket+0x17e>
	     break;
    case mtSendMsg98:
	     iPos=0;
   10a7c:	10 92 ce 02 	sts	0x02CE, r1
		 iSend=0;
   10a80:	10 92 cd 02 	sts	0x02CD, r1
		 IsMessage99=False;
   10a84:	10 92 b6 01 	sts	0x01B6, r1
		 TimSend=0;
   10a88:	10 92 a9 01 	sts	0x01A9, r1
   10a8c:	10 92 a8 01 	sts	0x01A8, r1
		 iLoop=0;
   10a90:	10 92 c8 02 	sts	0x02C8, r1
   10a94:	10 92 c7 02 	sts	0x02C7, r1
		 if (IFType==IT_SLAVE)sendMessage98(FIP_Used);
   10a98:	80 91 10 01 	lds	r24, 0x0110
   10a9c:	81 30       	cpi	r24, 0x01	; 1
   10a9e:	29 f4       	brne	.+10     	; 0x10aaa <FMenuTicket+0x248>
   10aa0:	80 91 ca 02 	lds	r24, 0x02CA
   10aa4:	0e 94 65 4c 	call	0x98ca	; 0x98ca <sendMessage98>
   10aa8:	27 c0       	rjmp	.+78     	; 0x10af8 <FMenuTicket+0x296>
		 else 
		 if (IFType==IT_STANDALONE)PrintStandalone(FIP_Used,False);
   10aaa:	82 30       	cpi	r24, 0x02	; 2
   10aac:	29 f5       	brne	.+74     	; 0x10af8 <FMenuTicket+0x296>
   10aae:	80 91 ca 02 	lds	r24, 0x02CA
   10ab2:	60 e0       	ldi	r22, 0x00	; 0
   10ab4:	0e 94 9c 1f 	call	0x3f38	; 0x3f38 <PrintStandalone>
   10ab8:	1f c0       	rjmp	.+62     	; 0x10af8 <FMenuTicket+0x296>
	                     stMenuTicket=mtSendMsg98;
				  }
			 }
		 }
		 */
		 if (IsMessage99==True){ 
   10aba:	80 91 b6 01 	lds	r24, 0x01B6
   10abe:	81 30       	cpi	r24, 0x01	; 1
   10ac0:	09 f5       	brne	.+66     	; 0x10b04 <FMenuTicket+0x2a2>
		    stMenuTicket=mtMessage99Received;
   10ac2:	8a e0       	ldi	r24, 0x0A	; 10
   10ac4:	8d cf       	rjmp	.-230    	; 0x109e0 <FMenuTicket+0x17e>
	     break;
    case mtMessage99Received:
	     stMenuTicket=mtExitMenuTicket;
		 break;
    case mtNoConnection:
	     lcd_clear();
   10ac6:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		 lcd_printf(2,1,PSTR("Error No Connection"));
   10aca:	82 e0       	ldi	r24, 0x02	; 2
   10acc:	61 e0       	ldi	r22, 0x01	; 1
   10ace:	47 e2       	ldi	r20, 0x27	; 39
   10ad0:	5a e0       	ldi	r21, 0x0A	; 10
   10ad2:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   10ad6:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   10ad8:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   10ada:	82 e0       	ldi	r24, 0x02	; 2
   10adc:	90 e0       	ldi	r25, 0x00	; 0
   10ade:	90 93 d7 01 	sts	0x01D7, r25
   10ae2:	80 93 d6 01 	sts	0x01D6, r24
   10ae6:	80 e2       	ldi	r24, 0x20	; 32
   10ae8:	9e e4       	ldi	r25, 0x4E	; 78
   10aea:	29 e1       	ldi	r18, 0x19	; 25
   10aec:	30 e0       	ldi	r19, 0x00	; 0
   10aee:	f9 01       	movw	r30, r18
   10af0:	31 97       	sbiw	r30, 0x01	; 1
   10af2:	f1 f7       	brne	.-4      	; 0x10af0 <FMenuTicket+0x28e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   10af4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   10af6:	d9 f7       	brne	.-10     	; 0x10aee <FMenuTicket+0x28c>
    case mtNoConnection:
	     lcd_clear();
		 lcd_printf(2,1,PSTR("Error No Connection"));
		 system_beep(2);
		 _delay_ms(2000);
         stMenuTicket=mtExitMenuTicket;
   10af8:	8c e0       	ldi	r24, 0x0C	; 12
   10afa:	72 cf       	rjmp	.-284    	; 0x109e0 <FMenuTicket+0x17e>
	     break;
    case mtExitMenuTicket:
	     Result=MENU_DONE;
	     stMenuTicket=mtInit;
   10afc:	10 92 d0 02 	sts	0x02D0, r1
   10b00:	81 e0       	ldi	r24, 0x01	; 1
   10b02:	01 c0       	rjmp	.+2      	; 0x10b06 <FMenuTicket+0x2a4>
   10b04:	80 e0       	ldi	r24, 0x00	; 0
	     break;
	}
  return Result;
}
   10b06:	64 96       	adiw	r28, 0x14	; 20
   10b08:	0f b6       	in	r0, 0x3f	; 63
   10b0a:	f8 94       	cli
   10b0c:	de bf       	out	0x3e, r29	; 62
   10b0e:	0f be       	out	0x3f, r0	; 63
   10b10:	cd bf       	out	0x3d, r28	; 61
   10b12:	cf 91       	pop	r28
   10b14:	df 91       	pop	r29
   10b16:	1f 91       	pop	r17
   10b18:	0f 91       	pop	r16
   10b1a:	ef 90       	pop	r14
   10b1c:	08 95       	ret

00010b1e <FSettingOperator>:
char FSettingHost(){
     _menu_host();
	 return MENU_DONE;
}

char FSettingOperator(){//Change Active Operator, Change Password
   10b1e:	ef 92       	push	r14
   10b20:	0f 93       	push	r16
   10b22:	1f 93       	push	r17
   10b24:	df 93       	push	r29
   10b26:	cf 93       	push	r28
   10b28:	cd b7       	in	r28, 0x3d	; 61
   10b2a:	de b7       	in	r29, 0x3e	; 62
   10b2c:	e5 97       	sbiw	r28, 0x35	; 53
   10b2e:	0f b6       	in	r0, 0x3f	; 63
   10b30:	f8 94       	cli
   10b32:	de bf       	out	0x3e, r29	; 62
   10b34:	0f be       	out	0x3f, r0	; 63
   10b36:	cd bf       	out	0x3d, r28	; 61
	        char KeyPressed,KeyChar,lcdteks[20],strPassword[15];
			char strOperatorName[18];
			char uiResult=USER_NONE,Result=MENU_NONE;
     //_menu_user();
	 Result=MENU_NONE;
	 switch(stSettingOperator){
   10b38:	80 91 e2 02 	lds	r24, 0x02E2
   10b3c:	87 30       	cpi	r24, 0x07	; 7
   10b3e:	09 f4       	brne	.+2      	; 0x10b42 <FSettingOperator+0x24>
   10b40:	6b c1       	rjmp	.+726    	; 0x10e18 <FSettingOperator+0x2fa>
   10b42:	88 30       	cpi	r24, 0x08	; 8
   10b44:	90 f4       	brcc	.+36     	; 0x10b6a <FSettingOperator+0x4c>
   10b46:	83 30       	cpi	r24, 0x03	; 3
   10b48:	09 f4       	brne	.+2      	; 0x10b4c <FSettingOperator+0x2e>
   10b4a:	9a c0       	rjmp	.+308    	; 0x10c80 <FSettingOperator+0x162>
   10b4c:	84 30       	cpi	r24, 0x04	; 4
   10b4e:	30 f4       	brcc	.+12     	; 0x10b5c <FSettingOperator+0x3e>
   10b50:	81 30       	cpi	r24, 0x01	; 1
   10b52:	a1 f1       	breq	.+104    	; 0x10bbc <FSettingOperator+0x9e>
   10b54:	82 30       	cpi	r24, 0x02	; 2
   10b56:	08 f0       	brcs	.+2      	; 0x10b5a <FSettingOperator+0x3c>
   10b58:	44 c0       	rjmp	.+136    	; 0x10be2 <FSettingOperator+0xc4>
   10b5a:	20 c0       	rjmp	.+64     	; 0x10b9c <FSettingOperator+0x7e>
   10b5c:	85 30       	cpi	r24, 0x05	; 5
   10b5e:	09 f4       	brne	.+2      	; 0x10b62 <FSettingOperator+0x44>
   10b60:	2c c1       	rjmp	.+600    	; 0x10dba <FSettingOperator+0x29c>
   10b62:	86 30       	cpi	r24, 0x06	; 6
   10b64:	08 f0       	brcs	.+2      	; 0x10b68 <FSettingOperator+0x4a>
   10b66:	45 c1       	rjmp	.+650    	; 0x10df2 <FSettingOperator+0x2d4>
   10b68:	fa c0       	rjmp	.+500    	; 0x10d5e <FSettingOperator+0x240>
   10b6a:	8b 30       	cpi	r24, 0x0B	; 11
   10b6c:	09 f4       	brne	.+2      	; 0x10b70 <FSettingOperator+0x52>
   10b6e:	14 c2       	rjmp	.+1064   	; 0x10f98 <FSettingOperator+0x47a>
   10b70:	8c 30       	cpi	r24, 0x0C	; 12
   10b72:	38 f4       	brcc	.+14     	; 0x10b82 <FSettingOperator+0x64>
   10b74:	89 30       	cpi	r24, 0x09	; 9
   10b76:	09 f4       	brne	.+2      	; 0x10b7a <FSettingOperator+0x5c>
   10b78:	9d c1       	rjmp	.+826    	; 0x10eb4 <FSettingOperator+0x396>
   10b7a:	8a 30       	cpi	r24, 0x0A	; 10
   10b7c:	08 f0       	brcs	.+2      	; 0x10b80 <FSettingOperator+0x62>
   10b7e:	cd c1       	rjmp	.+922    	; 0x10f1a <FSettingOperator+0x3fc>
   10b80:	6b c1       	rjmp	.+726    	; 0x10e58 <FSettingOperator+0x33a>
   10b82:	8d 30       	cpi	r24, 0x0D	; 13
   10b84:	09 f4       	brne	.+2      	; 0x10b88 <FSettingOperator+0x6a>
   10b86:	95 c2       	rjmp	.+1322   	; 0x110b2 <FSettingOperator+0x594>
   10b88:	8d 30       	cpi	r24, 0x0D	; 13
   10b8a:	08 f4       	brcc	.+2      	; 0x10b8e <FSettingOperator+0x70>
   10b8c:	0c c2       	rjmp	.+1048   	; 0x10fa6 <FSettingOperator+0x488>
   10b8e:	8e 30       	cpi	r24, 0x0E	; 14
   10b90:	09 f4       	brne	.+2      	; 0x10b94 <FSettingOperator+0x76>
   10b92:	94 c2       	rjmp	.+1320   	; 0x110bc <FSettingOperator+0x59e>
   10b94:	8f 30       	cpi	r24, 0x0F	; 15
   10b96:	09 f0       	breq	.+2      	; 0x10b9a <FSettingOperator+0x7c>
   10b98:	9c c2       	rjmp	.+1336   	; 0x110d2 <FSettingOperator+0x5b4>
   10b9a:	97 c2       	rjmp	.+1326   	; 0x110ca <FSettingOperator+0x5ac>
	 case soMenuOption:
	      lcd_clear();
   10b9c:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Change Operator"));
   10ba0:	81 e0       	ldi	r24, 0x01	; 1
   10ba2:	61 e0       	ldi	r22, 0x01	; 1
   10ba4:	45 e9       	ldi	r20, 0x95	; 149
   10ba6:	50 e1       	ldi	r21, 0x10	; 16
   10ba8:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Change Password"));
   10bac:	82 e0       	ldi	r24, 0x02	; 2
   10bae:	61 e0       	ldi	r22, 0x01	; 1
   10bb0:	43 e8       	ldi	r20, 0x83	; 131
   10bb2:	50 e1       	ldi	r21, 0x10	; 16
   10bb4:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          stSettingOperator=soMenuOptionInput;
   10bb8:	81 e0       	ldi	r24, 0x01	; 1
   10bba:	61 c2       	rjmp	.+1218   	; 0x1107e <FSettingOperator+0x560>
	      break;
     case soMenuOptionInput:
	      KeyPressed=_key_scan(1);
   10bbc:	81 e0       	ldi	r24, 0x01	; 1
   10bbe:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   10bc2:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
		  switch(KeyChar){
   10bc6:	81 33       	cpi	r24, 0x31	; 49
   10bc8:	31 f0       	breq	.+12     	; 0x10bd6 <FSettingOperator+0xb8>
   10bca:	82 33       	cpi	r24, 0x32	; 50
   10bcc:	31 f0       	breq	.+12     	; 0x10bda <FSettingOperator+0xbc>
   10bce:	8a 32       	cpi	r24, 0x2A	; 42
   10bd0:	09 f0       	breq	.+2      	; 0x10bd4 <FSettingOperator+0xb6>
   10bd2:	7f c2       	rjmp	.+1278   	; 0x110d2 <FSettingOperator+0x5b4>
   10bd4:	04 c0       	rjmp	.+8      	; 0x10bde <FSettingOperator+0xc0>
		  case '1':
		       stSettingOperator=soChangeOperatorInit;
   10bd6:	82 e0       	ldi	r24, 0x02	; 2
   10bd8:	52 c2       	rjmp	.+1188   	; 0x1107e <FSettingOperator+0x560>
		       break;
          case '2':
		       stSettingOperator=soChangePasswordInit;
   10bda:	85 e0       	ldi	r24, 0x05	; 5
   10bdc:	50 c2       	rjmp	.+1184   	; 0x1107e <FSettingOperator+0x560>
		       break;
          case '*':
		       stSettingOperator=soExitSettingOperator;
   10bde:	8f e0       	ldi	r24, 0x0F	; 15
   10be0:	4e c2       	rjmp	.+1180   	; 0x1107e <FSettingOperator+0x560>
		       break;
		  }
	      break;
     case soChangeOperatorInit:
	      lcd_clear();		  
   10be2:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   10be6:	8e 01       	movw	r16, r28
   10be8:	00 5f       	subi	r16, 0xF0	; 240
   10bea:	1f 4f       	sbci	r17, 0xFF	; 255
   10bec:	c8 01       	movw	r24, r16
   10bee:	65 e1       	ldi	r22, 0x15	; 21
   10bf0:	70 e0       	ldi	r23, 0x00	; 0
   10bf2:	42 e1       	ldi	r20, 0x12	; 18
   10bf4:	50 e0       	ldi	r21, 0x00	; 0
   10bf6:	25 ed       	ldi	r18, 0xD5	; 213
   10bf8:	32 e1       	ldi	r19, 0x12	; 18
   10bfa:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10bfe:	98 01       	movw	r18, r16
   10c00:	ce 01       	movw	r24, r28
   10c02:	4f 96       	adiw	r24, 0x1f	; 31
	    Dest[i]=Source[IdxSource+i];
   10c04:	0f 5f       	subi	r16, 0xFF	; 255
   10c06:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10c08:	08 17       	cp	r16, r24
   10c0a:	19 07       	cpc	r17, r25
   10c0c:	d9 f7       	brne	.-10     	; 0x10c04 <FSettingOperator+0xe6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10c0e:	1f 8e       	std	Y+31, r1	; 0x1f
     case soChangeOperatorInit:
	      lcd_clear();		  
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);

		  sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
   10c10:	00 d0       	rcall	.+0      	; 0x10c12 <FSettingOperator+0xf4>
   10c12:	00 d0       	rcall	.+0      	; 0x10c14 <FSettingOperator+0xf6>
   10c14:	00 d0       	rcall	.+0      	; 0x10c16 <FSettingOperator+0xf8>
   10c16:	ed b7       	in	r30, 0x3d	; 61
   10c18:	fe b7       	in	r31, 0x3e	; 62
   10c1a:	31 96       	adiw	r30, 0x01	; 1
   10c1c:	8e 01       	movw	r16, r28
   10c1e:	0e 5d       	subi	r16, 0xDE	; 222
   10c20:	1f 4f       	sbci	r17, 0xFF	; 255
   10c22:	ad b7       	in	r26, 0x3d	; 61
   10c24:	be b7       	in	r27, 0x3e	; 62
   10c26:	12 96       	adiw	r26, 0x02	; 2
   10c28:	1c 93       	st	X, r17
   10c2a:	0e 93       	st	-X, r16
   10c2c:	11 97       	sbiw	r26, 0x01	; 1
   10c2e:	80 e8       	ldi	r24, 0x80	; 128
   10c30:	90 e1       	ldi	r25, 0x10	; 16
   10c32:	93 83       	std	Z+3, r25	; 0x03
   10c34:	82 83       	std	Z+2, r24	; 0x02
   10c36:	24 83       	std	Z+4, r18	; 0x04
   10c38:	35 83       	std	Z+5, r19	; 0x05
   10c3a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_printf(1,1,PSTR("Name:"));
   10c3e:	8d b7       	in	r24, 0x3d	; 61
   10c40:	9e b7       	in	r25, 0x3e	; 62
   10c42:	06 96       	adiw	r24, 0x06	; 6
   10c44:	0f b6       	in	r0, 0x3f	; 63
   10c46:	f8 94       	cli
   10c48:	9e bf       	out	0x3e, r25	; 62
   10c4a:	0f be       	out	0x3f, r0	; 63
   10c4c:	8d bf       	out	0x3d, r24	; 61
   10c4e:	81 e0       	ldi	r24, 0x01	; 1
   10c50:	61 e0       	ldi	r22, 0x01	; 1
   10c52:	4a e7       	ldi	r20, 0x7A	; 122
   10c54:	50 e1       	ldi	r21, 0x10	; 16
   10c56:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_print (2,1,lcdteks);
   10c5a:	82 e0       	ldi	r24, 0x02	; 2
   10c5c:	61 e0       	ldi	r22, 0x01	; 1
   10c5e:	a8 01       	movw	r20, r16
   10c60:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_printf(3,1,PSTR("New:_"));
   10c64:	83 e0       	ldi	r24, 0x03	; 3
   10c66:	61 e0       	ldi	r22, 0x01	; 1
   10c68:	44 e7       	ldi	r20, 0x74	; 116
   10c6a:	50 e1       	ldi	r21, 0x10	; 16
   10c6c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10c70:	84 e0       	ldi	r24, 0x04	; 4
   10c72:	61 e0       	ldi	r22, 0x01	; 1
   10c74:	4f e5       	ldi	r20, 0x5F	; 95
   10c76:	50 e1       	ldi	r21, 0x10	; 16
   10c78:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          stSettingOperator=soOperatorNameInput;
   10c7c:	83 e0       	ldi	r24, 0x03	; 3
   10c7e:	ff c1       	rjmp	.+1022   	; 0x1107e <FSettingOperator+0x560>
	      break;
     case soOperatorNameInput:
          uiResult=USER_NONE;
	      uiResult=UserInput(UI_ALPHANUM_R,3,5,strFreeMessageLine1,0,16);
   10c80:	83 e0       	ldi	r24, 0x03	; 3
   10c82:	63 e0       	ldi	r22, 0x03	; 3
   10c84:	45 e0       	ldi	r20, 0x05	; 5
   10c86:	27 ee       	ldi	r18, 0xE7	; 231
   10c88:	3a e0       	ldi	r19, 0x0A	; 10
   10c8a:	00 e0       	ldi	r16, 0x00	; 0
   10c8c:	10 e0       	ldi	r17, 0x00	; 0
   10c8e:	b0 e1       	ldi	r27, 0x10	; 16
   10c90:	eb 2e       	mov	r14, r27
   10c92:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
		  switch(uiResult){
   10c96:	83 30       	cpi	r24, 0x03	; 3
   10c98:	51 f0       	breq	.+20     	; 0x10cae <FSettingOperator+0x190>
   10c9a:	84 30       	cpi	r24, 0x04	; 4
   10c9c:	08 f4       	brcc	.+2      	; 0x10ca0 <FSettingOperator+0x182>
   10c9e:	eb c0       	rjmp	.+470    	; 0x10e76 <FSettingOperator+0x358>
   10ca0:	84 30       	cpi	r24, 0x04	; 4
   10ca2:	09 f4       	brne	.+2      	; 0x10ca6 <FSettingOperator+0x188>
   10ca4:	52 c0       	rjmp	.+164    	; 0x10d4a <FSettingOperator+0x22c>
   10ca6:	85 30       	cpi	r24, 0x05	; 5
   10ca8:	09 f0       	breq	.+2      	; 0x10cac <FSettingOperator+0x18e>
   10caa:	13 c2       	rjmp	.+1062   	; 0x110d2 <FSettingOperator+0x5b4>
   10cac:	53 c0       	rjmp	.+166    	; 0x10d54 <FSettingOperator+0x236>
		  case USER_OK:
		       lcd_clear();
   10cae:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
   10cb2:	20 e0       	ldi	r18, 0x00	; 0
   10cb4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   10cb6:	ae 01       	movw	r20, r28
   10cb8:	40 5f       	subi	r20, 0xF0	; 240
   10cba:	5f 4f       	sbci	r21, 0xFF	; 255
   10cbc:	f9 01       	movw	r30, r18
   10cbe:	e9 51       	subi	r30, 0x19	; 25
   10cc0:	f5 4f       	sbci	r31, 0xF5	; 245
   10cc2:	da 01       	movw	r26, r20
   10cc4:	a2 0f       	add	r26, r18
   10cc6:	b3 1f       	adc	r27, r19
   10cc8:	8c 91       	ld	r24, X
   10cca:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10ccc:	2f 5f       	subi	r18, 0xFF	; 255
   10cce:	3f 4f       	sbci	r19, 0xFF	; 255
   10cd0:	2f 30       	cpi	r18, 0x0F	; 15
   10cd2:	31 05       	cpc	r19, r1
   10cd4:	99 f7       	brne	.-26     	; 0x10cbc <FSettingOperator+0x19e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10cd6:	10 92 f6 0a 	sts	0x0AF6, r1
	      uiResult=UserInput(UI_ALPHANUM_R,3,5,strFreeMessageLine1,0,16);
		  switch(uiResult){
		  case USER_OK:
		       lcd_clear();
			   StrPosCopy(strOperatorName,strFreeMessageLine1,0,15);
		       sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
   10cda:	00 d0       	rcall	.+0      	; 0x10cdc <FSettingOperator+0x1be>
   10cdc:	00 d0       	rcall	.+0      	; 0x10cde <FSettingOperator+0x1c0>
   10cde:	00 d0       	rcall	.+0      	; 0x10ce0 <FSettingOperator+0x1c2>
   10ce0:	ed b7       	in	r30, 0x3d	; 61
   10ce2:	fe b7       	in	r31, 0x3e	; 62
   10ce4:	31 96       	adiw	r30, 0x01	; 1
   10ce6:	8e 01       	movw	r16, r28
   10ce8:	0e 5d       	subi	r16, 0xDE	; 222
   10cea:	1f 4f       	sbci	r17, 0xFF	; 255
   10cec:	ad b7       	in	r26, 0x3d	; 61
   10cee:	be b7       	in	r27, 0x3e	; 62
   10cf0:	12 96       	adiw	r26, 0x02	; 2
   10cf2:	1c 93       	st	X, r17
   10cf4:	0e 93       	st	-X, r16
   10cf6:	11 97       	sbiw	r26, 0x01	; 1
   10cf8:	8c e5       	ldi	r24, 0x5C	; 92
   10cfa:	90 e1       	ldi	r25, 0x10	; 16
   10cfc:	93 83       	std	Z+3, r25	; 0x03
   10cfe:	82 83       	std	Z+2, r24	; 0x02
   10d00:	55 83       	std	Z+5, r21	; 0x05
   10d02:	44 83       	std	Z+4, r20	; 0x04
   10d04:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			   lcd_printf(1,1,PSTR("New Operator:"));
   10d08:	8d b7       	in	r24, 0x3d	; 61
   10d0a:	9e b7       	in	r25, 0x3e	; 62
   10d0c:	06 96       	adiw	r24, 0x06	; 6
   10d0e:	0f b6       	in	r0, 0x3f	; 63
   10d10:	f8 94       	cli
   10d12:	9e bf       	out	0x3e, r25	; 62
   10d14:	0f be       	out	0x3f, r0	; 63
   10d16:	8d bf       	out	0x3d, r24	; 61
   10d18:	81 e0       	ldi	r24, 0x01	; 1
   10d1a:	61 e0       	ldi	r22, 0x01	; 1
   10d1c:	4e e4       	ldi	r20, 0x4E	; 78
   10d1e:	50 e1       	ldi	r21, 0x10	; 16
   10d20:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			   lcd_print (2,1,lcdteks);
   10d24:	82 e0       	ldi	r24, 0x02	; 2
   10d26:	61 e0       	ldi	r22, 0x01	; 1
   10d28:	a8 01       	movw	r20, r16
   10d2a:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			   lcd_printf(3,1,PSTR("Save?"));
   10d2e:	83 e0       	ldi	r24, 0x03	; 3
   10d30:	61 e0       	ldi	r22, 0x01	; 1
   10d32:	48 e4       	ldi	r20, 0x48	; 72
   10d34:	50 e1       	ldi	r21, 0x10	; 16
   10d36:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]No    [#]Yes"));
   10d3a:	84 e0       	ldi	r24, 0x04	; 4
   10d3c:	61 e0       	ldi	r22, 0x01	; 1
   10d3e:	48 e3       	ldi	r20, 0x38	; 56
   10d40:	50 e1       	ldi	r21, 0x10	; 16
   10d42:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
               stSettingOperator=soIsSaveOperatorName;
   10d46:	84 e0       	ldi	r24, 0x04	; 4
   10d48:	9a c1       	rjmp	.+820    	; 0x1107e <FSettingOperator+0x560>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10d4a:	84 e0       	ldi	r24, 0x04	; 4
   10d4c:	61 e0       	ldi	r22, 0x01	; 1
   10d4e:	43 e2       	ldi	r20, 0x23	; 35
   10d50:	50 e1       	ldi	r21, 0x10	; 16
   10d52:	1f c1       	rjmp	.+574    	; 0x10f92 <FSettingOperator+0x474>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10d54:	84 e0       	ldi	r24, 0x04	; 4
   10d56:	61 e0       	ldi	r22, 0x01	; 1
   10d58:	4e e0       	ldi	r20, 0x0E	; 14
   10d5a:	50 e1       	ldi	r21, 0x10	; 16
   10d5c:	1a c1       	rjmp	.+564    	; 0x10f92 <FSettingOperator+0x474>
		       break;
		  }
	      break;
     case soIsSaveOperatorName:
          KeyPressed=_key_scan(1);
   10d5e:	81 e0       	ldi	r24, 0x01	; 1
   10d60:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   10d64:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
		  switch(KeyChar){
   10d68:	83 32       	cpi	r24, 0x23	; 35
   10d6a:	09 f0       	breq	.+2      	; 0x10d6e <FSettingOperator+0x250>
   10d6c:	4b c0       	rjmp	.+150    	; 0x10e04 <FSettingOperator+0x2e6>
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
   10d6e:	20 e0       	ldi	r18, 0x00	; 0
   10d70:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   10d72:	8e 01       	movw	r16, r28
   10d74:	00 5f       	subi	r16, 0xF0	; 240
   10d76:	1f 4f       	sbci	r17, 0xFF	; 255
   10d78:	f9 01       	movw	r30, r18
   10d7a:	e9 51       	subi	r30, 0x19	; 25
   10d7c:	f5 4f       	sbci	r31, 0xF5	; 245
   10d7e:	d8 01       	movw	r26, r16
   10d80:	a2 0f       	add	r26, r18
   10d82:	b3 1f       	adc	r27, r19
   10d84:	8c 91       	ld	r24, X
   10d86:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10d88:	2f 5f       	subi	r18, 0xFF	; 255
   10d8a:	3f 4f       	sbci	r19, 0xFF	; 255
   10d8c:	2f 30       	cpi	r18, 0x0F	; 15
   10d8e:	31 05       	cpc	r19, r1
   10d90:	99 f7       	brne	.-26     	; 0x10d78 <FSettingOperator+0x25a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10d92:	10 92 f6 0a 	sts	0x0AF6, r1
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
          case '#':
		       StrPosCopy(strOperatorName,strFreeMessageLine1,0,15);
               AddSpaceLag(strOperatorName,18); 
   10d96:	c8 01       	movw	r24, r16
   10d98:	62 e1       	ldi	r22, 0x12	; 18
   10d9a:	0e 94 b9 2a 	call	0x5572	; 0x5572 <AddSpaceLag>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   10d9e:	85 e1       	ldi	r24, 0x15	; 21
   10da0:	90 e0       	ldi	r25, 0x00	; 0
   10da2:	b8 01       	movw	r22, r16
   10da4:	42 e1       	ldi	r20, 0x12	; 18
   10da6:	50 e0       	ldi	r21, 0x00	; 0
   10da8:	2d ed       	ldi	r18, 0xDD	; 221
   10daa:	32 e1       	ldi	r19, 0x12	; 18
   10dac:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
		       eeprom_write_block((const void*) &strOperatorName, (void*) &DefOperatorName,18);
		       lcd_printf(3,1,PSTR("Saved "));
   10db0:	83 e0       	ldi	r24, 0x03	; 3
   10db2:	61 e0       	ldi	r22, 0x01	; 1
   10db4:	47 e0       	ldi	r20, 0x07	; 7
   10db6:	50 e1       	ldi	r21, 0x10	; 16
   10db8:	43 c1       	rjmp	.+646    	; 0x11040 <FSettingOperator+0x522>
		       stSettingOperator=soDelayDisplaySaved;
		       break;
		  }	      
		  break;
     case soChangePasswordInit:
	      lcd_clear();
   10dba:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("-Change Password-"));
   10dbe:	81 e0       	ldi	r24, 0x01	; 1
   10dc0:	61 e0       	ldi	r22, 0x01	; 1
   10dc2:	45 ef       	ldi	r20, 0xF5	; 245
   10dc4:	5f e0       	ldi	r21, 0x0F	; 15
   10dc6:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Supervisor"));
   10dca:	82 e0       	ldi	r24, 0x02	; 2
   10dcc:	61 e0       	ldi	r22, 0x01	; 1
   10dce:	48 ee       	ldi	r20, 0xE8	; 232
   10dd0:	5f e0       	ldi	r21, 0x0F	; 15
   10dd2:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Administrator"));
   10dd6:	83 e0       	ldi	r24, 0x03	; 3
   10dd8:	61 e0       	ldi	r22, 0x01	; 1
   10dda:	48 ed       	ldi	r20, 0xD8	; 216
   10ddc:	5f e0       	ldi	r21, 0x0F	; 15
   10dde:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back     "));
   10de2:	84 e0       	ldi	r24, 0x04	; 4
   10de4:	61 e0       	ldi	r22, 0x01	; 1
   10de6:	4b ec       	ldi	r20, 0xCB	; 203
   10de8:	5f e0       	ldi	r21, 0x0F	; 15
   10dea:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          stSettingOperator=soChangePasswordInput; 
   10dee:	86 e0       	ldi	r24, 0x06	; 6
   10df0:	46 c1       	rjmp	.+652    	; 0x1107e <FSettingOperator+0x560>
	      break;
     case soChangePasswordInput:
          KeyPressed=_key_scan(1);
   10df2:	81 e0       	ldi	r24, 0x01	; 1
   10df4:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   10df8:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
		  switch(KeyChar){
   10dfc:	81 33       	cpi	r24, 0x31	; 49
   10dfe:	31 f0       	breq	.+12     	; 0x10e0c <FSettingOperator+0x2ee>
   10e00:	82 33       	cpi	r24, 0x32	; 50
   10e02:	31 f0       	breq	.+12     	; 0x10e10 <FSettingOperator+0x2f2>
   10e04:	8a 32       	cpi	r24, 0x2A	; 42
   10e06:	09 f0       	breq	.+2      	; 0x10e0a <FSettingOperator+0x2ec>
   10e08:	64 c1       	rjmp	.+712    	; 0x110d2 <FSettingOperator+0x5b4>
   10e0a:	5c c1       	rjmp	.+696    	; 0x110c4 <FSettingOperator+0x5a6>
		  case '1':		 
		       PassType=PT_SUPERVISOR;
   10e0c:	81 e0       	ldi	r24, 0x01	; 1
   10e0e:	01 c0       	rjmp	.+2      	; 0x10e12 <FSettingOperator+0x2f4>
		       stSettingOperator=soOldPasswordDisplay;
		       break;
          case '2':		       
		       PassType=PT_ADMINISTRATOR;
   10e10:	82 e0       	ldi	r24, 0x02	; 2
   10e12:	80 93 e1 02 	sts	0x02E1, r24
   10e16:	75 c0       	rjmp	.+234    	; 0x10f02 <FSettingOperator+0x3e4>
		       stSettingOperator=soMenuOption;
		       break;
		  }	      
	      break;
     case soOldPasswordDisplay:
	 	  lcd_clear();
   10e18:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
	      if (PassType==PT_SUPERVISOR){
   10e1c:	80 91 e1 02 	lds	r24, 0x02E1
   10e20:	81 30       	cpi	r24, 0x01	; 1
   10e22:	21 f4       	brne	.+8      	; 0x10e2c <FSettingOperator+0x30e>
		      lcd_printf(1,1,PSTR("-Supervisor-"));              
   10e24:	61 e0       	ldi	r22, 0x01	; 1
   10e26:	4e eb       	ldi	r20, 0xBE	; 190
   10e28:	5f e0       	ldi	r21, 0x0F	; 15
   10e2a:	06 c0       	rjmp	.+12     	; 0x10e38 <FSettingOperator+0x31a>
		  }else if (PassType==PT_ADMINISTRATOR){		       
   10e2c:	82 30       	cpi	r24, 0x02	; 2
   10e2e:	31 f4       	brne	.+12     	; 0x10e3c <FSettingOperator+0x31e>
		       lcd_printf(1,1,PSTR("-Administrator-"));			   
   10e30:	81 e0       	ldi	r24, 0x01	; 1
   10e32:	61 e0       	ldi	r22, 0x01	; 1
   10e34:	4e ea       	ldi	r20, 0xAE	; 174
   10e36:	5f e0       	ldi	r21, 0x0F	; 15
   10e38:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  }
		      lcd_printf(2,1,PSTR("Old:_"));
   10e3c:	82 e0       	ldi	r24, 0x02	; 2
   10e3e:	61 e0       	ldi	r22, 0x01	; 1
   10e40:	48 ea       	ldi	r20, 0xA8	; 168
   10e42:	5f e0       	ldi	r21, 0x0F	; 15
   10e44:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10e48:	84 e0       	ldi	r24, 0x04	; 4
   10e4a:	61 e0       	ldi	r22, 0x01	; 1
   10e4c:	43 e9       	ldi	r20, 0x93	; 147
   10e4e:	5f e0       	ldi	r21, 0x0F	; 15
   10e50:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>

          stSettingOperator=soOldPasswordEntry;
   10e54:	88 e0       	ldi	r24, 0x08	; 8
   10e56:	13 c1       	rjmp	.+550    	; 0x1107e <FSettingOperator+0x560>
	      break;
     case soOldPasswordEntry:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine1,0,8);           
   10e58:	84 e0       	ldi	r24, 0x04	; 4
   10e5a:	62 e0       	ldi	r22, 0x02	; 2
   10e5c:	45 e0       	ldi	r20, 0x05	; 5
   10e5e:	27 ee       	ldi	r18, 0xE7	; 231
   10e60:	3a e0       	ldi	r19, 0x0A	; 10
   10e62:	00 e0       	ldi	r16, 0x00	; 0
   10e64:	10 e0       	ldi	r17, 0x00	; 0
   10e66:	a8 e0       	ldi	r26, 0x08	; 8
   10e68:	ea 2e       	mov	r14, r26
   10e6a:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
		  switch(uiResult){
   10e6e:	83 30       	cpi	r24, 0x03	; 3
   10e70:	61 f0       	breq	.+24     	; 0x10e8a <FSettingOperator+0x36c>
   10e72:	84 30       	cpi	r24, 0x04	; 4
   10e74:	20 f4       	brcc	.+8      	; 0x10e7e <FSettingOperator+0x360>
   10e76:	81 30       	cpi	r24, 0x01	; 1
   10e78:	09 f0       	breq	.+2      	; 0x10e7c <FSettingOperator+0x35e>
   10e7a:	2b c1       	rjmp	.+598    	; 0x110d2 <FSettingOperator+0x5b4>
   10e7c:	23 c1       	rjmp	.+582    	; 0x110c4 <FSettingOperator+0x5a6>
   10e7e:	84 30       	cpi	r24, 0x04	; 4
   10e80:	79 f0       	breq	.+30     	; 0x10ea0 <FSettingOperator+0x382>
   10e82:	85 30       	cpi	r24, 0x05	; 5
   10e84:	09 f0       	breq	.+2      	; 0x10e88 <FSettingOperator+0x36a>
   10e86:	25 c1       	rjmp	.+586    	; 0x110d2 <FSettingOperator+0x5b4>
   10e88:	10 c0       	rjmp	.+32     	; 0x10eaa <FSettingOperator+0x38c>
		  case USER_OK:
		       lcd_printf(2,1,PSTR("New:_"));
   10e8a:	82 e0       	ldi	r24, 0x02	; 2
   10e8c:	61 e0       	ldi	r22, 0x01	; 1
   10e8e:	4d e8       	ldi	r20, 0x8D	; 141
   10e90:	5f e0       	ldi	r21, 0x0F	; 15
   10e92:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10e96:	84 e0       	ldi	r24, 0x04	; 4
   10e98:	61 e0       	ldi	r22, 0x01	; 1
   10e9a:	48 e7       	ldi	r20, 0x78	; 120
   10e9c:	5f e0       	ldi	r21, 0x0F	; 15
   10e9e:	6c c0       	rjmp	.+216    	; 0x10f78 <FSettingOperator+0x45a>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10ea0:	84 e0       	ldi	r24, 0x04	; 4
   10ea2:	61 e0       	ldi	r22, 0x01	; 1
   10ea4:	43 e6       	ldi	r20, 0x63	; 99
   10ea6:	5f e0       	ldi	r21, 0x0F	; 15
   10ea8:	74 c0       	rjmp	.+232    	; 0x10f92 <FSettingOperator+0x474>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10eaa:	84 e0       	ldi	r24, 0x04	; 4
   10eac:	61 e0       	ldi	r22, 0x01	; 1
   10eae:	4e e4       	ldi	r20, 0x4E	; 78
   10eb0:	5f e0       	ldi	r21, 0x0F	; 15
   10eb2:	6f c0       	rjmp	.+222    	; 0x10f92 <FSettingOperator+0x474>
		       break;
		  }
	      break;
     case soNewPasswordEntry1:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine2,0,8);           
   10eb4:	84 e0       	ldi	r24, 0x04	; 4
   10eb6:	62 e0       	ldi	r22, 0x02	; 2
   10eb8:	45 e0       	ldi	r20, 0x05	; 5
   10eba:	26 ed       	ldi	r18, 0xD6	; 214
   10ebc:	39 e0       	ldi	r19, 0x09	; 9
   10ebe:	00 e0       	ldi	r16, 0x00	; 0
   10ec0:	10 e0       	ldi	r17, 0x00	; 0
   10ec2:	f8 e0       	ldi	r31, 0x08	; 8
   10ec4:	ef 2e       	mov	r14, r31
   10ec6:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
		  switch(uiResult){
   10eca:	83 30       	cpi	r24, 0x03	; 3
   10ecc:	61 f0       	breq	.+24     	; 0x10ee6 <FSettingOperator+0x3c8>
   10ece:	84 30       	cpi	r24, 0x04	; 4
   10ed0:	20 f4       	brcc	.+8      	; 0x10eda <FSettingOperator+0x3bc>
   10ed2:	81 30       	cpi	r24, 0x01	; 1
   10ed4:	09 f0       	breq	.+2      	; 0x10ed8 <FSettingOperator+0x3ba>
   10ed6:	fd c0       	rjmp	.+506    	; 0x110d2 <FSettingOperator+0x5b4>
   10ed8:	14 c0       	rjmp	.+40     	; 0x10f02 <FSettingOperator+0x3e4>
   10eda:	84 30       	cpi	r24, 0x04	; 4
   10edc:	a1 f0       	breq	.+40     	; 0x10f06 <FSettingOperator+0x3e8>
   10ede:	85 30       	cpi	r24, 0x05	; 5
   10ee0:	09 f0       	breq	.+2      	; 0x10ee4 <FSettingOperator+0x3c6>
   10ee2:	f7 c0       	rjmp	.+494    	; 0x110d2 <FSettingOperator+0x5b4>
   10ee4:	15 c0       	rjmp	.+42     	; 0x10f10 <FSettingOperator+0x3f2>
		  case USER_OK:
		       lcd_printf(3,1,PSTR("New:_"));
   10ee6:	83 e0       	ldi	r24, 0x03	; 3
   10ee8:	61 e0       	ldi	r22, 0x01	; 1
   10eea:	48 e4       	ldi	r20, 0x48	; 72
   10eec:	5f e0       	ldi	r21, 0x0F	; 15
   10eee:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10ef2:	84 e0       	ldi	r24, 0x04	; 4
   10ef4:	61 e0       	ldi	r22, 0x01	; 1
   10ef6:	43 e3       	ldi	r20, 0x33	; 51
   10ef8:	5f e0       	ldi	r21, 0x0F	; 15
   10efa:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		       stSettingOperator=soNewPasswordEntry2;
   10efe:	8a e0       	ldi	r24, 0x0A	; 10
   10f00:	be c0       	rjmp	.+380    	; 0x1107e <FSettingOperator+0x560>
		       break;
		  case USER_CANCEL:		       
			   stSettingOperator=soOldPasswordDisplay;
   10f02:	87 e0       	ldi	r24, 0x07	; 7
   10f04:	bc c0       	rjmp	.+376    	; 0x1107e <FSettingOperator+0x560>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10f06:	84 e0       	ldi	r24, 0x04	; 4
   10f08:	61 e0       	ldi	r22, 0x01	; 1
   10f0a:	4e e1       	ldi	r20, 0x1E	; 30
   10f0c:	5f e0       	ldi	r21, 0x0F	; 15
   10f0e:	41 c0       	rjmp	.+130    	; 0x10f92 <FSettingOperator+0x474>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10f10:	84 e0       	ldi	r24, 0x04	; 4
   10f12:	61 e0       	ldi	r22, 0x01	; 1
   10f14:	49 e0       	ldi	r20, 0x09	; 9
   10f16:	5f e0       	ldi	r21, 0x0F	; 15
   10f18:	3c c0       	rjmp	.+120    	; 0x10f92 <FSettingOperator+0x474>
		       break;
		  }	      
	      break;
     case soNewPasswordEntry2:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine3,0,8);           
   10f1a:	84 e0       	ldi	r24, 0x04	; 4
   10f1c:	62 e0       	ldi	r22, 0x02	; 2
   10f1e:	45 e0       	ldi	r20, 0x05	; 5
   10f20:	21 e7       	ldi	r18, 0x71	; 113
   10f22:	3a e0       	ldi	r19, 0x0A	; 10
   10f24:	00 e0       	ldi	r16, 0x00	; 0
   10f26:	10 e0       	ldi	r17, 0x00	; 0
   10f28:	e8 e0       	ldi	r30, 0x08	; 8
   10f2a:	ee 2e       	mov	r14, r30
   10f2c:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
		  switch(uiResult){
   10f30:	83 30       	cpi	r24, 0x03	; 3
   10f32:	61 f0       	breq	.+24     	; 0x10f4c <FSettingOperator+0x42e>
   10f34:	84 30       	cpi	r24, 0x04	; 4
   10f36:	20 f4       	brcc	.+8      	; 0x10f40 <FSettingOperator+0x422>
   10f38:	81 30       	cpi	r24, 0x01	; 1
   10f3a:	09 f0       	breq	.+2      	; 0x10f3e <FSettingOperator+0x420>
   10f3c:	ca c0       	rjmp	.+404    	; 0x110d2 <FSettingOperator+0x5b4>
   10f3e:	10 c0       	rjmp	.+32     	; 0x10f60 <FSettingOperator+0x442>
   10f40:	84 30       	cpi	r24, 0x04	; 4
   10f42:	f1 f0       	breq	.+60     	; 0x10f80 <FSettingOperator+0x462>
   10f44:	85 30       	cpi	r24, 0x05	; 5
   10f46:	09 f0       	breq	.+2      	; 0x10f4a <FSettingOperator+0x42c>
   10f48:	c4 c0       	rjmp	.+392    	; 0x110d2 <FSettingOperator+0x5b4>
   10f4a:	1f c0       	rjmp	.+62     	; 0x10f8a <FSettingOperator+0x46c>
		  case USER_OK:
               lcd_printf(1,1,PSTR("Validating.."));
   10f4c:	81 e0       	ldi	r24, 0x01	; 1
   10f4e:	61 e0       	ldi	r22, 0x01	; 1
   10f50:	4c ef       	ldi	r20, 0xFC	; 252
   10f52:	5e e0       	ldi	r21, 0x0E	; 14
   10f54:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			   TimDisplay=0;
   10f58:	10 92 a7 01 	sts	0x01A7, r1
		       stSettingOperator=soDispValidatePassword;
   10f5c:	8b e0       	ldi	r24, 0x0B	; 11
   10f5e:	8f c0       	rjmp	.+286    	; 0x1107e <FSettingOperator+0x560>
		       break;
		  case USER_CANCEL:
               lcd_clear();
   10f60:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
               lcd_printf(2,1,PSTR("New:_"));
   10f64:	82 e0       	ldi	r24, 0x02	; 2
   10f66:	61 e0       	ldi	r22, 0x01	; 1
   10f68:	46 ef       	ldi	r20, 0xF6	; 246
   10f6a:	5e e0       	ldi	r21, 0x0E	; 14
   10f6c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10f70:	84 e0       	ldi	r24, 0x04	; 4
   10f72:	61 e0       	ldi	r22, 0x01	; 1
   10f74:	41 ee       	ldi	r20, 0xE1	; 225
   10f76:	5e e0       	ldi	r21, 0x0E	; 14
   10f78:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		       stSettingOperator=soNewPasswordEntry1;
   10f7c:	89 e0       	ldi	r24, 0x09	; 9
   10f7e:	7f c0       	rjmp	.+254    	; 0x1107e <FSettingOperator+0x560>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10f80:	84 e0       	ldi	r24, 0x04	; 4
   10f82:	61 e0       	ldi	r22, 0x01	; 1
   10f84:	4c ec       	ldi	r20, 0xCC	; 204
   10f86:	5e e0       	ldi	r21, 0x0E	; 14
   10f88:	04 c0       	rjmp	.+8      	; 0x10f92 <FSettingOperator+0x474>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10f8a:	84 e0       	ldi	r24, 0x04	; 4
   10f8c:	61 e0       	ldi	r22, 0x01	; 1
   10f8e:	47 eb       	ldi	r20, 0xB7	; 183
   10f90:	5e e0       	ldi	r21, 0x0E	; 14
   10f92:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   10f96:	9d c0       	rjmp	.+314    	; 0x110d2 <FSettingOperator+0x5b4>
		       break;
		  }	      
	      break;
     case soDispValidatePassword:
	      if (TimDisplay>3)stSettingOperator=soValidatePassword;
   10f98:	80 91 a7 01 	lds	r24, 0x01A7
   10f9c:	84 30       	cpi	r24, 0x04	; 4
   10f9e:	08 f4       	brcc	.+2      	; 0x10fa2 <FSettingOperator+0x484>
   10fa0:	98 c0       	rjmp	.+304    	; 0x110d2 <FSettingOperator+0x5b4>
   10fa2:	8c e0       	ldi	r24, 0x0C	; 12
   10fa4:	6c c0       	rjmp	.+216    	; 0x1107e <FSettingOperator+0x560>
	      break;
     case soValidatePassword:
          if (PassType==PT_SUPERVISOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSysPassword, 10);		      			   
   10fa6:	80 91 e1 02 	lds	r24, 0x02E1
   10faa:	81 30       	cpi	r24, 0x01	; 1
   10fac:	29 f4       	brne	.+10     	; 0x10fb8 <FSettingOperator+0x49a>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   10fae:	ce 01       	movw	r24, r28
   10fb0:	01 96       	adiw	r24, 0x01	; 1
   10fb2:	6b e0       	ldi	r22, 0x0B	; 11
   10fb4:	70 e0       	ldi	r23, 0x00	; 0
   10fb6:	06 c0       	rjmp	.+12     	; 0x10fc4 <FSettingOperator+0x4a6>
		  else 
		  if (PassType==PT_ADMINISTRATOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSpvPassword, 10);    
   10fb8:	82 30       	cpi	r24, 0x02	; 2
   10fba:	51 f4       	brne	.+20     	; 0x10fd0 <FSettingOperator+0x4b2>
   10fbc:	ce 01       	movw	r24, r28
   10fbe:	01 96       	adiw	r24, 0x01	; 1
   10fc0:	61 e0       	ldi	r22, 0x01	; 1
   10fc2:	70 e0       	ldi	r23, 0x00	; 0
   10fc4:	4a e0       	ldi	r20, 0x0A	; 10
   10fc6:	50 e0       	ldi	r21, 0x00	; 0
   10fc8:	25 ed       	ldi	r18, 0xD5	; 213
   10fca:	32 e1       	ldi	r19, 0x12	; 18
   10fcc:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
		  
		  //Check Old Validity
		  if (strcmp(strPassword,strFreeMessageLine1)==0){//OldMessage Valid
   10fd0:	ce 01       	movw	r24, r28
   10fd2:	01 96       	adiw	r24, 0x01	; 1
   10fd4:	67 ee       	ldi	r22, 0xE7	; 231
   10fd6:	7a e0       	ldi	r23, 0x0A	; 10
   10fd8:	0e 94 e4 b3 	call	0x167c8	; 0x167c8 <strcmp>
   10fdc:	00 97       	sbiw	r24, 0x00	; 0
   10fde:	09 f0       	breq	.+2      	; 0x10fe2 <FSettingOperator+0x4c4>
   10fe0:	51 c0       	rjmp	.+162    	; 0x11084 <FSettingOperator+0x566>
              if (strcmp(strFreeMessageLine2,strFreeMessageLine3)==0){
   10fe2:	86 ed       	ldi	r24, 0xD6	; 214
   10fe4:	99 e0       	ldi	r25, 0x09	; 9
   10fe6:	61 e7       	ldi	r22, 0x71	; 113
   10fe8:	7a e0       	ldi	r23, 0x0A	; 10
   10fea:	0e 94 e4 b3 	call	0x167c8	; 0x167c8 <strcmp>
   10fee:	00 97       	sbiw	r24, 0x00	; 0
   10ff0:	69 f5       	brne	.+90     	; 0x1104c <FSettingOperator+0x52e>
                  
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
   10ff2:	80 91 e1 02 	lds	r24, 0x02E1
   10ff6:	81 30       	cpi	r24, 0x01	; 1
   10ff8:	19 f4       	brne	.+6      	; 0x11000 <FSettingOperator+0x4e2>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   10ffa:	8b e0       	ldi	r24, 0x0B	; 11
   10ffc:	90 e0       	ldi	r25, 0x00	; 0
   10ffe:	04 c0       	rjmp	.+8      	; 0x11008 <FSettingOperator+0x4ea>
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSpvPassword, 10);    
   11000:	82 30       	cpi	r24, 0x02	; 2
   11002:	51 f4       	brne	.+20     	; 0x11018 <FSettingOperator+0x4fa>
   11004:	81 e0       	ldi	r24, 0x01	; 1
   11006:	90 e0       	ldi	r25, 0x00	; 0
   11008:	66 ed       	ldi	r22, 0xD6	; 214
   1100a:	79 e0       	ldi	r23, 0x09	; 9
   1100c:	4a e0       	ldi	r20, 0x0A	; 10
   1100e:	50 e0       	ldi	r21, 0x00	; 0
   11010:	2d ed       	ldi	r18, 0xDD	; 221
   11012:	32 e1       	ldi	r19, 0x12	; 18
   11014:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11018:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1101a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1101c:	81 e0       	ldi	r24, 0x01	; 1
   1101e:	90 e0       	ldi	r25, 0x00	; 0
   11020:	90 93 d7 01 	sts	0x01D7, r25
   11024:	80 93 d6 01 	sts	0x01D6, r24
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSpvPassword, 10);    

			      system_beep(1);
				  lcd_clear();
   11028:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
			      lcd_printf(2,1,PSTR("     Completed      "));
   1102c:	82 e0       	ldi	r24, 0x02	; 2
   1102e:	61 e0       	ldi	r22, 0x01	; 1
   11030:	42 ea       	ldi	r20, 0xA2	; 162
   11032:	5e e0       	ldi	r21, 0x0E	; 14
   11034:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
   11038:	83 e0       	ldi	r24, 0x03	; 3
   1103a:	61 e0       	ldi	r22, 0x01	; 1
   1103c:	4d e8       	ldi	r20, 0x8D	; 141
   1103e:	5e e0       	ldi	r21, 0x0E	; 14
   11040:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				  TimDisplay=0;
   11044:	10 92 a7 01 	sts	0x01A7, r1
				  stSettingOperator=soDelayDisplaySaved;
   11048:	8e e0       	ldi	r24, 0x0E	; 14
   1104a:	19 c0       	rjmp	.+50     	; 0x1107e <FSettingOperator+0x560>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1104c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1104e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11050:	82 e0       	ldi	r24, 0x02	; 2
   11052:	90 e0       	ldi	r25, 0x00	; 0
   11054:	90 93 d7 01 	sts	0x01D7, r25
   11058:	80 93 d6 01 	sts	0x01D6, r24
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
				  TimDisplay=0;
				  stSettingOperator=soDelayDisplaySaved;
			  }else {
			  system_beep(2);
		      TimDisplay=0;
   1105c:	10 92 a7 01 	sts	0x01A7, r1
		      lcd_clear();
   11060:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		      lcd_printf(2,1,PSTR("      ERROR         "));
   11064:	82 e0       	ldi	r24, 0x02	; 2
   11066:	61 e0       	ldi	r22, 0x01	; 1
   11068:	48 e7       	ldi	r20, 0x78	; 120
   1106a:	5e e0       	ldi	r21, 0x0E	; 14
   1106c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		      lcd_printf(3,1,PSTR("Invalid New Password"));
   11070:	83 e0       	ldi	r24, 0x03	; 3
   11072:	61 e0       	ldi	r22, 0x01	; 1
   11074:	43 e6       	ldi	r20, 0x63	; 99
   11076:	5e e0       	ldi	r21, 0x0E	; 14
   11078:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		      stSettingOperator=soDisplayInvalidPassword;
   1107c:	8d e0       	ldi	r24, 0x0D	; 13
   1107e:	80 93 e2 02 	sts	0x02E2, r24
   11082:	27 c0       	rjmp	.+78     	; 0x110d2 <FSettingOperator+0x5b4>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11084:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   11086:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11088:	82 e0       	ldi	r24, 0x02	; 2
   1108a:	90 e0       	ldi	r25, 0x00	; 0
   1108c:	90 93 d7 01 	sts	0x01D7, r25
   11090:	80 93 d6 01 	sts	0x01D6, r24
		      stSettingOperator=soDisplayInvalidPassword;
			  }
		  }else {
		   //InvalidOld Password
		   system_beep(2);
		   TimDisplay=0;
   11094:	10 92 a7 01 	sts	0x01A7, r1
		   lcd_clear();
   11098:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		   lcd_printf(2,1,PSTR("      ERROR         "));
   1109c:	82 e0       	ldi	r24, 0x02	; 2
   1109e:	61 e0       	ldi	r22, 0x01	; 1
   110a0:	4e e4       	ldi	r20, 0x4E	; 78
   110a2:	5e e0       	ldi	r21, 0x0E	; 14
   110a4:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		   lcd_printf(3,1,PSTR("Invalid Old Password"));
   110a8:	83 e0       	ldi	r24, 0x03	; 3
   110aa:	61 e0       	ldi	r22, 0x01	; 1
   110ac:	49 e3       	ldi	r20, 0x39	; 57
   110ae:	5e e0       	ldi	r21, 0x0E	; 14
   110b0:	e3 cf       	rjmp	.-58     	; 0x11078 <FSettingOperator+0x55a>
		   stSettingOperator=soDisplayInvalidPassword;
		   }
	      break;
     case soDisplayInvalidPassword:
	      if (TimDisplay>6)stSettingOperator=soMenuOption;
   110b2:	80 91 a7 01 	lds	r24, 0x01A7
   110b6:	87 30       	cpi	r24, 0x07	; 7
   110b8:	60 f0       	brcs	.+24     	; 0x110d2 <FSettingOperator+0x5b4>
   110ba:	04 c0       	rjmp	.+8      	; 0x110c4 <FSettingOperator+0x5a6>
	      break;
     case soDelayDisplaySaved:
	      if (TimDisplay>4)stSettingOperator=soMenuOption;
   110bc:	80 91 a7 01 	lds	r24, 0x01A7
   110c0:	85 30       	cpi	r24, 0x05	; 5
   110c2:	38 f0       	brcs	.+14     	; 0x110d2 <FSettingOperator+0x5b4>
   110c4:	10 92 e2 02 	sts	0x02E2, r1
   110c8:	04 c0       	rjmp	.+8      	; 0x110d2 <FSettingOperator+0x5b4>
	      break;
	 case soExitSettingOperator:
	      stSettingOperator=soMenuOption;
   110ca:	10 92 e2 02 	sts	0x02E2, r1
   110ce:	81 e0       	ldi	r24, 0x01	; 1
   110d0:	01 c0       	rjmp	.+2      	; 0x110d4 <FSettingOperator+0x5b6>
   110d2:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
   110d4:	e5 96       	adiw	r28, 0x35	; 53
   110d6:	0f b6       	in	r0, 0x3f	; 63
   110d8:	f8 94       	cli
   110da:	de bf       	out	0x3e, r29	; 62
   110dc:	0f be       	out	0x3f, r0	; 63
   110de:	cd bf       	out	0x3d, r28	; 61
   110e0:	cf 91       	pop	r28
   110e2:	df 91       	pop	r29
   110e4:	1f 91       	pop	r17
   110e6:	0f 91       	pop	r16
   110e8:	ef 90       	pop	r14
   110ea:	08 95       	ret

000110ec <FSettingProduct>:

void menu_product(){

}

char FSettingProduct(){//Using strDescription
   110ec:	6f 92       	push	r6
   110ee:	7f 92       	push	r7
   110f0:	8f 92       	push	r8
   110f2:	9f 92       	push	r9
   110f4:	af 92       	push	r10
   110f6:	bf 92       	push	r11
   110f8:	cf 92       	push	r12
   110fa:	df 92       	push	r13
   110fc:	ef 92       	push	r14
   110fe:	ff 92       	push	r15
   11100:	0f 93       	push	r16
   11102:	1f 93       	push	r17
   11104:	df 93       	push	r29
   11106:	cf 93       	push	r28
   11108:	cd b7       	in	r28, 0x3d	; 61
   1110a:	de b7       	in	r29, 0x3e	; 62
   1110c:	a1 97       	sbiw	r28, 0x21	; 33
   1110e:	0f b6       	in	r0, 0x3f	; 63
   11110:	f8 94       	cli
   11112:	de bf       	out	0x3e, r29	; 62
   11114:	0f be       	out	0x3f, r0	; 63
   11116:	cd bf       	out	0x3d, r28	; 61
     char i;//,x,y;
	 char strProductName[13],lcdteks[20];
	 char Result=MENU_NONE;
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
   11118:	80 91 ef 02 	lds	r24, 0x02EF
   1111c:	83 30       	cpi	r24, 0x03	; 3
   1111e:	09 f4       	brne	.+2      	; 0x11122 <FSettingProduct+0x36>
   11120:	ff c0       	rjmp	.+510    	; 0x11320 <FSettingProduct+0x234>
   11122:	84 30       	cpi	r24, 0x04	; 4
   11124:	38 f4       	brcc	.+14     	; 0x11134 <FSettingProduct+0x48>
   11126:	81 30       	cpi	r24, 0x01	; 1
   11128:	09 f4       	brne	.+2      	; 0x1112c <FSettingProduct+0x40>
   1112a:	72 c0       	rjmp	.+228    	; 0x11210 <FSettingProduct+0x124>
   1112c:	82 30       	cpi	r24, 0x02	; 2
   1112e:	08 f0       	brcs	.+2      	; 0x11132 <FSettingProduct+0x46>
   11130:	82 c0       	rjmp	.+260    	; 0x11236 <FSettingProduct+0x14a>
   11132:	0a c0       	rjmp	.+20     	; 0x11148 <FSettingProduct+0x5c>
   11134:	85 30       	cpi	r24, 0x05	; 5
   11136:	09 f4       	brne	.+2      	; 0x1113a <FSettingProduct+0x4e>
   11138:	83 c1       	rjmp	.+774    	; 0x11440 <FSettingProduct+0x354>
   1113a:	85 30       	cpi	r24, 0x05	; 5
   1113c:	08 f4       	brcc	.+2      	; 0x11140 <FSettingProduct+0x54>
   1113e:	a2 c1       	rjmp	.+836    	; 0x11484 <FSettingProduct+0x398>
   11140:	86 30       	cpi	r24, 0x06	; 6
   11142:	09 f0       	breq	.+2      	; 0x11146 <FSettingProduct+0x5a>
   11144:	c9 c1       	rjmp	.+914    	; 0x114d8 <FSettingProduct+0x3ec>
   11146:	c4 c1       	rjmp	.+904    	; 0x114d0 <FSettingProduct+0x3e4>
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   11148:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
   1114c:	bb eb       	ldi	r27, 0xBB	; 187
   1114e:	cb 2e       	mov	r12, r27
   11150:	b0 e0       	ldi	r27, 0x00	; 0
   11152:	db 2e       	mov	r13, r27
   11154:	a1 e0       	ldi	r26, 0x01	; 1
   11156:	ea 2e       	mov	r14, r26
   11158:	f1 2c       	mov	r15, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   1115a:	4e 01       	movw	r8, r28
   1115c:	08 94       	sec
   1115e:	81 1c       	adc	r8, r1
   11160:	91 1c       	adc	r9, r1
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   11162:	fe e0       	ldi	r31, 0x0E	; 14
   11164:	af 2e       	mov	r10, r31
   11166:	b1 2c       	mov	r11, r1
   11168:	ac 0e       	add	r10, r28
   1116a:	bd 1e       	adc	r11, r29
   1116c:	ec ec       	ldi	r30, 0xCC	; 204
   1116e:	6e 2e       	mov	r6, r30
   11170:	e1 e1       	ldi	r30, 0x11	; 17
   11172:	7e 2e       	mov	r7, r30
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   11174:	0a e0       	ldi	r16, 0x0A	; 10
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   11176:	1e 2d       	mov	r17, r14
   11178:	11 50       	subi	r17, 0x01	; 1
   1117a:	c4 01       	movw	r24, r8
   1117c:	b6 01       	movw	r22, r12
   1117e:	4d e0       	ldi	r20, 0x0D	; 13
   11180:	50 e0       	ldi	r21, 0x00	; 0
   11182:	25 ed       	ldi	r18, 0xD5	; 213
   11184:	32 e1       	ldi	r19, 0x12	; 18
   11186:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   1118a:	8d b7       	in	r24, 0x3d	; 61
   1118c:	9e b7       	in	r25, 0x3e	; 62
   1118e:	08 97       	sbiw	r24, 0x08	; 8
   11190:	0f b6       	in	r0, 0x3f	; 63
   11192:	f8 94       	cli
   11194:	9e bf       	out	0x3e, r25	; 62
   11196:	0f be       	out	0x3f, r0	; 63
   11198:	8d bf       	out	0x3d, r24	; 61
   1119a:	ed b7       	in	r30, 0x3d	; 61
   1119c:	fe b7       	in	r31, 0x3e	; 62
   1119e:	31 96       	adiw	r30, 0x01	; 1
   111a0:	ad b7       	in	r26, 0x3d	; 61
   111a2:	be b7       	in	r27, 0x3e	; 62
   111a4:	12 96       	adiw	r26, 0x02	; 2
   111a6:	bc 92       	st	X, r11
   111a8:	ae 92       	st	-X, r10
   111aa:	11 97       	sbiw	r26, 0x01	; 1
   111ac:	73 82       	std	Z+3, r7	; 0x03
   111ae:	62 82       	std	Z+2, r6	; 0x02
   111b0:	f5 82       	std	Z+5, r15	; 0x05
   111b2:	e4 82       	std	Z+4, r14	; 0x04
   111b4:	97 82       	std	Z+7, r9	; 0x07
   111b6:	86 82       	std	Z+6, r8	; 0x06
   111b8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   111bc:	8d b7       	in	r24, 0x3d	; 61
   111be:	9e b7       	in	r25, 0x3e	; 62
   111c0:	08 96       	adiw	r24, 0x08	; 8
   111c2:	0f b6       	in	r0, 0x3f	; 63
   111c4:	f8 94       	cli
   111c6:	9e bf       	out	0x3e, r25	; 62
   111c8:	0f be       	out	0x3f, r0	; 63
   111ca:	8d bf       	out	0x3d, r24	; 61
   111cc:	61 2f       	mov	r22, r17
   111ce:	66 95       	lsr	r22
   111d0:	66 95       	lsr	r22
   111d2:	60 9f       	mul	r22, r16
   111d4:	b0 01       	movw	r22, r0
   111d6:	11 24       	eor	r1, r1
   111d8:	6f 5f       	subi	r22, 0xFF	; 255
   111da:	13 70       	andi	r17, 0x03	; 3
   111dc:	81 2f       	mov	r24, r17
   111de:	8f 5f       	subi	r24, 0xFF	; 255
   111e0:	a5 01       	movw	r20, r10
   111e2:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
   111e6:	ad e0       	ldi	r26, 0x0D	; 13
   111e8:	b0 e0       	ldi	r27, 0x00	; 0
   111ea:	ca 0e       	add	r12, r26
   111ec:	db 1e       	adc	r13, r27
   111ee:	08 94       	sec
   111f0:	e1 1c       	adc	r14, r1
   111f2:	f1 1c       	adc	r15, r1
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
   111f4:	b9 e0       	ldi	r27, 0x09	; 9
   111f6:	cb 16       	cp	r12, r27
   111f8:	b1 e0       	ldi	r27, 0x01	; 1
   111fa:	db 06       	cpc	r13, r27
   111fc:	09 f0       	breq	.+2      	; 0x11200 <FSettingProduct+0x114>
   111fe:	bb cf       	rjmp	.-138    	; 0x11176 <FSettingProduct+0x8a>
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
		  }
		  lcd_printf(4,11,PSTR("*)Back"));
   11200:	84 e0       	ldi	r24, 0x04	; 4
   11202:	6b e0       	ldi	r22, 0x0B	; 11
   11204:	45 ec       	ldi	r20, 0xC5	; 197
   11206:	51 e1       	ldi	r21, 0x11	; 17
   11208:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          stMenuProduct=mpChangeProduct;
   1120c:	81 e0       	ldi	r24, 0x01	; 1
   1120e:	5a c1       	rjmp	.+692    	; 0x114c4 <FSettingProduct+0x3d8>
	      break;
     case mpChangeProduct:
		  KeyPressed=_key_scan(1);
   11210:	81 e0       	ldi	r24, 0x01	; 1
   11212:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   11216:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   11218:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   1121c:	81 53       	subi	r24, 0x31	; 49
   1121e:	86 30       	cpi	r24, 0x06	; 6
   11220:	28 f4       	brcc	.+10     	; 0x1122c <FSettingProduct+0x140>
		      ProdID=KeyChar-'1';
   11222:	80 93 ee 02 	sts	0x02EE, r24
			  stMenuProduct=mpDispPrice;
   11226:	82 e0       	ldi	r24, 0x02	; 2
   11228:	80 93 ef 02 	sts	0x02EF, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
   1122c:	17 3e       	cpi	r17, 0xE7	; 231
   1122e:	09 f0       	breq	.+2      	; 0x11232 <FSettingProduct+0x146>
   11230:	53 c1       	rjmp	.+678    	; 0x114d8 <FSettingProduct+0x3ec>
		      stMenuProduct=mpExitMenuProduct;
   11232:	86 e0       	ldi	r24, 0x06	; 6
   11234:	47 c1       	rjmp	.+654    	; 0x114c4 <FSettingProduct+0x3d8>
   11236:	60 91 ee 02 	lds	r22, 0x02EE
   1123a:	8d e0       	ldi	r24, 0x0D	; 13
   1123c:	68 9f       	mul	r22, r24
   1123e:	b0 01       	movw	r22, r0
   11240:	11 24       	eor	r1, r1
   11242:	65 54       	subi	r22, 0x45	; 69
   11244:	7f 4f       	sbci	r23, 0xFF	; 255
   11246:	7e 01       	movw	r14, r28
   11248:	08 94       	sec
   1124a:	e1 1c       	adc	r14, r1
   1124c:	f1 1c       	adc	r15, r1
   1124e:	c7 01       	movw	r24, r14
   11250:	4d e0       	ldi	r20, 0x0D	; 13
   11252:	50 e0       	ldi	r21, 0x00	; 0
   11254:	25 ed       	ldi	r18, 0xD5	; 213
   11256:	32 e1       	ldi	r19, 0x12	; 18
   11258:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
		  }
	      break;
     case mpDispPrice:
	 	  eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		  eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[ProdID], 9);
		  sprintf_P(lcdteks,PSTR("1)%s"),strProductName);
   1125c:	74 ee       	ldi	r23, 0xE4	; 228
   1125e:	c7 2e       	mov	r12, r23
   11260:	72 e0       	ldi	r23, 0x02	; 2
   11262:	d7 2e       	mov	r13, r23
   11264:	60 91 ee 02 	lds	r22, 0x02EE
   11268:	89 e0       	ldi	r24, 0x09	; 9
   1126a:	68 9f       	mul	r22, r24
   1126c:	b0 01       	movw	r22, r0
   1126e:	11 24       	eor	r1, r1
   11270:	6b 57       	subi	r22, 0x7B	; 123
   11272:	7f 4f       	sbci	r23, 0xFF	; 255
   11274:	c6 01       	movw	r24, r12
   11276:	49 e0       	ldi	r20, 0x09	; 9
   11278:	50 e0       	ldi	r21, 0x00	; 0
   1127a:	25 ed       	ldi	r18, 0xD5	; 213
   1127c:	32 e1       	ldi	r19, 0x12	; 18
   1127e:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
   11282:	00 d0       	rcall	.+0      	; 0x11284 <FSettingProduct+0x198>
   11284:	00 d0       	rcall	.+0      	; 0x11286 <FSettingProduct+0x19a>
   11286:	00 d0       	rcall	.+0      	; 0x11288 <FSettingProduct+0x19c>
   11288:	ed b7       	in	r30, 0x3d	; 61
   1128a:	fe b7       	in	r31, 0x3e	; 62
   1128c:	31 96       	adiw	r30, 0x01	; 1
   1128e:	8e 01       	movw	r16, r28
   11290:	02 5f       	subi	r16, 0xF2	; 242
   11292:	1f 4f       	sbci	r17, 0xFF	; 255
   11294:	ad b7       	in	r26, 0x3d	; 61
   11296:	be b7       	in	r27, 0x3e	; 62
   11298:	12 96       	adiw	r26, 0x02	; 2
   1129a:	1c 93       	st	X, r17
   1129c:	0e 93       	st	-X, r16
   1129e:	11 97       	sbiw	r26, 0x01	; 1
   112a0:	80 ec       	ldi	r24, 0xC0	; 192
   112a2:	91 e1       	ldi	r25, 0x11	; 17
   112a4:	93 83       	std	Z+3, r25	; 0x03
   112a6:	82 83       	std	Z+2, r24	; 0x02
   112a8:	f5 82       	std	Z+5, r15	; 0x05
   112aa:	e4 82       	std	Z+4, r14	; 0x04
   112ac:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_clear();lcd_print(1,1,lcdteks);
   112b0:	8d b7       	in	r24, 0x3d	; 61
   112b2:	9e b7       	in	r25, 0x3e	; 62
   112b4:	06 96       	adiw	r24, 0x06	; 6
   112b6:	0f b6       	in	r0, 0x3f	; 63
   112b8:	f8 94       	cli
   112ba:	9e bf       	out	0x3e, r25	; 62
   112bc:	0f be       	out	0x3f, r0	; 63
   112be:	8d bf       	out	0x3d, r24	; 61
   112c0:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
   112c4:	81 e0       	ldi	r24, 0x01	; 1
   112c6:	61 e0       	ldi	r22, 0x01	; 1
   112c8:	a8 01       	movw	r20, r16
   112ca:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2)%s"),strPrice);
   112ce:	00 d0       	rcall	.+0      	; 0x112d0 <FSettingProduct+0x1e4>
   112d0:	00 d0       	rcall	.+0      	; 0x112d2 <FSettingProduct+0x1e6>
   112d2:	00 d0       	rcall	.+0      	; 0x112d4 <FSettingProduct+0x1e8>
   112d4:	ed b7       	in	r30, 0x3d	; 61
   112d6:	fe b7       	in	r31, 0x3e	; 62
   112d8:	31 96       	adiw	r30, 0x01	; 1
   112da:	ad b7       	in	r26, 0x3d	; 61
   112dc:	be b7       	in	r27, 0x3e	; 62
   112de:	12 96       	adiw	r26, 0x02	; 2
   112e0:	1c 93       	st	X, r17
   112e2:	0e 93       	st	-X, r16
   112e4:	11 97       	sbiw	r26, 0x01	; 1
   112e6:	8b eb       	ldi	r24, 0xBB	; 187
   112e8:	91 e1       	ldi	r25, 0x11	; 17
   112ea:	93 83       	std	Z+3, r25	; 0x03
   112ec:	82 83       	std	Z+2, r24	; 0x02
   112ee:	d5 82       	std	Z+5, r13	; 0x05
   112f0:	c4 82       	std	Z+4, r12	; 0x04
   112f2:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   112f6:	8d b7       	in	r24, 0x3d	; 61
   112f8:	9e b7       	in	r25, 0x3e	; 62
   112fa:	06 96       	adiw	r24, 0x06	; 6
   112fc:	0f b6       	in	r0, 0x3f	; 63
   112fe:	f8 94       	cli
   11300:	9e bf       	out	0x3e, r25	; 62
   11302:	0f be       	out	0x3f, r0	; 63
   11304:	8d bf       	out	0x3d, r24	; 61
   11306:	82 e0       	ldi	r24, 0x02	; 2
   11308:	61 e0       	ldi	r22, 0x01	; 1
   1130a:	a8 01       	movw	r20, r16
   1130c:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_printf(4,1,PSTR("*)Back       "));
   11310:	84 e0       	ldi	r24, 0x04	; 4
   11312:	61 e0       	ldi	r22, 0x01	; 1
   11314:	4d ea       	ldi	r20, 0xAD	; 173
   11316:	51 e1       	ldi	r21, 0x11	; 17
   11318:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  stMenuProduct=mpIsEdit;
   1131c:	83 e0       	ldi	r24, 0x03	; 3
   1131e:	d2 c0       	rjmp	.+420    	; 0x114c4 <FSettingProduct+0x3d8>
	      break;
     case mpIsEdit:
		  KeyPressed=_key_scan(1);
   11320:	81 e0       	ldi	r24, 0x01	; 1
   11322:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   11326:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
		  if (KeyChar=='*'){
   1132a:	8a 32       	cpi	r24, 0x2A	; 42
   1132c:	09 f4       	brne	.+2      	; 0x11330 <FSettingProduct+0x244>
   1132e:	a7 c0       	rjmp	.+334    	; 0x1147e <FSettingProduct+0x392>
		      stMenuProduct=mpInitProduct;
		  }else
		  if (KeyChar=='1'){
   11330:	81 33       	cpi	r24, 0x31	; 49
   11332:	09 f0       	breq	.+2      	; 0x11336 <FSettingProduct+0x24a>
   11334:	4c c0       	rjmp	.+152    	; 0x113ce <FSettingProduct+0x2e2>
   11336:	60 91 ee 02 	lds	r22, 0x02EE
   1133a:	8d e0       	ldi	r24, 0x0D	; 13
   1133c:	68 9f       	mul	r22, r24
   1133e:	b0 01       	movw	r22, r0
   11340:	11 24       	eor	r1, r1
   11342:	65 54       	subi	r22, 0x45	; 69
   11344:	7f 4f       	sbci	r23, 0xFF	; 255
   11346:	8e 01       	movw	r16, r28
   11348:	0f 5f       	subi	r16, 0xFF	; 255
   1134a:	1f 4f       	sbci	r17, 0xFF	; 255
   1134c:	c8 01       	movw	r24, r16
   1134e:	4d e0       	ldi	r20, 0x0D	; 13
   11350:	50 e0       	ldi	r21, 0x00	; 0
   11352:	25 ed       	ldi	r18, 0xD5	; 213
   11354:	32 e1       	ldi	r19, 0x12	; 18
   11356:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
		      eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		      sprintf_P(lcdteks,PSTR("Old:%s"),strProductName);
   1135a:	00 d0       	rcall	.+0      	; 0x1135c <FSettingProduct+0x270>
   1135c:	00 d0       	rcall	.+0      	; 0x1135e <FSettingProduct+0x272>
   1135e:	00 d0       	rcall	.+0      	; 0x11360 <FSettingProduct+0x274>
   11360:	ed b7       	in	r30, 0x3d	; 61
   11362:	fe b7       	in	r31, 0x3e	; 62
   11364:	31 96       	adiw	r30, 0x01	; 1
   11366:	6e e0       	ldi	r22, 0x0E	; 14
   11368:	e6 2e       	mov	r14, r22
   1136a:	f1 2c       	mov	r15, r1
   1136c:	ec 0e       	add	r14, r28
   1136e:	fd 1e       	adc	r15, r29
   11370:	ad b7       	in	r26, 0x3d	; 61
   11372:	be b7       	in	r27, 0x3e	; 62
   11374:	12 96       	adiw	r26, 0x02	; 2
   11376:	fc 92       	st	X, r15
   11378:	ee 92       	st	-X, r14
   1137a:	11 97       	sbiw	r26, 0x01	; 1
   1137c:	86 ea       	ldi	r24, 0xA6	; 166
   1137e:	91 e1       	ldi	r25, 0x11	; 17
   11380:	93 83       	std	Z+3, r25	; 0x03
   11382:	82 83       	std	Z+2, r24	; 0x02
   11384:	15 83       	std	Z+5, r17	; 0x05
   11386:	04 83       	std	Z+4, r16	; 0x04
   11388:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			  lcd_printf(1,1,PSTR("Edit Product Name   "));
   1138c:	8d b7       	in	r24, 0x3d	; 61
   1138e:	9e b7       	in	r25, 0x3e	; 62
   11390:	06 96       	adiw	r24, 0x06	; 6
   11392:	0f b6       	in	r0, 0x3f	; 63
   11394:	f8 94       	cli
   11396:	9e bf       	out	0x3e, r25	; 62
   11398:	0f be       	out	0x3f, r0	; 63
   1139a:	8d bf       	out	0x3d, r24	; 61
   1139c:	81 e0       	ldi	r24, 0x01	; 1
   1139e:	61 e0       	ldi	r22, 0x01	; 1
   113a0:	41 e9       	ldi	r20, 0x91	; 145
   113a2:	51 e1       	ldi	r21, 0x11	; 17
   113a4:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		       lcd_print(2,1,lcdteks);
   113a8:	82 e0       	ldi	r24, 0x02	; 2
   113aa:	61 e0       	ldi	r22, 0x01	; 1
   113ac:	a7 01       	movw	r20, r14
   113ae:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   113b2:	83 e0       	ldi	r24, 0x03	; 3
   113b4:	61 e0       	ldi	r22, 0x01	; 1
   113b6:	4b e8       	ldi	r20, 0x8B	; 139
   113b8:	51 e1       	ldi	r21, 0x11	; 17
   113ba:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   113be:	84 e0       	ldi	r24, 0x04	; 4
   113c0:	61 e0       	ldi	r22, 0x01	; 1
   113c2:	46 e7       	ldi	r20, 0x76	; 118
   113c4:	51 e1       	ldi	r21, 0x11	; 17
   113c6:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		      stMenuProduct=mpEditProductName;
   113ca:	85 e0       	ldi	r24, 0x05	; 5
   113cc:	7b c0       	rjmp	.+246    	; 0x114c4 <FSettingProduct+0x3d8>
		  }else
		  if (KeyChar=='2'){
   113ce:	82 33       	cpi	r24, 0x32	; 50
   113d0:	09 f0       	breq	.+2      	; 0x113d4 <FSettingProduct+0x2e8>
   113d2:	82 c0       	rjmp	.+260    	; 0x114d8 <FSettingProduct+0x3ec>
		      uiResult=USER_NONE;
   113d4:	10 92 ed 02 	sts	0x02ED, r1
		      sprintf_P(lcdteks,PSTR("Old:%s"),strPrice);
   113d8:	00 d0       	rcall	.+0      	; 0x113da <FSettingProduct+0x2ee>
   113da:	00 d0       	rcall	.+0      	; 0x113dc <FSettingProduct+0x2f0>
   113dc:	00 d0       	rcall	.+0      	; 0x113de <FSettingProduct+0x2f2>
   113de:	ed b7       	in	r30, 0x3d	; 61
   113e0:	fe b7       	in	r31, 0x3e	; 62
   113e2:	31 96       	adiw	r30, 0x01	; 1
   113e4:	8e 01       	movw	r16, r28
   113e6:	02 5f       	subi	r16, 0xF2	; 242
   113e8:	1f 4f       	sbci	r17, 0xFF	; 255
   113ea:	ad b7       	in	r26, 0x3d	; 61
   113ec:	be b7       	in	r27, 0x3e	; 62
   113ee:	12 96       	adiw	r26, 0x02	; 2
   113f0:	1c 93       	st	X, r17
   113f2:	0e 93       	st	-X, r16
   113f4:	11 97       	sbiw	r26, 0x01	; 1
   113f6:	8f e6       	ldi	r24, 0x6F	; 111
   113f8:	91 e1       	ldi	r25, 0x11	; 17
   113fa:	93 83       	std	Z+3, r25	; 0x03
   113fc:	82 83       	std	Z+2, r24	; 0x02
   113fe:	84 ee       	ldi	r24, 0xE4	; 228
   11400:	92 e0       	ldi	r25, 0x02	; 2
   11402:	95 83       	std	Z+5, r25	; 0x05
   11404:	84 83       	std	Z+4, r24	; 0x04
   11406:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		       lcd_print(2,1,lcdteks);
   1140a:	8d b7       	in	r24, 0x3d	; 61
   1140c:	9e b7       	in	r25, 0x3e	; 62
   1140e:	06 96       	adiw	r24, 0x06	; 6
   11410:	0f b6       	in	r0, 0x3f	; 63
   11412:	f8 94       	cli
   11414:	9e bf       	out	0x3e, r25	; 62
   11416:	0f be       	out	0x3f, r0	; 63
   11418:	8d bf       	out	0x3d, r24	; 61
   1141a:	82 e0       	ldi	r24, 0x02	; 2
   1141c:	61 e0       	ldi	r22, 0x01	; 1
   1141e:	a8 01       	movw	r20, r16
   11420:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   11424:	83 e0       	ldi	r24, 0x03	; 3
   11426:	61 e0       	ldi	r22, 0x01	; 1
   11428:	49 e6       	ldi	r20, 0x69	; 105
   1142a:	51 e1       	ldi	r21, 0x11	; 17
   1142c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   11430:	84 e0       	ldi	r24, 0x04	; 4
   11432:	61 e0       	ldi	r22, 0x01	; 1
   11434:	44 e5       	ldi	r20, 0x54	; 84
   11436:	51 e1       	ldi	r21, 0x11	; 17
   11438:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		      stMenuProduct=mpEditPrice;
   1143c:	84 e0       	ldi	r24, 0x04	; 4
   1143e:	42 c0       	rjmp	.+132    	; 0x114c4 <FSettingProduct+0x3d8>
		  }
	      break;
     case mpEditProductName:
	      uiResult=UserInput(UI_ALPHANUM_R,3,5,strDescription,0,10);
   11440:	83 e0       	ldi	r24, 0x03	; 3
   11442:	63 e0       	ldi	r22, 0x03	; 3
   11444:	45 e0       	ldi	r20, 0x05	; 5
   11446:	21 e6       	ldi	r18, 0x61	; 97
   11448:	3a e0       	ldi	r19, 0x0A	; 10
   1144a:	00 e0       	ldi	r16, 0x00	; 0
   1144c:	10 e0       	ldi	r17, 0x00	; 0
   1144e:	5a e0       	ldi	r21, 0x0A	; 10
   11450:	e5 2e       	mov	r14, r21
   11452:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
   11456:	80 93 ed 02 	sts	0x02ED, r24
		  if (uiResult==USER_OK){
   1145a:	83 30       	cpi	r24, 0x03	; 3
   1145c:	b1 f5       	brne	.+108    	; 0x114ca <FSettingProduct+0x3de>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   1145e:	80 91 ee 02 	lds	r24, 0x02EE
   11462:	2d e0       	ldi	r18, 0x0D	; 13
   11464:	82 9f       	mul	r24, r18
   11466:	c0 01       	movw	r24, r0
   11468:	11 24       	eor	r1, r1
   1146a:	85 54       	subi	r24, 0x45	; 69
   1146c:	9f 4f       	sbci	r25, 0xFF	; 255
   1146e:	61 e6       	ldi	r22, 0x61	; 97
   11470:	7a e0       	ldi	r23, 0x0A	; 10
   11472:	4d e0       	ldi	r20, 0x0D	; 13
   11474:	50 e0       	ldi	r21, 0x00	; 0
   11476:	2d ed       	ldi	r18, 0xDD	; 221
   11478:	32 e1       	ldi	r19, 0x12	; 18
   1147a:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
		      eeprom_write_block((const void*)&strDescription,(void*)&DefProductName[ProdID], 13);
		      stMenuProduct=mpInitProduct;
   1147e:	10 92 ef 02 	sts	0x02EF, r1
   11482:	2a c0       	rjmp	.+84     	; 0x114d8 <FSettingProduct+0x3ec>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
	      break;
     case mpEditPrice:
	      uiResult=UserInput(UI_NUMBER_R,3,5,strPrice,0,7);
   11484:	81 e0       	ldi	r24, 0x01	; 1
   11486:	63 e0       	ldi	r22, 0x03	; 3
   11488:	45 e0       	ldi	r20, 0x05	; 5
   1148a:	24 ee       	ldi	r18, 0xE4	; 228
   1148c:	32 e0       	ldi	r19, 0x02	; 2
   1148e:	00 e0       	ldi	r16, 0x00	; 0
   11490:	10 e0       	ldi	r17, 0x00	; 0
   11492:	97 e0       	ldi	r25, 0x07	; 7
   11494:	e9 2e       	mov	r14, r25
   11496:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
   1149a:	80 93 ed 02 	sts	0x02ED, r24
		  if (uiResult==USER_OK){
   1149e:	83 30       	cpi	r24, 0x03	; 3
   114a0:	a1 f4       	brne	.+40     	; 0x114ca <FSettingProduct+0x3de>
   114a2:	80 91 ee 02 	lds	r24, 0x02EE
   114a6:	29 e0       	ldi	r18, 0x09	; 9
   114a8:	82 9f       	mul	r24, r18
   114aa:	c0 01       	movw	r24, r0
   114ac:	11 24       	eor	r1, r1
   114ae:	8b 57       	subi	r24, 0x7B	; 123
   114b0:	9f 4f       	sbci	r25, 0xFF	; 255
   114b2:	64 ee       	ldi	r22, 0xE4	; 228
   114b4:	72 e0       	ldi	r23, 0x02	; 2
   114b6:	49 e0       	ldi	r20, 0x09	; 9
   114b8:	50 e0       	ldi	r21, 0x00	; 0
   114ba:	2d ed       	ldi	r18, 0xDD	; 221
   114bc:	32 e1       	ldi	r19, 0x12	; 18
   114be:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
		      eeprom_write_block((const void*)&strPrice,(void*)&DefProductPrice[ProdID], 9);
		      stMenuProduct=mpDispPrice;//stMenuProduct=mpInit;
   114c2:	82 e0       	ldi	r24, 0x02	; 2
   114c4:	80 93 ef 02 	sts	0x02EF, r24
   114c8:	07 c0       	rjmp	.+14     	; 0x114d8 <FSettingProduct+0x3ec>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
   114ca:	81 30       	cpi	r24, 0x01	; 1
   114cc:	29 f4       	brne	.+10     	; 0x114d8 <FSettingProduct+0x3ec>
   114ce:	f9 cf       	rjmp	.-14     	; 0x114c2 <FSettingProduct+0x3d6>
	      break;
     case mpExitMenuProduct:
	      stMenuProduct=mpInitProduct;
   114d0:	10 92 ef 02 	sts	0x02EF, r1
   114d4:	81 e0       	ldi	r24, 0x01	; 1
   114d6:	01 c0       	rjmp	.+2      	; 0x114da <FSettingProduct+0x3ee>
   114d8:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   114da:	a1 96       	adiw	r28, 0x21	; 33
   114dc:	0f b6       	in	r0, 0x3f	; 63
   114de:	f8 94       	cli
   114e0:	de bf       	out	0x3e, r29	; 62
   114e2:	0f be       	out	0x3f, r0	; 63
   114e4:	cd bf       	out	0x3d, r28	; 61
   114e6:	cf 91       	pop	r28
   114e8:	df 91       	pop	r29
   114ea:	1f 91       	pop	r17
   114ec:	0f 91       	pop	r16
   114ee:	ff 90       	pop	r15
   114f0:	ef 90       	pop	r14
   114f2:	df 90       	pop	r13
   114f4:	cf 90       	pop	r12
   114f6:	bf 90       	pop	r11
   114f8:	af 90       	pop	r10
   114fa:	9f 90       	pop	r9
   114fc:	8f 90       	pop	r8
   114fe:	7f 90       	pop	r7
   11500:	6f 90       	pop	r6
   11502:	08 95       	ret

00011504 <FMenuSettingFooter>:
	 }
   //_menu_header();   
   return Result;
}

char FMenuSettingFooter(){
   11504:	ef 92       	push	r14
   11506:	0f 93       	push	r16
   11508:	1f 93       	push	r17
   1150a:	df 93       	push	r29
   1150c:	cf 93       	push	r28
   1150e:	cd b7       	in	r28, 0x3d	; 61
   11510:	de b7       	in	r29, 0x3e	; 62
   11512:	c6 54       	subi	r28, 0x46	; 70
   11514:	d0 40       	sbci	r29, 0x00	; 0
   11516:	0f b6       	in	r0, 0x3f	; 63
   11518:	f8 94       	cli
   1151a:	de bf       	out	0x3e, r29	; 62
   1151c:	0f be       	out	0x3f, r0	; 63
   1151e:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[50];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   11520:	80 91 1a 03 	lds	r24, 0x031A
   11524:	84 30       	cpi	r24, 0x04	; 4
   11526:	09 f4       	brne	.+2      	; 0x1152a <FMenuSettingFooter+0x26>
   11528:	3f c1       	rjmp	.+638    	; 0x117a8 <FMenuSettingFooter+0x2a4>
   1152a:	85 30       	cpi	r24, 0x05	; 5
   1152c:	40 f4       	brcc	.+16     	; 0x1153e <FMenuSettingFooter+0x3a>
   1152e:	81 30       	cpi	r24, 0x01	; 1
   11530:	79 f1       	breq	.+94     	; 0x11590 <FMenuSettingFooter+0x8c>
   11532:	81 30       	cpi	r24, 0x01	; 1
   11534:	88 f0       	brcs	.+34     	; 0x11558 <FMenuSettingFooter+0x54>
   11536:	82 30       	cpi	r24, 0x02	; 2
   11538:	09 f0       	breq	.+2      	; 0x1153c <FMenuSettingFooter+0x38>
   1153a:	85 c1       	rjmp	.+778    	; 0x11846 <FMenuSettingFooter+0x342>
   1153c:	76 c0       	rjmp	.+236    	; 0x1162a <FMenuSettingFooter+0x126>
   1153e:	86 30       	cpi	r24, 0x06	; 6
   11540:	09 f4       	brne	.+2      	; 0x11544 <FMenuSettingFooter+0x40>
   11542:	d7 c0       	rjmp	.+430    	; 0x116f2 <FMenuSettingFooter+0x1ee>
   11544:	86 30       	cpi	r24, 0x06	; 6
   11546:	08 f4       	brcc	.+2      	; 0x1154a <FMenuSettingFooter+0x46>
   11548:	bf c0       	rjmp	.+382    	; 0x116c8 <FMenuSettingFooter+0x1c4>
   1154a:	87 30       	cpi	r24, 0x07	; 7
   1154c:	09 f4       	brne	.+2      	; 0x11550 <FMenuSettingFooter+0x4c>
   1154e:	3d c1       	rjmp	.+634    	; 0x117ca <FMenuSettingFooter+0x2c6>
   11550:	88 30       	cpi	r24, 0x08	; 8
   11552:	09 f0       	breq	.+2      	; 0x11556 <FMenuSettingFooter+0x52>
   11554:	78 c1       	rjmp	.+752    	; 0x11846 <FMenuSettingFooter+0x342>
   11556:	73 c1       	rjmp	.+742    	; 0x1183e <FMenuSettingFooter+0x33a>
	 case shInitHeader:
	      lcd_clear();
   11558:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Footer1  3)Footer3"));
   1155c:	81 e0       	ldi	r24, 0x01	; 1
   1155e:	61 e0       	ldi	r22, 0x01	; 1
   11560:	43 ec       	ldi	r20, 0xC3	; 195
   11562:	53 e1       	ldi	r21, 0x13	; 19
   11564:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Footer2  4)Footer4"));
   11568:	82 e0       	ldi	r24, 0x02	; 2
   1156a:	61 e0       	ldi	r22, 0x01	; 1
   1156c:	4e ea       	ldi	r20, 0xAE	; 174
   1156e:	53 e1       	ldi	r21, 0x13	; 19
   11570:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(3,1,PSTR("                    "));
   11574:	83 e0       	ldi	r24, 0x03	; 3
   11576:	61 e0       	ldi	r22, 0x01	; 1
   11578:	49 e9       	ldi	r20, 0x99	; 153
   1157a:	53 e1       	ldi	r21, 0x13	; 19
   1157c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   11580:	84 e0       	ldi	r24, 0x04	; 4
   11582:	61 e0       	ldi	r22, 0x01	; 1
   11584:	44 e8       	ldi	r20, 0x84	; 132
   11586:	53 e1       	ldi	r21, 0x13	; 19
   11588:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   1158c:	81 e0       	ldi	r24, 0x01	; 1
   1158e:	16 c1       	rjmp	.+556    	; 0x117bc <FMenuSettingFooter+0x2b8>
	      break;
      case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   11590:	81 e0       	ldi	r24, 0x01	; 1
   11592:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   11596:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   1159a:	80 93 18 03 	sts	0x0318, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   1159e:	81 53       	subi	r24, 0x31	; 49
   115a0:	86 30       	cpi	r24, 0x06	; 6
   115a2:	e0 f5       	brcc	.+120    	; 0x1161c <FMenuSettingFooter+0x118>
		       HeaderIdx=KeyChar-'1';//
   115a4:	80 93 19 03 	sts	0x0319, r24
			   lcd_clear();
   115a8:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
   115ac:	00 d0       	rcall	.+0      	; 0x115ae <FMenuSettingFooter+0xaa>
   115ae:	00 d0       	rcall	.+0      	; 0x115b0 <FMenuSettingFooter+0xac>
   115b0:	00 d0       	rcall	.+0      	; 0x115b2 <FMenuSettingFooter+0xae>
   115b2:	ed b7       	in	r30, 0x3d	; 61
   115b4:	fe b7       	in	r31, 0x3e	; 62
   115b6:	31 96       	adiw	r30, 0x01	; 1
   115b8:	8e 01       	movw	r16, r28
   115ba:	0f 5f       	subi	r16, 0xFF	; 255
   115bc:	1f 4f       	sbci	r17, 0xFF	; 255
   115be:	ad b7       	in	r26, 0x3d	; 61
   115c0:	be b7       	in	r27, 0x3e	; 62
   115c2:	12 96       	adiw	r26, 0x02	; 2
   115c4:	1c 93       	st	X, r17
   115c6:	0e 93       	st	-X, r16
   115c8:	11 97       	sbiw	r26, 0x01	; 1
   115ca:	85 e7       	ldi	r24, 0x75	; 117
   115cc:	93 e1       	ldi	r25, 0x13	; 19
   115ce:	93 83       	std	Z+3, r25	; 0x03
   115d0:	82 83       	std	Z+2, r24	; 0x02
   115d2:	80 91 19 03 	lds	r24, 0x0319
   115d6:	90 e0       	ldi	r25, 0x00	; 0
   115d8:	01 96       	adiw	r24, 0x01	; 1
   115da:	95 83       	std	Z+5, r25	; 0x05
   115dc:	84 83       	std	Z+4, r24	; 0x04
   115de:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			   lcd_print(1,1,lcdteks);
   115e2:	8d b7       	in	r24, 0x3d	; 61
   115e4:	9e b7       	in	r25, 0x3e	; 62
   115e6:	06 96       	adiw	r24, 0x06	; 6
   115e8:	0f b6       	in	r0, 0x3f	; 63
   115ea:	f8 94       	cli
   115ec:	9e bf       	out	0x3e, r25	; 62
   115ee:	0f be       	out	0x3f, r0	; 63
   115f0:	8d bf       	out	0x3d, r24	; 61
   115f2:	81 e0       	ldi	r24, 0x01	; 1
   115f4:	61 e0       	ldi	r22, 0x01	; 1
   115f6:	a8 01       	movw	r20, r16
   115f8:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   115fc:	84 e0       	ldi	r24, 0x04	; 4
   115fe:	61 e0       	ldi	r22, 0x01	; 1
   11600:	46 e6       	ldi	r20, 0x66	; 102
   11602:	53 e1       	ldi	r21, 0x13	; 19
   11604:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   11608:	ef e1       	ldi	r30, 0x1F	; 31
   1160a:	f6 e0       	ldi	r31, 0x06	; 6
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   1160c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   1160e:	97 e0       	ldi	r25, 0x07	; 7
   11610:	e0 3b       	cpi	r30, 0xB0	; 176
   11612:	f9 07       	cpc	r31, r25
   11614:	d9 f7       	brne	.-10     	; 0x1160c <FMenuSettingFooter+0x108>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
   11616:	82 e0       	ldi	r24, 0x02	; 2
   11618:	80 93 1a 03 	sts	0x031A, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   1161c:	80 91 18 03 	lds	r24, 0x0318
   11620:	8a 32       	cpi	r24, 0x2A	; 42
   11622:	09 f0       	breq	.+2      	; 0x11626 <FMenuSettingFooter+0x122>
   11624:	10 c1       	rjmp	.+544    	; 0x11846 <FMenuSettingFooter+0x342>
   11626:	88 e0       	ldi	r24, 0x08	; 8
   11628:	c9 c0       	rjmp	.+402    	; 0x117bc <FMenuSettingFooter+0x2b8>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
   1162a:	83 e0       	ldi	r24, 0x03	; 3
   1162c:	62 e0       	ldi	r22, 0x02	; 2
   1162e:	41 e0       	ldi	r20, 0x01	; 1
   11630:	2f e1       	ldi	r18, 0x1F	; 31
   11632:	36 e0       	ldi	r19, 0x06	; 6
   11634:	00 e0       	ldi	r16, 0x00	; 0
   11636:	10 e0       	ldi	r17, 0x00	; 0
   11638:	98 e2       	ldi	r25, 0x28	; 40
   1163a:	e9 2e       	mov	r14, r25
   1163c:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
		  if (uiResult==USER_OK){
   11640:	83 30       	cpi	r24, 0x03	; 3
   11642:	f1 f5       	brne	.+124    	; 0x116c0 <FMenuSettingFooter+0x1bc>
			  lcd_clear();
   11644:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
   11648:	8f e1       	ldi	r24, 0x1F	; 31
   1164a:	96 e0       	ldi	r25, 0x06	; 6
   1164c:	68 e2       	ldi	r22, 0x28	; 40
   1164e:	0e 94 b9 2a 	call	0x5572	; 0x5572 <AddSpaceLag>
   11652:	20 e0       	ldi	r18, 0x00	; 0
   11654:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11656:	f9 01       	movw	r30, r18
   11658:	e9 51       	subi	r30, 0x19	; 25
   1165a:	f5 4f       	sbci	r31, 0xF5	; 245
   1165c:	d9 01       	movw	r26, r18
   1165e:	a1 5e       	subi	r26, 0xE1	; 225
   11660:	b9 4f       	sbci	r27, 0xF9	; 249
   11662:	8c 91       	ld	r24, X
   11664:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11666:	2f 5f       	subi	r18, 0xFF	; 255
   11668:	3f 4f       	sbci	r19, 0xFF	; 255
   1166a:	24 31       	cpi	r18, 0x14	; 20
   1166c:	31 05       	cpc	r19, r1
   1166e:	99 f7       	brne	.-26     	; 0x11656 <FMenuSettingFooter+0x152>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11670:	10 92 fb 0a 	sts	0x0AFB, r1
   11674:	e3 e3       	ldi	r30, 0x33	; 51
   11676:	f6 e0       	ldi	r31, 0x06	; 6
   11678:	a6 ed       	ldi	r26, 0xD6	; 214
   1167a:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1167c:	81 91       	ld	r24, Z+
   1167e:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11680:	86 e0       	ldi	r24, 0x06	; 6
   11682:	e7 34       	cpi	r30, 0x47	; 71
   11684:	f8 07       	cpc	r31, r24
   11686:	d1 f7       	brne	.-12     	; 0x1167c <FMenuSettingFooter+0x178>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11688:	10 92 ea 09 	sts	0x09EA, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
   1168c:	81 e0       	ldi	r24, 0x01	; 1
   1168e:	61 e0       	ldi	r22, 0x01	; 1
   11690:	47 ee       	ldi	r20, 0xE7	; 231
   11692:	5a e0       	ldi	r21, 0x0A	; 10
   11694:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
   11698:	82 e0       	ldi	r24, 0x02	; 2
   1169a:	61 e0       	ldi	r22, 0x01	; 1
   1169c:	46 ed       	ldi	r20, 0xD6	; 214
   1169e:	59 e0       	ldi	r21, 0x09	; 9
   116a0:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
   116a4:	83 e0       	ldi	r24, 0x03	; 3
   116a6:	61 e0       	ldi	r22, 0x01	; 1
   116a8:	48 e5       	ldi	r20, 0x58	; 88
   116aa:	53 e1       	ldi	r21, 0x13	; 19
   116ac:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
   116b0:	84 e0       	ldi	r24, 0x04	; 4
   116b2:	61 e0       	ldi	r22, 0x01	; 1
   116b4:	4a e4       	ldi	r20, 0x4A	; 74
   116b6:	53 e1       	ldi	r21, 0x13	; 19
   116b8:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
   116bc:	85 e0       	ldi	r24, 0x05	; 5
   116be:	7e c0       	rjmp	.+252    	; 0x117bc <FMenuSettingFooter+0x2b8>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   116c0:	81 30       	cpi	r24, 0x01	; 1
   116c2:	09 f0       	breq	.+2      	; 0x116c6 <FMenuSettingFooter+0x1c2>
   116c4:	c0 c0       	rjmp	.+384    	; 0x11846 <FMenuSettingFooter+0x342>
   116c6:	b8 c0       	rjmp	.+368    	; 0x11838 <FMenuSettingFooter+0x334>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
   116c8:	81 e0       	ldi	r24, 0x01	; 1
   116ca:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   116ce:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   116d2:	80 93 18 03 	sts	0x0318, r24
          if(KeyChar=='#'){
   116d6:	83 32       	cpi	r24, 0x23	; 35
   116d8:	39 f4       	brne	.+14     	; 0x116e8 <FMenuSettingFooter+0x1e4>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
   116da:	8f e1       	ldi	r24, 0x1F	; 31
   116dc:	96 e0       	ldi	r25, 0x06	; 6
   116de:	68 e2       	ldi	r22, 0x28	; 40
   116e0:	70 e0       	ldi	r23, 0x00	; 0
   116e2:	0e 94 c3 2c 	call	0x5986	; 0x5986 <StrAlignCenter>
   116e6:	03 c0       	rjmp	.+6      	; 0x116ee <FMenuSettingFooter+0x1ea>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
   116e8:	8a 32       	cpi	r24, 0x2A	; 42
   116ea:	09 f0       	breq	.+2      	; 0x116ee <FMenuSettingFooter+0x1ea>
   116ec:	ac c0       	rjmp	.+344    	; 0x11846 <FMenuSettingFooter+0x342>
   116ee:	86 e0       	ldi	r24, 0x06	; 6
   116f0:	65 c0       	rjmp	.+202    	; 0x117bc <FMenuSettingFooter+0x2b8>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
   116f2:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
   116f6:	20 e0       	ldi	r18, 0x00	; 0
   116f8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   116fa:	f9 01       	movw	r30, r18
   116fc:	e9 51       	subi	r30, 0x19	; 25
   116fe:	f5 4f       	sbci	r31, 0xF5	; 245
   11700:	d9 01       	movw	r26, r18
   11702:	a1 5e       	subi	r26, 0xE1	; 225
   11704:	b9 4f       	sbci	r27, 0xF9	; 249
   11706:	8c 91       	ld	r24, X
   11708:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1170a:	2f 5f       	subi	r18, 0xFF	; 255
   1170c:	3f 4f       	sbci	r19, 0xFF	; 255
   1170e:	24 31       	cpi	r18, 0x14	; 20
   11710:	31 05       	cpc	r19, r1
   11712:	99 f7       	brne	.-26     	; 0x116fa <FMenuSettingFooter+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11714:	10 92 fb 0a 	sts	0x0AFB, r1
   11718:	e3 e3       	ldi	r30, 0x33	; 51
   1171a:	f6 e0       	ldi	r31, 0x06	; 6
   1171c:	a6 ed       	ldi	r26, 0xD6	; 214
   1171e:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11720:	81 91       	ld	r24, Z+
   11722:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11724:	96 e0       	ldi	r25, 0x06	; 6
   11726:	e7 34       	cpi	r30, 0x47	; 71
   11728:	f9 07       	cpc	r31, r25
   1172a:	d1 f7       	brne	.-12     	; 0x11720 <FMenuSettingFooter+0x21c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   1172c:	10 92 ea 09 	sts	0x09EA, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
   11730:	81 e0       	ldi	r24, 0x01	; 1
   11732:	61 e0       	ldi	r22, 0x01	; 1
   11734:	47 ee       	ldi	r20, 0xE7	; 231
   11736:	5a e0       	ldi	r21, 0x0A	; 10
   11738:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   1173c:	82 e0       	ldi	r24, 0x02	; 2
   1173e:	61 e0       	ldi	r22, 0x01	; 1
   11740:	46 ed       	ldi	r20, 0xD6	; 214
   11742:	59 e0       	ldi	r21, 0x09	; 9
   11744:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Footer%d ?"),HeaderIdx+1);
   11748:	00 d0       	rcall	.+0      	; 0x1174a <FMenuSettingFooter+0x246>
   1174a:	00 d0       	rcall	.+0      	; 0x1174c <FMenuSettingFooter+0x248>
   1174c:	00 d0       	rcall	.+0      	; 0x1174e <FMenuSettingFooter+0x24a>
   1174e:	ed b7       	in	r30, 0x3d	; 61
   11750:	fe b7       	in	r31, 0x3e	; 62
   11752:	31 96       	adiw	r30, 0x01	; 1
   11754:	8e 01       	movw	r16, r28
   11756:	0f 5f       	subi	r16, 0xFF	; 255
   11758:	1f 4f       	sbci	r17, 0xFF	; 255
   1175a:	ad b7       	in	r26, 0x3d	; 61
   1175c:	be b7       	in	r27, 0x3e	; 62
   1175e:	12 96       	adiw	r26, 0x02	; 2
   11760:	1c 93       	st	X, r17
   11762:	0e 93       	st	-X, r16
   11764:	11 97       	sbiw	r26, 0x01	; 1
   11766:	8a e3       	ldi	r24, 0x3A	; 58
   11768:	93 e1       	ldi	r25, 0x13	; 19
   1176a:	93 83       	std	Z+3, r25	; 0x03
   1176c:	82 83       	std	Z+2, r24	; 0x02
   1176e:	80 91 19 03 	lds	r24, 0x0319
   11772:	90 e0       	ldi	r25, 0x00	; 0
   11774:	01 96       	adiw	r24, 0x01	; 1
   11776:	95 83       	std	Z+5, r25	; 0x05
   11778:	84 83       	std	Z+4, r24	; 0x04
   1177a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   1177e:	8d b7       	in	r24, 0x3d	; 61
   11780:	9e b7       	in	r25, 0x3e	; 62
   11782:	06 96       	adiw	r24, 0x06	; 6
   11784:	0f b6       	in	r0, 0x3f	; 63
   11786:	f8 94       	cli
   11788:	9e bf       	out	0x3e, r25	; 62
   1178a:	0f be       	out	0x3f, r0	; 63
   1178c:	8d bf       	out	0x3d, r24	; 61
   1178e:	83 e0       	ldi	r24, 0x03	; 3
   11790:	61 e0       	ldi	r22, 0x01	; 1
   11792:	a8 01       	movw	r20, r16
   11794:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
   11798:	84 e0       	ldi	r24, 0x04	; 4
   1179a:	61 e0       	ldi	r22, 0x01	; 1
   1179c:	4d e2       	ldi	r20, 0x2D	; 45
   1179e:	53 e1       	ldi	r21, 0x13	; 19
   117a0:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
   117a4:	84 e0       	ldi	r24, 0x04	; 4
   117a6:	0a c0       	rjmp	.+20     	; 0x117bc <FMenuSettingFooter+0x2b8>
	      break;       
     case shSaveHeaderQuestions:
          KeyChar=_key_btn(_key_scan(1));
   117a8:	81 e0       	ldi	r24, 0x01	; 1
   117aa:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   117ae:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   117b2:	80 93 18 03 	sts	0x0318, r24
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   117b6:	83 32       	cpi	r24, 0x23	; 35
   117b8:	21 f4       	brne	.+8      	; 0x117c2 <FMenuSettingFooter+0x2be>
   117ba:	87 e0       	ldi	r24, 0x07	; 7
   117bc:	80 93 1a 03 	sts	0x031A, r24
   117c0:	42 c0       	rjmp	.+132    	; 0x11846 <FMenuSettingFooter+0x342>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   117c2:	8a 32       	cpi	r24, 0x2A	; 42
   117c4:	09 f0       	breq	.+2      	; 0x117c8 <FMenuSettingFooter+0x2c4>
   117c6:	3f c0       	rjmp	.+126    	; 0x11846 <FMenuSettingFooter+0x342>
   117c8:	37 c0       	rjmp	.+110    	; 0x11838 <FMenuSettingFooter+0x334>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
   117ca:	ad b7       	in	r26, 0x3d	; 61
   117cc:	be b7       	in	r27, 0x3e	; 62
   117ce:	18 97       	sbiw	r26, 0x08	; 8
   117d0:	0f b6       	in	r0, 0x3f	; 63
   117d2:	f8 94       	cli
   117d4:	be bf       	out	0x3e, r27	; 62
   117d6:	0f be       	out	0x3f, r0	; 63
   117d8:	ad bf       	out	0x3d, r26	; 61
   117da:	ed b7       	in	r30, 0x3d	; 61
   117dc:	fe b7       	in	r31, 0x3e	; 62
   117de:	31 96       	adiw	r30, 0x01	; 1
   117e0:	8e 01       	movw	r16, r28
   117e2:	0b 5e       	subi	r16, 0xEB	; 235
   117e4:	1f 4f       	sbci	r17, 0xFF	; 255
   117e6:	12 96       	adiw	r26, 0x02	; 2
   117e8:	1c 93       	st	X, r17
   117ea:	0e 93       	st	-X, r16
   117ec:	11 97       	sbiw	r26, 0x01	; 1
   117ee:	88 e2       	ldi	r24, 0x28	; 40
   117f0:	93 e1       	ldi	r25, 0x13	; 19
   117f2:	93 83       	std	Z+3, r25	; 0x03
   117f4:	82 83       	std	Z+2, r24	; 0x02
   117f6:	87 ee       	ldi	r24, 0xE7	; 231
   117f8:	9a e0       	ldi	r25, 0x0A	; 10
   117fa:	95 83       	std	Z+5, r25	; 0x05
   117fc:	84 83       	std	Z+4, r24	; 0x04
   117fe:	86 ed       	ldi	r24, 0xD6	; 214
   11800:	99 e0       	ldi	r25, 0x09	; 9
   11802:	97 83       	std	Z+7, r25	; 0x07
   11804:	86 83       	std	Z+6, r24	; 0x06
   11806:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   1180a:	8d b7       	in	r24, 0x3d	; 61
   1180c:	9e b7       	in	r25, 0x3e	; 62
   1180e:	08 96       	adiw	r24, 0x08	; 8
   11810:	0f b6       	in	r0, 0x3f	; 63
   11812:	f8 94       	cli
   11814:	9e bf       	out	0x3e, r25	; 62
   11816:	0f be       	out	0x3f, r0	; 63
   11818:	8d bf       	out	0x3d, r24	; 61
   1181a:	80 91 19 03 	lds	r24, 0x0319
   1181e:	29 e2       	ldi	r18, 0x29	; 41
   11820:	82 9f       	mul	r24, r18
   11822:	c0 01       	movw	r24, r0
   11824:	11 24       	eor	r1, r1
   11826:	83 5e       	subi	r24, 0xE3	; 227
   11828:	9c 4f       	sbci	r25, 0xFC	; 252
   1182a:	b8 01       	movw	r22, r16
   1182c:	48 e2       	ldi	r20, 0x28	; 40
   1182e:	50 e0       	ldi	r21, 0x00	; 0
   11830:	2d ed       	ldi	r18, 0xDD	; 221
   11832:	32 e1       	ldi	r19, 0x12	; 18
   11834:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx+6],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx+6],40);

          stSettingHeader=shInitHeader;
   11838:	10 92 1a 03 	sts	0x031A, r1
   1183c:	04 c0       	rjmp	.+8      	; 0x11846 <FMenuSettingFooter+0x342>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   1183e:	10 92 1a 03 	sts	0x031A, r1
   11842:	81 e0       	ldi	r24, 0x01	; 1
   11844:	01 c0       	rjmp	.+2      	; 0x11848 <FMenuSettingFooter+0x344>
   11846:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   return Result;
}
   11848:	ca 5b       	subi	r28, 0xBA	; 186
   1184a:	df 4f       	sbci	r29, 0xFF	; 255
   1184c:	0f b6       	in	r0, 0x3f	; 63
   1184e:	f8 94       	cli
   11850:	de bf       	out	0x3e, r29	; 62
   11852:	0f be       	out	0x3f, r0	; 63
   11854:	cd bf       	out	0x3d, r28	; 61
   11856:	cf 91       	pop	r28
   11858:	df 91       	pop	r29
   1185a:	1f 91       	pop	r17
   1185c:	0f 91       	pop	r16
   1185e:	ef 90       	pop	r14
   11860:	08 95       	ret

00011862 <FMenuSettingHeader>:
	      break;
	 }
   return Result;
}

char FMenuSettingHeader(){
   11862:	ef 92       	push	r14
   11864:	0f 93       	push	r16
   11866:	1f 93       	push	r17
   11868:	df 93       	push	r29
   1186a:	cf 93       	push	r28
   1186c:	cd b7       	in	r28, 0x3d	; 61
   1186e:	de b7       	in	r29, 0x3e	; 62
   11870:	c6 54       	subi	r28, 0x46	; 70
   11872:	d0 40       	sbci	r29, 0x00	; 0
   11874:	0f b6       	in	r0, 0x3f	; 63
   11876:	f8 94       	cli
   11878:	de bf       	out	0x3e, r29	; 62
   1187a:	0f be       	out	0x3f, r0	; 63
   1187c:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[50];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   1187e:	80 91 1d 03 	lds	r24, 0x031D
   11882:	84 30       	cpi	r24, 0x04	; 4
   11884:	09 f4       	brne	.+2      	; 0x11888 <FMenuSettingHeader+0x26>
   11886:	3f c1       	rjmp	.+638    	; 0x11b06 <FMenuSettingHeader+0x2a4>
   11888:	85 30       	cpi	r24, 0x05	; 5
   1188a:	40 f4       	brcc	.+16     	; 0x1189c <FMenuSettingHeader+0x3a>
   1188c:	81 30       	cpi	r24, 0x01	; 1
   1188e:	79 f1       	breq	.+94     	; 0x118ee <FMenuSettingHeader+0x8c>
   11890:	81 30       	cpi	r24, 0x01	; 1
   11892:	88 f0       	brcs	.+34     	; 0x118b6 <FMenuSettingHeader+0x54>
   11894:	82 30       	cpi	r24, 0x02	; 2
   11896:	09 f0       	breq	.+2      	; 0x1189a <FMenuSettingHeader+0x38>
   11898:	85 c1       	rjmp	.+778    	; 0x11ba4 <FMenuSettingHeader+0x342>
   1189a:	76 c0       	rjmp	.+236    	; 0x11988 <FMenuSettingHeader+0x126>
   1189c:	86 30       	cpi	r24, 0x06	; 6
   1189e:	09 f4       	brne	.+2      	; 0x118a2 <FMenuSettingHeader+0x40>
   118a0:	d7 c0       	rjmp	.+430    	; 0x11a50 <FMenuSettingHeader+0x1ee>
   118a2:	86 30       	cpi	r24, 0x06	; 6
   118a4:	08 f4       	brcc	.+2      	; 0x118a8 <FMenuSettingHeader+0x46>
   118a6:	bf c0       	rjmp	.+382    	; 0x11a26 <FMenuSettingHeader+0x1c4>
   118a8:	87 30       	cpi	r24, 0x07	; 7
   118aa:	09 f4       	brne	.+2      	; 0x118ae <FMenuSettingHeader+0x4c>
   118ac:	3d c1       	rjmp	.+634    	; 0x11b28 <FMenuSettingHeader+0x2c6>
   118ae:	88 30       	cpi	r24, 0x08	; 8
   118b0:	09 f0       	breq	.+2      	; 0x118b4 <FMenuSettingHeader+0x52>
   118b2:	78 c1       	rjmp	.+752    	; 0x11ba4 <FMenuSettingHeader+0x342>
   118b4:	73 c1       	rjmp	.+742    	; 0x11b9c <FMenuSettingHeader+0x33a>
	 case shInitHeader:
	      lcd_clear();
   118b6:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Header1  4)Header4"));
   118ba:	81 e0       	ldi	r24, 0x01	; 1
   118bc:	61 e0       	ldi	r22, 0x01	; 1
   118be:	43 e7       	ldi	r20, 0x73	; 115
   118c0:	54 e1       	ldi	r21, 0x14	; 20
   118c2:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Header2  5)Header5"));
   118c6:	82 e0       	ldi	r24, 0x02	; 2
   118c8:	61 e0       	ldi	r22, 0x01	; 1
   118ca:	4e e5       	ldi	r20, 0x5E	; 94
   118cc:	54 e1       	ldi	r21, 0x14	; 20
   118ce:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(3,1,PSTR("3)Header3  6)Header6"));
   118d2:	83 e0       	ldi	r24, 0x03	; 3
   118d4:	61 e0       	ldi	r22, 0x01	; 1
   118d6:	49 e4       	ldi	r20, 0x49	; 73
   118d8:	54 e1       	ldi	r21, 0x14	; 20
   118da:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   118de:	84 e0       	ldi	r24, 0x04	; 4
   118e0:	61 e0       	ldi	r22, 0x01	; 1
   118e2:	44 e3       	ldi	r20, 0x34	; 52
   118e4:	54 e1       	ldi	r21, 0x14	; 20
   118e6:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   118ea:	81 e0       	ldi	r24, 0x01	; 1
   118ec:	16 c1       	rjmp	.+556    	; 0x11b1a <FMenuSettingHeader+0x2b8>
	      break;
     case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   118ee:	81 e0       	ldi	r24, 0x01	; 1
   118f0:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   118f4:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   118f8:	80 93 1b 03 	sts	0x031B, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   118fc:	81 53       	subi	r24, 0x31	; 49
   118fe:	86 30       	cpi	r24, 0x06	; 6
   11900:	e0 f5       	brcc	.+120    	; 0x1197a <FMenuSettingHeader+0x118>
		       HeaderIdx=KeyChar-'1';//
   11902:	80 93 1c 03 	sts	0x031C, r24
			   lcd_clear();
   11906:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
   1190a:	00 d0       	rcall	.+0      	; 0x1190c <FMenuSettingHeader+0xaa>
   1190c:	00 d0       	rcall	.+0      	; 0x1190e <FMenuSettingHeader+0xac>
   1190e:	00 d0       	rcall	.+0      	; 0x11910 <FMenuSettingHeader+0xae>
   11910:	ed b7       	in	r30, 0x3d	; 61
   11912:	fe b7       	in	r31, 0x3e	; 62
   11914:	31 96       	adiw	r30, 0x01	; 1
   11916:	8e 01       	movw	r16, r28
   11918:	0f 5f       	subi	r16, 0xFF	; 255
   1191a:	1f 4f       	sbci	r17, 0xFF	; 255
   1191c:	ad b7       	in	r26, 0x3d	; 61
   1191e:	be b7       	in	r27, 0x3e	; 62
   11920:	12 96       	adiw	r26, 0x02	; 2
   11922:	1c 93       	st	X, r17
   11924:	0e 93       	st	-X, r16
   11926:	11 97       	sbiw	r26, 0x01	; 1
   11928:	85 e2       	ldi	r24, 0x25	; 37
   1192a:	94 e1       	ldi	r25, 0x14	; 20
   1192c:	93 83       	std	Z+3, r25	; 0x03
   1192e:	82 83       	std	Z+2, r24	; 0x02
   11930:	80 91 1c 03 	lds	r24, 0x031C
   11934:	90 e0       	ldi	r25, 0x00	; 0
   11936:	01 96       	adiw	r24, 0x01	; 1
   11938:	95 83       	std	Z+5, r25	; 0x05
   1193a:	84 83       	std	Z+4, r24	; 0x04
   1193c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			   lcd_print(1,1,lcdteks);
   11940:	8d b7       	in	r24, 0x3d	; 61
   11942:	9e b7       	in	r25, 0x3e	; 62
   11944:	06 96       	adiw	r24, 0x06	; 6
   11946:	0f b6       	in	r0, 0x3f	; 63
   11948:	f8 94       	cli
   1194a:	9e bf       	out	0x3e, r25	; 62
   1194c:	0f be       	out	0x3f, r0	; 63
   1194e:	8d bf       	out	0x3d, r24	; 61
   11950:	81 e0       	ldi	r24, 0x01	; 1
   11952:	61 e0       	ldi	r22, 0x01	; 1
   11954:	a8 01       	movw	r20, r16
   11956:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   1195a:	84 e0       	ldi	r24, 0x04	; 4
   1195c:	61 e0       	ldi	r22, 0x01	; 1
   1195e:	46 e1       	ldi	r20, 0x16	; 22
   11960:	54 e1       	ldi	r21, 0x14	; 20
   11962:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   11966:	ef e1       	ldi	r30, 0x1F	; 31
   11968:	f6 e0       	ldi	r31, 0x06	; 6
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   1196a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   1196c:	97 e0       	ldi	r25, 0x07	; 7
   1196e:	e0 3b       	cpi	r30, 0xB0	; 176
   11970:	f9 07       	cpc	r31, r25
   11972:	d9 f7       	brne	.-10     	; 0x1196a <FMenuSettingHeader+0x108>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
   11974:	82 e0       	ldi	r24, 0x02	; 2
   11976:	80 93 1d 03 	sts	0x031D, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   1197a:	80 91 1b 03 	lds	r24, 0x031B
   1197e:	8a 32       	cpi	r24, 0x2A	; 42
   11980:	09 f0       	breq	.+2      	; 0x11984 <FMenuSettingHeader+0x122>
   11982:	10 c1       	rjmp	.+544    	; 0x11ba4 <FMenuSettingHeader+0x342>
   11984:	88 e0       	ldi	r24, 0x08	; 8
   11986:	c9 c0       	rjmp	.+402    	; 0x11b1a <FMenuSettingHeader+0x2b8>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
   11988:	83 e0       	ldi	r24, 0x03	; 3
   1198a:	62 e0       	ldi	r22, 0x02	; 2
   1198c:	41 e0       	ldi	r20, 0x01	; 1
   1198e:	2f e1       	ldi	r18, 0x1F	; 31
   11990:	36 e0       	ldi	r19, 0x06	; 6
   11992:	00 e0       	ldi	r16, 0x00	; 0
   11994:	10 e0       	ldi	r17, 0x00	; 0
   11996:	58 e2       	ldi	r21, 0x28	; 40
   11998:	e5 2e       	mov	r14, r21
   1199a:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
		  if (uiResult==USER_OK){
   1199e:	83 30       	cpi	r24, 0x03	; 3
   119a0:	f1 f5       	brne	.+124    	; 0x11a1e <FMenuSettingHeader+0x1bc>
			  lcd_clear();
   119a2:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
   119a6:	8f e1       	ldi	r24, 0x1F	; 31
   119a8:	96 e0       	ldi	r25, 0x06	; 6
   119aa:	68 e2       	ldi	r22, 0x28	; 40
   119ac:	0e 94 b9 2a 	call	0x5572	; 0x5572 <AddSpaceLag>
   119b0:	20 e0       	ldi	r18, 0x00	; 0
   119b2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   119b4:	f9 01       	movw	r30, r18
   119b6:	e9 51       	subi	r30, 0x19	; 25
   119b8:	f5 4f       	sbci	r31, 0xF5	; 245
   119ba:	d9 01       	movw	r26, r18
   119bc:	a1 5e       	subi	r26, 0xE1	; 225
   119be:	b9 4f       	sbci	r27, 0xF9	; 249
   119c0:	8c 91       	ld	r24, X
   119c2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   119c4:	2f 5f       	subi	r18, 0xFF	; 255
   119c6:	3f 4f       	sbci	r19, 0xFF	; 255
   119c8:	24 31       	cpi	r18, 0x14	; 20
   119ca:	31 05       	cpc	r19, r1
   119cc:	99 f7       	brne	.-26     	; 0x119b4 <FMenuSettingHeader+0x152>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   119ce:	10 92 fb 0a 	sts	0x0AFB, r1
   119d2:	e3 e3       	ldi	r30, 0x33	; 51
   119d4:	f6 e0       	ldi	r31, 0x06	; 6
   119d6:	a6 ed       	ldi	r26, 0xD6	; 214
   119d8:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   119da:	81 91       	ld	r24, Z+
   119dc:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   119de:	86 e0       	ldi	r24, 0x06	; 6
   119e0:	e7 34       	cpi	r30, 0x47	; 71
   119e2:	f8 07       	cpc	r31, r24
   119e4:	d1 f7       	brne	.-12     	; 0x119da <FMenuSettingHeader+0x178>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   119e6:	10 92 ea 09 	sts	0x09EA, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
   119ea:	81 e0       	ldi	r24, 0x01	; 1
   119ec:	61 e0       	ldi	r22, 0x01	; 1
   119ee:	47 ee       	ldi	r20, 0xE7	; 231
   119f0:	5a e0       	ldi	r21, 0x0A	; 10
   119f2:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
   119f6:	82 e0       	ldi	r24, 0x02	; 2
   119f8:	61 e0       	ldi	r22, 0x01	; 1
   119fa:	46 ed       	ldi	r20, 0xD6	; 214
   119fc:	59 e0       	ldi	r21, 0x09	; 9
   119fe:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
   11a02:	83 e0       	ldi	r24, 0x03	; 3
   11a04:	61 e0       	ldi	r22, 0x01	; 1
   11a06:	48 e0       	ldi	r20, 0x08	; 8
   11a08:	54 e1       	ldi	r21, 0x14	; 20
   11a0a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
   11a0e:	84 e0       	ldi	r24, 0x04	; 4
   11a10:	61 e0       	ldi	r22, 0x01	; 1
   11a12:	4a ef       	ldi	r20, 0xFA	; 250
   11a14:	53 e1       	ldi	r21, 0x13	; 19
   11a16:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
   11a1a:	85 e0       	ldi	r24, 0x05	; 5
   11a1c:	7e c0       	rjmp	.+252    	; 0x11b1a <FMenuSettingHeader+0x2b8>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   11a1e:	81 30       	cpi	r24, 0x01	; 1
   11a20:	09 f0       	breq	.+2      	; 0x11a24 <FMenuSettingHeader+0x1c2>
   11a22:	c0 c0       	rjmp	.+384    	; 0x11ba4 <FMenuSettingHeader+0x342>
   11a24:	b8 c0       	rjmp	.+368    	; 0x11b96 <FMenuSettingHeader+0x334>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
   11a26:	81 e0       	ldi	r24, 0x01	; 1
   11a28:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   11a2c:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   11a30:	80 93 1b 03 	sts	0x031B, r24
          if(KeyChar=='#'){
   11a34:	83 32       	cpi	r24, 0x23	; 35
   11a36:	39 f4       	brne	.+14     	; 0x11a46 <FMenuSettingHeader+0x1e4>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
   11a38:	8f e1       	ldi	r24, 0x1F	; 31
   11a3a:	96 e0       	ldi	r25, 0x06	; 6
   11a3c:	68 e2       	ldi	r22, 0x28	; 40
   11a3e:	70 e0       	ldi	r23, 0x00	; 0
   11a40:	0e 94 c3 2c 	call	0x5986	; 0x5986 <StrAlignCenter>
   11a44:	03 c0       	rjmp	.+6      	; 0x11a4c <FMenuSettingHeader+0x1ea>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
   11a46:	8a 32       	cpi	r24, 0x2A	; 42
   11a48:	09 f0       	breq	.+2      	; 0x11a4c <FMenuSettingHeader+0x1ea>
   11a4a:	ac c0       	rjmp	.+344    	; 0x11ba4 <FMenuSettingHeader+0x342>
   11a4c:	86 e0       	ldi	r24, 0x06	; 6
   11a4e:	65 c0       	rjmp	.+202    	; 0x11b1a <FMenuSettingHeader+0x2b8>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
   11a50:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
   11a54:	20 e0       	ldi	r18, 0x00	; 0
   11a56:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11a58:	f9 01       	movw	r30, r18
   11a5a:	e9 51       	subi	r30, 0x19	; 25
   11a5c:	f5 4f       	sbci	r31, 0xF5	; 245
   11a5e:	d9 01       	movw	r26, r18
   11a60:	a1 5e       	subi	r26, 0xE1	; 225
   11a62:	b9 4f       	sbci	r27, 0xF9	; 249
   11a64:	8c 91       	ld	r24, X
   11a66:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11a68:	2f 5f       	subi	r18, 0xFF	; 255
   11a6a:	3f 4f       	sbci	r19, 0xFF	; 255
   11a6c:	24 31       	cpi	r18, 0x14	; 20
   11a6e:	31 05       	cpc	r19, r1
   11a70:	99 f7       	brne	.-26     	; 0x11a58 <FMenuSettingHeader+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11a72:	10 92 fb 0a 	sts	0x0AFB, r1
   11a76:	e3 e3       	ldi	r30, 0x33	; 51
   11a78:	f6 e0       	ldi	r31, 0x06	; 6
   11a7a:	a6 ed       	ldi	r26, 0xD6	; 214
   11a7c:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11a7e:	81 91       	ld	r24, Z+
   11a80:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11a82:	96 e0       	ldi	r25, 0x06	; 6
   11a84:	e7 34       	cpi	r30, 0x47	; 71
   11a86:	f9 07       	cpc	r31, r25
   11a88:	d1 f7       	brne	.-12     	; 0x11a7e <FMenuSettingHeader+0x21c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11a8a:	10 92 ea 09 	sts	0x09EA, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
   11a8e:	81 e0       	ldi	r24, 0x01	; 1
   11a90:	61 e0       	ldi	r22, 0x01	; 1
   11a92:	47 ee       	ldi	r20, 0xE7	; 231
   11a94:	5a e0       	ldi	r21, 0x0A	; 10
   11a96:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   11a9a:	82 e0       	ldi	r24, 0x02	; 2
   11a9c:	61 e0       	ldi	r22, 0x01	; 1
   11a9e:	46 ed       	ldi	r20, 0xD6	; 214
   11aa0:	59 e0       	ldi	r21, 0x09	; 9
   11aa2:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Header%d ?"),HeaderIdx+1);
   11aa6:	00 d0       	rcall	.+0      	; 0x11aa8 <FMenuSettingHeader+0x246>
   11aa8:	00 d0       	rcall	.+0      	; 0x11aaa <FMenuSettingHeader+0x248>
   11aaa:	00 d0       	rcall	.+0      	; 0x11aac <FMenuSettingHeader+0x24a>
   11aac:	ed b7       	in	r30, 0x3d	; 61
   11aae:	fe b7       	in	r31, 0x3e	; 62
   11ab0:	31 96       	adiw	r30, 0x01	; 1
   11ab2:	8e 01       	movw	r16, r28
   11ab4:	0f 5f       	subi	r16, 0xFF	; 255
   11ab6:	1f 4f       	sbci	r17, 0xFF	; 255
   11ab8:	ad b7       	in	r26, 0x3d	; 61
   11aba:	be b7       	in	r27, 0x3e	; 62
   11abc:	12 96       	adiw	r26, 0x02	; 2
   11abe:	1c 93       	st	X, r17
   11ac0:	0e 93       	st	-X, r16
   11ac2:	11 97       	sbiw	r26, 0x01	; 1
   11ac4:	8a ee       	ldi	r24, 0xEA	; 234
   11ac6:	93 e1       	ldi	r25, 0x13	; 19
   11ac8:	93 83       	std	Z+3, r25	; 0x03
   11aca:	82 83       	std	Z+2, r24	; 0x02
   11acc:	80 91 1c 03 	lds	r24, 0x031C
   11ad0:	90 e0       	ldi	r25, 0x00	; 0
   11ad2:	01 96       	adiw	r24, 0x01	; 1
   11ad4:	95 83       	std	Z+5, r25	; 0x05
   11ad6:	84 83       	std	Z+4, r24	; 0x04
   11ad8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   11adc:	8d b7       	in	r24, 0x3d	; 61
   11ade:	9e b7       	in	r25, 0x3e	; 62
   11ae0:	06 96       	adiw	r24, 0x06	; 6
   11ae2:	0f b6       	in	r0, 0x3f	; 63
   11ae4:	f8 94       	cli
   11ae6:	9e bf       	out	0x3e, r25	; 62
   11ae8:	0f be       	out	0x3f, r0	; 63
   11aea:	8d bf       	out	0x3d, r24	; 61
   11aec:	83 e0       	ldi	r24, 0x03	; 3
   11aee:	61 e0       	ldi	r22, 0x01	; 1
   11af0:	a8 01       	movw	r20, r16
   11af2:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
   11af6:	84 e0       	ldi	r24, 0x04	; 4
   11af8:	61 e0       	ldi	r22, 0x01	; 1
   11afa:	4d ed       	ldi	r20, 0xDD	; 221
   11afc:	53 e1       	ldi	r21, 0x13	; 19
   11afe:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
   11b02:	84 e0       	ldi	r24, 0x04	; 4
   11b04:	0a c0       	rjmp	.+20     	; 0x11b1a <FMenuSettingHeader+0x2b8>
	      break;    
     case shSaveHeaderQuestions:
	      KeyChar=_key_btn(_key_scan(1));
   11b06:	81 e0       	ldi	r24, 0x01	; 1
   11b08:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   11b0c:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   11b10:	80 93 1b 03 	sts	0x031B, r24
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   11b14:	83 32       	cpi	r24, 0x23	; 35
   11b16:	21 f4       	brne	.+8      	; 0x11b20 <FMenuSettingHeader+0x2be>
   11b18:	87 e0       	ldi	r24, 0x07	; 7
   11b1a:	80 93 1d 03 	sts	0x031D, r24
   11b1e:	42 c0       	rjmp	.+132    	; 0x11ba4 <FMenuSettingHeader+0x342>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   11b20:	8a 32       	cpi	r24, 0x2A	; 42
   11b22:	09 f0       	breq	.+2      	; 0x11b26 <FMenuSettingHeader+0x2c4>
   11b24:	3f c0       	rjmp	.+126    	; 0x11ba4 <FMenuSettingHeader+0x342>
   11b26:	37 c0       	rjmp	.+110    	; 0x11b96 <FMenuSettingHeader+0x334>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
   11b28:	ad b7       	in	r26, 0x3d	; 61
   11b2a:	be b7       	in	r27, 0x3e	; 62
   11b2c:	18 97       	sbiw	r26, 0x08	; 8
   11b2e:	0f b6       	in	r0, 0x3f	; 63
   11b30:	f8 94       	cli
   11b32:	be bf       	out	0x3e, r27	; 62
   11b34:	0f be       	out	0x3f, r0	; 63
   11b36:	ad bf       	out	0x3d, r26	; 61
   11b38:	ed b7       	in	r30, 0x3d	; 61
   11b3a:	fe b7       	in	r31, 0x3e	; 62
   11b3c:	31 96       	adiw	r30, 0x01	; 1
   11b3e:	8e 01       	movw	r16, r28
   11b40:	0b 5e       	subi	r16, 0xEB	; 235
   11b42:	1f 4f       	sbci	r17, 0xFF	; 255
   11b44:	12 96       	adiw	r26, 0x02	; 2
   11b46:	1c 93       	st	X, r17
   11b48:	0e 93       	st	-X, r16
   11b4a:	11 97       	sbiw	r26, 0x01	; 1
   11b4c:	88 ed       	ldi	r24, 0xD8	; 216
   11b4e:	93 e1       	ldi	r25, 0x13	; 19
   11b50:	93 83       	std	Z+3, r25	; 0x03
   11b52:	82 83       	std	Z+2, r24	; 0x02
   11b54:	87 ee       	ldi	r24, 0xE7	; 231
   11b56:	9a e0       	ldi	r25, 0x0A	; 10
   11b58:	95 83       	std	Z+5, r25	; 0x05
   11b5a:	84 83       	std	Z+4, r24	; 0x04
   11b5c:	86 ed       	ldi	r24, 0xD6	; 214
   11b5e:	99 e0       	ldi	r25, 0x09	; 9
   11b60:	97 83       	std	Z+7, r25	; 0x07
   11b62:	86 83       	std	Z+6, r24	; 0x06
   11b64:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   11b68:	8d b7       	in	r24, 0x3d	; 61
   11b6a:	9e b7       	in	r25, 0x3e	; 62
   11b6c:	08 96       	adiw	r24, 0x08	; 8
   11b6e:	0f b6       	in	r0, 0x3f	; 63
   11b70:	f8 94       	cli
   11b72:	9e bf       	out	0x3e, r25	; 62
   11b74:	0f be       	out	0x3f, r0	; 63
   11b76:	8d bf       	out	0x3d, r24	; 61
   11b78:	80 91 1c 03 	lds	r24, 0x031C
   11b7c:	29 e2       	ldi	r18, 0x29	; 41
   11b7e:	82 9f       	mul	r24, r18
   11b80:	c0 01       	movw	r24, r0
   11b82:	11 24       	eor	r1, r1
   11b84:	89 5d       	subi	r24, 0xD9	; 217
   11b86:	9d 4f       	sbci	r25, 0xFD	; 253
   11b88:	b8 01       	movw	r22, r16
   11b8a:	48 e2       	ldi	r20, 0x28	; 40
   11b8c:	50 e0       	ldi	r21, 0x00	; 0
   11b8e:	2d ed       	ldi	r18, 0xDD	; 221
   11b90:	32 e1       	ldi	r19, 0x12	; 18
   11b92:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx],40);
          stSettingHeader=shInitHeader;
   11b96:	10 92 1d 03 	sts	0x031D, r1
   11b9a:	04 c0       	rjmp	.+8      	; 0x11ba4 <FMenuSettingHeader+0x342>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   11b9c:	10 92 1d 03 	sts	0x031D, r1
   11ba0:	81 e0       	ldi	r24, 0x01	; 1
   11ba2:	01 c0       	rjmp	.+2      	; 0x11ba6 <FMenuSettingHeader+0x344>
   11ba4:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   //_menu_header();   
   return Result;
}
   11ba6:	ca 5b       	subi	r28, 0xBA	; 186
   11ba8:	df 4f       	sbci	r29, 0xFF	; 255
   11baa:	0f b6       	in	r0, 0x3f	; 63
   11bac:	f8 94       	cli
   11bae:	de bf       	out	0x3e, r29	; 62
   11bb0:	0f be       	out	0x3f, r0	; 63
   11bb2:	cd bf       	out	0x3d, r28	; 61
   11bb4:	cf 91       	pop	r28
   11bb6:	df 91       	pop	r29
   11bb8:	1f 91       	pop	r17
   11bba:	0f 91       	pop	r16
   11bbc:	ef 90       	pop	r14
   11bbe:	08 95       	ret

00011bc0 <FMenuAdminSettings>:

char FMenuAdminSettings(){
     static char stAdminSettings=asInitMenu;
	 char SubMenu,Result,KeyChar;
	 Result=MENU_NONE;
	 switch(stAdminSettings){
   11bc0:	80 91 1e 03 	lds	r24, 0x031E
   11bc4:	83 30       	cpi	r24, 0x03	; 3
   11bc6:	09 f4       	brne	.+2      	; 0x11bca <FMenuAdminSettings+0xa>
   11bc8:	6e c0       	rjmp	.+220    	; 0x11ca6 <FMenuAdminSettings+0xe6>
   11bca:	84 30       	cpi	r24, 0x04	; 4
   11bcc:	30 f4       	brcc	.+12     	; 0x11bda <FMenuAdminSettings+0x1a>
   11bce:	81 30       	cpi	r24, 0x01	; 1
   11bd0:	e9 f1       	breq	.+122    	; 0x11c4c <FMenuAdminSettings+0x8c>
   11bd2:	82 30       	cpi	r24, 0x02	; 2
   11bd4:	08 f0       	brcs	.+2      	; 0x11bd8 <FMenuAdminSettings+0x18>
   11bd6:	64 c0       	rjmp	.+200    	; 0x11ca0 <FMenuAdminSettings+0xe0>
   11bd8:	0d c0       	rjmp	.+26     	; 0x11bf4 <FMenuAdminSettings+0x34>
   11bda:	85 30       	cpi	r24, 0x05	; 5
   11bdc:	09 f4       	brne	.+2      	; 0x11be0 <FMenuAdminSettings+0x20>
   11bde:	66 c0       	rjmp	.+204    	; 0x11cac <FMenuAdminSettings+0xec>
   11be0:	85 30       	cpi	r24, 0x05	; 5
   11be2:	08 f4       	brcc	.+2      	; 0x11be6 <FMenuAdminSettings+0x26>
   11be4:	6a c0       	rjmp	.+212    	; 0x11cba <FMenuAdminSettings+0xfa>
   11be6:	86 30       	cpi	r24, 0x06	; 6
   11be8:	09 f4       	brne	.+2      	; 0x11bec <FMenuAdminSettings+0x2c>
   11bea:	63 c0       	rjmp	.+198    	; 0x11cb2 <FMenuAdminSettings+0xf2>
   11bec:	87 30       	cpi	r24, 0x07	; 7
   11bee:	09 f0       	breq	.+2      	; 0x11bf2 <FMenuAdminSettings+0x32>
   11bf0:	6c c0       	rjmp	.+216    	; 0x11cca <FMenuAdminSettings+0x10a>
   11bf2:	67 c0       	rjmp	.+206    	; 0x11cc2 <FMenuAdminSettings+0x102>
	 case asInitMenu:
          lcd_clear();
   11bf4:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  if (IFType==IT_SLAVE){
   11bf8:	80 91 10 01 	lds	r24, 0x0110
   11bfc:	81 30       	cpi	r24, 0x01	; 1
   11bfe:	51 f4       	brne	.+20     	; 0x11c14 <FMenuAdminSettings+0x54>
		      lcd_printf(1,1, PSTR("1)Header    4)Client"));
   11c00:	61 e0       	ldi	r22, 0x01	; 1
   11c02:	43 ee       	ldi	r20, 0xE3	; 227
   11c04:	54 e1       	ldi	r21, 0x14	; 20
   11c06:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer    5)Server"));
   11c0a:	82 e0       	ldi	r24, 0x02	; 2
   11c0c:	61 e0       	ldi	r22, 0x01	; 1
   11c0e:	4e ec       	ldi	r20, 0xCE	; 206
   11c10:	54 e1       	ldi	r21, 0x14	; 20
   11c12:	0c c0       	rjmp	.+24     	; 0x11c2c <FMenuAdminSettings+0x6c>
		  }else
		  if (IFType==IT_STANDALONE){
   11c14:	82 30       	cpi	r24, 0x02	; 2
   11c16:	61 f4       	brne	.+24     	; 0x11c30 <FMenuAdminSettings+0x70>
		      lcd_printf(1,1, PSTR("1)Header            "));
   11c18:	81 e0       	ldi	r24, 0x01	; 1
   11c1a:	61 e0       	ldi	r22, 0x01	; 1
   11c1c:	49 eb       	ldi	r20, 0xB9	; 185
   11c1e:	54 e1       	ldi	r21, 0x14	; 20
   11c20:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer            "));
   11c24:	82 e0       	ldi	r24, 0x02	; 2
   11c26:	61 e0       	ldi	r22, 0x01	; 1
   11c28:	44 ea       	ldi	r20, 0xA4	; 164
   11c2a:	54 e1       	ldi	r21, 0x14	; 20
   11c2c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  }
		  lcd_printf(3,1, PSTR("3)Password          "));
   11c30:	83 e0       	ldi	r24, 0x03	; 3
   11c32:	61 e0       	ldi	r22, 0x01	; 1
   11c34:	4f e8       	ldi	r20, 0x8F	; 143
   11c36:	54 e1       	ldi	r21, 0x14	; 20
   11c38:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4,1, PSTR("*)Exit"));
   11c3c:	84 e0       	ldi	r24, 0x04	; 4
   11c3e:	61 e0       	ldi	r22, 0x01	; 1
   11c40:	48 e8       	ldi	r20, 0x88	; 136
   11c42:	54 e1       	ldi	r21, 0x14	; 20
   11c44:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  stAdminSettings=asAdminSettingsOption;
   11c48:	81 e0       	ldi	r24, 0x01	; 1
   11c4a:	27 c0       	rjmp	.+78     	; 0x11c9a <FMenuAdminSettings+0xda>
		  break;
     case asAdminSettingsOption:
	      KeyChar=_key_btn(_key_scan(1));
   11c4c:	81 e0       	ldi	r24, 0x01	; 1
   11c4e:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   11c52:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   11c56:	98 2f       	mov	r25, r24
		  switch(KeyChar){
   11c58:	82 33       	cpi	r24, 0x32	; 50
   11c5a:	61 f0       	breq	.+24     	; 0x11c74 <FMenuAdminSettings+0xb4>
   11c5c:	83 33       	cpi	r24, 0x33	; 51
   11c5e:	28 f4       	brcc	.+10     	; 0x11c6a <FMenuAdminSettings+0xaa>
   11c60:	8a 32       	cpi	r24, 0x2A	; 42
   11c62:	61 f0       	breq	.+24     	; 0x11c7c <FMenuAdminSettings+0xbc>
   11c64:	81 33       	cpi	r24, 0x31	; 49
   11c66:	69 f4       	brne	.+26     	; 0x11c82 <FMenuAdminSettings+0xc2>
   11c68:	03 c0       	rjmp	.+6      	; 0x11c70 <FMenuAdminSettings+0xb0>
   11c6a:	83 33       	cpi	r24, 0x33	; 51
   11c6c:	51 f4       	brne	.+20     	; 0x11c82 <FMenuAdminSettings+0xc2>
   11c6e:	04 c0       	rjmp	.+8      	; 0x11c78 <FMenuAdminSettings+0xb8>
		  case '1':stAdminSettings=asAdminSettingHeader;
   11c70:	82 e0       	ldi	r24, 0x02	; 2
   11c72:	05 c0       	rjmp	.+10     	; 0x11c7e <FMenuAdminSettings+0xbe>
		       break;
		  case '2':stAdminSettings=asAdminSettingFooter;
   11c74:	83 e0       	ldi	r24, 0x03	; 3
   11c76:	03 c0       	rjmp	.+6      	; 0x11c7e <FMenuAdminSettings+0xbe>
		       break;
		  case '3':stAdminSettings=asAdminSettingPassword;
   11c78:	84 e0       	ldi	r24, 0x04	; 4
   11c7a:	01 c0       	rjmp	.+2      	; 0x11c7e <FMenuAdminSettings+0xbe>
		       break;
		  case '*':stAdminSettings=asExitAdminSetting;
   11c7c:	87 e0       	ldi	r24, 0x07	; 7
   11c7e:	80 93 1e 03 	sts	0x031E, r24
		       break;			   
		  }
		  if (IFType==IT_SLAVE){
   11c82:	80 91 10 01 	lds	r24, 0x0110
   11c86:	81 30       	cpi	r24, 0x01	; 1
   11c88:	01 f5       	brne	.+64     	; 0x11cca <FMenuAdminSettings+0x10a>
			  switch(KeyChar){
   11c8a:	94 33       	cpi	r25, 0x34	; 52
   11c8c:	19 f0       	breq	.+6      	; 0x11c94 <FMenuAdminSettings+0xd4>
   11c8e:	95 33       	cpi	r25, 0x35	; 53
   11c90:	e1 f4       	brne	.+56     	; 0x11cca <FMenuAdminSettings+0x10a>
   11c92:	02 c0       	rjmp	.+4      	; 0x11c98 <FMenuAdminSettings+0xd8>
			  case '4':stAdminSettings=asAdminSettingClientIP;
   11c94:	85 e0       	ldi	r24, 0x05	; 5
   11c96:	01 c0       	rjmp	.+2      	; 0x11c9a <FMenuAdminSettings+0xda>
				   break;
			  case '5':stAdminSettings=asAdminSettingServerIP;
   11c98:	86 e0       	ldi	r24, 0x06	; 6
   11c9a:	80 93 1e 03 	sts	0x031E, r24
   11c9e:	0f c0       	rjmp	.+30     	; 0x11cbe <FMenuAdminSettings+0xfe>
				   break;
			  }
		  }
	      break;
	 case asAdminSettingHeader:
	      SubMenu=FMenuSettingHeader();
   11ca0:	0e 94 31 8c 	call	0x11862	; 0x11862 <FMenuSettingHeader>
   11ca4:	08 c0       	rjmp	.+16     	; 0x11cb6 <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;
	      break;
	 case asAdminSettingFooter:
	      SubMenu=FMenuSettingFooter();
   11ca6:	0e 94 82 8a 	call	0x11504	; 0x11504 <FMenuSettingFooter>
   11caa:	05 c0       	rjmp	.+10     	; 0x11cb6 <FMenuAdminSettings+0xf6>
	 case asAdminSettingPassword:
	      SubMenu=FMenuSettingPassword();
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
     case asAdminSettingClientIP:
	      SubMenu=FMenuSettingClientIP();
   11cac:	0e 94 48 6b 	call	0xd690	; 0xd690 <FMenuSettingClientIP>
   11cb0:	02 c0       	rjmp	.+4      	; 0x11cb6 <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
	 case asAdminSettingServerIP:
	      SubMenu=FMenuSettingServerIP();
   11cb2:	0e 94 be 68 	call	0xd17c	; 0xd17c <FMenuSettingServerIP>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
   11cb6:	81 30       	cpi	r24, 0x01	; 1
   11cb8:	41 f4       	brne	.+16     	; 0x11cca <FMenuAdminSettings+0x10a>
   11cba:	10 92 1e 03 	sts	0x031E, r1
   11cbe:	80 e0       	ldi	r24, 0x00	; 0
   11cc0:	08 95       	ret
	      break;
     case asExitAdminSetting:
	      stAdminSettings=asInitMenu;
   11cc2:	10 92 1e 03 	sts	0x031E, r1
   11cc6:	81 e0       	ldi	r24, 0x01	; 1
   11cc8:	08 95       	ret
   11cca:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   11ccc:	08 95       	ret

00011cce <FMenuMaster>:
     else Result=RC_INVALID;

   return Result;
}

char FMenuMaster(){ 
   11cce:	ef 92       	push	r14
   11cd0:	ff 92       	push	r15
   11cd2:	0f 93       	push	r16
   11cd4:	1f 93       	push	r17
   11cd6:	df 93       	push	r29
   11cd8:	cf 93       	push	r28
   11cda:	cd b7       	in	r28, 0x3d	; 61
   11cdc:	de b7       	in	r29, 0x3e	; 62
   11cde:	e2 97       	sbiw	r28, 0x32	; 50
   11ce0:	0f b6       	in	r0, 0x3f	; 63
   11ce2:	f8 94       	cli
   11ce4:	de bf       	out	0x3e, r29	; 62
   11ce6:	0f be       	out	0x3f, r0	; 63
   11ce8:	cd bf       	out	0x3d, r28	; 61
static char stMenuMaster=mmInitMaster;
     char KeyPressed,KeyChar,Result=MENU_NONE;
	 char uiResult,lcdteks[20],PTime[10],PDate[10],strNewPassword[10];
	 char strSend[20];

	 switch(stMenuMaster){
   11cea:	80 91 23 03 	lds	r24, 0x0323
   11cee:	e8 2f       	mov	r30, r24
   11cf0:	f0 e0       	ldi	r31, 0x00	; 0
   11cf2:	e1 31       	cpi	r30, 0x11	; 17
   11cf4:	f1 05       	cpc	r31, r1
   11cf6:	08 f0       	brcs	.+2      	; 0x11cfa <FMenuMaster+0x2c>
   11cf8:	f3 c1       	rjmp	.+998    	; 0x120e0 <FMenuMaster+0x412>
   11cfa:	ed 54       	subi	r30, 0x4D	; 77
   11cfc:	ff 4f       	sbci	r31, 0xFF	; 255
   11cfe:	ee 0f       	add	r30, r30
   11d00:	ff 1f       	adc	r31, r31
   11d02:	05 90       	lpm	r0, Z+
   11d04:	f4 91       	lpm	r31, Z+
   11d06:	e0 2d       	mov	r30, r0
   11d08:	09 94       	ijmp
	 case mmInitMaster:
	      lcd_clear();
   11d0a:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("-System Admin Level-"));
   11d0e:	81 e0       	ldi	r24, 0x01	; 1
   11d10:	61 e0       	ldi	r22, 0x01	; 1
   11d12:	49 e5       	ldi	r20, 0x59	; 89
   11d14:	57 e1       	ldi	r21, 0x17	; 23
   11d16:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Restore Password  "));
   11d1a:	82 e0       	ldi	r24, 0x02	; 2
   11d1c:	61 e0       	ldi	r22, 0x01	; 1
   11d1e:	44 e4       	ldi	r20, 0x44	; 68
   11d20:	57 e1       	ldi	r21, 0x17	; 23
   11d22:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Change Password   "));
   11d26:	83 e0       	ldi	r24, 0x03	; 3
   11d28:	61 e0       	ldi	r22, 0x01	; 1
   11d2a:	4f e2       	ldi	r20, 0x2F	; 47
   11d2c:	57 e1       	ldi	r21, 0x17	; 23
   11d2e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Exit             "));
   11d32:	84 e0       	ldi	r24, 0x04	; 4
   11d34:	61 e0       	ldi	r22, 0x01	; 1
   11d36:	4a e1       	ldi	r20, 0x1A	; 26
   11d38:	57 e1       	ldi	r21, 0x17	; 23
   11d3a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>

		  //_uart_printf(1,1,PSTR("-System Admin Level-"));

		  stMenuMaster=mmMasterSelect;
   11d3e:	81 e0       	ldi	r24, 0x01	; 1
   11d40:	f6 c0       	rjmp	.+492    	; 0x11f2e <FMenuMaster+0x260>
	      break;
     case mmMasterSelect:
	 	  KeyPressed=_key_scan(1);
   11d42:	81 e0       	ldi	r24, 0x01	; 1
   11d44:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   11d48:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
          switch(KeyChar){
   11d4c:	81 33       	cpi	r24, 0x31	; 49
   11d4e:	09 f4       	brne	.+2      	; 0x11d52 <FMenuMaster+0x84>
   11d50:	ed c0       	rjmp	.+474    	; 0x11f2c <FMenuMaster+0x25e>
   11d52:	82 33       	cpi	r24, 0x32	; 50
   11d54:	21 f0       	breq	.+8      	; 0x11d5e <FMenuMaster+0x90>
   11d56:	8a 32       	cpi	r24, 0x2A	; 42
   11d58:	09 f0       	breq	.+2      	; 0x11d5c <FMenuMaster+0x8e>
   11d5a:	c2 c1       	rjmp	.+900    	; 0x120e0 <FMenuMaster+0x412>
   11d5c:	bb c1       	rjmp	.+886    	; 0x120d4 <FMenuMaster+0x406>
		  case '1':
               stMenuMaster=mmRestorePasswordMenu;
		       break;
		  case '2':
		       stMenuMaster=mmChangePassword;
   11d5e:	8e e0       	ldi	r24, 0x0E	; 14
   11d60:	e6 c0       	rjmp	.+460    	; 0x11f2e <FMenuMaster+0x260>
		       stMenuMaster=mmExitMaster;
		       break;
		  }
	      break;
     case mmChangePassword:
	      stMenuMaster=mmInitMaster;
   11d62:	10 92 23 03 	sts	0x0323, r1
   11d66:	bc c1       	rjmp	.+888    	; 0x120e0 <FMenuMaster+0x412>
	      break;
     case mmRestorePasswordMenu:	      
	      lcd_clear();
   11d68:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("Enter GeNiUs Code   "));
   11d6c:	81 e0       	ldi	r24, 0x01	; 1
   11d6e:	61 e0       	ldi	r22, 0x01	; 1
   11d70:	45 e0       	ldi	r20, 0x05	; 5
   11d72:	57 e1       	ldi	r21, 0x17	; 23
   11d74:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2,1,PSTR("_                   "));
   11d78:	82 e0       	ldi	r24, 0x02	; 2
   11d7a:	61 e0       	ldi	r22, 0x01	; 1
   11d7c:	40 ef       	ldi	r20, 0xF0	; 240
   11d7e:	56 e1       	ldi	r21, 0x16	; 22
   11d80:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4,4,PSTR("[*]Cancel   [#]Enter"));
   11d84:	84 e0       	ldi	r24, 0x04	; 4
   11d86:	64 e0       	ldi	r22, 0x04	; 4
   11d88:	4b ed       	ldi	r20, 0xDB	; 219
   11d8a:	56 e1       	ldi	r21, 0x16	; 22
   11d8c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  sprintf_P(strGeniusCode,PSTR(""));
   11d90:	00 d0       	rcall	.+0      	; 0x11d92 <FMenuMaster+0xc4>
   11d92:	00 d0       	rcall	.+0      	; 0x11d94 <FMenuMaster+0xc6>
   11d94:	85 ec       	ldi	r24, 0xC5	; 197
   11d96:	97 e0       	ldi	r25, 0x07	; 7
   11d98:	ad b7       	in	r26, 0x3d	; 61
   11d9a:	be b7       	in	r27, 0x3e	; 62
   11d9c:	12 96       	adiw	r26, 0x02	; 2
   11d9e:	9c 93       	st	X, r25
   11da0:	8e 93       	st	-X, r24
   11da2:	11 97       	sbiw	r26, 0x01	; 1
   11da4:	8a ed       	ldi	r24, 0xDA	; 218
   11da6:	96 e1       	ldi	r25, 0x16	; 22
   11da8:	14 96       	adiw	r26, 0x04	; 4
   11daa:	9c 93       	st	X, r25
   11dac:	8e 93       	st	-X, r24
   11dae:	13 97       	sbiw	r26, 0x03	; 3
   11db0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
          stMenuMaster=mmGeniusCodeEntry;
   11db4:	83 e0       	ldi	r24, 0x03	; 3
   11db6:	80 93 23 03 	sts	0x0323, r24
   11dba:	80 e0       	ldi	r24, 0x00	; 0
   11dbc:	0f 90       	pop	r0
   11dbe:	0f 90       	pop	r0
   11dc0:	0f 90       	pop	r0
   11dc2:	0f 90       	pop	r0
   11dc4:	8e c1       	rjmp	.+796    	; 0x120e2 <FMenuMaster+0x414>
	      break;
     case mmGeniusCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,2,1,strGeniusCode,0,10);
   11dc6:	81 e0       	ldi	r24, 0x01	; 1
   11dc8:	62 e0       	ldi	r22, 0x02	; 2
   11dca:	41 e0       	ldi	r20, 0x01	; 1
   11dcc:	25 ec       	ldi	r18, 0xC5	; 197
   11dce:	37 e0       	ldi	r19, 0x07	; 7
   11dd0:	00 e0       	ldi	r16, 0x00	; 0
   11dd2:	10 e0       	ldi	r17, 0x00	; 0
   11dd4:	fa e0       	ldi	r31, 0x0A	; 10
   11dd6:	ef 2e       	mov	r14, r31
   11dd8:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
		  switch(uiResult){
   11ddc:	83 30       	cpi	r24, 0x03	; 3
   11dde:	49 f0       	breq	.+18     	; 0x11df2 <FMenuMaster+0x124>
   11de0:	84 30       	cpi	r24, 0x04	; 4
   11de2:	08 f4       	brcc	.+2      	; 0x11de6 <FMenuMaster+0x118>
   11de4:	f2 c0       	rjmp	.+484    	; 0x11fca <FMenuMaster+0x2fc>
   11de6:	84 30       	cpi	r24, 0x04	; 4
   11de8:	69 f0       	breq	.+26     	; 0x11e04 <FMenuMaster+0x136>
   11dea:	85 30       	cpi	r24, 0x05	; 5
   11dec:	09 f0       	breq	.+2      	; 0x11df0 <FMenuMaster+0x122>
   11dee:	78 c1       	rjmp	.+752    	; 0x120e0 <FMenuMaster+0x412>
   11df0:	0e c0       	rjmp	.+28     	; 0x11e0e <FMenuMaster+0x140>
		  case USER_OK:
               
			   //_uart_printf(1,0,PSTR("GeniusCode: "));
			   //_uart_print(1,1,strGeniusCode);

		       _datetime(0, strSystemDate, strSystemTime);
   11df2:	80 e0       	ldi	r24, 0x00	; 0
   11df4:	6a ee       	ldi	r22, 0xEA	; 234
   11df6:	75 e0       	ldi	r23, 0x05	; 5
   11df8:	49 ec       	ldi	r20, 0xC9	; 201
   11dfa:	5a e0       	ldi	r21, 0x0A	; 10
   11dfc:	0e 94 4b b1 	call	0x16296	; 0x16296 <_datetime>
               stMenuMaster=mmIsValidGeniusCode;
   11e00:	84 e0       	ldi	r24, 0x04	; 4
   11e02:	95 c0       	rjmp	.+298    	; 0x11f2e <FMenuMaster+0x260>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11e04:	84 e0       	ldi	r24, 0x04	; 4
   11e06:	61 e0       	ldi	r22, 0x01	; 1
   11e08:	45 ec       	ldi	r20, 0xC5	; 197
   11e0a:	56 e1       	ldi	r21, 0x16	; 22
   11e0c:	f3 c0       	rjmp	.+486    	; 0x11ff4 <FMenuMaster+0x326>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11e0e:	84 e0       	ldi	r24, 0x04	; 4
   11e10:	61 e0       	ldi	r22, 0x01	; 1
   11e12:	40 eb       	ldi	r20, 0xB0	; 176
   11e14:	56 e1       	ldi	r21, 0x16	; 22
   11e16:	ee c0       	rjmp	.+476    	; 0x11ff4 <FMenuMaster+0x326>
		       break;
		  }
	      break;
     case mmIsValidGeniusCode:
	      //GetDate
		      sprintf_P(PDate,PSTR("%s"),strSystemDate);
   11e18:	00 d0       	rcall	.+0      	; 0x11e1a <FMenuMaster+0x14c>
   11e1a:	00 d0       	rcall	.+0      	; 0x11e1c <FMenuMaster+0x14e>
   11e1c:	00 d0       	rcall	.+0      	; 0x11e1e <FMenuMaster+0x150>
   11e1e:	ed b7       	in	r30, 0x3d	; 61
   11e20:	fe b7       	in	r31, 0x3e	; 62
   11e22:	31 96       	adiw	r30, 0x01	; 1
   11e24:	8e 01       	movw	r16, r28
   11e26:	05 5f       	subi	r16, 0xF5	; 245
   11e28:	1f 4f       	sbci	r17, 0xFF	; 255
   11e2a:	ad b7       	in	r26, 0x3d	; 61
   11e2c:	be b7       	in	r27, 0x3e	; 62
   11e2e:	12 96       	adiw	r26, 0x02	; 2
   11e30:	1c 93       	st	X, r17
   11e32:	0e 93       	st	-X, r16
   11e34:	11 97       	sbiw	r26, 0x01	; 1
   11e36:	8d ea       	ldi	r24, 0xAD	; 173
   11e38:	96 e1       	ldi	r25, 0x16	; 22
   11e3a:	93 83       	std	Z+3, r25	; 0x03
   11e3c:	82 83       	std	Z+2, r24	; 0x02
   11e3e:	8a ee       	ldi	r24, 0xEA	; 234
   11e40:	95 e0       	ldi	r25, 0x05	; 5
   11e42:	95 83       	std	Z+5, r25	; 0x05
   11e44:	84 83       	std	Z+4, r24	; 0x04
   11e46:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			  RemoveChar(PDate,'/');
   11e4a:	ed b7       	in	r30, 0x3d	; 61
   11e4c:	fe b7       	in	r31, 0x3e	; 62
   11e4e:	36 96       	adiw	r30, 0x06	; 6
   11e50:	0f b6       	in	r0, 0x3f	; 63
   11e52:	f8 94       	cli
   11e54:	fe bf       	out	0x3e, r31	; 62
   11e56:	0f be       	out	0x3f, r0	; 63
   11e58:	ed bf       	out	0x3d, r30	; 61
   11e5a:	c8 01       	movw	r24, r16
   11e5c:	6f e2       	ldi	r22, 0x2F	; 47
   11e5e:	0e 94 9b 2d 	call	0x5b36	; 0x5b36 <RemoveChar>
		  if (ValidateGeniusCode(PDate,strGeniusCode)==GC_VALID){
   11e62:	c8 01       	movw	r24, r16
   11e64:	65 ec       	ldi	r22, 0xC5	; 197
   11e66:	77 e0       	ldi	r23, 0x07	; 7
   11e68:	0e 94 87 68 	call	0xd10e	; 0xd10e <ValidateGeniusCode>
   11e6c:	81 30       	cpi	r24, 0x01	; 1
   11e6e:	09 f0       	breq	.+2      	; 0x11e72 <FMenuMaster+0x1a4>
   11e70:	44 c0       	rjmp	.+136    	; 0x11efa <FMenuMaster+0x22c>

		  	  sprintf_P(PTime,PSTR("%s"),strSystemTime);
   11e72:	00 d0       	rcall	.+0      	; 0x11e74 <FMenuMaster+0x1a6>
   11e74:	00 d0       	rcall	.+0      	; 0x11e76 <FMenuMaster+0x1a8>
   11e76:	00 d0       	rcall	.+0      	; 0x11e78 <FMenuMaster+0x1aa>
   11e78:	ed b7       	in	r30, 0x3d	; 61
   11e7a:	fe b7       	in	r31, 0x3e	; 62
   11e7c:	31 96       	adiw	r30, 0x01	; 1
   11e7e:	8e 01       	movw	r16, r28
   11e80:	0f 5f       	subi	r16, 0xFF	; 255
   11e82:	1f 4f       	sbci	r17, 0xFF	; 255
   11e84:	ad b7       	in	r26, 0x3d	; 61
   11e86:	be b7       	in	r27, 0x3e	; 62
   11e88:	12 96       	adiw	r26, 0x02	; 2
   11e8a:	1c 93       	st	X, r17
   11e8c:	0e 93       	st	-X, r16
   11e8e:	11 97       	sbiw	r26, 0x01	; 1
   11e90:	8a ea       	ldi	r24, 0xAA	; 170
   11e92:	96 e1       	ldi	r25, 0x16	; 22
   11e94:	93 83       	std	Z+3, r25	; 0x03
   11e96:	82 83       	std	Z+2, r24	; 0x02
   11e98:	89 ec       	ldi	r24, 0xC9	; 201
   11e9a:	9a e0       	ldi	r25, 0x0A	; 10
   11e9c:	95 83       	std	Z+5, r25	; 0x05
   11e9e:	84 83       	std	Z+4, r24	; 0x04
   11ea0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			  RemoveChar(PTime,':');sprintf_P(strKeyStamp,PSTR(""));
   11ea4:	ed b7       	in	r30, 0x3d	; 61
   11ea6:	fe b7       	in	r31, 0x3e	; 62
   11ea8:	36 96       	adiw	r30, 0x06	; 6
   11eaa:	0f b6       	in	r0, 0x3f	; 63
   11eac:	f8 94       	cli
   11eae:	fe bf       	out	0x3e, r31	; 62
   11eb0:	0f be       	out	0x3f, r0	; 63
   11eb2:	ed bf       	out	0x3d, r30	; 61
   11eb4:	c8 01       	movw	r24, r16
   11eb6:	6a e3       	ldi	r22, 0x3A	; 58
   11eb8:	0e 94 9b 2d 	call	0x5b36	; 0x5b36 <RemoveChar>
   11ebc:	00 d0       	rcall	.+0      	; 0x11ebe <FMenuMaster+0x1f0>
   11ebe:	00 d0       	rcall	.+0      	; 0x11ec0 <FMenuMaster+0x1f2>
   11ec0:	e3 e0       	ldi	r30, 0x03	; 3
   11ec2:	ee 2e       	mov	r14, r30
   11ec4:	ea e0       	ldi	r30, 0x0A	; 10
   11ec6:	fe 2e       	mov	r15, r30
   11ec8:	ad b7       	in	r26, 0x3d	; 61
   11eca:	be b7       	in	r27, 0x3e	; 62
   11ecc:	12 96       	adiw	r26, 0x02	; 2
   11ece:	fc 92       	st	X, r15
   11ed0:	ee 92       	st	-X, r14
   11ed2:	11 97       	sbiw	r26, 0x01	; 1
   11ed4:	89 ea       	ldi	r24, 0xA9	; 169
   11ed6:	96 e1       	ldi	r25, 0x16	; 22
   11ed8:	14 96       	adiw	r26, 0x04	; 4
   11eda:	9c 93       	st	X, r25
   11edc:	8e 93       	st	-X, r24
   11ede:	13 97       	sbiw	r26, 0x03	; 3
   11ee0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>

              //sprintf_P(strSend,PSTR("Time:%s"),PTime);
			  // _uart_print(1,1,strSend);

		      GenerateKeyStamp(PTime,strGeniusCode,strKeyStamp);			  
   11ee4:	0f 90       	pop	r0
   11ee6:	0f 90       	pop	r0
   11ee8:	0f 90       	pop	r0
   11eea:	0f 90       	pop	r0
   11eec:	c8 01       	movw	r24, r16
   11eee:	65 ec       	ldi	r22, 0xC5	; 197
   11ef0:	77 e0       	ldi	r23, 0x07	; 7
   11ef2:	a7 01       	movw	r20, r14
   11ef4:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <GenerateKeyStamp>
   11ef8:	d5 c0       	rjmp	.+426    	; 0x120a4 <FMenuMaster+0x3d6>
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
   11efa:	85 e0       	ldi	r24, 0x05	; 5
   11efc:	18 c0       	rjmp	.+48     	; 0x11f2e <FMenuMaster+0x260>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11efe:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   11f00:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11f02:	81 e0       	ldi	r24, 0x01	; 1
   11f04:	90 e0       	ldi	r25, 0x00	; 0
   11f06:	90 93 d7 01 	sts	0x01D7, r25
   11f0a:	80 93 d6 01 	sts	0x01D6, r24
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
	      break;
     case mmDisplayInvalidCode:
	      system_beep(1);
          lcd_printf(3,1,PSTR("Invalid Code        "));
   11f0e:	83 e0       	ldi	r24, 0x03	; 3
   11f10:	61 e0       	ldi	r22, 0x01	; 1
   11f12:	44 e9       	ldi	r20, 0x94	; 148
   11f14:	56 e1       	ldi	r21, 0x16	; 22
   11f16:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          TimDisplay=0; 
   11f1a:	10 92 a7 01 	sts	0x01A7, r1
		  stMenuMaster=mmDelayDisplayInvalidCode;
   11f1e:	86 e0       	ldi	r24, 0x06	; 6
   11f20:	06 c0       	rjmp	.+12     	; 0x11f2e <FMenuMaster+0x260>
	      break;
     case mmDelayDisplayInvalidCode:
	      if (TimDisplay>5)stMenuMaster=mmRestorePasswordMenu;
   11f22:	80 91 a7 01 	lds	r24, 0x01A7
   11f26:	86 30       	cpi	r24, 0x06	; 6
   11f28:	08 f4       	brcc	.+2      	; 0x11f2c <FMenuMaster+0x25e>
   11f2a:	da c0       	rjmp	.+436    	; 0x120e0 <FMenuMaster+0x412>
   11f2c:	82 e0       	ldi	r24, 0x02	; 2
   11f2e:	80 93 23 03 	sts	0x0323, r24
   11f32:	d6 c0       	rjmp	.+428    	; 0x120e0 <FMenuMaster+0x412>
	      break;
     case mmDisplayKeyStamp:
	      lcd_clear();
   11f34:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("Key Stamp:%s "),strKeyStamp);
   11f38:	00 d0       	rcall	.+0      	; 0x11f3a <FMenuMaster+0x26c>
   11f3a:	00 d0       	rcall	.+0      	; 0x11f3c <FMenuMaster+0x26e>
   11f3c:	00 d0       	rcall	.+0      	; 0x11f3e <FMenuMaster+0x270>
   11f3e:	ed b7       	in	r30, 0x3d	; 61
   11f40:	fe b7       	in	r31, 0x3e	; 62
   11f42:	31 96       	adiw	r30, 0x01	; 1
   11f44:	8e 01       	movw	r16, r28
   11f46:	01 5e       	subi	r16, 0xE1	; 225
   11f48:	1f 4f       	sbci	r17, 0xFF	; 255
   11f4a:	ad b7       	in	r26, 0x3d	; 61
   11f4c:	be b7       	in	r27, 0x3e	; 62
   11f4e:	12 96       	adiw	r26, 0x02	; 2
   11f50:	1c 93       	st	X, r17
   11f52:	0e 93       	st	-X, r16
   11f54:	11 97       	sbiw	r26, 0x01	; 1
   11f56:	86 e8       	ldi	r24, 0x86	; 134
   11f58:	96 e1       	ldi	r25, 0x16	; 22
   11f5a:	93 83       	std	Z+3, r25	; 0x03
   11f5c:	82 83       	std	Z+2, r24	; 0x02
   11f5e:	83 e0       	ldi	r24, 0x03	; 3
   11f60:	9a e0       	ldi	r25, 0x0A	; 10
   11f62:	95 83       	std	Z+5, r25	; 0x05
   11f64:	84 83       	std	Z+4, r24	; 0x04
   11f66:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   11f6a:	ed b7       	in	r30, 0x3d	; 61
   11f6c:	fe b7       	in	r31, 0x3e	; 62
   11f6e:	36 96       	adiw	r30, 0x06	; 6
   11f70:	0f b6       	in	r0, 0x3f	; 63
   11f72:	f8 94       	cli
   11f74:	fe bf       	out	0x3e, r31	; 62
   11f76:	0f be       	out	0x3f, r0	; 63
   11f78:	ed bf       	out	0x3d, r30	; 61
   11f7a:	81 e0       	ldi	r24, 0x01	; 1
   11f7c:	61 e0       	ldi	r22, 0x01	; 1
   11f7e:	a8 01       	movw	r20, r16
   11f80:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_printf(2,1,PSTR("Enter Restore Code  "));
   11f84:	82 e0       	ldi	r24, 0x02	; 2
   11f86:	61 e0       	ldi	r22, 0x01	; 1
   11f88:	41 e7       	ldi	r20, 0x71	; 113
   11f8a:	56 e1       	ldi	r21, 0x16	; 22
   11f8c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(3,1,PSTR("_                   "));
   11f90:	83 e0       	ldi	r24, 0x03	; 3
   11f92:	61 e0       	ldi	r22, 0x01	; 1
   11f94:	4c e5       	ldi	r20, 0x5C	; 92
   11f96:	56 e1       	ldi	r21, 0x16	; 22
   11f98:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11f9c:	84 e0       	ldi	r24, 0x04	; 4
   11f9e:	61 e0       	ldi	r22, 0x01	; 1
   11fa0:	47 e4       	ldi	r20, 0x47	; 71
   11fa2:	56 e1       	ldi	r21, 0x16	; 22
   11fa4:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          stMenuMaster=mmRestoreCodeEntry;
   11fa8:	88 e0       	ldi	r24, 0x08	; 8
   11faa:	c1 cf       	rjmp	.-126    	; 0x11f2e <FMenuMaster+0x260>
	      break;
     case mmRestoreCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,3,1,strRestoreCode,0,10);
   11fac:	81 e0       	ldi	r24, 0x01	; 1
   11fae:	63 e0       	ldi	r22, 0x03	; 3
   11fb0:	41 e0       	ldi	r20, 0x01	; 1
   11fb2:	26 e8       	ldi	r18, 0x86	; 134
   11fb4:	3e e0       	ldi	r19, 0x0E	; 14
   11fb6:	00 e0       	ldi	r16, 0x00	; 0
   11fb8:	10 e0       	ldi	r17, 0x00	; 0
   11fba:	7a e0       	ldi	r23, 0x0A	; 10
   11fbc:	e7 2e       	mov	r14, r23
   11fbe:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
		  switch(uiResult){
   11fc2:	83 30       	cpi	r24, 0x03	; 3
   11fc4:	61 f0       	breq	.+24     	; 0x11fde <FMenuMaster+0x310>
   11fc6:	84 30       	cpi	r24, 0x04	; 4
   11fc8:	20 f4       	brcc	.+8      	; 0x11fd2 <FMenuMaster+0x304>
   11fca:	81 30       	cpi	r24, 0x01	; 1
   11fcc:	09 f0       	breq	.+2      	; 0x11fd0 <FMenuMaster+0x302>
   11fce:	88 c0       	rjmp	.+272    	; 0x120e0 <FMenuMaster+0x412>
   11fd0:	81 c0       	rjmp	.+258    	; 0x120d4 <FMenuMaster+0x406>
   11fd2:	84 30       	cpi	r24, 0x04	; 4
   11fd4:	31 f0       	breq	.+12     	; 0x11fe2 <FMenuMaster+0x314>
   11fd6:	85 30       	cpi	r24, 0x05	; 5
   11fd8:	09 f0       	breq	.+2      	; 0x11fdc <FMenuMaster+0x30e>
   11fda:	82 c0       	rjmp	.+260    	; 0x120e0 <FMenuMaster+0x412>
   11fdc:	07 c0       	rjmp	.+14     	; 0x11fec <FMenuMaster+0x31e>
		  case USER_OK:
               stMenuMaster=mmIsValidRestoreCode;
   11fde:	89 e0       	ldi	r24, 0x09	; 9
   11fe0:	a6 cf       	rjmp	.-180    	; 0x11f2e <FMenuMaster+0x260>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11fe2:	84 e0       	ldi	r24, 0x04	; 4
   11fe4:	61 e0       	ldi	r22, 0x01	; 1
   11fe6:	42 e3       	ldi	r20, 0x32	; 50
   11fe8:	56 e1       	ldi	r21, 0x16	; 22
   11fea:	04 c0       	rjmp	.+8      	; 0x11ff4 <FMenuMaster+0x326>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11fec:	84 e0       	ldi	r24, 0x04	; 4
   11fee:	61 e0       	ldi	r22, 0x01	; 1
   11ff0:	4d e1       	ldi	r20, 0x1D	; 29
   11ff2:	56 e1       	ldi	r21, 0x16	; 22
   11ff4:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   11ff8:	73 c0       	rjmp	.+230    	; 0x120e0 <FMenuMaster+0x412>
		       break;
		  }
	      break;
     case mmIsValidRestoreCode:
	      if (ValidateRestoreCode(strKeyStamp,strRestoreCode)==RC_VALID){
   11ffa:	83 e0       	ldi	r24, 0x03	; 3
   11ffc:	9a e0       	ldi	r25, 0x0A	; 10
   11ffe:	66 e8       	ldi	r22, 0x86	; 134
   12000:	7e e0       	ldi	r23, 0x0E	; 14
   12002:	0e 94 65 68 	call	0xd0ca	; 0xd0ca <ValidateRestoreCode>
   12006:	81 30       	cpi	r24, 0x01	; 1
   12008:	11 f4       	brne	.+4      	; 0x1200e <FMenuMaster+0x340>
		      stMenuMaster=mmRestorePassword;
   1200a:	8c e0       	ldi	r24, 0x0C	; 12
   1200c:	90 cf       	rjmp	.-224    	; 0x11f2e <FMenuMaster+0x260>
		  }else stMenuMaster=mmDisplayInvalidRestoreCode;
   1200e:	8a e0       	ldi	r24, 0x0A	; 10
   12010:	8e cf       	rjmp	.-228    	; 0x11f2e <FMenuMaster+0x260>
	      break;
     case mmRestorePassword:
	      sprintf_P(strNewPassword,PSTR(SPV_DEFAULT_PASS));
   12012:	00 d0       	rcall	.+0      	; 0x12014 <FMenuMaster+0x346>
   12014:	00 d0       	rcall	.+0      	; 0x12016 <FMenuMaster+0x348>
   12016:	8e 01       	movw	r16, r28
   12018:	0b 5e       	subi	r16, 0xEB	; 235
   1201a:	1f 4f       	sbci	r17, 0xFF	; 255
   1201c:	ad b7       	in	r26, 0x3d	; 61
   1201e:	be b7       	in	r27, 0x3e	; 62
   12020:	12 96       	adiw	r26, 0x02	; 2
   12022:	1c 93       	st	X, r17
   12024:	0e 93       	st	-X, r16
   12026:	11 97       	sbiw	r26, 0x01	; 1
   12028:	87 e1       	ldi	r24, 0x17	; 23
   1202a:	96 e1       	ldi	r25, 0x16	; 22
   1202c:	14 96       	adiw	r26, 0x04	; 4
   1202e:	9c 93       	st	X, r25
   12030:	8e 93       	st	-X, r24
   12032:	13 97       	sbiw	r26, 0x03	; 3
   12034:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   12038:	0f 90       	pop	r0
   1203a:	0f 90       	pop	r0
   1203c:	0f 90       	pop	r0
   1203e:	0f 90       	pop	r0
   12040:	81 e0       	ldi	r24, 0x01	; 1
   12042:	90 e0       	ldi	r25, 0x00	; 0
   12044:	b8 01       	movw	r22, r16
   12046:	4a e0       	ldi	r20, 0x0A	; 10
   12048:	50 e0       	ldi	r21, 0x00	; 0
   1204a:	2d ed       	ldi	r18, 0xDD	; 221
   1204c:	32 e1       	ldi	r19, 0x12	; 18
   1204e:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSpvPassword,sizeof(DefSpvPassword));
		  sprintf_P(strNewPassword,PSTR(SYS_DEFAULT_PASS));
   12052:	00 d0       	rcall	.+0      	; 0x12054 <FMenuMaster+0x386>
   12054:	00 d0       	rcall	.+0      	; 0x12056 <FMenuMaster+0x388>
   12056:	ed b7       	in	r30, 0x3d	; 61
   12058:	fe b7       	in	r31, 0x3e	; 62
   1205a:	12 83       	std	Z+2, r17	; 0x02
   1205c:	01 83       	std	Z+1, r16	; 0x01
   1205e:	81 e1       	ldi	r24, 0x11	; 17
   12060:	96 e1       	ldi	r25, 0x16	; 22
   12062:	94 83       	std	Z+4, r25	; 0x04
   12064:	83 83       	std	Z+3, r24	; 0x03
   12066:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   1206a:	0f 90       	pop	r0
   1206c:	0f 90       	pop	r0
   1206e:	0f 90       	pop	r0
   12070:	0f 90       	pop	r0
   12072:	8b e0       	ldi	r24, 0x0B	; 11
   12074:	90 e0       	ldi	r25, 0x00	; 0
   12076:	b8 01       	movw	r22, r16
   12078:	4a e0       	ldi	r20, 0x0A	; 10
   1207a:	50 e0       	ldi	r21, 0x00	; 0
   1207c:	2d ed       	ldi	r18, 0xDD	; 221
   1207e:	32 e1       	ldi	r19, 0x12	; 18
   12080:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSysPassword,sizeof(DefSysPassword));	      		  
	      stMenuMaster=mmDisplaySuccess;
   12084:	8d e0       	ldi	r24, 0x0D	; 13
   12086:	53 cf       	rjmp	.-346    	; 0x11f2e <FMenuMaster+0x260>
	      break;
     case mmDisplayInvalidRestoreCode:
	      lcd_printf(3,1,PSTR("Invalid Restore  "));
   12088:	83 e0       	ldi	r24, 0x03	; 3
   1208a:	61 e0       	ldi	r22, 0x01	; 1
   1208c:	4f ef       	ldi	r20, 0xFF	; 255
   1208e:	55 e1       	ldi	r21, 0x15	; 21
   12090:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  TimDisplay=0;
   12094:	10 92 a7 01 	sts	0x01A7, r1
          stMenuMaster=mmDelayInvalidRestoreCode;
   12098:	8b e0       	ldi	r24, 0x0B	; 11
   1209a:	49 cf       	rjmp	.-366    	; 0x11f2e <FMenuMaster+0x260>
	      break;
     case mmDelayInvalidRestoreCode:
	      if (TimDisplay>5)stMenuMaster=mmDisplayKeyStamp;
   1209c:	80 91 a7 01 	lds	r24, 0x01A7
   120a0:	86 30       	cpi	r24, 0x06	; 6
   120a2:	f0 f0       	brcs	.+60     	; 0x120e0 <FMenuMaster+0x412>
   120a4:	87 e0       	ldi	r24, 0x07	; 7
   120a6:	43 cf       	rjmp	.-378    	; 0x11f2e <FMenuMaster+0x260>
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
   120a8:	83 e0       	ldi	r24, 0x03	; 3
   120aa:	61 e0       	ldi	r22, 0x01	; 1
   120ac:	4d ee       	ldi	r20, 0xED	; 237
   120ae:	55 e1       	ldi	r21, 0x15	; 21
   120b0:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   120b4:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   120b6:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   120b8:	81 e0       	ldi	r24, 0x01	; 1
   120ba:	90 e0       	ldi	r25, 0x00	; 0
   120bc:	90 93 d7 01 	sts	0x01D7, r25
   120c0:	80 93 d6 01 	sts	0x01D6, r24
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
		  system_beep(1);
		  TimDisplay=0;
   120c4:	10 92 a7 01 	sts	0x01A7, r1
          stMenuMaster=mmDelayExit;
   120c8:	8f e0       	ldi	r24, 0x0F	; 15
   120ca:	31 cf       	rjmp	.-414    	; 0x11f2e <FMenuMaster+0x260>
	      break;
     case mmDelayExit:
	      if (TimDisplay>=5)stMenuMaster=mmExitMaster;
   120cc:	80 91 a7 01 	lds	r24, 0x01A7
   120d0:	85 30       	cpi	r24, 0x05	; 5
   120d2:	30 f0       	brcs	.+12     	; 0x120e0 <FMenuMaster+0x412>
   120d4:	80 e1       	ldi	r24, 0x10	; 16
   120d6:	2b cf       	rjmp	.-426    	; 0x11f2e <FMenuMaster+0x260>
	      break;
     case mmExitMaster:
	      stMenuMaster=mmInitMaster;
   120d8:	10 92 23 03 	sts	0x0323, r1
   120dc:	81 e0       	ldi	r24, 0x01	; 1
   120de:	01 c0       	rjmp	.+2      	; 0x120e2 <FMenuMaster+0x414>
   120e0:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;

}
   120e2:	e2 96       	adiw	r28, 0x32	; 50
   120e4:	0f b6       	in	r0, 0x3f	; 63
   120e6:	f8 94       	cli
   120e8:	de bf       	out	0x3e, r29	; 62
   120ea:	0f be       	out	0x3f, r0	; 63
   120ec:	cd bf       	out	0x3d, r28	; 61
   120ee:	cf 91       	pop	r28
   120f0:	df 91       	pop	r29
   120f2:	1f 91       	pop	r17
   120f4:	0f 91       	pop	r16
   120f6:	ff 90       	pop	r15
   120f8:	ef 90       	pop	r14
   120fa:	08 95       	ret

000120fc <FMenuPassword>:
   return Result;	 
}



char FMenuPassword(){
   120fc:	af 92       	push	r10
   120fe:	bf 92       	push	r11
   12100:	cf 92       	push	r12
   12102:	df 92       	push	r13
   12104:	ef 92       	push	r14
   12106:	0f 93       	push	r16
   12108:	1f 93       	push	r17
   1210a:	df 93       	push	r29
   1210c:	cf 93       	push	r28
   1210e:	cd b7       	in	r28, 0x3d	; 61
   12110:	de b7       	in	r29, 0x3e	; 62
   12112:	6e 97       	sbiw	r28, 0x1e	; 30
   12114:	0f b6       	in	r0, 0x3f	; 63
   12116:	f8 94       	cli
   12118:	de bf       	out	0x3e, r29	; 62
   1211a:	0f be       	out	0x3f, r0	; 63
   1211c:	cd bf       	out	0x3d, r28	; 61
static char stMenuPasword=mpInitPassword,uiResult,strPassword[10],PassStatus=MP_NONE;;
char Result=MP_NONE,strMasterPass[10],strSystemPass[10],strAdminPass[10];

     Result=MP_NONE;
     switch(stMenuPasword){
   1211e:	e0 90 30 03 	lds	r14, 0x0330
   12122:	81 e0       	ldi	r24, 0x01	; 1
   12124:	e8 16       	cp	r14, r24
   12126:	09 f1       	breq	.+66     	; 0x1216a <FMenuPassword+0x6e>
   12128:	e8 16       	cp	r14, r24
   1212a:	48 f0       	brcs	.+18     	; 0x1213e <FMenuPassword+0x42>
   1212c:	e2 e0       	ldi	r30, 0x02	; 2
   1212e:	ee 16       	cp	r14, r30
   12130:	09 f4       	brne	.+2      	; 0x12134 <FMenuPassword+0x38>
   12132:	3f c0       	rjmp	.+126    	; 0x121b2 <FMenuPassword+0xb6>
   12134:	f3 e0       	ldi	r31, 0x03	; 3
   12136:	ef 16       	cp	r14, r31
   12138:	09 f0       	breq	.+2      	; 0x1213c <FMenuPassword+0x40>
   1213a:	92 c0       	rjmp	.+292    	; 0x12260 <FMenuPassword+0x164>
   1213c:	8c c0       	rjmp	.+280    	; 0x12256 <FMenuPassword+0x15a>
	 case mpInitPassword:
	      lcd_clear();
   1213e:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("PASSWORD:"));
   12142:	81 e0       	ldi	r24, 0x01	; 1
   12144:	61 e0       	ldi	r22, 0x01	; 1
   12146:	4a ec       	ldi	r20, 0xCA	; 202
   12148:	57 e1       	ldi	r21, 0x17	; 23
   1214a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   1214e:	82 e0       	ldi	r24, 0x02	; 2
   12150:	61 e0       	ldi	r22, 0x01	; 1
   12152:	48 ec       	ldi	r20, 0xC8	; 200
   12154:	57 e1       	ldi	r21, 0x17	; 23
   12156:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1215a:	84 e0       	ldi	r24, 0x04	; 4
   1215c:	61 e0       	ldi	r22, 0x01	; 1
   1215e:	43 eb       	ldi	r20, 0xB3	; 179
   12160:	57 e1       	ldi	r21, 0x17	; 23
   12162:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  FillChar(strPassword,0,sizeof(strPassword));
		  stMenuPasword=mpInputPasword;
   12166:	81 e0       	ldi	r24, 0x01	; 1
   12168:	73 c0       	rjmp	.+230    	; 0x12250 <FMenuPassword+0x154>
	      break;
     case mpInputPasword:
	 	      uiResult=UserInput(UI_NUM_PASSWORD,2,1,strPassword,0,8);
   1216a:	84 e0       	ldi	r24, 0x04	; 4
   1216c:	62 e0       	ldi	r22, 0x02	; 2
   1216e:	41 e0       	ldi	r20, 0x01	; 1
   12170:	25 e2       	ldi	r18, 0x25	; 37
   12172:	33 e0       	ldi	r19, 0x03	; 3
   12174:	00 e0       	ldi	r16, 0x00	; 0
   12176:	10 e0       	ldi	r17, 0x00	; 0
   12178:	98 e0       	ldi	r25, 0x08	; 8
   1217a:	e9 2e       	mov	r14, r25
   1217c:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
   12180:	80 93 2f 03 	sts	0x032F, r24
		  if (uiResult==USER_OK){
   12184:	83 30       	cpi	r24, 0x03	; 3
   12186:	11 f4       	brne	.+4      	; 0x1218c <FMenuPassword+0x90>
		      stMenuPasword=mpProcessPassword;
   12188:	82 e0       	ldi	r24, 0x02	; 2
   1218a:	62 c0       	rjmp	.+196    	; 0x12250 <FMenuPassword+0x154>
			  }
		  else
		  if (uiResult==USER_CANCEL){
   1218c:	81 30       	cpi	r24, 0x01	; 1
   1218e:	09 f4       	brne	.+2      	; 0x12192 <FMenuPassword+0x96>
   12190:	50 c0       	rjmp	.+160    	; 0x12232 <FMenuPassword+0x136>
		      PassStatus=MP_CANCEL;
		      stMenuPasword=mpExit;
			  }
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12192:	84 30       	cpi	r24, 0x04	; 4
   12194:	21 f4       	brne	.+8      	; 0x1219e <FMenuPassword+0xa2>
   12196:	61 e0       	ldi	r22, 0x01	; 1
   12198:	4e e9       	ldi	r20, 0x9E	; 158
   1219a:	57 e1       	ldi	r21, 0x17	; 23
   1219c:	07 c0       	rjmp	.+14     	; 0x121ac <FMenuPassword+0xb0>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1219e:	85 30       	cpi	r24, 0x05	; 5
   121a0:	09 f0       	breq	.+2      	; 0x121a4 <FMenuPassword+0xa8>
   121a2:	5e c0       	rjmp	.+188    	; 0x12260 <FMenuPassword+0x164>
   121a4:	84 e0       	ldi	r24, 0x04	; 4
   121a6:	61 e0       	ldi	r22, 0x01	; 1
   121a8:	49 e8       	ldi	r20, 0x89	; 137
   121aa:	57 e1       	ldi	r21, 0x17	; 23
   121ac:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   121b0:	57 c0       	rjmp	.+174    	; 0x12260 <FMenuPassword+0x164>
          break;	 
	 case mpProcessPassword:
		      
	      sprintf_P(strMasterPass,PSTR(MASTER_PASSWORD)); 
   121b2:	00 d0       	rcall	.+0      	; 0x121b4 <FMenuPassword+0xb8>
   121b4:	00 d0       	rcall	.+0      	; 0x121b6 <FMenuPassword+0xba>
   121b6:	8e 01       	movw	r16, r28
   121b8:	0f 5f       	subi	r16, 0xFF	; 255
   121ba:	1f 4f       	sbci	r17, 0xFF	; 255
   121bc:	ed b7       	in	r30, 0x3d	; 61
   121be:	fe b7       	in	r31, 0x3e	; 62
   121c0:	12 83       	std	Z+2, r17	; 0x02
   121c2:	01 83       	std	Z+1, r16	; 0x01
   121c4:	81 e8       	ldi	r24, 0x81	; 129
   121c6:	97 e1       	ldi	r25, 0x17	; 23
   121c8:	94 83       	std	Z+4, r25	; 0x04
   121ca:	83 83       	std	Z+3, r24	; 0x03
   121cc:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   121d0:	0f 90       	pop	r0
   121d2:	0f 90       	pop	r0
   121d4:	0f 90       	pop	r0
   121d6:	0f 90       	pop	r0
   121d8:	b5 e1       	ldi	r27, 0x15	; 21
   121da:	cb 2e       	mov	r12, r27
   121dc:	d1 2c       	mov	r13, r1
   121de:	cc 0e       	add	r12, r28
   121e0:	dd 1e       	adc	r13, r29
   121e2:	c6 01       	movw	r24, r12
   121e4:	61 e0       	ldi	r22, 0x01	; 1
   121e6:	70 e0       	ldi	r23, 0x00	; 0
   121e8:	4a e0       	ldi	r20, 0x0A	; 10
   121ea:	50 e0       	ldi	r21, 0x00	; 0
   121ec:	25 ed       	ldi	r18, 0xD5	; 213
   121ee:	32 e1       	ldi	r19, 0x12	; 18
   121f0:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
	      eeprom_read_block((void*) &strAdminPass, (const void*) &DefSpvPassword, 10);
	      eeprom_read_block((void*) &strSystemPass, (const void*) &DefSysPassword, 10);
		  
		  if (strcmp(strMasterPass,strPassword)==0)
   121f4:	ab e0       	ldi	r26, 0x0B	; 11
   121f6:	aa 2e       	mov	r10, r26
   121f8:	b1 2c       	mov	r11, r1
   121fa:	ac 0e       	add	r10, r28
   121fc:	bd 1e       	adc	r11, r29
   121fe:	c5 01       	movw	r24, r10
   12200:	6b e0       	ldi	r22, 0x0B	; 11
   12202:	70 e0       	ldi	r23, 0x00	; 0
   12204:	4a e0       	ldi	r20, 0x0A	; 10
   12206:	50 e0       	ldi	r21, 0x00	; 0
   12208:	25 ed       	ldi	r18, 0xD5	; 213
   1220a:	32 e1       	ldi	r19, 0x12	; 18
   1220c:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
   12210:	c8 01       	movw	r24, r16
   12212:	65 e2       	ldi	r22, 0x25	; 37
   12214:	73 e0       	ldi	r23, 0x03	; 3
   12216:	0e 94 e4 b3 	call	0x167c8	; 0x167c8 <strcmp>
   1221a:	00 97       	sbiw	r24, 0x00	; 0
   1221c:	11 f4       	brne	.+4      	; 0x12222 <FMenuPassword+0x126>
		       PassStatus=MP_VALID_MASTER;
   1221e:	83 e0       	ldi	r24, 0x03	; 3
   12220:	08 c0       	rjmp	.+16     	; 0x12232 <FMenuPassword+0x136>
		  else
	      if (strcmp(strAdminPass,strPassword)==0){
   12222:	c6 01       	movw	r24, r12
   12224:	65 e2       	ldi	r22, 0x25	; 37
   12226:	73 e0       	ldi	r23, 0x03	; 3
   12228:	0e 94 e4 b3 	call	0x167c8	; 0x167c8 <strcmp>
   1222c:	00 97       	sbiw	r24, 0x00	; 0
   1222e:	21 f4       	brne	.+8      	; 0x12238 <FMenuPassword+0x13c>
		       PassStatus=MP_VALID_ADMIN;
   12230:	84 e0       	ldi	r24, 0x04	; 4
   12232:	80 93 24 03 	sts	0x0324, r24
   12236:	0b c0       	rjmp	.+22     	; 0x1224e <FMenuPassword+0x152>
               //lcd_printf(3,1,PSTR("Admin"));
               //_delay_ms(5000);
			   }
		  else if (strcmp(strSystemPass,strPassword)==0){
   12238:	c5 01       	movw	r24, r10
   1223a:	65 e2       	ldi	r22, 0x25	; 37
   1223c:	73 e0       	ldi	r23, 0x03	; 3
   1223e:	0e 94 e4 b3 	call	0x167c8	; 0x167c8 <strcmp>
   12242:	00 97       	sbiw	r24, 0x00	; 0
   12244:	11 f4       	brne	.+4      	; 0x1224a <FMenuPassword+0x14e>
		       PassStatus=MP_VALID_SYSTEM;
   12246:	85 e0       	ldi	r24, 0x05	; 5
   12248:	f4 cf       	rjmp	.-24     	; 0x12232 <FMenuPassword+0x136>
			   //lcd_printf(3,1,PSTR("System"));
               //_delay_ms(5000);
			   }
		  else PassStatus=MP_INVALID;
   1224a:	e0 92 24 03 	sts	0x0324, r14
		  stMenuPasword=mpExit;
   1224e:	83 e0       	ldi	r24, 0x03	; 3
   12250:	80 93 30 03 	sts	0x0330, r24
   12254:	05 c0       	rjmp	.+10     	; 0x12260 <FMenuPassword+0x164>
	      break;
	 case mpExit:
	      //lcd_print(3,1,strPassword);
		  //_delay_ms(5000);
	      stMenuPasword=mpInitPassword;
   12256:	10 92 30 03 	sts	0x0330, r1
	      Result=PassStatus;
   1225a:	80 91 24 03 	lds	r24, 0x0324
   1225e:	01 c0       	rjmp	.+2      	; 0x12262 <FMenuPassword+0x166>
   12260:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
   12262:	6e 96       	adiw	r28, 0x1e	; 30
   12264:	0f b6       	in	r0, 0x3f	; 63
   12266:	f8 94       	cli
   12268:	de bf       	out	0x3e, r29	; 62
   1226a:	0f be       	out	0x3f, r0	; 63
   1226c:	cd bf       	out	0x3d, r28	; 61
   1226e:	cf 91       	pop	r28
   12270:	df 91       	pop	r29
   12272:	1f 91       	pop	r17
   12274:	0f 91       	pop	r16
   12276:	ef 90       	pop	r14
   12278:	df 90       	pop	r13
   1227a:	cf 90       	pop	r12
   1227c:	bf 90       	pop	r11
   1227e:	af 90       	pop	r10
   12280:	08 95       	ret

00012282 <FMenuReprint>:
	       break;
	 }
return Result;
}

char FMenuReprint(){
   12282:	0f 93       	push	r16
   12284:	1f 93       	push	r17
   12286:	df 93       	push	r29
   12288:	cf 93       	push	r28
   1228a:	cd b7       	in	r28, 0x3d	; 61
   1228c:	de b7       	in	r29, 0x3e	; 62
   1228e:	64 97       	sbiw	r28, 0x14	; 20
   12290:	0f b6       	in	r0, 0x3f	; 63
   12292:	f8 94       	cli
   12294:	de bf       	out	0x3e, r29	; 62
   12296:	0f be       	out	0x3f, r0	; 63
   12298:	cd bf       	out	0x3d, r28	; 61
static char KeyPressed=0,FIP_Used=0;
       char lcdteks[20],FIPResult,KeyChar;//,FIP_USED;
	   char PassResult,Result=MENU_NONE,ReprintResult;

     Result=MENU_NONE;
	 switch(stReprint){
   1229a:	80 91 52 03 	lds	r24, 0x0352
   1229e:	87 30       	cpi	r24, 0x07	; 7
   122a0:	09 f4       	brne	.+2      	; 0x122a4 <FMenuReprint+0x22>
   122a2:	8e c0       	rjmp	.+284    	; 0x123c0 <FMenuReprint+0x13e>
   122a4:	88 30       	cpi	r24, 0x08	; 8
   122a6:	90 f4       	brcc	.+36     	; 0x122cc <FMenuReprint+0x4a>
   122a8:	83 30       	cpi	r24, 0x03	; 3
   122aa:	09 f4       	brne	.+2      	; 0x122ae <FMenuReprint+0x2c>
   122ac:	43 c0       	rjmp	.+134    	; 0x12334 <FMenuReprint+0xb2>
   122ae:	84 30       	cpi	r24, 0x04	; 4
   122b0:	30 f4       	brcc	.+12     	; 0x122be <FMenuReprint+0x3c>
   122b2:	81 30       	cpi	r24, 0x01	; 1
   122b4:	09 f4       	brne	.+2      	; 0x122b8 <FMenuReprint+0x36>
   122b6:	55 c0       	rjmp	.+170    	; 0x12362 <FMenuReprint+0xe0>
   122b8:	82 30       	cpi	r24, 0x02	; 2
   122ba:	48 f5       	brcc	.+82     	; 0x1230e <FMenuReprint+0x8c>
   122bc:	1d c0       	rjmp	.+58     	; 0x122f8 <FMenuReprint+0x76>
   122be:	85 30       	cpi	r24, 0x05	; 5
   122c0:	09 f4       	brne	.+2      	; 0x122c4 <FMenuReprint+0x42>
   122c2:	6c c0       	rjmp	.+216    	; 0x1239c <FMenuReprint+0x11a>
   122c4:	86 30       	cpi	r24, 0x06	; 6
   122c6:	08 f0       	brcs	.+2      	; 0x122ca <FMenuReprint+0x48>
   122c8:	50 c0       	rjmp	.+160    	; 0x1236a <FMenuReprint+0xe8>
   122ca:	45 c0       	rjmp	.+138    	; 0x12356 <FMenuReprint+0xd4>
   122cc:	8b 30       	cpi	r24, 0x0B	; 11
   122ce:	09 f4       	brne	.+2      	; 0x122d2 <FMenuReprint+0x50>
   122d0:	da c0       	rjmp	.+436    	; 0x12486 <FMenuReprint+0x204>
   122d2:	8c 30       	cpi	r24, 0x0C	; 12
   122d4:	38 f4       	brcc	.+14     	; 0x122e4 <FMenuReprint+0x62>
   122d6:	89 30       	cpi	r24, 0x09	; 9
   122d8:	09 f4       	brne	.+2      	; 0x122dc <FMenuReprint+0x5a>
   122da:	b8 c0       	rjmp	.+368    	; 0x1244c <FMenuReprint+0x1ca>
   122dc:	8a 30       	cpi	r24, 0x0A	; 10
   122de:	08 f0       	brcs	.+2      	; 0x122e2 <FMenuReprint+0x60>
   122e0:	ca c0       	rjmp	.+404    	; 0x12476 <FMenuReprint+0x1f4>
   122e2:	7c c0       	rjmp	.+248    	; 0x123dc <FMenuReprint+0x15a>
   122e4:	8d 30       	cpi	r24, 0x0D	; 13
   122e6:	09 f4       	brne	.+2      	; 0x122ea <FMenuReprint+0x68>
   122e8:	ed c0       	rjmp	.+474    	; 0x124c4 <FMenuReprint+0x242>
   122ea:	8d 30       	cpi	r24, 0x0D	; 13
   122ec:	08 f4       	brcc	.+2      	; 0x122f0 <FMenuReprint+0x6e>
   122ee:	d7 c0       	rjmp	.+430    	; 0x1249e <FMenuReprint+0x21c>
   122f0:	8e 30       	cpi	r24, 0x0E	; 14
   122f2:	09 f0       	breq	.+2      	; 0x122f6 <FMenuReprint+0x74>
   122f4:	f0 c0       	rjmp	.+480    	; 0x124d6 <FMenuReprint+0x254>
   122f6:	eb c0       	rjmp	.+470    	; 0x124ce <FMenuReprint+0x24c>
	 case rtInit:
	      lcd_clear();
   122f8:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
          if (IFType==IT_SLAVE)stReprint=rtFIP;
   122fc:	80 91 10 01 	lds	r24, 0x0110
   12300:	81 30       	cpi	r24, 0x01	; 1
   12302:	09 f4       	brne	.+2      	; 0x12306 <FMenuReprint+0x84>
   12304:	b3 c0       	rjmp	.+358    	; 0x1246c <FMenuReprint+0x1ea>
		  else
		  if (IFType==IT_STANDALONE)stReprint=rtStandaloneFIP;//rtValidPassword;//rtStandaloneFIP;
   12306:	82 30       	cpi	r24, 0x02	; 2
   12308:	09 f0       	breq	.+2      	; 0x1230c <FMenuReprint+0x8a>
   1230a:	e5 c0       	rjmp	.+458    	; 0x124d6 <FMenuReprint+0x254>
   1230c:	04 c0       	rjmp	.+8      	; 0x12316 <FMenuReprint+0x94>
	      break;
     case rtValidPassword:
	      PassResult=FMenuPassword();
   1230e:	0e 94 7e 90 	call	0x120fc	; 0x120fc <FMenuPassword>
	      if (PassResult==MP_VALID_ADMIN)stReprint=rtStandaloneFIP;
   12312:	84 30       	cpi	r24, 0x04	; 4
   12314:	11 f4       	brne	.+4      	; 0x1231a <FMenuReprint+0x98>
   12316:	81 e0       	ldi	r24, 0x01	; 1
   12318:	0a c0       	rjmp	.+20     	; 0x1232e <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_VALID_SYSTEM)stReprint=rtInvalidPassword;
   1231a:	85 30       	cpi	r24, 0x05	; 5
   1231c:	11 f0       	breq	.+4      	; 0x12322 <FMenuReprint+0xa0>
          else
	      if (PassResult==MP_INVALID)stReprint=rtInvalidPassword;
   1231e:	82 30       	cpi	r24, 0x02	; 2
   12320:	11 f4       	brne	.+4      	; 0x12326 <FMenuReprint+0xa4>
   12322:	83 e0       	ldi	r24, 0x03	; 3
   12324:	04 c0       	rjmp	.+8      	; 0x1232e <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
   12326:	81 30       	cpi	r24, 0x01	; 1
   12328:	09 f0       	breq	.+2      	; 0x1232c <FMenuReprint+0xaa>
   1232a:	d5 c0       	rjmp	.+426    	; 0x124d6 <FMenuReprint+0x254>
   1232c:	8e e0       	ldi	r24, 0x0E	; 14
   1232e:	80 93 52 03 	sts	0x0352, r24
   12332:	d1 c0       	rjmp	.+418    	; 0x124d6 <FMenuReprint+0x254>
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
   12334:	10 92 a7 01 	sts	0x01A7, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   12338:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1233a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1233c:	81 e0       	ldi	r24, 0x01	; 1
   1233e:	90 e0       	ldi	r25, 0x00	; 0
   12340:	90 93 d7 01 	sts	0x01D7, r25
   12344:	80 93 d6 01 	sts	0x01D6, r24
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   12348:	83 e0       	ldi	r24, 0x03	; 3
   1234a:	61 e0       	ldi	r22, 0x01	; 1
   1234c:	45 e3       	ldi	r20, 0x35	; 53
   1234e:	5b e1       	ldi	r21, 0x1B	; 27
   12350:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   12354:	33 c0       	rjmp	.+102    	; 0x123bc <FMenuReprint+0x13a>
          stReprint=rtTimDisplayInvalid;
	      break;
     case rtTimDisplayInvalid:
	      if (TimDisplay>2)stReprint=rtExitReprint;
   12356:	80 91 a7 01 	lds	r24, 0x01A7
   1235a:	83 30       	cpi	r24, 0x03	; 3
   1235c:	08 f4       	brcc	.+2      	; 0x12360 <FMenuReprint+0xde>
   1235e:	bb c0       	rjmp	.+374    	; 0x124d6 <FMenuReprint+0x254>
   12360:	e5 cf       	rjmp	.-54     	; 0x1232c <FMenuReprint+0xaa>
	      break;
     case rtStandaloneFIP:
	      _scr_pump();
   12362:	0e 94 58 42 	call	0x84b0	; 0x84b0 <_scr_pump>
		  stReprint=rtStandaloneInputFIP;
   12366:	86 e0       	ldi	r24, 0x06	; 6
   12368:	e2 cf       	rjmp	.-60     	; 0x1232e <FMenuReprint+0xac>
	      break;
     case rtStandaloneInputFIP:
		  KeyChar=_key_btn(_key_scan(1));
   1236a:	81 e0       	ldi	r24, 0x01	; 1
   1236c:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   12370:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   12374:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='8')){
   12376:	81 53       	subi	r24, 0x31	; 49
   12378:	88 30       	cpi	r24, 0x08	; 8
   1237a:	60 f4       	brcc	.+24     	; 0x12394 <FMenuReprint+0x112>
		       ReprintResult=PrintStandalone(KeyChar-'0',True);
   1237c:	8f 5f       	subi	r24, 0xFF	; 255
   1237e:	61 e0       	ldi	r22, 0x01	; 1
   12380:	0e 94 9c 1f 	call	0x3f38	; 0x3f38 <PrintStandalone>
			   if (ReprintResult==PS_NO_DATA)stReprint=rtDisplayNoTransaction;
   12384:	82 31       	cpi	r24, 0x12	; 18
   12386:	11 f4       	brne	.+4      	; 0x1238c <FMenuReprint+0x10a>
   12388:	85 e0       	ldi	r24, 0x05	; 5
   1238a:	d1 cf       	rjmp	.-94     	; 0x1232e <FMenuReprint+0xac>
			   else if (ReprintResult==PS_PRINTED)stReprint=rtExitReprint;
   1238c:	81 31       	cpi	r24, 0x11	; 17
   1238e:	09 f0       	breq	.+2      	; 0x12392 <FMenuReprint+0x110>
   12390:	a2 c0       	rjmp	.+324    	; 0x124d6 <FMenuReprint+0x254>
   12392:	cc cf       	rjmp	.-104    	; 0x1232c <FMenuReprint+0xaa>

		  }else if (KeyChar=='*')stReprint=rtExitReprint;
   12394:	9a 32       	cpi	r25, 0x2A	; 42
   12396:	09 f0       	breq	.+2      	; 0x1239a <FMenuReprint+0x118>
   12398:	9e c0       	rjmp	.+316    	; 0x124d6 <FMenuReprint+0x254>
   1239a:	c8 cf       	rjmp	.-112    	; 0x1232c <FMenuReprint+0xaa>

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   1239c:	83 e0       	ldi	r24, 0x03	; 3
   1239e:	61 e0       	ldi	r22, 0x01	; 1
   123a0:	40 e2       	ldi	r20, 0x20	; 32
   123a2:	5b e1       	ldi	r21, 0x1B	; 27
   123a4:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   123a8:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   123aa:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   123ac:	81 e0       	ldi	r24, 0x01	; 1
   123ae:	90 e0       	ldi	r25, 0x00	; 0
   123b0:	90 93 d7 01 	sts	0x01D7, r25
   123b4:	80 93 d6 01 	sts	0x01D6, r24

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
		  system_beep(1);
          TimDisplay=0;
   123b8:	10 92 a7 01 	sts	0x01A7, r1
		  stReprint=rtTimDisplayInvalid;
   123bc:	84 e0       	ldi	r24, 0x04	; 4
   123be:	b7 cf       	rjmp	.-146    	; 0x1232e <FMenuReprint+0xac>
	      break;
	 case rtFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   123c0:	80 e5       	ldi	r24, 0x50	; 80
   123c2:	93 e0       	ldi	r25, 0x03	; 3
   123c4:	6c ee       	ldi	r22, 0xEC	; 236
   123c6:	79 e0       	ldi	r23, 0x09	; 9
   123c8:	0e 94 77 63 	call	0xc6ee	; 0xc6ee <menu_FIP>
		  if (FIPResult==FIP_DONE){
   123cc:	88 23       	and	r24, r24
   123ce:	11 f4       	brne	.+4      	; 0x123d4 <FMenuReprint+0x152>
		      stReprint=rtRFID;
   123d0:	88 e0       	ldi	r24, 0x08	; 8
   123d2:	ad cf       	rjmp	.-166    	; 0x1232e <FMenuReprint+0xac>
			  }
		  else
		  if (FIPResult==FIP_CANCEL)stReprint=rtExitReprint;
   123d4:	82 30       	cpi	r24, 0x02	; 2
   123d6:	09 f0       	breq	.+2      	; 0x123da <FMenuReprint+0x158>
   123d8:	7e c0       	rjmp	.+252    	; 0x124d6 <FMenuReprint+0x254>
   123da:	a8 cf       	rjmp	.-176    	; 0x1232c <FMenuReprint+0xaa>
	      break;
	 case rtRFID:
	      lcd_clear();
   123dc:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("RePrint FIP:%s "),strFIP_ID);lcd_print(1,1,lcdteks);
   123e0:	00 d0       	rcall	.+0      	; 0x123e2 <FMenuReprint+0x160>
   123e2:	00 d0       	rcall	.+0      	; 0x123e4 <FMenuReprint+0x162>
   123e4:	00 d0       	rcall	.+0      	; 0x123e6 <FMenuReprint+0x164>
   123e6:	ed b7       	in	r30, 0x3d	; 61
   123e8:	fe b7       	in	r31, 0x3e	; 62
   123ea:	31 96       	adiw	r30, 0x01	; 1
   123ec:	8e 01       	movw	r16, r28
   123ee:	0f 5f       	subi	r16, 0xFF	; 255
   123f0:	1f 4f       	sbci	r17, 0xFF	; 255
   123f2:	ad b7       	in	r26, 0x3d	; 61
   123f4:	be b7       	in	r27, 0x3e	; 62
   123f6:	12 96       	adiw	r26, 0x02	; 2
   123f8:	1c 93       	st	X, r17
   123fa:	0e 93       	st	-X, r16
   123fc:	11 97       	sbiw	r26, 0x01	; 1
   123fe:	80 e1       	ldi	r24, 0x10	; 16
   12400:	9b e1       	ldi	r25, 0x1B	; 27
   12402:	93 83       	std	Z+3, r25	; 0x03
   12404:	82 83       	std	Z+2, r24	; 0x02
   12406:	8c ee       	ldi	r24, 0xEC	; 236
   12408:	99 e0       	ldi	r25, 0x09	; 9
   1240a:	95 83       	std	Z+5, r25	; 0x05
   1240c:	84 83       	std	Z+4, r24	; 0x04
   1240e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   12412:	8d b7       	in	r24, 0x3d	; 61
   12414:	9e b7       	in	r25, 0x3e	; 62
   12416:	06 96       	adiw	r24, 0x06	; 6
   12418:	0f b6       	in	r0, 0x3f	; 63
   1241a:	f8 94       	cli
   1241c:	9e bf       	out	0x3e, r25	; 62
   1241e:	0f be       	out	0x3f, r0	; 63
   12420:	8d bf       	out	0x3d, r24	; 61
   12422:	81 e0       	ldi	r24, 0x01	; 1
   12424:	61 e0       	ldi	r22, 0x01	; 1
   12426:	a8 01       	movw	r20, r16
   12428:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_printf(2,1,PSTR(  "Tap Supervisor Card"));
   1242c:	82 e0       	ldi	r24, 0x02	; 2
   1242e:	61 e0       	ldi	r22, 0x01	; 1
   12430:	4c ef       	ldi	r20, 0xFC	; 252
   12432:	5a e1       	ldi	r21, 0x1A	; 26
   12434:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          lcd_printf(4,1,PSTR(  "[*]Back    [#]Exit"));
   12438:	84 e0       	ldi	r24, 0x04	; 4
   1243a:	61 e0       	ldi	r22, 0x01	; 1
   1243c:	49 ee       	ldi	r20, 0xE9	; 233
   1243e:	5a e1       	ldi	r21, 0x1A	; 26
   12440:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  IsRFIDDetected=False;
   12444:	10 92 af 01 	sts	0x01AF, r1
		  stReprint=rtInputRFID;
   12448:	89 e0       	ldi	r24, 0x09	; 9
   1244a:	71 cf       	rjmp	.-286    	; 0x1232e <FMenuReprint+0xac>
	      break;
	 case rtInputRFID:
	      if (IsRFIDDetected==True){
   1244c:	80 91 af 01 	lds	r24, 0x01AF
   12450:	81 30       	cpi	r24, 0x01	; 1
   12452:	29 f4       	brne	.+10     	; 0x1245e <FMenuReprint+0x1dc>
		      IsRFIDDetected=False;
   12454:	10 92 af 01 	sts	0x01AF, r1
		      stReprint=rtSendMessage28;
   12458:	8a e0       	ldi	r24, 0x0A	; 10
   1245a:	80 93 52 03 	sts	0x0352, r24
		  }
	 	  KeyPressed=_key_scan(1);
   1245e:	81 e0       	ldi	r24, 0x01	; 1
   12460:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   12464:	80 93 51 03 	sts	0x0351, r24
		  if (KeyPressed==_KEY_CANCEL){
   12468:	87 3e       	cpi	r24, 0xE7	; 231
   1246a:	11 f4       	brne	.+4      	; 0x12470 <FMenuReprint+0x1ee>
		      stReprint=rtFIP;
   1246c:	87 e0       	ldi	r24, 0x07	; 7
   1246e:	5f cf       	rjmp	.-322    	; 0x1232e <FMenuReprint+0xac>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stReprint=rtExitReprint;
   12470:	87 3b       	cpi	r24, 0xB7	; 183
   12472:	89 f5       	brne	.+98     	; 0x124d6 <FMenuReprint+0x254>
   12474:	5b cf       	rjmp	.-330    	; 0x1232c <FMenuReprint+0xaa>
	      break;
     case rtSendMessage28:
		  sendMessage28();
   12476:	0e 94 c6 50 	call	0xa18c	; 0xa18c <sendMessage28>
		  TimSend=0;
   1247a:	10 92 a9 01 	sts	0x01A9, r1
   1247e:	10 92 a8 01 	sts	0x01A8, r1
		  stReprint=rtWaitReply;
   12482:	8b e0       	ldi	r24, 0x0B	; 11
   12484:	54 cf       	rjmp	.-344    	; 0x1232e <FMenuReprint+0xac>
		  break;
     case rtWaitReply:
	      if (TimSend>TIM_SEND*3)stReprint=rtNoConnection;
   12486:	80 91 a8 01 	lds	r24, 0x01A8
   1248a:	90 91 a9 01 	lds	r25, 0x01A9
   1248e:	4f 97       	sbiw	r24, 0x1f	; 31
   12490:	18 f0       	brcs	.+6      	; 0x12498 <FMenuReprint+0x216>
   12492:	8c e0       	ldi	r24, 0x0C	; 12
   12494:	80 93 52 03 	sts	0x0352, r24
	      if (IsMessage99==True){
   12498:	80 91 b6 01 	lds	r24, 0x01B6
   1249c:	44 cf       	rjmp	.-376    	; 0x12326 <FMenuReprint+0xa4>
		      stReprint=rtExitReprint;
		  }
	      break;
     case rtNoConnection:
	      lcd_clear();
   1249e:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
   124a2:	82 e0       	ldi	r24, 0x02	; 2
   124a4:	61 e0       	ldi	r22, 0x01	; 1
   124a6:	4b ed       	ldi	r20, 0xDB	; 219
   124a8:	5a e1       	ldi	r21, 0x1A	; 26
   124aa:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
   124ae:	83 e0       	ldi	r24, 0x03	; 3
   124b0:	61 e0       	ldi	r22, 0x01	; 1
   124b2:	4d ec       	ldi	r20, 0xCD	; 205
   124b4:	5a e1       	ldi	r21, 0x1A	; 26
   124b6:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  TimDisplay=5;
   124ba:	85 e0       	ldi	r24, 0x05	; 5
   124bc:	80 93 a7 01 	sts	0x01A7, r24
		  stReprint=rtDelayExitReprint;
   124c0:	8d e0       	ldi	r24, 0x0D	; 13
   124c2:	35 cf       	rjmp	.-406    	; 0x1232e <FMenuReprint+0xac>
	      break;
     case rtDelayExitReprint:
	      if(TimDisplay>=10)stReprint=rtExitReprint;
   124c4:	80 91 a7 01 	lds	r24, 0x01A7
   124c8:	8a 30       	cpi	r24, 0x0A	; 10
   124ca:	28 f0       	brcs	.+10     	; 0x124d6 <FMenuReprint+0x254>
   124cc:	2f cf       	rjmp	.-418    	; 0x1232c <FMenuReprint+0xaa>
	      break;
	 case rtExitReprint:
	      stReprint=rtInit;
   124ce:	10 92 52 03 	sts	0x0352, r1
   124d2:	81 e0       	ldi	r24, 0x01	; 1
   124d4:	01 c0       	rjmp	.+2      	; 0x124d8 <FMenuReprint+0x256>
   124d6:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   124d8:	64 96       	adiw	r28, 0x14	; 20
   124da:	0f b6       	in	r0, 0x3f	; 63
   124dc:	f8 94       	cli
   124de:	de bf       	out	0x3e, r29	; 62
   124e0:	0f be       	out	0x3f, r0	; 63
   124e2:	cd bf       	out	0x3d, r28	; 61
   124e4:	cf 91       	pop	r28
   124e6:	df 91       	pop	r29
   124e8:	1f 91       	pop	r17
   124ea:	0f 91       	pop	r16
   124ec:	08 95       	ret

000124ee <FMenuAdmin>:

char FMenuAdmin(){
static char stMenuAdmin=maInitAdmin;
	 char SubMenu,KeyPressed,KeyChar,Result=MENU_NONE;
     
	 switch(stMenuAdmin){
   124ee:	80 91 22 03 	lds	r24, 0x0322
   124f2:	83 30       	cpi	r24, 0x03	; 3
   124f4:	09 f4       	brne	.+2      	; 0x124f8 <FMenuAdmin+0xa>
   124f6:	66 c0       	rjmp	.+204    	; 0x125c4 <FMenuAdmin+0xd6>
   124f8:	84 30       	cpi	r24, 0x04	; 4
   124fa:	30 f4       	brcc	.+12     	; 0x12508 <FMenuAdmin+0x1a>
   124fc:	81 30       	cpi	r24, 0x01	; 1
   124fe:	69 f1       	breq	.+90     	; 0x1255a <FMenuAdmin+0x6c>
   12500:	82 30       	cpi	r24, 0x02	; 2
   12502:	08 f0       	brcs	.+2      	; 0x12506 <FMenuAdmin+0x18>
   12504:	4d c0       	rjmp	.+154    	; 0x125a0 <FMenuAdmin+0xb2>
   12506:	0d c0       	rjmp	.+26     	; 0x12522 <FMenuAdmin+0x34>
   12508:	85 30       	cpi	r24, 0x05	; 5
   1250a:	09 f4       	brne	.+2      	; 0x1250e <FMenuAdmin+0x20>
   1250c:	4e c0       	rjmp	.+156    	; 0x125aa <FMenuAdmin+0xbc>
   1250e:	85 30       	cpi	r24, 0x05	; 5
   12510:	08 f4       	brcc	.+2      	; 0x12514 <FMenuAdmin+0x26>
   12512:	49 c0       	rjmp	.+146    	; 0x125a6 <FMenuAdmin+0xb8>
   12514:	86 30       	cpi	r24, 0x06	; 6
   12516:	09 f4       	brne	.+2      	; 0x1251a <FMenuAdmin+0x2c>
   12518:	51 c0       	rjmp	.+162    	; 0x125bc <FMenuAdmin+0xce>
   1251a:	87 30       	cpi	r24, 0x07	; 7
   1251c:	09 f0       	breq	.+2      	; 0x12520 <FMenuAdmin+0x32>
   1251e:	5a c0       	rjmp	.+180    	; 0x125d4 <FMenuAdmin+0xe6>
   12520:	55 c0       	rjmp	.+170    	; 0x125cc <FMenuAdmin+0xde>
	 case maInitAdmin:
		  lcd_clear();
   12522:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)RePrint           "));
   12526:	81 e0       	ldi	r24, 0x01	; 1
   12528:	61 e0       	ldi	r22, 0x01	; 1
   1252a:	48 ed       	ldi	r20, 0xD8	; 216
   1252c:	55 e1       	ldi	r21, 0x15	; 21
   1252e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2,1,PSTR("2)CloseShift        "));
   12532:	82 e0       	ldi	r24, 0x02	; 2
   12534:	61 e0       	ldi	r22, 0x01	; 1
   12536:	43 ec       	ldi	r20, 0xC3	; 195
   12538:	55 e1       	ldi	r21, 0x15	; 21
   1253a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(3,1,PSTR("3)CloseDay          "));		  
   1253e:	83 e0       	ldi	r24, 0x03	; 3
   12540:	61 e0       	ldi	r22, 0x01	; 1
   12542:	4e ea       	ldi	r20, 0xAE	; 174
   12544:	55 e1       	ldi	r21, 0x15	; 21
   12546:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4,1,PSTR("4)Settings   *)Exit "));
   1254a:	84 e0       	ldi	r24, 0x04	; 4
   1254c:	61 e0       	ldi	r22, 0x01	; 1
   1254e:	49 e9       	ldi	r20, 0x99	; 153
   12550:	55 e1       	ldi	r21, 0x15	; 21
   12552:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	      stMenuAdmin=maSelectOptions;
   12556:	81 e0       	ldi	r24, 0x01	; 1
   12558:	2e c0       	rjmp	.+92     	; 0x125b6 <FMenuAdmin+0xc8>
	      break;
	 case maSelectOptions:
          KeyPressed=_key_scan(1);
   1255a:	81 e0       	ldi	r24, 0x01	; 1
   1255c:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   12560:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
		  switch (KeyChar){
   12564:	82 33       	cpi	r24, 0x32	; 50
   12566:	71 f0       	breq	.+28     	; 0x12584 <FMenuAdmin+0x96>
   12568:	83 33       	cpi	r24, 0x33	; 51
   1256a:	28 f4       	brcc	.+10     	; 0x12576 <FMenuAdmin+0x88>
   1256c:	8a 32       	cpi	r24, 0x2A	; 42
   1256e:	11 f1       	breq	.+68     	; 0x125b4 <FMenuAdmin+0xc6>
   12570:	81 33       	cpi	r24, 0x31	; 49
   12572:	81 f5       	brne	.+96     	; 0x125d4 <FMenuAdmin+0xe6>
   12574:	05 c0       	rjmp	.+10     	; 0x12580 <FMenuAdmin+0x92>
   12576:	83 33       	cpi	r24, 0x33	; 51
   12578:	59 f0       	breq	.+22     	; 0x12590 <FMenuAdmin+0xa2>
   1257a:	84 33       	cpi	r24, 0x34	; 52
   1257c:	59 f5       	brne	.+86     	; 0x125d4 <FMenuAdmin+0xe6>
   1257e:	0e c0       	rjmp	.+28     	; 0x1259c <FMenuAdmin+0xae>
		  case '1':
		       stMenuAdmin=maMenuReprint;//maMenuAdminConfig;
   12580:	82 e0       	ldi	r24, 0x02	; 2
   12582:	19 c0       	rjmp	.+50     	; 0x125b6 <FMenuAdmin+0xc8>
		       break;  
		  case '2':
		       if (IFType==IT_STANDALONE)
   12584:	80 91 10 01 	lds	r24, 0x0110
   12588:	82 30       	cpi	r24, 0x02	; 2
   1258a:	e1 f4       	brne	.+56     	; 0x125c4 <FMenuAdmin+0xd6>
			       stMenuAdmin=maMenuCloseShift;
   1258c:	84 e0       	ldi	r24, 0x04	; 4
   1258e:	13 c0       	rjmp	.+38     	; 0x125b6 <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '3':
		       if (IFType==IT_STANDALONE)stMenuAdmin=maMenuCloseDay;
   12590:	80 91 10 01 	lds	r24, 0x0110
   12594:	82 30       	cpi	r24, 0x02	; 2
   12596:	b1 f4       	brne	.+44     	; 0x125c4 <FMenuAdmin+0xd6>
   12598:	85 e0       	ldi	r24, 0x05	; 5
   1259a:	0d c0       	rjmp	.+26     	; 0x125b6 <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '4':
		  	   stMenuAdmin=maMenuAdminSettings;
   1259c:	86 e0       	ldi	r24, 0x06	; 6
   1259e:	0b c0       	rjmp	.+22     	; 0x125b6 <FMenuAdmin+0xc8>
    		   stMenuAdmin=maExitMenuAdmin;
		       break;  		  
		  }		  
	      break;
     case maMenuReprint:
	      SubMenu=FMenuReprint();
   125a0:	0e 94 41 91 	call	0x12282	; 0x12282 <FMenuReprint>
   125a4:	05 c0       	rjmp	.+10     	; 0x125b0 <FMenuAdmin+0xc2>
	 case maMenuAdminConfig://ChangePassword[],RePrint,PumpTest
	      SubMenu=FSubMenuAdmin();
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;
          break;	 
	 case maMenuCloseShift:
	 	  SubMenu=FCloseShift(CONTINUE_SHIFT);
   125a6:	82 e0       	ldi	r24, 0x02	; 2
   125a8:	01 c0       	rjmp	.+2      	; 0x125ac <FMenuAdmin+0xbe>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
	      break;
     case maMenuCloseDay://maMenuCloseShift,maMenuCloseDay
	 	  SubMenu=FCloseShift(NEW_SHIFT);
   125aa:	81 e0       	ldi	r24, 0x01	; 1
   125ac:	0e 94 d3 5e 	call	0xbda6	; 0xbda6 <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
   125b0:	81 30       	cpi	r24, 0x01	; 1
   125b2:	81 f4       	brne	.+32     	; 0x125d4 <FMenuAdmin+0xe6>
   125b4:	87 e0       	ldi	r24, 0x07	; 7
   125b6:	80 93 22 03 	sts	0x0322, r24
   125ba:	06 c0       	rjmp	.+12     	; 0x125c8 <FMenuAdmin+0xda>
	      break;
     case maMenuAdminSettings:
	      SubMenu=FMenuAdminSettings();
   125bc:	0e 94 e0 8d 	call	0x11bc0	; 0x11bc0 <FMenuAdminSettings>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;	      
   125c0:	81 30       	cpi	r24, 0x01	; 1
   125c2:	41 f4       	brne	.+16     	; 0x125d4 <FMenuAdmin+0xe6>
   125c4:	10 92 22 03 	sts	0x0322, r1
   125c8:	80 e0       	ldi	r24, 0x00	; 0
   125ca:	08 95       	ret
	      break;
     case maExitMenuAdmin:
	      stMenuAdmin=maInitAdmin;	      
   125cc:	10 92 22 03 	sts	0x0322, r1
   125d0:	81 e0       	ldi	r24, 0x01	; 1
   125d2:	08 95       	ret
   125d4:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
          break;	 
	 }
   return Result;
}
   125d6:	08 95       	ret

000125d8 <FMenuChangeMOP>:
	      break;
	 }
   return Result;
}

char FMenuChangeMOP(){
   125d8:	af 92       	push	r10
   125da:	bf 92       	push	r11
   125dc:	cf 92       	push	r12
   125de:	df 92       	push	r13
   125e0:	ef 92       	push	r14
   125e2:	ff 92       	push	r15
   125e4:	0f 93       	push	r16
   125e6:	1f 93       	push	r17
   125e8:	df 93       	push	r29
   125ea:	cf 93       	push	r28
   125ec:	cd b7       	in	r28, 0x3d	; 61
   125ee:	de b7       	in	r29, 0x3e	; 62
   125f0:	a3 97       	sbiw	r28, 0x23	; 35
   125f2:	0f b6       	in	r0, 0x3f	; 63
   125f4:	f8 94       	cli
   125f6:	de bf       	out	0x3e, r29	; 62
   125f8:	0f be       	out	0x3f, r0	; 63
   125fa:	cd bf       	out	0x3d, r28	; 61
	   char strBankName[11],strSurcharge[4],Result;
static char BankIdx=0,uiResult;//,Surcharge=0;
     
Result=MENU_NONE; 

	 switch(stChangeMOP){
   125fc:	80 91 47 03 	lds	r24, 0x0347
   12600:	e8 2f       	mov	r30, r24
   12602:	f0 e0       	ldi	r31, 0x00	; 0
   12604:	ee 31       	cpi	r30, 0x1E	; 30
   12606:	f1 05       	cpc	r31, r1
   12608:	08 f0       	brcs	.+2      	; 0x1260c <FMenuChangeMOP+0x34>
   1260a:	24 c4       	rjmp	.+2120   	; 0x12e54 <FMenuChangeMOP+0x87c>
   1260c:	ec 53       	subi	r30, 0x3C	; 60
   1260e:	ff 4f       	sbci	r31, 0xFF	; 255
   12610:	ee 0f       	add	r30, r30
   12612:	ff 1f       	adc	r31, r31
   12614:	05 90       	lpm	r0, Z+
   12616:	f4 91       	lpm	r31, Z+
   12618:	e0 2d       	mov	r30, r0
   1261a:	09 94       	ijmp
	 case cmInit:
	      MOPType=PAY_NONE;
   1261c:	85 e0       	ldi	r24, 0x05	; 5
   1261e:	80 93 cf 01 	sts	0x01CF, r24
   12622:	4e c1       	rjmp	.+668    	; 0x128c0 <FMenuChangeMOP+0x2e8>
		  stChangeMOP=cmDisplayMOPOption;
	      break;
	 case cmDisplayMOPOption: //12345678901234567890
	      lcd_clear();
   12624:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
	      lcd_printf(1,1,PSTR("   Select Payment   "));
   12628:	81 e0       	ldi	r24, 0x01	; 1
   1262a:	61 e0       	ldi	r22, 0x01	; 1
   1262c:	4f e6       	ldi	r20, 0x6F	; 111
   1262e:	59 e1       	ldi	r21, 0x19	; 25
   12630:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	      lcd_printf(2,1,PSTR("1.Account 3.Voucher "));
   12634:	82 e0       	ldi	r24, 0x02	; 2
   12636:	61 e0       	ldi	r22, 0x01	; 1
   12638:	4a e5       	ldi	r20, 0x5A	; 90
   1263a:	59 e1       	ldi	r21, 0x19	; 25
   1263c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	      lcd_printf(3,1,PSTR("2.Bank    4.PumpTest"));
   12640:	83 e0       	ldi	r24, 0x03	; 3
   12642:	61 e0       	ldi	r22, 0x01	; 1
   12644:	45 e4       	ldi	r20, 0x45	; 69
   12646:	59 e1       	ldi	r21, 0x19	; 25
   12648:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
   1264c:	84 e0       	ldi	r24, 0x04	; 4
   1264e:	61 e0       	ldi	r22, 0x01	; 1
   12650:	40 e3       	ldi	r20, 0x30	; 48
   12652:	59 e1       	ldi	r21, 0x19	; 25
   12654:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          stChangeMOP=cmInputMOP;		 
   12658:	82 e0       	ldi	r24, 0x02	; 2
   1265a:	b5 c1       	rjmp	.+874    	; 0x129c6 <FMenuChangeMOP+0x3ee>
		  break;
	 case cmInputMOP:
	      KeyPressed=_key_scan(1);
   1265c:	81 e0       	ldi	r24, 0x01	; 1
   1265e:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   12662:	80 93 42 03 	sts	0x0342, r24
		  KeyChar=_key_btn(KeyPressed);
   12666:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   1266a:	98 2f       	mov	r25, r24
   1266c:	80 93 43 03 	sts	0x0343, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   12670:	81 53       	subi	r24, 0x31	; 49
   12672:	84 30       	cpi	r24, 0x04	; 4
   12674:	f0 f4       	brcc	.+60     	; 0x126b2 <FMenuChangeMOP+0xda>
              switch(KeyChar){
   12676:	92 33       	cpi	r25, 0x32	; 50
   12678:	61 f0       	breq	.+24     	; 0x12692 <FMenuChangeMOP+0xba>
   1267a:	93 33       	cpi	r25, 0x33	; 51
   1267c:	18 f4       	brcc	.+6      	; 0x12684 <FMenuChangeMOP+0xac>
   1267e:	91 33       	cpi	r25, 0x31	; 49
   12680:	c1 f4       	brne	.+48     	; 0x126b2 <FMenuChangeMOP+0xda>
   12682:	05 c0       	rjmp	.+10     	; 0x1268e <FMenuChangeMOP+0xb6>
   12684:	93 33       	cpi	r25, 0x33	; 51
   12686:	51 f0       	breq	.+20     	; 0x1269c <FMenuChangeMOP+0xc4>
   12688:	94 33       	cpi	r25, 0x34	; 52
   1268a:	99 f4       	brne	.+38     	; 0x126b2 <FMenuChangeMOP+0xda>
   1268c:	0c c0       	rjmp	.+24     	; 0x126a6 <FMenuChangeMOP+0xce>
		        case '1':MOPType=PAY_ACCOUNT; stChangeMOP=cmSelectFIP;         break;
   1268e:	81 e0       	ldi	r24, 0x01	; 1
   12690:	0b c0       	rjmp	.+22     	; 0x126a8 <FMenuChangeMOP+0xd0>
		        case '2':MOPType=PAY_BANK;    stChangeMOP=cmSelectBankName;    break;
   12692:	82 e0       	ldi	r24, 0x02	; 2
   12694:	80 93 cf 01 	sts	0x01CF, r24
   12698:	8b e0       	ldi	r24, 0x0B	; 11
   1269a:	09 c0       	rjmp	.+18     	; 0x126ae <FMenuChangeMOP+0xd6>
		        case '3':MOPType=PAY_VOUCHER; stChangeMOP=cmDispInputVoucher;  break;
   1269c:	83 e0       	ldi	r24, 0x03	; 3
   1269e:	80 93 cf 01 	sts	0x01CF, r24
   126a2:	8f e0       	ldi	r24, 0x0F	; 15
   126a4:	04 c0       	rjmp	.+8      	; 0x126ae <FMenuChangeMOP+0xd6>
		        case '4':MOPType=PAY_PUMPTEST;stChangeMOP=cmSelectFIP;         break;
   126a6:	84 e0       	ldi	r24, 0x04	; 4
   126a8:	80 93 cf 01 	sts	0x01CF, r24
   126ac:	89 e0       	ldi	r24, 0x09	; 9
   126ae:	80 93 47 03 	sts	0x0347, r24
		     }
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmExitChangeMOP;
   126b2:	80 91 42 03 	lds	r24, 0x0342
   126b6:	87 3e       	cpi	r24, 0xE7	; 231
   126b8:	09 f0       	breq	.+2      	; 0x126bc <FMenuChangeMOP+0xe4>
   126ba:	cc c3       	rjmp	.+1944   	; 0x12e54 <FMenuChangeMOP+0x87c>
   126bc:	c3 c3       	rjmp	.+1926   	; 0x12e44 <FMenuChangeMOP+0x86c>
	      break;
	 case cmDispInputVoucher://Enter Voucher number
          lcd_clear();
   126be:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("Kode Voucher"));
   126c2:	81 e0       	ldi	r24, 0x01	; 1
   126c4:	61 e0       	ldi	r22, 0x01	; 1
   126c6:	43 e2       	ldi	r20, 0x23	; 35
   126c8:	59 e1       	ldi	r21, 0x19	; 25
   126ca:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   126ce:	82 e0       	ldi	r24, 0x02	; 2
   126d0:	61 e0       	ldi	r22, 0x01	; 1
   126d2:	41 e2       	ldi	r20, 0x21	; 33
   126d4:	59 e1       	ldi	r21, 0x19	; 25
   126d6:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   126da:	84 e0       	ldi	r24, 0x04	; 4
   126dc:	61 e0       	ldi	r22, 0x01	; 1
   126de:	4c e0       	ldi	r20, 0x0C	; 12
   126e0:	59 e1       	ldi	r21, 0x19	; 25
   126e2:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   126e6:	e7 e6       	ldi	r30, 0x67	; 103
   126e8:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   126ea:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   126ec:	8e e0       	ldi	r24, 0x0E	; 14
   126ee:	ec 37       	cpi	r30, 0x7C	; 124
   126f0:	f8 07       	cpc	r31, r24
   126f2:	d9 f7       	brne	.-10     	; 0x126ea <FMenuChangeMOP+0x112>
          lcd_clear();
		  lcd_printf(1,1,PSTR("Kode Voucher"));
		  lcd_printf(2,1,PSTR("_"));
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
		  FillChar(strVoucherNum,sizeof(strVoucherNum),0);
          stChangeMOP=cmInputVoucher;
   126f4:	87 e0       	ldi	r24, 0x07	; 7
   126f6:	80 93 47 03 	sts	0x0347, r24
		  uiResult=USER_NONE;
   126fa:	10 92 33 03 	sts	0x0333, r1
   126fe:	aa c3       	rjmp	.+1876   	; 0x12e54 <FMenuChangeMOP+0x87c>
	      break;
     case cmInputVoucher:
          uiResult=UserInput(UI_NUMBER_R,2,1,strVoucherNum,0,13);
   12700:	81 e0       	ldi	r24, 0x01	; 1
   12702:	62 e0       	ldi	r22, 0x02	; 2
   12704:	41 e0       	ldi	r20, 0x01	; 1
   12706:	27 e6       	ldi	r18, 0x67	; 103
   12708:	3e e0       	ldi	r19, 0x0E	; 14
   1270a:	00 e0       	ldi	r16, 0x00	; 0
   1270c:	10 e0       	ldi	r17, 0x00	; 0
   1270e:	5d e0       	ldi	r21, 0x0D	; 13
   12710:	e5 2e       	mov	r14, r21
   12712:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
   12716:	80 93 33 03 	sts	0x0333, r24
	      if (uiResult==USER_OK){
   1271a:	83 30       	cpi	r24, 0x03	; 3
   1271c:	11 f4       	brne	.+4      	; 0x12722 <FMenuChangeMOP+0x14a>
		     stChangeMOP=cmSelectFIP;
   1271e:	89 e0       	ldi	r24, 0x09	; 9
   12720:	52 c1       	rjmp	.+676    	; 0x129c6 <FMenuChangeMOP+0x3ee>
			 }
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmDisplayMOPOption;
   12722:	81 30       	cpi	r24, 0x01	; 1
   12724:	09 f4       	brne	.+2      	; 0x12728 <FMenuChangeMOP+0x150>
   12726:	4f c1       	rjmp	.+670    	; 0x129c6 <FMenuChangeMOP+0x3ee>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12728:	84 30       	cpi	r24, 0x04	; 4
   1272a:	21 f4       	brne	.+8      	; 0x12734 <FMenuChangeMOP+0x15c>
   1272c:	61 e0       	ldi	r22, 0x01	; 1
   1272e:	47 ef       	ldi	r20, 0xF7	; 247
   12730:	58 e1       	ldi	r21, 0x18	; 24
   12732:	31 c1       	rjmp	.+610    	; 0x12996 <FMenuChangeMOP+0x3be>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12734:	85 30       	cpi	r24, 0x05	; 5
   12736:	09 f0       	breq	.+2      	; 0x1273a <FMenuChangeMOP+0x162>
   12738:	8d c3       	rjmp	.+1818   	; 0x12e54 <FMenuChangeMOP+0x87c>
   1273a:	84 e0       	ldi	r24, 0x04	; 4
   1273c:	61 e0       	ldi	r22, 0x01	; 1
   1273e:	42 ee       	ldi	r20, 0xE2	; 226
   12740:	58 e1       	ldi	r21, 0x18	; 24
   12742:	29 c1       	rjmp	.+594    	; 0x12996 <FMenuChangeMOP+0x3be>
	      break;
	 case cmSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   12744:	81 e4       	ldi	r24, 0x41	; 65
   12746:	93 e0       	ldi	r25, 0x03	; 3
   12748:	6c ee       	ldi	r22, 0xEC	; 236
   1274a:	79 e0       	ldi	r23, 0x09	; 9
   1274c:	0e 94 77 63 	call	0xc6ee	; 0xc6ee <menu_FIP>
   12750:	80 93 46 03 	sts	0x0346, r24
		  if (FIPResult==FIP_DONE){
   12754:	88 23       	and	r24, r24
   12756:	11 f4       	brne	.+4      	; 0x1275c <FMenuChangeMOP+0x184>
		      //sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
		      stChangeMOP=cmFlowFIP;
   12758:	8e e0       	ldi	r24, 0x0E	; 14
   1275a:	35 c1       	rjmp	.+618    	; 0x129c6 <FMenuChangeMOP+0x3ee>
		  }
		  else
		  if (FIPResult==FIP_CANCEL){
   1275c:	82 30       	cpi	r24, 0x02	; 2
   1275e:	09 f0       	breq	.+2      	; 0x12762 <FMenuChangeMOP+0x18a>
   12760:	79 c3       	rjmp	.+1778   	; 0x12e54 <FMenuChangeMOP+0x87c>
		      if (MOPType==PAY_ACCOUNT)stChangeMOP=cmDisplayMOPOption;
   12762:	80 91 cf 01 	lds	r24, 0x01CF
   12766:	81 30       	cpi	r24, 0x01	; 1
   12768:	09 f4       	brne	.+2      	; 0x1276c <FMenuChangeMOP+0x194>
   1276a:	2d c1       	rjmp	.+602    	; 0x129c6 <FMenuChangeMOP+0x3ee>
		      if (MOPType==PAY_BANK)stChangeMOP=cmSelectBankName;
   1276c:	82 30       	cpi	r24, 0x02	; 2
   1276e:	09 f4       	brne	.+2      	; 0x12772 <FMenuChangeMOP+0x19a>
   12770:	03 c1       	rjmp	.+518    	; 0x12978 <FMenuChangeMOP+0x3a0>
		      if (MOPType==PAY_VOUCHER)stChangeMOP=cmDispInputVoucher;
   12772:	83 30       	cpi	r24, 0x03	; 3
   12774:	11 f4       	brne	.+4      	; 0x1277a <FMenuChangeMOP+0x1a2>
   12776:	8f e0       	ldi	r24, 0x0F	; 15
   12778:	26 c1       	rjmp	.+588    	; 0x129c6 <FMenuChangeMOP+0x3ee>
		      if (MOPType==PAY_PUMPTEST)stChangeMOP=cmDisplayMOPOption;		  
   1277a:	84 30       	cpi	r24, 0x04	; 4
   1277c:	09 f4       	brne	.+2      	; 0x12780 <FMenuChangeMOP+0x1a8>
   1277e:	a0 c0       	rjmp	.+320    	; 0x128c0 <FMenuChangeMOP+0x2e8>
   12780:	69 c3       	rjmp	.+1746   	; 0x12e54 <FMenuChangeMOP+0x87c>
     case cmSelectFIPInput:
		
	      break;
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
   12782:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Bank"));
   12786:	81 e0       	ldi	r24, 0x01	; 1
   12788:	61 e0       	ldi	r22, 0x01	; 1
   1278a:	46 ed       	ldi	r20, 0xD6	; 214
   1278c:	58 e1       	ldi	r21, 0x18	; 24
   1278e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   12792:	10 92 36 03 	sts	0x0336, r1
   12796:	10 92 35 03 	sts	0x0335, r1
   1279a:	8e 01       	movw	r16, r28
   1279c:	0b 5f       	subi	r16, 0xFB	; 251
   1279e:	1f 4f       	sbci	r17, 0xFF	; 255
   127a0:	9b e0       	ldi	r25, 0x0B	; 11
   127a2:	a9 2e       	mov	r10, r25
   127a4:	b1 2c       	mov	r11, r1
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   127a6:	80 e1       	ldi	r24, 0x10	; 16
   127a8:	e8 2e       	mov	r14, r24
   127aa:	f1 2c       	mov	r15, r1
   127ac:	ec 0e       	add	r14, r28
   127ae:	fd 1e       	adc	r15, r29
   127b0:	b0 ed       	ldi	r27, 0xD0	; 208
   127b2:	cb 2e       	mov	r12, r27
   127b4:	b8 e1       	ldi	r27, 0x18	; 24
   127b6:	db 2e       	mov	r13, r27
   127b8:	5d c0       	rjmp	.+186    	; 0x12874 <FMenuChangeMOP+0x29c>
   127ba:	8a 9d       	mul	r24, r10
   127bc:	b0 01       	movw	r22, r0
   127be:	8b 9d       	mul	r24, r11
   127c0:	70 0d       	add	r23, r0
   127c2:	9a 9d       	mul	r25, r10
   127c4:	70 0d       	add	r23, r0
   127c6:	11 24       	eor	r1, r1
   127c8:	67 5f       	subi	r22, 0xF7	; 247
   127ca:	7e 4f       	sbci	r23, 0xFE	; 254
   127cc:	c8 01       	movw	r24, r16
   127ce:	4b e0       	ldi	r20, 0x0B	; 11
   127d0:	50 e0       	ldi	r21, 0x00	; 0
   127d2:	25 ed       	ldi	r18, 0xD5	; 213
   127d4:	32 e1       	ldi	r19, 0x12	; 18
   127d6:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
   127da:	e0 e0       	ldi	r30, 0x00	; 0
   127dc:	f0 e0       	ldi	r31, 0x00	; 0
   127de:	0b 30       	cpi	r16, 0x0B	; 11
   127e0:	11 05       	cpc	r17, r1
   127e2:	10 f4       	brcc	.+4      	; 0x127e8 <FMenuChangeMOP+0x210>
   127e4:	e1 e0       	ldi	r30, 0x01	; 1
   127e6:	f0 e0       	ldi	r31, 0x00	; 0
   127e8:	80 81       	ld	r24, Z
   127ea:	88 23       	and	r24, r24
   127ec:	d1 f1       	breq	.+116    	; 0x12862 <FMenuChangeMOP+0x28a>
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   127ee:	ad b7       	in	r26, 0x3d	; 61
   127f0:	be b7       	in	r27, 0x3e	; 62
   127f2:	18 97       	sbiw	r26, 0x08	; 8
   127f4:	0f b6       	in	r0, 0x3f	; 63
   127f6:	f8 94       	cli
   127f8:	be bf       	out	0x3e, r27	; 62
   127fa:	0f be       	out	0x3f, r0	; 63
   127fc:	ad bf       	out	0x3d, r26	; 61
   127fe:	ed b7       	in	r30, 0x3d	; 61
   12800:	fe b7       	in	r31, 0x3e	; 62
   12802:	31 96       	adiw	r30, 0x01	; 1
   12804:	12 96       	adiw	r26, 0x02	; 2
   12806:	fc 92       	st	X, r15
   12808:	ee 92       	st	-X, r14
   1280a:	11 97       	sbiw	r26, 0x01	; 1
   1280c:	d3 82       	std	Z+3, r13	; 0x03
   1280e:	c2 82       	std	Z+2, r12	; 0x02
   12810:	80 91 35 03 	lds	r24, 0x0335
   12814:	90 91 36 03 	lds	r25, 0x0336
   12818:	01 96       	adiw	r24, 0x01	; 1
   1281a:	95 83       	std	Z+5, r25	; 0x05
   1281c:	84 83       	std	Z+4, r24	; 0x04
   1281e:	17 83       	std	Z+7, r17	; 0x07
   12820:	06 83       	std	Z+6, r16	; 0x06
   12822:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
   12826:	20 91 35 03 	lds	r18, 0x0335
   1282a:	30 91 36 03 	lds	r19, 0x0336
   1282e:	ed b7       	in	r30, 0x3d	; 61
   12830:	fe b7       	in	r31, 0x3e	; 62
   12832:	38 96       	adiw	r30, 0x08	; 8
   12834:	0f b6       	in	r0, 0x3f	; 63
   12836:	f8 94       	cli
   12838:	fe bf       	out	0x3e, r31	; 62
   1283a:	0f be       	out	0x3f, r0	; 63
   1283c:	ed bf       	out	0x3d, r30	; 61
   1283e:	82 2f       	mov	r24, r18
   12840:	81 70       	andi	r24, 0x01	; 1
   12842:	36 95       	lsr	r19
   12844:	27 95       	ror	r18
   12846:	b9 01       	movw	r22, r18
   12848:	66 0f       	add	r22, r22
   1284a:	77 1f       	adc	r23, r23
   1284c:	62 0f       	add	r22, r18
   1284e:	73 1f       	adc	r23, r19
   12850:	66 0f       	add	r22, r22
   12852:	77 1f       	adc	r23, r23
   12854:	66 0f       	add	r22, r22
   12856:	77 1f       	adc	r23, r23
   12858:	6f 5f       	subi	r22, 0xFF	; 255
   1285a:	8e 5f       	subi	r24, 0xFE	; 254
   1285c:	a7 01       	movw	r20, r14
   1285e:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   12862:	80 91 35 03 	lds	r24, 0x0335
   12866:	90 91 36 03 	lds	r25, 0x0336
   1286a:	01 96       	adiw	r24, 0x01	; 1
   1286c:	90 93 36 03 	sts	0x0336, r25
   12870:	80 93 35 03 	sts	0x0335, r24
   12874:	80 91 35 03 	lds	r24, 0x0335
   12878:	90 91 36 03 	lds	r25, 0x0336
   1287c:	84 30       	cpi	r24, 0x04	; 4
   1287e:	91 05       	cpc	r25, r1
   12880:	08 f4       	brcc	.+2      	; 0x12884 <FMenuChangeMOP+0x2ac>
   12882:	9b cf       	rjmp	.-202    	; 0x127ba <FMenuChangeMOP+0x1e2>
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
				 }
		  }
	      lcd_printf(4,1,PSTR("[*]Back"));
   12884:	84 e0       	ldi	r24, 0x04	; 4
   12886:	61 e0       	ldi	r22, 0x01	; 1
   12888:	48 ec       	ldi	r20, 0xC8	; 200
   1288a:	58 e1       	ldi	r21, 0x18	; 24
   1288c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  stChangeMOP=cmSelectBankNameInput;
   12890:	8c e0       	ldi	r24, 0x0C	; 12
   12892:	99 c0       	rjmp	.+306    	; 0x129c6 <FMenuChangeMOP+0x3ee>
	      break;
     case cmSelectBankNameInput:
		  KeyPressed=_key_scan(1);
   12894:	81 e0       	ldi	r24, 0x01	; 1
   12896:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   1289a:	80 93 42 03 	sts	0x0342, r24
		  KeyChar=_key_btn(KeyPressed);
   1289e:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   128a2:	80 93 43 03 	sts	0x0343, r24
          if ((KeyChar>='1')&&(KeyChar<='4')){
   128a6:	81 53       	subi	r24, 0x31	; 49
   128a8:	84 30       	cpi	r24, 0x04	; 4
   128aa:	28 f4       	brcc	.+10     	; 0x128b6 <FMenuChangeMOP+0x2de>
		      BankIdx=KeyChar-'1';
   128ac:	80 93 34 03 	sts	0x0334, r24
			  stChangeMOP=cmSelectFIP;
   128b0:	89 e0       	ldi	r24, 0x09	; 9
   128b2:	80 93 47 03 	sts	0x0347, r24
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmDisplayMOPOption;
   128b6:	80 91 42 03 	lds	r24, 0x0342
   128ba:	87 3e       	cpi	r24, 0xE7	; 231
   128bc:	09 f0       	breq	.+2      	; 0x128c0 <FMenuChangeMOP+0x2e8>
   128be:	ca c2       	rjmp	.+1428   	; 0x12e54 <FMenuChangeMOP+0x87c>
   128c0:	81 e0       	ldi	r24, 0x01	; 1
   128c2:	81 c0       	rjmp	.+258    	; 0x129c6 <FMenuChangeMOP+0x3ee>

	      break;
     case cmDispBankSurcharge:
	      lcd_clear();
   128c4:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
   128c8:	65 e0       	ldi	r22, 0x05	; 5
   128ca:	e6 2e       	mov	r14, r22
   128cc:	f1 2c       	mov	r15, r1
   128ce:	ec 0e       	add	r14, r28
   128d0:	fd 1e       	adc	r15, r29
   128d2:	60 91 34 03 	lds	r22, 0x0334
   128d6:	8b e0       	ldi	r24, 0x0B	; 11
   128d8:	68 9f       	mul	r22, r24
   128da:	b0 01       	movw	r22, r0
   128dc:	11 24       	eor	r1, r1
   128de:	67 5f       	subi	r22, 0xF7	; 247
   128e0:	7e 4f       	sbci	r23, 0xFE	; 254
   128e2:	c7 01       	movw	r24, r14
   128e4:	4b e0       	ldi	r20, 0x0B	; 11
   128e6:	50 e0       	ldi	r21, 0x00	; 0
   128e8:	25 ed       	ldi	r18, 0xD5	; 213
   128ea:	32 e1       	ldi	r19, 0x12	; 18
   128ec:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
		  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		  sprintf_P(lcdteks,PSTR("%s"),strBankName);
   128f0:	00 d0       	rcall	.+0      	; 0x128f2 <FMenuChangeMOP+0x31a>
   128f2:	00 d0       	rcall	.+0      	; 0x128f4 <FMenuChangeMOP+0x31c>
   128f4:	00 d0       	rcall	.+0      	; 0x128f6 <FMenuChangeMOP+0x31e>
   128f6:	ed b7       	in	r30, 0x3d	; 61
   128f8:	fe b7       	in	r31, 0x3e	; 62
   128fa:	31 96       	adiw	r30, 0x01	; 1
   128fc:	8e 01       	movw	r16, r28
   128fe:	00 5f       	subi	r16, 0xF0	; 240
   12900:	1f 4f       	sbci	r17, 0xFF	; 255
   12902:	ad b7       	in	r26, 0x3d	; 61
   12904:	be b7       	in	r27, 0x3e	; 62
   12906:	12 96       	adiw	r26, 0x02	; 2
   12908:	1c 93       	st	X, r17
   1290a:	0e 93       	st	-X, r16
   1290c:	11 97       	sbiw	r26, 0x01	; 1
   1290e:	85 ec       	ldi	r24, 0xC5	; 197
   12910:	98 e1       	ldi	r25, 0x18	; 24
   12912:	93 83       	std	Z+3, r25	; 0x03
   12914:	82 83       	std	Z+2, r24	; 0x02
   12916:	f5 82       	std	Z+5, r15	; 0x05
   12918:	e4 82       	std	Z+4, r14	; 0x04
   1291a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   1291e:	ed b7       	in	r30, 0x3d	; 61
   12920:	fe b7       	in	r31, 0x3e	; 62
   12922:	36 96       	adiw	r30, 0x06	; 6
   12924:	0f b6       	in	r0, 0x3f	; 63
   12926:	f8 94       	cli
   12928:	fe bf       	out	0x3e, r31	; 62
   1292a:	0f be       	out	0x3f, r0	; 63
   1292c:	ed bf       	out	0x3d, r30	; 61
   1292e:	81 e0       	ldi	r24, 0x01	; 1
   12930:	61 e0       	ldi	r22, 0x01	; 1
   12932:	a8 01       	movw	r20, r16
   12934:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_printf(2,1,PSTR("Surcharge:   _%"));
   12938:	82 e0       	ldi	r24, 0x02	; 2
   1293a:	61 e0       	ldi	r22, 0x01	; 1
   1293c:	45 eb       	ldi	r20, 0xB5	; 181
   1293e:	58 e1       	ldi	r21, 0x18	; 24
   12940:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12944:	84 e0       	ldi	r24, 0x04	; 4
   12946:	61 e0       	ldi	r22, 0x01	; 1
   12948:	40 ea       	ldi	r20, 0xA0	; 160
   1294a:	58 e1       	ldi	r21, 0x18	; 24
   1294c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          stChangeMOP=cmInputBankSurcharge;
   12950:	8d e0       	ldi	r24, 0x0D	; 13
   12952:	39 c0       	rjmp	.+114    	; 0x129c6 <FMenuChangeMOP+0x3ee>
	      break;
	 case cmInputBankSurcharge:
	      uiResult=UserInput(UI_NUMBER_L,2,14,ValueChar,100,3);
   12954:	82 e0       	ldi	r24, 0x02	; 2
   12956:	62 e0       	ldi	r22, 0x02	; 2
   12958:	4e e0       	ldi	r20, 0x0E	; 14
   1295a:	27 e3       	ldi	r18, 0x37	; 55
   1295c:	33 e0       	ldi	r19, 0x03	; 3
   1295e:	04 e6       	ldi	r16, 0x64	; 100
   12960:	10 e0       	ldi	r17, 0x00	; 0
   12962:	53 e0       	ldi	r21, 0x03	; 3
   12964:	e5 2e       	mov	r14, r21
   12966:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
   1296a:	80 93 33 03 	sts	0x0333, r24
	      if (uiResult==USER_OK)stChangeMOP=cmGenerateData;
   1296e:	83 30       	cpi	r24, 0x03	; 3
   12970:	09 f4       	brne	.+2      	; 0x12974 <FMenuChangeMOP+0x39c>
   12972:	cb c0       	rjmp	.+406    	; 0x12b0a <FMenuChangeMOP+0x532>
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmSelectBankName;
   12974:	81 30       	cpi	r24, 0x01	; 1
   12976:	11 f4       	brne	.+4      	; 0x1297c <FMenuChangeMOP+0x3a4>
   12978:	8b e0       	ldi	r24, 0x0B	; 11
   1297a:	25 c0       	rjmp	.+74     	; 0x129c6 <FMenuChangeMOP+0x3ee>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   1297c:	84 30       	cpi	r24, 0x04	; 4
   1297e:	21 f4       	brne	.+8      	; 0x12988 <FMenuChangeMOP+0x3b0>
   12980:	61 e0       	ldi	r22, 0x01	; 1
   12982:	4b e8       	ldi	r20, 0x8B	; 139
   12984:	58 e1       	ldi	r21, 0x18	; 24
   12986:	07 c0       	rjmp	.+14     	; 0x12996 <FMenuChangeMOP+0x3be>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12988:	85 30       	cpi	r24, 0x05	; 5
   1298a:	09 f0       	breq	.+2      	; 0x1298e <FMenuChangeMOP+0x3b6>
   1298c:	63 c2       	rjmp	.+1222   	; 0x12e54 <FMenuChangeMOP+0x87c>
   1298e:	84 e0       	ldi	r24, 0x04	; 4
   12990:	61 e0       	ldi	r22, 0x01	; 1
   12992:	46 e7       	ldi	r20, 0x76	; 118
   12994:	58 e1       	ldi	r21, 0x18	; 24
   12996:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   1299a:	5c c2       	rjmp	.+1208   	; 0x12e54 <FMenuChangeMOP+0x87c>
	      break;
     case cmFlowFIP:
          switch(MOPType){
   1299c:	80 91 cf 01 	lds	r24, 0x01CF
   129a0:	82 30       	cpi	r24, 0x02	; 2
   129a2:	61 f0       	breq	.+24     	; 0x129bc <FMenuChangeMOP+0x3e4>
   129a4:	83 30       	cpi	r24, 0x03	; 3
   129a6:	20 f4       	brcc	.+8      	; 0x129b0 <FMenuChangeMOP+0x3d8>
   129a8:	81 30       	cpi	r24, 0x01	; 1
   129aa:	09 f0       	breq	.+2      	; 0x129ae <FMenuChangeMOP+0x3d6>
   129ac:	53 c2       	rjmp	.+1190   	; 0x12e54 <FMenuChangeMOP+0x87c>
   129ae:	0a c0       	rjmp	.+20     	; 0x129c4 <FMenuChangeMOP+0x3ec>
   129b0:	83 30       	cpi	r24, 0x03	; 3
   129b2:	31 f0       	breq	.+12     	; 0x129c0 <FMenuChangeMOP+0x3e8>
   129b4:	84 30       	cpi	r24, 0x04	; 4
   129b6:	09 f0       	breq	.+2      	; 0x129ba <FMenuChangeMOP+0x3e2>
   129b8:	4d c2       	rjmp	.+1178   	; 0x12e54 <FMenuChangeMOP+0x87c>
   129ba:	04 c0       	rjmp	.+8      	; 0x129c4 <FMenuChangeMOP+0x3ec>
		  case PAY_ACCOUNT: stChangeMOP=cmDispCardTap;       break;
		  case PAY_BANK:    stChangeMOP=cmDispBankSurcharge; break;
   129bc:	81 e1       	ldi	r24, 0x11	; 17
   129be:	03 c0       	rjmp	.+6      	; 0x129c6 <FMenuChangeMOP+0x3ee>
		  case PAY_VOUCHER: stChangeMOP=cmProsesVoucher;      break;
   129c0:	85 e1       	ldi	r24, 0x15	; 21
   129c2:	01 c0       	rjmp	.+2      	; 0x129c6 <FMenuChangeMOP+0x3ee>
		  case PAY_PUMPTEST:stChangeMOP=cmDispCardTap;       break;
   129c4:	82 e1       	ldi	r24, 0x12	; 18
   129c6:	80 93 47 03 	sts	0x0347, r24
   129ca:	44 c2       	rjmp	.+1160   	; 0x12e54 <FMenuChangeMOP+0x87c>
		  }
	      break;
     case cmDispCardTap:
	      lcd_clear();
   129cc:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
	      lcd_printf(1,1,PSTR("Tap Kartu RFID"));
   129d0:	81 e0       	ldi	r24, 0x01	; 1
   129d2:	61 e0       	ldi	r22, 0x01	; 1
   129d4:	47 e6       	ldi	r20, 0x67	; 103
   129d6:	58 e1       	ldi	r21, 0x18	; 24
   129d8:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  sprintf_P(lcdteks,PSTR("FIP%s"),strFIP_ID);
   129dc:	00 d0       	rcall	.+0      	; 0x129de <FMenuChangeMOP+0x406>
   129de:	00 d0       	rcall	.+0      	; 0x129e0 <FMenuChangeMOP+0x408>
   129e0:	00 d0       	rcall	.+0      	; 0x129e2 <FMenuChangeMOP+0x40a>
   129e2:	ed b7       	in	r30, 0x3d	; 61
   129e4:	fe b7       	in	r31, 0x3e	; 62
   129e6:	31 96       	adiw	r30, 0x01	; 1
   129e8:	8e 01       	movw	r16, r28
   129ea:	00 5f       	subi	r16, 0xF0	; 240
   129ec:	1f 4f       	sbci	r17, 0xFF	; 255
   129ee:	ad b7       	in	r26, 0x3d	; 61
   129f0:	be b7       	in	r27, 0x3e	; 62
   129f2:	12 96       	adiw	r26, 0x02	; 2
   129f4:	1c 93       	st	X, r17
   129f6:	0e 93       	st	-X, r16
   129f8:	11 97       	sbiw	r26, 0x01	; 1
   129fa:	81 e6       	ldi	r24, 0x61	; 97
   129fc:	98 e1       	ldi	r25, 0x18	; 24
   129fe:	93 83       	std	Z+3, r25	; 0x03
   12a00:	82 83       	std	Z+2, r24	; 0x02
   12a02:	8c ee       	ldi	r24, 0xEC	; 236
   12a04:	99 e0       	ldi	r25, 0x09	; 9
   12a06:	95 83       	std	Z+5, r25	; 0x05
   12a08:	84 83       	std	Z+4, r24	; 0x04
   12a0a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   12a0e:	ed b7       	in	r30, 0x3d	; 61
   12a10:	fe b7       	in	r31, 0x3e	; 62
   12a12:	36 96       	adiw	r30, 0x06	; 6
   12a14:	0f b6       	in	r0, 0x3f	; 63
   12a16:	f8 94       	cli
   12a18:	fe bf       	out	0x3e, r31	; 62
   12a1a:	0f be       	out	0x3f, r0	; 63
   12a1c:	ed bf       	out	0x3d, r30	; 61
   12a1e:	82 e0       	ldi	r24, 0x02	; 2
   12a20:	61 e0       	ldi	r22, 0x01	; 1
   12a22:	a8 01       	movw	r20, r16
   12a24:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
   12a28:	84 e0       	ldi	r24, 0x04	; 4
   12a2a:	61 e0       	ldi	r22, 0x01	; 1
   12a2c:	4e e4       	ldi	r20, 0x4E	; 78
   12a2e:	58 e1       	ldi	r21, 0x18	; 24
   12a30:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  IsRFIDDetected=False;
   12a34:	10 92 af 01 	sts	0x01AF, r1
          stChangeMOP=cmRFIDCardInput;
   12a38:	83 e1       	ldi	r24, 0x13	; 19
   12a3a:	c5 cf       	rjmp	.-118    	; 0x129c6 <FMenuChangeMOP+0x3ee>
	      break;
	 case cmRFIDCardInput:
		  KeyPressed=_key_scan(1);
   12a3c:	81 e0       	ldi	r24, 0x01	; 1
   12a3e:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   12a42:	80 93 42 03 	sts	0x0342, r24
		  KeyChar=_key_btn(KeyPressed);
   12a46:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   12a4a:	80 93 43 03 	sts	0x0343, r24
		  if (KeyPressed==_KEY_ENTER){
   12a4e:	80 91 42 03 	lds	r24, 0x0342
   12a52:	87 3b       	cpi	r24, 0xB7	; 183
   12a54:	11 f4       	brne	.+4      	; 0x12a5a <FMenuChangeMOP+0x482>
		      stChangeMOP=cmExitChangeMOP;
   12a56:	8c e1       	ldi	r24, 0x1C	; 28
   12a58:	03 c0       	rjmp	.+6      	; 0x12a60 <FMenuChangeMOP+0x488>
		  }
		  else
		  if (KeyPressed==_KEY_CANCEL){
   12a5a:	87 3e       	cpi	r24, 0xE7	; 231
   12a5c:	19 f4       	brne	.+6      	; 0x12a64 <FMenuChangeMOP+0x48c>
   		      stChangeMOP=cmSelectFIP;
   12a5e:	89 e0       	ldi	r24, 0x09	; 9
   12a60:	80 93 47 03 	sts	0x0347, r24
			 }
          if (IsRFIDDetected==True){
   12a64:	80 91 af 01 	lds	r24, 0x01AF
   12a68:	81 30       	cpi	r24, 0x01	; 1
   12a6a:	09 f0       	breq	.+2      	; 0x12a6e <FMenuChangeMOP+0x496>
   12a6c:	f3 c1       	rjmp	.+998    	; 0x12e54 <FMenuChangeMOP+0x87c>
		      IsRFIDDetected=False;
   12a6e:	10 92 af 01 	sts	0x01AF, r1
			   stChangeMOP=cmProsesRFID;
   12a72:	84 e1       	ldi	r24, 0x14	; 20
   12a74:	a8 cf       	rjmp	.-176    	; 0x129c6 <FMenuChangeMOP+0x3ee>
   12a76:	20 e0       	ldi	r18, 0x00	; 0
   12a78:	30 e0       	ldi	r19, 0x00	; 0
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   12a7a:	f9 01       	movw	r30, r18
   12a7c:	ef 54       	subi	r30, 0x4F	; 79
   12a7e:	f2 4f       	sbci	r31, 0xF2	; 242
   12a80:	d9 01       	movw	r26, r18
   12a82:	a4 58       	subi	r26, 0x84	; 132
   12a84:	b1 4f       	sbci	r27, 0xF1	; 241
   12a86:	8c 91       	ld	r24, X
   12a88:	80 83       	st	Z, r24
   12a8a:	2f 5f       	subi	r18, 0xFF	; 255
   12a8c:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   12a8e:	28 30       	cpi	r18, 0x08	; 8
   12a90:	31 05       	cpc	r19, r1
   12a92:	99 f7       	brne	.-26     	; 0x12a7a <FMenuChangeMOP+0x4a2>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   12a94:	10 92 b9 0d 	sts	0x0DB9, r1
			   stChangeMOP=cmProsesRFID;
			 }
	      break;
     case cmProsesRFID:
	      ViewCardID();
          sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   12a98:	00 d0       	rcall	.+0      	; 0x12a9a <FMenuChangeMOP+0x4c2>
   12a9a:	00 d0       	rcall	.+0      	; 0x12a9c <FMenuChangeMOP+0x4c4>
   12a9c:	00 d0       	rcall	.+0      	; 0x12a9e <FMenuChangeMOP+0x4c6>
   12a9e:	ed b7       	in	r30, 0x3d	; 61
   12aa0:	fe b7       	in	r31, 0x3e	; 62
   12aa2:	31 96       	adiw	r30, 0x01	; 1
   12aa4:	8e 01       	movw	r16, r28
   12aa6:	00 5f       	subi	r16, 0xF0	; 240
   12aa8:	1f 4f       	sbci	r17, 0xFF	; 255
   12aaa:	ad b7       	in	r26, 0x3d	; 61
   12aac:	be b7       	in	r27, 0x3e	; 62
   12aae:	12 96       	adiw	r26, 0x02	; 2
   12ab0:	1c 93       	st	X, r17
   12ab2:	0e 93       	st	-X, r16
   12ab4:	11 97       	sbiw	r26, 0x01	; 1
   12ab6:	88 e4       	ldi	r24, 0x48	; 72
   12ab8:	98 e1       	ldi	r25, 0x18	; 24
   12aba:	93 83       	std	Z+3, r25	; 0x03
   12abc:	82 83       	std	Z+2, r24	; 0x02
   12abe:	81 eb       	ldi	r24, 0xB1	; 177
   12ac0:	9d e0       	ldi	r25, 0x0D	; 13
   12ac2:	95 83       	std	Z+5, r25	; 0x05
   12ac4:	84 83       	std	Z+4, r24	; 0x04
   12ac6:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   12aca:	ed b7       	in	r30, 0x3d	; 61
   12acc:	fe b7       	in	r31, 0x3e	; 62
   12ace:	36 96       	adiw	r30, 0x06	; 6
   12ad0:	0f b6       	in	r0, 0x3f	; 63
   12ad2:	f8 94       	cli
   12ad4:	fe bf       	out	0x3e, r31	; 62
   12ad6:	0f be       	out	0x3f, r0	; 63
   12ad8:	ed bf       	out	0x3d, r30	; 61
   12ada:	82 e0       	ldi	r24, 0x02	; 2
   12adc:	61 e0       	ldi	r22, 0x01	; 1
   12ade:	a8 01       	movw	r20, r16
   12ae0:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
          lcd_printf(3,1,PSTR("Proses"));
   12ae4:	83 e0       	ldi	r24, 0x03	; 3
   12ae6:	61 e0       	ldi	r22, 0x01	; 1
   12ae8:	41 e4       	ldi	r20, 0x41	; 65
   12aea:	58 e1       	ldi	r21, 0x18	; 24
   12aec:	0c c0       	rjmp	.+24     	; 0x12b06 <FMenuChangeMOP+0x52e>
		  stChangeMOP=cmGenerateData;
	      break;
     case cmProsesVoucher:
          lcd_clear();
   12aee:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
          lcd_printf(1,1,PSTR("-MOP Voucher-")); 
   12af2:	81 e0       	ldi	r24, 0x01	; 1
   12af4:	61 e0       	ldi	r22, 0x01	; 1
   12af6:	43 e3       	ldi	r20, 0x33	; 51
   12af8:	58 e1       	ldi	r21, 0x18	; 24
   12afa:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
          lcd_printf(3,1,PSTR("Proses"));
   12afe:	83 e0       	ldi	r24, 0x03	; 3
   12b00:	61 e0       	ldi	r22, 0x01	; 1
   12b02:	4c e2       	ldi	r20, 0x2C	; 44
   12b04:	58 e1       	ldi	r21, 0x18	; 24
   12b06:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  stChangeMOP=cmGenerateData;
   12b0a:	86 e1       	ldi	r24, 0x16	; 22
   12b0c:	5c cf       	rjmp	.-328    	; 0x129c6 <FMenuChangeMOP+0x3ee>
	      break;
   12b0e:	e8 eb       	ldi	r30, 0xB8	; 184
   12b10:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   12b12:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12b14:	8e e0       	ldi	r24, 0x0E	; 14
   12b16:	ed 3c       	cpi	r30, 0xCD	; 205
   12b18:	f8 07       	cpc	r31, r24
   12b1a:	d9 f7       	brne	.-10     	; 0x12b12 <FMenuChangeMOP+0x53a>
   12b1c:	e6 ec       	ldi	r30, 0xC6	; 198
   12b1e:	fd e0       	ldi	r31, 0x0D	; 13
	     strMemory[i]=data;
   12b20:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12b22:	9d e0       	ldi	r25, 0x0D	; 13
   12b24:	eb 3d       	cpi	r30, 0xDB	; 219
   12b26:	f9 07       	cpc	r31, r25
   12b28:	d9 f7       	brne	.-10     	; 0x12b20 <FMenuChangeMOP+0x548>
   12b2a:	e2 ed       	ldi	r30, 0xD2	; 210
   12b2c:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
   12b2e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12b30:	aa e0       	ldi	r26, 0x0A	; 10
   12b32:	e7 3e       	cpi	r30, 0xE7	; 231
   12b34:	fa 07       	cpc	r31, r26
   12b36:	d9 f7       	brne	.-10     	; 0x12b2e <FMenuChangeMOP+0x556>
   12b38:	25 ed       	ldi	r18, 0xD5	; 213
   12b3a:	e2 2e       	mov	r14, r18
   12b3c:	25 e0       	ldi	r18, 0x05	; 5
   12b3e:	f2 2e       	mov	r15, r18
	     strMemory[i]=data;
   12b40:	f7 01       	movw	r30, r14
   12b42:	11 92       	st	Z+, r1
   12b44:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12b46:	fa ee       	ldi	r31, 0xEA	; 234
   12b48:	ef 16       	cp	r14, r31
   12b4a:	f5 e0       	ldi	r31, 0x05	; 5
   12b4c:	ff 06       	cpc	r15, r31
   12b4e:	c1 f7       	brne	.-16     	; 0x12b40 <FMenuChangeMOP+0x568>
     case cmGenerateData:
	      FillChar(strRef1,sizeof(strRef1),0);
	      FillChar(strRef2,sizeof(strRef2),0);
	      FillChar(strRef3,sizeof(strRef3),0);
	      FillChar(strRef4,sizeof(strRef4),0);
          switch(MOPType){
   12b50:	80 91 cf 01 	lds	r24, 0x01CF
   12b54:	82 30       	cpi	r24, 0x02	; 2
   12b56:	f1 f0       	breq	.+60     	; 0x12b94 <FMenuChangeMOP+0x5bc>
   12b58:	83 30       	cpi	r24, 0x03	; 3
   12b5a:	20 f4       	brcc	.+8      	; 0x12b64 <FMenuChangeMOP+0x58c>
   12b5c:	81 30       	cpi	r24, 0x01	; 1
   12b5e:	09 f0       	breq	.+2      	; 0x12b62 <FMenuChangeMOP+0x58a>
   12b60:	ad c0       	rjmp	.+346    	; 0x12cbc <FMenuChangeMOP+0x6e4>
   12b62:	07 c0       	rjmp	.+14     	; 0x12b72 <FMenuChangeMOP+0x59a>
   12b64:	83 30       	cpi	r24, 0x03	; 3
   12b66:	09 f4       	brne	.+2      	; 0x12b6a <FMenuChangeMOP+0x592>
   12b68:	64 c0       	rjmp	.+200    	; 0x12c32 <FMenuChangeMOP+0x65a>
   12b6a:	84 30       	cpi	r24, 0x04	; 4
   12b6c:	09 f0       	breq	.+2      	; 0x12b70 <FMenuChangeMOP+0x598>
   12b6e:	a6 c0       	rjmp	.+332    	; 0x12cbc <FMenuChangeMOP+0x6e4>
   12b70:	75 c0       	rjmp	.+234    	; 0x12c5c <FMenuChangeMOP+0x684>
		  case PAY_ACCOUNT:
		       sprintf_P(strRef1,PSTR("%s"),strCardID); 
   12b72:	00 d0       	rcall	.+0      	; 0x12b74 <FMenuChangeMOP+0x59c>
   12b74:	00 d0       	rcall	.+0      	; 0x12b76 <FMenuChangeMOP+0x59e>
   12b76:	00 d0       	rcall	.+0      	; 0x12b78 <FMenuChangeMOP+0x5a0>
   12b78:	ed b7       	in	r30, 0x3d	; 61
   12b7a:	fe b7       	in	r31, 0x3e	; 62
   12b7c:	31 96       	adiw	r30, 0x01	; 1
   12b7e:	88 eb       	ldi	r24, 0xB8	; 184
   12b80:	9e e0       	ldi	r25, 0x0E	; 14
   12b82:	ad b7       	in	r26, 0x3d	; 61
   12b84:	be b7       	in	r27, 0x3e	; 62
   12b86:	12 96       	adiw	r26, 0x02	; 2
   12b88:	9c 93       	st	X, r25
   12b8a:	8e 93       	st	-X, r24
   12b8c:	11 97       	sbiw	r26, 0x01	; 1
   12b8e:	89 e2       	ldi	r24, 0x29	; 41
   12b90:	98 e1       	ldi	r25, 0x18	; 24
   12b92:	84 c0       	rjmp	.+264    	; 0x12c9c <FMenuChangeMOP+0x6c4>
   12b94:	8e 01       	movw	r16, r28
   12b96:	0b 5f       	subi	r16, 0xFB	; 251
   12b98:	1f 4f       	sbci	r17, 0xFF	; 255
   12b9a:	60 91 34 03 	lds	r22, 0x0334
   12b9e:	8b e0       	ldi	r24, 0x0B	; 11
   12ba0:	68 9f       	mul	r22, r24
   12ba2:	b0 01       	movw	r22, r0
   12ba4:	11 24       	eor	r1, r1
   12ba6:	67 5f       	subi	r22, 0xF7	; 247
   12ba8:	7e 4f       	sbci	r23, 0xFE	; 254
   12baa:	c8 01       	movw	r24, r16
   12bac:	4b e0       	ldi	r20, 0x0B	; 11
   12bae:	50 e0       	ldi	r21, 0x00	; 0
   12bb0:	25 ed       	ldi	r18, 0xD5	; 213
   12bb2:	32 e1       	ldi	r19, 0x12	; 18
   12bb4:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
		       break;
		  case PAY_BANK:
		  	   eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		       sprintf_P(lcdteks,PSTR("%s"),strBankName);
   12bb8:	00 d0       	rcall	.+0      	; 0x12bba <FMenuChangeMOP+0x5e2>
   12bba:	00 d0       	rcall	.+0      	; 0x12bbc <FMenuChangeMOP+0x5e4>
   12bbc:	00 d0       	rcall	.+0      	; 0x12bbe <FMenuChangeMOP+0x5e6>
   12bbe:	ed b7       	in	r30, 0x3d	; 61
   12bc0:	fe b7       	in	r31, 0x3e	; 62
   12bc2:	31 96       	adiw	r30, 0x01	; 1
   12bc4:	ce 01       	movw	r24, r28
   12bc6:	40 96       	adiw	r24, 0x10	; 16
   12bc8:	ad b7       	in	r26, 0x3d	; 61
   12bca:	be b7       	in	r27, 0x3e	; 62
   12bcc:	12 96       	adiw	r26, 0x02	; 2
   12bce:	9c 93       	st	X, r25
   12bd0:	8e 93       	st	-X, r24
   12bd2:	11 97       	sbiw	r26, 0x01	; 1
   12bd4:	86 e2       	ldi	r24, 0x26	; 38
   12bd6:	98 e1       	ldi	r25, 0x18	; 24
   12bd8:	93 83       	std	Z+3, r25	; 0x03
   12bda:	82 83       	std	Z+2, r24	; 0x02
   12bdc:	15 83       	std	Z+5, r17	; 0x05
   12bde:	04 83       	std	Z+4, r16	; 0x04
   12be0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		       sprintf_P(strRef1,PSTR("%s"),strBankName); 
   12be4:	ed b7       	in	r30, 0x3d	; 61
   12be6:	fe b7       	in	r31, 0x3e	; 62
   12be8:	31 96       	adiw	r30, 0x01	; 1
   12bea:	88 eb       	ldi	r24, 0xB8	; 184
   12bec:	9e e0       	ldi	r25, 0x0E	; 14
   12bee:	ad b7       	in	r26, 0x3d	; 61
   12bf0:	be b7       	in	r27, 0x3e	; 62
   12bf2:	12 96       	adiw	r26, 0x02	; 2
   12bf4:	9c 93       	st	X, r25
   12bf6:	8e 93       	st	-X, r24
   12bf8:	11 97       	sbiw	r26, 0x01	; 1
   12bfa:	83 e2       	ldi	r24, 0x23	; 35
   12bfc:	98 e1       	ldi	r25, 0x18	; 24
   12bfe:	93 83       	std	Z+3, r25	; 0x03
   12c00:	82 83       	std	Z+2, r24	; 0x02
   12c02:	15 83       	std	Z+5, r17	; 0x05
   12c04:	04 83       	std	Z+4, r16	; 0x04
   12c06:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		       sprintf_P(strRef4,PSTR("%s"),strSurcharge); 
   12c0a:	ed b7       	in	r30, 0x3d	; 61
   12c0c:	fe b7       	in	r31, 0x3e	; 62
   12c0e:	31 96       	adiw	r30, 0x01	; 1
   12c10:	8b ee       	ldi	r24, 0xEB	; 235
   12c12:	9f ef       	ldi	r25, 0xFF	; 255
   12c14:	e8 0e       	add	r14, r24
   12c16:	f9 1e       	adc	r15, r25
   12c18:	ad b7       	in	r26, 0x3d	; 61
   12c1a:	be b7       	in	r27, 0x3e	; 62
   12c1c:	12 96       	adiw	r26, 0x02	; 2
   12c1e:	fc 92       	st	X, r15
   12c20:	ee 92       	st	-X, r14
   12c22:	11 97       	sbiw	r26, 0x01	; 1
   12c24:	80 e2       	ldi	r24, 0x20	; 32
   12c26:	98 e1       	ldi	r25, 0x18	; 24
   12c28:	93 83       	std	Z+3, r25	; 0x03
   12c2a:	82 83       	std	Z+2, r24	; 0x02
   12c2c:	ce 01       	movw	r24, r28
   12c2e:	01 96       	adiw	r24, 0x01	; 1
   12c30:	39 c0       	rjmp	.+114    	; 0x12ca4 <FMenuChangeMOP+0x6cc>
		       break;
		  case PAY_VOUCHER://Load data Ref1=Voucher on cmVoucherInput
		  	   sprintf_P(strRef1,PSTR("%s"),strVoucherNum); 
   12c32:	00 d0       	rcall	.+0      	; 0x12c34 <FMenuChangeMOP+0x65c>
   12c34:	00 d0       	rcall	.+0      	; 0x12c36 <FMenuChangeMOP+0x65e>
   12c36:	00 d0       	rcall	.+0      	; 0x12c38 <FMenuChangeMOP+0x660>
   12c38:	ed b7       	in	r30, 0x3d	; 61
   12c3a:	fe b7       	in	r31, 0x3e	; 62
   12c3c:	31 96       	adiw	r30, 0x01	; 1
   12c3e:	88 eb       	ldi	r24, 0xB8	; 184
   12c40:	9e e0       	ldi	r25, 0x0E	; 14
   12c42:	ad b7       	in	r26, 0x3d	; 61
   12c44:	be b7       	in	r27, 0x3e	; 62
   12c46:	12 96       	adiw	r26, 0x02	; 2
   12c48:	9c 93       	st	X, r25
   12c4a:	8e 93       	st	-X, r24
   12c4c:	11 97       	sbiw	r26, 0x01	; 1
   12c4e:	8d e1       	ldi	r24, 0x1D	; 29
   12c50:	98 e1       	ldi	r25, 0x18	; 24
   12c52:	93 83       	std	Z+3, r25	; 0x03
   12c54:	82 83       	std	Z+2, r24	; 0x02
   12c56:	87 e6       	ldi	r24, 0x67	; 103
   12c58:	9e e0       	ldi	r25, 0x0E	; 14
   12c5a:	24 c0       	rjmp	.+72     	; 0x12ca4 <FMenuChangeMOP+0x6cc>
		       break;
		  case PAY_PUMPTEST:
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
   12c5c:	00 d0       	rcall	.+0      	; 0x12c5e <FMenuChangeMOP+0x686>
   12c5e:	00 d0       	rcall	.+0      	; 0x12c60 <FMenuChangeMOP+0x688>
   12c60:	88 eb       	ldi	r24, 0xB8	; 184
   12c62:	9e e0       	ldi	r25, 0x0E	; 14
   12c64:	ad b7       	in	r26, 0x3d	; 61
   12c66:	be b7       	in	r27, 0x3e	; 62
   12c68:	12 96       	adiw	r26, 0x02	; 2
   12c6a:	9c 93       	st	X, r25
   12c6c:	8e 93       	st	-X, r24
   12c6e:	11 97       	sbiw	r26, 0x01	; 1
   12c70:	83 e1       	ldi	r24, 0x13	; 19
   12c72:	98 e1       	ldi	r25, 0x18	; 24
   12c74:	14 96       	adiw	r26, 0x04	; 4
   12c76:	9c 93       	st	X, r25
   12c78:	8e 93       	st	-X, r24
   12c7a:	13 97       	sbiw	r26, 0x03	; 3
   12c7c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
   12c80:	00 d0       	rcall	.+0      	; 0x12c82 <FMenuChangeMOP+0x6aa>
   12c82:	ed b7       	in	r30, 0x3d	; 61
   12c84:	fe b7       	in	r31, 0x3e	; 62
   12c86:	31 96       	adiw	r30, 0x01	; 1
   12c88:	86 ec       	ldi	r24, 0xC6	; 198
   12c8a:	9d e0       	ldi	r25, 0x0D	; 13
   12c8c:	ad b7       	in	r26, 0x3d	; 61
   12c8e:	be b7       	in	r27, 0x3e	; 62
   12c90:	12 96       	adiw	r26, 0x02	; 2
   12c92:	9c 93       	st	X, r25
   12c94:	8e 93       	st	-X, r24
   12c96:	11 97       	sbiw	r26, 0x01	; 1
   12c98:	80 e1       	ldi	r24, 0x10	; 16
   12c9a:	98 e1       	ldi	r25, 0x18	; 24
   12c9c:	93 83       	std	Z+3, r25	; 0x03
   12c9e:	82 83       	std	Z+2, r24	; 0x02
   12ca0:	81 eb       	ldi	r24, 0xB1	; 177
   12ca2:	9d e0       	ldi	r25, 0x0D	; 13
   12ca4:	95 83       	std	Z+5, r25	; 0x05
   12ca6:	84 83       	std	Z+4, r24	; 0x04
   12ca8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   12cac:	ed b7       	in	r30, 0x3d	; 61
   12cae:	fe b7       	in	r31, 0x3e	; 62
   12cb0:	36 96       	adiw	r30, 0x06	; 6
   12cb2:	0f b6       	in	r0, 0x3f	; 63
   12cb4:	f8 94       	cli
   12cb6:	fe bf       	out	0x3e, r31	; 62
   12cb8:	0f be       	out	0x3f, r0	; 63
   12cba:	ed bf       	out	0x3d, r30	; 61
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
   12cbc:	00 d0       	rcall	.+0      	; 0x12cbe <FMenuChangeMOP+0x6e6>
   12cbe:	00 d0       	rcall	.+0      	; 0x12cc0 <FMenuChangeMOP+0x6e8>
   12cc0:	00 d0       	rcall	.+0      	; 0x12cc2 <FMenuChangeMOP+0x6ea>
   12cc2:	ed b7       	in	r30, 0x3d	; 61
   12cc4:	fe b7       	in	r31, 0x3e	; 62
   12cc6:	31 96       	adiw	r30, 0x01	; 1
   12cc8:	83 e8       	ldi	r24, 0x83	; 131
   12cca:	99 e0       	ldi	r25, 0x09	; 9
   12ccc:	ad b7       	in	r26, 0x3d	; 61
   12cce:	be b7       	in	r27, 0x3e	; 62
   12cd0:	12 96       	adiw	r26, 0x02	; 2
   12cd2:	9c 93       	st	X, r25
   12cd4:	8e 93       	st	-X, r24
   12cd6:	11 97       	sbiw	r26, 0x01	; 1
   12cd8:	86 e5       	ldi	r24, 0x56	; 86
   12cda:	9d e0       	ldi	r25, 0x0D	; 13
   12cdc:	93 83       	std	Z+3, r25	; 0x03
   12cde:	82 83       	std	Z+2, r24	; 0x02
   12ce0:	80 91 cf 01 	lds	r24, 0x01CF
   12ce4:	84 83       	std	Z+4, r24	; 0x04
   12ce6:	15 82       	std	Z+5, r1	; 0x05
   12ce8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
		       break;
		  }
		  leadingZero(MOPType,strPaymentType);
		  AddSpaceLead(strRef1,20);
   12cec:	ed b7       	in	r30, 0x3d	; 61
   12cee:	fe b7       	in	r31, 0x3e	; 62
   12cf0:	36 96       	adiw	r30, 0x06	; 6
   12cf2:	0f b6       	in	r0, 0x3f	; 63
   12cf4:	f8 94       	cli
   12cf6:	fe bf       	out	0x3e, r31	; 62
   12cf8:	0f be       	out	0x3f, r0	; 63
   12cfa:	ed bf       	out	0x3d, r30	; 61
   12cfc:	88 eb       	ldi	r24, 0xB8	; 184
   12cfe:	9e e0       	ldi	r25, 0x0E	; 14
   12d00:	64 e1       	ldi	r22, 0x14	; 20
   12d02:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <AddSpaceLead>
		  AddSpaceLead(strRef2,20);
   12d06:	86 ec       	ldi	r24, 0xC6	; 198
   12d08:	9d e0       	ldi	r25, 0x0D	; 13
   12d0a:	64 e1       	ldi	r22, 0x14	; 20
   12d0c:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <AddSpaceLead>
		  AddSpaceLead(strRef3,20);
   12d10:	82 ed       	ldi	r24, 0xD2	; 210
   12d12:	9a e0       	ldi	r25, 0x0A	; 10
   12d14:	64 e1       	ldi	r22, 0x14	; 20
   12d16:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <AddSpaceLead>
		  AddSpaceLead(strRef4,20);
   12d1a:	85 ed       	ldi	r24, 0xD5	; 213
   12d1c:	95 e0       	ldi	r25, 0x05	; 5
   12d1e:	64 e1       	ldi	r22, 0x14	; 20
   12d20:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <AddSpaceLead>
		  iWait=0;
   12d24:	10 92 44 03 	sts	0x0344, r1
		  IsMessage09=False;
   12d28:	10 92 ba 01 	sts	0x01BA, r1
		  stChangeMOP=cmSendMessage32;	      
   12d2c:	87 e1       	ldi	r24, 0x17	; 23
   12d2e:	4b ce       	rjmp	.-874    	; 0x129c6 <FMenuChangeMOP+0x3ee>
	      break;
     case cmSendMessage32://SendMessage32
	      sendMessage32();
   12d30:	0e 94 eb 4f 	call	0x9fd6	; 0x9fd6 <sendMessage32>
		  iLoop=0;
   12d34:	10 92 36 03 	sts	0x0336, r1
   12d38:	10 92 35 03 	sts	0x0335, r1
		  iPos=0;
   12d3c:	10 92 45 03 	sts	0x0345, r1
		  lcd_printf(3,1,PSTR("Please Wait"));
   12d40:	83 e0       	ldi	r24, 0x03	; 3
   12d42:	61 e0       	ldi	r22, 0x01	; 1
   12d44:	44 e0       	ldi	r20, 0x04	; 4
   12d46:	58 e1       	ldi	r21, 0x18	; 24
   12d48:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  stChangeMOP=cmWaitReplyMessage;	      
   12d4c:	88 e1       	ldi	r24, 0x18	; 24
   12d4e:	3b ce       	rjmp	.-906    	; 0x129c6 <FMenuChangeMOP+0x3ee>
	      break;
     case cmWaitReplyMessage:
          iLoop++;
   12d50:	80 91 35 03 	lds	r24, 0x0335
   12d54:	90 91 36 03 	lds	r25, 0x0336
   12d58:	01 96       	adiw	r24, 0x01	; 1
   12d5a:	90 93 36 03 	sts	0x0336, r25
   12d5e:	80 93 35 03 	sts	0x0335, r24
		  if ((iLoop%MSG_WAIT_TIMOUT)==0){
   12d62:	68 e9       	ldi	r22, 0x98	; 152
   12d64:	7a e3       	ldi	r23, 0x3A	; 58
   12d66:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
   12d6a:	89 2b       	or	r24, r25
   12d6c:	19 f5       	brne	.+70     	; 0x12db4 <FMenuChangeMOP+0x7dc>
			 if (iPos<5){
   12d6e:	60 91 45 03 	lds	r22, 0x0345
   12d72:	65 30       	cpi	r22, 0x05	; 5
   12d74:	68 f4       	brcc	.+26     	; 0x12d90 <FMenuChangeMOP+0x7b8>
				 lcd_xy(3,(13+iPos));_lcd('.');
   12d76:	63 5f       	subi	r22, 0xF3	; 243
   12d78:	83 e0       	ldi	r24, 0x03	; 3
   12d7a:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
   12d7e:	8e e2       	ldi	r24, 0x2E	; 46
   12d80:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
				 iPos++;
   12d84:	80 91 45 03 	lds	r24, 0x0345
   12d88:	8f 5f       	subi	r24, 0xFF	; 255
   12d8a:	80 93 45 03 	sts	0x0345, r24
   12d8e:	12 c0       	rjmp	.+36     	; 0x12db4 <FMenuChangeMOP+0x7dc>
				}
			 else{
				 iPos=0;
   12d90:	10 92 45 03 	sts	0x0345, r1
				 lcd_printf(3,(13+iPos),PSTR("       "));
   12d94:	83 e0       	ldi	r24, 0x03	; 3
   12d96:	6d e0       	ldi	r22, 0x0D	; 13
   12d98:	4c ef       	ldi	r20, 0xFC	; 252
   12d9a:	57 e1       	ldi	r21, 0x17	; 23
   12d9c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				 //Resend Message32
				 if (iWait<5)stChangeMOP=cmSendMessage32;
   12da0:	90 91 44 03 	lds	r25, 0x0344
   12da4:	95 30       	cpi	r25, 0x05	; 5
   12da6:	18 f4       	brcc	.+6      	; 0x12dae <FMenuChangeMOP+0x7d6>
   12da8:	87 e1       	ldi	r24, 0x17	; 23
   12daa:	80 93 47 03 	sts	0x0347, r24
				iWait++;
   12dae:	9f 5f       	subi	r25, 0xFF	; 255
   12db0:	90 93 44 03 	sts	0x0344, r25
				}
		  }
		  if (iWait>5)stChangeMOP=cmNoReply;
   12db4:	80 91 44 03 	lds	r24, 0x0344
   12db8:	86 30       	cpi	r24, 0x06	; 6
   12dba:	18 f0       	brcs	.+6      	; 0x12dc2 <FMenuChangeMOP+0x7ea>
   12dbc:	8a e1       	ldi	r24, 0x1A	; 26
   12dbe:	80 93 47 03 	sts	0x0347, r24
		  if (IsMessage09==True)stChangeMOP=cmDisplayFreeMessage;
   12dc2:	80 91 ba 01 	lds	r24, 0x01BA
   12dc6:	81 30       	cpi	r24, 0x01	; 1
   12dc8:	19 f4       	brne	.+6      	; 0x12dd0 <FMenuChangeMOP+0x7f8>
   12dca:	89 e1       	ldi	r24, 0x19	; 25
   12dcc:	80 93 47 03 	sts	0x0347, r24
		  if (IsMessage99==True)stChangeMOP=cmFinishChangeMOP;
   12dd0:	80 91 b6 01 	lds	r24, 0x01B6
   12dd4:	81 30       	cpi	r24, 0x01	; 1
   12dd6:	f1 f5       	brne	.+124    	; 0x12e54 <FMenuChangeMOP+0x87c>
   12dd8:	37 c0       	rjmp	.+110    	; 0x12e48 <FMenuChangeMOP+0x870>
		  break;
     case cmDisplayFreeMessage:
	      IsMessage09=False;
   12dda:	10 92 ba 01 	sts	0x01BA, r1
	      msgResult=procMessage09();
   12dde:	0e 94 38 17 	call	0x2e70	; 0x2e70 <procMessage09>
		  lcd_clear();
   12de2:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
   12de6:	81 e0       	ldi	r24, 0x01	; 1
   12de8:	61 e0       	ldi	r22, 0x01	; 1
   12dea:	47 ee       	ldi	r20, 0xE7	; 231
   12dec:	5a e0       	ldi	r21, 0x0A	; 10
   12dee:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   12df2:	82 e0       	ldi	r24, 0x02	; 2
   12df4:	61 e0       	ldi	r22, 0x01	; 1
   12df6:	46 ed       	ldi	r20, 0xD6	; 214
   12df8:	59 e0       	ldi	r21, 0x09	; 9
   12dfa:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
   12dfe:	83 e0       	ldi	r24, 0x03	; 3
   12e00:	61 e0       	ldi	r22, 0x01	; 1
   12e02:	41 e7       	ldi	r20, 0x71	; 113
   12e04:	5a e0       	ldi	r21, 0x0A	; 10
   12e06:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
   12e0a:	84 e0       	ldi	r24, 0x04	; 4
   12e0c:	61 e0       	ldi	r22, 0x01	; 1
   12e0e:	41 e0       	ldi	r20, 0x01	; 1
   12e10:	5e e0       	ldi	r21, 0x0E	; 14
   12e12:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
   12e16:	0e c0       	rjmp	.+28     	; 0x12e34 <FMenuChangeMOP+0x85c>
		  TimDisplay=0;
          stChangeMOP=cmDelayMOP;
	      break;
     case cmNoReply:
	      lcd_clear();
   12e18:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(2,1,PSTR("No Reply    "));
   12e1c:	82 e0       	ldi	r24, 0x02	; 2
   12e1e:	61 e0       	ldi	r22, 0x01	; 1
   12e20:	4f ee       	ldi	r20, 0xEF	; 239
   12e22:	57 e1       	ldi	r21, 0x17	; 23
   12e24:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	      lcd_printf(3,1,PSTR("TCP/IP Error"));
   12e28:	83 e0       	ldi	r24, 0x03	; 3
   12e2a:	61 e0       	ldi	r22, 0x01	; 1
   12e2c:	42 ee       	ldi	r20, 0xE2	; 226
   12e2e:	57 e1       	ldi	r21, 0x17	; 23
   12e30:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  TimDisplay=0;
   12e34:	10 92 a7 01 	sts	0x01A7, r1
          stChangeMOP=cmDelayMOP;
   12e38:	8b e1       	ldi	r24, 0x1B	; 27
   12e3a:	c5 cd       	rjmp	.-1142   	; 0x129c6 <FMenuChangeMOP+0x3ee>
	      break;
     case cmDelayMOP:
	      if (TimDisplay>9)stChangeMOP=cmExitChangeMOP;
   12e3c:	80 91 a7 01 	lds	r24, 0x01A7
   12e40:	8a 30       	cpi	r24, 0x0A	; 10
   12e42:	40 f0       	brcs	.+16     	; 0x12e54 <FMenuChangeMOP+0x87c>
   12e44:	8c e1       	ldi	r24, 0x1C	; 28
   12e46:	bf cd       	rjmp	.-1154   	; 0x129c6 <FMenuChangeMOP+0x3ee>
	      break;
     case cmExitChangeMOP:
	      stChangeMOP=cmFinishChangeMOP;
   12e48:	8d e1       	ldi	r24, 0x1D	; 29
   12e4a:	bd cd       	rjmp	.-1158   	; 0x129c6 <FMenuChangeMOP+0x3ee>
	      break;
     case cmFinishChangeMOP:
	      stChangeMOP=cmInit;
   12e4c:	10 92 47 03 	sts	0x0347, r1
   12e50:	81 e0       	ldi	r24, 0x01	; 1
   12e52:	01 c0       	rjmp	.+2      	; 0x12e56 <FMenuChangeMOP+0x87e>
   12e54:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   12e56:	a3 96       	adiw	r28, 0x23	; 35
   12e58:	0f b6       	in	r0, 0x3f	; 63
   12e5a:	f8 94       	cli
   12e5c:	de bf       	out	0x3e, r29	; 62
   12e5e:	0f be       	out	0x3f, r0	; 63
   12e60:	cd bf       	out	0x3d, r28	; 61
   12e62:	cf 91       	pop	r28
   12e64:	df 91       	pop	r29
   12e66:	1f 91       	pop	r17
   12e68:	0f 91       	pop	r16
   12e6a:	ff 90       	pop	r15
   12e6c:	ef 90       	pop	r14
   12e6e:	df 90       	pop	r13
   12e70:	cf 90       	pop	r12
   12e72:	bf 90       	pop	r11
   12e74:	af 90       	pop	r10
   12e76:	08 95       	ret

00012e78 <SetBaudRate>:
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
	 IsFreePrinting=True;
}

void SetBaudRate(char ComAddr,char brMap){//Com1..Com4
   12e78:	28 2f       	mov	r18, r24
   12e7a:	96 2f       	mov	r25, r22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
   12e7c:	81 50       	subi	r24, 0x01	; 1
   12e7e:	82 30       	cpi	r24, 0x02	; 2
   12e80:	b8 f4       	brcc	.+46     	; 0x12eb0 <SetBaudRate+0x38>
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   12e82:	62 30       	cpi	r22, 0x02	; 2
   12e84:	59 f0       	breq	.+22     	; 0x12e9c <SetBaudRate+0x24>
   12e86:	62 30       	cpi	r22, 0x02	; 2
   12e88:	18 f0       	brcs	.+6      	; 0x12e90 <SetBaudRate+0x18>
   12e8a:	63 30       	cpi	r22, 0x03	; 3
   12e8c:	21 f4       	brne	.+8      	; 0x12e96 <SetBaudRate+0x1e>
   12e8e:	09 c0       	rjmp	.+18     	; 0x12ea2 <SetBaudRate+0x2a>
   12e90:	40 e8       	ldi	r20, 0x80	; 128
   12e92:	55 e2       	ldi	r21, 0x25	; 37
   12e94:	08 c0       	rjmp	.+16     	; 0x12ea6 <SetBaudRate+0x2e>
   12e96:	40 e0       	ldi	r20, 0x00	; 0
   12e98:	50 e0       	ldi	r21, 0x00	; 0
   12e9a:	05 c0       	rjmp	.+10     	; 0x12ea6 <SetBaudRate+0x2e>
   12e9c:	40 e0       	ldi	r20, 0x00	; 0
   12e9e:	5b e4       	ldi	r21, 0x4B	; 75
   12ea0:	02 c0       	rjmp	.+4      	; 0x12ea6 <SetBaudRate+0x2e>
   12ea2:	4b e9       	ldi	r20, 0x9B	; 155
   12ea4:	56 e1       	ldi	r21, 0x16	; 22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
	     brValue=GetBaudrate(brMap);
	      _uart_init((ComAddr-1),brValue);
   12ea6:	60 e0       	ldi	r22, 0x00	; 0
   12ea8:	70 e0       	ldi	r23, 0x00	; 0
   12eaa:	0e 94 3c b2 	call	0x16478	; 0x16478 <_uart_init>
   12eae:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
   12eb0:	82 2f       	mov	r24, r18
   12eb2:	83 50       	subi	r24, 0x03	; 3
   12eb4:	82 30       	cpi	r24, 0x02	; 2
   12eb6:	a8 f4       	brcc	.+42     	; 0x12ee2 <SetBaudRate+0x6a>
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
   12eb8:	9f 70       	andi	r25, 0x0F	; 15
   12eba:	62 2f       	mov	r22, r18
   12ebc:	62 95       	swap	r22
   12ebe:	60 7f       	andi	r22, 0xF0	; 240
   12ec0:	69 2b       	or	r22, r25
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
   12ec2:	80 91 93 01 	lds	r24, 0x0193
   12ec6:	88 23       	and	r24, r24
   12ec8:	49 f0       	breq	.+18     	; 0x12edc <SetBaudRate+0x64>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
   12eca:	86 e0       	ldi	r24, 0x06	; 6
   12ecc:	80 93 da 07 	sts	0x07DA, r24
	 PoolMsg=plMsg;
   12ed0:	60 93 fe 0d 	sts	0x0DFE, r22
     IsControlPooling=True;
   12ed4:	81 e0       	ldi	r24, 0x01	; 1
   12ed6:	80 93 97 01 	sts	0x0197, r24
   12eda:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
		 else SendSlaveCommand(SC_BAUDRATE,brMessage);
   12edc:	86 e0       	ldi	r24, 0x06	; 6
   12ede:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
   12ee2:	08 95       	ret

00012ee4 <FSettingSystem>:
	      break;
	 }
     return Result;
}

char FSettingSystem(){
   12ee4:	af 92       	push	r10
   12ee6:	bf 92       	push	r11
   12ee8:	cf 92       	push	r12
   12eea:	df 92       	push	r13
   12eec:	ef 92       	push	r14
   12eee:	ff 92       	push	r15
   12ef0:	0f 93       	push	r16
   12ef2:	1f 93       	push	r17
   12ef4:	df 93       	push	r29
   12ef6:	cf 93       	push	r28
   12ef8:	cd b7       	in	r28, 0x3d	; 61
   12efa:	de b7       	in	r29, 0x3e	; 62
   12efc:	64 97       	sbiw	r28, 0x14	; 20
   12efe:	0f b6       	in	r0, 0x3f	; 63
   12f00:	f8 94       	cli
   12f02:	de bf       	out	0x3e, r29	; 62
   12f04:	0f be       	out	0x3f, r0	; 63
   12f06:	cd bf       	out	0x3d, r28	; 61
       char SubMenu,Result=MENU_NONE;
	   char HGMode;
       char lcdteks[20];
	   int bValue;

     switch(stSettingSytem){
   12f08:	80 91 e0 02 	lds	r24, 0x02E0
   12f0c:	82 30       	cpi	r24, 0x02	; 2
   12f0e:	09 f4       	brne	.+2      	; 0x12f12 <FSettingSystem+0x2e>
   12f10:	cf c0       	rjmp	.+414    	; 0x130b0 <FSettingSystem+0x1cc>
   12f12:	83 30       	cpi	r24, 0x03	; 3
   12f14:	30 f4       	brcc	.+12     	; 0x12f22 <FSettingSystem+0x3e>
   12f16:	88 23       	and	r24, r24
   12f18:	71 f0       	breq	.+28     	; 0x12f36 <FSettingSystem+0x52>
   12f1a:	81 30       	cpi	r24, 0x01	; 1
   12f1c:	09 f0       	breq	.+2      	; 0x12f20 <FSettingSystem+0x3c>
   12f1e:	6f c1       	rjmp	.+734    	; 0x131fe <FSettingSystem+0x31a>
   12f20:	7f c0       	rjmp	.+254    	; 0x13020 <FSettingSystem+0x13c>
   12f22:	84 30       	cpi	r24, 0x04	; 4
   12f24:	09 f4       	brne	.+2      	; 0x12f28 <FSettingSystem+0x44>
   12f26:	60 c1       	rjmp	.+704    	; 0x131e8 <FSettingSystem+0x304>
   12f28:	84 30       	cpi	r24, 0x04	; 4
   12f2a:	08 f4       	brcc	.+2      	; 0x12f2e <FSettingSystem+0x4a>
   12f2c:	2b c1       	rjmp	.+598    	; 0x13184 <FSettingSystem+0x2a0>
   12f2e:	85 30       	cpi	r24, 0x05	; 5
   12f30:	09 f0       	breq	.+2      	; 0x12f34 <FSettingSystem+0x50>
   12f32:	65 c1       	rjmp	.+714    	; 0x131fe <FSettingSystem+0x31a>
   12f34:	60 c1       	rjmp	.+704    	; 0x131f6 <FSettingSystem+0x312>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12f36:	e1 99       	sbic	0x1c, 1	; 28
   12f38:	fe cf       	rjmp	.-4      	; 0x12f36 <FSettingSystem+0x52>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12f3a:	86 e3       	ldi	r24, 0x36	; 54
   12f3c:	91 e0       	ldi	r25, 0x01	; 1
   12f3e:	9f bb       	out	0x1f, r25	; 31
   12f40:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12f42:	e0 9a       	sbi	0x1c, 0	; 28
   12f44:	2d b3       	in	r18, 0x1d	; 29
	 case ssInitSettingSystem:
	      IFType=eeprom_read_byte(&DefInitIFT);
   12f46:	20 93 10 01 	sts	0x0110, r18
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12f4a:	e1 99       	sbic	0x1c, 1	; 28
   12f4c:	fe cf       	rjmp	.-4      	; 0x12f4a <FSettingSystem+0x66>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12f4e:	82 ec       	ldi	r24, 0xC2	; 194
   12f50:	93 e0       	ldi	r25, 0x03	; 3
   12f52:	9f bb       	out	0x1f, r25	; 31
   12f54:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12f56:	e0 9a       	sbi	0x1c, 0	; 28
   12f58:	1d b3       	in	r17, 0x1d	; 29
		  HGMode=eeprom_read_byte(&DefHGMode);

	      if (IFType==IT_NONE)sprintf_P(lcdteks,PSTR("1.Mode:None"));
   12f5a:	22 23       	and	r18, r18
   12f5c:	69 f4       	brne	.+26     	; 0x12f78 <FSettingSystem+0x94>
   12f5e:	00 d0       	rcall	.+0      	; 0x12f60 <FSettingSystem+0x7c>
   12f60:	00 d0       	rcall	.+0      	; 0x12f62 <FSettingSystem+0x7e>
   12f62:	ce 01       	movw	r24, r28
   12f64:	01 96       	adiw	r24, 0x01	; 1
   12f66:	ad b7       	in	r26, 0x3d	; 61
   12f68:	be b7       	in	r27, 0x3e	; 62
   12f6a:	12 96       	adiw	r26, 0x02	; 2
   12f6c:	9c 93       	st	X, r25
   12f6e:	8e 93       	st	-X, r24
   12f70:	11 97       	sbiw	r26, 0x01	; 1
   12f72:	8d e2       	ldi	r24, 0x2D	; 45
   12f74:	9e e0       	ldi	r25, 0x0E	; 14
   12f76:	1d c0       	rjmp	.+58     	; 0x12fb2 <FSettingSystem+0xce>
		  else
	      if (IFType==IT_SLAVE)sprintf_P(lcdteks,PSTR("1.Mode:Slave"));
   12f78:	21 30       	cpi	r18, 0x01	; 1
   12f7a:	69 f4       	brne	.+26     	; 0x12f96 <FSettingSystem+0xb2>
   12f7c:	00 d0       	rcall	.+0      	; 0x12f7e <FSettingSystem+0x9a>
   12f7e:	00 d0       	rcall	.+0      	; 0x12f80 <FSettingSystem+0x9c>
   12f80:	ce 01       	movw	r24, r28
   12f82:	01 96       	adiw	r24, 0x01	; 1
   12f84:	ed b7       	in	r30, 0x3d	; 61
   12f86:	fe b7       	in	r31, 0x3e	; 62
   12f88:	92 83       	std	Z+2, r25	; 0x02
   12f8a:	81 83       	std	Z+1, r24	; 0x01
   12f8c:	80 e2       	ldi	r24, 0x20	; 32
   12f8e:	9e e0       	ldi	r25, 0x0E	; 14
   12f90:	94 83       	std	Z+4, r25	; 0x04
   12f92:	83 83       	std	Z+3, r24	; 0x03
   12f94:	12 c0       	rjmp	.+36     	; 0x12fba <FSettingSystem+0xd6>
		  else
	      if (IFType==IT_STANDALONE)sprintf_P(lcdteks,PSTR("1.Mode:Standalone"));
   12f96:	22 30       	cpi	r18, 0x02	; 2
   12f98:	b1 f4       	brne	.+44     	; 0x12fc6 <FSettingSystem+0xe2>
   12f9a:	00 d0       	rcall	.+0      	; 0x12f9c <FSettingSystem+0xb8>
   12f9c:	00 d0       	rcall	.+0      	; 0x12f9e <FSettingSystem+0xba>
   12f9e:	ce 01       	movw	r24, r28
   12fa0:	01 96       	adiw	r24, 0x01	; 1
   12fa2:	ad b7       	in	r26, 0x3d	; 61
   12fa4:	be b7       	in	r27, 0x3e	; 62
   12fa6:	12 96       	adiw	r26, 0x02	; 2
   12fa8:	9c 93       	st	X, r25
   12faa:	8e 93       	st	-X, r24
   12fac:	11 97       	sbiw	r26, 0x01	; 1
   12fae:	8e e0       	ldi	r24, 0x0E	; 14
   12fb0:	9e e0       	ldi	r25, 0x0E	; 14
   12fb2:	14 96       	adiw	r26, 0x04	; 4
   12fb4:	9c 93       	st	X, r25
   12fb6:	8e 93       	st	-X, r24
   12fb8:	13 97       	sbiw	r26, 0x03	; 3
   12fba:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   12fbe:	0f 90       	pop	r0
   12fc0:	0f 90       	pop	r0
   12fc2:	0f 90       	pop	r0
   12fc4:	0f 90       	pop	r0

	      lcd_clear();
   12fc6:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_print(1,1,lcdteks);
   12fca:	81 e0       	ldi	r24, 0x01	; 1
   12fcc:	61 e0       	ldi	r22, 0x01	; 1
   12fce:	ae 01       	movw	r20, r28
   12fd0:	4f 5f       	subi	r20, 0xFF	; 255
   12fd2:	5f 4f       	sbci	r21, 0xFF	; 255
   12fd4:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  lcd_printf(2,1,PSTR("2.Baudrate"));
   12fd8:	82 e0       	ldi	r24, 0x02	; 2
   12fda:	61 e0       	ldi	r22, 0x01	; 1
   12fdc:	43 e0       	ldi	r20, 0x03	; 3
   12fde:	5e e0       	ldi	r21, 0x0E	; 14
   12fe0:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>

		  if (HGMode==HM_TTL)lcd_printf(3,1,PSTR("3.COM3:TTL"));
   12fe4:	11 23       	and	r17, r17
   12fe6:	29 f4       	brne	.+10     	; 0x12ff2 <FSettingSystem+0x10e>
   12fe8:	83 e0       	ldi	r24, 0x03	; 3
   12fea:	61 e0       	ldi	r22, 0x01	; 1
   12fec:	48 ef       	ldi	r20, 0xF8	; 248
   12fee:	5d e0       	ldi	r21, 0x0D	; 13
   12ff0:	0d c0       	rjmp	.+26     	; 0x1300c <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_232)lcd_printf(3,1,PSTR("3.COM3:232"));
   12ff2:	11 30       	cpi	r17, 0x01	; 1
   12ff4:	29 f4       	brne	.+10     	; 0x13000 <FSettingSystem+0x11c>
   12ff6:	83 e0       	ldi	r24, 0x03	; 3
   12ff8:	61 e0       	ldi	r22, 0x01	; 1
   12ffa:	4d ee       	ldi	r20, 0xED	; 237
   12ffc:	5d e0       	ldi	r21, 0x0D	; 13
   12ffe:	06 c0       	rjmp	.+12     	; 0x1300c <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_485)lcd_printf(3,1,PSTR("3.COM3:485"));		  
   13000:	12 30       	cpi	r17, 0x02	; 2
   13002:	31 f4       	brne	.+12     	; 0x13010 <FSettingSystem+0x12c>
   13004:	83 e0       	ldi	r24, 0x03	; 3
   13006:	61 e0       	ldi	r22, 0x01	; 1
   13008:	42 ee       	ldi	r20, 0xE2	; 226
   1300a:	5d e0       	ldi	r21, 0x0D	; 13
   1300c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back      "));
   13010:	84 e0       	ldi	r24, 0x04	; 4
   13012:	61 e0       	ldi	r22, 0x01	; 1
   13014:	44 ed       	ldi	r20, 0xD4	; 212
   13016:	5d e0       	ldi	r21, 0x0D	; 13
   13018:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  stSettingSytem=ssMenuSelect;
   1301c:	81 e0       	ldi	r24, 0x01	; 1
   1301e:	e1 c0       	rjmp	.+450    	; 0x131e2 <FSettingSystem+0x2fe>
	      break;
     case ssMenuSelect:
          KeyPressed=_key_scan(1);
   13020:	81 e0       	ldi	r24, 0x01	; 1
   13022:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   13026:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
		  if (KeyChar=='1'){
   1302a:	81 33       	cpi	r24, 0x31	; 49
   1302c:	c1 f4       	brne	.+48     	; 0x1305e <FSettingSystem+0x17a>
		      IFType=((IFType+1)%3);
   1302e:	80 91 10 01 	lds	r24, 0x0110
   13032:	90 e0       	ldi	r25, 0x00	; 0
   13034:	01 96       	adiw	r24, 0x01	; 1
   13036:	63 e0       	ldi	r22, 0x03	; 3
   13038:	70 e0       	ldi	r23, 0x00	; 0
   1303a:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
   1303e:	80 93 10 01 	sts	0x0110, r24
			  SendSlaveCommand(IFType,DispenserBrand);
   13042:	60 91 61 01 	lds	r22, 0x0161
   13046:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
			  eeprom_write_byte(&DefInitIFT,IFType);
   1304a:	20 91 10 01 	lds	r18, 0x0110
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1304e:	e1 99       	sbic	0x1c, 1	; 28
   13050:	fe cf       	rjmp	.-4      	; 0x1304e <FSettingSystem+0x16a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13052:	86 e3       	ldi	r24, 0x36	; 54
   13054:	91 e0       	ldi	r25, 0x01	; 1
   13056:	9f bb       	out	0x1f, r25	; 31
   13058:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   1305a:	2d bb       	out	0x1d, r18	; 29
   1305c:	1f c0       	rjmp	.+62     	; 0x1309c <FSettingSystem+0x1b8>
			  stSettingSytem=ssInitSettingSystem;
		  }
		  else
		  if (KeyChar=='2'){
   1305e:	82 33       	cpi	r24, 0x32	; 50
   13060:	09 f4       	brne	.+2      	; 0x13064 <FSettingSystem+0x180>
   13062:	ba c0       	rjmp	.+372    	; 0x131d8 <FSettingSystem+0x2f4>
		      stSettingSytem=ssComSettings;
		  }
		  else
		  if (KeyChar=='3'){
   13064:	83 33       	cpi	r24, 0x33	; 51
   13066:	01 f5       	brne	.+64     	; 0x130a8 <FSettingSystem+0x1c4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13068:	e1 99       	sbic	0x1c, 1	; 28
   1306a:	fe cf       	rjmp	.-4      	; 0x13068 <FSettingSystem+0x184>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1306c:	e2 ec       	ldi	r30, 0xC2	; 194
   1306e:	ee 2e       	mov	r14, r30
   13070:	e3 e0       	ldi	r30, 0x03	; 3
   13072:	fe 2e       	mov	r15, r30
   13074:	ff ba       	out	0x1f, r15	; 31
   13076:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13078:	e0 9a       	sbi	0x1c, 0	; 28
   1307a:	8d b3       	in	r24, 0x1d	; 29
		      HGMode=eeprom_read_byte(&DefHGMode);
		      HGMode=((HGMode+1)%3);
   1307c:	90 e0       	ldi	r25, 0x00	; 0
   1307e:	01 96       	adiw	r24, 0x01	; 1
   13080:	63 e0       	ldi	r22, 0x03	; 3
   13082:	70 e0       	ldi	r23, 0x00	; 0
   13084:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
   13088:	18 2f       	mov	r17, r24
			  SendSlaveCommand(SC_HGM_MODE,HGMode);
   1308a:	81 e2       	ldi	r24, 0x21	; 33
   1308c:	61 2f       	mov	r22, r17
   1308e:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   13092:	e1 99       	sbic	0x1c, 1	; 28
   13094:	fe cf       	rjmp	.-4      	; 0x13092 <FSettingSystem+0x1ae>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13096:	ff ba       	out	0x1f, r15	; 31
   13098:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   1309a:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
   1309c:	0f b6       	in	r0, 0x3f	; 63
   1309e:	f8 94       	cli
   130a0:	e2 9a       	sbi	0x1c, 2	; 28
   130a2:	e1 9a       	sbi	0x1c, 1	; 28
   130a4:	0f be       	out	0x3f, r0	; 63
   130a6:	a4 c0       	rjmp	.+328    	; 0x131f0 <FSettingSystem+0x30c>
			  eeprom_write_byte(&DefHGMode,HGMode);
			  stSettingSytem=ssInitSettingSystem;
		  }
		  //else
		  if (KeyChar=='*'){
   130a8:	8a 32       	cpi	r24, 0x2A	; 42
   130aa:	09 f4       	brne	.+2      	; 0x130ae <FSettingSystem+0x1ca>
   130ac:	99 c0       	rjmp	.+306    	; 0x131e0 <FSettingSystem+0x2fc>
   130ae:	a7 c0       	rjmp	.+334    	; 0x131fe <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
   130b0:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   130b4:	81 e0       	ldi	r24, 0x01	; 1
   130b6:	61 e0       	ldi	r22, 0x01	; 1
   130b8:	4f eb       	ldi	r20, 0xBF	; 191
   130ba:	5d e0       	ldi	r21, 0x0D	; 13
   130bc:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   130c0:	01 e0       	ldi	r16, 0x01	; 1
   130c2:	10 e0       	ldi	r17, 0x00	; 0

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   130c4:	6e 01       	movw	r12, r28
   130c6:	08 94       	sec
   130c8:	c1 1c       	adc	r12, r1
   130ca:	d1 1c       	adc	r13, r1
   130cc:	76 eb       	ldi	r23, 0xB6	; 182
   130ce:	a7 2e       	mov	r10, r23
   130d0:	7d e0       	ldi	r23, 0x0D	; 13
   130d2:	b7 2e       	mov	r11, r23
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   130d4:	6b e0       	ldi	r22, 0x0B	; 11
   130d6:	e6 2e       	mov	r14, r22
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   130d8:	f0 2e       	mov	r15, r16
   130da:	fa 94       	dec	r15
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   130dc:	e1 99       	sbic	0x1c, 1	; 28
   130de:	fe cf       	rjmp	.-4      	; 0x130dc <FSettingSystem+0x1f8>
   130e0:	c8 01       	movw	r24, r16
   130e2:	81 5c       	subi	r24, 0xC1	; 193
   130e4:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   130e6:	9f bb       	out	0x1f, r25	; 31
   130e8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   130ea:	e0 9a       	sbi	0x1c, 0	; 28
   130ec:	8d b3       	in	r24, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   130ee:	82 30       	cpi	r24, 0x02	; 2
   130f0:	69 f0       	breq	.+26     	; 0x1310c <FSettingSystem+0x228>
   130f2:	82 30       	cpi	r24, 0x02	; 2
   130f4:	28 f0       	brcs	.+10     	; 0x13100 <FSettingSystem+0x21c>
   130f6:	83 30       	cpi	r24, 0x03	; 3
   130f8:	31 f4       	brne	.+12     	; 0x13106 <FSettingSystem+0x222>
   130fa:	85 eb       	ldi	r24, 0xB5	; 181
   130fc:	9f e2       	ldi	r25, 0x2F	; 47
   130fe:	08 c0       	rjmp	.+16     	; 0x13110 <FSettingSystem+0x22c>
   13100:	80 e8       	ldi	r24, 0x80	; 128
   13102:	95 e2       	ldi	r25, 0x25	; 37
   13104:	05 c0       	rjmp	.+10     	; 0x13110 <FSettingSystem+0x22c>
   13106:	80 e0       	ldi	r24, 0x00	; 0
   13108:	90 e0       	ldi	r25, 0x00	; 0
   1310a:	02 c0       	rjmp	.+4      	; 0x13110 <FSettingSystem+0x22c>
   1310c:	80 e0       	ldi	r24, 0x00	; 0
   1310e:	9b e4       	ldi	r25, 0x4B	; 75
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   13110:	ed b7       	in	r30, 0x3d	; 61
   13112:	fe b7       	in	r31, 0x3e	; 62
   13114:	38 97       	sbiw	r30, 0x08	; 8
   13116:	0f b6       	in	r0, 0x3f	; 63
   13118:	f8 94       	cli
   1311a:	fe bf       	out	0x3e, r31	; 62
   1311c:	0f be       	out	0x3f, r0	; 63
   1311e:	ed bf       	out	0x3d, r30	; 61
   13120:	31 96       	adiw	r30, 0x01	; 1
   13122:	ad b7       	in	r26, 0x3d	; 61
   13124:	be b7       	in	r27, 0x3e	; 62
   13126:	12 96       	adiw	r26, 0x02	; 2
   13128:	dc 92       	st	X, r13
   1312a:	ce 92       	st	-X, r12
   1312c:	11 97       	sbiw	r26, 0x01	; 1
   1312e:	b3 82       	std	Z+3, r11	; 0x03
   13130:	a2 82       	std	Z+2, r10	; 0x02
   13132:	15 83       	std	Z+5, r17	; 0x05
   13134:	04 83       	std	Z+4, r16	; 0x04
   13136:	97 83       	std	Z+7, r25	; 0x07
   13138:	86 83       	std	Z+6, r24	; 0x06
   1313a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   1313e:	ed b7       	in	r30, 0x3d	; 61
   13140:	fe b7       	in	r31, 0x3e	; 62
   13142:	38 96       	adiw	r30, 0x08	; 8
   13144:	0f b6       	in	r0, 0x3f	; 63
   13146:	f8 94       	cli
   13148:	fe bf       	out	0x3e, r31	; 62
   1314a:	0f be       	out	0x3f, r0	; 63
   1314c:	ed bf       	out	0x3d, r30	; 61
   1314e:	6f 2d       	mov	r22, r15
   13150:	66 95       	lsr	r22
   13152:	6e 9d       	mul	r22, r14
   13154:	b0 01       	movw	r22, r0
   13156:	11 24       	eor	r1, r1
   13158:	6f 5f       	subi	r22, 0xFF	; 255
   1315a:	f1 e0       	ldi	r31, 0x01	; 1
   1315c:	ff 22       	and	r15, r31
   1315e:	8f 2d       	mov	r24, r15
   13160:	8e 5f       	subi	r24, 0xFE	; 254
   13162:	a6 01       	movw	r20, r12
   13164:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
   13168:	0f 5f       	subi	r16, 0xFF	; 255
   1316a:	1f 4f       	sbci	r17, 0xFF	; 255
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
   1316c:	05 30       	cpi	r16, 0x05	; 5
   1316e:	11 05       	cpc	r17, r1
   13170:	09 f0       	breq	.+2      	; 0x13174 <FSettingSystem+0x290>
   13172:	b2 cf       	rjmp	.-156    	; 0x130d8 <FSettingSystem+0x1f4>
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
		  }
		  lcd_printf(4,1,PSTR("[*]Back     "));
   13174:	84 e0       	ldi	r24, 0x04	; 4
   13176:	61 e0       	ldi	r22, 0x01	; 1
   13178:	49 ea       	ldi	r20, 0xA9	; 169
   1317a:	5d e0       	ldi	r21, 0x0D	; 13
   1317c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  stSettingSytem=ssBaudrateInput;
   13180:	83 e0       	ldi	r24, 0x03	; 3
   13182:	2f c0       	rjmp	.+94     	; 0x131e2 <FSettingSystem+0x2fe>
	      break;
     case ssBaudrateInput:
	      KeyPressed=_key_scan(1);
   13184:	81 e0       	ldi	r24, 0x01	; 1
   13186:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   1318a:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   1318e:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   13190:	81 53       	subi	r24, 0x31	; 49
   13192:	84 30       	cpi	r24, 0x04	; 4
   13194:	18 f5       	brcc	.+70     	; 0x131dc <FSettingSystem+0x2f8>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13196:	e1 99       	sbic	0x1c, 1	; 28
   13198:	fe cf       	rjmp	.-4      	; 0x13196 <FSettingSystem+0x2b2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1319a:	02 2f       	mov	r16, r18
   1319c:	10 e0       	ldi	r17, 0x00	; 0
   1319e:	01 5f       	subi	r16, 0xF1	; 241
   131a0:	1e 4f       	sbci	r17, 0xFE	; 254
   131a2:	1f bb       	out	0x1f, r17	; 31
   131a4:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   131a6:	e0 9a       	sbi	0x1c, 0	; 28
   131a8:	8d b3       	in	r24, 0x1d	; 29
		       brVal=eeprom_read_byte(&DefBaudrate[KeyChar-'1']);
			   brVal=((brVal+1)%3)+1;
   131aa:	90 e0       	ldi	r25, 0x00	; 0
   131ac:	01 96       	adiw	r24, 0x01	; 1
   131ae:	63 e0       	ldi	r22, 0x03	; 3
   131b0:	70 e0       	ldi	r23, 0x00	; 0
   131b2:	0e 94 21 b7 	call	0x16e42	; 0x16e42 <__divmodhi4>
   131b6:	f8 2e       	mov	r15, r24
   131b8:	f3 94       	inc	r15
			   SetBaudRate(KeyChar-'0',brVal);
   131ba:	82 2f       	mov	r24, r18
   131bc:	80 53       	subi	r24, 0x30	; 48
   131be:	6f 2d       	mov	r22, r15
   131c0:	0e 94 3c 97 	call	0x12e78	; 0x12e78 <SetBaudRate>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   131c4:	e1 99       	sbic	0x1c, 1	; 28
   131c6:	fe cf       	rjmp	.-4      	; 0x131c4 <FSettingSystem+0x2e0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   131c8:	1f bb       	out	0x1f, r17	; 31
   131ca:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   131cc:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
   131ce:	0f b6       	in	r0, 0x3f	; 63
   131d0:	f8 94       	cli
   131d2:	e2 9a       	sbi	0x1c, 2	; 28
   131d4:	e1 9a       	sbi	0x1c, 1	; 28
   131d6:	0f be       	out	0x3f, r0	; 63
			   eeprom_write_byte(&DefBaudrate[KeyChar-'1'],brVal);
               stSettingSytem=ssComSettings;
   131d8:	82 e0       	ldi	r24, 0x02	; 2
   131da:	03 c0       	rjmp	.+6      	; 0x131e2 <FSettingSystem+0x2fe>
		  }else if (KeyChar=='*')
   131dc:	2a 32       	cpi	r18, 0x2A	; 42
   131de:	79 f4       	brne	.+30     	; 0x131fe <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;		  	
   131e0:	85 e0       	ldi	r24, 0x05	; 5
   131e2:	80 93 e0 02 	sts	0x02E0, r24
   131e6:	0b c0       	rjmp	.+22     	; 0x131fe <FSettingSystem+0x31a>
	      break;
	 case ssPumpPoolingSettings:
          SubMenu=FSettingPumpPooling();
   131e8:	0e 94 08 6e 	call	0xdc10	; 0xdc10 <FSettingPumpPooling>
		  if (SubMenu==MENU_DONE)stSettingSytem=ssInitSettingSystem;
   131ec:	81 30       	cpi	r24, 0x01	; 1
   131ee:	39 f4       	brne	.+14     	; 0x131fe <FSettingSystem+0x31a>
   131f0:	10 92 e0 02 	sts	0x02E0, r1
   131f4:	04 c0       	rjmp	.+8      	; 0x131fe <FSettingSystem+0x31a>
	      break;
     case ssExitSystemSettings:
	      stSettingSytem=ssInitSettingSystem;
   131f6:	10 92 e0 02 	sts	0x02E0, r1
   131fa:	81 e0       	ldi	r24, 0x01	; 1
   131fc:	01 c0       	rjmp	.+2      	; 0x13200 <FSettingSystem+0x31c>
   131fe:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
   13200:	64 96       	adiw	r28, 0x14	; 20
   13202:	0f b6       	in	r0, 0x3f	; 63
   13204:	f8 94       	cli
   13206:	de bf       	out	0x3e, r29	; 62
   13208:	0f be       	out	0x3f, r0	; 63
   1320a:	cd bf       	out	0x3d, r28	; 61
   1320c:	cf 91       	pop	r28
   1320e:	df 91       	pop	r29
   13210:	1f 91       	pop	r17
   13212:	0f 91       	pop	r16
   13214:	ff 90       	pop	r15
   13216:	ef 90       	pop	r14
   13218:	df 90       	pop	r13
   1321a:	cf 90       	pop	r12
   1321c:	bf 90       	pop	r11
   1321e:	af 90       	pop	r10
   13220:	08 95       	ret

00013222 <FMenuSettings>:


char FMenuSettings(){
char Result=MENU_NONE;
static char stMenuSettings=msInit,PageSetting=1,KeyPressed,KeyChar,SubMenu;
     switch(stMenuSettings){
   13222:	80 91 f3 02 	lds	r24, 0x02F3
   13226:	e8 2f       	mov	r30, r24
   13228:	f0 e0       	ldi	r31, 0x00	; 0
   1322a:	e3 31       	cpi	r30, 0x13	; 19
   1322c:	f1 05       	cpc	r31, r1
   1322e:	08 f0       	brcs	.+2      	; 0x13232 <FMenuSettings+0x10>
   13230:	cd c0       	rjmp	.+410    	; 0x133cc <FMenuSettings+0x1aa>
   13232:	ee 51       	subi	r30, 0x1E	; 30
   13234:	ff 4f       	sbci	r31, 0xFF	; 255
   13236:	ee 0f       	add	r30, r30
   13238:	ff 1f       	adc	r31, r31
   1323a:	05 90       	lpm	r0, Z+
   1323c:	f4 91       	lpm	r31, Z+
   1323e:	e0 2d       	mov	r30, r0
   13240:	09 94       	ijmp
	 case msInit:
		  lcd_clear();
   13242:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		  PageSetting=1;
   13246:	81 e0       	ldi	r24, 0x01	; 1
   13248:	80 93 57 01 	sts	0x0157, r24
   1324c:	b7 c0       	rjmp	.+366    	; 0x133bc <FMenuSettings+0x19a>
		  stMenuSettings=msDisplayPage;
		  break;
	 case msDisplayPage:
	      stMenuSettings=msDisplayPage+PageSetting;
   1324e:	80 91 57 01 	lds	r24, 0x0157
   13252:	8f 5f       	subi	r24, 0xFF	; 255
   13254:	b3 c0       	rjmp	.+358    	; 0x133bc <FMenuSettings+0x19a>
          break; 	 
	 case msDisplayPage1:
		  lcd_printf(1, 1, PSTR("1)Product  5)Printer"));
   13256:	81 e0       	ldi	r24, 0x01	; 1
   13258:	61 e0       	ldi	r22, 0x01	; 1
   1325a:	45 e6       	ldi	r20, 0x65	; 101
   1325c:	52 e1       	ldi	r21, 0x12	; 18
   1325e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)Pump     6)Host   "));
   13262:	82 e0       	ldi	r24, 0x02	; 2
   13264:	61 e0       	ldi	r22, 0x01	; 1
   13266:	40 e5       	ldi	r20, 0x50	; 80
   13268:	52 e1       	ldi	r21, 0x12	; 18
   1326a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)Decimal  7)Next   "));
   1326e:	83 e0       	ldi	r24, 0x03	; 3
   13270:	61 e0       	ldi	r22, 0x01	; 1
   13272:	4b e3       	ldi	r20, 0x3B	; 59
   13274:	52 e1       	ldi	r21, 0x12	; 18
   13276:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4, 1, PSTR("4)Datetime *)Exit   "));
   1327a:	84 e0       	ldi	r24, 0x04	; 4
   1327c:	61 e0       	ldi	r22, 0x01	; 1
   1327e:	46 e2       	ldi	r20, 0x26	; 38
   13280:	52 e1       	ldi	r21, 0x12	; 18
   13282:	16 c0       	rjmp	.+44     	; 0x132b0 <FMenuSettings+0x8e>
		  stMenuSettings=msSelection;
	      break;
	 case msDisplayPage2:
		  lcd_printf(1, 1, PSTR("1)Operator          "));
   13284:	81 e0       	ldi	r24, 0x01	; 1
   13286:	61 e0       	ldi	r22, 0x01	; 1
   13288:	41 e1       	ldi	r20, 0x11	; 17
   1328a:	52 e1       	ldi	r21, 0x12	; 18
   1328c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)System            "));
   13290:	82 e0       	ldi	r24, 0x02	; 2
   13292:	61 e0       	ldi	r22, 0x01	; 1
   13294:	4c ef       	ldi	r20, 0xFC	; 252
   13296:	51 e1       	ldi	r21, 0x11	; 17
   13298:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)PumpPooling       "));
   1329c:	83 e0       	ldi	r24, 0x03	; 3
   1329e:	61 e0       	ldi	r22, 0x01	; 1
   132a0:	47 ee       	ldi	r20, 0xE7	; 231
   132a2:	51 e1       	ldi	r21, 0x11	; 17
   132a4:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  lcd_printf(4, 1, PSTR("*)Back              "));
   132a8:	84 e0       	ldi	r24, 0x04	; 4
   132aa:	61 e0       	ldi	r22, 0x01	; 1
   132ac:	42 ed       	ldi	r20, 0xD2	; 210
   132ae:	51 e1       	ldi	r21, 0x11	; 17
   132b0:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  stMenuSettings=msSelection;
   132b4:	84 e0       	ldi	r24, 0x04	; 4
   132b6:	82 c0       	rjmp	.+260    	; 0x133bc <FMenuSettings+0x19a>
	      break;
	 case msSelection:
	      stMenuSettings=msSelection+PageSetting;
   132b8:	80 91 57 01 	lds	r24, 0x0157
   132bc:	8c 5f       	subi	r24, 0xFC	; 252
   132be:	7e c0       	rjmp	.+252    	; 0x133bc <FMenuSettings+0x19a>
          break;	 
	 case msSelectionPage1:
		  KeyPressed=_key_scan(1);
   132c0:	81 e0       	ldi	r24, 0x01	; 1
   132c2:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   132c6:	80 93 f2 02 	sts	0x02F2, r24
		  KeyChar=_key_btn(KeyPressed);
   132ca:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   132ce:	80 93 f1 02 	sts	0x02F1, r24
		  switch(KeyChar){
   132d2:	84 33       	cpi	r24, 0x34	; 52
   132d4:	d1 f0       	breq	.+52     	; 0x1330a <FMenuSettings+0xe8>
   132d6:	85 33       	cpi	r24, 0x35	; 53
   132d8:	50 f4       	brcc	.+20     	; 0x132ee <FMenuSettings+0xcc>
   132da:	82 33       	cpi	r24, 0x32	; 50
   132dc:	91 f0       	breq	.+36     	; 0x13302 <FMenuSettings+0xe0>
   132de:	83 33       	cpi	r24, 0x33	; 51
   132e0:	90 f4       	brcc	.+36     	; 0x13306 <FMenuSettings+0xe4>
   132e2:	8a 32       	cpi	r24, 0x2A	; 42
   132e4:	d1 f0       	breq	.+52     	; 0x1331a <FMenuSettings+0xf8>
   132e6:	81 33       	cpi	r24, 0x31	; 49
   132e8:	09 f0       	breq	.+2      	; 0x132ec <FMenuSettings+0xca>
   132ea:	70 c0       	rjmp	.+224    	; 0x133cc <FMenuSettings+0x1aa>
   132ec:	08 c0       	rjmp	.+16     	; 0x132fe <FMenuSettings+0xdc>
   132ee:	86 33       	cpi	r24, 0x36	; 54
   132f0:	81 f0       	breq	.+32     	; 0x13312 <FMenuSettings+0xf0>
   132f2:	86 33       	cpi	r24, 0x36	; 54
   132f4:	60 f0       	brcs	.+24     	; 0x1330e <FMenuSettings+0xec>
   132f6:	87 33       	cpi	r24, 0x37	; 55
   132f8:	09 f0       	breq	.+2      	; 0x132fc <FMenuSettings+0xda>
   132fa:	68 c0       	rjmp	.+208    	; 0x133cc <FMenuSettings+0x1aa>
   132fc:	0c c0       	rjmp	.+24     	; 0x13316 <FMenuSettings+0xf4>
		  case '1':
		       stMenuSettings=msMenuSettingProduct;
   132fe:	89 e0       	ldi	r24, 0x09	; 9
   13300:	5d c0       	rjmp	.+186    	; 0x133bc <FMenuSettings+0x19a>
		       break;
		  case '2': 
		       stMenuSettings=msMenuSettingPump;
   13302:	8a e0       	ldi	r24, 0x0A	; 10
   13304:	5b c0       	rjmp	.+182    	; 0x133bc <FMenuSettings+0x19a>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingDec;
   13306:	8b e0       	ldi	r24, 0x0B	; 11
   13308:	59 c0       	rjmp	.+178    	; 0x133bc <FMenuSettings+0x19a>
		       break;
		  case '4':
		       stMenuSettings=msMenuSettingDatetime;
   1330a:	8c e0       	ldi	r24, 0x0C	; 12
   1330c:	57 c0       	rjmp	.+174    	; 0x133bc <FMenuSettings+0x19a>
		       break;
		  case '5':
		       stMenuSettings=msMenuSettingPrinter;
   1330e:	8d e0       	ldi	r24, 0x0D	; 13
   13310:	55 c0       	rjmp	.+170    	; 0x133bc <FMenuSettings+0x19a>
		       break;
		  case '6':
		       stMenuSettings=msMenuSettingHost;
   13312:	8e e0       	ldi	r24, 0x0E	; 14
   13314:	53 c0       	rjmp	.+166    	; 0x133bc <FMenuSettings+0x19a>
		       break;
		  case '7':
		       stMenuSettings=msMenuSettingNextPage;
   13316:	87 e0       	ldi	r24, 0x07	; 7
   13318:	51 c0       	rjmp	.+162    	; 0x133bc <FMenuSettings+0x19a>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingExit;
   1331a:	82 e1       	ldi	r24, 0x12	; 18
   1331c:	4f c0       	rjmp	.+158    	; 0x133bc <FMenuSettings+0x19a>
		       break;			   
		  }
	      break;
	 case msSelectionPage2:
	 	  KeyPressed=_key_scan(1);
   1331e:	81 e0       	ldi	r24, 0x01	; 1
   13320:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   13324:	80 93 f2 02 	sts	0x02F2, r24
		  KeyChar=_key_btn(KeyPressed);
   13328:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   1332c:	80 93 f1 02 	sts	0x02F1, r24
		  switch(KeyChar){
   13330:	82 33       	cpi	r24, 0x32	; 50
   13332:	71 f0       	breq	.+28     	; 0x13350 <FMenuSettings+0x12e>
   13334:	83 33       	cpi	r24, 0x33	; 51
   13336:	30 f4       	brcc	.+12     	; 0x13344 <FMenuSettings+0x122>
   13338:	8a 32       	cpi	r24, 0x2A	; 42
   1333a:	71 f0       	breq	.+28     	; 0x13358 <FMenuSettings+0x136>
   1333c:	81 33       	cpi	r24, 0x31	; 49
   1333e:	09 f0       	breq	.+2      	; 0x13342 <FMenuSettings+0x120>
   13340:	45 c0       	rjmp	.+138    	; 0x133cc <FMenuSettings+0x1aa>
   13342:	04 c0       	rjmp	.+8      	; 0x1334c <FMenuSettings+0x12a>
   13344:	83 33       	cpi	r24, 0x33	; 51
   13346:	09 f0       	breq	.+2      	; 0x1334a <FMenuSettings+0x128>
   13348:	41 c0       	rjmp	.+130    	; 0x133cc <FMenuSettings+0x1aa>
   1334a:	04 c0       	rjmp	.+8      	; 0x13354 <FMenuSettings+0x132>
		  case '1':
		       stMenuSettings=msMenuSettingOperator;
   1334c:	8f e0       	ldi	r24, 0x0F	; 15
   1334e:	36 c0       	rjmp	.+108    	; 0x133bc <FMenuSettings+0x19a>
		       break;
		  case '2':
		       stMenuSettings=msMenuSettingSystem;
   13350:	80 e1       	ldi	r24, 0x10	; 16
   13352:	34 c0       	rjmp	.+104    	; 0x133bc <FMenuSettings+0x19a>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingPumpPooling;
   13354:	81 e1       	ldi	r24, 0x11	; 17
   13356:	32 c0       	rjmp	.+100    	; 0x133bc <FMenuSettings+0x19a>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingBackPage;
   13358:	88 e0       	ldi	r24, 0x08	; 8
   1335a:	30 c0       	rjmp	.+96     	; 0x133bc <FMenuSettings+0x19a>
		       break;		  
		  }
	      break;
		  
	 case msMenuSettingNextPage:
	      if (PageSetting<2)PageSetting++;
   1335c:	80 91 57 01 	lds	r24, 0x0157
   13360:	82 30       	cpi	r24, 0x02	; 2
   13362:	48 f4       	brcc	.+18     	; 0x13376 <FMenuSettings+0x154>
   13364:	8f 5f       	subi	r24, 0xFF	; 255
   13366:	05 c0       	rjmp	.+10     	; 0x13372 <FMenuSettings+0x150>
		  stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingBackPage:
	      if (PageSetting>1)PageSetting--;
   13368:	80 91 57 01 	lds	r24, 0x0157
   1336c:	82 30       	cpi	r24, 0x02	; 2
   1336e:	18 f0       	brcs	.+6      	; 0x13376 <FMenuSettings+0x154>
   13370:	81 50       	subi	r24, 0x01	; 1
   13372:	80 93 57 01 	sts	0x0157, r24
		  stMenuSettings=msDisplayPage;
   13376:	81 e0       	ldi	r24, 0x01	; 1
   13378:	21 c0       	rjmp	.+66     	; 0x133bc <FMenuSettings+0x19a>
	      break;
//---Sub Menu Operations--------------------------------------------		  
     case msMenuSettingProduct:
	      SubMenu=FSettingProduct();
   1337a:	0e 94 76 88 	call	0x110ec	; 0x110ec <FSettingProduct>
   1337e:	1a c0       	rjmp	.+52     	; 0x133b4 <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingPump:
	      SubMenu=FSettingPump();
   13380:	0e 94 1b 76 	call	0xec36	; 0xec36 <FSettingPump>
   13384:	17 c0       	rjmp	.+46     	; 0x133b4 <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingDec:
	      SubMenu=FSettingDec();
   13386:	0e 94 32 81 	call	0x10264	; 0x10264 <FSettingDec>
   1338a:	14 c0       	rjmp	.+40     	; 0x133b4 <FMenuSettings+0x192>
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
   1338c:	0e 94 d8 61 	call	0xc3b0	; 0xc3b0 <_menu_datetime>
   13390:	05 c0       	rjmp	.+10     	; 0x1339c <FMenuSettings+0x17a>
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
   13392:	0e 94 2c 4a 	call	0x9458	; 0x9458 <_menu_printer>
   13396:	02 c0       	rjmp	.+4      	; 0x1339c <FMenuSettings+0x17a>
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
   13398:	0e 94 e2 42 	call	0x85c4	; 0x85c4 <_menu_host>
	 case msMenuSettingPrinter: 
	      SubMenu=FSettingPrinter();
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingHost:
	      SubMenu=FSettingHost();
   1339c:	81 e0       	ldi	r24, 0x01	; 1
   1339e:	80 93 f0 02 	sts	0x02F0, r24
   133a2:	0c c0       	rjmp	.+24     	; 0x133bc <FMenuSettings+0x19a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
     case msMenuSettingOperator:
          SubMenu=FSettingOperator();
   133a4:	0e 94 8f 85 	call	0x10b1e	; 0x10b1e <FSettingOperator>
   133a8:	05 c0       	rjmp	.+10     	; 0x133b4 <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingSystem:
	      SubMenu=FSettingSystem();
   133aa:	0e 94 72 97 	call	0x12ee4	; 0x12ee4 <FSettingSystem>
   133ae:	02 c0       	rjmp	.+4      	; 0x133b4 <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;	 
     case msMenuSettingPumpPooling:
	      SubMenu=FSettingPumpPooling();
   133b0:	0e 94 08 6e 	call	0xdc10	; 0xdc10 <FSettingPumpPooling>
   133b4:	80 93 f0 02 	sts	0x02F0, r24
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
   133b8:	81 30       	cpi	r24, 0x01	; 1
   133ba:	41 f4       	brne	.+16     	; 0x133cc <FMenuSettings+0x1aa>
   133bc:	80 93 f3 02 	sts	0x02F3, r24
   133c0:	80 e0       	ldi	r24, 0x00	; 0
   133c2:	08 95       	ret
	      break;
//------------------------------------------------------------------
     case msMenuSettingExit:
	      stMenuSettings=msInit;
   133c4:	10 92 f3 02 	sts	0x02F3, r1
   133c8:	81 e0       	ldi	r24, 0x01	; 1
   133ca:	08 95       	ret
   133cc:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   133ce:	08 95       	ret

000133d0 <FMenuAuthorization>:


char FMenuAuthorization(){
char Result=MENU_NONE,PassResult=MP_NONE,SubMenu=MENU_NONE;
static char stMenuAuthorization=maInit,PassTry=0;
     switch(stMenuAuthorization){
   133d0:	80 91 32 03 	lds	r24, 0x0332
   133d4:	83 30       	cpi	r24, 0x03	; 3
   133d6:	69 f1       	breq	.+90     	; 0x13432 <FMenuAuthorization+0x62>
   133d8:	84 30       	cpi	r24, 0x04	; 4
   133da:	28 f4       	brcc	.+10     	; 0x133e6 <FMenuAuthorization+0x16>
   133dc:	81 30       	cpi	r24, 0x01	; 1
   133de:	89 f0       	breq	.+34     	; 0x13402 <FMenuAuthorization+0x32>
   133e0:	82 30       	cpi	r24, 0x02	; 2
   133e2:	50 f5       	brcc	.+84     	; 0x13438 <FMenuAuthorization+0x68>
   133e4:	0b c0       	rjmp	.+22     	; 0x133fc <FMenuAuthorization+0x2c>
   133e6:	85 30       	cpi	r24, 0x05	; 5
   133e8:	79 f1       	breq	.+94     	; 0x13448 <FMenuAuthorization+0x78>
   133ea:	85 30       	cpi	r24, 0x05	; 5
   133ec:	40 f1       	brcs	.+80     	; 0x1343e <FMenuAuthorization+0x6e>
   133ee:	86 30       	cpi	r24, 0x06	; 6
   133f0:	09 f4       	brne	.+2      	; 0x133f4 <FMenuAuthorization+0x24>
   133f2:	41 c0       	rjmp	.+130    	; 0x13476 <FMenuAuthorization+0xa6>
   133f4:	87 30       	cpi	r24, 0x07	; 7
   133f6:	09 f0       	breq	.+2      	; 0x133fa <FMenuAuthorization+0x2a>
   133f8:	51 c0       	rjmp	.+162    	; 0x1349c <FMenuAuthorization+0xcc>
   133fa:	4c c0       	rjmp	.+152    	; 0x13494 <FMenuAuthorization+0xc4>
	 case maInit:
	      PassTry=0;
   133fc:	10 92 31 03 	sts	0x0331, r1
   13400:	42 c0       	rjmp	.+132    	; 0x13486 <FMenuAuthorization+0xb6>
		  stMenuAuthorization=maInputPassword;
	      break;
	 case maInputPassword:
	      PassResult=FMenuPassword();
   13402:	0e 94 7e 90 	call	0x120fc	; 0x120fc <FMenuPassword>
		  switch(PassResult){
   13406:	83 30       	cpi	r24, 0x03	; 3
   13408:	09 f4       	brne	.+2      	; 0x1340c <FMenuAuthorization+0x3c>
   1340a:	40 c0       	rjmp	.+128    	; 0x1348c <FMenuAuthorization+0xbc>
   1340c:	84 30       	cpi	r24, 0x04	; 4
   1340e:	30 f4       	brcc	.+12     	; 0x1341c <FMenuAuthorization+0x4c>
   13410:	81 30       	cpi	r24, 0x01	; 1
   13412:	d9 f1       	breq	.+118    	; 0x1348a <FMenuAuthorization+0xba>
   13414:	82 30       	cpi	r24, 0x02	; 2
   13416:	09 f0       	breq	.+2      	; 0x1341a <FMenuAuthorization+0x4a>
   13418:	41 c0       	rjmp	.+130    	; 0x1349c <FMenuAuthorization+0xcc>
   1341a:	09 c0       	rjmp	.+18     	; 0x1342e <FMenuAuthorization+0x5e>
   1341c:	84 30       	cpi	r24, 0x04	; 4
   1341e:	19 f0       	breq	.+6      	; 0x13426 <FMenuAuthorization+0x56>
   13420:	85 30       	cpi	r24, 0x05	; 5
   13422:	e1 f5       	brne	.+120    	; 0x1349c <FMenuAuthorization+0xcc>
   13424:	02 c0       	rjmp	.+4      	; 0x1342a <FMenuAuthorization+0x5a>
		  case MP_VALID_ADMIN:
		       stMenuAuthorization=maMenuAdmin;
   13426:	82 e0       	ldi	r24, 0x02	; 2
   13428:	31 c0       	rjmp	.+98     	; 0x1348c <FMenuAuthorization+0xbc>
		       break;
		  case MP_VALID_SYSTEM:
		       stMenuAuthorization=maMenuSettings;
   1342a:	84 e0       	ldi	r24, 0x04	; 4
   1342c:	2f c0       	rjmp	.+94     	; 0x1348c <FMenuAuthorization+0xbc>
		       break;
		  case MP_INVALID:
		       stMenuAuthorization=maInvalidAuthorization;
   1342e:	85 e0       	ldi	r24, 0x05	; 5
   13430:	2d c0       	rjmp	.+90     	; 0x1348c <FMenuAuthorization+0xbc>
		  else
	      if (PassResult==MP_CANCEL)stMenuAuthorization=maExitAuthorization;
		  */
	      break;
	 case maMenuMaster:
	      SubMenu=FMenuMaster();
   13432:	0e 94 67 8e 	call	0x11cce	; 0x11cce <FMenuMaster>
   13436:	05 c0       	rjmp	.+10     	; 0x13442 <FMenuAuthorization+0x72>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
	      break;
	 case maMenuAdmin:
          SubMenu=FMenuAdmin();
   13438:	0e 94 77 92 	call	0x124ee	; 0x124ee <FMenuAdmin>
   1343c:	02 c0       	rjmp	.+4      	; 0x13442 <FMenuAuthorization+0x72>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;          
		  break;
	 case maMenuSettings:
	      SubMenu=FMenuSettings();
   1343e:	0e 94 11 99 	call	0x13222	; 0x13222 <FMenuSettings>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
   13442:	81 30       	cpi	r24, 0x01	; 1
   13444:	59 f5       	brne	.+86     	; 0x1349c <FMenuAuthorization+0xcc>
   13446:	21 c0       	rjmp	.+66     	; 0x1348a <FMenuAuthorization+0xba>
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
   13448:	80 91 31 03 	lds	r24, 0x0331
   1344c:	8f 5f       	subi	r24, 0xFF	; 255
   1344e:	80 93 31 03 	sts	0x0331, r24
	      TimDisplay=0;
   13452:	10 92 a7 01 	sts	0x01A7, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   13456:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   13458:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1345a:	81 e0       	ldi	r24, 0x01	; 1
   1345c:	90 e0       	ldi	r25, 0x00	; 0
   1345e:	90 93 d7 01 	sts	0x01D7, r25
   13462:	80 93 d6 01 	sts	0x01D6, r24
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
	      TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   13466:	83 e0       	ldi	r24, 0x03	; 3
   13468:	61 e0       	ldi	r22, 0x01	; 1
   1346a:	44 ed       	ldi	r20, 0xD4	; 212
   1346c:	57 e1       	ldi	r21, 0x17	; 23
   1346e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		  stMenuAuthorization=maDelayExitAuthorization;
   13472:	86 e0       	ldi	r24, 0x06	; 6
   13474:	0b c0       	rjmp	.+22     	; 0x1348c <FMenuAuthorization+0xbc>
          break;	 
	 case maDelayExitAuthorization:
	      if (TimDisplay>2){
   13476:	80 91 a7 01 	lds	r24, 0x01A7
   1347a:	83 30       	cpi	r24, 0x03	; 3
   1347c:	78 f0       	brcs	.+30     	; 0x1349c <FMenuAuthorization+0xcc>
		      if (PassTry<3)stMenuAuthorization=maInputPassword;
   1347e:	80 91 31 03 	lds	r24, 0x0331
   13482:	83 30       	cpi	r24, 0x03	; 3
   13484:	10 f4       	brcc	.+4      	; 0x1348a <FMenuAuthorization+0xba>
   13486:	81 e0       	ldi	r24, 0x01	; 1
   13488:	01 c0       	rjmp	.+2      	; 0x1348c <FMenuAuthorization+0xbc>
			  else stMenuAuthorization=maExitAuthorization;
   1348a:	87 e0       	ldi	r24, 0x07	; 7
   1348c:	80 93 32 03 	sts	0x0332, r24
   13490:	80 e0       	ldi	r24, 0x00	; 0
   13492:	08 95       	ret
		  }
	      break;
	 case maExitAuthorization:
	      stMenuAuthorization=maInit;
   13494:	10 92 32 03 	sts	0x0332, r1
   13498:	81 e0       	ldi	r24, 0x01	; 1
   1349a:	08 95       	ret
   1349c:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;	 
}
   1349e:	08 95       	ret

000134a0 <InitComport>:
     	  break;	 
	 }
   return Result;
}

void InitComport(){
   134a0:	af 92       	push	r10
   134a2:	bf 92       	push	r11
   134a4:	cf 92       	push	r12
   134a6:	df 92       	push	r13
   134a8:	ff 92       	push	r15
   134aa:	0f 93       	push	r16
   134ac:	1f 93       	push	r17
   134ae:	df 93       	push	r29
   134b0:	cf 93       	push	r28
   134b2:	cd b7       	in	r28, 0x3d	; 61
   134b4:	de b7       	in	r29, 0x3e	; 62
   134b6:	64 97       	sbiw	r28, 0x14	; 20
   134b8:	0f b6       	in	r0, 0x3f	; 63
   134ba:	f8 94       	cli
   134bc:	de bf       	out	0x3e, r29	; 62
   134be:	0f be       	out	0x3f, r0	; 63
   134c0:	cd bf       	out	0x3d, r28	; 61
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
   134c2:	83 e0       	ldi	r24, 0x03	; 3
   134c4:	61 e0       	ldi	r22, 0x01	; 1
   134c6:	48 e6       	ldi	r20, 0x68	; 104
   134c8:	5c e1       	ldi	r21, 0x1C	; 28
   134ca:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   134ce:	01 e0       	ldi	r16, 0x01	; 1
   134d0:	10 e0       	ldi	r17, 0x00	; 0
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   134d2:	6e 01       	movw	r12, r28
   134d4:	08 94       	sec
   134d6:	c1 1c       	adc	r12, r1
   134d8:	d1 1c       	adc	r13, r1
   134da:	f4 e5       	ldi	r31, 0x54	; 84
   134dc:	af 2e       	mov	r10, r31
   134de:	fc e1       	ldi	r31, 0x1C	; 28
   134e0:	bf 2e       	mov	r11, r31
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   134e2:	e1 99       	sbic	0x1c, 1	; 28
   134e4:	fe cf       	rjmp	.-4      	; 0x134e2 <InitComport+0x42>
   134e6:	c8 01       	movw	r24, r16
   134e8:	81 5c       	subi	r24, 0xC1	; 193
   134ea:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   134ec:	9f bb       	out	0x1f, r25	; 31
   134ee:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   134f0:	e0 9a       	sbi	0x1c, 0	; 28
   134f2:	fd b2       	in	r15, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   134f4:	22 e0       	ldi	r18, 0x02	; 2
   134f6:	f2 16       	cp	r15, r18
   134f8:	71 f0       	breq	.+28     	; 0x13516 <InitComport+0x76>
   134fa:	f2 16       	cp	r15, r18
   134fc:	30 f0       	brcs	.+12     	; 0x1350a <InitComport+0x6a>
   134fe:	33 e0       	ldi	r19, 0x03	; 3
   13500:	f3 16       	cp	r15, r19
   13502:	31 f4       	brne	.+12     	; 0x13510 <InitComport+0x70>
   13504:	85 eb       	ldi	r24, 0xB5	; 181
   13506:	9f e2       	ldi	r25, 0x2F	; 47
   13508:	08 c0       	rjmp	.+16     	; 0x1351a <InitComport+0x7a>
   1350a:	80 e8       	ldi	r24, 0x80	; 128
   1350c:	95 e2       	ldi	r25, 0x25	; 37
   1350e:	05 c0       	rjmp	.+10     	; 0x1351a <InitComport+0x7a>
   13510:	80 e0       	ldi	r24, 0x00	; 0
   13512:	90 e0       	ldi	r25, 0x00	; 0
   13514:	02 c0       	rjmp	.+4      	; 0x1351a <InitComport+0x7a>
   13516:	80 e0       	ldi	r24, 0x00	; 0
   13518:	9b e4       	ldi	r25, 0x4B	; 75
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   1351a:	ad b7       	in	r26, 0x3d	; 61
   1351c:	be b7       	in	r27, 0x3e	; 62
   1351e:	18 97       	sbiw	r26, 0x08	; 8
   13520:	0f b6       	in	r0, 0x3f	; 63
   13522:	f8 94       	cli
   13524:	be bf       	out	0x3e, r27	; 62
   13526:	0f be       	out	0x3f, r0	; 63
   13528:	ad bf       	out	0x3d, r26	; 61
   1352a:	ed b7       	in	r30, 0x3d	; 61
   1352c:	fe b7       	in	r31, 0x3e	; 62
   1352e:	31 96       	adiw	r30, 0x01	; 1
   13530:	12 96       	adiw	r26, 0x02	; 2
   13532:	dc 92       	st	X, r13
   13534:	ce 92       	st	-X, r12
   13536:	11 97       	sbiw	r26, 0x01	; 1
   13538:	b3 82       	std	Z+3, r11	; 0x03
   1353a:	a2 82       	std	Z+2, r10	; 0x02
   1353c:	15 83       	std	Z+5, r17	; 0x05
   1353e:	04 83       	std	Z+4, r16	; 0x04
   13540:	97 83       	std	Z+7, r25	; 0x07
   13542:	86 83       	std	Z+6, r24	; 0x06
   13544:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		 lcd_print(4,1,lcdteks);
   13548:	2d b7       	in	r18, 0x3d	; 61
   1354a:	3e b7       	in	r19, 0x3e	; 62
   1354c:	28 5f       	subi	r18, 0xF8	; 248
   1354e:	3f 4f       	sbci	r19, 0xFF	; 255
   13550:	0f b6       	in	r0, 0x3f	; 63
   13552:	f8 94       	cli
   13554:	3e bf       	out	0x3e, r19	; 62
   13556:	0f be       	out	0x3f, r0	; 63
   13558:	2d bf       	out	0x3d, r18	; 61
   1355a:	84 e0       	ldi	r24, 0x04	; 4
   1355c:	61 e0       	ldi	r22, 0x01	; 1
   1355e:	a6 01       	movw	r20, r12
   13560:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		 SetBaudRate(i+1,brMap);
   13564:	80 2f       	mov	r24, r16
   13566:	6f 2d       	mov	r22, r15
   13568:	0e 94 3c 97 	call	0x12e78	; 0x12e78 <SetBaudRate>
 	     TimDisplay=0;
   1356c:	10 92 a7 01 	sts	0x01A7, r1
   13570:	04 c0       	rjmp	.+8      	; 0x1357a <InitComport+0xda>
	     while(TimDisplay<2){
		     if (TimDisplay>2)break;
   13572:	80 91 a7 01 	lds	r24, 0x01A7
   13576:	83 30       	cpi	r24, 0x03	; 3
   13578:	20 f4       	brcc	.+8      	; 0x13582 <InitComport+0xe2>
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
		 lcd_print(4,1,lcdteks);
		 SetBaudRate(i+1,brMap);
 	     TimDisplay=0;
	     while(TimDisplay<2){
   1357a:	80 91 a7 01 	lds	r24, 0x01A7
   1357e:	82 30       	cpi	r24, 0x02	; 2
   13580:	c0 f3       	brcs	.-16     	; 0x13572 <InitComport+0xd2>
   13582:	0f 5f       	subi	r16, 0xFF	; 255
   13584:	1f 4f       	sbci	r17, 0xFF	; 255

void InitComport(){
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
   13586:	05 30       	cpi	r16, 0x05	; 5
   13588:	11 05       	cpc	r17, r1
   1358a:	09 f0       	breq	.+2      	; 0x1358e <InitComport+0xee>
   1358c:	aa cf       	rjmp	.-172    	; 0x134e2 <InitComport+0x42>
	     while(TimDisplay<2){
		     if (TimDisplay>2)break;
		 };

	 }
}
   1358e:	64 96       	adiw	r28, 0x14	; 20
   13590:	0f b6       	in	r0, 0x3f	; 63
   13592:	f8 94       	cli
   13594:	de bf       	out	0x3e, r29	; 62
   13596:	0f be       	out	0x3f, r0	; 63
   13598:	cd bf       	out	0x3d, r28	; 61
   1359a:	cf 91       	pop	r28
   1359c:	df 91       	pop	r29
   1359e:	1f 91       	pop	r17
   135a0:	0f 91       	pop	r16
   135a2:	ff 90       	pop	r15
   135a4:	df 90       	pop	r13
   135a6:	cf 90       	pop	r12
   135a8:	bf 90       	pop	r11
   135aa:	af 90       	pop	r10
   135ac:	08 95       	ret

000135ae <sendMessage56>:
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);

}

void sendMessage56(){
   135ae:	0f 93       	push	r16
   135b0:	1f 93       	push	r17
   135b2:	df 93       	push	r29
   135b4:	cf 93       	push	r28
   135b6:	cd b7       	in	r28, 0x3d	; 61
   135b8:	de b7       	in	r29, 0x3e	; 62
   135ba:	ec 97       	sbiw	r28, 0x3c	; 60
   135bc:	0f b6       	in	r0, 0x3f	; 63
   135be:	f8 94       	cli
   135c0:	de bf       	out	0x3e, r29	; 62
   135c2:	0f be       	out	0x3f, r0	; 63
   135c4:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
   135c6:	81 e0       	ldi	r24, 0x01	; 1
   135c8:	61 e0       	ldi	r22, 0x01	; 1
   135ca:	41 e0       	ldi	r20, 0x01	; 1
   135cc:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
   135d0:	0e 94 f0 1b 	call	0x37e0	; 0x37e0 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
   135d4:	0e 94 c5 1b 	call	0x378a	; 0x378a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
   135d8:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
   135dc:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateServerIP>
	UpdateCardID();  //ReadCardID
   135e0:	0e 94 ce 3c 	call	0x799c	; 0x799c <UpdateCardID>

	sprintf_P(strSend,PSTR("%s%s%s"),strIFT_ID,strSeqNum,strClientIP);
   135e4:	8d b7       	in	r24, 0x3d	; 61
   135e6:	9e b7       	in	r25, 0x3e	; 62
   135e8:	0a 97       	sbiw	r24, 0x0a	; 10
   135ea:	0f b6       	in	r0, 0x3f	; 63
   135ec:	f8 94       	cli
   135ee:	9e bf       	out	0x3e, r25	; 62
   135f0:	0f be       	out	0x3f, r0	; 63
   135f2:	8d bf       	out	0x3d, r24	; 61
   135f4:	ed b7       	in	r30, 0x3d	; 61
   135f6:	fe b7       	in	r31, 0x3e	; 62
   135f8:	31 96       	adiw	r30, 0x01	; 1
   135fa:	8e 01       	movw	r16, r28
   135fc:	0f 5f       	subi	r16, 0xFF	; 255
   135fe:	1f 4f       	sbci	r17, 0xFF	; 255
   13600:	ad b7       	in	r26, 0x3d	; 61
   13602:	be b7       	in	r27, 0x3e	; 62
   13604:	12 96       	adiw	r26, 0x02	; 2
   13606:	1c 93       	st	X, r17
   13608:	0e 93       	st	-X, r16
   1360a:	11 97       	sbiw	r26, 0x01	; 1
   1360c:	86 e2       	ldi	r24, 0x26	; 38
   1360e:	91 e2       	ldi	r25, 0x21	; 33
   13610:	93 83       	std	Z+3, r25	; 0x03
   13612:	82 83       	std	Z+2, r24	; 0x02
   13614:	8c e1       	ldi	r24, 0x1C	; 28
   13616:	96 e0       	ldi	r25, 0x06	; 6
   13618:	95 83       	std	Z+5, r25	; 0x05
   1361a:	84 83       	std	Z+4, r24	; 0x04
   1361c:	8b ef       	ldi	r24, 0xFB	; 251
   1361e:	9d e0       	ldi	r25, 0x0D	; 13
   13620:	97 83       	std	Z+7, r25	; 0x07
   13622:	86 83       	std	Z+6, r24	; 0x06
   13624:	8e e0       	ldi	r24, 0x0E	; 14
   13626:	9a e0       	ldi	r25, 0x0A	; 10
   13628:	91 87       	std	Z+9, r25	; 0x09
   1362a:	80 87       	std	Z+8, r24	; 0x08
   1362c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
   13630:	8d b7       	in	r24, 0x3d	; 61
   13632:	9e b7       	in	r25, 0x3e	; 62
   13634:	0a 96       	adiw	r24, 0x0a	; 10
   13636:	0f b6       	in	r0, 0x3f	; 63
   13638:	f8 94       	cli
   1363a:	9e bf       	out	0x3e, r25	; 62
   1363c:	0f be       	out	0x3f, r0	; 63
   1363e:	8d bf       	out	0x3d, r24	; 61
   13640:	81 e0       	ldi	r24, 0x01	; 1
   13642:	60 e0       	ldi	r22, 0x00	; 0
   13644:	a8 01       	movw	r20, r16
   13646:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
	sprintf_P(strSend,PSTR("%s56"),strServerIP);
   1364a:	00 d0       	rcall	.+0      	; 0x1364c <sendMessage56+0x9e>
   1364c:	00 d0       	rcall	.+0      	; 0x1364e <sendMessage56+0xa0>
   1364e:	00 d0       	rcall	.+0      	; 0x13650 <sendMessage56+0xa2>
   13650:	ed b7       	in	r30, 0x3d	; 61
   13652:	fe b7       	in	r31, 0x3e	; 62
   13654:	31 96       	adiw	r30, 0x01	; 1
   13656:	ad b7       	in	r26, 0x3d	; 61
   13658:	be b7       	in	r27, 0x3e	; 62
   1365a:	12 96       	adiw	r26, 0x02	; 2
   1365c:	1c 93       	st	X, r17
   1365e:	0e 93       	st	-X, r16
   13660:	11 97       	sbiw	r26, 0x01	; 1
   13662:	81 e2       	ldi	r24, 0x21	; 33
   13664:	91 e2       	ldi	r25, 0x21	; 33
   13666:	93 83       	std	Z+3, r25	; 0x03
   13668:	82 83       	std	Z+2, r24	; 0x02
   1366a:	8b e3       	ldi	r24, 0x3B	; 59
   1366c:	9a e0       	ldi	r25, 0x0A	; 10
   1366e:	95 83       	std	Z+5, r25	; 0x05
   13670:	84 83       	std	Z+4, r24	; 0x04
   13672:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);
   13676:	8d b7       	in	r24, 0x3d	; 61
   13678:	9e b7       	in	r25, 0x3e	; 62
   1367a:	06 96       	adiw	r24, 0x06	; 6
   1367c:	0f b6       	in	r0, 0x3f	; 63
   1367e:	f8 94       	cli
   13680:	9e bf       	out	0x3e, r25	; 62
   13682:	0f be       	out	0x3f, r0	; 63
   13684:	8d bf       	out	0x3d, r24	; 61
   13686:	81 e0       	ldi	r24, 0x01	; 1
   13688:	60 e0       	ldi	r22, 0x00	; 0
   1368a:	a8 01       	movw	r20, r16
   1368c:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
    sprintf_P(strSend,PSTR("%s"),strCardID);
   13690:	00 d0       	rcall	.+0      	; 0x13692 <sendMessage56+0xe4>
   13692:	00 d0       	rcall	.+0      	; 0x13694 <sendMessage56+0xe6>
   13694:	00 d0       	rcall	.+0      	; 0x13696 <sendMessage56+0xe8>
   13696:	ed b7       	in	r30, 0x3d	; 61
   13698:	fe b7       	in	r31, 0x3e	; 62
   1369a:	31 96       	adiw	r30, 0x01	; 1
   1369c:	ad b7       	in	r26, 0x3d	; 61
   1369e:	be b7       	in	r27, 0x3e	; 62
   136a0:	12 96       	adiw	r26, 0x02	; 2
   136a2:	1c 93       	st	X, r17
   136a4:	0e 93       	st	-X, r16
   136a6:	11 97       	sbiw	r26, 0x01	; 1
   136a8:	8e e1       	ldi	r24, 0x1E	; 30
   136aa:	91 e2       	ldi	r25, 0x21	; 33
   136ac:	93 83       	std	Z+3, r25	; 0x03
   136ae:	82 83       	std	Z+2, r24	; 0x02
   136b0:	81 eb       	ldi	r24, 0xB1	; 177
   136b2:	9d e0       	ldi	r25, 0x0D	; 13
   136b4:	95 83       	std	Z+5, r25	; 0x05
   136b6:	84 83       	std	Z+4, r24	; 0x04
   136b8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
    _uart_print(1, 0,strSend);	
   136bc:	8d b7       	in	r24, 0x3d	; 61
   136be:	9e b7       	in	r25, 0x3e	; 62
   136c0:	06 96       	adiw	r24, 0x06	; 6
   136c2:	0f b6       	in	r0, 0x3f	; 63
   136c4:	f8 94       	cli
   136c6:	9e bf       	out	0x3e, r25	; 62
   136c8:	0f be       	out	0x3f, r0	; 63
   136ca:	8d bf       	out	0x3d, r24	; 61
   136cc:	81 e0       	ldi	r24, 0x01	; 1
   136ce:	60 e0       	ldi	r22, 0x00	; 0
   136d0:	a8 01       	movw	r20, r16
   136d2:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>

	_uart_printf(1,0,PSTR("AF968CFFB"));
   136d6:	81 e0       	ldi	r24, 0x01	; 1
   136d8:	60 e0       	ldi	r22, 0x00	; 0
   136da:	44 e1       	ldi	r20, 0x14	; 20
   136dc:	51 e2       	ldi	r21, 0x21	; 33
   136de:	0e 94 94 b2 	call	0x16528	; 0x16528 <_uart_printf>
	_uart(1, 1,0x02);
   136e2:	81 e0       	ldi	r24, 0x01	; 1
   136e4:	61 e0       	ldi	r22, 0x01	; 1
   136e6:	42 e0       	ldi	r20, 0x02	; 2
   136e8:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
}
   136ec:	ec 96       	adiw	r28, 0x3c	; 60
   136ee:	0f b6       	in	r0, 0x3f	; 63
   136f0:	f8 94       	cli
   136f2:	de bf       	out	0x3e, r29	; 62
   136f4:	0f be       	out	0x3f, r0	; 63
   136f6:	cd bf       	out	0x3d, r28	; 61
   136f8:	cf 91       	pop	r28
   136fa:	df 91       	pop	r29
   136fc:	1f 91       	pop	r17
   136fe:	0f 91       	pop	r16
   13700:	08 95       	ret

00013702 <FMenuLocalAccount>:
		 }
	 else PORTG=PORTG|0x02;
}


char FMenuLocalAccount(){
   13702:	af 92       	push	r10
   13704:	bf 92       	push	r11
   13706:	cf 92       	push	r12
   13708:	df 92       	push	r13
   1370a:	ef 92       	push	r14
   1370c:	ff 92       	push	r15
   1370e:	0f 93       	push	r16
   13710:	1f 93       	push	r17
   13712:	df 93       	push	r29
   13714:	cf 93       	push	r28
   13716:	cd b7       	in	r28, 0x3d	; 61
   13718:	de b7       	in	r29, 0x3e	; 62
   1371a:	a9 97       	sbiw	r28, 0x29	; 41
   1371c:	0f b6       	in	r0, 0x3f	; 63
   1371e:	f8 94       	cli
   13720:	de bf       	out	0x3e, r29	; 62
   13722:	0f be       	out	0x3f, r0	; 63
   13724:	cd bf       	out	0x3d, r28	; 61
       char strName[21];//,strPumpL[3],strPumpR[3];
       char Result;

	   Result=MENU_NONE;
	                                 //|   Local Account   |          
	       switch(stLocalAccount){   //|ID: ACD12345       |
   13726:	80 91 5c 01 	lds	r24, 0x015C
   1372a:	90 e0       	ldi	r25, 0x00	; 0
   1372c:	fc 01       	movw	r30, r24
   1372e:	31 97       	sbiw	r30, 0x01	; 1
   13730:	ef 31       	cpi	r30, 0x1F	; 31
   13732:	f1 05       	cpc	r31, r1
   13734:	10 f0       	brcs	.+4      	; 0x1373a <FMenuLocalAccount+0x38>
   13736:	0c 94 ad a5 	jmp	0x14b5a	; 0x14b5a <FMenuLocalAccount+0x1458>
   1373a:	eb 50       	subi	r30, 0x0B	; 11
   1373c:	ff 4f       	sbci	r31, 0xFF	; 255
   1373e:	ee 0f       	add	r30, r30
   13740:	ff 1f       	adc	r31, r31
   13742:	05 90       	lpm	r0, Z+
   13744:	f4 91       	lpm	r31, Z+
   13746:	e0 2d       	mov	r30, r0
   13748:	09 94       	ijmp
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
   1374a:	81 e0       	ldi	r24, 0x01	; 1
   1374c:	80 93 bf 03 	sts	0x03BF, r24
   13750:	10 92 c0 03 	sts	0x03C0, r1
   13754:	80 91 65 00 	lds	r24, 0x0065
   13758:	8d 7f       	andi	r24, 0xFD	; 253
   1375a:	80 93 65 00 	sts	0x0065, r24
   1375e:	20 e0       	ldi	r18, 0x00	; 0
   13760:	30 e0       	ldi	r19, 0x00	; 0
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   13762:	f9 01       	movw	r30, r18
   13764:	ef 54       	subi	r30, 0x4F	; 79
   13766:	f2 4f       	sbci	r31, 0xF2	; 242
   13768:	d9 01       	movw	r26, r18
   1376a:	a4 58       	subi	r26, 0x84	; 132
   1376c:	b1 4f       	sbci	r27, 0xF1	; 241
   1376e:	8c 91       	ld	r24, X
   13770:	80 83       	st	Z, r24
   13772:	2f 5f       	subi	r18, 0xFF	; 255
   13774:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   13776:	28 30       	cpi	r18, 0x08	; 8
   13778:	31 05       	cpc	r19, r1
   1377a:	99 f7       	brne	.-26     	; 0x13762 <FMenuLocalAccount+0x60>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   1377c:	10 92 b9 0d 	sts	0x0DB9, r1
	       switch(stLocalAccount){   //|ID: ACD12345       |
	       case laInit:              //|Process ...        |
		        //Process RFID Data  //|                   |
				//UpdateCardID();
                BackLightTrig();ViewCardID();
	            lcd_clear();
   13780:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
	            lcd_printf(1,1,PSTR("   Local Account   "));
   13784:	81 e0       	ldi	r24, 0x01	; 1
   13786:	61 e0       	ldi	r22, 0x01	; 1
   13788:	4e e6       	ldi	r20, 0x6E	; 110
   1378a:	50 e2       	ldi	r21, 0x20	; 32
   1378c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	            sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   13790:	00 d0       	rcall	.+0      	; 0x13792 <FMenuLocalAccount+0x90>
   13792:	00 d0       	rcall	.+0      	; 0x13794 <FMenuLocalAccount+0x92>
   13794:	00 d0       	rcall	.+0      	; 0x13796 <FMenuLocalAccount+0x94>
   13796:	ed b7       	in	r30, 0x3d	; 61
   13798:	fe b7       	in	r31, 0x3e	; 62
   1379a:	31 96       	adiw	r30, 0x01	; 1
   1379c:	8e 01       	movw	r16, r28
   1379e:	0f 5f       	subi	r16, 0xFF	; 255
   137a0:	1f 4f       	sbci	r17, 0xFF	; 255
   137a2:	ad b7       	in	r26, 0x3d	; 61
   137a4:	be b7       	in	r27, 0x3e	; 62
   137a6:	12 96       	adiw	r26, 0x02	; 2
   137a8:	1c 93       	st	X, r17
   137aa:	0e 93       	st	-X, r16
   137ac:	11 97       	sbiw	r26, 0x01	; 1
   137ae:	88 e6       	ldi	r24, 0x68	; 104
   137b0:	90 e2       	ldi	r25, 0x20	; 32
   137b2:	93 83       	std	Z+3, r25	; 0x03
   137b4:	82 83       	std	Z+2, r24	; 0x02
   137b6:	81 eb       	ldi	r24, 0xB1	; 177
   137b8:	9d e0       	ldi	r25, 0x0D	; 13
   137ba:	95 83       	std	Z+5, r25	; 0x05
   137bc:	84 83       	std	Z+4, r24	; 0x04
   137be:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   137c2:	ed b7       	in	r30, 0x3d	; 61
   137c4:	fe b7       	in	r31, 0x3e	; 62
   137c6:	36 96       	adiw	r30, 0x06	; 6
   137c8:	0f b6       	in	r0, 0x3f	; 63
   137ca:	f8 94       	cli
   137cc:	fe bf       	out	0x3e, r31	; 62
   137ce:	0f be       	out	0x3f, r0	; 63
   137d0:	ed bf       	out	0x3d, r30	; 61
   137d2:	82 e0       	ldi	r24, 0x02	; 2
   137d4:	61 e0       	ldi	r22, 0x01	; 1
   137d6:	a8 01       	movw	r20, r16
   137d8:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
                lcd_printf(3,1,PSTR("Proses"));
   137dc:	83 e0       	ldi	r24, 0x03	; 3
   137de:	61 e0       	ldi	r22, 0x01	; 1
   137e0:	41 e6       	ldi	r20, 0x61	; 97
   137e2:	50 e2       	ldi	r21, 0x20	; 32
   137e4:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				iPos=0;iLoop=0;
   137e8:	10 92 a3 03 	sts	0x03A3, r1
   137ec:	10 92 73 03 	sts	0x0373, r1
   137f0:	10 92 72 03 	sts	0x0372, r1
				IsFullAuthorized=False;
   137f4:	10 92 74 03 	sts	0x0374, r1
		        stLocalAccount=laSendID;
   137f8:	82 e0       	ldi	r24, 0x02	; 2
   137fa:	dc c6       	rjmp	.+3512   	; 0x145b4 <FMenuLocalAccount+0xeb2>
				break;         
           case laSendID://sendMessage56 
				IsMessage57=False;
   137fc:	10 92 bc 01 	sts	0x01BC, r1
                sendMessage56();
   13800:	0e 94 d7 9a 	call	0x135ae	; 0x135ae <sendMessage56>
				iWait=0;iLoop=0;iPos=0;
   13804:	10 92 a2 03 	sts	0x03A2, r1
   13808:	10 92 73 03 	sts	0x0373, r1
   1380c:	10 92 72 03 	sts	0x0372, r1
   13810:	10 92 a3 03 	sts	0x03A3, r1
				stLocalAccount=laWaitMessage57;
   13814:	83 e0       	ldi	r24, 0x03	; 3
   13816:	ce c6       	rjmp	.+3484   	; 0x145b4 <FMenuLocalAccount+0xeb2>
		        break;
           case laWaitMessage57:
		        iLoop++;
   13818:	80 91 72 03 	lds	r24, 0x0372
   1381c:	90 91 73 03 	lds	r25, 0x0373
   13820:	01 96       	adiw	r24, 0x01	; 1
   13822:	90 93 73 03 	sts	0x0373, r25
   13826:	80 93 72 03 	sts	0x0372, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   1382a:	68 e9       	ldi	r22, 0x98	; 152
   1382c:	7a e3       	ldi	r23, 0x3A	; 58
   1382e:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
   13832:	89 2b       	or	r24, r25
   13834:	e1 f4       	brne	.+56     	; 0x1386e <FMenuLocalAccount+0x16c>
				   if (iPos<5){
   13836:	60 91 a3 03 	lds	r22, 0x03A3
   1383a:	65 30       	cpi	r22, 0x05	; 5
   1383c:	58 f4       	brcc	.+22     	; 0x13854 <FMenuLocalAccount+0x152>
					   lcd_put(3,(8+iPos),'.');
   1383e:	68 5f       	subi	r22, 0xF8	; 248
   13840:	83 e0       	ldi	r24, 0x03	; 3
   13842:	4e e2       	ldi	r20, 0x2E	; 46
   13844:	0e 94 54 ad 	call	0x15aa8	; 0x15aa8 <lcd_put>
				       iPos++;
   13848:	80 91 a3 03 	lds	r24, 0x03A3
   1384c:	8f 5f       	subi	r24, 0xFF	; 255
   1384e:	80 93 a3 03 	sts	0x03A3, r24
   13852:	0d c0       	rjmp	.+26     	; 0x1386e <FMenuLocalAccount+0x16c>
					   }
				   else{
				       iPos=0;
   13854:	10 92 a3 03 	sts	0x03A3, r1
					   lcd_printf(3,(9+iPos),PSTR("       "));
   13858:	83 e0       	ldi	r24, 0x03	; 3
   1385a:	69 e0       	ldi	r22, 0x09	; 9
   1385c:	49 e5       	ldi	r20, 0x59	; 89
   1385e:	50 e2       	ldi	r21, 0x20	; 32
   13860:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
					   iWait++;
   13864:	80 91 a2 03 	lds	r24, 0x03A2
   13868:	8f 5f       	subi	r24, 0xFF	; 255
   1386a:	80 93 a2 03 	sts	0x03A2, r24
					   }
				}
				if (iWait>3){
   1386e:	80 91 a2 03 	lds	r24, 0x03A2
   13872:	84 30       	cpi	r24, 0x04	; 4
   13874:	78 f0       	brcs	.+30     	; 0x13894 <FMenuLocalAccount+0x192>
				    stLocalAccount=laConTimout;
   13876:	84 e0       	ldi	r24, 0x04	; 4
   13878:	80 93 5c 01 	sts	0x015C, r24
					TimLocAcc=0;
   1387c:	10 92 d3 01 	sts	0x01D3, r1
   13880:	10 92 d2 01 	sts	0x01D2, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   13884:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   13886:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   13888:	82 e0       	ldi	r24, 0x02	; 2
   1388a:	90 e0       	ldi	r25, 0x00	; 0
   1388c:	90 93 d7 01 	sts	0x01D7, r25
   13890:	80 93 d6 01 	sts	0x01D6, r24
				if (iWait>3){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage57==True){
   13894:	80 91 bc 01 	lds	r24, 0x01BC
   13898:	81 30       	cpi	r24, 0x01	; 1
   1389a:	11 f0       	breq	.+4      	; 0x138a0 <FMenuLocalAccount+0x19e>
   1389c:	0c 94 ad a5 	jmp	0x14b5a	; 0x14b5a <FMenuLocalAccount+0x1458>
				    IsMessage57=False;
   138a0:	10 92 bc 01 	sts	0x01BC, r1
				    stLocalAccount=laProcMessage57;
   138a4:	85 e0       	ldi	r24, 0x05	; 5
   138a6:	86 c6       	rjmp	.+3340   	; 0x145b4 <FMenuLocalAccount+0xeb2>
					}
		        break;
           case laConTimout:
		        //IsErrorTCPIP=True;
				lcd_printf(3,1,PSTR("Sending Failed      "));
   138a8:	83 e0       	ldi	r24, 0x03	; 3
   138aa:	61 e0       	ldi	r22, 0x01	; 1
   138ac:	44 e4       	ldi	r20, 0x44	; 68
   138ae:	50 e2       	ldi	r21, 0x20	; 32
   138b0:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
   138b4:	84 e0       	ldi	r24, 0x04	; 4
   138b6:	61 e0       	ldi	r22, 0x01	; 1
   138b8:	4f e2       	ldi	r20, 0x2F	; 47
   138ba:	50 e2       	ldi	r21, 0x20	; 32
   138bc:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
   138c0:	80 91 d2 01 	lds	r24, 0x01D2
   138c4:	90 91 d3 01 	lds	r25, 0x01D3
   138c8:	03 97       	sbiw	r24, 0x03	; 3
   138ca:	10 f4       	brcc	.+4      	; 0x138d0 <FMenuLocalAccount+0x1ce>
   138cc:	0c 94 ad a5 	jmp	0x14b5a	; 0x14b5a <FMenuLocalAccount+0x1458>
   138d0:	0c 94 a4 a5 	jmp	0x14b48	; 0x14b48 <FMenuLocalAccount+0x1446>
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
   138d4:	83 e0       	ldi	r24, 0x03	; 3
   138d6:	61 e0       	ldi	r22, 0x01	; 1
   138d8:	4a e1       	ldi	r20, 0x1A	; 26
   138da:	50 e2       	ldi	r21, 0x20	; 32
   138dc:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				LocAccStatus=GetLocAccStatus(procMessage57());
   138e0:	0e 94 9b 24 	call	0x4936	; 0x4936 <procMessage57>


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
   138e4:	81 30       	cpi	r24, 0x01	; 1
   138e6:	29 f0       	breq	.+10     	; 0x138f2 <FMenuLocalAccount+0x1f0>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
   138e8:	82 30       	cpi	r24, 0x02	; 2
   138ea:	19 f0       	breq	.+6      	; 0x138f2 <FMenuLocalAccount+0x1f0>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
   138ec:	83 30       	cpi	r24, 0x03	; 3
   138ee:	09 f0       	breq	.+2      	; 0x138f2 <FMenuLocalAccount+0x1f0>
   138f0:	80 e0       	ldi	r24, 0x00	; 0
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
				LocAccStatus=GetLocAccStatus(procMessage57());
   138f2:	80 93 a4 03 	sts	0x03A4, r24
				TimLocAcc=0;
   138f6:	10 92 d3 01 	sts	0x01D3, r1
   138fa:	10 92 d2 01 	sts	0x01D2, r1
				stLocalAccount=laDispStatus;
   138fe:	86 e0       	ldi	r24, 0x06	; 6
   13900:	59 c6       	rjmp	.+3250   	; 0x145b4 <FMenuLocalAccount+0xeb2>
		        break;
           case laDispStatus://Display Status
		        if (LocAccStatus==LA_INVALID){
   13902:	80 91 a4 03 	lds	r24, 0x03A4
   13906:	81 30       	cpi	r24, 0x01	; 1
   13908:	29 f4       	brne	.+10     	; 0x13914 <FMenuLocalAccount+0x212>
					lcd_printf(3,1,PSTR("Tidak Terdaftar     "));    
   1390a:	83 e0       	ldi	r24, 0x03	; 3
   1390c:	61 e0       	ldi	r22, 0x01	; 1
   1390e:	45 e0       	ldi	r20, 0x05	; 5
   13910:	50 e2       	ldi	r21, 0x20	; 32
   13912:	0d c0       	rjmp	.+26     	; 0x1392e <FMenuLocalAccount+0x22c>
					TimLocAcc=0;
				    stLocalAccount=laDelayExit;
				}
				else
                if (LocAccStatus==LA_VALID) {
   13914:	82 30       	cpi	r24, 0x02	; 2
   13916:	31 f4       	brne	.+12     	; 0x13924 <FMenuLocalAccount+0x222>
				    stLocalAccount=laDispValid; 
   13918:	87 e0       	ldi	r24, 0x07	; 7
   1391a:	80 93 5c 01 	sts	0x015C, r24
					lcd_clear();
   1391e:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
   13922:	0e c0       	rjmp	.+28     	; 0x13940 <FMenuLocalAccount+0x23e>
					}
				else
                if (LocAccStatus==LA_LIMITED){
   13924:	83 30       	cpi	r24, 0x03	; 3
   13926:	61 f4       	brne	.+24     	; 0x13940 <FMenuLocalAccount+0x23e>
					lcd_printf(3,1,PSTR("Kartu Terbatas      "));    
   13928:	61 e0       	ldi	r22, 0x01	; 1
   1392a:	40 ef       	ldi	r20, 0xF0	; 240
   1392c:	5f e1       	ldi	r21, 0x1F	; 31
   1392e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
					TimLocAcc=0;
   13932:	10 92 d3 01 	sts	0x01D3, r1
   13936:	10 92 d2 01 	sts	0x01D2, r1
				    stLocalAccount=laDelayExit;
   1393a:	8e e1       	ldi	r24, 0x1E	; 30
   1393c:	80 93 5c 01 	sts	0x015C, r24
				}
                if (TimLocAcc>5)stLocalAccount=laExitLocAcc;
   13940:	80 91 d2 01 	lds	r24, 0x01D2
   13944:	90 91 d3 01 	lds	r25, 0x01D3
   13948:	06 97       	sbiw	r24, 0x06	; 6
   1394a:	10 f4       	brcc	.+4      	; 0x13950 <FMenuLocalAccount+0x24e>
   1394c:	0c 94 ad a5 	jmp	0x14b5a	; 0x14b5a <FMenuLocalAccount+0x1458>
   13950:	0c 94 a4 a5 	jmp	0x14b48	; 0x14b48 <FMenuLocalAccount+0x1446>
		        break;
           case laDispValid://Display VALID ID
		        lcd_clear();
   13954:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
   13958:	00 d0       	rcall	.+0      	; 0x1395a <FMenuLocalAccount+0x258>
   1395a:	00 d0       	rcall	.+0      	; 0x1395c <FMenuLocalAccount+0x25a>
   1395c:	00 d0       	rcall	.+0      	; 0x1395e <FMenuLocalAccount+0x25c>
   1395e:	ed b7       	in	r30, 0x3d	; 61
   13960:	fe b7       	in	r31, 0x3e	; 62
   13962:	31 96       	adiw	r30, 0x01	; 1
   13964:	8a e4       	ldi	r24, 0x4A	; 74
   13966:	9e e0       	ldi	r25, 0x0E	; 14
   13968:	ad b7       	in	r26, 0x3d	; 61
   1396a:	be b7       	in	r27, 0x3e	; 62
   1396c:	12 96       	adiw	r26, 0x02	; 2
   1396e:	9c 93       	st	X, r25
   13970:	8e 93       	st	-X, r24
   13972:	11 97       	sbiw	r26, 0x01	; 1
   13974:	8d ee       	ldi	r24, 0xED	; 237
   13976:	9f e1       	ldi	r25, 0x1F	; 31
   13978:	93 83       	std	Z+3, r25	; 0x03
   1397a:	82 83       	std	Z+2, r24	; 0x02
   1397c:	03 e2       	ldi	r16, 0x23	; 35
   1397e:	1e e0       	ldi	r17, 0x0E	; 14
   13980:	15 83       	std	Z+5, r17	; 0x05
   13982:	04 83       	std	Z+4, r16	; 0x04
   13984:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
				FormatCurrency(strBalance);
   13988:	ed b7       	in	r30, 0x3d	; 61
   1398a:	fe b7       	in	r31, 0x3e	; 62
   1398c:	36 96       	adiw	r30, 0x06	; 6
   1398e:	0f b6       	in	r0, 0x3f	; 63
   13990:	f8 94       	cli
   13992:	fe bf       	out	0x3e, r31	; 62
   13994:	0f be       	out	0x3f, r0	; 63
   13996:	ed bf       	out	0x3d, r30	; 61
   13998:	c8 01       	movw	r24, r16
   1399a:	0e 94 2a 30 	call	0x6054	; 0x6054 <FormatCurrency>
   1399e:	20 e0       	ldi	r18, 0x00	; 0
   139a0:	30 e0       	ldi	r19, 0x00	; 0


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
   139a2:	65 e1       	ldi	r22, 0x15	; 21
   139a4:	e6 2e       	mov	r14, r22
   139a6:	f1 2c       	mov	r15, r1
   139a8:	ec 0e       	add	r14, r28
   139aa:	fd 1e       	adc	r15, r29
   139ac:	f7 01       	movw	r30, r14
   139ae:	e2 0f       	add	r30, r18
   139b0:	f3 1f       	adc	r31, r19
   139b2:	d9 01       	movw	r26, r18
   139b4:	ac 5f       	subi	r26, 0xFC	; 252
   139b6:	ba 4f       	sbci	r27, 0xFA	; 250
   139b8:	8c 91       	ld	r24, X
   139ba:	80 83       	st	Z, r24
   139bc:	2f 5f       	subi	r18, 0xFF	; 255
   139be:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
   139c0:	24 31       	cpi	r18, 0x14	; 20
   139c2:	31 05       	cpc	r19, r1
   139c4:	99 f7       	brne	.-26     	; 0x139ac <FMenuLocalAccount+0x2aa>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
   139c6:	19 a6       	std	Y+41, r1	; 0x29
		        lcd_clear();
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
				FormatCurrency(strBalance);

		        StringCopy(strCardHolder,strName,20);  				                                                        
		        sprintf_P(lcdteks,PSTR("%s"),strCompName);               lcd_print(1,1,lcdteks);   //[CompName]
   139c8:	00 d0       	rcall	.+0      	; 0x139ca <FMenuLocalAccount+0x2c8>
   139ca:	00 d0       	rcall	.+0      	; 0x139cc <FMenuLocalAccount+0x2ca>
   139cc:	00 d0       	rcall	.+0      	; 0x139ce <FMenuLocalAccount+0x2cc>
   139ce:	ed b7       	in	r30, 0x3d	; 61
   139d0:	fe b7       	in	r31, 0x3e	; 62
   139d2:	31 96       	adiw	r30, 0x01	; 1
   139d4:	8e 01       	movw	r16, r28
   139d6:	0f 5f       	subi	r16, 0xFF	; 255
   139d8:	1f 4f       	sbci	r17, 0xFF	; 255
   139da:	ad b7       	in	r26, 0x3d	; 61
   139dc:	be b7       	in	r27, 0x3e	; 62
   139de:	12 96       	adiw	r26, 0x02	; 2
   139e0:	1c 93       	st	X, r17
   139e2:	0e 93       	st	-X, r16
   139e4:	11 97       	sbiw	r26, 0x01	; 1
   139e6:	8a ee       	ldi	r24, 0xEA	; 234
   139e8:	9f e1       	ldi	r25, 0x1F	; 31
   139ea:	93 83       	std	Z+3, r25	; 0x03
   139ec:	82 83       	std	Z+2, r24	; 0x02
   139ee:	8c ea       	ldi	r24, 0xAC	; 172
   139f0:	99 e0       	ldi	r25, 0x09	; 9
   139f2:	95 83       	std	Z+5, r25	; 0x05
   139f4:	84 83       	std	Z+4, r24	; 0x04
   139f6:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   139fa:	ed b7       	in	r30, 0x3d	; 61
   139fc:	fe b7       	in	r31, 0x3e	; 62
   139fe:	36 96       	adiw	r30, 0x06	; 6
   13a00:	0f b6       	in	r0, 0x3f	; 63
   13a02:	f8 94       	cli
   13a04:	fe bf       	out	0x3e, r31	; 62
   13a06:	0f be       	out	0x3f, r0	; 63
   13a08:	ed bf       	out	0x3d, r30	; 61
   13a0a:	81 e0       	ldi	r24, 0x01	; 1
   13a0c:	61 e0       	ldi	r22, 0x01	; 1
   13a0e:	a8 01       	movw	r20, r16
   13a10:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
                //sprintf(lcdteks,"%s %s",strCardID,strName);    lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
				sprintf_P(lcdteks,PSTR("%s"),strName);                   lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
   13a14:	00 d0       	rcall	.+0      	; 0x13a16 <FMenuLocalAccount+0x314>
   13a16:	00 d0       	rcall	.+0      	; 0x13a18 <FMenuLocalAccount+0x316>
   13a18:	00 d0       	rcall	.+0      	; 0x13a1a <FMenuLocalAccount+0x318>
   13a1a:	ed b7       	in	r30, 0x3d	; 61
   13a1c:	fe b7       	in	r31, 0x3e	; 62
   13a1e:	31 96       	adiw	r30, 0x01	; 1
   13a20:	ad b7       	in	r26, 0x3d	; 61
   13a22:	be b7       	in	r27, 0x3e	; 62
   13a24:	12 96       	adiw	r26, 0x02	; 2
   13a26:	1c 93       	st	X, r17
   13a28:	0e 93       	st	-X, r16
   13a2a:	11 97       	sbiw	r26, 0x01	; 1
   13a2c:	87 ee       	ldi	r24, 0xE7	; 231
   13a2e:	9f e1       	ldi	r25, 0x1F	; 31
   13a30:	93 83       	std	Z+3, r25	; 0x03
   13a32:	82 83       	std	Z+2, r24	; 0x02
   13a34:	f5 82       	std	Z+5, r15	; 0x05
   13a36:	e4 82       	std	Z+4, r14	; 0x04
   13a38:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   13a3c:	ed b7       	in	r30, 0x3d	; 61
   13a3e:	fe b7       	in	r31, 0x3e	; 62
   13a40:	36 96       	adiw	r30, 0x06	; 6
   13a42:	0f b6       	in	r0, 0x3f	; 63
   13a44:	f8 94       	cli
   13a46:	fe bf       	out	0x3e, r31	; 62
   13a48:	0f be       	out	0x3f, r0	; 63
   13a4a:	ed bf       	out	0x3d, r30	; 61
   13a4c:	82 e0       	ldi	r24, 0x02	; 2
   13a4e:	61 e0       	ldi	r22, 0x01	; 1
   13a50:	a8 01       	movw	r20, r16
   13a52:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
				sprintf_P(lcdteks,PSTR("%s %s"),strLicPlate,strBalance); lcd_print(3,1,lcdteks);   //[LicPlate][Balance] 
   13a56:	2d b7       	in	r18, 0x3d	; 61
   13a58:	3e b7       	in	r19, 0x3e	; 62
   13a5a:	28 50       	subi	r18, 0x08	; 8
   13a5c:	30 40       	sbci	r19, 0x00	; 0
   13a5e:	0f b6       	in	r0, 0x3f	; 63
   13a60:	f8 94       	cli
   13a62:	3e bf       	out	0x3e, r19	; 62
   13a64:	0f be       	out	0x3f, r0	; 63
   13a66:	2d bf       	out	0x3d, r18	; 61
   13a68:	ed b7       	in	r30, 0x3d	; 61
   13a6a:	fe b7       	in	r31, 0x3e	; 62
   13a6c:	31 96       	adiw	r30, 0x01	; 1
   13a6e:	ad b7       	in	r26, 0x3d	; 61
   13a70:	be b7       	in	r27, 0x3e	; 62
   13a72:	12 96       	adiw	r26, 0x02	; 2
   13a74:	1c 93       	st	X, r17
   13a76:	0e 93       	st	-X, r16
   13a78:	11 97       	sbiw	r26, 0x01	; 1
   13a7a:	81 ee       	ldi	r24, 0xE1	; 225
   13a7c:	9f e1       	ldi	r25, 0x1F	; 31
   13a7e:	93 83       	std	Z+3, r25	; 0x03
   13a80:	82 83       	std	Z+2, r24	; 0x02
   13a82:	82 e2       	ldi	r24, 0x22	; 34
   13a84:	9b e0       	ldi	r25, 0x0B	; 11
   13a86:	95 83       	std	Z+5, r25	; 0x05
   13a88:	84 83       	std	Z+4, r24	; 0x04
   13a8a:	83 e2       	ldi	r24, 0x23	; 35
   13a8c:	9e e0       	ldi	r25, 0x0E	; 14
   13a8e:	97 83       	std	Z+7, r25	; 0x07
   13a90:	86 83       	std	Z+6, r24	; 0x06
   13a92:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   13a96:	ed b7       	in	r30, 0x3d	; 61
   13a98:	fe b7       	in	r31, 0x3e	; 62
   13a9a:	38 96       	adiw	r30, 0x08	; 8
   13a9c:	0f b6       	in	r0, 0x3f	; 63
   13a9e:	f8 94       	cli
   13aa0:	fe bf       	out	0x3e, r31	; 62
   13aa2:	0f be       	out	0x3f, r0	; 63
   13aa4:	ed bf       	out	0x3d, r30	; 61
   13aa6:	83 e0       	ldi	r24, 0x03	; 3
   13aa8:	61 e0       	ldi	r22, 0x01	; 1
   13aaa:	a8 01       	movw	r20, r16
   13aac:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
	            lcd_printf(4,1,PSTR("[*]Batal       [#]OK"));   //[*]Batal       [#]OK
   13ab0:	84 e0       	ldi	r24, 0x04	; 4
   13ab2:	61 e0       	ldi	r22, 0x01	; 1
   13ab4:	4c ec       	ldi	r20, 0xCC	; 204
   13ab6:	5f e1       	ldi	r21, 0x1F	; 31
   13ab8:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				stLocalAccount=laDispValidInput;
   13abc:	88 e0       	ldi	r24, 0x08	; 8
   13abe:	7a c5       	rjmp	.+2804   	; 0x145b4 <FMenuLocalAccount+0xeb2>
		        break;
           case laDispValidInput:
                KeyPressed=_key_scan(1);
   13ac0:	81 e0       	ldi	r24, 0x01	; 1
   13ac2:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   13ac6:	80 93 9c 03 	sts	0x039C, r24
				if (KeyPressed==_KEY_ENTER) stLocalAccount=laSelectFIP;
   13aca:	87 3b       	cpi	r24, 0xB7	; 183
   13acc:	09 f4       	brne	.+2      	; 0x13ad0 <FMenuLocalAccount+0x3ce>
   13ace:	84 c2       	rjmp	.+1288   	; 0x13fd8 <FMenuLocalAccount+0x8d6>
				else
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laExitLocAcc;
   13ad0:	87 3e       	cpi	r24, 0xE7	; 231
   13ad2:	11 f0       	breq	.+4      	; 0x13ad8 <FMenuLocalAccount+0x3d6>
   13ad4:	0c 94 ad a5 	jmp	0x14b5a	; 0x14b5a <FMenuLocalAccount+0x1458>
   13ad8:	0c 94 a4 a5 	jmp	0x14b48	; 0x14b48 <FMenuLocalAccount+0x1446>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   13adc:	82 e8       	ldi	r24, 0x82	; 130
   13ade:	93 e0       	ldi	r25, 0x03	; 3
   13ae0:	65 e4       	ldi	r22, 0x45	; 69
   13ae2:	70 e0       	ldi	r23, 0x00	; 0
   13ae4:	48 e0       	ldi	r20, 0x08	; 8
   13ae6:	50 e0       	ldi	r21, 0x00	; 0
   13ae8:	25 ed       	ldi	r18, 0xD5	; 213
   13aea:	32 e1       	ldi	r19, 0x12	; 18
   13aec:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
		        break;
           case laSelectFIP:       
		  		eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				lcd_clear(); 
   13af0:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
				//for (iLoop=0;iLoop<8;iLoop++){
				//     if (FIP[iLoop]>16) FIP[iLoop]=0;
				//	 }
				for (iLoop=0;iLoop<4;iLoop++){
   13af4:	10 92 73 03 	sts	0x0373, r1
   13af8:	10 92 72 03 	sts	0x0372, r1
                     //leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                     //sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
					 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
   13afc:	8e 01       	movw	r16, r28
   13afe:	0f 5f       	subi	r16, 0xFF	; 255
   13b00:	1f 4f       	sbci	r17, 0xFF	; 255
   13b02:	58 eb       	ldi	r21, 0xB8	; 184
   13b04:	e5 2e       	mov	r14, r21
   13b06:	5f e1       	ldi	r21, 0x1F	; 31
   13b08:	f5 2e       	mov	r15, r21
   13b0a:	41 c0       	rjmp	.+130    	; 0x13b8e <FMenuLocalAccount+0x48c>
   13b0c:	8d b7       	in	r24, 0x3d	; 61
   13b0e:	9e b7       	in	r25, 0x3e	; 62
   13b10:	0c 97       	sbiw	r24, 0x0c	; 12
   13b12:	0f b6       	in	r0, 0x3f	; 63
   13b14:	f8 94       	cli
   13b16:	9e bf       	out	0x3e, r25	; 62
   13b18:	0f be       	out	0x3f, r0	; 63
   13b1a:	8d bf       	out	0x3d, r24	; 61
   13b1c:	ed b7       	in	r30, 0x3d	; 61
   13b1e:	fe b7       	in	r31, 0x3e	; 62
   13b20:	31 96       	adiw	r30, 0x01	; 1
   13b22:	ad b7       	in	r26, 0x3d	; 61
   13b24:	be b7       	in	r27, 0x3e	; 62
   13b26:	12 96       	adiw	r26, 0x02	; 2
   13b28:	1c 93       	st	X, r17
   13b2a:	0e 93       	st	-X, r16
   13b2c:	11 97       	sbiw	r26, 0x01	; 1
   13b2e:	f3 82       	std	Z+3, r15	; 0x03
   13b30:	e2 82       	std	Z+2, r14	; 0x02
   13b32:	2f 5f       	subi	r18, 0xFF	; 255
   13b34:	3f 4f       	sbci	r19, 0xFF	; 255
   13b36:	35 83       	std	Z+5, r19	; 0x05
   13b38:	24 83       	std	Z+4, r18	; 0x04
   13b3a:	21 50       	subi	r18, 0x01	; 1
   13b3c:	30 40       	sbci	r19, 0x00	; 0
   13b3e:	d9 01       	movw	r26, r18
   13b40:	ae 57       	subi	r26, 0x7E	; 126
   13b42:	bc 4f       	sbci	r27, 0xFC	; 252
   13b44:	8c 91       	ld	r24, X
   13b46:	86 83       	std	Z+6, r24	; 0x06
   13b48:	17 82       	std	Z+7, r1	; 0x07
   13b4a:	2b 5f       	subi	r18, 0xFB	; 251
   13b4c:	3f 4f       	sbci	r19, 0xFF	; 255
   13b4e:	31 87       	std	Z+9, r19	; 0x09
   13b50:	20 87       	std	Z+8, r18	; 0x08
   13b52:	14 96       	adiw	r26, 0x04	; 4
   13b54:	8c 91       	ld	r24, X
   13b56:	82 87       	std	Z+10, r24	; 0x0a
   13b58:	13 86       	std	Z+11, r1	; 0x0b
   13b5a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
					 lcd_print((iLoop+1),1,lcdteks);
   13b5e:	ed b7       	in	r30, 0x3d	; 61
   13b60:	fe b7       	in	r31, 0x3e	; 62
   13b62:	3c 96       	adiw	r30, 0x0c	; 12
   13b64:	0f b6       	in	r0, 0x3f	; 63
   13b66:	f8 94       	cli
   13b68:	fe bf       	out	0x3e, r31	; 62
   13b6a:	0f be       	out	0x3f, r0	; 63
   13b6c:	ed bf       	out	0x3d, r30	; 61
   13b6e:	80 91 72 03 	lds	r24, 0x0372
   13b72:	8f 5f       	subi	r24, 0xFF	; 255
   13b74:	61 e0       	ldi	r22, 0x01	; 1
   13b76:	a8 01       	movw	r20, r16
   13b78:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		  		eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				lcd_clear(); 
				//for (iLoop=0;iLoop<8;iLoop++){
				//     if (FIP[iLoop]>16) FIP[iLoop]=0;
				//	 }
				for (iLoop=0;iLoop<4;iLoop++){
   13b7c:	80 91 72 03 	lds	r24, 0x0372
   13b80:	90 91 73 03 	lds	r25, 0x0373
   13b84:	01 96       	adiw	r24, 0x01	; 1
   13b86:	90 93 73 03 	sts	0x0373, r25
   13b8a:	80 93 72 03 	sts	0x0372, r24
   13b8e:	20 91 72 03 	lds	r18, 0x0372
   13b92:	30 91 73 03 	lds	r19, 0x0373
   13b96:	24 30       	cpi	r18, 0x04	; 4
   13b98:	31 05       	cpc	r19, r1
   13b9a:	08 f4       	brcc	.+2      	; 0x13b9e <FMenuLocalAccount+0x49c>
   13b9c:	b7 cf       	rjmp	.-146    	; 0x13b0c <FMenuLocalAccount+0x40a>
                     //leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                     //sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
					 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
					 lcd_print((iLoop+1),1,lcdteks);
					 }
		        lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
   13b9e:	81 e0       	ldi	r24, 0x01	; 1
   13ba0:	6f e0       	ldi	r22, 0x0F	; 15
   13ba2:	42 eb       	ldi	r20, 0xB2	; 178
   13ba4:	5f e1       	ldi	r21, 0x1F	; 31
   13ba6:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
   13baa:	82 e0       	ldi	r24, 0x02	; 2
   13bac:	6f e0       	ldi	r22, 0x0F	; 15
   13bae:	4c ea       	ldi	r20, 0xAC	; 172
   13bb0:	5f e1       	ldi	r21, 0x1F	; 31
   13bb2:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
   13bb6:	83 e0       	ldi	r24, 0x03	; 3
   13bb8:	6f e0       	ldi	r22, 0x0F	; 15
   13bba:	46 ea       	ldi	r20, 0xA6	; 166
   13bbc:	5f e1       	ldi	r21, 0x1F	; 31
   13bbe:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	            lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
   13bc2:	84 e0       	ldi	r24, 0x04	; 4
   13bc4:	6f e0       	ldi	r22, 0x0F	; 15
   13bc6:	4f e9       	ldi	r20, 0x9F	; 159
   13bc8:	5f e1       	ldi	r21, 0x1F	; 31
   13bca:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				//eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				iLoop=0;
   13bce:	10 92 73 03 	sts	0x0373, r1
   13bd2:	10 92 72 03 	sts	0x0372, r1
				stLocalAccount=laSelectFIPInput;
   13bd6:	8a e0       	ldi	r24, 0x0A	; 10
   13bd8:	ed c4       	rjmp	.+2522   	; 0x145b4 <FMenuLocalAccount+0xeb2>
		        break; 
           case laSelectFIPInput:
			    //Blinking 50% _ 
			    iLoop++;
   13bda:	80 91 72 03 	lds	r24, 0x0372
   13bde:	90 91 73 03 	lds	r25, 0x0373
   13be2:	01 96       	adiw	r24, 0x01	; 1
   13be4:	90 93 73 03 	sts	0x0373, r25
   13be8:	80 93 72 03 	sts	0x0372, r24
			    //GetKeyPressed
			    KeyPressed=_key_scan(1);
   13bec:	81 e0       	ldi	r24, 0x01	; 1
   13bee:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   13bf2:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   13bf6:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   13bfa:	98 2f       	mov	r25, r24
   13bfc:	80 93 a1 03 	sts	0x03A1, r24
				if ((KeyChar>='1')&&(KeyChar<='8')){
   13c00:	81 53       	subi	r24, 0x31	; 49
   13c02:	88 30       	cpi	r24, 0x08	; 8
   13c04:	60 f4       	brcc	.+24     	; 0x13c1e <FMenuLocalAccount+0x51c>
				    if (KeyCharLast!=KeyChar){
   13c06:	80 91 5b 01 	lds	r24, 0x015B
   13c0a:	89 17       	cp	r24, r25
   13c0c:	41 f0       	breq	.+16     	; 0x13c1e <FMenuLocalAccount+0x51c>
					    KeyCharLast=KeyChar;
   13c0e:	90 93 5b 01 	sts	0x015B, r25
						iLoop=1000;
   13c12:	88 ee       	ldi	r24, 0xE8	; 232
   13c14:	93 e0       	ldi	r25, 0x03	; 3
   13c16:	90 93 73 03 	sts	0x0373, r25
   13c1a:	80 93 72 03 	sts	0x0372, r24
                    }
				}

			    if ((iLoop%2000)==0){
   13c1e:	80 91 72 03 	lds	r24, 0x0372
   13c22:	90 91 73 03 	lds	r25, 0x0373
   13c26:	60 ed       	ldi	r22, 0xD0	; 208
   13c28:	77 e0       	ldi	r23, 0x07	; 7
   13c2a:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
   13c2e:	89 2b       	or	r24, r25
   13c30:	39 f4       	brne	.+14     	; 0x13c40 <FMenuLocalAccount+0x53e>
			       lcd_xy(1,19);_lcd('_'); 
   13c32:	81 e0       	ldi	r24, 0x01	; 1
   13c34:	63 e1       	ldi	r22, 0x13	; 19
   13c36:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
   13c3a:	8f e5       	ldi	r24, 0x5F	; 95
   13c3c:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
			    }
			    if ((iLoop%2000)==1000){
   13c40:	80 91 72 03 	lds	r24, 0x0372
   13c44:	90 91 73 03 	lds	r25, 0x0373
   13c48:	60 ed       	ldi	r22, 0xD0	; 208
   13c4a:	77 e0       	ldi	r23, 0x07	; 7
   13c4c:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
   13c50:	88 5e       	subi	r24, 0xE8	; 232
   13c52:	93 40       	sbci	r25, 0x03	; 3
   13c54:	41 f4       	brne	.+16     	; 0x13c66 <FMenuLocalAccount+0x564>
			       lcd_xy(1,19);_lcd(KeyCharLast); 
   13c56:	81 e0       	ldi	r24, 0x01	; 1
   13c58:	63 e1       	ldi	r22, 0x13	; 19
   13c5a:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
   13c5e:	80 91 5b 01 	lds	r24, 0x015B
   13c62:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
			    }
				if (((KeyChar>='1')&&(KeyChar<='8'))||
   13c66:	80 91 a1 03 	lds	r24, 0x03A1
   13c6a:	81 53       	subi	r24, 0x31	; 49
   13c6c:	88 30       	cpi	r24, 0x08	; 8
   13c6e:	50 f0       	brcs	.+20     	; 0x13c84 <FMenuLocalAccount+0x582>
   13c70:	80 91 9c 03 	lds	r24, 0x039C
   13c74:	87 3b       	cpi	r24, 0xB7	; 183
   13c76:	09 f0       	breq	.+2      	; 0x13c7a <FMenuLocalAccount+0x578>
   13c78:	57 c0       	rjmp	.+174    	; 0x13d28 <FMenuLocalAccount+0x626>
   13c7a:	80 91 5b 01 	lds	r24, 0x015B
   13c7e:	80 32       	cpi	r24, 0x20	; 32
   13c80:	09 f4       	brne	.+2      	; 0x13c84 <FMenuLocalAccount+0x582>
   13c82:	6b c7       	rjmp	.+3798   	; 0x14b5a <FMenuLocalAccount+0x1458>
				    (KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')
					){
				    stLocalAccount=laSelectProduct;
   13c84:	8b e0       	ldi	r24, 0x0B	; 11
   13c86:	80 93 5c 01 	sts	0x015C, r24
					FIP_Used=FIP[KeyCharLast-'1'];
   13c8a:	e0 91 5b 01 	lds	r30, 0x015B
   13c8e:	f0 e0       	ldi	r31, 0x00	; 0
   13c90:	ef 5a       	subi	r30, 0xAF	; 175
   13c92:	fc 4f       	sbci	r31, 0xFC	; 252
   13c94:	20 81       	ld	r18, Z
   13c96:	20 93 76 03 	sts	0x0376, r18
					if (FIP_Used<=99){
   13c9a:	24 36       	cpi	r18, 0x64	; 100
   13c9c:	08 f0       	brcs	.+2      	; 0x13ca0 <FMenuLocalAccount+0x59e>
   13c9e:	5d c7       	rjmp	.+3770   	; 0x14b5a <FMenuLocalAccount+0x1458>
					    //leadingZero(FIP_Used,strFIP);
						//leadingZero(FIP_Used,strFIP_ID);
						sprintf_P(strFIP,PSTR("%.2d"),FIP_Used);
   13ca0:	00 d0       	rcall	.+0      	; 0x13ca2 <FMenuLocalAccount+0x5a0>
   13ca2:	00 d0       	rcall	.+0      	; 0x13ca4 <FMenuLocalAccount+0x5a2>
   13ca4:	00 d0       	rcall	.+0      	; 0x13ca6 <FMenuLocalAccount+0x5a4>
   13ca6:	ed b7       	in	r30, 0x3d	; 61
   13ca8:	fe b7       	in	r31, 0x3e	; 62
   13caa:	31 96       	adiw	r30, 0x01	; 1
   13cac:	8d e9       	ldi	r24, 0x9D	; 157
   13cae:	93 e0       	ldi	r25, 0x03	; 3
   13cb0:	ad b7       	in	r26, 0x3d	; 61
   13cb2:	be b7       	in	r27, 0x3e	; 62
   13cb4:	12 96       	adiw	r26, 0x02	; 2
   13cb6:	9c 93       	st	X, r25
   13cb8:	8e 93       	st	-X, r24
   13cba:	11 97       	sbiw	r26, 0x01	; 1
   13cbc:	8a e9       	ldi	r24, 0x9A	; 154
   13cbe:	9f e1       	ldi	r25, 0x1F	; 31
   13cc0:	93 83       	std	Z+3, r25	; 0x03
   13cc2:	82 83       	std	Z+2, r24	; 0x02
   13cc4:	24 83       	std	Z+4, r18	; 0x04
   13cc6:	15 82       	std	Z+5, r1	; 0x05
   13cc8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
						sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
   13ccc:	ed b7       	in	r30, 0x3d	; 61
   13cce:	fe b7       	in	r31, 0x3e	; 62
   13cd0:	31 96       	adiw	r30, 0x01	; 1
   13cd2:	8c ee       	ldi	r24, 0xEC	; 236
   13cd4:	99 e0       	ldi	r25, 0x09	; 9
   13cd6:	ad b7       	in	r26, 0x3d	; 61
   13cd8:	be b7       	in	r27, 0x3e	; 62
   13cda:	12 96       	adiw	r26, 0x02	; 2
   13cdc:	9c 93       	st	X, r25
   13cde:	8e 93       	st	-X, r24
   13ce0:	11 97       	sbiw	r26, 0x01	; 1
   13ce2:	85 e9       	ldi	r24, 0x95	; 149
   13ce4:	9f e1       	ldi	r25, 0x1F	; 31
   13ce6:	93 83       	std	Z+3, r25	; 0x03
   13ce8:	82 83       	std	Z+2, r24	; 0x02
   13cea:	80 91 76 03 	lds	r24, 0x0376
   13cee:	84 83       	std	Z+4, r24	; 0x04
   13cf0:	15 82       	std	Z+5, r1	; 0x05
   13cf2:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   13cf6:	ed b7       	in	r30, 0x3d	; 61
   13cf8:	fe b7       	in	r31, 0x3e	; 62
   13cfa:	36 96       	adiw	r30, 0x06	; 6
   13cfc:	0f b6       	in	r0, 0x3f	; 63
   13cfe:	f8 94       	cli
   13d00:	fe bf       	out	0x3e, r31	; 62
   13d02:	0f be       	out	0x3f, r0	; 63
   13d04:	ed bf       	out	0x3d, r30	; 61
   13d06:	60 91 5b 01 	lds	r22, 0x015B
   13d0a:	86 e0       	ldi	r24, 0x06	; 6
   13d0c:	68 9f       	mul	r22, r24
   13d0e:	b0 01       	movw	r22, r0
   13d10:	11 24       	eor	r1, r1
   13d12:	61 5d       	subi	r22, 0xD1	; 209
   13d14:	70 40       	sbci	r23, 0x00	; 0
   13d16:	8a e8       	ldi	r24, 0x8A	; 138
   13d18:	93 e0       	ldi	r25, 0x03	; 3
   13d1a:	46 e0       	ldi	r20, 0x06	; 6
   13d1c:	50 e0       	ldi	r21, 0x00	; 0
   13d1e:	25 ed       	ldi	r18, 0xD5	; 213
   13d20:	32 e1       	ldi	r19, 0x12	; 18
   13d22:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
   13d26:	19 c7       	rjmp	.+3634   	; 0x14b5a <FMenuLocalAccount+0x1458>

						eeprom_read_block((void*) &ProductID, (const void*) &DefNozzleMap[(KeyCharLast-'1')], 6);
						}
					}
				else
				if (KeyPressed==_KEY_CANCEL){
   13d28:	87 3e       	cpi	r24, 0xE7	; 231
   13d2a:	09 f0       	breq	.+2      	; 0x13d2e <FMenuLocalAccount+0x62c>
   13d2c:	16 c7       	rjmp	.+3628   	; 0x14b5a <FMenuLocalAccount+0x1458>
				    stLocalAccount=laDispValid;
   13d2e:	87 e0       	ldi	r24, 0x07	; 7
   13d30:	41 c4       	rjmp	.+2178   	; 0x145b4 <FMenuLocalAccount+0xeb2>
					}
		        break;
           case laSelectProduct://NozzleID
				lcd_clear();
   13d32:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		        sprintf_P(lcdteks,PSTR("Pompa-%s"),strFIP);lcd_print(1,1,lcdteks);
   13d36:	00 d0       	rcall	.+0      	; 0x13d38 <FMenuLocalAccount+0x636>
   13d38:	00 d0       	rcall	.+0      	; 0x13d3a <FMenuLocalAccount+0x638>
   13d3a:	00 d0       	rcall	.+0      	; 0x13d3c <FMenuLocalAccount+0x63a>
   13d3c:	ed b7       	in	r30, 0x3d	; 61
   13d3e:	fe b7       	in	r31, 0x3e	; 62
   13d40:	31 96       	adiw	r30, 0x01	; 1
   13d42:	8e 01       	movw	r16, r28
   13d44:	0f 5f       	subi	r16, 0xFF	; 255
   13d46:	1f 4f       	sbci	r17, 0xFF	; 255
   13d48:	ad b7       	in	r26, 0x3d	; 61
   13d4a:	be b7       	in	r27, 0x3e	; 62
   13d4c:	12 96       	adiw	r26, 0x02	; 2
   13d4e:	1c 93       	st	X, r17
   13d50:	0e 93       	st	-X, r16
   13d52:	11 97       	sbiw	r26, 0x01	; 1
   13d54:	8c e8       	ldi	r24, 0x8C	; 140
   13d56:	9f e1       	ldi	r25, 0x1F	; 31
   13d58:	93 83       	std	Z+3, r25	; 0x03
   13d5a:	82 83       	std	Z+2, r24	; 0x02
   13d5c:	8d e9       	ldi	r24, 0x9D	; 157
   13d5e:	93 e0       	ldi	r25, 0x03	; 3
   13d60:	95 83       	std	Z+5, r25	; 0x05
   13d62:	84 83       	std	Z+4, r24	; 0x04
   13d64:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   13d68:	ed b7       	in	r30, 0x3d	; 61
   13d6a:	fe b7       	in	r31, 0x3e	; 62
   13d6c:	36 96       	adiw	r30, 0x06	; 6
   13d6e:	0f b6       	in	r0, 0x3f	; 63
   13d70:	f8 94       	cli
   13d72:	fe bf       	out	0x3e, r31	; 62
   13d74:	0f be       	out	0x3f, r0	; 63
   13d76:	ed bf       	out	0x3d, r30	; 61
   13d78:	81 e0       	ldi	r24, 0x01	; 1
   13d7a:	61 e0       	ldi	r22, 0x01	; 1
   13d7c:	a8 01       	movw	r20, r16
   13d7e:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
				//Not MPD->Single Product
				if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&
   13d82:	90 91 8a 03 	lds	r25, 0x038A
   13d86:	89 2f       	mov	r24, r25
   13d88:	81 50       	subi	r24, 0x01	; 1
   13d8a:	86 30       	cpi	r24, 0x06	; 6
   13d8c:	08 f0       	brcs	.+2      	; 0x13d90 <FMenuLocalAccount+0x68e>
   13d8e:	4b c0       	rjmp	.+150    	; 0x13e26 <FMenuLocalAccount+0x724>
   13d90:	80 91 8b 03 	lds	r24, 0x038B
   13d94:	88 23       	and	r24, r24
   13d96:	09 f0       	breq	.+2      	; 0x13d9a <FMenuLocalAccount+0x698>
   13d98:	46 c0       	rjmp	.+140    	; 0x13e26 <FMenuLocalAccount+0x724>
   13d9a:	80 91 8c 03 	lds	r24, 0x038C
   13d9e:	88 23       	and	r24, r24
   13da0:	09 f0       	breq	.+2      	; 0x13da4 <FMenuLocalAccount+0x6a2>
   13da2:	41 c0       	rjmp	.+130    	; 0x13e26 <FMenuLocalAccount+0x724>
   13da4:	80 91 8d 03 	lds	r24, 0x038D
   13da8:	88 23       	and	r24, r24
   13daa:	e9 f5       	brne	.+122    	; 0x13e26 <FMenuLocalAccount+0x724>
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
   13dac:	90 93 75 03 	sts	0x0375, r25
   13db0:	6d e0       	ldi	r22, 0x0D	; 13
   13db2:	96 9f       	mul	r25, r22
   13db4:	b0 01       	movw	r22, r0
   13db6:	11 24       	eor	r1, r1
   13db8:	62 55       	subi	r22, 0x52	; 82
   13dba:	7f 4f       	sbci	r23, 0xFF	; 255
   13dbc:	87 e7       	ldi	r24, 0x77	; 119
   13dbe:	93 e0       	ldi	r25, 0x03	; 3
   13dc0:	4a e0       	ldi	r20, 0x0A	; 10
   13dc2:	50 e0       	ldi	r21, 0x00	; 0
   13dc4:	25 ed       	ldi	r18, 0xD5	; 213
   13dc6:	32 e1       	ldi	r19, 0x12	; 18
   13dc8:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
   13dcc:	a7 e7       	ldi	r26, 0x77	; 119
   13dce:	b3 e0       	ldi	r27, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   13dd0:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13dd2:	f3 e0       	ldi	r31, 0x03	; 3
   13dd4:	af 37       	cpi	r26, 0x7F	; 127
   13dd6:	bf 07       	cpc	r27, r31
   13dd8:	d9 f7       	brne	.-10     	; 0x13dd0 <FMenuLocalAccount+0x6ce>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   13dda:	1c 92       	st	X, r1
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
					 eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
					 StrPosCopy(ProductName,ProductName,0,8);
					 sprintf_P(strProduct,PSTR("%s"),ProductName);
   13ddc:	00 d0       	rcall	.+0      	; 0x13dde <FMenuLocalAccount+0x6dc>
   13dde:	00 d0       	rcall	.+0      	; 0x13de0 <FMenuLocalAccount+0x6de>
   13de0:	00 d0       	rcall	.+0      	; 0x13de2 <FMenuLocalAccount+0x6e0>
   13de2:	2d b7       	in	r18, 0x3d	; 61
   13de4:	3e b7       	in	r19, 0x3e	; 62
   13de6:	2f 5f       	subi	r18, 0xFF	; 255
   13de8:	3f 4f       	sbci	r19, 0xFF	; 255
   13dea:	81 e9       	ldi	r24, 0x91	; 145
   13dec:	99 e0       	ldi	r25, 0x09	; 9
   13dee:	ed b7       	in	r30, 0x3d	; 61
   13df0:	fe b7       	in	r31, 0x3e	; 62
   13df2:	92 83       	std	Z+2, r25	; 0x02
   13df4:	81 83       	std	Z+1, r24	; 0x01
   13df6:	89 e8       	ldi	r24, 0x89	; 137
   13df8:	9f e1       	ldi	r25, 0x1F	; 31
   13dfa:	f9 01       	movw	r30, r18
   13dfc:	93 83       	std	Z+3, r25	; 0x03
   13dfe:	82 83       	std	Z+2, r24	; 0x02
   13e00:	18 97       	sbiw	r26, 0x08	; 8
   13e02:	b5 83       	std	Z+5, r27	; 0x05
   13e04:	a4 83       	std	Z+4, r26	; 0x04
   13e06:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
                     stLocalAccount=laSelectBalanceType;
   13e0a:	8d e0       	ldi	r24, 0x0D	; 13
   13e0c:	80 93 5c 01 	sts	0x015C, r24
   13e10:	80 e0       	ldi	r24, 0x00	; 0
   13e12:	2d b7       	in	r18, 0x3d	; 61
   13e14:	3e b7       	in	r19, 0x3e	; 62
   13e16:	2a 5f       	subi	r18, 0xFA	; 250
   13e18:	3f 4f       	sbci	r19, 0xFF	; 255
   13e1a:	0f b6       	in	r0, 0x3f	; 63
   13e1c:	f8 94       	cli
   13e1e:	3e bf       	out	0x3e, r19	; 62
   13e20:	0f be       	out	0x3f, r0	; 63
   13e22:	2d bf       	out	0x3d, r18	; 61
   13e24:	9b c6       	rjmp	.+3382   	; 0x14b5c <FMenuLocalAccount+0x145a>
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   13e26:	10 92 9a 03 	sts	0x039A, r1
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   13e2a:	8e 01       	movw	r16, r28
   13e2c:	0f 5f       	subi	r16, 0xFF	; 255
   13e2e:	1f 4f       	sbci	r17, 0xFF	; 255
   13e30:	4d e7       	ldi	r20, 0x7D	; 125
   13e32:	c4 2e       	mov	r12, r20
   13e34:	4f e1       	ldi	r20, 0x1F	; 31
   13e36:	d4 2e       	mov	r13, r20
   13e38:	3d e0       	ldi	r19, 0x0D	; 13
   13e3a:	a3 2e       	mov	r10, r19
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   13e3c:	23 e8       	ldi	r18, 0x83	; 131
   13e3e:	e2 2e       	mov	r14, r18
   13e40:	2f e1       	ldi	r18, 0x1F	; 31
   13e42:	f2 2e       	mov	r15, r18
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   13e44:	9b e0       	ldi	r25, 0x0B	; 11
   13e46:	b9 2e       	mov	r11, r25
   13e48:	6b c0       	rjmp	.+214    	; 0x13f20 <FMenuLocalAccount+0x81e>
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
   13e4a:	f0 e0       	ldi	r31, 0x00	; 0
   13e4c:	e6 57       	subi	r30, 0x76	; 118
   13e4e:	fc 4f       	sbci	r31, 0xFC	; 252
   13e50:	e0 81       	ld	r30, Z
   13e52:	e0 93 75 03 	sts	0x0375, r30
					if ((ProdId>=1)&&(ProdId<=6)){
   13e56:	8e 2f       	mov	r24, r30
   13e58:	81 50       	subi	r24, 0x01	; 1
   13e5a:	86 30       	cpi	r24, 0x06	; 6
   13e5c:	e8 f5       	brcc	.+122    	; 0x13ed8 <FMenuLocalAccount+0x7d6>
   13e5e:	ea 9d       	mul	r30, r10
   13e60:	b0 01       	movw	r22, r0
   13e62:	11 24       	eor	r1, r1
   13e64:	62 55       	subi	r22, 0x52	; 82
   13e66:	7f 4f       	sbci	r23, 0xFF	; 255
   13e68:	87 e7       	ldi	r24, 0x77	; 119
   13e6a:	93 e0       	ldi	r25, 0x03	; 3
   13e6c:	4a e0       	ldi	r20, 0x0A	; 10
   13e6e:	50 e0       	ldi	r21, 0x00	; 0
   13e70:	25 ed       	ldi	r18, 0xD5	; 213
   13e72:	32 e1       	ldi	r19, 0x12	; 18
   13e74:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
   13e78:	a7 e7       	ldi	r26, 0x77	; 119
   13e7a:	b3 e0       	ldi	r27, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   13e7c:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13e7e:	33 e0       	ldi	r19, 0x03	; 3
   13e80:	af 37       	cpi	r26, 0x7F	; 127
   13e82:	b3 07       	cpc	r27, r19
   13e84:	d9 f7       	brne	.-10     	; 0x13e7c <FMenuLocalAccount+0x77a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   13e86:	1c 92       	st	X, r1
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   13e88:	8d b7       	in	r24, 0x3d	; 61
   13e8a:	9e b7       	in	r25, 0x3e	; 62
   13e8c:	08 97       	sbiw	r24, 0x08	; 8
   13e8e:	0f b6       	in	r0, 0x3f	; 63
   13e90:	f8 94       	cli
   13e92:	9e bf       	out	0x3e, r25	; 62
   13e94:	0f be       	out	0x3f, r0	; 63
   13e96:	8d bf       	out	0x3d, r24	; 61
   13e98:	2d b7       	in	r18, 0x3d	; 61
   13e9a:	3e b7       	in	r19, 0x3e	; 62
   13e9c:	2f 5f       	subi	r18, 0xFF	; 255
   13e9e:	3f 4f       	sbci	r19, 0xFF	; 255
   13ea0:	ed b7       	in	r30, 0x3d	; 61
   13ea2:	fe b7       	in	r31, 0x3e	; 62
   13ea4:	12 83       	std	Z+2, r17	; 0x02
   13ea6:	01 83       	std	Z+1, r16	; 0x01
   13ea8:	f9 01       	movw	r30, r18
   13eaa:	f3 82       	std	Z+3, r15	; 0x03
   13eac:	e2 82       	std	Z+2, r14	; 0x02
   13eae:	80 91 9a 03 	lds	r24, 0x039A
   13eb2:	90 e0       	ldi	r25, 0x00	; 0
   13eb4:	01 96       	adiw	r24, 0x01	; 1
   13eb6:	95 83       	std	Z+5, r25	; 0x05
   13eb8:	84 83       	std	Z+4, r24	; 0x04
   13eba:	18 97       	sbiw	r26, 0x08	; 8
   13ebc:	b7 83       	std	Z+7, r27	; 0x07
   13ebe:	a6 83       	std	Z+6, r26	; 0x06
   13ec0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   13ec4:	2d b7       	in	r18, 0x3d	; 61
   13ec6:	3e b7       	in	r19, 0x3e	; 62
   13ec8:	28 5f       	subi	r18, 0xF8	; 248
   13eca:	3f 4f       	sbci	r19, 0xFF	; 255
   13ecc:	0f b6       	in	r0, 0x3f	; 63
   13ece:	f8 94       	cli
   13ed0:	3e bf       	out	0x3e, r19	; 62
   13ed2:	0f be       	out	0x3f, r0	; 63
   13ed4:	2d bf       	out	0x3d, r18	; 61
   13ed6:	12 c0       	rjmp	.+36     	; 0x13efc <FMenuLocalAccount+0x7fa>
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   13ed8:	00 d0       	rcall	.+0      	; 0x13eda <FMenuLocalAccount+0x7d8>
   13eda:	00 d0       	rcall	.+0      	; 0x13edc <FMenuLocalAccount+0x7da>
   13edc:	ad b7       	in	r26, 0x3d	; 61
   13ede:	be b7       	in	r27, 0x3e	; 62
   13ee0:	12 96       	adiw	r26, 0x02	; 2
   13ee2:	1c 93       	st	X, r17
   13ee4:	0e 93       	st	-X, r16
   13ee6:	11 97       	sbiw	r26, 0x01	; 1
   13ee8:	14 96       	adiw	r26, 0x04	; 4
   13eea:	dc 92       	st	X, r13
   13eec:	ce 92       	st	-X, r12
   13eee:	13 97       	sbiw	r26, 0x03	; 3
   13ef0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   13ef4:	0f 90       	pop	r0
   13ef6:	0f 90       	pop	r0
   13ef8:	0f 90       	pop	r0
   13efa:	0f 90       	pop	r0
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   13efc:	80 91 9a 03 	lds	r24, 0x039A
   13f00:	68 2f       	mov	r22, r24
   13f02:	66 95       	lsr	r22
   13f04:	6b 9d       	mul	r22, r11
   13f06:	b0 01       	movw	r22, r0
   13f08:	11 24       	eor	r1, r1
   13f0a:	6f 5f       	subi	r22, 0xFF	; 255
   13f0c:	81 70       	andi	r24, 0x01	; 1
   13f0e:	8e 5f       	subi	r24, 0xFE	; 254
   13f10:	a8 01       	movw	r20, r16
   13f12:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
                     stLocalAccount=laSelectBalanceType;
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   13f16:	80 91 9a 03 	lds	r24, 0x039A
   13f1a:	8f 5f       	subi	r24, 0xFF	; 255
   13f1c:	80 93 9a 03 	sts	0x039A, r24
   13f20:	e0 91 9a 03 	lds	r30, 0x039A
   13f24:	e4 30       	cpi	r30, 0x04	; 4
   13f26:	08 f4       	brcc	.+2      	; 0x13f2a <FMenuLocalAccount+0x828>
   13f28:	90 cf       	rjmp	.-224    	; 0x13e4a <FMenuLocalAccount+0x748>
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
				}
	            lcd_printf(4,1,PSTR("[*]Back             "));   //"[*]Back             "				
   13f2a:	84 e0       	ldi	r24, 0x04	; 4
   13f2c:	61 e0       	ldi	r22, 0x01	; 1
   13f2e:	48 e6       	ldi	r20, 0x68	; 104
   13f30:	5f e1       	ldi	r21, 0x1F	; 31
   13f32:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				stLocalAccount=laSelectProductInput;
   13f36:	8c e0       	ldi	r24, 0x0C	; 12
   13f38:	3d c3       	rjmp	.+1658   	; 0x145b4 <FMenuLocalAccount+0xeb2>
				}
		        break; 
           case laSelectProductInput:
				KeyPressed=_key_scan(1);
   13f3a:	81 e0       	ldi	r24, 0x01	; 1
   13f3c:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   13f40:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   13f44:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   13f48:	80 93 a1 03 	sts	0x03A1, r24
				if ((KeyChar>='1')&&(KeyChar<='4')){
   13f4c:	81 53       	subi	r24, 0x31	; 49
   13f4e:	84 30       	cpi	r24, 0x04	; 4
   13f50:	f0 f5       	brcc	.+124    	; 0x13fce <FMenuLocalAccount+0x8cc>
				    iNozzle=KeyChar-'1';
   13f52:	80 93 9a 03 	sts	0x039A, r24
   13f56:	07 e7       	ldi	r16, 0x77	; 119
   13f58:	13 e0       	ldi	r17, 0x03	; 3
   13f5a:	e8 2f       	mov	r30, r24
   13f5c:	f0 e0       	ldi	r31, 0x00	; 0
   13f5e:	e6 57       	subi	r30, 0x76	; 118
   13f60:	fc 4f       	sbci	r31, 0xFC	; 252
   13f62:	60 81       	ld	r22, Z
   13f64:	8d e0       	ldi	r24, 0x0D	; 13
   13f66:	f8 2e       	mov	r15, r24
   13f68:	6f 9d       	mul	r22, r15
   13f6a:	b0 01       	movw	r22, r0
   13f6c:	11 24       	eor	r1, r1
   13f6e:	62 55       	subi	r22, 0x52	; 82
   13f70:	7f 4f       	sbci	r23, 0xFF	; 255
   13f72:	c8 01       	movw	r24, r16
   13f74:	4a e0       	ldi	r20, 0x0A	; 10
   13f76:	50 e0       	ldi	r21, 0x00	; 0
   13f78:	25 ed       	ldi	r18, 0xD5	; 213
   13f7a:	32 e1       	ldi	r19, 0x12	; 18
   13f7c:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
				    eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProductID[iNozzle]-1],10);
					sprintf_P(strProduct,PSTR("%s"),ProductName);
   13f80:	00 d0       	rcall	.+0      	; 0x13f82 <FMenuLocalAccount+0x880>
   13f82:	00 d0       	rcall	.+0      	; 0x13f84 <FMenuLocalAccount+0x882>
   13f84:	00 d0       	rcall	.+0      	; 0x13f86 <FMenuLocalAccount+0x884>
   13f86:	ed b7       	in	r30, 0x3d	; 61
   13f88:	fe b7       	in	r31, 0x3e	; 62
   13f8a:	31 96       	adiw	r30, 0x01	; 1
   13f8c:	81 e9       	ldi	r24, 0x91	; 145
   13f8e:	99 e0       	ldi	r25, 0x09	; 9
   13f90:	ad b7       	in	r26, 0x3d	; 61
   13f92:	be b7       	in	r27, 0x3e	; 62
   13f94:	12 96       	adiw	r26, 0x02	; 2
   13f96:	9c 93       	st	X, r25
   13f98:	8e 93       	st	-X, r24
   13f9a:	11 97       	sbiw	r26, 0x01	; 1
   13f9c:	85 e6       	ldi	r24, 0x65	; 101
   13f9e:	9f e1       	ldi	r25, 0x1F	; 31
   13fa0:	93 83       	std	Z+3, r25	; 0x03
   13fa2:	82 83       	std	Z+2, r24	; 0x02
   13fa4:	15 83       	std	Z+5, r17	; 0x05
   13fa6:	04 83       	std	Z+4, r16	; 0x04
   13fa8:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
					NozzleID=iNozzle+1;
   13fac:	80 91 9a 03 	lds	r24, 0x039A
   13fb0:	8f 5f       	subi	r24, 0xFF	; 255
   13fb2:	80 93 a0 09 	sts	0x09A0, r24
                    stLocalAccount=laSelectBalanceType;
   13fb6:	f0 92 5c 01 	sts	0x015C, r15
					lcd_clear();
   13fba:	ed b7       	in	r30, 0x3d	; 61
   13fbc:	fe b7       	in	r31, 0x3e	; 62
   13fbe:	36 96       	adiw	r30, 0x06	; 6
   13fc0:	0f b6       	in	r0, 0x3f	; 63
   13fc2:	f8 94       	cli
   13fc4:	fe bf       	out	0x3e, r31	; 62
   13fc6:	0f be       	out	0x3f, r0	; 63
   13fc8:	ed bf       	out	0x3d, r30	; 61
   13fca:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
					}                
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laSelectFIP;//Back To Pump Selection
   13fce:	80 91 9c 03 	lds	r24, 0x039C
   13fd2:	87 3e       	cpi	r24, 0xE7	; 231
   13fd4:	09 f0       	breq	.+2      	; 0x13fd8 <FMenuLocalAccount+0x8d6>
   13fd6:	c1 c5       	rjmp	.+2946   	; 0x14b5a <FMenuLocalAccount+0x1458>
   13fd8:	89 e0       	ldi	r24, 0x09	; 9
   13fda:	ec c2       	rjmp	.+1496   	; 0x145b4 <FMenuLocalAccount+0xeb2>
		        break;
           case laSelectBalanceType:
		        lcd_clear();
   13fdc:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		        sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   13fe0:	2d b7       	in	r18, 0x3d	; 61
   13fe2:	3e b7       	in	r19, 0x3e	; 62
   13fe4:	28 50       	subi	r18, 0x08	; 8
   13fe6:	30 40       	sbci	r19, 0x00	; 0
   13fe8:	0f b6       	in	r0, 0x3f	; 63
   13fea:	f8 94       	cli
   13fec:	3e bf       	out	0x3e, r19	; 62
   13fee:	0f be       	out	0x3f, r0	; 63
   13ff0:	2d bf       	out	0x3d, r18	; 61
   13ff2:	ed b7       	in	r30, 0x3d	; 61
   13ff4:	fe b7       	in	r31, 0x3e	; 62
   13ff6:	31 96       	adiw	r30, 0x01	; 1
   13ff8:	8e 01       	movw	r16, r28
   13ffa:	0f 5f       	subi	r16, 0xFF	; 255
   13ffc:	1f 4f       	sbci	r17, 0xFF	; 255
   13ffe:	ad b7       	in	r26, 0x3d	; 61
   14000:	be b7       	in	r27, 0x3e	; 62
   14002:	12 96       	adiw	r26, 0x02	; 2
   14004:	1c 93       	st	X, r17
   14006:	0e 93       	st	-X, r16
   14008:	11 97       	sbiw	r26, 0x01	; 1
   1400a:	8d e5       	ldi	r24, 0x5D	; 93
   1400c:	9f e1       	ldi	r25, 0x1F	; 31
   1400e:	93 83       	std	Z+3, r25	; 0x03
   14010:	82 83       	std	Z+2, r24	; 0x02
   14012:	8d e9       	ldi	r24, 0x9D	; 157
   14014:	93 e0       	ldi	r25, 0x03	; 3
   14016:	95 83       	std	Z+5, r25	; 0x05
   14018:	84 83       	std	Z+4, r24	; 0x04
   1401a:	81 e9       	ldi	r24, 0x91	; 145
   1401c:	99 e0       	ldi	r25, 0x09	; 9
   1401e:	97 83       	std	Z+7, r25	; 0x07
   14020:	86 83       	std	Z+6, r24	; 0x06
   14022:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
				 lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   14026:	ed b7       	in	r30, 0x3d	; 61
   14028:	fe b7       	in	r31, 0x3e	; 62
   1402a:	38 96       	adiw	r30, 0x08	; 8
   1402c:	0f b6       	in	r0, 0x3f	; 63
   1402e:	f8 94       	cli
   14030:	fe bf       	out	0x3e, r31	; 62
   14032:	0f be       	out	0x3f, r0	; 63
   14034:	ed bf       	out	0x3d, r30	; 61
   14036:	81 e0       	ldi	r24, 0x01	; 1
   14038:	61 e0       	ldi	r22, 0x01	; 1
   1403a:	a8 01       	movw	r20, r16
   1403c:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		        lcd_printf(2,1,PSTR("[1]Volume           "));   //"[1]Premium          "                                                                      
   14040:	82 e0       	ldi	r24, 0x02	; 2
   14042:	61 e0       	ldi	r22, 0x01	; 1
   14044:	48 e4       	ldi	r20, 0x48	; 72
   14046:	5f e1       	ldi	r21, 0x1F	; 31
   14048:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				lcd_printf(3,1,PSTR("[2]Amount           "));   //"[2]Pertamax         "
   1404c:	83 e0       	ldi	r24, 0x03	; 3
   1404e:	61 e0       	ldi	r22, 0x01	; 1
   14050:	43 e3       	ldi	r20, 0x33	; 51
   14052:	5f e1       	ldi	r21, 0x1F	; 31
   14054:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
   14058:	84 e0       	ldi	r24, 0x04	; 4
   1405a:	61 e0       	ldi	r22, 0x01	; 1
   1405c:	4e e1       	ldi	r20, 0x1E	; 30
   1405e:	5f e1       	ldi	r21, 0x1F	; 31
   14060:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	            //lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
                stLocalAccount=laSelectBalanceTypeInput;   
   14064:	8e e0       	ldi	r24, 0x0E	; 14
   14066:	a6 c2       	rjmp	.+1356   	; 0x145b4 <FMenuLocalAccount+0xeb2>
		        break;
           case laSelectBalanceTypeInput:
				KeyPressed=_key_scan(1);
   14068:	81 e0       	ldi	r24, 0x01	; 1
   1406a:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   1406e:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   14072:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   14076:	98 2f       	mov	r25, r24
   14078:	80 93 a1 03 	sts	0x03A1, r24
				if ((KeyChar>='1')&&(KeyChar<='2')){
   1407c:	81 53       	subi	r24, 0x31	; 49
   1407e:	82 30       	cpi	r24, 0x02	; 2
   14080:	80 f5       	brcc	.+96     	; 0x140e2 <FMenuLocalAccount+0x9e0>
                    if(KeyChar=='1'){
   14082:	91 33       	cpi	r25, 0x31	; 49
   14084:	a1 f4       	brne	.+40     	; 0x140ae <FMenuLocalAccount+0x9ac>
					   BalanceType=1;
   14086:	81 e0       	ldi	r24, 0x01	; 1
   14088:	80 93 a0 03 	sts	0x03A0, r24
					   sprintf_P(strBalanceType,PSTR("V"));
   1408c:	00 d0       	rcall	.+0      	; 0x1408e <FMenuLocalAccount+0x98c>
   1408e:	00 d0       	rcall	.+0      	; 0x14090 <FMenuLocalAccount+0x98e>
   14090:	83 ed       	ldi	r24, 0xD3	; 211
   14092:	95 e0       	ldi	r25, 0x05	; 5
   14094:	ad b7       	in	r26, 0x3d	; 61
   14096:	be b7       	in	r27, 0x3e	; 62
   14098:	12 96       	adiw	r26, 0x02	; 2
   1409a:	9c 93       	st	X, r25
   1409c:	8e 93       	st	-X, r24
   1409e:	11 97       	sbiw	r26, 0x01	; 1
   140a0:	8c e1       	ldi	r24, 0x1C	; 28
   140a2:	9f e1       	ldi	r25, 0x1F	; 31
   140a4:	14 96       	adiw	r26, 0x04	; 4
   140a6:	9c 93       	st	X, r25
   140a8:	8e 93       	st	-X, r24
   140aa:	13 97       	sbiw	r26, 0x03	; 3
   140ac:	11 c0       	rjmp	.+34     	; 0x140d0 <FMenuLocalAccount+0x9ce>
					   }
					else
                    if(KeyChar=='2'){
   140ae:	92 33       	cpi	r25, 0x32	; 50
   140b0:	a9 f4       	brne	.+42     	; 0x140dc <FMenuLocalAccount+0x9da>
					   BalanceType=2;
   140b2:	82 e0       	ldi	r24, 0x02	; 2
   140b4:	80 93 a0 03 	sts	0x03A0, r24
                       sprintf_P(strBalanceType,PSTR("A"));
   140b8:	00 d0       	rcall	.+0      	; 0x140ba <FMenuLocalAccount+0x9b8>
   140ba:	00 d0       	rcall	.+0      	; 0x140bc <FMenuLocalAccount+0x9ba>
   140bc:	83 ed       	ldi	r24, 0xD3	; 211
   140be:	95 e0       	ldi	r25, 0x05	; 5
   140c0:	ed b7       	in	r30, 0x3d	; 61
   140c2:	fe b7       	in	r31, 0x3e	; 62
   140c4:	92 83       	std	Z+2, r25	; 0x02
   140c6:	81 83       	std	Z+1, r24	; 0x01
   140c8:	8a e1       	ldi	r24, 0x1A	; 26
   140ca:	9f e1       	ldi	r25, 0x1F	; 31
   140cc:	94 83       	std	Z+4, r25	; 0x04
   140ce:	83 83       	std	Z+3, r24	; 0x03
   140d0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   140d4:	0f 90       	pop	r0
   140d6:	0f 90       	pop	r0
   140d8:	0f 90       	pop	r0
   140da:	0f 90       	pop	r0
					   }
				    stLocalAccount=laBalanceValue;  
   140dc:	8f e0       	ldi	r24, 0x0F	; 15
   140de:	80 93 5c 01 	sts	0x015C, r24
					}              
				if (KeyPressed==_KEY_CANCEL){
   140e2:	80 91 9c 03 	lds	r24, 0x039C
   140e6:	87 3e       	cpi	r24, 0xE7	; 231
   140e8:	c9 f4       	brne	.+50     	; 0x1411c <FMenuLocalAccount+0xa1a>
				    if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&(ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0))
   140ea:	80 91 8a 03 	lds	r24, 0x038A
   140ee:	81 50       	subi	r24, 0x01	; 1
   140f0:	86 30       	cpi	r24, 0x06	; 6
   140f2:	70 f4       	brcc	.+28     	; 0x14110 <FMenuLocalAccount+0xa0e>
   140f4:	80 91 8b 03 	lds	r24, 0x038B
   140f8:	88 23       	and	r24, r24
   140fa:	51 f4       	brne	.+20     	; 0x14110 <FMenuLocalAccount+0xa0e>
   140fc:	80 91 8c 03 	lds	r24, 0x038C
   14100:	88 23       	and	r24, r24
   14102:	31 f4       	brne	.+12     	; 0x14110 <FMenuLocalAccount+0xa0e>
   14104:	80 91 8d 03 	lds	r24, 0x038D
   14108:	88 23       	and	r24, r24
   1410a:	11 f4       	brne	.+4      	; 0x14110 <FMenuLocalAccount+0xa0e>
					     stLocalAccount=laSelectFIP;//Back To FIP Select Non MPD
   1410c:	89 e0       	ldi	r24, 0x09	; 9
   1410e:	01 c0       	rjmp	.+2      	; 0x14112 <FMenuLocalAccount+0xa10>
                    else stLocalAccount=laSelectProduct;//Back To Product Selection MPD
   14110:	8b e0       	ldi	r24, 0x0B	; 11
   14112:	80 93 5c 01 	sts	0x015C, r24
					lcd_clear();
   14116:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
   1411a:	1f c5       	rjmp	.+2622   	; 0x14b5a <FMenuLocalAccount+0x1458>
					}
                else
				if (KeyPressed==_KEY_ENTER){
   1411c:	87 3b       	cpi	r24, 0xB7	; 183
   1411e:	09 f0       	breq	.+2      	; 0x14122 <FMenuLocalAccount+0xa20>
   14120:	1c c5       	rjmp	.+2616   	; 0x14b5a <FMenuLocalAccount+0x1458>
				    BalanceType=1;
   14122:	11 e0       	ldi	r17, 0x01	; 1
   14124:	10 93 a0 03 	sts	0x03A0, r17
					sprintf_P(strBalanceType,PSTR("A"));
   14128:	00 d0       	rcall	.+0      	; 0x1412a <FMenuLocalAccount+0xa28>
   1412a:	00 d0       	rcall	.+0      	; 0x1412c <FMenuLocalAccount+0xa2a>
   1412c:	83 ed       	ldi	r24, 0xD3	; 211
   1412e:	95 e0       	ldi	r25, 0x05	; 5
   14130:	ad b7       	in	r26, 0x3d	; 61
   14132:	be b7       	in	r27, 0x3e	; 62
   14134:	12 96       	adiw	r26, 0x02	; 2
   14136:	9c 93       	st	X, r25
   14138:	8e 93       	st	-X, r24
   1413a:	11 97       	sbiw	r26, 0x01	; 1
   1413c:	88 e1       	ldi	r24, 0x18	; 24
   1413e:	9f e1       	ldi	r25, 0x1F	; 31
   14140:	14 96       	adiw	r26, 0x04	; 4
   14142:	9c 93       	st	X, r25
   14144:	8e 93       	st	-X, r24
   14146:	13 97       	sbiw	r26, 0x03	; 3
   14148:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
					//sprintf_P(strBalanceValue,PSTR("999"));
					IsFullAuthorized=True;
   1414c:	10 93 74 03 	sts	0x0374, r17
                    stLocalAccount=laOdometer;//FullAuthorized
   14150:	81 e1       	ldi	r24, 0x11	; 17
   14152:	80 93 5c 01 	sts	0x015C, r24
   14156:	80 e0       	ldi	r24, 0x00	; 0
   14158:	0f 90       	pop	r0
   1415a:	0f 90       	pop	r0
   1415c:	0f 90       	pop	r0
   1415e:	0f 90       	pop	r0
   14160:	fd c4       	rjmp	.+2554   	; 0x14b5c <FMenuLocalAccount+0x145a>
					}

		        break;
           case laBalanceValue:
		        lcd_clear();
   14162:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		        if(BalanceType==1){
   14166:	80 91 a0 03 	lds	r24, 0x03A0
   1416a:	81 30       	cpi	r24, 0x01	; 1
   1416c:	f1 f5       	brne	.+124    	; 0x141ea <FMenuLocalAccount+0xae8>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   1416e:	ed b7       	in	r30, 0x3d	; 61
   14170:	fe b7       	in	r31, 0x3e	; 62
   14172:	38 97       	sbiw	r30, 0x08	; 8
   14174:	0f b6       	in	r0, 0x3f	; 63
   14176:	f8 94       	cli
   14178:	fe bf       	out	0x3e, r31	; 62
   1417a:	0f be       	out	0x3f, r0	; 63
   1417c:	ed bf       	out	0x3d, r30	; 61
   1417e:	31 96       	adiw	r30, 0x01	; 1
   14180:	8e 01       	movw	r16, r28
   14182:	0f 5f       	subi	r16, 0xFF	; 255
   14184:	1f 4f       	sbci	r17, 0xFF	; 255
   14186:	ad b7       	in	r26, 0x3d	; 61
   14188:	be b7       	in	r27, 0x3e	; 62
   1418a:	12 96       	adiw	r26, 0x02	; 2
   1418c:	1c 93       	st	X, r17
   1418e:	0e 93       	st	-X, r16
   14190:	11 97       	sbiw	r26, 0x01	; 1
   14192:	80 e1       	ldi	r24, 0x10	; 16
   14194:	9f e1       	ldi	r25, 0x1F	; 31
   14196:	93 83       	std	Z+3, r25	; 0x03
   14198:	82 83       	std	Z+2, r24	; 0x02
   1419a:	8d e9       	ldi	r24, 0x9D	; 157
   1419c:	93 e0       	ldi	r25, 0x03	; 3
   1419e:	95 83       	std	Z+5, r25	; 0x05
   141a0:	84 83       	std	Z+4, r24	; 0x04
   141a2:	81 e9       	ldi	r24, 0x91	; 145
   141a4:	99 e0       	ldi	r25, 0x09	; 9
   141a6:	97 83       	std	Z+7, r25	; 0x07
   141a8:	86 83       	std	Z+6, r24	; 0x06
   141aa:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
				    lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   141ae:	ed b7       	in	r30, 0x3d	; 61
   141b0:	fe b7       	in	r31, 0x3e	; 62
   141b2:	38 96       	adiw	r30, 0x08	; 8
   141b4:	0f b6       	in	r0, 0x3f	; 63
   141b6:	f8 94       	cli
   141b8:	fe bf       	out	0x3e, r31	; 62
   141ba:	0f be       	out	0x3f, r0	; 63
   141bc:	ed bf       	out	0x3d, r30	; 61
   141be:	81 e0       	ldi	r24, 0x01	; 1
   141c0:	61 e0       	ldi	r22, 0x01	; 1
   141c2:	a8 01       	movw	r20, r16
   141c4:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		           lcd_printf(2,1,PSTR("[1]Volume:_         "));   //"[1]Volume:_         "                                                                      
   141c8:	82 e0       	ldi	r24, 0x02	; 2
   141ca:	61 e0       	ldi	r22, 0x01	; 1
   141cc:	4b ef       	ldi	r20, 0xFB	; 251
   141ce:	5e e1       	ldi	r21, 0x1E	; 30
   141d0:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				   lcd_printf(3,1,PSTR("                    "));   //"                    "
   141d4:	83 e0       	ldi	r24, 0x03	; 3
   141d6:	61 e0       	ldi	r22, 0x01	; 1
   141d8:	46 ee       	ldi	r20, 0xE6	; 230
   141da:	5e e1       	ldi	r21, 0x1E	; 30
   141dc:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK     "						        
   141e0:	84 e0       	ldi	r24, 0x04	; 4
   141e2:	61 e0       	ldi	r22, 0x01	; 1
   141e4:	41 ed       	ldi	r20, 0xD1	; 209
   141e6:	5e e1       	ldi	r21, 0x1E	; 30
   141e8:	43 c0       	rjmp	.+134    	; 0x14270 <FMenuLocalAccount+0xb6e>
				   }
                else
		        if(BalanceType==2){
   141ea:	82 30       	cpi	r24, 0x02	; 2
   141ec:	09 f0       	breq	.+2      	; 0x141f0 <FMenuLocalAccount+0xaee>
   141ee:	42 c0       	rjmp	.+132    	; 0x14274 <FMenuLocalAccount+0xb72>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   141f0:	2d b7       	in	r18, 0x3d	; 61
   141f2:	3e b7       	in	r19, 0x3e	; 62
   141f4:	28 50       	subi	r18, 0x08	; 8
   141f6:	30 40       	sbci	r19, 0x00	; 0
   141f8:	0f b6       	in	r0, 0x3f	; 63
   141fa:	f8 94       	cli
   141fc:	3e bf       	out	0x3e, r19	; 62
   141fe:	0f be       	out	0x3f, r0	; 63
   14200:	2d bf       	out	0x3d, r18	; 61
   14202:	ed b7       	in	r30, 0x3d	; 61
   14204:	fe b7       	in	r31, 0x3e	; 62
   14206:	31 96       	adiw	r30, 0x01	; 1
   14208:	8e 01       	movw	r16, r28
   1420a:	0f 5f       	subi	r16, 0xFF	; 255
   1420c:	1f 4f       	sbci	r17, 0xFF	; 255
   1420e:	ad b7       	in	r26, 0x3d	; 61
   14210:	be b7       	in	r27, 0x3e	; 62
   14212:	12 96       	adiw	r26, 0x02	; 2
   14214:	1c 93       	st	X, r17
   14216:	0e 93       	st	-X, r16
   14218:	11 97       	sbiw	r26, 0x01	; 1
   1421a:	89 ec       	ldi	r24, 0xC9	; 201
   1421c:	9e e1       	ldi	r25, 0x1E	; 30
   1421e:	93 83       	std	Z+3, r25	; 0x03
   14220:	82 83       	std	Z+2, r24	; 0x02
   14222:	8d e9       	ldi	r24, 0x9D	; 157
   14224:	93 e0       	ldi	r25, 0x03	; 3
   14226:	95 83       	std	Z+5, r25	; 0x05
   14228:	84 83       	std	Z+4, r24	; 0x04
   1422a:	81 e9       	ldi	r24, 0x91	; 145
   1422c:	99 e0       	ldi	r25, 0x09	; 9
   1422e:	97 83       	std	Z+7, r25	; 0x07
   14230:	86 83       	std	Z+6, r24	; 0x06
   14232:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
				   lcd_print(1,1,lcdteks);                         //"P01-Pertamax        "                                                                      
   14236:	ed b7       	in	r30, 0x3d	; 61
   14238:	fe b7       	in	r31, 0x3e	; 62
   1423a:	38 96       	adiw	r30, 0x08	; 8
   1423c:	0f b6       	in	r0, 0x3f	; 63
   1423e:	f8 94       	cli
   14240:	fe bf       	out	0x3e, r31	; 62
   14242:	0f be       	out	0x3f, r0	; 63
   14244:	ed bf       	out	0x3d, r30	; 61
   14246:	81 e0       	ldi	r24, 0x01	; 1
   14248:	61 e0       	ldi	r22, 0x01	; 1
   1424a:	a8 01       	movw	r20, r16
   1424c:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		           lcd_printf(2,1,PSTR("                    "));   //"                    "                                                                      
   14250:	82 e0       	ldi	r24, 0x02	; 2
   14252:	61 e0       	ldi	r22, 0x01	; 1
   14254:	44 eb       	ldi	r20, 0xB4	; 180
   14256:	5e e1       	ldi	r21, 0x1E	; 30
   14258:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				   lcd_printf(3,1,PSTR("[2]Amount:_         "));   //"[2]Amount:_         "
   1425c:	83 e0       	ldi	r24, 0x03	; 3
   1425e:	61 e0       	ldi	r22, 0x01	; 1
   14260:	4f e9       	ldi	r20, 0x9F	; 159
   14262:	5e e1       	ldi	r21, 0x1E	; 30
   14264:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK      "			        
   14268:	84 e0       	ldi	r24, 0x04	; 4
   1426a:	61 e0       	ldi	r22, 0x01	; 1
   1426c:	4a e8       	ldi	r20, 0x8A	; 138
   1426e:	5e e1       	ldi	r21, 0x1E	; 30
   14270:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				   }
                iLoop=0;
   14274:	10 92 73 03 	sts	0x0373, r1
   14278:	10 92 72 03 	sts	0x0372, r1
				iValuePos=0;
   1427c:	10 92 9b 03 	sts	0x039B, r1
				ValueChar[iValuePos]=' ';
   14280:	80 e2       	ldi	r24, 0x20	; 32
   14282:	80 93 90 03 	sts	0x0390, r24
		        stLocalAccount=laBalanceValueInput;  
   14286:	80 e1       	ldi	r24, 0x10	; 16
   14288:	95 c1       	rjmp	.+810    	; 0x145b4 <FMenuLocalAccount+0xeb2>
		        break; 
           case laBalanceValueInput:
			    //Blinking 50% _      BalanceValue Volume=999  Amount=65536
			    iLoop++;
   1428a:	80 91 72 03 	lds	r24, 0x0372
   1428e:	90 91 73 03 	lds	r25, 0x0373
   14292:	01 96       	adiw	r24, 0x01	; 1
   14294:	90 93 73 03 	sts	0x0373, r25
   14298:	80 93 72 03 	sts	0x0372, r24
			    //GetKeyPressed
			    KeyPressed=_key_scan(1);
   1429c:	81 e0       	ldi	r24, 0x01	; 1
   1429e:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   142a2:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   142a6:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   142aa:	98 2f       	mov	r25, r24
   142ac:	80 93 a1 03 	sts	0x03A1, r24
				if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<6)&&(BalanceType==2))||//Max Rp.999999
   142b0:	80 53       	subi	r24, 0x30	; 48
   142b2:	8a 30       	cpi	r24, 0x0A	; 10
   142b4:	38 f5       	brcc	.+78     	; 0x14304 <FMenuLocalAccount+0xc02>
   142b6:	e0 91 9b 03 	lds	r30, 0x039B
   142ba:	e6 30       	cpi	r30, 0x06	; 6
   142bc:	18 f5       	brcc	.+70     	; 0x14304 <FMenuLocalAccount+0xc02>
   142be:	80 91 a0 03 	lds	r24, 0x03A0
   142c2:	82 30       	cpi	r24, 0x02	; 2
   142c4:	21 f0       	breq	.+8      	; 0x142ce <FMenuLocalAccount+0xbcc>
   142c6:	e3 30       	cpi	r30, 0x03	; 3
   142c8:	e8 f4       	brcc	.+58     	; 0x14304 <FMenuLocalAccount+0xc02>
   142ca:	81 30       	cpi	r24, 0x01	; 1
   142cc:	d9 f4       	brne	.+54     	; 0x14304 <FMenuLocalAccount+0xc02>
				   ((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<3)&&(BalanceType==1))){ //Max       999L
				    ValueChar[iValuePos]=KeyChar;
   142ce:	f0 e0       	ldi	r31, 0x00	; 0
   142d0:	e0 57       	subi	r30, 0x70	; 112
   142d2:	fc 4f       	sbci	r31, 0xFC	; 252
   142d4:	90 83       	st	Z, r25
					iValuePos++;
   142d6:	60 91 9b 03 	lds	r22, 0x039B
   142da:	6f 5f       	subi	r22, 0xFF	; 255
   142dc:	60 93 9b 03 	sts	0x039B, r22
					lcd_xy(1+BalanceType,(10+iValuePos));_lcd(ValueChar[iValuePos-1]); 
   142e0:	80 91 a0 03 	lds	r24, 0x03A0
   142e4:	66 5f       	subi	r22, 0xF6	; 246
   142e6:	8f 5f       	subi	r24, 0xFF	; 255
   142e8:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
   142ec:	e0 91 9b 03 	lds	r30, 0x039B
   142f0:	f0 e0       	ldi	r31, 0x00	; 0
   142f2:	e1 57       	subi	r30, 0x71	; 113
   142f4:	fc 4f       	sbci	r31, 0xFC	; 252
   142f6:	80 81       	ld	r24, Z
   142f8:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
   142fc:	80 e5       	ldi	r24, 0x50	; 80
   142fe:	93 ec       	ldi	r25, 0xC3	; 195
   14300:	01 97       	sbiw	r24, 0x01	; 1
   14302:	f1 f7       	brne	.-4      	; 0x14300 <FMenuLocalAccount+0xbfe>
					_delay_ms(200);
					}
			    if ((iLoop%2000)==0){
   14304:	80 91 72 03 	lds	r24, 0x0372
   14308:	90 91 73 03 	lds	r25, 0x0373
   1430c:	60 ed       	ldi	r22, 0xD0	; 208
   1430e:	77 e0       	ldi	r23, 0x07	; 7
   14310:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
   14314:	89 2b       	or	r24, r25
   14316:	59 f4       	brne	.+22     	; 0x1432e <FMenuLocalAccount+0xc2c>
				     lcd_xy((1+BalanceType),(11+iValuePos));_lcd('_'); 
   14318:	80 91 a0 03 	lds	r24, 0x03A0
   1431c:	60 91 9b 03 	lds	r22, 0x039B
   14320:	65 5f       	subi	r22, 0xF5	; 245
   14322:	8f 5f       	subi	r24, 0xFF	; 255
   14324:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
   14328:	8f e5       	ldi	r24, 0x5F	; 95
   1432a:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
			    }
			    if ((iLoop%2000)==1000){
   1432e:	80 91 72 03 	lds	r24, 0x0372
   14332:	90 91 73 03 	lds	r25, 0x0373
   14336:	60 ed       	ldi	r22, 0xD0	; 208
   14338:	77 e0       	ldi	r23, 0x07	; 7
   1433a:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
   1433e:	88 5e       	subi	r24, 0xE8	; 232
   14340:	93 40       	sbci	r25, 0x03	; 3
   14342:	59 f4       	brne	.+22     	; 0x1435a <FMenuLocalAccount+0xc58>
				     lcd_xy((1+BalanceType),(11+iValuePos));_lcd(' '); 
   14344:	80 91 a0 03 	lds	r24, 0x03A0
   14348:	60 91 9b 03 	lds	r22, 0x039B
   1434c:	65 5f       	subi	r22, 0xF5	; 245
   1434e:	8f 5f       	subi	r24, 0xFF	; 255
   14350:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
   14354:	80 e2       	ldi	r24, 0x20	; 32
   14356:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
			    }
				if (KeyPressed==_KEY_CANCEL){
   1435a:	80 91 9c 03 	lds	r24, 0x039C
   1435e:	87 3e       	cpi	r24, 0xE7	; 231
   14360:	39 f4       	brne	.+14     	; 0x14370 <FMenuLocalAccount+0xc6e>
				    lcd_clear();
   14362:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
   14366:	88 ea       	ldi	r24, 0xA8	; 168
   14368:	91 e6       	ldi	r25, 0x61	; 97
   1436a:	01 97       	sbiw	r24, 0x01	; 1
   1436c:	f1 f7       	brne	.-4      	; 0x1436a <FMenuLocalAccount+0xc68>
   1436e:	1f c1       	rjmp	.+574    	; 0x145ae <FMenuLocalAccount+0xeac>
					_delay_ms(100);		        
				    stLocalAccount=laSelectBalanceType;		        
					}
				else
				if (KeyPressed==_KEY_ENTER){				    
   14370:	87 3b       	cpi	r24, 0xB7	; 183
   14372:	09 f0       	breq	.+2      	; 0x14376 <FMenuLocalAccount+0xc74>
   14374:	f2 c3       	rjmp	.+2020   	; 0x14b5a <FMenuLocalAccount+0x1458>
                    ValueChar[iValuePos]=0;
   14376:	e0 91 9b 03 	lds	r30, 0x039B
   1437a:	f0 e0       	ldi	r31, 0x00	; 0
   1437c:	e0 57       	subi	r30, 0x70	; 112
   1437e:	fc 4f       	sbci	r31, 0xFC	; 252
   14380:	10 82       	st	Z, r1
					sprintf_P(strBalanceValue,PSTR("%s"),ValueChar);
   14382:	00 d0       	rcall	.+0      	; 0x14384 <FMenuLocalAccount+0xc82>
   14384:	00 d0       	rcall	.+0      	; 0x14386 <FMenuLocalAccount+0xc84>
   14386:	00 d0       	rcall	.+0      	; 0x14388 <FMenuLocalAccount+0xc86>
   14388:	ed b7       	in	r30, 0x3d	; 61
   1438a:	fe b7       	in	r31, 0x3e	; 62
   1438c:	31 96       	adiw	r30, 0x01	; 1
   1438e:	8a e4       	ldi	r24, 0x4A	; 74
   14390:	9e e0       	ldi	r25, 0x0E	; 14
   14392:	ad b7       	in	r26, 0x3d	; 61
   14394:	be b7       	in	r27, 0x3e	; 62
   14396:	12 96       	adiw	r26, 0x02	; 2
   14398:	9c 93       	st	X, r25
   1439a:	8e 93       	st	-X, r24
   1439c:	11 97       	sbiw	r26, 0x01	; 1
   1439e:	87 e8       	ldi	r24, 0x87	; 135
   143a0:	9e e1       	ldi	r25, 0x1E	; 30
   143a2:	93 83       	std	Z+3, r25	; 0x03
   143a4:	82 83       	std	Z+2, r24	; 0x02
   143a6:	80 e9       	ldi	r24, 0x90	; 144
   143a8:	93 e0       	ldi	r25, 0x03	; 3
   143aa:	95 83       	std	Z+5, r25	; 0x05
   143ac:	84 83       	std	Z+4, r24	; 0x04
   143ae:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
				    stLocalAccount=laOdometer;
   143b2:	81 e1       	ldi	r24, 0x11	; 17
   143b4:	80 93 5c 01 	sts	0x015C, r24
					lcd_clear();
   143b8:	ed b7       	in	r30, 0x3d	; 61
   143ba:	fe b7       	in	r31, 0x3e	; 62
   143bc:	36 96       	adiw	r30, 0x06	; 6
   143be:	0f b6       	in	r0, 0x3f	; 63
   143c0:	f8 94       	cli
   143c2:	fe bf       	out	0x3e, r31	; 62
   143c4:	0f be       	out	0x3f, r0	; 63
   143c6:	ed bf       	out	0x3d, r30	; 61
   143c8:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
   143cc:	88 ea       	ldi	r24, 0xA8	; 168
   143ce:	91 e6       	ldi	r25, 0x61	; 97
   143d0:	01 97       	sbiw	r24, 0x01	; 1
   143d2:	f1 f7       	brne	.-4      	; 0x143d0 <FMenuLocalAccount+0xcce>
   143d4:	c2 c3       	rjmp	.+1924   	; 0x14b5a <FMenuLocalAccount+0x1458>
					_delay_ms(100);		        
					}
		        break;
           case laOdometer://GetOdometer			
		        lcd_clear();
   143d6:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
				if (IsFullAuthorized==True){
   143da:	80 91 74 03 	lds	r24, 0x0374
   143de:	81 30       	cpi	r24, 0x01	; 1
   143e0:	09 f0       	breq	.+2      	; 0x143e4 <FMenuLocalAccount+0xce2>
   143e2:	4a c0       	rjmp	.+148    	; 0x14478 <FMenuLocalAccount+0xd76>
				    lcd_printf(1,1,PSTR("Pump Product   Full"));
   143e4:	61 e0       	ldi	r22, 0x01	; 1
   143e6:	43 e7       	ldi	r20, 0x73	; 115
   143e8:	5e e1       	ldi	r21, 0x1E	; 30
   143ea:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   143ee:	2d b7       	in	r18, 0x3d	; 61
   143f0:	3e b7       	in	r19, 0x3e	; 62
   143f2:	28 50       	subi	r18, 0x08	; 8
   143f4:	30 40       	sbci	r19, 0x00	; 0
   143f6:	0f b6       	in	r0, 0x3f	; 63
   143f8:	f8 94       	cli
   143fa:	3e bf       	out	0x3e, r19	; 62
   143fc:	0f be       	out	0x3f, r0	; 63
   143fe:	2d bf       	out	0x3d, r18	; 61
   14400:	ed b7       	in	r30, 0x3d	; 61
   14402:	fe b7       	in	r31, 0x3e	; 62
   14404:	31 96       	adiw	r30, 0x01	; 1
   14406:	8e 01       	movw	r16, r28
   14408:	0f 5f       	subi	r16, 0xFF	; 255
   1440a:	1f 4f       	sbci	r17, 0xFF	; 255
   1440c:	ad b7       	in	r26, 0x3d	; 61
   1440e:	be b7       	in	r27, 0x3e	; 62
   14410:	12 96       	adiw	r26, 0x02	; 2
   14412:	1c 93       	st	X, r17
   14414:	0e 93       	st	-X, r16
   14416:	11 97       	sbiw	r26, 0x01	; 1
   14418:	8a e6       	ldi	r24, 0x6A	; 106
   1441a:	9e e1       	ldi	r25, 0x1E	; 30
   1441c:	93 83       	std	Z+3, r25	; 0x03
   1441e:	82 83       	std	Z+2, r24	; 0x02
   14420:	8d e9       	ldi	r24, 0x9D	; 157
   14422:	93 e0       	ldi	r25, 0x03	; 3
   14424:	95 83       	std	Z+5, r25	; 0x05
   14426:	84 83       	std	Z+4, r24	; 0x04
   14428:	81 e9       	ldi	r24, 0x91	; 145
   1442a:	99 e0       	ldi	r25, 0x09	; 9
   1442c:	97 83       	std	Z+7, r25	; 0x07
   1442e:	86 83       	std	Z+6, r24	; 0x06
   14430:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   14434:	ed b7       	in	r30, 0x3d	; 61
   14436:	fe b7       	in	r31, 0x3e	; 62
   14438:	38 96       	adiw	r30, 0x08	; 8
   1443a:	0f b6       	in	r0, 0x3f	; 63
   1443c:	f8 94       	cli
   1443e:	fe bf       	out	0x3e, r31	; 62
   14440:	0f be       	out	0x3f, r0	; 63
   14442:	ed bf       	out	0x3d, r30	; 61
   14444:	82 e0       	ldi	r24, 0x02	; 2
   14446:	61 e0       	ldi	r22, 0x01	; 1
   14448:	a8 01       	movw	r20, r16
   1444a:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		            sprintf_P(lcdteks,PSTR("  Tank"));            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   1444e:	00 d0       	rcall	.+0      	; 0x14450 <FMenuLocalAccount+0xd4e>
   14450:	00 d0       	rcall	.+0      	; 0x14452 <FMenuLocalAccount+0xd50>
   14452:	ad b7       	in	r26, 0x3d	; 61
   14454:	be b7       	in	r27, 0x3e	; 62
   14456:	12 96       	adiw	r26, 0x02	; 2
   14458:	1c 93       	st	X, r17
   1445a:	0e 93       	st	-X, r16
   1445c:	11 97       	sbiw	r26, 0x01	; 1
   1445e:	83 e6       	ldi	r24, 0x63	; 99
   14460:	9e e1       	ldi	r25, 0x1E	; 30
   14462:	14 96       	adiw	r26, 0x04	; 4
   14464:	9c 93       	st	X, r25
   14466:	8e 93       	st	-X, r24
   14468:	13 97       	sbiw	r26, 0x03	; 3
   1446a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   1446e:	0f 90       	pop	r0
   14470:	0f 90       	pop	r0
   14472:	0f 90       	pop	r0
   14474:	0f 90       	pop	r0
   14476:	5e c0       	rjmp	.+188    	; 0x14534 <FMenuLocalAccount+0xe32>
				}
                else{
		            if (BalanceType==1) lcd_printf(1,1,PSTR("Pump Product Volume"));
   14478:	80 91 a0 03 	lds	r24, 0x03A0
   1447c:	81 30       	cpi	r24, 0x01	; 1
   1447e:	29 f4       	brne	.+10     	; 0x1448a <FMenuLocalAccount+0xd88>
   14480:	61 e0       	ldi	r22, 0x01	; 1
   14482:	4f e4       	ldi	r20, 0x4F	; 79
   14484:	5e e1       	ldi	r21, 0x1E	; 30
   14486:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
                    if (BalanceType==2) lcd_printf(1,1,PSTR("Pump Product Amount"));//"Pump Product  Amount" 
   1448a:	80 91 a0 03 	lds	r24, 0x03A0
   1448e:	82 30       	cpi	r24, 0x02	; 2
   14490:	31 f4       	brne	.+12     	; 0x1449e <FMenuLocalAccount+0xd9c>
   14492:	81 e0       	ldi	r24, 0x01	; 1
   14494:	61 e0       	ldi	r22, 0x01	; 1
   14496:	4b e3       	ldi	r20, 0x3B	; 59
   14498:	5e e1       	ldi	r21, 0x1E	; 30
   1449a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   1449e:	ed b7       	in	r30, 0x3d	; 61
   144a0:	fe b7       	in	r31, 0x3e	; 62
   144a2:	38 97       	sbiw	r30, 0x08	; 8
   144a4:	0f b6       	in	r0, 0x3f	; 63
   144a6:	f8 94       	cli
   144a8:	fe bf       	out	0x3e, r31	; 62
   144aa:	0f be       	out	0x3f, r0	; 63
   144ac:	ed bf       	out	0x3d, r30	; 61
   144ae:	31 96       	adiw	r30, 0x01	; 1
   144b0:	8e 01       	movw	r16, r28
   144b2:	0f 5f       	subi	r16, 0xFF	; 255
   144b4:	1f 4f       	sbci	r17, 0xFF	; 255
   144b6:	ad b7       	in	r26, 0x3d	; 61
   144b8:	be b7       	in	r27, 0x3e	; 62
   144ba:	12 96       	adiw	r26, 0x02	; 2
   144bc:	1c 93       	st	X, r17
   144be:	0e 93       	st	-X, r16
   144c0:	11 97       	sbiw	r26, 0x01	; 1
   144c2:	82 e3       	ldi	r24, 0x32	; 50
   144c4:	9e e1       	ldi	r25, 0x1E	; 30
   144c6:	93 83       	std	Z+3, r25	; 0x03
   144c8:	82 83       	std	Z+2, r24	; 0x02
   144ca:	8d e9       	ldi	r24, 0x9D	; 157
   144cc:	93 e0       	ldi	r25, 0x03	; 3
   144ce:	95 83       	std	Z+5, r25	; 0x05
   144d0:	84 83       	std	Z+4, r24	; 0x04
   144d2:	81 e9       	ldi	r24, 0x91	; 145
   144d4:	99 e0       	ldi	r25, 0x09	; 9
   144d6:	97 83       	std	Z+7, r25	; 0x07
   144d8:	86 83       	std	Z+6, r24	; 0x06
   144da:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   144de:	ed b7       	in	r30, 0x3d	; 61
   144e0:	fe b7       	in	r31, 0x3e	; 62
   144e2:	38 96       	adiw	r30, 0x08	; 8
   144e4:	0f b6       	in	r0, 0x3f	; 63
   144e6:	f8 94       	cli
   144e8:	fe bf       	out	0x3e, r31	; 62
   144ea:	0f be       	out	0x3f, r0	; 63
   144ec:	ed bf       	out	0x3d, r30	; 61
   144ee:	82 e0       	ldi	r24, 0x02	; 2
   144f0:	61 e0       	ldi	r22, 0x01	; 1
   144f2:	a8 01       	movw	r20, r16
   144f4:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		            sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   144f8:	00 d0       	rcall	.+0      	; 0x144fa <FMenuLocalAccount+0xdf8>
   144fa:	00 d0       	rcall	.+0      	; 0x144fc <FMenuLocalAccount+0xdfa>
   144fc:	00 d0       	rcall	.+0      	; 0x144fe <FMenuLocalAccount+0xdfc>
   144fe:	ed b7       	in	r30, 0x3d	; 61
   14500:	fe b7       	in	r31, 0x3e	; 62
   14502:	31 96       	adiw	r30, 0x01	; 1
   14504:	ad b7       	in	r26, 0x3d	; 61
   14506:	be b7       	in	r27, 0x3e	; 62
   14508:	12 96       	adiw	r26, 0x02	; 2
   1450a:	1c 93       	st	X, r17
   1450c:	0e 93       	st	-X, r16
   1450e:	11 97       	sbiw	r26, 0x01	; 1
   14510:	8e e2       	ldi	r24, 0x2E	; 46
   14512:	9e e1       	ldi	r25, 0x1E	; 30
   14514:	93 83       	std	Z+3, r25	; 0x03
   14516:	82 83       	std	Z+2, r24	; 0x02
   14518:	8a e4       	ldi	r24, 0x4A	; 74
   1451a:	9e e0       	ldi	r25, 0x0E	; 14
   1451c:	95 83       	std	Z+5, r25	; 0x05
   1451e:	84 83       	std	Z+4, r24	; 0x04
   14520:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   14524:	ed b7       	in	r30, 0x3d	; 61
   14526:	fe b7       	in	r31, 0x3e	; 62
   14528:	36 96       	adiw	r30, 0x06	; 6
   1452a:	0f b6       	in	r0, 0x3f	; 63
   1452c:	f8 94       	cli
   1452e:	fe bf       	out	0x3e, r31	; 62
   14530:	0f be       	out	0x3f, r0	; 63
   14532:	ed bf       	out	0x3d, r30	; 61
   14534:	82 e0       	ldi	r24, 0x02	; 2
   14536:	6e e0       	ldi	r22, 0x0E	; 14
   14538:	a8 01       	movw	r20, r16
   1453a:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>

				}
				lcd_printf(3,1,PSTR("Odometer:_       "));                                //"Odometer:_          "
   1453e:	83 e0       	ldi	r24, 0x03	; 3
   14540:	61 e0       	ldi	r22, 0x01	; 1
   14542:	4c e1       	ldi	r20, 0x1C	; 28
   14544:	5e e1       	ldi	r21, 0x1E	; 30
   14546:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	            lcd_printf(4,1,PSTR("[*]Back  [#]OK   "));                                //"[*]Back  [#]OK      "						        
   1454a:	84 e0       	ldi	r24, 0x04	; 4
   1454c:	61 e0       	ldi	r22, 0x01	; 1
   1454e:	4a e0       	ldi	r20, 0x0A	; 10
   14550:	5e e1       	ldi	r21, 0x1E	; 30
   14552:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
                //iLoop=0;
				//iValuePos=0;
				//ValueChar[iValuePos]=' ';        
				ClearMem(strOdometer);
   14556:	83 ef       	ldi	r24, 0xF3	; 243
   14558:	95 e0       	ldi	r25, 0x05	; 5
   1455a:	0e 94 7b ad 	call	0x15af6	; 0x15af6 <ClearMem>
		        stLocalAccount=laOdometerInput;
   1455e:	82 e1       	ldi	r24, 0x12	; 18
   14560:	29 c0       	rjmp	.+82     	; 0x145b4 <FMenuLocalAccount+0xeb2>
		        break;
           case laOdometerInput:
		        //Blinking 50% _      BalanceValue Volume=999  Amount=65536
			    //iLoop++;
				uiResult=UserInput(UI_NUMBER_R,3,10,strOdometer,0,10);
   14562:	13 ef       	ldi	r17, 0xF3	; 243
   14564:	c1 2e       	mov	r12, r17
   14566:	15 e0       	ldi	r17, 0x05	; 5
   14568:	d1 2e       	mov	r13, r17
   1456a:	81 e0       	ldi	r24, 0x01	; 1
   1456c:	63 e0       	ldi	r22, 0x03	; 3
   1456e:	4a e0       	ldi	r20, 0x0A	; 10
   14570:	96 01       	movw	r18, r12
   14572:	00 e0       	ldi	r16, 0x00	; 0
   14574:	10 e0       	ldi	r17, 0x00	; 0
   14576:	ba e0       	ldi	r27, 0x0A	; 10
   14578:	eb 2e       	mov	r14, r27
   1457a:	0e 94 d1 7b 	call	0xf7a2	; 0xf7a2 <UserInput>
				if (uiResult==USER_OK){
   1457e:	83 30       	cpi	r24, 0x03	; 3
   14580:	79 f4       	brne	.+30     	; 0x145a0 <FMenuLocalAccount+0xe9e>
				    if ((strlen(strOdometer)==1)&&(strOdometer[0]=='0'))
   14582:	f6 01       	movw	r30, r12
   14584:	01 90       	ld	r0, Z+
   14586:	00 20       	and	r0, r0
   14588:	e9 f7       	brne	.-6      	; 0x14584 <FMenuLocalAccount+0xe82>
   1458a:	e5 5f       	subi	r30, 0xF5	; 245
   1458c:	f5 40       	sbci	r31, 0x05	; 5
   1458e:	31 f4       	brne	.+12     	; 0x1459c <FMenuLocalAccount+0xe9a>
   14590:	80 91 f3 05 	lds	r24, 0x05F3
   14594:	80 33       	cpi	r24, 0x30	; 48
   14596:	11 f4       	brne	.+4      	; 0x1459c <FMenuLocalAccount+0xe9a>
					    strOdometer[0]=0;
   14598:	10 92 f3 05 	sts	0x05F3, r1

				    stLocalAccount=laDataConfirm;
   1459c:	83 e1       	ldi	r24, 0x13	; 19
   1459e:	0a c0       	rjmp	.+20     	; 0x145b4 <FMenuLocalAccount+0xeb2>
					}
			    else
			    if (uiResult==USER_CANCEL){
   145a0:	81 30       	cpi	r24, 0x01	; 1
   145a2:	09 f0       	breq	.+2      	; 0x145a6 <FMenuLocalAccount+0xea4>
   145a4:	da c2       	rjmp	.+1460   	; 0x14b5a <FMenuLocalAccount+0x1458>
				    if (IsFullAuthorized==True)
   145a6:	80 91 74 03 	lds	r24, 0x0374
   145aa:	81 30       	cpi	r24, 0x01	; 1
   145ac:	11 f4       	brne	.+4      	; 0x145b2 <FMenuLocalAccount+0xeb0>
					     stLocalAccount=laSelectBalanceType;
   145ae:	8d e0       	ldi	r24, 0x0D	; 13
   145b0:	01 c0       	rjmp	.+2      	; 0x145b4 <FMenuLocalAccount+0xeb2>
					else stLocalAccount=laBalanceValue;		        
   145b2:	8f e0       	ldi	r24, 0x0F	; 15
   145b4:	80 93 5c 01 	sts	0x015C, r24
   145b8:	d0 c2       	rjmp	.+1440   	; 0x14b5a <FMenuLocalAccount+0x1458>
					}
                */

		        break;
           case laDataConfirm: 
		        lcd_clear();
   145ba:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
   145be:	ed e0       	ldi	r30, 0x0D	; 13
   145c0:	f5 e0       	ldi	r31, 0x05	; 5
   145c2:	de 01       	movw	r26, r28
   145c4:	55 96       	adiw	r26, 0x15	; 21
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
   145c6:	81 91       	ld	r24, Z+
   145c8:	8d 93       	st	X+, r24
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
   145ca:	35 e0       	ldi	r19, 0x05	; 5
   145cc:	e7 31       	cpi	r30, 0x17	; 23
   145ce:	f3 07       	cpc	r31, r19
   145d0:	d1 f7       	brne	.-12     	; 0x145c6 <FMenuLocalAccount+0xec4>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
   145d2:	1f 8e       	std	Y+31, r1	; 0x1f

		        break;
           case laDataConfirm: 
		        lcd_clear();
		        StringCopyPos(strCardHolder,strName,9,10);                                          //Data Confirmation   
                sprintf_P(lcdteks,PSTR("%s "),strName);                  lcd_print(1,1,lcdteks);    //"Iyan The Man        "
   145d4:	00 d0       	rcall	.+0      	; 0x145d6 <FMenuLocalAccount+0xed4>
   145d6:	00 d0       	rcall	.+0      	; 0x145d8 <FMenuLocalAccount+0xed6>
   145d8:	00 d0       	rcall	.+0      	; 0x145da <FMenuLocalAccount+0xed8>
   145da:	ed b7       	in	r30, 0x3d	; 61
   145dc:	fe b7       	in	r31, 0x3e	; 62
   145de:	31 96       	adiw	r30, 0x01	; 1
   145e0:	8e 01       	movw	r16, r28
   145e2:	0f 5f       	subi	r16, 0xFF	; 255
   145e4:	1f 4f       	sbci	r17, 0xFF	; 255
   145e6:	ad b7       	in	r26, 0x3d	; 61
   145e8:	be b7       	in	r27, 0x3e	; 62
   145ea:	12 96       	adiw	r26, 0x02	; 2
   145ec:	1c 93       	st	X, r17
   145ee:	0e 93       	st	-X, r16
   145f0:	11 97       	sbiw	r26, 0x01	; 1
   145f2:	86 e0       	ldi	r24, 0x06	; 6
   145f4:	9e e1       	ldi	r25, 0x1E	; 30
   145f6:	93 83       	std	Z+3, r25	; 0x03
   145f8:	82 83       	std	Z+2, r24	; 0x02
   145fa:	ce 01       	movw	r24, r28
   145fc:	45 96       	adiw	r24, 0x15	; 21
   145fe:	95 83       	std	Z+5, r25	; 0x05
   14600:	84 83       	std	Z+4, r24	; 0x04
   14602:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   14606:	ed b7       	in	r30, 0x3d	; 61
   14608:	fe b7       	in	r31, 0x3e	; 62
   1460a:	36 96       	adiw	r30, 0x06	; 6
   1460c:	0f b6       	in	r0, 0x3f	; 63
   1460e:	f8 94       	cli
   14610:	fe bf       	out	0x3e, r31	; 62
   14612:	0f be       	out	0x3f, r0	; 63
   14614:	ed bf       	out	0x3d, r30	; 61
   14616:	81 e0       	ldi	r24, 0x01	; 1
   14618:	61 e0       	ldi	r22, 0x01	; 1
   1461a:	a8 01       	movw	r20, r16
   1461c:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		        sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);             lcd_print(2,1,lcdteks);    //"ID1CCDA565 OD:123456"
   14620:	00 d0       	rcall	.+0      	; 0x14622 <FMenuLocalAccount+0xf20>
   14622:	00 d0       	rcall	.+0      	; 0x14624 <FMenuLocalAccount+0xf22>
   14624:	00 d0       	rcall	.+0      	; 0x14626 <FMenuLocalAccount+0xf24>
   14626:	ed b7       	in	r30, 0x3d	; 61
   14628:	fe b7       	in	r31, 0x3e	; 62
   1462a:	31 96       	adiw	r30, 0x01	; 1
   1462c:	ad b7       	in	r26, 0x3d	; 61
   1462e:	be b7       	in	r27, 0x3e	; 62
   14630:	12 96       	adiw	r26, 0x02	; 2
   14632:	1c 93       	st	X, r17
   14634:	0e 93       	st	-X, r16
   14636:	11 97       	sbiw	r26, 0x01	; 1
   14638:	8f ef       	ldi	r24, 0xFF	; 255
   1463a:	9d e1       	ldi	r25, 0x1D	; 29
   1463c:	93 83       	std	Z+3, r25	; 0x03
   1463e:	82 83       	std	Z+2, r24	; 0x02
   14640:	81 eb       	ldi	r24, 0xB1	; 177
   14642:	9d e0       	ldi	r25, 0x0D	; 13
   14644:	95 83       	std	Z+5, r25	; 0x05
   14646:	84 83       	std	Z+4, r24	; 0x04
   14648:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   1464c:	ed b7       	in	r30, 0x3d	; 61
   1464e:	fe b7       	in	r31, 0x3e	; 62
   14650:	36 96       	adiw	r30, 0x06	; 6
   14652:	0f b6       	in	r0, 0x3f	; 63
   14654:	f8 94       	cli
   14656:	fe bf       	out	0x3e, r31	; 62
   14658:	0f be       	out	0x3f, r0	; 63
   1465a:	ed bf       	out	0x3d, r30	; 61
   1465c:	82 e0       	ldi	r24, 0x02	; 2
   1465e:	61 e0       	ldi	r22, 0x01	; 1
   14660:	a8 01       	movw	r20, r16
   14662:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
				sprintf_P(lcdteks,PSTR("%s  %s "),strFIP,strProduct);    lcd_print(3,1,lcdteks);    //"P01  Pertamax 500000"
   14666:	2d b7       	in	r18, 0x3d	; 61
   14668:	3e b7       	in	r19, 0x3e	; 62
   1466a:	28 50       	subi	r18, 0x08	; 8
   1466c:	30 40       	sbci	r19, 0x00	; 0
   1466e:	0f b6       	in	r0, 0x3f	; 63
   14670:	f8 94       	cli
   14672:	3e bf       	out	0x3e, r19	; 62
   14674:	0f be       	out	0x3f, r0	; 63
   14676:	2d bf       	out	0x3d, r18	; 61
   14678:	ed b7       	in	r30, 0x3d	; 61
   1467a:	fe b7       	in	r31, 0x3e	; 62
   1467c:	31 96       	adiw	r30, 0x01	; 1
   1467e:	ad b7       	in	r26, 0x3d	; 61
   14680:	be b7       	in	r27, 0x3e	; 62
   14682:	12 96       	adiw	r26, 0x02	; 2
   14684:	1c 93       	st	X, r17
   14686:	0e 93       	st	-X, r16
   14688:	11 97       	sbiw	r26, 0x01	; 1
   1468a:	87 ef       	ldi	r24, 0xF7	; 247
   1468c:	9d e1       	ldi	r25, 0x1D	; 29
   1468e:	93 83       	std	Z+3, r25	; 0x03
   14690:	82 83       	std	Z+2, r24	; 0x02
   14692:	8d e9       	ldi	r24, 0x9D	; 157
   14694:	93 e0       	ldi	r25, 0x03	; 3
   14696:	95 83       	std	Z+5, r25	; 0x05
   14698:	84 83       	std	Z+4, r24	; 0x04
   1469a:	81 e9       	ldi	r24, 0x91	; 145
   1469c:	99 e0       	ldi	r25, 0x09	; 9
   1469e:	97 83       	std	Z+7, r25	; 0x07
   146a0:	86 83       	std	Z+6, r24	; 0x06
   146a2:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   146a6:	ed b7       	in	r30, 0x3d	; 61
   146a8:	fe b7       	in	r31, 0x3e	; 62
   146aa:	38 96       	adiw	r30, 0x08	; 8
   146ac:	0f b6       	in	r0, 0x3f	; 63
   146ae:	f8 94       	cli
   146b0:	fe bf       	out	0x3e, r31	; 62
   146b2:	0f be       	out	0x3f, r0	; 63
   146b4:	ed bf       	out	0x3d, r30	; 61
   146b6:	83 e0       	ldi	r24, 0x03	; 3
   146b8:	61 e0       	ldi	r22, 0x01	; 1
   146ba:	a8 01       	movw	r20, r16
   146bc:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		        if (IsFullAuthorized==True){
   146c0:	80 91 74 03 	lds	r24, 0x0374
   146c4:	81 30       	cpi	r24, 0x01	; 1
   146c6:	39 f4       	brne	.+14     	; 0x146d6 <FMenuLocalAccount+0xfd4>
                    lcd_printf(3,15,PSTR(" Full"));
   146c8:	83 e0       	ldi	r24, 0x03	; 3
   146ca:	6f e0       	ldi	r22, 0x0F	; 15
   146cc:	41 ef       	ldi	r20, 0xF1	; 241
   146ce:	5d e1       	ldi	r21, 0x1D	; 29
   146d0:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   146d4:	23 c0       	rjmp	.+70     	; 0x1471c <FMenuLocalAccount+0x101a>
				}
				else {
				    sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);          lcd_print(3,15,lcdteks);   //"[*]Back [0]ESC [#]OK " 
   146d6:	00 d0       	rcall	.+0      	; 0x146d8 <FMenuLocalAccount+0xfd6>
   146d8:	00 d0       	rcall	.+0      	; 0x146da <FMenuLocalAccount+0xfd8>
   146da:	00 d0       	rcall	.+0      	; 0x146dc <FMenuLocalAccount+0xfda>
   146dc:	ed b7       	in	r30, 0x3d	; 61
   146de:	fe b7       	in	r31, 0x3e	; 62
   146e0:	31 96       	adiw	r30, 0x01	; 1
   146e2:	ad b7       	in	r26, 0x3d	; 61
   146e4:	be b7       	in	r27, 0x3e	; 62
   146e6:	12 96       	adiw	r26, 0x02	; 2
   146e8:	1c 93       	st	X, r17
   146ea:	0e 93       	st	-X, r16
   146ec:	11 97       	sbiw	r26, 0x01	; 1
   146ee:	8d ee       	ldi	r24, 0xED	; 237
   146f0:	9d e1       	ldi	r25, 0x1D	; 29
   146f2:	93 83       	std	Z+3, r25	; 0x03
   146f4:	82 83       	std	Z+2, r24	; 0x02
   146f6:	8a e4       	ldi	r24, 0x4A	; 74
   146f8:	9e e0       	ldi	r25, 0x0E	; 14
   146fa:	95 83       	std	Z+5, r25	; 0x05
   146fc:	84 83       	std	Z+4, r24	; 0x04
   146fe:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   14702:	ed b7       	in	r30, 0x3d	; 61
   14704:	fe b7       	in	r31, 0x3e	; 62
   14706:	36 96       	adiw	r30, 0x06	; 6
   14708:	0f b6       	in	r0, 0x3f	; 63
   1470a:	f8 94       	cli
   1470c:	fe bf       	out	0x3e, r31	; 62
   1470e:	0f be       	out	0x3f, r0	; 63
   14710:	ed bf       	out	0x3d, r30	; 61
   14712:	83 e0       	ldi	r24, 0x03	; 3
   14714:	6f e0       	ldi	r22, 0x0F	; 15
   14716:	a8 01       	movw	r20, r16
   14718:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
					}
	            lcd_printf(4,1,PSTR("[*]Back [0]ESC [#]OK"));    
   1471c:	84 e0       	ldi	r24, 0x04	; 4
   1471e:	61 e0       	ldi	r22, 0x01	; 1
   14720:	48 ed       	ldi	r20, 0xD8	; 216
   14722:	5d e1       	ldi	r21, 0x1D	; 29
   14724:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
                stLocalAccount=laDataConfirmInput;
   14728:	84 e1       	ldi	r24, 0x14	; 20
   1472a:	44 cf       	rjmp	.-376    	; 0x145b4 <FMenuLocalAccount+0xeb2>
                //while(1){};   
		        break;
           case laDataConfirmInput:
                KeyPressed=_key_scan(1);
   1472c:	81 e0       	ldi	r24, 0x01	; 1
   1472e:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   14732:	80 93 9c 03 	sts	0x039C, r24
                if (KeyPressed==_KEY_CANCEL)stLocalAccount=laOdometer;		        
   14736:	87 3e       	cpi	r24, 0xE7	; 231
   14738:	11 f4       	brne	.+4      	; 0x1473e <FMenuLocalAccount+0x103c>
   1473a:	81 e1       	ldi	r24, 0x11	; 17
   1473c:	3b cf       	rjmp	.-394    	; 0x145b4 <FMenuLocalAccount+0xeb2>
				else
				if (KeyPressed==_KEY_ENTER)stLocalAccount=laProceedTransaction;
   1473e:	87 3b       	cpi	r24, 0xB7	; 183
   14740:	11 f4       	brne	.+4      	; 0x14746 <FMenuLocalAccount+0x1044>
   14742:	85 e1       	ldi	r24, 0x15	; 21
   14744:	37 cf       	rjmp	.-402    	; 0x145b4 <FMenuLocalAccount+0xeb2>
				else
				if (KeyPressed==_KEY_0){
   14746:	87 3d       	cpi	r24, 0xD7	; 215
   14748:	09 f0       	breq	.+2      	; 0x1474c <FMenuLocalAccount+0x104a>
   1474a:	07 c2       	rjmp	.+1038   	; 0x14b5a <FMenuLocalAccount+0x1458>
				   //ShowCancel
				   TimLocAcc=0;
   1474c:	10 92 d3 01 	sts	0x01D3, r1
   14750:	10 92 d2 01 	sts	0x01D2, r1
                   lcd_clear();
   14754:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
				   lcd_printf(1,1,PSTR("Cancel Transaction  "));    //"Cancel Transaction"
   14758:	81 e0       	ldi	r24, 0x01	; 1
   1475a:	61 e0       	ldi	r22, 0x01	; 1
   1475c:	43 ec       	ldi	r20, 0xC3	; 195
   1475e:	5d e1       	ldi	r21, 0x1D	; 29
   14760:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
   14764:	e9 c1       	rjmp	.+978    	; 0x14b38 <FMenuLocalAccount+0x1436>
				   stLocalAccount=laDelayExit;
				   }
		        break;
           case laProceedTransaction:
		        sendMessage58();
   14766:	0e 94 13 4f 	call	0x9e26	; 0x9e26 <sendMessage58>
                RemZeroLead(strCardID);
   1476a:	81 eb       	ldi	r24, 0xB1	; 177
   1476c:	9d e0       	ldi	r25, 0x0D	; 13
   1476e:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
                RemZeroLead(strBalanceValue);
   14772:	aa e4       	ldi	r26, 0x4A	; 74
   14774:	ea 2e       	mov	r14, r26
   14776:	ae e0       	ldi	r26, 0x0E	; 14
   14778:	fa 2e       	mov	r15, r26
   1477a:	c7 01       	movw	r24, r14
   1477c:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
				sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct);       lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   14780:	2d b7       	in	r18, 0x3d	; 61
   14782:	3e b7       	in	r19, 0x3e	; 62
   14784:	28 50       	subi	r18, 0x08	; 8
   14786:	30 40       	sbci	r19, 0x00	; 0
   14788:	0f b6       	in	r0, 0x3f	; 63
   1478a:	f8 94       	cli
   1478c:	3e bf       	out	0x3e, r19	; 62
   1478e:	0f be       	out	0x3f, r0	; 63
   14790:	2d bf       	out	0x3d, r18	; 61
   14792:	ed b7       	in	r30, 0x3d	; 61
   14794:	fe b7       	in	r31, 0x3e	; 62
   14796:	31 96       	adiw	r30, 0x01	; 1
   14798:	8e 01       	movw	r16, r28
   1479a:	0f 5f       	subi	r16, 0xFF	; 255
   1479c:	1f 4f       	sbci	r17, 0xFF	; 255
   1479e:	ad b7       	in	r26, 0x3d	; 61
   147a0:	be b7       	in	r27, 0x3e	; 62
   147a2:	12 96       	adiw	r26, 0x02	; 2
   147a4:	1c 93       	st	X, r17
   147a6:	0e 93       	st	-X, r16
   147a8:	11 97       	sbiw	r26, 0x01	; 1
   147aa:	8b eb       	ldi	r24, 0xBB	; 187
   147ac:	9d e1       	ldi	r25, 0x1D	; 29
   147ae:	93 83       	std	Z+3, r25	; 0x03
   147b0:	82 83       	std	Z+2, r24	; 0x02
   147b2:	8d e9       	ldi	r24, 0x9D	; 157
   147b4:	93 e0       	ldi	r25, 0x03	; 3
   147b6:	95 83       	std	Z+5, r25	; 0x05
   147b8:	84 83       	std	Z+4, r24	; 0x04
   147ba:	81 e9       	ldi	r24, 0x91	; 145
   147bc:	99 e0       	ldi	r25, 0x09	; 9
   147be:	97 83       	std	Z+7, r25	; 0x07
   147c0:	86 83       	std	Z+6, r24	; 0x06
   147c2:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   147c6:	ed b7       	in	r30, 0x3d	; 61
   147c8:	fe b7       	in	r31, 0x3e	; 62
   147ca:	38 96       	adiw	r30, 0x08	; 8
   147cc:	0f b6       	in	r0, 0x3f	; 63
   147ce:	f8 94       	cli
   147d0:	fe bf       	out	0x3e, r31	; 62
   147d2:	0f be       	out	0x3f, r0	; 63
   147d4:	ed bf       	out	0x3d, r30	; 61
   147d6:	81 e0       	ldi	r24, 0x01	; 1
   147d8:	61 e0       	ldi	r22, 0x01	; 1
   147da:	a8 01       	movw	r20, r16
   147dc:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);              lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   147e0:	00 d0       	rcall	.+0      	; 0x147e2 <FMenuLocalAccount+0x10e0>
   147e2:	00 d0       	rcall	.+0      	; 0x147e4 <FMenuLocalAccount+0x10e2>
   147e4:	00 d0       	rcall	.+0      	; 0x147e6 <FMenuLocalAccount+0x10e4>
   147e6:	ed b7       	in	r30, 0x3d	; 61
   147e8:	fe b7       	in	r31, 0x3e	; 62
   147ea:	31 96       	adiw	r30, 0x01	; 1
   147ec:	ad b7       	in	r26, 0x3d	; 61
   147ee:	be b7       	in	r27, 0x3e	; 62
   147f0:	12 96       	adiw	r26, 0x02	; 2
   147f2:	1c 93       	st	X, r17
   147f4:	0e 93       	st	-X, r16
   147f6:	11 97       	sbiw	r26, 0x01	; 1
   147f8:	88 eb       	ldi	r24, 0xB8	; 184
   147fa:	9d e1       	ldi	r25, 0x1D	; 29
   147fc:	93 83       	std	Z+3, r25	; 0x03
   147fe:	82 83       	std	Z+2, r24	; 0x02
   14800:	f5 82       	std	Z+5, r15	; 0x05
   14802:	e4 82       	std	Z+4, r14	; 0x04
   14804:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   14808:	ed b7       	in	r30, 0x3d	; 61
   1480a:	fe b7       	in	r31, 0x3e	; 62
   1480c:	36 96       	adiw	r30, 0x06	; 6
   1480e:	0f b6       	in	r0, 0x3f	; 63
   14810:	f8 94       	cli
   14812:	fe bf       	out	0x3e, r31	; 62
   14814:	0f be       	out	0x3f, r0	; 63
   14816:	ed bf       	out	0x3d, r30	; 61
   14818:	81 e0       	ldi	r24, 0x01	; 1
   1481a:	6f e0       	ldi	r22, 0x0F	; 15
   1481c:	a8 01       	movw	r20, r16
   1481e:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
                lcd_printf(3,1,PSTR("Mohon Tunggu        "));                                         //"Mohon Tunggu ...    "
   14822:	83 e0       	ldi	r24, 0x03	; 3
   14824:	61 e0       	ldi	r22, 0x01	; 1
   14826:	43 ea       	ldi	r20, 0xA3	; 163
   14828:	5d e1       	ldi	r21, 0x1D	; 29
   1482a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		        lcd_printf(4,1,PSTR("                    "));                                  //"                    "
   1482e:	84 e0       	ldi	r24, 0x04	; 4
   14830:	61 e0       	ldi	r22, 0x01	; 1
   14832:	4e e8       	ldi	r20, 0x8E	; 142
   14834:	5d e1       	ldi	r21, 0x1D	; 29
   14836:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				IsMessage00=False;
   1483a:	10 92 b5 01 	sts	0x01B5, r1
				TimLocAcc=0;
   1483e:	10 92 d3 01 	sts	0x01D3, r1
   14842:	10 92 d2 01 	sts	0x01D2, r1
				iLoop=0;iPos=0;iWait=0;
   14846:	10 92 73 03 	sts	0x0373, r1
   1484a:	10 92 72 03 	sts	0x0372, r1
   1484e:	10 92 a3 03 	sts	0x03A3, r1
   14852:	10 92 a2 03 	sts	0x03A2, r1
				stLocalAccount=laWaitMessage00;
   14856:	87 e1       	ldi	r24, 0x17	; 23
   14858:	ad ce       	rjmp	.-678    	; 0x145b4 <FMenuLocalAccount+0xeb2>
		        break;
           case laWaitMessage00:
                iLoop++;
   1485a:	80 91 72 03 	lds	r24, 0x0372
   1485e:	90 91 73 03 	lds	r25, 0x0373
   14862:	01 96       	adiw	r24, 0x01	; 1
   14864:	90 93 73 03 	sts	0x0373, r25
   14868:	80 93 72 03 	sts	0x0372, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   1486c:	68 e9       	ldi	r22, 0x98	; 152
   1486e:	7a e3       	ldi	r23, 0x3A	; 58
   14870:	0e 94 0d b7 	call	0x16e1a	; 0x16e1a <__udivmodhi4>
   14874:	89 2b       	or	r24, r25
   14876:	e1 f4       	brne	.+56     	; 0x148b0 <FMenuLocalAccount+0x11ae>
				   if (iPos<5){
   14878:	60 91 a3 03 	lds	r22, 0x03A3
   1487c:	65 30       	cpi	r22, 0x05	; 5
   1487e:	58 f4       	brcc	.+22     	; 0x14896 <FMenuLocalAccount+0x1194>
				       iPos++;
   14880:	6f 5f       	subi	r22, 0xFF	; 255
   14882:	60 93 a3 03 	sts	0x03A3, r22
					   lcd_xy(3,(14+iPos));_lcd('.');
   14886:	62 5f       	subi	r22, 0xF2	; 242
   14888:	83 e0       	ldi	r24, 0x03	; 3
   1488a:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
   1488e:	8e e2       	ldi	r24, 0x2E	; 46
   14890:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
   14894:	0d c0       	rjmp	.+26     	; 0x148b0 <FMenuLocalAccount+0x11ae>
					   }
				   else{
				       iPos=0;
   14896:	10 92 a3 03 	sts	0x03A3, r1
					   lcd_printf(3,(14+iPos),PSTR("       "));
   1489a:	83 e0       	ldi	r24, 0x03	; 3
   1489c:	6e e0       	ldi	r22, 0x0E	; 14
   1489e:	46 e8       	ldi	r20, 0x86	; 134
   148a0:	5d e1       	ldi	r21, 0x1D	; 29
   148a2:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
					   iWait++;
   148a6:	80 91 a2 03 	lds	r24, 0x03A2
   148aa:	8f 5f       	subi	r24, 0xFF	; 255
   148ac:	80 93 a2 03 	sts	0x03A2, r24
					   }
				}
				if (iWait>5){
   148b0:	80 91 a2 03 	lds	r24, 0x03A2
   148b4:	86 30       	cpi	r24, 0x06	; 6
   148b6:	78 f0       	brcs	.+30     	; 0x148d6 <FMenuLocalAccount+0x11d4>
				    stLocalAccount=laConTimout;
   148b8:	84 e0       	ldi	r24, 0x04	; 4
   148ba:	80 93 5c 01 	sts	0x015C, r24
					TimLocAcc=0;
   148be:	10 92 d3 01 	sts	0x01D3, r1
   148c2:	10 92 d2 01 	sts	0x01D2, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   148c6:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   148c8:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   148ca:	82 e0       	ldi	r24, 0x02	; 2
   148cc:	90 e0       	ldi	r25, 0x00	; 0
   148ce:	90 93 d7 01 	sts	0x01D7, r25
   148d2:	80 93 d6 01 	sts	0x01D6, r24
				if (iWait>5){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage00==True){
   148d6:	80 91 b5 01 	lds	r24, 0x01B5
   148da:	81 30       	cpi	r24, 0x01	; 1
   148dc:	09 f0       	breq	.+2      	; 0x148e0 <FMenuLocalAccount+0x11de>
   148de:	3d c1       	rjmp	.+634    	; 0x14b5a <FMenuLocalAccount+0x1458>
                    IsMessage00=False;
   148e0:	10 92 b5 01 	sts	0x01B5, r1
				    stLocalAccount=laProcMessage00;
   148e4:	88 e1       	ldi	r24, 0x18	; 24
   148e6:	66 ce       	rjmp	.-820    	; 0x145b4 <FMenuLocalAccount+0xeb2>
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   148e8:	80 91 45 0b 	lds	r24, 0x0B45
   148ec:	81 30       	cpi	r24, 0x01	; 1
   148ee:	51 f4       	brne	.+20     	; 0x14904 <FMenuLocalAccount+0x1202>
   148f0:	80 91 9e 01 	lds	r24, 0x019E
   148f4:	90 91 9f 01 	lds	r25, 0x019F
   148f8:	8f 97       	sbiw	r24, 0x2f	; 47
   148fa:	21 f4       	brne	.+8      	; 0x14904 <FMenuLocalAccount+0x1202>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
   148fc:	80 91 6a 0b 	lds	r24, 0x0B6A
   14900:	80 53       	subi	r24, 0x30	; 48
   14902:	01 c0       	rjmp	.+2      	; 0x14906 <FMenuLocalAccount+0x1204>
   14904:	80 e0       	ldi	r24, 0x00	; 0
                    IsMessage00=False;
				    stLocalAccount=laProcMessage00;
					}
		        break;
           case laProcMessage00:
		        LocAccStatus=procMessage00();
   14906:	80 93 a4 03 	sts	0x03A4, r24
                lcd_clear();
   1490a:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
		        switch(LocAccStatus){
   1490e:	10 91 a4 03 	lds	r17, 0x03A4
   14912:	11 30       	cpi	r17, 0x01	; 1
   14914:	51 f0       	breq	.+20     	; 0x1492a <FMenuLocalAccount+0x1228>
   14916:	11 30       	cpi	r17, 0x01	; 1
   14918:	18 f0       	brcs	.+6      	; 0x14920 <FMenuLocalAccount+0x121e>
   1491a:	13 30       	cpi	r17, 0x03	; 3
   1491c:	69 f5       	brne	.+90     	; 0x14978 <FMenuLocalAccount+0x1276>
   1491e:	1b c0       	rjmp	.+54     	; 0x14956 <FMenuLocalAccount+0x1254>
				case MSG00_NACK:
                     lcd_printf(2,1,PSTR("Authorisasi Gagal   "));
   14920:	82 e0       	ldi	r24, 0x02	; 2
   14922:	61 e0       	ldi	r22, 0x01	; 1
   14924:	41 e7       	ldi	r20, 0x71	; 113
   14926:	5d e1       	ldi	r21, 0x1D	; 29
   14928:	1a c0       	rjmp	.+52     	; 0x1495e <FMenuLocalAccount+0x125c>
					 system_beep(2); 
					 stLocalAccount=laDelayExit;
				     break;
                case MSG00_ACK:
				     lcd_printf(2,1,PSTR("Authorisasi Berhasil"));
   1492a:	82 e0       	ldi	r24, 0x02	; 2
   1492c:	61 e0       	ldi	r22, 0x01	; 1
   1492e:	4c e5       	ldi	r20, 0x5C	; 92
   14930:	5d e1       	ldi	r21, 0x1D	; 29
   14932:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				     LocalAccountFIP[nLocalAccount]=FIP_Used;
   14936:	90 91 a4 01 	lds	r25, 0x01A4
   1493a:	e9 2f       	mov	r30, r25
   1493c:	f0 e0       	ldi	r31, 0x00	; 0
   1493e:	ea 5c       	subi	r30, 0xCA	; 202
   14940:	fa 4f       	sbci	r31, 0xFA	; 250
   14942:	80 91 76 03 	lds	r24, 0x0376
   14946:	80 83       	st	Z, r24
					 nLocalAccount++;
   14948:	9f 5f       	subi	r25, 0xFF	; 255
   1494a:	90 93 a4 01 	sts	0x01A4, r25
					 IsViewFillingFIP=True;
   1494e:	10 93 ad 01 	sts	0x01AD, r17
					 stLocalAccount=laViewStatus;
   14952:	86 e1       	ldi	r24, 0x16	; 22
   14954:	0f c0       	rjmp	.+30     	; 0x14974 <FMenuLocalAccount+0x1272>
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
   14956:	82 e0       	ldi	r24, 0x02	; 2
   14958:	61 e0       	ldi	r22, 0x01	; 1
   1495a:	49 e4       	ldi	r20, 0x49	; 73
   1495c:	5d e1       	ldi	r21, 0x1D	; 29
   1495e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14962:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14964:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14966:	82 e0       	ldi	r24, 0x02	; 2
   14968:	90 e0       	ldi	r25, 0x00	; 0
   1496a:	90 93 d7 01 	sts	0x01D7, r25
   1496e:	80 93 d6 01 	sts	0x01D6, r24
					 stLocalAccount=laViewStatus;
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
					 system_beep(2);
					 stLocalAccount=laDelayExit;
   14972:	8e e1       	ldi	r24, 0x1E	; 30
   14974:	80 93 5c 01 	sts	0x015C, r24
				     break;
				}
				TimLocAcc=0;
   14978:	10 92 d3 01 	sts	0x01D3, r1
   1497c:	10 92 d2 01 	sts	0x01D2, r1
				ClearMem(strOdometer);
   14980:	83 ef       	ldi	r24, 0xF3	; 243
   14982:	95 e0       	ldi	r25, 0x05	; 5
   14984:	0e 94 7b ad 	call	0x15af6	; 0x15af6 <ClearMem>
	            ClearMem(strLicPlate);
   14988:	82 e2       	ldi	r24, 0x22	; 34
   1498a:	9b e0       	ldi	r25, 0x0B	; 11
   1498c:	0e 94 7b ad 	call	0x15af6	; 0x15af6 <ClearMem>
   14990:	e4 c0       	rjmp	.+456    	; 0x14b5a <FMenuLocalAccount+0x1458>
		        break;
           case laViewStatus:
                if (TimLocAcc>20)stLocalAccount=laExitLocAcc;//laDisplayTransaction;
   14992:	80 91 d2 01 	lds	r24, 0x01D2
   14996:	90 91 d3 01 	lds	r25, 0x01D3
   1499a:	45 97       	sbiw	r24, 0x15	; 21
   1499c:	08 f4       	brcc	.+2      	; 0x149a0 <FMenuLocalAccount+0x129e>
   1499e:	dd c0       	rjmp	.+442    	; 0x14b5a <FMenuLocalAccount+0x1458>
   149a0:	d3 c0       	rjmp	.+422    	; 0x14b48 <FMenuLocalAccount+0x1446>
		        break; 
           case laDisplayTransaction:
		        lcd_clear();
   149a2:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
                sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct); lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   149a6:	2d b7       	in	r18, 0x3d	; 61
   149a8:	3e b7       	in	r19, 0x3e	; 62
   149aa:	28 50       	subi	r18, 0x08	; 8
   149ac:	30 40       	sbci	r19, 0x00	; 0
   149ae:	0f b6       	in	r0, 0x3f	; 63
   149b0:	f8 94       	cli
   149b2:	3e bf       	out	0x3e, r19	; 62
   149b4:	0f be       	out	0x3f, r0	; 63
   149b6:	2d bf       	out	0x3d, r18	; 61
   149b8:	ed b7       	in	r30, 0x3d	; 61
   149ba:	fe b7       	in	r31, 0x3e	; 62
   149bc:	31 96       	adiw	r30, 0x01	; 1
   149be:	7e 01       	movw	r14, r28
   149c0:	08 94       	sec
   149c2:	e1 1c       	adc	r14, r1
   149c4:	f1 1c       	adc	r15, r1
   149c6:	ad b7       	in	r26, 0x3d	; 61
   149c8:	be b7       	in	r27, 0x3e	; 62
   149ca:	12 96       	adiw	r26, 0x02	; 2
   149cc:	fc 92       	st	X, r15
   149ce:	ee 92       	st	-X, r14
   149d0:	11 97       	sbiw	r26, 0x01	; 1
   149d2:	81 e4       	ldi	r24, 0x41	; 65
   149d4:	9d e1       	ldi	r25, 0x1D	; 29
   149d6:	93 83       	std	Z+3, r25	; 0x03
   149d8:	82 83       	std	Z+2, r24	; 0x02
   149da:	8d e9       	ldi	r24, 0x9D	; 157
   149dc:	93 e0       	ldi	r25, 0x03	; 3
   149de:	95 83       	std	Z+5, r25	; 0x05
   149e0:	84 83       	std	Z+4, r24	; 0x04
   149e2:	81 e9       	ldi	r24, 0x91	; 145
   149e4:	99 e0       	ldi	r25, 0x09	; 9
   149e6:	97 83       	std	Z+7, r25	; 0x07
   149e8:	86 83       	std	Z+6, r24	; 0x06
   149ea:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   149ee:	ed b7       	in	r30, 0x3d	; 61
   149f0:	fe b7       	in	r31, 0x3e	; 62
   149f2:	38 96       	adiw	r30, 0x08	; 8
   149f4:	0f b6       	in	r0, 0x3f	; 63
   149f6:	f8 94       	cli
   149f8:	fe bf       	out	0x3e, r31	; 62
   149fa:	0f be       	out	0x3f, r0	; 63
   149fc:	ed bf       	out	0x3d, r30	; 61
   149fe:	81 e0       	ldi	r24, 0x01	; 1
   14a00:	61 e0       	ldi	r22, 0x01	; 1
   14a02:	a7 01       	movw	r20, r14
   14a04:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);        lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   14a08:	00 d0       	rcall	.+0      	; 0x14a0a <FMenuLocalAccount+0x1308>
   14a0a:	00 d0       	rcall	.+0      	; 0x14a0c <FMenuLocalAccount+0x130a>
   14a0c:	00 d0       	rcall	.+0      	; 0x14a0e <FMenuLocalAccount+0x130c>
   14a0e:	ed b7       	in	r30, 0x3d	; 61
   14a10:	fe b7       	in	r31, 0x3e	; 62
   14a12:	31 96       	adiw	r30, 0x01	; 1
   14a14:	ad b7       	in	r26, 0x3d	; 61
   14a16:	be b7       	in	r27, 0x3e	; 62
   14a18:	12 96       	adiw	r26, 0x02	; 2
   14a1a:	fc 92       	st	X, r15
   14a1c:	ee 92       	st	-X, r14
   14a1e:	11 97       	sbiw	r26, 0x01	; 1
   14a20:	8e e3       	ldi	r24, 0x3E	; 62
   14a22:	9d e1       	ldi	r25, 0x1D	; 29
   14a24:	93 83       	std	Z+3, r25	; 0x03
   14a26:	82 83       	std	Z+2, r24	; 0x02
   14a28:	8a e4       	ldi	r24, 0x4A	; 74
   14a2a:	9e e0       	ldi	r25, 0x0E	; 14
   14a2c:	95 83       	std	Z+5, r25	; 0x05
   14a2e:	84 83       	std	Z+4, r24	; 0x04
   14a30:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   14a34:	ed b7       	in	r30, 0x3d	; 61
   14a36:	fe b7       	in	r31, 0x3e	; 62
   14a38:	36 96       	adiw	r30, 0x06	; 6
   14a3a:	0f b6       	in	r0, 0x3f	; 63
   14a3c:	f8 94       	cli
   14a3e:	fe bf       	out	0x3e, r31	; 62
   14a40:	0f be       	out	0x3f, r0	; 63
   14a42:	ed bf       	out	0x3d, r30	; 61
   14a44:	81 e0       	ldi	r24, 0x01	; 1
   14a46:	6f e0       	ldi	r22, 0x0F	; 15
   14a48:	a7 01       	movw	r20, r14
   14a4a:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
                RemSpaceLead(strCardID);
   14a4e:	01 eb       	ldi	r16, 0xB1	; 177
   14a50:	1d e0       	ldi	r17, 0x0D	; 13
   14a52:	c8 01       	movw	r24, r16
   14a54:	0e 94 06 24 	call	0x480c	; 0x480c <RemSpaceLead>
				sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);          lcd_print(2,1,lcdteks);
   14a58:	00 d0       	rcall	.+0      	; 0x14a5a <FMenuLocalAccount+0x1358>
   14a5a:	00 d0       	rcall	.+0      	; 0x14a5c <FMenuLocalAccount+0x135a>
   14a5c:	00 d0       	rcall	.+0      	; 0x14a5e <FMenuLocalAccount+0x135c>
   14a5e:	ed b7       	in	r30, 0x3d	; 61
   14a60:	fe b7       	in	r31, 0x3e	; 62
   14a62:	31 96       	adiw	r30, 0x01	; 1
   14a64:	ad b7       	in	r26, 0x3d	; 61
   14a66:	be b7       	in	r27, 0x3e	; 62
   14a68:	12 96       	adiw	r26, 0x02	; 2
   14a6a:	fc 92       	st	X, r15
   14a6c:	ee 92       	st	-X, r14
   14a6e:	11 97       	sbiw	r26, 0x01	; 1
   14a70:	87 e3       	ldi	r24, 0x37	; 55
   14a72:	9d e1       	ldi	r25, 0x1D	; 29
   14a74:	93 83       	std	Z+3, r25	; 0x03
   14a76:	82 83       	std	Z+2, r24	; 0x02
   14a78:	15 83       	std	Z+5, r17	; 0x05
   14a7a:	04 83       	std	Z+4, r16	; 0x04
   14a7c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   14a80:	ed b7       	in	r30, 0x3d	; 61
   14a82:	fe b7       	in	r31, 0x3e	; 62
   14a84:	36 96       	adiw	r30, 0x06	; 6
   14a86:	0f b6       	in	r0, 0x3f	; 63
   14a88:	f8 94       	cli
   14a8a:	fe bf       	out	0x3e, r31	; 62
   14a8c:	0f be       	out	0x3f, r0	; 63
   14a8e:	ed bf       	out	0x3d, r30	; 61
   14a90:	82 e0       	ldi	r24, 0x02	; 2
   14a92:	61 e0       	ldi	r22, 0x01	; 1
   14a94:	a7 01       	movw	r20, r14
   14a96:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>
				TimLocAcc=0;
   14a9a:	10 92 d3 01 	sts	0x01D3, r1
   14a9e:	10 92 d2 01 	sts	0x01D2, r1
		        IsCompleteFilling=False;
   14aa2:	10 92 c0 01 	sts	0x01C0, r1
				stLocalAccount=laWaitFilling;
   14aa6:	8d e1       	ldi	r24, 0x1D	; 29
   14aa8:	85 cd       	rjmp	.-1270   	; 0x145b4 <FMenuLocalAccount+0xeb2>
		        break; 
           case laWaitFilling:
				if ((IsCompleteFilling==True)||(TimLocAcc>FILLING_TIMOUT)){
   14aaa:	80 91 c0 01 	lds	r24, 0x01C0
   14aae:	81 30       	cpi	r24, 0x01	; 1
   14ab0:	39 f0       	breq	.+14     	; 0x14ac0 <FMenuLocalAccount+0x13be>
   14ab2:	80 91 d2 01 	lds	r24, 0x01D2
   14ab6:	90 91 d3 01 	lds	r25, 0x01D3
   14aba:	0b 97       	sbiw	r24, 0x0b	; 11
   14abc:	08 f4       	brcc	.+2      	; 0x14ac0 <FMenuLocalAccount+0x13be>
   14abe:	4d c0       	rjmp	.+154    	; 0x14b5a <FMenuLocalAccount+0x1458>
				    IsCompleteFilling=False;
   14ac0:	10 92 c0 01 	sts	0x01C0, r1
				    stLocalAccount=laSuccessTransaction;
   14ac4:	89 e1       	ldi	r24, 0x19	; 25
   14ac6:	80 93 5c 01 	sts	0x015C, r24
					TimLocAcc=0;
   14aca:	10 92 d3 01 	sts	0x01D3, r1
   14ace:	10 92 d2 01 	sts	0x01D2, r1
   14ad2:	43 c0       	rjmp	.+134    	; 0x14b5a <FMenuLocalAccount+0x1458>
					}
		        break;
           case laSuccessTransaction:
				lcd_clear();lcd_printf(2,1,PSTR("Transaksi Selesai"));
   14ad4:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
   14ad8:	82 e0       	ldi	r24, 0x02	; 2
   14ada:	61 e0       	ldi	r22, 0x01	; 1
   14adc:	45 e2       	ldi	r20, 0x25	; 37
   14ade:	5d e1       	ldi	r21, 0x1D	; 29
   14ae0:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
				//Show Status FIP
				sprintf_P(lcdteks,PSTR("Fueling @FIP:#%d"),FIP_Used);
   14ae4:	00 d0       	rcall	.+0      	; 0x14ae6 <FMenuLocalAccount+0x13e4>
   14ae6:	00 d0       	rcall	.+0      	; 0x14ae8 <FMenuLocalAccount+0x13e6>
   14ae8:	00 d0       	rcall	.+0      	; 0x14aea <FMenuLocalAccount+0x13e8>
   14aea:	ed b7       	in	r30, 0x3d	; 61
   14aec:	fe b7       	in	r31, 0x3e	; 62
   14aee:	31 96       	adiw	r30, 0x01	; 1
   14af0:	8e 01       	movw	r16, r28
   14af2:	0f 5f       	subi	r16, 0xFF	; 255
   14af4:	1f 4f       	sbci	r17, 0xFF	; 255
   14af6:	ad b7       	in	r26, 0x3d	; 61
   14af8:	be b7       	in	r27, 0x3e	; 62
   14afa:	12 96       	adiw	r26, 0x02	; 2
   14afc:	1c 93       	st	X, r17
   14afe:	0e 93       	st	-X, r16
   14b00:	11 97       	sbiw	r26, 0x01	; 1
   14b02:	84 e1       	ldi	r24, 0x14	; 20
   14b04:	9d e1       	ldi	r25, 0x1D	; 29
   14b06:	93 83       	std	Z+3, r25	; 0x03
   14b08:	82 83       	std	Z+2, r24	; 0x02
   14b0a:	80 91 76 03 	lds	r24, 0x0376
   14b0e:	84 83       	std	Z+4, r24	; 0x04
   14b10:	15 82       	std	Z+5, r1	; 0x05
   14b12:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
				lcd_print(3,1,lcdteks);
   14b16:	ed b7       	in	r30, 0x3d	; 61
   14b18:	fe b7       	in	r31, 0x3e	; 62
   14b1a:	36 96       	adiw	r30, 0x06	; 6
   14b1c:	0f b6       	in	r0, 0x3f	; 63
   14b1e:	f8 94       	cli
   14b20:	fe bf       	out	0x3e, r31	; 62
   14b22:	0f be       	out	0x3f, r0	; 63
   14b24:	ed bf       	out	0x3d, r30	; 61
   14b26:	83 e0       	ldi	r24, 0x03	; 3
   14b28:	61 e0       	ldi	r22, 0x01	; 1
   14b2a:	a8 01       	movw	r20, r16
   14b2c:	0e 94 e2 ac 	call	0x159c4	; 0x159c4 <lcd_print>

				TimLocAcc=0;
				stLocalAccount=laDelayExit;
		        break;
           case laFailedTransaction:
		        TimLocAcc=0;
   14b30:	10 92 d3 01 	sts	0x01D3, r1
   14b34:	10 92 d2 01 	sts	0x01D2, r1
		        //Show Failed Report
				stLocalAccount=laDelayExit;
   14b38:	8e e1       	ldi	r24, 0x1E	; 30
   14b3a:	3c cd       	rjmp	.-1416   	; 0x145b4 <FMenuLocalAccount+0xeb2>
		        break;
           case laDelayExit:
		        if (TimLocAcc>15)stLocalAccount=laExitLocAcc;
   14b3c:	80 91 d2 01 	lds	r24, 0x01D2
   14b40:	90 91 d3 01 	lds	r25, 0x01D3
   14b44:	40 97       	sbiw	r24, 0x10	; 16
   14b46:	48 f0       	brcs	.+18     	; 0x14b5a <FMenuLocalAccount+0x1458>
   14b48:	8f e1       	ldi	r24, 0x1F	; 31
   14b4a:	34 cd       	rjmp	.-1432   	; 0x145b4 <FMenuLocalAccount+0xeb2>
		        break;
           case laExitLocAcc:
		        Result=MENU_DONE;
				stLocalAccount=laInit;
   14b4c:	81 e0       	ldi	r24, 0x01	; 1
   14b4e:	80 93 5c 01 	sts	0x015C, r24
				lcd_clear();
   14b52:	0e 94 3b ad 	call	0x15a76	; 0x15a76 <lcd_clear>
   14b56:	81 e0       	ldi	r24, 0x01	; 1
   14b58:	01 c0       	rjmp	.+2      	; 0x14b5c <FMenuLocalAccount+0x145a>
   14b5a:	80 e0       	ldi	r24, 0x00	; 0
		        break;
	       }//EndSwitch
return Result;
}
   14b5c:	a9 96       	adiw	r28, 0x29	; 41
   14b5e:	0f b6       	in	r0, 0x3f	; 63
   14b60:	f8 94       	cli
   14b62:	de bf       	out	0x3e, r29	; 62
   14b64:	0f be       	out	0x3f, r0	; 63
   14b66:	cd bf       	out	0x3d, r28	; 61
   14b68:	cf 91       	pop	r28
   14b6a:	df 91       	pop	r29
   14b6c:	1f 91       	pop	r17
   14b6e:	0f 91       	pop	r16
   14b70:	ff 90       	pop	r15
   14b72:	ef 90       	pop	r14
   14b74:	df 90       	pop	r13
   14b76:	cf 90       	pop	r12
   14b78:	bf 90       	pop	r11
   14b7a:	af 90       	pop	r10
   14b7c:	08 95       	ret

00014b7e <SendConfigParamater>:
          stConfigProtocol=cpWaitSend;
	      break;
	 }
}

void SendConfigParamater(){
   14b7e:	8f 92       	push	r8
   14b80:	9f 92       	push	r9
   14b82:	af 92       	push	r10
   14b84:	bf 92       	push	r11
   14b86:	cf 92       	push	r12
   14b88:	df 92       	push	r13
   14b8a:	ef 92       	push	r14
   14b8c:	ff 92       	push	r15
   14b8e:	0f 93       	push	r16
   14b90:	1f 93       	push	r17
   14b92:	df 93       	push	r29
   14b94:	cf 93       	push	r28
   14b96:	cd b7       	in	r28, 0x3d	; 61
   14b98:	de b7       	in	r29, 0x3e	; 62
   14b9a:	c5 56       	subi	r28, 0x65	; 101
   14b9c:	d0 40       	sbci	r29, 0x00	; 0
   14b9e:	0f b6       	in	r0, 0x3f	; 63
   14ba0:	f8 94       	cli
   14ba2:	de bf       	out	0x3e, r29	; 62
   14ba4:	0f be       	out	0x3f, r0	; 63
   14ba6:	cd bf       	out	0x3d, r28	; 61
char i,j,strSend[60];
char strEEPROM[41],xEEPROM;

     //Start
	 _uart_printf(1,0,PSTR("<"));
   14ba8:	81 e0       	ldi	r24, 0x01	; 1
   14baa:	60 e0       	ldi	r22, 0x00	; 0
   14bac:	45 e3       	ldi	r20, 0x35	; 53
   14bae:	52 e2       	ldi	r21, 0x22	; 34
   14bb0:	0e 94 94 b2 	call	0x16528	; 0x16528 <_uart_printf>
   14bb4:	07 e2       	ldi	r16, 0x27	; 39
   14bb6:	12 e0       	ldi	r17, 0x02	; 2
   14bb8:	6e 01       	movw	r12, r28
   14bba:	08 94       	sec
   14bbc:	c1 1c       	adc	r12, r1
   14bbe:	d1 1c       	adc	r13, r1
     //Header Footer 400
	 for (i=0;i<10;i++){
	      eeprom_read_block((void*) &strEEPROM, (const void*) &DefHeaderFooter[i],sizeof(DefHeaderFooter[i]));
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14bc0:	7a e2       	ldi	r23, 0x2A	; 42
   14bc2:	e7 2e       	mov	r14, r23
   14bc4:	f1 2c       	mov	r15, r1
   14bc6:	ec 0e       	add	r14, r28
   14bc8:	fd 1e       	adc	r15, r29
   14bca:	62 e3       	ldi	r22, 0x32	; 50
   14bcc:	a6 2e       	mov	r10, r22
   14bce:	62 e2       	ldi	r22, 0x22	; 34
   14bd0:	b6 2e       	mov	r11, r22
   14bd2:	c6 01       	movw	r24, r12
   14bd4:	b8 01       	movw	r22, r16
   14bd6:	49 e2       	ldi	r20, 0x29	; 41
   14bd8:	50 e0       	ldi	r21, 0x00	; 0
   14bda:	25 ed       	ldi	r18, 0xD5	; 213
   14bdc:	32 e1       	ldi	r19, 0x12	; 18
   14bde:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
   14be2:	00 d0       	rcall	.+0      	; 0x14be4 <SendConfigParamater+0x66>
   14be4:	00 d0       	rcall	.+0      	; 0x14be6 <SendConfigParamater+0x68>
   14be6:	00 d0       	rcall	.+0      	; 0x14be8 <SendConfigParamater+0x6a>
   14be8:	ed b7       	in	r30, 0x3d	; 61
   14bea:	fe b7       	in	r31, 0x3e	; 62
   14bec:	31 96       	adiw	r30, 0x01	; 1
   14bee:	ad b7       	in	r26, 0x3d	; 61
   14bf0:	be b7       	in	r27, 0x3e	; 62
   14bf2:	12 96       	adiw	r26, 0x02	; 2
   14bf4:	fc 92       	st	X, r15
   14bf6:	ee 92       	st	-X, r14
   14bf8:	11 97       	sbiw	r26, 0x01	; 1
   14bfa:	b3 82       	std	Z+3, r11	; 0x03
   14bfc:	a2 82       	std	Z+2, r10	; 0x02
   14bfe:	d5 82       	std	Z+5, r13	; 0x05
   14c00:	c4 82       	std	Z+4, r12	; 0x04
   14c02:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  AddSpaceLag(strSend,40);
   14c06:	ed b7       	in	r30, 0x3d	; 61
   14c08:	fe b7       	in	r31, 0x3e	; 62
   14c0a:	36 96       	adiw	r30, 0x06	; 6
   14c0c:	0f b6       	in	r0, 0x3f	; 63
   14c0e:	f8 94       	cli
   14c10:	fe bf       	out	0x3e, r31	; 62
   14c12:	0f be       	out	0x3f, r0	; 63
   14c14:	ed bf       	out	0x3d, r30	; 61
   14c16:	c7 01       	movw	r24, r14
   14c18:	68 e2       	ldi	r22, 0x28	; 40
   14c1a:	0e 94 b9 2a 	call	0x5572	; 0x5572 <AddSpaceLag>
		  _uart_print(1,0,strSend);
   14c1e:	81 e0       	ldi	r24, 0x01	; 1
   14c20:	60 e0       	ldi	r22, 0x00	; 0
   14c22:	a7 01       	movw	r20, r14
   14c24:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
   14c28:	07 5d       	subi	r16, 0xD7	; 215
   14c2a:	1f 4f       	sbci	r17, 0xFF	; 255
char strEEPROM[41],xEEPROM;

     //Start
	 _uart_printf(1,0,PSTR("<"));
     //Header Footer 400
	 for (i=0;i<10;i++){
   14c2c:	f3 e0       	ldi	r31, 0x03	; 3
   14c2e:	01 3c       	cpi	r16, 0xC1	; 193
   14c30:	1f 07       	cpc	r17, r31
   14c32:	79 f6       	brne	.-98     	; 0x14bd2 <SendConfigParamater+0x54>
   14c34:	0b eb       	ldi	r16, 0xBB	; 187
   14c36:	10 e0       	ldi	r17, 0x00	; 0
   14c38:	6e 01       	movw	r12, r28
   14c3a:	08 94       	sec
   14c3c:	c1 1c       	adc	r12, r1
   14c3e:	d1 1c       	adc	r13, r1
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductName[i],sizeof(DefProductName[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14c40:	5a e2       	ldi	r21, 0x2A	; 42
   14c42:	e5 2e       	mov	r14, r21
   14c44:	f1 2c       	mov	r15, r1
   14c46:	ec 0e       	add	r14, r28
   14c48:	fd 1e       	adc	r15, r29
   14c4a:	4f e2       	ldi	r20, 0x2F	; 47
   14c4c:	a4 2e       	mov	r10, r20
   14c4e:	42 e2       	ldi	r20, 0x22	; 34
   14c50:	b4 2e       	mov	r11, r20
   14c52:	c6 01       	movw	r24, r12
   14c54:	b8 01       	movw	r22, r16
   14c56:	4d e0       	ldi	r20, 0x0D	; 13
   14c58:	50 e0       	ldi	r21, 0x00	; 0
   14c5a:	25 ed       	ldi	r18, 0xD5	; 213
   14c5c:	32 e1       	ldi	r19, 0x12	; 18
   14c5e:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
   14c62:	00 d0       	rcall	.+0      	; 0x14c64 <SendConfigParamater+0xe6>
   14c64:	00 d0       	rcall	.+0      	; 0x14c66 <SendConfigParamater+0xe8>
   14c66:	00 d0       	rcall	.+0      	; 0x14c68 <SendConfigParamater+0xea>
   14c68:	ed b7       	in	r30, 0x3d	; 61
   14c6a:	fe b7       	in	r31, 0x3e	; 62
   14c6c:	31 96       	adiw	r30, 0x01	; 1
   14c6e:	ad b7       	in	r26, 0x3d	; 61
   14c70:	be b7       	in	r27, 0x3e	; 62
   14c72:	12 96       	adiw	r26, 0x02	; 2
   14c74:	fc 92       	st	X, r15
   14c76:	ee 92       	st	-X, r14
   14c78:	11 97       	sbiw	r26, 0x01	; 1
   14c7a:	b3 82       	std	Z+3, r11	; 0x03
   14c7c:	a2 82       	std	Z+2, r10	; 0x02
   14c7e:	d5 82       	std	Z+5, r13	; 0x05
   14c80:	c4 82       	std	Z+4, r12	; 0x04
   14c82:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		 AddSpaceLag(strSend,12);
   14c86:	ed b7       	in	r30, 0x3d	; 61
   14c88:	fe b7       	in	r31, 0x3e	; 62
   14c8a:	36 96       	adiw	r30, 0x06	; 6
   14c8c:	0f b6       	in	r0, 0x3f	; 63
   14c8e:	f8 94       	cli
   14c90:	fe bf       	out	0x3e, r31	; 62
   14c92:	0f be       	out	0x3f, r0	; 63
   14c94:	ed bf       	out	0x3d, r30	; 61
   14c96:	c7 01       	movw	r24, r14
   14c98:	6c e0       	ldi	r22, 0x0C	; 12
   14c9a:	0e 94 b9 2a 	call	0x5572	; 0x5572 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14c9e:	81 e0       	ldi	r24, 0x01	; 1
   14ca0:	60 e0       	ldi	r22, 0x00	; 0
   14ca2:	a7 01       	movw	r20, r14
   14ca4:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
   14ca8:	03 5f       	subi	r16, 0xF3	; 243
   14caa:	1f 4f       	sbci	r17, 0xFF	; 255
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
		  AddSpaceLag(strSend,40);
		  _uart_print(1,0,strSend);
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
   14cac:	f1 e0       	ldi	r31, 0x01	; 1
   14cae:	09 30       	cpi	r16, 0x09	; 9
   14cb0:	1f 07       	cpc	r17, r31
   14cb2:	79 f6       	brne	.-98     	; 0x14c52 <SendConfigParamater+0xd4>
   14cb4:	05 e8       	ldi	r16, 0x85	; 133
   14cb6:	10 e0       	ldi	r17, 0x00	; 0
   14cb8:	6e 01       	movw	r12, r28
   14cba:	08 94       	sec
   14cbc:	c1 1c       	adc	r12, r1
   14cbe:	d1 1c       	adc	r13, r1
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductPrice[i],sizeof(DefProductPrice[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14cc0:	3a e2       	ldi	r19, 0x2A	; 42
   14cc2:	e3 2e       	mov	r14, r19
   14cc4:	f1 2c       	mov	r15, r1
   14cc6:	ec 0e       	add	r14, r28
   14cc8:	fd 1e       	adc	r15, r29
   14cca:	2c e2       	ldi	r18, 0x2C	; 44
   14ccc:	a2 2e       	mov	r10, r18
   14cce:	22 e2       	ldi	r18, 0x22	; 34
   14cd0:	b2 2e       	mov	r11, r18
   14cd2:	c6 01       	movw	r24, r12
   14cd4:	b8 01       	movw	r22, r16
   14cd6:	49 e0       	ldi	r20, 0x09	; 9
   14cd8:	50 e0       	ldi	r21, 0x00	; 0
   14cda:	25 ed       	ldi	r18, 0xD5	; 213
   14cdc:	32 e1       	ldi	r19, 0x12	; 18
   14cde:	0e 94 f4 b3 	call	0x167e8	; 0x167e8 <__eerd_block>
   14ce2:	00 d0       	rcall	.+0      	; 0x14ce4 <SendConfigParamater+0x166>
   14ce4:	00 d0       	rcall	.+0      	; 0x14ce6 <SendConfigParamater+0x168>
   14ce6:	00 d0       	rcall	.+0      	; 0x14ce8 <SendConfigParamater+0x16a>
   14ce8:	ed b7       	in	r30, 0x3d	; 61
   14cea:	fe b7       	in	r31, 0x3e	; 62
   14cec:	31 96       	adiw	r30, 0x01	; 1
   14cee:	ad b7       	in	r26, 0x3d	; 61
   14cf0:	be b7       	in	r27, 0x3e	; 62
   14cf2:	12 96       	adiw	r26, 0x02	; 2
   14cf4:	fc 92       	st	X, r15
   14cf6:	ee 92       	st	-X, r14
   14cf8:	11 97       	sbiw	r26, 0x01	; 1
   14cfa:	b3 82       	std	Z+3, r11	; 0x03
   14cfc:	a2 82       	std	Z+2, r10	; 0x02
   14cfe:	d5 82       	std	Z+5, r13	; 0x05
   14d00:	c4 82       	std	Z+4, r12	; 0x04
   14d02:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		 AddSpaceLag(strSend,5);
   14d06:	ed b7       	in	r30, 0x3d	; 61
   14d08:	fe b7       	in	r31, 0x3e	; 62
   14d0a:	36 96       	adiw	r30, 0x06	; 6
   14d0c:	0f b6       	in	r0, 0x3f	; 63
   14d0e:	f8 94       	cli
   14d10:	fe bf       	out	0x3e, r31	; 62
   14d12:	0f be       	out	0x3f, r0	; 63
   14d14:	ed bf       	out	0x3d, r30	; 61
   14d16:	c7 01       	movw	r24, r14
   14d18:	65 e0       	ldi	r22, 0x05	; 5
   14d1a:	0e 94 b9 2a 	call	0x5572	; 0x5572 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14d1e:	81 e0       	ldi	r24, 0x01	; 1
   14d20:	60 e0       	ldi	r22, 0x00	; 0
   14d22:	a7 01       	movw	r20, r14
   14d24:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
   14d28:	07 5f       	subi	r16, 0xF7	; 247
   14d2a:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,12);
		 _uart_print(1,0,strSend);
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
   14d2c:	f0 e0       	ldi	r31, 0x00	; 0
   14d2e:	0b 3b       	cpi	r16, 0xBB	; 187
   14d30:	1f 07       	cpc	r17, r31
   14d32:	79 f6       	brne	.-98     	; 0x14cd2 <SendConfigParamater+0x154>
   14d34:	05 e4       	ldi	r16, 0x45	; 69
   14d36:	10 e0       	ldi	r17, 0x00	; 0
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14d38:	9a e2       	ldi	r25, 0x2A	; 42
   14d3a:	e9 2e       	mov	r14, r25
   14d3c:	f1 2c       	mov	r15, r1
   14d3e:	ec 0e       	add	r14, r28
   14d40:	fd 1e       	adc	r15, r29
   14d42:	87 e2       	ldi	r24, 0x27	; 39
   14d44:	c8 2e       	mov	r12, r24
   14d46:	82 e2       	ldi	r24, 0x22	; 34
   14d48:	d8 2e       	mov	r13, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14d4a:	e1 99       	sbic	0x1c, 1	; 28
   14d4c:	fe cf       	rjmp	.-4      	; 0x14d4a <SendConfigParamater+0x1cc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14d4e:	1f bb       	out	0x1f, r17	; 31
   14d50:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14d52:	e0 9a       	sbi	0x1c, 0	; 28
   14d54:	8d b3       	in	r24, 0x1d	; 29
		 _uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   14d56:	84 36       	cpi	r24, 0x64	; 100
   14d58:	08 f0       	brcs	.+2      	; 0x14d5c <SendConfigParamater+0x1de>
   14d5a:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14d5c:	00 d0       	rcall	.+0      	; 0x14d5e <SendConfigParamater+0x1e0>
   14d5e:	00 d0       	rcall	.+0      	; 0x14d60 <SendConfigParamater+0x1e2>
   14d60:	00 d0       	rcall	.+0      	; 0x14d62 <SendConfigParamater+0x1e4>
   14d62:	ed b7       	in	r30, 0x3d	; 61
   14d64:	fe b7       	in	r31, 0x3e	; 62
   14d66:	31 96       	adiw	r30, 0x01	; 1
   14d68:	ad b7       	in	r26, 0x3d	; 61
   14d6a:	be b7       	in	r27, 0x3e	; 62
   14d6c:	12 96       	adiw	r26, 0x02	; 2
   14d6e:	fc 92       	st	X, r15
   14d70:	ee 92       	st	-X, r14
   14d72:	11 97       	sbiw	r26, 0x01	; 1
   14d74:	d3 82       	std	Z+3, r13	; 0x03
   14d76:	c2 82       	std	Z+2, r12	; 0x02
   14d78:	84 83       	std	Z+4, r24	; 0x04
   14d7a:	15 82       	std	Z+5, r1	; 0x05
   14d7c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  AddSpaceLag(strSend,2);
   14d80:	ed b7       	in	r30, 0x3d	; 61
   14d82:	fe b7       	in	r31, 0x3e	; 62
   14d84:	36 96       	adiw	r30, 0x06	; 6
   14d86:	0f b6       	in	r0, 0x3f	; 63
   14d88:	f8 94       	cli
   14d8a:	fe bf       	out	0x3e, r31	; 62
   14d8c:	0f be       	out	0x3f, r0	; 63
   14d8e:	ed bf       	out	0x3d, r30	; 61
   14d90:	c7 01       	movw	r24, r14
   14d92:	62 e0       	ldi	r22, 0x02	; 2
   14d94:	0e 94 b9 2a 	call	0x5572	; 0x5572 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14d98:	81 e0       	ldi	r24, 0x01	; 1
   14d9a:	60 e0       	ldi	r22, 0x00	; 0
   14d9c:	a7 01       	movw	r20, r14
   14d9e:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
   14da2:	0f 5f       	subi	r16, 0xFF	; 255
   14da4:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,5);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
   14da6:	f0 e0       	ldi	r31, 0x00	; 0
   14da8:	0d 34       	cpi	r16, 0x4D	; 77
   14daa:	1f 07       	cpc	r17, r31
   14dac:	71 f6       	brne	.-100    	; 0x14d4a <SendConfigParamater+0x1cc>
   14dae:	b5 e5       	ldi	r27, 0x55	; 85
   14db0:	eb 2e       	mov	r14, r27
   14db2:	b0 e0       	ldi	r27, 0x00	; 0
   14db4:	fb 2e       	mov	r15, r27
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14db6:	aa e2       	ldi	r26, 0x2A	; 42
   14db8:	aa 2e       	mov	r10, r26
   14dba:	b1 2c       	mov	r11, r1
   14dbc:	ac 0e       	add	r10, r28
   14dbe:	bd 1e       	adc	r11, r29
   14dc0:	f4 e2       	ldi	r31, 0x24	; 36
   14dc2:	8f 2e       	mov	r8, r31
   14dc4:	f2 e2       	ldi	r31, 0x22	; 34
   14dc6:	9f 2e       	mov	r9, r31
   14dc8:	37 c0       	rjmp	.+110    	; 0x14e38 <SendConfigParamater+0x2ba>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14dca:	e1 99       	sbic	0x1c, 1	; 28
   14dcc:	fe cf       	rjmp	.-4      	; 0x14dca <SendConfigParamater+0x24c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14dce:	1f bb       	out	0x1f, r17	; 31
   14dd0:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14dd2:	e0 9a       	sbi	0x1c, 0	; 28
   14dd4:	8d b3       	in	r24, 0x1d	; 29
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
   14dd6:	8a 30       	cpi	r24, 0x0A	; 10
   14dd8:	08 f0       	brcs	.+2      	; 0x14ddc <SendConfigParamater+0x25e>
   14dda:	80 e0       	ldi	r24, 0x00	; 0
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14ddc:	00 d0       	rcall	.+0      	; 0x14dde <SendConfigParamater+0x260>
   14dde:	00 d0       	rcall	.+0      	; 0x14de0 <SendConfigParamater+0x262>
   14de0:	00 d0       	rcall	.+0      	; 0x14de2 <SendConfigParamater+0x264>
   14de2:	ed b7       	in	r30, 0x3d	; 61
   14de4:	fe b7       	in	r31, 0x3e	; 62
   14de6:	31 96       	adiw	r30, 0x01	; 1
   14de8:	ad b7       	in	r26, 0x3d	; 61
   14dea:	be b7       	in	r27, 0x3e	; 62
   14dec:	12 96       	adiw	r26, 0x02	; 2
   14dee:	bc 92       	st	X, r11
   14df0:	ae 92       	st	-X, r10
   14df2:	11 97       	sbiw	r26, 0x01	; 1
   14df4:	93 82       	std	Z+3, r9	; 0x03
   14df6:	82 82       	std	Z+2, r8	; 0x02
   14df8:	84 83       	std	Z+4, r24	; 0x04
   14dfa:	15 82       	std	Z+5, r1	; 0x05
   14dfc:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
			   _uart_print(1,0,strSend);
   14e00:	ed b7       	in	r30, 0x3d	; 61
   14e02:	fe b7       	in	r31, 0x3e	; 62
   14e04:	36 96       	adiw	r30, 0x06	; 6
   14e06:	0f b6       	in	r0, 0x3f	; 63
   14e08:	f8 94       	cli
   14e0a:	fe bf       	out	0x3e, r31	; 62
   14e0c:	0f be       	out	0x3f, r0	; 63
   14e0e:	ed bf       	out	0x3d, r30	; 61
   14e10:	81 e0       	ldi	r24, 0x01	; 1
   14e12:	60 e0       	ldi	r22, 0x00	; 0
   14e14:	a5 01       	movw	r20, r10
   14e16:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
   14e1a:	d3 94       	inc	r13
   14e1c:	0f 5f       	subi	r16, 0xFF	; 255
   14e1e:	1f 4f       	sbci	r17, 0xFF	; 255
   14e20:	f6 e0       	ldi	r31, 0x06	; 6
   14e22:	df 16       	cp	r13, r31
   14e24:	91 f6       	brne	.-92     	; 0x14dca <SendConfigParamater+0x24c>
   14e26:	86 e0       	ldi	r24, 0x06	; 6
   14e28:	90 e0       	ldi	r25, 0x00	; 0
   14e2a:	e8 0e       	add	r14, r24
   14e2c:	f9 1e       	adc	r15, r25
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
   14e2e:	95 e8       	ldi	r25, 0x85	; 133
   14e30:	e9 16       	cp	r14, r25
   14e32:	90 e0       	ldi	r25, 0x00	; 0
   14e34:	f9 06       	cpc	r15, r25
   14e36:	19 f0       	breq	.+6      	; 0x14e3e <SendConfigParamater+0x2c0>
   14e38:	87 01       	movw	r16, r14
   14e3a:	dd 24       	eor	r13, r13
   14e3c:	c6 cf       	rjmp	.-116    	; 0x14dca <SendConfigParamater+0x24c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14e3e:	e1 99       	sbic	0x1c, 1	; 28
   14e40:	fe cf       	rjmp	.-4      	; 0x14e3e <SendConfigParamater+0x2c0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14e42:	81 ec       	ldi	r24, 0xC1	; 193
   14e44:	93 e0       	ldi	r25, 0x03	; 3
   14e46:	9f bb       	out	0x1f, r25	; 31
   14e48:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14e4a:	e0 9a       	sbi	0x1c, 0	; 28
   14e4c:	8d b3       	in	r24, 0x1d	; 29
   14e4e:	9e 01       	movw	r18, r28
   14e50:	26 5d       	subi	r18, 0xD6	; 214
   14e52:	3f 4f       	sbci	r19, 0xFF	; 255
			   _uart_print(1,0,strSend);
		  }
	 }
	 //PrintNoMoney
	 xEEPROM=eeprom_read_byte(&DefPrintMoney);
	 if (xEEPROM==True){
   14e54:	81 30       	cpi	r24, 0x01	; 1
   14e56:	79 f4       	brne	.+30     	; 0x14e76 <SendConfigParamater+0x2f8>
		 sprintf_P(strSend,PSTR("1"));
   14e58:	00 d0       	rcall	.+0      	; 0x14e5a <SendConfigParamater+0x2dc>
   14e5a:	00 d0       	rcall	.+0      	; 0x14e5c <SendConfigParamater+0x2de>
   14e5c:	ad b7       	in	r26, 0x3d	; 61
   14e5e:	be b7       	in	r27, 0x3e	; 62
   14e60:	12 96       	adiw	r26, 0x02	; 2
   14e62:	3c 93       	st	X, r19
   14e64:	2e 93       	st	-X, r18
   14e66:	11 97       	sbiw	r26, 0x01	; 1
   14e68:	82 e2       	ldi	r24, 0x22	; 34
   14e6a:	92 e2       	ldi	r25, 0x22	; 34
   14e6c:	14 96       	adiw	r26, 0x04	; 4
   14e6e:	9c 93       	st	X, r25
   14e70:	8e 93       	st	-X, r24
   14e72:	13 97       	sbiw	r26, 0x03	; 3
   14e74:	0a c0       	rjmp	.+20     	; 0x14e8a <SendConfigParamater+0x30c>
	 }else{
	     sprintf_P(strSend,PSTR("0"));
   14e76:	00 d0       	rcall	.+0      	; 0x14e78 <SendConfigParamater+0x2fa>
   14e78:	00 d0       	rcall	.+0      	; 0x14e7a <SendConfigParamater+0x2fc>
   14e7a:	ed b7       	in	r30, 0x3d	; 61
   14e7c:	fe b7       	in	r31, 0x3e	; 62
   14e7e:	32 83       	std	Z+2, r19	; 0x02
   14e80:	21 83       	std	Z+1, r18	; 0x01
   14e82:	80 e2       	ldi	r24, 0x20	; 32
   14e84:	92 e2       	ldi	r25, 0x22	; 34
   14e86:	94 83       	std	Z+4, r25	; 0x04
   14e88:	83 83       	std	Z+3, r24	; 0x03
   14e8a:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   14e8e:	0f 90       	pop	r0
   14e90:	0f 90       	pop	r0
   14e92:	0f 90       	pop	r0
   14e94:	0f 90       	pop	r0
	 }_uart_print(1,0,strSend);
   14e96:	81 e0       	ldi	r24, 0x01	; 1
   14e98:	60 e0       	ldi	r22, 0x00	; 0
   14e9a:	ae 01       	movw	r20, r28
   14e9c:	46 5d       	subi	r20, 0xD6	; 214
   14e9e:	5f 4f       	sbci	r21, 0xFF	; 255
   14ea0:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14ea4:	e1 99       	sbic	0x1c, 1	; 28
   14ea6:	fe cf       	rjmp	.-4      	; 0x14ea4 <SendConfigParamater+0x326>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14ea8:	80 e0       	ldi	r24, 0x00	; 0
   14eaa:	90 e0       	ldi	r25, 0x00	; 0
   14eac:	9f bb       	out	0x1f, r25	; 31
   14eae:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14eb0:	e0 9a       	sbi	0x1c, 0	; 28
   14eb2:	2d b3       	in	r18, 0x1d	; 29
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14eb4:	00 d0       	rcall	.+0      	; 0x14eb6 <SendConfigParamater+0x338>
   14eb6:	00 d0       	rcall	.+0      	; 0x14eb8 <SendConfigParamater+0x33a>
   14eb8:	00 d0       	rcall	.+0      	; 0x14eba <SendConfigParamater+0x33c>
   14eba:	ed b7       	in	r30, 0x3d	; 61
   14ebc:	fe b7       	in	r31, 0x3e	; 62
   14ebe:	31 96       	adiw	r30, 0x01	; 1
   14ec0:	8e 01       	movw	r16, r28
   14ec2:	06 5d       	subi	r16, 0xD6	; 214
   14ec4:	1f 4f       	sbci	r17, 0xFF	; 255
   14ec6:	ad b7       	in	r26, 0x3d	; 61
   14ec8:	be b7       	in	r27, 0x3e	; 62
   14eca:	12 96       	adiw	r26, 0x02	; 2
   14ecc:	1c 93       	st	X, r17
   14ece:	0e 93       	st	-X, r16
   14ed0:	11 97       	sbiw	r26, 0x01	; 1
   14ed2:	8b e1       	ldi	r24, 0x1B	; 27
   14ed4:	92 e2       	ldi	r25, 0x22	; 34
   14ed6:	93 83       	std	Z+3, r25	; 0x03
   14ed8:	82 83       	std	Z+2, r24	; 0x02
   14eda:	24 83       	std	Z+4, r18	; 0x04
   14edc:	15 82       	std	Z+5, r1	; 0x05
   14ede:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
     _uart_print(1,0,strSend);
   14ee2:	ed b7       	in	r30, 0x3d	; 61
   14ee4:	fe b7       	in	r31, 0x3e	; 62
   14ee6:	36 96       	adiw	r30, 0x06	; 6
   14ee8:	0f b6       	in	r0, 0x3f	; 63
   14eea:	f8 94       	cli
   14eec:	fe bf       	out	0x3e, r31	; 62
   14eee:	0f be       	out	0x3f, r0	; 63
   14ef0:	ed bf       	out	0x3d, r30	; 61
   14ef2:	81 e0       	ldi	r24, 0x01	; 1
   14ef4:	60 e0       	ldi	r22, 0x00	; 0
   14ef6:	a8 01       	movw	r20, r16
   14ef8:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
   14efc:	ed e4       	ldi	r30, 0x4D	; 77
   14efe:	ee 2e       	mov	r14, r30
   14f00:	e0 e0       	ldi	r30, 0x00	; 0
   14f02:	fe 2e       	mov	r15, r30
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14f04:	d0 2e       	mov	r13, r16
   14f06:	01 2f       	mov	r16, r17
   14f08:	76 e1       	ldi	r23, 0x16	; 22
   14f0a:	a7 2e       	mov	r10, r23
   14f0c:	72 e2       	ldi	r23, 0x22	; 34
   14f0e:	b7 2e       	mov	r11, r23
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14f10:	e1 99       	sbic	0x1c, 1	; 28
   14f12:	fe cf       	rjmp	.-4      	; 0x14f10 <SendConfigParamater+0x392>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14f14:	ff ba       	out	0x1f, r15	; 31
   14f16:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14f18:	e0 9a       	sbi	0x1c, 0	; 28
   14f1a:	8d b3       	in	r24, 0x1d	; 29
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     _uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   14f1c:	84 36       	cpi	r24, 0x64	; 100
   14f1e:	08 f0       	brcs	.+2      	; 0x14f22 <SendConfigParamater+0x3a4>
   14f20:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14f22:	00 d0       	rcall	.+0      	; 0x14f24 <SendConfigParamater+0x3a6>
   14f24:	00 d0       	rcall	.+0      	; 0x14f26 <SendConfigParamater+0x3a8>
   14f26:	00 d0       	rcall	.+0      	; 0x14f28 <SendConfigParamater+0x3aa>
   14f28:	ed b7       	in	r30, 0x3d	; 61
   14f2a:	fe b7       	in	r31, 0x3e	; 62
   14f2c:	31 96       	adiw	r30, 0x01	; 1
   14f2e:	ad b7       	in	r26, 0x3d	; 61
   14f30:	be b7       	in	r27, 0x3e	; 62
   14f32:	11 96       	adiw	r26, 0x01	; 1
   14f34:	dc 92       	st	X, r13
   14f36:	11 97       	sbiw	r26, 0x01	; 1
   14f38:	12 96       	adiw	r26, 0x02	; 2
   14f3a:	0c 93       	st	X, r16
   14f3c:	b3 82       	std	Z+3, r11	; 0x03
   14f3e:	a2 82       	std	Z+2, r10	; 0x02
   14f40:	84 83       	std	Z+4, r24	; 0x04
   14f42:	15 82       	std	Z+5, r1	; 0x05
   14f44:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
		  AddSpaceLag(strSend,2);
   14f48:	ed b7       	in	r30, 0x3d	; 61
   14f4a:	fe b7       	in	r31, 0x3e	; 62
   14f4c:	36 96       	adiw	r30, 0x06	; 6
   14f4e:	0f b6       	in	r0, 0x3f	; 63
   14f50:	f8 94       	cli
   14f52:	fe bf       	out	0x3e, r31	; 62
   14f54:	0f be       	out	0x3f, r0	; 63
   14f56:	ed bf       	out	0x3d, r30	; 61
   14f58:	8d 2d       	mov	r24, r13
   14f5a:	90 2f       	mov	r25, r16
   14f5c:	62 e0       	ldi	r22, 0x02	; 2
   14f5e:	0e 94 b9 2a 	call	0x5572	; 0x5572 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14f62:	81 e0       	ldi	r24, 0x01	; 1
   14f64:	60 e0       	ldi	r22, 0x00	; 0
   14f66:	4d 2d       	mov	r20, r13
   14f68:	50 2f       	mov	r21, r16
   14f6a:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>
   14f6e:	08 94       	sec
   14f70:	e1 1c       	adc	r14, r1
   14f72:	f1 1c       	adc	r15, r1
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     _uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
   14f74:	f5 e5       	ldi	r31, 0x55	; 85
   14f76:	ef 16       	cp	r14, r31
   14f78:	f0 e0       	ldi	r31, 0x00	; 0
   14f7a:	ff 06       	cpc	r15, r31
   14f7c:	49 f6       	brne	.-110    	; 0x14f10 <SendConfigParamater+0x392>
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 _uart_printf(1,1,PSTR(">"));
   14f7e:	81 e0       	ldi	r24, 0x01	; 1
   14f80:	61 e0       	ldi	r22, 0x01	; 1
   14f82:	44 e1       	ldi	r20, 0x14	; 20
   14f84:	52 e2       	ldi	r21, 0x22	; 34
   14f86:	0e 94 94 b2 	call	0x16528	; 0x16528 <_uart_printf>
	 //End
}
   14f8a:	cb 59       	subi	r28, 0x9B	; 155
   14f8c:	df 4f       	sbci	r29, 0xFF	; 255
   14f8e:	0f b6       	in	r0, 0x3f	; 63
   14f90:	f8 94       	cli
   14f92:	de bf       	out	0x3e, r29	; 62
   14f94:	0f be       	out	0x3f, r0	; 63
   14f96:	cd bf       	out	0x3d, r28	; 61
   14f98:	cf 91       	pop	r28
   14f9a:	df 91       	pop	r29
   14f9c:	1f 91       	pop	r17
   14f9e:	0f 91       	pop	r16
   14fa0:	ff 90       	pop	r15
   14fa2:	ef 90       	pop	r14
   14fa4:	df 90       	pop	r13
   14fa6:	cf 90       	pop	r12
   14fa8:	bf 90       	pop	r11
   14faa:	af 90       	pop	r10
   14fac:	9f 90       	pop	r9
   14fae:	8f 90       	pop	r8
   14fb0:	08 95       	ret

00014fb2 <SaveConfigParameter>:
     char Result;
	 Result=False;
   return Result;
}

void SaveConfigParameter(){
   14fb2:	8f 92       	push	r8
   14fb4:	9f 92       	push	r9
   14fb6:	af 92       	push	r10
   14fb8:	bf 92       	push	r11
   14fba:	cf 92       	push	r12
   14fbc:	df 92       	push	r13
   14fbe:	ef 92       	push	r14
   14fc0:	ff 92       	push	r15
   14fc2:	0f 93       	push	r16
   14fc4:	1f 93       	push	r17
   14fc6:	df 93       	push	r29
   14fc8:	cf 93       	push	r28
   14fca:	cd b7       	in	r28, 0x3d	; 61
   14fcc:	de b7       	in	r29, 0x3e	; 62
   14fce:	c6 54       	subi	r28, 0x46	; 70
   14fd0:	d0 40       	sbci	r29, 0x00	; 0
   14fd2:	0f b6       	in	r0, 0x3f	; 63
   14fd4:	f8 94       	cli
   14fd6:	de bf       	out	0x3e, r29	; 62
   14fd8:	0f be       	out	0x3f, r0	; 63
   14fda:	cd bf       	out	0x3d, r28	; 61
char i,j;
char strEEPROM[50],xEEPROM;
unsigned int StrPos;
char strSend[20];
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
   14fdc:	00 d0       	rcall	.+0      	; 0x14fde <SaveConfigParameter+0x2c>
   14fde:	00 d0       	rcall	.+0      	; 0x14fe0 <SaveConfigParameter+0x2e>
   14fe0:	00 d0       	rcall	.+0      	; 0x14fe2 <SaveConfigParameter+0x30>
   14fe2:	ed b7       	in	r30, 0x3d	; 61
   14fe4:	fe b7       	in	r31, 0x3e	; 62
   14fe6:	31 96       	adiw	r30, 0x01	; 1
   14fe8:	8e 01       	movw	r16, r28
   14fea:	0f 5f       	subi	r16, 0xFF	; 255
   14fec:	1f 4f       	sbci	r17, 0xFF	; 255
   14fee:	ad b7       	in	r26, 0x3d	; 61
   14ff0:	be b7       	in	r27, 0x3e	; 62
   14ff2:	12 96       	adiw	r26, 0x02	; 2
   14ff4:	1c 93       	st	X, r17
   14ff6:	0e 93       	st	-X, r16
   14ff8:	11 97       	sbiw	r26, 0x01	; 1
   14ffa:	8e e4       	ldi	r24, 0x4E	; 78
   14ffc:	92 e2       	ldi	r25, 0x22	; 34
   14ffe:	93 83       	std	Z+3, r25	; 0x03
   15000:	82 83       	std	Z+2, r24	; 0x02
   15002:	80 91 9e 01 	lds	r24, 0x019E
   15006:	90 91 9f 01 	lds	r25, 0x019F
   1500a:	95 83       	std	Z+5, r25	; 0x05
   1500c:	84 83       	std	Z+4, r24	; 0x04
   1500e:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	 _uart_print(1,1,strSend);
   15012:	ed b7       	in	r30, 0x3d	; 61
   15014:	fe b7       	in	r31, 0x3e	; 62
   15016:	36 96       	adiw	r30, 0x06	; 6
   15018:	0f b6       	in	r0, 0x3f	; 63
   1501a:	f8 94       	cli
   1501c:	fe bf       	out	0x3e, r31	; 62
   1501e:	0f be       	out	0x3f, r0	; 63
   15020:	ed bf       	out	0x3d, r30	; 61
   15022:	81 e0       	ldi	r24, 0x01	; 1
   15024:	61 e0       	ldi	r22, 0x01	; 1
   15026:	a8 01       	movw	r20, r16
   15028:	0e 94 6c b2 	call	0x164d8	; 0x164d8 <_uart_print>

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
   1502c:	81 e0       	ldi	r24, 0x01	; 1
   1502e:	61 e0       	ldi	r22, 0x01	; 1
   15030:	45 e4       	ldi	r20, 0x45	; 69
   15032:	52 e2       	ldi	r21, 0x22	; 34
   15034:	0e 94 94 b2 	call	0x16528	; 0x16528 <_uart_printf>
   15038:	07 e2       	ldi	r16, 0x27	; 39
   1503a:	12 e0       	ldi	r17, 0x02	; 2
   1503c:	a5 e4       	ldi	r26, 0x45	; 69
   1503e:	ea 2e       	mov	r14, r26
   15040:	ab e0       	ldi	r26, 0x0B	; 11
   15042:	fa 2e       	mov	r15, r26
   15044:	f5 e1       	ldi	r31, 0x15	; 21
   15046:	af 2e       	mov	r10, r31
   15048:	b1 2c       	mov	r11, r1
   1504a:	ac 0e       	add	r10, r28
   1504c:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1504e:	ed e3       	ldi	r30, 0x3D	; 61
   15050:	ce 2e       	mov	r12, r30
   15052:	d1 2c       	mov	r13, r1
   15054:	cc 0e       	add	r12, r28
   15056:	dd 1e       	adc	r13, r29
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
   15058:	d7 01       	movw	r26, r14
   1505a:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1505c:	8d 91       	ld	r24, X+
   1505e:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   15060:	ec 15       	cp	r30, r12
   15062:	fd 05       	cpc	r31, r13
   15064:	d9 f7       	brne	.-10     	; 0x1505c <SaveConfigParameter+0xaa>
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(40*i)),40);
		 strEEPROM[40]=0;
   15066:	1d ae       	std	Y+61, r1	; 0x3d
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   15068:	c8 01       	movw	r24, r16
   1506a:	b5 01       	movw	r22, r10
   1506c:	49 e2       	ldi	r20, 0x29	; 41
   1506e:	50 e0       	ldi	r21, 0x00	; 0
   15070:	2d ed       	ldi	r18, 0xDD	; 221
   15072:	32 e1       	ldi	r19, 0x12	; 18
   15074:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
   15078:	07 5d       	subi	r16, 0xD7	; 215
   1507a:	1f 4f       	sbci	r17, 0xFF	; 255
   1507c:	88 e2       	ldi	r24, 0x28	; 40
   1507e:	90 e0       	ldi	r25, 0x00	; 0
   15080:	e8 0e       	add	r14, r24
   15082:	f9 1e       	adc	r15, r25
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   15084:	93 e0       	ldi	r25, 0x03	; 3
   15086:	01 3c       	cpi	r16, 0xC1	; 193
   15088:	19 07       	cpc	r17, r25
   1508a:	31 f7       	brne	.-52     	; 0x15058 <SaveConfigParameter+0xa6>
   1508c:	0b eb       	ldi	r16, 0xBB	; 187
   1508e:	10 e0       	ldi	r17, 0x00	; 0
   15090:	75 ed       	ldi	r23, 0xD5	; 213
   15092:	e7 2e       	mov	r14, r23
   15094:	7c e0       	ldi	r23, 0x0C	; 12
   15096:	f7 2e       	mov	r15, r23
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   15098:	65 e1       	ldi	r22, 0x15	; 21
   1509a:	c6 2e       	mov	r12, r22
   1509c:	d1 2c       	mov	r13, r1
   1509e:	cc 0e       	add	r12, r28
   150a0:	dd 1e       	adc	r13, r29
   150a2:	51 e2       	ldi	r21, 0x21	; 33
   150a4:	85 2e       	mov	r8, r21
   150a6:	91 2c       	mov	r9, r1
   150a8:	8c 0e       	add	r8, r28
   150aa:	9d 1e       	adc	r9, r29
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   150ac:	d7 01       	movw	r26, r14
   150ae:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   150b0:	8d 91       	ld	r24, X+
   150b2:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   150b4:	e8 15       	cp	r30, r8
   150b6:	f9 05       	cpc	r31, r9
   150b8:	d9 f7       	brne	.-10     	; 0x150b0 <SaveConfigParameter+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   150ba:	19 a2       	std	Y+33, r1	; 0x21
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(12*i)),12);
		 RemSpaceLag(strEEPROM);
   150bc:	c6 01       	movw	r24, r12
   150be:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
		 strEEPROM[strlen(strEEPROM)]=0;
   150c2:	f6 01       	movw	r30, r12
   150c4:	01 90       	ld	r0, Z+
   150c6:	00 20       	and	r0, r0
   150c8:	e9 f7       	brne	.-6      	; 0x150c4 <SaveConfigParameter+0x112>
   150ca:	31 97       	sbiw	r30, 0x01	; 1
   150cc:	10 82       	st	Z, r1
   150ce:	c8 01       	movw	r24, r16
   150d0:	b6 01       	movw	r22, r12
   150d2:	4d e0       	ldi	r20, 0x0D	; 13
   150d4:	50 e0       	ldi	r21, 0x00	; 0
   150d6:	2d ed       	ldi	r18, 0xDD	; 221
   150d8:	32 e1       	ldi	r19, 0x12	; 18
   150da:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
   150de:	03 5f       	subi	r16, 0xF3	; 243
   150e0:	1f 4f       	sbci	r17, 0xFF	; 255
   150e2:	ac e0       	ldi	r26, 0x0C	; 12
   150e4:	b0 e0       	ldi	r27, 0x00	; 0
   150e6:	ea 0e       	add	r14, r26
   150e8:	fb 1e       	adc	r15, r27
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //_uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   150ea:	b1 e0       	ldi	r27, 0x01	; 1
   150ec:	09 30       	cpi	r16, 0x09	; 9
   150ee:	1b 07       	cpc	r17, r27
   150f0:	e9 f6       	brne	.-70     	; 0x150ac <SaveConfigParameter+0xfa>
   150f2:	05 e8       	ldi	r16, 0x85	; 133
   150f4:	10 e0       	ldi	r17, 0x00	; 0
   150f6:	4d e1       	ldi	r20, 0x1D	; 29
   150f8:	e4 2e       	mov	r14, r20
   150fa:	4d e0       	ldi	r20, 0x0D	; 13
   150fc:	f4 2e       	mov	r15, r20
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   150fe:	35 e1       	ldi	r19, 0x15	; 21
   15100:	c3 2e       	mov	r12, r19
   15102:	d1 2c       	mov	r13, r1
   15104:	cc 0e       	add	r12, r28
   15106:	dd 1e       	adc	r13, r29
   15108:	2a e1       	ldi	r18, 0x1A	; 26
   1510a:	82 2e       	mov	r8, r18
   1510c:	91 2c       	mov	r9, r1
   1510e:	8c 0e       	add	r8, r28
   15110:	9d 1e       	adc	r9, r29
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //_uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   15112:	d7 01       	movw	r26, r14
   15114:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   15116:	8d 91       	ld	r24, X+
   15118:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1511a:	e8 15       	cp	r30, r8
   1511c:	f9 05       	cpc	r31, r9
   1511e:	d9 f7       	brne	.-10     	; 0x15116 <SaveConfigParameter+0x164>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   15120:	1a 8e       	std	Y+26, r1	; 0x1a
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(5*i)),5);
		 RemSpaceLag(strEEPROM);
   15122:	c6 01       	movw	r24, r12
   15124:	0e 94 51 24 	call	0x48a2	; 0x48a2 <RemSpaceLag>
   15128:	c8 01       	movw	r24, r16
   1512a:	b6 01       	movw	r22, r12
   1512c:	49 e0       	ldi	r20, 0x09	; 9
   1512e:	50 e0       	ldi	r21, 0x00	; 0
   15130:	2d ed       	ldi	r18, 0xDD	; 221
   15132:	32 e1       	ldi	r19, 0x12	; 18
   15134:	0e 94 10 b4 	call	0x16820	; 0x16820 <__eewr_block>
   15138:	07 5f       	subi	r16, 0xF7	; 247
   1513a:	1f 4f       	sbci	r17, 0xFF	; 255
   1513c:	e5 e0       	ldi	r30, 0x05	; 5
   1513e:	f0 e0       	ldi	r31, 0x00	; 0
   15140:	ee 0e       	add	r14, r30
   15142:	ff 1e       	adc	r15, r31
		// _uart_print(1,1,strEEPROM);

	 }    
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
   15144:	f0 e0       	ldi	r31, 0x00	; 0
   15146:	0b 3b       	cpi	r16, 0xBB	; 187
   15148:	1f 07       	cpc	r17, r31
   1514a:	19 f7       	brne	.-58     	; 0x15112 <SaveConfigParameter+0x160>
   1514c:	0b e3       	ldi	r16, 0x3B	; 59
   1514e:	1d e0       	ldi	r17, 0x0D	; 13
   15150:	95 e4       	ldi	r25, 0x45	; 69
   15152:	e9 2e       	mov	r14, r25
   15154:	90 e0       	ldi	r25, 0x00	; 0
   15156:	f9 2e       	mov	r15, r25
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   15158:	85 e1       	ldi	r24, 0x15	; 21
   1515a:	c8 2e       	mov	r12, r24
   1515c:	d1 2c       	mov	r13, r1
   1515e:	cc 0e       	add	r12, r28
   15160:	dd 1e       	adc	r13, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   15162:	4e 01       	movw	r8, r28
   15164:	08 94       	sec
   15166:	81 1c       	adc	r8, r1
   15168:	91 1c       	adc	r9, r1
   1516a:	b2 e4       	ldi	r27, 0x42	; 66
   1516c:	ab 2e       	mov	r10, r27
   1516e:	b2 e2       	ldi	r27, 0x22	; 34
   15170:	bb 2e       	mov	r11, r27
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   15172:	d8 01       	movw	r26, r16
   15174:	8c 91       	ld	r24, X
   15176:	8d 8b       	std	Y+21, r24	; 0x15
   15178:	11 96       	adiw	r26, 0x01	; 1
   1517a:	8c 91       	ld	r24, X
   1517c:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   1517e:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   15180:	c6 01       	movw	r24, r12
   15182:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   15186:	c6 01       	movw	r24, r12
   15188:	0e 94 bf b3 	call	0x1677e	; 0x1677e <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1518c:	e1 99       	sbic	0x1c, 1	; 28
   1518e:	fe cf       	rjmp	.-4      	; 0x1518c <SaveConfigParameter+0x1da>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15190:	ff ba       	out	0x1f, r15	; 31
   15192:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   15194:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   15196:	0f b6       	in	r0, 0x3f	; 63
   15198:	f8 94       	cli
   1519a:	e2 9a       	sbi	0x1c, 2	; 28
   1519c:	e1 9a       	sbi	0x1c, 1	; 28
   1519e:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   151a0:	00 d0       	rcall	.+0      	; 0x151a2 <SaveConfigParameter+0x1f0>
   151a2:	00 d0       	rcall	.+0      	; 0x151a4 <SaveConfigParameter+0x1f2>
   151a4:	00 d0       	rcall	.+0      	; 0x151a6 <SaveConfigParameter+0x1f4>
   151a6:	ed b7       	in	r30, 0x3d	; 61
   151a8:	fe b7       	in	r31, 0x3e	; 62
   151aa:	31 96       	adiw	r30, 0x01	; 1
   151ac:	ad b7       	in	r26, 0x3d	; 61
   151ae:	be b7       	in	r27, 0x3e	; 62
   151b0:	12 96       	adiw	r26, 0x02	; 2
   151b2:	9c 92       	st	X, r9
   151b4:	8e 92       	st	-X, r8
   151b6:	11 97       	sbiw	r26, 0x01	; 1
   151b8:	b3 82       	std	Z+3, r11	; 0x03
   151ba:	a2 82       	std	Z+2, r10	; 0x02
   151bc:	84 83       	std	Z+4, r24	; 0x04
   151be:	15 82       	std	Z+5, r1	; 0x05
   151c0:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   151c4:	0e 5f       	subi	r16, 0xFE	; 254
   151c6:	1f 4f       	sbci	r17, 0xFF	; 255
   151c8:	08 94       	sec
   151ca:	e1 1c       	adc	r14, r1
   151cc:	f1 1c       	adc	r15, r1
		// _uart_print(1,1,strEEPROM);

	 }    
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
   151ce:	ed b7       	in	r30, 0x3d	; 61
   151d0:	fe b7       	in	r31, 0x3e	; 62
   151d2:	36 96       	adiw	r30, 0x06	; 6
   151d4:	0f b6       	in	r0, 0x3f	; 63
   151d6:	f8 94       	cli
   151d8:	fe bf       	out	0x3e, r31	; 62
   151da:	0f be       	out	0x3f, r0	; 63
   151dc:	ed bf       	out	0x3d, r30	; 61
   151de:	fd e0       	ldi	r31, 0x0D	; 13
   151e0:	0b 34       	cpi	r16, 0x4B	; 75
   151e2:	1f 07       	cpc	r17, r31
   151e4:	09 f0       	breq	.+2      	; 0x151e8 <SaveConfigParameter+0x236>
   151e6:	c5 cf       	rjmp	.-118    	; 0x15172 <SaveConfigParameter+0x1c0>
   151e8:	45 e5       	ldi	r20, 0x55	; 85
   151ea:	50 e0       	ldi	r21, 0x00	; 0
   151ec:	b8 01       	movw	r22, r16
   151ee:	1d c0       	rjmp	.+58     	; 0x1522a <SaveConfigParameter+0x278>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   151f0:	90 81       	ld	r25, Z
   151f2:	90 53       	subi	r25, 0x30	; 48
   151f4:	9a 30       	cpi	r25, 0x0A	; 10
   151f6:	08 f0       	brcs	.+2      	; 0x151fa <SaveConfigParameter+0x248>
   151f8:	90 e0       	ldi	r25, 0x00	; 0
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   151fa:	e1 99       	sbic	0x1c, 1	; 28
   151fc:	fe cf       	rjmp	.-4      	; 0x151fa <SaveConfigParameter+0x248>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   151fe:	3f bb       	out	0x1f, r19	; 31
   15200:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
   15202:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
   15204:	0f b6       	in	r0, 0x3f	; 63
   15206:	f8 94       	cli
   15208:	e2 9a       	sbi	0x1c, 2	; 28
   1520a:	e1 9a       	sbi	0x1c, 1	; 28
   1520c:	0f be       	out	0x3f, r0	; 63

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
	     for (j=0;j<6;j++){
   1520e:	8f 5f       	subi	r24, 0xFF	; 255
   15210:	31 96       	adiw	r30, 0x01	; 1
   15212:	2f 5f       	subi	r18, 0xFF	; 255
   15214:	3f 4f       	sbci	r19, 0xFF	; 255
   15216:	86 30       	cpi	r24, 0x06	; 6
   15218:	59 f7       	brne	.-42     	; 0x151f0 <SaveConfigParameter+0x23e>
   1521a:	4a 5f       	subi	r20, 0xFA	; 250
   1521c:	5f 4f       	sbci	r21, 0xFF	; 255
   1521e:	6a 5f       	subi	r22, 0xFA	; 250
   15220:	7f 4f       	sbci	r23, 0xFF	; 255
		// _uart_print(1,1,strSend); 

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
   15222:	80 e0       	ldi	r24, 0x00	; 0
   15224:	45 38       	cpi	r20, 0x85	; 133
   15226:	58 07       	cpc	r21, r24
   15228:	21 f0       	breq	.+8      	; 0x15232 <SaveConfigParameter+0x280>
   1522a:	fb 01       	movw	r30, r22
   1522c:	9a 01       	movw	r18, r20
   1522e:	80 e0       	ldi	r24, 0x00	; 0
   15230:	df cf       	rjmp	.-66     	; 0x151f0 <SaveConfigParameter+0x23e>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   15232:	80 91 7b 0d 	lds	r24, 0x0D7B
   15236:	80 53       	subi	r24, 0x30	; 48
   15238:	8a 30       	cpi	r24, 0x0A	; 10
   1523a:	10 f0       	brcs	.+4      	; 0x15240 <SaveConfigParameter+0x28e>
   1523c:	20 e0       	ldi	r18, 0x00	; 0
   1523e:	03 c0       	rjmp	.+6      	; 0x15246 <SaveConfigParameter+0x294>
   15240:	81 11       	cpse	r24, r1
   15242:	81 e0       	ldi	r24, 0x01	; 1
   15244:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15246:	e1 99       	sbic	0x1c, 1	; 28
   15248:	fe cf       	rjmp	.-4      	; 0x15246 <SaveConfigParameter+0x294>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1524a:	81 ec       	ldi	r24, 0xC1	; 193
   1524c:	93 e0       	ldi	r25, 0x03	; 3
   1524e:	9f bb       	out	0x1f, r25	; 31
   15250:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   15252:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   15254:	0f b6       	in	r0, 0x3f	; 63
   15256:	f8 94       	cli
   15258:	e2 9a       	sbi	0x1c, 2	; 28
   1525a:	e1 9a       	sbi	0x1c, 1	; 28
   1525c:	0f be       	out	0x3f, r0	; 63
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1525e:	80 91 7c 0d 	lds	r24, 0x0D7C
   15262:	8d 8b       	std	Y+21, r24	; 0x15
   15264:	80 91 7d 0d 	lds	r24, 0x0D7D
   15268:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   1526a:	1f 8a       	std	Y+23, r1	; 0x17

	 //TermID
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1;
     FillChar(strEEPROM,0,sizeof(strEEPROM));   
	 StrPosCopy(rcv_trans,strEEPROM,StrPos,2);
	 RemZeroLead(strEEPROM);
   1526c:	8e 01       	movw	r16, r28
   1526e:	0b 5e       	subi	r16, 0xEB	; 235
   15270:	1f 4f       	sbci	r17, 0xFF	; 255
   15272:	c8 01       	movw	r24, r16
   15274:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
	 xEEPROM=atoi(strEEPROM);
   15278:	c8 01       	movw	r24, r16
   1527a:	0e 94 bf b3 	call	0x1677e	; 0x1677e <atoi>
   1527e:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15280:	e1 99       	sbic	0x1c, 1	; 28
   15282:	fe cf       	rjmp	.-4      	; 0x15280 <SaveConfigParameter+0x2ce>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15284:	80 e0       	ldi	r24, 0x00	; 0
   15286:	90 e0       	ldi	r25, 0x00	; 0
   15288:	9f bb       	out	0x1f, r25	; 31
   1528a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   1528c:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   1528e:	0f b6       	in	r0, 0x3f	; 63
   15290:	f8 94       	cli
   15292:	e2 9a       	sbi	0x1c, 2	; 28
   15294:	e1 9a       	sbi	0x1c, 1	; 28
   15296:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefIFT_ID,xEEPROM);
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   15298:	00 d0       	rcall	.+0      	; 0x1529a <SaveConfigParameter+0x2e8>
   1529a:	00 d0       	rcall	.+0      	; 0x1529c <SaveConfigParameter+0x2ea>
   1529c:	00 d0       	rcall	.+0      	; 0x1529e <SaveConfigParameter+0x2ec>
   1529e:	ed b7       	in	r30, 0x3d	; 61
   152a0:	fe b7       	in	r31, 0x3e	; 62
   152a2:	31 96       	adiw	r30, 0x01	; 1
   152a4:	8e 01       	movw	r16, r28
   152a6:	0f 5f       	subi	r16, 0xFF	; 255
   152a8:	1f 4f       	sbci	r17, 0xFF	; 255
   152aa:	ad b7       	in	r26, 0x3d	; 61
   152ac:	be b7       	in	r27, 0x3e	; 62
   152ae:	12 96       	adiw	r26, 0x02	; 2
   152b0:	1c 93       	st	X, r17
   152b2:	0e 93       	st	-X, r16
   152b4:	11 97       	sbiw	r26, 0x01	; 1
   152b6:	8f e3       	ldi	r24, 0x3F	; 63
   152b8:	92 e2       	ldi	r25, 0x22	; 34
   152ba:	93 83       	std	Z+3, r25	; 0x03
   152bc:	82 83       	std	Z+2, r24	; 0x02
   152be:	24 83       	std	Z+4, r18	; 0x04
   152c0:	15 82       	std	Z+5, r1	; 0x05
   152c2:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   152c6:	ae e7       	ldi	r26, 0x7E	; 126
   152c8:	ea 2e       	mov	r14, r26
   152ca:	ad e0       	ldi	r26, 0x0D	; 13
   152cc:	fa 2e       	mov	r15, r26
   152ce:	fd e4       	ldi	r31, 0x4D	; 77
   152d0:	cf 2e       	mov	r12, r31
   152d2:	f0 e0       	ldi	r31, 0x00	; 0
   152d4:	df 2e       	mov	r13, r31
   152d6:	ed b7       	in	r30, 0x3d	; 61
   152d8:	fe b7       	in	r31, 0x3e	; 62
   152da:	36 96       	adiw	r30, 0x06	; 6
   152dc:	0f b6       	in	r0, 0x3f	; 63
   152de:	f8 94       	cli
   152e0:	fe bf       	out	0x3e, r31	; 62
   152e2:	0f be       	out	0x3f, r0	; 63
   152e4:	ed bf       	out	0x3d, r30	; 61
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   152e6:	e5 e1       	ldi	r30, 0x15	; 21
   152e8:	ae 2e       	mov	r10, r30
   152ea:	b1 2c       	mov	r11, r1
   152ec:	ac 0e       	add	r10, r28
   152ee:	bd 1e       	adc	r11, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   152f0:	48 01       	movw	r8, r16
   152f2:	0c e3       	ldi	r16, 0x3C	; 60
   152f4:	12 e2       	ldi	r17, 0x22	; 34
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   152f6:	d7 01       	movw	r26, r14
   152f8:	8c 91       	ld	r24, X
   152fa:	8d 8b       	std	Y+21, r24	; 0x15
   152fc:	11 96       	adiw	r26, 0x01	; 1
   152fe:	8c 91       	ld	r24, X
   15300:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   15302:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   15304:	c5 01       	movw	r24, r10
   15306:	0e 94 be 23 	call	0x477c	; 0x477c <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   1530a:	c5 01       	movw	r24, r10
   1530c:	0e 94 bf b3 	call	0x1677e	; 0x1677e <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15310:	e1 99       	sbic	0x1c, 1	; 28
   15312:	fe cf       	rjmp	.-4      	; 0x15310 <SaveConfigParameter+0x35e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15314:	df ba       	out	0x1f, r13	; 31
   15316:	ce ba       	out	0x1e, r12	; 30
#endif
    EEDR = __value;
   15318:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   1531a:	0f b6       	in	r0, 0x3f	; 63
   1531c:	f8 94       	cli
   1531e:	e2 9a       	sbi	0x1c, 2	; 28
   15320:	e1 9a       	sbi	0x1c, 1	; 28
   15322:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   15324:	00 d0       	rcall	.+0      	; 0x15326 <SaveConfigParameter+0x374>
   15326:	00 d0       	rcall	.+0      	; 0x15328 <SaveConfigParameter+0x376>
   15328:	00 d0       	rcall	.+0      	; 0x1532a <SaveConfigParameter+0x378>
   1532a:	ed b7       	in	r30, 0x3d	; 61
   1532c:	fe b7       	in	r31, 0x3e	; 62
   1532e:	31 96       	adiw	r30, 0x01	; 1
   15330:	ad b7       	in	r26, 0x3d	; 61
   15332:	be b7       	in	r27, 0x3e	; 62
   15334:	11 96       	adiw	r26, 0x01	; 1
   15336:	8c 92       	st	X, r8
   15338:	11 97       	sbiw	r26, 0x01	; 1
   1533a:	12 96       	adiw	r26, 0x02	; 2
   1533c:	9c 92       	st	X, r9
   1533e:	13 83       	std	Z+3, r17	; 0x03
   15340:	02 83       	std	Z+2, r16	; 0x02
   15342:	84 83       	std	Z+4, r24	; 0x04
   15344:	15 82       	std	Z+5, r1	; 0x05
   15346:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
   1534a:	e2 e0       	ldi	r30, 0x02	; 2
   1534c:	f0 e0       	ldi	r31, 0x00	; 0
   1534e:	ee 0e       	add	r14, r30
   15350:	ff 1e       	adc	r15, r31
   15352:	08 94       	sec
   15354:	c1 1c       	adc	r12, r1
   15356:	d1 1c       	adc	r13, r1
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//	 _uart_print(1,1,strSend); 

	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
   15358:	8d b7       	in	r24, 0x3d	; 61
   1535a:	9e b7       	in	r25, 0x3e	; 62
   1535c:	06 96       	adiw	r24, 0x06	; 6
   1535e:	0f b6       	in	r0, 0x3f	; 63
   15360:	f8 94       	cli
   15362:	9e bf       	out	0x3e, r25	; 62
   15364:	0f be       	out	0x3f, r0	; 63
   15366:	8d bf       	out	0x3d, r24	; 61
   15368:	9e e8       	ldi	r25, 0x8E	; 142
   1536a:	e9 16       	cp	r14, r25
   1536c:	9d e0       	ldi	r25, 0x0D	; 13
   1536e:	f9 06       	cpc	r15, r25
   15370:	09 f0       	breq	.+2      	; 0x15374 <SaveConfigParameter+0x3c2>
   15372:	c1 cf       	rjmp	.-126    	; 0x152f6 <SaveConfigParameter+0x344>
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//		 _uart_print(1,1,strSend); 
	 }    
	 _uart_printf(1,1,PSTR("<OK>")); 
   15374:	81 e0       	ldi	r24, 0x01	; 1
   15376:	61 e0       	ldi	r22, 0x01	; 1
   15378:	47 e3       	ldi	r20, 0x37	; 55
   1537a:	52 e2       	ldi	r21, 0x22	; 34
   1537c:	0e 94 94 b2 	call	0x16528	; 0x16528 <_uart_printf>
}
   15380:	ca 5b       	subi	r28, 0xBA	; 186
   15382:	df 4f       	sbci	r29, 0xFF	; 255
   15384:	0f b6       	in	r0, 0x3f	; 63
   15386:	f8 94       	cli
   15388:	de bf       	out	0x3e, r29	; 62
   1538a:	0f be       	out	0x3f, r0	; 63
   1538c:	cd bf       	out	0x3d, r28	; 61
   1538e:	cf 91       	pop	r28
   15390:	df 91       	pop	r29
   15392:	1f 91       	pop	r17
   15394:	0f 91       	pop	r16
   15396:	ff 90       	pop	r15
   15398:	ef 90       	pop	r14
   1539a:	df 90       	pop	r13
   1539c:	cf 90       	pop	r12
   1539e:	bf 90       	pop	r11
   153a0:	af 90       	pop	r10
   153a2:	9f 90       	pop	r9
   153a4:	8f 90       	pop	r8
   153a6:	08 95       	ret

000153a8 <systemConfigProtocol>:



void systemConfigProtocol(){
     static char stConfigProtocol=cpWaitSend;
	 switch(stConfigProtocol){
   153a8:	80 91 ad 03 	lds	r24, 0x03AD
   153ac:	81 30       	cpi	r24, 0x01	; 1
   153ae:	c1 f0       	breq	.+48     	; 0x153e0 <systemConfigProtocol+0x38>
   153b0:	81 30       	cpi	r24, 0x01	; 1
   153b2:	18 f0       	brcs	.+6      	; 0x153ba <systemConfigProtocol+0x12>
   153b4:	82 30       	cpi	r24, 0x02	; 2
   153b6:	e9 f4       	brne	.+58     	; 0x153f2 <systemConfigProtocol+0x4a>
   153b8:	18 c0       	rjmp	.+48     	; 0x153ea <systemConfigProtocol+0x42>
	 case cpWaitSend:
	      switch(ConfigCommand){
   153ba:	80 91 c6 01 	lds	r24, 0x01C6
   153be:	81 30       	cpi	r24, 0x01	; 1
   153c0:	31 f0       	breq	.+12     	; 0x153ce <systemConfigProtocol+0x26>
   153c2:	82 30       	cpi	r24, 0x02	; 2
   153c4:	51 f4       	brne	.+20     	; 0x153da <systemConfigProtocol+0x32>
		  case CC_SEND_CONFIG:
		       ConfigCommand=CC_NONE;
   153c6:	10 92 c6 01 	sts	0x01C6, r1
			   stConfigProtocol=cpSendingParameter;
   153ca:	81 e0       	ldi	r24, 0x01	; 1
   153cc:	03 c0       	rjmp	.+6      	; 0x153d4 <systemConfigProtocol+0x2c>
		       break;
		  case CC_SAVE_CONFIG:
		       ConfigCommand=CC_NONE;
   153ce:	10 92 c6 01 	sts	0x01C6, r1
			   stConfigProtocol=cpSavingParameter;
   153d2:	82 e0       	ldi	r24, 0x02	; 2
   153d4:	80 93 ad 03 	sts	0x03AD, r24
   153d8:	08 95       	ret
		       break;
          default:
		       ConfigCommand=CC_NONE;
   153da:	10 92 c6 01 	sts	0x01C6, r1
   153de:	08 95       	ret
		       break;
		  }
	      break;
     case cpSendingParameter:
	      SendConfigParamater();
   153e0:	0e 94 bf a5 	call	0x14b7e	; 0x14b7e <SendConfigParamater>
          stConfigProtocol=cpWaitSend;
   153e4:	10 92 ad 03 	sts	0x03AD, r1
   153e8:	08 95       	ret
	      break;
     case cpSavingParameter:
          SaveConfigParameter();
   153ea:	0e 94 d9 a7 	call	0x14fb2	; 0x14fb2 <SaveConfigParameter>
          stConfigProtocol=cpWaitSend;
   153ee:	10 92 ad 03 	sts	0x03AD, r1
   153f2:	08 95       	ret

000153f4 <FMenuIdle>:
	     ProcTimeOut++;
	}
	TimSend++;
}

void FMenuIdle(){
   153f4:	1f 93       	push	r17
	static char stMenuIdle=miInit,KeyPressed=0,KeyChar=0,ButtonID=0,PrintStandaloneResult=PS_NONE;
    //static unsigned int iLoopIdle=0;
	char lcdteks[20];
   

	switch(stMenuIdle){
   153f6:	80 91 bc 03 	lds	r24, 0x03BC
   153fa:	e8 2f       	mov	r30, r24
   153fc:	f0 e0       	ldi	r31, 0x00	; 0
   153fe:	e9 31       	cpi	r30, 0x19	; 25
   15400:	f1 05       	cpc	r31, r1
   15402:	08 f0       	brcs	.+2      	; 0x15406 <FMenuIdle+0x12>
   15404:	a6 c1       	rjmp	.+844    	; 0x15752 <FMenuIdle+0x35e>
   15406:	ec 5e       	subi	r30, 0xEC	; 236
   15408:	fe 4f       	sbci	r31, 0xFE	; 254
   1540a:	ee 0f       	add	r30, r30
   1540c:	ff 1f       	adc	r31, r31
   1540e:	05 90       	lpm	r0, Z+
   15410:	f4 91       	lpm	r31, Z+
   15412:	e0 2d       	mov	r30, r0
   15414:	09 94       	ijmp
	case miInit:
         _scr_idle();
   15416:	0e 94 ef 41 	call	0x83de	; 0x83de <_scr_idle>
   1541a:	62 c1       	rjmp	.+708    	; 0x156e0 <FMenuIdle+0x2ec>
		 stMenuIdle=miScan;		
	     break;
	case miScan:
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
   1541c:	81 e0       	ldi	r24, 0x01	; 1
   1541e:	0e 94 80 ae 	call	0x15d00	; 0x15d00 <_key_scan>
   15422:	80 93 bb 03 	sts	0x03BB, r24
		 KeyChar= _key_btn(KeyPressed);       
   15426:	0e 94 e1 ad 	call	0x15bc2	; 0x15bc2 <_key_btn>
   1542a:	80 93 ba 03 	sts	0x03BA, r24

		 switch(KeyPressed){
   1542e:	80 91 bb 03 	lds	r24, 0x03BB
   15432:	8b 3b       	cpi	r24, 0xBB	; 187
   15434:	09 f4       	brne	.+2      	; 0x15438 <FMenuIdle+0x44>
   15436:	94 c0       	rjmp	.+296    	; 0x15560 <FMenuIdle+0x16c>
   15438:	8c 3b       	cpi	r24, 0xBC	; 188
   1543a:	70 f4       	brcc	.+28     	; 0x15458 <FMenuIdle+0x64>
   1543c:	8b 37       	cpi	r24, 0x7B	; 123
   1543e:	a1 f1       	breq	.+104    	; 0x154a8 <FMenuIdle+0xb4>
   15440:	8c 37       	cpi	r24, 0x7C	; 124
   15442:	20 f4       	brcc	.+8      	; 0x1544c <FMenuIdle+0x58>
   15444:	87 37       	cpi	r24, 0x77	; 119
   15446:	09 f0       	breq	.+2      	; 0x1544a <FMenuIdle+0x56>
   15448:	84 c1       	rjmp	.+776    	; 0x15752 <FMenuIdle+0x35e>
   1544a:	38 c0       	rjmp	.+112    	; 0x154bc <FMenuIdle+0xc8>
   1544c:	8d 37       	cpi	r24, 0x7D	; 125
   1544e:	01 f1       	breq	.+64     	; 0x15490 <FMenuIdle+0x9c>
   15450:	8e 37       	cpi	r24, 0x7E	; 126
   15452:	09 f0       	breq	.+2      	; 0x15456 <FMenuIdle+0x62>
   15454:	7e c1       	rjmp	.+764    	; 0x15752 <FMenuIdle+0x35e>
   15456:	12 c0       	rjmp	.+36     	; 0x1547c <FMenuIdle+0x88>
   15458:	8d 3d       	cpi	r24, 0xDD	; 221
   1545a:	09 f4       	brne	.+2      	; 0x1545e <FMenuIdle+0x6a>
   1545c:	63 c0       	rjmp	.+198    	; 0x15524 <FMenuIdle+0x130>
   1545e:	8e 3d       	cpi	r24, 0xDE	; 222
   15460:	38 f4       	brcc	.+14     	; 0x15470 <FMenuIdle+0x7c>
   15462:	8d 3b       	cpi	r24, 0xBD	; 189
   15464:	09 f4       	brne	.+2      	; 0x15468 <FMenuIdle+0x74>
   15466:	6d c0       	rjmp	.+218    	; 0x15542 <FMenuIdle+0x14e>
   15468:	87 3d       	cpi	r24, 0xD7	; 215
   1546a:	09 f0       	breq	.+2      	; 0x1546e <FMenuIdle+0x7a>
   1546c:	72 c1       	rjmp	.+740    	; 0x15752 <FMenuIdle+0x35e>
   1546e:	32 c0       	rjmp	.+100    	; 0x154d4 <FMenuIdle+0xe0>
   15470:	8e 3d       	cpi	r24, 0xDE	; 222
   15472:	d1 f1       	breq	.+116    	; 0x154e8 <FMenuIdle+0xf4>
   15474:	8d 3e       	cpi	r24, 0xED	; 237
   15476:	09 f0       	breq	.+2      	; 0x1547a <FMenuIdle+0x86>
   15478:	6c c1       	rjmp	.+728    	; 0x15752 <FMenuIdle+0x35e>
   1547a:	45 c0       	rjmp	.+138    	; 0x15506 <FMenuIdle+0x112>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1547c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1547e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15480:	82 e0       	ldi	r24, 0x02	; 2
   15482:	90 e0       	ldi	r25, 0x00	; 0
   15484:	90 93 d7 01 	sts	0x01D7, r25
   15488:	80 93 d6 01 	sts	0x01D6, r24
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
   1548c:	81 e0       	ldi	r24, 0x01	; 1
   1548e:	1f c0       	rjmp	.+62     	; 0x154ce <FMenuIdle+0xda>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15490:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15492:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15494:	82 e0       	ldi	r24, 0x02	; 2
   15496:	90 e0       	ldi	r25, 0x00	; 0
   15498:	90 93 d7 01 	sts	0x01D7, r25
   1549c:	80 93 d6 01 	sts	0x01D6, r24
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
   154a0:	82 e0       	ldi	r24, 0x02	; 2
   154a2:	80 93 b9 03 	sts	0x03B9, r24
   154a6:	53 c1       	rjmp	.+678    	; 0x1574e <FMenuIdle+0x35a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   154a8:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   154aa:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   154ac:	82 e0       	ldi	r24, 0x02	; 2
   154ae:	90 e0       	ldi	r25, 0x00	; 0
   154b0:	90 93 d7 01 	sts	0x01D7, r25
   154b4:	80 93 d6 01 	sts	0x01D6, r24
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
   154b8:	83 e0       	ldi	r24, 0x03	; 3
   154ba:	09 c0       	rjmp	.+18     	; 0x154ce <FMenuIdle+0xda>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   154bc:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   154be:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   154c0:	82 e0       	ldi	r24, 0x02	; 2
   154c2:	90 e0       	ldi	r25, 0x00	; 0
   154c4:	90 93 d7 01 	sts	0x01D7, r25
   154c8:	80 93 d6 01 	sts	0x01D6, r24

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
   154cc:	84 e0       	ldi	r24, 0x04	; 4
   154ce:	80 93 b9 03 	sts	0x03B9, r24
   154d2:	64 c0       	rjmp	.+200    	; 0x1559c <FMenuIdle+0x1a8>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   154d4:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   154d6:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   154d8:	82 e0       	ldi	r24, 0x02	; 2
   154da:	90 e0       	ldi	r25, 0x00	; 0
   154dc:	90 93 d7 01 	sts	0x01D7, r25
   154e0:	80 93 d6 01 	sts	0x01D6, r24
		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
   154e4:	8c e0       	ldi	r24, 0x0C	; 12
   154e6:	33 c1       	rjmp	.+614    	; 0x1574e <FMenuIdle+0x35a>
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   154e8:	80 91 10 01 	lds	r24, 0x0110
   154ec:	81 30       	cpi	r24, 0x01	; 1
   154ee:	09 f0       	breq	.+2      	; 0x154f2 <FMenuIdle+0xfe>
   154f0:	30 c1       	rjmp	.+608    	; 0x15752 <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   154f2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   154f4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   154f6:	82 e0       	ldi	r24, 0x02	; 2
   154f8:	90 e0       	ldi	r25, 0x00	; 0
   154fa:	90 93 d7 01 	sts	0x01D7, r25
   154fe:	80 93 d6 01 	sts	0x01D6, r24
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   15502:	80 e1       	ldi	r24, 0x10	; 16
   15504:	24 c1       	rjmp	.+584    	; 0x1574e <FMenuIdle+0x35a>
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   15506:	80 91 10 01 	lds	r24, 0x0110
   1550a:	81 30       	cpi	r24, 0x01	; 1
   1550c:	09 f0       	breq	.+2      	; 0x15510 <FMenuIdle+0x11c>
   1550e:	21 c1       	rjmp	.+578    	; 0x15752 <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15510:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15512:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15514:	82 e0       	ldi	r24, 0x02	; 2
   15516:	90 e0       	ldi	r25, 0x00	; 0
   15518:	90 93 d7 01 	sts	0x01D7, r25
   1551c:	80 93 d6 01 	sts	0x01D6, r24
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   15520:	82 e1       	ldi	r24, 0x12	; 18
   15522:	15 c1       	rjmp	.+554    	; 0x1574e <FMenuIdle+0x35a>
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   15524:	80 91 10 01 	lds	r24, 0x0110
   15528:	81 30       	cpi	r24, 0x01	; 1
   1552a:	09 f0       	breq	.+2      	; 0x1552e <FMenuIdle+0x13a>
   1552c:	12 c1       	rjmp	.+548    	; 0x15752 <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1552e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15530:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15532:	82 e0       	ldi	r24, 0x02	; 2
   15534:	90 e0       	ldi	r25, 0x00	; 0
   15536:	90 93 d7 01 	sts	0x01D7, r25
   1553a:	80 93 d6 01 	sts	0x01D6, r24
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   1553e:	81 e1       	ldi	r24, 0x11	; 17
   15540:	06 c1       	rjmp	.+524    	; 0x1574e <FMenuIdle+0x35a>
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   15542:	80 91 10 01 	lds	r24, 0x0110
   15546:	81 30       	cpi	r24, 0x01	; 1
   15548:	09 f0       	breq	.+2      	; 0x1554c <FMenuIdle+0x158>
   1554a:	03 c1       	rjmp	.+518    	; 0x15752 <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1554c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1554e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15550:	82 e0       	ldi	r24, 0x02	; 2
   15552:	90 e0       	ldi	r25, 0x00	; 0
   15554:	90 93 d7 01 	sts	0x01D7, r25
   15558:	80 93 d6 01 	sts	0x01D6, r24
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   1555c:	8f e0       	ldi	r24, 0x0F	; 15
   1555e:	f7 c0       	rjmp	.+494    	; 0x1574e <FMenuIdle+0x35a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15560:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15562:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15564:	82 e0       	ldi	r24, 0x02	; 2
   15566:	90 e0       	ldi	r25, 0x00	; 0
   15568:	90 93 d7 01 	sts	0x01D7, r25
   1556c:	80 93 d6 01 	sts	0x01D6, r24
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
		 //case _KEY_8:    system_beep(2);           stMenuIdle=miRunTestChar;   break;
		 case _KEY_9:    system_beep(2);stMenuIdle=miRunAuth;      break;
   15570:	8d e0       	ldi	r24, 0x0D	; 13
   15572:	ed c0       	rjmp	.+474    	; 0x1574e <FMenuIdle+0x35a>
		 }
	     break;
    case miTestMsg56:
	     sprintf_P(strCardID,PSTR("4356A31A"));
   15574:	00 d0       	rcall	.+0      	; 0x15576 <FMenuIdle+0x182>
   15576:	00 d0       	rcall	.+0      	; 0x15578 <FMenuIdle+0x184>
   15578:	81 eb       	ldi	r24, 0xB1	; 177
   1557a:	9d e0       	ldi	r25, 0x0D	; 13
   1557c:	ed b7       	in	r30, 0x3d	; 61
   1557e:	fe b7       	in	r31, 0x3e	; 62
   15580:	92 83       	std	Z+2, r25	; 0x02
   15582:	81 83       	std	Z+1, r24	; 0x01
   15584:	80 e6       	ldi	r24, 0x60	; 96
   15586:	93 e2       	ldi	r25, 0x23	; 35
   15588:	94 83       	std	Z+4, r25	; 0x04
   1558a:	83 83       	std	Z+3, r24	; 0x03
   1558c:	0e 94 34 b4 	call	0x16868	; 0x16868 <sprintf_P>
	     sendMessage56();
   15590:	0f 90       	pop	r0
   15592:	0f 90       	pop	r0
   15594:	0f 90       	pop	r0
   15596:	0f 90       	pop	r0
   15598:	0e 94 d7 9a 	call	0x135ae	; 0x135ae <sendMessage56>
         stMenuIdle=miDisplayProses;
   1559c:	82 e0       	ldi	r24, 0x02	; 2
   1559e:	d7 c0       	rjmp	.+430    	; 0x1574e <FMenuIdle+0x35a>
	     break;
	case miDisplayProses:
	     if (IsBusyIdlePrinting==False){
   155a0:	80 91 c8 01 	lds	r24, 0x01C8
   155a4:	88 23       	and	r24, r24
   155a6:	09 f0       	breq	.+2      	; 0x155aa <FMenuIdle+0x1b6>
   155a8:	9b c0       	rjmp	.+310    	; 0x156e0 <FMenuIdle+0x2ec>
		     lcd_printf(3,1,PSTR("SedangProses"));
   155aa:	83 e0       	ldi	r24, 0x03	; 3
   155ac:	61 e0       	ldi	r22, 0x01	; 1
   155ae:	43 e5       	ldi	r20, 0x53	; 83
   155b0:	53 e2       	ldi	r21, 0x23	; 35
   155b2:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	         TimDisplay=0;
   155b6:	10 92 a7 01 	sts	0x01A7, r1
			 stMenuIdle=miWaitProses;
   155ba:	83 e0       	ldi	r24, 0x03	; 3
   155bc:	c8 c0       	rjmp	.+400    	; 0x1574e <FMenuIdle+0x35a>
         }else stMenuIdle=miScan;
	     break;
    case miWaitProses:
	     if (TimDisplay>1){
   155be:	80 91 a7 01 	lds	r24, 0x01A7
   155c2:	82 30       	cpi	r24, 0x02	; 2
   155c4:	08 f4       	brcc	.+2      	; 0x155c8 <FMenuIdle+0x1d4>
   155c6:	c5 c0       	rjmp	.+394    	; 0x15752 <FMenuIdle+0x35e>
		     if (IFType==IT_SLAVE)stMenuIdle=miSendMessage98;
   155c8:	80 91 10 01 	lds	r24, 0x0110
   155cc:	81 30       	cpi	r24, 0x01	; 1
   155ce:	11 f4       	brne	.+4      	; 0x155d4 <FMenuIdle+0x1e0>
   155d0:	84 e0       	ldi	r24, 0x04	; 4
   155d2:	bd c0       	rjmp	.+378    	; 0x1574e <FMenuIdle+0x35a>
			 else
		     if (IFType==IT_STANDALONE)stMenuIdle=miPrintStandalone;
   155d4:	82 30       	cpi	r24, 0x02	; 2
   155d6:	09 f0       	breq	.+2      	; 0x155da <FMenuIdle+0x1e6>
   155d8:	bc c0       	rjmp	.+376    	; 0x15752 <FMenuIdle+0x35e>
   155da:	87 e0       	ldi	r24, 0x07	; 7
   155dc:	b8 c0       	rjmp	.+368    	; 0x1574e <FMenuIdle+0x35a>
		 }
	     break;
    case miPrintStandalone:
	     PrintStandaloneResult=PrintStandalone(ButtonID,False);
   155de:	80 91 b9 03 	lds	r24, 0x03B9
   155e2:	60 e0       	ldi	r22, 0x00	; 0
   155e4:	0e 94 9c 1f 	call	0x3f38	; 0x3f38 <PrintStandalone>
   155e8:	80 93 5d 01 	sts	0x015D, r24
	     if (PrintStandaloneResult==PS_PRINTED)stMenuIdle=miReady;
   155ec:	81 31       	cpi	r24, 0x11	; 17
   155ee:	09 f4       	brne	.+2      	; 0x155f2 <FMenuIdle+0x1fe>
   155f0:	ad c0       	rjmp	.+346    	; 0x1574c <FMenuIdle+0x358>
		 else
		 if (PrintStandaloneResult==PS_NO_DATA)stMenuIdle=miDisplayNoTransaction;
   155f2:	82 31       	cpi	r24, 0x12	; 18
   155f4:	09 f0       	breq	.+2      	; 0x155f8 <FMenuIdle+0x204>
   155f6:	ad c0       	rjmp	.+346    	; 0x15752 <FMenuIdle+0x35e>
   155f8:	88 e0       	ldi	r24, 0x08	; 8
   155fa:	a9 c0       	rjmp	.+338    	; 0x1574e <FMenuIdle+0x35a>
	     break;
    case miDisplayNoTransaction:
	     lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   155fc:	83 e0       	ldi	r24, 0x03	; 3
   155fe:	61 e0       	ldi	r22, 0x01	; 1
   15600:	4e e3       	ldi	r20, 0x3E	; 62
   15602:	53 e2       	ldi	r21, 0x23	; 35
   15604:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
         TimDisplay=0;
   15608:	10 92 a7 01 	sts	0x01A7, r1
		 stMenuIdle=miWaitDisplayNoTransaction;
   1560c:	89 e0       	ldi	r24, 0x09	; 9
   1560e:	9f c0       	rjmp	.+318    	; 0x1574e <FMenuIdle+0x35a>
	     break;
    case miWaitDisplayNoTransaction:
	     if (TimDisplay>1){
   15610:	80 91 a7 01 	lds	r24, 0x01A7
   15614:	82 30       	cpi	r24, 0x02	; 2
   15616:	08 f4       	brcc	.+2      	; 0x1561a <FMenuIdle+0x226>
   15618:	9c c0       	rjmp	.+312    	; 0x15752 <FMenuIdle+0x35e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   1561a:	83 e0       	ldi	r24, 0x03	; 3
   1561c:	61 e0       	ldi	r22, 0x01	; 1
   1561e:	49 e2       	ldi	r20, 0x29	; 41
   15620:	53 e2       	ldi	r21, 0x23	; 35
   15622:	36 c0       	rjmp	.+108    	; 0x15690 <FMenuIdle+0x29c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
		 }
	     break;
    case miSendMessage98:
	     lcd_printf(3,1,PSTR("Please Wait..       "));
   15624:	83 e0       	ldi	r24, 0x03	; 3
   15626:	61 e0       	ldi	r22, 0x01	; 1
   15628:	44 e1       	ldi	r20, 0x14	; 20
   1562a:	53 e2       	ldi	r21, 0x23	; 35
   1562c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	     sendMessage98(ButtonID);
   15630:	80 91 b9 03 	lds	r24, 0x03B9
   15634:	0e 94 65 4c 	call	0x98ca	; 0x98ca <sendMessage98>
		 ProcTimeOut=0;
   15638:	10 92 d9 01 	sts	0x01D9, r1
   1563c:	10 92 d8 01 	sts	0x01D8, r1
		 stMenuIdle=miWaitPlease;
   15640:	85 e0       	ldi	r24, 0x05	; 5
   15642:	85 c0       	rjmp	.+266    	; 0x1574e <FMenuIdle+0x35a>
	     break;
    case miWaitPlease:
         if (ProcTimeOut>TIM_NO_RESPONSE){
   15644:	80 91 d8 01 	lds	r24, 0x01D8
   15648:	90 91 d9 01 	lds	r25, 0x01D9
   1564c:	0f 97       	sbiw	r24, 0x0f	; 15
   1564e:	58 f0       	brcs	.+22     	; 0x15666 <FMenuIdle+0x272>
	         lcd_printf(3,1,PSTR("No Response..       "));
   15650:	83 e0       	ldi	r24, 0x03	; 3
   15652:	61 e0       	ldi	r22, 0x01	; 1
   15654:	4f ef       	ldi	r20, 0xFF	; 255
   15656:	52 e2       	ldi	r21, 0x22	; 34
   15658:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		     stMenuIdle=miNoResponse;
   1565c:	86 e0       	ldi	r24, 0x06	; 6
   1565e:	80 93 bc 03 	sts	0x03BC, r24
			 TimDisplay=0;		 
   15662:	10 92 a7 01 	sts	0x01A7, r1
		 }
		 if ((IsMessage99==True)||(IsMessage00==True)){
   15666:	80 91 b6 01 	lds	r24, 0x01B6
   1566a:	81 30       	cpi	r24, 0x01	; 1
   1566c:	29 f0       	breq	.+10     	; 0x15678 <FMenuIdle+0x284>
   1566e:	80 91 b5 01 	lds	r24, 0x01B5
   15672:	81 30       	cpi	r24, 0x01	; 1
   15674:	09 f0       	breq	.+2      	; 0x15678 <FMenuIdle+0x284>
   15676:	6d c0       	rjmp	.+218    	; 0x15752 <FMenuIdle+0x35e>
		     ClearMem(strOdometer);
   15678:	83 ef       	ldi	r24, 0xF3	; 243
   1567a:	95 e0       	ldi	r25, 0x05	; 5
   1567c:	0e 94 7b ad 	call	0x15af6	; 0x15af6 <ClearMem>
		     ClearMem(strLicPlate);
   15680:	82 e2       	ldi	r24, 0x22	; 34
   15682:	9b e0       	ldi	r25, 0x0B	; 11
   15684:	0e 94 7b ad 	call	0x15af6	; 0x15af6 <ClearMem>
	         lcd_printf(3,1,PSTR("Ready...            "));
   15688:	83 e0       	ldi	r24, 0x03	; 3
   1568a:	61 e0       	ldi	r22, 0x01	; 1
   1568c:	4a ee       	ldi	r20, 0xEA	; 234
   1568e:	52 e2       	ldi	r21, 0x22	; 34
   15690:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		     stMenuIdle=miWaitReady;
   15694:	8a e0       	ldi	r24, 0x0A	; 10
   15696:	80 93 bc 03 	sts	0x03BC, r24
			 TimDisplay=0;
   1569a:	10 92 a7 01 	sts	0x01A7, r1
   1569e:	59 c0       	rjmp	.+178    	; 0x15752 <FMenuIdle+0x35e>
			 }
	     break;
    case miNoResponse:
         if (TimDisplay>1){
   156a0:	80 91 a7 01 	lds	r24, 0x01A7
   156a4:	82 30       	cpi	r24, 0x02	; 2
   156a6:	08 f4       	brcc	.+2      	; 0x156aa <FMenuIdle+0x2b6>
   156a8:	54 c0       	rjmp	.+168    	; 0x15752 <FMenuIdle+0x35e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   156aa:	83 e0       	ldi	r24, 0x03	; 3
   156ac:	61 e0       	ldi	r22, 0x01	; 1
   156ae:	45 ed       	ldi	r20, 0xD5	; 213
   156b0:	52 e2       	ldi	r21, 0x22	; 34
   156b2:	ee cf       	rjmp	.-36     	; 0x15690 <FMenuIdle+0x29c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
			 }	     
	     break;
    case miWaitReady:
         if (TimDisplay>1){
   156b4:	80 91 a7 01 	lds	r24, 0x01A7
   156b8:	82 30       	cpi	r24, 0x02	; 2
   156ba:	08 f4       	brcc	.+2      	; 0x156be <FMenuIdle+0x2ca>
   156bc:	4a c0       	rjmp	.+148    	; 0x15752 <FMenuIdle+0x35e>
	         lcd_printf(3,1,PSTR("                "));
   156be:	83 e0       	ldi	r24, 0x03	; 3
   156c0:	61 e0       	ldi	r22, 0x01	; 1
   156c2:	44 ec       	ldi	r20, 0xC4	; 196
   156c4:	52 e2       	ldi	r21, 0x22	; 34
   156c6:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		     stMenuIdle=miReady;
   156ca:	8b e0       	ldi	r24, 0x0B	; 11
   156cc:	e4 cf       	rjmp	.-56     	; 0x15696 <FMenuIdle+0x2a2>
			 TimDisplay=0;
			 }	     
	     break;
    case miReady:
	     _scr_idle();
   156ce:	0e 94 ef 41 	call	0x83de	; 0x83de <_scr_idle>
		 if (IFType==IT_STANDALONE)IsNewPumpStatus=True;
   156d2:	80 91 10 01 	lds	r24, 0x0110
   156d6:	82 30       	cpi	r24, 0x02	; 2
   156d8:	19 f4       	brne	.+6      	; 0x156e0 <FMenuIdle+0x2ec>
   156da:	81 e0       	ldi	r24, 0x01	; 1
   156dc:	80 93 11 01 	sts	0x0111, r24
		 stMenuIdle=miScan;
   156e0:	81 e0       	ldi	r24, 0x01	; 1
   156e2:	35 c0       	rjmp	.+106    	; 0x1574e <FMenuIdle+0x35a>
	     break;
	case miRunTicket://Slave,Standalone
		 if (FMenuTicket()==MENU_DONE)
   156e4:	0e 94 31 84 	call	0x10862	; 0x10862 <FMenuTicket>
   156e8:	2f c0       	rjmp	.+94     	; 0x15748 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
	case miRunAuth://Slave,Standalone
		 if (FMenuAuthorization()==MENU_DONE)
   156ea:	0e 94 e8 99 	call	0x133d0	; 0x133d0 <FMenuAuthorization>
   156ee:	2c c0       	rjmp	.+88     	; 0x15748 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
		 
    case miRunLocalAccount://Slave
		 if (FMenuLocalAccount()==MENU_DONE)
   156f0:	0e 94 81 9b 	call	0x13702	; 0x13702 <FMenuLocalAccount>
   156f4:	29 c0       	rjmp	.+82     	; 0x15748 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;  
    case miRunChangeMOP://Slave
	     if (FMenuChangeMOP()==MENU_DONE)
   156f6:	0e 94 ec 92 	call	0x125d8	; 0x125d8 <FMenuChangeMOP>
   156fa:	26 c0       	rjmp	.+76     	; 0x15748 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miRunEDC://Slave
	     if (FMenuEDCTransaction()==MENU_DONE)
   156fc:	0e 94 08 65 	call	0xca10	; 0xca10 <FMenuEDCTransaction>
   15700:	23 c0       	rjmp	.+70     	; 0x15748 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
         break;
    case miRunLoyalty://Slave
	     if (FMenuLoyalty()==MENU_DONE)
   15702:	0e 94 fc 65 	call	0xcbf8	; 0xcbf8 <FMenuLoyalty>
   15706:	20 c0       	rjmp	.+64     	; 0x15748 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miRunReprint://Slave,Standalone
	     if (FMenuReprint()==MENU_DONE)
   15708:	0e 94 41 91 	call	0x12282	; 0x12282 <FMenuReprint>
   1570c:	1d c0       	rjmp	.+58     	; 0x15748 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miRunViewFreeMessage://Slave
	     if (FViewFreeMessage()==MENU_DONE)
   1570e:	0e 94 b5 41 	call	0x836a	; 0x836a <FViewFreeMessage>
   15712:	1a c0       	rjmp	.+52     	; 0x15748 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miClearTotalizer://Standalone
	     lcd_printf(3,1,PSTR("Clear Data Totalizer"));
   15714:	83 e0       	ldi	r24, 0x03	; 3
   15716:	61 e0       	ldi	r22, 0x01	; 1
   15718:	4f ea       	ldi	r20, 0xAF	; 175
   1571a:	52 e2       	ldi	r21, 0x22	; 34
   1571c:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	     ResetTotalizer(TOTALIZER_LAST);
   15720:	80 e0       	ldi	r24, 0x00	; 0
   15722:	0e 94 d7 45 	call	0x8bae	; 0x8bae <ResetTotalizer>
         ResetTotalizer(TOTALIZER_NOW);
   15726:	81 e0       	ldi	r24, 0x01	; 1
   15728:	0e 94 d7 45 	call	0x8bae	; 0x8bae <ResetTotalizer>
   1572c:	0f c0       	rjmp	.+30     	; 0x1574c <FMenuIdle+0x358>
         stMenuIdle=miReady;	      
	     break;
    case miRunTotalizer://Standalone
	     lcd_printf(3,1,PSTR("TotalizerAll     "));
   1572e:	83 e0       	ldi	r24, 0x03	; 3
   15730:	61 e0       	ldi	r22, 0x01	; 1
   15732:	4d e9       	ldi	r20, 0x9D	; 157
   15734:	52 e2       	ldi	r21, 0x22	; 34
   15736:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
	     SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);
   1573a:	85 e0       	ldi	r24, 0x05	; 5
   1573c:	62 e1       	ldi	r22, 0x12	; 18
   1573e:	0e 94 64 72 	call	0xe4c8	; 0xe4c8 <SendSlaveCommand>
   15742:	04 c0       	rjmp	.+8      	; 0x1574c <FMenuIdle+0x358>
		 stMenuIdle=miReady;	      
	     break;
    case miRunTestChar:	     
 	     if (FTestChar()==MENU_DONE)
   15744:	0e 94 f8 40 	call	0x81f0	; 0x81f0 <FTestChar>
   15748:	81 30       	cpi	r24, 0x01	; 1
   1574a:	19 f4       	brne	.+6      	; 0x15752 <FMenuIdle+0x35e>
         stMenuIdle=miReady;
   1574c:	8b e0       	ldi	r24, 0x0B	; 11
   1574e:	80 93 bc 03 	sts	0x03BC, r24
	     break;
	}
//----------SYSTEM_PROC--------------------------------

        //Bank InfoUpdated
        if (IsMessage21==True){
   15752:	80 91 b8 01 	lds	r24, 0x01B8
   15756:	81 30       	cpi	r24, 0x01	; 1
   15758:	21 f4       	brne	.+8      	; 0x15762 <FMenuIdle+0x36e>
		    IsMessage21=False;
   1575a:	10 92 b8 01 	sts	0x01B8, r1
			procMessage21();
   1575e:	0e 94 2f 46 	call	0x8c5e	; 0x8c5e <procMessage21>

        }
        //Transaction Status
        if (IsMessage00==True){
   15762:	80 91 b5 01 	lds	r24, 0x01B5
   15766:	81 30       	cpi	r24, 0x01	; 1
   15768:	91 f4       	brne	.+36     	; 0x1578e <FMenuIdle+0x39a>
		    IsMessage00=False;
   1576a:	10 92 b5 01 	sts	0x01B5, r1
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   1576e:	20 91 45 0b 	lds	r18, 0x0B45
   15772:	21 30       	cpi	r18, 0x01	; 1
   15774:	61 f4       	brne	.+24     	; 0x1578e <FMenuIdle+0x39a>
   15776:	80 91 9e 01 	lds	r24, 0x019E
   1577a:	90 91 9f 01 	lds	r25, 0x019F
   1577e:	8f 97       	sbiw	r24, 0x2f	; 47
   15780:	31 f4       	brne	.+12     	; 0x1578e <FMenuIdle+0x39a>

        }
        //Transaction Status
        if (IsMessage00==True){
		    IsMessage00=False;
			if (procMessage00()==MSG00_NO_PRINT){
   15782:	80 91 6a 0b 	lds	r24, 0x0B6A
   15786:	84 33       	cpi	r24, 0x34	; 52
   15788:	11 f4       	brne	.+4      	; 0x1578e <FMenuIdle+0x39a>
			    IsNoTransaction=True;
   1578a:	20 93 c2 01 	sts	0x01C2, r18
				}
		}
  
		//Send EDC Message Information;
		if (IsSendMessageEDC==True){
   1578e:	80 91 ae 01 	lds	r24, 0x01AE
   15792:	81 30       	cpi	r24, 0x01	; 1
   15794:	21 f4       	brne	.+8      	; 0x1579e <FMenuIdle+0x3aa>
		    IsSendMessageEDC=False;
   15796:	10 92 ae 01 	sts	0x01AE, r1
			SendEDCMessage();
   1579a:	0e 94 df 71 	call	0xe3be	; 0xe3be <SendEDCMessage>
		}
		if (IsEDCApproved==True){
   1579e:	80 91 b0 01 	lds	r24, 0x01B0
   157a2:	81 30       	cpi	r24, 0x01	; 1
   157a4:	21 f4       	brne	.+8      	; 0x157ae <FMenuIdle+0x3ba>
		    IsEDCApproved=False;
   157a6:	10 92 b0 01 	sts	0x01B0, r1
            sendMessage92();
   157aa:	0e 94 8d 4d 	call	0x9b1a	; 0x9b1a <sendMessage92>
		}
		if (IsVoidTransaction==True){
   157ae:	80 91 b2 01 	lds	r24, 0x01B2
   157b2:	81 30       	cpi	r24, 0x01	; 1
   157b4:	21 f4       	brne	.+8      	; 0x157be <FMenuIdle+0x3ca>
		    IsVoidTransaction=False;
   157b6:	10 92 b2 01 	sts	0x01B2, r1
            sendMessage94();
   157ba:	0e 94 e6 4c 	call	0x99cc	; 0x99cc <sendMessage94>
		}


        //Message99 Detection 
        if (IsMessage99==True){
   157be:	10 91 b6 01 	lds	r17, 0x01B6
   157c2:	11 30       	cpi	r17, 0x01	; 1
   157c4:	31 f4       	brne	.+12     	; 0x157d2 <FMenuIdle+0x3de>
	        IsMessage99=False;
   157c6:	10 92 b6 01 	sts	0x01B6, r1
		    procMessage99();
   157ca:	0e 94 a0 3e 	call	0x7d40	; 0x7d40 <procMessage99>
		    IsPrinting=True;
   157ce:	10 93 c3 01 	sts	0x01C3, r17
		}
		//No Transaction
		if (IsNoTransaction==True){
   157d2:	80 91 c2 01 	lds	r24, 0x01C2
   157d6:	81 30       	cpi	r24, 0x01	; 1
   157d8:	41 f4       	brne	.+16     	; 0x157ea <FMenuIdle+0x3f6>
			IsNoTransaction=False;
   157da:	10 92 c2 01 	sts	0x01C2, r1
			lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   157de:	83 e0       	ldi	r24, 0x03	; 3
   157e0:	61 e0       	ldi	r22, 0x01	; 1
   157e2:	48 e8       	ldi	r20, 0x88	; 136
   157e4:	52 e2       	ldi	r21, 0x22	; 34
   157e6:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
		}
        
		//Display Idle
		if (stMenuIdle==miScan){//||(stMenuIdle=miWaitPlease)){ 
   157ea:	80 91 bc 03 	lds	r24, 0x03BC
   157ee:	81 30       	cpi	r24, 0x01	; 1
   157f0:	11 f4       	brne	.+4      	; 0x157f6 <FMenuIdle+0x402>
		    DisplayIdle();			
   157f2:	0e 94 73 70 	call	0xe0e6	; 0xe0e6 <DisplayIdle>
			}        

        //Display FreeMessage
		if (stMenuIdle==miScan){ 
   157f6:	80 91 bc 03 	lds	r24, 0x03BC
   157fa:	81 30       	cpi	r24, 0x01	; 1
   157fc:	59 f4       	brne	.+22     	; 0x15814 <FMenuIdle+0x420>
		    if (IsMessage09==True){
   157fe:	80 91 ba 01 	lds	r24, 0x01BA
   15802:	81 30       	cpi	r24, 0x01	; 1
   15804:	39 f4       	brne	.+14     	; 0x15814 <FMenuIdle+0x420>
			    IsMessage09=False;
   15806:	10 92 ba 01 	sts	0x01BA, r1
				procMessage09();
   1580a:	0e 94 38 17 	call	0x2e70	; 0x2e70 <procMessage09>
				stMenuIdle=miRunViewFreeMessage;
   1580e:	83 e1       	ldi	r24, 0x13	; 19
   15810:	80 93 bc 03 	sts	0x03BC, r24
			   }
			}

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
   15814:	80 91 bc 03 	lds	r24, 0x03BC
   15818:	81 30       	cpi	r24, 0x01	; 1
   1581a:	89 f4       	brne	.+34     	; 0x1583e <FMenuIdle+0x44a>
   1581c:	80 91 af 01 	lds	r24, 0x01AF
   15820:	81 30       	cpi	r24, 0x01	; 1
   15822:	69 f4       	brne	.+26     	; 0x1583e <FMenuIdle+0x44a>
		    IsRFIDDetected=False;
   15824:	10 92 af 01 	sts	0x01AF, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15828:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1582a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1582c:	82 e0       	ldi	r24, 0x02	; 2
   1582e:	90 e0       	ldi	r25, 0x00	; 0
   15830:	90 93 d7 01 	sts	0x01D7, r25
   15834:	80 93 d6 01 	sts	0x01D6, r24

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
		    IsRFIDDetected=False;
		    system_beep(2);           
			stMenuIdle=miRunLocalAccount;
   15838:	8e e0       	ldi	r24, 0x0E	; 14
   1583a:	80 93 bc 03 	sts	0x03BC, r24
		}
        //Print Spooling
		if (IsMessage81==True){
   1583e:	10 91 bd 01 	lds	r17, 0x01BD
   15842:	11 30       	cpi	r17, 0x01	; 1
   15844:	41 f4       	brne	.+16     	; 0x15856 <FMenuIdle+0x462>
		    IsMessage81=False;
   15846:	10 92 bd 01 	sts	0x01BD, r1
			//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
			cmdPrint=procMessage81();
   1584a:	0e 94 15 18 	call	0x302a	; 0x302a <procMessage81>
   1584e:	80 93 cb 01 	sts	0x01CB, r24
			IsFreePrinting=True;
   15852:	10 93 bf 01 	sts	0x01BF, r17
         }

    //SystemService
      systemGenerateReport();
   15856:	0e 94 9b 31 	call	0x6336	; 0x6336 <systemGenerateReport>
      systemPrinting();
   1585a:	0e 94 e6 5c 	call	0xb9cc	; 0xb9cc <systemPrinting>
	  systemEDC();
	  systemConfigProtocol();
   1585e:	0e 94 d4 a9 	call	0x153a8	; 0x153a8 <systemConfigProtocol>
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}
   15862:	1f 91       	pop	r17
   15864:	08 95       	ret

00015866 <lcd_command>:
	lcd_command(0x0c);
	lcd_command(0x06);
}

void lcd_command(unsigned char __chr){
	_LCD_PORT = __chr & 0xF0;
   15866:	98 2f       	mov	r25, r24
   15868:	90 7f       	andi	r25, 0xF0	; 240
   1586a:	95 bb       	out	0x15, r25	; 21
	cbi(_LCD_PORT, _LCD_RS);
   1586c:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   1586e:	a9 9a       	sbi	0x15, 1	; 21
   15870:	48 ee       	ldi	r20, 0xE8	; 232
   15872:	53 e0       	ldi	r21, 0x03	; 3
   15874:	fa 01       	movw	r30, r20
   15876:	31 97       	sbiw	r30, 0x01	; 1
   15878:	f1 f7       	brne	.-4      	; 0x15876 <lcd_command+0x10>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   1587a:	a9 98       	cbi	0x15, 1	; 21
   1587c:	fa 01       	movw	r30, r20
   1587e:	31 97       	sbiw	r30, 0x01	; 1
   15880:	f1 f7       	brne	.-4      	; 0x1587e <lcd_command+0x18>
	_LCD_BUSY;

	_LCD_PORT = (__chr & 0x0F) << 4;
   15882:	28 2f       	mov	r18, r24
   15884:	30 e0       	ldi	r19, 0x00	; 0
   15886:	94 e0       	ldi	r25, 0x04	; 4
   15888:	22 0f       	add	r18, r18
   1588a:	33 1f       	adc	r19, r19
   1588c:	9a 95       	dec	r25
   1588e:	e1 f7       	brne	.-8      	; 0x15888 <lcd_command+0x22>
   15890:	25 bb       	out	0x15, r18	; 21
	cbi(_LCD_PORT, _LCD_RS);
   15892:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15894:	a9 9a       	sbi	0x15, 1	; 21
   15896:	fa 01       	movw	r30, r20
   15898:	31 97       	sbiw	r30, 0x01	; 1
   1589a:	f1 f7       	brne	.-4      	; 0x15898 <lcd_command+0x32>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   1589c:	a9 98       	cbi	0x15, 1	; 21
   1589e:	fa 01       	movw	r30, r20
   158a0:	31 97       	sbiw	r30, 0x01	; 1
   158a2:	f1 f7       	brne	.-4      	; 0x158a0 <lcd_command+0x3a>
	_LCD_BUSY;
	_LCD_BUSY;
	if (__chr==0x01) _delay_ms(50);
   158a4:	fa 01       	movw	r30, r20
   158a6:	31 97       	sbiw	r30, 0x01	; 1
   158a8:	f1 f7       	brne	.-4      	; 0x158a6 <lcd_command+0x40>
   158aa:	81 30       	cpi	r24, 0x01	; 1
   158ac:	21 f4       	brne	.+8      	; 0x158b6 <lcd_command+0x50>
   158ae:	84 ed       	ldi	r24, 0xD4	; 212
   158b0:	90 e3       	ldi	r25, 0x30	; 48
   158b2:	01 97       	sbiw	r24, 0x01	; 1
   158b4:	f1 f7       	brne	.-4      	; 0x158b2 <lcd_command+0x4c>
   158b6:	08 95       	ret

000158b8 <lcd_init>:
   158b8:	86 ea       	ldi	r24, 0xA6	; 166
   158ba:	9e e0       	ldi	r25, 0x0E	; 14
   158bc:	01 97       	sbiw	r24, 0x01	; 1
   158be:	f1 f7       	brne	.-4      	; 0x158bc <lcd_init+0x4>

#define _LCD_BUSY	_delay_ms(4);

void lcd_init(void){
	_delay_ms(15);
	_LCD_PORT = 0x00;
   158c0:	15 ba       	out	0x15, r1	; 21
	_LCD_DDR |= (1 << _LCD_D7) | (1 << _LCD_D6) | (1 << _LCD_D5) | (1 << _LCD_D4);
   158c2:	84 b3       	in	r24, 0x14	; 20
   158c4:	80 6f       	ori	r24, 0xF0	; 240
   158c6:	84 bb       	out	0x14, r24	; 20
	_LCD_DDR |= (1 << _LCD_E) | (1 << _LCD_RW) | (1 << _LCD_RS);
   158c8:	84 b3       	in	r24, 0x14	; 20
   158ca:	8e 60       	ori	r24, 0x0E	; 14
   158cc:	84 bb       	out	0x14, r24	; 20

	_LCD_PORT = 0x30;
   158ce:	20 e3       	ldi	r18, 0x30	; 48
   158d0:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   158d2:	a9 9a       	sbi	0x15, 1	; 21
   158d4:	88 ee       	ldi	r24, 0xE8	; 232
   158d6:	93 e0       	ldi	r25, 0x03	; 3
   158d8:	fc 01       	movw	r30, r24
   158da:	31 97       	sbiw	r30, 0x01	; 1
   158dc:	f1 f7       	brne	.-4      	; 0x158da <lcd_init+0x22>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   158de:	a9 98       	cbi	0x15, 1	; 21
   158e0:	fc 01       	movw	r30, r24
   158e2:	31 97       	sbiw	r30, 0x01	; 1
   158e4:	f1 f7       	brne	.-4      	; 0x158e2 <lcd_init+0x2a>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   158e6:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   158e8:	a9 9a       	sbi	0x15, 1	; 21
   158ea:	fc 01       	movw	r30, r24
   158ec:	31 97       	sbiw	r30, 0x01	; 1
   158ee:	f1 f7       	brne	.-4      	; 0x158ec <lcd_init+0x34>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   158f0:	a9 98       	cbi	0x15, 1	; 21
   158f2:	fc 01       	movw	r30, r24
   158f4:	31 97       	sbiw	r30, 0x01	; 1
   158f6:	f1 f7       	brne	.-4      	; 0x158f4 <lcd_init+0x3c>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   158f8:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   158fa:	a9 9a       	sbi	0x15, 1	; 21
   158fc:	fc 01       	movw	r30, r24
   158fe:	31 97       	sbiw	r30, 0x01	; 1
   15900:	f1 f7       	brne	.-4      	; 0x158fe <lcd_init+0x46>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15902:	a9 98       	cbi	0x15, 1	; 21
   15904:	fc 01       	movw	r30, r24
   15906:	31 97       	sbiw	r30, 0x01	; 1
   15908:	f1 f7       	brne	.-4      	; 0x15906 <lcd_init+0x4e>
	_LCD_BUSY;

	_LCD_PORT = 0x20;
   1590a:	20 e2       	ldi	r18, 0x20	; 32
   1590c:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   1590e:	a9 9a       	sbi	0x15, 1	; 21
   15910:	fc 01       	movw	r30, r24
   15912:	31 97       	sbiw	r30, 0x01	; 1
   15914:	f1 f7       	brne	.-4      	; 0x15912 <lcd_init+0x5a>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15916:	a9 98       	cbi	0x15, 1	; 21
   15918:	01 97       	sbiw	r24, 0x01	; 1
   1591a:	f1 f7       	brne	.-4      	; 0x15918 <lcd_init+0x60>
	_LCD_BUSY;

	_LIGHT_PORT = 0x01;
   1591c:	81 e0       	ldi	r24, 0x01	; 1
   1591e:	80 93 65 00 	sts	0x0065, r24
	_LIGHT_DDR |= (1 << _LIGHT_PIN);
   15922:	e4 e6       	ldi	r30, 0x64	; 100
   15924:	f0 e0       	ldi	r31, 0x00	; 0
   15926:	80 81       	ld	r24, Z
   15928:	82 60       	ori	r24, 0x02	; 2
   1592a:	80 83       	st	Z, r24

	lcd_command(0x28);
   1592c:	88 e2       	ldi	r24, 0x28	; 40
   1592e:	0e 94 33 ac 	call	0x15866	; 0x15866 <lcd_command>
	lcd_command(0x0c);
   15932:	8c e0       	ldi	r24, 0x0C	; 12
   15934:	0e 94 33 ac 	call	0x15866	; 0x15866 <lcd_command>
	lcd_command(0x06);
   15938:	86 e0       	ldi	r24, 0x06	; 6
   1593a:	0e 94 33 ac 	call	0x15866	; 0x15866 <lcd_command>
}
   1593e:	08 95       	ret

00015940 <_lcd>:
	if (__chr==0x01) _delay_ms(50);

}

void _lcd(unsigned char __chr){
	_LCD_PORT =((__chr & 0xF0));
   15940:	28 2f       	mov	r18, r24
   15942:	20 7f       	andi	r18, 0xF0	; 240
   15944:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_RS);
   15946:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15948:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   1594a:	a9 98       	cbi	0x15, 1	; 21

	_LCD_PORT = (((__chr & 0x0F) << 4));
   1594c:	90 e0       	ldi	r25, 0x00	; 0
   1594e:	24 e0       	ldi	r18, 0x04	; 4
   15950:	88 0f       	add	r24, r24
   15952:	99 1f       	adc	r25, r25
   15954:	2a 95       	dec	r18
   15956:	e1 f7       	brne	.-8      	; 0x15950 <_lcd+0x10>
   15958:	85 bb       	out	0x15, r24	; 21
	sbi(_LCD_PORT, _LCD_RS);
   1595a:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   1595c:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   1595e:	a9 98       	cbi	0x15, 1	; 21
   15960:	88 ee       	ldi	r24, 0xE8	; 232
   15962:	93 e0       	ldi	r25, 0x03	; 3
   15964:	01 97       	sbiw	r24, 0x01	; 1
   15966:	f1 f7       	brne	.-4      	; 0x15964 <_lcd+0x24>
	_LCD_BUSY;
	_delay_ms(1);
}
   15968:	8a ef       	ldi	r24, 0xFA	; 250
   1596a:	90 e0       	ldi	r25, 0x00	; 0
   1596c:	01 97       	sbiw	r24, 0x01	; 1
   1596e:	f1 f7       	brne	.-4      	; 0x1596c <_lcd+0x2c>
   15970:	08 95       	ret

00015972 <lcd_string>:
     lcd_printf(2,1,PSTR("                    "));
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
   15972:	cf 93       	push	r28
   15974:	df 93       	push	r29
   15976:	ec 01       	movw	r28, r24
   15978:	03 c0       	rjmp	.+6      	; 0x15980 <lcd_string+0xe>
	while(*__string)
		_lcd(*__string++);
   1597a:	21 96       	adiw	r28, 0x01	; 1
   1597c:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
	while(*__string)
   15980:	88 81       	ld	r24, Y
   15982:	88 23       	and	r24, r24
   15984:	d1 f7       	brne	.-12     	; 0x1597a <lcd_string+0x8>
		_lcd(*__string++);
}
   15986:	df 91       	pop	r29
   15988:	cf 91       	pop	r28
   1598a:	08 95       	ret

0001598c <lcd_xy>:

void lcd_xy(unsigned char __x, unsigned char __y){
	switch(__x){
   1598c:	82 30       	cpi	r24, 0x02	; 2
   1598e:	69 f0       	breq	.+26     	; 0x159aa <lcd_xy+0x1e>
   15990:	83 30       	cpi	r24, 0x03	; 3
   15992:	18 f4       	brcc	.+6      	; 0x1599a <lcd_xy+0xe>
   15994:	81 30       	cpi	r24, 0x01	; 1
   15996:	a9 f4       	brne	.+42     	; 0x159c2 <lcd_xy+0x36>
   15998:	05 c0       	rjmp	.+10     	; 0x159a4 <lcd_xy+0x18>
   1599a:	83 30       	cpi	r24, 0x03	; 3
   1599c:	49 f0       	breq	.+18     	; 0x159b0 <lcd_xy+0x24>
   1599e:	84 30       	cpi	r24, 0x04	; 4
   159a0:	81 f4       	brne	.+32     	; 0x159c2 <lcd_xy+0x36>
   159a2:	0b c0       	rjmp	.+22     	; 0x159ba <lcd_xy+0x2e>
		case 1:
			lcd_command(0x80 + __y - 1);
   159a4:	86 2f       	mov	r24, r22
   159a6:	81 58       	subi	r24, 0x81	; 129
   159a8:	05 c0       	rjmp	.+10     	; 0x159b4 <lcd_xy+0x28>
			break;
		case 2:
			lcd_command(0xC0 + __y - 1);
   159aa:	86 2f       	mov	r24, r22
   159ac:	81 54       	subi	r24, 0x41	; 65
   159ae:	02 c0       	rjmp	.+4      	; 0x159b4 <lcd_xy+0x28>
			break;
		case 3:
			lcd_command(0x94 + __y - 1);
   159b0:	86 2f       	mov	r24, r22
   159b2:	8d 56       	subi	r24, 0x6D	; 109
   159b4:	0e 94 33 ac 	call	0x15866	; 0x15866 <lcd_command>
   159b8:	08 95       	ret
			break;
		case 4:
			lcd_command(0xD4 + __y - 1);
   159ba:	86 2f       	mov	r24, r22
   159bc:	8d 52       	subi	r24, 0x2D	; 45
   159be:	0e 94 33 ac 	call	0x15866	; 0x15866 <lcd_command>
   159c2:	08 95       	ret

000159c4 <lcd_print>:
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
	 }     
}

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
   159c4:	df 92       	push	r13
   159c6:	ef 92       	push	r14
   159c8:	ff 92       	push	r15
   159ca:	0f 93       	push	r16
   159cc:	1f 93       	push	r17
   159ce:	cf 93       	push	r28
   159d0:	df 93       	push	r29
   159d2:	06 2f       	mov	r16, r22
   159d4:	d4 2e       	mov	r13, r20
   159d6:	15 2f       	mov	r17, r21
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
   159d8:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
   159dc:	2d 2d       	mov	r18, r13
   159de:	31 2f       	mov	r19, r17
   159e0:	c9 01       	movw	r24, r18
   159e2:	ec 01       	movw	r28, r24
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   159e4:	34 e1       	ldi	r19, 0x14	; 20
   159e6:	e3 2e       	mov	r14, r19
   159e8:	f1 2c       	mov	r15, r1
   159ea:	e0 1a       	sub	r14, r16
   159ec:	f1 08       	sbc	r15, r1
   159ee:	04 c0       	rjmp	.+8      	; 0x159f8 <lcd_print+0x34>
		_lcd(*__string);__string++;
   159f0:	82 2f       	mov	r24, r18
   159f2:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
   159f6:	21 96       	adiw	r28, 0x01	; 1
   159f8:	9e 01       	movw	r18, r28
   159fa:	2d 19       	sub	r18, r13
   159fc:	82 2f       	mov	r24, r18

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   159fe:	28 81       	ld	r18, Y
   15a00:	22 23       	and	r18, r18
   15a02:	21 f0       	breq	.+8      	; 0x15a0c <lcd_print+0x48>
   15a04:	90 e0       	ldi	r25, 0x00	; 0
   15a06:	e8 16       	cp	r14, r24
   15a08:	f9 06       	cpc	r15, r25
   15a0a:	94 f7       	brge	.-28     	; 0x159f0 <lcd_print+0x2c>
		_lcd(*__string);__string++;
		iPos++;
		}    
}
   15a0c:	df 91       	pop	r29
   15a0e:	cf 91       	pop	r28
   15a10:	1f 91       	pop	r17
   15a12:	0f 91       	pop	r16
   15a14:	ff 90       	pop	r15
   15a16:	ef 90       	pop	r14
   15a18:	df 90       	pop	r13
   15a1a:	08 95       	ret

00015a1c <lcd_printf>:

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
   15a1c:	df 92       	push	r13
   15a1e:	ef 92       	push	r14
   15a20:	ff 92       	push	r15
   15a22:	0f 93       	push	r16
   15a24:	1f 93       	push	r17
   15a26:	cf 93       	push	r28
   15a28:	df 93       	push	r29
   15a2a:	06 2f       	mov	r16, r22
   15a2c:	d4 2e       	mov	r13, r20
   15a2e:	15 2f       	mov	r17, r21
    char iPos=0;
	lcd_xy(__x, __y);
   15a30:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
   15a34:	8d 2d       	mov	r24, r13
   15a36:	91 2f       	mov	r25, r17
   15a38:	fc 01       	movw	r30, r24
   15a3a:	ef 01       	movw	r28, r30
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   15a3c:	44 e1       	ldi	r20, 0x14	; 20
   15a3e:	e4 2e       	mov	r14, r20
   15a40:	f1 2c       	mov	r15, r1
   15a42:	e0 1a       	sub	r14, r16
   15a44:	f1 08       	sbc	r15, r1
   15a46:	04 c0       	rjmp	.+8      	; 0x15a50 <lcd_printf+0x34>
		_lcd(pgm_read_byte(&(*__string)));
   15a48:	82 2f       	mov	r24, r18
   15a4a:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
		__string++;
   15a4e:	21 96       	adiw	r28, 0x01	; 1
   15a50:	9e 01       	movw	r18, r28
   15a52:	2d 19       	sub	r18, r13
   15a54:	82 2f       	mov	r24, r18

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
    char iPos=0;
	lcd_xy(__x, __y);
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   15a56:	fe 01       	movw	r30, r28
   15a58:	24 91       	lpm	r18, Z+
   15a5a:	22 23       	and	r18, r18
   15a5c:	21 f0       	breq	.+8      	; 0x15a66 <lcd_printf+0x4a>
   15a5e:	90 e0       	ldi	r25, 0x00	; 0
   15a60:	e8 16       	cp	r14, r24
   15a62:	f9 06       	cpc	r15, r25
   15a64:	8c f7       	brge	.-30     	; 0x15a48 <lcd_printf+0x2c>
		_lcd(pgm_read_byte(&(*__string)));
		__string++;
		iPos++;
		}
}
   15a66:	df 91       	pop	r29
   15a68:	cf 91       	pop	r28
   15a6a:	1f 91       	pop	r17
   15a6c:	0f 91       	pop	r16
   15a6e:	ff 90       	pop	r15
   15a70:	ef 90       	pop	r14
   15a72:	df 90       	pop	r13
   15a74:	08 95       	ret

00015a76 <lcd_clear>:
	_LCD_BUSY;
	_delay_ms(1);
}

void lcd_clear(){
     lcd_printf(1,1,PSTR("                    "));
   15a76:	81 e0       	ldi	r24, 0x01	; 1
   15a78:	61 e0       	ldi	r22, 0x01	; 1
   15a7a:	48 ea       	ldi	r20, 0xA8	; 168
   15a7c:	53 e2       	ldi	r21, 0x23	; 35
   15a7e:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
     lcd_printf(2,1,PSTR("                    "));
   15a82:	82 e0       	ldi	r24, 0x02	; 2
   15a84:	61 e0       	ldi	r22, 0x01	; 1
   15a86:	43 e9       	ldi	r20, 0x93	; 147
   15a88:	53 e2       	ldi	r21, 0x23	; 35
   15a8a:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
     lcd_printf(3,1,PSTR("                    "));
   15a8e:	83 e0       	ldi	r24, 0x03	; 3
   15a90:	61 e0       	ldi	r22, 0x01	; 1
   15a92:	4e e7       	ldi	r20, 0x7E	; 126
   15a94:	53 e2       	ldi	r21, 0x23	; 35
   15a96:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
     lcd_printf(4,1,PSTR("                    "));
   15a9a:	84 e0       	ldi	r24, 0x04	; 4
   15a9c:	61 e0       	ldi	r22, 0x01	; 1
   15a9e:	49 e6       	ldi	r20, 0x69	; 105
   15aa0:	53 e2       	ldi	r21, 0x23	; 35
   15aa2:	0e 94 0e ad 	call	0x15a1c	; 0x15a1c <lcd_printf>
}
   15aa6:	08 95       	ret

00015aa8 <lcd_put>:
		__string++;
		iPos++;
		}
}

void lcd_put(unsigned char __x, unsigned char __y, unsigned char __chr){
   15aa8:	1f 93       	push	r17
   15aaa:	14 2f       	mov	r17, r20
	lcd_xy(__x, __y);
   15aac:	0e 94 c6 ac 	call	0x1598c	; 0x1598c <lcd_xy>
	_lcd(__chr);
   15ab0:	81 2f       	mov	r24, r17
   15ab2:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
}
   15ab6:	1f 91       	pop	r17
   15ab8:	08 95       	ret

00015aba <lcd_cgram>:

void lcd_cgram(unsigned char location, char *ptr){
   15aba:	0f 93       	push	r16
   15abc:	1f 93       	push	r17
   15abe:	cf 93       	push	r28
   15ac0:	df 93       	push	r29
   15ac2:	8b 01       	movw	r16, r22
	unsigned char i;
    if(location < 8){
   15ac4:	88 30       	cpi	r24, 0x08	; 8
   15ac6:	90 f4       	brcc	.+36     	; 0x15aec <lcd_cgram+0x32>
		lcd_command(0x40 + (location * 8));
   15ac8:	88 0f       	add	r24, r24
   15aca:	88 0f       	add	r24, r24
   15acc:	88 0f       	add	r24, r24
   15ace:	80 5c       	subi	r24, 0xC0	; 192
   15ad0:	0e 94 33 ac 	call	0x15866	; 0x15866 <lcd_command>
   15ad4:	c0 e0       	ldi	r28, 0x00	; 0
   15ad6:	d0 e0       	ldi	r29, 0x00	; 0
		for(i = 0; i < 8; i++)
			_lcd(ptr[i]);
   15ad8:	f8 01       	movw	r30, r16
   15ada:	ec 0f       	add	r30, r28
   15adc:	fd 1f       	adc	r31, r29
   15ade:	80 81       	ld	r24, Z
   15ae0:	0e 94 a0 ac 	call	0x15940	; 0x15940 <_lcd>
   15ae4:	21 96       	adiw	r28, 0x01	; 1

void lcd_cgram(unsigned char location, char *ptr){
	unsigned char i;
    if(location < 8){
		lcd_command(0x40 + (location * 8));
		for(i = 0; i < 8; i++)
   15ae6:	c8 30       	cpi	r28, 0x08	; 8
   15ae8:	d1 05       	cpc	r29, r1
   15aea:	b1 f7       	brne	.-20     	; 0x15ad8 <lcd_cgram+0x1e>
			_lcd(ptr[i]);
	}
}
   15aec:	df 91       	pop	r29
   15aee:	cf 91       	pop	r28
   15af0:	1f 91       	pop	r17
   15af2:	0f 91       	pop	r16
   15af4:	08 95       	ret

00015af6 <ClearMem>:
			lcd_command(0xD4 + __y - 1);
			break;
	}
}

void ClearMem(char *string){
   15af6:	cf 93       	push	r28
   15af8:	df 93       	push	r29
   15afa:	20 e0       	ldi	r18, 0x00	; 0
   15afc:	04 c0       	rjmp	.+8      	; 0x15b06 <ClearMem+0x10>
     char i;
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
   15afe:	c8 0f       	add	r28, r24
   15b00:	d9 1f       	adc	r29, r25
   15b02:	18 82       	st	Y, r1
	}
}

void ClearMem(char *string){
     char i;
	 for (i=0;i<strlen(string);i++){
   15b04:	2f 5f       	subi	r18, 0xFF	; 255
   15b06:	c2 2f       	mov	r28, r18
   15b08:	d0 e0       	ldi	r29, 0x00	; 0
   15b0a:	fc 01       	movw	r30, r24
   15b0c:	01 90       	ld	r0, Z+
   15b0e:	00 20       	and	r0, r0
   15b10:	e9 f7       	brne	.-6      	; 0x15b0c <ClearMem+0x16>
   15b12:	31 97       	sbiw	r30, 0x01	; 1
   15b14:	e8 1b       	sub	r30, r24
   15b16:	f9 0b       	sbc	r31, r25
   15b18:	ce 17       	cp	r28, r30
   15b1a:	df 07       	cpc	r29, r31
   15b1c:	80 f3       	brcs	.-32     	; 0x15afe <ClearMem+0x8>
          string[i]=0;
	 }     
}
   15b1e:	df 91       	pop	r29
   15b20:	cf 91       	pop	r28
   15b22:	08 95       	ret

00015b24 <_key_hit>:
													 {'7', 'P', 'Q', 'R', 'S', '\0'},
											         {'8', 'T', 'U', 'V', '\0'}, 
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
   15b24:	df 93       	push	r29
   15b26:	cf 93       	push	r28
   15b28:	00 d0       	rcall	.+0      	; 0x15b2a <_key_hit+0x6>
   15b2a:	00 d0       	rcall	.+0      	; 0x15b2c <_key_hit+0x8>
   15b2c:	cd b7       	in	r28, 0x3d	; 61
   15b2e:	de b7       	in	r29, 0x3e	; 62
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15b30:	8f ee       	ldi	r24, 0xEF	; 239
   15b32:	89 83       	std	Y+1, r24	; 0x01
   15b34:	8f ed       	ldi	r24, 0xDF	; 223
   15b36:	8a 83       	std	Y+2, r24	; 0x02
   15b38:	8f eb       	ldi	r24, 0xBF	; 191
   15b3a:	8b 83       	std	Y+3, r24	; 0x03
   15b3c:	8f e7       	ldi	r24, 0x7F	; 127
   15b3e:	8c 83       	std	Y+4, r24	; 0x04
   15b40:	de 01       	movw	r26, r28
   15b42:	11 96       	adiw	r26, 0x01	; 1
   15b44:	2a ef       	ldi	r18, 0xFA	; 250
   15b46:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   15b48:	ae 01       	movw	r20, r28
   15b4a:	4b 5f       	subi	r20, 0xFB	; 251
   15b4c:	5f 4f       	sbci	r21, 0xFF	; 255
   15b4e:	c9 01       	movw	r24, r18
   15b50:	01 97       	sbiw	r24, 0x01	; 1
   15b52:	f1 f7       	brne	.-4      	; 0x15b50 <_key_hit+0x2c>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15b54:	8c 91       	ld	r24, X
   15b56:	80 93 62 00 	sts	0x0062, r24
   15b5a:	f9 01       	movw	r30, r18
   15b5c:	31 97       	sbiw	r30, 0x01	; 1
   15b5e:	f1 f7       	brne	.-4      	; 0x15b5c <_key_hit+0x38>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15b60:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15b62:	98 17       	cp	r25, r24
   15b64:	21 f4       	brne	.+8      	; 0x15b6e <_key_hit+0x4a>
		    break;
   15b66:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15b68:	a4 17       	cp	r26, r20
   15b6a:	b5 07       	cpc	r27, r21
   15b6c:	81 f7       	brne	.-32     	; 0x15b4e <_key_hit+0x2a>
		keyhit = _KEY_MATRIX;
		if (keyhit!=outmap[i]) 
		    break;
	}
	return keyhit;
}
   15b6e:	89 2f       	mov	r24, r25
   15b70:	0f 90       	pop	r0
   15b72:	0f 90       	pop	r0
   15b74:	0f 90       	pop	r0
   15b76:	0f 90       	pop	r0
   15b78:	cf 91       	pop	r28
   15b7a:	df 91       	pop	r29
   15b7c:	08 95       	ret

00015b7e <_key_crr>:

char _key_crr(char __key){
	if(	__key != _KEY_1 && __key != _KEY_2 &&
   15b7e:	8e 3e       	cpi	r24, 0xEE	; 238
   15b80:	f9 f0       	breq	.+62     	; 0x15bc0 <_key_crr+0x42>
   15b82:	8e 3d       	cpi	r24, 0xDE	; 222
   15b84:	e9 f0       	breq	.+58     	; 0x15bc0 <_key_crr+0x42>
   15b86:	8e 3b       	cpi	r24, 0xBE	; 190
   15b88:	d9 f0       	breq	.+54     	; 0x15bc0 <_key_crr+0x42>
   15b8a:	8d 3e       	cpi	r24, 0xED	; 237
   15b8c:	c9 f0       	breq	.+50     	; 0x15bc0 <_key_crr+0x42>
   15b8e:	8d 3d       	cpi	r24, 0xDD	; 221
   15b90:	b9 f0       	breq	.+46     	; 0x15bc0 <_key_crr+0x42>
   15b92:	8d 3b       	cpi	r24, 0xBD	; 189
   15b94:	a9 f0       	breq	.+42     	; 0x15bc0 <_key_crr+0x42>
   15b96:	8b 3e       	cpi	r24, 0xEB	; 235
   15b98:	99 f0       	breq	.+38     	; 0x15bc0 <_key_crr+0x42>
   15b9a:	8b 3d       	cpi	r24, 0xDB	; 219
   15b9c:	89 f0       	breq	.+34     	; 0x15bc0 <_key_crr+0x42>
   15b9e:	8b 3b       	cpi	r24, 0xBB	; 187
   15ba0:	79 f0       	breq	.+30     	; 0x15bc0 <_key_crr+0x42>
   15ba2:	87 3d       	cpi	r24, 0xD7	; 215
   15ba4:	69 f0       	breq	.+26     	; 0x15bc0 <_key_crr+0x42>
   15ba6:	87 3e       	cpi	r24, 0xE7	; 231
   15ba8:	59 f0       	breq	.+22     	; 0x15bc0 <_key_crr+0x42>
   15baa:	87 3b       	cpi	r24, 0xB7	; 183
   15bac:	49 f0       	breq	.+18     	; 0x15bc0 <_key_crr+0x42>
   15bae:	8e 37       	cpi	r24, 0x7E	; 126
   15bb0:	39 f0       	breq	.+14     	; 0x15bc0 <_key_crr+0x42>
   15bb2:	8d 37       	cpi	r24, 0x7D	; 125
   15bb4:	29 f0       	breq	.+10     	; 0x15bc0 <_key_crr+0x42>
   15bb6:	8b 37       	cpi	r24, 0x7B	; 123
   15bb8:	19 f0       	breq	.+6      	; 0x15bc0 <_key_crr+0x42>
   15bba:	87 37       	cpi	r24, 0x77	; 119
   15bbc:	09 f0       	breq	.+2      	; 0x15bc0 <_key_crr+0x42>
   15bbe:	80 e0       	ldi	r24, 0x00	; 0
		__key != _KEY_CANCEL && __key != _KEY_ENTER &&
		__key != _KEY_TIKET && __key != _KEY_MENU &&
		__key != _KEY_SHIFT && __key != _KEY_CLEAR)
		return _KEY_NULL;
	return __key;
}
   15bc0:	08 95       	ret

00015bc2 <_key_btn>:

char _key_btn(char __key){
	char __keychar = 0;
	
	switch (__key){
   15bc2:	8e 3b       	cpi	r24, 0xBE	; 190
   15bc4:	91 f1       	breq	.+100    	; 0x15c2a <_key_btn+0x68>
   15bc6:	8f 3b       	cpi	r24, 0xBF	; 191
   15bc8:	a8 f4       	brcc	.+42     	; 0x15bf4 <_key_btn+0x32>
   15bca:	8e 37       	cpi	r24, 0x7E	; 126
   15bcc:	09 f4       	brne	.+2      	; 0x15bd0 <_key_btn+0xe>
   15bce:	41 c0       	rjmp	.+130    	; 0x15c52 <_key_btn+0x90>
   15bd0:	8f 37       	cpi	r24, 0x7F	; 127
   15bd2:	48 f4       	brcc	.+18     	; 0x15be6 <_key_btn+0x24>
   15bd4:	8b 37       	cpi	r24, 0x7B	; 123
   15bd6:	09 f4       	brne	.+2      	; 0x15bda <_key_btn+0x18>
   15bd8:	40 c0       	rjmp	.+128    	; 0x15c5a <_key_btn+0x98>
   15bda:	8d 37       	cpi	r24, 0x7D	; 125
   15bdc:	e1 f1       	breq	.+120    	; 0x15c56 <_key_btn+0x94>
   15bde:	87 37       	cpi	r24, 0x77	; 119
   15be0:	09 f0       	breq	.+2      	; 0x15be4 <_key_btn+0x22>
   15be2:	3f c0       	rjmp	.+126    	; 0x15c62 <_key_btn+0xa0>
   15be4:	3c c0       	rjmp	.+120    	; 0x15c5e <_key_btn+0x9c>
   15be6:	8b 3b       	cpi	r24, 0xBB	; 187
   15be8:	61 f1       	breq	.+88     	; 0x15c42 <_key_btn+0x80>
   15bea:	8d 3b       	cpi	r24, 0xBD	; 189
   15bec:	21 f1       	breq	.+72     	; 0x15c36 <_key_btn+0x74>
   15bee:	87 3b       	cpi	r24, 0xB7	; 183
   15bf0:	c1 f5       	brne	.+112    	; 0x15c62 <_key_btn+0xa0>
   15bf2:	2d c0       	rjmp	.+90     	; 0x15c4e <_key_btn+0x8c>
   15bf4:	8e 3d       	cpi	r24, 0xDE	; 222
   15bf6:	a9 f0       	breq	.+42     	; 0x15c22 <_key_btn+0x60>
   15bf8:	8f 3d       	cpi	r24, 0xDF	; 223
   15bfa:	38 f4       	brcc	.+14     	; 0x15c0a <_key_btn+0x48>
   15bfc:	8b 3d       	cpi	r24, 0xDB	; 219
   15bfe:	f9 f0       	breq	.+62     	; 0x15c3e <_key_btn+0x7c>
   15c00:	8d 3d       	cpi	r24, 0xDD	; 221
   15c02:	b9 f0       	breq	.+46     	; 0x15c32 <_key_btn+0x70>
   15c04:	87 3d       	cpi	r24, 0xD7	; 215
   15c06:	69 f5       	brne	.+90     	; 0x15c62 <_key_btn+0xa0>
   15c08:	1e c0       	rjmp	.+60     	; 0x15c46 <_key_btn+0x84>
   15c0a:	8b 3e       	cpi	r24, 0xEB	; 235
   15c0c:	b1 f0       	breq	.+44     	; 0x15c3a <_key_btn+0x78>
   15c0e:	8c 3e       	cpi	r24, 0xEC	; 236
   15c10:	18 f4       	brcc	.+6      	; 0x15c18 <_key_btn+0x56>
   15c12:	87 3e       	cpi	r24, 0xE7	; 231
   15c14:	31 f5       	brne	.+76     	; 0x15c62 <_key_btn+0xa0>
   15c16:	19 c0       	rjmp	.+50     	; 0x15c4a <_key_btn+0x88>
   15c18:	8d 3e       	cpi	r24, 0xED	; 237
   15c1a:	49 f0       	breq	.+18     	; 0x15c2e <_key_btn+0x6c>
   15c1c:	8e 3e       	cpi	r24, 0xEE	; 238
   15c1e:	09 f5       	brne	.+66     	; 0x15c62 <_key_btn+0xa0>
   15c20:	02 c0       	rjmp	.+4      	; 0x15c26 <_key_btn+0x64>
   15c22:	82 e3       	ldi	r24, 0x32	; 50
   15c24:	08 95       	ret
   15c26:	81 e3       	ldi	r24, 0x31	; 49
   15c28:	08 95       	ret
   15c2a:	83 e3       	ldi	r24, 0x33	; 51
   15c2c:	08 95       	ret
		case 0xDE:
			__keychar = 0x32; //2
			break;
		case 0xBE:
			__keychar = 0x33; //3
			break;
   15c2e:	84 e3       	ldi	r24, 0x34	; 52
   15c30:	08 95       	ret
		case 0xED:
			__keychar = 0x34; //4
			break;
   15c32:	85 e3       	ldi	r24, 0x35	; 53
   15c34:	08 95       	ret
		case 0xDD:
			__keychar = 0x35; //5
			break;
   15c36:	86 e3       	ldi	r24, 0x36	; 54
   15c38:	08 95       	ret
		case 0xBD:
			__keychar = 0x36; //6
			break;
   15c3a:	87 e3       	ldi	r24, 0x37	; 55
   15c3c:	08 95       	ret
		case 0xEB:
			__keychar = 0x37; //7
			break;
   15c3e:	88 e3       	ldi	r24, 0x38	; 56
   15c40:	08 95       	ret
		case 0xDB:
			__keychar = 0x38; //8
			break;
   15c42:	89 e3       	ldi	r24, 0x39	; 57
   15c44:	08 95       	ret
		case 0xBB:
			__keychar = 0x39; //9
			break;
   15c46:	80 e3       	ldi	r24, 0x30	; 48
   15c48:	08 95       	ret
		case 0xD7:
			__keychar = 0x30; //0
			break;
   15c4a:	8a e2       	ldi	r24, 0x2A	; 42
   15c4c:	08 95       	ret
		case 0xE7:
			__keychar = 0x2a; //*
			break;
   15c4e:	83 e2       	ldi	r24, 0x23	; 35
   15c50:	08 95       	ret
		case 0xB7:
			__keychar = 0x23; //#
			break;
   15c52:	81 ef       	ldi	r24, 0xF1	; 241
   15c54:	08 95       	ret
		case 0x7E:
			__keychar = 0xF1; //Menu 1
			break;
   15c56:	82 ef       	ldi	r24, 0xF2	; 242
   15c58:	08 95       	ret
		case 0x7D:
			__keychar = 0xF2; //Menu 2
			break;
   15c5a:	83 ef       	ldi	r24, 0xF3	; 243
   15c5c:	08 95       	ret
		case 0x7B:
			__keychar = 0xF3; //Menu 3
			break;
   15c5e:	84 ef       	ldi	r24, 0xF4	; 244
   15c60:	08 95       	ret
		case 0x77:
			__keychar = 0xF4; //Menu 4
			break;
   15c62:	80 e0       	ldi	r24, 0x00	; 0
			__keychar = 0x00;
			break;

	}
	return __keychar;
}
   15c64:	08 95       	ret

00015c66 <_table_alphanum>:
	}
	_PAD_1st;
	return __key;
}

char _table_alphanum(char __caps, char __key, char __hit){
   15c66:	98 2f       	mov	r25, r24
unsigned char __retchar = 0;

	switch(__key){
   15c68:	6d 3d       	cpi	r22, 0xDD	; 221
   15c6a:	11 f1       	breq	.+68     	; 0x15cb0 <_table_alphanum+0x4a>
   15c6c:	6e 3d       	cpi	r22, 0xDE	; 222
   15c6e:	60 f4       	brcc	.+24     	; 0x15c88 <_table_alphanum+0x22>
   15c70:	6d 3b       	cpi	r22, 0xBD	; 189
   15c72:	01 f1       	breq	.+64     	; 0x15cb4 <_table_alphanum+0x4e>
   15c74:	6e 3b       	cpi	r22, 0xBE	; 190
   15c76:	18 f4       	brcc	.+6      	; 0x15c7e <_table_alphanum+0x18>
   15c78:	6b 3b       	cpi	r22, 0xBB	; 187
   15c7a:	21 f5       	brne	.+72     	; 0x15cc4 <_table_alphanum+0x5e>
   15c7c:	21 c0       	rjmp	.+66     	; 0x15cc0 <_table_alphanum+0x5a>
   15c7e:	6e 3b       	cpi	r22, 0xBE	; 190
   15c80:	99 f0       	breq	.+38     	; 0x15ca8 <_table_alphanum+0x42>
   15c82:	6b 3d       	cpi	r22, 0xDB	; 219
   15c84:	f9 f4       	brne	.+62     	; 0x15cc4 <_table_alphanum+0x5e>
   15c86:	1a c0       	rjmp	.+52     	; 0x15cbc <_table_alphanum+0x56>
   15c88:	6b 3e       	cpi	r22, 0xEB	; 235
   15c8a:	b1 f0       	breq	.+44     	; 0x15cb8 <_table_alphanum+0x52>
   15c8c:	6c 3e       	cpi	r22, 0xEC	; 236
   15c8e:	18 f4       	brcc	.+6      	; 0x15c96 <_table_alphanum+0x30>
   15c90:	6e 3d       	cpi	r22, 0xDE	; 222
   15c92:	c1 f4       	brne	.+48     	; 0x15cc4 <_table_alphanum+0x5e>
   15c94:	05 c0       	rjmp	.+10     	; 0x15ca0 <_table_alphanum+0x3a>
   15c96:	6d 3e       	cpi	r22, 0xED	; 237
   15c98:	49 f0       	breq	.+18     	; 0x15cac <_table_alphanum+0x46>
   15c9a:	6e 3e       	cpi	r22, 0xEE	; 238
   15c9c:	99 f4       	brne	.+38     	; 0x15cc4 <_table_alphanum+0x5e>
   15c9e:	02 c0       	rjmp	.+4      	; 0x15ca4 <_table_alphanum+0x3e>
   15ca0:	82 e0       	ldi	r24, 0x02	; 2
   15ca2:	11 c0       	rjmp	.+34     	; 0x15cc6 <_table_alphanum+0x60>
   15ca4:	81 e0       	ldi	r24, 0x01	; 1
   15ca6:	0f c0       	rjmp	.+30     	; 0x15cc6 <_table_alphanum+0x60>
   15ca8:	83 e0       	ldi	r24, 0x03	; 3
   15caa:	0d c0       	rjmp	.+26     	; 0x15cc6 <_table_alphanum+0x60>
		case 0xDE:
			__key = 2; //2
			break;
		case 0xBE:
			__key = 3; //3
			break;
   15cac:	84 e0       	ldi	r24, 0x04	; 4
   15cae:	0b c0       	rjmp	.+22     	; 0x15cc6 <_table_alphanum+0x60>
		case 0xED:
			__key = 4; //4
			break;
   15cb0:	85 e0       	ldi	r24, 0x05	; 5
   15cb2:	09 c0       	rjmp	.+18     	; 0x15cc6 <_table_alphanum+0x60>
		case 0xDD:
			__key = 5; //5
			break;
   15cb4:	86 e0       	ldi	r24, 0x06	; 6
   15cb6:	07 c0       	rjmp	.+14     	; 0x15cc6 <_table_alphanum+0x60>
		case 0xBD:
			__key = 6; //6
			break;
   15cb8:	87 e0       	ldi	r24, 0x07	; 7
   15cba:	05 c0       	rjmp	.+10     	; 0x15cc6 <_table_alphanum+0x60>
		case 0xEB:
			__key = 7; //7
			break;
   15cbc:	88 e0       	ldi	r24, 0x08	; 8
   15cbe:	03 c0       	rjmp	.+6      	; 0x15cc6 <_table_alphanum+0x60>
		case 0xDB:
			__key = 8; //8
			break;
   15cc0:	89 e0       	ldi	r24, 0x09	; 9
   15cc2:	01 c0       	rjmp	.+2      	; 0x15cc6 <_table_alphanum+0x60>
		case 0xBB:
			__key = 9; //9
			break;
   15cc4:	80 e0       	ldi	r24, 0x00	; 0
		default:
			__key = 0;
			break;	
	}

	if(__hit <= pgm_read_byte(&__maxchar[__key]))
   15cc6:	28 2f       	mov	r18, r24
   15cc8:	30 e0       	ldi	r19, 0x00	; 0
   15cca:	f9 01       	movw	r30, r18
   15ccc:	eb 5c       	subi	r30, 0xCB	; 203
   15cce:	fb 4d       	sbci	r31, 0xDB	; 219
   15cd0:	e4 91       	lpm	r30, Z+
   15cd2:	e4 17       	cp	r30, r20
   15cd4:	10 f4       	brcc	.+4      	; 0x15cda <_table_alphanum+0x74>
   15cd6:	80 e0       	ldi	r24, 0x00	; 0
   15cd8:	08 95       	ret
		__retchar = pgm_read_byte(&__alphanum[__caps][__key][__hit]);
   15cda:	ec e3       	ldi	r30, 0x3C	; 60
   15cdc:	9e 9f       	mul	r25, r30
   15cde:	f0 01       	movw	r30, r0
   15ce0:	11 24       	eor	r1, r1
   15ce2:	e4 0f       	add	r30, r20
   15ce4:	f1 1d       	adc	r31, r1
   15ce6:	c9 01       	movw	r24, r18
   15ce8:	88 0f       	add	r24, r24
   15cea:	99 1f       	adc	r25, r25
   15cec:	82 0f       	add	r24, r18
   15cee:	93 1f       	adc	r25, r19
   15cf0:	88 0f       	add	r24, r24
   15cf2:	99 1f       	adc	r25, r25
   15cf4:	e8 0f       	add	r30, r24
   15cf6:	f9 1f       	adc	r31, r25
   15cf8:	e3 54       	subi	r30, 0x43	; 67
   15cfa:	fc 4d       	sbci	r31, 0xDC	; 220
   15cfc:	84 91       	lpm	r24, Z+
	else __retchar = '\0';

	return __retchar;
}
   15cfe:	08 95       	ret

00015d00 <_key_scan>:





char _key_scan(char __select){
   15d00:	8f 92       	push	r8
   15d02:	9f 92       	push	r9
   15d04:	af 92       	push	r10
   15d06:	bf 92       	push	r11
   15d08:	cf 92       	push	r12
   15d0a:	df 92       	push	r13
   15d0c:	ef 92       	push	r14
   15d0e:	ff 92       	push	r15
   15d10:	0f 93       	push	r16
   15d12:	1f 93       	push	r17
   15d14:	df 93       	push	r29
   15d16:	cf 93       	push	r28
   15d18:	00 d0       	rcall	.+0      	; 0x15d1a <_key_scan+0x1a>
   15d1a:	00 d0       	rcall	.+0      	; 0x15d1c <_key_scan+0x1c>
   15d1c:	cd b7       	in	r28, 0x3d	; 61
   15d1e:	de b7       	in	r29, 0x3e	; 62
   15d20:	18 2f       	mov	r17, r24
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
   15d22:	81 50       	subi	r24, 0x01	; 1
   15d24:	82 30       	cpi	r24, 0x02	; 2
   15d26:	08 f0       	brcs	.+2      	; 0x15d2a <_key_scan+0x2a>
   15d28:	aa c0       	rjmp	.+340    	; 0x15e7e <_key_scan+0x17e>
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15d2a:	8f ee       	ldi	r24, 0xEF	; 239
   15d2c:	89 83       	std	Y+1, r24	; 0x01
   15d2e:	8f ed       	ldi	r24, 0xDF	; 223
   15d30:	8a 83       	std	Y+2, r24	; 0x02
   15d32:	8f eb       	ldi	r24, 0xBF	; 191
   15d34:	8b 83       	std	Y+3, r24	; 0x03
   15d36:	8f e7       	ldi	r24, 0x7F	; 127
   15d38:	8c 83       	std	Y+4, r24	; 0x04
   15d3a:	de 01       	movw	r26, r28
   15d3c:	11 96       	adiw	r26, 0x01	; 1
   15d3e:	2a ef       	ldi	r18, 0xFA	; 250
   15d40:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   15d42:	ae 01       	movw	r20, r28
   15d44:	4b 5f       	subi	r20, 0xFB	; 251
   15d46:	5f 4f       	sbci	r21, 0xFF	; 255
   15d48:	c9 01       	movw	r24, r18
   15d4a:	01 97       	sbiw	r24, 0x01	; 1
   15d4c:	f1 f7       	brne	.-4      	; 0x15d4a <_key_scan+0x4a>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15d4e:	8c 91       	ld	r24, X
   15d50:	80 93 62 00 	sts	0x0062, r24
   15d54:	f9 01       	movw	r30, r18
   15d56:	31 97       	sbiw	r30, 0x01	; 1
   15d58:	f1 f7       	brne	.-4      	; 0x15d56 <_key_scan+0x56>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15d5a:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15d5c:	98 17       	cp	r25, r24
   15d5e:	21 f4       	brne	.+8      	; 0x15d68 <_key_scan+0x68>
   15d60:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15d62:	a4 17       	cp	r26, r20
   15d64:	b5 07       	cpc	r27, r21
   15d66:	81 f7       	brne	.-32     	; 0x15d48 <_key_scan+0x48>
char _key_scan(char __select){
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
		__key = _key_hit();
		__key = _key_crr(__key);
   15d68:	89 2f       	mov	r24, r25
   15d6a:	0e 94 bf ad 	call	0x15b7e	; 0x15b7e <_key_crr>
   15d6e:	28 2f       	mov	r18, r24

		if(__key!=_KEY_NULL){
   15d70:	88 23       	and	r24, r24
   15d72:	09 f4       	brne	.+2      	; 0x15d76 <_key_scan+0x76>
   15d74:	85 c0       	rjmp	.+266    	; 0x15e80 <_key_scan+0x180>
			_LIGHT_SET;
   15d76:	91 e0       	ldi	r25, 0x01	; 1
   15d78:	90 93 bf 03 	sts	0x03BF, r25
   15d7c:	10 92 c0 03 	sts	0x03C0, r1
   15d80:	80 91 65 00 	lds	r24, 0x0065
   15d84:	8d 7f       	andi	r24, 0xFD	; 253
   15d86:	80 93 65 00 	sts	0x0065, r24
			if(__sec_par)
   15d8a:	80 91 99 04 	lds	r24, 0x0499
   15d8e:	88 23       	and	r24, r24
   15d90:	31 f0       	breq	.+12     	; 0x15d9e <_key_scan+0x9e>
				_SEC_ON;
   15d92:	90 93 c7 03 	sts	0x03C7, r25
   15d96:	10 92 ff 03 	sts	0x03FF, r1
   15d9a:	10 92 c8 03 	sts	0x03C8, r1

			if(_IS1st){
   15d9e:	80 91 c1 03 	lds	r24, 0x03C1
   15da2:	88 23       	and	r24, r24
   15da4:	71 f4       	brne	.+28     	; 0x15dc2 <_key_scan+0xc2>
				if(	__key == _KEY_CANCEL || __key == _KEY_ENTER)
   15da6:	27 3e       	cpi	r18, 0xE7	; 231
   15da8:	11 f0       	breq	.+4      	; 0x15dae <_key_scan+0xae>
   15daa:	27 3b       	cpi	r18, 0xB7	; 183
   15dac:	31 f4       	brne	.+12     	; 0x15dba <_key_scan+0xba>
					if(__lock_num)
   15dae:	80 91 be 03 	lds	r24, 0x03BE
   15db2:	88 23       	and	r24, r24
   15db4:	11 f0       	breq	.+4      	; 0x15dba <_key_scan+0xba>
						__lock_num = 0;
   15db6:	10 92 be 03 	sts	0x03BE, r1
				_PAD_2nd;
   15dba:	81 e0       	ldi	r24, 0x01	; 1
   15dbc:	80 93 c1 03 	sts	0x03C1, r24
   15dc0:	59 c0       	rjmp	.+178    	; 0x15e74 <_key_scan+0x174>
				//_spi_tx(0x24, _SPI_SLAVE, "~");
				_delay_ms(5);
				return __key;
			}
			if(_IS2nd){
   15dc2:	81 30       	cpi	r24, 0x01	; 1
   15dc4:	09 f0       	breq	.+2      	; 0x15dc8 <_key_scan+0xc8>
   15dc6:	5c c0       	rjmp	.+184    	; 0x15e80 <_key_scan+0x180>
				if(__select==_PAD_MULTI){
   15dc8:	12 30       	cpi	r17, 0x02	; 2
   15dca:	21 f5       	brne	.+72     	; 0x15e14 <_key_scan+0x114>
					if(	__key==_KEY_0 || __key==_KEY_1 || __key==_KEY_2 || __key==_KEY_3||
   15dcc:	27 3d       	cpi	r18, 0xD7	; 215
   15dce:	91 f0       	breq	.+36     	; 0x15df4 <_key_scan+0xf4>
   15dd0:	2e 3e       	cpi	r18, 0xEE	; 238
   15dd2:	81 f0       	breq	.+32     	; 0x15df4 <_key_scan+0xf4>
   15dd4:	2e 3d       	cpi	r18, 0xDE	; 222
   15dd6:	71 f0       	breq	.+28     	; 0x15df4 <_key_scan+0xf4>
   15dd8:	2e 3b       	cpi	r18, 0xBE	; 190
   15dda:	61 f0       	breq	.+24     	; 0x15df4 <_key_scan+0xf4>
   15ddc:	2d 3e       	cpi	r18, 0xED	; 237
   15dde:	51 f0       	breq	.+20     	; 0x15df4 <_key_scan+0xf4>
   15de0:	2d 3d       	cpi	r18, 0xDD	; 221
   15de2:	41 f0       	breq	.+16     	; 0x15df4 <_key_scan+0xf4>
   15de4:	2d 3b       	cpi	r18, 0xBD	; 189
   15de6:	31 f0       	breq	.+12     	; 0x15df4 <_key_scan+0xf4>
   15de8:	2b 3e       	cpi	r18, 0xEB	; 235
   15dea:	21 f0       	breq	.+8      	; 0x15df4 <_key_scan+0xf4>
   15dec:	2b 3d       	cpi	r18, 0xDB	; 219
   15dee:	11 f0       	breq	.+4      	; 0x15df4 <_key_scan+0xf4>
   15df0:	2b 3b       	cpi	r18, 0xBB	; 187
   15df2:	81 f4       	brne	.+32     	; 0x15e14 <_key_scan+0x114>
						__key==_KEY_4 || __key==_KEY_5 || __key==_KEY_6 ||
						__key==_KEY_7 || __key==_KEY_8 || __key==_KEY_9){
						if(__lock_num){
   15df4:	80 91 be 03 	lds	r24, 0x03BE
   15df8:	88 23       	and	r24, r24
   15dfa:	49 f0       	breq	.+18     	; 0x15e0e <_key_scan+0x10e>
							_SHIFT_SET;
   15dfc:	81 e0       	ldi	r24, 0x01	; 1
   15dfe:	80 93 c2 03 	sts	0x03C2, r24
   15e02:	10 92 c3 03 	sts	0x03C3, r1
							CURSOR_HIDE;
   15e06:	8c e0       	ldi	r24, 0x0C	; 12
   15e08:	0e 94 33 ac 	call	0x15866	; 0x15866 <lcd_command>
   15e0c:	03 c0       	rjmp	.+6      	; 0x15e14 <_key_scan+0x114>
						}
						else
							__lock_num = 1;
   15e0e:	81 e0       	ldi	r24, 0x01	; 1
   15e10:	80 93 be 03 	sts	0x03BE, r24
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15e14:	ff ee       	ldi	r31, 0xEF	; 239
   15e16:	8f 2e       	mov	r8, r31
   15e18:	ef ed       	ldi	r30, 0xDF	; 223
   15e1a:	9e 2e       	mov	r9, r30
   15e1c:	7f eb       	ldi	r23, 0xBF	; 191
   15e1e:	a7 2e       	mov	r10, r23
   15e20:	6f e7       	ldi	r22, 0x7F	; 127
   15e22:	b6 2e       	mov	r11, r22
   15e24:	6e 01       	movw	r12, r28
   15e26:	08 94       	sec
   15e28:	c1 1c       	adc	r12, r1
   15e2a:	d1 1c       	adc	r13, r1
   15e2c:	0a ef       	ldi	r16, 0xFA	; 250
   15e2e:	10 e0       	ldi	r17, 0x00	; 0

	for(i=0; i<4; i++){
   15e30:	55 e0       	ldi	r21, 0x05	; 5
   15e32:	e5 2e       	mov	r14, r21
   15e34:	f1 2c       	mov	r15, r1
   15e36:	ec 0e       	add	r14, r28
   15e38:	fd 1e       	adc	r15, r29
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15e3a:	89 82       	std	Y+1, r8	; 0x01
   15e3c:	9a 82       	std	Y+2, r9	; 0x02
   15e3e:	ab 82       	std	Y+3, r10	; 0x03
   15e40:	bc 82       	std	Y+4, r11	; 0x04
   15e42:	d6 01       	movw	r26, r12
   15e44:	c8 01       	movw	r24, r16
   15e46:	01 97       	sbiw	r24, 0x01	; 1
   15e48:	f1 f7       	brne	.-4      	; 0x15e46 <_key_scan+0x146>

	for(i=0; i<4; i++){
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15e4a:	8c 91       	ld	r24, X
   15e4c:	80 93 62 00 	sts	0x0062, r24
   15e50:	f8 01       	movw	r30, r16
   15e52:	31 97       	sbiw	r30, 0x01	; 1
   15e54:	f1 f7       	brne	.-4      	; 0x15e52 <_key_scan+0x152>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15e56:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15e58:	98 17       	cp	r25, r24
   15e5a:	21 f4       	brne	.+8      	; 0x15e64 <_key_scan+0x164>
   15e5c:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15e5e:	ae 15       	cp	r26, r14
   15e60:	bf 05       	cpc	r27, r15
   15e62:	81 f7       	brne	.-32     	; 0x15e44 <_key_scan+0x144>
							__lock_num = 1;
					}
				}
				do{
					__key = _key_hit();
					__key = _key_crr(__key);
   15e64:	89 2f       	mov	r24, r25
   15e66:	0e 94 bf ad 	call	0x15b7e	; 0x15b7e <_key_crr>
   15e6a:	28 2f       	mov	r18, r24
				}while(__key!=_KEY_NULL);
   15e6c:	88 23       	and	r24, r24
   15e6e:	29 f7       	brne	.-54     	; 0x15e3a <_key_scan+0x13a>
				_PAD_1st;
   15e70:	10 92 c1 03 	sts	0x03C1, r1
   15e74:	82 ee       	ldi	r24, 0xE2	; 226
   15e76:	94 e0       	ldi	r25, 0x04	; 4
   15e78:	01 97       	sbiw	r24, 0x01	; 1
   15e7a:	f1 f7       	brne	.-4      	; 0x15e78 <_key_scan+0x178>
   15e7c:	03 c0       	rjmp	.+6      	; 0x15e84 <_key_scan+0x184>
				_delay_ms(5);
				return _KEY_NULL;
   15e7e:	20 e0       	ldi	r18, 0x00	; 0
			}
		}
	}
	_PAD_1st;
   15e80:	10 92 c1 03 	sts	0x03C1, r1
	return __key;
}
   15e84:	82 2f       	mov	r24, r18
   15e86:	0f 90       	pop	r0
   15e88:	0f 90       	pop	r0
   15e8a:	0f 90       	pop	r0
   15e8c:	0f 90       	pop	r0
   15e8e:	cf 91       	pop	r28
   15e90:	df 91       	pop	r29
   15e92:	1f 91       	pop	r17
   15e94:	0f 91       	pop	r16
   15e96:	ff 90       	pop	r15
   15e98:	ef 90       	pop	r14
   15e9a:	df 90       	pop	r13
   15e9c:	cf 90       	pop	r12
   15e9e:	bf 90       	pop	r11
   15ea0:	af 90       	pop	r10
   15ea2:	9f 90       	pop	r9
   15ea4:	8f 90       	pop	r8
   15ea6:	08 95       	ret

00015ea8 <_spi_init>:
unsigned char	__spi_i;
unsigned char	__spi_isstart = 0;
unsigned char	__spi_ismessage = 0;

void _spi_init(unsigned char __mode, unsigned char __interrupt){
	if(__mode){
   15ea8:	88 23       	and	r24, r24
   15eaa:	41 f0       	breq	.+16     	; 0x15ebc <_spi_init+0x14>
		_SPI_DDR = (1 << _SPI_MOSI) | (1 << _SPI_SCK);
   15eac:	86 e0       	ldi	r24, 0x06	; 6
   15eae:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   15eb0:	66 23       	and	r22, r22
   15eb2:	11 f0       	breq	.+4      	; 0x15eb8 <_spi_init+0x10>
			SPCR = (1 << SPIE) | (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   15eb4:	82 ed       	ldi	r24, 0xD2	; 210
   15eb6:	09 c0       	rjmp	.+18     	; 0x15eca <_spi_init+0x22>
		else
			SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   15eb8:	82 e5       	ldi	r24, 0x52	; 82
   15eba:	07 c0       	rjmp	.+14     	; 0x15eca <_spi_init+0x22>
	}
	else{
		_SPI_DDR = (1 << _SPI_MISO);
   15ebc:	88 e0       	ldi	r24, 0x08	; 8
   15ebe:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   15ec0:	66 23       	and	r22, r22
   15ec2:	11 f0       	breq	.+4      	; 0x15ec8 <_spi_init+0x20>
			SPCR = (1 << SPIE) | (1 << SPE);
   15ec4:	80 ec       	ldi	r24, 0xC0	; 192
   15ec6:	01 c0       	rjmp	.+2      	; 0x15eca <_spi_init+0x22>
		else
			SPCR = (1 << SPE);
   15ec8:	80 e4       	ldi	r24, 0x40	; 64
   15eca:	8d b9       	out	0x0d, r24	; 13
   15ecc:	08 95       	ret

00015ece <_spi_enable>:
	}
}

void _spi_enable(unsigned char __select){
	if(__select == 0){
   15ece:	88 23       	and	r24, r24
   15ed0:	19 f4       	brne	.+6      	; 0x15ed8 <_spi_enable+0xa>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   15ed2:	db 9a       	sbi	0x1b, 3	; 27
		sbi(_MMC_PORT, _MMC_PIN);
   15ed4:	1b 9a       	sbi	0x03, 3	; 3
   15ed6:	08 95       	ret
	}
	if(__select == 1){
   15ed8:	81 30       	cpi	r24, 0x01	; 1
   15eda:	39 f4       	brne	.+14     	; 0x15eea <_spi_enable+0x1c>
		sbi(_MMC_PORT, _MMC_PIN);
   15edc:	1b 9a       	sbi	0x03, 3	; 3
   15ede:	82 ee       	ldi	r24, 0xE2	; 226
   15ee0:	94 e0       	ldi	r25, 0x04	; 4
   15ee2:	01 97       	sbiw	r24, 0x01	; 1
   15ee4:	f1 f7       	brne	.-4      	; 0x15ee2 <_spi_enable+0x14>
		_delay_ms(5);
		cbi(_SLAVE_PORT, _SLAVE_PIN);
   15ee6:	db 98       	cbi	0x1b, 3	; 27
   15ee8:	08 95       	ret
	}
	if(__select == 2){
   15eea:	82 30       	cpi	r24, 0x02	; 2
   15eec:	31 f4       	brne	.+12     	; 0x15efa <_spi_enable+0x2c>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   15eee:	db 9a       	sbi	0x1b, 3	; 27
   15ef0:	82 ee       	ldi	r24, 0xE2	; 226
   15ef2:	94 e0       	ldi	r25, 0x04	; 4
   15ef4:	01 97       	sbiw	r24, 0x01	; 1
   15ef6:	f1 f7       	brne	.-4      	; 0x15ef4 <_spi_enable+0x26>
		_delay_ms(5);
		cbi(_MMC_PORT, _MMC_PIN);
   15ef8:	1b 98       	cbi	0x03, 3	; 3
   15efa:	08 95       	ret

00015efc <_spi>:
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15efc:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15efe:	77 9b       	sbis	0x0e, 7	; 14
   15f00:	fe cf       	rjmp	.-4      	; 0x15efe <_spi+0x2>
	return SPDR;
   15f02:	8f b1       	in	r24, 0x0f	; 15
}
   15f04:	08 95       	ret

00015f06 <_spi_rx>:


unsigned char _spi_rx(unsigned char __select){
	unsigned char __i = 0;

	_spi_enable(__select);
   15f06:	0e 94 67 af 	call	0x15ece	; 0x15ece <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f0a:	81 e4       	ldi	r24, 0x41	; 65
   15f0c:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f0e:	77 9b       	sbis	0x0e, 7	; 14
   15f10:	fe cf       	rjmp	.-4      	; 0x15f0e <_spi_rx+0x8>
	return SPDR;
   15f12:	8f b1       	in	r24, 0x0f	; 15
unsigned char _spi_rx(unsigned char __select){
	unsigned char __i = 0;

	_spi_enable(__select);

		__spi_char = _spi(0x41);
   15f14:	80 93 de 0e 	sts	0x0EDE, r24
		if(__spi_char==0xff) return 0;
   15f18:	8f 3f       	cpi	r24, 0xFF	; 255
   15f1a:	11 f4       	brne	.+4      	; 0x15f20 <_spi_rx+0x1a>
   15f1c:	80 e0       	ldi	r24, 0x00	; 0
   15f1e:	08 95       	ret
		if(__spi_char==0x55) return 1;
   15f20:	85 35       	cpi	r24, 0x55	; 85
   15f22:	11 f4       	brne	.+4      	; 0x15f28 <_spi_rx+0x22>
   15f24:	81 e0       	ldi	r24, 0x01	; 1
   15f26:	08 95       	ret
		if(__spi_char==0x02) return 2;
   15f28:	82 30       	cpi	r24, 0x02	; 2
   15f2a:	21 f0       	breq	.+8      	; 0x15f34 <_spi_rx+0x2e>
	_spi_enable(_SPI_NONE);
   15f2c:	80 e0       	ldi	r24, 0x00	; 0
   15f2e:	0e 94 67 af 	call	0x15ece	; 0x15ece <_spi_enable>
   15f32:	85 e1       	ldi	r24, 0x15	; 21
	return 21;
}
   15f34:	08 95       	ret

00015f36 <_spi_tx>:

unsigned char _spi_tx(unsigned char __command, unsigned char __select, char* __message){
   15f36:	1f 93       	push	r17
   15f38:	cf 93       	push	r28
   15f3a:	df 93       	push	r29
   15f3c:	18 2f       	mov	r17, r24
   15f3e:	86 2f       	mov	r24, r22
   15f40:	ea 01       	movw	r28, r20
	_spi_enable(__select);
   15f42:	0e 94 67 af 	call	0x15ece	; 0x15ece <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f46:	8b e7       	ldi	r24, 0x7B	; 123
   15f48:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f4a:	77 9b       	sbis	0x0e, 7	; 14
   15f4c:	fe cf       	rjmp	.-4      	; 0x15f4a <_spi_tx+0x14>
	return SPDR;
   15f4e:	8f b1       	in	r24, 0x0f	; 15
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f50:	1f b9       	out	0x0f, r17	; 15
	while(!(SPSR & (1 << SPIF)));
   15f52:	77 9b       	sbis	0x0e, 7	; 14
   15f54:	fe cf       	rjmp	.-4      	; 0x15f52 <_spi_tx+0x1c>
	return SPDR;
   15f56:	8f b1       	in	r24, 0x0f	; 15
unsigned char _spi_tx(unsigned char __command, unsigned char __select, char* __message){
	_spi_enable(__select);
	_spi(0x7B);
	_spi(__command);

	if(strlen(__message) > 0){
   15f58:	88 81       	ld	r24, Y
   15f5a:	88 23       	and	r24, r24
   15f5c:	91 f0       	breq	.+36     	; 0x15f82 <_spi_tx+0x4c>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f5e:	88 e2       	ldi	r24, 0x28	; 40
   15f60:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f62:	77 9b       	sbis	0x0e, 7	; 14
   15f64:	fe cf       	rjmp	.-4      	; 0x15f62 <_spi_tx+0x2c>
   15f66:	04 c0       	rjmp	.+8      	; 0x15f70 <_spi_tx+0x3a>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f68:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f6a:	77 9b       	sbis	0x0e, 7	; 14
   15f6c:	fe cf       	rjmp	.-4      	; 0x15f6a <_spi_tx+0x34>
	_spi(__command);

	if(strlen(__message) > 0){
		_spi(0x28);
		while(*__message)
			_spi(*__message++);
   15f6e:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
	while(!(SPSR & (1 << SPIF)));
	return SPDR;
   15f70:	8f b1       	in	r24, 0x0f	; 15
	_spi(0x7B);
	_spi(__command);

	if(strlen(__message) > 0){
		_spi(0x28);
		while(*__message)
   15f72:	88 81       	ld	r24, Y
   15f74:	88 23       	and	r24, r24
   15f76:	c1 f7       	brne	.-16     	; 0x15f68 <_spi_tx+0x32>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f78:	89 e2       	ldi	r24, 0x29	; 41
   15f7a:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f7c:	77 9b       	sbis	0x0e, 7	; 14
   15f7e:	fe cf       	rjmp	.-4      	; 0x15f7c <_spi_tx+0x46>
	return SPDR;
   15f80:	8f b1       	in	r24, 0x0f	; 15
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f82:	8d e7       	ldi	r24, 0x7D	; 125
   15f84:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f86:	77 9b       	sbis	0x0e, 7	; 14
   15f88:	fe cf       	rjmp	.-4      	; 0x15f86 <_spi_tx+0x50>
	return SPDR;
   15f8a:	8f b1       	in	r24, 0x0f	; 15
			_spi(*__message++);
		_spi(0x29);
	}

	_spi(0x7D);
	_spi_enable(_SPI_NONE);
   15f8c:	80 e0       	ldi	r24, 0x00	; 0
   15f8e:	0e 94 67 af 	call	0x15ece	; 0x15ece <_spi_enable>
	return 0;
}
   15f92:	80 e0       	ldi	r24, 0x00	; 0
   15f94:	df 91       	pop	r29
   15f96:	cf 91       	pop	r28
   15f98:	1f 91       	pop	r17
   15f9a:	08 95       	ret

00015f9c <_spi_txnum>:

unsigned char _spi_txnum(unsigned char __command, unsigned char __select, char* __message, unsigned char __num){
   15f9c:	ff 92       	push	r15
   15f9e:	0f 93       	push	r16
   15fa0:	1f 93       	push	r17
   15fa2:	86 2f       	mov	r24, r22
   15fa4:	14 2f       	mov	r17, r20
   15fa6:	05 2f       	mov	r16, r21
   15fa8:	f2 2e       	mov	r15, r18
	unsigned char	__i;

	_spi_enable(__select);
   15faa:	0e 94 67 af 	call	0x15ece	; 0x15ece <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15fae:	82 e0       	ldi	r24, 0x02	; 2
   15fb0:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15fb2:	77 9b       	sbis	0x0e, 7	; 14
   15fb4:	fe cf       	rjmp	.-4      	; 0x15fb2 <_spi_txnum+0x16>
	return SPDR;
   15fb6:	8f b1       	in	r24, 0x0f	; 15
	unsigned char	__i;

	_spi_enable(__select);
	_spi(0x02);

	if(__num > 0){
   15fb8:	ff 20       	and	r15, r15
   15fba:	79 f0       	breq	.+30     	; 0x15fda <_spi_txnum+0x3e>
   15fbc:	81 2f       	mov	r24, r17
   15fbe:	90 2f       	mov	r25, r16
   15fc0:	9c 01       	movw	r18, r24
   15fc2:	f9 01       	movw	r30, r18
   15fc4:	90 e0       	ldi	r25, 0x00	; 0
   15fc6:	07 c0       	rjmp	.+14     	; 0x15fd6 <_spi_txnum+0x3a>
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
   15fc8:	80 81       	ld	r24, Z
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15fca:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15fcc:	77 9b       	sbis	0x0e, 7	; 14
   15fce:	fe cf       	rjmp	.-4      	; 0x15fcc <_spi_txnum+0x30>
	return SPDR;
   15fd0:	8f b1       	in	r24, 0x0f	; 15

	_spi_enable(__select);
	_spi(0x02);

	if(__num > 0){
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
   15fd2:	9f 5f       	subi	r25, 0xFF	; 255
   15fd4:	31 96       	adiw	r30, 0x01	; 1
   15fd6:	9f 15       	cp	r25, r15
   15fd8:	b8 f3       	brcs	.-18     	; 0x15fc8 <_spi_txnum+0x2c>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15fda:	83 e0       	ldi	r24, 0x03	; 3
   15fdc:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15fde:	77 9b       	sbis	0x0e, 7	; 14
   15fe0:	fe cf       	rjmp	.-4      	; 0x15fde <_spi_txnum+0x42>
	return SPDR;
   15fe2:	8f b1       	in	r24, 0x0f	; 15
	if(__num > 0){
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
				}// for

	_spi(0x03);
	_spi_enable(_SPI_NONE);
   15fe4:	80 e0       	ldi	r24, 0x00	; 0
   15fe6:	0e 94 67 af 	call	0x15ece	; 0x15ece <_spi_enable>
	return 0;
}
   15fea:	80 e0       	ldi	r24, 0x00	; 0
   15fec:	1f 91       	pop	r17
   15fee:	0f 91       	pop	r16
   15ff0:	ff 90       	pop	r15
   15ff2:	08 95       	ret

00015ff4 <_spi_interrupt>:

unsigned char _spi_interrupt(void){
	__spi_char = SPDR;
   15ff4:	9f b1       	in	r25, 0x0f	; 15
   15ff6:	90 93 de 0e 	sts	0x0EDE, r25

	if(__spi_char == 0xFF){
   15ffa:	9f 3f       	cpi	r25, 0xFF	; 255
   15ffc:	e9 f4       	brne	.+58     	; 0x16038 <_spi_interrupt+0x44>
		if(__spi_istransmit){
   15ffe:	80 91 fb 03 	lds	r24, 0x03FB
   16002:	88 23       	and	r24, r24
   16004:	b9 f0       	breq	.+46     	; 0x16034 <_spi_interrupt+0x40>
			SPDR = __command[__spi_i];
   16006:	90 91 dd 0e 	lds	r25, 0x0EDD
   1600a:	e9 2f       	mov	r30, r25
   1600c:	f0 e0       	ldi	r31, 0x00	; 0
   1600e:	e7 53       	subi	r30, 0x37	; 55
   16010:	fc 4f       	sbci	r31, 0xFC	; 252
   16012:	80 81       	ld	r24, Z
   16014:	8f b9       	out	0x0f, r24	; 15
			if(__command[__spi_i] == 0x7D){
   16016:	8d 37       	cpi	r24, 0x7D	; 125
   16018:	19 f4       	brne	.+6      	; 0x16020 <_spi_interrupt+0x2c>
				__spi_i = 0;
   1601a:	10 92 dd 0e 	sts	0x0EDD, r1
   1601e:	07 c0       	rjmp	.+14     	; 0x1602e <_spi_interrupt+0x3a>
				__spi_istransmit = 0;
			}
			else{
				__spi_i++;
   16020:	89 2f       	mov	r24, r25
   16022:	8f 5f       	subi	r24, 0xFF	; 255
   16024:	80 93 dd 0e 	sts	0x0EDD, r24
				if(__spi_i == _MAX_COMMAND)
   16028:	82 33       	cpi	r24, 0x32	; 50
   1602a:	09 f0       	breq	.+2      	; 0x1602e <_spi_interrupt+0x3a>
   1602c:	3f c0       	rjmp	.+126    	; 0x160ac <_spi_interrupt+0xb8>
					__spi_istransmit = 0;
   1602e:	10 92 fb 03 	sts	0x03FB, r1
   16032:	3c c0       	rjmp	.+120    	; 0x160ac <_spi_interrupt+0xb8>
			}
		}
		else
			SPDR = 0xFF;
   16034:	9f b9       	out	0x0f, r25	; 15
   16036:	3a c0       	rjmp	.+116    	; 0x160ac <_spi_interrupt+0xb8>
	}
	else{
		if(__spi_char == 0x7D && __spi_isstart){
   16038:	9d 37       	cpi	r25, 0x7D	; 125
   1603a:	69 f4       	brne	.+26     	; 0x16056 <_spi_interrupt+0x62>
   1603c:	80 91 c4 03 	lds	r24, 0x03C4
   16040:	88 23       	and	r24, r24
   16042:	49 f0       	breq	.+18     	; 0x16056 <_spi_interrupt+0x62>
			__spi_isstart = 0;
   16044:	10 92 c4 03 	sts	0x03C4, r1
			__spi_ismessage = 0;
   16048:	10 92 c5 03 	sts	0x03C5, r1
			__spi_i = 0;
   1604c:	10 92 dd 0e 	sts	0x0EDD, r1
			__command_flag = 1;
   16050:	81 e0       	ldi	r24, 0x01	; 1
   16052:	80 93 fe 03 	sts	0x03FE, r24
		}
		if(__spi_isstart && __spi_ismessage){
   16056:	20 91 c4 03 	lds	r18, 0x03C4
   1605a:	22 23       	and	r18, r18
   1605c:	f1 f0       	breq	.+60     	; 0x1609a <_spi_interrupt+0xa6>
   1605e:	80 91 c5 03 	lds	r24, 0x03C5
   16062:	88 23       	and	r24, r24
   16064:	29 f1       	breq	.+74     	; 0x160b0 <_spi_interrupt+0xbc>
			if(__spi_char != 0x29){
   16066:	99 32       	cpi	r25, 0x29	; 41
   16068:	c1 f0       	breq	.+48     	; 0x1609a <_spi_interrupt+0xa6>
				__package[__spi_i] = __spi_char;
   1606a:	80 91 dd 0e 	lds	r24, 0x0EDD
   1606e:	e8 2f       	mov	r30, r24
   16070:	f0 e0       	ldi	r31, 0x00	; 0
   16072:	ed 5f       	subi	r30, 0xFD	; 253
   16074:	fb 4f       	sbci	r31, 0xFB	; 251
   16076:	90 83       	st	Z, r25
				__package[__spi_i + 1] = '\0';
   16078:	11 82       	std	Z+1, r1	; 0x01
				__spi_i++;
   1607a:	8f 5f       	subi	r24, 0xFF	; 255
   1607c:	80 93 dd 0e 	sts	0x0EDD, r24
				if(__spi_i == _MAX_PACKAGE)
   16080:	82 38       	cpi	r24, 0x82	; 130
   16082:	59 f4       	brne	.+22     	; 0x1609a <_spi_interrupt+0xa6>
					__spi_i = 0;
   16084:	10 92 dd 0e 	sts	0x0EDD, r1
   16088:	08 c0       	rjmp	.+16     	; 0x1609a <_spi_interrupt+0xa6>
			}
		}
		if(__spi_isstart && !__spi_ismessage){
			if(__spi_char == 0x28){
				__spi_ismessage = 1;
   1608a:	81 e0       	ldi	r24, 0x01	; 1
   1608c:	80 93 c5 03 	sts	0x03C5, r24
				__spi_i = 0;
   16090:	10 92 dd 0e 	sts	0x0EDD, r1
   16094:	0b c0       	rjmp	.+22     	; 0x160ac <_spi_interrupt+0xb8>
			}
			else
				__command_set = __spi_char;
   16096:	90 93 00 04 	sts	0x0400, r25
		}
		if(__spi_char == 0x7B && !__spi_isstart){
   1609a:	9b 37       	cpi	r25, 0x7B	; 123
   1609c:	39 f4       	brne	.+14     	; 0x160ac <_spi_interrupt+0xb8>
   1609e:	22 23       	and	r18, r18
   160a0:	29 f4       	brne	.+10     	; 0x160ac <_spi_interrupt+0xb8>
			__spi_isstart = 1;
   160a2:	81 e0       	ldi	r24, 0x01	; 1
   160a4:	80 93 c4 03 	sts	0x03C4, r24
			__spi_ismessage = 0;
   160a8:	10 92 c5 03 	sts	0x03C5, r1
		}
	}

	return 0;
}
   160ac:	80 e0       	ldi	r24, 0x00	; 0
   160ae:	08 95       	ret
				if(__spi_i == _MAX_PACKAGE)
					__spi_i = 0;
			}
		}
		if(__spi_isstart && !__spi_ismessage){
			if(__spi_char == 0x28){
   160b0:	98 32       	cpi	r25, 0x28	; 40
   160b2:	89 f7       	brne	.-30     	; 0x16096 <_spi_interrupt+0xa2>
   160b4:	ea cf       	rjmp	.-44     	; 0x1608a <_spi_interrupt+0x96>

000160b6 <_spi_command>:
	}

	return 0;
}

void _spi_command(unsigned char __cmd, char* __cell){
   160b6:	fb 01       	movw	r30, r22
	unsigned char __i = 0;

	__command[__i++] = 0x7B;
   160b8:	9b e7       	ldi	r25, 0x7B	; 123
   160ba:	90 93 c9 03 	sts	0x03C9, r25
	__command[__i++] = __cmd;
   160be:	80 93 ca 03 	sts	0x03CA, r24

	if(strlen(__cell) > 0){
   160c2:	80 81       	ld	r24, Z
   160c4:	88 23       	and	r24, r24
   160c6:	11 f4       	brne	.+4      	; 0x160cc <_spi_command+0x16>
   160c8:	92 e0       	ldi	r25, 0x02	; 2
   160ca:	16 c0       	rjmp	.+44     	; 0x160f8 <_spi_command+0x42>
		__command[__i++] = 0x28;
   160cc:	88 e2       	ldi	r24, 0x28	; 40
   160ce:	80 93 cb 03 	sts	0x03CB, r24
   160d2:	83 e0       	ldi	r24, 0x03	; 3
   160d4:	05 c0       	rjmp	.+10     	; 0x160e0 <_spi_command+0x2a>

		while(*__cell)
			__command[__i++] = *__cell++;
   160d6:	a7 53       	subi	r26, 0x37	; 55
   160d8:	bc 4f       	sbci	r27, 0xFC	; 252
   160da:	9c 93       	st	X, r25
   160dc:	82 2f       	mov	r24, r18
   160de:	31 96       	adiw	r30, 0x01	; 1
	__command[__i++] = __cmd;

	if(strlen(__cell) > 0){
		__command[__i++] = 0x28;

		while(*__cell)
   160e0:	90 81       	ld	r25, Z
   160e2:	a8 2f       	mov	r26, r24
   160e4:	b0 e0       	ldi	r27, 0x00	; 0
   160e6:	28 2f       	mov	r18, r24
   160e8:	2f 5f       	subi	r18, 0xFF	; 255
   160ea:	99 23       	and	r25, r25
   160ec:	a1 f7       	brne	.-24     	; 0x160d6 <_spi_command+0x20>
			__command[__i++] = *__cell++;

		__command[__i++] = 0x29;
   160ee:	a7 53       	subi	r26, 0x37	; 55
   160f0:	bc 4f       	sbci	r27, 0xFC	; 252
   160f2:	89 e2       	ldi	r24, 0x29	; 41
   160f4:	8c 93       	st	X, r24
   160f6:	92 2f       	mov	r25, r18
	}

	__command[__i++] = 0x7D;
   160f8:	e9 2f       	mov	r30, r25
   160fa:	f0 e0       	ldi	r31, 0x00	; 0
   160fc:	e7 53       	subi	r30, 0x37	; 55
   160fe:	fc 4f       	sbci	r31, 0xFC	; 252
   16100:	8d e7       	ldi	r24, 0x7D	; 125
   16102:	80 83       	st	Z, r24
	__command[__i++] = '\0';
   16104:	9f 5f       	subi	r25, 0xFF	; 255
   16106:	e9 2f       	mov	r30, r25
   16108:	f0 e0       	ldi	r31, 0x00	; 0
   1610a:	e7 53       	subi	r30, 0x37	; 55
   1610c:	fc 4f       	sbci	r31, 0xFC	; 252
   1610e:	10 82       	st	Z, r1
}
   16110:	08 95       	ret

00016112 <_rtc>:

#include <compat/twi.h>

#include "RTC.h"

unsigned char _rtc(int __addr, int __len, char* __datetime, unsigned char __dir){
   16112:	98 2f       	mov	r25, r24
	int				__twcr;
	unsigned char	__i = 0;
	
	if(__dir){
   16114:	22 23       	and	r18, r18
   16116:	09 f4       	brne	.+2      	; 0x1611a <_rtc+0x8>
   16118:	49 c0       	rjmp	.+146    	; 0x161ac <_rtc+0x9a>
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   1611a:	84 ea       	ldi	r24, 0xA4	; 164
   1611c:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16120:	80 91 74 00 	lds	r24, 0x0074
   16124:	87 ff       	sbrs	r24, 7
   16126:	fc cf       	rjmp	.-8      	; 0x16120 <_rtc+0xe>
		if(TW_STATUS != TW_START)
   16128:	80 91 71 00 	lds	r24, 0x0071
   1612c:	88 7f       	andi	r24, 0xF8	; 248
   1612e:	88 30       	cpi	r24, 0x08	; 8
   16130:	09 f0       	breq	.+2      	; 0x16134 <_rtc+0x22>
   16132:	af c0       	rjmp	.+350    	; 0x16292 <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   16134:	80 ed       	ldi	r24, 0xD0	; 208
   16136:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   1613a:	84 e8       	ldi	r24, 0x84	; 132
   1613c:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16140:	80 91 74 00 	lds	r24, 0x0074
   16144:	87 ff       	sbrs	r24, 7
   16146:	fc cf       	rjmp	.-8      	; 0x16140 <_rtc+0x2e>
		if(TW_STATUS != TW_MT_SLA_ACK)
   16148:	80 91 71 00 	lds	r24, 0x0071
   1614c:	88 7f       	andi	r24, 0xF8	; 248
   1614e:	88 31       	cpi	r24, 0x18	; 24
   16150:	09 f0       	breq	.+2      	; 0x16154 <_rtc+0x42>
   16152:	9f c0       	rjmp	.+318    	; 0x16292 <_rtc+0x180>
			return 1;

		TWDR = __addr;
   16154:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   16158:	84 e8       	ldi	r24, 0x84	; 132
   1615a:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1615e:	80 91 74 00 	lds	r24, 0x0074
   16162:	87 ff       	sbrs	r24, 7
   16164:	fc cf       	rjmp	.-8      	; 0x1615e <_rtc+0x4c>
		if(TW_STATUS != TW_MT_DATA_ACK)
   16166:	80 91 71 00 	lds	r24, 0x0071
   1616a:	88 7f       	andi	r24, 0xF8	; 248
   1616c:	88 32       	cpi	r24, 0x28	; 40
   1616e:	09 f0       	breq	.+2      	; 0x16172 <_rtc+0x60>
   16170:	90 c0       	rjmp	.+288    	; 0x16292 <_rtc+0x180>
   16172:	9b 01       	movw	r18, r22
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
			TWCR = _BV(TWINT) | _BV(TWEN);
   16174:	94 e8       	ldi	r25, 0x84	; 132
   16176:	14 c0       	rjmp	.+40     	; 0x161a0 <_rtc+0x8e>
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
   16178:	fa 01       	movw	r30, r20
   1617a:	e8 0f       	add	r30, r24
   1617c:	f1 1d       	adc	r31, r1
   1617e:	80 81       	ld	r24, Z
   16180:	80 93 73 00 	sts	0x0073, r24
			TWCR = _BV(TWINT) | _BV(TWEN);
   16184:	90 93 74 00 	sts	0x0074, r25
			_rtc_response;
   16188:	80 91 74 00 	lds	r24, 0x0074
   1618c:	87 ff       	sbrs	r24, 7
   1618e:	fc cf       	rjmp	.-8      	; 0x16188 <_rtc+0x76>
			if(TW_STATUS == TW_MT_DATA_NACK)
   16190:	80 91 71 00 	lds	r24, 0x0071
   16194:	88 7f       	andi	r24, 0xF8	; 248
   16196:	80 33       	cpi	r24, 0x30	; 48
   16198:	09 f4       	brne	.+2      	; 0x1619c <_rtc+0x8a>
   1619a:	7b c0       	rjmp	.+246    	; 0x16292 <_rtc+0x180>
		TWCR = _BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
   1619c:	21 50       	subi	r18, 0x01	; 1
   1619e:	30 40       	sbci	r19, 0x00	; 0
   161a0:	86 2f       	mov	r24, r22
   161a2:	82 1b       	sub	r24, r18
   161a4:	12 16       	cp	r1, r18
   161a6:	13 06       	cpc	r1, r19
   161a8:	3c f3       	brlt	.-50     	; 0x16178 <_rtc+0x66>
   161aa:	6e c0       	rjmp	.+220    	; 0x16288 <_rtc+0x176>
		}

		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
	}
	else{
		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   161ac:	84 ea       	ldi	r24, 0xA4	; 164
   161ae:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   161b2:	80 91 74 00 	lds	r24, 0x0074
   161b6:	87 ff       	sbrs	r24, 7
   161b8:	fc cf       	rjmp	.-8      	; 0x161b2 <_rtc+0xa0>
		if(TW_STATUS != TW_START)
   161ba:	80 91 71 00 	lds	r24, 0x0071
   161be:	88 7f       	andi	r24, 0xF8	; 248
   161c0:	88 30       	cpi	r24, 0x08	; 8
   161c2:	09 f0       	breq	.+2      	; 0x161c6 <_rtc+0xb4>
   161c4:	66 c0       	rjmp	.+204    	; 0x16292 <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   161c6:	80 ed       	ldi	r24, 0xD0	; 208
   161c8:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   161cc:	84 e8       	ldi	r24, 0x84	; 132
   161ce:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   161d2:	80 91 74 00 	lds	r24, 0x0074
   161d6:	87 ff       	sbrs	r24, 7
   161d8:	fc cf       	rjmp	.-8      	; 0x161d2 <_rtc+0xc0>
		if(TW_STATUS != TW_MT_SLA_ACK)
   161da:	80 91 71 00 	lds	r24, 0x0071
   161de:	88 7f       	andi	r24, 0xF8	; 248
   161e0:	88 31       	cpi	r24, 0x18	; 24
   161e2:	09 f0       	breq	.+2      	; 0x161e6 <_rtc+0xd4>
   161e4:	56 c0       	rjmp	.+172    	; 0x16292 <_rtc+0x180>
			return 1;

		TWDR = __addr;
   161e6:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   161ea:	84 e8       	ldi	r24, 0x84	; 132
   161ec:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   161f0:	80 91 74 00 	lds	r24, 0x0074
   161f4:	87 ff       	sbrs	r24, 7
   161f6:	fc cf       	rjmp	.-8      	; 0x161f0 <_rtc+0xde>
		if(TW_STATUS != TW_MT_DATA_ACK)
   161f8:	80 91 71 00 	lds	r24, 0x0071
   161fc:	88 7f       	andi	r24, 0xF8	; 248
   161fe:	88 32       	cpi	r24, 0x28	; 40
   16200:	09 f0       	breq	.+2      	; 0x16204 <_rtc+0xf2>
   16202:	47 c0       	rjmp	.+142    	; 0x16292 <_rtc+0x180>
			return 1;

		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   16204:	84 ea       	ldi	r24, 0xA4	; 164
   16206:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1620a:	80 91 74 00 	lds	r24, 0x0074
   1620e:	87 ff       	sbrs	r24, 7
   16210:	fc cf       	rjmp	.-8      	; 0x1620a <_rtc+0xf8>
		if(TW_STATUS != TW_REP_START)
   16212:	80 91 71 00 	lds	r24, 0x0071
   16216:	88 7f       	andi	r24, 0xF8	; 248
   16218:	80 31       	cpi	r24, 0x10	; 16
   1621a:	d9 f5       	brne	.+118    	; 0x16292 <_rtc+0x180>
			return 1;

		TWDR = _DS1307R;
   1621c:	81 ed       	ldi	r24, 0xD1	; 209
   1621e:	80 93 73 00 	sts	0x0073, r24
		TWCR =_BV(TWINT) | _BV(TWEN);
   16222:	84 e8       	ldi	r24, 0x84	; 132
   16224:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16228:	80 91 74 00 	lds	r24, 0x0074
   1622c:	87 ff       	sbrs	r24, 7
   1622e:	fc cf       	rjmp	.-8      	; 0x16228 <_rtc+0x116>
		if(TW_STATUS != TW_MR_SLA_ACK)
   16230:	80 91 71 00 	lds	r24, 0x0071
   16234:	88 7f       	andi	r24, 0xF8	; 248
   16236:	80 34       	cpi	r24, 0x40	; 64
   16238:	61 f5       	brne	.+88     	; 0x16292 <_rtc+0x180>
   1623a:	24 ec       	ldi	r18, 0xC4	; 196
   1623c:	30 e0       	ldi	r19, 0x00	; 0
   1623e:	90 e0       	ldi	r25, 0x00	; 0
   16240:	20 c0       	rjmp	.+64     	; 0x16282 <_rtc+0x170>
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
			if(__len == 1)
   16242:	61 30       	cpi	r22, 0x01	; 1
   16244:	71 05       	cpc	r23, r1
   16246:	11 f4       	brne	.+4      	; 0x1624c <_rtc+0x13a>
   16248:	24 e8       	ldi	r18, 0x84	; 132
   1624a:	30 e0       	ldi	r19, 0x00	; 0
				__twcr = _BV(TWINT) | _BV(TWEN);
			TWCR = __twcr;
   1624c:	20 93 74 00 	sts	0x0074, r18
			_rtc_response;
   16250:	80 91 74 00 	lds	r24, 0x0074
   16254:	87 ff       	sbrs	r24, 7
   16256:	fc cf       	rjmp	.-8      	; 0x16250 <_rtc+0x13e>
			if(TW_STATUS == TW_MR_DATA_NACK)
   16258:	80 91 71 00 	lds	r24, 0x0071
   1625c:	88 7f       	andi	r24, 0xF8	; 248
   1625e:	88 35       	cpi	r24, 0x58	; 88
   16260:	11 f4       	brne	.+4      	; 0x16266 <_rtc+0x154>
   16262:	60 e0       	ldi	r22, 0x00	; 0
   16264:	70 e0       	ldi	r23, 0x00	; 0
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
   16266:	80 91 71 00 	lds	r24, 0x0071
   1626a:	88 7f       	andi	r24, 0xF8	; 248
   1626c:	80 35       	cpi	r24, 0x50	; 80
   1626e:	39 f4       	brne	.+14     	; 0x1627e <_rtc+0x16c>
				__datetime[__i++] = TWDR;
   16270:	80 91 73 00 	lds	r24, 0x0073
   16274:	fa 01       	movw	r30, r20
   16276:	e9 0f       	add	r30, r25
   16278:	f1 1d       	adc	r31, r1
   1627a:	80 83       	st	Z, r24
   1627c:	9f 5f       	subi	r25, 0xFF	; 255
		TWCR =_BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MR_SLA_ACK)
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
   1627e:	61 50       	subi	r22, 0x01	; 1
   16280:	70 40       	sbci	r23, 0x00	; 0
   16282:	16 16       	cp	r1, r22
   16284:	17 06       	cpc	r1, r23
   16286:	ec f2       	brlt	.-70     	; 0x16242 <_rtc+0x130>
			if(TW_STATUS == TW_MR_DATA_NACK)
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
				__datetime[__i++] = TWDR;
		}
		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
   16288:	84 e9       	ldi	r24, 0x94	; 148
   1628a:	80 93 74 00 	sts	0x0074, r24
   1628e:	80 e0       	ldi	r24, 0x00	; 0
   16290:	08 95       	ret
   16292:	81 e0       	ldi	r24, 0x01	; 1
	}

    return 0;
}
   16294:	08 95       	ret

00016296 <_datetime>:

void _datetime(unsigned char __mode, char* __date, char* __time){
   16296:	ef 92       	push	r14
   16298:	ff 92       	push	r15
   1629a:	0f 93       	push	r16
   1629c:	1f 93       	push	r17
   1629e:	df 93       	push	r29
   162a0:	cf 93       	push	r28
   162a2:	cd b7       	in	r28, 0x3d	; 61
   162a4:	de b7       	in	r29, 0x3e	; 62
   162a6:	64 97       	sbiw	r28, 0x14	; 20
   162a8:	0f b6       	in	r0, 0x3f	; 63
   162aa:	f8 94       	cli
   162ac:	de bf       	out	0x3e, r29	; 62
   162ae:	0f be       	out	0x3f, r0	; 63
   162b0:	cd bf       	out	0x3d, r28	; 61
   162b2:	28 2f       	mov	r18, r24
   162b4:	8b 01       	movw	r16, r22
   162b6:	7a 01       	movw	r14, r20
   162b8:	ae 01       	movw	r20, r28
   162ba:	4f 5f       	subi	r20, 0xFF	; 255
   162bc:	5f 4f       	sbci	r21, 0xFF	; 255
	char	__datetime[20];

	if(__mode){
   162be:	88 23       	and	r24, r24
   162c0:	99 f1       	breq	.+102    	; 0x16328 <_datetime+0x92>
		__datetime[4] = (((__date[0] - 0x30) & 0x0F) << 4) + ((__date[1] - 0x30) & 0x0F);
   162c2:	fb 01       	movw	r30, r22
   162c4:	90 81       	ld	r25, Z
   162c6:	92 95       	swap	r25
   162c8:	90 7f       	andi	r25, 0xF0	; 240
   162ca:	81 81       	ldd	r24, Z+1	; 0x01
   162cc:	8f 70       	andi	r24, 0x0F	; 15
   162ce:	98 0f       	add	r25, r24
   162d0:	9d 83       	std	Y+5, r25	; 0x05
		__datetime[5] = (((__date[3] - 0x30) & 0x0F) << 4) + ((__date[4] - 0x30) & 0x0F);
   162d2:	93 81       	ldd	r25, Z+3	; 0x03
   162d4:	92 95       	swap	r25
   162d6:	90 7f       	andi	r25, 0xF0	; 240
   162d8:	84 81       	ldd	r24, Z+4	; 0x04
   162da:	8f 70       	andi	r24, 0x0F	; 15
   162dc:	98 0f       	add	r25, r24
   162de:	9e 83       	std	Y+6, r25	; 0x06
		__datetime[6] = (((__date[6] - 0x30) & 0x0F) << 4) + ((__date[7] - 0x30) & 0x0F);
   162e0:	96 81       	ldd	r25, Z+6	; 0x06
   162e2:	92 95       	swap	r25
   162e4:	90 7f       	andi	r25, 0xF0	; 240
   162e6:	87 81       	ldd	r24, Z+7	; 0x07
   162e8:	8f 70       	andi	r24, 0x0F	; 15
   162ea:	98 0f       	add	r25, r24
   162ec:	9f 83       	std	Y+7, r25	; 0x07

		__datetime[2] = (((__time[0] - 0x30) & 0x0F) << 4) + ((__time[1] - 0x30) & 0x0F);
   162ee:	f7 01       	movw	r30, r14
   162f0:	90 81       	ld	r25, Z
   162f2:	92 95       	swap	r25
   162f4:	90 7f       	andi	r25, 0xF0	; 240
   162f6:	81 81       	ldd	r24, Z+1	; 0x01
   162f8:	8f 70       	andi	r24, 0x0F	; 15
   162fa:	98 0f       	add	r25, r24
   162fc:	9b 83       	std	Y+3, r25	; 0x03
		__datetime[1] = (((__time[3] - 0x30) & 0x0F) << 4) + ((__time[4] - 0x30) & 0x0F);
   162fe:	93 81       	ldd	r25, Z+3	; 0x03
   16300:	92 95       	swap	r25
   16302:	90 7f       	andi	r25, 0xF0	; 240
   16304:	84 81       	ldd	r24, Z+4	; 0x04
   16306:	8f 70       	andi	r24, 0x0F	; 15
   16308:	98 0f       	add	r25, r24
   1630a:	9a 83       	std	Y+2, r25	; 0x02
		__datetime[0] = (((__time[6] - 0x30) & 0x0F) << 4) + ((__time[7] - 0x30) & 0x0F);
   1630c:	96 81       	ldd	r25, Z+6	; 0x06
   1630e:	92 95       	swap	r25
   16310:	90 7f       	andi	r25, 0xF0	; 240
   16312:	87 81       	ldd	r24, Z+7	; 0x07
   16314:	8f 70       	andi	r24, 0x0F	; 15
   16316:	98 0f       	add	r25, r24
   16318:	99 83       	std	Y+1, r25	; 0x01
		_rtc(0, 8, __datetime, __mode);
   1631a:	80 e0       	ldi	r24, 0x00	; 0
   1631c:	90 e0       	ldi	r25, 0x00	; 0
   1631e:	68 e0       	ldi	r22, 0x08	; 8
   16320:	70 e0       	ldi	r23, 0x00	; 0
   16322:	0e 94 89 b0 	call	0x16112	; 0x16112 <_rtc>
   16326:	4a c0       	rjmp	.+148    	; 0x163bc <_datetime+0x126>
	}
	else
		if(_rtc(0, 8, __datetime, __mode) != 1){
   16328:	80 e0       	ldi	r24, 0x00	; 0
   1632a:	90 e0       	ldi	r25, 0x00	; 0
   1632c:	68 e0       	ldi	r22, 0x08	; 8
   1632e:	70 e0       	ldi	r23, 0x00	; 0
   16330:	20 e0       	ldi	r18, 0x00	; 0
   16332:	0e 94 89 b0 	call	0x16112	; 0x16112 <_rtc>
   16336:	81 30       	cpi	r24, 0x01	; 1
   16338:	09 f4       	brne	.+2      	; 0x1633c <_datetime+0xa6>
   1633a:	40 c0       	rjmp	.+128    	; 0x163bc <_datetime+0x126>
			__date[0] = (__datetime[4] >> 4) + 0x30;
   1633c:	9d 81       	ldd	r25, Y+5	; 0x05
   1633e:	89 2f       	mov	r24, r25
   16340:	82 95       	swap	r24
   16342:	8f 70       	andi	r24, 0x0F	; 15
   16344:	80 5d       	subi	r24, 0xD0	; 208
   16346:	f8 01       	movw	r30, r16
   16348:	80 83       	st	Z, r24
			__date[1] = (__datetime[4] & 0x0F) + 0x30;
   1634a:	9f 70       	andi	r25, 0x0F	; 15
   1634c:	90 5d       	subi	r25, 0xD0	; 208
   1634e:	91 83       	std	Z+1, r25	; 0x01
			__date[2] = '/';
   16350:	2f e2       	ldi	r18, 0x2F	; 47
   16352:	22 83       	std	Z+2, r18	; 0x02
			__date[3] = (__datetime[5] >> 4) + 0x30;
   16354:	9e 81       	ldd	r25, Y+6	; 0x06
   16356:	89 2f       	mov	r24, r25
   16358:	82 95       	swap	r24
   1635a:	8f 70       	andi	r24, 0x0F	; 15
   1635c:	80 5d       	subi	r24, 0xD0	; 208
   1635e:	83 83       	std	Z+3, r24	; 0x03
			__date[4] = (__datetime[5] & 0x0F) + 0x30;
   16360:	9f 70       	andi	r25, 0x0F	; 15
   16362:	90 5d       	subi	r25, 0xD0	; 208
   16364:	94 83       	std	Z+4, r25	; 0x04
			__date[5] = '/';
   16366:	25 83       	std	Z+5, r18	; 0x05
			__date[6] = (__datetime[6] >> 4) + 0x30;
   16368:	9f 81       	ldd	r25, Y+7	; 0x07
   1636a:	89 2f       	mov	r24, r25
   1636c:	82 95       	swap	r24
   1636e:	8f 70       	andi	r24, 0x0F	; 15
   16370:	80 5d       	subi	r24, 0xD0	; 208
   16372:	86 83       	std	Z+6, r24	; 0x06
			__date[7] = (__datetime[6] & 0x0F) + 0x30;
   16374:	9f 70       	andi	r25, 0x0F	; 15
   16376:	90 5d       	subi	r25, 0xD0	; 208
   16378:	97 83       	std	Z+7, r25	; 0x07
			__date[8] = '\0';
   1637a:	10 86       	std	Z+8, r1	; 0x08

			__time[0] = (__datetime[2] >> 4) + 0x30;
   1637c:	9b 81       	ldd	r25, Y+3	; 0x03
   1637e:	89 2f       	mov	r24, r25
   16380:	82 95       	swap	r24
   16382:	8f 70       	andi	r24, 0x0F	; 15
   16384:	80 5d       	subi	r24, 0xD0	; 208
   16386:	f7 01       	movw	r30, r14
   16388:	80 83       	st	Z, r24
			__time[1] = (__datetime[2] & 0x0F) + 0x30;
   1638a:	9f 70       	andi	r25, 0x0F	; 15
   1638c:	90 5d       	subi	r25, 0xD0	; 208
   1638e:	91 83       	std	Z+1, r25	; 0x01
			__time[2] = ':';
   16390:	2a e3       	ldi	r18, 0x3A	; 58
   16392:	22 83       	std	Z+2, r18	; 0x02
			__time[3] = (__datetime[1] >> 4) + 0x30;
   16394:	9a 81       	ldd	r25, Y+2	; 0x02
   16396:	89 2f       	mov	r24, r25
   16398:	82 95       	swap	r24
   1639a:	8f 70       	andi	r24, 0x0F	; 15
   1639c:	80 5d       	subi	r24, 0xD0	; 208
   1639e:	83 83       	std	Z+3, r24	; 0x03
			__time[4] = (__datetime[1] & 0x0F) + 0x30;
   163a0:	9f 70       	andi	r25, 0x0F	; 15
   163a2:	90 5d       	subi	r25, 0xD0	; 208
   163a4:	94 83       	std	Z+4, r25	; 0x04
			__time[5] = ':';
   163a6:	25 83       	std	Z+5, r18	; 0x05
			__time[6] = (__datetime[0] >> 4) + 0x30;
   163a8:	99 81       	ldd	r25, Y+1	; 0x01
   163aa:	89 2f       	mov	r24, r25
   163ac:	82 95       	swap	r24
   163ae:	8f 70       	andi	r24, 0x0F	; 15
   163b0:	80 5d       	subi	r24, 0xD0	; 208
   163b2:	86 83       	std	Z+6, r24	; 0x06
			__time[7] = (__datetime[0] & 0x0F) + 0x30;
   163b4:	9f 70       	andi	r25, 0x0F	; 15
   163b6:	90 5d       	subi	r25, 0xD0	; 208
   163b8:	97 83       	std	Z+7, r25	; 0x07
			__time[8] = '\0';
   163ba:	10 86       	std	Z+8, r1	; 0x08
		}
}
   163bc:	64 96       	adiw	r28, 0x14	; 20
   163be:	0f b6       	in	r0, 0x3f	; 63
   163c0:	f8 94       	cli
   163c2:	de bf       	out	0x3e, r29	; 62
   163c4:	0f be       	out	0x3f, r0	; 63
   163c6:	cd bf       	out	0x3d, r28	; 61
   163c8:	cf 91       	pop	r28
   163ca:	df 91       	pop	r29
   163cc:	1f 91       	pop	r17
   163ce:	0f 91       	pop	r16
   163d0:	ff 90       	pop	r15
   163d2:	ef 90       	pop	r14
   163d4:	08 95       	ret

000163d6 <_day>:

unsigned char _day(void){
   163d6:	df 93       	push	r29
   163d8:	cf 93       	push	r28
   163da:	cd b7       	in	r28, 0x3d	; 61
   163dc:	de b7       	in	r29, 0x3e	; 62
   163de:	64 97       	sbiw	r28, 0x14	; 20
   163e0:	0f b6       	in	r0, 0x3f	; 63
   163e2:	f8 94       	cli
   163e4:	de bf       	out	0x3e, r29	; 62
   163e6:	0f be       	out	0x3f, r0	; 63
   163e8:	cd bf       	out	0x3d, r28	; 61
	char	__datetime[20];

	if(_rtc(0, 8, __datetime, 0) != 1)
   163ea:	80 e0       	ldi	r24, 0x00	; 0
   163ec:	90 e0       	ldi	r25, 0x00	; 0
   163ee:	68 e0       	ldi	r22, 0x08	; 8
   163f0:	70 e0       	ldi	r23, 0x00	; 0
   163f2:	ae 01       	movw	r20, r28
   163f4:	4f 5f       	subi	r20, 0xFF	; 255
   163f6:	5f 4f       	sbci	r21, 0xFF	; 255
   163f8:	20 e0       	ldi	r18, 0x00	; 0
   163fa:	0e 94 89 b0 	call	0x16112	; 0x16112 <_rtc>
   163fe:	81 30       	cpi	r24, 0x01	; 1
   16400:	11 f4       	brne	.+4      	; 0x16406 <_day+0x30>
   16402:	80 e0       	ldi	r24, 0x00	; 0
   16404:	02 c0       	rjmp	.+4      	; 0x1640a <_day+0x34>
		return __datetime[3] & 0x0F;
   16406:	8c 81       	ldd	r24, Y+4	; 0x04
   16408:	8f 70       	andi	r24, 0x0F	; 15
	return 0;
   1640a:	64 96       	adiw	r28, 0x14	; 20
   1640c:	0f b6       	in	r0, 0x3f	; 63
   1640e:	f8 94       	cli
   16410:	de bf       	out	0x3e, r29	; 62
   16412:	0f be       	out	0x3f, r0	; 63
   16414:	cd bf       	out	0x3d, r28	; 61
   16416:	cf 91       	pop	r28
   16418:	df 91       	pop	r29
   1641a:	08 95       	ret

0001641c <_uart_baudrate>:
	}

	_uart_baudrate(__com, __baudrate);
}

void _uart_baudrate(unsigned char __com, unsigned long __baudrate){
   1641c:	1f 93       	push	r17
   1641e:	18 2f       	mov	r17, r24
   16420:	9a 01       	movw	r18, r20
   16422:	ab 01       	movw	r20, r22
	unsigned long __br;

	__br = (unsigned long)((_CPU_DEFAULT + (__baudrate * 8)) / (__baudrate * 16) - 1);
   16424:	ca 01       	movw	r24, r20
   16426:	b9 01       	movw	r22, r18
   16428:	60 50       	subi	r22, 0x00	; 0
   1642a:	70 4e       	sbci	r23, 0xE0	; 224
   1642c:	83 4e       	sbci	r24, 0xE3	; 227
   1642e:	9f 4f       	sbci	r25, 0xFF	; 255
   16430:	f3 e0       	ldi	r31, 0x03	; 3
   16432:	66 0f       	add	r22, r22
   16434:	77 1f       	adc	r23, r23
   16436:	88 1f       	adc	r24, r24
   16438:	99 1f       	adc	r25, r25
   1643a:	fa 95       	dec	r31
   1643c:	d1 f7       	brne	.-12     	; 0x16432 <_uart_baudrate+0x16>
   1643e:	e4 e0       	ldi	r30, 0x04	; 4
   16440:	22 0f       	add	r18, r18
   16442:	33 1f       	adc	r19, r19
   16444:	44 1f       	adc	r20, r20
   16446:	55 1f       	adc	r21, r21
   16448:	ea 95       	dec	r30
   1644a:	d1 f7       	brne	.-12     	; 0x16440 <_uart_baudrate+0x24>
   1644c:	0e 94 34 b7 	call	0x16e68	; 0x16e68 <__udivmodsi4>
   16450:	21 50       	subi	r18, 0x01	; 1
   16452:	30 40       	sbci	r19, 0x00	; 0
   16454:	40 40       	sbci	r20, 0x00	; 0
   16456:	50 40       	sbci	r21, 0x00	; 0
   16458:	bb 27       	eor	r27, r27
   1645a:	a5 2f       	mov	r26, r21
   1645c:	94 2f       	mov	r25, r20
   1645e:	83 2f       	mov	r24, r19

	if(__com){
   16460:	11 23       	and	r17, r17
   16462:	29 f0       	breq	.+10     	; 0x1646e <_uart_baudrate+0x52>
		UBRR1L = __br;
   16464:	20 93 99 00 	sts	0x0099, r18
		UBRR1H = __br >> 8;
   16468:	80 93 98 00 	sts	0x0098, r24
   1646c:	03 c0       	rjmp	.+6      	; 0x16474 <_uart_baudrate+0x58>
	}
	else{
		UBRR0L = __br;
   1646e:	29 b9       	out	0x09, r18	; 9
		UBRR0H = __br >> 8;
   16470:	80 93 90 00 	sts	0x0090, r24
	}
}
   16474:	1f 91       	pop	r17
   16476:	08 95       	ret

00016478 <_uart_init>:
#include <util/delay.h>
#include <string.h>

#include "UART.h"

void _uart_init(unsigned char __com, unsigned long __baudrate){
   16478:	98 2f       	mov	r25, r24
	if(__com){
   1647a:	88 23       	and	r24, r24
   1647c:	39 f0       	breq	.+14     	; 0x1648c <_uart_init+0x14>
		UCSR1B = _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1);
   1647e:	88 e9       	ldi	r24, 0x98	; 152
   16480:	80 93 9a 00 	sts	0x009A, r24
		UCSR1C = _BV(UCSZ11) | _BV(UCSZ10);
   16484:	86 e0       	ldi	r24, 0x06	; 6
   16486:	80 93 9d 00 	sts	0x009D, r24
   1648a:	05 c0       	rjmp	.+10     	; 0x16496 <_uart_init+0x1e>
	}
	else{
		UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
   1648c:	88 e9       	ldi	r24, 0x98	; 152
   1648e:	8a b9       	out	0x0a, r24	; 10
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
   16490:	86 e0       	ldi	r24, 0x06	; 6
   16492:	80 93 95 00 	sts	0x0095, r24
	}

	_uart_baudrate(__com, __baudrate);
   16496:	89 2f       	mov	r24, r25
   16498:	0e 94 0e b2 	call	0x1641c	; 0x1641c <_uart_baudrate>
}
   1649c:	08 95       	ret

0001649e <_uart>:
		UBRR0H = __br >> 8;
	}
}

unsigned char _uart(unsigned char __com, unsigned char __dir, unsigned char __chr){
	if(__com){
   1649e:	88 23       	and	r24, r24
   164a0:	81 f0       	breq	.+32     	; 0x164c2 <_uart+0x24>
		if(__dir){
   164a2:	66 23       	and	r22, r22
   164a4:	39 f0       	breq	.+14     	; 0x164b4 <_uart+0x16>
			loop_until_bit_is_set(UCSR1A, UDRE1);
   164a6:	80 91 9b 00 	lds	r24, 0x009B
   164aa:	85 ff       	sbrs	r24, 5
   164ac:	fc cf       	rjmp	.-8      	; 0x164a6 <_uart+0x8>
			UDR1 = __chr;
   164ae:	40 93 9c 00 	sts	0x009C, r20
   164b2:	0c c0       	rjmp	.+24     	; 0x164cc <_uart+0x2e>
		}
		else{
			loop_until_bit_is_set(UCSR1A, RXC);
   164b4:	80 91 9b 00 	lds	r24, 0x009B
   164b8:	87 ff       	sbrs	r24, 7
   164ba:	fc cf       	rjmp	.-8      	; 0x164b4 <_uart+0x16>
			return UDR1;
   164bc:	80 91 9c 00 	lds	r24, 0x009C
   164c0:	08 95       	ret
		}
	}
	else{
		if(__dir){
   164c2:	66 23       	and	r22, r22
   164c4:	29 f0       	breq	.+10     	; 0x164d0 <_uart+0x32>
			loop_until_bit_is_set(UCSR0A, UDRE0);
   164c6:	5d 9b       	sbis	0x0b, 5	; 11
   164c8:	fe cf       	rjmp	.-4      	; 0x164c6 <_uart+0x28>
			UDR0 = __chr;
   164ca:	4c b9       	out	0x0c, r20	; 12
   164cc:	81 e0       	ldi	r24, 0x01	; 1
   164ce:	08 95       	ret
		}
		else{
			loop_until_bit_is_set(UCSR0A,  RXC);
   164d0:	5f 9b       	sbis	0x0b, 7	; 11
   164d2:	fe cf       	rjmp	.-4      	; 0x164d0 <_uart+0x32>
			return UDR0;
   164d4:	8c b1       	in	r24, 0x0c	; 12
		}

	}

	return 1;
}
   164d6:	08 95       	ret

000164d8 <_uart_print>:

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
   164d8:	0f 93       	push	r16
   164da:	1f 93       	push	r17
   164dc:	cf 93       	push	r28
   164de:	df 93       	push	r29
   164e0:	18 2f       	mov	r17, r24
   164e2:	06 2f       	mov	r16, r22
   164e4:	ea 01       	movw	r28, r20
	if(strlen(__str)>0)
   164e6:	88 81       	ld	r24, Y
   164e8:	88 23       	and	r24, r24
   164ea:	31 f4       	brne	.+12     	; 0x164f8 <_uart_print+0x20>
   164ec:	08 c0       	rjmp	.+16     	; 0x164fe <_uart_print+0x26>
		while(*__str)
		     _uart(__com, 1, *__str++);
   164ee:	21 96       	adiw	r28, 0x01	; 1
   164f0:	81 2f       	mov	r24, r17
   164f2:	61 e0       	ldi	r22, 0x01	; 1
   164f4:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
	return 1;
}

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
	if(strlen(__str)>0)
		while(*__str)
   164f8:	48 81       	ld	r20, Y
   164fa:	44 23       	and	r20, r20
   164fc:	c1 f7       	brne	.-16     	; 0x164ee <_uart_print+0x16>
		     _uart(__com, 1, *__str++);

	if(__ret){
   164fe:	00 23       	and	r16, r16
   16500:	51 f0       	breq	.+20     	; 0x16516 <_uart_print+0x3e>
		_uart(__com, 1, 0x0D);
   16502:	81 2f       	mov	r24, r17
   16504:	61 e0       	ldi	r22, 0x01	; 1
   16506:	4d e0       	ldi	r20, 0x0D	; 13
   16508:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
		_uart(__com, 1, 0x0A);
   1650c:	81 2f       	mov	r24, r17
   1650e:	61 e0       	ldi	r22, 0x01	; 1
   16510:	4a e0       	ldi	r20, 0x0A	; 10
   16512:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
   16516:	82 ee       	ldi	r24, 0xE2	; 226
   16518:	94 e0       	ldi	r25, 0x04	; 4
   1651a:	01 97       	sbiw	r24, 0x01	; 1
   1651c:	f1 f7       	brne	.-4      	; 0x1651a <_uart_print+0x42>
	}
	_delay_ms(5);
}
   1651e:	df 91       	pop	r29
   16520:	cf 91       	pop	r28
   16522:	1f 91       	pop	r17
   16524:	0f 91       	pop	r16
   16526:	08 95       	ret

00016528 <_uart_printf>:

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
   16528:	0f 93       	push	r16
   1652a:	1f 93       	push	r17
   1652c:	cf 93       	push	r28
   1652e:	df 93       	push	r29
   16530:	18 2f       	mov	r17, r24
   16532:	06 2f       	mov	r16, r22
   16534:	ea 01       	movw	r28, r20
   16536:	07 c0       	rjmp	.+14     	; 0x16546 <_uart_printf+0x1e>
	while(pgm_read_byte(&(*__str)))
		_uart(__com, 1, pgm_read_byte(&(*__str++)));
   16538:	21 96       	adiw	r28, 0x01	; 1
   1653a:	f9 01       	movw	r30, r18
   1653c:	44 91       	lpm	r20, Z+
   1653e:	81 2f       	mov	r24, r17
   16540:	61 e0       	ldi	r22, 0x01	; 1
   16542:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
   16546:	9e 01       	movw	r18, r28
	}
	_delay_ms(5);
}

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
	while(pgm_read_byte(&(*__str)))
   16548:	fe 01       	movw	r30, r28
   1654a:	84 91       	lpm	r24, Z+
   1654c:	88 23       	and	r24, r24
   1654e:	a1 f7       	brne	.-24     	; 0x16538 <_uart_printf+0x10>
		_uart(__com, 1, pgm_read_byte(&(*__str++)));

	if(__ret){
   16550:	00 23       	and	r16, r16
   16552:	51 f0       	breq	.+20     	; 0x16568 <_uart_printf+0x40>
		_uart(__com, 1, 0x0D);
   16554:	81 2f       	mov	r24, r17
   16556:	61 e0       	ldi	r22, 0x01	; 1
   16558:	4d e0       	ldi	r20, 0x0D	; 13
   1655a:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
		_uart(__com, 1, 0x0A);
   1655e:	81 2f       	mov	r24, r17
   16560:	61 e0       	ldi	r22, 0x01	; 1
   16562:	4a e0       	ldi	r20, 0x0A	; 10
   16564:	0e 94 4f b2 	call	0x1649e	; 0x1649e <_uart>
   16568:	86 ea       	ldi	r24, 0xA6	; 166
   1656a:	9e e0       	ldi	r25, 0x0E	; 14
   1656c:	01 97       	sbiw	r24, 0x01	; 1
   1656e:	f1 f7       	brne	.-4      	; 0x1656c <_uart_printf+0x44>
	}
	_delay_ms(15);
}
   16570:	df 91       	pop	r29
   16572:	cf 91       	pop	r28
   16574:	1f 91       	pop	r17
   16576:	0f 91       	pop	r16
   16578:	08 95       	ret

0001657a <Int2Str>:

void Int2Str(char* __string, unsigned long __value){
   1657a:	6f 92       	push	r6
   1657c:	7f 92       	push	r7
   1657e:	8f 92       	push	r8
   16580:	9f 92       	push	r9
   16582:	af 92       	push	r10
   16584:	bf 92       	push	r11
   16586:	cf 92       	push	r12
   16588:	df 92       	push	r13
   1658a:	ef 92       	push	r14
   1658c:	ff 92       	push	r15
   1658e:	0f 93       	push	r16
   16590:	1f 93       	push	r17
   16592:	cf 93       	push	r28
   16594:	df 93       	push	r29
   16596:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
   16598:	41 15       	cp	r20, r1
   1659a:	51 05       	cpc	r21, r1
   1659c:	61 05       	cpc	r22, r1
   1659e:	71 05       	cpc	r23, r1
   165a0:	21 f4       	brne	.+8      	; 0x165aa <Int2Str+0x30>
		__string[0] = '0';
   165a2:	80 e3       	ldi	r24, 0x30	; 48
   165a4:	88 83       	st	Y, r24
		__string[1] = '\0';
   165a6:	19 82       	std	Y+1, r1	; 0x01
   165a8:	48 c0       	rjmp	.+144    	; 0x1663a <Int2Str+0xc0>
		return;
   165aa:	4a 01       	movw	r8, r20
   165ac:	5b 01       	movw	r10, r22
   165ae:	10 e0       	ldi	r17, 0x00	; 0
   165b0:	00 e0       	ldi	r16, 0x00	; 0
   165b2:	77 24       	eor	r7, r7
   165b4:	c1 2c       	mov	r12, r1
   165b6:	ba ec       	ldi	r27, 0xCA	; 202
   165b8:	db 2e       	mov	r13, r27
   165ba:	ba e9       	ldi	r27, 0x9A	; 154
   165bc:	eb 2e       	mov	r14, r27
   165be:	bb e3       	ldi	r27, 0x3B	; 59
   165c0:	fb 2e       	mov	r15, r27
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
   165c2:	a0 e3       	ldi	r26, 0x30	; 48
   165c4:	6a 2e       	mov	r6, r26
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
   165c6:	8c 14       	cp	r8, r12
   165c8:	9d 04       	cpc	r9, r13
   165ca:	ae 04       	cpc	r10, r14
   165cc:	bf 04       	cpc	r11, r15
   165ce:	d0 f0       	brcs	.+52     	; 0x16604 <Int2Str+0x8a>
			__tmp = (int)(__num / __devider);
   165d0:	c5 01       	movw	r24, r10
   165d2:	b4 01       	movw	r22, r8
   165d4:	a7 01       	movw	r20, r14
   165d6:	96 01       	movw	r18, r12
   165d8:	0e 94 34 b7 	call	0x16e68	; 0x16e68 <__udivmodsi4>
   165dc:	12 2f       	mov	r17, r18
			__num = __num % __devider;
   165de:	c5 01       	movw	r24, r10
   165e0:	b4 01       	movw	r22, r8
   165e2:	a7 01       	movw	r20, r14
   165e4:	96 01       	movw	r18, r12
   165e6:	0e 94 34 b7 	call	0x16e68	; 0x16e68 <__udivmodsi4>
   165ea:	ac 01       	movw	r20, r24
   165ec:	cb 01       	movw	r24, r22
   165ee:	da 01       	movw	r26, r20
   165f0:	4c 01       	movw	r8, r24
   165f2:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
   165f4:	fe 01       	movw	r30, r28
   165f6:	e0 0f       	add	r30, r16
   165f8:	f1 1d       	adc	r31, r1
   165fa:	10 5d       	subi	r17, 0xD0	; 208
   165fc:	10 83       	st	Z, r17
   165fe:	0f 5f       	subi	r16, 0xFF	; 255
   16600:	11 e0       	ldi	r17, 0x01	; 1
   16602:	07 c0       	rjmp	.+14     	; 0x16612 <Int2Str+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
   16604:	11 23       	and	r17, r17
   16606:	29 f0       	breq	.+10     	; 0x16612 <Int2Str+0x98>
				__string[__i++] = 0x30;
   16608:	fe 01       	movw	r30, r28
   1660a:	e0 0f       	add	r30, r16
   1660c:	f1 1d       	adc	r31, r1
   1660e:	60 82       	st	Z, r6
   16610:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
   16612:	73 94       	inc	r7
   16614:	8a e0       	ldi	r24, 0x0A	; 10
   16616:	78 16       	cp	r7, r24
   16618:	69 f0       	breq	.+26     	; 0x16634 <Int2Str+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
   1661a:	c7 01       	movw	r24, r14
   1661c:	b6 01       	movw	r22, r12
   1661e:	2a e0       	ldi	r18, 0x0A	; 10
   16620:	30 e0       	ldi	r19, 0x00	; 0
   16622:	40 e0       	ldi	r20, 0x00	; 0
   16624:	50 e0       	ldi	r21, 0x00	; 0
   16626:	0e 94 34 b7 	call	0x16e68	; 0x16e68 <__udivmodsi4>
   1662a:	c9 01       	movw	r24, r18
   1662c:	da 01       	movw	r26, r20
   1662e:	6c 01       	movw	r12, r24
   16630:	7d 01       	movw	r14, r26
   16632:	c9 cf       	rjmp	.-110    	; 0x165c6 <Int2Str+0x4c>
	}
	__string[__i] = '\0';
   16634:	c0 0f       	add	r28, r16
   16636:	d1 1d       	adc	r29, r1
   16638:	18 82       	st	Y, r1
}
   1663a:	df 91       	pop	r29
   1663c:	cf 91       	pop	r28
   1663e:	1f 91       	pop	r17
   16640:	0f 91       	pop	r16
   16642:	ff 90       	pop	r15
   16644:	ef 90       	pop	r14
   16646:	df 90       	pop	r13
   16648:	cf 90       	pop	r12
   1664a:	bf 90       	pop	r11
   1664c:	af 90       	pop	r10
   1664e:	9f 90       	pop	r9
   16650:	8f 90       	pop	r8
   16652:	7f 90       	pop	r7
   16654:	6f 90       	pop	r6
   16656:	08 95       	ret

00016658 <Str2Int>:

unsigned long Str2Int(char* __string){
   16658:	6f 92       	push	r6
   1665a:	7f 92       	push	r7
   1665c:	8f 92       	push	r8
   1665e:	9f 92       	push	r9
   16660:	af 92       	push	r10
   16662:	bf 92       	push	r11
   16664:	cf 92       	push	r12
   16666:	df 92       	push	r13
   16668:	ef 92       	push	r14
   1666a:	ff 92       	push	r15
   1666c:	0f 93       	push	r16
   1666e:	1f 93       	push	r17
   16670:	cf 93       	push	r28
   16672:	df 93       	push	r29
   16674:	ec 01       	movw	r28, r24
	unsigned char	__i, __len;
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);
   16676:	dc 01       	movw	r26, r24
   16678:	0d 90       	ld	r0, X+
   1667a:	00 20       	and	r0, r0
   1667c:	e9 f7       	brne	.-6      	; 0x16678 <Str2Int+0x20>
   1667e:	11 97       	sbiw	r26, 0x01	; 1
   16680:	7a 2e       	mov	r7, r26
   16682:	78 1a       	sub	r7, r24

	if(__len > 0 && __len < 11){
   16684:	87 2d       	mov	r24, r7
   16686:	81 50       	subi	r24, 0x01	; 1
   16688:	8a 30       	cpi	r24, 0x0A	; 10
   1668a:	08 f0       	brcs	.+2      	; 0x1668e <Str2Int+0x36>
   1668c:	64 c0       	rjmp	.+200    	; 0x16756 <Str2Int+0xfe>
   1668e:	4e 01       	movw	r8, r28
   16690:	fe 01       	movw	r30, r28
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}

unsigned long Str2Int(char* __string){
   16692:	6c 2e       	mov	r6, r28
   16694:	05 c0       	rjmp	.+10     	; 0x166a0 <Str2Int+0x48>

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
   16696:	81 91       	ld	r24, Z+
   16698:	80 53       	subi	r24, 0x30	; 48
   1669a:	8a 30       	cpi	r24, 0x0A	; 10
   1669c:	08 f0       	brcs	.+2      	; 0x166a0 <Str2Int+0x48>
   1669e:	5b c0       	rjmp	.+182    	; 0x16756 <Str2Int+0xfe>
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
   166a0:	8e 2f       	mov	r24, r30
   166a2:	86 19       	sub	r24, r6
   166a4:	87 15       	cp	r24, r7
   166a6:	b8 f3       	brcs	.-18     	; 0x16696 <Str2Int+0x3e>
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
				return 0;
		if(__len == 10){
   166a8:	8a e0       	ldi	r24, 0x0A	; 10
   166aa:	78 16       	cp	r7, r24
   166ac:	f9 f4       	brne	.+62     	; 0x166ec <Str2Int+0x94>
			if(__string[0] < 0x30 || __string[0] > 0x32)
   166ae:	98 81       	ld	r25, Y
   166b0:	89 2f       	mov	r24, r25
   166b2:	80 53       	subi	r24, 0x30	; 48
   166b4:	83 30       	cpi	r24, 0x03	; 3
   166b6:	08 f0       	brcs	.+2      	; 0x166ba <Str2Int+0x62>
   166b8:	4e c0       	rjmp	.+156    	; 0x16756 <Str2Int+0xfe>
				return 0;
			if(__string[0] == 0x32){
   166ba:	92 33       	cpi	r25, 0x32	; 50
   166bc:	b9 f4       	brne	.+46     	; 0x166ec <Str2Int+0x94>
   166be:	fe 01       	movw	r30, r28
   166c0:	91 e0       	ldi	r25, 0x01	; 1
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
   166c2:	81 81       	ldd	r24, Z+1	; 0x01
   166c4:	80 33       	cpi	r24, 0x30	; 48
   166c6:	09 f0       	breq	.+2      	; 0x166ca <Str2Int+0x72>
   166c8:	46 c0       	rjmp	.+140    	; 0x16756 <Str2Int+0xfe>
				return 0;
		if(__len == 10){
			if(__string[0] < 0x30 || __string[0] > 0x32)
				return 0;
			if(__string[0] == 0x32){
				for(__i = 1; __i < __len; __i++)
   166ca:	9f 5f       	subi	r25, 0xFF	; 255
   166cc:	31 96       	adiw	r30, 0x01	; 1
   166ce:	9a 30       	cpi	r25, 0x0A	; 10
   166d0:	c1 f7       	brne	.-16     	; 0x166c2 <Str2Int+0x6a>
   166d2:	0c c0       	rjmp	.+24     	; 0x166ec <Str2Int+0x94>
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
   166d4:	c6 01       	movw	r24, r12
   166d6:	b5 01       	movw	r22, r10
   166d8:	2a e0       	ldi	r18, 0x0A	; 10
   166da:	30 e0       	ldi	r19, 0x00	; 0
   166dc:	40 e0       	ldi	r20, 0x00	; 0
   166de:	50 e0       	ldi	r21, 0x00	; 0
   166e0:	0e 94 d5 b6 	call	0x16daa	; 0x16daa <__mulsi3>
   166e4:	5b 01       	movw	r10, r22
   166e6:	6c 01       	movw	r12, r24
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
   166e8:	1f 5f       	subi	r17, 0xFF	; 255
   166ea:	09 c0       	rjmp	.+18     	; 0x166fe <Str2Int+0xa6>
   166ec:	10 e0       	ldi	r17, 0x00	; 0
   166ee:	01 e0       	ldi	r16, 0x01	; 1
   166f0:	a0 2e       	mov	r10, r16
   166f2:	b1 2c       	mov	r11, r1
   166f4:	c1 2c       	mov	r12, r1
   166f6:	d1 2c       	mov	r13, r1
   166f8:	c7 2d       	mov	r28, r7
   166fa:	d0 e0       	ldi	r29, 0x00	; 0
   166fc:	21 97       	sbiw	r28, 0x01	; 1
   166fe:	81 2f       	mov	r24, r17
   16700:	90 e0       	ldi	r25, 0x00	; 0
   16702:	8c 17       	cp	r24, r28
   16704:	9d 07       	cpc	r25, r29
   16706:	34 f3       	brlt	.-52     	; 0x166d4 <Str2Int+0x7c>
   16708:	ee 24       	eor	r14, r14
   1670a:	ff 24       	eor	r15, r15
   1670c:	87 01       	movw	r16, r14
   1670e:	1e c0       	rjmp	.+60     	; 0x1674c <Str2Int+0xf4>
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
   16710:	f4 01       	movw	r30, r8
   16712:	21 91       	ld	r18, Z+
   16714:	4f 01       	movw	r8, r30
   16716:	30 e0       	ldi	r19, 0x00	; 0
   16718:	20 53       	subi	r18, 0x30	; 48
   1671a:	30 40       	sbci	r19, 0x00	; 0
   1671c:	44 27       	eor	r20, r20
   1671e:	37 fd       	sbrc	r19, 7
   16720:	40 95       	com	r20
   16722:	54 2f       	mov	r21, r20
   16724:	c6 01       	movw	r24, r12
   16726:	b5 01       	movw	r22, r10
   16728:	0e 94 d5 b6 	call	0x16daa	; 0x16daa <__mulsi3>
   1672c:	e6 0e       	add	r14, r22
   1672e:	f7 1e       	adc	r15, r23
   16730:	08 1f       	adc	r16, r24
   16732:	19 1f       	adc	r17, r25
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
   16734:	c6 01       	movw	r24, r12
   16736:	b5 01       	movw	r22, r10
   16738:	2a e0       	ldi	r18, 0x0A	; 10
   1673a:	30 e0       	ldi	r19, 0x00	; 0
   1673c:	40 e0       	ldi	r20, 0x00	; 0
   1673e:	50 e0       	ldi	r21, 0x00	; 0
   16740:	0e 94 34 b7 	call	0x16e68	; 0x16e68 <__udivmodsi4>
   16744:	c9 01       	movw	r24, r18
   16746:	da 01       	movw	r26, r20
   16748:	5c 01       	movw	r10, r24
   1674a:	6d 01       	movw	r12, r26
   1674c:	88 2d       	mov	r24, r8
   1674e:	86 19       	sub	r24, r6
   16750:	87 15       	cp	r24, r7
   16752:	f0 f2       	brcs	.-68     	; 0x16710 <Str2Int+0xb8>
   16754:	03 c0       	rjmp	.+6      	; 0x1675c <Str2Int+0x104>
   16756:	ee 24       	eor	r14, r14
   16758:	ff 24       	eor	r15, r15
   1675a:	87 01       	movw	r16, r14
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
	}
	return __retval;
}
   1675c:	b7 01       	movw	r22, r14
   1675e:	c8 01       	movw	r24, r16
   16760:	df 91       	pop	r29
   16762:	cf 91       	pop	r28
   16764:	1f 91       	pop	r17
   16766:	0f 91       	pop	r16
   16768:	ff 90       	pop	r15
   1676a:	ef 90       	pop	r14
   1676c:	df 90       	pop	r13
   1676e:	cf 90       	pop	r12
   16770:	bf 90       	pop	r11
   16772:	af 90       	pop	r10
   16774:	9f 90       	pop	r9
   16776:	8f 90       	pop	r8
   16778:	7f 90       	pop	r7
   1677a:	6f 90       	pop	r6
   1677c:	08 95       	ret

0001677e <atoi>:
   1677e:	fc 01       	movw	r30, r24
   16780:	88 27       	eor	r24, r24
   16782:	99 27       	eor	r25, r25
   16784:	e8 94       	clt
   16786:	21 91       	ld	r18, Z+
   16788:	20 32       	cpi	r18, 0x20	; 32
   1678a:	e9 f3       	breq	.-6      	; 0x16786 <atoi+0x8>
   1678c:	29 30       	cpi	r18, 0x09	; 9
   1678e:	10 f0       	brcs	.+4      	; 0x16794 <atoi+0x16>
   16790:	2e 30       	cpi	r18, 0x0E	; 14
   16792:	c8 f3       	brcs	.-14     	; 0x16786 <atoi+0x8>
   16794:	2b 32       	cpi	r18, 0x2B	; 43
   16796:	41 f0       	breq	.+16     	; 0x167a8 <atoi+0x2a>
   16798:	2d 32       	cpi	r18, 0x2D	; 45
   1679a:	39 f4       	brne	.+14     	; 0x167aa <atoi+0x2c>
   1679c:	68 94       	set
   1679e:	04 c0       	rjmp	.+8      	; 0x167a8 <atoi+0x2a>
   167a0:	0e 94 2c b4 	call	0x16858	; 0x16858 <__mulhi_const_10>
   167a4:	82 0f       	add	r24, r18
   167a6:	91 1d       	adc	r25, r1
   167a8:	21 91       	ld	r18, Z+
   167aa:	20 53       	subi	r18, 0x30	; 48
   167ac:	2a 30       	cpi	r18, 0x0A	; 10
   167ae:	c0 f3       	brcs	.-16     	; 0x167a0 <atoi+0x22>
   167b0:	1e f4       	brtc	.+6      	; 0x167b8 <atoi+0x3a>
   167b2:	90 95       	com	r25
   167b4:	81 95       	neg	r24
   167b6:	9f 4f       	sbci	r25, 0xFF	; 255
   167b8:	08 95       	ret

000167ba <strcpy_P>:
   167ba:	fb 01       	movw	r30, r22
   167bc:	dc 01       	movw	r26, r24
   167be:	05 90       	lpm	r0, Z+
   167c0:	0d 92       	st	X+, r0
   167c2:	00 20       	and	r0, r0
   167c4:	e1 f7       	brne	.-8      	; 0x167be <strcpy_P+0x4>
   167c6:	08 95       	ret

000167c8 <strcmp>:
   167c8:	fb 01       	movw	r30, r22
   167ca:	dc 01       	movw	r26, r24
   167cc:	8d 91       	ld	r24, X+
   167ce:	01 90       	ld	r0, Z+
   167d0:	80 19       	sub	r24, r0
   167d2:	01 10       	cpse	r0, r1
   167d4:	d9 f3       	breq	.-10     	; 0x167cc <strcmp+0x4>
   167d6:	99 0b       	sbc	r25, r25
   167d8:	08 95       	ret

000167da <strcpy>:
   167da:	fb 01       	movw	r30, r22
   167dc:	dc 01       	movw	r26, r24
   167de:	01 90       	ld	r0, Z+
   167e0:	0d 92       	st	X+, r0
   167e2:	00 20       	and	r0, r0
   167e4:	e1 f7       	brne	.-8      	; 0x167de <strcpy+0x4>
   167e6:	08 95       	ret

000167e8 <__eerd_block>:
   167e8:	a0 e0       	ldi	r26, 0x00	; 0
   167ea:	b0 e0       	ldi	r27, 0x00	; 0
   167ec:	ea ef       	ldi	r30, 0xFA	; 250
   167ee:	f3 eb       	ldi	r31, 0xB3	; 179
   167f0:	0c 94 60 b7 	jmp	0x16ec0	; 0x16ec0 <__prologue_saves__+0x14>
   167f4:	7c 01       	movw	r14, r24
   167f6:	eb 01       	movw	r28, r22
   167f8:	8a 01       	movw	r16, r20
   167fa:	69 01       	movw	r12, r18
   167fc:	09 c0       	rjmp	.+18     	; 0x16810 <__eerd_block+0x28>
   167fe:	ce 01       	movw	r24, r28
   16800:	21 96       	adiw	r28, 0x01	; 1
   16802:	f6 01       	movw	r30, r12
   16804:	09 95       	icall
   16806:	f7 01       	movw	r30, r14
   16808:	81 93       	st	Z+, r24
   1680a:	7f 01       	movw	r14, r30
   1680c:	01 50       	subi	r16, 0x01	; 1
   1680e:	10 40       	sbci	r17, 0x00	; 0
   16810:	01 15       	cp	r16, r1
   16812:	11 05       	cpc	r17, r1
   16814:	a1 f7       	brne	.-24     	; 0x167fe <__eerd_block+0x16>
   16816:	cd b7       	in	r28, 0x3d	; 61
   16818:	de b7       	in	r29, 0x3e	; 62
   1681a:	e8 e0       	ldi	r30, 0x08	; 8
   1681c:	0c 94 7c b7 	jmp	0x16ef8	; 0x16ef8 <__epilogue_restores__+0x14>

00016820 <__eewr_block>:
   16820:	a0 e0       	ldi	r26, 0x00	; 0
   16822:	b0 e0       	ldi	r27, 0x00	; 0
   16824:	e6 e1       	ldi	r30, 0x16	; 22
   16826:	f4 eb       	ldi	r31, 0xB4	; 180
   16828:	0c 94 60 b7 	jmp	0x16ec0	; 0x16ec0 <__prologue_saves__+0x14>
   1682c:	ec 01       	movw	r28, r24
   1682e:	7b 01       	movw	r14, r22
   16830:	8a 01       	movw	r16, r20
   16832:	69 01       	movw	r12, r18
   16834:	09 c0       	rjmp	.+18     	; 0x16848 <__eewr_block+0x28>
   16836:	ce 01       	movw	r24, r28
   16838:	21 96       	adiw	r28, 0x01	; 1
   1683a:	f7 01       	movw	r30, r14
   1683c:	61 91       	ld	r22, Z+
   1683e:	7f 01       	movw	r14, r30
   16840:	f6 01       	movw	r30, r12
   16842:	09 95       	icall
   16844:	01 50       	subi	r16, 0x01	; 1
   16846:	10 40       	sbci	r17, 0x00	; 0
   16848:	01 15       	cp	r16, r1
   1684a:	11 05       	cpc	r17, r1
   1684c:	a1 f7       	brne	.-24     	; 0x16836 <__eewr_block+0x16>
   1684e:	cd b7       	in	r28, 0x3d	; 61
   16850:	de b7       	in	r29, 0x3e	; 62
   16852:	e8 e0       	ldi	r30, 0x08	; 8
   16854:	0c 94 7c b7 	jmp	0x16ef8	; 0x16ef8 <__epilogue_restores__+0x14>

00016858 <__mulhi_const_10>:
   16858:	7a e0       	ldi	r23, 0x0A	; 10
   1685a:	97 9f       	mul	r25, r23
   1685c:	90 2d       	mov	r25, r0
   1685e:	87 9f       	mul	r24, r23
   16860:	80 2d       	mov	r24, r0
   16862:	91 0d       	add	r25, r1
   16864:	11 24       	eor	r1, r1
   16866:	08 95       	ret

00016868 <sprintf_P>:
   16868:	ae e0       	ldi	r26, 0x0E	; 14
   1686a:	b0 e0       	ldi	r27, 0x00	; 0
   1686c:	ea e3       	ldi	r30, 0x3A	; 58
   1686e:	f4 eb       	ldi	r31, 0xB4	; 180
   16870:	0c 94 64 b7 	jmp	0x16ec8	; 0x16ec8 <__prologue_saves__+0x1c>
   16874:	0d 89       	ldd	r16, Y+21	; 0x15
   16876:	1e 89       	ldd	r17, Y+22	; 0x16
   16878:	8e e0       	ldi	r24, 0x0E	; 14
   1687a:	8c 83       	std	Y+4, r24	; 0x04
   1687c:	1a 83       	std	Y+2, r17	; 0x02
   1687e:	09 83       	std	Y+1, r16	; 0x01
   16880:	8f ef       	ldi	r24, 0xFF	; 255
   16882:	9f e7       	ldi	r25, 0x7F	; 127
   16884:	9e 83       	std	Y+6, r25	; 0x06
   16886:	8d 83       	std	Y+5, r24	; 0x05
   16888:	9e 01       	movw	r18, r28
   1688a:	27 5e       	subi	r18, 0xE7	; 231
   1688c:	3f 4f       	sbci	r19, 0xFF	; 255
   1688e:	ce 01       	movw	r24, r28
   16890:	01 96       	adiw	r24, 0x01	; 1
   16892:	6f 89       	ldd	r22, Y+23	; 0x17
   16894:	78 8d       	ldd	r23, Y+24	; 0x18
   16896:	a9 01       	movw	r20, r18
   16898:	0e 94 58 b4 	call	0x168b0	; 0x168b0 <vfprintf>
   1689c:	2f 81       	ldd	r18, Y+7	; 0x07
   1689e:	38 85       	ldd	r19, Y+8	; 0x08
   168a0:	02 0f       	add	r16, r18
   168a2:	13 1f       	adc	r17, r19
   168a4:	f8 01       	movw	r30, r16
   168a6:	10 82       	st	Z, r1
   168a8:	2e 96       	adiw	r28, 0x0e	; 14
   168aa:	e4 e0       	ldi	r30, 0x04	; 4
   168ac:	0c 94 80 b7 	jmp	0x16f00	; 0x16f00 <__epilogue_restores__+0x1c>

000168b0 <vfprintf>:
   168b0:	ab e0       	ldi	r26, 0x0B	; 11
   168b2:	b0 e0       	ldi	r27, 0x00	; 0
   168b4:	ee e5       	ldi	r30, 0x5E	; 94
   168b6:	f4 eb       	ldi	r31, 0xB4	; 180
   168b8:	0c 94 56 b7 	jmp	0x16eac	; 0x16eac <__prologue_saves__>
   168bc:	3c 01       	movw	r6, r24
   168be:	2b 01       	movw	r4, r22
   168c0:	5a 01       	movw	r10, r20
   168c2:	fc 01       	movw	r30, r24
   168c4:	17 82       	std	Z+7, r1	; 0x07
   168c6:	16 82       	std	Z+6, r1	; 0x06
   168c8:	83 81       	ldd	r24, Z+3	; 0x03
   168ca:	81 fd       	sbrc	r24, 1
   168cc:	03 c0       	rjmp	.+6      	; 0x168d4 <vfprintf+0x24>
   168ce:	6f ef       	ldi	r22, 0xFF	; 255
   168d0:	7f ef       	ldi	r23, 0xFF	; 255
   168d2:	c6 c1       	rjmp	.+908    	; 0x16c60 <vfprintf+0x3b0>
   168d4:	9a e0       	ldi	r25, 0x0A	; 10
   168d6:	89 2e       	mov	r8, r25
   168d8:	1e 01       	movw	r2, r28
   168da:	08 94       	sec
   168dc:	21 1c       	adc	r2, r1
   168de:	31 1c       	adc	r3, r1
   168e0:	f3 01       	movw	r30, r6
   168e2:	23 81       	ldd	r18, Z+3	; 0x03
   168e4:	f2 01       	movw	r30, r4
   168e6:	23 fd       	sbrc	r18, 3
   168e8:	85 91       	lpm	r24, Z+
   168ea:	23 ff       	sbrs	r18, 3
   168ec:	81 91       	ld	r24, Z+
   168ee:	2f 01       	movw	r4, r30
   168f0:	88 23       	and	r24, r24
   168f2:	09 f4       	brne	.+2      	; 0x168f6 <vfprintf+0x46>
   168f4:	b2 c1       	rjmp	.+868    	; 0x16c5a <vfprintf+0x3aa>
   168f6:	85 32       	cpi	r24, 0x25	; 37
   168f8:	39 f4       	brne	.+14     	; 0x16908 <vfprintf+0x58>
   168fa:	23 fd       	sbrc	r18, 3
   168fc:	85 91       	lpm	r24, Z+
   168fe:	23 ff       	sbrs	r18, 3
   16900:	81 91       	ld	r24, Z+
   16902:	2f 01       	movw	r4, r30
   16904:	85 32       	cpi	r24, 0x25	; 37
   16906:	29 f4       	brne	.+10     	; 0x16912 <vfprintf+0x62>
   16908:	90 e0       	ldi	r25, 0x00	; 0
   1690a:	b3 01       	movw	r22, r6
   1690c:	0e 94 4b b6 	call	0x16c96	; 0x16c96 <fputc>
   16910:	e7 cf       	rjmp	.-50     	; 0x168e0 <vfprintf+0x30>
   16912:	98 2f       	mov	r25, r24
   16914:	ff 24       	eor	r15, r15
   16916:	ee 24       	eor	r14, r14
   16918:	99 24       	eor	r9, r9
   1691a:	ff e1       	ldi	r31, 0x1F	; 31
   1691c:	ff 15       	cp	r31, r15
   1691e:	d0 f0       	brcs	.+52     	; 0x16954 <vfprintf+0xa4>
   16920:	9b 32       	cpi	r25, 0x2B	; 43
   16922:	69 f0       	breq	.+26     	; 0x1693e <vfprintf+0x8e>
   16924:	9c 32       	cpi	r25, 0x2C	; 44
   16926:	28 f4       	brcc	.+10     	; 0x16932 <vfprintf+0x82>
   16928:	90 32       	cpi	r25, 0x20	; 32
   1692a:	59 f0       	breq	.+22     	; 0x16942 <vfprintf+0x92>
   1692c:	93 32       	cpi	r25, 0x23	; 35
   1692e:	91 f4       	brne	.+36     	; 0x16954 <vfprintf+0xa4>
   16930:	0e c0       	rjmp	.+28     	; 0x1694e <vfprintf+0x9e>
   16932:	9d 32       	cpi	r25, 0x2D	; 45
   16934:	49 f0       	breq	.+18     	; 0x16948 <vfprintf+0x98>
   16936:	90 33       	cpi	r25, 0x30	; 48
   16938:	69 f4       	brne	.+26     	; 0x16954 <vfprintf+0xa4>
   1693a:	41 e0       	ldi	r20, 0x01	; 1
   1693c:	24 c0       	rjmp	.+72     	; 0x16986 <vfprintf+0xd6>
   1693e:	52 e0       	ldi	r21, 0x02	; 2
   16940:	f5 2a       	or	r15, r21
   16942:	84 e0       	ldi	r24, 0x04	; 4
   16944:	f8 2a       	or	r15, r24
   16946:	28 c0       	rjmp	.+80     	; 0x16998 <vfprintf+0xe8>
   16948:	98 e0       	ldi	r25, 0x08	; 8
   1694a:	f9 2a       	or	r15, r25
   1694c:	25 c0       	rjmp	.+74     	; 0x16998 <vfprintf+0xe8>
   1694e:	e0 e1       	ldi	r30, 0x10	; 16
   16950:	fe 2a       	or	r15, r30
   16952:	22 c0       	rjmp	.+68     	; 0x16998 <vfprintf+0xe8>
   16954:	f7 fc       	sbrc	r15, 7
   16956:	29 c0       	rjmp	.+82     	; 0x169aa <vfprintf+0xfa>
   16958:	89 2f       	mov	r24, r25
   1695a:	80 53       	subi	r24, 0x30	; 48
   1695c:	8a 30       	cpi	r24, 0x0A	; 10
   1695e:	70 f4       	brcc	.+28     	; 0x1697c <vfprintf+0xcc>
   16960:	f6 fe       	sbrs	r15, 6
   16962:	05 c0       	rjmp	.+10     	; 0x1696e <vfprintf+0xbe>
   16964:	98 9c       	mul	r9, r8
   16966:	90 2c       	mov	r9, r0
   16968:	11 24       	eor	r1, r1
   1696a:	98 0e       	add	r9, r24
   1696c:	15 c0       	rjmp	.+42     	; 0x16998 <vfprintf+0xe8>
   1696e:	e8 9c       	mul	r14, r8
   16970:	e0 2c       	mov	r14, r0
   16972:	11 24       	eor	r1, r1
   16974:	e8 0e       	add	r14, r24
   16976:	f0 e2       	ldi	r31, 0x20	; 32
   16978:	ff 2a       	or	r15, r31
   1697a:	0e c0       	rjmp	.+28     	; 0x16998 <vfprintf+0xe8>
   1697c:	9e 32       	cpi	r25, 0x2E	; 46
   1697e:	29 f4       	brne	.+10     	; 0x1698a <vfprintf+0xda>
   16980:	f6 fc       	sbrc	r15, 6
   16982:	6b c1       	rjmp	.+726    	; 0x16c5a <vfprintf+0x3aa>
   16984:	40 e4       	ldi	r20, 0x40	; 64
   16986:	f4 2a       	or	r15, r20
   16988:	07 c0       	rjmp	.+14     	; 0x16998 <vfprintf+0xe8>
   1698a:	9c 36       	cpi	r25, 0x6C	; 108
   1698c:	19 f4       	brne	.+6      	; 0x16994 <vfprintf+0xe4>
   1698e:	50 e8       	ldi	r21, 0x80	; 128
   16990:	f5 2a       	or	r15, r21
   16992:	02 c0       	rjmp	.+4      	; 0x16998 <vfprintf+0xe8>
   16994:	98 36       	cpi	r25, 0x68	; 104
   16996:	49 f4       	brne	.+18     	; 0x169aa <vfprintf+0xfa>
   16998:	f2 01       	movw	r30, r4
   1699a:	23 fd       	sbrc	r18, 3
   1699c:	95 91       	lpm	r25, Z+
   1699e:	23 ff       	sbrs	r18, 3
   169a0:	91 91       	ld	r25, Z+
   169a2:	2f 01       	movw	r4, r30
   169a4:	99 23       	and	r25, r25
   169a6:	09 f0       	breq	.+2      	; 0x169aa <vfprintf+0xfa>
   169a8:	b8 cf       	rjmp	.-144    	; 0x1691a <vfprintf+0x6a>
   169aa:	89 2f       	mov	r24, r25
   169ac:	85 54       	subi	r24, 0x45	; 69
   169ae:	83 30       	cpi	r24, 0x03	; 3
   169b0:	18 f0       	brcs	.+6      	; 0x169b8 <vfprintf+0x108>
   169b2:	80 52       	subi	r24, 0x20	; 32
   169b4:	83 30       	cpi	r24, 0x03	; 3
   169b6:	38 f4       	brcc	.+14     	; 0x169c6 <vfprintf+0x116>
   169b8:	44 e0       	ldi	r20, 0x04	; 4
   169ba:	50 e0       	ldi	r21, 0x00	; 0
   169bc:	a4 0e       	add	r10, r20
   169be:	b5 1e       	adc	r11, r21
   169c0:	5f e3       	ldi	r21, 0x3F	; 63
   169c2:	59 83       	std	Y+1, r21	; 0x01
   169c4:	0f c0       	rjmp	.+30     	; 0x169e4 <vfprintf+0x134>
   169c6:	93 36       	cpi	r25, 0x63	; 99
   169c8:	31 f0       	breq	.+12     	; 0x169d6 <vfprintf+0x126>
   169ca:	93 37       	cpi	r25, 0x73	; 115
   169cc:	79 f0       	breq	.+30     	; 0x169ec <vfprintf+0x13c>
   169ce:	93 35       	cpi	r25, 0x53	; 83
   169d0:	09 f0       	breq	.+2      	; 0x169d4 <vfprintf+0x124>
   169d2:	56 c0       	rjmp	.+172    	; 0x16a80 <vfprintf+0x1d0>
   169d4:	20 c0       	rjmp	.+64     	; 0x16a16 <vfprintf+0x166>
   169d6:	f5 01       	movw	r30, r10
   169d8:	80 81       	ld	r24, Z
   169da:	89 83       	std	Y+1, r24	; 0x01
   169dc:	42 e0       	ldi	r20, 0x02	; 2
   169de:	50 e0       	ldi	r21, 0x00	; 0
   169e0:	a4 0e       	add	r10, r20
   169e2:	b5 1e       	adc	r11, r21
   169e4:	61 01       	movw	r12, r2
   169e6:	01 e0       	ldi	r16, 0x01	; 1
   169e8:	10 e0       	ldi	r17, 0x00	; 0
   169ea:	12 c0       	rjmp	.+36     	; 0x16a10 <vfprintf+0x160>
   169ec:	f5 01       	movw	r30, r10
   169ee:	c0 80       	ld	r12, Z
   169f0:	d1 80       	ldd	r13, Z+1	; 0x01
   169f2:	f6 fc       	sbrc	r15, 6
   169f4:	03 c0       	rjmp	.+6      	; 0x169fc <vfprintf+0x14c>
   169f6:	6f ef       	ldi	r22, 0xFF	; 255
   169f8:	7f ef       	ldi	r23, 0xFF	; 255
   169fa:	02 c0       	rjmp	.+4      	; 0x16a00 <vfprintf+0x150>
   169fc:	69 2d       	mov	r22, r9
   169fe:	70 e0       	ldi	r23, 0x00	; 0
   16a00:	42 e0       	ldi	r20, 0x02	; 2
   16a02:	50 e0       	ldi	r21, 0x00	; 0
   16a04:	a4 0e       	add	r10, r20
   16a06:	b5 1e       	adc	r11, r21
   16a08:	c6 01       	movw	r24, r12
   16a0a:	0e 94 40 b6 	call	0x16c80	; 0x16c80 <strnlen>
   16a0e:	8c 01       	movw	r16, r24
   16a10:	5f e7       	ldi	r21, 0x7F	; 127
   16a12:	f5 22       	and	r15, r21
   16a14:	14 c0       	rjmp	.+40     	; 0x16a3e <vfprintf+0x18e>
   16a16:	f5 01       	movw	r30, r10
   16a18:	c0 80       	ld	r12, Z
   16a1a:	d1 80       	ldd	r13, Z+1	; 0x01
   16a1c:	f6 fc       	sbrc	r15, 6
   16a1e:	03 c0       	rjmp	.+6      	; 0x16a26 <vfprintf+0x176>
   16a20:	6f ef       	ldi	r22, 0xFF	; 255
   16a22:	7f ef       	ldi	r23, 0xFF	; 255
   16a24:	02 c0       	rjmp	.+4      	; 0x16a2a <vfprintf+0x17a>
   16a26:	69 2d       	mov	r22, r9
   16a28:	70 e0       	ldi	r23, 0x00	; 0
   16a2a:	42 e0       	ldi	r20, 0x02	; 2
   16a2c:	50 e0       	ldi	r21, 0x00	; 0
   16a2e:	a4 0e       	add	r10, r20
   16a30:	b5 1e       	adc	r11, r21
   16a32:	c6 01       	movw	r24, r12
   16a34:	0e 94 35 b6 	call	0x16c6a	; 0x16c6a <strnlen_P>
   16a38:	8c 01       	movw	r16, r24
   16a3a:	50 e8       	ldi	r21, 0x80	; 128
   16a3c:	f5 2a       	or	r15, r21
   16a3e:	f3 fe       	sbrs	r15, 3
   16a40:	07 c0       	rjmp	.+14     	; 0x16a50 <vfprintf+0x1a0>
   16a42:	1a c0       	rjmp	.+52     	; 0x16a78 <vfprintf+0x1c8>
   16a44:	80 e2       	ldi	r24, 0x20	; 32
   16a46:	90 e0       	ldi	r25, 0x00	; 0
   16a48:	b3 01       	movw	r22, r6
   16a4a:	0e 94 4b b6 	call	0x16c96	; 0x16c96 <fputc>
   16a4e:	ea 94       	dec	r14
   16a50:	8e 2d       	mov	r24, r14
   16a52:	90 e0       	ldi	r25, 0x00	; 0
   16a54:	08 17       	cp	r16, r24
   16a56:	19 07       	cpc	r17, r25
   16a58:	a8 f3       	brcs	.-22     	; 0x16a44 <vfprintf+0x194>
   16a5a:	0e c0       	rjmp	.+28     	; 0x16a78 <vfprintf+0x1c8>
   16a5c:	f6 01       	movw	r30, r12
   16a5e:	f7 fc       	sbrc	r15, 7
   16a60:	85 91       	lpm	r24, Z+
   16a62:	f7 fe       	sbrs	r15, 7
   16a64:	81 91       	ld	r24, Z+
   16a66:	6f 01       	movw	r12, r30
   16a68:	90 e0       	ldi	r25, 0x00	; 0
   16a6a:	b3 01       	movw	r22, r6
   16a6c:	0e 94 4b b6 	call	0x16c96	; 0x16c96 <fputc>
   16a70:	e1 10       	cpse	r14, r1
   16a72:	ea 94       	dec	r14
   16a74:	01 50       	subi	r16, 0x01	; 1
   16a76:	10 40       	sbci	r17, 0x00	; 0
   16a78:	01 15       	cp	r16, r1
   16a7a:	11 05       	cpc	r17, r1
   16a7c:	79 f7       	brne	.-34     	; 0x16a5c <vfprintf+0x1ac>
   16a7e:	ea c0       	rjmp	.+468    	; 0x16c54 <vfprintf+0x3a4>
   16a80:	94 36       	cpi	r25, 0x64	; 100
   16a82:	11 f0       	breq	.+4      	; 0x16a88 <vfprintf+0x1d8>
   16a84:	99 36       	cpi	r25, 0x69	; 105
   16a86:	69 f5       	brne	.+90     	; 0x16ae2 <vfprintf+0x232>
   16a88:	f7 fe       	sbrs	r15, 7
   16a8a:	08 c0       	rjmp	.+16     	; 0x16a9c <vfprintf+0x1ec>
   16a8c:	f5 01       	movw	r30, r10
   16a8e:	20 81       	ld	r18, Z
   16a90:	31 81       	ldd	r19, Z+1	; 0x01
   16a92:	42 81       	ldd	r20, Z+2	; 0x02
   16a94:	53 81       	ldd	r21, Z+3	; 0x03
   16a96:	84 e0       	ldi	r24, 0x04	; 4
   16a98:	90 e0       	ldi	r25, 0x00	; 0
   16a9a:	0a c0       	rjmp	.+20     	; 0x16ab0 <vfprintf+0x200>
   16a9c:	f5 01       	movw	r30, r10
   16a9e:	80 81       	ld	r24, Z
   16aa0:	91 81       	ldd	r25, Z+1	; 0x01
   16aa2:	9c 01       	movw	r18, r24
   16aa4:	44 27       	eor	r20, r20
   16aa6:	37 fd       	sbrc	r19, 7
   16aa8:	40 95       	com	r20
   16aaa:	54 2f       	mov	r21, r20
   16aac:	82 e0       	ldi	r24, 0x02	; 2
   16aae:	90 e0       	ldi	r25, 0x00	; 0
   16ab0:	a8 0e       	add	r10, r24
   16ab2:	b9 1e       	adc	r11, r25
   16ab4:	9f e6       	ldi	r25, 0x6F	; 111
   16ab6:	f9 22       	and	r15, r25
   16ab8:	57 ff       	sbrs	r21, 7
   16aba:	09 c0       	rjmp	.+18     	; 0x16ace <vfprintf+0x21e>
   16abc:	50 95       	com	r21
   16abe:	40 95       	com	r20
   16ac0:	30 95       	com	r19
   16ac2:	21 95       	neg	r18
   16ac4:	3f 4f       	sbci	r19, 0xFF	; 255
   16ac6:	4f 4f       	sbci	r20, 0xFF	; 255
   16ac8:	5f 4f       	sbci	r21, 0xFF	; 255
   16aca:	e0 e8       	ldi	r30, 0x80	; 128
   16acc:	fe 2a       	or	r15, r30
   16ace:	ca 01       	movw	r24, r20
   16ad0:	b9 01       	movw	r22, r18
   16ad2:	a1 01       	movw	r20, r2
   16ad4:	2a e0       	ldi	r18, 0x0A	; 10
   16ad6:	30 e0       	ldi	r19, 0x00	; 0
   16ad8:	0e 94 77 b6 	call	0x16cee	; 0x16cee <__ultoa_invert>
   16adc:	d8 2e       	mov	r13, r24
   16ade:	d2 18       	sub	r13, r2
   16ae0:	40 c0       	rjmp	.+128    	; 0x16b62 <vfprintf+0x2b2>
   16ae2:	95 37       	cpi	r25, 0x75	; 117
   16ae4:	29 f4       	brne	.+10     	; 0x16af0 <vfprintf+0x240>
   16ae6:	1f 2d       	mov	r17, r15
   16ae8:	1f 7e       	andi	r17, 0xEF	; 239
   16aea:	2a e0       	ldi	r18, 0x0A	; 10
   16aec:	30 e0       	ldi	r19, 0x00	; 0
   16aee:	1d c0       	rjmp	.+58     	; 0x16b2a <vfprintf+0x27a>
   16af0:	1f 2d       	mov	r17, r15
   16af2:	19 7f       	andi	r17, 0xF9	; 249
   16af4:	9f 36       	cpi	r25, 0x6F	; 111
   16af6:	61 f0       	breq	.+24     	; 0x16b10 <vfprintf+0x260>
   16af8:	90 37       	cpi	r25, 0x70	; 112
   16afa:	20 f4       	brcc	.+8      	; 0x16b04 <vfprintf+0x254>
   16afc:	98 35       	cpi	r25, 0x58	; 88
   16afe:	09 f0       	breq	.+2      	; 0x16b02 <vfprintf+0x252>
   16b00:	ac c0       	rjmp	.+344    	; 0x16c5a <vfprintf+0x3aa>
   16b02:	0f c0       	rjmp	.+30     	; 0x16b22 <vfprintf+0x272>
   16b04:	90 37       	cpi	r25, 0x70	; 112
   16b06:	39 f0       	breq	.+14     	; 0x16b16 <vfprintf+0x266>
   16b08:	98 37       	cpi	r25, 0x78	; 120
   16b0a:	09 f0       	breq	.+2      	; 0x16b0e <vfprintf+0x25e>
   16b0c:	a6 c0       	rjmp	.+332    	; 0x16c5a <vfprintf+0x3aa>
   16b0e:	04 c0       	rjmp	.+8      	; 0x16b18 <vfprintf+0x268>
   16b10:	28 e0       	ldi	r18, 0x08	; 8
   16b12:	30 e0       	ldi	r19, 0x00	; 0
   16b14:	0a c0       	rjmp	.+20     	; 0x16b2a <vfprintf+0x27a>
   16b16:	10 61       	ori	r17, 0x10	; 16
   16b18:	14 fd       	sbrc	r17, 4
   16b1a:	14 60       	ori	r17, 0x04	; 4
   16b1c:	20 e1       	ldi	r18, 0x10	; 16
   16b1e:	30 e0       	ldi	r19, 0x00	; 0
   16b20:	04 c0       	rjmp	.+8      	; 0x16b2a <vfprintf+0x27a>
   16b22:	14 fd       	sbrc	r17, 4
   16b24:	16 60       	ori	r17, 0x06	; 6
   16b26:	20 e1       	ldi	r18, 0x10	; 16
   16b28:	32 e0       	ldi	r19, 0x02	; 2
   16b2a:	17 ff       	sbrs	r17, 7
   16b2c:	08 c0       	rjmp	.+16     	; 0x16b3e <vfprintf+0x28e>
   16b2e:	f5 01       	movw	r30, r10
   16b30:	60 81       	ld	r22, Z
   16b32:	71 81       	ldd	r23, Z+1	; 0x01
   16b34:	82 81       	ldd	r24, Z+2	; 0x02
   16b36:	93 81       	ldd	r25, Z+3	; 0x03
   16b38:	44 e0       	ldi	r20, 0x04	; 4
   16b3a:	50 e0       	ldi	r21, 0x00	; 0
   16b3c:	08 c0       	rjmp	.+16     	; 0x16b4e <vfprintf+0x29e>
   16b3e:	f5 01       	movw	r30, r10
   16b40:	80 81       	ld	r24, Z
   16b42:	91 81       	ldd	r25, Z+1	; 0x01
   16b44:	bc 01       	movw	r22, r24
   16b46:	80 e0       	ldi	r24, 0x00	; 0
   16b48:	90 e0       	ldi	r25, 0x00	; 0
   16b4a:	42 e0       	ldi	r20, 0x02	; 2
   16b4c:	50 e0       	ldi	r21, 0x00	; 0
   16b4e:	a4 0e       	add	r10, r20
   16b50:	b5 1e       	adc	r11, r21
   16b52:	a1 01       	movw	r20, r2
   16b54:	0e 94 77 b6 	call	0x16cee	; 0x16cee <__ultoa_invert>
   16b58:	d8 2e       	mov	r13, r24
   16b5a:	d2 18       	sub	r13, r2
   16b5c:	8f e7       	ldi	r24, 0x7F	; 127
   16b5e:	f8 2e       	mov	r15, r24
   16b60:	f1 22       	and	r15, r17
   16b62:	f6 fe       	sbrs	r15, 6
   16b64:	0b c0       	rjmp	.+22     	; 0x16b7c <vfprintf+0x2cc>
   16b66:	5e ef       	ldi	r21, 0xFE	; 254
   16b68:	f5 22       	and	r15, r21
   16b6a:	d9 14       	cp	r13, r9
   16b6c:	38 f4       	brcc	.+14     	; 0x16b7c <vfprintf+0x2cc>
   16b6e:	f4 fe       	sbrs	r15, 4
   16b70:	07 c0       	rjmp	.+14     	; 0x16b80 <vfprintf+0x2d0>
   16b72:	f2 fc       	sbrc	r15, 2
   16b74:	05 c0       	rjmp	.+10     	; 0x16b80 <vfprintf+0x2d0>
   16b76:	8f ee       	ldi	r24, 0xEF	; 239
   16b78:	f8 22       	and	r15, r24
   16b7a:	02 c0       	rjmp	.+4      	; 0x16b80 <vfprintf+0x2d0>
   16b7c:	1d 2d       	mov	r17, r13
   16b7e:	01 c0       	rjmp	.+2      	; 0x16b82 <vfprintf+0x2d2>
   16b80:	19 2d       	mov	r17, r9
   16b82:	f4 fe       	sbrs	r15, 4
   16b84:	0d c0       	rjmp	.+26     	; 0x16ba0 <vfprintf+0x2f0>
   16b86:	fe 01       	movw	r30, r28
   16b88:	ed 0d       	add	r30, r13
   16b8a:	f1 1d       	adc	r31, r1
   16b8c:	80 81       	ld	r24, Z
   16b8e:	80 33       	cpi	r24, 0x30	; 48
   16b90:	19 f4       	brne	.+6      	; 0x16b98 <vfprintf+0x2e8>
   16b92:	99 ee       	ldi	r25, 0xE9	; 233
   16b94:	f9 22       	and	r15, r25
   16b96:	08 c0       	rjmp	.+16     	; 0x16ba8 <vfprintf+0x2f8>
   16b98:	1f 5f       	subi	r17, 0xFF	; 255
   16b9a:	f2 fe       	sbrs	r15, 2
   16b9c:	05 c0       	rjmp	.+10     	; 0x16ba8 <vfprintf+0x2f8>
   16b9e:	03 c0       	rjmp	.+6      	; 0x16ba6 <vfprintf+0x2f6>
   16ba0:	8f 2d       	mov	r24, r15
   16ba2:	86 78       	andi	r24, 0x86	; 134
   16ba4:	09 f0       	breq	.+2      	; 0x16ba8 <vfprintf+0x2f8>
   16ba6:	1f 5f       	subi	r17, 0xFF	; 255
   16ba8:	0f 2d       	mov	r16, r15
   16baa:	f3 fc       	sbrc	r15, 3
   16bac:	14 c0       	rjmp	.+40     	; 0x16bd6 <vfprintf+0x326>
   16bae:	f0 fe       	sbrs	r15, 0
   16bb0:	0f c0       	rjmp	.+30     	; 0x16bd0 <vfprintf+0x320>
   16bb2:	1e 15       	cp	r17, r14
   16bb4:	10 f0       	brcs	.+4      	; 0x16bba <vfprintf+0x30a>
   16bb6:	9d 2c       	mov	r9, r13
   16bb8:	0b c0       	rjmp	.+22     	; 0x16bd0 <vfprintf+0x320>
   16bba:	9d 2c       	mov	r9, r13
   16bbc:	9e 0c       	add	r9, r14
   16bbe:	91 1a       	sub	r9, r17
   16bc0:	1e 2d       	mov	r17, r14
   16bc2:	06 c0       	rjmp	.+12     	; 0x16bd0 <vfprintf+0x320>
   16bc4:	80 e2       	ldi	r24, 0x20	; 32
   16bc6:	90 e0       	ldi	r25, 0x00	; 0
   16bc8:	b3 01       	movw	r22, r6
   16bca:	0e 94 4b b6 	call	0x16c96	; 0x16c96 <fputc>
   16bce:	1f 5f       	subi	r17, 0xFF	; 255
   16bd0:	1e 15       	cp	r17, r14
   16bd2:	c0 f3       	brcs	.-16     	; 0x16bc4 <vfprintf+0x314>
   16bd4:	04 c0       	rjmp	.+8      	; 0x16bde <vfprintf+0x32e>
   16bd6:	1e 15       	cp	r17, r14
   16bd8:	10 f4       	brcc	.+4      	; 0x16bde <vfprintf+0x32e>
   16bda:	e1 1a       	sub	r14, r17
   16bdc:	01 c0       	rjmp	.+2      	; 0x16be0 <vfprintf+0x330>
   16bde:	ee 24       	eor	r14, r14
   16be0:	04 ff       	sbrs	r16, 4
   16be2:	0f c0       	rjmp	.+30     	; 0x16c02 <vfprintf+0x352>
   16be4:	80 e3       	ldi	r24, 0x30	; 48
   16be6:	90 e0       	ldi	r25, 0x00	; 0
   16be8:	b3 01       	movw	r22, r6
   16bea:	0e 94 4b b6 	call	0x16c96	; 0x16c96 <fputc>
   16bee:	02 ff       	sbrs	r16, 2
   16bf0:	1d c0       	rjmp	.+58     	; 0x16c2c <vfprintf+0x37c>
   16bf2:	01 fd       	sbrc	r16, 1
   16bf4:	03 c0       	rjmp	.+6      	; 0x16bfc <vfprintf+0x34c>
   16bf6:	88 e7       	ldi	r24, 0x78	; 120
   16bf8:	90 e0       	ldi	r25, 0x00	; 0
   16bfa:	0e c0       	rjmp	.+28     	; 0x16c18 <vfprintf+0x368>
   16bfc:	88 e5       	ldi	r24, 0x58	; 88
   16bfe:	90 e0       	ldi	r25, 0x00	; 0
   16c00:	0b c0       	rjmp	.+22     	; 0x16c18 <vfprintf+0x368>
   16c02:	80 2f       	mov	r24, r16
   16c04:	86 78       	andi	r24, 0x86	; 134
   16c06:	91 f0       	breq	.+36     	; 0x16c2c <vfprintf+0x37c>
   16c08:	01 ff       	sbrs	r16, 1
   16c0a:	02 c0       	rjmp	.+4      	; 0x16c10 <vfprintf+0x360>
   16c0c:	8b e2       	ldi	r24, 0x2B	; 43
   16c0e:	01 c0       	rjmp	.+2      	; 0x16c12 <vfprintf+0x362>
   16c10:	80 e2       	ldi	r24, 0x20	; 32
   16c12:	f7 fc       	sbrc	r15, 7
   16c14:	8d e2       	ldi	r24, 0x2D	; 45
   16c16:	90 e0       	ldi	r25, 0x00	; 0
   16c18:	b3 01       	movw	r22, r6
   16c1a:	0e 94 4b b6 	call	0x16c96	; 0x16c96 <fputc>
   16c1e:	06 c0       	rjmp	.+12     	; 0x16c2c <vfprintf+0x37c>
   16c20:	80 e3       	ldi	r24, 0x30	; 48
   16c22:	90 e0       	ldi	r25, 0x00	; 0
   16c24:	b3 01       	movw	r22, r6
   16c26:	0e 94 4b b6 	call	0x16c96	; 0x16c96 <fputc>
   16c2a:	9a 94       	dec	r9
   16c2c:	d9 14       	cp	r13, r9
   16c2e:	c0 f3       	brcs	.-16     	; 0x16c20 <vfprintf+0x370>
   16c30:	da 94       	dec	r13
   16c32:	f1 01       	movw	r30, r2
   16c34:	ed 0d       	add	r30, r13
   16c36:	f1 1d       	adc	r31, r1
   16c38:	80 81       	ld	r24, Z
   16c3a:	90 e0       	ldi	r25, 0x00	; 0
   16c3c:	b3 01       	movw	r22, r6
   16c3e:	0e 94 4b b6 	call	0x16c96	; 0x16c96 <fputc>
   16c42:	dd 20       	and	r13, r13
   16c44:	a9 f7       	brne	.-22     	; 0x16c30 <vfprintf+0x380>
   16c46:	06 c0       	rjmp	.+12     	; 0x16c54 <vfprintf+0x3a4>
   16c48:	80 e2       	ldi	r24, 0x20	; 32
   16c4a:	90 e0       	ldi	r25, 0x00	; 0
   16c4c:	b3 01       	movw	r22, r6
   16c4e:	0e 94 4b b6 	call	0x16c96	; 0x16c96 <fputc>
   16c52:	ea 94       	dec	r14
   16c54:	ee 20       	and	r14, r14
   16c56:	c1 f7       	brne	.-16     	; 0x16c48 <vfprintf+0x398>
   16c58:	43 ce       	rjmp	.-890    	; 0x168e0 <vfprintf+0x30>
   16c5a:	f3 01       	movw	r30, r6
   16c5c:	66 81       	ldd	r22, Z+6	; 0x06
   16c5e:	77 81       	ldd	r23, Z+7	; 0x07
   16c60:	cb 01       	movw	r24, r22
   16c62:	2b 96       	adiw	r28, 0x0b	; 11
   16c64:	e2 e1       	ldi	r30, 0x12	; 18
   16c66:	0c 94 72 b7 	jmp	0x16ee4	; 0x16ee4 <__epilogue_restores__>

00016c6a <strnlen_P>:
   16c6a:	fc 01       	movw	r30, r24
   16c6c:	05 90       	lpm	r0, Z+
   16c6e:	61 50       	subi	r22, 0x01	; 1
   16c70:	70 40       	sbci	r23, 0x00	; 0
   16c72:	01 10       	cpse	r0, r1
   16c74:	d8 f7       	brcc	.-10     	; 0x16c6c <strnlen_P+0x2>
   16c76:	80 95       	com	r24
   16c78:	90 95       	com	r25
   16c7a:	8e 0f       	add	r24, r30
   16c7c:	9f 1f       	adc	r25, r31
   16c7e:	08 95       	ret

00016c80 <strnlen>:
   16c80:	fc 01       	movw	r30, r24
   16c82:	61 50       	subi	r22, 0x01	; 1
   16c84:	70 40       	sbci	r23, 0x00	; 0
   16c86:	01 90       	ld	r0, Z+
   16c88:	01 10       	cpse	r0, r1
   16c8a:	d8 f7       	brcc	.-10     	; 0x16c82 <strnlen+0x2>
   16c8c:	80 95       	com	r24
   16c8e:	90 95       	com	r25
   16c90:	8e 0f       	add	r24, r30
   16c92:	9f 1f       	adc	r25, r31
   16c94:	08 95       	ret

00016c96 <fputc>:
   16c96:	0f 93       	push	r16
   16c98:	1f 93       	push	r17
   16c9a:	cf 93       	push	r28
   16c9c:	df 93       	push	r29
   16c9e:	8c 01       	movw	r16, r24
   16ca0:	eb 01       	movw	r28, r22
   16ca2:	8b 81       	ldd	r24, Y+3	; 0x03
   16ca4:	81 ff       	sbrs	r24, 1
   16ca6:	1b c0       	rjmp	.+54     	; 0x16cde <fputc+0x48>
   16ca8:	82 ff       	sbrs	r24, 2
   16caa:	0d c0       	rjmp	.+26     	; 0x16cc6 <fputc+0x30>
   16cac:	2e 81       	ldd	r18, Y+6	; 0x06
   16cae:	3f 81       	ldd	r19, Y+7	; 0x07
   16cb0:	8c 81       	ldd	r24, Y+4	; 0x04
   16cb2:	9d 81       	ldd	r25, Y+5	; 0x05
   16cb4:	28 17       	cp	r18, r24
   16cb6:	39 07       	cpc	r19, r25
   16cb8:	64 f4       	brge	.+24     	; 0x16cd2 <fputc+0x3c>
   16cba:	e8 81       	ld	r30, Y
   16cbc:	f9 81       	ldd	r31, Y+1	; 0x01
   16cbe:	01 93       	st	Z+, r16
   16cc0:	f9 83       	std	Y+1, r31	; 0x01
   16cc2:	e8 83       	st	Y, r30
   16cc4:	06 c0       	rjmp	.+12     	; 0x16cd2 <fputc+0x3c>
   16cc6:	e8 85       	ldd	r30, Y+8	; 0x08
   16cc8:	f9 85       	ldd	r31, Y+9	; 0x09
   16cca:	80 2f       	mov	r24, r16
   16ccc:	09 95       	icall
   16cce:	89 2b       	or	r24, r25
   16cd0:	31 f4       	brne	.+12     	; 0x16cde <fputc+0x48>
   16cd2:	8e 81       	ldd	r24, Y+6	; 0x06
   16cd4:	9f 81       	ldd	r25, Y+7	; 0x07
   16cd6:	01 96       	adiw	r24, 0x01	; 1
   16cd8:	9f 83       	std	Y+7, r25	; 0x07
   16cda:	8e 83       	std	Y+6, r24	; 0x06
   16cdc:	02 c0       	rjmp	.+4      	; 0x16ce2 <fputc+0x4c>
   16cde:	0f ef       	ldi	r16, 0xFF	; 255
   16ce0:	1f ef       	ldi	r17, 0xFF	; 255
   16ce2:	c8 01       	movw	r24, r16
   16ce4:	df 91       	pop	r29
   16ce6:	cf 91       	pop	r28
   16ce8:	1f 91       	pop	r17
   16cea:	0f 91       	pop	r16
   16cec:	08 95       	ret

00016cee <__ultoa_invert>:
   16cee:	fa 01       	movw	r30, r20
   16cf0:	aa 27       	eor	r26, r26
   16cf2:	28 30       	cpi	r18, 0x08	; 8
   16cf4:	51 f1       	breq	.+84     	; 0x16d4a <__ultoa_invert+0x5c>
   16cf6:	20 31       	cpi	r18, 0x10	; 16
   16cf8:	81 f1       	breq	.+96     	; 0x16d5a <__ultoa_invert+0x6c>
   16cfa:	e8 94       	clt
   16cfc:	6f 93       	push	r22
   16cfe:	6e 7f       	andi	r22, 0xFE	; 254
   16d00:	6e 5f       	subi	r22, 0xFE	; 254
   16d02:	7f 4f       	sbci	r23, 0xFF	; 255
   16d04:	8f 4f       	sbci	r24, 0xFF	; 255
   16d06:	9f 4f       	sbci	r25, 0xFF	; 255
   16d08:	af 4f       	sbci	r26, 0xFF	; 255
   16d0a:	b1 e0       	ldi	r27, 0x01	; 1
   16d0c:	3e d0       	rcall	.+124    	; 0x16d8a <__ultoa_invert+0x9c>
   16d0e:	b4 e0       	ldi	r27, 0x04	; 4
   16d10:	3c d0       	rcall	.+120    	; 0x16d8a <__ultoa_invert+0x9c>
   16d12:	67 0f       	add	r22, r23
   16d14:	78 1f       	adc	r23, r24
   16d16:	89 1f       	adc	r24, r25
   16d18:	9a 1f       	adc	r25, r26
   16d1a:	a1 1d       	adc	r26, r1
   16d1c:	68 0f       	add	r22, r24
   16d1e:	79 1f       	adc	r23, r25
   16d20:	8a 1f       	adc	r24, r26
   16d22:	91 1d       	adc	r25, r1
   16d24:	a1 1d       	adc	r26, r1
   16d26:	6a 0f       	add	r22, r26
   16d28:	71 1d       	adc	r23, r1
   16d2a:	81 1d       	adc	r24, r1
   16d2c:	91 1d       	adc	r25, r1
   16d2e:	a1 1d       	adc	r26, r1
   16d30:	20 d0       	rcall	.+64     	; 0x16d72 <__ultoa_invert+0x84>
   16d32:	09 f4       	brne	.+2      	; 0x16d36 <__ultoa_invert+0x48>
   16d34:	68 94       	set
   16d36:	3f 91       	pop	r19
   16d38:	2a e0       	ldi	r18, 0x0A	; 10
   16d3a:	26 9f       	mul	r18, r22
   16d3c:	11 24       	eor	r1, r1
   16d3e:	30 19       	sub	r19, r0
   16d40:	30 5d       	subi	r19, 0xD0	; 208
   16d42:	31 93       	st	Z+, r19
   16d44:	de f6       	brtc	.-74     	; 0x16cfc <__ultoa_invert+0xe>
   16d46:	cf 01       	movw	r24, r30
   16d48:	08 95       	ret
   16d4a:	46 2f       	mov	r20, r22
   16d4c:	47 70       	andi	r20, 0x07	; 7
   16d4e:	40 5d       	subi	r20, 0xD0	; 208
   16d50:	41 93       	st	Z+, r20
   16d52:	b3 e0       	ldi	r27, 0x03	; 3
   16d54:	0f d0       	rcall	.+30     	; 0x16d74 <__ultoa_invert+0x86>
   16d56:	c9 f7       	brne	.-14     	; 0x16d4a <__ultoa_invert+0x5c>
   16d58:	f6 cf       	rjmp	.-20     	; 0x16d46 <__ultoa_invert+0x58>
   16d5a:	46 2f       	mov	r20, r22
   16d5c:	4f 70       	andi	r20, 0x0F	; 15
   16d5e:	40 5d       	subi	r20, 0xD0	; 208
   16d60:	4a 33       	cpi	r20, 0x3A	; 58
   16d62:	18 f0       	brcs	.+6      	; 0x16d6a <__ultoa_invert+0x7c>
   16d64:	49 5d       	subi	r20, 0xD9	; 217
   16d66:	31 fd       	sbrc	r19, 1
   16d68:	40 52       	subi	r20, 0x20	; 32
   16d6a:	41 93       	st	Z+, r20
   16d6c:	02 d0       	rcall	.+4      	; 0x16d72 <__ultoa_invert+0x84>
   16d6e:	a9 f7       	brne	.-22     	; 0x16d5a <__ultoa_invert+0x6c>
   16d70:	ea cf       	rjmp	.-44     	; 0x16d46 <__ultoa_invert+0x58>
   16d72:	b4 e0       	ldi	r27, 0x04	; 4
   16d74:	a6 95       	lsr	r26
   16d76:	97 95       	ror	r25
   16d78:	87 95       	ror	r24
   16d7a:	77 95       	ror	r23
   16d7c:	67 95       	ror	r22
   16d7e:	ba 95       	dec	r27
   16d80:	c9 f7       	brne	.-14     	; 0x16d74 <__ultoa_invert+0x86>
   16d82:	00 97       	sbiw	r24, 0x00	; 0
   16d84:	61 05       	cpc	r22, r1
   16d86:	71 05       	cpc	r23, r1
   16d88:	08 95       	ret
   16d8a:	9b 01       	movw	r18, r22
   16d8c:	ac 01       	movw	r20, r24
   16d8e:	0a 2e       	mov	r0, r26
   16d90:	06 94       	lsr	r0
   16d92:	57 95       	ror	r21
   16d94:	47 95       	ror	r20
   16d96:	37 95       	ror	r19
   16d98:	27 95       	ror	r18
   16d9a:	ba 95       	dec	r27
   16d9c:	c9 f7       	brne	.-14     	; 0x16d90 <__ultoa_invert+0xa2>
   16d9e:	62 0f       	add	r22, r18
   16da0:	73 1f       	adc	r23, r19
   16da2:	84 1f       	adc	r24, r20
   16da4:	95 1f       	adc	r25, r21
   16da6:	a0 1d       	adc	r26, r0
   16da8:	08 95       	ret

00016daa <__mulsi3>:
   16daa:	62 9f       	mul	r22, r18
   16dac:	d0 01       	movw	r26, r0
   16dae:	73 9f       	mul	r23, r19
   16db0:	f0 01       	movw	r30, r0
   16db2:	82 9f       	mul	r24, r18
   16db4:	e0 0d       	add	r30, r0
   16db6:	f1 1d       	adc	r31, r1
   16db8:	64 9f       	mul	r22, r20
   16dba:	e0 0d       	add	r30, r0
   16dbc:	f1 1d       	adc	r31, r1
   16dbe:	92 9f       	mul	r25, r18
   16dc0:	f0 0d       	add	r31, r0
   16dc2:	83 9f       	mul	r24, r19
   16dc4:	f0 0d       	add	r31, r0
   16dc6:	74 9f       	mul	r23, r20
   16dc8:	f0 0d       	add	r31, r0
   16dca:	65 9f       	mul	r22, r21
   16dcc:	f0 0d       	add	r31, r0
   16dce:	99 27       	eor	r25, r25
   16dd0:	72 9f       	mul	r23, r18
   16dd2:	b0 0d       	add	r27, r0
   16dd4:	e1 1d       	adc	r30, r1
   16dd6:	f9 1f       	adc	r31, r25
   16dd8:	63 9f       	mul	r22, r19
   16dda:	b0 0d       	add	r27, r0
   16ddc:	e1 1d       	adc	r30, r1
   16dde:	f9 1f       	adc	r31, r25
   16de0:	bd 01       	movw	r22, r26
   16de2:	cf 01       	movw	r24, r30
   16de4:	11 24       	eor	r1, r1
   16de6:	08 95       	ret

00016de8 <__udivmodqi4>:
   16de8:	99 1b       	sub	r25, r25
   16dea:	79 e0       	ldi	r23, 0x09	; 9
   16dec:	04 c0       	rjmp	.+8      	; 0x16df6 <__udivmodqi4_ep>

00016dee <__udivmodqi4_loop>:
   16dee:	99 1f       	adc	r25, r25
   16df0:	96 17       	cp	r25, r22
   16df2:	08 f0       	brcs	.+2      	; 0x16df6 <__udivmodqi4_ep>
   16df4:	96 1b       	sub	r25, r22

00016df6 <__udivmodqi4_ep>:
   16df6:	88 1f       	adc	r24, r24
   16df8:	7a 95       	dec	r23
   16dfa:	c9 f7       	brne	.-14     	; 0x16dee <__udivmodqi4_loop>
   16dfc:	80 95       	com	r24
   16dfe:	08 95       	ret

00016e00 <__divmodqi4>:
   16e00:	87 fb       	bst	r24, 7
   16e02:	08 2e       	mov	r0, r24
   16e04:	06 26       	eor	r0, r22
   16e06:	87 fd       	sbrc	r24, 7
   16e08:	81 95       	neg	r24
   16e0a:	67 fd       	sbrc	r22, 7
   16e0c:	61 95       	neg	r22
   16e0e:	ec df       	rcall	.-40     	; 0x16de8 <__udivmodqi4>
   16e10:	0e f4       	brtc	.+2      	; 0x16e14 <__divmodqi4_1>
   16e12:	91 95       	neg	r25

00016e14 <__divmodqi4_1>:
   16e14:	07 fc       	sbrc	r0, 7
   16e16:	81 95       	neg	r24

00016e18 <__divmodqi4_exit>:
   16e18:	08 95       	ret

00016e1a <__udivmodhi4>:
   16e1a:	aa 1b       	sub	r26, r26
   16e1c:	bb 1b       	sub	r27, r27
   16e1e:	51 e1       	ldi	r21, 0x11	; 17
   16e20:	07 c0       	rjmp	.+14     	; 0x16e30 <__udivmodhi4_ep>

00016e22 <__udivmodhi4_loop>:
   16e22:	aa 1f       	adc	r26, r26
   16e24:	bb 1f       	adc	r27, r27
   16e26:	a6 17       	cp	r26, r22
   16e28:	b7 07       	cpc	r27, r23
   16e2a:	10 f0       	brcs	.+4      	; 0x16e30 <__udivmodhi4_ep>
   16e2c:	a6 1b       	sub	r26, r22
   16e2e:	b7 0b       	sbc	r27, r23

00016e30 <__udivmodhi4_ep>:
   16e30:	88 1f       	adc	r24, r24
   16e32:	99 1f       	adc	r25, r25
   16e34:	5a 95       	dec	r21
   16e36:	a9 f7       	brne	.-22     	; 0x16e22 <__udivmodhi4_loop>
   16e38:	80 95       	com	r24
   16e3a:	90 95       	com	r25
   16e3c:	bc 01       	movw	r22, r24
   16e3e:	cd 01       	movw	r24, r26
   16e40:	08 95       	ret

00016e42 <__divmodhi4>:
   16e42:	97 fb       	bst	r25, 7
   16e44:	09 2e       	mov	r0, r25
   16e46:	07 26       	eor	r0, r23
   16e48:	0a d0       	rcall	.+20     	; 0x16e5e <__divmodhi4_neg1>
   16e4a:	77 fd       	sbrc	r23, 7
   16e4c:	04 d0       	rcall	.+8      	; 0x16e56 <__divmodhi4_neg2>
   16e4e:	e5 df       	rcall	.-54     	; 0x16e1a <__udivmodhi4>
   16e50:	06 d0       	rcall	.+12     	; 0x16e5e <__divmodhi4_neg1>
   16e52:	00 20       	and	r0, r0
   16e54:	1a f4       	brpl	.+6      	; 0x16e5c <__divmodhi4_exit>

00016e56 <__divmodhi4_neg2>:
   16e56:	70 95       	com	r23
   16e58:	61 95       	neg	r22
   16e5a:	7f 4f       	sbci	r23, 0xFF	; 255

00016e5c <__divmodhi4_exit>:
   16e5c:	08 95       	ret

00016e5e <__divmodhi4_neg1>:
   16e5e:	f6 f7       	brtc	.-4      	; 0x16e5c <__divmodhi4_exit>
   16e60:	90 95       	com	r25
   16e62:	81 95       	neg	r24
   16e64:	9f 4f       	sbci	r25, 0xFF	; 255
   16e66:	08 95       	ret

00016e68 <__udivmodsi4>:
   16e68:	a1 e2       	ldi	r26, 0x21	; 33
   16e6a:	1a 2e       	mov	r1, r26
   16e6c:	aa 1b       	sub	r26, r26
   16e6e:	bb 1b       	sub	r27, r27
   16e70:	fd 01       	movw	r30, r26
   16e72:	0d c0       	rjmp	.+26     	; 0x16e8e <__udivmodsi4_ep>

00016e74 <__udivmodsi4_loop>:
   16e74:	aa 1f       	adc	r26, r26
   16e76:	bb 1f       	adc	r27, r27
   16e78:	ee 1f       	adc	r30, r30
   16e7a:	ff 1f       	adc	r31, r31
   16e7c:	a2 17       	cp	r26, r18
   16e7e:	b3 07       	cpc	r27, r19
   16e80:	e4 07       	cpc	r30, r20
   16e82:	f5 07       	cpc	r31, r21
   16e84:	20 f0       	brcs	.+8      	; 0x16e8e <__udivmodsi4_ep>
   16e86:	a2 1b       	sub	r26, r18
   16e88:	b3 0b       	sbc	r27, r19
   16e8a:	e4 0b       	sbc	r30, r20
   16e8c:	f5 0b       	sbc	r31, r21

00016e8e <__udivmodsi4_ep>:
   16e8e:	66 1f       	adc	r22, r22
   16e90:	77 1f       	adc	r23, r23
   16e92:	88 1f       	adc	r24, r24
   16e94:	99 1f       	adc	r25, r25
   16e96:	1a 94       	dec	r1
   16e98:	69 f7       	brne	.-38     	; 0x16e74 <__udivmodsi4_loop>
   16e9a:	60 95       	com	r22
   16e9c:	70 95       	com	r23
   16e9e:	80 95       	com	r24
   16ea0:	90 95       	com	r25
   16ea2:	9b 01       	movw	r18, r22
   16ea4:	ac 01       	movw	r20, r24
   16ea6:	bd 01       	movw	r22, r26
   16ea8:	cf 01       	movw	r24, r30
   16eaa:	08 95       	ret

00016eac <__prologue_saves__>:
   16eac:	2f 92       	push	r2
   16eae:	3f 92       	push	r3
   16eb0:	4f 92       	push	r4
   16eb2:	5f 92       	push	r5
   16eb4:	6f 92       	push	r6
   16eb6:	7f 92       	push	r7
   16eb8:	8f 92       	push	r8
   16eba:	9f 92       	push	r9
   16ebc:	af 92       	push	r10
   16ebe:	bf 92       	push	r11
   16ec0:	cf 92       	push	r12
   16ec2:	df 92       	push	r13
   16ec4:	ef 92       	push	r14
   16ec6:	ff 92       	push	r15
   16ec8:	0f 93       	push	r16
   16eca:	1f 93       	push	r17
   16ecc:	cf 93       	push	r28
   16ece:	df 93       	push	r29
   16ed0:	cd b7       	in	r28, 0x3d	; 61
   16ed2:	de b7       	in	r29, 0x3e	; 62
   16ed4:	ca 1b       	sub	r28, r26
   16ed6:	db 0b       	sbc	r29, r27
   16ed8:	0f b6       	in	r0, 0x3f	; 63
   16eda:	f8 94       	cli
   16edc:	de bf       	out	0x3e, r29	; 62
   16ede:	0f be       	out	0x3f, r0	; 63
   16ee0:	cd bf       	out	0x3d, r28	; 61
   16ee2:	09 94       	ijmp

00016ee4 <__epilogue_restores__>:
   16ee4:	2a 88       	ldd	r2, Y+18	; 0x12
   16ee6:	39 88       	ldd	r3, Y+17	; 0x11
   16ee8:	48 88       	ldd	r4, Y+16	; 0x10
   16eea:	5f 84       	ldd	r5, Y+15	; 0x0f
   16eec:	6e 84       	ldd	r6, Y+14	; 0x0e
   16eee:	7d 84       	ldd	r7, Y+13	; 0x0d
   16ef0:	8c 84       	ldd	r8, Y+12	; 0x0c
   16ef2:	9b 84       	ldd	r9, Y+11	; 0x0b
   16ef4:	aa 84       	ldd	r10, Y+10	; 0x0a
   16ef6:	b9 84       	ldd	r11, Y+9	; 0x09
   16ef8:	c8 84       	ldd	r12, Y+8	; 0x08
   16efa:	df 80       	ldd	r13, Y+7	; 0x07
   16efc:	ee 80       	ldd	r14, Y+6	; 0x06
   16efe:	fd 80       	ldd	r15, Y+5	; 0x05
   16f00:	0c 81       	ldd	r16, Y+4	; 0x04
   16f02:	1b 81       	ldd	r17, Y+3	; 0x03
   16f04:	aa 81       	ldd	r26, Y+2	; 0x02
   16f06:	b9 81       	ldd	r27, Y+1	; 0x01
   16f08:	ce 0f       	add	r28, r30
   16f0a:	d1 1d       	adc	r29, r1
   16f0c:	0f b6       	in	r0, 0x3f	; 63
   16f0e:	f8 94       	cli
   16f10:	de bf       	out	0x3e, r29	; 62
   16f12:	0f be       	out	0x3f, r0	; 63
   16f14:	cd bf       	out	0x3d, r28	; 61
   16f16:	ed 01       	movw	r28, r26
   16f18:	08 95       	ret

00016f1a <_exit>:
   16f1a:	f8 94       	cli

00016f1c <__stop_program>:
   16f1c:	ff cf       	rjmp	.-2      	; 0x16f1c <__stop_program>
