
master4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005e  00800100  0001721a  000172ce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0001721a  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000ea9  0080015e  0080015e  0001732c  2**0
                  ALLOC
  3 .eeprom       00000857  00810000  00810000  0001732c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000000e0  00000000  00000000  00017b83  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000026fb  00000000  00000000  00017c63  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00013e8f  00000000  00000000  0001a35e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c66  00000000  00000000  0002e1ed  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000e1f5  00000000  00000000  0002ee53  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001220  00000000  00000000  0003d048  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000053f8  00000000  00000000  0003e268  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007645  00000000  00000000  00043660  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006f0  00000000  00000000  0004aca5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 43 12 	jmp	0x2486	; 0x2486 <__ctors_end>
       4:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
       8:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
       c:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      10:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      14:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      18:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      1c:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      20:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      24:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      28:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      2c:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      30:	0c 94 0c 13 	jmp	0x2618	; 0x2618 <__vector_12>
      34:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      38:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      3c:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      40:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      44:	0c 94 0e 7d 	jmp	0xfa1c	; 0xfa1c <__vector_17>
      48:	0c 94 c5 14 	jmp	0x298a	; 0x298a <__vector_18>
      4c:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      50:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      54:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      58:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      5c:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      60:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      64:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      68:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      6c:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      70:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      74:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      78:	0c 94 04 42 	jmp	0x8408	; 0x8408 <__vector_30>
      7c:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      80:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      84:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      88:	0c 94 62 12 	jmp	0x24c4	; 0x24c4 <__bad_interrupt>
      8c:	a4 13       	cpse	r26, r20
      8e:	a2 13       	cpse	r26, r18
      90:	a6 13       	cpse	r26, r22
      92:	a8 13       	cpse	r26, r24
      94:	aa 13       	cpse	r26, r26
      96:	ac 13       	cpse	r26, r28
      98:	ae 13       	cpse	r26, r30
      9a:	b0 13       	cpse	r27, r16
      9c:	b2 13       	cpse	r27, r18
      9e:	b4 13       	cpse	r27, r20
      a0:	b6 13       	cpse	r27, r22
      a2:	b8 13       	cpse	r27, r24
      a4:	ba 13       	cpse	r27, r26
      a6:	c8 13       	cpse	r28, r24
      a8:	bc 13       	cpse	r27, r28
      aa:	c8 13       	cpse	r28, r24
      ac:	be 13       	cpse	r27, r30
      ae:	c0 13       	cpse	r28, r16
      b0:	c8 13       	cpse	r28, r24
      b2:	c2 13       	cpse	r28, r18
      b4:	c4 13       	cpse	r28, r20
      b6:	c6 13       	cpse	r28, r22
      b8:	c8 13       	cpse	r28, r24
      ba:	c8 13       	cpse	r28, r24
      bc:	bc 13       	cpse	r27, r28
      be:	ae 13       	cpse	r26, r30
      c0:	c8 13       	cpse	r28, r24
      c2:	b0 13       	cpse	r27, r16
      c4:	b4 13       	cpse	r27, r20
      c6:	b8 13       	cpse	r27, r24
      c8:	bd 54       	subi	r27, 0x4D	; 77
      ca:	d5 54       	subi	r29, 0x45	; 69
      cc:	e7 54       	subi	r30, 0x47	; 71
      ce:	1c 55       	subi	r17, 0x5C	; 92
      d0:	4d 55       	subi	r20, 0x5D	; 93
      d2:	63 55       	subi	r22, 0x53	; 83
      d4:	98 55       	subi	r25, 0x58	; 88
      d6:	d2 55       	subi	r29, 0x52	; 82
      d8:	16 56       	subi	r17, 0x66	; 102
      da:	1e 56       	subi	r17, 0x6E	; 110
      dc:	36 56       	subi	r19, 0x66	; 102
      de:	42 56       	subi	r20, 0x62	; 98
      e0:	74 56       	subi	r23, 0x64	; 100
      e2:	b5 56       	subi	r27, 0x65	; 101
      e4:	d2 56       	subi	r29, 0x62	; 98
      e6:	ec 56       	subi	r30, 0x6C	; 108
      e8:	2c 57       	subi	r18, 0x7C	; 124
      ea:	33 55       	subi	r19, 0x53	; 83
      ec:	ee 55       	subi	r30, 0x5E	; 94
      ee:	8f 56       	subi	r24, 0x6F	; 111
      f0:	b8 55       	subi	r27, 0x58	; 88
      f2:	52 57       	subi	r21, 0x72	; 114
      f4:	68 57       	subi	r22, 0x78	; 120
      f6:	6d 57       	subi	r22, 0x7D	; 125
      f8:	a6 57       	subi	r26, 0x76	; 118
      fa:	d7 57       	subi	r29, 0x77	; 119
      fc:	1c 58       	subi	r17, 0x8C	; 140
      fe:	3c 58       	subi	r19, 0x8C	; 140
     100:	5a 58       	subi	r21, 0x8A	; 138
     102:	94 58       	subi	r25, 0x84	; 132
     104:	f7 58       	subi	r31, 0x87	; 135
     106:	3b 5d       	subi	r19, 0xDB	; 219
     108:	bd 57       	subi	r27, 0x7D	; 125
     10a:	63 5d       	subi	r22, 0xD3	; 211
     10c:	c3 5d       	subi	r28, 0xD3	; 211
     10e:	7d 5d       	subi	r23, 0xDD	; 221
     110:	a8 5d       	subi	r26, 0xD8	; 216
     112:	fd 5d       	subi	r31, 0xDD	; 221
     114:	dd 5d       	subi	r29, 0xDD	; 221
     116:	16 5e       	subi	r17, 0xE6	; 230
     118:	31 5e       	subi	r19, 0xE1	; 225
     11a:	43 5e       	subi	r20, 0xE3	; 227
     11c:	07 59       	subi	r16, 0x97	; 151
     11e:	27 59       	subi	r18, 0x97	; 151
     120:	4e 59       	subi	r20, 0x9E	; 158
     122:	5d 59       	subi	r21, 0x9D	; 157
     124:	7b 59       	subi	r23, 0x9B	; 155
     126:	92 59       	subi	r25, 0x92	; 146
     128:	be 59       	subi	r27, 0x9E	; 158
     12a:	d5 59       	subi	r29, 0x95	; 149
     12c:	01 5a       	subi	r16, 0xA1	; 161
     12e:	21 5a       	subi	r18, 0xA1	; 161
     130:	52 5a       	subi	r21, 0xA2	; 162
     132:	61 5a       	subi	r22, 0xA1	; 161
     134:	ba 5a       	subi	r27, 0xAA	; 170
     136:	31 5b       	subi	r19, 0xB1	; 177
     138:	45 5b       	subi	r20, 0xB5	; 181
     13a:	20 5c       	subi	r18, 0xC0	; 192
     13c:	20 5c       	subi	r18, 0xC0	; 192
     13e:	59 5b       	subi	r21, 0xB9	; 185
     140:	6d 5b       	subi	r22, 0xBD	; 189
     142:	75 5b       	subi	r23, 0xB5	; 181
     144:	91 5b       	subi	r25, 0xB1	; 177
     146:	a5 5b       	subi	r26, 0xB5	; 181
     148:	b2 5b       	subi	r27, 0xB2	; 178
     14a:	c9 5b       	subi	r28, 0xB9	; 185
     14c:	e0 5b       	subi	r30, 0xB0	; 176
     14e:	fe 5b       	subi	r31, 0xBE	; 190
     150:	23 5c       	subi	r18, 0xC3	; 195
     152:	3a 5c       	subi	r19, 0xCA	; 202
     154:	51 5c       	subi	r21, 0xC1	; 193
     156:	68 5c       	subi	r22, 0xC8	; 200
     158:	7f 5c       	subi	r23, 0xCF	; 207
     15a:	96 5c       	subi	r25, 0xC6	; 198
     15c:	ad 5c       	subi	r26, 0xCD	; 205
     15e:	c4 5c       	subi	r28, 0xC4	; 196
     160:	d3 5c       	subi	r29, 0xC3	; 195
     162:	ea 5c       	subi	r30, 0xCA	; 202
     164:	0d 5d       	subi	r16, 0xDD	; 221
     166:	03 90       	.word	0x9003	; ????
     168:	1f 90       	pop	r1
     16a:	32 90       	ld	r3, -Z
     16c:	61 90       	ld	r6, Z+
     16e:	8a 90       	ld	r8, -Y
     170:	fd 90       	ld	r15, X+
     172:	0f 91       	pop	r16
     174:	18 91       	.word	0x9118	; ????
     176:	54 91       	lpm	r21, Z+
     178:	7b 91       	.word	0x917b	; ????
     17a:	c2 91       	ld	r28, -Z
     17c:	cc 91       	ld	r28, X
     17e:	87 91       	elpm	r24, Z+
     180:	d2 91       	ld	r29, -Z
     182:	2f 90       	pop	r2
     184:	e4 91       	lpm	r30, Z+
     186:	ea 91       	ld	r30, -Y
     188:	8c 94 90 94 	jmp	0x212920	; 0x212920 <__data_load_end+0x1fb6a8>
     18c:	ac 94 a8 98 	jmp	0x293150	; 0x293150 <__data_load_end+0x27bed8>
     190:	a8 98       	cbi	0x15, 0	; 21
     192:	a8 98       	cbi	0x15, 0	; 21
     194:	a8 98       	cbi	0x15, 0	; 21
     196:	fe 94 a8 98 	call	0x3d3150	; 0x3d3150 <__data_load_end+0x3bbed8>
     19a:	20 95       	com	r18
     19c:	a8 98       	cbi	0x15, 0	; 21
     19e:	3f 95 c8 95 	call	0x4f2b90	; 0x4f2b90 <__data_load_end+0x4db918>
     1a2:	28 96       	adiw	r28, 0x08	; 8
     1a4:	4c 96       	adiw	r24, 0x1c	; 28
     1a6:	dd 94 a8 98 	jmp	0x373150	; 0x373150 <__data_load_end+0x35bed8>
     1aa:	e0 95       	com	r30
     1ac:	64 96       	adiw	r28, 0x14	; 20
     1ae:	9c 96       	adiw	r26, 0x2c	; 44
     1b0:	b9 96       	adiw	r30, 0x29	; 41
     1b2:	f5 96       	adiw	r30, 0x35	; 53
     1b4:	05 97       	sbiw	r24, 0x05	; 5
     1b6:	16 98       	cbi	0x02, 6	; 2
     1b8:	26 98       	cbi	0x04, 6	; 4
     1ba:	6b 98       	cbi	0x0d, 3	; 13
     1bc:	8a 98       	cbi	0x11, 2	; 17
     1be:	9c 98       	cbi	0x13, 4	; 19
     1c0:	a2 98       	cbi	0x14, 2	; 20
     1c2:	a4 98       	cbi	0x14, 4	; 20
     1c4:	9f 9a       	sbi	0x13, 7	; 19
     1c6:	a5 9a       	sbi	0x14, 5	; 20
     1c8:	a9 9a       	sbi	0x15, 1	; 21
     1ca:	c0 9a       	sbi	0x18, 0	; 24
     1cc:	da 9a       	sbi	0x1b, 2	; 27
     1ce:	de 9a       	sbi	0x1b, 6	; 27
     1d0:	0d 9b       	sbis	0x01, 5	; 1
     1d2:	2c 9b       	sbis	0x05, 4	; 5
     1d4:	32 9b       	sbis	0x06, 2	; 6
     1d6:	3b 9b       	sbis	0x07, 3	; 7
     1d8:	3e 9b       	sbis	0x07, 6	; 7
     1da:	41 9b       	sbis	0x08, 1	; 8
     1dc:	44 9b       	sbis	0x08, 4	; 8
     1de:	47 9b       	sbis	0x08, 7	; 8
     1e0:	4a 9b       	sbis	0x09, 2	; 9
     1e2:	50 9b       	sbis	0x0a, 0	; 10
     1e4:	53 9b       	sbis	0x0a, 3	; 10
     1e6:	56 9b       	sbis	0x0a, 6	; 10
     1e8:	60 9b       	sbis	0x0c, 0	; 12
     1ea:	23 9d       	mul	r18, r3
     1ec:	7c 9d       	mul	r23, r12
     1ee:	8a 9d       	mul	r24, r10
     1f0:	d2 9d       	mul	r29, r2
     1f2:	e8 9d       	mul	r30, r8
     1f4:	ff 9d       	mul	r31, r15
     1f6:	28 9e       	mul	r2, r24
     1f8:	de 9e       	mul	r13, r30
     1fa:	ec 9e       	mul	r14, r28
     1fc:	6b 9f       	mul	r22, r27
     1fe:	17 a0       	ldd	r1, Z+39	; 0x27
     200:	1b a1       	ldd	r17, Y+35	; 0x23
     202:	6c a1       	ldd	r22, Y+36	; 0x24
     204:	b2 a1       	ldd	r27, Z+34	; 0x22
     206:	2f a2       	std	Y+39, r2	; 0x27
     208:	c3 a2       	std	Z+35, r12	; 0x23
     20a:	69 a3       	std	Y+33, r22	; 0x21
     20c:	2f a4       	ldd	r2, Y+47	; 0x2f
     20e:	5b a4       	ldd	r5, Y+43	; 0x2b
     210:	14 a5       	ldd	r17, Z+44	; 0x2c
     212:	31 a5       	ldd	r19, Z+41	; 0x29
     214:	47 a6       	std	Z+47, r4	; 0x2f
     216:	ab a5       	ldd	r26, Y+43	; 0x2b
     218:	f2 a5       	ldd	r31, Z+42	; 0x2a
     21a:	e8 a6       	std	Y+40, r14	; 0x28
     21c:	16 a7       	std	Z+46, r17	; 0x2e
     21e:	2b a7       	std	Y+43, r18	; 0x2b
     220:	4f a6       	std	Y+47, r4	; 0x2f
     222:	d3 a6       	std	Z+43, r13	; 0x2b
     224:	1c a7       	std	Y+44, r17	; 0x2c
     226:	24 a7       	std	Z+44, r18	; 0x2c
     228:	89 ab       	std	Y+49, r24	; 0x31
     22a:	8c ab       	std	Y+52, r24	; 0x34
     22c:	4e ac       	ldd	r4, Y+62	; 0x3e
     22e:	5d ac       	ldd	r5, Y+61	; 0x3d
     230:	90 ac       	ldd	r9, Z+56	; 0x38
     232:	a0 ac       	ldd	r10, Z+56	; 0x38
     234:	ce ac       	ldd	r12, Y+62	; 0x3e
     236:	6d ac       	ldd	r6, Y+61	; 0x3d
     238:	7c ac       	ldd	r7, Y+60	; 0x3c
     23a:	86 ac       	ldd	r8, Z+62	; 0x3e
     23c:	d8 ac       	ldd	r13, Y+56	; 0x38
     23e:	e5 ac       	ldd	r14, Z+61	; 0x3d
     240:	f0 ac       	ldd	r15, Z+56	; 0x38
     242:	f3 ac       	ldd	r15, Z+59	; 0x3b
     244:	f6 ac       	ldd	r15, Z+62	; 0x3e
     246:	f9 ac       	ldd	r15, Y+57	; 0x39
     248:	fc ac       	ldd	r15, Y+60	; 0x3c
     24a:	ff ac       	ldd	r15, Y+63	; 0x3f
     24c:	02 ad       	ldd	r16, Z+58	; 0x3a
     24e:	05 ad       	ldd	r16, Z+61	; 0x3d
     250:	27 ad       	ldd	r18, Z+63	; 0x3f
     252:	15 ad       	ldd	r17, Z+61	; 0x3d
     254:	08 ad       	ldd	r16, Y+56	; 0x38
     256:	20 ad       	ldd	r18, Z+56	; 0x38
     258:	38 ac       	ldd	r3, Y+56	; 0x38

0000025a <__logo>:
     25a:	00 00 00 01 01 01 05 09 00 00 00 11 11 11 15 15     ................
     26a:	11 00 00 00 00 10 10 10 14 12 00 0f 07 03 01 01     ................
     27a:	01 01 00 00 11 11 11 11 11 11 00 00 00 1e 1c 18     ................
     28a:	10 10 10 10 00 00 1f 1b 15 17 17 15 1b 1f 00 14     ................
     29a:	14 08 08 07 04 06 04 00                             ........

000002a2 <__c.3009>:
     2a2:	49 6e 69 74 69 61 6c 69 7a 65 2e 2e 2e 20 00        Initialize... .

000002b1 <__c.2993>:
     2b1:	57 61 74 63 68 44 6f 67 00                          WatchDog.

000002ba <__c.2991>:
     2ba:	42 72 6f 77 6e 4f 75 74 00                          BrownOut.

000002c3 <__c.2989>:
     2c3:	45 78 74 65 72 6e 61 6c 00                          External.

000002cc <__c.2987>:
     2cc:	50 6f 77 65 72 4f 6e 00                             PowerOn.

000002d4 <__prodloc>:
     2d4:	01 06 02 06 01 0d 02 0d 01 14 02 14                 ............

000002e0 <__prntloc>:
     2e0:	01 08 02 08 03 08 04 08 01 13 02 13                 ............

000002ec <__prntlmt>:
     2ec:	02 03 04 02 0f 0f                                   ......

000002f2 <__prntstr>:
     2f2:	01 01 00 00 00 00                                   ......

000002f8 <__hostloc>:
     2f8:	01 0a 02 0a 03 0a                                   ......

000002fe <MaxKeyHit>:
     2fe:	02 04 03 03 03 03 03 04 03 04                       ..........

00000308 <strDispenserName1>:
     308:	4e 2f 41 00                                         N/A.

0000030c <strDispenserName2>:
     30c:	47 69 6c 62 61 72 63 6f 00                          Gilbarco.

00000315 <strDispenserName3>:
     315:	57 61 79 6e 65 20 44 41 52 54 00                    Wayne DART.

00000320 <strDispenserName4>:
     320:	54 61 74 73 75 6e 6f 00                             Tatsuno.

00000328 <strDispenserName5>:
     328:	4c 47 00                                            LG.

0000032b <DefListDispenserName>:
     32b:	08 03 0c 03 15 03 20 03 28 03                       ...... .(.

00000335 <__c.10216>:
     335:	4d 72 2e 42 69 67 00                                Mr.Big.

0000033c <__c.10121>:
     33c:	25 64 00                                            %d.

0000033f <__c.10119>:
     33f:	54 25 2e 32 64 25 2e 32 64 25 73 25 73 25 73 25     T%.2d%.2d%s%s%s%
     34f:	73 25 73 25 73 3a 00                                s%s%s:.

00000356 <__c.10070>:
     356:	32 30 25 73 2f 25 73 2f 25 73 20 25 73 3a 25 73     20%s/%s/%s %s:%s
     366:	3a 25 73 00                                         :%s.

0000036a <__c.10042>:
     36a:	25 73 00                                            %s.

0000036d <__c.10033>:
     36d:	25 73 00                                            %s.

00000370 <__c.9982>:
     370:	25 63 25 2e 32 64 3a 00                             %c%.2d:.

00000378 <__c.9961>:
     378:	43 54 53 52 50 00                                   CTSRP.

0000037e <__c.9937>:
     37e:	3a 00                                               :.

00000380 <__c.9881>:
     380:	46 6d 74 54 4d 6f 6e 65 79 3a 25 73 00              FmtTMoney:%s.

0000038d <__c.9879>:
     38d:	46 6d 74 4d 6f 6e 65 79 3a 25 73 00                 FmtMoney:%s.

00000399 <__c.9877>:
     399:	54 4d 6f 6e 65 79 3a 25 73 00                       TMoney:%s.

000003a3 <__c.9875>:
     3a3:	54 56 6f 6c 75 6d 65 3a 25 73 00                    TVolume:%s.

000003ae <__c.9873>:
     3ae:	4d 6f 6e 65 79 3a 25 73 00                          Money:%s.

000003b7 <__c.9871>:
     3b7:	56 6f 6c 75 6d 65 3a 25 73 00                       Volume:%s.

000003c1 <__c.9869>:
     3c1:	52 65 6d 6f 76 65 64 3a 25 73 00                    Removed:%s.

000003cc <__c.9867>:
     3cc:	4d 69 6e 75 73 3a 25 73 00                          Minus:%s.

000003d5 <__c.9865>:
     3d5:	52 61 77 3a 25 73 00                                Raw:%s.

000003dc <__c.9863>:
     3dc:	46 6f 72 6d 61 74 65 64 3a 25 73 00                 Formated:%s.

000003e8 <__c.9861>:
     3e8:	25 73 00                                            %s.

000003eb <__c.9859>:
     3eb:	25 73 00                                            %s.

000003ee <__c.9857>:
     3ee:	25 73 00                                            %s.

000003f1 <__c.9855>:
     3f1:	25 73 00                                            %s.

000003f4 <__c.9853>:
     3f4:	44 61 74 61 3a 25 73 00                             Data:%s.

000003fc <__c.9742>:
     3fc:	4e 2f 41 00                                         N/A.

00000400 <__c.9722>:
     400:	25 73 00                                            %s.

00000403 <__c.9717>:
	...

00000404 <__c.9590>:
     404:	25 64 2e 25 73 25 73 25 73 00                       %d.%s%s%s.

0000040e <__c.9588>:
     40e:	25 64 2e 25 73 25 73 25 73 25 73 25 73 00           %d.%s%s%s%s%s.

0000041c <__c.9580>:
     41c:	54 4f 54 41 4c 20 25 73 25 73 00                    TOTAL %s%s.

00000427 <__c.9578>:
     427:	54 4f 54 41 4c 20 25 73 25 73 25 73 25 73 00        TOTAL %s%s%s%s.

00000436 <__c.9574>:
     436:	25 73 25 73 00                                      %s%s.

0000043b <__c.9572>:
     43b:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

00000444 <__c.9570>:
     444:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     454:	20 20 20 20 20 20 20 20 20 20 20 20 20 00                        .

00000462 <__c.9568>:
     462:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     472:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00           -------------.

00000480 <__c.9566>:
     480:	41 77 61 6c 20 3a 25 73 25 73 00                    Awal :%s%s.

0000048b <__c.9564>:
     48b:	41 77 61 6c 20 3a 25 73 25 73 25 73 25 73 00        Awal :%s%s%s%s.

0000049a <__c.9562>:
     49a:	41 6b 68 69 72 3a 25 73 25 73 00                    Akhir:%s%s.

000004a5 <__c.9560>:
     4a5:	41 6b 68 69 72 3a 25 73 25 73 25 73 25 73 00        Akhir:%s%s%s%s.

000004b4 <__c.9558>:
     4b4:	50 25 64 2e 25 64 20 2d 20 25 73 20 00              P%d.%d - %s .

000004c1 <__c.9556>:
     4c1:	50 25 64 2e 25 64 20 2d 20 25 73 20 25 73 20 25     P%d.%d - %s %s %
     4d1:	73 00                                               s.

000004d3 <__c.9554>:
     4d3:	48 61 72 67 61 3a 20 52 70 2e 25 73 00              Harga: Rp.%s.

000004e0 <__c.9550>:
     4e0:	4e 2f 41 00                                         N/A.

000004e4 <__c.9546>:
     4e4:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     4f4:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 20 20 20 20     OLUME(L)        
     504:	20 20 20 20 20 20 00                                      .

0000050b <__c.9544>:
     50b:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     51b:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 52 55 50 49     OLUME(L)    RUPI
     52b:	41 48 28 52 50 29 00                                AH(RP).

00000532 <__c.9540>:
     532:	41 6b 68 69 72 20 53 68 69 66 74 20 3a 20 25 73     Akhir Shift : %s
     542:	20 00                                                .

00000544 <__c.9538>:
     544:	41 77 61 6c 20 20 53 68 69 66 74 20 3a 20 25 73     Awal  Shift : %s
     554:	20 00                                                .

00000556 <__c.9536>:
     556:	54 65 72 6d 69 6e 61 6c 20 49 44 20 3a 20 25 2e     Terminal ID : %.
     566:	32 64 20 20 20 20 20 20 20 20 20 20 20 20 20 20     2d              
     576:	20 20 20 20 20 00                                        .

0000057c <__c.9534>:
     57c:	20 20 20 20 20 20 20 20 4c 61 70 6f 72 61 6e 20             Laporan 
     58c:	54 75 74 75 70 20 53 68 69 66 74 3a 20 25 73 20     Tutup Shift: %s 
     59c:	20 20 20 20 20 00                                        .

000005a2 <__c.9531>:
     5a2:	25 64 00                                            %d.

000005a5 <__c.9473>:
     5a5:	25 73 00                                            %s.

000005a8 <__c.9468>:
     5a8:	30 00                                               0.

000005aa <__c.9466>:
     5aa:	30 00                                               0.

000005ac <__c.9302>:
     5ac:	25 73 00                                            %s.

000005af <__c.9300>:
     5af:	25 73 00                                            %s.

000005b2 <__c.9298>:
     5b2:	25 73 00                                            %s.

000005b5 <__c.9296>:
     5b5:	25 73 00                                            %s.

000005b8 <__c.9294>:
     5b8:	25 73 00                                            %s.

000005bb <__c.9208>:
     5bb:	41 2b 42 3a 25 73 00                                A+B:%s.

000005c2 <__c.9206>:
     5c2:	49 6e 42 3a 25 73 00                                InB:%s.

000005c9 <__c.9202>:
     5c9:	49 6e 42 3a 5f 00                                   InB:_.

000005cf <__c.9200>:
     5cf:	49 6e 41 3a 25 73 00                                InA:%s.

000005d6 <__c.9195>:
     5d6:	49 6e 41 3a 5f 00                                   InA:_.

000005dc <__c.9193>:
     5dc:	4f 70 65 72 61 74 69 6f 6e 20 4d 75 6c 74 69 70     Operation Multip
     5ec:	6c 79 00                                            ly.

000005ef <__c.9064>:
     5ef:	25 73 00                                            %s.

000005f2 <__c.8976>:
     5f2:	30 30 30 30 30 30 30 30 00                          00000000.

000005fb <__c.8819>:
     5fb:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     60b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     61b:	20 20 20 00                                            .

0000061f <__c.8817>:
     61f:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     62f:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     63f:	20 20 20 00                                            .

00000643 <__c.8670>:
     643:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     653:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     663:	2d 2d 00                                            --.

00000666 <__c.8667>:
     666:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 41          Surcharge A
     676:	6d 74 3a 20 25 73 00                                mt: %s.

0000067d <__c.8664>:
     67d:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 44          Surcharge D
     68d:	73 63 3a 20 25 73 00                                sc: %s.

00000694 <__c.8661>:
     694:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     6a4:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     6b4:	2d 2d 00                                            --.

000006b7 <__c.8658>:
     6b7:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     6c7:	41 20 3a 20 52 70 2e 25 73 00                       A : Rp.%s.

000006d1 <__c.8655>:
     6d1:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     6e1:	56 20 3a 20 25 73 20 4c 00                          V : %s L.

000006ea <__c.8652>:
     6ea:	20 20 20 20 20 54 6f 74 61 6c 20 52 65 64 65 65          Total Redee
     6fa:	6d 20 3a 20 25 73 00                                m : %s.

00000701 <__c.8649>:
     701:	20 20 20 20 20 45 78 70 69 72 79 20 20 20 20 20          Expiry     
     711:	20 20 3a 20 25 73 00                                  : %s.

00000718 <__c.8646>:
     718:	20 20 20 20 20 43 75 72 72 20 50 6f 69 6e 74 73          Curr Points
     728:	20 20 3a 20 25 73 00                                  : %s.

0000072f <__c.8643>:
     72f:	20 20 20 20 20 50 72 65 76 20 50 6f 69 6e 74 73          Prev Points
     73f:	20 20 3a 20 25 73 00                                  : %s.

00000746 <__c.8640>:
     746:	20 20 20 20 20 47 61 69 6e 20 50 6f 69 6e 74 73          Gain Points
     756:	20 20 3a 20 25 73 00                                  : %s.

0000075d <__c.8637>:
     75d:	20 20 20 20 20 43 6f 72 70 20 4e 61 6d 65 20 20          Corp Name  
     76d:	20 20 3a 20 25 73 00                                  : %s.

00000774 <__c.8634>:
     774:	20 20 20 20 20 43 6f 72 70 20 49 44 20 20 20 20          Corp ID    
     784:	20 20 3a 20 25 73 00                                  : %s.

0000078b <__c.8631>:
     78b:	20 20 20 20 20 43 61 72 64 20 48 6f 6c 64 65 72          Card Holder
     79b:	20 20 3a 20 25 73 20 00                               : %s .

000007a3 <__c.8628>:
     7a3:	20 20 20 20 20 43 61 72 64 20 49 44 20 20 20 20          Card ID    
     7b3:	20 20 3a 20 25 73 00                                  : %s.

000007ba <__c.8625>:
     7ba:	20 20 20 20 20 20 20 20 20 4c 4f 59 41 4c 54 59              LOYALTY
     7ca:	20 49 4e 46 4f 52 4d 41 54 49 4f 4e 20 20 20 20      INFORMATION    
     7da:	20 20 00                                              .

000007dd <__c.8622>:
     7dd:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     7ed:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     7fd:	2d 2d 00                                            --.

00000800 <__c.8619>:
     800:	20 20 20 20 2e 25 73 00                                 .%s.

00000808 <__c.8615>:
     808:	20 20 20 20 54 61 6e 64 61 20 54 61 6e 67 61 6e         Tanda Tangan
     818:	20 20 28 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f       (_____________
     828:	5f 29 00                                            _).

0000082b <__c.8610>:
     82b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     83b:	20 20 20 20 20 20 00                                      .

00000842 <__c.8607>:
     842:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     852:	20 20 20 20 20 20 00                                      .

00000859 <__c.8604>:
     859:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     869:	20 00                                                .

0000086b <__c.8602>:
     86b:	20 20 00                                              .

0000086e <__c.8600>:
     86e:	20 20 20 20 41 70 70 72 20 43 6f 64 65 3a 20 25         Appr Code: %
     87e:	73 00                                               s.

00000880 <__c.8598>:
     880:	25 73 20 20 00                                      %s  .

00000885 <__c.8596>:
     885:	20 20 20 20 4e 61 6d 61 20 20 20 20 20 3a 20 25         Nama     : %
     895:	73 00                                               s.

00000897 <__c.8593>:
     897:	20 20 20 20 20 20 20 20 20 20 2a 2a 2a 20 50 55               *** PU
     8a7:	4d 50 20 54 45 53 54 20 2a 2a 2a 20 20 20 20 20     MP TEST ***     
     8b7:	20 20 00                                              .

000008ba <__c.8591>:
     8ba:	20 20 20 20 56 6f 75 63 68 65 72 20 4e 6f 3a 20         Voucher No: 
     8ca:	25 73 00                                            %s.

000008cd <__c.8589>:
     8cd:	20 20 20 20 4b 61 72 74 75 20 49 44 20 3a 20 25         Kartu ID : %
     8dd:	73 00                                               s.

000008df <__c.8586>:
     8df:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     8ef:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     8ff:	2d 2d 00                                            --.

00000902 <__c.8583>:
     902:	20 20 20 20 20 20 4f 64 6f 6d 65 74 65 72 20 20           Odometer  
     912:	20 20 3a 20 25 73 00                                  : %s.

00000919 <__c.8580>:
     919:	20 20 20 20 20 20 4e 6f 2e 50 6f 6c 69 73 69 20           No.Polisi 
     929:	20 20 3a 20 25 73 00                                  : %s.

00000930 <__c.8577>:
	...

00000931 <__c.8575>:
     931:	20 20 20 20 20 20 4a 6d 6c 20 52 75 70 69 61 68           Jml Rupiah
     941:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

0000094b <__c.8572>:
     94b:	20 20 20 20 20 20 4a 6d 6c 20 4c 69 74 65 72 20           Jml Liter 
     95b:	20 20 3a 20 25 73 20 4c 00                            : %s L.

00000964 <__c.8569>:
	...

00000965 <__c.8567>:
     965:	20 20 20 20 20 20 48 61 72 67 61 2f 4c 20 20 20           Harga/L   
     975:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

0000097f <__c.8564>:
     97f:	20 20 20 20 20 20 50 72 6f 64 75 6b 20 20 20 20           Produk    
     98f:	20 20 3a 20 25 73 00                                  : %s.

00000996 <__c.8561>:
     996:	20 20 20 20 20 20 50 75 6c 61 75 2f 50 6f 6d 70           Pulau/Pomp
     9a6:	61 20 3a 20 5b 25 73 5d 2d 25 73 00                 a : [%s]-%s.

000009b2 <__c.8558>:
     9b2:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     9c2:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     9d2:	2d 2d 00                                            --.

000009d5 <__c.8555>:
     9d5:	20 20 20 20 20 20 57 61 6b 74 75 3a 20 25 73 20           Waktu: %s 
     9e5:	25 73 20 00                                         %s .

000009e9 <__c.8551>:
     9e9:	20 20 20 20 20 20 53 68 69 66 74 3a 20 25 73 20           Shift: %s 
     9f9:	20 4e 6f 2e 54 72 61 6e 73 3a 20 25 73 20 00         No.Trans: %s .

00000a08 <__c.8534>:
     a08:	20 00                                                .

00000a0a <__c.8532>:
     a0a:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     a1a:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     a2a:	20 20 20 00                                            .

00000a2e <__c.8130>:
     a2e:	45 72 72 6f 72 20 4e 6f 20 43 6f 6e 6e 65 63 74     Error No Connect
     a3e:	69 6f 6e 00                                         ion.

00000a42 <__c.8124>:
     a42:	50 72 6f 73 65 73 00                                Proses.

00000a49 <__c.8122>:
     a49:	53 65 6e 64 20 52 65 71 75 65 73 74 00              Send Request.

00000a56 <__c.8117>:
     a56:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     a66:	6e 74 65 72 00                                      nter.

00000a6b <__c.8115>:
     a6b:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     a7b:	6e 74 65 72 00                                      nter.

00000a80 <__c.8112>:
     a80:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     a90:	74 65 72 20 00                                      ter .

00000a95 <__c.8110>:
     a95:	4f 64 6f 6d 65 74 65 72 3a 5f 20 00                 Odometer:_ .

00000aa1 <__c.8108>:
     aa1:	50 6c 61 74 20 4e 6f 3a 20 25 73 20 00              Plat No: %s .

00000aae <__c.8105>:
     aae:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     abe:	6e 74 65 72 00                                      nter.

00000ac3 <__c.8103>:
     ac3:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     ad3:	6e 74 65 72 00                                      nter.

00000ad8 <__c.8100>:
     ad8:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     ae8:	74 65 72 20 00                                      ter .

00000aed <__c.8098>:
     aed:	5f 00                                               _.

00000aef <__c.8096>:
     aef:	49 6e 70 75 74 20 50 6c 61 74 20 4e 6f 3a 20 00     Input Plat No: .

00000aff <__c.8017>:
     aff:	23 29 53 61 76 65 00                                #)Save.

00000b06 <__c.8015>:
     b06:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000b13 <__c.7997>:
     b13:	23 29 53 61 76 65 00                                #)Save.

00000b1a <__c.7995>:
     b1a:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000b27 <__c.7993>:
     b27:	33 29 4e 6f 74 69 66 20 3a 20 20 20 20 20 2a 29     3)Notif :     *)
     b37:	45 78 69 74 00                                      Exit.

00000b3c <__c.7991>:
     b3c:	32 29 44 2f 54 20 20 20 3a 00                       2)D/T   :.

00000b46 <__c.7989>:
     b46:	31 29 4d 6f 6e 65 79 20 3a 00                       1)Money :.

00000b50 <__c.7915>:
     b50:	34 29 43 75 74 20 3a 20 20 2a 29 45 78 69 74 00     4)Cut :  *)Exit.

00000b60 <__c.7913>:
     b60:	33 29 4c 6f 67 6f 3a 20 20 23 29 53 61 76 65 00     3)Logo:  #)Save.

00000b70 <__c.7911>:
     b70:	32 29 53 69 7a 65 3a 20 20 36 29 53 70 61 63 65     2)Size:  6)Space
     b80:	20 3a 00                                             :.

00000b83 <__c.7909>:
     b83:	31 29 54 79 70 65 3a 20 20 35 29 53 63 72 6f 6c     1)Type:  5)Scrol
     b93:	6c 3a 00                                            l:.

00000b96 <__c.7845>:
     b96:	2a 29 43 61 6e 63 65 6c 20 20 20 20 20 20 23 29     *)Cancel      #)
     ba6:	53 61 76 65 00                                      Save.

00000bab <__c.7843>:
     bab:	54 49 4d 45 20 3a 20 00                             TIME : .

00000bb3 <__c.7841>:
     bb3:	44 41 54 45 20 3a 20 00                             DATE : .

00000bbb <__c.7776>:
     bbb:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 23 29     *)Exit        #)
     bcb:	53 61 76 65 00                                      Save.

00000bd0 <__c.7774>:
     bd0:	32 29 4e 32 3a 20 20 34 29 4e 34 3a 20 20 36 29     2)N2:  4)N4:  6)
     be0:	4e 36 3a 00                                         N6:.

00000be4 <__c.7772>:
     be4:	31 29 4e 31 3a 20 20 33 29 4e 33 3a 20 20 35 29     1)N1:  3)N3:  5)
     bf4:	4e 35 3a 00                                         N5:.

00000bf8 <__c.7770>:
     bf8:	50 72 6f 64 75 63 74 20 46 49 50 25 2e 32 64 00     Product FIP%.2d.

00000c08 <__c.7686>:
     c08:	43 6f 6d 70 6c 65 74 65 64 00                       Completed.

00000c12 <__c.7684>:
     c12:	43 61 6e 63 65 6c 20 20 20 20 20 00                 Cancel     .

00000c1e <__c.7681>:
     c1e:	49 64 5b 25 64 5d 3d 25 2e 32 64 20 20 00           Id[%d]=%.2d  .

00000c2c <__c.7678>:
     c2c:	53 61 76 69 6e 67 2e 2e 00                          Saving...

00000c35 <__c.7676>:
     c35:	2d 50 75 6d 70 49 44 2d 00                          -PumpID-.

00000c3e <__c.7672>:
     c3e:	20 20 20 20 4e 6f 74 20 41 6c 6c 6f 77 65 64 20         Not Allowed 
     c4e:	20 20 20 20 00                                          .

00000c53 <__c.7670>:
     c53:	20 20 44 75 70 6c 69 63 61 74 65 20 50 75 6d 70       Duplicate Pump
     c63:	49 44 20 20 00                                      ID  .

00000c68 <__c.7668>:
     c68:	20 20 20 20 20 20 57 61 72 6e 69 6e 67 21 20 20           Warning!  
     c78:	20 20 20 20 00                                          .

00000c7d <__c.7656>:
     c7d:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     c8d:	2e 32 64 00                                         .2d.

00000c91 <__c.7650>:
     c91:	23 29 53 61 76 65 00                                #)Save.

00000c98 <__c.7648>:
     c98:	2a 29 42 61 63 6b 00                                *)Back.

00000c9f <__c.7643>:
     c9f:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     caf:	2e 32 64 00                                         .2d.

00000cb3 <__c.7594>:
     cb3:	25 2e 32 64 00                                      %.2d.

00000cb8 <__c.7588>:
     cb8:	25 2e 32 64 00                                      %.2d.

00000cbd <__c.7586>:
     cbd:	34 29 34 3a 20 20 20 38 29 38 3a 20 20 20 2a 29     4)4:   8)8:   *)
     ccd:	45 78 69 74 00                                      Exit.

00000cd2 <__c.7584>:
     cd2:	33 29 33 3a 20 20 20 37 29 37 3a 20 20 20 23 29     3)3:   7)7:   #)
     ce2:	53 61 76 65 00                                      Save.

00000ce7 <__c.7582>:
     ce7:	32 29 32 3a 20 20 20 36 29 36 3a 00                 2)2:   6)6:.

00000cf3 <__c.7580>:
     cf3:	31 29 31 3a 20 20 20 35 29 35 3a 00                 1)1:   5)5:.

00000cff <__c.7546>:
     cff:	5b 2a 5d 45 78 69 74 20 20 5b 23 5d 43 68 61 6e     [*]Exit  [#]Chan
     d0f:	67 65 20 00                                         ge .

00000d13 <__c.7544>:
     d13:	25 64 2e 25 73 00                                   %d.%s.

00000d19 <__c.7539>:
     d19:	2d 44 69 73 70 65 6e 73 65 72 20 42 72 61 6e 64     -Dispenser Brand
     d29:	2d 00                                               -.

00000d2b <__c.7523>:
     d2b:	2a 29 45 78 69 74 00                                *)Exit.

00000d32 <__c.7521>:
     d32:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

00000d3c <__c.7519>:
     d3c:	31 29 49 44 00                                      1)ID.

00000d41 <__c.7504>:
     d41:	2a 29 45 78 69 74 00                                *)Exit.

00000d48 <__c.7499>:
     d48:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     d58:	2e 32 64 20 00                                      .2d .

00000d5d <__c.7490>:
     d5d:	25 2e 32 64 00                                      %.2d.

00000d62 <__c.7289>:
     d62:	5b 2a 5d 45 78 69 74 00                             [*]Exit.

00000d6a <__c.7287>:
     d6a:	36 2e 41 63 74 3a 25 64 00                          6.Act:%d.

00000d73 <__c.7285>:
     d73:	35 2e 44 6c 79 3a 25 64 00                          5.Dly:%d.

00000d7c <__c.7283>:
     d7c:	34 2e 54 69 6d 50 6f 6f 6c 3a 25 64 00              4.TimPool:%d.

00000d89 <__c.7281>:
     d89:	33 2e 54 72 79 53 65 6e 64 3a 25 64 00              3.TrySend:%d.

00000d96 <__c.7279>:
     d96:	32 2e 6e 4e 6f 50 75 6d 70 3a 25 64 00              2.nNoPump:%d.

00000da3 <__c.7277>:
     da3:	31 2e 4d 61 78 50 75 6d 70 3a 25 64 00              1.MaxPump:%d.

00000db0 <__c.7218>:
     db0:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00000dbd <__c.7213>:
     dbd:	43 4f 4d 25 64 3a 25 64 00                          COM%d:%d.

00000dc6 <__c.7211>:
     dc6:	20 20 20 20 20 2d 42 61 75 64 72 61 74 65 2d 20          -Baudrate- 
     dd6:	20 20 20 20 00                                          .

00000ddb <__c.7206>:
     ddb:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 00           [*]Back      .

00000de9 <__c.7204>:
     de9:	33 2e 43 4f 4d 33 3a 34 38 35 00                    3.COM3:485.

00000df4 <__c.7202>:
     df4:	33 2e 43 4f 4d 33 3a 32 33 32 00                    3.COM3:232.

00000dff <__c.7200>:
     dff:	33 2e 43 4f 4d 33 3a 54 54 4c 00                    3.COM3:TTL.

00000e0a <__c.7198>:
     e0a:	32 2e 42 61 75 64 72 61 74 65 00                    2.Baudrate.

00000e15 <__c.7196>:
     e15:	31 2e 4d 6f 64 65 3a 53 74 61 6e 64 61 6c 6f 6e     1.Mode:Standalon
     e25:	65 00                                               e.

00000e27 <__c.7194>:
     e27:	31 2e 4d 6f 64 65 3a 53 6c 61 76 65 00              1.Mode:Slave.

00000e34 <__c.7192>:
     e34:	31 2e 4d 6f 64 65 3a 4e 6f 6e 65 00                 1.Mode:None.

00000e40 <__c.7145>:
     e40:	49 6e 76 61 6c 69 64 20 4f 6c 64 20 50 61 73 73     Invalid Old Pass
     e50:	77 6f 72 64 00                                      word.

00000e55 <__c.7143>:
     e55:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     e65:	20 20 20 20 00                                          .

00000e6a <__c.7141>:
     e6a:	49 6e 76 61 6c 69 64 20 4e 65 77 20 50 61 73 73     Invalid New Pass
     e7a:	77 6f 72 64 00                                      word.

00000e7f <__c.7139>:
     e7f:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     e8f:	20 20 20 20 00                                          .

00000e94 <__c.7137>:
     e94:	20 20 20 50 61 73 73 77 6f 72 64 20 53 61 76 65        Password Save
     ea4:	64 20 20 20 00                                      d   .

00000ea9 <__c.7135>:
     ea9:	20 20 20 20 20 43 6f 6d 70 6c 65 74 65 64 20 20          Completed  
     eb9:	20 20 20 20 00                                          .

00000ebe <__c.7131>:
     ebe:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ece:	6e 74 65 72 00                                      nter.

00000ed3 <__c.7128>:
     ed3:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     ee3:	6e 74 65 72 00                                      nter.

00000ee8 <__c.7125>:
     ee8:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ef8:	6e 74 65 72 00                                      nter.

00000efd <__c.7123>:
     efd:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     f0d:	20 20 20 20 00                                          .

00000f12 <__c.7119>:
     f12:	56 61 6c 69 64 61 74 69 6e 67 2e 2e 00              Validating...

00000f1f <__c.7115>:
     f1f:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f2f:	6e 74 65 72 00                                      nter.

00000f34 <__c.7112>:
     f34:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     f44:	6e 74 65 72 00                                      nter.

00000f49 <__c.7107>:
     f49:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f59:	6e 74 65 72 00                                      nter.

00000f5e <__c.7105>:
     f5e:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     f6e:	20 20 20 20 00                                          .

00000f73 <__c.7101>:
     f73:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f83:	6e 74 65 72 00                                      nter.

00000f88 <__c.7098>:
     f88:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     f98:	6e 74 65 72 00                                      nter.

00000f9d <__c.7093>:
     f9d:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     fad:	6e 74 65 72 00                                      nter.

00000fb2 <__c.7091>:
     fb2:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     fc2:	20 20 20 20 00                                          .

00000fc7 <__c.7087>:
     fc7:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     fd7:	6e 74 65 72 00                                      nter.

00000fdc <__c.7085>:
     fdc:	4f 6c 64 3a 5f 00                                   Old:_.

00000fe2 <__c.7083>:
     fe2:	2d 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 2d 00     -Administrator-.

00000ff2 <__c.7081>:
     ff2:	2d 53 75 70 65 72 76 69 73 6f 72 2d 00              -Supervisor-.

00000fff <__c.7073>:
     fff:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

0000100c <__c.7071>:
    100c:	32 2e 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 00     2.Administrator.

0000101c <__c.7069>:
    101c:	31 2e 53 75 70 65 72 76 69 73 6f 72 00              1.Supervisor.

00001029 <__c.7067>:
    1029:	2d 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72 64     -Change Password
    1039:	2d 00                                               -.

0000103b <__c.7064>:
    103b:	53 61 76 65 64 20 00                                Saved .

00001042 <__c.7058>:
    1042:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1052:	6e 74 65 72 00                                      nter.

00001057 <__c.7055>:
    1057:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1067:	6e 74 65 72 00                                      nter.

0000106c <__c.7050>:
    106c:	5b 2a 5d 4e 6f 20 20 20 20 5b 23 5d 59 65 73 00     [*]No    [#]Yes.

0000107c <__c.7048>:
    107c:	53 61 76 65 3f 00                                   Save?.

00001082 <__c.7046>:
    1082:	4e 65 77 20 4f 70 65 72 61 74 6f 72 3a 00           New Operator:.

00001090 <__c.7044>:
    1090:	25 73 00                                            %s.

00001093 <__c.7040>:
    1093:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    10a3:	6e 74 65 72 00                                      nter.

000010a8 <__c.7038>:
    10a8:	4e 65 77 20 3a 5f 20 20 20 20 20 20 20 20 20 20     New :_          
    10b8:	20 20 20 20 00                                          .

000010bd <__c.7036>:
    10bd:	4e 61 6d 65 3a 00                                   Name:.

000010c3 <__c.7034>:
    10c3:	25 73 00                                            %s.

000010c6 <__c.7025>:
    10c6:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    10d6:	64 00                                               d.

000010d8 <__c.7023>:
    10d8:	31 2e 43 68 61 6e 67 65 20 4f 70 65 72 61 74 6f     1.Change Operato
    10e8:	72 00                                               r.

000010ea <__c.6940>:
    10ea:	2a 29 42 61 63 6b 00                                *)Back.

000010f1 <__c.6938>:
    10f1:	34 2e 53 70 61 72 61 74 6f 72 3a 25 63 20 00        4.Sparator:%c .

00001100 <__c.6936>:
    1100:	33 2e 44 65 63 69 6d 61 6c 20 3a 25 63 20 00        3.Decimal :%c .

0000110f <__c.6934>:
    110f:	32 2e 54 2e 4d 6f 6e 65 79 20 3a 25 64 20 00        2.T.Money :%d .

0000111e <__c.6932>:
    111e:	31 2e 54 2e 56 6f 6c 75 6d 65 3a 25 64 20 20 35     1.T.Volume:%d  5
    112e:	2e 54 65 73 74 00                                   .Test.

00001134 <__c.6927>:
    1134:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4e 65 78 74     [*]Back  [#]Next
	...

00001145 <__c.6925>:
    1145:	33 2e 4d 6f 6e 65 79 20 3a 25 64 00                 3.Money :%d.

00001151 <__c.6923>:
    1151:	32 2e 56 6f 6c 75 6d 65 3a 25 64 00                 2.Volume:%d.

0000115d <__c.6921>:
    115d:	31 2e 50 72 69 63 65 20 3a 25 64 00                 1.Price :%d.

00001169 <__c.6904>:
    1169:	34 29 42 72 61 6e 64 20 20 2a 29 45 78 69 74 00     4)Brand  *)Exit.

00001179 <__c.6902>:
    1179:	33 29 4c 61 62 65 6c 20 20 00                       3)Label  .

00001183 <__c.6900>:
    1183:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

0000118d <__c.6898>:
    118d:	31 29 49 44 20 20 20 20 20 00                       1)ID     .

00001197 <__c.6857>:
    1197:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    11a7:	20 20 20 20 00                                          .

000011ac <__c.6855>:
    11ac:	4e 65 77 3a 5f 00                                   New:_.

000011b2 <__c.6853>:
    11b2:	4f 6c 64 3a 25 73 00                                Old:%s.

000011b9 <__c.6851>:
    11b9:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    11c9:	20 20 20 20 00                                          .

000011ce <__c.6849>:
    11ce:	4e 65 77 3a 5f 00                                   New:_.

000011d4 <__c.6847>:
    11d4:	45 64 69 74 20 50 72 6f 64 75 63 74 20 4e 61 6d     Edit Product Nam
    11e4:	65 20 20 20 00                                      e   .

000011e9 <__c.6845>:
    11e9:	4f 6c 64 3a 25 73 00                                Old:%s.

000011f0 <__c.6842>:
    11f0:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 00           *)Back       .

000011fe <__c.6840>:
    11fe:	32 29 25 73 00                                      2)%s.

00001203 <__c.6838>:
    1203:	31 29 25 73 00                                      1)%s.

00001208 <__c.6833>:
    1208:	2a 29 42 61 63 6b 00                                *)Back.

0000120f <__c.6828>:
    120f:	25 64 29 25 73 00                                   %d)%s.

00001215 <__c.6755>:
    1215:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 20 20 20     *)Back          
    1225:	20 20 20 20 00                                          .

0000122a <__c.6753>:
    122a:	33 29 50 75 6d 70 50 6f 6f 6c 69 6e 67 20 20 20     3)PumpPooling   
    123a:	20 20 20 20 00                                          .

0000123f <__c.6751>:
    123f:	32 29 53 79 73 74 65 6d 20 20 20 20 20 20 20 20     2)System        
    124f:	20 20 20 20 00                                          .

00001254 <__c.6749>:
    1254:	31 29 4f 70 65 72 61 74 6f 72 20 20 20 20 20 20     1)Operator      
    1264:	20 20 20 20 00                                          .

00001269 <__c.6746>:
    1269:	34 29 44 61 74 65 74 69 6d 65 20 2a 29 45 78 69     4)Datetime *)Exi
    1279:	74 20 20 20 00                                      t   .

0000127e <__c.6744>:
    127e:	33 29 44 65 63 69 6d 61 6c 20 20 37 29 4e 65 78     3)Decimal  7)Nex
    128e:	74 20 20 20 00                                      t   .

00001293 <__c.6742>:
    1293:	32 29 50 75 6d 70 20 20 20 20 20 36 29 48 6f 73     2)Pump     6)Hos
    12a3:	74 20 20 20 00                                      t   .

000012a8 <__c.6740>:
    12a8:	31 29 50 72 6f 64 75 63 74 20 20 35 29 50 72 69     1)Product  5)Pri
    12b8:	6e 74 65 72 00                                      nter.

000012bd <__c.6653>:
    12bd:	2e 00                                               ..

000012bf <__c.6651>:
    12bf:	25 64 00                                            %d.

000012c2 <__c.6649>:
    12c2:	20 20 20 00                                            .

000012c6 <__c.6647>:
    12c6:	2e 00                                               ..

000012c8 <__c.6645>:
    12c8:	25 64 00                                            %d.

000012cb <__c.6643>:
    12cb:	20 20 20 00                                            .

000012cf <__c.6636>:
    12cf:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    12df:	78 74 20 20 00                                      xt  .

000012e4 <__c.6634>:
    12e4:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    12f4:	2e 20 20 20 00                                      .   .

000012f9 <__c.6632>:
    12f9:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

0000130a <__c.6630>:
    130a:	53 65 72 76 65 72 20 49 50 00                       Server IP.

00001314 <__c.6539>:
    1314:	2e 00                                               ..

00001316 <__c.6537>:
    1316:	25 64 00                                            %d.

00001319 <__c.6535>:
    1319:	20 20 20 00                                            .

0000131d <__c.6533>:
    131d:	2e 00                                               ..

0000131f <__c.6531>:
    131f:	25 64 00                                            %d.

00001322 <__c.6529>:
    1322:	20 20 20 00                                            .

00001326 <__c.6522>:
    1326:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    1336:	78 74 20 20 00                                      xt  .

0000133b <__c.6520>:
    133b:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    134b:	2e 20 20 20 00                                      .   .

00001350 <__c.6518>:
    1350:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

00001361 <__c.6516>:
    1361:	43 6c 69 65 6e 74 20 49 50 00                       Client IP.

0000136b <__c.6473>:
    136b:	25 73 25 73 00                                      %s%s.

00001370 <__c.6469>:
    1370:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

0000137d <__c.6467>:
    137d:	53 61 76 65 20 46 6f 6f 74 65 72 25 64 20 3f 00     Save Footer%d ?.

0000138d <__c.6463>:
    138d:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

0000139b <__c.6461>:
    139b:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

000013a9 <__c.6458>:
    13a9:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

000013b8 <__c.6456>:
    13b8:	45 64 69 74 20 46 6f 6f 74 65 72 25 64 20 00        Edit Footer%d .

000013c7 <__c.6452>:
    13c7:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    13d7:	20 20 20 20 00                                          .

000013dc <__c.6450>:
    13dc:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    13ec:	20 20 20 20 00                                          .

000013f1 <__c.6448>:
    13f1:	32 29 46 6f 6f 74 65 72 32 20 20 34 29 46 6f 6f     2)Footer2  4)Foo
    1401:	74 65 72 34 00                                      ter4.

00001406 <__c.6446>:
    1406:	31 29 46 6f 6f 74 65 72 31 20 20 33 29 46 6f 6f     1)Footer1  3)Foo
    1416:	74 65 72 33 00                                      ter3.

0000141b <__c.6414>:
    141b:	25 73 25 73 00                                      %s%s.

00001420 <__c.6410>:
    1420:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

0000142d <__c.6408>:
    142d:	53 61 76 65 20 48 65 61 64 65 72 25 64 20 3f 00     Save Header%d ?.

0000143d <__c.6404>:
    143d:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

0000144b <__c.6402>:
    144b:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

00001459 <__c.6399>:
    1459:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

00001468 <__c.6397>:
    1468:	45 64 69 74 20 48 65 61 64 65 72 25 64 20 00        Edit Header%d .

00001477 <__c.6393>:
    1477:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    1487:	20 20 20 20 00                                          .

0000148c <__c.6391>:
    148c:	33 29 48 65 61 64 65 72 33 20 20 36 29 48 65 61     3)Header3  6)Hea
    149c:	64 65 72 36 00                                      der6.

000014a1 <__c.6389>:
    14a1:	32 29 48 65 61 64 65 72 32 20 20 35 29 48 65 61     2)Header2  5)Hea
    14b1:	64 65 72 35 00                                      der5.

000014b6 <__c.6387>:
    14b6:	31 29 48 65 61 64 65 72 31 20 20 34 29 48 65 61     1)Header1  4)Hea
    14c6:	64 65 72 34 00                                      der4.

000014cb <__c.6344>:
    14cb:	2a 29 45 78 69 74 00                                *)Exit.

000014d2 <__c.6342>:
    14d2:	33 29 50 61 73 73 77 6f 72 64 20 20 20 20 20 20     3)Password      
    14e2:	20 20 20 20 00                                          .

000014e7 <__c.6340>:
    14e7:	32 29 46 6f 6f 74 65 72 20 20 20 20 20 20 20 20     2)Footer        
    14f7:	20 20 20 20 00                                          .

000014fc <__c.6338>:
    14fc:	31 29 48 65 61 64 65 72 20 20 20 20 20 20 20 20     1)Header        
    150c:	20 20 20 20 00                                          .

00001511 <__c.6336>:
    1511:	32 29 46 6f 6f 74 65 72 20 20 20 20 35 29 53 65     2)Footer    5)Se
    1521:	72 76 65 72 00                                      rver.

00001526 <__c.6334>:
    1526:	31 29 48 65 61 64 65 72 20 20 20 20 34 29 43 6c     1)Header    4)Cl
    1536:	69 65 6e 74 00                                      ient.

0000153b <__c.6280>:
    153b:	53 61 76 69 6e 67 20 53 68 69 66 74 44 61 74 61     Saving ShiftData
    154b:	2e 2e 20 00                                         .. .

0000154f <__c.6275>:
    154f:	25 73 20 25 73 00                                   %s %s.

00001555 <__c.6273>:
    1555:	50 72 69 6e 74 69 6e 67 20 54 6f 74 61 6c 69 7a     Printing Totaliz
    1565:	65 72 00                                            er.

00001568 <__c.6269>:
    1568:	43 61 6e 63 65 6c 00                                Cancel.

0000156f <__c.6264>:
    156f:	45 72 72 6f 72 20 2d 20 4e 6f 20 50 75 6d 70 3a     Error - No Pump:
    157f:	25 64 20 00                                         %d .

00001583 <__c.6259>:
    1583:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

00001591 <__c.6255>:
    1591:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

0000159f <__c.6253>:
    159f:	54 6f 74 61 6c 69 7a 65 72 2e 2e 00                 Totalizer...

000015ab <__c.6181>:
    15ab:	2a 29 45 78 69 74 00                                *)Exit.

000015b2 <__c.6179>:
    15b2:	33 2e 4c 6f 63 6b 20 50 75 6d 70 20 20 00           3.Lock Pump  .

000015c0 <__c.6177>:
    15c0:	32 2e 43 6c 6f 73 65 20 44 61 79 20 20 00           2.Close Day  .

000015ce <__c.6175>:
    15ce:	31 2e 43 6c 6f 73 65 20 53 68 69 66 74 00           1.Close Shift.

000015dc <__c.6133>:
    15dc:	34 29 53 65 74 74 69 6e 67 73 20 20 20 2a 29 45     4)Settings   *)E
    15ec:	78 69 74 20 00                                      xit .

000015f1 <__c.6131>:
    15f1:	33 29 43 6c 6f 73 65 44 61 79 20 20 20 20 20 20     3)CloseDay      
    1601:	20 20 20 20 00                                          .

00001606 <__c.6129>:
    1606:	32 29 43 6c 6f 73 65 53 68 69 66 74 20 20 20 20     2)CloseShift    
    1616:	20 20 20 20 00                                          .

0000161b <__c.6127>:
    161b:	31 29 52 65 50 72 69 6e 74 20 20 20 20 20 20 20     1)RePrint       
    162b:	20 20 20 20 00                                          .

00001630 <__c.6097>:
    1630:	50 61 73 73 77 6f 72 64 20 52 65 73 74 6f 72 65     Password Restore
    1640:	64 00                                               d.

00001642 <__c.6093>:
    1642:	49 6e 76 61 6c 69 64 20 52 65 73 74 6f 72 65 20     Invalid Restore 
    1652:	20 00                                                .

00001654 <__c.6090>:
    1654:	30 30 30 30 30 00                                   00000.

0000165a <__c.6088>:
    165a:	31 31 31 31 31 00                                   11111.

00001660 <__c.6084>:
    1660:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1670:	6e 74 65 72 00                                      nter.

00001675 <__c.6081>:
    1675:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1685:	6e 74 65 72 00                                      nter.

0000168a <__c.6074>:
    168a:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    169a:	6e 74 65 72 00                                      nter.

0000169f <__c.6072>:
    169f:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    16af:	20 20 20 20 00                                          .

000016b4 <__c.6070>:
    16b4:	45 6e 74 65 72 20 52 65 73 74 6f 72 65 20 43 6f     Enter Restore Co
    16c4:	64 65 20 20 00                                      de  .

000016c9 <__c.6068>:
    16c9:	4b 65 79 20 53 74 61 6d 70 3a 25 73 20 00           Key Stamp:%s .

000016d7 <__c.6064>:
    16d7:	49 6e 76 61 6c 69 64 20 43 6f 64 65 20 20 20 20     Invalid Code    
    16e7:	20 20 20 20 00                                          .

000016ec <__c.6061>:
	...

000016ed <__c.6059>:
    16ed:	25 73 00                                            %s.

000016f0 <__c.6057>:
    16f0:	25 73 00                                            %s.

000016f3 <__c.6054>:
    16f3:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1703:	6e 74 65 72 00                                      nter.

00001708 <__c.6051>:
    1708:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1718:	6e 74 65 72 00                                      nter.

0000171d <__c.6044>:
	...

0000171e <__c.6042>:
    171e:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    172e:	6e 74 65 72 00                                      nter.

00001733 <__c.6040>:
    1733:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    1743:	20 20 20 20 00                                          .

00001748 <__c.6038>:
    1748:	45 6e 74 65 72 20 47 65 4e 69 55 73 20 43 6f 64     Enter GeNiUs Cod
    1758:	65 20 20 20 00                                      e   .

0000175d <__c.6028>:
    175d:	5b 2a 5d 45 78 69 74 20 20 20 20 20 20 20 20 20     [*]Exit         
    176d:	20 20 20 20 00                                          .

00001772 <__c.6026>:
    1772:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    1782:	64 20 20 20 00                                      d   .

00001787 <__c.6024>:
    1787:	31 2e 52 65 73 74 6f 72 65 20 50 61 73 73 77 6f     1.Restore Passwo
    1797:	72 64 20 20 00                                      rd  .

0000179c <__c.6022>:
    179c:	2d 53 79 73 74 65 6d 20 41 64 6d 69 6e 20 4c 65     -System Admin Le
    17ac:	76 65 6c 2d 00                                      vel-.

000017b1 <__c.5963>:
    17b1:	25 73 25 73 00                                      %s%s.

000017b6 <__c.5935>:
    17b6:	25 73 00                                            %s.

000017b9 <__c.5902>:
    17b9:	25 63 00                                            %c.

000017bc <__c.5900>:
    17bc:	32 30 25 73 00                                      20%s.

000017c1 <__c.5878>:
    17c1:	25 73 00                                            %s.

000017c4 <__c.5829>:
    17c4:	34 32 36 34 36 33 36 00                             4264636.

000017cc <__c.5826>:
    17cc:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    17dc:	6e 74 65 72 00                                      nter.

000017e1 <__c.5824>:
    17e1:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    17f1:	6e 74 65 72 00                                      nter.

000017f6 <__c.5820>:
    17f6:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1806:	6e 74 65 72 00                                      nter.

0000180b <__c.5818>:
    180b:	5f 00                                               _.

0000180d <__c.5816>:
    180d:	50 41 53 53 57 4f 52 44 3a 00                       PASSWORD:.

00001817 <__c.5788>:
    1817:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001825 <__c.5711>:
    1825:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

00001832 <__c.5709>:
    1832:	4e 6f 20 52 65 70 6c 79 20 20 20 20 00              No Reply    .

0000183f <__c.5705>:
    183f:	20 20 20 20 20 20 20 00                                    .

00001847 <__c.5702>:
    1847:	50 6c 65 61 73 65 20 57 61 69 74 00                 Please Wait.

00001853 <__c.5699>:
    1853:	25 73 00                                            %s.

00001856 <__c.5697>:
    1856:	50 55 4d 50 20 54 45 53 54 00                       PUMP TEST.

00001860 <__c.5694>:
    1860:	25 73 00                                            %s.

00001863 <__c.5691>:
    1863:	25 73 00                                            %s.

00001866 <__c.5689>:
    1866:	25 73 00                                            %s.

00001869 <__c.5687>:
    1869:	25 73 00                                            %s.

0000186c <__c.5683>:
    186c:	25 73 00                                            %s.

0000186f <__c.5679>:
    186f:	50 72 6f 73 65 73 00                                Proses.

00001876 <__c.5677>:
    1876:	2d 4d 4f 50 20 56 6f 75 63 68 65 72 2d 00           -MOP Voucher-.

00001884 <__c.5674>:
    1884:	50 72 6f 73 65 73 00                                Proses.

0000188b <__c.5672>:
    188b:	49 44 3a 25 73 00                                   ID:%s.

00001891 <__c.5668>:
    1891:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    18a1:	69 74 00                                            it.

000018a4 <__c.5666>:
    18a4:	46 49 50 25 73 00                                   FIP%s.

000018aa <__c.5664>:
    18aa:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

000018b9 <__c.5655>:
    18b9:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18c9:	6e 74 65 72 00                                      nter.

000018ce <__c.5653>:
    18ce:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    18de:	6e 74 65 72 00                                      nter.

000018e3 <__c.5650>:
    18e3:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18f3:	6e 74 65 72 00                                      nter.

000018f8 <__c.5648>:
    18f8:	53 75 72 63 68 61 72 67 65 3a 20 20 20 5f 25 00     Surcharge:   _%.

00001908 <__c.5646>:
    1908:	25 73 00                                            %s.

0000190b <__c.5642>:
    190b:	5b 2a 5d 42 61 63 6b 00                             [*]Back.

00001913 <__c.5637>:
    1913:	25 64 2e 25 73 00                                   %d.%s.

00001919 <__c.5635>:
    1919:	53 65 6c 65 63 74 20 42 61 6e 6b 00                 Select Bank.

00001925 <__c.5630>:
    1925:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1935:	6e 74 65 72 00                                      nter.

0000193a <__c.5628>:
    193a:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    194a:	6e 74 65 72 00                                      nter.

0000194f <__c.5625>:
    194f:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    195f:	6e 74 65 72 00                                      nter.

00001964 <__c.5623>:
    1964:	5f 00                                               _.

00001966 <__c.5621>:
    1966:	4b 6f 64 65 20 56 6f 75 63 68 65 72 00              Kode Voucher.

00001973 <__c.5612>:
    1973:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1983:	20 20 20 20 00                                          .

00001988 <__c.5610>:
    1988:	32 2e 42 61 6e 6b 20 20 20 20 34 2e 50 75 6d 70     2.Bank    4.Pump
    1998:	54 65 73 74 00                                      Test.

0000199d <__c.5608>:
    199d:	31 2e 41 63 63 6f 75 6e 74 20 33 2e 56 6f 75 63     1.Account 3.Vouc
    19ad:	68 65 72 20 00                                      her .

000019b2 <__c.5606>:
    19b2:	20 20 20 53 65 6c 65 63 74 20 50 61 79 6d 65 6e        Select Paymen
    19c2:	74 20 20 20 00                                      t   .

000019c7 <__c.5553>:
    19c7:	43 52 45 44 49 54 43 41 52 44 00                    CREDITCARD.

000019d2 <__c.5547>:
    19d2:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    19e2:	20 20 20 20 00                                          .

000019e7 <__c.5545>:
    19e7:	32 2e 43 72 65 64 69 74 20 43 61 72 64 20 20 20     2.Credit Card   
    19f7:	20 20 20 20 00                                          .

000019fc <__c.5543>:
    19fc:	31 2e 44 65 62 69 74 2f 46 6c 61 73 68 20 43 61     1.Debit/Flash Ca
    1a0c:	72 64 20 20 00                                      rd  .

00001a11 <__c.5541>:
    1a11:	53 65 6c 65 63 74 20 43 61 72 64 20 54 79 70 65     Select Card Type
	...

00001a22 <__c.5507>:
    1a22:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001a30 <__c.5505>:
    1a30:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001a3e <__c.5498>:
    1a3e:	50 72 65 73 73 20 41 6e 79 20 4b 65 79 00           Press Any Key.

00001a4c <__c.5496>:
    1a4c:	43 6d 20 56 6f 6c 3a 25 73 00                       Cm Vol:%s.

00001a56 <__c.5494>:
    1a56:	43 4d 20 41 6d 74 3a 25 73 00                       CM Amt:%s.

00001a60 <__c.5492>:
    1a60:	50 6f 69 6e 74 73 3a 25 73 00                       Points:%s.

00001a6a <__c.5490>:
    1a6a:	25 73 3a 25 73 00                                   %s:%s.

00001a70 <__c.5483>:
    1a70:	50 72 6f 73 65 73 00                                Proses.

00001a77 <__c.5481>:
    1a77:	49 44 3a 25 73 00                                   ID:%s.

00001a7d <__c.5477>:
    1a7d:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1a8d:	69 74 00                                            it.

00001a90 <__c.5475>:
    1a90:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001a9f <__c.5472>:
    1a9f:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1aaf:	69 74 00                                            it.

00001ab2 <__c.5470>:
    1ab2:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001ac1 <__c.5468>:
    1ac1:	46 49 50 3a 25 73 00                                FIP:%s.

00001ac8 <__c.5462>:
    1ac8:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1ad8:	20 00                                                .

00001ada <__c.5460>:
    1ada:	32 2e 4c 6f 79 61 6c 74 79 20 55 70 64 61 74 65     2.Loyalty Update
    1aea:	20 00                                                .

00001aec <__c.5458>:
    1aec:	31 2e 45 6e 71 75 69 72 79 20 20 20 20 20 20 20     1.Enquiry       
    1afc:	20 00                                                .

00001afe <__c.5456>:
    1afe:	20 20 4d 65 6e 75 20 4c 6f 79 61 6c 74 79 20 20       Menu Loyalty  
    1b0e:	20 00                                                .

00001b10 <__c.5421>:
    1b10:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001b1e <__c.5419>:
    1b1e:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001b2c <__c.5413>:
    1b2c:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1b3c:	69 74 00                                            it.

00001b3f <__c.5411>:
    1b3f:	54 61 70 20 53 75 70 65 72 76 69 73 6f 72 20 43     Tap Supervisor C
    1b4f:	61 72 64 00                                         ard.

00001b53 <__c.5409>:
    1b53:	52 65 50 72 69 6e 74 20 46 49 50 3a 25 73 20 00     RePrint FIP:%s .

00001b63 <__c.5405>:
    1b63:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    1b73:	6b 73 69 20 00                                      ksi .

00001b78 <__c.5399>:
    1b78:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001b86 <__c.5353>:
    1b86:	2a 29 45 78 69 74 00                                *)Exit.

00001b8d <__c.5351>:
    1b8d:	23 29 4f 4b 20 00                                   #)OK .

00001b93 <__c.5349>:
    1b93:	20 20 20 20 20 00                                        .

00001b99 <__c.5347>:
    1b99:	46 49 50 3a 5f 00                                   FIP:_.

00001b9f <__c.5342>:
    1b9f:	25 64 2e 50 25 73 20 7c 20 25 64 2e 50 25 73 00     %d.P%s | %d.P%s.

00001baf <__c.5293>:
    1baf:	30 32 25 73 25 73 25 73 25 73 25 73 25 73 25 73     02%s%s%s%s%s%s%s
	...

00001bc0 <__c.5150>:
    1bc0:	30 00                                               0.

00001bc2 <__c.5081>:
    1bc2:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1bd2:	20 20 20 20 00                                          .

00001bd7 <__c.5076>:
    1bd7:	23 25 73 00                                         #%s.

00001bdb <__c.5074>:
    1bdb:	25 2e 32 64 00                                      %.2d.

00001be0 <__c.5072>:
    1be0:	40 46 49 50 3a 00                                   @FIP:.

00001be6 <__c.5070>:
    1be6:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1bf6:	20 20 20 20 00                                          .

00001bfb <__c.5066>:
    1bfb:	50 72 69 6e 74 69 6e 67 20 46 49 50 25 73 20 00     Printing FIP%s .

00001c0b <__c.5040>:
    1c0b:	44 3a 25 64 20 43 3a 25 63 20 20 00                 D:%d C:%c  .

00001c17 <__c.5021>:
    1c17:	25 73 20 25 73 00                                   %s %s.

00001c1d <__c.4994>:
    1c1d:	4e 6f 20 50 75 6d 70 20 46 6f 75 6e 64 00           No Pump Found.

00001c2b <__c.4992>:
    1c2b:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

00001c38 <__c.4990>:
    1c38:	50 75 6d 70 46 6f 75 6e 64 00                       PumpFound.

00001c42 <__c.4988>:
    1c42:	43 6f 6e 6e 65 63 74 65 64 00                       Connected.

00001c4c <__c.4983>:
    1c4c:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1c5c:	20 20 20 00                                            .

00001c60 <__c.4981>:
    1c60:	25 73 00                                            %s.

00001c63 <__c.4976>:
    1c63:	53 63 61 6e 20 50 75 6d 70 00                       Scan Pump.

00001c6d <__c.4971>:
    1c6d:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001c7e <__c.4969>:
    1c7e:	43 6f 6e 6e 65 63 74 00                             Connect.

00001c86 <__c.4967>:
    1c86:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001c97 <__c.4940>:
    1c97:	43 4f 4d 25 64 3a 25 69 20 20 20 20 20 20 20 20     COM%d:%i        
    1ca7:	20 20 20 00                                            .

00001cab <__c.4938>:
    1cab:	49 6e 69 74 69 61 6c 69 7a 65 20 43 4f 4d 20 2e     Initialize COM .
    1cbb:	2e 2e 00                                            ...

00001cbe <__c.4899>:
    1cbe:	0a 47 65 4e 69 55 73 20 54 69 63 6b 65 74 20 50     .GeNiUs Ticket P
    1cce:	72 69 6e 74 65 72 20 0a 20 56 65 72 73 69 6f 6e     rinter . Version
    1cde:	3a 25 73 0a 20 4c 61 73 74 20 55 70 64 61 74 65     :%s. Last Update
    1cee:	20 25 73 20 0a 20 48 61 6e 69 6e 64 6f 20 41 75      %s . Hanindo Au
    1cfe:	74 6f 6d 61 74 69 6f 6e 20 53 6f 6c 75 74 69 6f     tomation Solutio
    1d0e:	6e 73 20 0a 20 77 77 77 2e 68 61 6e 69 6e 64 6f     ns . www.hanindo
    1d1e:	67 72 6f 75 70 2e 63 6f 6d 0a 0a 0a 0a 0a 0a 0a     group.com.......
    1d2e:	0a 00                                               ..

00001d30 <__c.4897>:
    1d30:	31 34 2f 30 32 2f 32 30 31 31 00                    14/02/2011.

00001d3b <__c.4895>:
    1d3b:	32 2e 33 35 45 78 00                                2.35Ex.

00001d42 <__c.4886>:
    1d42:	25 73 25 73 25 73 25 73 39 38 25 2e 32 64 46 39     %s%s%s%s98%.2dF9
    1d52:	36 38 43 46 46 42 00                                68CFFB.

00001d59 <__c.4763>:
    1d59:	46 75 65 6c 69 6e 67 20 40 46 49 50 3a 23 25 64     Fueling @FIP:#%d
	...

00001d6a <__c.4761>:
    1d6a:	54 72 61 6e 73 61 6b 73 69 20 53 65 6c 65 73 61     Transaksi Selesa
    1d7a:	69 00                                               i.

00001d7c <__c.4757>:
    1d7c:	49 44 3a 20 25 73 00                                ID: %s.

00001d83 <__c.4755>:
    1d83:	25 73 00                                            %s.

00001d86 <__c.4753>:
    1d86:	50 25 73 20 25 73 20 00                             P%s %s .

00001d8e <__c.4749>:
    1d8e:	46 49 50 20 54 69 64 61 6b 20 53 69 61 70 20 20     FIP Tidak Siap  
    1d9e:	20 20 00                                              .

00001da1 <__c.4746>:
    1da1:	41 75 74 68 6f 72 69 73 61 73 69 20 42 65 72 68     Authorisasi Berh
    1db1:	61 73 69 6c 00                                      asil.

00001db6 <__c.4742>:
    1db6:	41 75 74 68 6f 72 69 73 61 73 69 20 47 61 67 61     Authorisasi Gaga
    1dc6:	6c 20 20 20 00                                      l   .

00001dcb <__c.4738>:
    1dcb:	20 20 20 20 20 20 20 00                                    .

00001dd3 <__c.4735>:
    1dd3:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1de3:	20 20 20 20 00                                          .

00001de8 <__c.4733>:
    1de8:	4d 6f 68 6f 6e 20 54 75 6e 67 67 75 20 20 20 20     Mohon Tunggu    
    1df8:	20 20 20 20 00                                          .

00001dfd <__c.4731>:
    1dfd:	25 73 00                                            %s.

00001e00 <__c.4729>:
    1e00:	50 25 73 20 25 73 20 00                             P%s %s .

00001e08 <__c.4726>:
    1e08:	43 61 6e 63 65 6c 20 54 72 61 6e 73 61 63 74 69     Cancel Transacti
    1e18:	6f 6e 20 20 00                                      on  .

00001e1d <__c.4723>:
    1e1d:	5b 2a 5d 42 61 63 6b 20 5b 30 5d 45 53 43 20 5b     [*]Back [0]ESC [
    1e2d:	23 5d 4f 4b 00                                      #]OK.

00001e32 <__c.4721>:
    1e32:	25 73 20 00                                         %s .

00001e36 <__c.4719>:
    1e36:	20 46 75 6c 6c 00                                    Full.

00001e3c <__c.4717>:
    1e3c:	25 73 20 20 25 73 20 00                             %s  %s .

00001e44 <__c.4715>:
    1e44:	49 44 3a 20 25 73 00                                ID: %s.

00001e4b <__c.4713>:
    1e4b:	25 73 20 00                                         %s .

00001e4f <__c.4709>:
    1e4f:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1e5f:	20 00                                                .

00001e61 <__c.4707>:
    1e61:	4f 64 6f 6d 65 74 65 72 3a 5f 20 20 20 20 20 20     Odometer:_      
    1e71:	20 00                                                .

00001e73 <__c.4705>:
    1e73:	25 73 20 00                                         %s .

00001e77 <__c.4703>:
    1e77:	20 20 25 73 20 25 73 20 00                            %s %s .

00001e80 <__c.4701>:
    1e80:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 41 6d 6f     Pump Product Amo
    1e90:	75 6e 74 00                                         unt.

00001e94 <__c.4699>:
    1e94:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 56 6f 6c     Pump Product Vol
    1ea4:	75 6d 65 00                                         ume.

00001ea8 <__c.4697>:
    1ea8:	20 20 54 61 6e 6b 00                                  Tank.

00001eaf <__c.4695>:
    1eaf:	20 20 25 73 20 25 73 20 00                            %s %s .

00001eb8 <__c.4693>:
    1eb8:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 20 20 46     Pump Product   F
    1ec8:	75 6c 6c 00                                         ull.

00001ecc <__c.4690>:
    1ecc:	25 73 00                                            %s.

00001ecf <__c.4687>:
    1ecf:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1edf:	20 20 20 20 00                                          .

00001ee4 <__c.4685>:
    1ee4:	5b 32 5d 41 6d 6f 75 6e 74 3a 5f 20 20 20 20 20     [2]Amount:_     
    1ef4:	20 20 20 20 00                                          .

00001ef9 <__c.4683>:
    1ef9:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1f09:	20 20 20 20 00                                          .

00001f0e <__c.4681>:
    1f0e:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001f16 <__c.4679>:
    1f16:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1f26:	20 20 20 20 00                                          .

00001f2b <__c.4677>:
    1f2b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1f3b:	20 20 20 20 00                                          .

00001f40 <__c.4675>:
    1f40:	5b 31 5d 56 6f 6c 75 6d 65 3a 5f 20 20 20 20 20     [1]Volume:_     
    1f50:	20 20 20 20 00                                          .

00001f55 <__c.4673>:
    1f55:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001f5d <__c.4670>:
    1f5d:	41 00                                               A.

00001f5f <__c.4668>:
    1f5f:	41 00                                               A.

00001f61 <__c.4666>:
    1f61:	56 00                                               V.

00001f63 <__c.4663>:
    1f63:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 4e 65     [*]Back    [#]Ne
    1f73:	78 74 20 20 00                                      xt  .

00001f78 <__c.4661>:
    1f78:	5b 32 5d 41 6d 6f 75 6e 74 20 20 20 20 20 20 20     [2]Amount       
    1f88:	20 20 20 20 00                                          .

00001f8d <__c.4659>:
    1f8d:	5b 31 5d 56 6f 6c 75 6d 65 20 20 20 20 20 20 20     [1]Volume       
    1f9d:	20 20 20 20 00                                          .

00001fa2 <__c.4657>:
    1fa2:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001faa <__c.4654>:
    1faa:	25 73 00                                            %s.

00001fad <__c.4651>:
    1fad:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1fbd:	20 20 20 20 00                                          .

00001fc2 <__c.4646>:
    1fc2:	20 20 20 20 20 00                                        .

00001fc8 <__c.4644>:
    1fc8:	25 64 2e 25 73 00                                   %d.%s.

00001fce <__c.4642>:
    1fce:	25 73 00                                            %s.

00001fd1 <__c.4640>:
    1fd1:	50 6f 6d 70 61 2d 25 73 00                          Pompa-%s.

00001fda <__c.4637>:
    1fda:	25 2e 32 64 00                                      %.2d.

00001fdf <__c.4635>:
    1fdf:	25 2e 32 64 00                                      %.2d.

00001fe4 <__c.4632>:
    1fe4:	2a 29 45 78 69 74 00                                *)Exit.

00001feb <__c.4630>:
    1feb:	23 29 4f 4b 20 00                                   #)OK .

00001ff1 <__c.4628>:
    1ff1:	20 20 20 20 20 00                                        .

00001ff7 <__c.4626>:
    1ff7:	46 49 50 3a 5f 00                                   FIP:_.

00001ffd <__c.4621>:
    1ffd:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
    200d:	2e 32 64 00                                         .2d.

00002011 <__c.4617>:
    2011:	5b 2a 5d 42 61 74 61 6c 20 20 20 20 20 20 20 5b     [*]Batal       [
    2021:	23 5d 4f 4b 00                                      #]OK.

00002026 <__c.4615>:
    2026:	25 73 20 25 73 00                                   %s %s.

0000202c <__c.4613>:
    202c:	25 73 00                                            %s.

0000202f <__c.4611>:
    202f:	25 73 00                                            %s.

00002032 <__c.4609>:
    2032:	25 73 00                                            %s.

00002035 <__c.4606>:
    2035:	4b 61 72 74 75 20 54 65 72 62 61 74 61 73 20 20     Kartu Terbatas  
    2045:	20 20 20 20 00                                          .

0000204a <__c.4604>:
    204a:	54 69 64 61 6b 20 54 65 72 64 61 66 74 61 72 20     Tidak Terdaftar 
    205a:	20 20 20 20 00                                          .

0000205f <__c.4601>:
    205f:	44 61 74 61 20 52 65 63 65 69 76 65 64 20 20 20     Data Received   
    206f:	20 20 20 20 00                                          .

00002074 <__c.4598>:
    2074:	54 43 50 2f 49 50 20 45 72 72 6f 72 20 20 20 20     TCP/IP Error    
    2084:	20 20 20 20 00                                          .

00002089 <__c.4596>:
    2089:	53 65 6e 64 69 6e 67 20 46 61 69 6c 65 64 20 20     Sending Failed  
    2099:	20 20 20 20 00                                          .

0000209e <__c.4593>:
    209e:	20 20 20 20 20 20 20 00                                    .

000020a6 <__c.4588>:
    20a6:	50 72 6f 73 65 73 00                                Proses.

000020ad <__c.4586>:
    20ad:	49 44 3a 25 73 00                                   ID:%s.

000020b3 <__c.4584>:
    20b3:	20 20 20 4c 6f 63 61 6c 20 41 63 63 6f 75 6e 74        Local Account
    20c3:	20 20 20 00                                            .

000020c7 <__c.4392>:
    20c7:	25 2e 32 64 00                                      %.2d.

000020cc <__c.4387>:
    20cc:	45 39 34 34 35 35 31 32 00                          E9445512.

000020d5 <__c.4385>:
    20d5:	25 73 25 73 00                                      %s%s.

000020da <__c.4383>:
    20da:	25 73 25 73 25 73 25 73 39 34 00                    %s%s%s%s94.

000020e5 <__c.4378>:
    20e5:	45 39 34 34 35 35 31 32 00                          E9445512.

000020ee <__c.4376>:
    20ee:	25 73 25 73 25 73 00                                %s%s%s.

000020f5 <__c.4374>:
    20f5:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

000020fe <__c.4372>:
    20fe:	25 73 25 73 25 73 25 73 39 32 00                    %s%s%s%s92.

00002109 <__c.4367>:
    2109:	45 39 34 34 35 35 31 32 00                          E9445512.

00002112 <__c.4365>:
    2112:	25 73 25 73 00                                      %s%s.

00002117 <__c.4363>:
    2117:	25 73 25 73 25 73 25 73 39 30 00                    %s%s%s%s90.

00002122 <__c.4354>:
    2122:	25 64 46 30 30 30 30 30 30 30 45 31 32 33 34 35     %dF0000000E12345
    2132:	36 46 46 46 46 46 25 73 45 39 34 34 35 35 31 32     6FFFFF%sE9445512
	...

00002143 <__c.4352>:
    2143:	25 73 25 73 25 64 25 73 25 73 00                    %s%s%d%s%s.

0000214e <__c.4350>:
    214e:	25 73 25 73 25 73 25 73 35 38 00                    %s%s%s%s58.

00002159 <__c.4345>:
    2159:	41 46 39 36 38 43 46 46 42 00                       AF968CFFB.

00002163 <__c.4343>:
    2163:	25 73 00                                            %s.

00002166 <__c.4341>:
    2166:	25 73 35 36 00                                      %s56.

0000216b <__c.4339>:
    216b:	25 73 25 73 25 73 00                                %s%s%s.

00002172 <__c.4334>:
    2172:	46 39 36 38 43 46 46 42 00                          F968CFFB.

0000217b <__c.4332>:
    217b:	25 73 25 73 00                                      %s%s.

00002180 <__c.4330>:
    2180:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

00002189 <__c.4328>:
    2189:	25 73 25 73 25 73 25 73 33 32 00                    %s%s%s%s32.

00002194 <__c.4323>:
    2194:	25 73 25 73 46 39 36 38 43 46 46 42 00              %s%sF968CFFB.

000021a1 <__c.4321>:
    21a1:	25 73 25 73 25 73 25 73 32 38 00                    %s%s%s%s28.

000021ac <__c.4316>:
    21ac:	25 73 25 73 46 39 36 38 43 46 46 42 00              %s%sF968CFFB.

000021b9 <__c.4314>:
    21b9:	25 73 25 73 25 73 25 73 32 34 00                    %s%s%s%s24.

000021c4 <__c.4309>:
    21c4:	25 73 46 39 36 38 43 46 46 42 00                    %sF968CFFB.

000021cf <__c.4307>:
    21cf:	25 73 25 73 25 73 25 73 32 32 00                    %s%s%s%s22.

000021da <__c.4302>:
    21da:	25 73 25 73 25 73 25 73 31 30 46 39 36 38 43 46     %s%s%s%s10F968CF
    21ea:	46 42 00                                            FB.

000021ed <__c.4297>:
    21ed:	25 73 25 73 25 73 25 73 30 34 25 73 31 46 39 36     %s%s%s%s04%s1F96
    21fd:	38 43 46 46 42 00                                   8CFFB.

00002203 <__c.4283>:
    2203:	25 73 2e 25 73 2e 25 73 2e 25 73 00                 %s.%s.%s.%s.

0000220f <__c.4264>:
    220f:	25 73 2e 25 73 2e 25 73 2e 25 73 00                 %s.%s.%s.%s.

0000221b <__c.4197>:
    221b:	25 73 20 25 73 00                                   %s %s.

00002221 <__c.4195>:
    2221:	32 2e 33 35 45 78 00                                2.35Ex.

00002228 <__c.4193>:
    2228:	47 65 4e 69 55 73 00                                GeNiUs.

0000222f <__c.4179>:
    222f:	50 72 65 73 73 20 61 6e 79 20 6b 65 79 2e 2e 20     Press any key.. 
    223f:	20 20 20 20 00                                          .

00002244 <__c.4167>:
    2244:	5b 31 5d 53 6c 61 76 65 20 5b 32 5d 53 74 61 6e     [1]Slave [2]Stan
    2254:	64 61 6c 6f 6e 65 00                                dalone.

0000225b <__c.4088>:
    225b:	3e 00                                               >.

0000225d <__c.4083>:
    225d:	25 2e 32 64 00                                      %.2d.

00002262 <__c.4081>:
    2262:	25 2e 32 64 00                                      %.2d.

00002267 <__c.4079>:
    2267:	30 00                                               0.

00002269 <__c.4077>:
    2269:	31 00                                               1.

0000226b <__c.4069>:
    226b:	25 64 00                                            %d.

0000226e <__c.4064>:
    226e:	25 2e 32 64 00                                      %.2d.

00002273 <__c.4059>:
    2273:	25 73 00                                            %s.

00002276 <__c.4054>:
    2276:	25 73 00                                            %s.

00002279 <__c.4049>:
    2279:	25 73 00                                            %s.

0000227c <__c.4047>:
    227c:	3c 00                                               <.

0000227e <__c.3979>:
    227e:	3c 4f 4b 3e 00                                      <OK>.

00002283 <__c.3974>:
    2283:	25 64 00                                            %d.

00002286 <__c.3972>:
    2286:	25 64 00                                            %d.

00002289 <__c.3961>:
    2289:	25 64 00                                            %d.

0000228c <__c.3950>:
    228c:	3c 53 61 76 69 6e 67 3e 00                          <Saving>.

00002295 <__c.3948>:
    2295:	4c 65 6e 67 74 68 3a 25 64 00                       Length:%d.

0000229f <__c.3762>:
    229f:	25 73 00                                            %s.

000022a2 <__c.3704>:
    22a2:	25 73 00                                            %s.

000022a5 <__c.3702>:
    22a5:	25 73 00                                            %s.

000022a8 <__c.3700>:
    22a8:	25 73 00                                            %s.

000022ab <__c.3698>:
    22ab:	25 73 00                                            %s.

000022ae <__c.3696>:
    22ae:	25 2e 32 64 00                                      %.2d.

000022b3 <__c.3694>:
    22b3:	25 64 00                                            %d.

000022b6 <__c.3692>:
    22b6:	25 73 00                                            %s.

000022b9 <__c.3690>:
    22b9:	25 73 00                                            %s.

000022bc <__c.3688>:
    22bc:	25 73 00                                            %s.

000022bf <__c.3686>:
    22bf:	25 64 00                                            %d.

000022c2 <__c.3684>:
    22c2:	4e 2f 41 00                                         N/A.

000022c6 <__c.3585>:
    22c6:	25 64 00                                            %d.

000022c9 <__c.3583>:
    22c9:	25 73 00                                            %s.

000022cc <__c.3581>:
    22cc:	25 73 00                                            %s.

000022cf <__c.3496>:
    22cf:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    22df:	6b 73 69 20 00                                      ksi .

000022e4 <__c.3493>:
    22e4:	54 6f 74 61 6c 69 7a 65 72 41 6c 6c 20 20 20 20     TotalizerAll    
    22f4:	20 00                                                .

000022f6 <__c.3490>:
    22f6:	43 6c 65 61 72 20 44 61 74 61 20 54 6f 74 61 6c     Clear Data Total
    2306:	69 7a 65 72 00                                      izer.

0000230b <__c.3478>:
    230b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

0000231c <__c.3475>:
    231c:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    232c:	20 20 20 20 00                                          .

00002331 <__c.3472>:
    2331:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    2341:	20 20 20 20 00                                          .

00002346 <__c.3470>:
    2346:	4e 6f 20 52 65 73 70 6f 6e 73 65 2e 2e 20 20 20     No Response..   
    2356:	20 20 20 20 00                                          .

0000235b <__c.3467>:
    235b:	50 6c 65 61 73 65 20 57 61 69 74 2e 2e 20 20 20     Please Wait..   
    236b:	20 20 20 20 00                                          .

00002370 <__c.3464>:
    2370:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    2380:	20 20 20 20 00                                          .

00002385 <__c.3461>:
    2385:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    2395:	6b 73 69 20 00                                      ksi .

0000239a <__c.3456>:
    239a:	53 65 64 61 6e 67 50 72 6f 73 65 73 00              SedangProses.

000023a7 <__c.3453>:
    23a7:	34 33 35 36 41 33 31 41 00                          4356A31A.

000023b0 <__c.1750>:
    23b0:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23c0:	20 20 20 20 00                                          .

000023c5 <__c.1748>:
    23c5:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23d5:	20 20 20 20 00                                          .

000023da <__c.1746>:
    23da:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23ea:	20 20 20 20 00                                          .

000023ef <__c.1744>:
    23ef:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23ff:	20 20 20 20 00                                          .

00002404 <__alphanum>:
    2404:	30 20 2e 00 00 00 31 2e 2c 3f 21 00 32 61 62 63     0 ....1.,?!.2abc
    2414:	00 00 33 64 65 66 00 00 34 67 68 69 00 00 35 6a     ..3def..4ghi..5j
    2424:	6b 6c 00 00 36 6d 6e 6f 00 00 37 70 71 72 73 00     kl..6mno..7pqrs.
    2434:	38 74 75 76 00 00 39 77 78 79 7a 00 30 20 2e 00     8tuv..9wxyz.0 ..
    2444:	00 00 31 26 40 2b 2d 00 32 41 42 43 00 00 33 44     ..1&@+-.2ABC..3D
    2454:	45 46 00 00 34 47 48 49 00 00 35 4a 4b 4c 00 00     EF..4GHI..5JKL..
    2464:	36 4d 4e 4f 00 00 37 50 51 52 53 00 38 54 55 56     6MNO..7PQRS.8TUV
    2474:	00 00 39 57 58 59 5a 00                             ..9WXYZ.

0000247c <__maxchar>:
    247c:	02 04 03 03 03 03 03 04 03 04                       ..........

00002486 <__ctors_end>:
    2486:	11 24       	eor	r1, r1
    2488:	1f be       	out	0x3f, r1	; 63
    248a:	cf ef       	ldi	r28, 0xFF	; 255
    248c:	d0 e1       	ldi	r29, 0x10	; 16
    248e:	de bf       	out	0x3e, r29	; 62
    2490:	cd bf       	out	0x3d, r28	; 61

00002492 <__do_copy_data>:
    2492:	11 e0       	ldi	r17, 0x01	; 1
    2494:	a0 e0       	ldi	r26, 0x00	; 0
    2496:	b1 e0       	ldi	r27, 0x01	; 1
    2498:	ea e1       	ldi	r30, 0x1A	; 26
    249a:	f2 e7       	ldi	r31, 0x72	; 114
    249c:	01 e0       	ldi	r16, 0x01	; 1
    249e:	0b bf       	out	0x3b, r16	; 59
    24a0:	02 c0       	rjmp	.+4      	; 0x24a6 <__do_copy_data+0x14>
    24a2:	07 90       	elpm	r0, Z+
    24a4:	0d 92       	st	X+, r0
    24a6:	ae 35       	cpi	r26, 0x5E	; 94
    24a8:	b1 07       	cpc	r27, r17
    24aa:	d9 f7       	brne	.-10     	; 0x24a2 <__do_copy_data+0x10>

000024ac <__do_clear_bss>:
    24ac:	10 e1       	ldi	r17, 0x10	; 16
    24ae:	ae e5       	ldi	r26, 0x5E	; 94
    24b0:	b1 e0       	ldi	r27, 0x01	; 1
    24b2:	01 c0       	rjmp	.+2      	; 0x24b6 <.do_clear_bss_start>

000024b4 <.do_clear_bss_loop>:
    24b4:	1d 92       	st	X+, r1

000024b6 <.do_clear_bss_start>:
    24b6:	a7 30       	cpi	r26, 0x07	; 7
    24b8:	b1 07       	cpc	r27, r17
    24ba:	e1 f7       	brne	.-8      	; 0x24b4 <.do_clear_bss_loop>
    24bc:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <main>
    24c0:	0c 94 0b b9 	jmp	0x17216	; 0x17216 <_exit>

000024c4 <__bad_interrupt>:
    24c4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000024c8 <systemOnReset>:
	};
}


void systemOnReset(){
     IsPowerOn=False;
    24c8:	10 92 9a 04 	sts	0x049A, r1
     if (MCUCSR & 1){   // Power-on Reset
    24cc:	04 b6       	in	r0, 0x34	; 52
    24ce:	00 fe       	sbrs	r0, 0
    24d0:	0b c0       	rjmp	.+22     	; 0x24e8 <systemOnReset+0x20>
         MCUCSR=0;lcd_printf(1,1,PSTR("PowerOn"));//Wiznet Blm Ready
    24d2:	14 be       	out	0x34, r1	; 52
    24d4:	81 e0       	ldi	r24, 0x01	; 1
    24d6:	61 e0       	ldi	r22, 0x01	; 1
    24d8:	4c ec       	ldi	r20, 0xCC	; 204
    24da:	52 e0       	ldi	r21, 0x02	; 2
    24dc:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		 IsPowerOn=True;
    24e0:	81 e0       	ldi	r24, 0x01	; 1
    24e2:	80 93 9a 04 	sts	0x049A, r24
    24e6:	18 c0       	rjmp	.+48     	; 0x2518 <systemOnReset+0x50>
         }
     else 
     if (MCUCSR & 2){   // External Reset
    24e8:	04 b6       	in	r0, 0x34	; 52
    24ea:	01 fe       	sbrs	r0, 1
    24ec:	06 c0       	rjmp	.+12     	; 0x24fa <systemOnReset+0x32>
         MCUCSR=0;lcd_printf(1,1,PSTR("External"));
    24ee:	14 be       	out	0x34, r1	; 52
    24f0:	81 e0       	ldi	r24, 0x01	; 1
    24f2:	61 e0       	ldi	r22, 0x01	; 1
    24f4:	43 ec       	ldi	r20, 0xC3	; 195
    24f6:	52 e0       	ldi	r21, 0x02	; 2
    24f8:	0d c0       	rjmp	.+26     	; 0x2514 <systemOnReset+0x4c>
        }
     else 
     if (MCUCSR & 4){   // Brown-Out Reset
    24fa:	04 b6       	in	r0, 0x34	; 52
    24fc:	02 fe       	sbrs	r0, 2
    24fe:	06 c0       	rjmp	.+12     	; 0x250c <systemOnReset+0x44>
         MCUCSR=0;lcd_printf(1,1,PSTR("BrownOut"));
    2500:	14 be       	out	0x34, r1	; 52
    2502:	81 e0       	ldi	r24, 0x01	; 1
    2504:	61 e0       	ldi	r22, 0x01	; 1
    2506:	4a eb       	ldi	r20, 0xBA	; 186
    2508:	52 e0       	ldi	r21, 0x02	; 2
    250a:	04 c0       	rjmp	.+8      	; 0x2514 <systemOnReset+0x4c>
         }
     else		  // Watchdog Reset
        {
         lcd_printf(1,1,PSTR("WatchDog"));
    250c:	81 e0       	ldi	r24, 0x01	; 1
    250e:	61 e0       	ldi	r22, 0x01	; 1
    2510:	41 eb       	ldi	r20, 0xB1	; 177
    2512:	52 e0       	ldi	r21, 0x02	; 2
    2514:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
        };
     MCUCSR=0;		  
    2518:	14 be       	out	0x34, r1	; 52
    251a:	80 ee       	ldi	r24, 0xE0	; 224
    251c:	9e e2       	ldi	r25, 0x2E	; 46
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    251e:	20 e7       	ldi	r18, 0x70	; 112
    2520:	31 e0       	ldi	r19, 0x01	; 1
    2522:	f9 01       	movw	r30, r18
    2524:	31 97       	sbiw	r30, 0x01	; 1
    2526:	f1 f7       	brne	.-4      	; 0x2524 <systemOnReset+0x5c>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2528:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    252a:	d9 f7       	brne	.-10     	; 0x2522 <systemOnReset+0x5a>
	 _delay_ms(1200);
}
    252c:	08 95       	ret

0000252e <SystemInit>:


void SystemInit(){
	unsigned int __delay =300;
	lcd_init();
    252e:	0e 94 da ad 	call	0x15bb4	; 0x15bb4 <lcd_init>
	lcd_clear();
    2532:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
	BackLightTrig();
    2536:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <BackLightTrig>
	systemOnReset();
    253a:	0e 94 64 12 	call	0x24c8	; 0x24c8 <systemOnReset>

	lcd_printf(4, 1, PSTR("Initialize... "));
    253e:	84 e0       	ldi	r24, 0x04	; 4
    2540:	61 e0       	ldi	r22, 0x01	; 1
    2542:	42 ea       	ldi	r20, 0xA2	; 162
    2544:	52 e0       	ldi	r21, 0x02	; 2
    2546:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
    254a:	88 eb       	ldi	r24, 0xB8	; 184
    254c:	9b e0       	ldi	r25, 0x0B	; 11
    254e:	20 e7       	ldi	r18, 0x70	; 112
    2550:	31 e0       	ldi	r19, 0x01	; 1
    2552:	f9 01       	movw	r30, r18
    2554:	31 97       	sbiw	r30, 0x01	; 1
    2556:	f1 f7       	brne	.-4      	; 0x2554 <SystemInit+0x26>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2558:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    255a:	d9 f7       	brne	.-10     	; 0x2552 <SystemInit+0x24>
	_delay_ms(__delay);
	PORTA = 0XFF;		// Buffer for PORTA
    255c:	9f ef       	ldi	r25, 0xFF	; 255
    255e:	9b bb       	out	0x1b, r25	; 27
	DDRA = 0xFF;		// Pin 3 out (SS _SPI_SLAVE)
    2560:	9a bb       	out	0x1a, r25	; 26
	sbi(PORTA, 3);		// Disable SS _SPI_SLAVE
    2562:	db 9a       	sbi	0x1b, 3	; 27

	//Buzzer PORTB.5
	PORTB = 0xFF;DDRB = 0xFF;
    2564:	98 bb       	out	0x18, r25	; 24
    2566:	97 bb       	out	0x17, r25	; 23
	PORTD = 0b00001101;
    2568:	8d e0       	ldi	r24, 0x0D	; 13
    256a:	82 bb       	out	0x12, r24	; 18
    DDRD =  0b00001001;
    256c:	89 e0       	ldi	r24, 0x09	; 9
    256e:	81 bb       	out	0x11, r24	; 17

	TWBR = 0xFF;
    2570:	90 93 70 00 	sts	0x0070, r25
    //MMC
	PORTE = 0x0E;		// Buffer for PORTE
    2574:	8e e0       	ldi	r24, 0x0E	; 14
    2576:	83 b9       	out	0x03, r24	; 3
	DDRE = 0x0E;		// Pin 3 out (SS _SPI_MMC), pin 2 out (HB)
    2578:	82 b9       	out	0x02, r24	; 2
	sbi(PORTE, 3);		// Disable SS _SPI_MMC
    257a:	1b 9a       	sbi	0x03, 3	; 3
	cbi(PORTE, 2);		// HB on
    257c:	1a 98       	cbi	0x03, 2	; 3

	//Keypad
	PORTF = 0xFF;		// Buffer for PORTF
    257e:	90 93 62 00 	sts	0x0062, r25
	DDRF = 0xF0;		// 4 bit row, 4 bit column
    2582:	80 ef       	ldi	r24, 0xF0	; 240
    2584:	80 93 61 00 	sts	0x0061, r24

  	_spi_init(0,1);//Slave
    2588:	80 e0       	ldi	r24, 0x00	; 0
    258a:	61 e0       	ldi	r22, 0x01	; 1
    258c:	0e 94 d2 b0 	call	0x161a4	; 0x161a4 <_spi_init>
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    2590:	bb 9a       	sbi	0x17, 3	; 23
    2592:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    2594:	ba 98       	cbi	0x17, 2	; 23
    2596:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    2598:	b9 98       	cbi	0x17, 1	; 23
    259a:	c1 9a       	sbi	0x18, 1	; 24

	TCCR1B |= (1 << WGM12);
    259c:	8e b5       	in	r24, 0x2e	; 46
    259e:	88 60       	ori	r24, 0x08	; 8
    25a0:	8e bd       	out	0x2e, r24	; 46
	TIMSK |= (1 << OCIE1A);
    25a2:	87 b7       	in	r24, 0x37	; 55
    25a4:	80 61       	ori	r24, 0x10	; 16
    25a6:	87 bf       	out	0x37, r24	; 55
	sei();          //1/14745600=0,06781684028uS *1400 = 100uS 65535-1400+1=64136
    25a8:	78 94       	sei
	OCR1A   = 15624;//49911 -->0,33847384982639 ms
    25aa:	88 e0       	ldi	r24, 0x08	; 8
    25ac:	9d e3       	ldi	r25, 0x3D	; 61
    25ae:	9b bd       	out	0x2b, r25	; 43
    25b0:	8a bd       	out	0x2a, r24	; 42
	TCCR1B |= ((1 << CS10) | (1 << CS11));
    25b2:	8e b5       	in	r24, 0x2e	; 46
    25b4:	83 60       	ori	r24, 0x03	; 3
    25b6:	8e bd       	out	0x2e, r24	; 46

	SendSlaveCommand(SC_SLAVE,ST_NONE);
    25b8:	81 e0       	ldi	r24, 0x01	; 1
    25ba:	60 e0       	ldi	r22, 0x00	; 0
    25bc:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
	
	InitComport();
    25c0:	0e 94 ce 9b 	call	0x1379c	; 0x1379c <InitComport>
	_LIGHT_SET;
    25c4:	81 e0       	ldi	r24, 0x01	; 1
    25c6:	80 93 bf 03 	sts	0x03BF, r24
    25ca:	10 92 c0 03 	sts	0x03C0, r1
    25ce:	80 91 65 00 	lds	r24, 0x0065
    25d2:	8d 7f       	andi	r24, 0xFD	; 253
    25d4:	80 93 65 00 	sts	0x0065, r24
	InitPrinter();
    25d8:	0e 94 22 4d 	call	0x9a44	; 0x9a44 <InitPrinter>
    InitializeConnection();
    25dc:	0e 94 d5 77 	call	0xefaa	; 0xefaa <InitializeConnection>
	lcd_clear(); 
    25e0:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
}
    25e4:	08 95       	ret

000025e6 <main>:
void SystemInit();
//void TestUserInput();

//Program Utama
int main(){
	SystemInit();
    25e6:	0e 94 97 12 	call	0x252e	; 0x252e <SystemInit>
	while(1){
	//FTestChar();
	//TestUserInput();
    FMenuIdle();
    25ea:	0e 94 78 ab 	call	0x156f0	; 0x156f0 <FMenuIdle>
    25ee:	fd cf       	rjmp	.-6      	; 0x25ea <main+0x4>

000025f0 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    25f0:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    25f2:	e1 99       	sbic	0x1c, 1	; 28
    25f4:	fe cf       	rjmp	.-4      	; 0x25f2 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    25f6:	3f bb       	out	0x1f, r19	; 31
    25f8:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    25fa:	e0 9a       	sbi	0x1c, 0	; 28
    25fc:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    25fe:	08 95       	ret

00002600 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    2600:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    2602:	e1 99       	sbic	0x1c, 1	; 28
    2604:	fe cf       	rjmp	.-4      	; 0x2602 <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2606:	3f bb       	out	0x1f, r19	; 31
    2608:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    260a:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    260c:	0f b6       	in	r0, 0x3f	; 63
    260e:	f8 94       	cli
    2610:	e2 9a       	sbi	0x1c, 2	; 28
    2612:	e1 9a       	sbi	0x1c, 1	; 28
    2614:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    2616:	08 95       	ret

00002618 <__vector_12>:
	  strDispenserName3,
	  strDispenserName4,
	  strDispenserName5,
};

ISR(TIMER1_COMPA_vect){//Timer Overflow 1ms
    2618:	1f 92       	push	r1
    261a:	0f 92       	push	r0
    261c:	0f b6       	in	r0, 0x3f	; 63
    261e:	0f 92       	push	r0
    2620:	11 24       	eor	r1, r1
    2622:	2f 93       	push	r18
    2624:	6f 93       	push	r22
    2626:	7f 93       	push	r23
    2628:	8f 93       	push	r24
    262a:	9f 93       	push	r25
static char __i_timer=0;

	//_light_ticker();
	if(__key_light == 1){
    262c:	80 91 bf 03 	lds	r24, 0x03BF
    2630:	81 30       	cpi	r24, 0x01	; 1
    2632:	81 f4       	brne	.+32     	; 0x2654 <__vector_12+0x3c>
		__key_lgtcnt++;
    2634:	80 91 c0 03 	lds	r24, 0x03C0
    2638:	8f 5f       	subi	r24, 0xFF	; 255
    263a:	80 93 c0 03 	sts	0x03C0, r24
		if(__key_lgtcnt == 150){
    263e:	86 39       	cpi	r24, 0x96	; 150
    2640:	49 f4       	brne	.+18     	; 0x2654 <__vector_12+0x3c>
		   __key_light = 0; 
    2642:	10 92 bf 03 	sts	0x03BF, r1
		   __key_lgtcnt = 0; 
    2646:	10 92 c0 03 	sts	0x03C0, r1
		   sbi(PORTG, 1);
    264a:	80 91 65 00 	lds	r24, 0x0065
    264e:	82 60       	ori	r24, 0x02	; 2
    2650:	80 93 65 00 	sts	0x0065, r24
		   }
	}
	

	__i_timer++;
    2654:	80 91 bd 03 	lds	r24, 0x03BD
    2658:	8f 5f       	subi	r24, 0xFF	; 255
    265a:	80 93 bd 03 	sts	0x03BD, r24
	if (__i_timer > 5){
    265e:	86 30       	cpi	r24, 0x06	; 6
    2660:	30 f0       	brcs	.+12     	; 0x266e <__vector_12+0x56>
		__i_timer = 0;
    2662:	10 92 bd 03 	sts	0x03BD, r1
		PORTE = PORTE^0x04;
    2666:	83 b1       	in	r24, 0x03	; 3
    2668:	94 e0       	ldi	r25, 0x04	; 4
    266a:	89 27       	eor	r24, r25
    266c:	83 b9       	out	0x03, r24	; 3
	}
	//Beep
	if (TimBeep>0){
    266e:	80 91 d6 01 	lds	r24, 0x01D6
    2672:	90 91 d7 01 	lds	r25, 0x01D7
    2676:	00 97       	sbiw	r24, 0x00	; 0
    2678:	41 f0       	breq	.+16     	; 0x268a <__vector_12+0x72>
	    TimBeep--;
    267a:	01 97       	sbiw	r24, 0x01	; 1
    267c:	90 93 d7 01 	sts	0x01D7, r25
    2680:	80 93 d6 01 	sts	0x01D6, r24
		DDRB=(DDRB|0b00100000);
    2684:	bd 9a       	sbi	0x17, 5	; 23
	    PORTB=(PORTB&0b11011111);
    2686:	c5 98       	cbi	0x18, 5	; 24
    2688:	05 c0       	rjmp	.+10     	; 0x2694 <__vector_12+0x7c>
	    }
	else{PORTB=(PORTB|~PORTB);
    268a:	98 b3       	in	r25, 0x18	; 24
    268c:	88 b3       	in	r24, 0x18	; 24
    268e:	80 95       	com	r24
    2690:	89 2b       	or	r24, r25
    2692:	88 bb       	out	0x18, r24	; 24
		}
    //LocalAccount
	TimLocAcc++;
    2694:	80 91 d2 01 	lds	r24, 0x01D2
    2698:	90 91 d3 01 	lds	r25, 0x01D3
    269c:	01 96       	adiw	r24, 0x01	; 1
    269e:	90 93 d3 01 	sts	0x01D3, r25
    26a2:	80 93 d2 01 	sts	0x01D2, r24
	//DisplaTicker
    TimTicker++;
    26a6:	80 91 a5 01 	lds	r24, 0x01A5
    26aa:	8f 5f       	subi	r24, 0xFF	; 255
    26ac:	80 93 a5 01 	sts	0x01A5, r24
	TimPressed++;
    26b0:	20 91 a6 01 	lds	r18, 0x01A6
    26b4:	2f 5f       	subi	r18, 0xFF	; 255
    26b6:	20 93 a6 01 	sts	0x01A6, r18
	if ((TimPressed%5)==0){
    26ba:	82 2f       	mov	r24, r18
    26bc:	65 e0       	ldi	r22, 0x05	; 5
    26be:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    26c2:	99 23       	and	r25, r25
    26c4:	71 f4       	brne	.+28     	; 0x26e2 <__vector_12+0xca>
	    TimDisplay++;
    26c6:	80 91 a7 01 	lds	r24, 0x01A7
    26ca:	8f 5f       	subi	r24, 0xFF	; 255
    26cc:	80 93 a7 01 	sts	0x01A7, r24
		TimPrintBusy++;
    26d0:	80 91 cc 01 	lds	r24, 0x01CC
    26d4:	90 91 cd 01 	lds	r25, 0x01CD
    26d8:	01 96       	adiw	r24, 0x01	; 1
    26da:	90 93 cd 01 	sts	0x01CD, r25
    26de:	80 93 cc 01 	sts	0x01CC, r24
		//FBackLight();
	}
	if ((TimPressed%PRESSED_DELAY)==0){
    26e2:	82 2f       	mov	r24, r18
    26e4:	6a e0       	ldi	r22, 0x0A	; 10
    26e6:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    26ea:	99 23       	and	r25, r25
    26ec:	49 f4       	brne	.+18     	; 0x2700 <__vector_12+0xe8>
	     ProcTimeOut++;
    26ee:	80 91 d8 01 	lds	r24, 0x01D8
    26f2:	90 91 d9 01 	lds	r25, 0x01D9
    26f6:	01 96       	adiw	r24, 0x01	; 1
    26f8:	90 93 d9 01 	sts	0x01D9, r25
    26fc:	80 93 d8 01 	sts	0x01D8, r24
	}
	TimSend++;
    2700:	80 91 a8 01 	lds	r24, 0x01A8
    2704:	90 91 a9 01 	lds	r25, 0x01A9
    2708:	01 96       	adiw	r24, 0x01	; 1
    270a:	90 93 a9 01 	sts	0x01A9, r25
    270e:	80 93 a8 01 	sts	0x01A8, r24
}
    2712:	9f 91       	pop	r25
    2714:	8f 91       	pop	r24
    2716:	7f 91       	pop	r23
    2718:	6f 91       	pop	r22
    271a:	2f 91       	pop	r18
    271c:	0f 90       	pop	r0
    271e:	0f be       	out	0x3f, r0	; 63
    2720:	0f 90       	pop	r0
    2722:	1f 90       	pop	r1
    2724:	18 95       	reti

00002726 <RePrintStandalone>:

char RePrintStandalone(char FIPAddr){
     char Result=PS_NONE;

   return Result;
}
    2726:	86 e1       	ldi	r24, 0x16	; 22
    2728:	08 95       	ret

0000272a <GetPumpStatusLabel>:


char GetPumpStatusLabel(char xPumpStatus){
     char Result;

	 switch(xPumpStatus){
    272a:	e8 2f       	mov	r30, r24
    272c:	f0 e0       	ldi	r31, 0x00	; 0
    272e:	ee 31       	cpi	r30, 0x1E	; 30
    2730:	f1 05       	cpc	r31, r1
    2732:	70 f5       	brcc	.+92     	; 0x2790 <GetPumpStatusLabel+0x66>
    2734:	ea 5b       	subi	r30, 0xBA	; 186
    2736:	ff 4f       	sbci	r31, 0xFF	; 255
    2738:	ee 0f       	add	r30, r30
    273a:	ff 1f       	adc	r31, r31
    273c:	05 90       	lpm	r0, Z+
    273e:	f4 91       	lpm	r31, Z+
    2740:	e0 2d       	mov	r30, r0
    2742:	09 94       	ijmp
    2744:	81 e3       	ldi	r24, 0x31	; 49
    2746:	08 95       	ret
    2748:	85 e4       	ldi	r24, 0x45	; 69
    274a:	08 95       	ret
    274c:	82 e3       	ldi	r24, 0x32	; 50
    274e:	08 95       	ret
	 case PUMP_ST1: 
	      Result='1';
		  break;
	 case PUMP_ST2: 
	 	  Result='2';
		  break;
    2750:	83 e3       	ldi	r24, 0x33	; 51
    2752:	08 95       	ret
     case PUMP_ST3:
	 	  Result='3';
		  break;	
    2754:	84 e3       	ldi	r24, 0x34	; 52
    2756:	08 95       	ret
	 case PUMP_ST4: 
          Result='4';
		  break;
    2758:	85 e3       	ldi	r24, 0x35	; 53
    275a:	08 95       	ret
	 case PUMP_ST5: 
	 	  Result='5';
		  break;
    275c:	89 e6       	ldi	r24, 0x69	; 105
    275e:	08 95       	ret
	 case PUMP_OFF: 
	 case PW_ONLINE:
	 	  Result='i';
		  break;
    2760:	8e e6       	ldi	r24, 0x6E	; 110
    2762:	08 95       	ret
     case PW_CALL:
	 case PUMP_CALL: 
	 	  Result='n';
		  break;     
    2764:	81 e6       	ldi	r24, 0x61	; 97
    2766:	08 95       	ret
	 case PUMP_AUTH: 
	 	  Result='a';
		  break;
    2768:	84 e6       	ldi	r24, 0x64	; 100
    276a:	08 95       	ret
     case PW_AUTHORIZED:
	 case PUMP_BUSY: 
	 	  Result='d';
		  break;
    276c:	8f e4       	ldi	r24, 0x4F	; 79
    276e:	08 95       	ret
	 case PUMP_PEOT: 
	 	  Result='O';
		  break;
    2770:	86 e4       	ldi	r24, 0x46	; 70
    2772:	08 95       	ret
     case PW_END_DELIVERY:
	 case PUMP_FEOT: 
	 	  Result='F';
		  break;
    2774:	83 e5       	ldi	r24, 0x53	; 83
    2776:	08 95       	ret
	 case PUMP_STOP: 
	 	  Result='S';
		  break;
    2778:	8d e2       	ldi	r24, 0x2D	; 45
    277a:	08 95       	ret
	 case PUMP_NONE:
	 case PW_DISCONNECT:
	 	  Result='-';
		  break;
    277c:	80 e5       	ldi	r24, 0x50	; 80
    277e:	08 95       	ret
     case PS_PRINT_READY:
	      Result='P';
 	      break;
    2780:	89 e4       	ldi	r24, 0x49	; 73
    2782:	08 95       	ret
     case PS_PRINTED:
	      Result='I';
 	      break;
    2784:	86 e5       	ldi	r24, 0x56	; 86
    2786:	08 95       	ret
     case PS_VOID:
	      Result='V';
	      break;
    2788:	84 e5       	ldi	r24, 0x54	; 84
    278a:	08 95       	ret
     case PS_TOTALIZER:
	      Result='T';
	      break;
    278c:	84 e7       	ldi	r24, 0x74	; 116
    278e:	08 95       	ret
     case PS_FINISH_TOTALIZER:
	      Result='t';
	      break;
    2790:	88 e7       	ldi	r24, 0x78	; 120
	 default:
          Result='x';
		  break;         	 
	 }
  return Result;	 
}
    2792:	08 95       	ret

00002794 <SendPoolingCommand>:
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    2794:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    2798:	60 93 3c 0f 	sts	0x0F3C, r22
     IsControlPooling=True;
    279c:	81 e0       	ldi	r24, 0x01	; 1
    279e:	80 93 97 01 	sts	0x0197, r24
}
    27a2:	08 95       	ret

000027a4 <ScanEDCFlow>:
	 RemZeroLead(strMsgID);
	 Result=atoi(strMsgID);
  return Result;
}

void ScanEDCFlow(char data){
    27a4:	28 2f       	mov	r18, r24
static char IsEDCFlow=False,EDCMsgCode=0;
static unsigned int nFlow=0;
     char i;
     //EDC-MSG
     if (data==0x02){
    27a6:	82 30       	cpi	r24, 0x02	; 2
    27a8:	39 f4       	brne	.+14     	; 0x27b8 <ScanEDCFlow+0x14>
	     IsEDCFlow=True;
    27aa:	81 e0       	ldi	r24, 0x01	; 1
    27ac:	80 93 b1 03 	sts	0x03B1, r24
		 nFlow=0;
    27b0:	10 92 af 03 	sts	0x03AF, r1
    27b4:	10 92 ae 03 	sts	0x03AE, r1
	 }//FillMessage
     if (IsEDCFlow==True){
    27b8:	80 91 b1 03 	lds	r24, 0x03B1
    27bc:	81 30       	cpi	r24, 0x01	; 1
    27be:	69 f4       	brne	.+26     	; 0x27da <ScanEDCFlow+0x36>
	     rcv_trans[nFlow]=data;
    27c0:	80 91 ae 03 	lds	r24, 0x03AE
    27c4:	90 91 af 03 	lds	r25, 0x03AF
    27c8:	fc 01       	movw	r30, r24
    27ca:	ed 57       	subi	r30, 0x7D	; 125
    27cc:	f3 4f       	sbci	r31, 0xF3	; 243
    27ce:	20 83       	st	Z, r18
		 nFlow++;
    27d0:	01 96       	adiw	r24, 0x01	; 1
    27d2:	90 93 af 03 	sts	0x03AF, r25
    27d6:	80 93 ae 03 	sts	0x03AE, r24
	 }//CloseMessage
	 if ((data==0x03)||(nFlow>=MSG03_LENGTH)){
    27da:	23 30       	cpi	r18, 0x03	; 3
    27dc:	41 f0       	breq	.+16     	; 0x27ee <ScanEDCFlow+0x4a>
    27de:	80 91 ae 03 	lds	r24, 0x03AE
    27e2:	90 91 af 03 	lds	r25, 0x03AF
    27e6:	8d 34       	cpi	r24, 0x4D	; 77
    27e8:	91 05       	cpc	r25, r1
    27ea:	08 f4       	brcc	.+2      	; 0x27ee <ScanEDCFlow+0x4a>
    27ec:	9b c0       	rjmp	.+310    	; 0x2924 <ScanEDCFlow+0x180>
	     //for(i=0;i<nFlow;i++){_uart(0,1,rcv_trans[i]);}
	     IsEDCFlow=False;
    27ee:	10 92 b1 03 	sts	0x03B1, r1
		 EDCMsgCode=((rcv_trans[1]-'0')*10)+(rcv_trans[2]-'0');
    27f2:	30 91 85 0c 	lds	r19, 0x0C85
    27f6:	30 51       	subi	r19, 0x10	; 16
    27f8:	80 91 84 0c 	lds	r24, 0x0C84
    27fc:	2a e0       	ldi	r18, 0x0A	; 10
    27fe:	82 9f       	mul	r24, r18
    2800:	c0 01       	movw	r24, r0
    2802:	11 24       	eor	r1, r1
    2804:	38 0f       	add	r19, r24
    2806:	30 93 b0 03 	sts	0x03B0, r19

		 if (EDCMsgCode==0x03){
    280a:	33 30       	cpi	r19, 0x03	; 3
    280c:	09 f0       	breq	.+2      	; 0x2810 <ScanEDCFlow+0x6c>
    280e:	65 c0       	rjmp	.+202    	; 0x28da <ScanEDCFlow+0x136>
    2810:	e6 e8       	ldi	r30, 0x86	; 134
    2812:	fc e0       	ldi	r31, 0x0C	; 12
    2814:	a9 ed       	ldi	r26, 0xD9	; 217
    2816:	bf e0       	ldi	r27, 0x0F	; 15
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2818:	81 91       	ld	r24, Z+
    281a:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    281c:	8c e0       	ldi	r24, 0x0C	; 12
    281e:	ec 38       	cpi	r30, 0x8C	; 140
    2820:	f8 07       	cpc	r31, r24
    2822:	d1 f7       	brne	.-12     	; 0x2818 <ScanEDCFlow+0x74>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2824:	10 92 df 0f 	sts	0x0FDF, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2828:	80 81       	ld	r24, Z
    282a:	80 93 86 09 	sts	0x0986, r24
    282e:	81 81       	ldd	r24, Z+1	; 0x01
    2830:	80 93 87 09 	sts	0x0987, r24
	 }Dest[Length]=0;
    2834:	10 92 88 09 	sts	0x0988, r1
    2838:	32 96       	adiw	r30, 0x02	; 2
    283a:	a5 ef       	ldi	r26, 0xF5	; 245
    283c:	bf e0       	ldi	r27, 0x0F	; 15
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    283e:	81 91       	ld	r24, Z+
    2840:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2842:	8c e0       	ldi	r24, 0x0C	; 12
    2844:	ed 39       	cpi	r30, 0x9D	; 157
    2846:	f8 07       	cpc	r31, r24
    2848:	d1 f7       	brne	.-12     	; 0x283e <ScanEDCFlow+0x9a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    284a:	10 92 04 10 	sts	0x1004, r1
    284e:	af ee       	ldi	r26, 0xEF	; 239
    2850:	be e0       	ldi	r27, 0x0E	; 14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2852:	81 91       	ld	r24, Z+
    2854:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2856:	8c e0       	ldi	r24, 0x0C	; 12
    2858:	e0 3b       	cpi	r30, 0xB0	; 176
    285a:	f8 07       	cpc	r31, r24
    285c:	d1 f7       	brne	.-12     	; 0x2852 <ScanEDCFlow+0xae>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    285e:	10 92 02 0f 	sts	0x0F02, r1
    2862:	20 e0       	ldi	r18, 0x00	; 0
    2864:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2866:	f9 01       	movw	r30, r18
    2868:	e2 53       	subi	r30, 0x32	; 50
    286a:	f6 4f       	sbci	r31, 0xF6	; 246
    286c:	d9 01       	movw	r26, r18
    286e:	ad 57       	subi	r26, 0x7D	; 125
    2870:	b3 4f       	sbci	r27, 0xF3	; 243
    2872:	9d 96       	adiw	r26, 0x2d	; 45
    2874:	8c 91       	ld	r24, X
    2876:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2878:	2f 5f       	subi	r18, 0xFF	; 255
    287a:	3f 4f       	sbci	r19, 0xFF	; 255
    287c:	26 30       	cpi	r18, 0x06	; 6
    287e:	31 05       	cpc	r19, r1
    2880:	91 f7       	brne	.-28     	; 0x2866 <ScanEDCFlow+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2882:	10 92 d4 09 	sts	0x09D4, r1
    2886:	20 e0       	ldi	r18, 0x00	; 0
    2888:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    288a:	f9 01       	movw	r30, r18
    288c:	ea 5c       	subi	r30, 0xCA	; 202
    288e:	f6 4f       	sbci	r31, 0xF6	; 246
    2890:	d9 01       	movw	r26, r18
    2892:	ad 57       	subi	r26, 0x7D	; 125
    2894:	b3 4f       	sbci	r27, 0xF3	; 243
    2896:	d3 96       	adiw	r26, 0x33	; 51
    2898:	8c 91       	ld	r24, X
    289a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    289c:	2f 5f       	subi	r18, 0xFF	; 255
    289e:	3f 4f       	sbci	r19, 0xFF	; 255
    28a0:	2a 30       	cpi	r18, 0x0A	; 10
    28a2:	31 05       	cpc	r19, r1
    28a4:	91 f7       	brne	.-28     	; 0x288a <ScanEDCFlow+0xe6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28a6:	10 92 40 09 	sts	0x0940, r1
    28aa:	20 e0       	ldi	r18, 0x00	; 0
    28ac:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28ae:	f9 01       	movw	r30, r18
    28b0:	eb 5d       	subi	r30, 0xDB	; 219
    28b2:	f0 4f       	sbci	r31, 0xF0	; 240
    28b4:	d9 01       	movw	r26, r18
    28b6:	ad 57       	subi	r26, 0x7D	; 125
    28b8:	b3 4f       	sbci	r27, 0xF3	; 243
    28ba:	dd 96       	adiw	r26, 0x3d	; 61
    28bc:	8c 91       	ld	r24, X
    28be:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28c0:	2f 5f       	subi	r18, 0xFF	; 255
    28c2:	3f 4f       	sbci	r19, 0xFF	; 255
    28c4:	2e 30       	cpi	r18, 0x0E	; 14
    28c6:	31 05       	cpc	r19, r1
    28c8:	91 f7       	brne	.-28     	; 0x28ae <ScanEDCFlow+0x10a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28ca:	10 92 33 0f 	sts	0x0F33, r1
             StrPosCopy(rcv_trans,strCardType,11,15);
             StrPosCopy(rcv_trans,strCardID,26,19);
             StrPosCopy(rcv_trans,strApprovalCode,45,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,51,10);
             StrPosCopy(rcv_trans,strDateTime,61,14);
		     IsEDCApproved=True;//Sending Message 92
    28ce:	81 e0       	ldi	r24, 0x01	; 1
    28d0:	80 93 b0 01 	sts	0x01B0, r24
			 IsPrintApprovalCode=True;
    28d4:	80 93 b1 01 	sts	0x01B1, r24
    28d8:	08 95       	ret
	    }else
		 if (EDCMsgCode==0x04){
    28da:	34 30       	cpi	r19, 0x04	; 4
    28dc:	19 f5       	brne	.+70     	; 0x2924 <ScanEDCFlow+0x180>
    28de:	e6 e8       	ldi	r30, 0x86	; 134
    28e0:	fc e0       	ldi	r31, 0x0C	; 12
    28e2:	ae ec       	ldi	r26, 0xCE	; 206
    28e4:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28e6:	81 91       	ld	r24, Z+
    28e8:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28ea:	8c e0       	ldi	r24, 0x0C	; 12
    28ec:	ec 38       	cpi	r30, 0x8C	; 140
    28ee:	f8 07       	cpc	r31, r24
    28f0:	d1 f7       	brne	.-12     	; 0x28e6 <ScanEDCFlow+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28f2:	10 92 d4 09 	sts	0x09D4, r1
    28f6:	a6 e3       	ldi	r26, 0x36	; 54
    28f8:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28fa:	81 91       	ld	r24, Z+
    28fc:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28fe:	8c e0       	ldi	r24, 0x0C	; 12
    2900:	e6 39       	cpi	r30, 0x96	; 150
    2902:	f8 07       	cpc	r31, r24
    2904:	d1 f7       	brne	.-12     	; 0x28fa <ScanEDCFlow+0x156>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2906:	10 92 40 09 	sts	0x0940, r1
    290a:	a5 e2       	ldi	r26, 0x25	; 37
    290c:	bf e0       	ldi	r27, 0x0F	; 15
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    290e:	81 91       	ld	r24, Z+
    2910:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2912:	8c e0       	ldi	r24, 0x0C	; 12
    2914:	e4 3a       	cpi	r30, 0xA4	; 164
    2916:	f8 07       	cpc	r31, r24
    2918:	d1 f7       	brne	.-12     	; 0x290e <ScanEDCFlow+0x16a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    291a:	10 92 33 0f 	sts	0x0F33, r1
	    }else
		 if (EDCMsgCode==0x04){
             StrPosCopy(rcv_trans,strApprovalCode,3,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,9,10);
             StrPosCopy(rcv_trans,strDateTime,19,14);
			 IsVoidTransaction=True;
    291e:	81 e0       	ldi	r24, 0x01	; 1
    2920:	80 93 b2 01 	sts	0x01B2, r24
    2924:	08 95       	ret

00002926 <ScanHiddenKeyFlow>:
	    }
    }//MSGDetection
}

void ScanHiddenKeyFlow(char KeyIn){
}
    2926:	08 95       	ret

00002928 <ScanRFIDFlow>:


void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
    2928:	98 2f       	mov	r25, r24
    292a:	e8 e1       	ldi	r30, 0x18	; 24
    292c:	fc e0       	ldi	r31, 0x0C	; 12
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
        strSerialFlow[19-i]=strSerialFlow[18-i];   
    292e:	80 81       	ld	r24, Z
    2930:	81 83       	std	Z+1, r24	; 0x01
    2932:	31 97       	sbiw	r30, 0x01	; 1

void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
    2934:	8c e0       	ldi	r24, 0x0C	; 12
    2936:	e5 30       	cpi	r30, 0x05	; 5
    2938:	f8 07       	cpc	r31, r24
    293a:	c9 f7       	brne	.-14     	; 0x292e <ScanRFIDFlow+0x6>
        strSerialFlow[19-i]=strSerialFlow[18-i];   
	 }  strSerialFlow[0]=data;
    293c:	9f 01       	movw	r18, r30
    293e:	2f 5f       	subi	r18, 0xFF	; 255
    2940:	3f 4f       	sbci	r19, 0xFF	; 255
    2942:	91 83       	std	Z+1, r25	; 0x01
	 //Detection
	 if ((strSerialFlow[11]==0x02)&&(strSerialFlow[1]==0x0A)&&(strSerialFlow[0]==0x03)){
    2944:	84 85       	ldd	r24, Z+12	; 0x0c
    2946:	82 30       	cpi	r24, 0x02	; 2
    2948:	f9 f4       	brne	.+62     	; 0x2988 <ScanRFIDFlow+0x60>
    294a:	80 91 07 0c 	lds	r24, 0x0C07
    294e:	8a 30       	cpi	r24, 0x0A	; 10
    2950:	d9 f4       	brne	.+54     	; 0x2988 <ScanRFIDFlow+0x60>
    2952:	93 30       	cpi	r25, 0x03	; 3
    2954:	c9 f4       	brne	.+50     	; 0x2988 <ScanRFIDFlow+0x60>
    2956:	f9 01       	movw	r30, r18
    2958:	3a 96       	adiw	r30, 0x0a	; 10
    295a:	a4 ea       	ldi	r26, 0xA4	; 164
    295c:	bf e0       	ldi	r27, 0x0F	; 15
		for(i=0;i<8;i++) strRFID[i]=strSerialFlow[10-i];
    295e:	80 81       	ld	r24, Z
    2960:	8d 93       	st	X+, r24
    2962:	31 97       	sbiw	r30, 0x01	; 1
    2964:	8c e0       	ldi	r24, 0x0C	; 12
    2966:	e8 30       	cpi	r30, 0x08	; 8
    2968:	f8 07       	cpc	r31, r24
    296a:	c9 f7       	brne	.-14     	; 0x295e <ScanRFIDFlow+0x36>
        strRFID[8]=0;
    296c:	10 92 ac 0f 	sts	0x0FAC, r1
	    IsRFIDDetected=True;
    2970:	81 e0       	ldi	r24, 0x01	; 1
    2972:	80 93 af 01 	sts	0x01AF, r24
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    2976:	80 93 bf 03 	sts	0x03BF, r24
    297a:	10 92 c0 03 	sts	0x03C0, r1
    297e:	80 91 65 00 	lds	r24, 0x0065
    2982:	8d 7f       	andi	r24, 0xFD	; 253
    2984:	80 93 65 00 	sts	0x0065, r24
    2988:	08 95       	ret

0000298a <__vector_18>:
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
}

ISR(USART0_RX_vect){
    298a:	1f 92       	push	r1
    298c:	0f 92       	push	r0
    298e:	0f b6       	in	r0, 0x3f	; 63
    2990:	0f 92       	push	r0
    2992:	11 24       	eor	r1, r1
    2994:	8f 93       	push	r24
    2996:	9f 93       	push	r25
	char dataRX0,IsSPI=False;
	dataRX0= UDR0;
    2998:	9c b1       	in	r25, 0x0c	; 12
	//PrintBusyDetection
	if ((IsBusyIdlePrinting==True)||(IsBusyFreePrinting==True)){
    299a:	80 91 c8 01 	lds	r24, 0x01C8
    299e:	81 30       	cpi	r24, 0x01	; 1
    29a0:	21 f0       	breq	.+8      	; 0x29aa <__vector_18+0x20>
    29a2:	80 91 ca 01 	lds	r24, 0x01CA
    29a6:	81 30       	cpi	r24, 0x01	; 1
    29a8:	51 f4       	brne	.+20     	; 0x29be <__vector_18+0x34>
	    if (dataRX0==19)IsBusyPrint=True;
    29aa:	93 31       	cpi	r25, 0x13	; 19
    29ac:	21 f4       	brne	.+8      	; 0x29b6 <__vector_18+0x2c>
    29ae:	81 e0       	ldi	r24, 0x01	; 1
    29b0:	80 93 c9 01 	sts	0x01C9, r24
    29b4:	04 c0       	rjmp	.+8      	; 0x29be <__vector_18+0x34>
		else 
	    if (dataRX0==17)IsBusyPrint=False;	
    29b6:	91 31       	cpi	r25, 0x11	; 17
    29b8:	11 f4       	brne	.+4      	; 0x29be <__vector_18+0x34>
    29ba:	10 92 c9 01 	sts	0x01C9, r1
	}
}
    29be:	9f 91       	pop	r25
    29c0:	8f 91       	pop	r24
    29c2:	0f 90       	pop	r0
    29c4:	0f be       	out	0x3f, r0	; 63
    29c6:	0f 90       	pop	r0
    29c8:	1f 90       	pop	r1
    29ca:	18 95       	reti

000029cc <ScanCommand>:

char ScanCommand(char *strFlow,char *fCommand){
     char Result;
	 Result=False;
   return Result;
}
    29cc:	80 e0       	ldi	r24, 0x00	; 0
    29ce:	08 95       	ret

000029d0 <ConfigProtocol>:
	 }
	 _uart_printf(1,1,PSTR(">"));
	 //End
}

void ConfigProtocol(char dataIn){
    29d0:	28 2f       	mov	r18, r24
     static char Conflow[7];
    //Configuration Data Request 
	if ((Conflow[6]=='i')&&(Conflow[5]=='C')&&(Conflow[4]=='o')&&(Conflow[3]=='n')&&(Conflow[2]=='f')&&(Conflow[1]=='?')&&(Conflow[0]==0x0D)&&(dataIn==0x0A)){
    29d2:	80 91 ac 03 	lds	r24, 0x03AC
    29d6:	89 36       	cpi	r24, 0x69	; 105
    29d8:	e9 f4       	brne	.+58     	; 0x2a14 <ConfigProtocol+0x44>
    29da:	80 91 ab 03 	lds	r24, 0x03AB
    29de:	83 34       	cpi	r24, 0x43	; 67
    29e0:	c9 f4       	brne	.+50     	; 0x2a14 <ConfigProtocol+0x44>
    29e2:	80 91 aa 03 	lds	r24, 0x03AA
    29e6:	8f 36       	cpi	r24, 0x6F	; 111
    29e8:	a9 f4       	brne	.+42     	; 0x2a14 <ConfigProtocol+0x44>
    29ea:	80 91 a9 03 	lds	r24, 0x03A9
    29ee:	8e 36       	cpi	r24, 0x6E	; 110
    29f0:	89 f4       	brne	.+34     	; 0x2a14 <ConfigProtocol+0x44>
    29f2:	80 91 a8 03 	lds	r24, 0x03A8
    29f6:	86 36       	cpi	r24, 0x66	; 102
    29f8:	69 f4       	brne	.+26     	; 0x2a14 <ConfigProtocol+0x44>
    29fa:	80 91 a7 03 	lds	r24, 0x03A7
    29fe:	8f 33       	cpi	r24, 0x3F	; 63
    2a00:	49 f4       	brne	.+18     	; 0x2a14 <ConfigProtocol+0x44>
    2a02:	80 91 a6 03 	lds	r24, 0x03A6
    2a06:	8d 30       	cpi	r24, 0x0D	; 13
    2a08:	29 f4       	brne	.+10     	; 0x2a14 <ConfigProtocol+0x44>
    2a0a:	2a 30       	cpi	r18, 0x0A	; 10
    2a0c:	19 f4       	brne	.+6      	; 0x2a14 <ConfigProtocol+0x44>
	     //SendConfigParamater();        
		 ConfigCommand=CC_SEND_CONFIG;
    2a0e:	82 e0       	ldi	r24, 0x02	; 2
    2a10:	80 93 c6 01 	sts	0x01C6, r24
	}

	if (IsConfigFlow==True){        
    2a14:	80 91 98 01 	lds	r24, 0x0198
    2a18:	81 30       	cpi	r24, 0x01	; 1
    2a1a:	69 f4       	brne	.+26     	; 0x2a36 <ConfigProtocol+0x66>
	    rcv_trans[char_count]=dataIn;
    2a1c:	80 91 9c 01 	lds	r24, 0x019C
    2a20:	90 91 9d 01 	lds	r25, 0x019D
    2a24:	fc 01       	movw	r30, r24
    2a26:	ed 57       	subi	r30, 0x7D	; 125
    2a28:	f3 4f       	sbci	r31, 0xF3	; 243
    2a2a:	20 83       	st	Z, r18
	    char_count++; 
    2a2c:	01 96       	adiw	r24, 0x01	; 1
    2a2e:	90 93 9d 01 	sts	0x019D, r25
    2a32:	80 93 9c 01 	sts	0x019C, r24
	}
	if ((Conflow[0]==0x04)&&(dataIn==0x40)){
    2a36:	80 91 a6 03 	lds	r24, 0x03A6
    2a3a:	84 30       	cpi	r24, 0x04	; 4
    2a3c:	51 f4       	brne	.+20     	; 0x2a52 <ConfigProtocol+0x82>
    2a3e:	20 34       	cpi	r18, 0x40	; 64
    2a40:	e9 f4       	brne	.+58     	; 0x2a7c <ConfigProtocol+0xac>
	     IsConfigFlow=True;
    2a42:	81 e0       	ldi	r24, 0x01	; 1
    2a44:	80 93 98 01 	sts	0x0198, r24
		 char_count=0;
    2a48:	10 92 9d 01 	sts	0x019D, r1
    2a4c:	10 92 9c 01 	sts	0x019C, r1
    2a50:	15 c0       	rjmp	.+42     	; 0x2a7c <ConfigProtocol+0xac>
	}
	//SavingData
	if ((Conflow[0]==0x05)&&(dataIn==0x50)){
    2a52:	85 30       	cpi	r24, 0x05	; 5
    2a54:	99 f4       	brne	.+38     	; 0x2a7c <ConfigProtocol+0xac>
    2a56:	20 35       	cpi	r18, 0x50	; 80
    2a58:	89 f4       	brne	.+34     	; 0x2a7c <ConfigProtocol+0xac>
	     transLength=char_count;
    2a5a:	80 91 9c 01 	lds	r24, 0x019C
    2a5e:	90 91 9d 01 	lds	r25, 0x019D
    2a62:	90 93 9f 01 	sts	0x019F, r25
    2a66:	80 93 9e 01 	sts	0x019E, r24
		 char_count=0;
    2a6a:	10 92 9d 01 	sts	0x019D, r1
    2a6e:	10 92 9c 01 	sts	0x019C, r1
	     IsConfigFlow=False;
    2a72:	10 92 98 01 	sts	0x0198, r1
		 ConfigCommand=CC_SAVE_CONFIG;
    2a76:	81 e0       	ldi	r24, 0x01	; 1
    2a78:	80 93 c6 01 	sts	0x01C6, r24
		 //SaveConfigParameter();
	}

	//Shifting
	Conflow[6]=Conflow[5];
    2a7c:	80 91 ab 03 	lds	r24, 0x03AB
    2a80:	80 93 ac 03 	sts	0x03AC, r24
	Conflow[5]=Conflow[4];
    2a84:	80 91 aa 03 	lds	r24, 0x03AA
    2a88:	80 93 ab 03 	sts	0x03AB, r24
	Conflow[4]=Conflow[3];
    2a8c:	80 91 a9 03 	lds	r24, 0x03A9
    2a90:	80 93 aa 03 	sts	0x03AA, r24
	Conflow[3]=Conflow[2];
    2a94:	80 91 a8 03 	lds	r24, 0x03A8
    2a98:	80 93 a9 03 	sts	0x03A9, r24
	Conflow[2]=Conflow[1];
    2a9c:	80 91 a7 03 	lds	r24, 0x03A7
    2aa0:	80 93 a8 03 	sts	0x03A8, r24
	Conflow[1]=Conflow[0];
    2aa4:	80 91 a6 03 	lds	r24, 0x03A6
    2aa8:	80 93 a7 03 	sts	0x03A7, r24
	Conflow[0]=dataIn;
    2aac:	20 93 a6 03 	sts	0x03A6, r18

}
    2ab0:	08 95       	ret

00002ab2 <system_beep>:
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    2ab2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    2ab4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    2ab6:	90 93 d7 01 	sts	0x01D7, r25
    2aba:	80 93 d6 01 	sts	0x01D6, r24
}
    2abe:	08 95       	ret

00002ac0 <systemRestart>:
	 iRestart=0;
	 while(iRestart<100){
	       strRestart[iRestart]=iRestart;
	       iRestart++;	 
	 }
}
    2ac0:	08 95       	ret

00002ac2 <Low>:

char Low(char X){
     char Result;
	 Result=(0x0F&X);
	 return Result;
}
    2ac2:	8f 70       	andi	r24, 0x0F	; 15
    2ac4:	08 95       	ret

00002ac6 <High>:
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
	 return Result;
}
    2ac6:	82 95       	swap	r24
    2ac8:	8f 70       	andi	r24, 0x0F	; 15
    2aca:	08 95       	ret

00002acc <Str>:
char Str(char H){
    2acc:	98 2f       	mov	r25, r24
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2ace:	8a 30       	cpi	r24, 0x0A	; 10
    2ad0:	10 f4       	brcc	.+4      	; 0x2ad6 <Str+0xa>
    2ad2:	80 5d       	subi	r24, 0xD0	; 208
    2ad4:	08 95       	ret
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2ad6:	8a 50       	subi	r24, 0x0A	; 10
    2ad8:	86 30       	cpi	r24, 0x06	; 6
    2ada:	10 f0       	brcs	.+4      	; 0x2ae0 <Str+0x14>
    2adc:	80 e0       	ldi	r24, 0x00	; 0
    2ade:	08 95       	ret
    2ae0:	89 2f       	mov	r24, r25
    2ae2:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}
    2ae4:	08 95       	ret

00002ae6 <charToHex>:

void charToHex(char X, char *Result){
    2ae6:	28 2f       	mov	r18, r24
    2ae8:	fb 01       	movw	r30, r22
	 Result=(0x0F&X);
	 return Result;
}
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
    2aea:	98 2f       	mov	r25, r24
    2aec:	92 95       	swap	r25
    2aee:	9f 70       	andi	r25, 0x0F	; 15
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2af0:	9a 30       	cpi	r25, 0x0A	; 10
    2af2:	18 f4       	brcc	.+6      	; 0x2afa <charToHex+0x14>
    2af4:	89 2f       	mov	r24, r25
    2af6:	80 5d       	subi	r24, 0xD0	; 208
    2af8:	08 c0       	rjmp	.+16     	; 0x2b0a <charToHex+0x24>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2afa:	89 2f       	mov	r24, r25
    2afc:	8a 50       	subi	r24, 0x0A	; 10
    2afe:	86 30       	cpi	r24, 0x06	; 6
    2b00:	10 f0       	brcs	.+4      	; 0x2b06 <charToHex+0x20>
    2b02:	80 e0       	ldi	r24, 0x00	; 0
    2b04:	02 c0       	rjmp	.+4      	; 0x2b0a <charToHex+0x24>
    2b06:	89 2f       	mov	r24, r25
    2b08:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
    2b0a:	80 83       	st	Z, r24
	lcd_print(1,1,lcdteks);
}

char Low(char X){
     char Result;
	 Result=(0x0F&X);
    2b0c:	92 2f       	mov	r25, r18
    2b0e:	9f 70       	andi	r25, 0x0F	; 15
	 Result=((X>>4)&(0x0F));
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2b10:	9a 30       	cpi	r25, 0x0A	; 10
    2b12:	18 f4       	brcc	.+6      	; 0x2b1a <charToHex+0x34>
    2b14:	89 2f       	mov	r24, r25
    2b16:	80 5d       	subi	r24, 0xD0	; 208
    2b18:	08 c0       	rjmp	.+16     	; 0x2b2a <charToHex+0x44>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2b1a:	89 2f       	mov	r24, r25
    2b1c:	8a 50       	subi	r24, 0x0A	; 10
    2b1e:	86 30       	cpi	r24, 0x06	; 6
    2b20:	10 f0       	brcs	.+4      	; 0x2b26 <charToHex+0x40>
    2b22:	80 e0       	ldi	r24, 0x00	; 0
    2b24:	02 c0       	rjmp	.+4      	; 0x2b2a <charToHex+0x44>
    2b26:	89 2f       	mov	r24, r25
    2b28:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
	 Result[1]=Str(Low(X));
    2b2a:	81 83       	std	Z+1, r24	; 0x01
	 Result[2]=0;
    2b2c:	12 82       	std	Z+2, r1	; 0x02
	 
}
    2b2e:	08 95       	ret

00002b30 <strToInt>:

char strToInt(char *str){
    2b30:	fc 01       	movw	r30, r24
     char Result;
     Result=(((str[0]-'0')*10) +(str[0]-'0'));
    2b32:	80 81       	ld	r24, Z
    2b34:	2a e0       	ldi	r18, 0x0A	; 10
    2b36:	82 9f       	mul	r24, r18
    2b38:	90 01       	movw	r18, r0
    2b3a:	11 24       	eor	r1, r1
    2b3c:	80 51       	subi	r24, 0x10	; 16
	 return Result;
}
    2b3e:	82 0f       	add	r24, r18
    2b40:	08 95       	ret

00002b42 <intToStr>:

void intToStr(char X, char *str){
    2b42:	58 2f       	mov	r21, r24
    2b44:	fb 01       	movw	r30, r22
     char R,P,S;
	 R=X/100;
    2b46:	64 e6       	ldi	r22, 0x64	; 100
    2b48:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    2b4c:	a8 2f       	mov	r26, r24
	 P=(X%100)/10;
    2b4e:	85 2f       	mov	r24, r21
    2b50:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    2b54:	89 2f       	mov	r24, r25
    2b56:	6a e0       	ldi	r22, 0x0A	; 10
    2b58:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    2b5c:	48 2f       	mov	r20, r24
	 S=X-(R*100)-(P*10);
    2b5e:	8c e9       	ldi	r24, 0x9C	; 156
    2b60:	9f ef       	ldi	r25, 0xFF	; 255
    2b62:	a8 9f       	mul	r26, r24
    2b64:	80 2d       	mov	r24, r0
    2b66:	11 24       	eor	r1, r1
    2b68:	85 0f       	add	r24, r21
    2b6a:	26 ef       	ldi	r18, 0xF6	; 246
    2b6c:	3f ef       	ldi	r19, 0xFF	; 255
    2b6e:	42 9f       	mul	r20, r18
    2b70:	90 2d       	mov	r25, r0
    2b72:	11 24       	eor	r1, r1
    2b74:	98 0f       	add	r25, r24
	 if (X>=100){
    2b76:	54 36       	cpi	r21, 0x64	; 100
    2b78:	40 f0       	brcs	.+16     	; 0x2b8a <intToStr+0x48>
	     str[0]=('0'+R);
    2b7a:	a0 5d       	subi	r26, 0xD0	; 208
    2b7c:	a0 83       	st	Z, r26
	     str[1]=('0'+P);
    2b7e:	40 5d       	subi	r20, 0xD0	; 208
    2b80:	41 83       	std	Z+1, r20	; 0x01
	     str[2]=('0'+S);
    2b82:	90 5d       	subi	r25, 0xD0	; 208
    2b84:	92 83       	std	Z+2, r25	; 0x02
	     str[3]=0;
    2b86:	13 82       	std	Z+3, r1	; 0x03
    2b88:	08 95       	ret
	 if ((X>=10)&&(X>100)){
	     str[0]=('0'+P);
	     str[1]=('0'+S);
	     str[2]=0;
	 }else 
	 if (X<=10){
    2b8a:	5b 30       	cpi	r21, 0x0B	; 11
    2b8c:	18 f4       	brcc	.+6      	; 0x2b94 <intToStr+0x52>
	     str[0]=('0'+S);
    2b8e:	90 5d       	subi	r25, 0xD0	; 208
    2b90:	90 83       	st	Z, r25
	     str[1]=0;
    2b92:	11 82       	std	Z+1, r1	; 0x01
    2b94:	08 95       	ret

00002b96 <ViewCardID>:
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;

}

void ViewCardID(){//+12345678 -->12345678
    2b96:	20 e0       	ldi	r18, 0x00	; 0
    2b98:	30 e0       	ldi	r19, 0x00	; 0
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
    2b9a:	f9 01       	movw	r30, r18
    2b9c:	e1 51       	subi	r30, 0x11	; 17
    2b9e:	f1 4f       	sbci	r31, 0xF1	; 241
    2ba0:	d9 01       	movw	r26, r18
    2ba2:	ac 55       	subi	r26, 0x5C	; 92
    2ba4:	b0 4f       	sbci	r27, 0xF0	; 240
    2ba6:	8c 91       	ld	r24, X
    2ba8:	80 83       	st	Z, r24
    2baa:	2f 5f       	subi	r18, 0xFF	; 255
    2bac:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
    2bae:	28 30       	cpi	r18, 0x08	; 8
    2bb0:	31 05       	cpc	r19, r1
    2bb2:	99 f7       	brne	.-26     	; 0x2b9a <ViewCardID+0x4>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
    2bb4:	10 92 f7 0e 	sts	0x0EF7, r1
}
    2bb8:	08 95       	ret

00002bba <StringCopy>:
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
    2bba:	cf 93       	push	r28
    2bbc:	df 93       	push	r29
    2bbe:	db 01       	movw	r26, r22
    2bc0:	ec 01       	movw	r28, r24
    2bc2:	20 e0       	ldi	r18, 0x00	; 0
    2bc4:	30 e0       	ldi	r19, 0x00	; 0
    2bc6:	07 c0       	rjmp	.+14     	; 0x2bd6 <StringCopy+0x1c>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
    2bc8:	fd 01       	movw	r30, r26
    2bca:	e2 0f       	add	r30, r18
    2bcc:	f3 1f       	adc	r31, r19
    2bce:	89 91       	ld	r24, Y+
    2bd0:	80 83       	st	Z, r24
    2bd2:	2f 5f       	subi	r18, 0xFF	; 255
    2bd4:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2bd6:	24 17       	cp	r18, r20
    2bd8:	b8 f3       	brcs	.-18     	; 0x2bc8 <StringCopy+0xe>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
    2bda:	a4 0f       	add	r26, r20
    2bdc:	b1 1d       	adc	r27, r1
    2bde:	1c 92       	st	X, r1
}
    2be0:	df 91       	pop	r29
    2be2:	cf 91       	pop	r28
    2be4:	08 95       	ret

00002be6 <StringCopyPos>:
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
    2be6:	cf 93       	push	r28
    2be8:	df 93       	push	r29
    2bea:	db 01       	movw	r26, r22
    2bec:	ec 01       	movw	r28, r24
    2bee:	c4 0f       	add	r28, r20
    2bf0:	d1 1d       	adc	r29, r1
    2bf2:	40 e0       	ldi	r20, 0x00	; 0
    2bf4:	50 e0       	ldi	r21, 0x00	; 0
    2bf6:	07 c0       	rjmp	.+14     	; 0x2c06 <StringCopyPos+0x20>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
    2bf8:	fd 01       	movw	r30, r26
    2bfa:	e4 0f       	add	r30, r20
    2bfc:	f5 1f       	adc	r31, r21
    2bfe:	89 91       	ld	r24, Y+
    2c00:	80 83       	st	Z, r24
    2c02:	4f 5f       	subi	r20, 0xFF	; 255
    2c04:	5f 4f       	sbci	r21, 0xFF	; 255
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2c06:	42 17       	cp	r20, r18
    2c08:	b8 f3       	brcs	.-18     	; 0x2bf8 <StringCopyPos+0x12>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
    2c0a:	a2 0f       	add	r26, r18
    2c0c:	b1 1d       	adc	r27, r1
    2c0e:	1c 92       	st	X, r1
}
    2c10:	df 91       	pop	r29
    2c12:	cf 91       	pop	r28
    2c14:	08 95       	ret

00002c16 <TestLocalAccount>:

void TestLocalAccount(){

}
    2c16:	08 95       	ret

00002c18 <BackLightTrig>:
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    2c18:	81 e0       	ldi	r24, 0x01	; 1
    2c1a:	80 93 bf 03 	sts	0x03BF, r24
    2c1e:	10 92 c0 03 	sts	0x03C0, r1
    2c22:	e5 e6       	ldi	r30, 0x65	; 101
    2c24:	f0 e0       	ldi	r31, 0x00	; 0
    2c26:	80 81       	ld	r24, Z
    2c28:	8d 7f       	andi	r24, 0xFD	; 253
    2c2a:	80 83       	st	Z, r24
}
    2c2c:	08 95       	ret

00002c2e <FBackLight>:

void FBackLight(){
     if (TimBackLight>0){
    2c2e:	20 91 a2 01 	lds	r18, 0x01A2
    2c32:	30 91 a3 01 	lds	r19, 0x01A3
    2c36:	21 15       	cp	r18, r1
    2c38:	31 05       	cpc	r19, r1
    2c3a:	61 f0       	breq	.+24     	; 0x2c54 <FBackLight+0x26>
	     PORTG=PORTG&0xFD;
    2c3c:	80 91 65 00 	lds	r24, 0x0065
    2c40:	8d 7f       	andi	r24, 0xFD	; 253
    2c42:	80 93 65 00 	sts	0x0065, r24
	     TimBackLight--;
    2c46:	21 50       	subi	r18, 0x01	; 1
    2c48:	30 40       	sbci	r19, 0x00	; 0
    2c4a:	30 93 a3 01 	sts	0x01A3, r19
    2c4e:	20 93 a2 01 	sts	0x01A2, r18
    2c52:	08 95       	ret
		 }
	 else PORTG=PORTG|0x02;
    2c54:	80 91 65 00 	lds	r24, 0x0065
    2c58:	82 60       	ori	r24, 0x02	; 2
    2c5a:	80 93 65 00 	sts	0x0065, r24
    2c5e:	08 95       	ret

00002c60 <GetBaudrate>:
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2c60:	82 30       	cpi	r24, 0x02	; 2
    2c62:	59 f0       	breq	.+22     	; 0x2c7a <GetBaudrate+0x1a>
    2c64:	82 30       	cpi	r24, 0x02	; 2
    2c66:	18 f0       	brcs	.+6      	; 0x2c6e <GetBaudrate+0xe>
    2c68:	83 30       	cpi	r24, 0x03	; 3
    2c6a:	21 f4       	brne	.+8      	; 0x2c74 <GetBaudrate+0x14>
    2c6c:	09 c0       	rjmp	.+18     	; 0x2c80 <GetBaudrate+0x20>
    2c6e:	20 e8       	ldi	r18, 0x80	; 128
    2c70:	35 e2       	ldi	r19, 0x25	; 37
    2c72:	08 c0       	rjmp	.+16     	; 0x2c84 <GetBaudrate+0x24>
    2c74:	20 e0       	ldi	r18, 0x00	; 0
    2c76:	30 e0       	ldi	r19, 0x00	; 0
    2c78:	05 c0       	rjmp	.+10     	; 0x2c84 <GetBaudrate+0x24>
    2c7a:	20 e0       	ldi	r18, 0x00	; 0
    2c7c:	3b e4       	ldi	r19, 0x4B	; 75
    2c7e:	02 c0       	rjmp	.+4      	; 0x2c84 <GetBaudrate+0x24>
	 case br9600: 
	      Result=9600;
	      break;
	 case br19200:
	      Result=19200;
	      break;
    2c80:	2b e9       	ldi	r18, 0x9B	; 155
    2c82:	36 e1       	ldi	r19, 0x16	; 22
	 case br5787:
	      Result=5787;
     	  break;	 
	 }
   return Result;
}
    2c84:	c9 01       	movw	r24, r18
    2c86:	08 95       	ret

00002c88 <InitMemory>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2c88:	e1 99       	sbic	0x1c, 1	; 28
    2c8a:	fe cf       	rjmp	.-4      	; 0x2c88 <InitMemory>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2c8c:	84 e4       	ldi	r24, 0x44	; 68
    2c8e:	91 e0       	ldi	r25, 0x01	; 1
    2c90:	9f bb       	out	0x1f, r25	; 31
    2c92:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2c94:	e0 9a       	sbi	0x1c, 0	; 28
    2c96:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    2c98:	80 93 5f 01 	sts	0x015F, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2c9c:	e1 99       	sbic	0x1c, 1	; 28
    2c9e:	fe cf       	rjmp	.-4      	; 0x2c9c <InitMemory+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2ca0:	89 e4       	ldi	r24, 0x49	; 73
    2ca2:	91 e0       	ldi	r25, 0x01	; 1
    2ca4:	9f bb       	out	0x1f, r25	; 31
    2ca6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2ca8:	e0 9a       	sbi	0x1c, 0	; 28
    2caa:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    2cac:	80 93 60 01 	sts	0x0160, r24
}
    2cb0:	08 95       	ret

00002cb2 <InitStandalone>:
	      RunInitStandalone=False;
	      break;
	 }
  }
  */
}
    2cb2:	08 95       	ret

00002cb4 <DisplayQueueFIP>:


void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}
    2cb4:	08 95       	ret

00002cb6 <ShowMessage>:
	 }
}

void ShowMessage(char *Message){//Display Message on Line3
     char i;
}
    2cb6:	08 95       	ret

00002cb8 <CalcLRC>:

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}
    2cb8:	86 27       	eor	r24, r22
    2cba:	08 95       	ret

00002cbc <systemEDC>:
}

void systemEDC(){//EDC Handler
     

}
    2cbc:	08 95       	ret

00002cbe <GeniusCalc>:


char GeniusCalc(char cOption, char valA, char valB){
     char valC_H,valC_L,xValA,xValB,Result;
	 Result=0;
     switch(cOption){
    2cbe:	88 23       	and	r24, r24
    2cc0:	19 f0       	breq	.+6      	; 0x2cc8 <GeniusCalc+0xa>
    2cc2:	81 30       	cpi	r24, 0x01	; 1
    2cc4:	49 f5       	brne	.+82     	; 0x2d18 <GeniusCalc+0x5a>
    2cc6:	11 c0       	rjmp	.+34     	; 0x2cea <GeniusCalc+0x2c>
	 case G_PLUS:                  // 5 + 8 = 1 + 3 = 4
	      valC_H=(valA+valB)/10;   //  
    2cc8:	26 2f       	mov	r18, r22
    2cca:	30 e0       	ldi	r19, 0x00	; 0
    2ccc:	24 0f       	add	r18, r20
    2cce:	31 1d       	adc	r19, r1
		  valC_L=(valA+valB)%10;   //
	      Result=valC_H+valC_L;
    2cd0:	c9 01       	movw	r24, r18
    2cd2:	6a e0       	ldi	r22, 0x0A	; 10
    2cd4:	70 e0       	ldi	r23, 0x00	; 0
    2cd6:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    2cda:	48 2f       	mov	r20, r24
    2cdc:	c9 01       	movw	r24, r18
    2cde:	6a e0       	ldi	r22, 0x0A	; 10
    2ce0:	70 e0       	ldi	r23, 0x00	; 0
    2ce2:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    2ce6:	46 0f       	add	r20, r22
    2ce8:	18 c0       	rjmp	.+48     	; 0x2d1a <GeniusCalc+0x5c>
	      break;
	 case G_MULTY:                 
	      if (valA>0)xValA=valA;
    2cea:	66 23       	and	r22, r22
    2cec:	09 f4       	brne	.+2      	; 0x2cf0 <GeniusCalc+0x32>
    2cee:	61 e0       	ldi	r22, 0x01	; 1
		  else xValA=1;
	      if (valB>0)xValB=valB;
    2cf0:	44 23       	and	r20, r20
    2cf2:	09 f4       	brne	.+2      	; 0x2cf6 <GeniusCalc+0x38>
    2cf4:	41 e0       	ldi	r20, 0x01	; 1
		  else xValB=1;
	      valC_H=(xValA*xValB)/10;   //  
    2cf6:	46 9f       	mul	r20, r22
    2cf8:	90 01       	movw	r18, r0
    2cfa:	11 24       	eor	r1, r1
    2cfc:	c9 01       	movw	r24, r18
    2cfe:	6a e0       	ldi	r22, 0x0A	; 10
    2d00:	70 e0       	ldi	r23, 0x00	; 0
    2d02:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    2d06:	46 2f       	mov	r20, r22
		  valC_L=(xValA*xValB)%10;   //
    2d08:	c9 01       	movw	r24, r18
    2d0a:	6a e0       	ldi	r22, 0x0A	; 10
    2d0c:	70 e0       	ldi	r23, 0x00	; 0
    2d0e:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    2d12:	64 2f       	mov	r22, r20
    2d14:	48 2f       	mov	r20, r24
    2d16:	d8 cf       	rjmp	.-80     	; 0x2cc8 <GeniusCalc+0xa>
    2d18:	40 e0       	ldi	r20, 0x00	; 0
	 case G_MINUS:
	      
	      break;
	 }
   return Result;
}
    2d1a:	84 2f       	mov	r24, r20
    2d1c:	08 95       	ret

00002d1e <FSubMenuAdmin>:

char FSubMenuAdmin(){
     char Result;
	 Result=MENU_DONE;
   return Result;
}
    2d1e:	81 e0       	ldi	r24, 0x01	; 1
    2d20:	08 95       	ret

00002d22 <CountNoPumpSatus>:
	      break;	 
	 } 
   return Result;
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
    2d22:	ff 92       	push	r15
    2d24:	0f 93       	push	r16
    2d26:	1f 93       	push	r17
    2d28:	cf 93       	push	r28
    2d2a:	df 93       	push	r29
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2d2c:	f0 90 5f 01 	lds	r15, 0x015F
    2d30:	ec 01       	movw	r28, r24
    2d32:	00 e0       	ldi	r16, 0x00	; 0
    2d34:	10 e0       	ldi	r17, 0x00	; 0
    2d36:	09 c0       	rjmp	.+18     	; 0x2d4a <CountNoPumpSatus+0x28>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
    2d38:	8e e0       	ldi	r24, 0x0E	; 14
    2d3a:	0e 94 95 13 	call	0x272a	; 0x272a <GetPumpStatusLabel>
    2d3e:	98 81       	ld	r25, Y
    2d40:	98 17       	cp	r25, r24
    2d42:	09 f4       	brne	.+2      	; 0x2d46 <CountNoPumpSatus+0x24>
		      Result++;		  
    2d44:	1f 5f       	subi	r17, 0xFF	; 255
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2d46:	0f 5f       	subi	r16, 0xFF	; 255
    2d48:	21 96       	adiw	r28, 0x01	; 1
    2d4a:	0f 15       	cp	r16, r15
    2d4c:	a8 f3       	brcs	.-22     	; 0x2d38 <CountNoPumpSatus+0x16>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    2d4e:	81 2f       	mov	r24, r17
    2d50:	df 91       	pop	r29
    2d52:	cf 91       	pop	r28
    2d54:	1f 91       	pop	r17
    2d56:	0f 91       	pop	r16
    2d58:	ff 90       	pop	r15
    2d5a:	08 95       	ret

00002d5c <FCloseDay>:
   return Result;
}

char FCloseDay(){

}
    2d5c:	08 95       	ret

00002d5e <FLockPump>:
char FLockPump(){

}
    2d5e:	08 95       	ret

00002d60 <FMenuSettingPassword>:
char FMenuSettingPassword(){
     char Result;
   //_menu_password();
   Result=MENU_DONE;
   return Result;
}
    2d60:	81 e0       	ldi	r24, 0x01	; 1
    2d62:	08 95       	ret

00002d64 <menu_product>:
   return Result;
}

void menu_product(){

}
    2d64:	08 95       	ret

00002d66 <IncValue>:
            lcd_print(xPos,yPos,strLabel);
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
    2d66:	fc 01       	movw	r30, r24
     if ((*Value)<MaxValue){
    2d68:	80 81       	ld	r24, Z
    2d6a:	84 17       	cp	r24, r20
    2d6c:	18 f4       	brcc	.+6      	; 0x2d74 <IncValue+0xe>
	     (*Value)++;
    2d6e:	8f 5f       	subi	r24, 0xFF	; 255
    2d70:	80 83       	st	Z, r24
    2d72:	08 95       	ret
	 }else *Value=MinValue;
    2d74:	60 83       	st	Z, r22
    2d76:	08 95       	ret

00002d78 <DecValue>:
}

void DecValue(char *Value,char MinValue,char MaxValue){
    2d78:	fc 01       	movw	r30, r24
     if ((*Value)>MinValue){
    2d7a:	80 81       	ld	r24, Z
    2d7c:	68 17       	cp	r22, r24
    2d7e:	18 f4       	brcc	.+6      	; 0x2d86 <DecValue+0xe>
	     (*Value)--;
    2d80:	81 50       	subi	r24, 0x01	; 1
    2d82:	80 83       	st	Z, r24
    2d84:	08 95       	ret
	 }else *Value=MaxValue;
    2d86:	40 83       	st	Z, r20
    2d88:	08 95       	ret

00002d8a <zeroIP>:
		 
		}

	}
}
void zeroIP(unsigned char Val,char *StrResult){
    2d8a:	58 2f       	mov	r21, r24
    2d8c:	fb 01       	movw	r30, r22
     unsigned char R,P,S;
	 if (Val>=100){
    2d8e:	84 36       	cpi	r24, 0x64	; 100
    2d90:	00 f1       	brcs	.+64     	; 0x2dd2 <zeroIP+0x48>
	    R=(Val/100);
    2d92:	64 e6       	ldi	r22, 0x64	; 100
    2d94:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    2d98:	48 2f       	mov	r20, r24
        P=((Val%100)/10);
    2d9a:	85 2f       	mov	r24, r21
    2d9c:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    2da0:	89 2f       	mov	r24, r25
    2da2:	6a e0       	ldi	r22, 0x0A	; 10
    2da4:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
		S=Val-((R*100)+(P*10)); 
        StrResult[0]='0'+R;//+(Val/100);
    2da8:	40 5d       	subi	r20, 0xD0	; 208
    2daa:	40 83       	st	Z, r20
    2dac:	40 53       	subi	r20, 0x30	; 48
	    StrResult[1]='0'+P;//+((Val%100)/10);
    2dae:	80 5d       	subi	r24, 0xD0	; 208
    2db0:	81 83       	std	Z+1, r24	; 0x01
    2db2:	80 53       	subi	r24, 0x30	; 48
		StrResult[2]='0'+S;//+(Val-((Val/100)*100)-((Val%100)/10));
    2db4:	50 5d       	subi	r21, 0xD0	; 208
    2db6:	2c e9       	ldi	r18, 0x9C	; 156
    2db8:	3f ef       	ldi	r19, 0xFF	; 255
    2dba:	42 9f       	mul	r20, r18
    2dbc:	40 2d       	mov	r20, r0
    2dbe:	11 24       	eor	r1, r1
    2dc0:	45 0f       	add	r20, r21
    2dc2:	26 ef       	ldi	r18, 0xF6	; 246
    2dc4:	3f ef       	ldi	r19, 0xFF	; 255
    2dc6:	82 9f       	mul	r24, r18
    2dc8:	80 2d       	mov	r24, r0
    2dca:	11 24       	eor	r1, r1
    2dcc:	84 0f       	add	r24, r20
    2dce:	82 83       	std	Z+2, r24	; 0x02
    2dd0:	10 c0       	rjmp	.+32     	; 0x2df2 <zeroIP+0x68>
		StrResult[3]=0;
		}else     
	 if ((Val>=10)&&(Val<100)){
    2dd2:	8a 50       	subi	r24, 0x0A	; 10
    2dd4:	8a 35       	cpi	r24, 0x5A	; 90
    2dd6:	78 f4       	brcc	.+30     	; 0x2df6 <zeroIP+0x6c>
        StrResult[0]='0';
    2dd8:	80 e3       	ldi	r24, 0x30	; 48
    2dda:	80 83       	st	Z, r24
	    StrResult[1]=('0'+(Val/10));
    2ddc:	85 2f       	mov	r24, r21
    2dde:	6a e0       	ldi	r22, 0x0A	; 10
    2de0:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    2de4:	80 5d       	subi	r24, 0xD0	; 208
    2de6:	81 83       	std	Z+1, r24	; 0x01
		StrResult[2]=('0'+(Val%10));
    2de8:	85 2f       	mov	r24, r21
    2dea:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    2dee:	90 5d       	subi	r25, 0xD0	; 208
    2df0:	92 83       	std	Z+2, r25	; 0x02
		StrResult[3]=0;
    2df2:	13 82       	std	Z+3, r1	; 0x03
    2df4:	08 95       	ret
		}
     else
	 if (Val<10){
    2df6:	5a 30       	cpi	r21, 0x0A	; 10
    2df8:	30 f4       	brcc	.+12     	; 0x2e06 <zeroIP+0x7c>
	    StrResult[0]='0';
    2dfa:	80 e3       	ldi	r24, 0x30	; 48
    2dfc:	80 83       	st	Z, r24
		StrResult[1]='0';
    2dfe:	81 83       	std	Z+1, r24	; 0x01
	    StrResult[2]='0'+Val;
    2e00:	50 5d       	subi	r21, 0xD0	; 208
    2e02:	52 83       	std	Z+2, r21	; 0x02
	    StrResult[3]=0;
    2e04:	13 82       	std	Z+3, r1	; 0x03
    2e06:	08 95       	ret

00002e08 <GetLocAccStatus>:


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
    2e08:	81 30       	cpi	r24, 0x01	; 1
    2e0a:	29 f0       	breq	.+10     	; 0x2e16 <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
    2e0c:	82 30       	cpi	r24, 0x02	; 2
    2e0e:	19 f0       	breq	.+6      	; 0x2e16 <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
    2e10:	83 30       	cpi	r24, 0x03	; 3
    2e12:	09 f0       	breq	.+2      	; 0x2e16 <GetLocAccStatus+0xe>
    2e14:	80 e0       	ldi	r24, 0x00	; 0
	 return Result;
}
    2e16:	08 95       	ret

00002e18 <FTestRemZero>:
	     RemZeroLead(strTest);  
		 _uart_print(0,1,strTest);

	while (1){};
  #endif
}
    2e18:	08 95       	ret

00002e1a <StrPosCopy>:
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2e1a:	cf 93       	push	r28
    2e1c:	df 93       	push	r29
    2e1e:	eb 01       	movw	r28, r22
    2e20:	da 01       	movw	r26, r20
    2e22:	a8 0f       	add	r26, r24
    2e24:	b9 1f       	adc	r27, r25
    2e26:	40 e0       	ldi	r20, 0x00	; 0
    2e28:	50 e0       	ldi	r21, 0x00	; 0
    2e2a:	07 c0       	rjmp	.+14     	; 0x2e3a <StrPosCopy+0x20>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e2c:	fe 01       	movw	r30, r28
    2e2e:	e4 0f       	add	r30, r20
    2e30:	f5 1f       	adc	r31, r21
    2e32:	8d 91       	ld	r24, X+
    2e34:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e36:	4f 5f       	subi	r20, 0xFF	; 255
    2e38:	5f 4f       	sbci	r21, 0xFF	; 255
    2e3a:	42 17       	cp	r20, r18
    2e3c:	53 07       	cpc	r21, r19
    2e3e:	b0 f3       	brcs	.-20     	; 0x2e2c <StrPosCopy+0x12>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e40:	c2 0f       	add	r28, r18
    2e42:	d3 1f       	adc	r29, r19
    2e44:	18 82       	st	Y, r1
}
    2e46:	df 91       	pop	r29
    2e48:	cf 91       	pop	r28
    2e4a:	08 95       	ret

00002e4c <StrPosPaste>:
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2e4c:	0f 93       	push	r16
    2e4e:	1f 93       	push	r17
    2e50:	cf 93       	push	r28
    2e52:	df 93       	push	r29
    2e54:	8c 01       	movw	r16, r24
    2e56:	db 01       	movw	r26, r22
    2e58:	eb 01       	movw	r28, r22
    2e5a:	c4 0f       	add	r28, r20
    2e5c:	d5 1f       	adc	r29, r21
    2e5e:	60 e0       	ldi	r22, 0x00	; 0
    2e60:	70 e0       	ldi	r23, 0x00	; 0
    2e62:	07 c0       	rjmp	.+14     	; 0x2e72 <StrPosPaste+0x26>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    2e64:	f8 01       	movw	r30, r16
    2e66:	e6 0f       	add	r30, r22
    2e68:	f7 1f       	adc	r31, r23
    2e6a:	80 81       	ld	r24, Z
    2e6c:	89 93       	st	Y+, r24
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e6e:	6f 5f       	subi	r22, 0xFF	; 255
    2e70:	7f 4f       	sbci	r23, 0xFF	; 255
    2e72:	62 17       	cp	r22, r18
    2e74:	73 07       	cpc	r23, r19
    2e76:	b0 f3       	brcs	.-20     	; 0x2e64 <StrPosPaste+0x18>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    2e78:	a4 0f       	add	r26, r20
    2e7a:	b5 1f       	adc	r27, r21
    2e7c:	a2 0f       	add	r26, r18
    2e7e:	b3 1f       	adc	r27, r19
    2e80:	1c 92       	st	X, r1
}
    2e82:	df 91       	pop	r29
    2e84:	cf 91       	pop	r28
    2e86:	1f 91       	pop	r17
    2e88:	0f 91       	pop	r16
    2e8a:	08 95       	ret

00002e8c <CharPosCopy>:
char CharPosCopy(char *Source, unsigned int IdxSource){
    2e8c:	fb 01       	movw	r30, r22
    2e8e:	e8 0f       	add	r30, r24
    2e90:	f9 1f       	adc	r31, r25
     char Result;
     Result=Source[IdxSource];
	 return Result;
}
    2e92:	80 81       	ld	r24, Z
    2e94:	08 95       	ret

00002e96 <procMessage00>:
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
    2e96:	80 91 83 0c 	lds	r24, 0x0C83
    2e9a:	81 30       	cpi	r24, 0x01	; 1
    2e9c:	51 f4       	brne	.+20     	; 0x2eb2 <procMessage00+0x1c>
    2e9e:	80 91 9e 01 	lds	r24, 0x019E
    2ea2:	90 91 9f 01 	lds	r25, 0x019F
    2ea6:	8f 97       	sbiw	r24, 0x2f	; 47
    2ea8:	21 f4       	brne	.+8      	; 0x2eb2 <procMessage00+0x1c>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
    2eaa:	80 91 a8 0c 	lds	r24, 0x0CA8
    2eae:	80 53       	subi	r24, 0x30	; 48
    2eb0:	08 95       	ret
    2eb2:	80 e0       	ldi	r24, 0x00	; 0
		 //sprintf(strSend,"R=%d",Result);
		 //_uart_print(0,1,strSend);
		 //*/
		 }
     return Result;
}
    2eb4:	08 95       	ret

00002eb6 <procMessage09>:
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    2eb6:	90 91 aa 0c 	lds	r25, 0x0CAA
    2eba:	20 e0       	ldi	r18, 0x00	; 0
    2ebc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ebe:	f9 01       	movw	r30, r18
    2ec0:	ea 51       	subi	r30, 0x1A	; 26
    2ec2:	f6 4f       	sbci	r31, 0xF6	; 246
    2ec4:	d9 01       	movw	r26, r18
    2ec6:	ad 57       	subi	r26, 0x7D	; 125
    2ec8:	b3 4f       	sbci	r27, 0xF3	; 243
    2eca:	97 96       	adiw	r26, 0x27	; 39
    2ecc:	8c 91       	ld	r24, X
    2ece:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ed0:	2f 5f       	subi	r18, 0xFF	; 255
    2ed2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ed4:	24 31       	cpi	r18, 0x14	; 20
    2ed6:	31 05       	cpc	r19, r1
    2ed8:	91 f7       	brne	.-28     	; 0x2ebe <procMessage09+0x8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2eda:	10 92 fa 09 	sts	0x09FA, r1
    2ede:	ee eb       	ldi	r30, 0xBE	; 190
    2ee0:	fc e0       	ldi	r31, 0x0C	; 12
    2ee2:	ab ef       	ldi	r26, 0xFB	; 251
    2ee4:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ee6:	81 91       	ld	r24, Z+
    2ee8:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2eea:	8c e0       	ldi	r24, 0x0C	; 12
    2eec:	e2 3d       	cpi	r30, 0xD2	; 210
    2eee:	f8 07       	cpc	r31, r24
    2ef0:	d1 f7       	brne	.-12     	; 0x2ee6 <procMessage09+0x30>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2ef2:	10 92 0f 0a 	sts	0x0A0F, r1
    2ef6:	20 e0       	ldi	r18, 0x00	; 0
    2ef8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2efa:	f9 01       	movw	r30, r18
    2efc:	ea 51       	subi	r30, 0x1A	; 26
    2efe:	f6 4f       	sbci	r31, 0xF6	; 246
    2f00:	d9 01       	movw	r26, r18
    2f02:	ae 52       	subi	r26, 0x2E	; 46
    2f04:	b3 4f       	sbci	r27, 0xF3	; 243
    2f06:	8c 91       	ld	r24, X
    2f08:	82 a7       	std	Z+42, r24	; 0x2a
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f0a:	2f 5f       	subi	r18, 0xFF	; 255
    2f0c:	3f 4f       	sbci	r19, 0xFF	; 255
    2f0e:	24 31       	cpi	r18, 0x14	; 20
    2f10:	31 05       	cpc	r19, r1
    2f12:	99 f7       	brne	.-26     	; 0x2efa <procMessage09+0x44>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f14:	10 92 24 0a 	sts	0x0A24, r1
    2f18:	20 e0       	ldi	r18, 0x00	; 0
    2f1a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f1c:	f9 01       	movw	r30, r18
    2f1e:	ea 51       	subi	r30, 0x1A	; 26
    2f20:	f6 4f       	sbci	r31, 0xF6	; 246
    2f22:	d9 01       	movw	r26, r18
    2f24:	aa 51       	subi	r26, 0x1A	; 26
    2f26:	b3 4f       	sbci	r27, 0xF3	; 243
    2f28:	8c 91       	ld	r24, X
    2f2a:	87 af       	std	Z+63, r24	; 0x3f
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f2c:	2f 5f       	subi	r18, 0xFF	; 255
    2f2e:	3f 4f       	sbci	r19, 0xFF	; 255
    2f30:	24 31       	cpi	r18, 0x14	; 20
    2f32:	31 05       	cpc	r19, r1
    2f34:	99 f7       	brne	.-26     	; 0x2f1c <procMessage09+0x66>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f36:	10 92 39 0a 	sts	0x0A39, r1
       StrPosCopy(rcv_trans,AdvanZ.Message09.strFreeMessageLine1,39,20);
       StrPosCopy(rcv_trans,AdvanZ.Message09.strFreeMessageLine2,59,20);
       StrPosCopy(rcv_trans,AdvanZ.Message09.strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,AdvanZ.Message09.strFreeMessageLine4,99,20);
	 return Result;
}
    2f3a:	89 2f       	mov	r24, r25
    2f3c:	80 53       	subi	r24, 0x30	; 48
    2f3e:	08 95       	ret

00002f40 <procMessage23>:
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}

char procMessage23(){
    2f40:	20 e0       	ldi	r18, 0x00	; 0
    2f42:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f44:	f9 01       	movw	r30, r18
    2f46:	e1 51       	subi	r30, 0x11	; 17
    2f48:	f1 4f       	sbci	r31, 0xF1	; 241
    2f4a:	d9 01       	movw	r26, r18
    2f4c:	ad 57       	subi	r26, 0x7D	; 125
    2f4e:	b3 4f       	sbci	r27, 0xF3	; 243
    2f50:	95 96       	adiw	r26, 0x25	; 37
    2f52:	8c 91       	ld	r24, X
    2f54:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f56:	2f 5f       	subi	r18, 0xFF	; 255
    2f58:	3f 4f       	sbci	r19, 0xFF	; 255
    2f5a:	24 31       	cpi	r18, 0x14	; 20
    2f5c:	31 05       	cpc	r19, r1
    2f5e:	91 f7       	brne	.-28     	; 0x2f44 <procMessage23+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f60:	10 92 03 0f 	sts	0x0F03, r1
    2f64:	20 e0       	ldi	r18, 0x00	; 0
    2f66:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f68:	f9 01       	movw	r30, r18
    2f6a:	ec 5f       	subi	r30, 0xFC	; 252
    2f6c:	fa 4f       	sbci	r31, 0xFA	; 250
    2f6e:	d9 01       	movw	r26, r18
    2f70:	ad 57       	subi	r26, 0x7D	; 125
    2f72:	b3 4f       	sbci	r27, 0xF3	; 243
    2f74:	d9 96       	adiw	r26, 0x39	; 57
    2f76:	8c 91       	ld	r24, X
    2f78:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f7a:	2f 5f       	subi	r18, 0xFF	; 255
    2f7c:	3f 4f       	sbci	r19, 0xFF	; 255
    2f7e:	2e 31       	cpi	r18, 0x1E	; 30
    2f80:	31 05       	cpc	r19, r1
    2f82:	91 f7       	brne	.-28     	; 0x2f68 <procMessage23+0x28>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f84:	10 92 22 05 	sts	0x0522, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f88:	80 91 da 0c 	lds	r24, 0x0CDA
    2f8c:	80 93 6a 05 	sts	0x056A, r24
	 }Dest[Length]=0;
    2f90:	10 92 6b 05 	sts	0x056B, r1
    2f94:	20 e0       	ldi	r18, 0x00	; 0
    2f96:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f98:	f9 01       	movw	r30, r18
    2f9a:	e2 52       	subi	r30, 0x22	; 34
    2f9c:	f4 4f       	sbci	r31, 0xF4	; 244
    2f9e:	d9 01       	movw	r26, r18
    2fa0:	a5 52       	subi	r26, 0x25	; 37
    2fa2:	b3 4f       	sbci	r27, 0xF3	; 243
    2fa4:	8c 91       	ld	r24, X
    2fa6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fa8:	2f 5f       	subi	r18, 0xFF	; 255
    2faa:	3f 4f       	sbci	r19, 0xFF	; 255
    2fac:	28 30       	cpi	r18, 0x08	; 8
    2fae:	31 05       	cpc	r19, r1
    2fb0:	99 f7       	brne	.-26     	; 0x2f98 <procMessage23+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fb2:	10 92 e6 0b 	sts	0x0BE6, r1
    2fb6:	20 e0       	ldi	r18, 0x00	; 0
    2fb8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fba:	f9 01       	movw	r30, r18
    2fbc:	e2 5a       	subi	r30, 0xA2	; 162
    2fbe:	fa 4f       	sbci	r31, 0xFA	; 250
    2fc0:	d9 01       	movw	r26, r18
    2fc2:	ad 51       	subi	r26, 0x1D	; 29
    2fc4:	b3 4f       	sbci	r27, 0xF3	; 243
    2fc6:	8c 91       	ld	r24, X
    2fc8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fca:	2f 5f       	subi	r18, 0xFF	; 255
    2fcc:	3f 4f       	sbci	r19, 0xFF	; 255
    2fce:	2a 30       	cpi	r18, 0x0A	; 10
    2fd0:	31 05       	cpc	r19, r1
    2fd2:	99 f7       	brne	.-26     	; 0x2fba <procMessage23+0x7a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fd4:	10 92 68 05 	sts	0x0568, r1
    2fd8:	20 e0       	ldi	r18, 0x00	; 0
    2fda:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fdc:	f9 01       	movw	r30, r18
    2fde:	e0 5c       	subi	r30, 0xC0	; 192
    2fe0:	f0 4f       	sbci	r31, 0xF0	; 240
    2fe2:	d9 01       	movw	r26, r18
    2fe4:	a3 51       	subi	r26, 0x13	; 19
    2fe6:	b3 4f       	sbci	r27, 0xF3	; 243
    2fe8:	8c 91       	ld	r24, X
    2fea:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fec:	2f 5f       	subi	r18, 0xFF	; 255
    2fee:	3f 4f       	sbci	r19, 0xFF	; 255
    2ff0:	2a 30       	cpi	r18, 0x0A	; 10
    2ff2:	31 05       	cpc	r19, r1
    2ff4:	99 f7       	brne	.-26     	; 0x2fdc <procMessage23+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2ff6:	10 92 4a 0f 	sts	0x0F4A, r1
    2ffa:	20 e0       	ldi	r18, 0x00	; 0
    2ffc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ffe:	f9 01       	movw	r30, r18
    3000:	eb 5d       	subi	r30, 0xDB	; 219
    3002:	f0 4f       	sbci	r31, 0xF0	; 240
    3004:	d9 01       	movw	r26, r18
    3006:	a9 50       	subi	r26, 0x09	; 9
    3008:	b3 4f       	sbci	r27, 0xF3	; 243
    300a:	8c 91       	ld	r24, X
    300c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    300e:	2f 5f       	subi	r18, 0xFF	; 255
    3010:	3f 4f       	sbci	r19, 0xFF	; 255
    3012:	23 31       	cpi	r18, 0x13	; 19
    3014:	31 05       	cpc	r19, r1
    3016:	99 f7       	brne	.-26     	; 0x2ffe <procMessage23+0xbe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3018:	10 92 38 0f 	sts	0x0F38, r1
    301c:	20 e0       	ldi	r18, 0x00	; 0
    301e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3020:	f9 01       	movw	r30, r18
    3022:	e7 5e       	subi	r30, 0xE7	; 231
    3024:	f0 4f       	sbci	r31, 0xF0	; 240
    3026:	d9 01       	movw	r26, r18
    3028:	a6 5f       	subi	r26, 0xF6	; 246
    302a:	b2 4f       	sbci	r27, 0xF2	; 242
    302c:	8c 91       	ld	r24, X
    302e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3030:	2f 5f       	subi	r18, 0xFF	; 255
    3032:	3f 4f       	sbci	r19, 0xFF	; 255
    3034:	27 30       	cpi	r18, 0x07	; 7
    3036:	31 05       	cpc	r19, r1
    3038:	99 f7       	brne	.-26     	; 0x3020 <procMessage23+0xe0>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    303a:	10 92 20 0f 	sts	0x0F20, r1
    303e:	20 e0       	ldi	r18, 0x00	; 0
    3040:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3042:	f9 01       	movw	r30, r18
    3044:	e5 56       	subi	r30, 0x65	; 101
    3046:	fb 4f       	sbci	r31, 0xFB	; 251
    3048:	d9 01       	movw	r26, r18
    304a:	af 5e       	subi	r26, 0xEF	; 239
    304c:	b2 4f       	sbci	r27, 0xF2	; 242
    304e:	8c 91       	ld	r24, X
    3050:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3052:	2f 5f       	subi	r18, 0xFF	; 255
    3054:	3f 4f       	sbci	r19, 0xFF	; 255
    3056:	24 30       	cpi	r18, 0x04	; 4
    3058:	31 05       	cpc	r19, r1
    305a:	99 f7       	brne	.-26     	; 0x3042 <procMessage23+0x102>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    305c:	10 92 9f 04 	sts	0x049F, r1
     StrPosCopy(rcv_trans,strLoyCurrMonConsumeV,106,10);
     StrPosCopy(rcv_trans,strDateTime,116,19);
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}
    3060:	80 e0       	ldi	r24, 0x00	; 0
    3062:	08 95       	ret

00003064 <procMessage81>:
_uart_print(0,1,strCardID);
*/	
     return Result;
}

char procMessage81(){// Result: HFCS0000
    3064:	cf 93       	push	r28
    3066:	df 93       	push	r29
     char Result=0,PrintCopy=0;//
	 char lcdteks[20];
	 //PrintHeader
     if ((CharPosCopy(rcv_trans,37))=='Y') Result=(Result|(1<<7));
    3068:	80 91 a8 0c 	lds	r24, 0x0CA8
    306c:	89 35       	cpi	r24, 0x59	; 89
    306e:	11 f4       	brne	.+4      	; 0x3074 <procMessage81+0x10>
    3070:	90 e8       	ldi	r25, 0x80	; 128
    3072:	01 c0       	rjmp	.+2      	; 0x3076 <procMessage81+0x12>
    3074:	90 e0       	ldi	r25, 0x00	; 0
     //PrintFooter
	 if ((CharPosCopy(rcv_trans,38))=='Y') Result=(Result|(1<<6));
    3076:	80 91 a9 0c 	lds	r24, 0x0CA9
    307a:	89 35       	cpi	r24, 0x59	; 89
    307c:	09 f4       	brne	.+2      	; 0x3080 <procMessage81+0x1c>
    307e:	90 64       	ori	r25, 0x40	; 64
	 //PaperCut
     if ((CharPosCopy(rcv_trans,39))=='Y') Result=(Result|(1<<5));
    3080:	80 91 aa 0c 	lds	r24, 0x0CAA
    3084:	89 35       	cpi	r24, 0x59	; 89
    3086:	09 f4       	brne	.+2      	; 0x308a <procMessage81+0x26>
    3088:	90 62       	ori	r25, 0x20	; 32
	 //Scrool
	 Result=(Result|(1<<4));
    308a:	90 61       	ori	r25, 0x10	; 16

	 //Copies
	 PrintCopy=(CharPosCopy(rcv_trans,40)-'0');
    308c:	80 91 ab 0c 	lds	r24, 0x0CAB
    3090:	80 53       	subi	r24, 0x30	; 48
     if (PrintCopy<=16) Result=Result|PrintCopy;
    3092:	81 31       	cpi	r24, 0x11	; 17
    3094:	08 f4       	brcc	.+2      	; 0x3098 <procMessage81+0x34>
    3096:	98 2b       	or	r25, r24
	 //Spooling
     StrPosCopy(rcv_trans,PrintBuffer,44,LengthMessage81);
    3098:	c0 91 a0 01 	lds	r28, 0x01A0
    309c:	d0 91 a1 01 	lds	r29, 0x01A1
    30a0:	20 e0       	ldi	r18, 0x00	; 0
    30a2:	30 e0       	ldi	r19, 0x00	; 0
    30a4:	0b c0       	rjmp	.+22     	; 0x30bc <procMessage81+0x58>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30a6:	f9 01       	movw	r30, r18
    30a8:	e1 53       	subi	r30, 0x31	; 49
    30aa:	fa 4f       	sbci	r31, 0xFA	; 250
    30ac:	d9 01       	movw	r26, r18
    30ae:	ad 57       	subi	r26, 0x7D	; 125
    30b0:	b3 4f       	sbci	r27, 0xF3	; 243
    30b2:	9c 96       	adiw	r26, 0x2c	; 44
    30b4:	8c 91       	ld	r24, X
    30b6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    30b8:	2f 5f       	subi	r18, 0xFF	; 255
    30ba:	3f 4f       	sbci	r19, 0xFF	; 255
    30bc:	2c 17       	cp	r18, r28
    30be:	3d 07       	cpc	r19, r29
    30c0:	90 f3       	brcs	.-28     	; 0x30a6 <procMessage81+0x42>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    30c2:	c1 53       	subi	r28, 0x31	; 49
    30c4:	da 4f       	sbci	r29, 0xFA	; 250
    30c6:	18 82       	st	Y, r1
	 //sprintf(lcdteks,"cmdPrint:%d ",Result);
     //_uart_print(0,1,lcdteks);

	 //while(1){};
	 return Result;
}
    30c8:	89 2f       	mov	r24, r25
    30ca:	df 91       	pop	r29
    30cc:	cf 91       	pop	r28
    30ce:	08 95       	ret

000030d0 <FillChar>:
	 if(CutType== 1) { _uart(_COM_PRINTER, 1, 0x6D);}
	 if(CutType== 2) {_uart(_COM_PRINTER, 1, 0x69);}

}

void FillChar(char *strMemory, unsigned int Length,char data){
    30d0:	20 e0       	ldi	r18, 0x00	; 0
    30d2:	30 e0       	ldi	r19, 0x00	; 0
    30d4:	06 c0       	rjmp	.+12     	; 0x30e2 <FillChar+0x12>
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    30d6:	fc 01       	movw	r30, r24
    30d8:	e2 0f       	add	r30, r18
    30da:	f3 1f       	adc	r31, r19
    30dc:	40 83       	st	Z, r20

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    30de:	2f 5f       	subi	r18, 0xFF	; 255
    30e0:	3f 4f       	sbci	r19, 0xFF	; 255
    30e2:	26 17       	cp	r18, r22
    30e4:	37 07       	cpc	r19, r23
    30e6:	b8 f3       	brcs	.-18     	; 0x30d6 <FillChar+0x6>
	     strMemory[i]=data;
	 }
}
    30e8:	08 95       	ret

000030ea <ProcMessage91>:

void ProcMessage91(){
    30ea:	20 e0       	ldi	r18, 0x00	; 0
    30ec:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30ee:	f9 01       	movw	r30, r18
    30f0:	e7 52       	subi	r30, 0x27	; 39
    30f2:	f0 4f       	sbci	r31, 0xF0	; 240
    30f4:	d9 01       	movw	r26, r18
    30f6:	ad 57       	subi	r26, 0x7D	; 125
    30f8:	b3 4f       	sbci	r27, 0xF3	; 243
    30fa:	95 96       	adiw	r26, 0x25	; 37
    30fc:	8c 91       	ld	r24, X
    30fe:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3100:	2f 5f       	subi	r18, 0xFF	; 255
    3102:	3f 4f       	sbci	r19, 0xFF	; 255
    3104:	26 30       	cpi	r18, 0x06	; 6
    3106:	31 05       	cpc	r19, r1
    3108:	91 f7       	brne	.-28     	; 0x30ee <ProcMessage91+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    310a:	10 92 df 0f 	sts	0x0FDF, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    310e:	80 91 ae 0c 	lds	r24, 0x0CAE
    3112:	80 93 86 09 	sts	0x0986, r24
    3116:	80 91 af 0c 	lds	r24, 0x0CAF
    311a:	80 93 87 09 	sts	0x0987, r24
	 }Dest[Length]=0;
    311e:	10 92 88 09 	sts	0x0988, r1
    3122:	20 e0       	ldi	r18, 0x00	; 0
    3124:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3126:	f9 01       	movw	r30, r18
    3128:	e5 53       	subi	r30, 0x35	; 53
    312a:	f4 4f       	sbci	r31, 0xF4	; 244
    312c:	d9 01       	movw	r26, r18
    312e:	ad 57       	subi	r26, 0x7D	; 125
    3130:	b3 4f       	sbci	r27, 0xF3	; 243
    3132:	9d 96       	adiw	r26, 0x2d	; 45
    3134:	8c 91       	ld	r24, X
    3136:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3138:	2f 5f       	subi	r18, 0xFF	; 255
    313a:	3f 4f       	sbci	r19, 0xFF	; 255
    313c:	2f 30       	cpi	r18, 0x0F	; 15
    313e:	31 05       	cpc	r19, r1
    3140:	91 f7       	brne	.-28     	; 0x3126 <ProcMessage91+0x3c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3142:	10 92 da 0b 	sts	0x0BDA, r1
    3146:	20 e0       	ldi	r18, 0x00	; 0
    3148:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    314a:	f9 01       	movw	r30, r18
    314c:	ef 57       	subi	r30, 0x7F	; 127
    314e:	f8 4f       	sbci	r31, 0xF8	; 248
    3150:	d9 01       	movw	r26, r18
    3152:	ad 57       	subi	r26, 0x7D	; 125
    3154:	b3 4f       	sbci	r27, 0xF3	; 243
    3156:	dc 96       	adiw	r26, 0x3c	; 60
    3158:	8c 91       	ld	r24, X
    315a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    315c:	2f 5f       	subi	r18, 0xFF	; 255
    315e:	3f 4f       	sbci	r19, 0xFF	; 255
    3160:	26 30       	cpi	r18, 0x06	; 6
    3162:	31 05       	cpc	r19, r1
    3164:	91 f7       	brne	.-28     	; 0x314a <ProcMessage91+0x60>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3166:	10 92 87 07 	sts	0x0787, r1
    316a:	20 e0       	ldi	r18, 0x00	; 0
    316c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    316e:	f9 01       	movw	r30, r18
    3170:	eb 5a       	subi	r30, 0xAB	; 171
    3172:	fa 4f       	sbci	r31, 0xFA	; 250
    3174:	d9 01       	movw	r26, r18
    3176:	ab 53       	subi	r26, 0x3B	; 59
    3178:	b3 4f       	sbci	r27, 0xF3	; 243
    317a:	8c 91       	ld	r24, X
    317c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    317e:	2f 5f       	subi	r18, 0xFF	; 255
    3180:	3f 4f       	sbci	r19, 0xFF	; 255
    3182:	28 30       	cpi	r18, 0x08	; 8
    3184:	31 05       	cpc	r19, r1
    3186:	99 f7       	brne	.-26     	; 0x316e <ProcMessage91+0x84>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3188:	10 92 5d 05 	sts	0x055D, r1
    318c:	20 e0       	ldi	r18, 0x00	; 0
    318e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3190:	f9 01       	movw	r30, r18
    3192:	e7 5e       	subi	r30, 0xE7	; 231
    3194:	f0 4f       	sbci	r31, 0xF0	; 240
    3196:	d9 01       	movw	r26, r18
    3198:	a3 53       	subi	r26, 0x33	; 51
    319a:	b3 4f       	sbci	r27, 0xF3	; 243
    319c:	8c 91       	ld	r24, X
    319e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    31a0:	2f 5f       	subi	r18, 0xFF	; 255
    31a2:	3f 4f       	sbci	r19, 0xFF	; 255
    31a4:	28 30       	cpi	r18, 0x08	; 8
    31a6:	31 05       	cpc	r19, r1
    31a8:	99 f7       	brne	.-26     	; 0x3190 <ProcMessage91+0xa6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    31aa:	10 92 21 0f 	sts	0x0F21, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    31ae:	80 91 d5 0c 	lds	r24, 0x0CD5
    31b2:	80 93 6a 05 	sts	0x056A, r24
	 }Dest[Length]=0;
    31b6:	10 92 6b 05 	sts	0x056B, r1
    31ba:	20 e0       	ldi	r18, 0x00	; 0
    31bc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    31be:	f9 01       	movw	r30, r18
    31c0:	e4 52       	subi	r30, 0x24	; 36
    31c2:	fb 4f       	sbci	r31, 0xFB	; 251
    31c4:	d9 01       	movw	r26, r18
    31c6:	aa 52       	subi	r26, 0x2A	; 42
    31c8:	b3 4f       	sbci	r27, 0xF3	; 243
    31ca:	8c 91       	ld	r24, X
    31cc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    31ce:	2f 5f       	subi	r18, 0xFF	; 255
    31d0:	3f 4f       	sbci	r19, 0xFF	; 255
    31d2:	29 30       	cpi	r18, 0x09	; 9
    31d4:	31 05       	cpc	r19, r1
    31d6:	99 f7       	brne	.-26     	; 0x31be <ProcMessage91+0xd4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    31d8:	10 92 e5 04 	sts	0x04E5, r1
     StrPosCopy(rcv_trans,strPrice,60,6);
     StrPosCopy(rcv_trans,strVolume,66,8);
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}
    31dc:	08 95       	ret

000031de <IdentifyMessage>:
        //sprintf_P(strSerial,PSTR("RFID:%s"),strRFID);
        //_uart_print(0,1,strSerial);
	 }
}

void IdentifyMessage(char STX,unsigned int Length){
    31de:	1f 93       	push	r17
   if (STX==0x01){
    31e0:	81 30       	cpi	r24, 0x01	; 1
    31e2:	09 f0       	breq	.+2      	; 0x31e6 <IdentifyMessage+0x8>
    31e4:	5f c0       	rjmp	.+190    	; 0x32a4 <IdentifyMessage+0xc6>
	    if ((Length==MSG00_LENGTH)||(MsgCode==0)) IsMessage00=True;//47
    31e6:	6f 32       	cpi	r22, 0x2F	; 47
    31e8:	71 05       	cpc	r23, r1
    31ea:	21 f0       	breq	.+8      	; 0x31f4 <IdentifyMessage+0x16>
    31ec:	80 91 24 01 	lds	r24, 0x0124
    31f0:	88 23       	and	r24, r24
    31f2:	21 f4       	brne	.+8      	; 0x31fc <IdentifyMessage+0x1e>
    31f4:	81 e0       	ldi	r24, 0x01	; 1
    31f6:	80 93 b5 01 	sts	0x01B5, r24
    31fa:	4a c0       	rjmp	.+148    	; 0x3290 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG09_LENGTH)||(MsgCode==9)) IsMessage09=True;//615
    31fc:	6c 36       	cpi	r22, 0x6C	; 108
    31fe:	71 05       	cpc	r23, r1
    3200:	11 f0       	breq	.+4      	; 0x3206 <IdentifyMessage+0x28>
    3202:	89 30       	cpi	r24, 0x09	; 9
    3204:	21 f4       	brne	.+8      	; 0x320e <IdentifyMessage+0x30>
    3206:	81 e0       	ldi	r24, 0x01	; 1
    3208:	80 93 ba 01 	sts	0x01BA, r24
    320c:	41 c0       	rjmp	.+130    	; 0x3290 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG11_LENGTH)||(MsgCode==11)) IsMessage11=True;//615
    320e:	92 e0       	ldi	r25, 0x02	; 2
    3210:	67 36       	cpi	r22, 0x67	; 103
    3212:	79 07       	cpc	r23, r25
    3214:	11 f0       	breq	.+4      	; 0x321a <IdentifyMessage+0x3c>
    3216:	8b 30       	cpi	r24, 0x0B	; 11
    3218:	21 f4       	brne	.+8      	; 0x3222 <IdentifyMessage+0x44>
    321a:	81 e0       	ldi	r24, 0x01	; 1
    321c:	80 93 b7 01 	sts	0x01B7, r24
    3220:	37 c0       	rjmp	.+110    	; 0x3290 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG23_LENGTH)||(MsgCode==23)) IsMessage23=True;//145
    3222:	61 39       	cpi	r22, 0x91	; 145
    3224:	71 05       	cpc	r23, r1
    3226:	11 f0       	breq	.+4      	; 0x322c <IdentifyMessage+0x4e>
    3228:	87 31       	cpi	r24, 0x17	; 23
    322a:	21 f4       	brne	.+8      	; 0x3234 <IdentifyMessage+0x56>
    322c:	81 e0       	ldi	r24, 0x01	; 1
    322e:	80 93 b9 01 	sts	0x01B9, r24
    3232:	2e c0       	rjmp	.+92     	; 0x3290 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG57_LENGTH)||(MsgCode==57)) IsMessage57=True;//230
    3234:	66 3e       	cpi	r22, 0xE6	; 230
    3236:	71 05       	cpc	r23, r1
    3238:	11 f0       	breq	.+4      	; 0x323e <IdentifyMessage+0x60>
    323a:	89 33       	cpi	r24, 0x39	; 57
    323c:	21 f4       	brne	.+8      	; 0x3246 <IdentifyMessage+0x68>
    323e:	81 e0       	ldi	r24, 0x01	; 1
    3240:	80 93 bc 01 	sts	0x01BC, r24
    3244:	25 c0       	rjmp	.+74     	; 0x3290 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG99_LENGTH)||(MsgCode==99)) IsMessage99=True;//378
    3246:	91 e0       	ldi	r25, 0x01	; 1
    3248:	68 39       	cpi	r22, 0x98	; 152
    324a:	79 07       	cpc	r23, r25
    324c:	11 f0       	breq	.+4      	; 0x3252 <IdentifyMessage+0x74>
    324e:	83 36       	cpi	r24, 0x63	; 99
    3250:	21 f4       	brne	.+8      	; 0x325a <IdentifyMessage+0x7c>
    3252:	81 e0       	ldi	r24, 0x01	; 1
    3254:	80 93 b6 01 	sts	0x01B6, r24
    3258:	1b c0       	rjmp	.+54     	; 0x3290 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG81_LENGTH)||(MsgCode==81)) IsMessage81=True;//426
    325a:	91 e0       	ldi	r25, 0x01	; 1
    325c:	66 3b       	cpi	r22, 0xB6	; 182
    325e:	79 07       	cpc	r23, r25
    3260:	11 f0       	breq	.+4      	; 0x3266 <IdentifyMessage+0x88>
    3262:	81 35       	cpi	r24, 0x51	; 81
    3264:	21 f4       	brne	.+8      	; 0x326e <IdentifyMessage+0x90>
    3266:	81 e0       	ldi	r24, 0x01	; 1
    3268:	80 93 bd 01 	sts	0x01BD, r24
    326c:	11 c0       	rjmp	.+34     	; 0x3290 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG91_LENGTH)||(MsgCode==91)) IsMessage91=True;//426
    326e:	6c 35       	cpi	r22, 0x5C	; 92
    3270:	71 05       	cpc	r23, r1
    3272:	11 f0       	breq	.+4      	; 0x3278 <IdentifyMessage+0x9a>
    3274:	8b 35       	cpi	r24, 0x5B	; 91
    3276:	21 f4       	brne	.+8      	; 0x3280 <IdentifyMessage+0xa2>
    3278:	81 e0       	ldi	r24, 0x01	; 1
    327a:	80 93 be 01 	sts	0x01BE, r24
    327e:	08 c0       	rjmp	.+16     	; 0x3290 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG21_LENGTH)||(MsgCode==21)) IsMessage21=True;//426
    3280:	66 35       	cpi	r22, 0x56	; 86
    3282:	71 05       	cpc	r23, r1
    3284:	11 f0       	breq	.+4      	; 0x328a <IdentifyMessage+0xac>
    3286:	85 31       	cpi	r24, 0x15	; 21
    3288:	19 f4       	brne	.+6      	; 0x3290 <IdentifyMessage+0xb2>
    328a:	81 e0       	ldi	r24, 0x01	; 1
    328c:	80 93 b8 01 	sts	0x01B8, r24

        //EDC AdvanZ Respond
		if (IsMessage91==True){
    3290:	10 91 be 01 	lds	r17, 0x01BE
    3294:	11 30       	cpi	r17, 0x01	; 1
    3296:	31 f4       	brne	.+12     	; 0x32a4 <IdentifyMessage+0xc6>
		    IsMessage91=False;
    3298:	10 92 be 01 	sts	0x01BE, r1
		    ProcMessage91();
    329c:	0e 94 75 18 	call	0x30ea	; 0x30ea <ProcMessage91>
			IsSendMessageEDC=True;
    32a0:	10 93 ae 01 	sts	0x01AE, r17
		  }

//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  _uart_print(1,0,SerialSend);
	 }
}
    32a4:	1f 91       	pop	r17
    32a6:	08 95       	ret

000032a8 <Tab>:

	  }
     return Result;     
}

void Tab(char *sTab, char nTab){
    32a8:	fc 01       	movw	r30, r24
    32aa:	dc 01       	movw	r26, r24
    32ac:	80 e0       	ldi	r24, 0x00	; 0
     char i;
	 for(i=0;i<nTab;i++){
	     sTab[i]=' ';
    32ae:	90 e2       	ldi	r25, 0x20	; 32
    32b0:	02 c0       	rjmp	.+4      	; 0x32b6 <Tab+0xe>
    32b2:	9d 93       	st	X+, r25
     return Result;     
}

void Tab(char *sTab, char nTab){
     char i;
	 for(i=0;i<nTab;i++){
    32b4:	8f 5f       	subi	r24, 0xFF	; 255
    32b6:	86 17       	cp	r24, r22
    32b8:	e0 f3       	brcs	.-8      	; 0x32b2 <Tab+0xa>
	     sTab[i]=' ';
	 }sTab[nTab]=0;
    32ba:	e6 0f       	add	r30, r22
    32bc:	f1 1d       	adc	r31, r1
    32be:	10 82       	st	Z, r1
}
    32c0:	08 95       	ret

000032c2 <_f_inttostr>:
}



//Old Function
void _f_inttostr(char* __string, unsigned long __value){
    32c2:	6f 92       	push	r6
    32c4:	7f 92       	push	r7
    32c6:	8f 92       	push	r8
    32c8:	9f 92       	push	r9
    32ca:	af 92       	push	r10
    32cc:	bf 92       	push	r11
    32ce:	cf 92       	push	r12
    32d0:	df 92       	push	r13
    32d2:	ef 92       	push	r14
    32d4:	ff 92       	push	r15
    32d6:	0f 93       	push	r16
    32d8:	1f 93       	push	r17
    32da:	cf 93       	push	r28
    32dc:	df 93       	push	r29
    32de:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
    32e0:	41 15       	cp	r20, r1
    32e2:	51 05       	cpc	r21, r1
    32e4:	61 05       	cpc	r22, r1
    32e6:	71 05       	cpc	r23, r1
    32e8:	21 f4       	brne	.+8      	; 0x32f2 <_f_inttostr+0x30>
		__string[0] = '0';
    32ea:	80 e3       	ldi	r24, 0x30	; 48
    32ec:	88 83       	st	Y, r24
		__string[1] = '\0';
    32ee:	19 82       	std	Y+1, r1	; 0x01
    32f0:	48 c0       	rjmp	.+144    	; 0x3382 <_f_inttostr+0xc0>
		return;
    32f2:	4a 01       	movw	r8, r20
    32f4:	5b 01       	movw	r10, r22
    32f6:	c1 2c       	mov	r12, r1
    32f8:	9a ec       	ldi	r25, 0xCA	; 202
    32fa:	d9 2e       	mov	r13, r25
    32fc:	9a e9       	ldi	r25, 0x9A	; 154
    32fe:	e9 2e       	mov	r14, r25
    3300:	9b e3       	ldi	r25, 0x3B	; 59
    3302:	f9 2e       	mov	r15, r25
    3304:	10 e0       	ldi	r17, 0x00	; 0
    3306:	00 e0       	ldi	r16, 0x00	; 0
    3308:	77 24       	eor	r7, r7
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
    330a:	80 e3       	ldi	r24, 0x30	; 48
    330c:	68 2e       	mov	r6, r24
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
    330e:	8c 14       	cp	r8, r12
    3310:	9d 04       	cpc	r9, r13
    3312:	ae 04       	cpc	r10, r14
    3314:	bf 04       	cpc	r11, r15
    3316:	d0 f0       	brcs	.+52     	; 0x334c <_f_inttostr+0x8a>
			__tmp = (int)(__num / __devider);
    3318:	c5 01       	movw	r24, r10
    331a:	b4 01       	movw	r22, r8
    331c:	a7 01       	movw	r20, r14
    331e:	96 01       	movw	r18, r12
    3320:	0e 94 b2 b8 	call	0x17164	; 0x17164 <__udivmodsi4>
    3324:	12 2f       	mov	r17, r18
			__num = __num % __devider;
    3326:	c5 01       	movw	r24, r10
    3328:	b4 01       	movw	r22, r8
    332a:	a7 01       	movw	r20, r14
    332c:	96 01       	movw	r18, r12
    332e:	0e 94 b2 b8 	call	0x17164	; 0x17164 <__udivmodsi4>
    3332:	ac 01       	movw	r20, r24
    3334:	cb 01       	movw	r24, r22
    3336:	da 01       	movw	r26, r20
    3338:	4c 01       	movw	r8, r24
    333a:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
    333c:	fe 01       	movw	r30, r28
    333e:	e0 0f       	add	r30, r16
    3340:	f1 1d       	adc	r31, r1
    3342:	10 5d       	subi	r17, 0xD0	; 208
    3344:	10 83       	st	Z, r17
    3346:	0f 5f       	subi	r16, 0xFF	; 255
    3348:	11 e0       	ldi	r17, 0x01	; 1
    334a:	07 c0       	rjmp	.+14     	; 0x335a <_f_inttostr+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
    334c:	11 23       	and	r17, r17
    334e:	29 f0       	breq	.+10     	; 0x335a <_f_inttostr+0x98>
				__string[__i++] = 0x30;
    3350:	fe 01       	movw	r30, r28
    3352:	e0 0f       	add	r30, r16
    3354:	f1 1d       	adc	r31, r1
    3356:	60 82       	st	Z, r6
    3358:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
    335a:	73 94       	inc	r7
    335c:	8a e0       	ldi	r24, 0x0A	; 10
    335e:	78 16       	cp	r7, r24
    3360:	69 f0       	breq	.+26     	; 0x337c <_f_inttostr+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
    3362:	c7 01       	movw	r24, r14
    3364:	b6 01       	movw	r22, r12
    3366:	2a e0       	ldi	r18, 0x0A	; 10
    3368:	30 e0       	ldi	r19, 0x00	; 0
    336a:	40 e0       	ldi	r20, 0x00	; 0
    336c:	50 e0       	ldi	r21, 0x00	; 0
    336e:	0e 94 b2 b8 	call	0x17164	; 0x17164 <__udivmodsi4>
    3372:	c9 01       	movw	r24, r18
    3374:	da 01       	movw	r26, r20
    3376:	6c 01       	movw	r12, r24
    3378:	7d 01       	movw	r14, r26
    337a:	c9 cf       	rjmp	.-110    	; 0x330e <_f_inttostr+0x4c>
	}
	__string[__i] = '\0';
    337c:	c0 0f       	add	r28, r16
    337e:	d1 1d       	adc	r29, r1
    3380:	18 82       	st	Y, r1
}
    3382:	df 91       	pop	r29
    3384:	cf 91       	pop	r28
    3386:	1f 91       	pop	r17
    3388:	0f 91       	pop	r16
    338a:	ff 90       	pop	r15
    338c:	ef 90       	pop	r14
    338e:	df 90       	pop	r13
    3390:	cf 90       	pop	r12
    3392:	bf 90       	pop	r11
    3394:	af 90       	pop	r10
    3396:	9f 90       	pop	r9
    3398:	8f 90       	pop	r8
    339a:	7f 90       	pop	r7
    339c:	6f 90       	pop	r6
    339e:	08 95       	ret

000033a0 <StrToRaw>:
			  }
		  }
	 }
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
    33a0:	dc 01       	movw	r26, r24
    33a2:	20 e0       	ldi	r18, 0x00	; 0
    33a4:	30 e0       	ldi	r19, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    33a6:	9c 91       	ld	r25, X
    33a8:	90 53       	subi	r25, 0x30	; 48
    33aa:	9a 30       	cpi	r25, 0x0A	; 10
    33ac:	08 f0       	brcs	.+2      	; 0x33b0 <StrToRaw+0x10>
    33ae:	90 e0       	ldi	r25, 0x00	; 0
	 char xRaw=0;
	 for (i=0;i<6;i++){
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
    33b0:	11 96       	adiw	r26, 0x01	; 1
    33b2:	8c 91       	ld	r24, X
    33b4:	11 97       	sbiw	r26, 0x01	; 1
    33b6:	80 53       	subi	r24, 0x30	; 48
    33b8:	8a 30       	cpi	r24, 0x0A	; 10
    33ba:	08 f0       	brcs	.+2      	; 0x33be <StrToRaw+0x1e>
    33bc:	80 e0       	ldi	r24, 0x00	; 0
    33be:	fb 01       	movw	r30, r22
    33c0:	e2 0f       	add	r30, r18
    33c2:	f3 1f       	adc	r31, r19
    33c4:	8f 70       	andi	r24, 0x0F	; 15
    33c6:	92 95       	swap	r25
    33c8:	90 7f       	andi	r25, 0xF0	; 240
    33ca:	98 2b       	or	r25, r24
    33cc:	90 83       	st	Z, r25
    33ce:	2f 5f       	subi	r18, 0xFF	; 255
    33d0:	3f 4f       	sbci	r19, 0xFF	; 255
    33d2:	12 96       	adiw	r26, 0x02	; 2
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
     char i,xA,xB;                //Dest  :  12345678 
	 char xRaw=0;
	 for (i=0;i<6;i++){
    33d4:	26 30       	cpi	r18, 0x06	; 6
    33d6:	31 05       	cpc	r19, r1
    33d8:	31 f7       	brne	.-52     	; 0x33a6 <StrToRaw+0x6>
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
	 }	      
}
    33da:	08 95       	ret

000033dc <RawToStr>:
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
    33dc:	cf 93       	push	r28
    33de:	df 93       	push	r29
    33e0:	eb 01       	movw	r28, r22
    33e2:	db 01       	movw	r26, r22
    33e4:	20 e0       	ldi	r18, 0x00	; 0
    33e6:	30 e0       	ldi	r19, 0x00	; 0
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
    33e8:	fc 01       	movw	r30, r24
    33ea:	e2 0f       	add	r30, r18
    33ec:	f3 1f       	adc	r31, r19
    33ee:	e0 81       	ld	r30, Z
    33f0:	4e 2f       	mov	r20, r30
    33f2:	42 95       	swap	r20
    33f4:	4f 70       	andi	r20, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    33f6:	4a 30       	cpi	r20, 0x0A	; 10
    33f8:	10 f0       	brcs	.+4      	; 0x33fe <RawToStr+0x22>
    33fa:	40 e3       	ldi	r20, 0x30	; 48
    33fc:	01 c0       	rjmp	.+2      	; 0x3400 <RawToStr+0x24>
	    Result='0'+X;
    33fe:	40 5d       	subi	r20, 0xD0	; 208
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
    3400:	ef 70       	andi	r30, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    3402:	ea 30       	cpi	r30, 0x0A	; 10
    3404:	10 f0       	brcs	.+4      	; 0x340a <RawToStr+0x2e>
    3406:	e0 e3       	ldi	r30, 0x30	; 48
    3408:	01 c0       	rjmp	.+2      	; 0x340c <RawToStr+0x30>
	    Result='0'+X;
    340a:	e0 5d       	subi	r30, 0xD0	; 208
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
    340c:	4c 93       	st	X, r20
          Dest[(2*i)+1]=cB;
    340e:	11 96       	adiw	r26, 0x01	; 1
    3410:	ec 93       	st	X, r30
    3412:	11 97       	sbiw	r26, 0x01	; 1
    3414:	2f 5f       	subi	r18, 0xFF	; 255
    3416:	3f 4f       	sbci	r19, 0xFF	; 255
    3418:	12 96       	adiw	r26, 0x02	; 2
	      Dest[i]=xRaw;
	 }	      
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
    341a:	26 30       	cpi	r18, 0x06	; 6
    341c:	31 05       	cpc	r19, r1
    341e:	21 f7       	brne	.-56     	; 0x33e8 <RawToStr+0xc>
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
          Dest[(2*i)+1]=cB;
	 }Dest[12]=0;
    3420:	1c 86       	std	Y+12, r1	; 0x0c
}
    3422:	df 91       	pop	r29
    3424:	cf 91       	pop	r28
    3426:	08 95       	ret

00003428 <CalcMinus>:
}

char CalcMinus(char A, char B){
     signed char xC;//,xA,xB;
	 char Result;
	 if (A>=B) xC=((A-'0')-(B-'0'));
    3428:	86 17       	cp	r24, r22
    342a:	08 f4       	brcc	.+2      	; 0x342e <CalcMinus+0x6>
	 else xC=10+((A-'0')-(B-'0'));//
    342c:	86 5f       	subi	r24, 0xF6	; 246
    342e:	86 1b       	sub	r24, r22
	 Result='0'+xC;
  return Result;
}
    3430:	80 5d       	subi	r24, 0xD0	; 208
    3432:	08 95       	ret

00003434 <CalcPlus>:

char CalcPlus(char A, char B){
    3434:	80 56       	subi	r24, 0x60	; 96
    3436:	86 0f       	add	r24, r22
    3438:	6a e0       	ldi	r22, 0x0A	; 10
    343a:	0e 94 7e b8 	call	0x170fc	; 0x170fc <__divmodqi4>
     signed char xA,xB,xC;
	 char Result;
	 xC=((A-'0')+(B-'0'));
     Result='0'+(xC%10);  
   return Result;
}
    343e:	89 2f       	mov	r24, r25
    3440:	80 5d       	subi	r24, 0xD0	; 208
    3442:	08 95       	ret

00003444 <Chr>:
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    3444:	8a 30       	cpi	r24, 0x0A	; 10
    3446:	10 f0       	brcs	.+4      	; 0x344c <Chr+0x8>
    3448:	80 e3       	ldi	r24, 0x30	; 48
    344a:	08 95       	ret
	    Result='0'+X;
    344c:	80 5d       	subi	r24, 0xD0	; 208
	 }
	return Result;
}
    344e:	08 95       	ret

00003450 <Ord>:
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    3450:	80 53       	subi	r24, 0x30	; 48
    3452:	8a 30       	cpi	r24, 0x0A	; 10
    3454:	08 f0       	brcs	.+2      	; 0x3458 <Ord+0x8>
    3456:	80 e0       	ldi	r24, 0x00	; 0
	    Result=c-'0';
	 }
	return Result;
}
    3458:	08 95       	ret

0000345a <GetTabSpace>:
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
    345a:	48 2f       	mov	r20, r24
    345c:	fb 01       	movw	r30, r22
     char i,nTab;
	 if (TabLength>0){
    345e:	18 16       	cp	r1, r24
    3460:	64 f4       	brge	.+24     	; 0x347a <GetTabSpace+0x20>
		 nTab=TabLength;//%40;
    3462:	56 2f       	mov	r21, r22
    3464:	db 01       	movw	r26, r22
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    3466:	90 e2       	ldi	r25, 0x20	; 32
    3468:	9d 93       	st	X+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    346a:	8a 2f       	mov	r24, r26
    346c:	85 1b       	sub	r24, r21
    346e:	84 17       	cp	r24, r20
    3470:	d8 f3       	brcs	.-10     	; 0x3468 <GetTabSpace+0xe>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    3472:	e4 0f       	add	r30, r20
    3474:	f1 1d       	adc	r31, r1
    3476:	10 82       	st	Z, r1
    3478:	08 95       	ret
     }else{
	 strTab[0]=' ';
    347a:	80 e2       	ldi	r24, 0x20	; 32
    347c:	80 83       	st	Z, r24
	 strTab[1]=0;
    347e:	11 82       	std	Z+1, r1	; 0x01
    3480:	08 95       	ret

00003482 <GetBorderValue>:

}

char GetBorderValue(char BoderType){
     char Result=0;
	 switch (BoderType){
    3482:	86 30       	cpi	r24, 0x06	; 6
    3484:	51 f1       	breq	.+84     	; 0x34da <GetBorderValue+0x58>
    3486:	87 30       	cpi	r24, 0x07	; 7
    3488:	70 f4       	brcc	.+28     	; 0x34a6 <GetBorderValue+0x24>
    348a:	83 30       	cpi	r24, 0x03	; 3
    348c:	11 f1       	breq	.+68     	; 0x34d2 <GetBorderValue+0x50>
    348e:	84 30       	cpi	r24, 0x04	; 4
    3490:	28 f4       	brcc	.+10     	; 0x349c <GetBorderValue+0x1a>
    3492:	81 30       	cpi	r24, 0x01	; 1
    3494:	c1 f0       	breq	.+48     	; 0x34c6 <GetBorderValue+0x44>
    3496:	82 30       	cpi	r24, 0x02	; 2
    3498:	c1 f4       	brne	.+48     	; 0x34ca <GetBorderValue+0x48>
    349a:	19 c0       	rjmp	.+50     	; 0x34ce <GetBorderValue+0x4c>
    349c:	84 30       	cpi	r24, 0x04	; 4
    349e:	d9 f0       	breq	.+54     	; 0x34d6 <GetBorderValue+0x54>
    34a0:	85 30       	cpi	r24, 0x05	; 5
    34a2:	99 f4       	brne	.+38     	; 0x34ca <GetBorderValue+0x48>
    34a4:	22 c0       	rjmp	.+68     	; 0x34ea <GetBorderValue+0x68>
    34a6:	89 30       	cpi	r24, 0x09	; 9
    34a8:	f1 f0       	breq	.+60     	; 0x34e6 <GetBorderValue+0x64>
    34aa:	8a 30       	cpi	r24, 0x0A	; 10
    34ac:	28 f4       	brcc	.+10     	; 0x34b8 <GetBorderValue+0x36>
    34ae:	87 30       	cpi	r24, 0x07	; 7
    34b0:	b1 f0       	breq	.+44     	; 0x34de <GetBorderValue+0x5c>
    34b2:	88 30       	cpi	r24, 0x08	; 8
    34b4:	51 f4       	brne	.+20     	; 0x34ca <GetBorderValue+0x48>
    34b6:	15 c0       	rjmp	.+42     	; 0x34e2 <GetBorderValue+0x60>
    34b8:	8b 30       	cpi	r24, 0x0B	; 11
    34ba:	d9 f0       	breq	.+54     	; 0x34f2 <GetBorderValue+0x70>
    34bc:	8b 30       	cpi	r24, 0x0B	; 11
    34be:	b8 f0       	brcs	.+46     	; 0x34ee <GetBorderValue+0x6c>
    34c0:	8c 30       	cpi	r24, 0x0C	; 12
    34c2:	19 f4       	brne	.+6      	; 0x34ca <GetBorderValue+0x48>
    34c4:	18 c0       	rjmp	.+48     	; 0x34f6 <GetBorderValue+0x74>
    34c6:	8a ed       	ldi	r24, 0xDA	; 218
    34c8:	08 95       	ret
    34ca:	80 e0       	ldi	r24, 0x00	; 0
    34cc:	08 95       	ret
    34ce:	82 ec       	ldi	r24, 0xC2	; 194
    34d0:	08 95       	ret
		case btTopLeft: 
		     Result=0xDA;
			 break;
		case btTopCenter: 
		     Result=0xC2;
			 break;
    34d2:	8f eb       	ldi	r24, 0xBF	; 191
    34d4:	08 95       	ret
		case btTopRight:
		     Result=0xBF;		 
			 break;
    34d6:	83 ec       	ldi	r24, 0xC3	; 195
    34d8:	08 95       	ret
		case btMiddleLeft: 
			 Result=0xC3;
			 break;
    34da:	84 eb       	ldi	r24, 0xB4	; 180
    34dc:	08 95       	ret
		case btMiddleRight: 
			 Result=0xB4;
			 break;
    34de:	80 ec       	ldi	r24, 0xC0	; 192
    34e0:	08 95       	ret
		case btBottomLeft: 
		     Result=0xC0;
			 break;
    34e2:	81 ec       	ldi	r24, 0xC1	; 193
    34e4:	08 95       	ret
		case btBottomCenter: 
			 Result=0xC1;
			 break;
    34e6:	89 ed       	ldi	r24, 0xD9	; 217
    34e8:	08 95       	ret
		case btBottomRight: 
			 Result=0xD9;
			 break;
    34ea:	85 ec       	ldi	r24, 0xC5	; 197
    34ec:	08 95       	ret
        case btMiddleCenter:
		     Result=0xC5;
		     break;
    34ee:	83 eb       	ldi	r24, 0xB3	; 179
    34f0:	08 95       	ret
		case btVertical: 
			 Result=0xB3;
			 break;
    34f2:	84 ec       	ldi	r24, 0xC4	; 196
    34f4:	08 95       	ret
		case btHorizontal:
			 Result=0xC4;
			 break;	 
    34f6:	8d e0       	ldi	r24, 0x0D	; 13
        case btNewLine:
		     Result=0x0D;
			 break;	 
	 }
   return Result;
}
    34f8:	08 95       	ret

000034fa <InserBorder>:

void InserBorder(char BorderType, char *strPrnBuffer,char nLength,unsigned int *Pos){
    34fa:	bf 92       	push	r11
    34fc:	cf 92       	push	r12
    34fe:	df 92       	push	r13
    3500:	ef 92       	push	r14
    3502:	ff 92       	push	r15
    3504:	0f 93       	push	r16
    3506:	1f 93       	push	r17
    3508:	cf 93       	push	r28
    350a:	df 93       	push	r29
    350c:	b8 2e       	mov	r11, r24
    350e:	8b 01       	movw	r16, r22
    3510:	e4 2e       	mov	r14, r20
    3512:	69 01       	movw	r12, r18
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
    3514:	f9 01       	movw	r30, r18
    3516:	c0 81       	ld	r28, Z
    3518:	d1 81       	ldd	r29, Z+1	; 0x01
    351a:	0c 0f       	add	r16, r28
    351c:	1d 1f       	adc	r17, r29
    351e:	ff 24       	eor	r15, r15
    3520:	07 c0       	rjmp	.+14     	; 0x3530 <InserBorder+0x36>
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
	      strPrnBuffer[iPos]=GetBorderValue(BorderType);
    3522:	8b 2d       	mov	r24, r11
    3524:	0e 94 41 1a 	call	0x3482	; 0x3482 <GetBorderValue>
    3528:	f8 01       	movw	r30, r16
    352a:	81 93       	st	Z+, r24
    352c:	8f 01       	movw	r16, r30
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
    352e:	f3 94       	inc	r15
    3530:	fe 14       	cp	r15, r14
    3532:	b8 f3       	brcs	.-18     	; 0x3522 <InserBorder+0x28>
	 //for (i=0;i<nLength;i++){
	 //     if (strPrnBuffer[i+StartPos]!=GetBorderValue(BorderType)){
//		      strPrnBuffer[i+StartPos]=GetBorderValue(BorderType);
//		  }
//	 }
     *Pos=iPos;
    3534:	ce 0d       	add	r28, r14
    3536:	d1 1d       	adc	r29, r1
    3538:	f6 01       	movw	r30, r12
    353a:	d1 83       	std	Z+1, r29	; 0x01
    353c:	c0 83       	st	Z, r28
}
    353e:	df 91       	pop	r29
    3540:	cf 91       	pop	r28
    3542:	1f 91       	pop	r17
    3544:	0f 91       	pop	r16
    3546:	ff 90       	pop	r15
    3548:	ef 90       	pop	r14
    354a:	df 90       	pop	r13
    354c:	cf 90       	pop	r12
    354e:	bf 90       	pop	r11
    3550:	08 95       	ret

00003552 <GeniusSendPumpStatus>:
   return Result;
}

void GeniusSendPumpStatus(char iPumpID){
     
}
    3552:	08 95       	ret

00003554 <GeniusSendStopPump>:
void GeniusSendStopPump(char iPumpID){
}
    3554:	08 95       	ret

00003556 <GeniusSendResumePump>:
void GeniusSendResumePump(char iPumpID){
}
    3556:	08 95       	ret

00003558 <GeniusSendPumpPreset>:
void GeniusSendPumpPreset(char iPumpID){
}
    3558:	08 95       	ret

0000355a <SetIncomingTransStatus>:
	 sprintf_P(strSend,PSTR("%d"),cSum);
	 _uart_print(1,1,strSend);	 
}


void SetIncomingTransStatus(char iPumpID,char xTransStatus){
    355a:	e8 2f       	mov	r30, r24
char iStatus,xMaskA,xMaskB,xMaskC,xPumpID;
	 xPumpID=(iPumpID&0x0F);
    355c:	28 2f       	mov	r18, r24
    355e:	2f 70       	andi	r18, 0x0F	; 15
     iStatus=IncomingTransaction[xPumpID/8];
    3560:	82 2f       	mov	r24, r18
    3562:	86 95       	lsr	r24
    3564:	86 95       	lsr	r24
    3566:	86 95       	lsr	r24
    3568:	a8 2f       	mov	r26, r24
    356a:	b0 e0       	ldi	r27, 0x00	; 0
    356c:	a3 5c       	subi	r26, 0xC3	; 195
    356e:	b0 4f       	sbci	r27, 0xF0	; 240
    3570:	4c 91       	ld	r20, X
	 if (xTransStatus==TS_NEW){
    3572:	62 30       	cpi	r22, 0x02	; 2
    3574:	59 f4       	brne	.+22     	; 0x358c <SetIncomingTransStatus+0x32>
	     iStatus=(iStatus|(1<<(xPumpID%8)));	 
    3576:	27 70       	andi	r18, 0x07	; 7
    3578:	81 e0       	ldi	r24, 0x01	; 1
    357a:	90 e0       	ldi	r25, 0x00	; 0
    357c:	02 c0       	rjmp	.+4      	; 0x3582 <SetIncomingTransStatus+0x28>
    357e:	88 0f       	add	r24, r24
    3580:	99 1f       	adc	r25, r25
    3582:	2a 95       	dec	r18
    3584:	e2 f7       	brpl	.-8      	; 0x357e <SetIncomingTransStatus+0x24>
    3586:	48 2b       	or	r20, r24
		 IncomingTransaction[xPumpID/8]=iStatus;
    3588:	4c 93       	st	X, r20
    358a:	08 95       	ret
	 }else if (xTransStatus==TS_OLD){
    358c:	63 30       	cpi	r22, 0x03	; 3
    358e:	b1 f4       	brne	.+44     	; 0x35bc <SetIncomingTransStatus+0x62>
		 xMaskA=(0xFE<<(xPumpID%8));
    3590:	27 70       	andi	r18, 0x07	; 7
    3592:	8e ef       	ldi	r24, 0xFE	; 254
    3594:	90 e0       	ldi	r25, 0x00	; 0
    3596:	01 c0       	rjmp	.+2      	; 0x359a <SetIncomingTransStatus+0x40>
    3598:	88 0f       	add	r24, r24
    359a:	2a 95       	dec	r18
    359c:	ea f7       	brpl	.-6      	; 0x3598 <SetIncomingTransStatus+0x3e>
		 xMaskB=(~xMaskA)>>1;
		 xMaskC=xMaskA|xMaskB;
		 iStatus=iStatus&xMaskC;
		 IncomingTransaction[iPumpID/8]=iStatus;
    359e:	e6 95       	lsr	r30
    35a0:	e6 95       	lsr	r30
    35a2:	e6 95       	lsr	r30
    35a4:	f0 e0       	ldi	r31, 0x00	; 0
    35a6:	e3 5c       	subi	r30, 0xC3	; 195
    35a8:	f0 4f       	sbci	r31, 0xF0	; 240
    35aa:	28 2f       	mov	r18, r24
    35ac:	30 e0       	ldi	r19, 0x00	; 0
    35ae:	20 95       	com	r18
    35b0:	30 95       	com	r19
    35b2:	35 95       	asr	r19
    35b4:	27 95       	ror	r18
    35b6:	82 2b       	or	r24, r18
    35b8:	84 23       	and	r24, r20
    35ba:	80 83       	st	Z, r24
    35bc:	08 95       	ret

000035be <GetIncomingTransStatus>:
	 }
}
char GetIncomingTransStatus(char iPumpID){
     char xPumpID,Result;
	 xPumpID=(iPumpID&0x0F);
    35be:	8f 70       	andi	r24, 0x0F	; 15
	 Result=TS_NONE;
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==1){
    35c0:	e8 2f       	mov	r30, r24
    35c2:	e6 95       	lsr	r30
    35c4:	e6 95       	lsr	r30
    35c6:	e6 95       	lsr	r30
    35c8:	f0 e0       	ldi	r31, 0x00	; 0
    35ca:	e3 5c       	subi	r30, 0xC3	; 195
    35cc:	f0 4f       	sbci	r31, 0xF0	; 240
    35ce:	90 81       	ld	r25, Z
    35d0:	29 2f       	mov	r18, r25
    35d2:	30 e0       	ldi	r19, 0x00	; 0
    35d4:	87 70       	andi	r24, 0x07	; 7
    35d6:	02 c0       	rjmp	.+4      	; 0x35dc <GetIncomingTransStatus+0x1e>
    35d8:	35 95       	asr	r19
    35da:	27 95       	ror	r18
    35dc:	8a 95       	dec	r24
    35de:	e2 f7       	brpl	.-8      	; 0x35d8 <GetIncomingTransStatus+0x1a>
    35e0:	21 30       	cpi	r18, 0x01	; 1
    35e2:	31 05       	cpc	r19, r1
    35e4:	11 f4       	brne	.+4      	; 0x35ea <GetIncomingTransStatus+0x2c>
    35e6:	82 e0       	ldi	r24, 0x02	; 2
    35e8:	08 95       	ret
	     Result=TS_NEW;
	 }else
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==0){
    35ea:	23 2b       	or	r18, r19
    35ec:	11 f4       	brne	.+4      	; 0x35f2 <GetIncomingTransStatus+0x34>
    35ee:	83 e0       	ldi	r24, 0x03	; 3
    35f0:	08 95       	ret
    35f2:	80 e0       	ldi	r24, 0x00	; 0
	     Result=TS_OLD;
	 }
   return Result;
}
    35f4:	08 95       	ret

000035f6 <SetDispenser>:
		  }
	      break;
	 }
}

void SetDispenser(char DispType){
    35f6:	df 93       	push	r29
    35f8:	cf 93       	push	r28
    35fa:	00 d0       	rcall	.+0      	; 0x35fc <SetDispenser+0x6>
    35fc:	00 d0       	rcall	.+0      	; 0x35fe <SetDispenser+0x8>
    35fe:	0f 92       	push	r0
    3600:	cd b7       	in	r28, 0x3d	; 61
    3602:	de b7       	in	r29, 0x3e	; 62
    3604:	98 2f       	mov	r25, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3606:	e1 99       	sbic	0x1c, 1	; 28
    3608:	fe cf       	rjmp	.-4      	; 0x3606 <SetDispenser+0x10>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    360a:	27 e3       	ldi	r18, 0x37	; 55
    360c:	31 e0       	ldi	r19, 0x01	; 1
    360e:	3f bb       	out	0x1f, r19	; 31
    3610:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3612:	e0 9a       	sbi	0x1c, 0	; 28
    3614:	8d b3       	in	r24, 0x1d	; 29
     char CurrentDispenser;
	 char i,DecimalSetting[5];
     CurrentDispenser=eeprom_read_byte(&DefDispenserBrand);
	 if (CurrentDispenser!=DispType){
    3616:	89 17       	cp	r24, r25
    3618:	51 f0       	breq	.+20     	; 0x362e <SetDispenser+0x38>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    361a:	e1 99       	sbic	0x1c, 1	; 28
    361c:	fe cf       	rjmp	.-4      	; 0x361a <SetDispenser+0x24>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    361e:	3f bb       	out	0x1f, r19	; 31
    3620:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    3622:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    3624:	0f b6       	in	r0, 0x3f	; 63
    3626:	f8 94       	cli
    3628:	e2 9a       	sbi	0x1c, 2	; 28
    362a:	e1 9a       	sbi	0x1c, 1	; 28
    362c:	0f be       	out	0x3f, r0	; 63
	     eeprom_write_byte(&DefDispenserBrand,DispType);
	 }
     //Apply Setting for Pump respectively
	 switch(DispType){
    362e:	91 30       	cpi	r25, 0x01	; 1
    3630:	19 f0       	breq	.+6      	; 0x3638 <SetDispenser+0x42>
    3632:	92 30       	cpi	r25, 0x02	; 2
    3634:	71 f4       	brne	.+28     	; 0x3652 <SetDispenser+0x5c>
    3636:	08 c0       	rjmp	.+16     	; 0x3648 <SetDispenser+0x52>
	 case ST_GILBARCO:
          DecimalSetting[0]=0;//Price
    3638:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=3;//Volume
    363a:	83 e0       	ldi	r24, 0x03	; 3
    363c:	8a 83       	std	Y+2, r24	; 0x02
		  DecimalSetting[2]=0;//Money
    363e:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    3640:	82 e0       	ldi	r24, 0x02	; 2
    3642:	8c 83       	std	Y+4, r24	; 0x04
		  DecimalSetting[4]=0;//TotalMoney 
    3644:	1d 82       	std	Y+5, r1	; 0x05
    3646:	05 c0       	rjmp	.+10     	; 0x3652 <SetDispenser+0x5c>
	      break;
	 case ST_WAYNE_DART:
          DecimalSetting[0]=0;//Price
    3648:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=2;//Volume
    364a:	9a 83       	std	Y+2, r25	; 0x02
		  DecimalSetting[2]=0;//Money
    364c:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    364e:	9c 83       	std	Y+4, r25	; 0x04
		  DecimalSetting[4]=2;//TotalMoney 
    3650:	9d 83       	std	Y+5, r25	; 0x05
    3652:	29 e3       	ldi	r18, 0x39	; 57
    3654:	30 e0       	ldi	r19, 0x00	; 0
    3656:	fe 01       	movw	r30, r28
    3658:	31 96       	adiw	r30, 0x01	; 1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    365a:	e1 99       	sbic	0x1c, 1	; 28
    365c:	fe cf       	rjmp	.-4      	; 0x365a <SetDispenser+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    365e:	3f bb       	out	0x1f, r19	; 31
    3660:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3662:	e0 9a       	sbi	0x1c, 0	; 28
    3664:	8d b3       	in	r24, 0x1d	; 29
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
    3666:	90 81       	ld	r25, Z
    3668:	89 17       	cp	r24, r25
    366a:	51 f0       	breq	.+20     	; 0x3680 <SetDispenser+0x8a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    366c:	e1 99       	sbic	0x1c, 1	; 28
    366e:	fe cf       	rjmp	.-4      	; 0x366c <SetDispenser+0x76>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3670:	3f bb       	out	0x1f, r19	; 31
    3672:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    3674:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    3676:	0f b6       	in	r0, 0x3f	; 63
    3678:	f8 94       	cli
    367a:	e2 9a       	sbi	0x1c, 2	; 28
    367c:	e1 9a       	sbi	0x1c, 1	; 28
    367e:	0f be       	out	0x3f, r0	; 63
    3680:	2f 5f       	subi	r18, 0xFF	; 255
    3682:	3f 4f       	sbci	r19, 0xFF	; 255
    3684:	31 96       	adiw	r30, 0x01	; 1
		  DecimalSetting[3]=2;//TotalVolume
		  DecimalSetting[4]=2;//TotalMoney 
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
    3686:	80 e0       	ldi	r24, 0x00	; 0
    3688:	2e 33       	cpi	r18, 0x3E	; 62
    368a:	38 07       	cpc	r19, r24
    368c:	31 f7       	brne	.-52     	; 0x365a <SetDispenser+0x64>
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
		     eeprom_write_byte(&DefDecimalPrice+i,DecimalSetting[i]);
		 }
	 }
}
    368e:	0f 90       	pop	r0
    3690:	0f 90       	pop	r0
    3692:	0f 90       	pop	r0
    3694:	0f 90       	pop	r0
    3696:	0f 90       	pop	r0
    3698:	cf 91       	pop	r28
    369a:	df 91       	pop	r29
    369c:	08 95       	ret

0000369e <ComposeDatetime>:
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}


void ComposeDatetime(char *Result){// 2010/10/01 16:27:44
    369e:	df 93       	push	r29
    36a0:	cf 93       	push	r28
    36a2:	cd b7       	in	r28, 0x3d	; 61
    36a4:	de b7       	in	r29, 0x3e	; 62
    36a6:	62 97       	sbiw	r28, 0x12	; 18
    36a8:	0f b6       	in	r0, 0x3f	; 63
    36aa:	f8 94       	cli
    36ac:	de bf       	out	0x3e, r29	; 62
    36ae:	0f be       	out	0x3f, r0	; 63
    36b0:	cd bf       	out	0x3d, r28	; 61
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    36b2:	20 91 9a 05 	lds	r18, 0x059A
    36b6:	2f 83       	std	Y+7, r18	; 0x07
    36b8:	20 91 9b 05 	lds	r18, 0x059B
    36bc:	28 87       	std	Y+8, r18	; 0x08
	 }Dest[Length]=0;
    36be:	20 91 9d 05 	lds	r18, 0x059D
    36c2:	2c 83       	std	Y+4, r18	; 0x04
    36c4:	20 91 9e 05 	lds	r18, 0x059E
    36c8:	2d 83       	std	Y+5, r18	; 0x05
    36ca:	20 91 a0 05 	lds	r18, 0x05A0
    36ce:	29 83       	std	Y+1, r18	; 0x01
    36d0:	20 91 a1 05 	lds	r18, 0x05A1
    36d4:	2a 83       	std	Y+2, r18	; 0x02
    36d6:	20 91 1d 0c 	lds	r18, 0x0C1D
    36da:	2a 87       	std	Y+10, r18	; 0x0a
    36dc:	20 91 1e 0c 	lds	r18, 0x0C1E
    36e0:	2b 87       	std	Y+11, r18	; 0x0b
    36e2:	20 91 20 0c 	lds	r18, 0x0C20
    36e6:	2d 87       	std	Y+13, r18	; 0x0d
    36e8:	20 91 21 0c 	lds	r18, 0x0C21
    36ec:	2e 87       	std	Y+14, r18	; 0x0e
    36ee:	20 91 23 0c 	lds	r18, 0x0C23
    36f2:	28 8b       	std	Y+16, r18	; 0x10
    36f4:	20 91 24 0c 	lds	r18, 0x0C24
    36f8:	29 8b       	std	Y+17, r18	; 0x11
    36fa:	1a 8a       	std	Y+18, r1	; 0x12
    36fc:	1f 86       	std	Y+15, r1	; 0x0f
    36fe:	1c 86       	std	Y+12, r1	; 0x0c
    3700:	1b 82       	std	Y+3, r1	; 0x03
    3702:	1e 82       	std	Y+6, r1	; 0x06
    3704:	19 86       	std	Y+9, r1	; 0x09
     StrPosCopy(strSystemDate,sYear,6,2);

     StrPosCopy(strSystemTime,sHour,0,2);
     StrPosCopy(strSystemTime,sMinute,3,2);
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
    3706:	2d b7       	in	r18, 0x3d	; 61
    3708:	3e b7       	in	r19, 0x3e	; 62
    370a:	20 51       	subi	r18, 0x10	; 16
    370c:	30 40       	sbci	r19, 0x00	; 0
    370e:	0f b6       	in	r0, 0x3f	; 63
    3710:	f8 94       	cli
    3712:	3e bf       	out	0x3e, r19	; 62
    3714:	0f be       	out	0x3f, r0	; 63
    3716:	2d bf       	out	0x3d, r18	; 61
    3718:	ed b7       	in	r30, 0x3d	; 61
    371a:	fe b7       	in	r31, 0x3e	; 62
    371c:	31 96       	adiw	r30, 0x01	; 1
    371e:	ad b7       	in	r26, 0x3d	; 61
    3720:	be b7       	in	r27, 0x3e	; 62
    3722:	12 96       	adiw	r26, 0x02	; 2
    3724:	9c 93       	st	X, r25
    3726:	8e 93       	st	-X, r24
    3728:	11 97       	sbiw	r26, 0x01	; 1
    372a:	86 e5       	ldi	r24, 0x56	; 86
    372c:	93 e0       	ldi	r25, 0x03	; 3
    372e:	93 83       	std	Z+3, r25	; 0x03
    3730:	82 83       	std	Z+2, r24	; 0x02
    3732:	ce 01       	movw	r24, r28
    3734:	01 96       	adiw	r24, 0x01	; 1
    3736:	95 83       	std	Z+5, r25	; 0x05
    3738:	84 83       	std	Z+4, r24	; 0x04
    373a:	ce 01       	movw	r24, r28
    373c:	04 96       	adiw	r24, 0x04	; 4
    373e:	97 83       	std	Z+7, r25	; 0x07
    3740:	86 83       	std	Z+6, r24	; 0x06
    3742:	ce 01       	movw	r24, r28
    3744:	07 96       	adiw	r24, 0x07	; 7
    3746:	91 87       	std	Z+9, r25	; 0x09
    3748:	80 87       	std	Z+8, r24	; 0x08
    374a:	ce 01       	movw	r24, r28
    374c:	0a 96       	adiw	r24, 0x0a	; 10
    374e:	93 87       	std	Z+11, r25	; 0x0b
    3750:	82 87       	std	Z+10, r24	; 0x0a
    3752:	ce 01       	movw	r24, r28
    3754:	0d 96       	adiw	r24, 0x0d	; 13
    3756:	95 87       	std	Z+13, r25	; 0x0d
    3758:	84 87       	std	Z+12, r24	; 0x0c
    375a:	ce 01       	movw	r24, r28
    375c:	40 96       	adiw	r24, 0x10	; 16
    375e:	97 87       	std	Z+15, r25	; 0x0f
    3760:	86 87       	std	Z+14, r24	; 0x0e
    3762:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    3766:	2d b7       	in	r18, 0x3d	; 61
    3768:	3e b7       	in	r19, 0x3e	; 62
    376a:	20 5f       	subi	r18, 0xF0	; 240
    376c:	3f 4f       	sbci	r19, 0xFF	; 255
    376e:	0f b6       	in	r0, 0x3f	; 63
    3770:	f8 94       	cli
    3772:	3e bf       	out	0x3e, r19	; 62
    3774:	0f be       	out	0x3f, r0	; 63
    3776:	2d bf       	out	0x3d, r18	; 61
}
    3778:	62 96       	adiw	r28, 0x12	; 18
    377a:	0f b6       	in	r0, 0x3f	; 63
    377c:	f8 94       	cli
    377e:	de bf       	out	0x3e, r29	; 62
    3780:	0f be       	out	0x3f, r0	; 63
    3782:	cd bf       	out	0x3d, r28	; 61
    3784:	cf 91       	pop	r28
    3786:	df 91       	pop	r29
    3788:	08 95       	ret

0000378a <leadingZero>:
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    378a:	00 d0       	rcall	.+0      	; 0x378c <leadingZero+0x2>
    378c:	00 d0       	rcall	.+0      	; 0x378e <leadingZero+0x4>
    378e:	00 d0       	rcall	.+0      	; 0x3790 <leadingZero+0x6>
    3790:	ed b7       	in	r30, 0x3d	; 61
    3792:	fe b7       	in	r31, 0x3e	; 62
    3794:	31 96       	adiw	r30, 0x01	; 1
    3796:	ad b7       	in	r26, 0x3d	; 61
    3798:	be b7       	in	r27, 0x3e	; 62
    379a:	12 96       	adiw	r26, 0x02	; 2
    379c:	7c 93       	st	X, r23
    379e:	6e 93       	st	-X, r22
    37a0:	11 97       	sbiw	r26, 0x01	; 1
    37a2:	2d e5       	ldi	r18, 0x5D	; 93
    37a4:	3d e0       	ldi	r19, 0x0D	; 13
    37a6:	33 83       	std	Z+3, r19	; 0x03
    37a8:	22 83       	std	Z+2, r18	; 0x02
    37aa:	84 83       	std	Z+4, r24	; 0x04
    37ac:	15 82       	std	Z+5, r1	; 0x05
    37ae:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    37b2:	8d b7       	in	r24, 0x3d	; 61
    37b4:	9e b7       	in	r25, 0x3e	; 62
    37b6:	06 96       	adiw	r24, 0x06	; 6
    37b8:	0f b6       	in	r0, 0x3f	; 63
    37ba:	f8 94       	cli
    37bc:	9e bf       	out	0x3e, r25	; 62
    37be:	0f be       	out	0x3f, r0	; 63
    37c0:	8d bf       	out	0x3d, r24	; 61

}
    37c2:	08 95       	ret

000037c4 <UpdateSeqNum>:
	 sprintf_P(strIFT_ID,PSTR("%.2d"),IdIFT);
	 //leadingZero(IdIFT,strIFT_ID);
}

void UpdateSeqNum(){
     if (SeqNum<100)SeqNum++;
    37c4:	80 91 d1 01 	lds	r24, 0x01D1
    37c8:	84 36       	cpi	r24, 0x64	; 100
    37ca:	20 f4       	brcc	.+8      	; 0x37d4 <UpdateSeqNum+0x10>
    37cc:	8f 5f       	subi	r24, 0xFF	; 255
    37ce:	80 93 d1 01 	sts	0x01D1, r24
    37d2:	02 c0       	rjmp	.+4      	; 0x37d8 <UpdateSeqNum+0x14>
	 else SeqNum=0;
    37d4:	10 92 d1 01 	sts	0x01D1, r1
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    37d8:	00 d0       	rcall	.+0      	; 0x37da <UpdateSeqNum+0x16>
    37da:	00 d0       	rcall	.+0      	; 0x37dc <UpdateSeqNum+0x18>
    37dc:	00 d0       	rcall	.+0      	; 0x37de <UpdateSeqNum+0x1a>
    37de:	ed b7       	in	r30, 0x3d	; 61
    37e0:	fe b7       	in	r31, 0x3e	; 62
    37e2:	31 96       	adiw	r30, 0x01	; 1
    37e4:	89 e3       	ldi	r24, 0x39	; 57
    37e6:	9f e0       	ldi	r25, 0x0F	; 15
    37e8:	ad b7       	in	r26, 0x3d	; 61
    37ea:	be b7       	in	r27, 0x3e	; 62
    37ec:	12 96       	adiw	r26, 0x02	; 2
    37ee:	9c 93       	st	X, r25
    37f0:	8e 93       	st	-X, r24
    37f2:	11 97       	sbiw	r26, 0x01	; 1
    37f4:	8d e5       	ldi	r24, 0x5D	; 93
    37f6:	9d e0       	ldi	r25, 0x0D	; 13
    37f8:	93 83       	std	Z+3, r25	; 0x03
    37fa:	82 83       	std	Z+2, r24	; 0x02
    37fc:	80 91 d1 01 	lds	r24, 0x01D1
    3800:	84 83       	std	Z+4, r24	; 0x04
    3802:	15 82       	std	Z+5, r1	; 0x05
    3804:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    3808:	8d b7       	in	r24, 0x3d	; 61
    380a:	9e b7       	in	r25, 0x3e	; 62
    380c:	06 96       	adiw	r24, 0x06	; 6
    380e:	0f b6       	in	r0, 0x3f	; 63
    3810:	f8 94       	cli
    3812:	9e bf       	out	0x3e, r25	; 62
    3814:	0f be       	out	0x3f, r0	; 63
    3816:	8d bf       	out	0x3d, r24	; 61

void UpdateSeqNum(){
     if (SeqNum<100)SeqNum++;
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 
    3818:	08 95       	ret

0000381a <UpdateIFT_ID>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    381a:	e1 99       	sbic	0x1c, 1	; 28
    381c:	fe cf       	rjmp	.-4      	; 0x381a <UpdateIFT_ID>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    381e:	80 e0       	ldi	r24, 0x00	; 0
    3820:	90 e0       	ldi	r25, 0x00	; 0
    3822:	9f bb       	out	0x1f, r25	; 31
    3824:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3826:	e0 9a       	sbi	0x1c, 0	; 28
    3828:	8d b3       	in	r24, 0x1d	; 29

void UpdateIFT_ID(){
     char IdIFT;
     //sprintf_P(strIFT_ID,PSTR("%.2d"),eeprom_read_byte(&DefIFT_ID));
	 IdIFT=(eeprom_read_byte(&DefIFT_ID)%100);
	 sprintf_P(strIFT_ID,PSTR("%.2d"),IdIFT);
    382a:	00 d0       	rcall	.+0      	; 0x382c <UpdateIFT_ID+0x12>
    382c:	00 d0       	rcall	.+0      	; 0x382e <UpdateIFT_ID+0x14>
    382e:	00 d0       	rcall	.+0      	; 0x3830 <UpdateIFT_ID+0x16>
    3830:	ed b7       	in	r30, 0x3d	; 61
    3832:	fe b7       	in	r31, 0x3e	; 62
    3834:	31 96       	adiw	r30, 0x01	; 1
    3836:	2c ec       	ldi	r18, 0xCC	; 204
    3838:	35 e0       	ldi	r19, 0x05	; 5
    383a:	ad b7       	in	r26, 0x3d	; 61
    383c:	be b7       	in	r27, 0x3e	; 62
    383e:	12 96       	adiw	r26, 0x02	; 2
    3840:	3c 93       	st	X, r19
    3842:	2e 93       	st	-X, r18
    3844:	11 97       	sbiw	r26, 0x01	; 1
    3846:	27 ec       	ldi	r18, 0xC7	; 199
    3848:	30 e2       	ldi	r19, 0x20	; 32
    384a:	33 83       	std	Z+3, r19	; 0x03
    384c:	22 83       	std	Z+2, r18	; 0x02
    384e:	64 e6       	ldi	r22, 0x64	; 100
    3850:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    3854:	94 83       	std	Z+4, r25	; 0x04
    3856:	15 82       	std	Z+5, r1	; 0x05
    3858:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    385c:	8d b7       	in	r24, 0x3d	; 61
    385e:	9e b7       	in	r25, 0x3e	; 62
    3860:	06 96       	adiw	r24, 0x06	; 6
    3862:	0f b6       	in	r0, 0x3f	; 63
    3864:	f8 94       	cli
    3866:	9e bf       	out	0x3e, r25	; 62
    3868:	0f be       	out	0x3f, r0	; 63
    386a:	8d bf       	out	0x3d, r24	; 61
	 //leadingZero(IdIFT,strIFT_ID);
}
    386c:	08 95       	ret

0000386e <MasterReset>:
	 }
}

#define DEF_OPERATOR_NAME "Mr.Big"

void MasterReset(){
    386e:	df 92       	push	r13
    3870:	ef 92       	push	r14
    3872:	ff 92       	push	r15
    3874:	0f 93       	push	r16
    3876:	1f 93       	push	r17
    3878:	df 93       	push	r29
    387a:	cf 93       	push	r28
    387c:	cd b7       	in	r28, 0x3d	; 61
    387e:	de b7       	in	r29, 0x3e	; 62
    3880:	ec 97       	sbiw	r28, 0x3c	; 60
    3882:	0f b6       	in	r0, 0x3f	; 63
    3884:	f8 94       	cli
    3886:	de bf       	out	0x3e, r29	; 62
    3888:	0f be       	out	0x3f, r0	; 63
    388a:	cd bf       	out	0x3d, r28	; 61
     char strEEP[50];
	 char xArray[10];
     //Restore All Stored EEPROM data to the Default
     sprintf_P(strEEP,PSTR(DEF_OPERATOR_NAME));
    388c:	00 d0       	rcall	.+0      	; 0x388e <MasterReset+0x20>
    388e:	00 d0       	rcall	.+0      	; 0x3890 <MasterReset+0x22>
    3890:	8e 01       	movw	r16, r28
    3892:	05 5f       	subi	r16, 0xF5	; 245
    3894:	1f 4f       	sbci	r17, 0xFF	; 255
    3896:	ed b7       	in	r30, 0x3d	; 61
    3898:	fe b7       	in	r31, 0x3e	; 62
    389a:	12 83       	std	Z+2, r17	; 0x02
    389c:	01 83       	std	Z+1, r16	; 0x01
    389e:	85 e3       	ldi	r24, 0x35	; 53
    38a0:	93 e0       	ldi	r25, 0x03	; 3
    38a2:	94 83       	std	Z+4, r25	; 0x04
    38a4:	83 83       	std	Z+3, r24	; 0x03
    38a6:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    38aa:	0f 90       	pop	r0
    38ac:	0f 90       	pop	r0
    38ae:	0f 90       	pop	r0
    38b0:	0f 90       	pop	r0
    38b2:	85 e1       	ldi	r24, 0x15	; 21
    38b4:	90 e0       	ldi	r25, 0x00	; 0
    38b6:	b8 01       	movw	r22, r16
    38b8:	43 e1       	ldi	r20, 0x13	; 19
    38ba:	50 e0       	ldi	r21, 0x00	; 0
    38bc:	20 e0       	ldi	r18, 0x00	; 0
    38be:	33 e1       	ldi	r19, 0x13	; 19
    38c0:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefOperatorName, sizeof(DefOperatorName));

	 xArray[0]=192;	 xArray[1]=168; 	 xArray[2]=16;	 xArray[3]=70; 
    38c4:	e0 ec       	ldi	r30, 0xC0	; 192
    38c6:	de 2e       	mov	r13, r30
    38c8:	d9 82       	std	Y+1, r13	; 0x01
    38ca:	78 ea       	ldi	r23, 0xA8	; 168
    38cc:	e7 2e       	mov	r14, r23
    38ce:	ea 82       	std	Y+2, r14	; 0x02
    38d0:	60 e1       	ldi	r22, 0x10	; 16
    38d2:	f6 2e       	mov	r15, r22
    38d4:	fb 82       	std	Y+3, r15	; 0x03
    38d6:	86 e4       	ldi	r24, 0x46	; 70
    38d8:	8c 83       	std	Y+4, r24	; 0x04
    38da:	88 e2       	ldi	r24, 0x28	; 40
    38dc:	90 e0       	ldi	r25, 0x00	; 0
    38de:	8e 01       	movw	r16, r28
    38e0:	0f 5f       	subi	r16, 0xFF	; 255
    38e2:	1f 4f       	sbci	r17, 0xFF	; 255
    38e4:	b8 01       	movw	r22, r16
    38e6:	44 e0       	ldi	r20, 0x04	; 4
    38e8:	50 e0       	ldi	r21, 0x00	; 0
    38ea:	20 e0       	ldi	r18, 0x00	; 0
    38ec:	33 e1       	ldi	r19, 0x13	; 19
    38ee:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefClientIP, 4);

	 xArray[0]=192;	 xArray[1]=168; 	 xArray[2]=16;	 xArray[3]=180; 
    38f2:	d9 82       	std	Y+1, r13	; 0x01
    38f4:	ea 82       	std	Y+2, r14	; 0x02
    38f6:	fb 82       	std	Y+3, r15	; 0x03
    38f8:	84 eb       	ldi	r24, 0xB4	; 180
    38fa:	8c 83       	std	Y+4, r24	; 0x04
    38fc:	8c e2       	ldi	r24, 0x2C	; 44
    38fe:	90 e0       	ldi	r25, 0x00	; 0
    3900:	b8 01       	movw	r22, r16
    3902:	44 e0       	ldi	r20, 0x04	; 4
    3904:	50 e0       	ldi	r21, 0x00	; 0
    3906:	20 e0       	ldi	r18, 0x00	; 0
    3908:	33 e1       	ldi	r19, 0x13	; 19
    390a:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    390e:	e1 99       	sbic	0x1c, 1	; 28
    3910:	fe cf       	rjmp	.-4      	; 0x390e <MasterReset+0xa0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3912:	80 e3       	ldi	r24, 0x30	; 48
    3914:	90 e0       	ldi	r25, 0x00	; 0
    3916:	9f bb       	out	0x1f, r25	; 31
    3918:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    391a:	81 e0       	ldi	r24, 0x01	; 1
    391c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    391e:	0f b6       	in	r0, 0x3f	; 63
    3920:	f8 94       	cli
    3922:	e2 9a       	sbi	0x1c, 2	; 28
    3924:	e1 9a       	sbi	0x1c, 1	; 28
    3926:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3928:	e1 99       	sbic	0x1c, 1	; 28
    392a:	fe cf       	rjmp	.-4      	; 0x3928 <MasterReset+0xba>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    392c:	81 e3       	ldi	r24, 0x31	; 49
    392e:	90 e0       	ldi	r25, 0x00	; 0
    3930:	9f bb       	out	0x1f, r25	; 31
    3932:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3934:	87 e0       	ldi	r24, 0x07	; 7
    3936:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3938:	0f b6       	in	r0, 0x3f	; 63
    393a:	f8 94       	cli
    393c:	e2 9a       	sbi	0x1c, 2	; 28
    393e:	e1 9a       	sbi	0x1c, 1	; 28
    3940:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3942:	e1 99       	sbic	0x1c, 1	; 28
    3944:	fe cf       	rjmp	.-4      	; 0x3942 <MasterReset+0xd4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3946:	82 e3       	ldi	r24, 0x32	; 50
    3948:	90 e0       	ldi	r25, 0x00	; 0
    394a:	9f bb       	out	0x1f, r25	; 31
    394c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    394e:	85 e0       	ldi	r24, 0x05	; 5
    3950:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3952:	0f b6       	in	r0, 0x3f	; 63
    3954:	f8 94       	cli
    3956:	e2 9a       	sbi	0x1c, 2	; 28
    3958:	e1 9a       	sbi	0x1c, 1	; 28
    395a:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    395c:	e1 99       	sbic	0x1c, 1	; 28
    395e:	fe cf       	rjmp	.-4      	; 0x395c <MasterReset+0xee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3960:	83 e3       	ldi	r24, 0x33	; 51
    3962:	90 e0       	ldi	r25, 0x00	; 0
    3964:	9f bb       	out	0x1f, r25	; 31
    3966:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3968:	82 e0       	ldi	r24, 0x02	; 2
    396a:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    396c:	0f b6       	in	r0, 0x3f	; 63
    396e:	f8 94       	cli
    3970:	e2 9a       	sbi	0x1c, 2	; 28
    3972:	e1 9a       	sbi	0x1c, 1	; 28
    3974:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3976:	e1 99       	sbic	0x1c, 1	; 28
    3978:	fe cf       	rjmp	.-4      	; 0x3976 <MasterReset+0x108>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    397a:	84 e3       	ldi	r24, 0x34	; 52
    397c:	90 e0       	ldi	r25, 0x00	; 0
    397e:	9f bb       	out	0x1f, r25	; 31
    3980:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3982:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3984:	0f b6       	in	r0, 0x3f	; 63
    3986:	f8 94       	cli
    3988:	e2 9a       	sbi	0x1c, 2	; 28
    398a:	e1 9a       	sbi	0x1c, 1	; 28
    398c:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    398e:	e1 99       	sbic	0x1c, 1	; 28
    3990:	fe cf       	rjmp	.-4      	; 0x398e <MasterReset+0x120>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3992:	85 e3       	ldi	r24, 0x35	; 53
    3994:	90 e0       	ldi	r25, 0x00	; 0
    3996:	9f bb       	out	0x1f, r25	; 31
    3998:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    399a:	83 e0       	ldi	r24, 0x03	; 3
    399c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    399e:	0f b6       	in	r0, 0x3f	; 63
    39a0:	f8 94       	cli
    39a2:	e2 9a       	sbi	0x1c, 2	; 28
    39a4:	e1 9a       	sbi	0x1c, 1	; 28
    39a6:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    39a8:	e1 99       	sbic	0x1c, 1	; 28
    39aa:	fe cf       	rjmp	.-4      	; 0x39a8 <MasterReset+0x13a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    39ac:	86 e3       	ldi	r24, 0x36	; 54
    39ae:	90 e0       	ldi	r25, 0x00	; 0
    39b0:	9f bb       	out	0x1f, r25	; 31
    39b2:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    39b4:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    39b6:	0f b6       	in	r0, 0x3f	; 63
    39b8:	f8 94       	cli
    39ba:	e2 9a       	sbi	0x1c, 2	; 28
    39bc:	e1 9a       	sbi	0x1c, 1	; 28
    39be:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    39c0:	e1 99       	sbic	0x1c, 1	; 28
    39c2:	fe cf       	rjmp	.-4      	; 0x39c0 <MasterReset+0x152>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    39c4:	87 e3       	ldi	r24, 0x37	; 55
    39c6:	90 e0       	ldi	r25, 0x00	; 0
    39c8:	9f bb       	out	0x1f, r25	; 31
    39ca:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    39cc:	81 e0       	ldi	r24, 0x01	; 1
    39ce:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    39d0:	0f b6       	in	r0, 0x3f	; 63
    39d2:	f8 94       	cli
    39d4:	e2 9a       	sbi	0x1c, 2	; 28
    39d6:	e1 9a       	sbi	0x1c, 1	; 28
    39d8:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    39da:	e1 99       	sbic	0x1c, 1	; 28
    39dc:	fe cf       	rjmp	.-4      	; 0x39da <MasterReset+0x16c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    39de:	88 e3       	ldi	r24, 0x38	; 56
    39e0:	90 e0       	ldi	r25, 0x00	; 0
    39e2:	9f bb       	out	0x1f, r25	; 31
    39e4:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    39e6:	81 e0       	ldi	r24, 0x01	; 1
    39e8:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    39ea:	0f b6       	in	r0, 0x3f	; 63
    39ec:	f8 94       	cli
    39ee:	e2 9a       	sbi	0x1c, 2	; 28
    39f0:	e1 9a       	sbi	0x1c, 1	; 28
    39f2:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    39f4:	e1 99       	sbic	0x1c, 1	; 28
    39f6:	fe cf       	rjmp	.-4      	; 0x39f4 <MasterReset+0x186>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    39f8:	89 e3       	ldi	r24, 0x39	; 57
    39fa:	90 e0       	ldi	r25, 0x00	; 0
    39fc:	9f bb       	out	0x1f, r25	; 31
    39fe:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a00:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3a02:	0f b6       	in	r0, 0x3f	; 63
    3a04:	f8 94       	cli
    3a06:	e2 9a       	sbi	0x1c, 2	; 28
    3a08:	e1 9a       	sbi	0x1c, 1	; 28
    3a0a:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a0c:	e1 99       	sbic	0x1c, 1	; 28
    3a0e:	fe cf       	rjmp	.-4      	; 0x3a0c <MasterReset+0x19e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a10:	8a e3       	ldi	r24, 0x3A	; 58
    3a12:	90 e0       	ldi	r25, 0x00	; 0
    3a14:	9f bb       	out	0x1f, r25	; 31
    3a16:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a18:	83 e0       	ldi	r24, 0x03	; 3
    3a1a:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3a1c:	0f b6       	in	r0, 0x3f	; 63
    3a1e:	f8 94       	cli
    3a20:	e2 9a       	sbi	0x1c, 2	; 28
    3a22:	e1 9a       	sbi	0x1c, 1	; 28
    3a24:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a26:	e1 99       	sbic	0x1c, 1	; 28
    3a28:	fe cf       	rjmp	.-4      	; 0x3a26 <MasterReset+0x1b8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a2a:	8b e3       	ldi	r24, 0x3B	; 59
    3a2c:	90 e0       	ldi	r25, 0x00	; 0
    3a2e:	9f bb       	out	0x1f, r25	; 31
    3a30:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a32:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3a34:	0f b6       	in	r0, 0x3f	; 63
    3a36:	f8 94       	cli
    3a38:	e2 9a       	sbi	0x1c, 2	; 28
    3a3a:	e1 9a       	sbi	0x1c, 1	; 28
    3a3c:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a3e:	e1 99       	sbic	0x1c, 1	; 28
    3a40:	fe cf       	rjmp	.-4      	; 0x3a3e <MasterReset+0x1d0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a42:	8c e3       	ldi	r24, 0x3C	; 60
    3a44:	90 e0       	ldi	r25, 0x00	; 0
    3a46:	9f bb       	out	0x1f, r25	; 31
    3a48:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a4a:	82 e0       	ldi	r24, 0x02	; 2
    3a4c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3a4e:	0f b6       	in	r0, 0x3f	; 63
    3a50:	f8 94       	cli
    3a52:	e2 9a       	sbi	0x1c, 2	; 28
    3a54:	e1 9a       	sbi	0x1c, 1	; 28
    3a56:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a58:	e1 99       	sbic	0x1c, 1	; 28
    3a5a:	fe cf       	rjmp	.-4      	; 0x3a58 <MasterReset+0x1ea>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a5c:	8d e3       	ldi	r24, 0x3D	; 61
    3a5e:	90 e0       	ldi	r25, 0x00	; 0
    3a60:	9f bb       	out	0x1f, r25	; 31
    3a62:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a64:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3a66:	0f b6       	in	r0, 0x3f	; 63
    3a68:	f8 94       	cli
    3a6a:	e2 9a       	sbi	0x1c, 2	; 28
    3a6c:	e1 9a       	sbi	0x1c, 1	; 28
    3a6e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a70:	e1 99       	sbic	0x1c, 1	; 28
    3a72:	fe cf       	rjmp	.-4      	; 0x3a70 <MasterReset+0x202>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a74:	8e e3       	ldi	r24, 0x3E	; 62
    3a76:	90 e0       	ldi	r25, 0x00	; 0
    3a78:	9f bb       	out	0x1f, r25	; 31
    3a7a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a7c:	8c e2       	ldi	r24, 0x2C	; 44
    3a7e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3a80:	0f b6       	in	r0, 0x3f	; 63
    3a82:	f8 94       	cli
    3a84:	e2 9a       	sbi	0x1c, 2	; 28
    3a86:	e1 9a       	sbi	0x1c, 1	; 28
    3a88:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a8a:	e1 99       	sbic	0x1c, 1	; 28
    3a8c:	fe cf       	rjmp	.-4      	; 0x3a8a <MasterReset+0x21c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a8e:	8f e3       	ldi	r24, 0x3F	; 63
    3a90:	90 e0       	ldi	r25, 0x00	; 0
    3a92:	9f bb       	out	0x1f, r25	; 31
    3a94:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a96:	9e e2       	ldi	r25, 0x2E	; 46
    3a98:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    3a9a:	0f b6       	in	r0, 0x3f	; 63
    3a9c:	f8 94       	cli
    3a9e:	e2 9a       	sbi	0x1c, 2	; 28
    3aa0:	e1 9a       	sbi	0x1c, 1	; 28
    3aa2:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefDecimalTotalVolume,2);
	 eeprom_write_byte(&DefDecimalTotalMoney,0);
	 eeprom_write_byte(&DefDecimalMark,',');
	 eeprom_write_byte(&DefCurrencyMark,'.');

	 xArray[0]=',';	 xArray[1]='.'; 	 xArray[2]=' ';	 xArray[3]='/';  xArray[4]='-'; 
    3aa4:	8c e2       	ldi	r24, 0x2C	; 44
    3aa6:	89 83       	std	Y+1, r24	; 0x01
    3aa8:	9a 83       	std	Y+2, r25	; 0x02
    3aaa:	80 e2       	ldi	r24, 0x20	; 32
    3aac:	8b 83       	std	Y+3, r24	; 0x03
    3aae:	8f e2       	ldi	r24, 0x2F	; 47
    3ab0:	8c 83       	std	Y+4, r24	; 0x04
    3ab2:	8d e2       	ldi	r24, 0x2D	; 45
    3ab4:	8d 83       	std	Y+5, r24	; 0x05
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    3ab6:	80 e4       	ldi	r24, 0x40	; 64
    3ab8:	90 e0       	ldi	r25, 0x00	; 0
    3aba:	8e 01       	movw	r16, r28
    3abc:	0f 5f       	subi	r16, 0xFF	; 255
    3abe:	1f 4f       	sbci	r17, 0xFF	; 255
    3ac0:	b8 01       	movw	r22, r16
    3ac2:	45 e0       	ldi	r20, 0x05	; 5
    3ac4:	50 e0       	ldi	r21, 0x00	; 0
    3ac6:	20 e0       	ldi	r18, 0x00	; 0
    3ac8:	33 e1       	ldi	r19, 0x13	; 19
    3aca:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefMarkMap, 5);

	 xArray[0]=1;	 xArray[1]=2; 	 xArray[2]=0;	 xArray[3]=0; xArray[4]=0;	 xArray[5]=0; xArray[6]=0;	 	 
    3ace:	81 e0       	ldi	r24, 0x01	; 1
    3ad0:	89 83       	std	Y+1, r24	; 0x01
    3ad2:	82 e0       	ldi	r24, 0x02	; 2
    3ad4:	8a 83       	std	Y+2, r24	; 0x02
    3ad6:	1b 82       	std	Y+3, r1	; 0x03
    3ad8:	1c 82       	std	Y+4, r1	; 0x04
    3ada:	1d 82       	std	Y+5, r1	; 0x05
    3adc:	1e 82       	std	Y+6, r1	; 0x06
    3ade:	1f 82       	std	Y+7, r1	; 0x07
    3ae0:	85 e4       	ldi	r24, 0x45	; 69
    3ae2:	90 e0       	ldi	r25, 0x00	; 0
    3ae4:	b8 01       	movw	r22, r16
    3ae6:	48 e0       	ldi	r20, 0x08	; 8
    3ae8:	50 e0       	ldi	r21, 0x00	; 0
    3aea:	20 e0       	ldi	r18, 0x00	; 0
    3aec:	33 e1       	ldi	r19, 0x13	; 19
    3aee:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefPumpMap, 8);
	 eeprom_write_block((const void*) &xArray, (void*) &DefPumpLabel, 8);

      

}
    3af2:	8d e4       	ldi	r24, 0x4D	; 77
    3af4:	90 e0       	ldi	r25, 0x00	; 0
    3af6:	b8 01       	movw	r22, r16
    3af8:	48 e0       	ldi	r20, 0x08	; 8
    3afa:	50 e0       	ldi	r21, 0x00	; 0
    3afc:	20 e0       	ldi	r18, 0x00	; 0
    3afe:	33 e1       	ldi	r19, 0x13	; 19
    3b00:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    3b04:	ec 96       	adiw	r28, 0x3c	; 60
    3b06:	0f b6       	in	r0, 0x3f	; 63
    3b08:	f8 94       	cli
    3b0a:	de bf       	out	0x3e, r29	; 62
    3b0c:	0f be       	out	0x3f, r0	; 63
    3b0e:	cd bf       	out	0x3d, r28	; 61
    3b10:	cf 91       	pop	r28
    3b12:	df 91       	pop	r29
    3b14:	1f 91       	pop	r17
    3b16:	0f 91       	pop	r16
    3b18:	ff 90       	pop	r15
    3b1a:	ef 90       	pop	r14
    3b1c:	df 90       	pop	r13
    3b1e:	08 95       	ret

00003b20 <procMessage21>:
       StrPosCopy(rcv_trans,AdvanZ.Message09.strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,AdvanZ.Message09.strFreeMessageLine4,99,20);
	 return Result;
}

char procMessage21(){
    3b20:	af 92       	push	r10
    3b22:	bf 92       	push	r11
    3b24:	cf 92       	push	r12
    3b26:	df 92       	push	r13
    3b28:	ef 92       	push	r14
    3b2a:	ff 92       	push	r15
    3b2c:	0f 93       	push	r16
    3b2e:	1f 93       	push	r17
    3b30:	df 93       	push	r29
    3b32:	cf 93       	push	r28
    3b34:	cd b7       	in	r28, 0x3d	; 61
    3b36:	de b7       	in	r29, 0x3e	; 62
    3b38:	2b 97       	sbiw	r28, 0x0b	; 11
    3b3a:	0f b6       	in	r0, 0x3f	; 63
    3b3c:	f8 94       	cli
    3b3e:	de bf       	out	0x3e, r29	; 62
    3b40:	0f be       	out	0x3f, r0	; 63
    3b42:	cd bf       	out	0x3d, r28	; 61
    3b44:	09 e0       	ldi	r16, 0x09	; 9
    3b46:	11 e0       	ldi	r17, 0x01	; 1
    3b48:	a8 ea       	ldi	r26, 0xA8	; 168
    3b4a:	ea 2e       	mov	r14, r26
    3b4c:	ac e0       	ldi	r26, 0x0C	; 12
    3b4e:	fa 2e       	mov	r15, r26
    3b50:	6e 01       	movw	r12, r28
    3b52:	08 94       	sec
    3b54:	c1 1c       	adc	r12, r1
    3b56:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3b58:	fb e0       	ldi	r31, 0x0B	; 11
    3b5a:	af 2e       	mov	r10, r31
    3b5c:	b1 2c       	mov	r11, r1
    3b5e:	ac 0e       	add	r10, r28
    3b60:	bd 1e       	adc	r11, r29
       StrPosCopy(rcv_trans,AdvanZ.Message09.strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,AdvanZ.Message09.strFreeMessageLine4,99,20);
	 return Result;
}

char procMessage21(){
    3b62:	f6 01       	movw	r30, r12
    3b64:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3b66:	8d 91       	ld	r24, X+
    3b68:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3b6a:	ea 15       	cp	r30, r10
    3b6c:	fb 05       	cpc	r31, r11
    3b6e:	d9 f7       	brne	.-10     	; 0x3b66 <procMessage21+0x46>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3b70:	1b 86       	std	Y+11, r1	; 0x0b
    3b72:	c8 01       	movw	r24, r16
    3b74:	b6 01       	movw	r22, r12
    3b76:	4b e0       	ldi	r20, 0x0B	; 11
    3b78:	50 e0       	ldi	r21, 0x00	; 0
    3b7a:	20 e0       	ldi	r18, 0x00	; 0
    3b7c:	33 e1       	ldi	r19, 0x13	; 19
    3b7e:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    3b82:	05 5f       	subi	r16, 0xF5	; 245
    3b84:	1f 4f       	sbci	r17, 0xFF	; 255
    3b86:	8a e0       	ldi	r24, 0x0A	; 10
    3b88:	90 e0       	ldi	r25, 0x00	; 0
    3b8a:	e8 0e       	add	r14, r24
    3b8c:	f9 1e       	adc	r15, r25
}

char procMessage21(){
     char i,Result,strBankName[11];
	 Result=0;
	 for(i=0;i<4;i++){
    3b8e:	91 e0       	ldi	r25, 0x01	; 1
    3b90:	05 33       	cpi	r16, 0x35	; 53
    3b92:	19 07       	cpc	r17, r25
    3b94:	31 f7       	brne	.-52     	; 0x3b62 <procMessage21+0x42>
         StrPosCopy(rcv_trans,strBankName,(37+(i*10)),10);
		 //Result=((Result<<1)|SaveToEEPROM(strBankName,DefBankName[i],11)); 
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}
    3b96:	80 e0       	ldi	r24, 0x00	; 0
    3b98:	2b 96       	adiw	r28, 0x0b	; 11
    3b9a:	0f b6       	in	r0, 0x3f	; 63
    3b9c:	f8 94       	cli
    3b9e:	de bf       	out	0x3e, r29	; 62
    3ba0:	0f be       	out	0x3f, r0	; 63
    3ba2:	cd bf       	out	0x3d, r28	; 61
    3ba4:	cf 91       	pop	r28
    3ba6:	df 91       	pop	r29
    3ba8:	1f 91       	pop	r17
    3baa:	0f 91       	pop	r16
    3bac:	ff 90       	pop	r15
    3bae:	ef 90       	pop	r14
    3bb0:	df 90       	pop	r13
    3bb2:	cf 90       	pop	r12
    3bb4:	bf 90       	pop	r11
    3bb6:	af 90       	pop	r10
    3bb8:	08 95       	ret

00003bba <GetFIPAddr>:
	    Result=PPumpID[FIPAddr-1];
	 }
   return Result;
}

char GetFIPAddr(char iPumpID){
    3bba:	ff 92       	push	r15
    3bbc:	0f 93       	push	r16
    3bbe:	1f 93       	push	r17
    3bc0:	df 93       	push	r29
    3bc2:	cf 93       	push	r28
    3bc4:	cd b7       	in	r28, 0x3d	; 61
    3bc6:	de b7       	in	r29, 0x3e	; 62
    3bc8:	28 97       	sbiw	r28, 0x08	; 8
    3bca:	0f b6       	in	r0, 0x3f	; 63
    3bcc:	f8 94       	cli
    3bce:	de bf       	out	0x3e, r29	; 62
    3bd0:	0f be       	out	0x3f, r0	; 63
    3bd2:	cd bf       	out	0x3d, r28	; 61
    3bd4:	f8 2e       	mov	r15, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3bd6:	8e 01       	movw	r16, r28
    3bd8:	0f 5f       	subi	r16, 0xFF	; 255
    3bda:	1f 4f       	sbci	r17, 0xFF	; 255
    3bdc:	c8 01       	movw	r24, r16
    3bde:	65 e4       	ldi	r22, 0x45	; 69
    3be0:	70 e0       	ldi	r23, 0x00	; 0
    3be2:	48 e0       	ldi	r20, 0x08	; 8
    3be4:	50 e0       	ldi	r21, 0x00	; 0
    3be6:	28 ef       	ldi	r18, 0xF8	; 248
    3be8:	32 e1       	ldi	r19, 0x12	; 18
    3bea:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
    3bee:	f8 01       	movw	r30, r16
char i,PPumpID[8],Result;     
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    3bf0:	9e 01       	movw	r18, r28
    3bf2:	27 5f       	subi	r18, 0xF7	; 247
    3bf4:	3f 4f       	sbci	r19, 0xFF	; 255
    3bf6:	9e 2f       	mov	r25, r30
    3bf8:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==iPumpID){
    3bfa:	80 81       	ld	r24, Z
    3bfc:	8f 15       	cp	r24, r15
    3bfe:	19 f4       	brne	.+6      	; 0x3c06 <GetFIPAddr+0x4c>
		     Result=i+1;
    3c00:	89 2f       	mov	r24, r25
    3c02:	8f 5f       	subi	r24, 0xFF	; 255
    3c04:	05 c0       	rjmp	.+10     	; 0x3c10 <GetFIPAddr+0x56>
			 break;
    3c06:	31 96       	adiw	r30, 0x01	; 1

char GetFIPAddr(char iPumpID){
char i,PPumpID[8],Result;     
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    3c08:	e2 17       	cp	r30, r18
    3c0a:	f3 07       	cpc	r31, r19
    3c0c:	a1 f7       	brne	.-24     	; 0x3bf6 <GetFIPAddr+0x3c>
    3c0e:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
   return Result;
}
    3c10:	28 96       	adiw	r28, 0x08	; 8
    3c12:	0f b6       	in	r0, 0x3f	; 63
    3c14:	f8 94       	cli
    3c16:	de bf       	out	0x3e, r29	; 62
    3c18:	0f be       	out	0x3f, r0	; 63
    3c1a:	cd bf       	out	0x3d, r28	; 61
    3c1c:	cf 91       	pop	r28
    3c1e:	df 91       	pop	r29
    3c20:	1f 91       	pop	r17
    3c22:	0f 91       	pop	r16
    3c24:	ff 90       	pop	r15
    3c26:	08 95       	ret

00003c28 <UpdateStandaloneStatus>:
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
         lcd_print(4,1,lcdteks);
     	 }
}

void UpdateStandaloneStatus(char xPumpID,char xPumpStatus){//xPumpID: (1-16)&0x0F
    3c28:	ff 92       	push	r15
    3c2a:	0f 93       	push	r16
    3c2c:	1f 93       	push	r17
    3c2e:	cf 93       	push	r28
    3c30:	df 93       	push	r29
    3c32:	28 2f       	mov	r18, r24
    3c34:	f6 2e       	mov	r15, r22
char strSend[20],iPumpID; //[xxxxxxxxxPx]
char iAddr;

	 if (xPumpID<16){
    3c36:	80 31       	cpi	r24, 0x10	; 16
    3c38:	08 f0       	brcs	.+2      	; 0x3c3c <UpdateStandaloneStatus+0x14>
    3c3a:	4e c0       	rjmp	.+156    	; 0x3cd8 <UpdateStandaloneStatus+0xb0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3c3c:	e1 99       	sbic	0x1c, 1	; 28
    3c3e:	fe cf       	rjmp	.-4      	; 0x3c3c <UpdateStandaloneStatus+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3c40:	87 e3       	ldi	r24, 0x37	; 55
    3c42:	91 e0       	ldi	r25, 0x01	; 1
    3c44:	9f bb       	out	0x1f, r25	; 31
    3c46:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3c48:	e0 9a       	sbi	0x1c, 0	; 28
    3c4a:	8d b3       	in	r24, 0x1d	; 29
	     DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    3c4c:	80 93 61 01 	sts	0x0161, r24
	     switch(DispenserBrand){
    3c50:	81 50       	subi	r24, 0x01	; 1
    3c52:	82 30       	cpi	r24, 0x02	; 2
    3c54:	08 f4       	brcc	.+2      	; 0x3c58 <UpdateStandaloneStatus+0x30>
    3c56:	82 2f       	mov	r24, r18
	     case ST_WAYNE_DART:
              iPumpID=xPumpID;
	          break;				   
	     }

		 iAddr=GetFIPAddr(iPumpID);
    3c58:	0e 94 dd 1d 	call	0x3bba	; 0x3bba <GetFIPAddr>
		 if (iAddr>0){
    3c5c:	88 23       	and	r24, r24
    3c5e:	e1 f1       	breq	.+120    	; 0x3cd8 <UpdateStandaloneStatus+0xb0>
		     iAddr=iAddr-1;
			 if (strPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY)){//iFdiiiiiiiiiiiii
    3c60:	81 50       	subi	r24, 0x01	; 1
    3c62:	c8 2f       	mov	r28, r24
    3c64:	d0 e0       	ldi	r29, 0x00	; 0
    3c66:	80 e1       	ldi	r24, 0x10	; 16
    3c68:	0e 94 95 13 	call	0x272a	; 0x272a <GetPumpStatusLabel>
    3c6c:	8e 01       	movw	r16, r28
    3c6e:	0e 5e       	subi	r16, 0xEE	; 238
    3c70:	1e 4f       	sbci	r17, 0xFE	; 254
    3c72:	f8 01       	movw	r30, r16
    3c74:	90 81       	ld	r25, Z
    3c76:	98 17       	cp	r25, r24
    3c78:	b1 f0       	breq	.+44     	; 0x3ca6 <UpdateStandaloneStatus+0x7e>
		         if (xPumpStatus!=PS_PRINT_READY)
    3c7a:	f0 e1       	ldi	r31, 0x10	; 16
    3c7c:	ff 16       	cp	r15, r31
    3c7e:	21 f0       	breq	.+8      	; 0x3c88 <UpdateStandaloneStatus+0x60>
				     CurrentPumpStatus[iAddr]=xPumpStatus;
    3c80:	fe 01       	movw	r30, r28
    3c82:	ee 59       	subi	r30, 0x9E	; 158
    3c84:	fe 4f       	sbci	r31, 0xFE	; 254
    3c86:	f0 82       	st	Z, r15
			     strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    3c88:	8f 2d       	mov	r24, r15
    3c8a:	0e 94 95 13 	call	0x272a	; 0x272a <GetPumpStatusLabel>
    3c8e:	8e 01       	movw	r16, r28
    3c90:	0e 5e       	subi	r16, 0xEE	; 238
    3c92:	1e 4f       	sbci	r17, 0xFE	; 254
    3c94:	f8 01       	movw	r30, r16
    3c96:	80 83       	st	Z, r24
                 if (xPumpStatus==PS_FINISH_TOTALIZER)
    3c98:	f5 e1       	ldi	r31, 0x15	; 21
    3c9a:	ff 16       	cp	r15, r31
    3c9c:	c1 f4       	brne	.+48     	; 0x3cce <UpdateStandaloneStatus+0xa6>
				     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    3c9e:	ce 59       	subi	r28, 0x9E	; 158
    3ca0:	de 4f       	sbci	r29, 0xFE	; 254
    3ca2:	88 81       	ld	r24, Y
    3ca4:	10 c0       	rjmp	.+32     	; 0x3cc6 <UpdateStandaloneStatus+0x9e>
    3ca6:	fe 01       	movw	r30, r28
    3ca8:	ee 59       	subi	r30, 0x9E	; 158
    3caa:	fe 4f       	sbci	r31, 0xFE	; 254
		     }else if ((strPumpStatus[iAddr]==GetPumpStatusLabel(PS_PRINT_READY))||(xPumpStatus==PUMP_FEOT)||(xPumpStatus==PS_PRINTED)||(xPumpStatus==PS_TOTALIZER)){//P
			     if (xPumpStatus==PS_PRINTED){
    3cac:	81 e1       	ldi	r24, 0x11	; 17
    3cae:	f8 16       	cp	r15, r24
    3cb0:	11 f4       	brne	.+4      	; 0x3cb6 <UpdateStandaloneStatus+0x8e>
				 //New

				     //if (CurrentPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY))
			             strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    3cb2:	80 81       	ld	r24, Z
    3cb4:	08 c0       	rjmp	.+16     	; 0x3cc6 <UpdateStandaloneStatus+0x9e>
					 //    CurrentPumpStatus[iAddr]=PUMP_OFF;
					 //    strPumpStatus[iAddr]=GetPumpStatusLabel(PUMP_OFF);
					 //}

				  }
			     else CurrentPumpStatus[iAddr]=xPumpStatus;			 
    3cb6:	f0 82       	st	Z, r15
			 if (xPumpStatus==PUMP_FEOT){
    3cb8:	8b e0       	ldi	r24, 0x0B	; 11
    3cba:	f8 16       	cp	r15, r24
    3cbc:	21 f0       	breq	.+8      	; 0x3cc6 <UpdateStandaloneStatus+0x9e>
			     CurrentPumpStatus[iAddr]=xPumpStatus;
			     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
				 }
             else if (xPumpStatus==PS_TOTALIZER){
    3cbe:	f4 e1       	ldi	r31, 0x14	; 20
    3cc0:	ff 16       	cp	r15, r31
    3cc2:	29 f4       	brne	.+10     	; 0x3cce <UpdateStandaloneStatus+0xa6>
			      strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    3cc4:	84 e1       	ldi	r24, 0x14	; 20
    3cc6:	0e 94 95 13 	call	0x272a	; 0x272a <GetPumpStatusLabel>
    3cca:	f8 01       	movw	r30, r16
    3ccc:	80 83       	st	Z, r24
				 }
		 }		 	     
         strPumpStatus[16]=0;
    3cce:	10 92 22 01 	sts	0x0122, r1
	     IsNewPumpStatus=True;		 
    3cd2:	81 e0       	ldi	r24, 0x01	; 1
    3cd4:	80 93 11 01 	sts	0x0111, r24
		 }		 
	 }
}
    3cd8:	df 91       	pop	r29
    3cda:	cf 91       	pop	r28
    3cdc:	1f 91       	pop	r17
    3cde:	0f 91       	pop	r16
    3ce0:	ff 90       	pop	r15
    3ce2:	08 95       	ret

00003ce4 <GetPumpID>:
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
}


char GetPumpID(char FIPAddr){//Find Stored PumpID in PumpMap
    3ce4:	1f 93       	push	r17
    3ce6:	df 93       	push	r29
    3ce8:	cf 93       	push	r28
    3cea:	cd b7       	in	r28, 0x3d	; 61
    3cec:	de b7       	in	r29, 0x3e	; 62
    3cee:	28 97       	sbiw	r28, 0x08	; 8
    3cf0:	0f b6       	in	r0, 0x3f	; 63
    3cf2:	f8 94       	cli
    3cf4:	de bf       	out	0x3e, r29	; 62
    3cf6:	0f be       	out	0x3f, r0	; 63
    3cf8:	cd bf       	out	0x3d, r28	; 61
    3cfa:	18 2f       	mov	r17, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3cfc:	ce 01       	movw	r24, r28
    3cfe:	01 96       	adiw	r24, 0x01	; 1
    3d00:	65 e4       	ldi	r22, 0x45	; 69
    3d02:	70 e0       	ldi	r23, 0x00	; 0
    3d04:	48 e0       	ldi	r20, 0x08	; 8
    3d06:	50 e0       	ldi	r21, 0x00	; 0
    3d08:	28 ef       	ldi	r18, 0xF8	; 248
    3d0a:	32 e1       	ldi	r19, 0x12	; 18
    3d0c:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
     char PPumpID[8],Result;     
     eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 Result=0;
	 if ((FIPAddr>0) && (FIPAddr<8)){
    3d10:	81 2f       	mov	r24, r17
    3d12:	81 50       	subi	r24, 0x01	; 1
    3d14:	87 30       	cpi	r24, 0x07	; 7
    3d16:	10 f0       	brcs	.+4      	; 0x3d1c <GetPumpID+0x38>
    3d18:	80 e0       	ldi	r24, 0x00	; 0
    3d1a:	04 c0       	rjmp	.+8      	; 0x3d24 <GetPumpID+0x40>
	    Result=PPumpID[FIPAddr-1];
    3d1c:	fe 01       	movw	r30, r28
    3d1e:	e1 0f       	add	r30, r17
    3d20:	f1 1d       	adc	r31, r1
    3d22:	80 81       	ld	r24, Z
	 }
   return Result;
}
    3d24:	28 96       	adiw	r28, 0x08	; 8
    3d26:	0f b6       	in	r0, 0x3f	; 63
    3d28:	f8 94       	cli
    3d2a:	de bf       	out	0x3e, r29	; 62
    3d2c:	0f be       	out	0x3f, r0	; 63
    3d2e:	cd bf       	out	0x3d, r28	; 61
    3d30:	cf 91       	pop	r28
    3d32:	df 91       	pop	r29
    3d34:	1f 91       	pop	r17
    3d36:	08 95       	ret

00003d38 <GetTotalizerData>:
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
}



void GetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "0000000"
    3d38:	0f 93       	push	r16
    3d3a:	1f 93       	push	r17
    3d3c:	df 93       	push	r29
    3d3e:	cf 93       	push	r28
    3d40:	00 d0       	rcall	.+0      	; 0x3d42 <GetTotalizerData+0xa>
    3d42:	00 d0       	rcall	.+0      	; 0x3d44 <GetTotalizerData+0xc>
    3d44:	00 d0       	rcall	.+0      	; 0x3d46 <GetTotalizerData+0xe>
    3d46:	cd b7       	in	r28, 0x3d	; 61
    3d48:	de b7       	in	r29, 0x3e	; 62
    3d4a:	96 2f       	mov	r25, r22
     char rawValue[6],iPumpAddr,iGrade;

	 iPumpAddr=(xPumpAddr&0x0F);
    3d4c:	4f 70       	andi	r20, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    3d4e:	21 50       	subi	r18, 0x01	; 1
    3d50:	26 30       	cpi	r18, 0x06	; 6
    3d52:	08 f4       	brcc	.+2      	; 0x3d56 <GetTotalizerData+0x1e>
    3d54:	52 2f       	mov	r21, r18
	     iGrade=xGradeAddr-1;
     
//TotalVolume[2][16][6][6];
//GetTotalizerData(TVOLUME,TOTALIZER_LAST,PumpNum,xGrade,strLastVolume);
	 if (TType==TVOLUME)eeprom_read_block((void*) &rawValue, (const void*) &(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    3d56:	88 23       	and	r24, r24
    3d58:	d9 f4       	brne	.+54     	; 0x3d90 <GetTotalizerData+0x58>
    3d5a:	64 e2       	ldi	r22, 0x24	; 36
    3d5c:	46 9f       	mul	r20, r22
    3d5e:	b0 01       	movw	r22, r0
    3d60:	11 24       	eor	r1, r1
    3d62:	29 2f       	mov	r18, r25
    3d64:	30 e0       	ldi	r19, 0x00	; 0
    3d66:	80 e2       	ldi	r24, 0x20	; 32
    3d68:	91 e0       	ldi	r25, 0x01	; 1
    3d6a:	fc 01       	movw	r30, r24
    3d6c:	2e 9f       	mul	r18, r30
    3d6e:	c0 01       	movw	r24, r0
    3d70:	2f 9f       	mul	r18, r31
    3d72:	90 0d       	add	r25, r0
    3d74:	3e 9f       	mul	r19, r30
    3d76:	90 0d       	add	r25, r0
    3d78:	11 24       	eor	r1, r1
    3d7a:	68 0f       	add	r22, r24
    3d7c:	79 1f       	adc	r23, r25
    3d7e:	86 e0       	ldi	r24, 0x06	; 6
    3d80:	58 9f       	mul	r21, r24
    3d82:	c0 01       	movw	r24, r0
    3d84:	11 24       	eor	r1, r1
    3d86:	68 0f       	add	r22, r24
    3d88:	79 1f       	adc	r23, r25
    3d8a:	6d 53       	subi	r22, 0x3D	; 61
    3d8c:	7c 4f       	sbci	r23, 0xFC	; 252
    3d8e:	1c c0       	rjmp	.+56     	; 0x3dc8 <GetTotalizerData+0x90>
	 else 
	 if (TType==TMONEY)eeprom_read_block((void*) &rawValue, (const void*) &(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    3d90:	81 30       	cpi	r24, 0x01	; 1
    3d92:	11 f5       	brne	.+68     	; 0x3dd8 <GetTotalizerData+0xa0>
    3d94:	64 e2       	ldi	r22, 0x24	; 36
    3d96:	46 9f       	mul	r20, r22
    3d98:	b0 01       	movw	r22, r0
    3d9a:	11 24       	eor	r1, r1
    3d9c:	29 2f       	mov	r18, r25
    3d9e:	30 e0       	ldi	r19, 0x00	; 0
    3da0:	80 e2       	ldi	r24, 0x20	; 32
    3da2:	91 e0       	ldi	r25, 0x01	; 1
    3da4:	fc 01       	movw	r30, r24
    3da6:	2e 9f       	mul	r18, r30
    3da8:	c0 01       	movw	r24, r0
    3daa:	2f 9f       	mul	r18, r31
    3dac:	90 0d       	add	r25, r0
    3dae:	3e 9f       	mul	r19, r30
    3db0:	90 0d       	add	r25, r0
    3db2:	11 24       	eor	r1, r1
    3db4:	68 0f       	add	r22, r24
    3db6:	79 1f       	adc	r23, r25
    3db8:	86 e0       	ldi	r24, 0x06	; 6
    3dba:	58 9f       	mul	r21, r24
    3dbc:	c0 01       	movw	r24, r0
    3dbe:	11 24       	eor	r1, r1
    3dc0:	68 0f       	add	r22, r24
    3dc2:	79 1f       	adc	r23, r25
    3dc4:	6d 5f       	subi	r22, 0xFD	; 253
    3dc6:	79 4f       	sbci	r23, 0xF9	; 249
    3dc8:	ce 01       	movw	r24, r28
    3dca:	01 96       	adiw	r24, 0x01	; 1
    3dcc:	46 e0       	ldi	r20, 0x06	; 6
    3dce:	50 e0       	ldi	r21, 0x00	; 0
    3dd0:	28 ef       	ldi	r18, 0xF8	; 248
    3dd2:	32 e1       	ldi	r19, 0x12	; 18
    3dd4:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
	 //Convert RawData to String 
	 RawToStr(rawValue,strValue);
    3dd8:	ce 01       	movw	r24, r28
    3dda:	01 96       	adiw	r24, 0x01	; 1
    3ddc:	b8 01       	movw	r22, r16
    3dde:	0e 94 ee 19 	call	0x33dc	; 0x33dc <RawToStr>
}
    3de2:	26 96       	adiw	r28, 0x06	; 6
    3de4:	0f b6       	in	r0, 0x3f	; 63
    3de6:	f8 94       	cli
    3de8:	de bf       	out	0x3e, r29	; 62
    3dea:	0f be       	out	0x3f, r0	; 63
    3dec:	cd bf       	out	0x3d, r28	; 61
    3dee:	cf 91       	pop	r28
    3df0:	df 91       	pop	r29
    3df2:	1f 91       	pop	r17
    3df4:	0f 91       	pop	r16
    3df6:	08 95       	ret

00003df8 <SaveToEEPROM>:
     return Result;
}



char SaveToEEPROM(char *Src,char *Dest,unsigned int Length){
    3df8:	ef 92       	push	r14
    3dfa:	ff 92       	push	r15
    3dfc:	0f 93       	push	r16
    3dfe:	1f 93       	push	r17
    3e00:	df 93       	push	r29
    3e02:	cf 93       	push	r28
    3e04:	cd b7       	in	r28, 0x3d	; 61
    3e06:	de b7       	in	r29, 0x3e	; 62
    3e08:	ac 97       	sbiw	r28, 0x2c	; 44
    3e0a:	0f b6       	in	r0, 0x3f	; 63
    3e0c:	f8 94       	cli
    3e0e:	de bf       	out	0x3e, r29	; 62
    3e10:	0f be       	out	0x3f, r0	; 63
    3e12:	cd bf       	out	0x3d, r28	; 61
    3e14:	9a a7       	std	Y+42, r25	; 0x2a
    3e16:	89 a7       	std	Y+41, r24	; 0x29
    3e18:	7c a7       	std	Y+44, r23	; 0x2c
    3e1a:	6b a7       	std	Y+43, r22	; 0x2b
    3e1c:	7a 01       	movw	r14, r20
    3e1e:	8e 01       	movw	r16, r28
    3e20:	05 5d       	subi	r16, 0xD5	; 213
    3e22:	1f 4f       	sbci	r17, 0xFF	; 255
    3e24:	c8 01       	movw	r24, r16
    3e26:	be 01       	movw	r22, r28
    3e28:	6f 5f       	subi	r22, 0xFF	; 255
    3e2a:	7f 4f       	sbci	r23, 0xFF	; 255
    3e2c:	28 ef       	ldi	r18, 0xF8	; 248
    3e2e:	32 e1       	ldi	r19, 0x12	; 18
    3e30:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    3e34:	c8 01       	movw	r24, r16
    3e36:	be 01       	movw	r22, r28
    3e38:	67 5d       	subi	r22, 0xD7	; 215
    3e3a:	7f 4f       	sbci	r23, 0xFF	; 255
    3e3c:	a7 01       	movw	r20, r14
    3e3e:	20 e0       	ldi	r18, 0x00	; 0
    3e40:	33 e1       	ldi	r19, 0x13	; 19
    3e42:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
     char strCompare[40];
	 //Read Previous Data
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}
    3e46:	ac 96       	adiw	r28, 0x2c	; 44
    3e48:	0f b6       	in	r0, 0x3f	; 63
    3e4a:	f8 94       	cli
    3e4c:	de bf       	out	0x3e, r29	; 62
    3e4e:	0f be       	out	0x3f, r0	; 63
    3e50:	cd bf       	out	0x3d, r28	; 61
    3e52:	cf 91       	pop	r28
    3e54:	df 91       	pop	r29
    3e56:	1f 91       	pop	r17
    3e58:	0f 91       	pop	r16
    3e5a:	ff 90       	pop	r15
    3e5c:	ef 90       	pop	r14
    3e5e:	08 95       	ret

00003e60 <SelectMark>:
	      break;
	 }
    return Result;
}

char SelectMark(char InMark){
    3e60:	df 92       	push	r13
    3e62:	ef 92       	push	r14
    3e64:	ff 92       	push	r15
    3e66:	0f 93       	push	r16
    3e68:	1f 93       	push	r17
    3e6a:	df 93       	push	r29
    3e6c:	cf 93       	push	r28
    3e6e:	00 d0       	rcall	.+0      	; 0x3e70 <SelectMark+0x10>
    3e70:	00 d0       	rcall	.+0      	; 0x3e72 <SelectMark+0x12>
    3e72:	0f 92       	push	r0
    3e74:	cd b7       	in	r28, 0x3d	; 61
    3e76:	de b7       	in	r29, 0x3e	; 62
    3e78:	d8 2e       	mov	r13, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3e7a:	8e 01       	movw	r16, r28
    3e7c:	0f 5f       	subi	r16, 0xFF	; 255
    3e7e:	1f 4f       	sbci	r17, 0xFF	; 255
    3e80:	c8 01       	movw	r24, r16
    3e82:	60 e4       	ldi	r22, 0x40	; 64
    3e84:	70 e0       	ldi	r23, 0x00	; 0
    3e86:	45 e0       	ldi	r20, 0x05	; 5
    3e88:	50 e0       	ldi	r21, 0x00	; 0
    3e8a:	28 ef       	ldi	r18, 0xF8	; 248
    3e8c:	32 e1       	ldi	r19, 0x12	; 18
    3e8e:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
    3e92:	ed 2d       	mov	r30, r13
    3e94:	21 e0       	ldi	r18, 0x01	; 1
    3e96:	30 e0       	ldi	r19, 0x00	; 0
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
    3e98:	78 01       	movw	r14, r16
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
    3e9a:	d8 01       	movw	r26, r16
    3e9c:	8c 91       	ld	r24, X
    3e9e:	d8 16       	cp	r13, r24
    3ea0:	49 f4       	brne	.+18     	; 0x3eb4 <SelectMark+0x54>
		     Result=PMark[(i+1)%Length];
    3ea2:	c9 01       	movw	r24, r18
    3ea4:	65 e0       	ldi	r22, 0x05	; 5
    3ea6:	70 e0       	ldi	r23, 0x00	; 0
    3ea8:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    3eac:	f7 01       	movw	r30, r14
    3eae:	e8 0f       	add	r30, r24
    3eb0:	f9 1f       	adc	r31, r25
    3eb2:	e0 81       	ld	r30, Z
    3eb4:	0f 5f       	subi	r16, 0xFF	; 255
    3eb6:	1f 4f       	sbci	r17, 0xFF	; 255
    3eb8:	2f 5f       	subi	r18, 0xFF	; 255
    3eba:	3f 4f       	sbci	r19, 0xFF	; 255
char SelectMark(char InMark){
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
    3ebc:	26 30       	cpi	r18, 0x06	; 6
    3ebe:	31 05       	cpc	r19, r1
    3ec0:	61 f7       	brne	.-40     	; 0x3e9a <SelectMark+0x3a>
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
	 }
     return Result;
}
    3ec2:	8e 2f       	mov	r24, r30
    3ec4:	0f 90       	pop	r0
    3ec6:	0f 90       	pop	r0
    3ec8:	0f 90       	pop	r0
    3eca:	0f 90       	pop	r0
    3ecc:	0f 90       	pop	r0
    3ece:	cf 91       	pop	r28
    3ed0:	df 91       	pop	r29
    3ed2:	1f 91       	pop	r17
    3ed4:	0f 91       	pop	r16
    3ed6:	ff 90       	pop	r15
    3ed8:	ef 90       	pop	r14
    3eda:	df 90       	pop	r13
    3edc:	08 95       	ret

00003ede <UpdateServerIP>:
	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
}
void UpdateServerIP(){     
    3ede:	cf 92       	push	r12
    3ee0:	df 92       	push	r13
    3ee2:	ef 92       	push	r14
    3ee4:	ff 92       	push	r15
    3ee6:	0f 93       	push	r16
    3ee8:	1f 93       	push	r17
    3eea:	df 93       	push	r29
    3eec:	cf 93       	push	r28
    3eee:	cd b7       	in	r28, 0x3d	; 61
    3ef0:	de b7       	in	r29, 0x3e	; 62
    3ef2:	64 97       	sbiw	r28, 0x14	; 20
    3ef4:	0f b6       	in	r0, 0x3f	; 63
    3ef6:	f8 94       	cli
    3ef8:	de bf       	out	0x3e, r29	; 62
    3efa:	0f be       	out	0x3f, r0	; 63
    3efc:	cd bf       	out	0x3d, r28	; 61
    3efe:	8e 01       	movw	r16, r28
    3f00:	0f 5f       	subi	r16, 0xFF	; 255
    3f02:	1f 4f       	sbci	r17, 0xFF	; 255
    3f04:	c8 01       	movw	r24, r16
    3f06:	6c e2       	ldi	r22, 0x2C	; 44
    3f08:	70 e0       	ldi	r23, 0x00	; 0
    3f0a:	44 e0       	ldi	r20, 0x04	; 4
    3f0c:	50 e0       	ldi	r21, 0x00	; 0
    3f0e:	28 ef       	ldi	r18, 0xF8	; 248
    3f10:	32 e1       	ldi	r19, 0x12	; 18
    3f12:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
    3f16:	78 01       	movw	r14, r16
    3f18:	8e 01       	movw	r16, r28
    3f1a:	0b 5f       	subi	r16, 0xFB	; 251
    3f1c:	1f 4f       	sbci	r17, 0xFF	; 255
	 char strIP[4][4];
	 //192.168.016.180
     eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);

	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
    3f1e:	68 01       	movw	r12, r16
    3f20:	d7 01       	movw	r26, r14
    3f22:	8d 91       	ld	r24, X+
    3f24:	7d 01       	movw	r14, r26
    3f26:	b8 01       	movw	r22, r16
    3f28:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <zeroIP>
    3f2c:	0c 5f       	subi	r16, 0xFC	; 252
    3f2e:	1f 4f       	sbci	r17, 0xFF	; 255
     char i,IP_blok[4];
	 char strIP[4][4];
	 //192.168.016.180
     eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);

	 for(i=0;i<4;i++){
    3f30:	ec 14       	cp	r14, r12
    3f32:	fd 04       	cpc	r15, r13
    3f34:	a9 f7       	brne	.-22     	; 0x3f20 <UpdateServerIP+0x42>
	     zeroIP(IP_blok[i],strIP[i]);
	 }
		 sprintf_P(strServerIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
    3f36:	ed b7       	in	r30, 0x3d	; 61
    3f38:	fe b7       	in	r31, 0x3e	; 62
    3f3a:	3c 97       	sbiw	r30, 0x0c	; 12
    3f3c:	0f b6       	in	r0, 0x3f	; 63
    3f3e:	f8 94       	cli
    3f40:	fe bf       	out	0x3e, r31	; 62
    3f42:	0f be       	out	0x3f, r0	; 63
    3f44:	ed bf       	out	0x3d, r30	; 61
    3f46:	31 96       	adiw	r30, 0x01	; 1
    3f48:	85 ed       	ldi	r24, 0xD5	; 213
    3f4a:	99 e0       	ldi	r25, 0x09	; 9
    3f4c:	ad b7       	in	r26, 0x3d	; 61
    3f4e:	be b7       	in	r27, 0x3e	; 62
    3f50:	12 96       	adiw	r26, 0x02	; 2
    3f52:	9c 93       	st	X, r25
    3f54:	8e 93       	st	-X, r24
    3f56:	11 97       	sbiw	r26, 0x01	; 1
    3f58:	83 e0       	ldi	r24, 0x03	; 3
    3f5a:	92 e2       	ldi	r25, 0x22	; 34
    3f5c:	93 83       	std	Z+3, r25	; 0x03
    3f5e:	82 83       	std	Z+2, r24	; 0x02
    3f60:	f5 82       	std	Z+5, r15	; 0x05
    3f62:	e4 82       	std	Z+4, r14	; 0x04
    3f64:	ce 01       	movw	r24, r28
    3f66:	09 96       	adiw	r24, 0x09	; 9
    3f68:	97 83       	std	Z+7, r25	; 0x07
    3f6a:	86 83       	std	Z+6, r24	; 0x06
    3f6c:	ce 01       	movw	r24, r28
    3f6e:	0d 96       	adiw	r24, 0x0d	; 13
    3f70:	91 87       	std	Z+9, r25	; 0x09
    3f72:	80 87       	std	Z+8, r24	; 0x08
    3f74:	ce 01       	movw	r24, r28
    3f76:	41 96       	adiw	r24, 0x11	; 17
    3f78:	93 87       	std	Z+11, r25	; 0x0b
    3f7a:	82 87       	std	Z+10, r24	; 0x0a
    3f7c:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    3f80:	ed b7       	in	r30, 0x3d	; 61
    3f82:	fe b7       	in	r31, 0x3e	; 62
    3f84:	3c 96       	adiw	r30, 0x0c	; 12
    3f86:	0f b6       	in	r0, 0x3f	; 63
    3f88:	f8 94       	cli
    3f8a:	fe bf       	out	0x3e, r31	; 62
    3f8c:	0f be       	out	0x3f, r0	; 63
    3f8e:	ed bf       	out	0x3d, r30	; 61
}
    3f90:	64 96       	adiw	r28, 0x14	; 20
    3f92:	0f b6       	in	r0, 0x3f	; 63
    3f94:	f8 94       	cli
    3f96:	de bf       	out	0x3e, r29	; 62
    3f98:	0f be       	out	0x3f, r0	; 63
    3f9a:	cd bf       	out	0x3d, r28	; 61
    3f9c:	cf 91       	pop	r28
    3f9e:	df 91       	pop	r29
    3fa0:	1f 91       	pop	r17
    3fa2:	0f 91       	pop	r16
    3fa4:	ff 90       	pop	r15
    3fa6:	ef 90       	pop	r14
    3fa8:	df 90       	pop	r13
    3faa:	cf 90       	pop	r12
    3fac:	08 95       	ret

00003fae <UpdateClientIP>:
	     str[0]=('0'+S);
	     str[1]=0;
	 }
}

void UpdateClientIP(){     
    3fae:	cf 92       	push	r12
    3fb0:	df 92       	push	r13
    3fb2:	ef 92       	push	r14
    3fb4:	ff 92       	push	r15
    3fb6:	0f 93       	push	r16
    3fb8:	1f 93       	push	r17
    3fba:	df 93       	push	r29
    3fbc:	cf 93       	push	r28
    3fbe:	cd b7       	in	r28, 0x3d	; 61
    3fc0:	de b7       	in	r29, 0x3e	; 62
    3fc2:	68 97       	sbiw	r28, 0x18	; 24
    3fc4:	0f b6       	in	r0, 0x3f	; 63
    3fc6:	f8 94       	cli
    3fc8:	de bf       	out	0x3e, r29	; 62
    3fca:	0f be       	out	0x3f, r0	; 63
    3fcc:	cd bf       	out	0x3d, r28	; 61
    3fce:	8e 01       	movw	r16, r28
    3fd0:	0f 5f       	subi	r16, 0xFF	; 255
    3fd2:	1f 4f       	sbci	r17, 0xFF	; 255
    3fd4:	c8 01       	movw	r24, r16
    3fd6:	68 e2       	ldi	r22, 0x28	; 40
    3fd8:	70 e0       	ldi	r23, 0x00	; 0
    3fda:	44 e0       	ldi	r20, 0x04	; 4
    3fdc:	50 e0       	ldi	r21, 0x00	; 0
    3fde:	28 ef       	ldi	r18, 0xF8	; 248
    3fe0:	32 e1       	ldi	r19, 0x12	; 18
    3fe2:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
    3fe6:	78 01       	movw	r14, r16
    3fe8:	8e 01       	movw	r16, r28
    3fea:	0b 5f       	subi	r16, 0xFB	; 251
    3fec:	1f 4f       	sbci	r17, 0xFF	; 255
	 char strIP[4][5];
	 //192.168.010.002
     eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);

	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
    3fee:	68 01       	movw	r12, r16
    3ff0:	d7 01       	movw	r26, r14
    3ff2:	8d 91       	ld	r24, X+
    3ff4:	7d 01       	movw	r14, r26
    3ff6:	b8 01       	movw	r22, r16
    3ff8:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <zeroIP>
    3ffc:	0b 5f       	subi	r16, 0xFB	; 251
    3ffe:	1f 4f       	sbci	r17, 0xFF	; 255
     char i,IP_blok[4];
	 char strIP[4][5];
	 //192.168.010.002
     eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);

	 for(i=0;i<4;i++){
    4000:	ec 14       	cp	r14, r12
    4002:	fd 04       	cpc	r15, r13
    4004:	a9 f7       	brne	.-22     	; 0x3ff0 <UpdateClientIP+0x42>
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
    4006:	ed b7       	in	r30, 0x3d	; 61
    4008:	fe b7       	in	r31, 0x3e	; 62
    400a:	3c 97       	sbiw	r30, 0x0c	; 12
    400c:	0f b6       	in	r0, 0x3f	; 63
    400e:	f8 94       	cli
    4010:	fe bf       	out	0x3e, r31	; 62
    4012:	0f be       	out	0x3f, r0	; 63
    4014:	ed bf       	out	0x3d, r30	; 61
    4016:	31 96       	adiw	r30, 0x01	; 1
    4018:	88 ea       	ldi	r24, 0xA8	; 168
    401a:	99 e0       	ldi	r25, 0x09	; 9
    401c:	ad b7       	in	r26, 0x3d	; 61
    401e:	be b7       	in	r27, 0x3e	; 62
    4020:	12 96       	adiw	r26, 0x02	; 2
    4022:	9c 93       	st	X, r25
    4024:	8e 93       	st	-X, r24
    4026:	11 97       	sbiw	r26, 0x01	; 1
    4028:	8f e0       	ldi	r24, 0x0F	; 15
    402a:	92 e2       	ldi	r25, 0x22	; 34
    402c:	93 83       	std	Z+3, r25	; 0x03
    402e:	82 83       	std	Z+2, r24	; 0x02
    4030:	f5 82       	std	Z+5, r15	; 0x05
    4032:	e4 82       	std	Z+4, r14	; 0x04
    4034:	ce 01       	movw	r24, r28
    4036:	0a 96       	adiw	r24, 0x0a	; 10
    4038:	97 83       	std	Z+7, r25	; 0x07
    403a:	86 83       	std	Z+6, r24	; 0x06
    403c:	ce 01       	movw	r24, r28
    403e:	0f 96       	adiw	r24, 0x0f	; 15
    4040:	91 87       	std	Z+9, r25	; 0x09
    4042:	80 87       	std	Z+8, r24	; 0x08
    4044:	ce 01       	movw	r24, r28
    4046:	44 96       	adiw	r24, 0x14	; 20
    4048:	93 87       	std	Z+11, r25	; 0x0b
    404a:	82 87       	std	Z+10, r24	; 0x0a
    404c:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    4050:	ed b7       	in	r30, 0x3d	; 61
    4052:	fe b7       	in	r31, 0x3e	; 62
    4054:	3c 96       	adiw	r30, 0x0c	; 12
    4056:	0f b6       	in	r0, 0x3f	; 63
    4058:	f8 94       	cli
    405a:	fe bf       	out	0x3e, r31	; 62
    405c:	0f be       	out	0x3f, r0	; 63
    405e:	ed bf       	out	0x3d, r30	; 61
}
    4060:	68 96       	adiw	r28, 0x18	; 24
    4062:	0f b6       	in	r0, 0x3f	; 63
    4064:	f8 94       	cli
    4066:	de bf       	out	0x3e, r29	; 62
    4068:	0f be       	out	0x3f, r0	; 63
    406a:	cd bf       	out	0x3d, r28	; 61
    406c:	cf 91       	pop	r28
    406e:	df 91       	pop	r29
    4070:	1f 91       	pop	r17
    4072:	0f 91       	pop	r16
    4074:	ff 90       	pop	r15
    4076:	ef 90       	pop	r14
    4078:	df 90       	pop	r13
    407a:	cf 90       	pop	r12
    407c:	08 95       	ret

0000407e <GenerateStandaloneTransData>:

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}


char GenerateStandaloneTransData(char xPumpID, char *PNozzle){//[1,2,3..16]->[1,2,3..0]
    407e:	cf 92       	push	r12
    4080:	df 92       	push	r13
    4082:	ef 92       	push	r14
    4084:	ff 92       	push	r15
    4086:	0f 93       	push	r16
    4088:	1f 93       	push	r17
    408a:	df 93       	push	r29
    408c:	cf 93       	push	r28
    408e:	cd b7       	in	r28, 0x3d	; 61
    4090:	de b7       	in	r29, 0x3e	; 62
    4092:	2f 97       	sbiw	r28, 0x0f	; 15
    4094:	0f b6       	in	r0, 0x3f	; 63
    4096:	f8 94       	cli
    4098:	de bf       	out	0x3e, r29	; 62
    409a:	0f be       	out	0x3f, r0	; 63
    409c:	cd bf       	out	0x3d, r28	; 61
    409e:	e8 2e       	mov	r14, r24
    40a0:	8b 01       	movw	r16, r22
     char Result=GS_NONE;
	 char strSend[30];
	 char FIPAddr;

	 iPumpID=(xPumpID&0x0F);
	 FIPAddr=GetFIPAddr(iPumpID);
    40a2:	8f 70       	andi	r24, 0x0F	; 15
    40a4:	0e 94 dd 1d 	call	0x3bba	; 0x3bba <GetFIPAddr>
     if (FIPAddr>0){
    40a8:	88 23       	and	r24, r24
    40aa:	09 f4       	brne	.+2      	; 0x40ae <GenerateStandaloneTransData+0x30>
    40ac:	2d c1       	rjmp	.+602    	; 0x4308 <GenerateStandaloneTransData+0x28a>
	     FIPAddr=FIPAddr-1;
		 iProdID=PNozzle[RecPumpData[FIPAddr].Grade];
    40ae:	81 50       	subi	r24, 0x01	; 1
    40b0:	c8 2e       	mov	r12, r24
    40b2:	dd 24       	eor	r13, r13
    40b4:	85 e3       	ldi	r24, 0x35	; 53
    40b6:	90 e0       	ldi	r25, 0x00	; 0
    40b8:	c8 9e       	mul	r12, r24
    40ba:	f0 01       	movw	r30, r0
    40bc:	c9 9e       	mul	r12, r25
    40be:	f0 0d       	add	r31, r0
    40c0:	d8 9e       	mul	r13, r24
    40c2:	f0 0d       	add	r31, r0
    40c4:	11 24       	eor	r1, r1
    40c6:	e5 57       	subi	r30, 0x75	; 117
    40c8:	f8 4f       	sbci	r31, 0xF8	; 248
    40ca:	80 81       	ld	r24, Z
    40cc:	08 0f       	add	r16, r24
    40ce:	11 1d       	adc	r17, r1
    40d0:	d8 01       	movw	r26, r16
    40d2:	2c 91       	ld	r18, X
    40d4:	ce 01       	movw	r24, r28
    40d6:	01 96       	adiw	r24, 0x01	; 1

		 if (iProdID>0) eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[iProdID-1],sizeof(DefProductName[iProdID-1]));
    40d8:	22 23       	and	r18, r18
    40da:	69 f0       	breq	.+26     	; 0x40f6 <GenerateStandaloneTransData+0x78>
    40dc:	6d e0       	ldi	r22, 0x0D	; 13
    40de:	26 9f       	mul	r18, r22
    40e0:	b0 01       	movw	r22, r0
    40e2:	11 24       	eor	r1, r1
    40e4:	62 55       	subi	r22, 0x52	; 82
    40e6:	7f 4f       	sbci	r23, 0xFF	; 255
    40e8:	4d e0       	ldi	r20, 0x0D	; 13
    40ea:	50 e0       	ldi	r21, 0x00	; 0
    40ec:	28 ef       	ldi	r18, 0xF8	; 248
    40ee:	32 e1       	ldi	r19, 0x12	; 18
    40f0:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
    40f4:	10 c0       	rjmp	.+32     	; 0x4116 <GenerateStandaloneTransData+0x98>
		 else sprintf_P(ProductName,PSTR("N/A"));
    40f6:	00 d0       	rcall	.+0      	; 0x40f8 <GenerateStandaloneTransData+0x7a>
    40f8:	00 d0       	rcall	.+0      	; 0x40fa <GenerateStandaloneTransData+0x7c>
    40fa:	ed b7       	in	r30, 0x3d	; 61
    40fc:	fe b7       	in	r31, 0x3e	; 62
    40fe:	92 83       	std	Z+2, r25	; 0x02
    4100:	81 83       	std	Z+1, r24	; 0x01
    4102:	82 ec       	ldi	r24, 0xC2	; 194
    4104:	92 e2       	ldi	r25, 0x22	; 34
    4106:	94 83       	std	Z+4, r25	; 0x04
    4108:	83 83       	std	Z+3, r24	; 0x03
    410a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    410e:	0f 90       	pop	r0
    4110:	0f 90       	pop	r0
    4112:	0f 90       	pop	r0
    4114:	0f 90       	pop	r0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    4116:	e1 99       	sbic	0x1c, 1	; 28
    4118:	fe cf       	rjmp	.-4      	; 0x4116 <GenerateStandaloneTransData+0x98>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    411a:	80 e0       	ldi	r24, 0x00	; 0
    411c:	90 e0       	ldi	r25, 0x00	; 0
    411e:	9f bb       	out	0x1f, r25	; 31
    4120:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    4122:	e0 9a       	sbi	0x1c, 0	; 28
    4124:	fd b2       	in	r15, 0x1d	; 29

		 TermID=eeprom_read_byte(&DefIFT_ID);

		 //Shift,TransNum,Date,Time
		 sprintf_P(strShift,PSTR("%d"),RecPumpData[FIPAddr].Shift);
    4126:	00 d0       	rcall	.+0      	; 0x4128 <GenerateStandaloneTransData+0xaa>
    4128:	00 d0       	rcall	.+0      	; 0x412a <GenerateStandaloneTransData+0xac>
    412a:	00 d0       	rcall	.+0      	; 0x412c <GenerateStandaloneTransData+0xae>
    412c:	ad b7       	in	r26, 0x3d	; 61
    412e:	be b7       	in	r27, 0x3e	; 62
    4130:	11 96       	adiw	r26, 0x01	; 1
    4132:	8b eb       	ldi	r24, 0xBB	; 187
    4134:	9f e0       	ldi	r25, 0x0F	; 15
    4136:	ed b7       	in	r30, 0x3d	; 61
    4138:	fe b7       	in	r31, 0x3e	; 62
    413a:	92 83       	std	Z+2, r25	; 0x02
    413c:	81 83       	std	Z+1, r24	; 0x01
    413e:	8f eb       	ldi	r24, 0xBF	; 191
    4140:	92 e2       	ldi	r25, 0x22	; 34
    4142:	13 96       	adiw	r26, 0x03	; 3
    4144:	9c 93       	st	X, r25
    4146:	8e 93       	st	-X, r24
    4148:	12 97       	sbiw	r26, 0x02	; 2
    414a:	85 e3       	ldi	r24, 0x35	; 53
    414c:	90 e0       	ldi	r25, 0x00	; 0
    414e:	c8 9e       	mul	r12, r24
    4150:	80 01       	movw	r16, r0
    4152:	c9 9e       	mul	r12, r25
    4154:	10 0d       	add	r17, r0
    4156:	d8 9e       	mul	r13, r24
    4158:	10 0d       	add	r17, r0
    415a:	11 24       	eor	r1, r1
    415c:	f8 01       	movw	r30, r16
    415e:	e5 57       	subi	r30, 0x75	; 117
    4160:	f8 4f       	sbci	r31, 0xF8	; 248
    4162:	82 81       	ldd	r24, Z+2	; 0x02
    4164:	14 96       	adiw	r26, 0x04	; 4
    4166:	8c 93       	st	X, r24
    4168:	14 97       	sbiw	r26, 0x04	; 4
    416a:	15 96       	adiw	r26, 0x05	; 5
    416c:	1c 92       	st	X, r1
    416e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		 sprintf_P(strTranNo,PSTR("%s"),RecPumpData[FIPAddr].strTransNum);
    4172:	ed b7       	in	r30, 0x3d	; 61
    4174:	fe b7       	in	r31, 0x3e	; 62
    4176:	31 96       	adiw	r30, 0x01	; 1
    4178:	89 ed       	ldi	r24, 0xD9	; 217
    417a:	9f e0       	ldi	r25, 0x0F	; 15
    417c:	ad b7       	in	r26, 0x3d	; 61
    417e:	be b7       	in	r27, 0x3e	; 62
    4180:	12 96       	adiw	r26, 0x02	; 2
    4182:	9c 93       	st	X, r25
    4184:	8e 93       	st	-X, r24
    4186:	11 97       	sbiw	r26, 0x01	; 1
    4188:	8c eb       	ldi	r24, 0xBC	; 188
    418a:	92 e2       	ldi	r25, 0x22	; 34
    418c:	93 83       	std	Z+3, r25	; 0x03
    418e:	82 83       	std	Z+2, r24	; 0x02
    4190:	c8 01       	movw	r24, r16
    4192:	82 57       	subi	r24, 0x72	; 114
    4194:	98 4f       	sbci	r25, 0xF8	; 248
    4196:	95 83       	std	Z+5, r25	; 0x05
    4198:	84 83       	std	Z+4, r24	; 0x04
    419a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	     sprintf_P(strDate,PSTR("%s"),RecPumpData[FIPAddr].strTransDate);
    419e:	ed b7       	in	r30, 0x3d	; 61
    41a0:	fe b7       	in	r31, 0x3e	; 62
    41a2:	31 96       	adiw	r30, 0x01	; 1
    41a4:	81 e5       	ldi	r24, 0x51	; 81
    41a6:	99 e0       	ldi	r25, 0x09	; 9
    41a8:	ad b7       	in	r26, 0x3d	; 61
    41aa:	be b7       	in	r27, 0x3e	; 62
    41ac:	12 96       	adiw	r26, 0x02	; 2
    41ae:	9c 93       	st	X, r25
    41b0:	8e 93       	st	-X, r24
    41b2:	11 97       	sbiw	r26, 0x01	; 1
    41b4:	89 eb       	ldi	r24, 0xB9	; 185
    41b6:	92 e2       	ldi	r25, 0x22	; 34
    41b8:	93 83       	std	Z+3, r25	; 0x03
    41ba:	82 83       	std	Z+2, r24	; 0x02
    41bc:	c8 01       	movw	r24, r16
    41be:	8b 56       	subi	r24, 0x6B	; 107
    41c0:	98 4f       	sbci	r25, 0xF8	; 248
    41c2:	95 83       	std	Z+5, r25	; 0x05
    41c4:	84 83       	std	Z+4, r24	; 0x04
    41c6:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		 sprintf_P(strTime,PSTR("%s"),RecPumpData[FIPAddr].strTransTime);	 
    41ca:	ed b7       	in	r30, 0x3d	; 61
    41cc:	fe b7       	in	r31, 0x3e	; 62
    41ce:	31 96       	adiw	r30, 0x01	; 1
    41d0:	8d e2       	ldi	r24, 0x2D	; 45
    41d2:	95 e0       	ldi	r25, 0x05	; 5
    41d4:	ad b7       	in	r26, 0x3d	; 61
    41d6:	be b7       	in	r27, 0x3e	; 62
    41d8:	12 96       	adiw	r26, 0x02	; 2
    41da:	9c 93       	st	X, r25
    41dc:	8e 93       	st	-X, r24
    41de:	11 97       	sbiw	r26, 0x01	; 1
    41e0:	86 eb       	ldi	r24, 0xB6	; 182
    41e2:	92 e2       	ldi	r25, 0x22	; 34
    41e4:	93 83       	std	Z+3, r25	; 0x03
    41e6:	82 83       	std	Z+2, r24	; 0x02
    41e8:	c8 01       	movw	r24, r16
    41ea:	82 56       	subi	r24, 0x62	; 98
    41ec:	98 4f       	sbci	r25, 0xF8	; 248
    41ee:	95 83       	std	Z+5, r25	; 0x05
    41f0:	84 83       	std	Z+4, r24	; 0x04
    41f2:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>

	     //TermID,FIP_ID,Product
		 sprintf_P(strIslandID,PSTR("%d"),TermID);
    41f6:	ed b7       	in	r30, 0x3d	; 61
    41f8:	fe b7       	in	r31, 0x3e	; 62
    41fa:	31 96       	adiw	r30, 0x01	; 1
    41fc:	8d e5       	ldi	r24, 0x5D	; 93
    41fe:	9c e0       	ldi	r25, 0x0C	; 12
    4200:	ad b7       	in	r26, 0x3d	; 61
    4202:	be b7       	in	r27, 0x3e	; 62
    4204:	12 96       	adiw	r26, 0x02	; 2
    4206:	9c 93       	st	X, r25
    4208:	8e 93       	st	-X, r24
    420a:	11 97       	sbiw	r26, 0x01	; 1
    420c:	83 eb       	ldi	r24, 0xB3	; 179
    420e:	92 e2       	ldi	r25, 0x22	; 34
    4210:	93 83       	std	Z+3, r25	; 0x03
    4212:	82 83       	std	Z+2, r24	; 0x02
    4214:	f4 82       	std	Z+4, r15	; 0x04
    4216:	15 82       	std	Z+5, r1	; 0x05
    4218:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		 sprintf_P(strFIP_ID,PSTR("%.2d"),xPumpID);
    421c:	ed b7       	in	r30, 0x3d	; 61
    421e:	fe b7       	in	r31, 0x3e	; 62
    4220:	31 96       	adiw	r30, 0x01	; 1
    4222:	86 e8       	ldi	r24, 0x86	; 134
    4224:	99 e0       	ldi	r25, 0x09	; 9
    4226:	ad b7       	in	r26, 0x3d	; 61
    4228:	be b7       	in	r27, 0x3e	; 62
    422a:	12 96       	adiw	r26, 0x02	; 2
    422c:	9c 93       	st	X, r25
    422e:	8e 93       	st	-X, r24
    4230:	11 97       	sbiw	r26, 0x01	; 1
    4232:	8e ea       	ldi	r24, 0xAE	; 174
    4234:	92 e2       	ldi	r25, 0x22	; 34
    4236:	93 83       	std	Z+3, r25	; 0x03
    4238:	82 83       	std	Z+2, r24	; 0x02
    423a:	e4 82       	std	Z+4, r14	; 0x04
    423c:	15 82       	std	Z+5, r1	; 0x05
    423e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	     sprintf_P(strDescription,PSTR("%s"),ProductName);
    4242:	ed b7       	in	r30, 0x3d	; 61
    4244:	fe b7       	in	r31, 0x3e	; 62
    4246:	31 96       	adiw	r30, 0x01	; 1
    4248:	8b ec       	ldi	r24, 0xCB	; 203
    424a:	9b e0       	ldi	r25, 0x0B	; 11
    424c:	ad b7       	in	r26, 0x3d	; 61
    424e:	be b7       	in	r27, 0x3e	; 62
    4250:	12 96       	adiw	r26, 0x02	; 2
    4252:	9c 93       	st	X, r25
    4254:	8e 93       	st	-X, r24
    4256:	11 97       	sbiw	r26, 0x01	; 1
    4258:	8b ea       	ldi	r24, 0xAB	; 171
    425a:	92 e2       	ldi	r25, 0x22	; 34
    425c:	93 83       	std	Z+3, r25	; 0x03
    425e:	82 83       	std	Z+2, r24	; 0x02
    4260:	ce 01       	movw	r24, r28
    4262:	01 96       	adiw	r24, 0x01	; 1
    4264:	95 83       	std	Z+5, r25	; 0x05
    4266:	84 83       	std	Z+4, r24	; 0x04
    4268:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>

		 //Price Volume Money
		 sprintf_P(strPrice,PSTR("%s"),RecPumpData[FIPAddr].Price);
    426c:	ed b7       	in	r30, 0x3d	; 61
    426e:	fe b7       	in	r31, 0x3e	; 62
    4270:	31 96       	adiw	r30, 0x01	; 1
    4272:	81 e8       	ldi	r24, 0x81	; 129
    4274:	97 e0       	ldi	r25, 0x07	; 7
    4276:	ad b7       	in	r26, 0x3d	; 61
    4278:	be b7       	in	r27, 0x3e	; 62
    427a:	12 96       	adiw	r26, 0x02	; 2
    427c:	9c 93       	st	X, r25
    427e:	8e 93       	st	-X, r24
    4280:	11 97       	sbiw	r26, 0x01	; 1
    4282:	88 ea       	ldi	r24, 0xA8	; 168
    4284:	92 e2       	ldi	r25, 0x22	; 34
    4286:	93 83       	std	Z+3, r25	; 0x03
    4288:	82 83       	std	Z+2, r24	; 0x02
    428a:	c8 01       	movw	r24, r16
    428c:	89 55       	subi	r24, 0x59	; 89
    428e:	98 4f       	sbci	r25, 0xF8	; 248
    4290:	95 83       	std	Z+5, r25	; 0x05
    4292:	84 83       	std	Z+4, r24	; 0x04
    4294:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	     sprintf_P(strVolume,PSTR("%s"),RecPumpData[FIPAddr].Volume);
    4298:	ed b7       	in	r30, 0x3d	; 61
    429a:	fe b7       	in	r31, 0x3e	; 62
    429c:	31 96       	adiw	r30, 0x01	; 1
    429e:	85 e5       	ldi	r24, 0x55	; 85
    42a0:	95 e0       	ldi	r25, 0x05	; 5
    42a2:	ad b7       	in	r26, 0x3d	; 61
    42a4:	be b7       	in	r27, 0x3e	; 62
    42a6:	12 96       	adiw	r26, 0x02	; 2
    42a8:	9c 93       	st	X, r25
    42aa:	8e 93       	st	-X, r24
    42ac:	11 97       	sbiw	r26, 0x01	; 1
    42ae:	85 ea       	ldi	r24, 0xA5	; 165
    42b0:	92 e2       	ldi	r25, 0x22	; 34
    42b2:	93 83       	std	Z+3, r25	; 0x03
    42b4:	82 83       	std	Z+2, r24	; 0x02
    42b6:	c8 01       	movw	r24, r16
    42b8:	82 55       	subi	r24, 0x52	; 82
    42ba:	98 4f       	sbci	r25, 0xF8	; 248
    42bc:	95 83       	std	Z+5, r25	; 0x05
    42be:	84 83       	std	Z+4, r24	; 0x04
    42c0:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		 sprintf_P(strAmount,PSTR("%s"),RecPumpData[FIPAddr].Money);
    42c4:	ed b7       	in	r30, 0x3d	; 61
    42c6:	fe b7       	in	r31, 0x3e	; 62
    42c8:	31 96       	adiw	r30, 0x01	; 1
    42ca:	89 e1       	ldi	r24, 0x19	; 25
    42cc:	9f e0       	ldi	r25, 0x0F	; 15
    42ce:	ad b7       	in	r26, 0x3d	; 61
    42d0:	be b7       	in	r27, 0x3e	; 62
    42d2:	12 96       	adiw	r26, 0x02	; 2
    42d4:	9c 93       	st	X, r25
    42d6:	8e 93       	st	-X, r24
    42d8:	11 97       	sbiw	r26, 0x01	; 1
    42da:	82 ea       	ldi	r24, 0xA2	; 162
    42dc:	92 e2       	ldi	r25, 0x22	; 34
    42de:	93 83       	std	Z+3, r25	; 0x03
    42e0:	82 83       	std	Z+2, r24	; 0x02
    42e2:	09 54       	subi	r16, 0x49	; 73
    42e4:	18 4f       	sbci	r17, 0xF8	; 248
    42e6:	15 83       	std	Z+5, r17	; 0x05
    42e8:	04 83       	std	Z+4, r16	; 0x04
    42ea:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>

		 MOPType=MOP_CASH;
    42ee:	10 92 cf 01 	sts	0x01CF, r1
	     IsPrinting=True;	 
    42f2:	81 e0       	ldi	r24, 0x01	; 1
    42f4:	80 93 c3 01 	sts	0x01C3, r24
    42f8:	ed b7       	in	r30, 0x3d	; 61
    42fa:	fe b7       	in	r31, 0x3e	; 62
    42fc:	36 96       	adiw	r30, 0x06	; 6
    42fe:	0f b6       	in	r0, 0x3f	; 63
    4300:	f8 94       	cli
    4302:	fe bf       	out	0x3e, r31	; 62
    4304:	0f be       	out	0x3f, r0	; 63
    4306:	ed bf       	out	0x3d, r30	; 61
	 }
	 //ProductName	 
	 //iProdID=PNozzle[RecPumpData[iPumpID].Nozzle];
	 //BAsedOnGrade
   return Result;
}
    4308:	2f 96       	adiw	r28, 0x0f	; 15
    430a:	0f b6       	in	r0, 0x3f	; 63
    430c:	f8 94       	cli
    430e:	de bf       	out	0x3e, r29	; 62
    4310:	0f be       	out	0x3f, r0	; 63
    4312:	cd bf       	out	0x3d, r28	; 61
    4314:	cf 91       	pop	r28
    4316:	df 91       	pop	r29
    4318:	1f 91       	pop	r17
    431a:	0f 91       	pop	r16
    431c:	ff 90       	pop	r15
    431e:	ef 90       	pop	r14
    4320:	df 90       	pop	r13
    4322:	cf 90       	pop	r12
    4324:	08 95       	ret

00004326 <PrintStandalone>:
     char Result=PS_NONE;

   return Result;
}

char PrintStandalone(char FIPAddr,char IsReprint){
    4326:	ef 92       	push	r14
    4328:	ff 92       	push	r15
    432a:	0f 93       	push	r16
    432c:	1f 93       	push	r17
    432e:	df 93       	push	r29
    4330:	cf 93       	push	r28
    4332:	00 d0       	rcall	.+0      	; 0x4334 <PrintStandalone+0xe>
    4334:	00 d0       	rcall	.+0      	; 0x4336 <PrintStandalone+0x10>
    4336:	00 d0       	rcall	.+0      	; 0x4338 <PrintStandalone+0x12>
    4338:	cd b7       	in	r28, 0x3d	; 61
    433a:	de b7       	in	r29, 0x3e	; 62
    433c:	f8 2e       	mov	r15, r24
    433e:	06 2f       	mov	r16, r22
	 char LFIPAddr;
	      
	 Result=PS_NO_DATA;

//	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
	 iPumpID=GetPumpID(FIPAddr);//PPumpID[FIPAddr-1];
    4340:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <GetPumpID>
    4344:	e8 2e       	mov	r14, r24
     LFIPAddr=GetFIPAddr(iPumpID);
    4346:	0e 94 dd 1d 	call	0x3bba	; 0x3bba <GetFIPAddr>
    434a:	18 2f       	mov	r17, r24

     if (LFIPAddr>0){
    434c:	88 23       	and	r24, r24
    434e:	99 f1       	breq	.+102    	; 0x43b6 <PrintStandalone+0x90>
	     LFIPAddr=LFIPAddr-1;
	     if ((IsReprint==True)||(iPumpID>0)&&(strPumpStatus[LFIPAddr]==GetPumpStatusLabel(PS_PRINT_READY))){    	 
    4350:	01 30       	cpi	r16, 0x01	; 1
    4352:	69 f0       	breq	.+26     	; 0x436e <PrintStandalone+0x48>
    4354:	ee 20       	and	r14, r14
    4356:	79 f1       	breq	.+94     	; 0x43b6 <PrintStandalone+0x90>
    4358:	80 e1       	ldi	r24, 0x10	; 16
    435a:	0e 94 95 13 	call	0x272a	; 0x272a <GetPumpStatusLabel>
    435e:	11 50       	subi	r17, 0x01	; 1
    4360:	e1 2f       	mov	r30, r17
    4362:	f0 e0       	ldi	r31, 0x00	; 0
    4364:	ee 5e       	subi	r30, 0xEE	; 238
    4366:	fe 4f       	sbci	r31, 0xFE	; 254
    4368:	90 81       	ld	r25, Z
    436a:	98 17       	cp	r25, r24
    436c:	21 f5       	brne	.+72     	; 0x43b6 <PrintStandalone+0x90>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    436e:	66 e0       	ldi	r22, 0x06	; 6
    4370:	f6 9e       	mul	r15, r22
    4372:	b0 01       	movw	r22, r0
    4374:	11 24       	eor	r1, r1
    4376:	61 5b       	subi	r22, 0xB1	; 177
    4378:	7f 4f       	sbci	r23, 0xFF	; 255
    437a:	ce 01       	movw	r24, r28
    437c:	01 96       	adiw	r24, 0x01	; 1
    437e:	46 e0       	ldi	r20, 0x06	; 6
    4380:	50 e0       	ldi	r21, 0x00	; 0
    4382:	28 ef       	ldi	r18, 0xF8	; 248
    4384:	32 e1       	ldi	r19, 0x12	; 18
    4386:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
		     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);		 
		     if (((ReprintReady[FIPAddr-1]==True))||(IsReprint==False)){
    438a:	ef 2d       	mov	r30, r15
    438c:	f0 e0       	ldi	r31, 0x00	; 0
    438e:	ef 57       	subi	r30, 0x7F	; 127
    4390:	fe 4f       	sbci	r31, 0xFE	; 254
    4392:	80 81       	ld	r24, Z
    4394:	81 30       	cpi	r24, 0x01	; 1
    4396:	19 f0       	breq	.+6      	; 0x439e <PrintStandalone+0x78>
    4398:	00 23       	and	r16, r16
    439a:	29 f0       	breq	.+10     	; 0x43a6 <PrintStandalone+0x80>
    439c:	0c c0       	rjmp	.+24     	; 0x43b6 <PrintStandalone+0x90>
			       if (IsReprint==True)IsReprintTicket=True;
    439e:	01 30       	cpi	r16, 0x01	; 1
    43a0:	11 f4       	brne	.+4      	; 0x43a6 <PrintStandalone+0x80>
    43a2:	00 93 92 01 	sts	0x0192, r16
			       GenerateStandaloneTransData(iPumpID,PProductID);		 			   
    43a6:	8e 2d       	mov	r24, r14
    43a8:	be 01       	movw	r22, r28
    43aa:	6f 5f       	subi	r22, 0xFF	; 255
    43ac:	7f 4f       	sbci	r23, 0xFF	; 255
    43ae:	0e 94 3f 20 	call	0x407e	; 0x407e <GenerateStandaloneTransData>
    43b2:	81 e1       	ldi	r24, 0x11	; 17
    43b4:	01 c0       	rjmp	.+2      	; 0x43b8 <PrintStandalone+0x92>
    43b6:	82 e1       	ldi	r24, 0x12	; 18
			 }//else Result=PS_NO_DATA;
		 }
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}
    43b8:	26 96       	adiw	r28, 0x06	; 6
    43ba:	0f b6       	in	r0, 0x3f	; 63
    43bc:	f8 94       	cli
    43be:	de bf       	out	0x3e, r29	; 62
    43c0:	0f be       	out	0x3f, r0	; 63
    43c2:	cd bf       	out	0x3d, r28	; 61
    43c4:	cf 91       	pop	r28
    43c6:	df 91       	pop	r29
    43c8:	1f 91       	pop	r17
    43ca:	0f 91       	pop	r16
    43cc:	ff 90       	pop	r15
    43ce:	ef 90       	pop	r14
    43d0:	08 95       	ret

000043d2 <SumChecksum>:
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}

char SumChecksum(char *strChecked){
    43d2:	ac 01       	movw	r20, r24
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    43d4:	dc 01       	movw	r26, r24
    43d6:	0d 90       	ld	r0, X+
    43d8:	00 20       	and	r0, r0
    43da:	e9 f7       	brne	.-6      	; 0x43d6 <SumChecksum+0x4>
    43dc:	11 97       	sbiw	r26, 0x01	; 1
    43de:	a8 1b       	sub	r26, r24
    43e0:	b9 0b       	sbc	r27, r25
    43e2:	20 e0       	ldi	r18, 0x00	; 0
    43e4:	30 e0       	ldi	r19, 0x00	; 0
    43e6:	90 e0       	ldi	r25, 0x00	; 0
    43e8:	06 c0       	rjmp	.+12     	; 0x43f6 <SumChecksum+0x24>
	     SigmaSum=SigmaSum+strChecked[i];
    43ea:	e4 0f       	add	r30, r20
    43ec:	f5 1f       	adc	r31, r21
    43ee:	80 81       	ld	r24, Z
    43f0:	28 0f       	add	r18, r24
    43f2:	31 1d       	adc	r19, r1
}

char SumChecksum(char *strChecked){
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    43f4:	9f 5f       	subi	r25, 0xFF	; 255
    43f6:	e9 2f       	mov	r30, r25
    43f8:	f0 e0       	ldi	r31, 0x00	; 0
    43fa:	ea 17       	cp	r30, r26
    43fc:	fb 07       	cpc	r31, r27
    43fe:	a8 f3       	brcs	.-22     	; 0x43ea <SumChecksum+0x18>
	     SigmaSum=SigmaSum+strChecked[i];
	 }
	 Result=(SigmaSum%255);
    4400:	c9 01       	movw	r24, r18
    4402:	6f ef       	ldi	r22, 0xFF	; 255
    4404:	70 e0       	ldi	r23, 0x00	; 0
    4406:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
	 if (Result==0)Result=255;
    440a:	88 23       	and	r24, r24
    440c:	09 f4       	brne	.+2      	; 0x4410 <SumChecksum+0x3e>
    440e:	8f ef       	ldi	r24, 0xFF	; 255
   return Result;
}
    4410:	08 95       	ret

00004412 <IsGeniusCommand>:
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 _uart_print(1,1,strSend);
*/
}

char IsGeniusCommand(char GCommand){
    4412:	ff 92       	push	r15
    4414:	0f 93       	push	r16
    4416:	1f 93       	push	r17
    4418:	df 93       	push	r29
    441a:	cf 93       	push	r28
    441c:	cd b7       	in	r28, 0x3d	; 61
    441e:	de b7       	in	r29, 0x3e	; 62
    4420:	2a 97       	sbiw	r28, 0x0a	; 10
    4422:	0f b6       	in	r0, 0x3f	; 63
    4424:	f8 94       	cli
    4426:	de bf       	out	0x3e, r29	; 62
    4428:	0f be       	out	0x3f, r0	; 63
    442a:	cd bf       	out	0x3d, r28	; 61
    442c:	f8 2e       	mov	r15, r24
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
    442e:	00 d0       	rcall	.+0      	; 0x4430 <IsGeniusCommand+0x1e>
    4430:	00 d0       	rcall	.+0      	; 0x4432 <IsGeniusCommand+0x20>
    4432:	8e 01       	movw	r16, r28
    4434:	0f 5f       	subi	r16, 0xFF	; 255
    4436:	1f 4f       	sbci	r17, 0xFF	; 255
    4438:	ed b7       	in	r30, 0x3d	; 61
    443a:	fe b7       	in	r31, 0x3e	; 62
    443c:	12 83       	std	Z+2, r17	; 0x02
    443e:	01 83       	std	Z+1, r16	; 0x01
    4440:	88 e7       	ldi	r24, 0x78	; 120
    4442:	93 e0       	ldi	r25, 0x03	; 3
    4444:	94 83       	std	Z+4, r25	; 0x04
    4446:	83 83       	std	Z+3, r24	; 0x03
    4448:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	 for(i=0;i<strlen(CommandList);i++){
    444c:	d8 01       	movw	r26, r16
    444e:	0d 90       	ld	r0, X+
    4450:	00 20       	and	r0, r0
    4452:	e9 f7       	brne	.-6      	; 0x444e <IsGeniusCommand+0x3c>
    4454:	11 97       	sbiw	r26, 0x01	; 1
    4456:	a0 1b       	sub	r26, r16
    4458:	b1 0b       	sbc	r27, r17
    445a:	90 e0       	ldi	r25, 0x00	; 0
    445c:	0f 90       	pop	r0
    445e:	0f 90       	pop	r0
    4460:	0f 90       	pop	r0
    4462:	0f 90       	pop	r0
	    if (CommandList[i]==GCommand){
    4464:	98 01       	movw	r18, r16
    4466:	08 c0       	rjmp	.+16     	; 0x4478 <IsGeniusCommand+0x66>
    4468:	e2 0f       	add	r30, r18
    446a:	f3 1f       	adc	r31, r19
    446c:	80 81       	ld	r24, Z
    446e:	8f 15       	cp	r24, r15
    4470:	11 f4       	brne	.+4      	; 0x4476 <IsGeniusCommand+0x64>
    4472:	81 e0       	ldi	r24, 0x01	; 1
    4474:	07 c0       	rjmp	.+14     	; 0x4484 <IsGeniusCommand+0x72>

char IsGeniusCommand(char GCommand){
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
	 for(i=0;i<strlen(CommandList);i++){
    4476:	9f 5f       	subi	r25, 0xFF	; 255
    4478:	e9 2f       	mov	r30, r25
    447a:	f0 e0       	ldi	r31, 0x00	; 0
    447c:	ea 17       	cp	r30, r26
    447e:	fb 07       	cpc	r31, r27
    4480:	98 f3       	brcs	.-26     	; 0x4468 <IsGeniusCommand+0x56>
    4482:	80 e0       	ldi	r24, 0x00	; 0
		    Result=True;
			break;
			}
	 }
   return Result;	 
}
    4484:	2a 96       	adiw	r28, 0x0a	; 10
    4486:	0f b6       	in	r0, 0x3f	; 63
    4488:	f8 94       	cli
    448a:	de bf       	out	0x3e, r29	; 62
    448c:	0f be       	out	0x3f, r0	; 63
    448e:	cd bf       	out	0x3d, r28	; 61
    4490:	cf 91       	pop	r28
    4492:	df 91       	pop	r29
    4494:	1f 91       	pop	r17
    4496:	0f 91       	pop	r16
    4498:	ff 90       	pop	r15
    449a:	08 95       	ret

0000449c <Pos>:
  return Result;
}
		

//Genius Protocol Version:1.0 AKR
int Pos(char *Substr, char *String){//1245:4645
    449c:	0f 93       	push	r16
    449e:	1f 93       	push	r17
    44a0:	cf 93       	push	r28
    44a2:	df 93       	push	r29
    44a4:	ac 01       	movw	r20, r24
    char i,j,CountMatch;
	char Length,subLen,PosFound;

	Length=strlen(String);
    44a6:	fb 01       	movw	r30, r22
    44a8:	01 90       	ld	r0, Z+
    44aa:	00 20       	and	r0, r0
    44ac:	e9 f7       	brne	.-6      	; 0x44a8 <Pos+0xc>
    44ae:	31 97       	sbiw	r30, 0x01	; 1
    44b0:	1e 2f       	mov	r17, r30
    44b2:	16 1b       	sub	r17, r22
	subLen=strlen(Substr);
    44b4:	fc 01       	movw	r30, r24
    44b6:	01 90       	ld	r0, Z+
    44b8:	00 20       	and	r0, r0
    44ba:	e9 f7       	brne	.-6      	; 0x44b6 <Pos+0x1a>
    44bc:	31 97       	sbiw	r30, 0x01	; 1
    44be:	0e 2f       	mov	r16, r30
    44c0:	08 1b       	sub	r16, r24
    44c2:	db 01       	movw	r26, r22
    44c4:	60 e0       	ldi	r22, 0x00	; 0
    44c6:	18 c0       	rjmp	.+48     	; 0x44f8 <Pos+0x5c>
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
    44c8:	9c 91       	ld	r25, X
    44ca:	fa 01       	movw	r30, r20
    44cc:	80 81       	ld	r24, Z
    44ce:	98 17       	cp	r25, r24
    44d0:	89 f4       	brne	.+34     	; 0x44f4 <Pos+0x58>
    44d2:	ed 01       	movw	r28, r26
    44d4:	20 e0       	ldi	r18, 0x00	; 0
    44d6:	30 e0       	ldi	r19, 0x00	; 0
    44d8:	09 c0       	rjmp	.+18     	; 0x44ec <Pos+0x50>
		    CountMatch=0;
			for(j=0;j<subLen;j++){
			    //notFound
			    if (Substr[j]==String[i+j]){
    44da:	fa 01       	movw	r30, r20
    44dc:	e2 0f       	add	r30, r18
    44de:	f3 1f       	adc	r31, r19
    44e0:	90 81       	ld	r25, Z
    44e2:	89 91       	ld	r24, Y+
    44e4:	2f 5f       	subi	r18, 0xFF	; 255
    44e6:	3f 4f       	sbci	r19, 0xFF	; 255
    44e8:	98 17       	cp	r25, r24
    44ea:	21 f4       	brne	.+8      	; 0x44f4 <Pos+0x58>
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
		    CountMatch=0;
			for(j=0;j<subLen;j++){
    44ec:	20 17       	cp	r18, r16
    44ee:	a8 f3       	brcs	.-22     	; 0x44da <Pos+0x3e>
    44f0:	86 2f       	mov	r24, r22
    44f2:	05 c0       	rjmp	.+10     	; 0x44fe <Pos+0x62>
	char Length,subLen,PosFound;

	Length=strlen(String);
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
    44f4:	6f 5f       	subi	r22, 0xFF	; 255
    44f6:	11 96       	adiw	r26, 0x01	; 1
    44f8:	61 17       	cp	r22, r17
    44fa:	30 f3       	brcs	.-52     	; 0x44c8 <Pos+0x2c>
    44fc:	81 2f       	mov	r24, r17
			    break;  
			}
		}
	}
  return  PosFound;
}
    44fe:	90 e0       	ldi	r25, 0x00	; 0
    4500:	df 91       	pop	r29
    4502:	cf 91       	pop	r28
    4504:	1f 91       	pop	r17
    4506:	0f 91       	pop	r16
    4508:	08 95       	ret

0000450a <CreateReport>:
//		  }
//	 }
     *Pos=iPos;
}

void CreateReport(char *strData, char *strPrnBuffer, unsigned int *Pos){
    450a:	7f 92       	push	r7
    450c:	8f 92       	push	r8
    450e:	9f 92       	push	r9
    4510:	af 92       	push	r10
    4512:	bf 92       	push	r11
    4514:	cf 92       	push	r12
    4516:	df 92       	push	r13
    4518:	ef 92       	push	r14
    451a:	ff 92       	push	r15
    451c:	0f 93       	push	r16
    451e:	1f 93       	push	r17
    4520:	cf 93       	push	r28
    4522:	df 93       	push	r29
    4524:	5c 01       	movw	r10, r24
    4526:	6b 01       	movw	r12, r22
    4528:	4a 01       	movw	r8, r20
     unsigned int iPos,PosResult,Length;
	 char i,strSend[20];
	 Length=strlen(strData);
    452a:	ec 01       	movw	r28, r24
    452c:	09 90       	ld	r0, Y+
    452e:	00 20       	and	r0, r0
    4530:	e9 f7       	brne	.-6      	; 0x452c <CreateReport+0x22>
    4532:	21 97       	sbiw	r28, 0x01	; 1
    4534:	c8 1b       	sub	r28, r24
    4536:	d9 0b       	sbc	r29, r25
    4538:	cb 32       	cpi	r28, 0x2B	; 43
    453a:	d1 05       	cpc	r29, r1
    453c:	10 f0       	brcs	.+4      	; 0x4542 <CreateReport+0x38>
    453e:	ca e2       	ldi	r28, 0x2A	; 42
    4540:	d0 e0       	ldi	r29, 0x00	; 0
	 if (Length>BORDER_LENGTH)Length=BORDER_LENGTH;
     
	 iPos=*Pos;
    4542:	f4 01       	movw	r30, r8
    4544:	00 81       	ld	r16, Z
    4546:	11 81       	ldd	r17, Z+1	; 0x01
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    4548:	76 01       	movw	r14, r12
    454a:	e0 0e       	add	r14, r16
    454c:	f1 1e       	adc	r15, r17
    454e:	8a e0       	ldi	r24, 0x0A	; 10
    4550:	0e 94 41 1a 	call	0x3482	; 0x3482 <GetBorderValue>
    4554:	78 2e       	mov	r7, r24
    4556:	f7 01       	movw	r30, r14
    4558:	80 83       	st	Z, r24
     iPos++;
    455a:	98 01       	movw	r18, r16
    455c:	2f 5f       	subi	r18, 0xFF	; 255
    455e:	3f 4f       	sbci	r19, 0xFF	; 255
    4560:	d7 01       	movw	r26, r14
    4562:	90 e0       	ldi	r25, 0x00	; 0
    4564:	07 c0       	rjmp	.+14     	; 0x4574 <CreateReport+0x6a>

	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
    4566:	ea 0d       	add	r30, r10
    4568:	fb 1d       	adc	r31, r11
    456a:	80 81       	ld	r24, Z
    456c:	8c 93       	st	X, r24
		  iPos++;
    456e:	2f 5f       	subi	r18, 0xFF	; 255
    4570:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 iPos=*Pos;
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
     iPos++;

	 for (i=0;i<Length;i++){	      
    4572:	9f 5f       	subi	r25, 0xFF	; 255
    4574:	e9 2f       	mov	r30, r25
    4576:	f0 e0       	ldi	r31, 0x00	; 0
    4578:	11 96       	adiw	r26, 0x01	; 1
    457a:	ec 17       	cp	r30, r28
    457c:	fd 07       	cpc	r31, r29
    457e:	98 f3       	brcs	.-26     	; 0x4566 <CreateReport+0x5c>
    4580:	62 2f       	mov	r22, r18
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
    4582:	ca 32       	cpi	r28, 0x2A	; 42
    4584:	d1 05       	cpc	r29, r1
    4586:	91 f0       	breq	.+36     	; 0x45ac <CreateReport+0xa2>
    4588:	f6 01       	movw	r30, r12
    458a:	e2 0f       	add	r30, r18
    458c:	f3 1f       	adc	r31, r19
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    458e:	4a e2       	ldi	r20, 0x2A	; 42
    4590:	50 e0       	ldi	r21, 0x00	; 0
    4592:	4c 1b       	sub	r20, r28
    4594:	5d 0b       	sbc	r21, r29
	          strPrnBuffer[iPos]=' ';
    4596:	70 e2       	ldi	r23, 0x20	; 32
    4598:	03 c0       	rjmp	.+6      	; 0x45a0 <CreateReport+0x96>
    459a:	71 93       	st	Z+, r23
		      iPos++;
    459c:	2f 5f       	subi	r18, 0xFF	; 255
    459e:	3f 4f       	sbci	r19, 0xFF	; 255
	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    45a0:	82 2f       	mov	r24, r18
    45a2:	86 1b       	sub	r24, r22
    45a4:	90 e0       	ldi	r25, 0x00	; 0
    45a6:	84 17       	cp	r24, r20
    45a8:	95 07       	cpc	r25, r21
    45aa:	b8 f3       	brcs	.-18     	; 0x459a <CreateReport+0x90>
	          strPrnBuffer[iPos]=' ';
		      iPos++;
	     }	    
	 }
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    45ac:	f6 01       	movw	r30, r12
    45ae:	e2 0f       	add	r30, r18
    45b0:	f3 1f       	adc	r31, r19
    45b2:	70 82       	st	Z, r7
     iPos++;
    45b4:	c9 01       	movw	r24, r18
    45b6:	01 96       	adiw	r24, 0x01	; 1
     //PosResult=*Pos+Length;
	 strPrnBuffer[iPos]=0x0D; 
    45b8:	c8 0e       	add	r12, r24
    45ba:	d9 1e       	adc	r13, r25
    45bc:	2d e0       	ldi	r18, 0x0D	; 13
    45be:	f6 01       	movw	r30, r12
    45c0:	20 83       	st	Z, r18
	 iPos++;

   //*Pos=PosResult+1;
   *Pos=iPos;
    45c2:	01 96       	adiw	r24, 0x01	; 1
    45c4:	f4 01       	movw	r30, r8
    45c6:	91 83       	std	Z+1, r25	; 0x01
    45c8:	80 83       	st	Z, r24
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//_uart_print(0,1,strSend);
}
    45ca:	df 91       	pop	r29
    45cc:	cf 91       	pop	r28
    45ce:	1f 91       	pop	r17
    45d0:	0f 91       	pop	r16
    45d2:	ff 90       	pop	r15
    45d4:	ef 90       	pop	r14
    45d6:	df 90       	pop	r13
    45d8:	cf 90       	pop	r12
    45da:	bf 90       	pop	r11
    45dc:	af 90       	pop	r10
    45de:	9f 90       	pop	r9
    45e0:	8f 90       	pop	r8
    45e2:	7f 90       	pop	r7
    45e4:	08 95       	ret

000045e6 <AddList>:

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
void AddList(char GradeId, char *strList){
    45e6:	38 2f       	mov	r19, r24
    45e8:	ab 01       	movw	r20, r22
     char i,iPos,Length,IsFound=False;	 
	 if ((GradeId>=1)&&((GradeId<=6))){
    45ea:	81 50       	subi	r24, 0x01	; 1
    45ec:	86 30       	cpi	r24, 0x06	; 6
    45ee:	68 f5       	brcc	.+90     	; 0x464a <AddList+0x64>
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
    45f0:	fb 01       	movw	r30, r22
    45f2:	01 90       	ld	r0, Z+
    45f4:	00 20       	and	r0, r0
    45f6:	e9 f7       	brne	.-6      	; 0x45f2 <AddList+0xc>
    45f8:	31 97       	sbiw	r30, 0x01	; 1
    45fa:	e6 1b       	sub	r30, r22
    45fc:	f7 0b       	sbc	r31, r23
    45fe:	7e 2f       	mov	r23, r30
	     if (Length>0){
    4600:	ee 23       	and	r30, r30
    4602:	11 f4       	brne	.+4      	; 0x4608 <AddList+0x22>
    4604:	20 e0       	ldi	r18, 0x00	; 0
    4606:	14 c0       	rjmp	.+40     	; 0x4630 <AddList+0x4a>
    4608:	80 e0       	ldi	r24, 0x00	; 0
    460a:	90 e0       	ldi	r25, 0x00	; 0
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    460c:	63 2f       	mov	r22, r19
    460e:	60 5d       	subi	r22, 0xD0	; 208
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //_uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4610:	fa 01       	movw	r30, r20
    4612:	e8 0f       	add	r30, r24
    4614:	f9 1f       	adc	r31, r25
    4616:	e0 81       	ld	r30, Z
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4618:	3a 30       	cpi	r19, 0x0A	; 10
    461a:	10 f0       	brcs	.+4      	; 0x4620 <AddList+0x3a>
    461c:	20 e3       	ldi	r18, 0x30	; 48
    461e:	01 c0       	rjmp	.+2      	; 0x4622 <AddList+0x3c>
	    Result='0'+X;
    4620:	26 2f       	mov	r18, r22
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //_uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4622:	e2 17       	cp	r30, r18
    4624:	91 f0       	breq	.+36     	; 0x464a <AddList+0x64>
    4626:	28 2f       	mov	r18, r24
    4628:	2f 5f       	subi	r18, 0xFF	; 255
    462a:	01 96       	adiw	r24, 0x01	; 1
	 if ((GradeId>=1)&&((GradeId<=6))){
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
    462c:	87 17       	cp	r24, r23
    462e:	80 f3       	brcs	.-32     	; 0x4610 <AddList+0x2a>
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4630:	62 2f       	mov	r22, r18
    4632:	70 e0       	ldi	r23, 0x00	; 0
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4634:	3a 30       	cpi	r19, 0x0A	; 10
    4636:	10 f0       	brcs	.+4      	; 0x463c <AddList+0x56>
    4638:	80 e3       	ldi	r24, 0x30	; 48
    463a:	02 c0       	rjmp	.+4      	; 0x4640 <AddList+0x5a>
	    Result='0'+X;
    463c:	83 2f       	mov	r24, r19
    463e:	80 5d       	subi	r24, 0xD0	; 208
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4640:	fa 01       	movw	r30, r20
    4642:	e6 0f       	add	r30, r22
    4644:	f7 1f       	adc	r31, r23
    4646:	80 83       	st	Z, r24
		     strList[iPos+1]=0;
    4648:	11 82       	std	Z+1, r1	; 0x01
    464a:	08 95       	ret

0000464c <ClearList>:
	 AddSpaceLag(strProductName,10);
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
    464c:	dc 01       	movw	r26, r24
    464e:	0d 90       	ld	r0, X+
    4650:	00 20       	and	r0, r0
    4652:	e9 f7       	brne	.-6      	; 0x464e <ClearList+0x2>
    4654:	11 97       	sbiw	r26, 0x01	; 1
    4656:	a8 1b       	sub	r26, r24
    4658:	b9 0b       	sbc	r27, r25
    465a:	20 e0       	ldi	r18, 0x00	; 0
    465c:	30 e0       	ldi	r19, 0x00	; 0
    465e:	06 c0       	rjmp	.+12     	; 0x466c <ClearList+0x20>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    4660:	fc 01       	movw	r30, r24
    4662:	e2 0f       	add	r30, r18
    4664:	f3 1f       	adc	r31, r19
    4666:	10 82       	st	Z, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4668:	2f 5f       	subi	r18, 0xFF	; 255
    466a:	3f 4f       	sbci	r19, 0xFF	; 255
    466c:	2a 17       	cp	r18, r26
    466e:	3b 07       	cpc	r19, r27
    4670:	b8 f3       	brcs	.-18     	; 0x4660 <ClearList+0x14>
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
    4672:	08 95       	ret

00004674 <CalcSegmen>:
		 */
		 CalcMultiply(strA,strB,strC);
	 }
}

void CalcSegmen(char *strMain, char cNum, char *strResult){
    4674:	6f 92       	push	r6
    4676:	7f 92       	push	r7
    4678:	8f 92       	push	r8
    467a:	9f 92       	push	r9
    467c:	bf 92       	push	r11
    467e:	cf 92       	push	r12
    4680:	df 92       	push	r13
    4682:	ef 92       	push	r14
    4684:	ff 92       	push	r15
    4686:	0f 93       	push	r16
    4688:	1f 93       	push	r17
    468a:	df 93       	push	r29
    468c:	cf 93       	push	r28
    468e:	cd b7       	in	r28, 0x3d	; 61
    4690:	de b7       	in	r29, 0x3e	; 62
    4692:	64 97       	sbiw	r28, 0x14	; 20
    4694:	0f b6       	in	r0, 0x3f	; 63
    4696:	f8 94       	cli
    4698:	de bf       	out	0x3e, r29	; 62
    469a:	0f be       	out	0x3f, r0	; 63
    469c:	cd bf       	out	0x3d, r28	; 61
    469e:	7c 01       	movw	r14, r24
    46a0:	6a 01       	movw	r12, r20
    46a2:	bb 24       	eor	r11, r11
    46a4:	30 e0       	ldi	r19, 0x00	; 0

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    46a6:	06 2f       	mov	r16, r22
    46a8:	10 e0       	ldi	r17, 0x00	; 0
    46aa:	00 53       	subi	r16, 0x30	; 48
    46ac:	10 40       	sbci	r17, 0x00	; 0
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
    46ae:	3e 01       	movw	r6, r28
    46b0:	08 94       	sec
    46b2:	61 1c       	adc	r6, r1
    46b4:	71 1c       	adc	r7, r1
		 tmpResult[i+1]=0;
    46b6:	b2 e0       	ldi	r27, 0x02	; 2
    46b8:	8b 2e       	mov	r8, r27
    46ba:	91 2c       	mov	r9, r1
    46bc:	8c 0e       	add	r8, r28
    46be:	9d 1e       	adc	r9, r29
    46c0:	24 c0       	rjmp	.+72     	; 0x470a <CalcSegmen+0x96>

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    46c2:	11 97       	sbiw	r26, 0x01	; 1
    46c4:	a4 1b       	sub	r26, r20
    46c6:	b5 0b       	sbc	r27, r21
    46c8:	ae 0d       	add	r26, r14
    46ca:	bf 1d       	adc	r27, r15
    46cc:	8c 91       	ld	r24, X
    46ce:	90 e0       	ldi	r25, 0x00	; 0
    46d0:	c0 97       	sbiw	r24, 0x30	; 48
    46d2:	bc 01       	movw	r22, r24
    46d4:	60 9f       	mul	r22, r16
    46d6:	c0 01       	movw	r24, r0
    46d8:	61 9f       	mul	r22, r17
    46da:	90 0d       	add	r25, r0
    46dc:	70 9f       	mul	r23, r16
    46de:	90 0d       	add	r25, r0
    46e0:	11 24       	eor	r1, r1
    46e2:	23 2f       	mov	r18, r19
    46e4:	28 0f       	add	r18, r24
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
    46e6:	82 2f       	mov	r24, r18
    46e8:	6a e0       	ldi	r22, 0x0A	; 10
    46ea:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    46ee:	38 2f       	mov	r19, r24
	     tmpResult[i]='0'+xRes;	 
    46f0:	f3 01       	movw	r30, r6
    46f2:	e4 0f       	add	r30, r20
    46f4:	f5 1f       	adc	r31, r21
    46f6:	82 2f       	mov	r24, r18
    46f8:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    46fc:	90 5d       	subi	r25, 0xD0	; 208
    46fe:	90 83       	st	Z, r25
		 tmpResult[i+1]=0;
    4700:	48 0d       	add	r20, r8
    4702:	59 1d       	adc	r21, r9
    4704:	fa 01       	movw	r30, r20
    4706:	10 82       	st	Z, r1
	 char i,lenR,xCalc,xRes,xResNext,tmpResult[20];

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
    4708:	b3 94       	inc	r11
    470a:	4b 2d       	mov	r20, r11
    470c:	50 e0       	ldi	r21, 0x00	; 0
    470e:	d7 01       	movw	r26, r14
    4710:	0d 90       	ld	r0, X+
    4712:	00 20       	and	r0, r0
    4714:	e9 f7       	brne	.-6      	; 0x4710 <CalcSegmen+0x9c>
    4716:	11 97       	sbiw	r26, 0x01	; 1
    4718:	ae 19       	sub	r26, r14
    471a:	bf 09       	sbc	r27, r15
    471c:	4a 17       	cp	r20, r26
    471e:	5b 07       	cpc	r21, r27
    4720:	80 f2       	brcs	.-96     	; 0x46c2 <CalcSegmen+0x4e>
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
		 tmpResult[i+1]=0;
	 }
	 if (xResNext>0){
    4722:	33 23       	and	r19, r19
    4724:	89 f0       	breq	.+34     	; 0x4748 <CalcSegmen+0xd4>
	     lenR=strlen(tmpResult);
    4726:	fe 01       	movw	r30, r28
    4728:	31 96       	adiw	r30, 0x01	; 1
    472a:	df 01       	movw	r26, r30
    472c:	0d 90       	ld	r0, X+
    472e:	00 20       	and	r0, r0
    4730:	e9 f7       	brne	.-6      	; 0x472c <CalcSegmen+0xb8>
    4732:	11 97       	sbiw	r26, 0x01	; 1
	     tmpResult[lenR]='0'+xResNext;
    4734:	ae 1b       	sub	r26, r30
    4736:	b0 e0       	ldi	r27, 0x00	; 0
    4738:	ea 0f       	add	r30, r26
    473a:	fb 1f       	adc	r31, r27
    473c:	30 5d       	subi	r19, 0xD0	; 208
    473e:	30 83       	st	Z, r19
		 tmpResult[lenR+1]=0;	 
    4740:	ac 0f       	add	r26, r28
    4742:	bd 1f       	adc	r27, r29
    4744:	12 96       	adiw	r26, 0x02	; 2
    4746:	1c 92       	st	X, r1
	 }
	 lenR=strlen(tmpResult);
    4748:	de 01       	movw	r26, r28
    474a:	11 96       	adiw	r26, 0x01	; 1
    474c:	fd 01       	movw	r30, r26
    474e:	01 90       	ld	r0, Z+
    4750:	00 20       	and	r0, r0
    4752:	e9 f7       	brne	.-6      	; 0x474e <CalcSegmen+0xda>
    4754:	31 97       	sbiw	r30, 0x01	; 1
    4756:	9e 2f       	mov	r25, r30
    4758:	9a 1b       	sub	r25, r26
    475a:	a9 0f       	add	r26, r25
    475c:	b1 1d       	adc	r27, r1
    475e:	f6 01       	movw	r30, r12
    4760:	02 c0       	rjmp	.+4      	; 0x4766 <CalcSegmen+0xf2>
	 for (i=0;i<lenR;i++){
	     strResult[i]=tmpResult[lenR-1-i];
    4762:	8c 91       	ld	r24, X
    4764:	81 93       	st	Z+, r24
    4766:	11 97       	sbiw	r26, 0x01	; 1
	     lenR=strlen(tmpResult);
	     tmpResult[lenR]='0'+xResNext;
		 tmpResult[lenR+1]=0;	 
	 }
	 lenR=strlen(tmpResult);
	 for (i=0;i<lenR;i++){
    4768:	ac 17       	cp	r26, r28
    476a:	bd 07       	cpc	r27, r29
    476c:	d1 f7       	brne	.-12     	; 0x4762 <CalcSegmen+0xee>
	     strResult[i]=tmpResult[lenR-1-i];
	 }
	 strResult[lenR]=0;
    476e:	c9 0e       	add	r12, r25
    4770:	d1 1c       	adc	r13, r1
    4772:	f6 01       	movw	r30, r12
    4774:	10 82       	st	Z, r1
}
    4776:	64 96       	adiw	r28, 0x14	; 20
    4778:	0f b6       	in	r0, 0x3f	; 63
    477a:	f8 94       	cli
    477c:	de bf       	out	0x3e, r29	; 62
    477e:	0f be       	out	0x3f, r0	; 63
    4780:	cd bf       	out	0x3d, r28	; 61
    4782:	cf 91       	pop	r28
    4784:	df 91       	pop	r29
    4786:	1f 91       	pop	r17
    4788:	0f 91       	pop	r16
    478a:	ff 90       	pop	r15
    478c:	ef 90       	pop	r14
    478e:	df 90       	pop	r13
    4790:	cf 90       	pop	r12
    4792:	bf 90       	pop	r11
    4794:	9f 90       	pop	r9
    4796:	8f 90       	pop	r8
    4798:	7f 90       	pop	r7
    479a:	6f 90       	pop	r6
    479c:	08 95       	ret

0000479e <GetMinusPos>:
		  if (KeyChar=='*')stTestCalc=tcInitData;
	      break;	 
	 }
}

char GetMinusPos(char *strNumber){
    479e:	ac 01       	movw	r20, r24
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    47a0:	dc 01       	movw	r26, r24
    47a2:	0d 90       	ld	r0, X+
    47a4:	00 20       	and	r0, r0
    47a6:	e9 f7       	brne	.-6      	; 0x47a2 <GetMinusPos+0x4>
    47a8:	11 97       	sbiw	r26, 0x01	; 1
    47aa:	a8 1b       	sub	r26, r24
    47ac:	b9 0b       	sbc	r27, r25
    47ae:	20 e0       	ldi	r18, 0x00	; 0
    47b0:	0a c0       	rjmp	.+20     	; 0x47c6 <GetMinusPos+0x28>
	     if (strNumber[i]=='-'){
    47b2:	e4 0f       	add	r30, r20
    47b4:	f5 1f       	adc	r31, r21
    47b6:	80 81       	ld	r24, Z
    47b8:	92 2f       	mov	r25, r18
    47ba:	9f 5f       	subi	r25, 0xFF	; 255
    47bc:	8d 32       	cpi	r24, 0x2D	; 45
    47be:	11 f4       	brne	.+4      	; 0x47c4 <GetMinusPos+0x26>
		     Result=i+1;
    47c0:	89 2f       	mov	r24, r25
    47c2:	08 95       	ret
}

char GetMinusPos(char *strNumber){
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    47c4:	29 2f       	mov	r18, r25
    47c6:	e2 2f       	mov	r30, r18
    47c8:	f0 e0       	ldi	r31, 0x00	; 0
    47ca:	ea 17       	cp	r30, r26
    47cc:	fb 07       	cpc	r31, r27
    47ce:	88 f3       	brcs	.-30     	; 0x47b2 <GetMinusPos+0x14>
    47d0:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
  return Result;     
}
    47d2:	08 95       	ret

000047d4 <IsMinus>:

char IsMinus(char *strNumber){
char i,Result=False;
     Result=False;
	 if (GetMinusPos(strNumber)>0){
    47d4:	0e 94 cf 23 	call	0x479e	; 0x479e <GetMinusPos>
    47d8:	81 11       	cpse	r24, r1
    47da:	81 e0       	ldi	r24, 0x01	; 1
	     Result=True;
	 }     
  return Result;
}
    47dc:	08 95       	ret

000047de <RemoveMinus>:

void RemoveMinus(char *strNumber){
    47de:	cf 93       	push	r28
    47e0:	df 93       	push	r29
    47e2:	ec 01       	movw	r28, r24
     char MinPos,Length;

     if (IsMinus(strNumber)==True){
    47e4:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <IsMinus>
    47e8:	81 30       	cpi	r24, 0x01	; 1
    47ea:	19 f5       	brne	.+70     	; 0x4832 <RemoveMinus+0x54>
	     MinPos=GetMinusPos(strNumber);
    47ec:	ce 01       	movw	r24, r28
    47ee:	0e 94 cf 23 	call	0x479e	; 0x479e <GetMinusPos>
		 Length=strlen(strNumber);
    47f2:	de 01       	movw	r26, r28
    47f4:	0d 90       	ld	r0, X+
    47f6:	00 20       	and	r0, r0
    47f8:	e9 f7       	brne	.-6      	; 0x47f4 <RemoveMinus+0x16>
    47fa:	11 97       	sbiw	r26, 0x01	; 1
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
    47fc:	ac 1b       	sub	r26, r28
    47fe:	b0 e0       	ldi	r27, 0x00	; 0
    4800:	90 e0       	ldi	r25, 0x00	; 0
    4802:	a8 1b       	sub	r26, r24
    4804:	b9 0b       	sbc	r27, r25
    4806:	ae 01       	movw	r20, r28
    4808:	48 0f       	add	r20, r24
    480a:	59 1f       	adc	r21, r25
    480c:	20 e0       	ldi	r18, 0x00	; 0
    480e:	30 e0       	ldi	r19, 0x00	; 0
    4810:	0a c0       	rjmp	.+20     	; 0x4826 <RemoveMinus+0x48>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4812:	be 01       	movw	r22, r28
    4814:	62 0f       	add	r22, r18
    4816:	73 1f       	adc	r23, r19
    4818:	fa 01       	movw	r30, r20
    481a:	81 91       	ld	r24, Z+
    481c:	af 01       	movw	r20, r30
    481e:	fb 01       	movw	r30, r22
    4820:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4822:	2f 5f       	subi	r18, 0xFF	; 255
    4824:	3f 4f       	sbci	r19, 0xFF	; 255
    4826:	2a 17       	cp	r18, r26
    4828:	3b 07       	cpc	r19, r27
    482a:	98 f3       	brcs	.-26     	; 0x4812 <RemoveMinus+0x34>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    482c:	ac 0f       	add	r26, r28
    482e:	bd 1f       	adc	r27, r29
    4830:	1c 92       	st	X, r1
     if (IsMinus(strNumber)==True){
	     MinPos=GetMinusPos(strNumber);
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}
    4832:	df 91       	pop	r29
    4834:	cf 91       	pop	r28
    4836:	08 95       	ret

00004838 <IsMoreThan>:
	    Result=c-'0';
	 }
	return Result;
}

char IsMoreThan(char *strA, char *strB){
    4838:	ac 01       	movw	r20, r24
    483a:	27 2f       	mov	r18, r23
     char i,LengthA,LengthB,Result=False;
	 char strSend[20];	 
     //Check Length
	 LengthA=strlen(strA);
    483c:	fc 01       	movw	r30, r24
    483e:	01 90       	ld	r0, Z+
    4840:	00 20       	and	r0, r0
    4842:	e9 f7       	brne	.-6      	; 0x483e <IsMoreThan+0x6>
    4844:	31 97       	sbiw	r30, 0x01	; 1
    4846:	7e 2f       	mov	r23, r30
    4848:	78 1b       	sub	r23, r24
	 LengthB=strlen(strB);
    484a:	a6 2f       	mov	r26, r22
    484c:	b2 2f       	mov	r27, r18
    484e:	fd 01       	movw	r30, r26
    4850:	01 90       	ld	r0, Z+
    4852:	00 20       	and	r0, r0
    4854:	e9 f7       	brne	.-6      	; 0x4850 <IsMoreThan+0x18>
    4856:	31 97       	sbiw	r30, 0x01	; 1
    4858:	e6 1b       	sub	r30, r22
	 Result=False;
	 if (LengthA>LengthB)Result=True;
    485a:	e7 17       	cp	r30, r23
    485c:	48 f1       	brcs	.+82     	; 0x48b0 <IsMoreThan+0x78>
	 else 
	 if (LengthA==LengthB){          //456755 
    485e:	7e 17       	cp	r23, r30
    4860:	49 f5       	brne	.+82     	; 0x48b4 <IsMoreThan+0x7c>
    4862:	86 2f       	mov	r24, r22
    4864:	92 2f       	mov	r25, r18
    4866:	9c 01       	movw	r18, r24
    4868:	d9 01       	movw	r26, r18
    486a:	20 e0       	ldi	r18, 0x00	; 0
    486c:	30 e0       	ldi	r19, 0x00	; 0
    486e:	1d c0       	rjmp	.+58     	; 0x48aa <IsMoreThan+0x72>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4870:	fa 01       	movw	r30, r20
    4872:	e2 0f       	add	r30, r18
    4874:	f3 1f       	adc	r31, r19
    4876:	e0 81       	ld	r30, Z
    4878:	e0 53       	subi	r30, 0x30	; 48
    487a:	ea 30       	cpi	r30, 0x0A	; 10
    487c:	10 f0       	brcs	.+4      	; 0x4882 <IsMoreThan+0x4a>
    487e:	60 e0       	ldi	r22, 0x00	; 0
    4880:	01 c0       	rjmp	.+2      	; 0x4884 <IsMoreThan+0x4c>
    4882:	6e 2f       	mov	r22, r30
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
    4884:	8c 91       	ld	r24, X
    4886:	80 53       	subi	r24, 0x30	; 48
    4888:	8a 30       	cpi	r24, 0x0A	; 10
    488a:	10 f0       	brcs	.+4      	; 0x4890 <IsMoreThan+0x58>
    488c:	90 e0       	ldi	r25, 0x00	; 0
    488e:	01 c0       	rjmp	.+2      	; 0x4892 <IsMoreThan+0x5a>
    4890:	98 2f       	mov	r25, r24
    4892:	96 17       	cp	r25, r22
    4894:	68 f0       	brcs	.+26     	; 0x48b0 <IsMoreThan+0x78>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4896:	ea 30       	cpi	r30, 0x0A	; 10
    4898:	08 f0       	brcs	.+2      	; 0x489c <IsMoreThan+0x64>
    489a:	e0 e0       	ldi	r30, 0x00	; 0
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
			     Result=True;
				 break;
			 }else if (Ord(strA[i])<Ord(strB[i])){
    489c:	8a 30       	cpi	r24, 0x0A	; 10
    489e:	10 f4       	brcc	.+4      	; 0x48a4 <IsMoreThan+0x6c>
    48a0:	e8 17       	cp	r30, r24
    48a2:	40 f0       	brcs	.+16     	; 0x48b4 <IsMoreThan+0x7c>
    48a4:	2f 5f       	subi	r18, 0xFF	; 255
    48a6:	3f 4f       	sbci	r19, 0xFF	; 255
    48a8:	11 96       	adiw	r26, 0x01	; 1
	 LengthB=strlen(strB);
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
    48aa:	27 17       	cp	r18, r23
    48ac:	08 f3       	brcs	.-62     	; 0x4870 <IsMoreThan+0x38>
    48ae:	02 c0       	rjmp	.+4      	; 0x48b4 <IsMoreThan+0x7c>
    48b0:	81 e0       	ldi	r24, 0x01	; 1
    48b2:	08 95       	ret
    48b4:	80 e0       	ldi	r24, 0x00	; 0
				 break;
			 }			 		 
		 }
	 }
  return Result;
}
    48b6:	08 95       	ret

000048b8 <IsZerroAll>:
   return Result;
}

char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
    48b8:	fc 01       	movw	r30, r24
    48ba:	01 90       	ld	r0, Z+
    48bc:	00 20       	and	r0, r0
    48be:	e9 f7       	brne	.-6      	; 0x48ba <IsZerroAll+0x2>
    48c0:	31 97       	sbiw	r30, 0x01	; 1
    48c2:	e8 1b       	sub	r30, r24
    48c4:	dc 01       	movw	r26, r24
    48c6:	ae 0f       	add	r26, r30
    48c8:	b1 1d       	adc	r27, r1
    48ca:	90 e0       	ldi	r25, 0x00	; 0
    48cc:	20 e0       	ldi	r18, 0x00	; 0
    48ce:	06 c0       	rjmp	.+12     	; 0x48dc <IsZerroAll+0x24>
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
	     if (strZerro[Length-i]=='0')nZerro++;
    48d0:	8c 91       	ld	r24, X
    48d2:	80 33       	cpi	r24, 0x30	; 48
    48d4:	09 f4       	brne	.+2      	; 0x48d8 <IsZerroAll+0x20>
    48d6:	2f 5f       	subi	r18, 0xFF	; 255
char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
    48d8:	9f 5f       	subi	r25, 0xFF	; 255
    48da:	11 97       	sbiw	r26, 0x01	; 1
    48dc:	9e 17       	cp	r25, r30
    48de:	c0 f3       	brcs	.-16     	; 0x48d0 <IsZerroAll+0x18>
    48e0:	80 e0       	ldi	r24, 0x00	; 0
    48e2:	2e 17       	cp	r18, r30
    48e4:	09 f4       	brne	.+2      	; 0x48e8 <IsZerroAll+0x30>
    48e6:	81 e0       	ldi	r24, 0x01	; 1
	     if (strZerro[Length-i]=='0')nZerro++;
	 }if (nZerro==Length) Result=True;
  return Result;
}
    48e8:	08 95       	ret

000048ea <PstrCopy>:
     _uart(_COM_PRINTER, 1, 0x0D);     
     _uart(_COM_PRINTER, 1, 0x0A);

}

void PstrCopy(char *Dest,char *Source){
    48ea:	cf 93       	push	r28
    48ec:	df 93       	push	r29
    48ee:	20 e0       	ldi	r18, 0x00	; 0
    48f0:	08 c0       	rjmp	.+16     	; 0x4902 <PstrCopy+0x18>
     char i=0;
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
    48f2:	fb 01       	movw	r30, r22
    48f4:	ec 0f       	add	r30, r28
    48f6:	fd 1f       	adc	r31, r29
    48f8:	e4 91       	lpm	r30, Z+
    48fa:	c8 0f       	add	r28, r24
    48fc:	d9 1f       	adc	r29, r25
    48fe:	e8 83       	st	Y, r30

}

void PstrCopy(char *Dest,char *Source){
     char i=0;
	 for(i=0;i<strlen(Source);i++){
    4900:	2f 5f       	subi	r18, 0xFF	; 255
    4902:	c2 2f       	mov	r28, r18
    4904:	d0 e0       	ldi	r29, 0x00	; 0
    4906:	fb 01       	movw	r30, r22
    4908:	01 90       	ld	r0, Z+
    490a:	00 20       	and	r0, r0
    490c:	e9 f7       	brne	.-6      	; 0x4908 <PstrCopy+0x1e>
    490e:	31 97       	sbiw	r30, 0x01	; 1
    4910:	e6 1b       	sub	r30, r22
    4912:	f7 0b       	sbc	r31, r23
    4914:	ce 17       	cp	r28, r30
    4916:	df 07       	cpc	r29, r31
    4918:	60 f3       	brcs	.-40     	; 0x48f2 <PstrCopy+0x8>
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}
    491a:	df 91       	pop	r29
    491c:	cf 91       	pop	r28
    491e:	08 95       	ret

00004920 <SpaceOnly>:
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}

char SpaceOnly(char *string){
    4920:	ac 01       	movw	r20, r24
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    4922:	dc 01       	movw	r26, r24
    4924:	0d 90       	ld	r0, X+
    4926:	00 20       	and	r0, r0
    4928:	e9 f7       	brne	.-6      	; 0x4924 <SpaceOnly+0x4>
    492a:	11 97       	sbiw	r26, 0x01	; 1
    492c:	a8 1b       	sub	r26, r24
    492e:	b9 0b       	sbc	r27, r25
    4930:	90 e0       	ldi	r25, 0x00	; 0
    4932:	20 e0       	ldi	r18, 0x00	; 0
    4934:	30 e0       	ldi	r19, 0x00	; 0
    4936:	09 c0       	rjmp	.+18     	; 0x494a <SpaceOnly+0x2a>
	    if(string[i]!=' ') nChar++;
    4938:	fa 01       	movw	r30, r20
    493a:	e2 0f       	add	r30, r18
    493c:	f3 1f       	adc	r31, r19
    493e:	80 81       	ld	r24, Z
    4940:	80 32       	cpi	r24, 0x20	; 32
    4942:	09 f0       	breq	.+2      	; 0x4946 <SpaceOnly+0x26>
    4944:	9f 5f       	subi	r25, 0xFF	; 255
char SpaceOnly(char *string){
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    4946:	2f 5f       	subi	r18, 0xFF	; 255
    4948:	3f 4f       	sbci	r19, 0xFF	; 255
    494a:	2a 17       	cp	r18, r26
    494c:	3b 07       	cpc	r19, r27
    494e:	a0 f3       	brcs	.-24     	; 0x4938 <SpaceOnly+0x18>
    4950:	80 e0       	ldi	r24, 0x00	; 0
    4952:	99 23       	and	r25, r25
    4954:	09 f4       	brne	.+2      	; 0x4958 <SpaceOnly+0x38>
    4956:	81 e0       	ldi	r24, 0x01	; 1
	 }
	 if (nChar>0) Result=False;
	 else Result=True;

	 return Result;
}
    4958:	08 95       	ret

0000495a <RemDecimal>:
	 }
}



void RemDecimal(char *strDecimal){//4500.00-->4500
    495a:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    495c:	e1 99       	sbic	0x1c, 1	; 28
    495e:	fe cf       	rjmp	.-4      	; 0x495c <RemDecimal+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4960:	8e e3       	ldi	r24, 0x3E	; 62
    4962:	90 e0       	ldi	r25, 0x00	; 0
    4964:	9f bb       	out	0x1f, r25	; 31
    4966:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    4968:	e0 9a       	sbi	0x1c, 0	; 28
    496a:	5d b3       	in	r21, 0x1d	; 29
    496c:	40 e0       	ldi	r20, 0x00	; 0
    496e:	08 c0       	rjmp	.+16     	; 0x4980 <RemDecimal+0x26>
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
	     if (strDecimal[i]==DecPointMark)
    4970:	f9 01       	movw	r30, r18
    4972:	e8 0f       	add	r30, r24
    4974:	f9 1f       	adc	r31, r25
    4976:	80 81       	ld	r24, Z
    4978:	85 17       	cp	r24, r21
    497a:	09 f4       	brne	.+2      	; 0x497e <RemDecimal+0x24>
		     strDecimal[i]=0;
    497c:	10 82       	st	Z, r1

void RemDecimal(char *strDecimal){//4500.00-->4500
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
    497e:	4f 5f       	subi	r20, 0xFF	; 255
    4980:	84 2f       	mov	r24, r20
    4982:	90 e0       	ldi	r25, 0x00	; 0
    4984:	f9 01       	movw	r30, r18
    4986:	01 90       	ld	r0, Z+
    4988:	00 20       	and	r0, r0
    498a:	e9 f7       	brne	.-6      	; 0x4986 <RemDecimal+0x2c>
    498c:	31 97       	sbiw	r30, 0x01	; 1
    498e:	e2 1b       	sub	r30, r18
    4990:	f3 0b       	sbc	r31, r19
    4992:	8e 17       	cp	r24, r30
    4994:	9f 07       	cpc	r25, r31
    4996:	60 f3       	brcs	.-40     	; 0x4970 <RemDecimal+0x16>
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}
    4998:	08 95       	ret

0000499a <GetProductPrice>:
          stGenerateReport=grScanAction;
	      break;
	 }
}
//SaveTotalProduct(xGrade,strDeltaVolume,strDeltaMoney);
void GetProductPrice(char *sPrice,char xPumpID,char xNozzle){
    499a:	cf 92       	push	r12
    499c:	df 92       	push	r13
    499e:	ef 92       	push	r14
    49a0:	ff 92       	push	r15
    49a2:	0f 93       	push	r16
    49a4:	1f 93       	push	r17
    49a6:	df 93       	push	r29
    49a8:	cf 93       	push	r28
    49aa:	cd b7       	in	r28, 0x3d	; 61
    49ac:	de b7       	in	r29, 0x3e	; 62
    49ae:	67 97       	sbiw	r28, 0x17	; 23
    49b0:	0f b6       	in	r0, 0x3f	; 63
    49b2:	f8 94       	cli
    49b4:	de bf       	out	0x3e, r29	; 62
    49b6:	0f be       	out	0x3f, r0	; 63
    49b8:	cd bf       	out	0x3d, r28	; 61
    49ba:	7c 01       	movw	r14, r24
    49bc:	d6 2e       	mov	r13, r22
    49be:	c4 2e       	mov	r12, r20
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
    49c0:	00 d0       	rcall	.+0      	; 0x49c2 <GetProductPrice+0x28>
    49c2:	00 d0       	rcall	.+0      	; 0x49c4 <GetProductPrice+0x2a>
    49c4:	ad b7       	in	r26, 0x3d	; 61
    49c6:	be b7       	in	r27, 0x3e	; 62
    49c8:	12 96       	adiw	r26, 0x02	; 2
    49ca:	9c 93       	st	X, r25
    49cc:	8e 93       	st	-X, r24
    49ce:	11 97       	sbiw	r26, 0x01	; 1
    49d0:	83 e0       	ldi	r24, 0x03	; 3
    49d2:	94 e0       	ldi	r25, 0x04	; 4
    49d4:	14 96       	adiw	r26, 0x04	; 4
    49d6:	9c 93       	st	X, r25
    49d8:	8e 93       	st	-X, r24
    49da:	13 97       	sbiw	r26, 0x03	; 3
    49dc:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    49e0:	0f 90       	pop	r0
    49e2:	0f 90       	pop	r0
    49e4:	0f 90       	pop	r0
    49e6:	0f 90       	pop	r0
    49e8:	8e 01       	movw	r16, r28
    49ea:	09 5f       	subi	r16, 0xF9	; 249
    49ec:	1f 4f       	sbci	r17, 0xFF	; 255
    49ee:	c8 01       	movw	r24, r16
    49f0:	65 e4       	ldi	r22, 0x45	; 69
    49f2:	70 e0       	ldi	r23, 0x00	; 0
    49f4:	48 e0       	ldi	r20, 0x08	; 8
    49f6:	50 e0       	ldi	r21, 0x00	; 0
    49f8:	28 ef       	ldi	r18, 0xF8	; 248
    49fa:	32 e1       	ldi	r19, 0x12	; 18
    49fc:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
    4a00:	f8 01       	movw	r30, r16
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4a02:	9e 01       	movw	r18, r28
    4a04:	21 5f       	subi	r18, 0xF1	; 241
    4a06:	3f 4f       	sbci	r19, 0xFF	; 255
    4a08:	9e 2f       	mov	r25, r30
    4a0a:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==xPumpID){
    4a0c:	80 81       	ld	r24, Z
    4a0e:	8d 15       	cp	r24, r13
    4a10:	11 f4       	brne	.+4      	; 0x4a16 <GetProductPrice+0x7c>
    4a12:	89 2f       	mov	r24, r25
    4a14:	05 c0       	rjmp	.+10     	; 0x4a20 <GetProductPrice+0x86>
    4a16:	31 96       	adiw	r30, 0x01	; 1
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4a18:	e2 17       	cp	r30, r18
    4a1a:	f3 07       	cpc	r31, r19
    4a1c:	a9 f7       	brne	.-22     	; 0x4a08 <GetProductPrice+0x6e>
    4a1e:	80 e0       	ldi	r24, 0x00	; 0
	     if (PPumpID[i]==xPumpID){
		     iPumpID=i;
			 break;
		 }	 
	 }
	 if ((iPumpID>=0)&&(xNozzle<6)){
    4a20:	b5 e0       	ldi	r27, 0x05	; 5
    4a22:	bc 15       	cp	r27, r12
    4a24:	08 f4       	brcc	.+2      	; 0x4a28 <GetProductPrice+0x8e>
    4a26:	41 c0       	rjmp	.+130    	; 0x4aaa <GetProductPrice+0x110>
    4a28:	66 e0       	ldi	r22, 0x06	; 6
    4a2a:	86 9f       	mul	r24, r22
    4a2c:	b0 01       	movw	r22, r0
    4a2e:	11 24       	eor	r1, r1
    4a30:	6b 5a       	subi	r22, 0xAB	; 171
    4a32:	7f 4f       	sbci	r23, 0xFF	; 255
    4a34:	ce 01       	movw	r24, r28
    4a36:	01 96       	adiw	r24, 0x01	; 1
    4a38:	46 e0       	ldi	r20, 0x06	; 6
    4a3a:	50 e0       	ldi	r21, 0x00	; 0
    4a3c:	28 ef       	ldi	r18, 0xF8	; 248
    4a3e:	32 e1       	ldi	r19, 0x12	; 18
    4a40:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
         eeprom_read_block((void*) &PProdID,(const void*) &DefNozzleMap[iPumpID],6);
         xProductID=PProdID[xNozzle-1];
		 //Price
		 eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[xProductID-1], 9);
		 RemDecimal(strPrice);
    4a44:	8e 01       	movw	r16, r28
    4a46:	01 5f       	subi	r16, 0xF1	; 241
    4a48:	1f 4f       	sbci	r17, 0xFF	; 255
    4a4a:	fe 01       	movw	r30, r28
    4a4c:	ec 0d       	add	r30, r12
    4a4e:	f1 1d       	adc	r31, r1
    4a50:	60 81       	ld	r22, Z
    4a52:	89 e0       	ldi	r24, 0x09	; 9
    4a54:	68 9f       	mul	r22, r24
    4a56:	b0 01       	movw	r22, r0
    4a58:	11 24       	eor	r1, r1
    4a5a:	64 58       	subi	r22, 0x84	; 132
    4a5c:	7f 4f       	sbci	r23, 0xFF	; 255
    4a5e:	c8 01       	movw	r24, r16
    4a60:	49 e0       	ldi	r20, 0x09	; 9
    4a62:	50 e0       	ldi	r21, 0x00	; 0
    4a64:	28 ef       	ldi	r18, 0xF8	; 248
    4a66:	32 e1       	ldi	r19, 0x12	; 18
    4a68:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
    4a6c:	c8 01       	movw	r24, r16
    4a6e:	0e 94 ad 24 	call	0x495a	; 0x495a <RemDecimal>
		 sprintf_P(sPrice,PSTR("%s"),strPrice);
    4a72:	00 d0       	rcall	.+0      	; 0x4a74 <GetProductPrice+0xda>
    4a74:	00 d0       	rcall	.+0      	; 0x4a76 <GetProductPrice+0xdc>
    4a76:	00 d0       	rcall	.+0      	; 0x4a78 <GetProductPrice+0xde>
    4a78:	ed b7       	in	r30, 0x3d	; 61
    4a7a:	fe b7       	in	r31, 0x3e	; 62
    4a7c:	31 96       	adiw	r30, 0x01	; 1
    4a7e:	ad b7       	in	r26, 0x3d	; 61
    4a80:	be b7       	in	r27, 0x3e	; 62
    4a82:	12 96       	adiw	r26, 0x02	; 2
    4a84:	fc 92       	st	X, r15
    4a86:	ee 92       	st	-X, r14
    4a88:	11 97       	sbiw	r26, 0x01	; 1
    4a8a:	80 e0       	ldi	r24, 0x00	; 0
    4a8c:	94 e0       	ldi	r25, 0x04	; 4
    4a8e:	93 83       	std	Z+3, r25	; 0x03
    4a90:	82 83       	std	Z+2, r24	; 0x02
    4a92:	15 83       	std	Z+5, r17	; 0x05
    4a94:	04 83       	std	Z+4, r16	; 0x04
    4a96:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    4a9a:	ed b7       	in	r30, 0x3d	; 61
    4a9c:	fe b7       	in	r31, 0x3e	; 62
    4a9e:	36 96       	adiw	r30, 0x06	; 6
    4aa0:	0f b6       	in	r0, 0x3f	; 63
    4aa2:	f8 94       	cli
    4aa4:	fe bf       	out	0x3e, r31	; 62
    4aa6:	0f be       	out	0x3f, r0	; 63
    4aa8:	ed bf       	out	0x3d, r30	; 61
	 }    
	 //Clear Decimal

}
    4aaa:	67 96       	adiw	r28, 0x17	; 23
    4aac:	0f b6       	in	r0, 0x3f	; 63
    4aae:	f8 94       	cli
    4ab0:	de bf       	out	0x3e, r29	; 62
    4ab2:	0f be       	out	0x3f, r0	; 63
    4ab4:	cd bf       	out	0x3d, r28	; 61
    4ab6:	cf 91       	pop	r28
    4ab8:	df 91       	pop	r29
    4aba:	1f 91       	pop	r17
    4abc:	0f 91       	pop	r16
    4abe:	ff 90       	pop	r15
    4ac0:	ef 90       	pop	r14
    4ac2:	df 90       	pop	r13
    4ac4:	cf 90       	pop	r12
    4ac6:	08 95       	ret

00004ac8 <FormatDate>:
	 }     
   }
}

              //Fmt:DATE_LONG_YEAR,DATE_SHORT_YEAR //0123456789    0123456789 
void FormatDate(char FmtYear, char *Date){         //2010/06/16 -> 16/06/2010
    4ac8:	df 93       	push	r29
    4aca:	cf 93       	push	r28
    4acc:	cd b7       	in	r28, 0x3d	; 61
    4ace:	de b7       	in	r29, 0x3e	; 62
    4ad0:	2b 97       	sbiw	r28, 0x0b	; 11
    4ad2:	0f b6       	in	r0, 0x3f	; 63
    4ad4:	f8 94       	cli
    4ad6:	de bf       	out	0x3e, r29	; 62
    4ad8:	0f be       	out	0x3f, r0	; 63
    4ada:	cd bf       	out	0x3d, r28	; 61
    4adc:	98 2f       	mov	r25, r24
    4ade:	9b 01       	movw	r18, r22
     char i,sDate[11];

     sDate[0]=Date[8];
    4ae0:	fb 01       	movw	r30, r22
    4ae2:	80 85       	ldd	r24, Z+8	; 0x08
    4ae4:	89 83       	std	Y+1, r24	; 0x01
	 sDate[1]=Date[9];
    4ae6:	81 85       	ldd	r24, Z+9	; 0x09
    4ae8:	8a 83       	std	Y+2, r24	; 0x02
     sDate[2]=Date[7];
    4aea:	87 81       	ldd	r24, Z+7	; 0x07
    4aec:	8b 83       	std	Y+3, r24	; 0x03
	 sDate[3]=Date[5];
    4aee:	85 81       	ldd	r24, Z+5	; 0x05
    4af0:	8c 83       	std	Y+4, r24	; 0x04
     sDate[4]=Date[6];
    4af2:	86 81       	ldd	r24, Z+6	; 0x06
    4af4:	8d 83       	std	Y+5, r24	; 0x05
	 sDate[5]=Date[4];
    4af6:	84 81       	ldd	r24, Z+4	; 0x04
    4af8:	8e 83       	std	Y+6, r24	; 0x06
	 switch(FmtYear){
    4afa:	99 23       	and	r25, r25
    4afc:	19 f0       	breq	.+6      	; 0x4b04 <FormatDate+0x3c>
    4afe:	91 30       	cpi	r25, 0x01	; 1
    4b00:	59 f4       	brne	.+22     	; 0x4b18 <FormatDate+0x50>
    4b02:	0f c0       	rjmp	.+30     	; 0x4b22 <FormatDate+0x5a>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
    4b04:	fb 01       	movw	r30, r22
    4b06:	80 81       	ld	r24, Z
    4b08:	8f 83       	std	Y+7, r24	; 0x07
    4b0a:	81 81       	ldd	r24, Z+1	; 0x01
    4b0c:	88 87       	std	Y+8, r24	; 0x08
    4b0e:	82 81       	ldd	r24, Z+2	; 0x02
    4b10:	89 87       	std	Y+9, r24	; 0x09
    4b12:	83 81       	ldd	r24, Z+3	; 0x03
    4b14:	8a 87       	std	Y+10, r24	; 0x0a
          sDate[10]=0;
    4b16:	1b 86       	std	Y+11, r1	; 0x0b
    4b18:	90 e0       	ldi	r25, 0x00	; 0
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
          sDate[8]=0;
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    4b1a:	ae 01       	movw	r20, r28
    4b1c:	4f 5f       	subi	r20, 0xFF	; 255
    4b1e:	5f 4f       	sbci	r21, 0xFF	; 255
    4b20:	0f c0       	rjmp	.+30     	; 0x4b40 <FormatDate+0x78>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
          sDate[10]=0;
	      break;
	 case DATE_SHORT_YEAR:
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
    4b22:	fb 01       	movw	r30, r22
    4b24:	82 81       	ldd	r24, Z+2	; 0x02
    4b26:	8f 83       	std	Y+7, r24	; 0x07
    4b28:	83 81       	ldd	r24, Z+3	; 0x03
    4b2a:	88 87       	std	Y+8, r24	; 0x08
          sDate[8]=0;
    4b2c:	19 86       	std	Y+9, r1	; 0x09
    4b2e:	f4 cf       	rjmp	.-24     	; 0x4b18 <FormatDate+0x50>
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    4b30:	f9 01       	movw	r30, r18
    4b32:	ea 0f       	add	r30, r26
    4b34:	fb 1f       	adc	r31, r27
    4b36:	a4 0f       	add	r26, r20
    4b38:	b5 1f       	adc	r27, r21
    4b3a:	8c 91       	ld	r24, X
    4b3c:	80 83       	st	Z, r24
    4b3e:	9f 5f       	subi	r25, 0xFF	; 255
    4b40:	a9 2f       	mov	r26, r25
    4b42:	b0 e0       	ldi	r27, 0x00	; 0
    4b44:	fa 01       	movw	r30, r20
    4b46:	01 90       	ld	r0, Z+
    4b48:	00 20       	and	r0, r0
    4b4a:	e9 f7       	brne	.-6      	; 0x4b46 <FormatDate+0x7e>
    4b4c:	31 97       	sbiw	r30, 0x01	; 1
    4b4e:	e4 1b       	sub	r30, r20
    4b50:	f5 0b       	sbc	r31, r21
    4b52:	ae 17       	cp	r26, r30
    4b54:	bf 07       	cpc	r27, r31
    4b56:	60 f3       	brcs	.-40     	; 0x4b30 <FormatDate+0x68>
}
    4b58:	2b 96       	adiw	r28, 0x0b	; 11
    4b5a:	0f b6       	in	r0, 0x3f	; 63
    4b5c:	f8 94       	cli
    4b5e:	de bf       	out	0x3e, r29	; 62
    4b60:	0f be       	out	0x3f, r0	; 63
    4b62:	cd bf       	out	0x3d, r28	; 61
    4b64:	cf 91       	pop	r28
    4b66:	df 91       	pop	r29
    4b68:	08 95       	ret

00004b6a <RemZeroLead>:

	while (1){};
  #endif
}

void RemZeroLead(char *Zeroed){//Remove Zero Character 00001004 000050000 0 
    4b6a:	cf 93       	push	r28
    4b6c:	df 93       	push	r29
    4b6e:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
    4b70:	fc 01       	movw	r30, r24
    4b72:	01 90       	ld	r0, Z+
    4b74:	00 20       	and	r0, r0
    4b76:	e9 f7       	brne	.-6      	; 0x4b72 <RemZeroLead+0x8>
    4b78:	31 97       	sbiw	r30, 0x01	; 1
    4b7a:	e8 1b       	sub	r30, r24
  if ((Length>1)&&(Zeroed[0]=='0')){
    4b7c:	e2 30       	cpi	r30, 0x02	; 2
    4b7e:	d0 f1       	brcs	.+116    	; 0x4bf4 <RemZeroLead+0x8a>
    4b80:	88 81       	ld	r24, Y
    4b82:	80 33       	cpi	r24, 0x30	; 48
    4b84:	b9 f5       	brne	.+110    	; 0x4bf4 <RemZeroLead+0x8a>
    4b86:	4c 2f       	mov	r20, r28
    4b88:	de 01       	movw	r26, r28
    4b8a:	90 e0       	ldi	r25, 0x00	; 0
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
	         if ((Zeroed[i]=='0')&&(Zeroed[i+1]=='0')&&(IsFound==False)) ZeroPos++;
    4b8c:	8c 91       	ld	r24, X
    4b8e:	80 33       	cpi	r24, 0x30	; 48
    4b90:	69 f4       	brne	.+26     	; 0x4bac <RemZeroLead+0x42>
    4b92:	11 96       	adiw	r26, 0x01	; 1
    4b94:	8c 91       	ld	r24, X
    4b96:	11 97       	sbiw	r26, 0x01	; 1
    4b98:	80 33       	cpi	r24, 0x30	; 48
    4b9a:	11 f4       	brne	.+4      	; 0x4ba0 <RemZeroLead+0x36>
    4b9c:	9f 5f       	subi	r25, 0xFF	; 255
    4b9e:	06 c0       	rjmp	.+12     	; 0x4bac <RemZeroLead+0x42>
             if ((Zeroed[i]=='0')&&(Zeroed[i+1]!='0')){
			     if ((Zeroed[i+1]=='.')||(Zeroed[i+1]==','))ZeroPos--;
    4ba0:	8e 32       	cpi	r24, 0x2E	; 46
    4ba2:	11 f0       	breq	.+4      	; 0x4ba8 <RemZeroLead+0x3e>
    4ba4:	8c 32       	cpi	r24, 0x2C	; 44
    4ba6:	41 f4       	brne	.+16     	; 0x4bb8 <RemZeroLead+0x4e>
    4ba8:	91 50       	subi	r25, 0x01	; 1
    4baa:	06 c0       	rjmp	.+12     	; 0x4bb8 <RemZeroLead+0x4e>
    4bac:	11 96       	adiw	r26, 0x01	; 1
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
  if ((Length>1)&&(Zeroed[0]=='0')){
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
    4bae:	8a 2f       	mov	r24, r26
    4bb0:	84 1b       	sub	r24, r20
    4bb2:	8e 17       	cp	r24, r30
    4bb4:	58 f3       	brcs	.-42     	; 0x4b8c <RemZeroLead+0x22>
    4bb6:	01 c0       	rjmp	.+2      	; 0x4bba <RemZeroLead+0x50>
		         IsFound=True;
			     break;			  
			     }
	      }

		  if (IsFound==True)ZeroPos++;
    4bb8:	9f 5f       	subi	r25, 0xFF	; 255
		  if (ZeroPos>=Length)ZeroPos=Length-1;
    4bba:	9e 17       	cp	r25, r30
    4bbc:	10 f0       	brcs	.+4      	; 0x4bc2 <RemZeroLead+0x58>
    4bbe:	9e 2f       	mov	r25, r30
    4bc0:	91 50       	subi	r25, 0x01	; 1
    4bc2:	40 e0       	ldi	r20, 0x00	; 0
          for(i=0;i<(Length-ZeroPos);i++){
    4bc4:	89 2f       	mov	r24, r25
    4bc6:	90 e0       	ldi	r25, 0x00	; 0
    4bc8:	2e 2f       	mov	r18, r30
    4bca:	30 e0       	ldi	r19, 0x00	; 0
    4bcc:	28 1b       	sub	r18, r24
    4bce:	39 0b       	sbc	r19, r25
	          Zeroed[i]=Zeroed[i+ZeroPos];
    4bd0:	be 01       	movw	r22, r28
    4bd2:	68 0f       	add	r22, r24
    4bd4:	79 1f       	adc	r23, r25
    4bd6:	09 c0       	rjmp	.+18     	; 0x4bea <RemZeroLead+0x80>
    4bd8:	fe 01       	movw	r30, r28
    4bda:	ea 0f       	add	r30, r26
    4bdc:	fb 1f       	adc	r31, r27
    4bde:	a6 0f       	add	r26, r22
    4be0:	b7 1f       	adc	r27, r23
    4be2:	8c 91       	ld	r24, X
    4be4:	80 83       	st	Z, r24
		      Zeroed[i+1]=0;
    4be6:	11 82       	std	Z+1, r1	; 0x01
			     }
	      }

		  if (IsFound==True)ZeroPos++;
		  if (ZeroPos>=Length)ZeroPos=Length-1;
          for(i=0;i<(Length-ZeroPos);i++){
    4be8:	4f 5f       	subi	r20, 0xFF	; 255
    4bea:	a4 2f       	mov	r26, r20
    4bec:	b0 e0       	ldi	r27, 0x00	; 0
    4bee:	a2 17       	cp	r26, r18
    4bf0:	b3 07       	cpc	r27, r19
    4bf2:	94 f3       	brlt	.-28     	; 0x4bd8 <RemZeroLead+0x6e>
	          Zeroed[i]=Zeroed[i+ZeroPos];
		      Zeroed[i+1]=0;
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}
    4bf4:	df 91       	pop	r29
    4bf6:	cf 91       	pop	r28
    4bf8:	08 95       	ret

00004bfa <RemSpaceLead>:
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
    4bfa:	cf 93       	push	r28
    4bfc:	df 93       	push	r29
    4bfe:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
    4c00:	fc 01       	movw	r30, r24
    4c02:	01 90       	ld	r0, Z+
    4c04:	00 20       	and	r0, r0
    4c06:	e9 f7       	brne	.-6      	; 0x4c02 <RemSpaceLead+0x8>
    4c08:	31 97       	sbiw	r30, 0x01	; 1
    4c0a:	6e 2f       	mov	r22, r30
    4c0c:	68 1b       	sub	r22, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
    4c0e:	62 30       	cpi	r22, 0x02	; 2
    4c10:	e0 f1       	brcs	.+120    	; 0x4c8a <RemSpaceLead+0x90>
    4c12:	88 81       	ld	r24, Y
    4c14:	80 32       	cpi	r24, 0x20	; 32
    4c16:	c9 f5       	brne	.+114    	; 0x4c8a <RemSpaceLead+0x90>
    4c18:	4c 2f       	mov	r20, r28
    4c1a:	fe 01       	movw	r30, r28
    4c1c:	90 e0       	ldi	r25, 0x00	; 0
    4c1e:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
    4c20:	80 81       	ld	r24, Z
    4c22:	80 32       	cpi	r24, 0x20	; 32
    4c24:	41 f4       	brne	.+16     	; 0x4c36 <RemSpaceLead+0x3c>
    4c26:	81 81       	ldd	r24, Z+1	; 0x01
    4c28:	80 32       	cpi	r24, 0x20	; 32
    4c2a:	21 f4       	brne	.+8      	; 0x4c34 <RemSpaceLead+0x3a>
    4c2c:	22 23       	and	r18, r18
    4c2e:	19 f4       	brne	.+6      	; 0x4c36 <RemSpaceLead+0x3c>
    4c30:	9f 5f       	subi	r25, 0xFF	; 255
    4c32:	01 c0       	rjmp	.+2      	; 0x4c36 <RemSpaceLead+0x3c>
    4c34:	21 e0       	ldi	r18, 0x01	; 1
    4c36:	31 96       	adiw	r30, 0x01	; 1

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
    4c38:	8e 2f       	mov	r24, r30
    4c3a:	84 1b       	sub	r24, r20
    4c3c:	86 17       	cp	r24, r22
    4c3e:	80 f3       	brcs	.-32     	; 0x4c20 <RemSpaceLead+0x26>
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
    4c40:	39 2f       	mov	r19, r25
    4c42:	3f 5f       	subi	r19, 0xFF	; 255
    4c44:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
    4c46:	43 2f       	mov	r20, r19
    4c48:	50 e0       	ldi	r21, 0x00	; 0
    4c4a:	09 c0       	rjmp	.+18     	; 0x4c5e <RemSpaceLead+0x64>
    4c4c:	fe 01       	movw	r30, r28
    4c4e:	e8 0f       	add	r30, r24
    4c50:	f9 1f       	adc	r31, r25
    4c52:	df 01       	movw	r26, r30
    4c54:	a4 0f       	add	r26, r20
    4c56:	b5 1f       	adc	r27, r21
    4c58:	8c 91       	ld	r24, X
    4c5a:	80 83       	st	Z, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
    4c5c:	2f 5f       	subi	r18, 0xFF	; 255
    4c5e:	82 2f       	mov	r24, r18
    4c60:	90 e0       	ldi	r25, 0x00	; 0
    4c62:	fe 01       	movw	r30, r28
    4c64:	01 90       	ld	r0, Z+
    4c66:	00 20       	and	r0, r0
    4c68:	e9 f7       	brne	.-6      	; 0x4c64 <RemSpaceLead+0x6a>
    4c6a:	31 97       	sbiw	r30, 0x01	; 1
    4c6c:	ec 1b       	sub	r30, r28
    4c6e:	fd 0b       	sbc	r31, r29
    4c70:	8e 17       	cp	r24, r30
    4c72:	9f 07       	cpc	r25, r31
    4c74:	58 f3       	brcs	.-42     	; 0x4c4c <RemSpaceLead+0x52>
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    4c76:	86 2f       	mov	r24, r22
    4c78:	83 1b       	sub	r24, r19
    4c7a:	05 c0       	rjmp	.+10     	; 0x4c86 <RemSpaceLead+0x8c>
		     Zeroed[i]=0;
    4c7c:	fe 01       	movw	r30, r28
    4c7e:	e8 0f       	add	r30, r24
    4c80:	f1 1d       	adc	r31, r1
    4c82:	10 82       	st	Z, r1
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    4c84:	8f 5f       	subi	r24, 0xFF	; 255
    4c86:	86 17       	cp	r24, r22
    4c88:	c8 f3       	brcs	.-14     	; 0x4c7c <RemSpaceLead+0x82>
		     Zeroed[i]=0;
		 }
     }
}
    4c8a:	df 91       	pop	r29
    4c8c:	cf 91       	pop	r28
    4c8e:	08 95       	ret

00004c90 <RemSpaceLag>:
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
    4c90:	0f 93       	push	r16
    4c92:	1f 93       	push	r17
    4c94:	cf 93       	push	r28
    4c96:	df 93       	push	r29
    4c98:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
    4c9a:	dc 01       	movw	r26, r24
    4c9c:	0d 90       	ld	r0, X+
    4c9e:	00 20       	and	r0, r0
    4ca0:	e9 f7       	brne	.-6      	; 0x4c9c <RemSpaceLag+0xc>
    4ca2:	11 97       	sbiw	r26, 0x01	; 1
    4ca4:	a8 1b       	sub	r26, r24
    4ca6:	b0 e0       	ldi	r27, 0x00	; 0
    4ca8:	20 e0       	ldi	r18, 0x00	; 0
    4caa:	30 e0       	ldi	r19, 0x00	; 0
     for(i=0;i<(Length-1);i++){
    4cac:	6a 2f       	mov	r22, r26
    4cae:	70 e0       	ldi	r23, 0x00	; 0
    4cb0:	8b 01       	movw	r16, r22
    4cb2:	01 50       	subi	r16, 0x01	; 1
    4cb4:	10 40       	sbci	r17, 0x00	; 0
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
		      Spaced[Length-i-1]=0;
    4cb6:	a1 50       	subi	r26, 0x01	; 1
    4cb8:	16 c0       	rjmp	.+44     	; 0x4ce6 <RemSpaceLag+0x56>
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
    4cba:	ab 01       	movw	r20, r22
    4cbc:	48 1b       	sub	r20, r24
    4cbe:	59 0b       	sbc	r21, r25
    4cc0:	fe 01       	movw	r30, r28
    4cc2:	e4 0f       	add	r30, r20
    4cc4:	f5 1f       	adc	r31, r21
    4cc6:	32 97       	sbiw	r30, 0x02	; 2
    4cc8:	80 81       	ld	r24, Z
    4cca:	80 32       	cpi	r24, 0x20	; 32
    4ccc:	89 f4       	brne	.+34     	; 0x4cf0 <RemSpaceLag+0x60>
    4cce:	fa 01       	movw	r30, r20
    4cd0:	31 97       	sbiw	r30, 0x01	; 1
    4cd2:	ec 0f       	add	r30, r28
    4cd4:	fd 1f       	adc	r31, r29
    4cd6:	2f 5f       	subi	r18, 0xFF	; 255
    4cd8:	3f 4f       	sbci	r19, 0xFF	; 255
    4cda:	80 81       	ld	r24, Z
    4cdc:	80 32       	cpi	r24, 0x20	; 32
    4cde:	41 f4       	brne	.+16     	; 0x4cf0 <RemSpaceLag+0x60>
		      Spaced[Length-i-1]=0;
    4ce0:	10 82       	st	Z, r1
    4ce2:	ba 2f       	mov	r27, r26
    4ce4:	b2 1b       	sub	r27, r18
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
    4ce6:	82 2f       	mov	r24, r18
    4ce8:	90 e0       	ldi	r25, 0x00	; 0
    4cea:	80 17       	cp	r24, r16
    4cec:	91 07       	cpc	r25, r17
    4cee:	2c f3       	brlt	.-54     	; 0x4cba <RemSpaceLag+0x2a>
		      Spaced[Length-i-1]=0;
			  PosSpaced=Length-i-2;
			  }
         else break;
	 }
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
    4cf0:	fe 01       	movw	r30, r28
    4cf2:	eb 0f       	add	r30, r27
    4cf4:	f1 1d       	adc	r31, r1
    4cf6:	80 81       	ld	r24, Z
    4cf8:	80 32       	cpi	r24, 0x20	; 32
    4cfa:	09 f4       	brne	.+2      	; 0x4cfe <RemSpaceLag+0x6e>
    4cfc:	10 82       	st	Z, r1
	 if (Spaced[0]==' ')Spaced[0]=0;
    4cfe:	88 81       	ld	r24, Y
    4d00:	80 32       	cpi	r24, 0x20	; 32
    4d02:	09 f4       	brne	.+2      	; 0x4d06 <RemSpaceLag+0x76>
    4d04:	18 82       	st	Y, r1
	 Spaced[strlen(Spaced)]=0;
    4d06:	fe 01       	movw	r30, r28
    4d08:	01 90       	ld	r0, Z+
    4d0a:	00 20       	and	r0, r0
    4d0c:	e9 f7       	brne	.-6      	; 0x4d08 <RemSpaceLag+0x78>
    4d0e:	31 97       	sbiw	r30, 0x01	; 1
    4d10:	ec 1b       	sub	r30, r28
    4d12:	fd 0b       	sbc	r31, r29
    4d14:	ec 0f       	add	r30, r28
    4d16:	fd 1f       	adc	r31, r29
    4d18:	10 82       	st	Z, r1
}
    4d1a:	df 91       	pop	r29
    4d1c:	cf 91       	pop	r28
    4d1e:	1f 91       	pop	r17
    4d20:	0f 91       	pop	r16
    4d22:	08 95       	ret

00004d24 <procMessage57>:
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}

char procMessage57(){
    4d24:	1f 93       	push	r17
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    4d26:	10 91 bc 0c 	lds	r17, 0x0CBC
    4d2a:	20 e0       	ldi	r18, 0x00	; 0
    4d2c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4d2e:	f9 01       	movw	r30, r18
    4d30:	ed 57       	subi	r30, 0x7D	; 125
    4d32:	f3 4f       	sbci	r31, 0xF3	; 243
    4d34:	d9 01       	movw	r26, r18
    4d36:	a1 51       	subi	r26, 0x11	; 17
    4d38:	b1 4f       	sbci	r27, 0xF1	; 241
    4d3a:	95 96       	adiw	r26, 0x25	; 37
    4d3c:	8c 91       	ld	r24, X
    4d3e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4d40:	2f 5f       	subi	r18, 0xFF	; 255
    4d42:	3f 4f       	sbci	r19, 0xFF	; 255
    4d44:	24 31       	cpi	r18, 0x14	; 20
    4d46:	31 05       	cpc	r19, r1
    4d48:	91 f7       	brne	.-28     	; 0x4d2e <procMessage57+0xa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4d4a:	10 92 97 0c 	sts	0x0C97, r1
	 
	     //Card Status
		 Result=(CharPosCopy(rcv_trans,57)-'0')+1;
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
    4d4e:	8f ee       	ldi	r24, 0xEF	; 239
    4d50:	9e e0       	ldi	r25, 0x0E	; 14
    4d52:	0e 94 fd 25 	call	0x4bfa	; 0x4bfa <RemSpaceLead>
    4d56:	20 e0       	ldi	r18, 0x00	; 0
    4d58:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4d5a:	f9 01       	movw	r30, r18
    4d5c:	ec 5f       	subi	r30, 0xFC	; 252
    4d5e:	fa 4f       	sbci	r31, 0xFA	; 250
    4d60:	d9 01       	movw	r26, r18
    4d62:	ad 57       	subi	r26, 0x7D	; 125
    4d64:	b3 4f       	sbci	r27, 0xF3	; 243
    4d66:	dc 96       	adiw	r26, 0x3c	; 60
    4d68:	8c 91       	ld	r24, X
    4d6a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4d6c:	2f 5f       	subi	r18, 0xFF	; 255
    4d6e:	3f 4f       	sbci	r19, 0xFF	; 255
    4d70:	28 32       	cpi	r18, 0x28	; 40
    4d72:	31 05       	cpc	r19, r1
    4d74:	91 f7       	brne	.-28     	; 0x4d5a <procMessage57+0x36>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4d76:	10 92 2c 05 	sts	0x052C, r1
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
    4d7a:	84 e0       	ldi	r24, 0x04	; 4
    4d7c:	95 e0       	ldi	r25, 0x05	; 5
    4d7e:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
    4d82:	20 e0       	ldi	r18, 0x00	; 0
    4d84:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4d86:	f9 01       	movw	r30, r18
    4d88:	e5 5c       	subi	r30, 0xC5	; 197
    4d8a:	fa 4f       	sbci	r31, 0xFA	; 250
    4d8c:	d9 01       	movw	r26, r18
    4d8e:	a5 5e       	subi	r26, 0xE5	; 229
    4d90:	b2 4f       	sbci	r27, 0xF2	; 242
    4d92:	8c 91       	ld	r24, X
    4d94:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4d96:	2f 5f       	subi	r18, 0xFF	; 255
    4d98:	3f 4f       	sbci	r19, 0xFF	; 255
    4d9a:	29 31       	cpi	r18, 0x19	; 25
    4d9c:	31 05       	cpc	r19, r1
    4d9e:	99 f7       	brne	.-26     	; 0x4d86 <procMessage57+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4da0:	10 92 54 05 	sts	0x0554, r1
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
		 //BalanceTypePrint
		 StrPosCopy(rcv_trans,strBalanceTypePrint,154-2,25);
		 RemSpaceLag(strBalanceTypePrint);
    4da4:	8b e3       	ldi	r24, 0x3B	; 59
    4da6:	95 e0       	ldi	r25, 0x05	; 5
    4da8:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4dac:	80 91 34 0d 	lds	r24, 0x0D34
    4db0:	80 93 c5 04 	sts	0x04C5, r24
	 }Dest[Length]=0;
    4db4:	10 92 c6 04 	sts	0x04C6, r1
    4db8:	20 e0       	ldi	r18, 0x00	; 0
    4dba:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4dbc:	f9 01       	movw	r30, r18
    4dbe:	e5 5b       	subi	r30, 0xB5	; 181
    4dc0:	f0 4f       	sbci	r31, 0xF0	; 240
    4dc2:	d9 01       	movw	r26, r18
    4dc4:	ab 5c       	subi	r26, 0xCB	; 203
    4dc6:	b2 4f       	sbci	r27, 0xF2	; 242
    4dc8:	8c 91       	ld	r24, X
    4dca:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4dcc:	2f 5f       	subi	r18, 0xFF	; 255
    4dce:	3f 4f       	sbci	r19, 0xFF	; 255
    4dd0:	2d 30       	cpi	r18, 0x0D	; 13
    4dd2:	31 05       	cpc	r19, r1
    4dd4:	99 f7       	brne	.-26     	; 0x4dbc <procMessage57+0x98>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4dd6:	10 92 58 0f 	sts	0x0F58, r1
		 RemSpaceLag(strBalanceTypePrint);
         //BalanceTypeCode
		 StrPosCopy(rcv_trans,strBalanceCode,177,1);
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
    4dda:	8b e4       	ldi	r24, 0x4B	; 75
    4ddc:	9f e0       	ldi	r25, 0x0F	; 15
    4dde:	0e 94 fd 25 	call	0x4bfa	; 0x4bfa <RemSpaceLead>
    4de2:	20 e0       	ldi	r18, 0x00	; 0
    4de4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4de6:	f9 01       	movw	r30, r18
    4de8:	e0 5a       	subi	r30, 0xA0	; 160
    4dea:	f3 4f       	sbci	r31, 0xF3	; 243
    4dec:	d9 01       	movw	r26, r18
    4dee:	ae 5b       	subi	r26, 0xBE	; 190
    4df0:	b2 4f       	sbci	r27, 0xF2	; 242
    4df2:	8c 91       	ld	r24, X
    4df4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4df6:	2f 5f       	subi	r18, 0xFF	; 255
    4df8:	3f 4f       	sbci	r19, 0xFF	; 255
    4dfa:	2a 30       	cpi	r18, 0x0A	; 10
    4dfc:	31 05       	cpc	r19, r1
    4dfe:	99 f7       	brne	.-26     	; 0x4de6 <procMessage57+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4e00:	10 92 6a 0c 	sts	0x0C6A, r1
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
    4e04:	80 e6       	ldi	r24, 0x60	; 96
    4e06:	9c e0       	ldi	r25, 0x0C	; 12
    4e08:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
    4e0c:	20 e0       	ldi	r18, 0x00	; 0
    4e0e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4e10:	f9 01       	movw	r30, r18
    4e12:	e4 5a       	subi	r30, 0xA4	; 164
    4e14:	f6 4f       	sbci	r31, 0xF6	; 246
    4e16:	d9 01       	movw	r26, r18
    4e18:	a4 5b       	subi	r26, 0xB4	; 180
    4e1a:	b2 4f       	sbci	r27, 0xF2	; 242
    4e1c:	8c 91       	ld	r24, X
    4e1e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4e20:	2f 5f       	subi	r18, 0xFF	; 255
    4e22:	3f 4f       	sbci	r19, 0xFF	; 255
    4e24:	24 31       	cpi	r18, 0x14	; 20
    4e26:	31 05       	cpc	r19, r1
    4e28:	99 f7       	brne	.-26     	; 0x4e10 <procMessage57+0xec>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4e2a:	10 92 70 09 	sts	0x0970, r1
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
		 //CompName
		 StrPosCopy(rcv_trans,strCompName,203-2,20);
		 RemSpaceLag(strCompName);
    4e2e:	8c e5       	ldi	r24, 0x5C	; 92
    4e30:	99 e0       	ldi	r25, 0x09	; 9
    4e32:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		 _uart_print(0,1,strCompName);
		 
_uart_print(0,1,strCardID);
*/	
     return Result;
}
    4e36:	81 2f       	mov	r24, r17
    4e38:	8f 52       	subi	r24, 0x2F	; 47
    4e3a:	1f 91       	pop	r17
    4e3c:	08 95       	ret

00004e3e <clearString>:
	     break;
	}
  return Result;
}

void clearString(char *str){
    4e3e:	20 e0       	ldi	r18, 0x00	; 0
    4e40:	30 e0       	ldi	r19, 0x00	; 0
    4e42:	06 c0       	rjmp	.+12     	; 0x4e50 <clearString+0x12>
     int i;
	 for(i=0;i<strlen(str);i++){
	    str[i]=0;
    4e44:	fc 01       	movw	r30, r24
    4e46:	e2 0f       	add	r30, r18
    4e48:	f3 1f       	adc	r31, r19
    4e4a:	10 82       	st	Z, r1
  return Result;
}

void clearString(char *str){
     int i;
	 for(i=0;i<strlen(str);i++){
    4e4c:	2f 5f       	subi	r18, 0xFF	; 255
    4e4e:	3f 4f       	sbci	r19, 0xFF	; 255
    4e50:	fc 01       	movw	r30, r24
    4e52:	01 90       	ld	r0, Z+
    4e54:	00 20       	and	r0, r0
    4e56:	e9 f7       	brne	.-6      	; 0x4e52 <clearString+0x14>
    4e58:	31 97       	sbiw	r30, 0x01	; 1
    4e5a:	e8 1b       	sub	r30, r24
    4e5c:	f9 0b       	sbc	r31, r25
    4e5e:	2e 17       	cp	r18, r30
    4e60:	3f 07       	cpc	r19, r31
    4e62:	80 f3       	brcs	.-32     	; 0x4e44 <clearString+0x6>
	    str[i]=0;
	 }
}
    4e64:	08 95       	ret

00004e66 <AddZeroLead>:
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    4e66:	bf 92       	push	r11
    4e68:	cf 92       	push	r12
    4e6a:	df 92       	push	r13
    4e6c:	ef 92       	push	r14
    4e6e:	ff 92       	push	r15
    4e70:	0f 93       	push	r16
    4e72:	1f 93       	push	r17
    4e74:	df 93       	push	r29
    4e76:	cf 93       	push	r28
    4e78:	cd b7       	in	r28, 0x3d	; 61
    4e7a:	de b7       	in	r29, 0x3e	; 62
    4e7c:	6e 97       	sbiw	r28, 0x1e	; 30
    4e7e:	0f b6       	in	r0, 0x3f	; 63
    4e80:	f8 94       	cli
    4e82:	de bf       	out	0x3e, r29	; 62
    4e84:	0f be       	out	0x3f, r0	; 63
    4e86:	cd bf       	out	0x3d, r28	; 61
    4e88:	8c 01       	movw	r16, r24
     char i,Length,strAdded[30];
     Length=strlen(String);
    4e8a:	fc 01       	movw	r30, r24
    4e8c:	01 90       	ld	r0, Z+
    4e8e:	00 20       	and	r0, r0
    4e90:	e9 f7       	brne	.-6      	; 0x4e8c <AddZeroLead+0x26>
    4e92:	31 97       	sbiw	r30, 0x01	; 1
    4e94:	2e 2f       	mov	r18, r30
    4e96:	28 1b       	sub	r18, r24

	 if (Size>Length){
    4e98:	26 17       	cp	r18, r22
    4e9a:	e0 f5       	brcc	.+120    	; 0x4f14 <AddZeroLead+0xae>
    4e9c:	7e 01       	movw	r14, r28
    4e9e:	08 94       	sec
    4ea0:	e1 1c       	adc	r14, r1
    4ea2:	f1 1c       	adc	r15, r1
    4ea4:	f7 01       	movw	r30, r14
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    4ea6:	be 2c       	mov	r11, r14
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
    4ea8:	90 e3       	ldi	r25, 0x30	; 48
    4eaa:	01 c0       	rjmp	.+2      	; 0x4eae <AddZeroLead+0x48>
    4eac:	91 93       	st	Z+, r25
void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    4eae:	8e 2f       	mov	r24, r30
    4eb0:	8b 19       	sub	r24, r11
    4eb2:	86 17       	cp	r24, r22
    4eb4:	d8 f3       	brcs	.-10     	; 0x4eac <AddZeroLead+0x46>
	         strAdded[i]='0';
	     }strAdded[Size]=0;
    4eb6:	46 2f       	mov	r20, r22
    4eb8:	50 e0       	ldi	r21, 0x00	; 0
    4eba:	ce 01       	movw	r24, r28
    4ebc:	01 96       	adiw	r24, 0x01	; 1
    4ebe:	fc 01       	movw	r30, r24
    4ec0:	e4 0f       	add	r30, r20
    4ec2:	f5 1f       	adc	r31, r21
    4ec4:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    4ec6:	76 2f       	mov	r23, r22
    4ec8:	72 1b       	sub	r23, r18
    4eca:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    4ecc:	30 e0       	ldi	r19, 0x00	; 0
    4ece:	24 1b       	sub	r18, r20
    4ed0:	35 0b       	sbc	r19, r21
    4ed2:	0c c0       	rjmp	.+24     	; 0x4eec <AddZeroLead+0x86>
    4ed4:	e7 2f       	mov	r30, r23
    4ed6:	f0 e0       	ldi	r31, 0x00	; 0
    4ed8:	d6 01       	movw	r26, r12
    4eda:	ae 0f       	add	r26, r30
    4edc:	bf 1f       	adc	r27, r31
    4ede:	e0 0f       	add	r30, r16
    4ee0:	f1 1f       	adc	r31, r17
    4ee2:	e2 0f       	add	r30, r18
    4ee4:	f3 1f       	adc	r31, r19
    4ee6:	80 81       	ld	r24, Z
    4ee8:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    4eea:	7f 5f       	subi	r23, 0xFF	; 255
    4eec:	76 17       	cp	r23, r22
    4eee:	90 f3       	brcs	.-28     	; 0x4ed4 <AddZeroLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    4ef0:	4c 0d       	add	r20, r12
    4ef2:	5d 1d       	adc	r21, r13
    4ef4:	da 01       	movw	r26, r20
    4ef6:	1c 92       	st	X, r1
    4ef8:	f8 01       	movw	r30, r16
    4efa:	04 c0       	rjmp	.+8      	; 0x4f04 <AddZeroLead+0x9e>
	     //Zeroed
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    4efc:	d7 01       	movw	r26, r14
    4efe:	8d 91       	ld	r24, X+
    4f00:	7d 01       	movw	r14, r26
    4f02:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Zeroed
         for(i=0;i<Size;i++){
    4f04:	8e 2d       	mov	r24, r14
    4f06:	8b 19       	sub	r24, r11
    4f08:	86 17       	cp	r24, r22
    4f0a:	c0 f3       	brcs	.-16     	; 0x4efc <AddZeroLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    4f0c:	06 0f       	add	r16, r22
    4f0e:	11 1d       	adc	r17, r1
    4f10:	f8 01       	movw	r30, r16
    4f12:	10 82       	st	Z, r1
	 }
}
    4f14:	6e 96       	adiw	r28, 0x1e	; 30
    4f16:	0f b6       	in	r0, 0x3f	; 63
    4f18:	f8 94       	cli
    4f1a:	de bf       	out	0x3e, r29	; 62
    4f1c:	0f be       	out	0x3f, r0	; 63
    4f1e:	cd bf       	out	0x3d, r28	; 61
    4f20:	cf 91       	pop	r28
    4f22:	df 91       	pop	r29
    4f24:	1f 91       	pop	r17
    4f26:	0f 91       	pop	r16
    4f28:	ff 90       	pop	r15
    4f2a:	ef 90       	pop	r14
    4f2c:	df 90       	pop	r13
    4f2e:	cf 90       	pop	r12
    4f30:	bf 90       	pop	r11
    4f32:	08 95       	ret

00004f34 <GetTotalizerMoney>:
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
void GetTotalizerMoney(char iPumpID,char iGrade, char *Result){
    4f34:	0f 93       	push	r16
    4f36:	1f 93       	push	r17
    4f38:	cf 93       	push	r28
    4f3a:	df 93       	push	r29
    4f3c:	18 2f       	mov	r17, r24
    4f3e:	06 2f       	mov	r16, r22
    4f40:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,13); 
    4f42:	ca 01       	movw	r24, r20
    4f44:	6d e0       	ldi	r22, 0x0D	; 13
    4f46:	0e 94 33 27 	call	0x4e66	; 0x4e66 <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4f4a:	81 2f       	mov	r24, r17
    4f4c:	0e 94 dd 1d 	call	0x3bba	; 0x3bba <GetFIPAddr>
    4f50:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4f52:	88 23       	and	r24, r24
    4f54:	39 f0       	breq	.+14     	; 0x4f64 <GetTotalizerMoney+0x30>
	    FIPAddr=FIPAddr-1;
	    GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4f56:	41 50       	subi	r20, 0x01	; 1
    4f58:	81 e0       	ldi	r24, 0x01	; 1
    4f5a:	61 e0       	ldi	r22, 0x01	; 1
    4f5c:	20 2f       	mov	r18, r16
    4f5e:	8e 01       	movw	r16, r28
    4f60:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <GetTotalizerData>
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}
    4f64:	df 91       	pop	r29
    4f66:	cf 91       	pop	r28
    4f68:	1f 91       	pop	r17
    4f6a:	0f 91       	pop	r16
    4f6c:	08 95       	ret

00004f6e <GetTotalizerVolume>:
     AddZeroLead(Result,10);
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}

void GetTotalizerVolume(char iPumpID,char iGrade,char *Result){
    4f6e:	0f 93       	push	r16
    4f70:	1f 93       	push	r17
    4f72:	cf 93       	push	r28
    4f74:	df 93       	push	r29
    4f76:	18 2f       	mov	r17, r24
    4f78:	06 2f       	mov	r16, r22
    4f7a:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,11);
    4f7c:	ca 01       	movw	r24, r20
    4f7e:	6b e0       	ldi	r22, 0x0B	; 11
    4f80:	0e 94 33 27 	call	0x4e66	; 0x4e66 <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4f84:	81 2f       	mov	r24, r17
    4f86:	0e 94 dd 1d 	call	0x3bba	; 0x3bba <GetFIPAddr>
    4f8a:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4f8c:	88 23       	and	r24, r24
    4f8e:	39 f0       	breq	.+14     	; 0x4f9e <GetTotalizerVolume+0x30>
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4f90:	41 50       	subi	r20, 0x01	; 1
    4f92:	80 e0       	ldi	r24, 0x00	; 0
    4f94:	61 e0       	ldi	r22, 0x01	; 1
    4f96:	20 2f       	mov	r18, r16
    4f98:	8e 01       	movw	r16, r28
    4f9a:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <GetTotalizerData>
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
    4f9e:	df 91       	pop	r29
    4fa0:	cf 91       	pop	r28
    4fa2:	1f 91       	pop	r17
    4fa4:	0f 91       	pop	r16
    4fa6:	08 95       	ret

00004fa8 <GetTransactionMoney>:
void GetTransactionVolume(char iPumpID,char *Result){
     AddZeroLead(Result,10);
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
void GetTransactionMoney(char iPumpID,char *Result){
    4fa8:	ef 92       	push	r14
    4faa:	ff 92       	push	r15
    4fac:	0f 93       	push	r16
    4fae:	1f 93       	push	r17
    4fb0:	08 2f       	mov	r16, r24
    4fb2:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    4fb4:	cb 01       	movw	r24, r22
    4fb6:	6a e0       	ldi	r22, 0x0A	; 10
    4fb8:	0e 94 33 27 	call	0x4e66	; 0x4e66 <AddZeroLead>
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
    4fbc:	00 d0       	rcall	.+0      	; 0x4fbe <GetTransactionMoney+0x16>
    4fbe:	00 d0       	rcall	.+0      	; 0x4fc0 <GetTransactionMoney+0x18>
    4fc0:	00 d0       	rcall	.+0      	; 0x4fc2 <GetTransactionMoney+0x1a>
    4fc2:	ed b7       	in	r30, 0x3d	; 61
    4fc4:	fe b7       	in	r31, 0x3e	; 62
    4fc6:	31 96       	adiw	r30, 0x01	; 1
    4fc8:	ad b7       	in	r26, 0x3d	; 61
    4fca:	be b7       	in	r27, 0x3e	; 62
    4fcc:	12 96       	adiw	r26, 0x02	; 2
    4fce:	fc 92       	st	X, r15
    4fd0:	ee 92       	st	-X, r14
    4fd2:	11 97       	sbiw	r26, 0x01	; 1
    4fd4:	8a e6       	ldi	r24, 0x6A	; 106
    4fd6:	93 e0       	ldi	r25, 0x03	; 3
    4fd8:	93 83       	std	Z+3, r25	; 0x03
    4fda:	82 83       	std	Z+2, r24	; 0x02
    4fdc:	10 e0       	ldi	r17, 0x00	; 0
    4fde:	0f 70       	andi	r16, 0x0F	; 15
    4fe0:	10 70       	andi	r17, 0x00	; 0
    4fe2:	85 e3       	ldi	r24, 0x35	; 53
    4fe4:	90 e0       	ldi	r25, 0x00	; 0
    4fe6:	9c 01       	movw	r18, r24
    4fe8:	02 9f       	mul	r16, r18
    4fea:	c0 01       	movw	r24, r0
    4fec:	03 9f       	mul	r16, r19
    4fee:	90 0d       	add	r25, r0
    4ff0:	12 9f       	mul	r17, r18
    4ff2:	90 0d       	add	r25, r0
    4ff4:	11 24       	eor	r1, r1
    4ff6:	89 54       	subi	r24, 0x49	; 73
    4ff8:	98 4f       	sbci	r25, 0xF8	; 248
    4ffa:	95 83       	std	Z+5, r25	; 0x05
    4ffc:	84 83       	std	Z+4, r24	; 0x04
    4ffe:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    5002:	8d b7       	in	r24, 0x3d	; 61
    5004:	9e b7       	in	r25, 0x3e	; 62
    5006:	06 96       	adiw	r24, 0x06	; 6
    5008:	0f b6       	in	r0, 0x3f	; 63
    500a:	f8 94       	cli
    500c:	9e bf       	out	0x3e, r25	; 62
    500e:	0f be       	out	0x3f, r0	; 63
    5010:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}
    5012:	1f 91       	pop	r17
    5014:	0f 91       	pop	r16
    5016:	ff 90       	pop	r15
    5018:	ef 90       	pop	r14
    501a:	08 95       	ret

0000501c <GetTransactionVolume>:
     }
*/
     FormatDecimal(Result,CurrentDecimal);
}

void GetTransactionVolume(char iPumpID,char *Result){
    501c:	ef 92       	push	r14
    501e:	ff 92       	push	r15
    5020:	0f 93       	push	r16
    5022:	1f 93       	push	r17
    5024:	08 2f       	mov	r16, r24
    5026:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    5028:	cb 01       	movw	r24, r22
    502a:	6a e0       	ldi	r22, 0x0A	; 10
    502c:	0e 94 33 27 	call	0x4e66	; 0x4e66 <AddZeroLead>
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
    5030:	00 d0       	rcall	.+0      	; 0x5032 <GetTransactionVolume+0x16>
    5032:	00 d0       	rcall	.+0      	; 0x5034 <GetTransactionVolume+0x18>
    5034:	00 d0       	rcall	.+0      	; 0x5036 <GetTransactionVolume+0x1a>
    5036:	ed b7       	in	r30, 0x3d	; 61
    5038:	fe b7       	in	r31, 0x3e	; 62
    503a:	31 96       	adiw	r30, 0x01	; 1
    503c:	ad b7       	in	r26, 0x3d	; 61
    503e:	be b7       	in	r27, 0x3e	; 62
    5040:	12 96       	adiw	r26, 0x02	; 2
    5042:	fc 92       	st	X, r15
    5044:	ee 92       	st	-X, r14
    5046:	11 97       	sbiw	r26, 0x01	; 1
    5048:	8d e6       	ldi	r24, 0x6D	; 109
    504a:	93 e0       	ldi	r25, 0x03	; 3
    504c:	93 83       	std	Z+3, r25	; 0x03
    504e:	82 83       	std	Z+2, r24	; 0x02
    5050:	10 e0       	ldi	r17, 0x00	; 0
    5052:	0f 70       	andi	r16, 0x0F	; 15
    5054:	10 70       	andi	r17, 0x00	; 0
    5056:	85 e3       	ldi	r24, 0x35	; 53
    5058:	90 e0       	ldi	r25, 0x00	; 0
    505a:	9c 01       	movw	r18, r24
    505c:	02 9f       	mul	r16, r18
    505e:	c0 01       	movw	r24, r0
    5060:	03 9f       	mul	r16, r19
    5062:	90 0d       	add	r25, r0
    5064:	12 9f       	mul	r17, r18
    5066:	90 0d       	add	r25, r0
    5068:	11 24       	eor	r1, r1
    506a:	82 55       	subi	r24, 0x52	; 82
    506c:	98 4f       	sbci	r25, 0xF8	; 248
    506e:	95 83       	std	Z+5, r25	; 0x05
    5070:	84 83       	std	Z+4, r24	; 0x04
    5072:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    5076:	8d b7       	in	r24, 0x3d	; 61
    5078:	9e b7       	in	r25, 0x3e	; 62
    507a:	06 96       	adiw	r24, 0x06	; 6
    507c:	0f b6       	in	r0, 0x3f	; 63
    507e:	f8 94       	cli
    5080:	9e bf       	out	0x3e, r25	; 62
    5082:	0f be       	out	0x3f, r0	; 63
    5084:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
    5086:	1f 91       	pop	r17
    5088:	0f 91       	pop	r16
    508a:	ff 90       	pop	r15
    508c:	ef 90       	pop	r14
    508e:	08 95       	ret

00005090 <SetTotalizerData>:
			  }
		  }
	 }
}

void SetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "00000000"
    5090:	af 92       	push	r10
    5092:	bf 92       	push	r11
    5094:	cf 92       	push	r12
    5096:	df 92       	push	r13
    5098:	ef 92       	push	r14
    509a:	ff 92       	push	r15
    509c:	0f 93       	push	r16
    509e:	1f 93       	push	r17
    50a0:	df 93       	push	r29
    50a2:	cf 93       	push	r28
    50a4:	cd b7       	in	r28, 0x3d	; 61
    50a6:	de b7       	in	r29, 0x3e	; 62
    50a8:	65 97       	sbiw	r28, 0x15	; 21
    50aa:	0f b6       	in	r0, 0x3f	; 63
    50ac:	f8 94       	cli
    50ae:	de bf       	out	0x3e, r29	; 62
    50b0:	0f be       	out	0x3f, r0	; 63
    50b2:	cd bf       	out	0x3d, r28	; 61
    50b4:	d8 2e       	mov	r13, r24
    50b6:	c6 2e       	mov	r12, r22
    50b8:	b4 2e       	mov	r11, r20
    50ba:	a2 2e       	mov	r10, r18
     char rawValue[6],iPumpAddr,iGrade;
	 char strPValue[15];
	 char Idx;
	 char strSend[30];
	 //Convert String to RawData
	 if (strlen(strValue)<=12){
    50bc:	d8 01       	movw	r26, r16
    50be:	0d 90       	ld	r0, X+
    50c0:	00 20       	and	r0, r0
    50c2:	e9 f7       	brne	.-6      	; 0x50be <SetTotalizerData+0x2e>
    50c4:	11 97       	sbiw	r26, 0x01	; 1
    50c6:	a0 1b       	sub	r26, r16
    50c8:	b1 0b       	sbc	r27, r17
    50ca:	87 e0       	ldi	r24, 0x07	; 7
    50cc:	e8 2e       	mov	r14, r24
    50ce:	f1 2c       	mov	r15, r1
    50d0:	ec 0e       	add	r14, r28
    50d2:	fd 1e       	adc	r15, r29
    50d4:	ad 30       	cpi	r26, 0x0D	; 13
    50d6:	b1 05       	cpc	r27, r1
    50d8:	58 f5       	brcc	.+86     	; 0x5130 <SetTotalizerData+0xa0>
	     sprintf_P(strPValue,PSTR("%s"),strValue);
    50da:	00 d0       	rcall	.+0      	; 0x50dc <SetTotalizerData+0x4c>
    50dc:	00 d0       	rcall	.+0      	; 0x50de <SetTotalizerData+0x4e>
    50de:	00 d0       	rcall	.+0      	; 0x50e0 <SetTotalizerData+0x50>
    50e0:	ed b7       	in	r30, 0x3d	; 61
    50e2:	fe b7       	in	r31, 0x3e	; 62
    50e4:	31 96       	adiw	r30, 0x01	; 1
    50e6:	ad b7       	in	r26, 0x3d	; 61
    50e8:	be b7       	in	r27, 0x3e	; 62
    50ea:	12 96       	adiw	r26, 0x02	; 2
    50ec:	fc 92       	st	X, r15
    50ee:	ee 92       	st	-X, r14
    50f0:	11 97       	sbiw	r26, 0x01	; 1
    50f2:	8f ee       	ldi	r24, 0xEF	; 239
    50f4:	95 e0       	ldi	r25, 0x05	; 5
    50f6:	93 83       	std	Z+3, r25	; 0x03
    50f8:	82 83       	std	Z+2, r24	; 0x02
    50fa:	15 83       	std	Z+5, r17	; 0x05
    50fc:	04 83       	std	Z+4, r16	; 0x04
    50fe:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		 if (strlen(strPValue)<12)AddZeroLead(strPValue,12);
    5102:	f7 01       	movw	r30, r14
    5104:	01 90       	ld	r0, Z+
    5106:	00 20       	and	r0, r0
    5108:	e9 f7       	brne	.-6      	; 0x5104 <SetTotalizerData+0x74>
    510a:	31 97       	sbiw	r30, 0x01	; 1
    510c:	ee 19       	sub	r30, r14
    510e:	ff 09       	sbc	r31, r15
    5110:	6d b7       	in	r22, 0x3d	; 61
    5112:	7e b7       	in	r23, 0x3e	; 62
    5114:	6a 5f       	subi	r22, 0xFA	; 250
    5116:	7f 4f       	sbci	r23, 0xFF	; 255
    5118:	0f b6       	in	r0, 0x3f	; 63
    511a:	f8 94       	cli
    511c:	7e bf       	out	0x3e, r23	; 62
    511e:	0f be       	out	0x3f, r0	; 63
    5120:	6d bf       	out	0x3d, r22	; 61
    5122:	3c 97       	sbiw	r30, 0x0c	; 12
    5124:	a0 f4       	brcc	.+40     	; 0x514e <SetTotalizerData+0xbe>
    5126:	c7 01       	movw	r24, r14
    5128:	6c e0       	ldi	r22, 0x0C	; 12
    512a:	0e 94 33 27 	call	0x4e66	; 0x4e66 <AddZeroLead>
    512e:	0f c0       	rjmp	.+30     	; 0x514e <SetTotalizerData+0xbe>
    5130:	8a 2f       	mov	r24, r26
    5132:	8c 50       	subi	r24, 0x0C	; 12
    5134:	f8 01       	movw	r30, r16
    5136:	e8 0f       	add	r30, r24
    5138:	f1 1d       	adc	r31, r1
    513a:	d7 01       	movw	r26, r14
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    513c:	9e 01       	movw	r18, r28
    513e:	2d 5e       	subi	r18, 0xED	; 237
    5140:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    5142:	81 91       	ld	r24, Z+
    5144:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5146:	a2 17       	cp	r26, r18
    5148:	b3 07       	cpc	r27, r19
    514a:	d9 f7       	brne	.-10     	; 0x5142 <SetTotalizerData+0xb2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    514c:	1b 8a       	std	Y+19, r1	; 0x13
	 else {//Lebih dari 8: 0123456789
	     Idx=strlen(strValue)-12;
	     StrPosCopy(strValue,strPValue,Idx,12);
	 }

	 iPumpAddr=(xPumpAddr&0x0F);
    514e:	0b 2d       	mov	r16, r11
    5150:	0f 70       	andi	r16, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    5152:	1a 2d       	mov	r17, r10
    5154:	11 50       	subi	r17, 0x01	; 1
    5156:	16 30       	cpi	r17, 0x06	; 6
    5158:	08 f0       	brcs	.+2      	; 0x515c <SetTotalizerData+0xcc>
    515a:	10 e0       	ldi	r17, 0x00	; 0
	     iGrade=xGradeAddr-1;
	 StrToRaw(strPValue,rawValue);
    515c:	ce 01       	movw	r24, r28
    515e:	07 96       	adiw	r24, 0x07	; 7
    5160:	7e 01       	movw	r14, r28
    5162:	08 94       	sec
    5164:	e1 1c       	adc	r14, r1
    5166:	f1 1c       	adc	r15, r1
    5168:	b7 01       	movw	r22, r14
    516a:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <StrToRaw>

	 if (TType==TVOLUME)eeprom_write_block((const void*)&rawValue,(void*)&(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    516e:	dd 20       	and	r13, r13
    5170:	d9 f4       	brne	.+54     	; 0x51a8 <SetTotalizerData+0x118>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    5172:	84 e2       	ldi	r24, 0x24	; 36
    5174:	08 9f       	mul	r16, r24
    5176:	c0 01       	movw	r24, r0
    5178:	11 24       	eor	r1, r1
    517a:	4c 2d       	mov	r20, r12
    517c:	50 e0       	ldi	r21, 0x00	; 0
    517e:	20 e2       	ldi	r18, 0x20	; 32
    5180:	31 e0       	ldi	r19, 0x01	; 1
    5182:	d9 01       	movw	r26, r18
    5184:	4a 9f       	mul	r20, r26
    5186:	90 01       	movw	r18, r0
    5188:	4b 9f       	mul	r20, r27
    518a:	30 0d       	add	r19, r0
    518c:	5a 9f       	mul	r21, r26
    518e:	30 0d       	add	r19, r0
    5190:	11 24       	eor	r1, r1
    5192:	82 0f       	add	r24, r18
    5194:	93 1f       	adc	r25, r19
    5196:	26 e0       	ldi	r18, 0x06	; 6
    5198:	12 9f       	mul	r17, r18
    519a:	90 01       	movw	r18, r0
    519c:	11 24       	eor	r1, r1
    519e:	82 0f       	add	r24, r18
    51a0:	93 1f       	adc	r25, r19
    51a2:	8d 53       	subi	r24, 0x3D	; 61
    51a4:	9c 4f       	sbci	r25, 0xFC	; 252
    51a6:	1d c0       	rjmp	.+58     	; 0x51e2 <SetTotalizerData+0x152>
	 else 
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    51a8:	b1 e0       	ldi	r27, 0x01	; 1
    51aa:	db 16       	cp	r13, r27
    51ac:	09 f5       	brne	.+66     	; 0x51f0 <SetTotalizerData+0x160>
    51ae:	84 e2       	ldi	r24, 0x24	; 36
    51b0:	08 9f       	mul	r16, r24
    51b2:	c0 01       	movw	r24, r0
    51b4:	11 24       	eor	r1, r1
    51b6:	4c 2d       	mov	r20, r12
    51b8:	50 e0       	ldi	r21, 0x00	; 0
    51ba:	20 e2       	ldi	r18, 0x20	; 32
    51bc:	31 e0       	ldi	r19, 0x01	; 1
    51be:	b9 01       	movw	r22, r18
    51c0:	46 9f       	mul	r20, r22
    51c2:	90 01       	movw	r18, r0
    51c4:	47 9f       	mul	r20, r23
    51c6:	30 0d       	add	r19, r0
    51c8:	56 9f       	mul	r21, r22
    51ca:	30 0d       	add	r19, r0
    51cc:	11 24       	eor	r1, r1
    51ce:	82 0f       	add	r24, r18
    51d0:	93 1f       	adc	r25, r19
    51d2:	26 e0       	ldi	r18, 0x06	; 6
    51d4:	12 9f       	mul	r17, r18
    51d6:	90 01       	movw	r18, r0
    51d8:	11 24       	eor	r1, r1
    51da:	82 0f       	add	r24, r18
    51dc:	93 1f       	adc	r25, r19
    51de:	8d 5f       	subi	r24, 0xFD	; 253
    51e0:	99 4f       	sbci	r25, 0xF9	; 249
    51e2:	b7 01       	movw	r22, r14
    51e4:	46 e0       	ldi	r20, 0x06	; 6
    51e6:	50 e0       	ldi	r21, 0x00	; 0
    51e8:	20 e0       	ldi	r18, 0x00	; 0
    51ea:	33 e1       	ldi	r19, 0x13	; 19
    51ec:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
}
    51f0:	65 96       	adiw	r28, 0x15	; 21
    51f2:	0f b6       	in	r0, 0x3f	; 63
    51f4:	f8 94       	cli
    51f6:	de bf       	out	0x3e, r29	; 62
    51f8:	0f be       	out	0x3f, r0	; 63
    51fa:	cd bf       	out	0x3d, r28	; 61
    51fc:	cf 91       	pop	r28
    51fe:	df 91       	pop	r29
    5200:	1f 91       	pop	r17
    5202:	0f 91       	pop	r16
    5204:	ff 90       	pop	r15
    5206:	ef 90       	pop	r14
    5208:	df 90       	pop	r13
    520a:	cf 90       	pop	r12
    520c:	bf 90       	pop	r11
    520e:	af 90       	pop	r10
    5210:	08 95       	ret

00005212 <SaveTotalizerCurrentToLast>:
	 }Dest[12]=0;
}

//SetTotalizerData(TVOLUME,TOTALIZER_NOW,1,1,strVolume)

void SaveTotalizerCurrentToLast(){
    5212:	4f 92       	push	r4
    5214:	5f 92       	push	r5
    5216:	7f 92       	push	r7
    5218:	8f 92       	push	r8
    521a:	9f 92       	push	r9
    521c:	af 92       	push	r10
    521e:	bf 92       	push	r11
    5220:	cf 92       	push	r12
    5222:	df 92       	push	r13
    5224:	ef 92       	push	r14
    5226:	ff 92       	push	r15
    5228:	0f 93       	push	r16
    522a:	1f 93       	push	r17
    522c:	df 93       	push	r29
    522e:	cf 93       	push	r28
    5230:	cd b7       	in	r28, 0x3d	; 61
    5232:	de b7       	in	r29, 0x3e	; 62
    5234:	2f 97       	sbiw	r28, 0x0f	; 15
    5236:	0f b6       	in	r0, 0x3f	; 63
    5238:	f8 94       	cli
    523a:	de bf       	out	0x3e, r29	; 62
    523c:	0f be       	out	0x3f, r0	; 63
    523e:	cd bf       	out	0x3d, r28	; 61
    5240:	77 24       	eor	r7, r7
    5242:	73 94       	inc	r7
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    5244:	4e 01       	movw	r8, r28
    5246:	08 94       	sec
    5248:	81 1c       	adc	r8, r1
    524a:	91 1c       	adc	r9, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    524c:	90 e1       	ldi	r25, 0x10	; 16
    524e:	49 2e       	mov	r4, r25
    5250:	51 2c       	mov	r5, r1
    5252:	4c 0e       	add	r4, r28
    5254:	5d 1e       	adc	r5, r29
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    5256:	87 2d       	mov	r24, r7
    5258:	0e 94 dd 1d 	call	0x3bba	; 0x3bba <GetFIPAddr>
		  if (FIPAddr>0){
    525c:	88 23       	and	r24, r24
    525e:	91 f1       	breq	.+100    	; 0x52c4 <SaveTotalizerCurrentToLast+0xb2>
		      FIPAddr=FIPAddr-1;
    5260:	a8 2e       	mov	r10, r24
    5262:	aa 94       	dec	r10
    5264:	bb 24       	eor	r11, r11
    5266:	b3 94       	inc	r11
    5268:	2a c0       	rjmp	.+84     	; 0x52be <SaveTotalizerCurrentToLast+0xac>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    526a:	f7 01       	movw	r30, r14
    526c:	11 92       	st	Z+, r1
    526e:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5270:	e4 15       	cp	r30, r4
    5272:	f5 05       	cpc	r31, r5
    5274:	d1 f7       	brne	.-12     	; 0x526a <SaveTotalizerCurrentToLast+0x58>
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    5276:	80 e0       	ldi	r24, 0x00	; 0
    5278:	61 e0       	ldi	r22, 0x01	; 1
    527a:	4a 2d       	mov	r20, r10
    527c:	2b 2d       	mov	r18, r11
    527e:	84 01       	movw	r16, r8
    5280:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <GetTotalizerData>
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    5284:	80 e0       	ldi	r24, 0x00	; 0
    5286:	60 e0       	ldi	r22, 0x00	; 0
    5288:	4a 2d       	mov	r20, r10
    528a:	2b 2d       	mov	r18, r11
    528c:	0e 94 48 28 	call	0x5090	; 0x5090 <SetTotalizerData>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    5290:	f6 01       	movw	r30, r12
    5292:	11 92       	st	Z+, r1
    5294:	6f 01       	movw	r12, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5296:	ee 15       	cp	r30, r14
    5298:	ff 05       	cpc	r31, r15
    529a:	d1 f7       	brne	.-12     	; 0x5290 <SaveTotalizerCurrentToLast+0x7e>
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    529c:	81 e0       	ldi	r24, 0x01	; 1
    529e:	61 e0       	ldi	r22, 0x01	; 1
    52a0:	4a 2d       	mov	r20, r10
    52a2:	2b 2d       	mov	r18, r11
    52a4:	84 01       	movw	r16, r8
    52a6:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <GetTotalizerData>
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    52aa:	81 e0       	ldi	r24, 0x01	; 1
    52ac:	60 e0       	ldi	r22, 0x00	; 0
    52ae:	4a 2d       	mov	r20, r10
    52b0:	2b 2d       	mov	r18, r11
    52b2:	0e 94 48 28 	call	0x5090	; 0x5090 <SetTotalizerData>
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    52b6:	b3 94       	inc	r11
    52b8:	f7 e0       	ldi	r31, 0x07	; 7
    52ba:	bf 16       	cp	r11, r31
    52bc:	19 f0       	breq	.+6      	; 0x52c4 <SaveTotalizerCurrentToLast+0xb2>
    52be:	64 01       	movw	r12, r8
    52c0:	74 01       	movw	r14, r8
    52c2:	d3 cf       	rjmp	.-90     	; 0x526a <SaveTotalizerCurrentToLast+0x58>
void SaveTotalizerCurrentToLast(){
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
    52c4:	73 94       	inc	r7
    52c6:	81 e1       	ldi	r24, 0x11	; 17
    52c8:	78 16       	cp	r7, r24
    52ca:	29 f6       	brne	.-118    	; 0x5256 <SaveTotalizerCurrentToLast+0x44>
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    52cc:	2f 96       	adiw	r28, 0x0f	; 15
    52ce:	0f b6       	in	r0, 0x3f	; 63
    52d0:	f8 94       	cli
    52d2:	de bf       	out	0x3e, r29	; 62
    52d4:	0f be       	out	0x3f, r0	; 63
    52d6:	cd bf       	out	0x3d, r28	; 61
    52d8:	cf 91       	pop	r28
    52da:	df 91       	pop	r29
    52dc:	1f 91       	pop	r17
    52de:	0f 91       	pop	r16
    52e0:	ff 90       	pop	r15
    52e2:	ef 90       	pop	r14
    52e4:	df 90       	pop	r13
    52e6:	cf 90       	pop	r12
    52e8:	bf 90       	pop	r11
    52ea:	af 90       	pop	r10
    52ec:	9f 90       	pop	r9
    52ee:	8f 90       	pop	r8
    52f0:	7f 90       	pop	r7
    52f2:	5f 90       	pop	r5
    52f4:	4f 90       	pop	r4
    52f6:	08 95       	ret

000052f8 <ResetTotalizer>:


//-------------------Totalizer-----------------------------------------
//TAddr{TOTALIZER_LAST,TOTALIZER_NOW}
//TType:{TNONE,TVOLUME,TMONEY};
void ResetTotalizer(char TAddr){//Clear All TotalizerData;
    52f8:	af 92       	push	r10
    52fa:	bf 92       	push	r11
    52fc:	cf 92       	push	r12
    52fe:	df 92       	push	r13
    5300:	ef 92       	push	r14
    5302:	ff 92       	push	r15
    5304:	0f 93       	push	r16
    5306:	1f 93       	push	r17
    5308:	df 93       	push	r29
    530a:	cf 93       	push	r28
    530c:	cd b7       	in	r28, 0x3d	; 61
    530e:	de b7       	in	r29, 0x3e	; 62
    5310:	29 97       	sbiw	r28, 0x09	; 9
    5312:	0f b6       	in	r0, 0x3f	; 63
    5314:	f8 94       	cli
    5316:	de bf       	out	0x3e, r29	; 62
    5318:	0f be       	out	0x3f, r0	; 63
    531a:	cd bf       	out	0x3d, r28	; 61
    531c:	a8 2e       	mov	r10, r24
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
    531e:	00 d0       	rcall	.+0      	; 0x5320 <ResetTotalizer+0x28>
    5320:	00 d0       	rcall	.+0      	; 0x5322 <ResetTotalizer+0x2a>
    5322:	6e 01       	movw	r12, r28
    5324:	08 94       	sec
    5326:	c1 1c       	adc	r12, r1
    5328:	d1 1c       	adc	r13, r1
    532a:	ed b7       	in	r30, 0x3d	; 61
    532c:	fe b7       	in	r31, 0x3e	; 62
    532e:	d2 82       	std	Z+2, r13	; 0x02
    5330:	c1 82       	std	Z+1, r12	; 0x01
    5332:	82 ef       	ldi	r24, 0xF2	; 242
    5334:	95 e0       	ldi	r25, 0x05	; 5
    5336:	94 83       	std	Z+4, r25	; 0x04
    5338:	83 83       	std	Z+3, r24	; 0x03
    533a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    533e:	ee 24       	eor	r14, r14
    5340:	e3 94       	inc	r14
    5342:	0f 90       	pop	r0
    5344:	0f 90       	pop	r0
    5346:	0f 90       	pop	r0
    5348:	0f 90       	pop	r0
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    534a:	8e 2d       	mov	r24, r14
    534c:	0e 94 dd 1d 	call	0x3bba	; 0x3bba <GetFIPAddr>
		  if (FIPAddr>0){
    5350:	88 23       	and	r24, r24
    5352:	a9 f0       	breq	.+42     	; 0x537e <ResetTotalizer+0x86>
		      FIPAddr=FIPAddr-1;
    5354:	b8 2e       	mov	r11, r24
    5356:	ba 94       	dec	r11
    5358:	ff 24       	eor	r15, r15
    535a:	f3 94       	inc	r15
			  for(iGrade=1;iGrade<=6;iGrade++){
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
    535c:	80 e0       	ldi	r24, 0x00	; 0
    535e:	6a 2d       	mov	r22, r10
    5360:	4b 2d       	mov	r20, r11
    5362:	2f 2d       	mov	r18, r15
    5364:	86 01       	movw	r16, r12
    5366:	0e 94 48 28 	call	0x5090	; 0x5090 <SetTotalizerData>
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
    536a:	81 e0       	ldi	r24, 0x01	; 1
    536c:	6a 2d       	mov	r22, r10
    536e:	4b 2d       	mov	r20, r11
    5370:	2f 2d       	mov	r18, r15
    5372:	0e 94 48 28 	call	0x5090	; 0x5090 <SetTotalizerData>
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    5376:	f3 94       	inc	r15
    5378:	f7 e0       	ldi	r31, 0x07	; 7
    537a:	ff 16       	cp	r15, r31
    537c:	79 f7       	brne	.-34     	; 0x535c <ResetTotalizer+0x64>
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
    537e:	e3 94       	inc	r14
    5380:	81 e1       	ldi	r24, 0x11	; 17
    5382:	e8 16       	cp	r14, r24
    5384:	11 f7       	brne	.-60     	; 0x534a <ResetTotalizer+0x52>
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    5386:	29 96       	adiw	r28, 0x09	; 9
    5388:	0f b6       	in	r0, 0x3f	; 63
    538a:	f8 94       	cli
    538c:	de bf       	out	0x3e, r29	; 62
    538e:	0f be       	out	0x3f, r0	; 63
    5390:	cd bf       	out	0x3d, r28	; 61
    5392:	cf 91       	pop	r28
    5394:	df 91       	pop	r29
    5396:	1f 91       	pop	r17
    5398:	0f 91       	pop	r16
    539a:	ff 90       	pop	r15
    539c:	ef 90       	pop	r14
    539e:	df 90       	pop	r13
    53a0:	cf 90       	pop	r12
    53a2:	bf 90       	pop	r11
    53a4:	af 90       	pop	r10
    53a6:	08 95       	ret

000053a8 <AddZeroLag>:
	         String[i]=strAdded[i];
	     }String[Size]=0;
	 }
}

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
    53a8:	cf 93       	push	r28
    53aa:	df 93       	push	r29
    53ac:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    53ae:	dc 01       	movw	r26, r24
    53b0:	0d 90       	ld	r0, X+
    53b2:	00 20       	and	r0, r0
    53b4:	e9 f7       	brne	.-6      	; 0x53b0 <AddZeroLag+0x8>
    53b6:	11 97       	sbiw	r26, 0x01	; 1
    53b8:	a8 1b       	sub	r26, r24
    53ba:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    53bc:	a6 17       	cp	r26, r22
    53be:	60 f4       	brcc	.+24     	; 0x53d8 <AddZeroLag+0x30>
    53c0:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]='0';
    53c2:	90 e3       	ldi	r25, 0x30	; 48
    53c4:	fe 01       	movw	r30, r28
    53c6:	e8 0f       	add	r30, r24
    53c8:	f1 1d       	adc	r31, r1
    53ca:	90 83       	st	Z, r25

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    53cc:	8f 5f       	subi	r24, 0xFF	; 255
    53ce:	86 17       	cp	r24, r22
    53d0:	c8 f3       	brcs	.-14     	; 0x53c4 <AddZeroLag+0x1c>
	    String[i]='0';
	 }String[Size]=0;
    53d2:	c6 0f       	add	r28, r22
    53d4:	d1 1d       	adc	r29, r1
    53d6:	18 82       	st	Y, r1
  }
}
    53d8:	df 91       	pop	r29
    53da:	cf 91       	pop	r28
    53dc:	08 95       	ret

000053de <StrCalc>:
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    53de:	3f 92       	push	r3
    53e0:	4f 92       	push	r4
    53e2:	5f 92       	push	r5
    53e4:	6f 92       	push	r6
    53e6:	7f 92       	push	r7
    53e8:	8f 92       	push	r8
    53ea:	9f 92       	push	r9
    53ec:	af 92       	push	r10
    53ee:	bf 92       	push	r11
    53f0:	cf 92       	push	r12
    53f2:	df 92       	push	r13
    53f4:	ef 92       	push	r14
    53f6:	ff 92       	push	r15
    53f8:	0f 93       	push	r16
    53fa:	1f 93       	push	r17
    53fc:	df 93       	push	r29
    53fe:	cf 93       	push	r28
    5400:	cd b7       	in	r28, 0x3d	; 61
    5402:	de b7       	in	r29, 0x3e	; 62
    5404:	c8 55       	subi	r28, 0x58	; 88
    5406:	d0 40       	sbci	r29, 0x00	; 0
    5408:	0f b6       	in	r0, 0x3f	; 63
    540a:	f8 94       	cli
    540c:	de bf       	out	0x3e, r29	; 62
    540e:	0f be       	out	0x3f, r0	; 63
    5410:	cd bf       	out	0x3d, r28	; 61
    5412:	68 2e       	mov	r6, r24
    5414:	67 96       	adiw	r28, 0x17	; 23
    5416:	7f af       	std	Y+63, r23	; 0x3f
    5418:	6e af       	std	Y+62, r22	; 0x3e
    541a:	67 97       	sbiw	r28, 0x17	; 23
    541c:	69 96       	adiw	r28, 0x19	; 25
    541e:	5f af       	std	Y+63, r21	; 0x3f
    5420:	4e af       	std	Y+62, r20	; 0x3e
    5422:	69 97       	sbiw	r28, 0x19	; 25
    5424:	59 01       	movw	r10, r18
    5426:	fe 01       	movw	r30, r28
    5428:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    542a:	ce 01       	movw	r24, r28
    542c:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    542e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5430:	e8 17       	cp	r30, r24
    5432:	f9 07       	cpc	r31, r25
    5434:	e1 f7       	brne	.-8      	; 0x542e <StrCalc+0x50>
	     strMemory[i]=data;
    5436:	ce 01       	movw	r24, r28
    5438:	89 96       	adiw	r24, 0x29	; 41
    543a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    543c:	e8 17       	cp	r30, r24
    543e:	f9 07       	cpc	r31, r25
    5440:	e1 f7       	brne	.-8      	; 0x543a <StrCalc+0x5c>
    5442:	fe 01       	movw	r30, r28
    5444:	fd 96       	adiw	r30, 0x3d	; 61
	     strMemory[i]=data;
    5446:	cf 01       	movw	r24, r30
    5448:	44 96       	adiw	r24, 0x14	; 20
    544a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    544c:	e8 17       	cp	r30, r24
    544e:	f9 07       	cpc	r31, r25
    5450:	e1 f7       	brne	.-8      	; 0x544a <StrCalc+0x6c>
	 FillChar(tmpB,sizeof(tmpB),0);
	 FillChar(Result,sizeof(Result),0);
                                            // -5    -5     5    5
	                                        // -6 -   6 -  -6 -  6 -
                                            // -5+6   
	 sprintf_P(tmpA,PSTR("%s"),strA);       // 
    5452:	00 d0       	rcall	.+0      	; 0x5454 <StrCalc+0x76>
    5454:	00 d0       	rcall	.+0      	; 0x5456 <StrCalc+0x78>
    5456:	00 d0       	rcall	.+0      	; 0x5458 <StrCalc+0x7a>
    5458:	ed b7       	in	r30, 0x3d	; 61
    545a:	fe b7       	in	r31, 0x3e	; 62
    545c:	31 96       	adiw	r30, 0x01	; 1
    545e:	8e 01       	movw	r16, r28
    5460:	0f 5f       	subi	r16, 0xFF	; 255
    5462:	1f 4f       	sbci	r17, 0xFF	; 255
    5464:	ad b7       	in	r26, 0x3d	; 61
    5466:	be b7       	in	r27, 0x3e	; 62
    5468:	12 96       	adiw	r26, 0x02	; 2
    546a:	1c 93       	st	X, r17
    546c:	0e 93       	st	-X, r16
    546e:	11 97       	sbiw	r26, 0x01	; 1
    5470:	88 eb       	ldi	r24, 0xB8	; 184
    5472:	95 e0       	ldi	r25, 0x05	; 5
    5474:	93 83       	std	Z+3, r25	; 0x03
    5476:	82 83       	std	Z+2, r24	; 0x02
    5478:	67 96       	adiw	r28, 0x17	; 23
    547a:	2e ad       	ldd	r18, Y+62	; 0x3e
    547c:	3f ad       	ldd	r19, Y+63	; 0x3f
    547e:	67 97       	sbiw	r28, 0x17	; 23
    5480:	35 83       	std	Z+5, r19	; 0x05
    5482:	24 83       	std	Z+4, r18	; 0x04
    5484:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	 sprintf_P(tmpB,PSTR("%s"),strB);  
    5488:	ed b7       	in	r30, 0x3d	; 61
    548a:	fe b7       	in	r31, 0x3e	; 62
    548c:	31 96       	adiw	r30, 0x01	; 1
    548e:	ce 01       	movw	r24, r28
    5490:	45 96       	adiw	r24, 0x15	; 21
    5492:	ad b7       	in	r26, 0x3d	; 61
    5494:	be b7       	in	r27, 0x3e	; 62
    5496:	12 96       	adiw	r26, 0x02	; 2
    5498:	9c 93       	st	X, r25
    549a:	8e 93       	st	-X, r24
    549c:	11 97       	sbiw	r26, 0x01	; 1
    549e:	85 eb       	ldi	r24, 0xB5	; 181
    54a0:	95 e0       	ldi	r25, 0x05	; 5
    54a2:	93 83       	std	Z+3, r25	; 0x03
    54a4:	82 83       	std	Z+2, r24	; 0x02
    54a6:	69 96       	adiw	r28, 0x19	; 25
    54a8:	2e ad       	ldd	r18, Y+62	; 0x3e
    54aa:	3f ad       	ldd	r19, Y+63	; 0x3f
    54ac:	69 97       	sbiw	r28, 0x19	; 25
    54ae:	35 83       	std	Z+5, r19	; 0x05
    54b0:	24 83       	std	Z+4, r18	; 0x04
    54b2:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>

     if (IsMinus(tmpA)==True){
    54b6:	8d b7       	in	r24, 0x3d	; 61
    54b8:	9e b7       	in	r25, 0x3e	; 62
    54ba:	06 96       	adiw	r24, 0x06	; 6
    54bc:	0f b6       	in	r0, 0x3f	; 63
    54be:	f8 94       	cli
    54c0:	9e bf       	out	0x3e, r25	; 62
    54c2:	0f be       	out	0x3f, r0	; 63
    54c4:	8d bf       	out	0x3d, r24	; 61
    54c6:	c8 01       	movw	r24, r16
    54c8:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <IsMinus>
    54cc:	81 30       	cpi	r24, 0x01	; 1
    54ce:	21 f0       	breq	.+8      	; 0x54d8 <StrCalc+0xfa>
    54d0:	65 96       	adiw	r28, 0x15	; 21
    54d2:	1f ae       	std	Y+63, r1	; 0x3f
    54d4:	65 97       	sbiw	r28, 0x15	; 21
    54d6:	07 c0       	rjmp	.+14     	; 0x54e6 <StrCalc+0x108>
	     RemoveMinus(tmpA);
    54d8:	c8 01       	movw	r24, r16
    54da:	0e 94 ef 23 	call	0x47de	; 0x47de <RemoveMinus>
    54de:	91 e0       	ldi	r25, 0x01	; 1
    54e0:	65 96       	adiw	r28, 0x15	; 21
    54e2:	9f af       	std	Y+63, r25	; 0x3f
    54e4:	65 97       	sbiw	r28, 0x15	; 21
		 IsMinA=True;
	 }
     if (IsMinus(tmpB)==True){
    54e6:	8e 01       	movw	r16, r28
    54e8:	0b 5e       	subi	r16, 0xEB	; 235
    54ea:	1f 4f       	sbci	r17, 0xFF	; 255
    54ec:	c8 01       	movw	r24, r16
    54ee:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <IsMinus>
    54f2:	81 30       	cpi	r24, 0x01	; 1
    54f4:	21 f0       	breq	.+8      	; 0x54fe <StrCalc+0x120>
    54f6:	64 96       	adiw	r28, 0x14	; 20
    54f8:	1f ae       	std	Y+63, r1	; 0x3f
    54fa:	64 97       	sbiw	r28, 0x14	; 20
    54fc:	07 c0       	rjmp	.+14     	; 0x550c <StrCalc+0x12e>
	     RemoveMinus(tmpB);
    54fe:	c8 01       	movw	r24, r16
    5500:	0e 94 ef 23 	call	0x47de	; 0x47de <RemoveMinus>
    5504:	a1 e0       	ldi	r26, 0x01	; 1
    5506:	64 96       	adiw	r28, 0x14	; 20
    5508:	af af       	std	Y+63, r26	; 0x3f
    550a:	64 97       	sbiw	r28, 0x14	; 20
		 IsMinB=True;
	 }    	

     lenA=strlen(tmpA);
    550c:	fe 01       	movw	r30, r28
    550e:	31 96       	adiw	r30, 0x01	; 1
    5510:	df 01       	movw	r26, r30
    5512:	0d 90       	ld	r0, X+
    5514:	00 20       	and	r0, r0
    5516:	e9 f7       	brne	.-6      	; 0x5512 <StrCalc+0x134>
    5518:	cd 01       	movw	r24, r26
    551a:	01 97       	sbiw	r24, 0x01	; 1
    551c:	8e 1b       	sub	r24, r30
    551e:	9f 0b       	sbc	r25, r31
     lenB=strlen(tmpB);
    5520:	de 01       	movw	r26, r28
    5522:	55 96       	adiw	r26, 0x15	; 21
    5524:	fd 01       	movw	r30, r26
    5526:	01 90       	ld	r0, Z+
    5528:	00 20       	and	r0, r0
    552a:	e9 f7       	brne	.-6      	; 0x5526 <StrCalc+0x148>
    552c:	31 97       	sbiw	r30, 0x01	; 1
     /*
	 sprintf_P(strSend,PSTR("A:%s"),strA);	 _uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);	 _uart_print(0,1,strSend);
     */

     AddZeroLead(tmpA,FixLen+1);
    552e:	1e 2f       	mov	r17, r30
    5530:	1a 1b       	sub	r17, r26
    5532:	18 17       	cp	r17, r24
    5534:	08 f4       	brcc	.+2      	; 0x5538 <StrCalc+0x15a>
    5536:	18 2f       	mov	r17, r24
    5538:	1f 5f       	subi	r17, 0xFF	; 255
    553a:	7e 01       	movw	r14, r28
    553c:	08 94       	sec
    553e:	e1 1c       	adc	r14, r1
    5540:	f1 1c       	adc	r15, r1
    5542:	c7 01       	movw	r24, r14
    5544:	61 2f       	mov	r22, r17
    5546:	0e 94 33 27 	call	0x4e66	; 0x4e66 <AddZeroLead>
     AddZeroLead(tmpB,FixLen+1);
    554a:	f5 e1       	ldi	r31, 0x15	; 21
    554c:	cf 2e       	mov	r12, r31
    554e:	d1 2c       	mov	r13, r1
    5550:	cc 0e       	add	r12, r28
    5552:	dd 1e       	adc	r13, r29
    5554:	c6 01       	movw	r24, r12
    5556:	61 2f       	mov	r22, r17
    5558:	0e 94 33 27 	call	0x4e66	; 0x4e66 <AddZeroLead>
	 _uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);
	 _uart_print(0,1,strSend);
	 */

     lenA=strlen(tmpA);
    555c:	f7 01       	movw	r30, r14
    555e:	01 90       	ld	r0, Z+
    5560:	00 20       	and	r0, r0
    5562:	e9 f7       	brne	.-6      	; 0x555e <StrCalc+0x180>
    5564:	31 97       	sbiw	r30, 0x01	; 1
    5566:	7e 2e       	mov	r7, r30
    5568:	7e 18       	sub	r7, r14
     lenB=strlen(tmpB);
    556a:	f6 01       	movw	r30, r12
    556c:	01 90       	ld	r0, Z+
    556e:	00 20       	and	r0, r0
    5570:	e9 f7       	brne	.-6      	; 0x556c <StrCalc+0x18e>
    5572:	31 97       	sbiw	r30, 0x01	; 1
    5574:	9e 2e       	mov	r9, r30
    5576:	9c 18       	sub	r9, r12
     IsNegative=False;
	 
	 IsNegative=False;
	 IsSwap=False;

	 if (IsMoreThan(tmpB,tmpA)==True){
    5578:	c6 01       	movw	r24, r12
    557a:	b7 01       	movw	r22, r14
    557c:	0e 94 1c 24 	call	0x4838	; 0x4838 <IsMoreThan>
    5580:	81 30       	cpi	r24, 0x01	; 1
    5582:	11 f0       	breq	.+4      	; 0x5588 <StrCalc+0x1aa>
    5584:	80 e0       	ldi	r24, 0x00	; 0
    5586:	42 c0       	rjmp	.+132    	; 0x560c <StrCalc+0x22e>
	     IsSwap=True;
         sprintf_P(tmpC,PSTR("%s"),tmpA);
    5588:	00 d0       	rcall	.+0      	; 0x558a <StrCalc+0x1ac>
    558a:	00 d0       	rcall	.+0      	; 0x558c <StrCalc+0x1ae>
    558c:	00 d0       	rcall	.+0      	; 0x558e <StrCalc+0x1b0>
    558e:	ed b7       	in	r30, 0x3d	; 61
    5590:	fe b7       	in	r31, 0x3e	; 62
    5592:	31 96       	adiw	r30, 0x01	; 1
    5594:	8e 01       	movw	r16, r28
    5596:	07 5d       	subi	r16, 0xD7	; 215
    5598:	1f 4f       	sbci	r17, 0xFF	; 255
    559a:	ad b7       	in	r26, 0x3d	; 61
    559c:	be b7       	in	r27, 0x3e	; 62
    559e:	12 96       	adiw	r26, 0x02	; 2
    55a0:	1c 93       	st	X, r17
    55a2:	0e 93       	st	-X, r16
    55a4:	11 97       	sbiw	r26, 0x01	; 1
    55a6:	82 eb       	ldi	r24, 0xB2	; 178
    55a8:	95 e0       	ldi	r25, 0x05	; 5
    55aa:	93 83       	std	Z+3, r25	; 0x03
    55ac:	82 83       	std	Z+2, r24	; 0x02
    55ae:	f5 82       	std	Z+5, r15	; 0x05
    55b0:	e4 82       	std	Z+4, r14	; 0x04
    55b2:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		 sprintf_P(tmpA,PSTR("%s"),tmpB);
    55b6:	ed b7       	in	r30, 0x3d	; 61
    55b8:	fe b7       	in	r31, 0x3e	; 62
    55ba:	31 96       	adiw	r30, 0x01	; 1
    55bc:	ad b7       	in	r26, 0x3d	; 61
    55be:	be b7       	in	r27, 0x3e	; 62
    55c0:	12 96       	adiw	r26, 0x02	; 2
    55c2:	fc 92       	st	X, r15
    55c4:	ee 92       	st	-X, r14
    55c6:	11 97       	sbiw	r26, 0x01	; 1
    55c8:	8f ea       	ldi	r24, 0xAF	; 175
    55ca:	95 e0       	ldi	r25, 0x05	; 5
    55cc:	93 83       	std	Z+3, r25	; 0x03
    55ce:	82 83       	std	Z+2, r24	; 0x02
    55d0:	d5 82       	std	Z+5, r13	; 0x05
    55d2:	c4 82       	std	Z+4, r12	; 0x04
    55d4:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		 sprintf_P(tmpB,PSTR("%s"),tmpC);
    55d8:	ed b7       	in	r30, 0x3d	; 61
    55da:	fe b7       	in	r31, 0x3e	; 62
    55dc:	31 96       	adiw	r30, 0x01	; 1
    55de:	ad b7       	in	r26, 0x3d	; 61
    55e0:	be b7       	in	r27, 0x3e	; 62
    55e2:	12 96       	adiw	r26, 0x02	; 2
    55e4:	dc 92       	st	X, r13
    55e6:	ce 92       	st	-X, r12
    55e8:	11 97       	sbiw	r26, 0x01	; 1
    55ea:	8c ea       	ldi	r24, 0xAC	; 172
    55ec:	95 e0       	ldi	r25, 0x05	; 5
    55ee:	93 83       	std	Z+3, r25	; 0x03
    55f0:	82 83       	std	Z+2, r24	; 0x02
    55f2:	15 83       	std	Z+5, r17	; 0x05
    55f4:	04 83       	std	Z+4, r16	; 0x04
    55f6:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    55fa:	81 e0       	ldi	r24, 0x01	; 1
    55fc:	ed b7       	in	r30, 0x3d	; 61
    55fe:	fe b7       	in	r31, 0x3e	; 62
    5600:	36 96       	adiw	r30, 0x06	; 6
    5602:	0f b6       	in	r0, 0x3f	; 63
    5604:	f8 94       	cli
    5606:	fe bf       	out	0x3e, r31	; 62
    5608:	0f be       	out	0x3f, r0	; 63
    560a:	ed bf       	out	0x3d, r30	; 61
	 }
    
	if (TOperation==TMINUS){
    560c:	66 20       	and	r6, r6
    560e:	39 f5       	brne	.+78     	; 0x565e <StrCalc+0x280>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    5610:	81 30       	cpi	r24, 0x01	; 1
    5612:	99 f4       	brne	.+38     	; 0x563a <StrCalc+0x25c>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    5614:	65 96       	adiw	r28, 0x15	; 21
    5616:	ff ad       	ldd	r31, Y+63	; 0x3f
    5618:	65 97       	sbiw	r28, 0x15	; 21
    561a:	f1 30       	cpi	r31, 0x01	; 1
    561c:	39 f4       	brne	.+14     	; 0x562c <StrCalc+0x24e>
    561e:	64 96       	adiw	r28, 0x14	; 20
    5620:	2f ad       	ldd	r18, Y+63	; 0x3f
    5622:	64 97       	sbiw	r28, 0x14	; 20
    5624:	21 30       	cpi	r18, 0x01	; 1
    5626:	09 f0       	breq	.+2      	; 0x562a <StrCalc+0x24c>
    5628:	9e c1       	rjmp	.+828    	; 0x5966 <StrCalc+0x588>
    562a:	42 c0       	rjmp	.+132    	; 0x56b0 <StrCalc+0x2d2>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    562c:	64 96       	adiw	r28, 0x14	; 20
    562e:	3f ad       	ldd	r19, Y+63	; 0x3f
    5630:	64 97       	sbiw	r28, 0x14	; 20
    5632:	31 30       	cpi	r19, 0x01	; 1
    5634:	09 f0       	breq	.+2      	; 0x5638 <StrCalc+0x25a>
    5636:	8e c1       	rjmp	.+796    	; 0x5954 <StrCalc+0x576>
    5638:	92 c1       	rjmp	.+804    	; 0x595e <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    563a:	65 96       	adiw	r28, 0x15	; 21
    563c:	8f ad       	ldd	r24, Y+63	; 0x3f
    563e:	65 97       	sbiw	r28, 0x15	; 21
    5640:	81 30       	cpi	r24, 0x01	; 1
    5642:	39 f4       	brne	.+14     	; 0x5652 <StrCalc+0x274>
    5644:	64 96       	adiw	r28, 0x14	; 20
    5646:	9f ad       	ldd	r25, Y+63	; 0x3f
    5648:	64 97       	sbiw	r28, 0x14	; 20
    564a:	91 30       	cpi	r25, 0x01	; 1
    564c:	09 f0       	breq	.+2      	; 0x5650 <StrCalc+0x272>
    564e:	8b c1       	rjmp	.+790    	; 0x5966 <StrCalc+0x588>
    5650:	81 c1       	rjmp	.+770    	; 0x5954 <StrCalc+0x576>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    5652:	64 96       	adiw	r28, 0x14	; 20
    5654:	af ad       	ldd	r26, Y+63	; 0x3f
    5656:	64 97       	sbiw	r28, 0x14	; 20
    5658:	a1 30       	cpi	r26, 0x01	; 1
    565a:	51 f5       	brne	.+84     	; 0x56b0 <StrCalc+0x2d2>
    565c:	80 c1       	rjmp	.+768    	; 0x595e <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
		}
	 }else
	if (TOperation==TPLUS){
    565e:	b1 e0       	ldi	r27, 0x01	; 1
    5660:	6b 16       	cp	r6, r27
    5662:	31 f5       	brne	.+76     	; 0x56b0 <StrCalc+0x2d2>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    5664:	81 30       	cpi	r24, 0x01	; 1
    5666:	91 f4       	brne	.+36     	; 0x568c <StrCalc+0x2ae>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    5668:	65 96       	adiw	r28, 0x15	; 21
    566a:	ef ad       	ldd	r30, Y+63	; 0x3f
    566c:	65 97       	sbiw	r28, 0x15	; 21
    566e:	e1 30       	cpi	r30, 0x01	; 1
    5670:	31 f4       	brne	.+12     	; 0x567e <StrCalc+0x2a0>
    5672:	64 96       	adiw	r28, 0x14	; 20
    5674:	ff ad       	ldd	r31, Y+63	; 0x3f
    5676:	64 97       	sbiw	r28, 0x14	; 20
    5678:	f1 30       	cpi	r31, 0x01	; 1
    567a:	d1 f4       	brne	.+52     	; 0x56b0 <StrCalc+0x2d2>
    567c:	74 c1       	rjmp	.+744    	; 0x5966 <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    567e:	64 96       	adiw	r28, 0x14	; 20
    5680:	2f ad       	ldd	r18, Y+63	; 0x3f
    5682:	64 97       	sbiw	r28, 0x14	; 20
    5684:	21 30       	cpi	r18, 0x01	; 1
    5686:	09 f0       	breq	.+2      	; 0x568a <StrCalc+0x2ac>
    5688:	6a c1       	rjmp	.+724    	; 0x595e <StrCalc+0x580>
    568a:	64 c1       	rjmp	.+712    	; 0x5954 <StrCalc+0x576>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TPLUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    568c:	65 96       	adiw	r28, 0x15	; 21
    568e:	3f ad       	ldd	r19, Y+63	; 0x3f
    5690:	65 97       	sbiw	r28, 0x15	; 21
    5692:	31 30       	cpi	r19, 0x01	; 1
    5694:	39 f4       	brne	.+14     	; 0x56a4 <StrCalc+0x2c6>
    5696:	64 96       	adiw	r28, 0x14	; 20
    5698:	8f ad       	ldd	r24, Y+63	; 0x3f
    569a:	64 97       	sbiw	r28, 0x14	; 20
    569c:	81 30       	cpi	r24, 0x01	; 1
    569e:	09 f0       	breq	.+2      	; 0x56a2 <StrCalc+0x2c4>
    56a0:	59 c1       	rjmp	.+690    	; 0x5954 <StrCalc+0x576>
    56a2:	61 c1       	rjmp	.+706    	; 0x5966 <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    56a4:	64 96       	adiw	r28, 0x14	; 20
    56a6:	9f ad       	ldd	r25, Y+63	; 0x3f
    56a8:	64 97       	sbiw	r28, 0x14	; 20
    56aa:	91 30       	cpi	r25, 0x01	; 1
    56ac:	09 f0       	breq	.+2      	; 0x56b0 <StrCalc+0x2d2>
    56ae:	57 c1       	rjmp	.+686    	; 0x595e <StrCalc+0x580>
   // A: 100000
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
    56b0:	62 96       	adiw	r28, 0x12	; 18
    56b2:	1f ae       	std	Y+63, r1	; 0x3f
    56b4:	62 97       	sbiw	r28, 0x12	; 18
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    56b6:	e7 2c       	mov	r14, r7
    56b8:	ff 24       	eor	r15, r15
    56ba:	67 01       	movw	r12, r14
    56bc:	08 94       	sec
    56be:	c1 08       	sbc	r12, r1
    56c0:	d1 08       	sbc	r13, r1
    56c2:	ae 01       	movw	r20, r28
    56c4:	43 5c       	subi	r20, 0xC3	; 195
    56c6:	5f 4f       	sbci	r21, 0xFF	; 255
    56c8:	4c 0d       	add	r20, r12
    56ca:	5d 1d       	adc	r21, r13
    56cc:	ce 01       	movw	r24, r28
    56ce:	01 96       	adiw	r24, 0x01	; 1
    56d0:	8c 01       	movw	r16, r24
    56d2:	0c 0d       	add	r16, r12
    56d4:	1d 1d       	adc	r17, r13
    56d6:	be 01       	movw	r22, r28
    56d8:	69 0d       	add	r22, r9
    56da:	71 1d       	adc	r23, r1
    56dc:	6c 5e       	subi	r22, 0xEC	; 236
    56de:	7f 4f       	sbci	r23, 0xFF	; 255
    56e0:	99 24       	eor	r9, r9
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    56e2:	2c 01       	movw	r4, r24
    56e4:	e9 e3       	ldi	r30, 0x39	; 57
    56e6:	8e 2e       	mov	r8, r30
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    56e8:	9a e0       	ldi	r25, 0x0A	; 10
    56ea:	52 c0       	rjmp	.+164    	; 0x5790 <StrCalc+0x3b2>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    56ec:	d8 01       	movw	r26, r16
    56ee:	8c 91       	ld	r24, X
    56f0:	80 53       	subi	r24, 0x30	; 48
    56f2:	8a 30       	cpi	r24, 0x0A	; 10
    56f4:	10 f0       	brcs	.+4      	; 0x56fa <StrCalc+0x31c>
    56f6:	20 e0       	ldi	r18, 0x00	; 0
    56f8:	01 c0       	rjmp	.+2      	; 0x56fc <StrCalc+0x31e>
    56fa:	28 2f       	mov	r18, r24
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
    56fc:	fb 01       	movw	r30, r22
    56fe:	30 81       	ld	r19, Z
    5700:	30 53       	subi	r19, 0x30	; 48
    5702:	3a 30       	cpi	r19, 0x0A	; 10
    5704:	10 f4       	brcc	.+4      	; 0x570a <StrCalc+0x32c>
    5706:	23 17       	cp	r18, r19
    5708:	40 f0       	brcs	.+16     	; 0x571a <StrCalc+0x33c>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    570a:	8a 30       	cpi	r24, 0x0A	; 10
    570c:	08 f0       	brcs	.+2      	; 0x5710 <StrCalc+0x332>
    570e:	80 e0       	ldi	r24, 0x00	; 0

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5710:	3a 30       	cpi	r19, 0x0A	; 10
    5712:	08 f0       	brcs	.+2      	; 0x5716 <StrCalc+0x338>
    5714:	30 e0       	ldi	r19, 0x00	; 0
    5716:	83 1b       	sub	r24, r19
    5718:	2d c0       	rjmp	.+90     	; 0x5774 <StrCalc+0x396>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    571a:	8a 30       	cpi	r24, 0x0A	; 10
    571c:	10 f4       	brcc	.+4      	; 0x5722 <StrCalc+0x344>
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
    571e:	83 17       	cp	r24, r19
    5720:	80 f5       	brcc	.+96     	; 0x5782 <StrCalc+0x3a4>
    5722:	29 2d       	mov	r18, r9
    5724:	0a c0       	rjmp	.+20     	; 0x573a <StrCalc+0x35c>
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    5726:	f6 01       	movw	r30, r12
    5728:	e2 1b       	sub	r30, r18
    572a:	f1 09       	sbc	r31, r1
    572c:	d2 01       	movw	r26, r4
    572e:	ae 0f       	add	r26, r30
    5730:	bf 1f       	adc	r27, r31
    5732:	8c 91       	ld	r24, X
    5734:	80 33       	cpi	r24, 0x30	; 48
    5736:	29 f4       	brne	.+10     	; 0x5742 <StrCalc+0x364>
    5738:	8c 92       	st	X, r8
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
    573a:	2f 5f       	subi	r18, 0xFF	; 255
    573c:	27 15       	cp	r18, r7
    573e:	98 f3       	brcs	.-26     	; 0x5726 <StrCalc+0x348>
    5740:	10 c0       	rjmp	.+32     	; 0x5762 <StrCalc+0x384>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5742:	28 2f       	mov	r18, r24
    5744:	20 53       	subi	r18, 0x30	; 48
    5746:	2a 30       	cpi	r18, 0x0A	; 10
    5748:	08 f0       	brcs	.+2      	; 0x574c <StrCalc+0x36e>
    574a:	20 e0       	ldi	r18, 0x00	; 0
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    574c:	82 2f       	mov	r24, r18
    574e:	81 50       	subi	r24, 0x01	; 1
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5750:	8a 30       	cpi	r24, 0x0A	; 10
    5752:	10 f0       	brcs	.+4      	; 0x5758 <StrCalc+0x37a>
    5754:	80 e3       	ldi	r24, 0x30	; 48
    5756:	02 c0       	rjmp	.+4      	; 0x575c <StrCalc+0x37e>
	    Result='0'+X;
    5758:	82 2f       	mov	r24, r18
    575a:	81 5d       	subi	r24, 0xD1	; 209
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    575c:	e4 0d       	add	r30, r4
    575e:	f5 1d       	adc	r31, r5
    5760:	80 83       	st	Z, r24
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5762:	f8 01       	movw	r30, r16
    5764:	20 81       	ld	r18, Z
    5766:	20 53       	subi	r18, 0x30	; 48
    5768:	2a 30       	cpi	r18, 0x0A	; 10
    576a:	08 f0       	brcs	.+2      	; 0x576e <StrCalc+0x390>
    576c:	20 e0       	ldi	r18, 0x00	; 0
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    576e:	89 2f       	mov	r24, r25
    5770:	83 1b       	sub	r24, r19
    5772:	82 0f       	add	r24, r18
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5774:	8a 30       	cpi	r24, 0x0A	; 10
    5776:	10 f0       	brcs	.+4      	; 0x577c <StrCalc+0x39e>
    5778:	80 e3       	ldi	r24, 0x30	; 48
    577a:	01 c0       	rjmp	.+2      	; 0x577e <StrCalc+0x3a0>
	    Result='0'+X;
    577c:	80 5d       	subi	r24, 0xD0	; 208
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    577e:	da 01       	movw	r26, r20
    5780:	8c 93       	st	X, r24
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
    5782:	93 94       	inc	r9
    5784:	41 50       	subi	r20, 0x01	; 1
    5786:	50 40       	sbci	r21, 0x00	; 0
    5788:	01 50       	subi	r16, 0x01	; 1
    578a:	10 40       	sbci	r17, 0x00	; 0
    578c:	61 50       	subi	r22, 0x01	; 1
    578e:	70 40       	sbci	r23, 0x00	; 0
    5790:	97 14       	cp	r9, r7
    5792:	08 f4       	brcc	.+2      	; 0x5796 <StrCalc+0x3b8>
    5794:	ab cf       	rjmp	.-170    	; 0x56ec <StrCalc+0x30e>
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }
		 }Result[lenA]=0;		    
    5796:	8e 01       	movw	r16, r28
    5798:	03 5c       	subi	r16, 0xC3	; 195
    579a:	1f 4f       	sbci	r17, 0xFF	; 255
    579c:	e0 0e       	add	r14, r16
    579e:	f1 1e       	adc	r15, r17
    57a0:	f7 01       	movw	r30, r14
    57a2:	10 82       	st	Z, r1
       RemZeroLead(Result);
    57a4:	c8 01       	movw	r24, r16
    57a6:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
    57aa:	f8 01       	movw	r30, r16
    57ac:	01 90       	ld	r0, Z+
    57ae:	00 20       	and	r0, r0
    57b0:	e9 f7       	brne	.-6      	; 0x57ac <StrCalc+0x3ce>
    57b2:	31 97       	sbiw	r30, 0x01	; 1
    57b4:	3e 2f       	mov	r19, r30
    57b6:	30 1b       	sub	r19, r16
    57b8:	d8 01       	movw	r26, r16
    57ba:	90 e0       	ldi	r25, 0x00	; 0
    57bc:	20 e0       	ldi	r18, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    57be:	4d e2       	ldi	r20, 0x2D	; 45
    57c0:	13 c0       	rjmp	.+38     	; 0x57e8 <StrCalc+0x40a>
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    57c2:	22 23       	and	r18, r18
    57c4:	51 f4       	brne	.+20     	; 0x57da <StrCalc+0x3fc>
    57c6:	62 96       	adiw	r28, 0x12	; 18
    57c8:	ff ad       	ldd	r31, Y+63	; 0x3f
    57ca:	62 97       	sbiw	r28, 0x12	; 18
    57cc:	f1 30       	cpi	r31, 0x01	; 1
    57ce:	29 f4       	brne	.+10     	; 0x57da <StrCalc+0x3fc>
			     strC[iPos]='-';
    57d0:	f5 01       	movw	r30, r10
    57d2:	e9 0f       	add	r30, r25
    57d4:	f1 1d       	adc	r31, r1
    57d6:	40 83       	st	Z, r20
				 iPos++;
    57d8:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[i];
    57da:	f5 01       	movw	r30, r10
    57dc:	e9 0f       	add	r30, r25
    57de:	f1 1d       	adc	r31, r1
    57e0:	8d 91       	ld	r24, X+
    57e2:	80 83       	st	Z, r24
			 iPos++;
    57e4:	9f 5f       	subi	r25, 0xFF	; 255
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    57e6:	2f 5f       	subi	r18, 0xFF	; 255
    57e8:	23 17       	cp	r18, r19
    57ea:	58 f3       	brcs	.-42     	; 0x57c2 <StrCalc+0x3e4>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[i];
			 iPos++;
		 }strC[iPos]=0;
    57ec:	f5 01       	movw	r30, r10
    57ee:	e9 0f       	add	r30, r25
    57f0:	f1 1d       	adc	r31, r1
    57f2:	10 82       	st	Z, r1
    57f4:	a0 c0       	rjmp	.+320    	; 0x5936 <StrCalc+0x558>
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
    57f6:	7d e3       	ldi	r23, 0x3D	; 61
    57f8:	e7 2e       	mov	r14, r23
    57fa:	f1 2c       	mov	r15, r1
    57fc:	ec 0e       	add	r14, r28
    57fe:	fd 1e       	adc	r15, r29
    5800:	ae 01       	movw	r20, r28
    5802:	49 0d       	add	r20, r9
    5804:	51 1d       	adc	r21, r1
    5806:	4c 5e       	subi	r20, 0xEC	; 236
    5808:	5f 4f       	sbci	r21, 0xFF	; 255
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    580a:	07 2d       	mov	r16, r7
    580c:	10 e0       	ldi	r17, 0x00	; 0
    580e:	48 01       	movw	r8, r16
    5810:	08 94       	sec
    5812:	81 08       	sbc	r8, r1
    5814:	91 08       	sbc	r9, r1
    5816:	ce 01       	movw	r24, r28
    5818:	01 96       	adiw	r24, 0x01	; 1
    581a:	6c 01       	movw	r12, r24
    581c:	c8 0c       	add	r12, r8
    581e:	d9 1c       	adc	r13, r9
    5820:	30 e0       	ldi	r19, 0x00	; 0
    5822:	20 e0       	ldi	r18, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5824:	2c 01       	movw	r4, r24
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    5826:	60 e3       	ldi	r22, 0x30	; 48
    5828:	36 2e       	mov	r3, r22
    582a:	47 c0       	rjmp	.+142    	; 0x58ba <StrCalc+0x4dc>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    582c:	d6 01       	movw	r26, r12
    582e:	9c 91       	ld	r25, X
    5830:	90 53       	subi	r25, 0x30	; 48
    5832:	9a 30       	cpi	r25, 0x0A	; 10
    5834:	08 f0       	brcs	.+2      	; 0x5838 <StrCalc+0x45a>
    5836:	90 e0       	ldi	r25, 0x00	; 0
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
		     newC=(Ord(tmpA[lenA-i-1])+Ord(tmpB[lenB-i-1]));			 
    5838:	fa 01       	movw	r30, r20
    583a:	80 81       	ld	r24, Z
    583c:	80 53       	subi	r24, 0x30	; 48
    583e:	8a 30       	cpi	r24, 0x0A	; 10
    5840:	08 f0       	brcs	.+2      	; 0x5844 <StrCalc+0x466>
    5842:	80 e0       	ldi	r24, 0x00	; 0
    5844:	89 0f       	add	r24, r25
			 if (newC<10){
    5846:	8a 30       	cpi	r24, 0x0A	; 10
    5848:	18 f4       	brcc	.+6      	; 0x5850 <StrCalc+0x472>
			     Result[i]=Chr(newC);
    584a:	80 5d       	subi	r24, 0xD0	; 208
    584c:	d7 01       	movw	r26, r14
    584e:	28 c0       	rjmp	.+80     	; 0x58a0 <StrCalc+0x4c2>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5850:	6a e0       	ldi	r22, 0x0A	; 10
    5852:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5856:	9a 30       	cpi	r25, 0x0A	; 10
    5858:	10 f0       	brcs	.+4      	; 0x585e <StrCalc+0x480>
    585a:	90 e3       	ldi	r25, 0x30	; 48
    585c:	01 c0       	rjmp	.+2      	; 0x5860 <StrCalc+0x482>
	    Result='0'+X;
    585e:	90 5d       	subi	r25, 0xD0	; 208
			 if (newC<10){
			     Result[i]=Chr(newC);
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5860:	f7 01       	movw	r30, r14
    5862:	90 83       	st	Z, r25
    5864:	83 2f       	mov	r24, r19
    5866:	0e c0       	rjmp	.+28     	; 0x5884 <StrCalc+0x4a6>
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    5868:	d4 01       	movw	r26, r8
    586a:	a8 1b       	sub	r26, r24
    586c:	b1 09       	sbc	r27, r1
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    586e:	f2 01       	movw	r30, r4
    5870:	ea 0f       	add	r30, r26
    5872:	fb 1f       	adc	r31, r27
    5874:	90 81       	ld	r25, Z
    5876:	90 53       	subi	r25, 0x30	; 48
    5878:	9a 30       	cpi	r25, 0x0A	; 10
    587a:	08 f0       	brcs	.+2      	; 0x587e <StrCalc+0x4a0>
    587c:	79 c0       	rjmp	.+242    	; 0x5970 <StrCalc+0x592>
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    587e:	99 30       	cpi	r25, 0x09	; 9
    5880:	29 f4       	brne	.+10     	; 0x588c <StrCalc+0x4ae>
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    5882:	30 82       	st	Z, r3
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    5884:	8f 5f       	subi	r24, 0xFF	; 255
    5886:	87 15       	cp	r24, r7
    5888:	78 f3       	brcs	.-34     	; 0x5868 <StrCalc+0x48a>
    588a:	0d c0       	rjmp	.+26     	; 0x58a6 <StrCalc+0x4c8>
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    588c:	89 2f       	mov	r24, r25
    588e:	8f 5f       	subi	r24, 0xFF	; 255
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5890:	8a 30       	cpi	r24, 0x0A	; 10
    5892:	10 f0       	brcs	.+4      	; 0x5898 <StrCalc+0x4ba>
    5894:	80 e3       	ldi	r24, 0x30	; 48
    5896:	02 c0       	rjmp	.+4      	; 0x589c <StrCalc+0x4be>
	    Result='0'+X;
    5898:	89 2f       	mov	r24, r25
    589a:	8f 5c       	subi	r24, 0xCF	; 207
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    589c:	a4 0d       	add	r26, r4
    589e:	b5 1d       	adc	r27, r5
    58a0:	8c 93       	st	X, r24
    58a2:	20 e0       	ldi	r18, 0x00	; 0
    58a4:	01 c0       	rjmp	.+2      	; 0x58a8 <StrCalc+0x4ca>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    58a6:	21 e0       	ldi	r18, 0x01	; 1
		 }strC[iPos]=0;
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
    58a8:	3f 5f       	subi	r19, 0xFF	; 255
    58aa:	08 94       	sec
    58ac:	e1 1c       	adc	r14, r1
    58ae:	f1 1c       	adc	r15, r1
    58b0:	41 50       	subi	r20, 0x01	; 1
    58b2:	50 40       	sbci	r21, 0x00	; 0
    58b4:	08 94       	sec
    58b6:	c1 08       	sbc	r12, r1
    58b8:	d1 08       	sbc	r13, r1
    58ba:	37 15       	cp	r19, r7
    58bc:	08 f4       	brcc	.+2      	; 0x58c0 <StrCalc+0x4e2>
    58be:	b6 cf       	rjmp	.-148    	; 0x582c <StrCalc+0x44e>
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    58c0:	20 5d       	subi	r18, 0xD0	; 208
				 }//EndFor j                
			   }//End else
			 }//EndFor

		  //Result[lenA]==Chr(zMin); ???
		  Result[lenA]=Chr(zMin);
    58c2:	de 01       	movw	r26, r28
    58c4:	dd 96       	adiw	r26, 0x3d	; 61
    58c6:	fd 01       	movw	r30, r26
    58c8:	e0 0f       	add	r30, r16
    58ca:	f1 1f       	adc	r31, r17
    58cc:	20 83       	st	Z, r18
		  Result[lenA+1]=0;
    58ce:	0c 0f       	add	r16, r28
    58d0:	1d 1f       	adc	r17, r29
    58d2:	f8 01       	movw	r30, r16
    58d4:	16 ae       	std	Z+62, r1	; 0x3e
		 FixLen=strlen(Result);
		 for(i=0;i<FixLen;i++){
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
    58d6:	fd 01       	movw	r30, r26
    58d8:	01 90       	ld	r0, Z+
    58da:	00 20       	and	r0, r0
    58dc:	e9 f7       	brne	.-6      	; 0x58d8 <StrCalc+0x4fa>
    58de:	31 97       	sbiw	r30, 0x01	; 1
    58e0:	5e 2f       	mov	r21, r30
    58e2:	5a 1b       	sub	r21, r26
    58e4:	25 2f       	mov	r18, r21
    58e6:	30 e0       	ldi	r19, 0x00	; 0
    58e8:	21 50       	subi	r18, 0x01	; 1
    58ea:	30 40       	sbci	r19, 0x00	; 0
    58ec:	2a 0f       	add	r18, r26
    58ee:	3b 1f       	adc	r19, r27
    58f0:	90 e0       	ldi	r25, 0x00	; 0
    58f2:	40 e0       	ldi	r20, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    58f4:	6d e2       	ldi	r22, 0x2D	; 45
    58f6:	16 c0       	rjmp	.+44     	; 0x5924 <StrCalc+0x546>
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    58f8:	44 23       	and	r20, r20
    58fa:	51 f4       	brne	.+20     	; 0x5910 <StrCalc+0x532>
    58fc:	63 96       	adiw	r28, 0x13	; 19
    58fe:	ff ad       	ldd	r31, Y+63	; 0x3f
    5900:	63 97       	sbiw	r28, 0x13	; 19
    5902:	f1 30       	cpi	r31, 0x01	; 1
    5904:	29 f4       	brne	.+10     	; 0x5910 <StrCalc+0x532>
			     strC[iPos]='-';
    5906:	f5 01       	movw	r30, r10
    5908:	e9 0f       	add	r30, r25
    590a:	f1 1d       	adc	r31, r1
    590c:	60 83       	st	Z, r22
				 iPos++;
    590e:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[FixLen-i-1];
    5910:	f5 01       	movw	r30, r10
    5912:	e9 0f       	add	r30, r25
    5914:	f1 1d       	adc	r31, r1
    5916:	d9 01       	movw	r26, r18
    5918:	8c 91       	ld	r24, X
    591a:	80 83       	st	Z, r24
			 iPos++;
    591c:	9f 5f       	subi	r25, 0xFF	; 255
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    591e:	4f 5f       	subi	r20, 0xFF	; 255
    5920:	21 50       	subi	r18, 0x01	; 1
    5922:	30 40       	sbci	r19, 0x00	; 0
    5924:	45 17       	cp	r20, r21
    5926:	40 f3       	brcs	.-48     	; 0x58f8 <StrCalc+0x51a>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[FixLen-i-1];
			 iPos++;
		 }strC[iPos]=0;
    5928:	f5 01       	movw	r30, r10
    592a:	e9 0f       	add	r30, r25
    592c:	f1 1d       	adc	r31, r1
    592e:	10 82       	st	Z, r1

       RemZeroLead(strC);
    5930:	c5 01       	movw	r24, r10
    5932:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
  //    sprintf_P(strSend,PSTR("C':%s"),strC);
//	 _uart_print(0,1,strSend);

	 }//EndIf 

	 if (TOperation==TMULTIPLY){
    5936:	b2 e0       	ldi	r27, 0x02	; 2
    5938:	6b 16       	cp	r6, r27
    593a:	e1 f4       	brne	.+56     	; 0x5974 <StrCalc+0x596>
		 valA=atol(strA);
		 valB=atol(strB);
		 valC=valA*valB;		 
         ltoa(valC,strC,10);
		 */
		 CalcMultiply(strA,strB,strC);
    593c:	67 96       	adiw	r28, 0x17	; 23
    593e:	8e ad       	ldd	r24, Y+62	; 0x3e
    5940:	9f ad       	ldd	r25, Y+63	; 0x3f
    5942:	67 97       	sbiw	r28, 0x17	; 23
    5944:	69 96       	adiw	r28, 0x19	; 25
    5946:	6e ad       	ldd	r22, Y+62	; 0x3e
    5948:	7f ad       	ldd	r23, Y+63	; 0x3f
    594a:	69 97       	sbiw	r28, 0x19	; 25
    594c:	a5 01       	movw	r20, r10
    594e:	0e 94 d3 2c 	call	0x59a6	; 0x59a6 <CalcMultiply>
    5952:	10 c0       	rjmp	.+32     	; 0x5974 <StrCalc+0x596>
	 }
}
    5954:	e1 e0       	ldi	r30, 0x01	; 1
    5956:	62 96       	adiw	r28, 0x12	; 18
    5958:	ef af       	std	Y+63, r30	; 0x3f
    595a:	62 97       	sbiw	r28, 0x12	; 18
    595c:	ac ce       	rjmp	.-680    	; 0x56b6 <StrCalc+0x2d8>
    595e:	63 96       	adiw	r28, 0x13	; 19
    5960:	1f ae       	std	Y+63, r1	; 0x3f
    5962:	63 97       	sbiw	r28, 0x13	; 19
    5964:	48 cf       	rjmp	.-368    	; 0x57f6 <StrCalc+0x418>
    5966:	f1 e0       	ldi	r31, 0x01	; 1
    5968:	63 96       	adiw	r28, 0x13	; 19
    596a:	ff af       	std	Y+63, r31	; 0x3f
    596c:	63 97       	sbiw	r28, 0x13	; 19
    596e:	43 cf       	rjmp	.-378    	; 0x57f6 <StrCalc+0x418>
    5970:	90 e0       	ldi	r25, 0x00	; 0
    5972:	8c cf       	rjmp	.-232    	; 0x588c <StrCalc+0x4ae>
    5974:	c8 5a       	subi	r28, 0xA8	; 168
    5976:	df 4f       	sbci	r29, 0xFF	; 255
    5978:	0f b6       	in	r0, 0x3f	; 63
    597a:	f8 94       	cli
    597c:	de bf       	out	0x3e, r29	; 62
    597e:	0f be       	out	0x3f, r0	; 63
    5980:	cd bf       	out	0x3d, r28	; 61
    5982:	cf 91       	pop	r28
    5984:	df 91       	pop	r29
    5986:	1f 91       	pop	r17
    5988:	0f 91       	pop	r16
    598a:	ff 90       	pop	r15
    598c:	ef 90       	pop	r14
    598e:	df 90       	pop	r13
    5990:	cf 90       	pop	r12
    5992:	bf 90       	pop	r11
    5994:	af 90       	pop	r10
    5996:	9f 90       	pop	r9
    5998:	8f 90       	pop	r8
    599a:	7f 90       	pop	r7
    599c:	6f 90       	pop	r6
    599e:	5f 90       	pop	r5
    59a0:	4f 90       	pop	r4
    59a2:	3f 90       	pop	r3
    59a4:	08 95       	ret

000059a6 <CalcMultiply>:
	 }
	 strResult[lenR]=0;
}


void CalcMultiply(char *strA,char *strB,char *strC){
    59a6:	4f 92       	push	r4
    59a8:	5f 92       	push	r5
    59aa:	6f 92       	push	r6
    59ac:	7f 92       	push	r7
    59ae:	8f 92       	push	r8
    59b0:	9f 92       	push	r9
    59b2:	af 92       	push	r10
    59b4:	bf 92       	push	r11
    59b6:	cf 92       	push	r12
    59b8:	df 92       	push	r13
    59ba:	ef 92       	push	r14
    59bc:	ff 92       	push	r15
    59be:	0f 93       	push	r16
    59c0:	1f 93       	push	r17
    59c2:	df 93       	push	r29
    59c4:	cf 93       	push	r28
    59c6:	cd b7       	in	r28, 0x3d	; 61
    59c8:	de b7       	in	r29, 0x3e	; 62
    59ca:	a8 97       	sbiw	r28, 0x28	; 40
    59cc:	0f b6       	in	r0, 0x3f	; 63
    59ce:	f8 94       	cli
    59d0:	de bf       	out	0x3e, r29	; 62
    59d2:	0f be       	out	0x3f, r0	; 63
    59d4:	cd bf       	out	0x3d, r28	; 61
    59d6:	3c 01       	movw	r6, r24
    59d8:	6b 01       	movw	r12, r22
    59da:	2a 01       	movw	r4, r20
	 
	 */
	 char i,lenB;
	 char prevSeg[20],currSeg[20];

     RemZeroLead(strA);
    59dc:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
     RemZeroLead(strB);
    59e0:	c6 01       	movw	r24, r12
    59e2:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
	 lenB=strlen(strB);
    59e6:	d6 01       	movw	r26, r12
    59e8:	0d 90       	ld	r0, X+
    59ea:	00 20       	and	r0, r0
    59ec:	e9 f7       	brne	.-6      	; 0x59e8 <CalcMultiply+0x42>
    59ee:	11 97       	sbiw	r26, 0x01	; 1
    59f0:	8a 2e       	mov	r8, r26
    59f2:	8c 18       	sub	r8, r12
	 sprintf_P(prevSeg,PSTR("0"));
    59f4:	00 d0       	rcall	.+0      	; 0x59f6 <CalcMultiply+0x50>
    59f6:	00 d0       	rcall	.+0      	; 0x59f8 <CalcMultiply+0x52>
    59f8:	8e 01       	movw	r16, r28
    59fa:	0f 5f       	subi	r16, 0xFF	; 255
    59fc:	1f 4f       	sbci	r17, 0xFF	; 255
    59fe:	ad b7       	in	r26, 0x3d	; 61
    5a00:	be b7       	in	r27, 0x3e	; 62
    5a02:	12 96       	adiw	r26, 0x02	; 2
    5a04:	1c 93       	st	X, r17
    5a06:	0e 93       	st	-X, r16
    5a08:	11 97       	sbiw	r26, 0x01	; 1
    5a0a:	8a ea       	ldi	r24, 0xAA	; 170
    5a0c:	95 e0       	ldi	r25, 0x05	; 5
    5a0e:	14 96       	adiw	r26, 0x04	; 4
    5a10:	9c 93       	st	X, r25
    5a12:	8e 93       	st	-X, r24
    5a14:	13 97       	sbiw	r26, 0x03	; 3
    5a16:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	 sprintf_P(currSeg,PSTR("0"));
    5a1a:	a5 e1       	ldi	r26, 0x15	; 21
    5a1c:	ea 2e       	mov	r14, r26
    5a1e:	f1 2c       	mov	r15, r1
    5a20:	ec 0e       	add	r14, r28
    5a22:	fd 1e       	adc	r15, r29
    5a24:	ed b7       	in	r30, 0x3d	; 61
    5a26:	fe b7       	in	r31, 0x3e	; 62
    5a28:	f2 82       	std	Z+2, r15	; 0x02
    5a2a:	e1 82       	std	Z+1, r14	; 0x01
    5a2c:	88 ea       	ldi	r24, 0xA8	; 168
    5a2e:	95 e0       	ldi	r25, 0x05	; 5
    5a30:	94 83       	std	Z+4, r25	; 0x04
    5a32:	83 83       	std	Z+3, r24	; 0x03
    5a34:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    5a38:	bb 24       	eor	r11, r11
    5a3a:	0f 90       	pop	r0
    5a3c:	0f 90       	pop	r0
    5a3e:	0f 90       	pop	r0
    5a40:	0f 90       	pop	r0
    5a42:	a0 2e       	mov	r10, r16
    5a44:	91 2e       	mov	r9, r17

	 for(i=0;i<strlen(strB);i++){
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
    5a46:	08 2d       	mov	r16, r8
    5a48:	10 e0       	ldi	r17, 0x00	; 0
    5a4a:	01 50       	subi	r16, 0x01	; 1
    5a4c:	10 40       	sbci	r17, 0x00	; 0
    5a4e:	1f c0       	rjmp	.+62     	; 0x5a8e <CalcMultiply+0xe8>
    5a50:	f8 01       	movw	r30, r16
    5a52:	e8 1b       	sub	r30, r24
    5a54:	f9 0b       	sbc	r31, r25
    5a56:	ec 0d       	add	r30, r12
    5a58:	fd 1d       	adc	r31, r13
    5a5a:	c3 01       	movw	r24, r6
    5a5c:	60 81       	ld	r22, Z
    5a5e:	a7 01       	movw	r20, r14
    5a60:	0e 94 3a 23 	call	0x4674	; 0x4674 <CalcSegmen>
         AddZeroLag(currSeg,strlen(currSeg)+i);
    5a64:	f7 01       	movw	r30, r14
    5a66:	01 90       	ld	r0, Z+
    5a68:	00 20       	and	r0, r0
    5a6a:	e9 f7       	brne	.-6      	; 0x5a66 <CalcMultiply+0xc0>
    5a6c:	31 97       	sbiw	r30, 0x01	; 1
    5a6e:	ee 19       	sub	r30, r14
    5a70:	ff 09       	sbc	r31, r15
    5a72:	6b 2d       	mov	r22, r11
    5a74:	6e 0f       	add	r22, r30
    5a76:	c7 01       	movw	r24, r14
    5a78:	0e 94 d4 29 	call	0x53a8	; 0x53a8 <AddZeroLag>
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
    5a7c:	81 e0       	ldi	r24, 0x01	; 1
    5a7e:	6a 2d       	mov	r22, r10
    5a80:	79 2d       	mov	r23, r9
    5a82:	a7 01       	movw	r20, r14
    5a84:	2a 2d       	mov	r18, r10
    5a86:	39 2d       	mov	r19, r9
    5a88:	0e 94 ef 29 	call	0x53de	; 0x53de <StrCalc>
     RemZeroLead(strB);
	 lenB=strlen(strB);
	 sprintf_P(prevSeg,PSTR("0"));
	 sprintf_P(currSeg,PSTR("0"));

	 for(i=0;i<strlen(strB);i++){
    5a8c:	b3 94       	inc	r11
    5a8e:	f6 01       	movw	r30, r12
    5a90:	01 90       	ld	r0, Z+
    5a92:	00 20       	and	r0, r0
    5a94:	e9 f7       	brne	.-6      	; 0x5a90 <CalcMultiply+0xea>
    5a96:	31 97       	sbiw	r30, 0x01	; 1
    5a98:	ec 19       	sub	r30, r12
    5a9a:	fd 09       	sbc	r31, r13
    5a9c:	8b 2d       	mov	r24, r11
    5a9e:	90 e0       	ldi	r25, 0x00	; 0
    5aa0:	8e 17       	cp	r24, r30
    5aa2:	9f 07       	cpc	r25, r31
    5aa4:	a8 f2       	brcs	.-86     	; 0x5a50 <CalcMultiply+0xaa>
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
         AddZeroLag(currSeg,strlen(currSeg)+i);
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
    5aa6:	00 d0       	rcall	.+0      	; 0x5aa8 <CalcMultiply+0x102>
    5aa8:	00 d0       	rcall	.+0      	; 0x5aaa <CalcMultiply+0x104>
    5aaa:	00 d0       	rcall	.+0      	; 0x5aac <CalcMultiply+0x106>
    5aac:	ed b7       	in	r30, 0x3d	; 61
    5aae:	fe b7       	in	r31, 0x3e	; 62
    5ab0:	31 96       	adiw	r30, 0x01	; 1
    5ab2:	ad b7       	in	r26, 0x3d	; 61
    5ab4:	be b7       	in	r27, 0x3e	; 62
    5ab6:	12 96       	adiw	r26, 0x02	; 2
    5ab8:	5c 92       	st	X, r5
    5aba:	4e 92       	st	-X, r4
    5abc:	11 97       	sbiw	r26, 0x01	; 1
    5abe:	85 ea       	ldi	r24, 0xA5	; 165
    5ac0:	95 e0       	ldi	r25, 0x05	; 5
    5ac2:	93 83       	std	Z+3, r25	; 0x03
    5ac4:	82 83       	std	Z+2, r24	; 0x02
    5ac6:	a4 82       	std	Z+4, r10	; 0x04
    5ac8:	95 82       	std	Z+5, r9	; 0x05
    5aca:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    5ace:	ed b7       	in	r30, 0x3d	; 61
    5ad0:	fe b7       	in	r31, 0x3e	; 62
    5ad2:	36 96       	adiw	r30, 0x06	; 6
    5ad4:	0f b6       	in	r0, 0x3f	; 63
    5ad6:	f8 94       	cli
    5ad8:	fe bf       	out	0x3e, r31	; 62
    5ada:	0f be       	out	0x3f, r0	; 63
    5adc:	ed bf       	out	0x3d, r30	; 61
}
    5ade:	a8 96       	adiw	r28, 0x28	; 40
    5ae0:	0f b6       	in	r0, 0x3f	; 63
    5ae2:	f8 94       	cli
    5ae4:	de bf       	out	0x3e, r29	; 62
    5ae6:	0f be       	out	0x3f, r0	; 63
    5ae8:	cd bf       	out	0x3d, r28	; 61
    5aea:	cf 91       	pop	r28
    5aec:	df 91       	pop	r29
    5aee:	1f 91       	pop	r17
    5af0:	0f 91       	pop	r16
    5af2:	ff 90       	pop	r15
    5af4:	ef 90       	pop	r14
    5af6:	df 90       	pop	r13
    5af8:	cf 90       	pop	r12
    5afa:	bf 90       	pop	r11
    5afc:	af 90       	pop	r10
    5afe:	9f 90       	pop	r9
    5b00:	8f 90       	pop	r8
    5b02:	7f 90       	pop	r7
    5b04:	6f 90       	pop	r6
    5b06:	5f 90       	pop	r5
    5b08:	4f 90       	pop	r4
    5b0a:	08 95       	ret

00005b0c <NormalizeOverflow>:
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}

void NormalizeOverflow(char *strOverflowed){
    5b0c:	cf 92       	push	r12
    5b0e:	df 92       	push	r13
    5b10:	ef 92       	push	r14
    5b12:	ff 92       	push	r15
    5b14:	0f 93       	push	r16
    5b16:	1f 93       	push	r17
    5b18:	df 93       	push	r29
    5b1a:	cf 93       	push	r28
    5b1c:	cd b7       	in	r28, 0x3d	; 61
    5b1e:	de b7       	in	r29, 0x3e	; 62
    5b20:	64 97       	sbiw	r28, 0x14	; 20
    5b22:	0f b6       	in	r0, 0x3f	; 63
    5b24:	f8 94       	cli
    5b26:	de bf       	out	0x3e, r29	; 62
    5b28:	0f be       	out	0x3f, r0	; 63
    5b2a:	cd bf       	out	0x3d, r28	; 61
    5b2c:	d8 2e       	mov	r13, r24
    5b2e:	c9 2e       	mov	r12, r25
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
    5b30:	a8 2f       	mov	r26, r24
    5b32:	b9 2f       	mov	r27, r25
    5b34:	fd 01       	movw	r30, r26
    5b36:	01 90       	ld	r0, Z+
    5b38:	00 20       	and	r0, r0
    5b3a:	e9 f7       	brne	.-6      	; 0x5b36 <NormalizeOverflow+0x2a>
    5b3c:	31 97       	sbiw	r30, 0x01	; 1
    5b3e:	4e 2f       	mov	r20, r30
    5b40:	48 1b       	sub	r20, r24
    5b42:	20 e0       	ldi	r18, 0x00	; 0
    5b44:	30 e0       	ldi	r19, 0x00	; 0
    5b46:	7e 01       	movw	r14, r28
    5b48:	08 94       	sec
    5b4a:	e1 1c       	adc	r14, r1
    5b4c:	f1 1c       	adc	r15, r1
    5b4e:	04 2f       	mov	r16, r20
    5b50:	10 e0       	ldi	r17, 0x00	; 0
    5b52:	0e c0       	rjmp	.+28     	; 0x5b70 <NormalizeOverflow+0x64>
     for(i=0;i<Length;i++){//123456
	     strMaxValue[i]='0'+((Length-i)/Length);
    5b54:	f7 01       	movw	r30, r14
    5b56:	e2 0f       	add	r30, r18
    5b58:	f3 1f       	adc	r31, r19
    5b5a:	c8 01       	movw	r24, r16
    5b5c:	82 1b       	sub	r24, r18
    5b5e:	93 0b       	sbc	r25, r19
    5b60:	64 2f       	mov	r22, r20
    5b62:	70 e0       	ldi	r23, 0x00	; 0
    5b64:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    5b68:	60 5d       	subi	r22, 0xD0	; 208
    5b6a:	60 83       	st	Z, r22
    5b6c:	2f 5f       	subi	r18, 0xFF	; 255
    5b6e:	3f 4f       	sbci	r19, 0xFF	; 255

void NormalizeOverflow(char *strOverflowed){
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
     for(i=0;i<Length;i++){//123456
    5b70:	24 17       	cp	r18, r20
    5b72:	80 f3       	brcs	.-32     	; 0x5b54 <NormalizeOverflow+0x48>
	     strMaxValue[i]='0'+((Length-i)/Length);
	 }strMaxValue[Length]=0;
    5b74:	0e 0d       	add	r16, r14
    5b76:	1f 1d       	adc	r17, r15
    5b78:	f8 01       	movw	r30, r16
    5b7a:	10 82       	st	Z, r1
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
    5b7c:	81 e0       	ldi	r24, 0x01	; 1
    5b7e:	b7 01       	movw	r22, r14
    5b80:	4d 2d       	mov	r20, r13
    5b82:	5c 2d       	mov	r21, r12
    5b84:	2d 2d       	mov	r18, r13
    5b86:	3c 2d       	mov	r19, r12
    5b88:	0e 94 ef 29 	call	0x53de	; 0x53de <StrCalc>
}
    5b8c:	64 96       	adiw	r28, 0x14	; 20
    5b8e:	0f b6       	in	r0, 0x3f	; 63
    5b90:	f8 94       	cli
    5b92:	de bf       	out	0x3e, r29	; 62
    5b94:	0f be       	out	0x3f, r0	; 63
    5b96:	cd bf       	out	0x3d, r28	; 61
    5b98:	cf 91       	pop	r28
    5b9a:	df 91       	pop	r29
    5b9c:	1f 91       	pop	r17
    5b9e:	0f 91       	pop	r16
    5ba0:	ff 90       	pop	r15
    5ba2:	ef 90       	pop	r14
    5ba4:	df 90       	pop	r13
    5ba6:	cf 90       	pop	r12
    5ba8:	08 95       	ret

00005baa <AddSpaceLead>:
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    5baa:	bf 92       	push	r11
    5bac:	cf 92       	push	r12
    5bae:	df 92       	push	r13
    5bb0:	ef 92       	push	r14
    5bb2:	ff 92       	push	r15
    5bb4:	0f 93       	push	r16
    5bb6:	1f 93       	push	r17
    5bb8:	df 93       	push	r29
    5bba:	cf 93       	push	r28
    5bbc:	cd b7       	in	r28, 0x3d	; 61
    5bbe:	de b7       	in	r29, 0x3e	; 62
    5bc0:	e2 97       	sbiw	r28, 0x32	; 50
    5bc2:	0f b6       	in	r0, 0x3f	; 63
    5bc4:	f8 94       	cli
    5bc6:	de bf       	out	0x3e, r29	; 62
    5bc8:	0f be       	out	0x3f, r0	; 63
    5bca:	cd bf       	out	0x3d, r28	; 61
    5bcc:	8c 01       	movw	r16, r24
     char i,Length,strAdded[50];
     Length=strlen(String);
    5bce:	fc 01       	movw	r30, r24
    5bd0:	01 90       	ld	r0, Z+
    5bd2:	00 20       	and	r0, r0
    5bd4:	e9 f7       	brne	.-6      	; 0x5bd0 <AddSpaceLead+0x26>
    5bd6:	31 97       	sbiw	r30, 0x01	; 1
    5bd8:	2e 2f       	mov	r18, r30
    5bda:	28 1b       	sub	r18, r24

	 if (Size>Length){
    5bdc:	26 17       	cp	r18, r22
    5bde:	e0 f5       	brcc	.+120    	; 0x5c58 <AddSpaceLead+0xae>
    5be0:	7e 01       	movw	r14, r28
    5be2:	08 94       	sec
    5be4:	e1 1c       	adc	r14, r1
    5be6:	f1 1c       	adc	r15, r1
    5be8:	f7 01       	movw	r30, r14
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    5bea:	be 2c       	mov	r11, r14
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
    5bec:	90 e2       	ldi	r25, 0x20	; 32
    5bee:	01 c0       	rjmp	.+2      	; 0x5bf2 <AddSpaceLead+0x48>
    5bf0:	91 93       	st	Z+, r25
void AddSpaceLead(char *String,unsigned char Size){//
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    5bf2:	8e 2f       	mov	r24, r30
    5bf4:	8b 19       	sub	r24, r11
    5bf6:	86 17       	cp	r24, r22
    5bf8:	d8 f3       	brcs	.-10     	; 0x5bf0 <AddSpaceLead+0x46>
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
    5bfa:	46 2f       	mov	r20, r22
    5bfc:	50 e0       	ldi	r21, 0x00	; 0
    5bfe:	ce 01       	movw	r24, r28
    5c00:	01 96       	adiw	r24, 0x01	; 1
    5c02:	fc 01       	movw	r30, r24
    5c04:	e4 0f       	add	r30, r20
    5c06:	f5 1f       	adc	r31, r21
    5c08:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5c0a:	76 2f       	mov	r23, r22
    5c0c:	72 1b       	sub	r23, r18
    5c0e:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    5c10:	30 e0       	ldi	r19, 0x00	; 0
    5c12:	24 1b       	sub	r18, r20
    5c14:	35 0b       	sbc	r19, r21
    5c16:	0c c0       	rjmp	.+24     	; 0x5c30 <AddSpaceLead+0x86>
    5c18:	e7 2f       	mov	r30, r23
    5c1a:	f0 e0       	ldi	r31, 0x00	; 0
    5c1c:	d6 01       	movw	r26, r12
    5c1e:	ae 0f       	add	r26, r30
    5c20:	bf 1f       	adc	r27, r31
    5c22:	e0 0f       	add	r30, r16
    5c24:	f1 1f       	adc	r31, r17
    5c26:	e2 0f       	add	r30, r18
    5c28:	f3 1f       	adc	r31, r19
    5c2a:	80 81       	ld	r24, Z
    5c2c:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5c2e:	7f 5f       	subi	r23, 0xFF	; 255
    5c30:	76 17       	cp	r23, r22
    5c32:	90 f3       	brcs	.-28     	; 0x5c18 <AddSpaceLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    5c34:	4c 0d       	add	r20, r12
    5c36:	5d 1d       	adc	r21, r13
    5c38:	da 01       	movw	r26, r20
    5c3a:	1c 92       	st	X, r1
    5c3c:	f8 01       	movw	r30, r16
    5c3e:	04 c0       	rjmp	.+8      	; 0x5c48 <AddSpaceLead+0x9e>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    5c40:	d7 01       	movw	r26, r14
    5c42:	8d 91       	ld	r24, X+
    5c44:	7d 01       	movw	r14, r26
    5c46:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    5c48:	8e 2d       	mov	r24, r14
    5c4a:	8b 19       	sub	r24, r11
    5c4c:	86 17       	cp	r24, r22
    5c4e:	c0 f3       	brcs	.-16     	; 0x5c40 <AddSpaceLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    5c50:	06 0f       	add	r16, r22
    5c52:	11 1d       	adc	r17, r1
    5c54:	f8 01       	movw	r30, r16
    5c56:	10 82       	st	Z, r1
	 }
}
    5c58:	e2 96       	adiw	r28, 0x32	; 50
    5c5a:	0f b6       	in	r0, 0x3f	; 63
    5c5c:	f8 94       	cli
    5c5e:	de bf       	out	0x3e, r29	; 62
    5c60:	0f be       	out	0x3f, r0	; 63
    5c62:	cd bf       	out	0x3d, r28	; 61
    5c64:	cf 91       	pop	r28
    5c66:	df 91       	pop	r29
    5c68:	1f 91       	pop	r17
    5c6a:	0f 91       	pop	r16
    5c6c:	ff 90       	pop	r15
    5c6e:	ef 90       	pop	r14
    5c70:	df 90       	pop	r13
    5c72:	cf 90       	pop	r12
    5c74:	bf 90       	pop	r11
    5c76:	08 95       	ret

00005c78 <AddSpaceLag>:
	 }
}



void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
    5c78:	cf 93       	push	r28
    5c7a:	df 93       	push	r29
    5c7c:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    5c7e:	dc 01       	movw	r26, r24
    5c80:	0d 90       	ld	r0, X+
    5c82:	00 20       	and	r0, r0
    5c84:	e9 f7       	brne	.-6      	; 0x5c80 <AddSpaceLag+0x8>
    5c86:	11 97       	sbiw	r26, 0x01	; 1
    5c88:	a8 1b       	sub	r26, r24
    5c8a:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    5c8c:	a6 17       	cp	r26, r22
    5c8e:	60 f4       	brcc	.+24     	; 0x5ca8 <AddSpaceLag+0x30>
    5c90:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=' ';
    5c92:	90 e2       	ldi	r25, 0x20	; 32
    5c94:	fe 01       	movw	r30, r28
    5c96:	e8 0f       	add	r30, r24
    5c98:	f1 1d       	adc	r31, r1
    5c9a:	90 83       	st	Z, r25

void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    5c9c:	8f 5f       	subi	r24, 0xFF	; 255
    5c9e:	86 17       	cp	r24, r22
    5ca0:	c8 f3       	brcs	.-14     	; 0x5c94 <AddSpaceLag+0x1c>
	    String[i]=' ';
	 }String[Size]=0;
    5ca2:	c6 0f       	add	r28, r22
    5ca4:	d1 1d       	adc	r29, r1
    5ca6:	18 82       	st	Y, r1
  }
}
    5ca8:	df 91       	pop	r29
    5caa:	cf 91       	pop	r28
    5cac:	08 95       	ret

00005cae <GetProductName>:
	 }    
	 //Clear Decimal

}

void GetProductName(char GradeId,char *strProductName){
    5cae:	0f 93       	push	r16
    5cb0:	1f 93       	push	r17
    5cb2:	df 93       	push	r29
    5cb4:	cf 93       	push	r28
    5cb6:	cd b7       	in	r28, 0x3d	; 61
    5cb8:	de b7       	in	r29, 0x3e	; 62
    5cba:	2c 97       	sbiw	r28, 0x0c	; 12
    5cbc:	0f b6       	in	r0, 0x3f	; 63
    5cbe:	f8 94       	cli
    5cc0:	de bf       	out	0x3e, r29	; 62
    5cc2:	0f be       	out	0x3f, r0	; 63
    5cc4:	cd bf       	out	0x3d, r28	; 61
    5cc6:	48 2f       	mov	r20, r24
    5cc8:	8b 01       	movw	r16, r22
    5cca:	fe 01       	movw	r30, r28
    5ccc:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5cce:	9e 01       	movw	r18, r28
    5cd0:	23 5f       	subi	r18, 0xF3	; 243
    5cd2:	3f 4f       	sbci	r19, 0xFF	; 255
	     strMemory[i]=data;
    5cd4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5cd6:	e2 17       	cp	r30, r18
    5cd8:	f3 07       	cpc	r31, r19
    5cda:	e1 f7       	brne	.-8      	; 0x5cd4 <GetProductName+0x26>
    5cdc:	ce 01       	movw	r24, r28
    5cde:	01 96       	adiw	r24, 0x01	; 1

void GetProductName(char GradeId,char *strProductName){
char SProductName[12],i,Length;
     FillChar(SProductName,sizeof(SProductName),0); 
	 //eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
	 if (GradeId>0) eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
    5ce0:	44 23       	and	r20, r20
    5ce2:	69 f0       	breq	.+26     	; 0x5cfe <GetProductName+0x50>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    5ce4:	6d e0       	ldi	r22, 0x0D	; 13
    5ce6:	46 9f       	mul	r20, r22
    5ce8:	b0 01       	movw	r22, r0
    5cea:	11 24       	eor	r1, r1
    5cec:	62 55       	subi	r22, 0x52	; 82
    5cee:	7f 4f       	sbci	r23, 0xFF	; 255
    5cf0:	4a e0       	ldi	r20, 0x0A	; 10
    5cf2:	50 e0       	ldi	r21, 0x00	; 0
    5cf4:	28 ef       	ldi	r18, 0xF8	; 248
    5cf6:	32 e1       	ldi	r19, 0x12	; 18
    5cf8:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
    5cfc:	14 c0       	rjmp	.+40     	; 0x5d26 <GetProductName+0x78>
	 else sprintf_P(SProductName,PSTR("N/A"));
    5cfe:	00 d0       	rcall	.+0      	; 0x5d00 <GetProductName+0x52>
    5d00:	00 d0       	rcall	.+0      	; 0x5d02 <GetProductName+0x54>
    5d02:	ad b7       	in	r26, 0x3d	; 61
    5d04:	be b7       	in	r27, 0x3e	; 62
    5d06:	12 96       	adiw	r26, 0x02	; 2
    5d08:	9c 93       	st	X, r25
    5d0a:	8e 93       	st	-X, r24
    5d0c:	11 97       	sbiw	r26, 0x01	; 1
    5d0e:	8c ef       	ldi	r24, 0xFC	; 252
    5d10:	93 e0       	ldi	r25, 0x03	; 3
    5d12:	14 96       	adiw	r26, 0x04	; 4
    5d14:	9c 93       	st	X, r25
    5d16:	8e 93       	st	-X, r24
    5d18:	13 97       	sbiw	r26, 0x03	; 3
    5d1a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    5d1e:	0f 90       	pop	r0
    5d20:	0f 90       	pop	r0
    5d22:	0f 90       	pop	r0
    5d24:	0f 90       	pop	r0

     Length=strlen(SProductName);
    5d26:	de 01       	movw	r26, r28
    5d28:	11 96       	adiw	r26, 0x01	; 1
    5d2a:	fd 01       	movw	r30, r26
    5d2c:	01 90       	ld	r0, Z+
    5d2e:	00 20       	and	r0, r0
    5d30:	e9 f7       	brne	.-6      	; 0x5d2c <GetProductName+0x7e>
    5d32:	31 97       	sbiw	r30, 0x01	; 1
    5d34:	ea 1b       	sub	r30, r26
    5d36:	eb 30       	cpi	r30, 0x0B	; 11
    5d38:	08 f0       	brcs	.+2      	; 0x5d3c <GetProductName+0x8e>
    5d3a:	ea e0       	ldi	r30, 0x0A	; 10
    5d3c:	ae 01       	movw	r20, r28
    5d3e:	4f 5f       	subi	r20, 0xFF	; 255
    5d40:	5f 4f       	sbci	r21, 0xFF	; 255
    5d42:	98 01       	movw	r18, r16
    5d44:	ba 01       	movw	r22, r20
    5d46:	06 c0       	rjmp	.+12     	; 0x5d54 <GetProductName+0xa6>
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
	     strProductName[i]=SProductName[i];
    5d48:	db 01       	movw	r26, r22
    5d4a:	8d 91       	ld	r24, X+
    5d4c:	bd 01       	movw	r22, r26
    5d4e:	d9 01       	movw	r26, r18
    5d50:	8d 93       	st	X+, r24
    5d52:	9d 01       	movw	r18, r26
	 else sprintf_P(SProductName,PSTR("N/A"));

     Length=strlen(SProductName);
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
    5d54:	86 2f       	mov	r24, r22
    5d56:	84 1b       	sub	r24, r20
    5d58:	8e 17       	cp	r24, r30
    5d5a:	b0 f3       	brcs	.-20     	; 0x5d48 <GetProductName+0x9a>
	     strProductName[i]=SProductName[i];
	 }strProductName[Length]=0;
    5d5c:	c8 01       	movw	r24, r16
    5d5e:	8e 0f       	add	r24, r30
    5d60:	91 1d       	adc	r25, r1
    5d62:	fc 01       	movw	r30, r24
    5d64:	10 82       	st	Z, r1

	 AddSpaceLag(strProductName,10);
    5d66:	c8 01       	movw	r24, r16
    5d68:	6a e0       	ldi	r22, 0x0A	; 10
    5d6a:	0e 94 3c 2e 	call	0x5c78	; 0x5c78 <AddSpaceLag>
}
    5d6e:	2c 96       	adiw	r28, 0x0c	; 12
    5d70:	0f b6       	in	r0, 0x3f	; 63
    5d72:	f8 94       	cli
    5d74:	de bf       	out	0x3e, r29	; 62
    5d76:	0f be       	out	0x3f, r0	; 63
    5d78:	cd bf       	out	0x3d, r28	; 61
    5d7a:	cf 91       	pop	r28
    5d7c:	df 91       	pop	r29
    5d7e:	1f 91       	pop	r17
    5d80:	0f 91       	pop	r16
    5d82:	08 95       	ret

00005d84 <GeniusSendLastTransaction>:
}
void GeniusSendPumpPreset(char iPumpID){
}


void GeniusSendLastTransaction(char iPumpID){
    5d84:	2f 92       	push	r2
    5d86:	3f 92       	push	r3
    5d88:	4f 92       	push	r4
    5d8a:	5f 92       	push	r5
    5d8c:	6f 92       	push	r6
    5d8e:	7f 92       	push	r7
    5d90:	8f 92       	push	r8
    5d92:	9f 92       	push	r9
    5d94:	af 92       	push	r10
    5d96:	bf 92       	push	r11
    5d98:	cf 92       	push	r12
    5d9a:	df 92       	push	r13
    5d9c:	ef 92       	push	r14
    5d9e:	ff 92       	push	r15
    5da0:	0f 93       	push	r16
    5da2:	1f 93       	push	r17
    5da4:	df 93       	push	r29
    5da6:	cf 93       	push	r28
    5da8:	cd b7       	in	r28, 0x3d	; 61
    5daa:	de b7       	in	r29, 0x3e	; 62
    5dac:	c0 5b       	subi	r28, 0xB0	; 176
    5dae:	d0 40       	sbci	r29, 0x00	; 0
    5db0:	0f b6       	in	r0, 0x3f	; 63
    5db2:	f8 94       	cli
    5db4:	de bf       	out	0x3e, r29	; 62
    5db6:	0f be       	out	0x3f, r0	; 63
    5db8:	cd bf       	out	0x3d, r28	; 61
    5dba:	e8 2e       	mov	r14, r24
    5dbc:	fe 01       	movw	r30, r28
    5dbe:	37 96       	adiw	r30, 0x07	; 7

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5dc0:	ce 01       	movw	r24, r28
    5dc2:	46 96       	adiw	r24, 0x16	; 22
	     strMemory[i]=data;
    5dc4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5dc6:	e8 17       	cp	r30, r24
    5dc8:	f9 07       	cpc	r31, r25
    5dca:	e1 f7       	brne	.-8      	; 0x5dc4 <GeniusSendLastTransaction+0x40>
	     strMemory[i]=data;
    5dcc:	ce 01       	movw	r24, r28
    5dce:	85 96       	adiw	r24, 0x25	; 37
    5dd0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5dd2:	e8 17       	cp	r30, r24
    5dd4:	f9 07       	cpc	r31, r25
    5dd6:	e1 f7       	brne	.-8      	; 0x5dd0 <GeniusSendLastTransaction+0x4c>
	     strMemory[i]=data;
    5dd8:	ce 01       	movw	r24, r28
    5dda:	c4 96       	adiw	r24, 0x34	; 52
    5ddc:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5dde:	e8 17       	cp	r30, r24
    5de0:	f9 07       	cpc	r31, r25
    5de2:	e1 f7       	brne	.-8      	; 0x5ddc <GeniusSendLastTransaction+0x58>
	     strMemory[i]=data;
    5de4:	cf 01       	movw	r24, r30
    5de6:	3f 01       	movw	r6, r30
    5de8:	0f 96       	adiw	r24, 0x0f	; 15
    5dea:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5dec:	e8 17       	cp	r30, r24
    5dee:	f9 07       	cpc	r31, r25
    5df0:	e1 f7       	brne	.-8      	; 0x5dea <GeniusSendLastTransaction+0x66>
	 FillChar(STotalVolume,sizeof(STotalVolume),0);
	 FillChar(STotalMoney,sizeof(STotalMoney),0);
	      

	 //Generate
	 FIPAddr=GetFIPAddr(iPumpID);
    5df2:	8e 2d       	mov	r24, r14
    5df4:	0e 94 dd 1d 	call	0x3bba	; 0x3bba <GetFIPAddr>
    5df8:	96 e0       	ldi	r25, 0x06	; 6
    5dfa:	89 9f       	mul	r24, r25
    5dfc:	b0 01       	movw	r22, r0
    5dfe:	11 24       	eor	r1, r1
    5e00:	61 5b       	subi	r22, 0xB1	; 177
    5e02:	7f 4f       	sbci	r23, 0xFF	; 255
    5e04:	8e 01       	movw	r16, r28
    5e06:	0f 5f       	subi	r16, 0xFF	; 255
    5e08:	1f 4f       	sbci	r17, 0xFF	; 255
    5e0a:	c8 01       	movw	r24, r16
    5e0c:	46 e0       	ldi	r20, 0x06	; 6
    5e0e:	50 e0       	ldi	r21, 0x00	; 0
    5e10:	28 ef       	ldi	r18, 0xF8	; 248
    5e12:	32 e1       	ldi	r19, 0x12	; 18
    5e14:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);
	 iNozzle=RecPumpData[iPumpID&0x0F].Grade;
    5e18:	2e 2c       	mov	r2, r14
    5e1a:	33 24       	eor	r3, r3
    5e1c:	91 01       	movw	r18, r2
    5e1e:	2f 70       	andi	r18, 0x0F	; 15
    5e20:	30 70       	andi	r19, 0x00	; 0
    5e22:	85 e3       	ldi	r24, 0x35	; 53
    5e24:	90 e0       	ldi	r25, 0x00	; 0
    5e26:	28 9f       	mul	r18, r24
    5e28:	f0 01       	movw	r30, r0
    5e2a:	29 9f       	mul	r18, r25
    5e2c:	f0 0d       	add	r31, r0
    5e2e:	38 9f       	mul	r19, r24
    5e30:	f0 0d       	add	r31, r0
    5e32:	11 24       	eor	r1, r1
    5e34:	e5 57       	subi	r30, 0x75	; 117
    5e36:	f8 4f       	sbci	r31, 0xF8	; 248
    5e38:	f0 80       	ld	r15, Z
	 iProdID=PProductID[iNozzle];
    5e3a:	4f 2c       	mov	r4, r15
    5e3c:	55 24       	eor	r5, r5

	 GetProductName(iProdID,strProduct);
    5e3e:	04 0d       	add	r16, r4
    5e40:	15 1d       	adc	r17, r5
    5e42:	d8 01       	movw	r26, r16
    5e44:	8c 91       	ld	r24, X
    5e46:	61 e4       	ldi	r22, 0x41	; 65
    5e48:	79 e0       	ldi	r23, 0x09	; 9
    5e4a:	0e 94 57 2e 	call	0x5cae	; 0x5cae <GetProductName>
	 GetTransactionVolume(iPumpID,SVolume);
    5e4e:	87 e0       	ldi	r24, 0x07	; 7
    5e50:	88 2e       	mov	r8, r24
    5e52:	91 2c       	mov	r9, r1
    5e54:	8c 0e       	add	r8, r28
    5e56:	9d 1e       	adc	r9, r29
    5e58:	8e 2d       	mov	r24, r14
    5e5a:	b4 01       	movw	r22, r8
    5e5c:	0e 94 0e 28 	call	0x501c	; 0x501c <GetTransactionVolume>
	 GetTransactionMoney(iPumpID,SMoney);
    5e60:	06 e1       	ldi	r16, 0x16	; 22
    5e62:	a0 2e       	mov	r10, r16
    5e64:	b1 2c       	mov	r11, r1
    5e66:	ac 0e       	add	r10, r28
    5e68:	bd 1e       	adc	r11, r29
    5e6a:	8e 2d       	mov	r24, r14
    5e6c:	b5 01       	movw	r22, r10
    5e6e:	0e 94 d4 27 	call	0x4fa8	; 0x4fa8 <GetTransactionMoney>
	 GetTotalizerVolume(iPumpID,iNozzle,STotalVolume);
    5e72:	15 e2       	ldi	r17, 0x25	; 37
    5e74:	c1 2e       	mov	r12, r17
    5e76:	d1 2c       	mov	r13, r1
    5e78:	cc 0e       	add	r12, r28
    5e7a:	dd 1e       	adc	r13, r29
    5e7c:	8e 2d       	mov	r24, r14
    5e7e:	6f 2d       	mov	r22, r15
    5e80:	a6 01       	movw	r20, r12
    5e82:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <GetTotalizerVolume>
	 GetTotalizerMoney(iPumpID,iNozzle,STotalMoney);
    5e86:	8e 2d       	mov	r24, r14
    5e88:	6f 2d       	mov	r22, r15
    5e8a:	a3 01       	movw	r20, r6
    5e8c:	0e 94 9a 27 	call	0x4f34	; 0x4f34 <GetTotalizerMoney>
	 
     ComposeDatetime(SDatetime);
    5e90:	b3 e4       	ldi	r27, 0x43	; 67
    5e92:	eb 2e       	mov	r14, r27
    5e94:	f1 2c       	mov	r15, r1
    5e96:	ec 0e       	add	r14, r28
    5e98:	fd 1e       	adc	r15, r29
    5e9a:	c7 01       	movw	r24, r14
    5e9c:	0e 94 4f 1b 	call	0x369e	; 0x369e <ComposeDatetime>

	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
    5ea0:	ed b7       	in	r30, 0x3d	; 61
    5ea2:	fe b7       	in	r31, 0x3e	; 62
    5ea4:	74 97       	sbiw	r30, 0x14	; 20
    5ea6:	0f b6       	in	r0, 0x3f	; 63
    5ea8:	f8 94       	cli
    5eaa:	fe bf       	out	0x3e, r31	; 62
    5eac:	0f be       	out	0x3f, r0	; 63
    5eae:	ed bf       	out	0x3d, r30	; 61
    5eb0:	31 96       	adiw	r30, 0x01	; 1
    5eb2:	8e 01       	movw	r16, r28
    5eb4:	09 5a       	subi	r16, 0xA9	; 169
    5eb6:	1f 4f       	sbci	r17, 0xFF	; 255
    5eb8:	ad b7       	in	r26, 0x3d	; 61
    5eba:	be b7       	in	r27, 0x3e	; 62
    5ebc:	12 96       	adiw	r26, 0x02	; 2
    5ebe:	1c 93       	st	X, r17
    5ec0:	0e 93       	st	-X, r16
    5ec2:	11 97       	sbiw	r26, 0x01	; 1
    5ec4:	8f e3       	ldi	r24, 0x3F	; 63
    5ec6:	93 e0       	ldi	r25, 0x03	; 3
    5ec8:	93 83       	std	Z+3, r25	; 0x03
    5eca:	82 83       	std	Z+2, r24	; 0x02
    5ecc:	35 82       	std	Z+5, r3	; 0x05
    5ece:	24 82       	std	Z+4, r2	; 0x04
    5ed0:	57 82       	std	Z+7, r5	; 0x07
    5ed2:	46 82       	std	Z+6, r4	; 0x06
    5ed4:	81 e4       	ldi	r24, 0x41	; 65
    5ed6:	99 e0       	ldi	r25, 0x09	; 9
    5ed8:	91 87       	std	Z+9, r25	; 0x09
    5eda:	80 87       	std	Z+8, r24	; 0x08
    5edc:	f3 86       	std	Z+11, r15	; 0x0b
    5ede:	e2 86       	std	Z+10, r14	; 0x0a
    5ee0:	95 86       	std	Z+13, r9	; 0x0d
    5ee2:	84 86       	std	Z+12, r8	; 0x0c
    5ee4:	b7 86       	std	Z+15, r11	; 0x0f
    5ee6:	a6 86       	std	Z+14, r10	; 0x0e
    5ee8:	d1 8a       	std	Z+17, r13	; 0x11
    5eea:	c0 8a       	std	Z+16, r12	; 0x10
    5eec:	62 8a       	std	Z+18, r6	; 0x12
    5eee:	73 8a       	std	Z+19, r7	; 0x13
    5ef0:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	 cSum=SumChecksum(strSend);
    5ef4:	ad b7       	in	r26, 0x3d	; 61
    5ef6:	be b7       	in	r27, 0x3e	; 62
    5ef8:	54 96       	adiw	r26, 0x14	; 20
    5efa:	0f b6       	in	r0, 0x3f	; 63
    5efc:	f8 94       	cli
    5efe:	be bf       	out	0x3e, r27	; 62
    5f00:	0f be       	out	0x3f, r0	; 63
    5f02:	ad bf       	out	0x3d, r26	; 61
    5f04:	c8 01       	movw	r24, r16
    5f06:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <SumChecksum>
    5f0a:	e8 2e       	mov	r14, r24
	 _uart_print(1,0,strSend);
    5f0c:	81 e0       	ldi	r24, 0x01	; 1
    5f0e:	60 e0       	ldi	r22, 0x00	; 0
    5f10:	a8 01       	movw	r20, r16
    5f12:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
    5f16:	f8 01       	movw	r30, r16

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5f18:	c8 01       	movw	r24, r16
    5f1a:	f9 2e       	mov	r15, r25
    5f1c:	ce 01       	movw	r24, r28
    5f1e:	8f 54       	subi	r24, 0x4F	; 79
    5f20:	9f 4f       	sbci	r25, 0xFF	; 255
	     strMemory[i]=data;
    5f22:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5f24:	e8 17       	cp	r30, r24
    5f26:	f9 07       	cpc	r31, r25
    5f28:	e1 f7       	brne	.-8      	; 0x5f22 <GeniusSendLastTransaction+0x19e>
	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
	 cSum=SumChecksum(strSend);
	 _uart_print(1,0,strSend);
	 FillChar(strSend,sizeof(strSend),0);      
	 sprintf_P(strSend,PSTR("%d"),cSum);
    5f2a:	00 d0       	rcall	.+0      	; 0x5f2c <GeniusSendLastTransaction+0x1a8>
    5f2c:	00 d0       	rcall	.+0      	; 0x5f2e <GeniusSendLastTransaction+0x1aa>
    5f2e:	00 d0       	rcall	.+0      	; 0x5f30 <GeniusSendLastTransaction+0x1ac>
    5f30:	ed b7       	in	r30, 0x3d	; 61
    5f32:	fe b7       	in	r31, 0x3e	; 62
    5f34:	31 96       	adiw	r30, 0x01	; 1
    5f36:	ad b7       	in	r26, 0x3d	; 61
    5f38:	be b7       	in	r27, 0x3e	; 62
    5f3a:	11 96       	adiw	r26, 0x01	; 1
    5f3c:	0c 93       	st	X, r16
    5f3e:	11 97       	sbiw	r26, 0x01	; 1
    5f40:	12 96       	adiw	r26, 0x02	; 2
    5f42:	fc 92       	st	X, r15
    5f44:	8c e3       	ldi	r24, 0x3C	; 60
    5f46:	93 e0       	ldi	r25, 0x03	; 3
    5f48:	93 83       	std	Z+3, r25	; 0x03
    5f4a:	82 83       	std	Z+2, r24	; 0x02
    5f4c:	e4 82       	std	Z+4, r14	; 0x04
    5f4e:	15 82       	std	Z+5, r1	; 0x05
    5f50:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	 _uart_print(1,1,strSend);	 
    5f54:	ed b7       	in	r30, 0x3d	; 61
    5f56:	fe b7       	in	r31, 0x3e	; 62
    5f58:	36 96       	adiw	r30, 0x06	; 6
    5f5a:	0f b6       	in	r0, 0x3f	; 63
    5f5c:	f8 94       	cli
    5f5e:	fe bf       	out	0x3e, r31	; 62
    5f60:	0f be       	out	0x3f, r0	; 63
    5f62:	ed bf       	out	0x3d, r30	; 61
    5f64:	81 e0       	ldi	r24, 0x01	; 1
    5f66:	61 e0       	ldi	r22, 0x01	; 1
    5f68:	40 2f       	mov	r20, r16
    5f6a:	5f 2d       	mov	r21, r15
    5f6c:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
}
    5f70:	c0 55       	subi	r28, 0x50	; 80
    5f72:	df 4f       	sbci	r29, 0xFF	; 255
    5f74:	0f b6       	in	r0, 0x3f	; 63
    5f76:	f8 94       	cli
    5f78:	de bf       	out	0x3e, r29	; 62
    5f7a:	0f be       	out	0x3f, r0	; 63
    5f7c:	cd bf       	out	0x3d, r28	; 61
    5f7e:	cf 91       	pop	r28
    5f80:	df 91       	pop	r29
    5f82:	1f 91       	pop	r17
    5f84:	0f 91       	pop	r16
    5f86:	ff 90       	pop	r15
    5f88:	ef 90       	pop	r14
    5f8a:	df 90       	pop	r13
    5f8c:	cf 90       	pop	r12
    5f8e:	bf 90       	pop	r11
    5f90:	af 90       	pop	r10
    5f92:	9f 90       	pop	r9
    5f94:	8f 90       	pop	r8
    5f96:	7f 90       	pop	r7
    5f98:	6f 90       	pop	r6
    5f9a:	5f 90       	pop	r5
    5f9c:	4f 90       	pop	r4
    5f9e:	3f 90       	pop	r3
    5fa0:	2f 90       	pop	r2
    5fa2:	08 95       	ret

00005fa4 <systemGeniusProtocol>:

void systemGeniusProtocol(){
static char stGeniusProtocol=gpInitScan;
static char iPumpID;
	 
	 switch(stGeniusProtocol){
    5fa4:	80 91 dc 01 	lds	r24, 0x01DC
    5fa8:	83 30       	cpi	r24, 0x03	; 3
    5faa:	71 f1       	breq	.+92     	; 0x6008 <systemGeniusProtocol+0x64>
    5fac:	84 30       	cpi	r24, 0x04	; 4
    5fae:	28 f4       	brcc	.+10     	; 0x5fba <systemGeniusProtocol+0x16>
    5fb0:	81 30       	cpi	r24, 0x01	; 1
    5fb2:	81 f0       	breq	.+32     	; 0x5fd4 <systemGeniusProtocol+0x30>
    5fb4:	82 30       	cpi	r24, 0x02	; 2
    5fb6:	c0 f4       	brcc	.+48     	; 0x5fe8 <systemGeniusProtocol+0x44>
    5fb8:	09 c0       	rjmp	.+18     	; 0x5fcc <systemGeniusProtocol+0x28>
    5fba:	85 30       	cpi	r24, 0x05	; 5
    5fbc:	09 f4       	brne	.+2      	; 0x5fc0 <systemGeniusProtocol+0x1c>
    5fbe:	49 c0       	rjmp	.+146    	; 0x6052 <systemGeniusProtocol+0xae>
    5fc0:	85 30       	cpi	r24, 0x05	; 5
    5fc2:	c0 f1       	brcs	.+112    	; 0x6034 <systemGeniusProtocol+0x90>
    5fc4:	86 30       	cpi	r24, 0x06	; 6
    5fc6:	09 f0       	breq	.+2      	; 0x5fca <systemGeniusProtocol+0x26>
    5fc8:	60 c0       	rjmp	.+192    	; 0x608a <systemGeniusProtocol+0xe6>
    5fca:	4d c0       	rjmp	.+154    	; 0x6066 <systemGeniusProtocol+0xc2>
	 case gpInitScan:
	      iPumpID=1;
    5fcc:	81 e0       	ldi	r24, 0x01	; 1
    5fce:	80 93 db 01 	sts	0x01DB, r24
    5fd2:	46 c0       	rjmp	.+140    	; 0x6060 <systemGeniusProtocol+0xbc>
          stGeniusProtocol=gpScanNewTransaction;
	      break;
	 case gpScanNewTransaction:
	      if (GetIncomingTransStatus(PumpID)==TS_NEW){
    5fd4:	80 91 da 01 	lds	r24, 0x01DA
    5fd8:	0e 94 df 1a 	call	0x35be	; 0x35be <GetIncomingTransStatus>
    5fdc:	82 30       	cpi	r24, 0x02	; 2
    5fde:	09 f0       	breq	.+2      	; 0x5fe2 <systemGeniusProtocol+0x3e>
    5fe0:	54 c0       	rjmp	.+168    	; 0x608a <systemGeniusProtocol+0xe6>
		      IsTotalizerReceived=False;
    5fe2:	10 92 c5 01 	sts	0x01C5, r1
    5fe6:	3c c0       	rjmp	.+120    	; 0x6060 <systemGeniusProtocol+0xbc>
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
    5fe8:	90 91 db 01 	lds	r25, 0x01DB
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    5fec:	85 e0       	ldi	r24, 0x05	; 5
    5fee:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    5ff2:	90 93 3c 0f 	sts	0x0F3C, r25
     IsControlPooling=True;
    5ff6:	81 e0       	ldi	r24, 0x01	; 1
    5ff8:	80 93 97 01 	sts	0x0197, r24
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
		  TimSend=0;
    5ffc:	10 92 a9 01 	sts	0x01A9, r1
    6000:	10 92 a8 01 	sts	0x01A8, r1
		  stGeniusProtocol=gpWaitRequestedTotalizer;
    6004:	83 e0       	ldi	r24, 0x03	; 3
    6006:	2c c0       	rjmp	.+88     	; 0x6060 <systemGeniusProtocol+0xbc>
	      break;
     case gpWaitRequestedTotalizer:
	      if ((IsTotalizerReceived==True)&&(AcknoledgePump==iPumpID)){
    6008:	80 91 c5 01 	lds	r24, 0x01C5
    600c:	81 30       	cpi	r24, 0x01	; 1
    600e:	59 f4       	brne	.+22     	; 0x6026 <systemGeniusProtocol+0x82>
    6010:	90 91 3f 0f 	lds	r25, 0x0F3F
    6014:	80 91 db 01 	lds	r24, 0x01DB
    6018:	98 17       	cp	r25, r24
    601a:	29 f4       	brne	.+10     	; 0x6026 <systemGeniusProtocol+0x82>
		      IsTotalizerReceived=False;
    601c:	10 92 c5 01 	sts	0x01C5, r1
			  stGeniusProtocol=gpSendTransactionData;
    6020:	84 e0       	ldi	r24, 0x04	; 4
    6022:	80 93 dc 01 	sts	0x01DC, r24
		  }
	      if (TimSend>TIM_SEND*2)stGeniusProtocol=gpNextPumpScan;
    6026:	80 91 a8 01 	lds	r24, 0x01A8
    602a:	90 91 a9 01 	lds	r25, 0x01A9
    602e:	45 97       	sbiw	r24, 0x15	; 21
    6030:	60 f1       	brcs	.+88     	; 0x608a <systemGeniusProtocol+0xe6>
    6032:	15 c0       	rjmp	.+42     	; 0x605e <systemGeniusProtocol+0xba>
	      break;
     case gpSendTransactionData:
          GeniusSendLastTransaction(iPumpID);
    6034:	80 91 db 01 	lds	r24, 0x01DB
    6038:	0e 94 c2 2e 	call	0x5d84	; 0x5d84 <GeniusSendLastTransaction>
		  SetIncomingTransStatus(iPumpID,TS_OLD);
    603c:	80 91 db 01 	lds	r24, 0x01DB
    6040:	63 e0       	ldi	r22, 0x03	; 3
    6042:	0e 94 ad 1a 	call	0x355a	; 0x355a <SetIncomingTransStatus>
		  
		  TimSend=0;
    6046:	10 92 a9 01 	sts	0x01A9, r1
    604a:	10 92 a8 01 	sts	0x01A8, r1
          stGeniusProtocol=gpDelayNextPumpScan;
    604e:	85 e0       	ldi	r24, 0x05	; 5
    6050:	07 c0       	rjmp	.+14     	; 0x6060 <systemGeniusProtocol+0xbc>
	      break;
     case gpDelayNextPumpScan:
          if (TimSend>1)stGeniusProtocol=gpNextPumpScan;
    6052:	80 91 a8 01 	lds	r24, 0x01A8
    6056:	90 91 a9 01 	lds	r25, 0x01A9
    605a:	02 97       	sbiw	r24, 0x02	; 2
    605c:	b0 f0       	brcs	.+44     	; 0x608a <systemGeniusProtocol+0xe6>
    605e:	86 e0       	ldi	r24, 0x06	; 6
    6060:	80 93 dc 01 	sts	0x01DC, r24
    6064:	08 95       	ret
	      break;
     case gpNextPumpScan:
          if (iPumpID<=eeprom_read_byte(&DefPoolingPumpMax)){
    6066:	20 91 db 01 	lds	r18, 0x01DB
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    606a:	e1 99       	sbic	0x1c, 1	; 28
    606c:	fe cf       	rjmp	.-4      	; 0x606a <systemGeniusProtocol+0xc6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    606e:	84 e4       	ldi	r24, 0x44	; 68
    6070:	91 e0       	ldi	r25, 0x01	; 1
    6072:	9f bb       	out	0x1f, r25	; 31
    6074:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6076:	e0 9a       	sbi	0x1c, 0	; 28
    6078:	8d b3       	in	r24, 0x1d	; 29
    607a:	82 17       	cp	r24, r18
    607c:	30 f0       	brcs	.+12     	; 0x608a <systemGeniusProtocol+0xe6>
		      iPumpID++;
    607e:	2f 5f       	subi	r18, 0xFF	; 255
    6080:	20 93 db 01 	sts	0x01DB, r18
              stGeniusProtocol=gpScanNewTransaction;
    6084:	81 e0       	ldi	r24, 0x01	; 1
    6086:	80 93 dc 01 	sts	0x01DC, r24
    608a:	08 95       	ret

0000608c <StrAlignCenter>:
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrAlignCenter(char *Source, unsigned int Length){
    608c:	ef 92       	push	r14
    608e:	ff 92       	push	r15
    6090:	0f 93       	push	r16
    6092:	1f 93       	push	r17
    6094:	18 2f       	mov	r17, r24
    6096:	09 2f       	mov	r16, r25
    6098:	7b 01       	movw	r14, r22
char nAddedSpace,srcLength;
     RemSpaceLag(Source);
    609a:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
	 RemSpaceLead(Source);
    609e:	81 2f       	mov	r24, r17
    60a0:	90 2f       	mov	r25, r16
    60a2:	0e 94 fd 25 	call	0x4bfa	; 0x4bfa <RemSpaceLead>
	 srcLength=strlen(Source);
    60a6:	a1 2f       	mov	r26, r17
    60a8:	b0 2f       	mov	r27, r16
    60aa:	fd 01       	movw	r30, r26
    60ac:	01 90       	ld	r0, Z+
    60ae:	00 20       	and	r0, r0
    60b0:	e9 f7       	brne	.-6      	; 0x60ac <StrAlignCenter+0x20>
    60b2:	31 97       	sbiw	r30, 0x01	; 1
    60b4:	e1 1b       	sub	r30, r17
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
    60b6:	c7 01       	movw	r24, r14
    60b8:	8e 1b       	sub	r24, r30
    60ba:	91 09       	sbc	r25, r1
    60bc:	96 95       	lsr	r25
    60be:	87 95       	ror	r24
    60c0:	e8 0f       	add	r30, r24
    60c2:	81 2f       	mov	r24, r17
    60c4:	90 2f       	mov	r25, r16
    60c6:	6e 2f       	mov	r22, r30
    60c8:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <AddSpaceLead>
	 AddSpaceLag(Source,Length);
    60cc:	81 2f       	mov	r24, r17
    60ce:	90 2f       	mov	r25, r16
    60d0:	6e 2d       	mov	r22, r14
    60d2:	0e 94 3c 2e 	call	0x5c78	; 0x5c78 <AddSpaceLag>
}
    60d6:	1f 91       	pop	r17
    60d8:	0f 91       	pop	r16
    60da:	ff 90       	pop	r15
    60dc:	ef 90       	pop	r14
    60de:	08 95       	ret

000060e0 <AddCharLead>:
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    60e0:	bf 92       	push	r11
    60e2:	cf 92       	push	r12
    60e4:	df 92       	push	r13
    60e6:	ef 92       	push	r14
    60e8:	ff 92       	push	r15
    60ea:	0f 93       	push	r16
    60ec:	1f 93       	push	r17
    60ee:	df 93       	push	r29
    60f0:	cf 93       	push	r28
    60f2:	cd b7       	in	r28, 0x3d	; 61
    60f4:	de b7       	in	r29, 0x3e	; 62
    60f6:	6e 97       	sbiw	r28, 0x1e	; 30
    60f8:	0f b6       	in	r0, 0x3f	; 63
    60fa:	f8 94       	cli
    60fc:	de bf       	out	0x3e, r29	; 62
    60fe:	0f be       	out	0x3f, r0	; 63
    6100:	cd bf       	out	0x3d, r28	; 61
    6102:	8c 01       	movw	r16, r24
    6104:	e4 2e       	mov	r14, r20
     char i,Length,strAdded[30];
     Length=strlen(String);
    6106:	fc 01       	movw	r30, r24
    6108:	01 90       	ld	r0, Z+
    610a:	00 20       	and	r0, r0
    610c:	e9 f7       	brne	.-6      	; 0x6108 <AddCharLead+0x28>
    610e:	31 97       	sbiw	r30, 0x01	; 1
    6110:	2e 2f       	mov	r18, r30
    6112:	28 1b       	sub	r18, r24

	 if (Size>Length){
    6114:	24 17       	cp	r18, r20
    6116:	d0 f5       	brcc	.+116    	; 0x618c <AddCharLead+0xac>
    6118:	ae 01       	movw	r20, r28
    611a:	4f 5f       	subi	r20, 0xFF	; 255
    611c:	5f 4f       	sbci	r21, 0xFF	; 255
    611e:	fa 01       	movw	r30, r20
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    6120:	b4 2e       	mov	r11, r20
    6122:	01 c0       	rjmp	.+2      	; 0x6126 <AddCharLead+0x46>
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
    6124:	61 93       	st	Z+, r22
void AddCharLead(char *String,char CharAdded,unsigned char Size){//
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    6126:	8e 2f       	mov	r24, r30
    6128:	8b 19       	sub	r24, r11
    612a:	8e 15       	cp	r24, r14
    612c:	d8 f3       	brcs	.-10     	; 0x6124 <AddCharLead+0x44>
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
    612e:	6e 2d       	mov	r22, r14
    6130:	70 e0       	ldi	r23, 0x00	; 0
    6132:	ce 01       	movw	r24, r28
    6134:	01 96       	adiw	r24, 0x01	; 1
    6136:	fc 01       	movw	r30, r24
    6138:	e6 0f       	add	r30, r22
    613a:	f7 1f       	adc	r31, r23
    613c:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    613e:	fe 2c       	mov	r15, r14
    6140:	f2 1a       	sub	r15, r18
    6142:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    6144:	30 e0       	ldi	r19, 0x00	; 0
    6146:	26 1b       	sub	r18, r22
    6148:	37 0b       	sbc	r19, r23
    614a:	0c c0       	rjmp	.+24     	; 0x6164 <AddCharLead+0x84>
    614c:	ef 2d       	mov	r30, r15
    614e:	f0 e0       	ldi	r31, 0x00	; 0
    6150:	d6 01       	movw	r26, r12
    6152:	ae 0f       	add	r26, r30
    6154:	bf 1f       	adc	r27, r31
    6156:	e0 0f       	add	r30, r16
    6158:	f1 1f       	adc	r31, r17
    615a:	e2 0f       	add	r30, r18
    615c:	f3 1f       	adc	r31, r19
    615e:	80 81       	ld	r24, Z
    6160:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    6162:	f3 94       	inc	r15
    6164:	fe 14       	cp	r15, r14
    6166:	90 f3       	brcs	.-28     	; 0x614c <AddCharLead+0x6c>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    6168:	6c 0d       	add	r22, r12
    616a:	7d 1d       	adc	r23, r13
    616c:	db 01       	movw	r26, r22
    616e:	1c 92       	st	X, r1
    6170:	f8 01       	movw	r30, r16
    6172:	04 c0       	rjmp	.+8      	; 0x617c <AddCharLead+0x9c>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    6174:	da 01       	movw	r26, r20
    6176:	8d 91       	ld	r24, X+
    6178:	ad 01       	movw	r20, r26
    617a:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    617c:	84 2f       	mov	r24, r20
    617e:	8b 19       	sub	r24, r11
    6180:	8e 15       	cp	r24, r14
    6182:	c0 f3       	brcs	.-16     	; 0x6174 <AddCharLead+0x94>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    6184:	0e 0d       	add	r16, r14
    6186:	11 1d       	adc	r17, r1
    6188:	f8 01       	movw	r30, r16
    618a:	10 82       	st	Z, r1
	 }
}
    618c:	6e 96       	adiw	r28, 0x1e	; 30
    618e:	0f b6       	in	r0, 0x3f	; 63
    6190:	f8 94       	cli
    6192:	de bf       	out	0x3e, r29	; 62
    6194:	0f be       	out	0x3f, r0	; 63
    6196:	cd bf       	out	0x3d, r28	; 61
    6198:	cf 91       	pop	r28
    619a:	df 91       	pop	r29
    619c:	1f 91       	pop	r17
    619e:	0f 91       	pop	r16
    61a0:	ff 90       	pop	r15
    61a2:	ef 90       	pop	r14
    61a4:	df 90       	pop	r13
    61a6:	cf 90       	pop	r12
    61a8:	bf 90       	pop	r11
    61aa:	08 95       	ret

000061ac <AddCharLag>:
    }
return Result;
}

//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
    61ac:	cf 93       	push	r28
    61ae:	df 93       	push	r29
    61b0:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    61b2:	dc 01       	movw	r26, r24
    61b4:	0d 90       	ld	r0, X+
    61b6:	00 20       	and	r0, r0
    61b8:	e9 f7       	brne	.-6      	; 0x61b4 <AddCharLag+0x8>
    61ba:	11 97       	sbiw	r26, 0x01	; 1
    61bc:	a8 1b       	sub	r26, r24
    61be:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    61c0:	a4 17       	cp	r26, r20
    61c2:	58 f4       	brcc	.+22     	; 0x61da <AddCharLag+0x2e>
    61c4:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=CharAdded;
    61c6:	fe 01       	movw	r30, r28
    61c8:	e8 0f       	add	r30, r24
    61ca:	f1 1d       	adc	r31, r1
    61cc:	60 83       	st	Z, r22
//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    61ce:	8f 5f       	subi	r24, 0xFF	; 255
    61d0:	84 17       	cp	r24, r20
    61d2:	c8 f3       	brcs	.-14     	; 0x61c6 <AddCharLag+0x1a>
	    String[i]=CharAdded;
	 }String[Size]=0;
    61d4:	c4 0f       	add	r28, r20
    61d6:	d1 1d       	adc	r29, r1
    61d8:	18 82       	st	Y, r1
  }

}
    61da:	df 91       	pop	r29
    61dc:	cf 91       	pop	r28
    61de:	08 95       	ret

000061e0 <CountTotalizerSatus>:
		      Result++;		  
		  }	 
	 }
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
    61e0:	cf 92       	push	r12
    61e2:	df 92       	push	r13
    61e4:	ef 92       	push	r14
    61e6:	ff 92       	push	r15
    61e8:	0f 93       	push	r16
    61ea:	1f 93       	push	r17
    61ec:	cf 93       	push	r28
    61ee:	df 93       	push	r29
    61f0:	7c 01       	movw	r14, r24
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    61f2:	dc 01       	movw	r26, r24
    61f4:	0d 90       	ld	r0, X+
    61f6:	00 20       	and	r0, r0
    61f8:	e9 f7       	brne	.-6      	; 0x61f4 <CountTotalizerSatus+0x14>
    61fa:	8d 01       	movw	r16, r26
    61fc:	01 50       	subi	r16, 0x01	; 1
    61fe:	10 40       	sbci	r17, 0x00	; 0
    6200:	08 1b       	sub	r16, r24
    6202:	19 0b       	sbc	r17, r25
    6204:	cc 24       	eor	r12, r12
    6206:	dd 24       	eor	r13, r13
    6208:	0a c0       	rjmp	.+20     	; 0x621e <CountTotalizerSatus+0x3e>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
    620a:	84 e1       	ldi	r24, 0x14	; 20
    620c:	0e 94 95 13 	call	0x272a	; 0x272a <GetPumpStatusLabel>
    6210:	ce 0d       	add	r28, r14
    6212:	df 1d       	adc	r29, r15
    6214:	98 81       	ld	r25, Y
    6216:	98 17       	cp	r25, r24
    6218:	09 f4       	brne	.+2      	; 0x621c <CountTotalizerSatus+0x3c>
		      Result++;		  
    621a:	d3 94       	inc	r13
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    621c:	c3 94       	inc	r12
    621e:	cc 2d       	mov	r28, r12
    6220:	d0 e0       	ldi	r29, 0x00	; 0
    6222:	c0 17       	cp	r28, r16
    6224:	d1 07       	cpc	r29, r17
    6226:	88 f3       	brcs	.-30     	; 0x620a <CountTotalizerSatus+0x2a>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    6228:	8d 2d       	mov	r24, r13
    622a:	df 91       	pop	r29
    622c:	cf 91       	pop	r28
    622e:	1f 91       	pop	r17
    6230:	0f 91       	pop	r16
    6232:	ff 90       	pop	r15
    6234:	ef 90       	pop	r14
    6236:	df 90       	pop	r13
    6238:	cf 90       	pop	r12
    623a:	08 95       	ret

0000623c <RemoveChar>:
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif
}

void RemoveChar(char *strSource, char cRem){
    623c:	1f 93       	push	r17
    623e:	df 93       	push	r29
    6240:	cf 93       	push	r28
    6242:	cd b7       	in	r28, 0x3d	; 61
    6244:	de b7       	in	r29, 0x3e	; 62
    6246:	64 97       	sbiw	r28, 0x14	; 20
    6248:	0f b6       	in	r0, 0x3f	; 63
    624a:	f8 94       	cli
    624c:	de bf       	out	0x3e, r29	; 62
    624e:	0f be       	out	0x3f, r0	; 63
    6250:	cd bf       	out	0x3d, r28	; 61
    6252:	16 2f       	mov	r17, r22
    6254:	50 e0       	ldi	r21, 0x00	; 0
    6256:	40 e0       	ldi	r20, 0x00	; 0
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
    6258:	be 01       	movw	r22, r28
    625a:	6f 5f       	subi	r22, 0xFF	; 255
    625c:	7f 4f       	sbci	r23, 0xFF	; 255
    625e:	0c c0       	rjmp	.+24     	; 0x6278 <RemoveChar+0x3c>

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
    6260:	28 0f       	add	r18, r24
    6262:	39 1f       	adc	r19, r25
    6264:	d9 01       	movw	r26, r18
    6266:	2c 91       	ld	r18, X
    6268:	21 17       	cp	r18, r17
    626a:	29 f0       	breq	.+10     	; 0x6276 <RemoveChar+0x3a>
		     sTemp[iAdd]=strSource[i];
    626c:	fb 01       	movw	r30, r22
    626e:	e4 0f       	add	r30, r20
    6270:	f1 1d       	adc	r31, r1
    6272:	20 83       	st	Z, r18
			 iAdd++;
    6274:	4f 5f       	subi	r20, 0xFF	; 255
}

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
    6276:	5f 5f       	subi	r21, 0xFF	; 255
    6278:	25 2f       	mov	r18, r21
    627a:	30 e0       	ldi	r19, 0x00	; 0
    627c:	fc 01       	movw	r30, r24
    627e:	01 90       	ld	r0, Z+
    6280:	00 20       	and	r0, r0
    6282:	e9 f7       	brne	.-6      	; 0x627e <RemoveChar+0x42>
    6284:	31 97       	sbiw	r30, 0x01	; 1
    6286:	e8 1b       	sub	r30, r24
    6288:	f9 0b       	sbc	r31, r25
    628a:	2e 17       	cp	r18, r30
    628c:	3f 07       	cpc	r19, r31
    628e:	40 f3       	brcs	.-48     	; 0x6260 <RemoveChar+0x24>
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
			 iAdd++;
          }
	 }sTemp[iAdd]=0;
    6290:	9e 01       	movw	r18, r28
    6292:	2f 5f       	subi	r18, 0xFF	; 255
    6294:	3f 4f       	sbci	r19, 0xFF	; 255
    6296:	f9 01       	movw	r30, r18
    6298:	e4 0f       	add	r30, r20
    629a:	f1 1d       	adc	r31, r1
    629c:	10 82       	st	Z, r1
	 sprintf_P(strSource,PSTR("%s"),sTemp);
    629e:	00 d0       	rcall	.+0      	; 0x62a0 <RemoveChar+0x64>
    62a0:	00 d0       	rcall	.+0      	; 0x62a2 <RemoveChar+0x66>
    62a2:	00 d0       	rcall	.+0      	; 0x62a4 <RemoveChar+0x68>
    62a4:	ed b7       	in	r30, 0x3d	; 61
    62a6:	fe b7       	in	r31, 0x3e	; 62
    62a8:	31 96       	adiw	r30, 0x01	; 1
    62aa:	ad b7       	in	r26, 0x3d	; 61
    62ac:	be b7       	in	r27, 0x3e	; 62
    62ae:	12 96       	adiw	r26, 0x02	; 2
    62b0:	9c 93       	st	X, r25
    62b2:	8e 93       	st	-X, r24
    62b4:	11 97       	sbiw	r26, 0x01	; 1
    62b6:	86 eb       	ldi	r24, 0xB6	; 182
    62b8:	97 e1       	ldi	r25, 0x17	; 23
    62ba:	93 83       	std	Z+3, r25	; 0x03
    62bc:	82 83       	std	Z+2, r24	; 0x02
    62be:	35 83       	std	Z+5, r19	; 0x05
    62c0:	24 83       	std	Z+4, r18	; 0x04
    62c2:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    62c6:	ed b7       	in	r30, 0x3d	; 61
    62c8:	fe b7       	in	r31, 0x3e	; 62
    62ca:	36 96       	adiw	r30, 0x06	; 6
    62cc:	0f b6       	in	r0, 0x3f	; 63
    62ce:	f8 94       	cli
    62d0:	fe bf       	out	0x3e, r31	; 62
    62d2:	0f be       	out	0x3f, r0	; 63
    62d4:	ed bf       	out	0x3d, r30	; 61
}
    62d6:	64 96       	adiw	r28, 0x14	; 20
    62d8:	0f b6       	in	r0, 0x3f	; 63
    62da:	f8 94       	cli
    62dc:	de bf       	out	0x3e, r29	; 62
    62de:	0f be       	out	0x3f, r0	; 63
    62e0:	cd bf       	out	0x3d, r28	; 61
    62e2:	cf 91       	pop	r28
    62e4:	df 91       	pop	r29
    62e6:	1f 91       	pop	r17
    62e8:	08 95       	ret

000062ea <WrapCode>:
	      break;
	 }
   return Result;
}

void WrapCode(char *strRawCode){
    62ea:	8f 92       	push	r8
    62ec:	9f 92       	push	r9
    62ee:	bf 92       	push	r11
    62f0:	cf 92       	push	r12
    62f2:	df 92       	push	r13
    62f4:	ef 92       	push	r14
    62f6:	ff 92       	push	r15
    62f8:	0f 93       	push	r16
    62fa:	1f 93       	push	r17
    62fc:	df 93       	push	r29
    62fe:	cf 93       	push	r28
    6300:	cd b7       	in	r28, 0x3d	; 61
    6302:	de b7       	in	r29, 0x3e	; 62
    6304:	2f 97       	sbiw	r28, 0x0f	; 15
    6306:	0f b6       	in	r0, 0x3f	; 63
    6308:	f8 94       	cli
    630a:	de bf       	out	0x3e, r29	; 62
    630c:	0f be       	out	0x3f, r0	; 63
    630e:	cd bf       	out	0x3d, r28	; 61
    6310:	6c 01       	movw	r12, r24
    6312:	bb 24       	eor	r11, r11
    6314:	40 e0       	ldi	r20, 0x00	; 0
    6316:	4e 01       	movw	r8, r28
    6318:	08 94       	sec
    631a:	81 1c       	adc	r8, r1
    631c:	91 1c       	adc	r9, r1
    631e:	12 c0       	rjmp	.+36     	; 0x6344 <WrapCode+0x5a>
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
    6320:	86 01       	movw	r16, r12
    6322:	0e 0d       	add	r16, r14
    6324:	1f 1d       	adc	r17, r15
    6326:	d8 01       	movw	r26, r16
    6328:	6c 91       	ld	r22, X
    632a:	60 53       	subi	r22, 0x30	; 48
    632c:	80 e0       	ldi	r24, 0x00	; 0
    632e:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <GeniusCalc>
    6332:	e8 0c       	add	r14, r8
    6334:	f9 1c       	adc	r15, r9
    6336:	80 5d       	subi	r24, 0xD0	; 208
    6338:	f7 01       	movw	r30, r14
    633a:	80 83       	st	Z, r24
		  seedKey=strRawCode[i]-'0';
    633c:	d8 01       	movw	r26, r16
    633e:	4c 91       	ld	r20, X
    6340:	40 53       	subi	r20, 0x30	; 48
void WrapCode(char *strRawCode){
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
    6342:	b3 94       	inc	r11
    6344:	eb 2c       	mov	r14, r11
    6346:	ff 24       	eor	r15, r15
    6348:	d6 01       	movw	r26, r12
    634a:	0d 90       	ld	r0, X+
    634c:	00 20       	and	r0, r0
    634e:	e9 f7       	brne	.-6      	; 0x634a <WrapCode+0x60>
    6350:	11 97       	sbiw	r26, 0x01	; 1
    6352:	ac 19       	sub	r26, r12
    6354:	bd 09       	sbc	r27, r13
    6356:	ea 16       	cp	r14, r26
    6358:	fb 06       	cpc	r15, r27
    635a:	10 f3       	brcs	.-60     	; 0x6320 <WrapCode+0x36>
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
    635c:	a8 0d       	add	r26, r8
    635e:	b9 1d       	adc	r27, r9
    6360:	1c 92       	st	X, r1
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
    6362:	00 d0       	rcall	.+0      	; 0x6364 <WrapCode+0x7a>
    6364:	00 d0       	rcall	.+0      	; 0x6366 <WrapCode+0x7c>
    6366:	00 d0       	rcall	.+0      	; 0x6368 <WrapCode+0x7e>
    6368:	ed b7       	in	r30, 0x3d	; 61
    636a:	fe b7       	in	r31, 0x3e	; 62
    636c:	31 96       	adiw	r30, 0x01	; 1
    636e:	ad b7       	in	r26, 0x3d	; 61
    6370:	be b7       	in	r27, 0x3e	; 62
    6372:	12 96       	adiw	r26, 0x02	; 2
    6374:	dc 92       	st	X, r13
    6376:	ce 92       	st	-X, r12
    6378:	11 97       	sbiw	r26, 0x01	; 1
    637a:	81 ec       	ldi	r24, 0xC1	; 193
    637c:	97 e1       	ldi	r25, 0x17	; 23
    637e:	93 83       	std	Z+3, r25	; 0x03
    6380:	82 83       	std	Z+2, r24	; 0x02
    6382:	95 82       	std	Z+5, r9	; 0x05
    6384:	84 82       	std	Z+4, r8	; 0x04
    6386:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    638a:	ed b7       	in	r30, 0x3d	; 61
    638c:	fe b7       	in	r31, 0x3e	; 62
    638e:	36 96       	adiw	r30, 0x06	; 6
    6390:	0f b6       	in	r0, 0x3f	; 63
    6392:	f8 94       	cli
    6394:	fe bf       	out	0x3e, r31	; 62
    6396:	0f be       	out	0x3f, r0	; 63
    6398:	ed bf       	out	0x3d, r30	; 61
}
    639a:	2f 96       	adiw	r28, 0x0f	; 15
    639c:	0f b6       	in	r0, 0x3f	; 63
    639e:	f8 94       	cli
    63a0:	de bf       	out	0x3e, r29	; 62
    63a2:	0f be       	out	0x3f, r0	; 63
    63a4:	cd bf       	out	0x3d, r28	; 61
    63a6:	cf 91       	pop	r28
    63a8:	df 91       	pop	r29
    63aa:	1f 91       	pop	r17
    63ac:	0f 91       	pop	r16
    63ae:	ff 90       	pop	r15
    63b0:	ef 90       	pop	r14
    63b2:	df 90       	pop	r13
    63b4:	cf 90       	pop	r12
    63b6:	bf 90       	pop	r11
    63b8:	9f 90       	pop	r9
    63ba:	8f 90       	pop	r8
    63bc:	08 95       	ret

000063be <GenerateKeyStamp>:


   return Result;
}

void GenerateKeyStamp(char *sTime, char *sGCode, char *strKeyStamp){//
    63be:	8f 92       	push	r8
    63c0:	9f 92       	push	r9
    63c2:	af 92       	push	r10
    63c4:	bf 92       	push	r11
    63c6:	df 92       	push	r13
    63c8:	ef 92       	push	r14
    63ca:	ff 92       	push	r15
    63cc:	0f 93       	push	r16
    63ce:	1f 93       	push	r17
    63d0:	df 93       	push	r29
    63d2:	cf 93       	push	r28
    63d4:	cd b7       	in	r28, 0x3d	; 61
    63d6:	de b7       	in	r29, 0x3e	; 62
    63d8:	2d 97       	sbiw	r28, 0x0d	; 13
    63da:	0f b6       	in	r0, 0x3f	; 63
    63dc:	f8 94       	cli
    63de:	de bf       	out	0x3e, r29	; 62
    63e0:	0f be       	out	0x3f, r0	; 63
    63e2:	cd bf       	out	0x3d, r28	; 61
    63e4:	9c 01       	movw	r18, r24
    63e6:	7b 01       	movw	r14, r22
    63e8:	5a 01       	movw	r10, r20
	             65585577
	 */
     char seedIdx,sSeed[10],sAdd[3],i;
     
	 seedIdx=(sTime[5]-'0')%8; 
	 sAdd[0]=sGCode[seedIdx];
    63ea:	dc 01       	movw	r26, r24
    63ec:	15 96       	adiw	r26, 0x05	; 5
    63ee:	8c 91       	ld	r24, X
    63f0:	90 e0       	ldi	r25, 0x00	; 0
    63f2:	c0 97       	sbiw	r24, 0x30	; 48
    63f4:	68 e0       	ldi	r22, 0x08	; 8
    63f6:	70 e0       	ldi	r23, 0x00	; 0
    63f8:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    63fc:	f7 01       	movw	r30, r14
    63fe:	e8 0f       	add	r30, r24
    6400:	f1 1d       	adc	r31, r1
    6402:	80 81       	ld	r24, Z
    6404:	89 83       	std	Y+1, r24	; 0x01
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
    6406:	f9 01       	movw	r30, r18
    6408:	86 81       	ldd	r24, Z+6	; 0x06
    640a:	90 e0       	ldi	r25, 0x00	; 0
    640c:	c0 97       	sbiw	r24, 0x30	; 48
    640e:	68 e0       	ldi	r22, 0x08	; 8
    6410:	70 e0       	ldi	r23, 0x00	; 0
    6412:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    6416:	f7 01       	movw	r30, r14
    6418:	e8 0f       	add	r30, r24
    641a:	f1 1d       	adc	r31, r1
    641c:	80 81       	ld	r24, Z
    641e:	8a 83       	std	Y+2, r24	; 0x02
	 sAdd[2]=0;
    6420:	1b 82       	std	Y+3, r1	; 0x03

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
    6422:	8d b7       	in	r24, 0x3d	; 61
    6424:	9e b7       	in	r25, 0x3e	; 62
    6426:	08 97       	sbiw	r24, 0x08	; 8
    6428:	0f b6       	in	r0, 0x3f	; 63
    642a:	f8 94       	cli
    642c:	9e bf       	out	0x3e, r25	; 62
    642e:	0f be       	out	0x3f, r0	; 63
    6430:	8d bf       	out	0x3d, r24	; 61
    6432:	ed b7       	in	r30, 0x3d	; 61
    6434:	fe b7       	in	r31, 0x3e	; 62
    6436:	31 96       	adiw	r30, 0x01	; 1
    6438:	8e 01       	movw	r16, r28
    643a:	0c 5f       	subi	r16, 0xFC	; 252
    643c:	1f 4f       	sbci	r17, 0xFF	; 255
    643e:	ad b7       	in	r26, 0x3d	; 61
    6440:	be b7       	in	r27, 0x3e	; 62
    6442:	12 96       	adiw	r26, 0x02	; 2
    6444:	1c 93       	st	X, r17
    6446:	0e 93       	st	-X, r16
    6448:	11 97       	sbiw	r26, 0x01	; 1
    644a:	81 eb       	ldi	r24, 0xB1	; 177
    644c:	97 e1       	ldi	r25, 0x17	; 23
    644e:	93 83       	std	Z+3, r25	; 0x03
    6450:	82 83       	std	Z+2, r24	; 0x02
    6452:	35 83       	std	Z+5, r19	; 0x05
    6454:	24 83       	std	Z+4, r18	; 0x04
    6456:	ce 01       	movw	r24, r28
    6458:	01 96       	adiw	r24, 0x01	; 1
    645a:	97 83       	std	Z+7, r25	; 0x07
    645c:	86 83       	std	Z+6, r24	; 0x06
    645e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    6462:	dd 24       	eor	r13, r13
    6464:	ed b7       	in	r30, 0x3d	; 61
    6466:	fe b7       	in	r31, 0x3e	; 62
    6468:	38 96       	adiw	r30, 0x08	; 8
    646a:	0f b6       	in	r0, 0x3f	; 63
    646c:	f8 94       	cli
    646e:	fe bf       	out	0x3e, r31	; 62
    6470:	0f be       	out	0x3f, r0	; 63
    6472:	ed bf       	out	0x3d, r30	; 61
     for(i=0;i<strlen(sGCode);i++){
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
    6474:	48 01       	movw	r8, r16
    6476:	13 c0       	rjmp	.+38     	; 0x649e <GenerateKeyStamp+0xe0>
    6478:	f4 01       	movw	r30, r8
    647a:	e0 0f       	add	r30, r16
    647c:	f1 1f       	adc	r31, r17
    647e:	60 81       	ld	r22, Z
    6480:	60 53       	subi	r22, 0x30	; 48
    6482:	f7 01       	movw	r30, r14
    6484:	e0 0f       	add	r30, r16
    6486:	f1 1f       	adc	r31, r17
    6488:	40 81       	ld	r20, Z
    648a:	40 53       	subi	r20, 0x30	; 48
    648c:	81 e0       	ldi	r24, 0x01	; 1
    648e:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <GeniusCalc>
    6492:	0a 0d       	add	r16, r10
    6494:	1b 1d       	adc	r17, r11
    6496:	80 5d       	subi	r24, 0xD0	; 208
    6498:	d8 01       	movw	r26, r16
    649a:	8c 93       	st	X, r24
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
	 sAdd[2]=0;

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
     for(i=0;i<strlen(sGCode);i++){
    649c:	d3 94       	inc	r13
    649e:	0d 2d       	mov	r16, r13
    64a0:	10 e0       	ldi	r17, 0x00	; 0
    64a2:	d7 01       	movw	r26, r14
    64a4:	0d 90       	ld	r0, X+
    64a6:	00 20       	and	r0, r0
    64a8:	e9 f7       	brne	.-6      	; 0x64a4 <GenerateKeyStamp+0xe6>
    64aa:	11 97       	sbiw	r26, 0x01	; 1
    64ac:	ae 19       	sub	r26, r14
    64ae:	bf 09       	sbc	r27, r15
    64b0:	0a 17       	cp	r16, r26
    64b2:	1b 07       	cpc	r17, r27
    64b4:	08 f3       	brcs	.-62     	; 0x6478 <GenerateKeyStamp+0xba>
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
    64b6:	aa 0d       	add	r26, r10
    64b8:	bb 1d       	adc	r27, r11
    64ba:	1c 92       	st	X, r1
     WrapCode(strKeyStamp);
    64bc:	c5 01       	movw	r24, r10
    64be:	0e 94 75 31 	call	0x62ea	; 0x62ea <WrapCode>
}
    64c2:	2d 96       	adiw	r28, 0x0d	; 13
    64c4:	0f b6       	in	r0, 0x3f	; 63
    64c6:	f8 94       	cli
    64c8:	de bf       	out	0x3e, r29	; 62
    64ca:	0f be       	out	0x3f, r0	; 63
    64cc:	cd bf       	out	0x3d, r28	; 61
    64ce:	cf 91       	pop	r28
    64d0:	df 91       	pop	r29
    64d2:	1f 91       	pop	r17
    64d4:	0f 91       	pop	r16
    64d6:	ff 90       	pop	r15
    64d8:	ef 90       	pop	r14
    64da:	df 90       	pop	r13
    64dc:	bf 90       	pop	r11
    64de:	af 90       	pop	r10
    64e0:	9f 90       	pop	r9
    64e2:	8f 90       	pop	r8
    64e4:	08 95       	ret

000064e6 <GenerateGeniusCode>:
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
}

void GenerateGeniusCode(char *srcDate, char cSeed, char *strDestCode){
    64e6:	af 92       	push	r10
    64e8:	bf 92       	push	r11
    64ea:	cf 92       	push	r12
    64ec:	df 92       	push	r13
    64ee:	ef 92       	push	r14
    64f0:	ff 92       	push	r15
    64f2:	0f 93       	push	r16
    64f4:	1f 93       	push	r17
    64f6:	df 93       	push	r29
    64f8:	cf 93       	push	r28
    64fa:	cd b7       	in	r28, 0x3d	; 61
    64fc:	de b7       	in	r29, 0x3e	; 62
    64fe:	28 97       	sbiw	r28, 0x08	; 8
    6500:	0f b6       	in	r0, 0x3f	; 63
    6502:	f8 94       	cli
    6504:	de bf       	out	0x3e, r29	; 62
    6506:	0f be       	out	0x3f, r0	; 63
    6508:	cd bf       	out	0x3d, r28	; 61
    650a:	7c 01       	movw	r14, r24
    650c:	c6 2e       	mov	r12, r22
    650e:	5a 01       	movw	r10, r20
	    sprintf_P(strSend,PSTR("Date[%s]"),srcDate);
		_uart_print(1,1,strSend);
     #endif
    

	 StrPosCopy(srcDate,AddYear,strlen(srcDate)-2,2);
    6510:	fc 01       	movw	r30, r24
    6512:	01 90       	ld	r0, Z+
    6514:	00 20       	and	r0, r0
    6516:	e9 f7       	brne	.-6      	; 0x6512 <GenerateGeniusCode+0x2c>
    6518:	e8 1b       	sub	r30, r24
    651a:	f9 0b       	sbc	r31, r25
    651c:	33 97       	sbiw	r30, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    651e:	e8 0f       	add	r30, r24
    6520:	f9 1f       	adc	r31, r25
    6522:	80 81       	ld	r24, Z
    6524:	89 83       	std	Y+1, r24	; 0x01
    6526:	81 81       	ldd	r24, Z+1	; 0x01
    6528:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    652a:	1b 82       	std	Y+3, r1	; 0x03
    #ifdef DEBUG_GENIUS_CODE
	    sprintf_P(strSend,PSTR("Year:[%s]"),AddYear);
		_uart_print(1,1,strSend);
     #endif

	 sprintf_P(SYear,PSTR("20%s"),AddYear);
    652c:	00 d0       	rcall	.+0      	; 0x652e <GenerateGeniusCode+0x48>
    652e:	00 d0       	rcall	.+0      	; 0x6530 <GenerateGeniusCode+0x4a>
    6530:	00 d0       	rcall	.+0      	; 0x6532 <GenerateGeniusCode+0x4c>
    6532:	ed b7       	in	r30, 0x3d	; 61
    6534:	fe b7       	in	r31, 0x3e	; 62
    6536:	31 96       	adiw	r30, 0x01	; 1
    6538:	8e 01       	movw	r16, r28
    653a:	0c 5f       	subi	r16, 0xFC	; 252
    653c:	1f 4f       	sbci	r17, 0xFF	; 255
    653e:	ad b7       	in	r26, 0x3d	; 61
    6540:	be b7       	in	r27, 0x3e	; 62
    6542:	12 96       	adiw	r26, 0x02	; 2
    6544:	1c 93       	st	X, r17
    6546:	0e 93       	st	-X, r16
    6548:	11 97       	sbiw	r26, 0x01	; 1
    654a:	8c eb       	ldi	r24, 0xBC	; 188
    654c:	97 e1       	ldi	r25, 0x17	; 23
    654e:	93 83       	std	Z+3, r25	; 0x03
    6550:	82 83       	std	Z+2, r24	; 0x02
    6552:	ce 01       	movw	r24, r28
    6554:	01 96       	adiw	r24, 0x01	; 1
    6556:	95 83       	std	Z+5, r25	; 0x05
    6558:	84 83       	std	Z+4, r24	; 0x04
    655a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	 StrPosPaste(SYear,srcDate,strlen(srcDate)-2,strlen(SYear));
    655e:	d7 01       	movw	r26, r14
    6560:	0d 90       	ld	r0, X+
    6562:	00 20       	and	r0, r0
    6564:	e9 f7       	brne	.-6      	; 0x6560 <GenerateGeniusCode+0x7a>
    6566:	9d 01       	movw	r18, r26
    6568:	21 50       	subi	r18, 0x01	; 1
    656a:	30 40       	sbci	r19, 0x00	; 0
    656c:	2e 19       	sub	r18, r14
    656e:	3f 09       	sbc	r19, r15
    6570:	d8 01       	movw	r26, r16
    6572:	0d 90       	ld	r0, X+
    6574:	00 20       	and	r0, r0
    6576:	e9 f7       	brne	.-6      	; 0x6572 <GenerateGeniusCode+0x8c>
    6578:	11 97       	sbiw	r26, 0x01	; 1
    657a:	a0 1b       	sub	r26, r16
    657c:	b1 0b       	sbc	r27, r17
    657e:	22 50       	subi	r18, 0x02	; 2
    6580:	30 40       	sbci	r19, 0x00	; 0
    6582:	b7 01       	movw	r22, r14
    6584:	62 0f       	add	r22, r18
    6586:	73 1f       	adc	r23, r19
    6588:	2e 5f       	subi	r18, 0xFE	; 254
    658a:	3f 4f       	sbci	r19, 0xFF	; 255
    658c:	40 e0       	ldi	r20, 0x00	; 0
    658e:	50 e0       	ldi	r21, 0x00	; 0
    6590:	ed b7       	in	r30, 0x3d	; 61
    6592:	fe b7       	in	r31, 0x3e	; 62
    6594:	36 96       	adiw	r30, 0x06	; 6
    6596:	0f b6       	in	r0, 0x3f	; 63
    6598:	f8 94       	cli
    659a:	fe bf       	out	0x3e, r31	; 62
    659c:	0f be       	out	0x3f, r0	; 63
    659e:	ed bf       	out	0x3d, r30	; 61
    65a0:	09 c0       	rjmp	.+18     	; 0x65b4 <GenerateGeniusCode+0xce>
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    65a2:	f8 01       	movw	r30, r16
    65a4:	e4 0f       	add	r30, r20
    65a6:	f5 1f       	adc	r31, r21
    65a8:	80 81       	ld	r24, Z
    65aa:	fb 01       	movw	r30, r22
    65ac:	81 93       	st	Z+, r24
    65ae:	bf 01       	movw	r22, r30
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    65b0:	4f 5f       	subi	r20, 0xFF	; 255
    65b2:	5f 4f       	sbci	r21, 0xFF	; 255
    65b4:	4a 17       	cp	r20, r26
    65b6:	5b 07       	cpc	r21, r27
    65b8:	a0 f3       	brcs	.-24     	; 0x65a2 <GenerateGeniusCode+0xbc>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    65ba:	ae 0d       	add	r26, r14
    65bc:	bf 1d       	adc	r27, r15
    65be:	a2 0f       	add	r26, r18
    65c0:	b3 1f       	adc	r27, r19
    65c2:	12 97       	sbiw	r26, 0x02	; 2
    65c4:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
	    sprintf_P(strSend,PSTR("NewDate[%s]"),srcDate);
		_uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
    65c6:	00 d0       	rcall	.+0      	; 0x65c8 <GenerateGeniusCode+0xe2>
    65c8:	00 d0       	rcall	.+0      	; 0x65ca <GenerateGeniusCode+0xe4>
    65ca:	00 d0       	rcall	.+0      	; 0x65cc <GenerateGeniusCode+0xe6>
    65cc:	ed b7       	in	r30, 0x3d	; 61
    65ce:	fe b7       	in	r31, 0x3e	; 62
    65d0:	31 96       	adiw	r30, 0x01	; 1
    65d2:	ad b7       	in	r26, 0x3d	; 61
    65d4:	be b7       	in	r27, 0x3e	; 62
    65d6:	12 96       	adiw	r26, 0x02	; 2
    65d8:	bc 92       	st	X, r11
    65da:	ae 92       	st	-X, r10
    65dc:	11 97       	sbiw	r26, 0x01	; 1
    65de:	89 eb       	ldi	r24, 0xB9	; 185
    65e0:	97 e1       	ldi	r25, 0x17	; 23
    65e2:	93 83       	std	Z+3, r25	; 0x03
    65e4:	82 83       	std	Z+2, r24	; 0x02
    65e6:	c4 82       	std	Z+4, r12	; 0x04
    65e8:	15 82       	std	Z+5, r1	; 0x05
    65ea:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    65ee:	dd 24       	eor	r13, r13
    65f0:	d3 94       	inc	r13
    65f2:	ed b7       	in	r30, 0x3d	; 61
    65f4:	fe b7       	in	r31, 0x3e	; 62
    65f6:	36 96       	adiw	r30, 0x06	; 6
    65f8:	0f b6       	in	r0, 0x3f	; 63
    65fa:	f8 94       	cli
    65fc:	fe bf       	out	0x3e, r31	; 62
    65fe:	0f be       	out	0x3f, r0	; 63
    6600:	ed bf       	out	0x3d, r30	; 61
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
    6602:	f0 ed       	ldi	r31, 0xD0	; 208
    6604:	cf 0e       	add	r12, r31
    6606:	0f c0       	rjmp	.+30     	; 0x6626 <GenerateGeniusCode+0x140>
    6608:	f7 01       	movw	r30, r14
    660a:	e0 0f       	add	r30, r16
    660c:	f1 1f       	adc	r31, r17
    660e:	40 81       	ld	r20, Z
    6610:	40 53       	subi	r20, 0x30	; 48
    6612:	80 e0       	ldi	r24, 0x00	; 0
    6614:	6c 2d       	mov	r22, r12
    6616:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <GeniusCalc>
    661a:	0a 0d       	add	r16, r10
    661c:	1b 1d       	adc	r17, r11
    661e:	80 5d       	subi	r24, 0xD0	; 208
    6620:	d8 01       	movw	r26, r16
    6622:	8c 93       	st	X, r24
		_uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
    6624:	d3 94       	inc	r13
    6626:	0d 2d       	mov	r16, r13
    6628:	10 e0       	ldi	r17, 0x00	; 0
    662a:	d7 01       	movw	r26, r14
    662c:	0d 90       	ld	r0, X+
    662e:	00 20       	and	r0, r0
    6630:	e9 f7       	brne	.-6      	; 0x662c <GenerateGeniusCode+0x146>
    6632:	11 97       	sbiw	r26, 0x01	; 1
    6634:	ae 19       	sub	r26, r14
    6636:	bf 09       	sbc	r27, r15
    6638:	0a 17       	cp	r16, r26
    663a:	1b 07       	cpc	r17, r27
    663c:	28 f3       	brcs	.-54     	; 0x6608 <GenerateGeniusCode+0x122>
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
	 }strDestCode[strlen(srcDate)]=0;
    663e:	aa 0d       	add	r26, r10
    6640:	bb 1d       	adc	r27, r11
    6642:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
       sprintf_P(strSend,PSTR("1st:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif

	 WrapCode(strDestCode);
    6644:	c5 01       	movw	r24, r10
    6646:	0e 94 75 31 	call	0x62ea	; 0x62ea <WrapCode>
	 #ifdef DEBUG_GENIUS_CODE
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif
}
    664a:	28 96       	adiw	r28, 0x08	; 8
    664c:	0f b6       	in	r0, 0x3f	; 63
    664e:	f8 94       	cli
    6650:	de bf       	out	0x3e, r29	; 62
    6652:	0f be       	out	0x3f, r0	; 63
    6654:	cd bf       	out	0x3d, r28	; 61
    6656:	cf 91       	pop	r28
    6658:	df 91       	pop	r29
    665a:	1f 91       	pop	r17
    665c:	0f 91       	pop	r16
    665e:	ff 90       	pop	r15
    6660:	ef 90       	pop	r14
    6662:	df 90       	pop	r13
    6664:	cf 90       	pop	r12
    6666:	bf 90       	pop	r11
    6668:	af 90       	pop	r10
    666a:	08 95       	ret

0000666c <GeneratePrintInit>:
	IsBusyMsg11=True;
}



void GeneratePrintInit(){//Create Initialize Print 
    666c:	cf 92       	push	r12
    666e:	df 92       	push	r13
    6670:	ef 92       	push	r14
    6672:	ff 92       	push	r15
    6674:	0f 93       	push	r16
    6676:	1f 93       	push	r17
    6678:	df 93       	push	r29
    667a:	cf 93       	push	r28
    667c:	cd b7       	in	r28, 0x3d	; 61
    667e:	de b7       	in	r29, 0x3e	; 62
    6680:	62 97       	sbiw	r28, 0x12	; 18
    6682:	0f b6       	in	r0, 0x3f	; 63
    6684:	f8 94       	cli
    6686:	de bf       	out	0x3e, r29	; 62
    6688:	0f be       	out	0x3f, r0	; 63
    668a:	cd bf       	out	0x3d, r28	; 61
     char strVernum[6],strVerdate[12];
	 sprintf_P(strVernum,PSTR(VERSION_NUM));
    668c:	00 d0       	rcall	.+0      	; 0x668e <GeneratePrintInit+0x22>
    668e:	00 d0       	rcall	.+0      	; 0x6690 <GeneratePrintInit+0x24>
    6690:	6e 01       	movw	r12, r28
    6692:	08 94       	sec
    6694:	c1 1c       	adc	r12, r1
    6696:	d1 1c       	adc	r13, r1
    6698:	ad b7       	in	r26, 0x3d	; 61
    669a:	be b7       	in	r27, 0x3e	; 62
    669c:	12 96       	adiw	r26, 0x02	; 2
    669e:	dc 92       	st	X, r13
    66a0:	ce 92       	st	-X, r12
    66a2:	11 97       	sbiw	r26, 0x01	; 1
    66a4:	8b e3       	ldi	r24, 0x3B	; 59
    66a6:	9d e1       	ldi	r25, 0x1D	; 29
    66a8:	14 96       	adiw	r26, 0x04	; 4
    66aa:	9c 93       	st	X, r25
    66ac:	8e 93       	st	-X, r24
    66ae:	13 97       	sbiw	r26, 0x03	; 3
    66b0:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	 sprintf_P(strVerdate,PSTR(VERSION_DATE));
    66b4:	37 e0       	ldi	r19, 0x07	; 7
    66b6:	e3 2e       	mov	r14, r19
    66b8:	f1 2c       	mov	r15, r1
    66ba:	ec 0e       	add	r14, r28
    66bc:	fd 1e       	adc	r15, r29
    66be:	ed b7       	in	r30, 0x3d	; 61
    66c0:	fe b7       	in	r31, 0x3e	; 62
    66c2:	f2 82       	std	Z+2, r15	; 0x02
    66c4:	e1 82       	std	Z+1, r14	; 0x01
    66c6:	80 e3       	ldi	r24, 0x30	; 48
    66c8:	9d e1       	ldi	r25, 0x1D	; 29
    66ca:	94 83       	std	Z+4, r25	; 0x04
    66cc:	83 83       	std	Z+3, r24	; 0x03
    66ce:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
     sprintf_P(PrintBuffer,PSTR("\nGeNiUs Ticket Printer \n Version:%s\n Last Update %s \n Hanindo Automation Solutions \n www.hanindogroup.com\n\n\n\n\n\n\n\n"),strVernum,strVerdate);
    66d2:	00 d0       	rcall	.+0      	; 0x66d4 <GeneratePrintInit+0x68>
    66d4:	00 d0       	rcall	.+0      	; 0x66d6 <GeneratePrintInit+0x6a>
    66d6:	ed b7       	in	r30, 0x3d	; 61
    66d8:	fe b7       	in	r31, 0x3e	; 62
    66da:	31 96       	adiw	r30, 0x01	; 1
    66dc:	0f ec       	ldi	r16, 0xCF	; 207
    66de:	15 e0       	ldi	r17, 0x05	; 5
    66e0:	ad b7       	in	r26, 0x3d	; 61
    66e2:	be b7       	in	r27, 0x3e	; 62
    66e4:	12 96       	adiw	r26, 0x02	; 2
    66e6:	1c 93       	st	X, r17
    66e8:	0e 93       	st	-X, r16
    66ea:	11 97       	sbiw	r26, 0x01	; 1
    66ec:	8e eb       	ldi	r24, 0xBE	; 190
    66ee:	9c e1       	ldi	r25, 0x1C	; 28
    66f0:	93 83       	std	Z+3, r25	; 0x03
    66f2:	82 83       	std	Z+2, r24	; 0x02
    66f4:	d5 82       	std	Z+5, r13	; 0x05
    66f6:	c4 82       	std	Z+4, r12	; 0x04
    66f8:	f7 82       	std	Z+7, r15	; 0x07
    66fa:	e6 82       	std	Z+6, r14	; 0x06
    66fc:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	 _uart_print(0,1,PrintBuffer);
    6700:	ed b7       	in	r30, 0x3d	; 61
    6702:	fe b7       	in	r31, 0x3e	; 62
    6704:	38 96       	adiw	r30, 0x08	; 8
    6706:	0f b6       	in	r0, 0x3f	; 63
    6708:	f8 94       	cli
    670a:	fe bf       	out	0x3e, r31	; 62
    670c:	0f be       	out	0x3f, r0	; 63
    670e:	ed bf       	out	0x3d, r30	; 61
    6710:	80 e0       	ldi	r24, 0x00	; 0
    6712:	61 e0       	ldi	r22, 0x01	; 1
    6714:	a8 01       	movw	r20, r16
    6716:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	 LengthMessage81=strlen(PrintBuffer);
    671a:	f8 01       	movw	r30, r16
    671c:	01 90       	ld	r0, Z+
    671e:	00 20       	and	r0, r0
    6720:	e9 f7       	brne	.-6      	; 0x671c <GeneratePrintInit+0xb0>
    6722:	31 97       	sbiw	r30, 0x01	; 1
    6724:	e0 1b       	sub	r30, r16
    6726:	f1 0b       	sbc	r31, r17
    6728:	f0 93 a1 01 	sts	0x01A1, r31
    672c:	e0 93 a0 01 	sts	0x01A0, r30
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    6730:	80 e3       	ldi	r24, 0x30	; 48
    6732:	80 93 cb 01 	sts	0x01CB, r24
	 IsFreePrinting=True;
    6736:	81 e0       	ldi	r24, 0x01	; 1
    6738:	80 93 bf 01 	sts	0x01BF, r24
}
    673c:	62 96       	adiw	r28, 0x12	; 18
    673e:	0f b6       	in	r0, 0x3f	; 63
    6740:	f8 94       	cli
    6742:	de bf       	out	0x3e, r29	; 62
    6744:	0f be       	out	0x3f, r0	; 63
    6746:	cd bf       	out	0x3d, r28	; 61
    6748:	cf 91       	pop	r28
    674a:	df 91       	pop	r29
    674c:	1f 91       	pop	r17
    674e:	0f 91       	pop	r16
    6750:	ff 90       	pop	r15
    6752:	ef 90       	pop	r14
    6754:	df 90       	pop	r13
    6756:	cf 90       	pop	r12
    6758:	08 95       	ret

0000675a <FormatCurrency>:
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}


void FormatCurrency(char *strCurrency){// 5000000.00 5,000,000.00
    675a:	9f 92       	push	r9
    675c:	af 92       	push	r10
    675e:	bf 92       	push	r11
    6760:	cf 92       	push	r12
    6762:	df 92       	push	r13
    6764:	ef 92       	push	r14
    6766:	ff 92       	push	r15
    6768:	0f 93       	push	r16
    676a:	1f 93       	push	r17
    676c:	df 93       	push	r29
    676e:	cf 93       	push	r28
    6770:	cd b7       	in	r28, 0x3d	; 61
    6772:	de b7       	in	r29, 0x3e	; 62
    6774:	64 97       	sbiw	r28, 0x14	; 20
    6776:	0f b6       	in	r0, 0x3f	; 63
    6778:	f8 94       	cli
    677a:	de bf       	out	0x3e, r29	; 62
    677c:	0f be       	out	0x3f, r0	; 63
    677e:	cd bf       	out	0x3d, r28	; 61
    6780:	6c 01       	movw	r12, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6782:	e1 99       	sbic	0x1c, 1	; 28
    6784:	fe cf       	rjmp	.-4      	; 0x6782 <FormatCurrency+0x28>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6786:	8f e3       	ldi	r24, 0x3F	; 63
    6788:	90 e0       	ldi	r25, 0x00	; 0
    678a:	9f bb       	out	0x1f, r25	; 31
    678c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    678e:	e0 9a       	sbi	0x1c, 0	; 28
    6790:	9d b2       	in	r9, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6792:	e1 99       	sbic	0x1c, 1	; 28
    6794:	fe cf       	rjmp	.-4      	; 0x6792 <FormatCurrency+0x38>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6796:	8e e3       	ldi	r24, 0x3E	; 62
    6798:	90 e0       	ldi	r25, 0x00	; 0
    679a:	9f bb       	out	0x1f, r25	; 31
    679c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    679e:	e0 9a       	sbi	0x1c, 0	; 28
    67a0:	3d b3       	in	r19, 0x1d	; 29
	 char CurrencyMark,DecimalMark;

	 CurrencyMark=eeprom_read_byte(&DefCurrencyMark);
	 DecimalMark=eeprom_read_byte(&DefDecimalMark);

	 Length=strlen(strCurrency);//123,456
    67a2:	f6 01       	movw	r30, r12
    67a4:	01 90       	ld	r0, Z+
    67a6:	00 20       	and	r0, r0
    67a8:	e9 f7       	brne	.-6      	; 0x67a4 <FormatCurrency+0x4a>
    67aa:	31 97       	sbiw	r30, 0x01	; 1
    67ac:	ee 2e       	mov	r14, r30
    67ae:	ec 18       	sub	r14, r12
    67b0:	fe 01       	movw	r30, r28
    67b2:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67b4:	ce 01       	movw	r24, r28
    67b6:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    67b8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67ba:	e8 17       	cp	r30, r24
    67bc:	f9 07       	cpc	r31, r25
    67be:	e1 f7       	brne	.-8      	; 0x67b8 <FormatCurrency+0x5e>
    67c0:	f6 01       	movw	r30, r12
    67c2:	fe 2c       	mov	r15, r14
    67c4:	20 e0       	ldi	r18, 0x00	; 0
    67c6:	80 e0       	ldi	r24, 0x00	; 0
    67c8:	09 c0       	rjmp	.+18     	; 0x67dc <FormatCurrency+0x82>
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
    67ca:	90 81       	ld	r25, Z
    67cc:	93 17       	cp	r25, r19
    67ce:	09 f4       	brne	.+2      	; 0x67d2 <FormatCurrency+0x78>
    67d0:	f8 2e       	mov	r15, r24
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
    67d2:	99 15       	cp	r25, r9
    67d4:	09 f4       	brne	.+2      	; 0x67d8 <FormatCurrency+0x7e>
    67d6:	2f 5f       	subi	r18, 0xFF	; 255
	 Length=strlen(strCurrency);//123,456
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
    67d8:	8f 5f       	subi	r24, 0xFF	; 255
    67da:	31 96       	adiw	r30, 0x01	; 1
    67dc:	8e 15       	cp	r24, r14
    67de:	a8 f3       	brcs	.-22     	; 0x67ca <FormatCurrency+0x70>
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
    67e0:	22 23       	and	r18, r18
    67e2:	09 f0       	breq	.+2      	; 0x67e6 <FormatCurrency+0x8c>
    67e4:	5e c0       	rjmp	.+188    	; 0x68a2 <FormatCurrency+0x148>
    67e6:	83 e0       	ldi	r24, 0x03	; 3
    67e8:	8f 15       	cp	r24, r15
    67ea:	08 f0       	brcs	.+2      	; 0x67ee <FormatCurrency+0x94>
    67ec:	5a c0       	rjmp	.+180    	; 0x68a2 <FormatCurrency+0x148>
    67ee:	40 e0       	ldi	r20, 0x00	; 0
    67f0:	20 e0       	ldi	r18, 0x00	; 0
    67f2:	30 e0       	ldi	r19, 0x00	; 0
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    67f4:	af 2c       	mov	r10, r15
    67f6:	bb 24       	eor	r11, r11
		        fmtCurrency[iPos]=CurrencyMark;
    67f8:	8e 01       	movw	r16, r28
    67fa:	0f 5f       	subi	r16, 0xFF	; 255
    67fc:	1f 4f       	sbci	r17, 0xFF	; 255
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    67fe:	c5 01       	movw	r24, r10
    6800:	82 1b       	sub	r24, r18
    6802:	93 0b       	sbc	r25, r19
    6804:	63 e0       	ldi	r22, 0x03	; 3
    6806:	70 e0       	ldi	r23, 0x00	; 0
    6808:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    680c:	89 2b       	or	r24, r25
    680e:	49 f4       	brne	.+18     	; 0x6822 <FormatCurrency+0xc8>
    6810:	2f 15       	cp	r18, r15
    6812:	38 f4       	brcc	.+14     	; 0x6822 <FormatCurrency+0xc8>
    6814:	22 23       	and	r18, r18
    6816:	29 f0       	breq	.+10     	; 0x6822 <FormatCurrency+0xc8>
		        fmtCurrency[iPos]=CurrencyMark;
    6818:	f8 01       	movw	r30, r16
    681a:	e4 0f       	add	r30, r20
    681c:	f1 1d       	adc	r31, r1
    681e:	90 82       	st	Z, r9
		        iPos++;
    6820:	4f 5f       	subi	r20, 0xFF	; 255
		        }
		        fmtCurrency[iPos]=strCurrency[i];
    6822:	d8 01       	movw	r26, r16
    6824:	a4 0f       	add	r26, r20
    6826:	b1 1d       	adc	r27, r1
    6828:	f6 01       	movw	r30, r12
    682a:	e2 0f       	add	r30, r18
    682c:	f3 1f       	adc	r31, r19
    682e:	80 81       	ld	r24, Z
    6830:	8c 93       	st	X, r24
			    iPos++;
    6832:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    6834:	f8 01       	movw	r30, r16
    6836:	e4 0f       	add	r30, r20
    6838:	f1 1d       	adc	r31, r1
    683a:	10 82       	st	Z, r1
    683c:	2f 5f       	subi	r18, 0xFF	; 255
    683e:	3f 4f       	sbci	r19, 0xFF	; 255
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
    6840:	2f 15       	cp	r18, r15
    6842:	e8 f2       	brcs	.-70     	; 0x67fe <FormatCurrency+0xa4>
    6844:	9f 2d       	mov	r25, r15
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
    6846:	9e 01       	movw	r18, r28
    6848:	2f 5f       	subi	r18, 0xFF	; 255
    684a:	3f 4f       	sbci	r19, 0xFF	; 255
    684c:	0e c0       	rjmp	.+28     	; 0x686a <FormatCurrency+0x110>
    684e:	d9 01       	movw	r26, r18
    6850:	a4 0f       	add	r26, r20
    6852:	b1 1d       	adc	r27, r1
    6854:	f6 01       	movw	r30, r12
    6856:	e9 0f       	add	r30, r25
    6858:	f1 1d       	adc	r31, r1
    685a:	80 81       	ld	r24, Z
    685c:	8c 93       	st	X, r24
			    iPos++;
    685e:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    6860:	f9 01       	movw	r30, r18
    6862:	e4 0f       	add	r30, r20
    6864:	f1 1d       	adc	r31, r1
    6866:	10 82       	st	Z, r1
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
    6868:	9f 5f       	subi	r25, 0xFF	; 255
    686a:	9e 15       	cp	r25, r14
    686c:	80 f3       	brcs	.-32     	; 0x684e <FormatCurrency+0xf4>
    686e:	90 e0       	ldi	r25, 0x00	; 0
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    6870:	9e 01       	movw	r18, r28
    6872:	2f 5f       	subi	r18, 0xFF	; 255
    6874:	3f 4f       	sbci	r19, 0xFF	; 255
    6876:	09 c0       	rjmp	.+18     	; 0x688a <FormatCurrency+0x130>
	          strCurrency[i]=fmtCurrency[i];
    6878:	f6 01       	movw	r30, r12
    687a:	ea 0f       	add	r30, r26
    687c:	fb 1f       	adc	r31, r27
    687e:	a2 0f       	add	r26, r18
    6880:	b3 1f       	adc	r27, r19
    6882:	8c 91       	ld	r24, X
    6884:	80 83       	st	Z, r24
			  strCurrency[i+1]=0;
    6886:	11 82       	std	Z+1, r1	; 0x01
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    6888:	9f 5f       	subi	r25, 0xFF	; 255
    688a:	a9 2f       	mov	r26, r25
    688c:	b0 e0       	ldi	r27, 0x00	; 0
    688e:	f9 01       	movw	r30, r18
    6890:	01 90       	ld	r0, Z+
    6892:	00 20       	and	r0, r0
    6894:	e9 f7       	brne	.-6      	; 0x6890 <FormatCurrency+0x136>
    6896:	31 97       	sbiw	r30, 0x01	; 1
    6898:	e2 1b       	sub	r30, r18
    689a:	f3 0b       	sbc	r31, r19
    689c:	ae 17       	cp	r26, r30
    689e:	bf 07       	cpc	r27, r31
    68a0:	58 f3       	brcs	.-42     	; 0x6878 <FormatCurrency+0x11e>
	          strCurrency[i]=fmtCurrency[i];
			  strCurrency[i+1]=0;
	      }
     }      
}
    68a2:	64 96       	adiw	r28, 0x14	; 20
    68a4:	0f b6       	in	r0, 0x3f	; 63
    68a6:	f8 94       	cli
    68a8:	de bf       	out	0x3e, r29	; 62
    68aa:	0f be       	out	0x3f, r0	; 63
    68ac:	cd bf       	out	0x3d, r28	; 61
    68ae:	cf 91       	pop	r28
    68b0:	df 91       	pop	r29
    68b2:	1f 91       	pop	r17
    68b4:	0f 91       	pop	r16
    68b6:	ff 90       	pop	r15
    68b8:	ef 90       	pop	r14
    68ba:	df 90       	pop	r13
    68bc:	cf 90       	pop	r12
    68be:	bf 90       	pop	r11
    68c0:	af 90       	pop	r10
    68c2:	9f 90       	pop	r9
    68c4:	08 95       	ret

000068c6 <FormatDecimal>:

void TestLocalAccount(){

}

void FormatDecimal(char *strRawData, char DecimalCfg){// 9-> 0,009 0,234 123 
    68c6:	ef 92       	push	r14
    68c8:	ff 92       	push	r15
    68ca:	0f 93       	push	r16
    68cc:	1f 93       	push	r17
    68ce:	df 93       	push	r29
    68d0:	cf 93       	push	r28
    68d2:	cd b7       	in	r28, 0x3d	; 61
    68d4:	de b7       	in	r29, 0x3e	; 62
    68d6:	64 97       	sbiw	r28, 0x14	; 20
    68d8:	0f b6       	in	r0, 0x3f	; 63
    68da:	f8 94       	cli
    68dc:	de bf       	out	0x3e, r29	; 62
    68de:	0f be       	out	0x3f, r0	; 63
    68e0:	cd bf       	out	0x3d, r28	; 61
    68e2:	8c 01       	movw	r16, r24
     char i,iPos,CommaPos,Length=0;                 //1->0,01 
	 char strDecimalFormated[20];
	 char DecPointMark;
     if (DecimalCfg>0){    
    68e4:	66 23       	and	r22, r22
    68e6:	09 f4       	brne	.+2      	; 0x68ea <FormatDecimal+0x24>
    68e8:	56 c0       	rjmp	.+172    	; 0x6996 <FormatDecimal+0xd0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    68ea:	e1 99       	sbic	0x1c, 1	; 28
    68ec:	fe cf       	rjmp	.-4      	; 0x68ea <FormatDecimal+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    68ee:	8e e3       	ldi	r24, 0x3E	; 62
    68f0:	90 e0       	ldi	r25, 0x00	; 0
    68f2:	9f bb       	out	0x1f, r25	; 31
    68f4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    68f6:	e0 9a       	sbi	0x1c, 0	; 28
    68f8:	ed b2       	in	r14, 0x1d	; 29
		 DecPointMark=eeprom_read_byte(&DefDecimalMark);	 
		 Length=strlen(strRawData);
    68fa:	f8 01       	movw	r30, r16
    68fc:	01 90       	ld	r0, Z+
    68fe:	00 20       	and	r0, r0
    6900:	e9 f7       	brne	.-6      	; 0x68fc <FormatDecimal+0x36>
    6902:	31 97       	sbiw	r30, 0x01	; 1
    6904:	3e 2f       	mov	r19, r30
    6906:	30 1b       	sub	r19, r16

		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
    6908:	63 17       	cp	r22, r19
    690a:	b8 f5       	brcc	.+110    	; 0x697a <FormatDecimal+0xb4>
    690c:	f3 2e       	mov	r15, r19
    690e:	f6 1a       	sub	r15, r22
    6910:	b8 01       	movw	r22, r16
    6912:	d8 01       	movw	r26, r16
    6914:	90 e0       	ldi	r25, 0x00	; 0
    6916:	20 e0       	ldi	r18, 0x00	; 0

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
				 strDecimalFormated[iPos]=DecPointMark;
    6918:	ae 01       	movw	r20, r28
    691a:	4f 5f       	subi	r20, 0xFF	; 255
    691c:	5f 4f       	sbci	r21, 0xFF	; 255
    691e:	0e c0       	rjmp	.+28     	; 0x693c <FormatDecimal+0x76>
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
    6920:	2f 15       	cp	r18, r15
    6922:	29 f4       	brne	.+10     	; 0x692e <FormatDecimal+0x68>
				 strDecimalFormated[iPos]=DecPointMark;
    6924:	fa 01       	movw	r30, r20
    6926:	e9 0f       	add	r30, r25
    6928:	f1 1d       	adc	r31, r1
    692a:	e0 82       	st	Z, r14
				 iPos++;
    692c:	9f 5f       	subi	r25, 0xFF	; 255
			}
			strDecimalFormated[iPos]=strRawData[i];
    692e:	fa 01       	movw	r30, r20
    6930:	e9 0f       	add	r30, r25
    6932:	f1 1d       	adc	r31, r1
    6934:	8d 91       	ld	r24, X+
    6936:	80 83       	st	Z, r24
			//strDecimalFormated[iPos+1]=0;
			iPos++;
    6938:	9f 5f       	subi	r25, 0xFF	; 255
			 CommaPos=1;
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
    693a:	2f 5f       	subi	r18, 0xFF	; 255
    693c:	23 17       	cp	r18, r19
    693e:	80 f3       	brcs	.-32     	; 0x6920 <FormatDecimal+0x5a>
				 iPos++;
			}
			strDecimalFormated[iPos]=strRawData[i];
			//strDecimalFormated[iPos+1]=0;
			iPos++;
		 }strDecimalFormated[iPos]=0;
    6940:	9e 01       	movw	r18, r28
    6942:	2f 5f       	subi	r18, 0xFF	; 255
    6944:	3f 4f       	sbci	r19, 0xFF	; 255
    6946:	f9 01       	movw	r30, r18
    6948:	e9 0f       	add	r30, r25
    694a:	f1 1d       	adc	r31, r1
    694c:	10 82       	st	Z, r1
		 
         //_uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
    694e:	f9 01       	movw	r30, r18
    6950:	01 90       	ld	r0, Z+
    6952:	00 20       	and	r0, r0
    6954:	e9 f7       	brne	.-6      	; 0x6950 <FormatDecimal+0x8a>
    6956:	31 97       	sbiw	r30, 0x01	; 1
    6958:	9e 2f       	mov	r25, r30
    695a:	92 1b       	sub	r25, r18
    695c:	d9 01       	movw	r26, r18
    695e:	04 c0       	rjmp	.+8      	; 0x6968 <FormatDecimal+0xa2>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
    6960:	8d 91       	ld	r24, X+
    6962:	fb 01       	movw	r30, r22
    6964:	81 93       	st	Z+, r24
    6966:	bf 01       	movw	r22, r30
		 }strDecimalFormated[iPos]=0;
		 
         //_uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
		 for(i=0;i<Length;i++){
    6968:	8a 2f       	mov	r24, r26
    696a:	82 1b       	sub	r24, r18
    696c:	89 17       	cp	r24, r25
    696e:	c0 f3       	brcs	.-16     	; 0x6960 <FormatDecimal+0x9a>
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
    6970:	09 0f       	add	r16, r25
    6972:	11 1d       	adc	r17, r1
    6974:	f8 01       	movw	r30, r16
    6976:	10 82       	st	Z, r1
    6978:	0e c0       	rjmp	.+28     	; 0x6996 <FormatDecimal+0xd0>
		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
		 else CommaPos=1;


		 if (Length<=DecimalCfg){// 123 -> 0123
			 AddZeroLead(strRawData,(DecimalCfg+1));
    697a:	6f 5f       	subi	r22, 0xFF	; 255
    697c:	c8 01       	movw	r24, r16
    697e:	0e 94 33 27 	call	0x4e66	; 0x4e66 <AddZeroLead>
			 //AddZeroLead(strRawData,(DecimalCfg+2));
			 Length=strlen(strRawData);
    6982:	f8 01       	movw	r30, r16
    6984:	01 90       	ld	r0, Z+
    6986:	00 20       	and	r0, r0
    6988:	e9 f7       	brne	.-6      	; 0x6984 <FormatDecimal+0xbe>
    698a:	31 97       	sbiw	r30, 0x01	; 1
    698c:	3e 2f       	mov	r19, r30
    698e:	30 1b       	sub	r19, r16
    6990:	ff 24       	eor	r15, r15
    6992:	f3 94       	inc	r15
    6994:	bd cf       	rjmp	.-134    	; 0x6910 <FormatDecimal+0x4a>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
	 }
          //_uart_print(1,1,strRawData); 
}
    6996:	64 96       	adiw	r28, 0x14	; 20
    6998:	0f b6       	in	r0, 0x3f	; 63
    699a:	f8 94       	cli
    699c:	de bf       	out	0x3e, r29	; 62
    699e:	0f be       	out	0x3f, r0	; 63
    69a0:	cd bf       	out	0x3d, r28	; 61
    69a2:	cf 91       	pop	r28
    69a4:	df 91       	pop	r29
    69a6:	1f 91       	pop	r17
    69a8:	0f 91       	pop	r16
    69aa:	ff 90       	pop	r15
    69ac:	ef 90       	pop	r14
    69ae:	08 95       	ret

000069b0 <NormalizeDecimal>:
	 Result=(SigmaSum%255);
	 if (Result==0)Result=255;
   return Result;
}

void NormalizeDecimal(char CurrentDecimal, char NewDecimal, char *Result){// 01234567,89
    69b0:	68 2f       	mov	r22, r24
    69b2:	ca 01       	movw	r24, r20
		 StrPosCopy(Result,SResult,DeltaDec,Length-DeltaDec);
		 	           
	 
     }
*/
     FormatDecimal(Result,CurrentDecimal);
    69b4:	0e 94 63 34 	call	0x68c6	; 0x68c6 <FormatDecimal>
}
    69b8:	08 95       	ret

000069ba <FormatTotalizerVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatTotalizerVolume(char *strRawVolume){//96->0,96 
    69ba:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    69bc:	e1 99       	sbic	0x1c, 1	; 28
    69be:	fe cf       	rjmp	.-4      	; 0x69bc <FormatTotalizerVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    69c0:	8c e3       	ldi	r24, 0x3C	; 60
    69c2:	90 e0       	ldi	r25, 0x00	; 0
    69c4:	9f bb       	out	0x1f, r25	; 31
    69c6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    69c8:	e0 9a       	sbi	0x1c, 0	; 28
    69ca:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    69cc:	c9 01       	movw	r24, r18
    69ce:	0e 94 63 34 	call	0x68c6	; 0x68c6 <FormatDecimal>
}
    69d2:	08 95       	ret

000069d4 <FormatTotalizerMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}

void FormatTotalizerMoney(char *strRawMoney){
    69d4:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    69d6:	e1 99       	sbic	0x1c, 1	; 28
    69d8:	fe cf       	rjmp	.-4      	; 0x69d6 <FormatTotalizerMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    69da:	8d e3       	ldi	r24, 0x3D	; 61
    69dc:	90 e0       	ldi	r25, 0x00	; 0
    69de:	9f bb       	out	0x1f, r25	; 31
    69e0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    69e2:	e0 9a       	sbi	0x1c, 0	; 28
    69e4:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    69e6:	c9 01       	movw	r24, r18
    69e8:	0e 94 63 34 	call	0x68c6	; 0x68c6 <FormatDecimal>
}
    69ec:	08 95       	ret

000069ee <FormatVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatVolume(char *strRawVolume){//96->0,96 
    69ee:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    69f0:	e1 99       	sbic	0x1c, 1	; 28
    69f2:	fe cf       	rjmp	.-4      	; 0x69f0 <FormatVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    69f4:	8a e3       	ldi	r24, 0x3A	; 58
    69f6:	90 e0       	ldi	r25, 0x00	; 0
    69f8:	9f bb       	out	0x1f, r25	; 31
    69fa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    69fc:	e0 9a       	sbi	0x1c, 0	; 28
    69fe:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    6a00:	c9 01       	movw	r24, r18
    6a02:	0e 94 63 34 	call	0x68c6	; 0x68c6 <FormatDecimal>
}
    6a06:	08 95       	ret

00006a08 <FormatMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
}

void FormatMoney(char *strRawMoney){
    6a08:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6a0a:	e1 99       	sbic	0x1c, 1	; 28
    6a0c:	fe cf       	rjmp	.-4      	; 0x6a0a <FormatMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6a0e:	8b e3       	ldi	r24, 0x3B	; 59
    6a10:	90 e0       	ldi	r25, 0x00	; 0
    6a12:	9f bb       	out	0x1f, r25	; 31
    6a14:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6a16:	e0 9a       	sbi	0x1c, 0	; 28
    6a18:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    6a1a:	c9 01       	movw	r24, r18
    6a1c:	0e 94 63 34 	call	0x68c6	; 0x68c6 <FormatDecimal>
}
    6a20:	08 95       	ret

00006a22 <FormatPrice>:
		 }strRawData[Length]=0;
	 }
          //_uart_print(1,1,strRawData); 
}

void FormatPrice(char *strRawPrice){
    6a22:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6a24:	e1 99       	sbic	0x1c, 1	; 28
    6a26:	fe cf       	rjmp	.-4      	; 0x6a24 <FormatPrice+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6a28:	89 e3       	ldi	r24, 0x39	; 57
    6a2a:	90 e0       	ldi	r25, 0x00	; 0
    6a2c:	9f bb       	out	0x1f, r25	; 31
    6a2e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6a30:	e0 9a       	sbi	0x1c, 0	; 28
    6a32:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
    6a34:	c9 01       	movw	r24, r18
    6a36:	0e 94 63 34 	call	0x68c6	; 0x68c6 <FormatDecimal>
}
    6a3a:	08 95       	ret

00006a3c <systemGenerateReport>:
	 }
}

//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
//			cmdPrint=procMessage81();
void systemGenerateReport(){
    6a3c:	2f 92       	push	r2
    6a3e:	3f 92       	push	r3
    6a40:	4f 92       	push	r4
    6a42:	5f 92       	push	r5
    6a44:	6f 92       	push	r6
    6a46:	7f 92       	push	r7
    6a48:	8f 92       	push	r8
    6a4a:	9f 92       	push	r9
    6a4c:	af 92       	push	r10
    6a4e:	bf 92       	push	r11
    6a50:	cf 92       	push	r12
    6a52:	df 92       	push	r13
    6a54:	ef 92       	push	r14
    6a56:	ff 92       	push	r15
    6a58:	0f 93       	push	r16
    6a5a:	1f 93       	push	r17
    6a5c:	df 93       	push	r29
    6a5e:	cf 93       	push	r28
    6a60:	cd b7       	in	r28, 0x3d	; 61
    6a62:	de b7       	in	r29, 0x3e	; 62
    6a64:	c8 5f       	subi	r28, 0xF8	; 248
    6a66:	d0 40       	sbci	r29, 0x00	; 0
    6a68:	0f b6       	in	r0, 0x3f	; 63
    6a6a:	f8 94       	cli
    6a6c:	de bf       	out	0x3e, r29	; 62
    6a6e:	0f be       	out	0x3f, r0	; 63
    6a70:	cd bf       	out	0x3d, r28	; 61
	   char strTabSpace[20],strTabSpace2[20];
	   char iTotal;//,PadLength;
	   char sPrice[10],strProductPrice[20];
	   char FIPAddr;

     switch(stGenerateReport){
    6a72:	10 91 14 02 	lds	r17, 0x0214
    6a76:	16 30       	cpi	r17, 0x06	; 6
    6a78:	09 f4       	brne	.+2      	; 0x6a7c <systemGenerateReport+0x40>
    6a7a:	5d c2       	rjmp	.+1210   	; 0x6f36 <systemGenerateReport+0x4fa>
    6a7c:	17 30       	cpi	r17, 0x07	; 7
    6a7e:	98 f4       	brcc	.+38     	; 0x6aa6 <systemGenerateReport+0x6a>
    6a80:	12 30       	cpi	r17, 0x02	; 2
    6a82:	09 f4       	brne	.+2      	; 0x6a86 <systemGenerateReport+0x4a>
    6a84:	a7 c0       	rjmp	.+334    	; 0x6bd4 <systemGenerateReport+0x198>
    6a86:	13 30       	cpi	r17, 0x03	; 3
    6a88:	38 f4       	brcc	.+14     	; 0x6a98 <systemGenerateReport+0x5c>
    6a8a:	11 23       	and	r17, r17
    6a8c:	31 f1       	breq	.+76     	; 0x6ada <systemGenerateReport+0x9e>
    6a8e:	11 30       	cpi	r17, 0x01	; 1
    6a90:	11 f0       	breq	.+4      	; 0x6a96 <systemGenerateReport+0x5a>
    6a92:	0c 94 37 40 	jmp	0x806e	; 0x806e <systemGenerateReport+0x1632>
    6a96:	2d c0       	rjmp	.+90     	; 0x6af2 <systemGenerateReport+0xb6>
    6a98:	14 30       	cpi	r17, 0x04	; 4
    6a9a:	09 f4       	brne	.+2      	; 0x6a9e <systemGenerateReport+0x62>
    6a9c:	c8 c1       	rjmp	.+912    	; 0x6e2e <systemGenerateReport+0x3f2>
    6a9e:	15 30       	cpi	r17, 0x05	; 5
    6aa0:	08 f0       	brcs	.+2      	; 0x6aa4 <systemGenerateReport+0x68>
    6aa2:	4c c7       	rjmp	.+3736   	; 0x793c <systemGenerateReport+0xf00>
    6aa4:	bb c1       	rjmp	.+886    	; 0x6e1c <systemGenerateReport+0x3e0>
    6aa6:	19 30       	cpi	r17, 0x09	; 9
    6aa8:	09 f4       	brne	.+2      	; 0x6aac <systemGenerateReport+0x70>
    6aaa:	48 c7       	rjmp	.+3728   	; 0x793c <systemGenerateReport+0xf00>
    6aac:	1a 30       	cpi	r17, 0x0A	; 10
    6aae:	40 f4       	brcc	.+16     	; 0x6ac0 <systemGenerateReport+0x84>
    6ab0:	17 30       	cpi	r17, 0x07	; 7
    6ab2:	09 f4       	brne	.+2      	; 0x6ab6 <systemGenerateReport+0x7a>
    6ab4:	aa c2       	rjmp	.+1364   	; 0x700a <systemGenerateReport+0x5ce>
    6ab6:	18 30       	cpi	r17, 0x08	; 8
    6ab8:	11 f0       	breq	.+4      	; 0x6abe <systemGenerateReport+0x82>
    6aba:	0c 94 37 40 	jmp	0x806e	; 0x806e <systemGenerateReport+0x1632>
    6abe:	b3 c2       	rjmp	.+1382   	; 0x7026 <systemGenerateReport+0x5ea>
    6ac0:	1b 30       	cpi	r17, 0x0B	; 11
    6ac2:	11 f4       	brne	.+4      	; 0x6ac8 <systemGenerateReport+0x8c>
    6ac4:	0c 94 2a 40 	jmp	0x8054	; 0x8054 <systemGenerateReport+0x1618>
    6ac8:	1b 30       	cpi	r17, 0x0B	; 11
    6aca:	08 f4       	brcc	.+2      	; 0x6ace <systemGenerateReport+0x92>
    6acc:	3e c7       	rjmp	.+3708   	; 0x794a <systemGenerateReport+0xf0e>
    6ace:	1c 30       	cpi	r17, 0x0C	; 12
    6ad0:	11 f0       	breq	.+4      	; 0x6ad6 <systemGenerateReport+0x9a>
    6ad2:	0c 94 37 40 	jmp	0x806e	; 0x806e <systemGenerateReport+0x1632>
    6ad6:	0c 94 32 40 	jmp	0x8064	; 0x8064 <systemGenerateReport+0x1628>
	 case grScanAction://Wait for Complete incoming Totalizer data	      
		  if (IsGenerateReport==True){
    6ada:	80 91 99 01 	lds	r24, 0x0199
    6ade:	81 30       	cpi	r24, 0x01	; 1
    6ae0:	11 f0       	breq	.+4      	; 0x6ae6 <systemGenerateReport+0xaa>
    6ae2:	0c 94 37 40 	jmp	0x806e	; 0x806e <systemGenerateReport+0x1632>
		      IsGenerateReport=False;
    6ae6:	10 92 99 01 	sts	0x0199, r1
			  IsFinishPrintingTotalizer=False;
    6aea:	10 92 9a 01 	sts	0x019A, r1
    6aee:	0c 94 2f 40 	jmp	0x805e	; 0x805e <systemGenerateReport+0x1622>
			  stGenerateReport=grInitData;
		  }
	      break;
	 case grInitData:
	      xPump=1;
    6af2:	10 93 13 02 	sts	0x0213, r17
		  xNozzle=1;
    6af6:	10 93 12 02 	sts	0x0212, r17
		  RepPos=0;
    6afa:	10 92 03 02 	sts	0x0203, r1
    6afe:	10 92 02 02 	sts	0x0202, r1
    6b02:	ef ec       	ldi	r30, 0xCF	; 207
    6b04:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    6b06:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b08:	87 e0       	ldi	r24, 0x07	; 7
    6b0a:	e0 36       	cpi	r30, 0x60	; 96
    6b0c:	f8 07       	cpc	r31, r24
    6b0e:	d9 f7       	brne	.-10     	; 0x6b06 <systemGenerateReport+0xca>
    6b10:	fe 01       	movw	r30, r28
    6b12:	eb 55       	subi	r30, 0x5B	; 91
    6b14:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6b16:	ce 01       	movw	r24, r28
    6b18:	8b 50       	subi	r24, 0x0B	; 11
    6b1a:	9f 4f       	sbci	r25, 0xFF	; 255
    6b1c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b1e:	e8 17       	cp	r30, r24
    6b20:	f9 07       	cpc	r31, r25
    6b22:	e1 f7       	brne	.-8      	; 0x6b1c <systemGenerateReport+0xe0>
    6b24:	fe 01       	movw	r30, r28
    6b26:	f7 96       	adiw	r30, 0x37	; 55
	     strMemory[i]=data;
    6b28:	cf 01       	movw	r24, r30
    6b2a:	0f 96       	adiw	r24, 0x0f	; 15
    6b2c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b2e:	e8 17       	cp	r30, r24
    6b30:	f9 07       	cpc	r31, r25
    6b32:	e1 f7       	brne	.-8      	; 0x6b2c <systemGenerateReport+0xf0>
    6b34:	fe 01       	movw	r30, r28
    6b36:	ea 5b       	subi	r30, 0xBA	; 186
    6b38:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6b3a:	cf 01       	movw	r24, r30
    6b3c:	0f 96       	adiw	r24, 0x0f	; 15
    6b3e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b40:	e8 17       	cp	r30, r24
    6b42:	f9 07       	cpc	r31, r25
    6b44:	e1 f7       	brne	.-8      	; 0x6b3e <systemGenerateReport+0x102>
    6b46:	e6 eb       	ldi	r30, 0xB6	; 182
    6b48:	fb e0       	ldi	r31, 0x0B	; 11
	     strMemory[i]=data;
    6b4a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b4c:	9b e0       	ldi	r25, 0x0B	; 11
    6b4e:	ea 3c       	cpi	r30, 0xCA	; 202
    6b50:	f9 07       	cpc	r31, r25
    6b52:	d9 f7       	brne	.-10     	; 0x6b4a <systemGenerateReport+0x10e>
    6b54:	eb e3       	ldi	r30, 0x3B	; 59
    6b56:	fc e0       	ldi	r31, 0x0C	; 12
	     strMemory[i]=data;
    6b58:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b5a:	ac e0       	ldi	r26, 0x0C	; 12
    6b5c:	ef 34       	cpi	r30, 0x4F	; 79
    6b5e:	fa 07       	cpc	r31, r26
    6b60:	d9 f7       	brne	.-10     	; 0x6b58 <systemGenerateReport+0x11c>
    6b62:	e0 e8       	ldi	r30, 0x80	; 128
    6b64:	ff e0       	ldi	r31, 0x0F	; 15
	     strMemory[i]=data;
    6b66:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b68:	bf e0       	ldi	r27, 0x0F	; 15
    6b6a:	ef 38       	cpi	r30, 0x8F	; 143
    6b6c:	fb 07       	cpc	r31, r27
    6b6e:	d9 f7       	brne	.-10     	; 0x6b66 <systemGenerateReport+0x12a>
    6b70:	eb e6       	ldi	r30, 0x6B	; 107
    6b72:	fc e0       	ldi	r31, 0x0C	; 12
	     strMemory[i]=data;
    6b74:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b76:	8c e0       	ldi	r24, 0x0C	; 12
    6b78:	ea 37       	cpi	r30, 0x7A	; 122
    6b7a:	f8 07       	cpc	r31, r24
    6b7c:	d9 f7       	brne	.-10     	; 0x6b74 <systemGenerateReport+0x138>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6b7e:	e1 99       	sbic	0x1c, 1	; 28
    6b80:	fe cf       	rjmp	.-4      	; 0x6b7e <systemGenerateReport+0x142>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6b82:	8f e3       	ldi	r24, 0x3F	; 63
    6b84:	91 e0       	ldi	r25, 0x01	; 1
    6b86:	9f bb       	out	0x1f, r25	; 31
    6b88:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6b8a:	e0 9a       	sbi	0x1c, 0	; 28
    6b8c:	2d b3       	in	r18, 0x1d	; 29
		  FillChar(strTotalMoney,sizeof(strTotalMoney),0);


		  FillChar(strDeltaMoney,sizeof(strDeltaMoney),0);
		  FillChar(strDeltaVolume,sizeof(strDeltaVolume),0);
		  sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    6b8e:	00 d0       	rcall	.+0      	; 0x6b90 <systemGenerateReport+0x154>
    6b90:	00 d0       	rcall	.+0      	; 0x6b92 <systemGenerateReport+0x156>
    6b92:	00 d0       	rcall	.+0      	; 0x6b94 <systemGenerateReport+0x158>
    6b94:	ed b7       	in	r30, 0x3d	; 61
    6b96:	fe b7       	in	r31, 0x3e	; 62
    6b98:	31 96       	adiw	r30, 0x01	; 1
    6b9a:	8b eb       	ldi	r24, 0xBB	; 187
    6b9c:	9f e0       	ldi	r25, 0x0F	; 15
    6b9e:	ad b7       	in	r26, 0x3d	; 61
    6ba0:	be b7       	in	r27, 0x3e	; 62
    6ba2:	12 96       	adiw	r26, 0x02	; 2
    6ba4:	9c 93       	st	X, r25
    6ba6:	8e 93       	st	-X, r24
    6ba8:	11 97       	sbiw	r26, 0x01	; 1
    6baa:	82 ea       	ldi	r24, 0xA2	; 162
    6bac:	95 e0       	ldi	r25, 0x05	; 5
    6bae:	93 83       	std	Z+3, r25	; 0x03
    6bb0:	82 83       	std	Z+2, r24	; 0x02
    6bb2:	24 83       	std	Z+4, r18	; 0x04
    6bb4:	15 82       	std	Z+5, r1	; 0x05
    6bb6:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>

          stGenerateReport=grCreateReportHeader;
    6bba:	82 e0       	ldi	r24, 0x02	; 2
    6bbc:	80 93 14 02 	sts	0x0214, r24
    6bc0:	ed b7       	in	r30, 0x3d	; 61
    6bc2:	fe b7       	in	r31, 0x3e	; 62
    6bc4:	36 96       	adiw	r30, 0x06	; 6
    6bc6:	0f b6       	in	r0, 0x3f	; 63
    6bc8:	f8 94       	cli
    6bca:	fe bf       	out	0x3e, r31	; 62
    6bcc:	0f be       	out	0x3f, r0	; 63
    6bce:	ed bf       	out	0x3d, r30	; 61
    6bd0:	0c 94 37 40 	jmp	0x806e	; 0x806e <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    6bd4:	ce 01       	movw	r24, r28
    6bd6:	8b 5a       	subi	r24, 0xAB	; 171
    6bd8:	9f 4f       	sbci	r25, 0xFF	; 255
    6bda:	63 e4       	ldi	r22, 0x43	; 67
    6bdc:	78 e0       	ldi	r23, 0x08	; 8
    6bde:	44 e1       	ldi	r20, 0x14	; 20
    6be0:	50 e0       	ldi	r21, 0x00	; 0
    6be2:	28 ef       	ldi	r18, 0xF8	; 248
    6be4:	32 e1       	ldi	r19, 0x12	; 18
    6be6:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
	      break;
	 case grCreateReportHeader://Border: btTopLeft,btTopCenter,btTopRight,btMiddleLeft,btMiddleCenter,btMiddleRight,btBottomLeft,btBottomCenter,btBottomRight,btVertical,btHorizontal
		  eeprom_read_block((void*) &LastShiftDateTime, (const void*) &DefLastShiftDateTime, sizeof(DefLastShiftDateTime));
          
		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    6bea:	81 e0       	ldi	r24, 0x01	; 1
    6bec:	6f ec       	ldi	r22, 0xCF	; 207
    6bee:	75 e0       	ldi	r23, 0x05	; 5
    6bf0:	41 e0       	ldi	r20, 0x01	; 1
    6bf2:	22 e0       	ldi	r18, 0x02	; 2
    6bf4:	32 e0       	ldi	r19, 0x02	; 2
    6bf6:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    6bfa:	8b e0       	ldi	r24, 0x0B	; 11
    6bfc:	6f ec       	ldi	r22, 0xCF	; 207
    6bfe:	75 e0       	ldi	r23, 0x05	; 5
    6c00:	4a e2       	ldi	r20, 0x2A	; 42
    6c02:	22 e0       	ldi	r18, 0x02	; 2
    6c04:	32 e0       	ldi	r19, 0x02	; 2
    6c06:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    6c0a:	83 e0       	ldi	r24, 0x03	; 3
    6c0c:	6f ec       	ldi	r22, 0xCF	; 207
    6c0e:	75 e0       	ldi	r23, 0x05	; 5
    6c10:	41 e0       	ldi	r20, 0x01	; 1
    6c12:	22 e0       	ldi	r18, 0x02	; 2
    6c14:	32 e0       	ldi	r19, 0x02	; 2
    6c16:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    6c1a:	8c e0       	ldi	r24, 0x0C	; 12
    6c1c:	6f ec       	ldi	r22, 0xCF	; 207
    6c1e:	75 e0       	ldi	r23, 0x05	; 5
    6c20:	41 e0       	ldi	r20, 0x01	; 1
    6c22:	22 e0       	ldi	r18, 0x02	; 2
    6c24:	32 e0       	ldi	r19, 0x02	; 2
    6c26:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
	      sprintf_P(strReport,PSTR("        Laporan Tutup Shift: %s      "),strShift);CreateReport(strReport,PrintBuffer,&RepPos);
    6c2a:	00 d0       	rcall	.+0      	; 0x6c2c <systemGenerateReport+0x1f0>
    6c2c:	00 d0       	rcall	.+0      	; 0x6c2e <systemGenerateReport+0x1f2>
    6c2e:	00 d0       	rcall	.+0      	; 0x6c30 <systemGenerateReport+0x1f4>
    6c30:	ed b7       	in	r30, 0x3d	; 61
    6c32:	fe b7       	in	r31, 0x3e	; 62
    6c34:	31 96       	adiw	r30, 0x01	; 1
    6c36:	8e 01       	movw	r16, r28
    6c38:	0b 55       	subi	r16, 0x5B	; 91
    6c3a:	1f 4f       	sbci	r17, 0xFF	; 255
    6c3c:	ad b7       	in	r26, 0x3d	; 61
    6c3e:	be b7       	in	r27, 0x3e	; 62
    6c40:	12 96       	adiw	r26, 0x02	; 2
    6c42:	1c 93       	st	X, r17
    6c44:	0e 93       	st	-X, r16
    6c46:	11 97       	sbiw	r26, 0x01	; 1
    6c48:	8c e7       	ldi	r24, 0x7C	; 124
    6c4a:	95 e0       	ldi	r25, 0x05	; 5
    6c4c:	93 83       	std	Z+3, r25	; 0x03
    6c4e:	82 83       	std	Z+2, r24	; 0x02
    6c50:	8b eb       	ldi	r24, 0xBB	; 187
    6c52:	9f e0       	ldi	r25, 0x0F	; 15
    6c54:	95 83       	std	Z+5, r25	; 0x05
    6c56:	84 83       	std	Z+4, r24	; 0x04
    6c58:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    6c5c:	ed b7       	in	r30, 0x3d	; 61
    6c5e:	fe b7       	in	r31, 0x3e	; 62
    6c60:	36 96       	adiw	r30, 0x06	; 6
    6c62:	0f b6       	in	r0, 0x3f	; 63
    6c64:	f8 94       	cli
    6c66:	fe bf       	out	0x3e, r31	; 62
    6c68:	0f be       	out	0x3f, r0	; 63
    6c6a:	ed bf       	out	0x3d, r30	; 61
    6c6c:	c8 01       	movw	r24, r16
    6c6e:	6f ec       	ldi	r22, 0xCF	; 207
    6c70:	75 e0       	ldi	r23, 0x05	; 5
    6c72:	42 e0       	ldi	r20, 0x02	; 2
    6c74:	52 e0       	ldi	r21, 0x02	; 2
    6c76:	0e 94 85 22 	call	0x450a	; 0x450a <CreateReport>
		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     
    6c7a:	84 e0       	ldi	r24, 0x04	; 4
    6c7c:	6f ec       	ldi	r22, 0xCF	; 207
    6c7e:	75 e0       	ldi	r23, 0x05	; 5
    6c80:	41 e0       	ldi	r20, 0x01	; 1
    6c82:	22 e0       	ldi	r18, 0x02	; 2
    6c84:	32 e0       	ldi	r19, 0x02	; 2
    6c86:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    6c8a:	8b e0       	ldi	r24, 0x0B	; 11
    6c8c:	6f ec       	ldi	r22, 0xCF	; 207
    6c8e:	75 e0       	ldi	r23, 0x05	; 5
    6c90:	4a e2       	ldi	r20, 0x2A	; 42
    6c92:	22 e0       	ldi	r18, 0x02	; 2
    6c94:	32 e0       	ldi	r19, 0x02	; 2
    6c96:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    6c9a:	86 e0       	ldi	r24, 0x06	; 6
    6c9c:	6f ec       	ldi	r22, 0xCF	; 207
    6c9e:	75 e0       	ldi	r23, 0x05	; 5
    6ca0:	41 e0       	ldi	r20, 0x01	; 1
    6ca2:	22 e0       	ldi	r18, 0x02	; 2
    6ca4:	32 e0       	ldi	r19, 0x02	; 2
    6ca6:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    6caa:	8c e0       	ldi	r24, 0x0C	; 12
    6cac:	6f ec       	ldi	r22, 0xCF	; 207
    6cae:	75 e0       	ldi	r23, 0x05	; 5
    6cb0:	41 e0       	ldi	r20, 0x01	; 1
    6cb2:	22 e0       	ldi	r18, 0x02	; 2
    6cb4:	32 e0       	ldi	r19, 0x02	; 2
    6cb6:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6cba:	e1 99       	sbic	0x1c, 1	; 28
    6cbc:	fe cf       	rjmp	.-4      	; 0x6cba <systemGenerateReport+0x27e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6cbe:	80 e0       	ldi	r24, 0x00	; 0
    6cc0:	90 e0       	ldi	r25, 0x00	; 0
    6cc2:	9f bb       	out	0x1f, r25	; 31
    6cc4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6cc6:	e0 9a       	sbi	0x1c, 0	; 28
    6cc8:	2d b3       	in	r18, 0x1d	; 29
	      sprintf_P(strReport,PSTR("Terminal ID : %.2d                   "),eeprom_read_byte(&DefIFT_ID));CreateReport(strReport,PrintBuffer,&RepPos);
    6cca:	00 d0       	rcall	.+0      	; 0x6ccc <systemGenerateReport+0x290>
    6ccc:	00 d0       	rcall	.+0      	; 0x6cce <systemGenerateReport+0x292>
    6cce:	00 d0       	rcall	.+0      	; 0x6cd0 <systemGenerateReport+0x294>
    6cd0:	ed b7       	in	r30, 0x3d	; 61
    6cd2:	fe b7       	in	r31, 0x3e	; 62
    6cd4:	31 96       	adiw	r30, 0x01	; 1
    6cd6:	8e 01       	movw	r16, r28
    6cd8:	0b 55       	subi	r16, 0x5B	; 91
    6cda:	1f 4f       	sbci	r17, 0xFF	; 255
    6cdc:	ad b7       	in	r26, 0x3d	; 61
    6cde:	be b7       	in	r27, 0x3e	; 62
    6ce0:	12 96       	adiw	r26, 0x02	; 2
    6ce2:	1c 93       	st	X, r17
    6ce4:	0e 93       	st	-X, r16
    6ce6:	11 97       	sbiw	r26, 0x01	; 1
    6ce8:	86 e5       	ldi	r24, 0x56	; 86
    6cea:	95 e0       	ldi	r25, 0x05	; 5
    6cec:	93 83       	std	Z+3, r25	; 0x03
    6cee:	82 83       	std	Z+2, r24	; 0x02
    6cf0:	24 83       	std	Z+4, r18	; 0x04
    6cf2:	15 82       	std	Z+5, r1	; 0x05
    6cf4:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    6cf8:	ed b7       	in	r30, 0x3d	; 61
    6cfa:	fe b7       	in	r31, 0x3e	; 62
    6cfc:	36 96       	adiw	r30, 0x06	; 6
    6cfe:	0f b6       	in	r0, 0x3f	; 63
    6d00:	f8 94       	cli
    6d02:	fe bf       	out	0x3e, r31	; 62
    6d04:	0f be       	out	0x3f, r0	; 63
    6d06:	ed bf       	out	0x3d, r30	; 61
    6d08:	c8 01       	movw	r24, r16
    6d0a:	6f ec       	ldi	r22, 0xCF	; 207
    6d0c:	75 e0       	ldi	r23, 0x05	; 5
    6d0e:	42 e0       	ldi	r20, 0x02	; 2
    6d10:	52 e0       	ldi	r21, 0x02	; 2
    6d12:	0e 94 85 22 	call	0x450a	; 0x450a <CreateReport>
	      sprintf_P(strReport,PSTR("Awal  Shift : %s "),LastShiftDateTime);             CreateReport(strReport,PrintBuffer,&RepPos);
    6d16:	00 d0       	rcall	.+0      	; 0x6d18 <systemGenerateReport+0x2dc>
    6d18:	00 d0       	rcall	.+0      	; 0x6d1a <systemGenerateReport+0x2de>
    6d1a:	00 d0       	rcall	.+0      	; 0x6d1c <systemGenerateReport+0x2e0>
    6d1c:	ed b7       	in	r30, 0x3d	; 61
    6d1e:	fe b7       	in	r31, 0x3e	; 62
    6d20:	31 96       	adiw	r30, 0x01	; 1
    6d22:	ad b7       	in	r26, 0x3d	; 61
    6d24:	be b7       	in	r27, 0x3e	; 62
    6d26:	12 96       	adiw	r26, 0x02	; 2
    6d28:	1c 93       	st	X, r17
    6d2a:	0e 93       	st	-X, r16
    6d2c:	11 97       	sbiw	r26, 0x01	; 1
    6d2e:	84 e4       	ldi	r24, 0x44	; 68
    6d30:	95 e0       	ldi	r25, 0x05	; 5
    6d32:	93 83       	std	Z+3, r25	; 0x03
    6d34:	82 83       	std	Z+2, r24	; 0x02
    6d36:	ce 01       	movw	r24, r28
    6d38:	8b 5a       	subi	r24, 0xAB	; 171
    6d3a:	9f 4f       	sbci	r25, 0xFF	; 255
    6d3c:	95 83       	std	Z+5, r25	; 0x05
    6d3e:	84 83       	std	Z+4, r24	; 0x04
    6d40:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    6d44:	ed b7       	in	r30, 0x3d	; 61
    6d46:	fe b7       	in	r31, 0x3e	; 62
    6d48:	36 96       	adiw	r30, 0x06	; 6
    6d4a:	0f b6       	in	r0, 0x3f	; 63
    6d4c:	f8 94       	cli
    6d4e:	fe bf       	out	0x3e, r31	; 62
    6d50:	0f be       	out	0x3f, r0	; 63
    6d52:	ed bf       	out	0x3d, r30	; 61
    6d54:	c8 01       	movw	r24, r16
    6d56:	6f ec       	ldi	r22, 0xCF	; 207
    6d58:	75 e0       	ldi	r23, 0x05	; 5
    6d5a:	42 e0       	ldi	r20, 0x02	; 2
    6d5c:	52 e0       	ldi	r21, 0x02	; 2
    6d5e:	0e 94 85 22 	call	0x450a	; 0x450a <CreateReport>
	      sprintf_P(strReport,PSTR("Akhir Shift : %s "),CurrentShiftDateTime);      CreateReport(strReport,PrintBuffer,&RepPos);
    6d62:	00 d0       	rcall	.+0      	; 0x6d64 <systemGenerateReport+0x328>
    6d64:	00 d0       	rcall	.+0      	; 0x6d66 <systemGenerateReport+0x32a>
    6d66:	00 d0       	rcall	.+0      	; 0x6d68 <systemGenerateReport+0x32c>
    6d68:	ed b7       	in	r30, 0x3d	; 61
    6d6a:	fe b7       	in	r31, 0x3e	; 62
    6d6c:	31 96       	adiw	r30, 0x01	; 1
    6d6e:	ad b7       	in	r26, 0x3d	; 61
    6d70:	be b7       	in	r27, 0x3e	; 62
    6d72:	12 96       	adiw	r26, 0x02	; 2
    6d74:	1c 93       	st	X, r17
    6d76:	0e 93       	st	-X, r16
    6d78:	11 97       	sbiw	r26, 0x01	; 1
    6d7a:	82 e3       	ldi	r24, 0x32	; 50
    6d7c:	95 e0       	ldi	r25, 0x05	; 5
    6d7e:	93 83       	std	Z+3, r25	; 0x03
    6d80:	82 83       	std	Z+2, r24	; 0x02
    6d82:	81 e7       	ldi	r24, 0x71	; 113
    6d84:	99 e0       	ldi	r25, 0x09	; 9
    6d86:	95 83       	std	Z+5, r25	; 0x05
    6d88:	84 83       	std	Z+4, r24	; 0x04
    6d8a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    6d8e:	ed b7       	in	r30, 0x3d	; 61
    6d90:	fe b7       	in	r31, 0x3e	; 62
    6d92:	36 96       	adiw	r30, 0x06	; 6
    6d94:	0f b6       	in	r0, 0x3f	; 63
    6d96:	f8 94       	cli
    6d98:	fe bf       	out	0x3e, r31	; 62
    6d9a:	0f be       	out	0x3f, r0	; 63
    6d9c:	ed bf       	out	0x3d, r30	; 61
    6d9e:	c8 01       	movw	r24, r16
    6da0:	6f ec       	ldi	r22, 0xCF	; 207
    6da2:	75 e0       	ldi	r23, 0x05	; 5
    6da4:	42 e0       	ldi	r20, 0x02	; 2
    6da6:	52 e0       	ldi	r21, 0x02	; 2
    6da8:	0e 94 85 22 	call	0x450a	; 0x450a <CreateReport>
	      //sprintf_P(strReport,PSTR("Transaksi   : %s "),DeltaTransaction);      CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    6dac:	87 e0       	ldi	r24, 0x07	; 7
    6dae:	6f ec       	ldi	r22, 0xCF	; 207
    6db0:	75 e0       	ldi	r23, 0x05	; 5
    6db2:	41 e0       	ldi	r20, 0x01	; 1
    6db4:	22 e0       	ldi	r18, 0x02	; 2
    6db6:	32 e0       	ldi	r19, 0x02	; 2
    6db8:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    6dbc:	8b e0       	ldi	r24, 0x0B	; 11
    6dbe:	6f ec       	ldi	r22, 0xCF	; 207
    6dc0:	75 e0       	ldi	r23, 0x05	; 5
    6dc2:	4a e2       	ldi	r20, 0x2A	; 42
    6dc4:	22 e0       	ldi	r18, 0x02	; 2
    6dc6:	32 e0       	ldi	r19, 0x02	; 2
    6dc8:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    6dcc:	89 e0       	ldi	r24, 0x09	; 9
    6dce:	6f ec       	ldi	r22, 0xCF	; 207
    6dd0:	75 e0       	ldi	r23, 0x05	; 5
    6dd2:	41 e0       	ldi	r20, 0x01	; 1
    6dd4:	22 e0       	ldi	r18, 0x02	; 2
    6dd6:	32 e0       	ldi	r19, 0x02	; 2
    6dd8:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    6ddc:	8c e0       	ldi	r24, 0x0C	; 12
    6dde:	6f ec       	ldi	r22, 0xCF	; 207
    6de0:	75 e0       	ldi	r23, 0x05	; 5
    6de2:	41 e0       	ldi	r20, 0x01	; 1
    6de4:	22 e0       	ldi	r18, 0x02	; 2
    6de6:	32 e0       	ldi	r19, 0x02	; 2
    6de8:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
		  /*
	      if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
          */
		  ClearList(GradeList);
    6dec:	84 e0       	ldi	r24, 0x04	; 4
    6dee:	92 e0       	ldi	r25, 0x02	; 2
    6df0:	0e 94 26 23 	call	0x464c	; 0x464c <ClearList>
		  cmdPrint=0b10000000;//PrintHeader
    6df4:	80 e8       	ldi	r24, 0x80	; 128
    6df6:	80 93 cb 01 	sts	0x01CB, r24
		  LengthMessage81=RepPos+1;
    6dfa:	80 91 02 02 	lds	r24, 0x0202
    6dfe:	90 91 03 02 	lds	r25, 0x0203
    6e02:	01 96       	adiw	r24, 0x01	; 1
    6e04:	90 93 a1 01 	sts	0x01A1, r25
    6e08:	80 93 a0 01 	sts	0x01A0, r24
		  IsFreePrinting=True;
    6e0c:	81 e0       	ldi	r24, 0x01	; 1
    6e0e:	80 93 bf 01 	sts	0x01BF, r24
          IsBusyFreePrinting=True;
    6e12:	80 93 ca 01 	sts	0x01CA, r24
		  		  
          stGenerateReport=grWaitPrinted1;
    6e16:	83 e0       	ldi	r24, 0x03	; 3
    6e18:	0c 94 2f 40 	jmp	0x805e	; 0x805e <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted1:
          if (IsBusyFreePrinting==False)
    6e1c:	80 91 ca 01 	lds	r24, 0x01CA
    6e20:	88 23       	and	r24, r24
    6e22:	11 f0       	breq	.+4      	; 0x6e28 <systemGenerateReport+0x3ec>
    6e24:	0c 94 37 40 	jmp	0x806e	; 0x806e <systemGenerateReport+0x1632>
		      stGenerateReport=grGenerateLabel;//grGenerateReportData;//grFinishGenerateReport;
    6e28:	84 e0       	ldi	r24, 0x04	; 4
    6e2a:	0c 94 2f 40 	jmp	0x805e	; 0x805e <systemGenerateReport+0x1622>
	      break;
     case grGenerateLabel:
          RepPos=0;
    6e2e:	10 92 03 02 	sts	0x0203, r1
    6e32:	10 92 02 02 	sts	0x0202, r1
          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    6e36:	81 e0       	ldi	r24, 0x01	; 1
    6e38:	6f ec       	ldi	r22, 0xCF	; 207
    6e3a:	75 e0       	ldi	r23, 0x05	; 5
    6e3c:	41 e0       	ldi	r20, 0x01	; 1
    6e3e:	22 e0       	ldi	r18, 0x02	; 2
    6e40:	32 e0       	ldi	r19, 0x02	; 2
    6e42:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    6e46:	8b e0       	ldi	r24, 0x0B	; 11
    6e48:	6f ec       	ldi	r22, 0xCF	; 207
    6e4a:	75 e0       	ldi	r23, 0x05	; 5
    6e4c:	4a e2       	ldi	r20, 0x2A	; 42
    6e4e:	22 e0       	ldi	r18, 0x02	; 2
    6e50:	32 e0       	ldi	r19, 0x02	; 2
    6e52:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    6e56:	83 e0       	ldi	r24, 0x03	; 3
    6e58:	6f ec       	ldi	r22, 0xCF	; 207
    6e5a:	75 e0       	ldi	r23, 0x05	; 5
    6e5c:	41 e0       	ldi	r20, 0x01	; 1
    6e5e:	22 e0       	ldi	r18, 0x02	; 2
    6e60:	32 e0       	ldi	r19, 0x02	; 2
    6e62:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    6e66:	8c e0       	ldi	r24, 0x0C	; 12
    6e68:	6f ec       	ldi	r22, 0xCF	; 207
    6e6a:	75 e0       	ldi	r23, 0x05	; 5
    6e6c:	41 e0       	ldi	r20, 0x01	; 1
    6e6e:	22 e0       	ldi	r18, 0x02	; 2
    6e70:	32 e0       	ldi	r19, 0x02	; 2
    6e72:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6e76:	e1 99       	sbic	0x1c, 1	; 28
    6e78:	fe cf       	rjmp	.-4      	; 0x6e76 <systemGenerateReport+0x43a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6e7a:	81 ec       	ldi	r24, 0xC1	; 193
    6e7c:	93 e0       	ldi	r25, 0x03	; 3
    6e7e:	9f bb       	out	0x1f, r25	; 31
    6e80:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6e82:	e0 9a       	sbi	0x1c, 0	; 28
    6e84:	8d b3       	in	r24, 0x1d	; 29
    6e86:	9e 01       	movw	r18, r28
    6e88:	2b 55       	subi	r18, 0x5B	; 91
    6e8a:	3f 4f       	sbci	r19, 0xFF	; 255
	      if (eeprom_read_byte(&DefPrintMoney)==True)
    6e8c:	81 30       	cpi	r24, 0x01	; 1
    6e8e:	79 f4       	brne	.+30     	; 0x6eae <systemGenerateReport+0x472>
		       sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
    6e90:	00 d0       	rcall	.+0      	; 0x6e92 <systemGenerateReport+0x456>
    6e92:	00 d0       	rcall	.+0      	; 0x6e94 <systemGenerateReport+0x458>
    6e94:	ad b7       	in	r26, 0x3d	; 61
    6e96:	be b7       	in	r27, 0x3e	; 62
    6e98:	12 96       	adiw	r26, 0x02	; 2
    6e9a:	3c 93       	st	X, r19
    6e9c:	2e 93       	st	-X, r18
    6e9e:	11 97       	sbiw	r26, 0x01	; 1
    6ea0:	8b e0       	ldi	r24, 0x0B	; 11
    6ea2:	95 e0       	ldi	r25, 0x05	; 5
    6ea4:	14 96       	adiw	r26, 0x04	; 4
    6ea6:	9c 93       	st	X, r25
    6ea8:	8e 93       	st	-X, r24
    6eaa:	13 97       	sbiw	r26, 0x03	; 3
    6eac:	0a c0       	rjmp	.+20     	; 0x6ec2 <systemGenerateReport+0x486>
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
    6eae:	00 d0       	rcall	.+0      	; 0x6eb0 <systemGenerateReport+0x474>
    6eb0:	00 d0       	rcall	.+0      	; 0x6eb2 <systemGenerateReport+0x476>
    6eb2:	ed b7       	in	r30, 0x3d	; 61
    6eb4:	fe b7       	in	r31, 0x3e	; 62
    6eb6:	32 83       	std	Z+2, r19	; 0x02
    6eb8:	21 83       	std	Z+1, r18	; 0x01
    6eba:	84 ee       	ldi	r24, 0xE4	; 228
    6ebc:	94 e0       	ldi	r25, 0x04	; 4
    6ebe:	94 83       	std	Z+4, r25	; 0x04
    6ec0:	83 83       	std	Z+3, r24	; 0x03
    6ec2:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    6ec6:	0f 90       	pop	r0
    6ec8:	0f 90       	pop	r0
    6eca:	0f 90       	pop	r0
    6ecc:	0f 90       	pop	r0
    6ece:	ce 01       	movw	r24, r28
    6ed0:	8b 55       	subi	r24, 0x5B	; 91
    6ed2:	9f 4f       	sbci	r25, 0xFF	; 255
    6ed4:	6f ec       	ldi	r22, 0xCF	; 207
    6ed6:	75 e0       	ldi	r23, 0x05	; 5
    6ed8:	42 e0       	ldi	r20, 0x02	; 2
    6eda:	52 e0       	ldi	r21, 0x02	; 2
    6edc:	0e 94 85 22 	call	0x450a	; 0x450a <CreateReport>
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
    6ee0:	87 e0       	ldi	r24, 0x07	; 7
    6ee2:	6f ec       	ldi	r22, 0xCF	; 207
    6ee4:	75 e0       	ldi	r23, 0x05	; 5
    6ee6:	41 e0       	ldi	r20, 0x01	; 1
    6ee8:	22 e0       	ldi	r18, 0x02	; 2
    6eea:	32 e0       	ldi	r19, 0x02	; 2
    6eec:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    6ef0:	8b e0       	ldi	r24, 0x0B	; 11
    6ef2:	6f ec       	ldi	r22, 0xCF	; 207
    6ef4:	75 e0       	ldi	r23, 0x05	; 5
    6ef6:	4a e2       	ldi	r20, 0x2A	; 42
    6ef8:	22 e0       	ldi	r18, 0x02	; 2
    6efa:	32 e0       	ldi	r19, 0x02	; 2
    6efc:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    6f00:	89 e0       	ldi	r24, 0x09	; 9
    6f02:	6f ec       	ldi	r22, 0xCF	; 207
    6f04:	75 e0       	ldi	r23, 0x05	; 5
    6f06:	41 e0       	ldi	r20, 0x01	; 1
    6f08:	22 e0       	ldi	r18, 0x02	; 2
    6f0a:	32 e0       	ldi	r19, 0x02	; 2
    6f0c:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
          
		  cmdPrint=0b00000000;
    6f10:	10 92 cb 01 	sts	0x01CB, r1
		  LengthMessage81=RepPos+1;
    6f14:	80 91 02 02 	lds	r24, 0x0202
    6f18:	90 91 03 02 	lds	r25, 0x0203
    6f1c:	01 96       	adiw	r24, 0x01	; 1
    6f1e:	90 93 a1 01 	sts	0x01A1, r25
    6f22:	80 93 a0 01 	sts	0x01A0, r24

		  IsFreePrinting=True;
    6f26:	81 e0       	ldi	r24, 0x01	; 1
    6f28:	80 93 bf 01 	sts	0x01BF, r24
	      IsBusyFreePrinting=True;
    6f2c:	80 93 ca 01 	sts	0x01CA, r24

		  stGenerateReport=grWaitLabelPrinted;
    6f30:	85 e0       	ldi	r24, 0x05	; 5
    6f32:	0c 94 2f 40 	jmp	0x805e	; 0x805e <systemGenerateReport+0x1622>
          if (IsBusyFreePrinting==False)
		      stGenerateReport=grGenerateReportData;//grFinishGenerateReport;
	      break;
     case grGenerateReportData:
	      //Generate: PumpNum, Nozzle, Product
	      if ((xPump>=1)&&(xPump<=8)){
    6f36:	80 91 13 02 	lds	r24, 0x0213
    6f3a:	81 50       	subi	r24, 0x01	; 1
    6f3c:	88 30       	cpi	r24, 0x08	; 8
    6f3e:	10 f0       	brcs	.+4      	; 0x6f44 <systemGenerateReport+0x508>
    6f40:	0c 94 37 40 	jmp	0x806e	; 0x806e <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    6f44:	ce 01       	movw	r24, r28
    6f46:	07 96       	adiw	r24, 0x07	; 7
    6f48:	65 e4       	ldi	r22, 0x45	; 69
    6f4a:	70 e0       	ldi	r23, 0x00	; 0
    6f4c:	48 e0       	ldi	r20, 0x08	; 8
    6f4e:	50 e0       	ldi	r21, 0x00	; 0
    6f50:	28 ef       	ldi	r18, 0xF8	; 248
    6f52:	32 e1       	ldi	r19, 0x12	; 18
    6f54:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
		      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			  PumpNum=PPumpID[xPump-1];
    6f58:	90 91 13 02 	lds	r25, 0x0213
    6f5c:	fe 01       	movw	r30, r28
    6f5e:	e9 0f       	add	r30, r25
    6f60:	f1 1d       	adc	r31, r1
    6f62:	86 81       	ldd	r24, Z+6	; 0x06
    6f64:	80 93 10 02 	sts	0x0210, r24
			  if (PumpNum>0){
    6f68:	88 23       	and	r24, r24
    6f6a:	09 f4       	brne	.+2      	; 0x6f6e <systemGenerateReport+0x532>
    6f6c:	4b c0       	rjmp	.+150    	; 0x7004 <systemGenerateReport+0x5c8>
    6f6e:	91 9f       	mul	r25, r17
    6f70:	b0 01       	movw	r22, r0
    6f72:	11 24       	eor	r1, r1
    6f74:	61 5b       	subi	r22, 0xB1	; 177
    6f76:	7f 4f       	sbci	r23, 0xFF	; 255
    6f78:	ce 01       	movw	r24, r28
    6f7a:	01 96       	adiw	r24, 0x01	; 1
    6f7c:	46 e0       	ldi	r20, 0x06	; 6
    6f7e:	50 e0       	ldi	r21, 0x00	; 0
    6f80:	28 ef       	ldi	r18, 0xF8	; 248
    6f82:	32 e1       	ldi	r19, 0x12	; 18
    6f84:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
				  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
				  xGrade=PProductID[xNozzle-1];
    6f88:	80 91 12 02 	lds	r24, 0x0212
    6f8c:	fe 01       	movw	r30, r28
    6f8e:	e8 0f       	add	r30, r24
    6f90:	f1 1d       	adc	r31, r1
    6f92:	80 81       	ld	r24, Z
    6f94:	80 93 11 02 	sts	0x0211, r24
    6f98:	61 e4       	ldi	r22, 0x41	; 65
    6f9a:	c6 2e       	mov	r12, r22
    6f9c:	69 e0       	ldi	r22, 0x09	; 9
    6f9e:	d6 2e       	mov	r13, r22

				  if (xGrade>0){
    6fa0:	88 23       	and	r24, r24
    6fa2:	99 f0       	breq	.+38     	; 0x6fca <systemGenerateReport+0x58e>
				      GetProductName(xGrade,strProduct);
    6fa4:	b6 01       	movw	r22, r12
    6fa6:	0e 94 57 2e 	call	0x5cae	; 0x5cae <GetProductName>
                      GradeUsed=xGrade;
    6faa:	80 91 11 02 	lds	r24, 0x0211
    6fae:	80 93 0e 02 	sts	0x020E, r24
					  xGrade=xNozzle;//
    6fb2:	80 91 12 02 	lds	r24, 0x0212
    6fb6:	80 93 11 02 	sts	0x0211, r24
					  PumpNozzle=xNozzle;
    6fba:	80 93 0f 02 	sts	0x020F, r24
					  xNozzle++;
    6fbe:	8f 5f       	subi	r24, 0xFF	; 255
    6fc0:	80 93 12 02 	sts	0x0212, r24
					  stGenerateReport=grCreateReportTotalizer;
    6fc4:	88 e0       	ldi	r24, 0x08	; 8
    6fc6:	0c 94 2f 40 	jmp	0x805e	; 0x805e <systemGenerateReport+0x1622>
				  }
				  else{sprintf_P(strProduct,PSTR("N/A"));			  
    6fca:	00 d0       	rcall	.+0      	; 0x6fcc <systemGenerateReport+0x590>
    6fcc:	00 d0       	rcall	.+0      	; 0x6fce <systemGenerateReport+0x592>
    6fce:	ad b7       	in	r26, 0x3d	; 61
    6fd0:	be b7       	in	r27, 0x3e	; 62
    6fd2:	12 96       	adiw	r26, 0x02	; 2
    6fd4:	dc 92       	st	X, r13
    6fd6:	ce 92       	st	-X, r12
    6fd8:	11 97       	sbiw	r26, 0x01	; 1
    6fda:	80 ee       	ldi	r24, 0xE0	; 224
    6fdc:	94 e0       	ldi	r25, 0x04	; 4
    6fde:	14 96       	adiw	r26, 0x04	; 4
    6fe0:	9c 93       	st	X, r25
    6fe2:	8e 93       	st	-X, r24
    6fe4:	13 97       	sbiw	r26, 0x03	; 3
    6fe6:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
					   xNozzle++;
    6fea:	80 91 12 02 	lds	r24, 0x0212
    6fee:	8f 5f       	subi	r24, 0xFF	; 255
    6ff0:	80 93 12 02 	sts	0x0212, r24
					   if (xNozzle>6)stGenerateReport=grNextPump;
    6ff4:	0f 90       	pop	r0
    6ff6:	0f 90       	pop	r0
    6ff8:	0f 90       	pop	r0
    6ffa:	0f 90       	pop	r0
    6ffc:	87 30       	cpi	r24, 0x07	; 7
    6ffe:	10 f4       	brcc	.+4      	; 0x7004 <systemGenerateReport+0x5c8>
    7000:	0c 94 37 40 	jmp	0x806e	; 0x806e <systemGenerateReport+0x1632>
					  }
				}else stGenerateReport=grNextPump;
    7004:	87 e0       	ldi	r24, 0x07	; 7
    7006:	0c 94 2f 40 	jmp	0x805e	; 0x805e <systemGenerateReport+0x1622>
			  }
	      break;
     case grNextPump:
	      xNozzle=1;
    700a:	81 e0       	ldi	r24, 0x01	; 1
    700c:	80 93 12 02 	sts	0x0212, r24
	      xPump++;
    7010:	80 91 13 02 	lds	r24, 0x0213
    7014:	8f 5f       	subi	r24, 0xFF	; 255
    7016:	80 93 13 02 	sts	0x0213, r24
	      if (xPump>8)stGenerateReport=grCreateReportFooter;
    701a:	89 30       	cpi	r24, 0x09	; 9
    701c:	08 f4       	brcc	.+2      	; 0x7020 <systemGenerateReport+0x5e4>
    701e:	93 c4       	rjmp	.+2342   	; 0x7946 <systemGenerateReport+0xf0a>
    7020:	8a e0       	ldi	r24, 0x0A	; 10
    7022:	0c 94 2f 40 	jmp	0x805e	; 0x805e <systemGenerateReport+0x1622>
		  else stGenerateReport=grGenerateReportData;
	      break;
     case grCreateReportTotalizer:

          RepPos=0;
    7026:	10 92 03 02 	sts	0x0203, r1
    702a:	10 92 02 02 	sts	0x0202, r1
    702e:	ef ec       	ldi	r30, 0xCF	; 207
    7030:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    7032:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7034:	b7 e0       	ldi	r27, 0x07	; 7
    7036:	e0 36       	cpi	r30, 0x60	; 96
    7038:	fb 07       	cpc	r31, r27
    703a:	d9 f7       	brne	.-10     	; 0x7032 <systemGenerateReport+0x5f6>
    703c:	fe 01       	movw	r30, r28
    703e:	eb 55       	subi	r30, 0x5B	; 91
    7040:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    7042:	ce 01       	movw	r24, r28
    7044:	8b 50       	subi	r24, 0x0B	; 11
    7046:	9f 4f       	sbci	r25, 0xFF	; 255
    7048:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    704a:	e8 17       	cp	r30, r24
    704c:	f9 07       	cpc	r31, r25
    704e:	e1 f7       	brne	.-8      	; 0x7048 <systemGenerateReport+0x60c>
    7050:	e0 e8       	ldi	r30, 0x80	; 128
    7052:	ff e0       	ldi	r31, 0x0F	; 15
	     strMemory[i]=data;
    7054:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7056:	8f e0       	ldi	r24, 0x0F	; 15
    7058:	ef 38       	cpi	r30, 0x8F	; 143
    705a:	f8 07       	cpc	r31, r24
    705c:	d9 f7       	brne	.-10     	; 0x7054 <systemGenerateReport+0x618>
    705e:	eb e6       	ldi	r30, 0x6B	; 107
    7060:	fc e0       	ldi	r31, 0x0C	; 12
	     strMemory[i]=data;
    7062:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7064:	9c e0       	ldi	r25, 0x0C	; 12
    7066:	ea 37       	cpi	r30, 0x7A	; 122
    7068:	f9 07       	cpc	r31, r25
    706a:	d9 f7       	brne	.-10     	; 0x7062 <systemGenerateReport+0x626>
    706c:	fe 01       	movw	r30, r28
    706e:	79 96       	adiw	r30, 0x19	; 25
	     strMemory[i]=data;
    7070:	ce 01       	movw	r24, r28
    7072:	88 96       	adiw	r24, 0x28	; 40
    7074:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7076:	e8 17       	cp	r30, r24
    7078:	f9 07       	cpc	r31, r25
    707a:	e1 f7       	brne	.-8      	; 0x7074 <systemGenerateReport+0x638>
	     strMemory[i]=data;
    707c:	ce 01       	movw	r24, r28
    707e:	c7 96       	adiw	r24, 0x37	; 55
    7080:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7082:	e8 17       	cp	r30, r24
    7084:	f9 07       	cpc	r31, r25
    7086:	e1 f7       	brne	.-8      	; 0x7080 <systemGenerateReport+0x644>
	     strMemory[i]=data;
    7088:	cf 01       	movw	r24, r30
    708a:	0f 96       	adiw	r24, 0x0f	; 15
    708c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    708e:	e8 17       	cp	r30, r24
    7090:	f9 07       	cpc	r31, r25
    7092:	e1 f7       	brne	.-8      	; 0x708c <systemGenerateReport+0x650>
    7094:	fe 01       	movw	r30, r28
    7096:	ea 5b       	subi	r30, 0xBA	; 186
    7098:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    709a:	cf 01       	movw	r24, r30
    709c:	ee 2e       	mov	r14, r30
    709e:	d9 2e       	mov	r13, r25
    70a0:	0f 96       	adiw	r24, 0x0f	; 15
    70a2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    70a4:	e8 17       	cp	r30, r24
    70a6:	f9 07       	cpc	r31, r25
    70a8:	e1 f7       	brne	.-8      	; 0x70a2 <systemGenerateReport+0x666>
		  FillChar(strLastMoney,sizeof(strLastMoney),0);

		  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
		  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

          FIPAddr=GetFIPAddr(PumpNum); 
    70aa:	80 91 10 02 	lds	r24, 0x0210
    70ae:	0e 94 dd 1d 	call	0x3bba	; 0x3bba <GetFIPAddr>
		  if (FIPAddr>0){
    70b2:	88 23       	and	r24, r24
    70b4:	49 f1       	breq	.+82     	; 0x7108 <systemGenerateReport+0x6cc>
		      FIPAddr=FIPAddr-1;		  
    70b6:	f8 2e       	mov	r15, r24
    70b8:	fa 94       	dec	r15
			  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    70ba:	80 e0       	ldi	r24, 0x00	; 0
    70bc:	60 e0       	ldi	r22, 0x00	; 0
    70be:	4f 2d       	mov	r20, r15
    70c0:	20 91 0f 02 	lds	r18, 0x020F
    70c4:	8e 01       	movw	r16, r28
    70c6:	07 5e       	subi	r16, 0xE7	; 231
    70c8:	1f 4f       	sbci	r17, 0xFF	; 255
    70ca:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    70ce:	81 e0       	ldi	r24, 0x01	; 1
    70d0:	60 e0       	ldi	r22, 0x00	; 0
    70d2:	4f 2d       	mov	r20, r15
    70d4:	20 91 0f 02 	lds	r18, 0x020F
    70d8:	8e 01       	movw	r16, r28
    70da:	08 5d       	subi	r16, 0xD8	; 216
    70dc:	1f 4f       	sbci	r17, 0xFF	; 255
    70de:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <GetTotalizerData>

			  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    70e2:	80 e0       	ldi	r24, 0x00	; 0
    70e4:	61 e0       	ldi	r22, 0x01	; 1
    70e6:	4f 2d       	mov	r20, r15
    70e8:	20 91 0f 02 	lds	r18, 0x020F
    70ec:	8e 01       	movw	r16, r28
    70ee:	09 5c       	subi	r16, 0xC9	; 201
    70f0:	1f 4f       	sbci	r17, 0xFF	; 255
    70f2:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    70f6:	81 e0       	ldi	r24, 0x01	; 1
    70f8:	61 e0       	ldi	r22, 0x01	; 1
    70fa:	4f 2d       	mov	r20, r15
    70fc:	20 91 0f 02 	lds	r18, 0x020F
    7100:	0e 2d       	mov	r16, r14
    7102:	1d 2d       	mov	r17, r13
    7104:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <GetTotalizerData>
		  }

		  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    7108:	80 e0       	ldi	r24, 0x00	; 0
    710a:	be 01       	movw	r22, r28
    710c:	69 5c       	subi	r22, 0xC9	; 201
    710e:	7f 4f       	sbci	r23, 0xFF	; 255
    7110:	ae 01       	movw	r20, r28
    7112:	47 5e       	subi	r20, 0xE7	; 231
    7114:	5f 4f       	sbci	r21, 0xFF	; 255
    7116:	2b e6       	ldi	r18, 0x6B	; 107
    7118:	3c e0       	ldi	r19, 0x0C	; 12
    711a:	0e 94 ef 29 	call	0x53de	; 0x53de <StrCalc>

		  if (IsMinus(strDeltaVolume)==True)
    711e:	8b e6       	ldi	r24, 0x6B	; 107
    7120:	9c e0       	ldi	r25, 0x0C	; 12
    7122:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <IsMinus>
    7126:	81 30       	cpi	r24, 0x01	; 1
    7128:	21 f4       	brne	.+8      	; 0x7132 <systemGenerateReport+0x6f6>
		      NormalizeOverflow(strDeltaVolume);
    712a:	8b e6       	ldi	r24, 0x6B	; 107
    712c:	9c e0       	ldi	r25, 0x0C	; 12
    712e:	0e 94 86 2d 	call	0x5b0c	; 0x5b0c <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7132:	e1 99       	sbic	0x1c, 1	; 28
    7134:	fe cf       	rjmp	.-4      	; 0x7132 <systemGenerateReport+0x6f6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7136:	57 e3       	ldi	r21, 0x37	; 55
    7138:	85 2e       	mov	r8, r21
    713a:	51 e0       	ldi	r21, 0x01	; 1
    713c:	95 2e       	mov	r9, r21
    713e:	9f ba       	out	0x1f, r9	; 31
    7140:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7142:	e0 9a       	sbi	0x1c, 0	; 28
    7144:	8d b3       	in	r24, 0x1d	; 29

		  //Calculate Wayne Estimated Total Money
		  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    7146:	82 30       	cpi	r24, 0x02	; 2
    7148:	79 f4       	brne	.+30     	; 0x7168 <systemGenerateReport+0x72c>
              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    714a:	8e 01       	movw	r16, r28
    714c:	01 5f       	subi	r16, 0xF1	; 241
    714e:	1f 4f       	sbci	r17, 0xFF	; 255
    7150:	c8 01       	movw	r24, r16
    7152:	60 91 10 02 	lds	r22, 0x0210
    7156:	40 91 0f 02 	lds	r20, 0x020F
    715a:	0e 94 cd 24 	call	0x499a	; 0x499a <GetProductPrice>
			  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    715e:	82 e0       	ldi	r24, 0x02	; 2
    7160:	b8 01       	movw	r22, r16
    7162:	4b e6       	ldi	r20, 0x6B	; 107
    7164:	5c e0       	ldi	r21, 0x0C	; 12
    7166:	07 c0       	rjmp	.+14     	; 0x7176 <systemGenerateReport+0x73a>
			  
		  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    7168:	80 e0       	ldi	r24, 0x00	; 0
    716a:	be 01       	movw	r22, r28
    716c:	6a 5b       	subi	r22, 0xBA	; 186
    716e:	7f 4f       	sbci	r23, 0xFF	; 255
    7170:	ae 01       	movw	r20, r28
    7172:	48 5d       	subi	r20, 0xD8	; 216
    7174:	5f 4f       	sbci	r21, 0xFF	; 255
    7176:	20 e8       	ldi	r18, 0x80	; 128
    7178:	3f e0       	ldi	r19, 0x0F	; 15
    717a:	0e 94 ef 29 	call	0x53de	; 0x53de <StrCalc>

		  if (IsMinus(strDeltaMoney)==True)
    717e:	80 e8       	ldi	r24, 0x80	; 128
    7180:	9f e0       	ldi	r25, 0x0F	; 15
    7182:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <IsMinus>
    7186:	81 30       	cpi	r24, 0x01	; 1
    7188:	21 f4       	brne	.+8      	; 0x7192 <systemGenerateReport+0x756>
		      NormalizeOverflow(strDeltaMoney);
    718a:	80 e8       	ldi	r24, 0x80	; 128
    718c:	9f e0       	ldi	r25, 0x0F	; 15
    718e:	0e 94 86 2d 	call	0x5b0c	; 0x5b0c <NormalizeOverflow>

		  AddList(GradeUsed,GradeList);
    7192:	80 91 0e 02 	lds	r24, 0x020E
    7196:	64 e0       	ldi	r22, 0x04	; 4
    7198:	72 e0       	ldi	r23, 0x02	; 2
    719a:	0e 94 f3 22 	call	0x45e6	; 0x45e6 <AddList>
		  
		  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    719e:	81 e0       	ldi	r24, 0x01	; 1
    71a0:	66 eb       	ldi	r22, 0xB6	; 182
    71a2:	7b e0       	ldi	r23, 0x0B	; 11
    71a4:	4b e6       	ldi	r20, 0x6B	; 107
    71a6:	5c e0       	ldi	r21, 0x0C	; 12
    71a8:	9b 01       	movw	r18, r22
    71aa:	0e 94 ef 29 	call	0x53de	; 0x53de <StrCalc>
		  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    71ae:	81 e0       	ldi	r24, 0x01	; 1
    71b0:	6b e3       	ldi	r22, 0x3B	; 59
    71b2:	7c e0       	ldi	r23, 0x0C	; 12
    71b4:	40 e8       	ldi	r20, 0x80	; 128
    71b6:	5f e0       	ldi	r21, 0x0F	; 15
    71b8:	9b 01       	movw	r18, r22
    71ba:	0e 94 ef 29 	call	0x53de	; 0x53de <StrCalc>


		  RemZeroLead(strDeltaMoney);
    71be:	80 e8       	ldi	r24, 0x80	; 128
    71c0:	9f e0       	ldi	r25, 0x0F	; 15
    71c2:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
		  RemZeroLead(strCurrentMoney);
    71c6:	46 e4       	ldi	r20, 0x46	; 70
    71c8:	c4 2e       	mov	r12, r20
    71ca:	d1 2c       	mov	r13, r1
    71cc:	cc 0e       	add	r12, r28
    71ce:	dd 1e       	adc	r13, r29
    71d0:	c6 01       	movw	r24, r12
    71d2:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
		  RemZeroLead(strLastMoney);
    71d6:	38 e2       	ldi	r19, 0x28	; 40
    71d8:	e3 2e       	mov	r14, r19
    71da:	f1 2c       	mov	r15, r1
    71dc:	ec 0e       	add	r14, r28
    71de:	fd 1e       	adc	r15, r29
    71e0:	c7 01       	movw	r24, r14
    71e2:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>

          RemZeroLead(strDeltaVolume);
    71e6:	8b e6       	ldi	r24, 0x6B	; 107
    71e8:	9c e0       	ldi	r25, 0x0C	; 12
    71ea:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
          RemZeroLead(strCurrentVolume);
    71ee:	27 e3       	ldi	r18, 0x37	; 55
    71f0:	a2 2e       	mov	r10, r18
    71f2:	b1 2c       	mov	r11, r1
    71f4:	ac 0e       	add	r10, r28
    71f6:	bd 1e       	adc	r11, r29
    71f8:	c5 01       	movw	r24, r10
    71fa:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
          RemZeroLead(strLastVolume);
    71fe:	8e 01       	movw	r16, r28
    7200:	07 5e       	subi	r16, 0xE7	; 231
    7202:	1f 4f       	sbci	r17, 0xFF	; 255
    7204:	c8 01       	movw	r24, r16
    7206:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>

		  FormatTotalizerMoney(strDeltaMoney);
    720a:	80 e8       	ldi	r24, 0x80	; 128
    720c:	9f e0       	ldi	r25, 0x0F	; 15
    720e:	0e 94 ea 34 	call	0x69d4	; 0x69d4 <FormatTotalizerMoney>
		  FormatTotalizerMoney(strCurrentMoney);
    7212:	c6 01       	movw	r24, r12
    7214:	0e 94 ea 34 	call	0x69d4	; 0x69d4 <FormatTotalizerMoney>
		  FormatTotalizerMoney(strLastMoney);
    7218:	c7 01       	movw	r24, r14
    721a:	0e 94 ea 34 	call	0x69d4	; 0x69d4 <FormatTotalizerMoney>

		  FormatTotalizerVolume(strDeltaVolume);
    721e:	8b e6       	ldi	r24, 0x6B	; 107
    7220:	9c e0       	ldi	r25, 0x0C	; 12
    7222:	0e 94 dd 34 	call	0x69ba	; 0x69ba <FormatTotalizerVolume>
		  FormatTotalizerVolume(strLastVolume);
    7226:	c8 01       	movw	r24, r16
    7228:	0e 94 dd 34 	call	0x69ba	; 0x69ba <FormatTotalizerVolume>
		  FormatTotalizerVolume(strCurrentVolume); 
    722c:	c5 01       	movw	r24, r10
    722e:	0e 94 dd 34 	call	0x69ba	; 0x69ba <FormatTotalizerVolume>

          FormatCurrency(strDeltaMoney);
    7232:	80 e8       	ldi	r24, 0x80	; 128
    7234:	9f e0       	ldi	r25, 0x0F	; 15
    7236:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>
		  FormatCurrency(strCurrentMoney);
    723a:	c6 01       	movw	r24, r12
    723c:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>
		  FormatCurrency(strLastMoney);
    7240:	c7 01       	movw	r24, r14
    7242:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>

		  FormatCurrency(strDeltaVolume);		  
    7246:	8b e6       	ldi	r24, 0x6B	; 107
    7248:	9c e0       	ldi	r25, 0x0C	; 12
    724a:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>
		  FormatCurrency(strLastVolume);
    724e:	c8 01       	movw	r24, r16
    7250:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>
          FormatCurrency(strCurrentVolume);
    7254:	c5 01       	movw	r24, r10
    7256:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>


          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    725a:	81 e0       	ldi	r24, 0x01	; 1
    725c:	6f ec       	ldi	r22, 0xCF	; 207
    725e:	75 e0       	ldi	r23, 0x05	; 5
    7260:	41 e0       	ldi	r20, 0x01	; 1
    7262:	22 e0       	ldi	r18, 0x02	; 2
    7264:	32 e0       	ldi	r19, 0x02	; 2
    7266:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    726a:	8b e0       	ldi	r24, 0x0B	; 11
    726c:	6f ec       	ldi	r22, 0xCF	; 207
    726e:	75 e0       	ldi	r23, 0x05	; 5
    7270:	4a e2       	ldi	r20, 0x2A	; 42
    7272:	22 e0       	ldi	r18, 0x02	; 2
    7274:	32 e0       	ldi	r19, 0x02	; 2
    7276:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    727a:	83 e0       	ldi	r24, 0x03	; 3
    727c:	6f ec       	ldi	r22, 0xCF	; 207
    727e:	75 e0       	ldi	r23, 0x05	; 5
    7280:	41 e0       	ldi	r20, 0x01	; 1
    7282:	22 e0       	ldi	r18, 0x02	; 2
    7284:	32 e0       	ldi	r19, 0x02	; 2
    7286:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    728a:	8c e0       	ldi	r24, 0x0C	; 12
    728c:	6f ec       	ldi	r22, 0xCF	; 207
    728e:	75 e0       	ldi	r23, 0x05	; 5
    7290:	41 e0       	ldi	r20, 0x01	; 1
    7292:	22 e0       	ldi	r18, 0x02	; 2
    7294:	32 e0       	ldi	r19, 0x02	; 2
    7296:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    729a:	e1 99       	sbic	0x1c, 1	; 28
    729c:	fe cf       	rjmp	.-4      	; 0x729a <systemGenerateReport+0x85e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    729e:	9f ba       	out	0x1f, r9	; 31
    72a0:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    72a2:	e0 9a       	sbi	0x1c, 0	; 28
    72a4:	8d b3       	in	r24, 0x1d	; 29
    72a6:	91 e4       	ldi	r25, 0x41	; 65
    72a8:	c9 2e       	mov	r12, r25
    72aa:	99 e0       	ldi	r25, 0x09	; 9
    72ac:	d9 2e       	mov	r13, r25
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    72ae:	82 30       	cpi	r24, 0x02	; 2
    72b0:	09 f0       	breq	.+2      	; 0x72b4 <systemGenerateReport+0x878>
    72b2:	84 c0       	rjmp	.+264    	; 0x73bc <systemGenerateReport+0x980>
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
    72b4:	0f e0       	ldi	r16, 0x0F	; 15
    72b6:	e0 2e       	mov	r14, r16
    72b8:	f1 2c       	mov	r15, r1
    72ba:	ec 0e       	add	r14, r28
    72bc:	fd 1e       	adc	r15, r29
    72be:	c7 01       	movw	r24, r14
    72c0:	60 91 10 02 	lds	r22, 0x0210
    72c4:	40 91 0f 02 	lds	r20, 0x020F
    72c8:	0e 94 cd 24 	call	0x499a	; 0x499a <GetProductPrice>
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);
    72cc:	00 d0       	rcall	.+0      	; 0x72ce <systemGenerateReport+0x892>
    72ce:	00 d0       	rcall	.+0      	; 0x72d0 <systemGenerateReport+0x894>
    72d0:	00 d0       	rcall	.+0      	; 0x72d2 <systemGenerateReport+0x896>
    72d2:	ed b7       	in	r30, 0x3d	; 61
    72d4:	fe b7       	in	r31, 0x3e	; 62
    72d6:	31 96       	adiw	r30, 0x01	; 1
    72d8:	8e 01       	movw	r16, r28
    72da:	0f 56       	subi	r16, 0x6F	; 111
    72dc:	1f 4f       	sbci	r17, 0xFF	; 255
    72de:	ad b7       	in	r26, 0x3d	; 61
    72e0:	be b7       	in	r27, 0x3e	; 62
    72e2:	12 96       	adiw	r26, 0x02	; 2
    72e4:	1c 93       	st	X, r17
    72e6:	0e 93       	st	-X, r16
    72e8:	11 97       	sbiw	r26, 0x01	; 1
    72ea:	83 ed       	ldi	r24, 0xD3	; 211
    72ec:	94 e0       	ldi	r25, 0x04	; 4
    72ee:	93 83       	std	Z+3, r25	; 0x03
    72f0:	82 83       	std	Z+2, r24	; 0x02
    72f2:	f5 82       	std	Z+5, r15	; 0x05
    72f4:	e4 82       	std	Z+4, r14	; 0x04
    72f6:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
    72fa:	d6 01       	movw	r26, r12
    72fc:	0d 90       	ld	r0, X+
    72fe:	00 20       	and	r0, r0
    7300:	e9 f7       	brne	.-6      	; 0x72fc <systemGenerateReport+0x8c0>
    7302:	11 97       	sbiw	r26, 0x01	; 1
    7304:	ac 19       	sub	r26, r12
    7306:	bd 09       	sbc	r27, r13
    7308:	f8 01       	movw	r30, r16
    730a:	01 90       	ld	r0, Z+
    730c:	00 20       	and	r0, r0
    730e:	e9 f7       	brne	.-6      	; 0x730a <systemGenerateReport+0x8ce>
    7310:	31 97       	sbiw	r30, 0x01	; 1
    7312:	0e 1b       	sub	r16, r30
    7314:	0a 1b       	sub	r16, r26
    7316:	05 5e       	subi	r16, 0xE5	; 229
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7318:	ed b7       	in	r30, 0x3d	; 61
    731a:	fe b7       	in	r31, 0x3e	; 62
    731c:	36 96       	adiw	r30, 0x06	; 6
    731e:	0f b6       	in	r0, 0x3f	; 63
    7320:	f8 94       	cli
    7322:	fe bf       	out	0x3e, r31	; 62
    7324:	0f be       	out	0x3f, r0	; 63
    7326:	ed bf       	out	0x3d, r30	; 61
    7328:	fe 01       	movw	r30, r28
    732a:	e3 58       	subi	r30, 0x83	; 131
    732c:	ff 4f       	sbci	r31, 0xFF	; 255
    732e:	10 16       	cp	r1, r16
    7330:	74 f4       	brge	.+28     	; 0x734e <systemGenerateReport+0x912>
    7332:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7334:	90 e2       	ldi	r25, 0x20	; 32
    7336:	02 c0       	rjmp	.+4      	; 0x733c <systemGenerateReport+0x900>
    7338:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    733a:	8f 5f       	subi	r24, 0xFF	; 255
    733c:	80 17       	cp	r24, r16
    733e:	e0 f3       	brcs	.-8      	; 0x7338 <systemGenerateReport+0x8fc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7340:	fe 01       	movw	r30, r28
    7342:	e3 58       	subi	r30, 0x83	; 131
    7344:	ff 4f       	sbci	r31, 0xFF	; 255
    7346:	e0 0f       	add	r30, r16
    7348:	f1 1d       	adc	r31, r1
    734a:	10 82       	st	Z, r1
    734c:	03 c0       	rjmp	.+6      	; 0x7354 <systemGenerateReport+0x918>
     }else{
	 strTab[0]=' ';
    734e:	80 e2       	ldi	r24, 0x20	; 32
    7350:	80 83       	st	Z, r24
	 strTab[1]=0;
    7352:	11 82       	std	Z+1, r1	; 0x01
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
		      sprintf_P(strReport,PSTR("P%d.%d - %s %s %s"),PumpNum,PumpNozzle,strProduct,strTabSpace2,strProductPrice);
    7354:	8d b7       	in	r24, 0x3d	; 61
    7356:	9e b7       	in	r25, 0x3e	; 62
    7358:	0e 97       	sbiw	r24, 0x0e	; 14
    735a:	0f b6       	in	r0, 0x3f	; 63
    735c:	f8 94       	cli
    735e:	9e bf       	out	0x3e, r25	; 62
    7360:	0f be       	out	0x3f, r0	; 63
    7362:	8d bf       	out	0x3d, r24	; 61
    7364:	ed b7       	in	r30, 0x3d	; 61
    7366:	fe b7       	in	r31, 0x3e	; 62
    7368:	31 96       	adiw	r30, 0x01	; 1
    736a:	ce 01       	movw	r24, r28
    736c:	8b 55       	subi	r24, 0x5B	; 91
    736e:	9f 4f       	sbci	r25, 0xFF	; 255
    7370:	ad b7       	in	r26, 0x3d	; 61
    7372:	be b7       	in	r27, 0x3e	; 62
    7374:	12 96       	adiw	r26, 0x02	; 2
    7376:	9c 93       	st	X, r25
    7378:	8e 93       	st	-X, r24
    737a:	11 97       	sbiw	r26, 0x01	; 1
    737c:	81 ec       	ldi	r24, 0xC1	; 193
    737e:	94 e0       	ldi	r25, 0x04	; 4
    7380:	93 83       	std	Z+3, r25	; 0x03
    7382:	82 83       	std	Z+2, r24	; 0x02
    7384:	80 91 10 02 	lds	r24, 0x0210
    7388:	84 83       	std	Z+4, r24	; 0x04
    738a:	15 82       	std	Z+5, r1	; 0x05
    738c:	80 91 0f 02 	lds	r24, 0x020F
    7390:	86 83       	std	Z+6, r24	; 0x06
    7392:	17 82       	std	Z+7, r1	; 0x07
    7394:	81 e4       	ldi	r24, 0x41	; 65
    7396:	99 e0       	ldi	r25, 0x09	; 9
    7398:	91 87       	std	Z+9, r25	; 0x09
    739a:	80 87       	std	Z+8, r24	; 0x08
    739c:	ce 01       	movw	r24, r28
    739e:	83 58       	subi	r24, 0x83	; 131
    73a0:	9f 4f       	sbci	r25, 0xFF	; 255
    73a2:	93 87       	std	Z+11, r25	; 0x0b
    73a4:	82 87       	std	Z+10, r24	; 0x0a
    73a6:	ce 01       	movw	r24, r28
    73a8:	8f 56       	subi	r24, 0x6F	; 111
    73aa:	9f 4f       	sbci	r25, 0xFF	; 255
    73ac:	95 87       	std	Z+13, r25	; 0x0d
    73ae:	84 87       	std	Z+12, r24	; 0x0c
    73b0:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    73b4:	ed b7       	in	r30, 0x3d	; 61
    73b6:	fe b7       	in	r31, 0x3e	; 62
    73b8:	3e 96       	adiw	r30, 0x0e	; 14
    73ba:	27 c0       	rjmp	.+78     	; 0x740a <systemGenerateReport+0x9ce>
		  }
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
    73bc:	8d b7       	in	r24, 0x3d	; 61
    73be:	9e b7       	in	r25, 0x3e	; 62
    73c0:	0a 97       	sbiw	r24, 0x0a	; 10
    73c2:	0f b6       	in	r0, 0x3f	; 63
    73c4:	f8 94       	cli
    73c6:	9e bf       	out	0x3e, r25	; 62
    73c8:	0f be       	out	0x3f, r0	; 63
    73ca:	8d bf       	out	0x3d, r24	; 61
    73cc:	ed b7       	in	r30, 0x3d	; 61
    73ce:	fe b7       	in	r31, 0x3e	; 62
    73d0:	31 96       	adiw	r30, 0x01	; 1
    73d2:	ce 01       	movw	r24, r28
    73d4:	8b 55       	subi	r24, 0x5B	; 91
    73d6:	9f 4f       	sbci	r25, 0xFF	; 255
    73d8:	ad b7       	in	r26, 0x3d	; 61
    73da:	be b7       	in	r27, 0x3e	; 62
    73dc:	12 96       	adiw	r26, 0x02	; 2
    73de:	9c 93       	st	X, r25
    73e0:	8e 93       	st	-X, r24
    73e2:	11 97       	sbiw	r26, 0x01	; 1
    73e4:	84 eb       	ldi	r24, 0xB4	; 180
    73e6:	94 e0       	ldi	r25, 0x04	; 4
    73e8:	93 83       	std	Z+3, r25	; 0x03
    73ea:	82 83       	std	Z+2, r24	; 0x02
    73ec:	80 91 10 02 	lds	r24, 0x0210
    73f0:	84 83       	std	Z+4, r24	; 0x04
    73f2:	15 82       	std	Z+5, r1	; 0x05
    73f4:	80 91 0f 02 	lds	r24, 0x020F
    73f8:	86 83       	std	Z+6, r24	; 0x06
    73fa:	17 82       	std	Z+7, r1	; 0x07
    73fc:	d1 86       	std	Z+9, r13	; 0x09
    73fe:	c0 86       	std	Z+8, r12	; 0x08
    7400:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    7404:	ed b7       	in	r30, 0x3d	; 61
    7406:	fe b7       	in	r31, 0x3e	; 62
    7408:	3a 96       	adiw	r30, 0x0a	; 10
    740a:	0f b6       	in	r0, 0x3f	; 63
    740c:	f8 94       	cli
    740e:	fe bf       	out	0x3e, r31	; 62
    7410:	0f be       	out	0x3f, r0	; 63
    7412:	ed bf       	out	0x3d, r30	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    7414:	ce 01       	movw	r24, r28
    7416:	8b 55       	subi	r24, 0x5B	; 91
    7418:	9f 4f       	sbci	r25, 0xFF	; 255
    741a:	6f ec       	ldi	r22, 0xCF	; 207
    741c:	75 e0       	ldi	r23, 0x05	; 5
    741e:	42 e0       	ldi	r20, 0x02	; 2
    7420:	52 e0       	ldi	r21, 0x02	; 2
    7422:	0e 94 85 22 	call	0x450a	; 0x450a <CreateReport>
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    7426:	84 e0       	ldi	r24, 0x04	; 4
    7428:	6f ec       	ldi	r22, 0xCF	; 207
    742a:	75 e0       	ldi	r23, 0x05	; 5
    742c:	41 e0       	ldi	r20, 0x01	; 1
    742e:	22 e0       	ldi	r18, 0x02	; 2
    7430:	32 e0       	ldi	r19, 0x02	; 2
    7432:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    7436:	8b e0       	ldi	r24, 0x0B	; 11
    7438:	6f ec       	ldi	r22, 0xCF	; 207
    743a:	75 e0       	ldi	r23, 0x05	; 5
    743c:	4a e2       	ldi	r20, 0x2A	; 42
    743e:	22 e0       	ldi	r18, 0x02	; 2
    7440:	32 e0       	ldi	r19, 0x02	; 2
    7442:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    7446:	86 e0       	ldi	r24, 0x06	; 6
    7448:	6f ec       	ldi	r22, 0xCF	; 207
    744a:	75 e0       	ldi	r23, 0x05	; 5
    744c:	41 e0       	ldi	r20, 0x01	; 1
    744e:	22 e0       	ldi	r18, 0x02	; 2
    7450:	32 e0       	ldi	r19, 0x02	; 2
    7452:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    7456:	8c e0       	ldi	r24, 0x0C	; 12
    7458:	6f ec       	ldi	r22, 0xCF	; 207
    745a:	75 e0       	ldi	r23, 0x05	; 5
    745c:	41 e0       	ldi	r20, 0x01	; 1
    745e:	22 e0       	ldi	r18, 0x02	; 2
    7460:	32 e0       	ldi	r19, 0x02	; 2
    7462:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
    7466:	de 01       	movw	r26, r28
    7468:	d7 96       	adiw	r26, 0x37	; 55
    746a:	fd 01       	movw	r30, r26
    746c:	01 90       	ld	r0, Z+
    746e:	00 20       	and	r0, r0
    7470:	e9 f7       	brne	.-6      	; 0x746c <systemGenerateReport+0xa30>
    7472:	9a 2f       	mov	r25, r26
    7474:	9e 1b       	sub	r25, r30
    7476:	9e 5e       	subi	r25, 0xEE	; 238
    7478:	de 01       	movw	r26, r28
    747a:	a7 59       	subi	r26, 0x97	; 151
    747c:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    747e:	19 16       	cp	r1, r25
    7480:	7c f4       	brge	.+30     	; 0x74a0 <systemGenerateReport+0xa64>
    7482:	fd 01       	movw	r30, r26
    7484:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7486:	20 e2       	ldi	r18, 0x20	; 32
    7488:	02 c0       	rjmp	.+4      	; 0x748e <systemGenerateReport+0xa52>
    748a:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    748c:	8f 5f       	subi	r24, 0xFF	; 255
    748e:	89 17       	cp	r24, r25
    7490:	e0 f3       	brcs	.-8      	; 0x748a <systemGenerateReport+0xa4e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7492:	fe 01       	movw	r30, r28
    7494:	e7 59       	subi	r30, 0x97	; 151
    7496:	ff 4f       	sbci	r31, 0xFF	; 255
    7498:	e9 0f       	add	r30, r25
    749a:	f1 1d       	adc	r31, r1
    749c:	10 82       	st	Z, r1
    749e:	04 c0       	rjmp	.+8      	; 0x74a8 <systemGenerateReport+0xa6c>
     }else{
	 strTab[0]=' ';
    74a0:	80 e2       	ldi	r24, 0x20	; 32
    74a2:	8c 93       	st	X, r24
	 strTab[1]=0;
    74a4:	11 96       	adiw	r26, 0x01	; 1
    74a6:	1c 92       	st	X, r1
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
		  CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
    74a8:	de 01       	movw	r26, r28
    74aa:	aa 5b       	subi	r26, 0xBA	; 186
    74ac:	bf 4f       	sbci	r27, 0xFF	; 255
    74ae:	fd 01       	movw	r30, r26
    74b0:	01 90       	ld	r0, Z+
    74b2:	00 20       	and	r0, r0
    74b4:	e9 f7       	brne	.-6      	; 0x74b0 <systemGenerateReport+0xa74>
    74b6:	ae 1b       	sub	r26, r30
    74b8:	a0 5f       	subi	r26, 0xF0	; 240
    74ba:	fe 01       	movw	r30, r28
    74bc:	e3 58       	subi	r30, 0x83	; 131
    74be:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    74c0:	1a 16       	cp	r1, r26
    74c2:	74 f4       	brge	.+28     	; 0x74e0 <systemGenerateReport+0xaa4>
    74c4:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    74c6:	90 e2       	ldi	r25, 0x20	; 32
    74c8:	02 c0       	rjmp	.+4      	; 0x74ce <systemGenerateReport+0xa92>
    74ca:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    74cc:	8f 5f       	subi	r24, 0xFF	; 255
    74ce:	8a 17       	cp	r24, r26
    74d0:	e0 f3       	brcs	.-8      	; 0x74ca <systemGenerateReport+0xa8e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    74d2:	fe 01       	movw	r30, r28
    74d4:	e3 58       	subi	r30, 0x83	; 131
    74d6:	ff 4f       	sbci	r31, 0xFF	; 255
    74d8:	ea 0f       	add	r30, r26
    74da:	f1 1d       	adc	r31, r1
    74dc:	10 82       	st	Z, r1
    74de:	03 c0       	rjmp	.+6      	; 0x74e6 <systemGenerateReport+0xaaa>
     }else{
	 strTab[0]=' ';
    74e0:	80 e2       	ldi	r24, 0x20	; 32
    74e2:	80 83       	st	Z, r24
	 strTab[1]=0;
    74e4:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    74e6:	e1 99       	sbic	0x1c, 1	; 28
    74e8:	fe cf       	rjmp	.-4      	; 0x74e6 <systemGenerateReport+0xaaa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    74ea:	11 ec       	ldi	r17, 0xC1	; 193
    74ec:	e1 2e       	mov	r14, r17
    74ee:	13 e0       	ldi	r17, 0x03	; 3
    74f0:	f1 2e       	mov	r15, r17
    74f2:	ff ba       	out	0x1f, r15	; 31
    74f4:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    74f6:	e0 9a       	sbi	0x1c, 0	; 28
    74f8:	8d b3       	in	r24, 0x1d	; 29
    74fa:	9e 01       	movw	r18, r28
    74fc:	2b 55       	subi	r18, 0x5B	; 91
    74fe:	3f 4f       	sbci	r19, 0xFF	; 255
    7500:	ae 01       	movw	r20, r28
    7502:	49 5c       	subi	r20, 0xC9	; 201
    7504:	5f 4f       	sbci	r21, 0xFF	; 255
    7506:	de 01       	movw	r26, r28
    7508:	a7 59       	subi	r26, 0x97	; 151
    750a:	bf 4f       	sbci	r27, 0xFF	; 255
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    750c:	81 30       	cpi	r24, 0x01	; 1
    750e:	49 f5       	brne	.+82     	; 0x7562 <systemGenerateReport+0xb26>
    7510:	8d b7       	in	r24, 0x3d	; 61
    7512:	9e b7       	in	r25, 0x3e	; 62
    7514:	0c 97       	sbiw	r24, 0x0c	; 12
    7516:	0f b6       	in	r0, 0x3f	; 63
    7518:	f8 94       	cli
    751a:	9e bf       	out	0x3e, r25	; 62
    751c:	0f be       	out	0x3f, r0	; 63
    751e:	8d bf       	out	0x3d, r24	; 61
    7520:	6d b7       	in	r22, 0x3d	; 61
    7522:	7e b7       	in	r23, 0x3e	; 62
    7524:	6f 5f       	subi	r22, 0xFF	; 255
    7526:	7f 4f       	sbci	r23, 0xFF	; 255
    7528:	ed b7       	in	r30, 0x3d	; 61
    752a:	fe b7       	in	r31, 0x3e	; 62
    752c:	32 83       	std	Z+2, r19	; 0x02
    752e:	21 83       	std	Z+1, r18	; 0x01
    7530:	85 ea       	ldi	r24, 0xA5	; 165
    7532:	94 e0       	ldi	r25, 0x04	; 4
    7534:	fb 01       	movw	r30, r22
    7536:	93 83       	std	Z+3, r25	; 0x03
    7538:	82 83       	std	Z+2, r24	; 0x02
    753a:	b5 83       	std	Z+5, r27	; 0x05
    753c:	a4 83       	std	Z+4, r26	; 0x04
    753e:	57 83       	std	Z+7, r21	; 0x07
    7540:	46 83       	std	Z+6, r20	; 0x06
    7542:	ce 01       	movw	r24, r28
    7544:	83 58       	subi	r24, 0x83	; 131
    7546:	9f 4f       	sbci	r25, 0xFF	; 255
    7548:	91 87       	std	Z+9, r25	; 0x09
    754a:	80 87       	std	Z+8, r24	; 0x08
    754c:	ce 01       	movw	r24, r28
    754e:	8a 5b       	subi	r24, 0xBA	; 186
    7550:	9f 4f       	sbci	r25, 0xFF	; 255
    7552:	93 87       	std	Z+11, r25	; 0x0b
    7554:	82 87       	std	Z+10, r24	; 0x0a
    7556:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    755a:	8d b7       	in	r24, 0x3d	; 61
    755c:	9e b7       	in	r25, 0x3e	; 62
    755e:	0c 96       	adiw	r24, 0x0c	; 12
    7560:	1c c0       	rjmp	.+56     	; 0x759a <systemGenerateReport+0xb5e>
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
    7562:	ed b7       	in	r30, 0x3d	; 61
    7564:	fe b7       	in	r31, 0x3e	; 62
    7566:	38 97       	sbiw	r30, 0x08	; 8
    7568:	0f b6       	in	r0, 0x3f	; 63
    756a:	f8 94       	cli
    756c:	fe bf       	out	0x3e, r31	; 62
    756e:	0f be       	out	0x3f, r0	; 63
    7570:	ed bf       	out	0x3d, r30	; 61
    7572:	6d b7       	in	r22, 0x3d	; 61
    7574:	7e b7       	in	r23, 0x3e	; 62
    7576:	6f 5f       	subi	r22, 0xFF	; 255
    7578:	7f 4f       	sbci	r23, 0xFF	; 255
    757a:	32 83       	std	Z+2, r19	; 0x02
    757c:	21 83       	std	Z+1, r18	; 0x01
    757e:	8a e9       	ldi	r24, 0x9A	; 154
    7580:	94 e0       	ldi	r25, 0x04	; 4
    7582:	fb 01       	movw	r30, r22
    7584:	93 83       	std	Z+3, r25	; 0x03
    7586:	82 83       	std	Z+2, r24	; 0x02
    7588:	b5 83       	std	Z+5, r27	; 0x05
    758a:	a4 83       	std	Z+4, r26	; 0x04
    758c:	57 83       	std	Z+7, r21	; 0x07
    758e:	46 83       	std	Z+6, r20	; 0x06
    7590:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    7594:	8d b7       	in	r24, 0x3d	; 61
    7596:	9e b7       	in	r25, 0x3e	; 62
    7598:	08 96       	adiw	r24, 0x08	; 8
    759a:	0f b6       	in	r0, 0x3f	; 63
    759c:	f8 94       	cli
    759e:	9e bf       	out	0x3e, r25	; 62
    75a0:	0f be       	out	0x3f, r0	; 63
    75a2:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    75a4:	ce 01       	movw	r24, r28
    75a6:	8b 55       	subi	r24, 0x5B	; 91
    75a8:	9f 4f       	sbci	r25, 0xFF	; 255
    75aa:	6f ec       	ldi	r22, 0xCF	; 207
    75ac:	75 e0       	ldi	r23, 0x05	; 5
    75ae:	42 e0       	ldi	r20, 0x02	; 2
    75b0:	52 e0       	ldi	r21, 0x02	; 2
    75b2:	0e 94 85 22 	call	0x450a	; 0x450a <CreateReport>

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
    75b6:	de 01       	movw	r26, r28
    75b8:	59 96       	adiw	r26, 0x19	; 25
    75ba:	fd 01       	movw	r30, r26
    75bc:	01 90       	ld	r0, Z+
    75be:	00 20       	and	r0, r0
    75c0:	e9 f7       	brne	.-6      	; 0x75bc <systemGenerateReport+0xb80>
    75c2:	9a 2f       	mov	r25, r26
    75c4:	9e 1b       	sub	r25, r30
    75c6:	9e 5e       	subi	r25, 0xEE	; 238
    75c8:	de 01       	movw	r26, r28
    75ca:	a7 59       	subi	r26, 0x97	; 151
    75cc:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    75ce:	19 16       	cp	r1, r25
    75d0:	7c f4       	brge	.+30     	; 0x75f0 <systemGenerateReport+0xbb4>
    75d2:	fd 01       	movw	r30, r26
    75d4:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    75d6:	20 e2       	ldi	r18, 0x20	; 32
    75d8:	02 c0       	rjmp	.+4      	; 0x75de <systemGenerateReport+0xba2>
    75da:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    75dc:	8f 5f       	subi	r24, 0xFF	; 255
    75de:	89 17       	cp	r24, r25
    75e0:	e0 f3       	brcs	.-8      	; 0x75da <systemGenerateReport+0xb9e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    75e2:	fe 01       	movw	r30, r28
    75e4:	e7 59       	subi	r30, 0x97	; 151
    75e6:	ff 4f       	sbci	r31, 0xFF	; 255
    75e8:	e9 0f       	add	r30, r25
    75ea:	f1 1d       	adc	r31, r1
    75ec:	10 82       	st	Z, r1
    75ee:	04 c0       	rjmp	.+8      	; 0x75f8 <systemGenerateReport+0xbbc>
     }else{
	 strTab[0]=' ';
    75f0:	80 e2       	ldi	r24, 0x20	; 32
    75f2:	8c 93       	st	X, r24
	 strTab[1]=0;
    75f4:	11 96       	adiw	r26, 0x01	; 1
    75f6:	1c 92       	st	X, r1
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
    75f8:	de 01       	movw	r26, r28
    75fa:	98 96       	adiw	r26, 0x28	; 40
    75fc:	fd 01       	movw	r30, r26
    75fe:	01 90       	ld	r0, Z+
    7600:	00 20       	and	r0, r0
    7602:	e9 f7       	brne	.-6      	; 0x75fe <systemGenerateReport+0xbc2>
    7604:	ae 1b       	sub	r26, r30
    7606:	a0 5f       	subi	r26, 0xF0	; 240
    7608:	fe 01       	movw	r30, r28
    760a:	e3 58       	subi	r30, 0x83	; 131
    760c:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    760e:	1a 16       	cp	r1, r26
    7610:	74 f4       	brge	.+28     	; 0x762e <systemGenerateReport+0xbf2>
    7612:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7614:	90 e2       	ldi	r25, 0x20	; 32
    7616:	02 c0       	rjmp	.+4      	; 0x761c <systemGenerateReport+0xbe0>
    7618:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    761a:	8f 5f       	subi	r24, 0xFF	; 255
    761c:	8a 17       	cp	r24, r26
    761e:	e0 f3       	brcs	.-8      	; 0x7618 <systemGenerateReport+0xbdc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7620:	fe 01       	movw	r30, r28
    7622:	e3 58       	subi	r30, 0x83	; 131
    7624:	ff 4f       	sbci	r31, 0xFF	; 255
    7626:	ea 0f       	add	r30, r26
    7628:	f1 1d       	adc	r31, r1
    762a:	10 82       	st	Z, r1
    762c:	03 c0       	rjmp	.+6      	; 0x7634 <systemGenerateReport+0xbf8>
     }else{
	 strTab[0]=' ';
    762e:	80 e2       	ldi	r24, 0x20	; 32
    7630:	80 83       	st	Z, r24
	 strTab[1]=0;
    7632:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7634:	e1 99       	sbic	0x1c, 1	; 28
    7636:	fe cf       	rjmp	.-4      	; 0x7634 <systemGenerateReport+0xbf8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7638:	ff ba       	out	0x1f, r15	; 31
    763a:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    763c:	e0 9a       	sbi	0x1c, 0	; 28
    763e:	8d b3       	in	r24, 0x1d	; 29
    7640:	9e 01       	movw	r18, r28
    7642:	2b 55       	subi	r18, 0x5B	; 91
    7644:	3f 4f       	sbci	r19, 0xFF	; 255
    7646:	ae 01       	movw	r20, r28
    7648:	47 5e       	subi	r20, 0xE7	; 231
    764a:	5f 4f       	sbci	r21, 0xFF	; 255
    764c:	de 01       	movw	r26, r28
    764e:	a7 59       	subi	r26, 0x97	; 151
    7650:	bf 4f       	sbci	r27, 0xFF	; 255
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("Awal :%s%s%s%s"),strTabSpace,strLastVolume,strTabSpace2,strLastMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7652:	81 30       	cpi	r24, 0x01	; 1
    7654:	31 f5       	brne	.+76     	; 0x76a2 <systemGenerateReport+0xc66>
    7656:	ed b7       	in	r30, 0x3d	; 61
    7658:	fe b7       	in	r31, 0x3e	; 62
    765a:	3c 97       	sbiw	r30, 0x0c	; 12
    765c:	0f b6       	in	r0, 0x3f	; 63
    765e:	f8 94       	cli
    7660:	fe bf       	out	0x3e, r31	; 62
    7662:	0f be       	out	0x3f, r0	; 63
    7664:	ed bf       	out	0x3d, r30	; 61
    7666:	6d b7       	in	r22, 0x3d	; 61
    7668:	7e b7       	in	r23, 0x3e	; 62
    766a:	6f 5f       	subi	r22, 0xFF	; 255
    766c:	7f 4f       	sbci	r23, 0xFF	; 255
    766e:	32 83       	std	Z+2, r19	; 0x02
    7670:	21 83       	std	Z+1, r18	; 0x01
    7672:	8b e8       	ldi	r24, 0x8B	; 139
    7674:	94 e0       	ldi	r25, 0x04	; 4
    7676:	fb 01       	movw	r30, r22
    7678:	93 83       	std	Z+3, r25	; 0x03
    767a:	82 83       	std	Z+2, r24	; 0x02
    767c:	b5 83       	std	Z+5, r27	; 0x05
    767e:	a4 83       	std	Z+4, r26	; 0x04
    7680:	57 83       	std	Z+7, r21	; 0x07
    7682:	46 83       	std	Z+6, r20	; 0x06
    7684:	ce 01       	movw	r24, r28
    7686:	83 58       	subi	r24, 0x83	; 131
    7688:	9f 4f       	sbci	r25, 0xFF	; 255
    768a:	91 87       	std	Z+9, r25	; 0x09
    768c:	80 87       	std	Z+8, r24	; 0x08
    768e:	ce 01       	movw	r24, r28
    7690:	88 96       	adiw	r24, 0x28	; 40
    7692:	93 87       	std	Z+11, r25	; 0x0b
    7694:	82 87       	std	Z+10, r24	; 0x0a
    7696:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    769a:	8d b7       	in	r24, 0x3d	; 61
    769c:	9e b7       	in	r25, 0x3e	; 62
    769e:	0c 96       	adiw	r24, 0x0c	; 12
    76a0:	1c c0       	rjmp	.+56     	; 0x76da <systemGenerateReport+0xc9e>
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
    76a2:	ed b7       	in	r30, 0x3d	; 61
    76a4:	fe b7       	in	r31, 0x3e	; 62
    76a6:	38 97       	sbiw	r30, 0x08	; 8
    76a8:	0f b6       	in	r0, 0x3f	; 63
    76aa:	f8 94       	cli
    76ac:	fe bf       	out	0x3e, r31	; 62
    76ae:	0f be       	out	0x3f, r0	; 63
    76b0:	ed bf       	out	0x3d, r30	; 61
    76b2:	6d b7       	in	r22, 0x3d	; 61
    76b4:	7e b7       	in	r23, 0x3e	; 62
    76b6:	6f 5f       	subi	r22, 0xFF	; 255
    76b8:	7f 4f       	sbci	r23, 0xFF	; 255
    76ba:	32 83       	std	Z+2, r19	; 0x02
    76bc:	21 83       	std	Z+1, r18	; 0x01
    76be:	80 e8       	ldi	r24, 0x80	; 128
    76c0:	94 e0       	ldi	r25, 0x04	; 4
    76c2:	fb 01       	movw	r30, r22
    76c4:	93 83       	std	Z+3, r25	; 0x03
    76c6:	82 83       	std	Z+2, r24	; 0x02
    76c8:	b5 83       	std	Z+5, r27	; 0x05
    76ca:	a4 83       	std	Z+4, r26	; 0x04
    76cc:	57 83       	std	Z+7, r21	; 0x07
    76ce:	46 83       	std	Z+6, r20	; 0x06
    76d0:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    76d4:	8d b7       	in	r24, 0x3d	; 61
    76d6:	9e b7       	in	r25, 0x3e	; 62
    76d8:	08 96       	adiw	r24, 0x08	; 8
    76da:	0f b6       	in	r0, 0x3f	; 63
    76dc:	f8 94       	cli
    76de:	9e bf       	out	0x3e, r25	; 62
    76e0:	0f be       	out	0x3f, r0	; 63
    76e2:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    76e4:	ce 01       	movw	r24, r28
    76e6:	8b 55       	subi	r24, 0x5B	; 91
    76e8:	9f 4f       	sbci	r25, 0xFF	; 255
    76ea:	6f ec       	ldi	r22, 0xCF	; 207
    76ec:	75 e0       	ldi	r23, 0x05	; 5
    76ee:	42 e0       	ldi	r20, 0x02	; 2
    76f0:	52 e0       	ldi	r21, 0x02	; 2
    76f2:	0e 94 85 22 	call	0x450a	; 0x450a <CreateReport>
    76f6:	8e 01       	movw	r16, r28
    76f8:	07 59       	subi	r16, 0x97	; 151
    76fa:	1f 4f       	sbci	r17, 0xFF	; 255
    76fc:	f8 01       	movw	r30, r16
void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    76fe:	20 e2       	ldi	r18, 0x20	; 32

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7700:	d8 01       	movw	r26, r16
    7702:	c8 01       	movw	r24, r16
    7704:	0c 96       	adiw	r24, 0x0c	; 12
		     strTab[i]=' ';
    7706:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7708:	e8 17       	cp	r30, r24
    770a:	f9 07       	cpc	r31, r25
    770c:	e1 f7       	brne	.-8      	; 0x7706 <systemGenerateReport+0xcca>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    770e:	1c 96       	adiw	r26, 0x0c	; 12
    7710:	1c 92       	st	X, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7712:	e1 99       	sbic	0x1c, 1	; 28
    7714:	fe cf       	rjmp	.-4      	; 0x7712 <systemGenerateReport+0xcd6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7716:	ff ba       	out	0x1f, r15	; 31
    7718:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    771a:	e0 9a       	sbi	0x1c, 0	; 28
    771c:	8d b3       	in	r24, 0x1d	; 29
    771e:	9e 01       	movw	r18, r28
    7720:	2b 55       	subi	r18, 0x5B	; 91
    7722:	3f 4f       	sbci	r19, 0xFF	; 255
    7724:	de 01       	movw	r26, r28
    7726:	a7 59       	subi	r26, 0x97	; 151
    7728:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace(12,strTabSpace);
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
    772a:	81 30       	cpi	r24, 0x01	; 1
    772c:	71 f4       	brne	.+28     	; 0x774a <systemGenerateReport+0xd0e>
    772e:	00 d0       	rcall	.+0      	; 0x7730 <systemGenerateReport+0xcf4>
    7730:	00 d0       	rcall	.+0      	; 0x7732 <systemGenerateReport+0xcf6>
    7732:	00 d0       	rcall	.+0      	; 0x7734 <systemGenerateReport+0xcf8>
    7734:	4d b7       	in	r20, 0x3d	; 61
    7736:	5e b7       	in	r21, 0x3e	; 62
    7738:	4f 5f       	subi	r20, 0xFF	; 255
    773a:	5f 4f       	sbci	r21, 0xFF	; 255
    773c:	ed b7       	in	r30, 0x3d	; 61
    773e:	fe b7       	in	r31, 0x3e	; 62
    7740:	32 83       	std	Z+2, r19	; 0x02
    7742:	21 83       	std	Z+1, r18	; 0x01
    7744:	82 e6       	ldi	r24, 0x62	; 98
    7746:	94 e0       	ldi	r25, 0x04	; 4
    7748:	0d c0       	rjmp	.+26     	; 0x7764 <systemGenerateReport+0xd28>
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);
    774a:	00 d0       	rcall	.+0      	; 0x774c <systemGenerateReport+0xd10>
    774c:	00 d0       	rcall	.+0      	; 0x774e <systemGenerateReport+0xd12>
    774e:	00 d0       	rcall	.+0      	; 0x7750 <systemGenerateReport+0xd14>
    7750:	4d b7       	in	r20, 0x3d	; 61
    7752:	5e b7       	in	r21, 0x3e	; 62
    7754:	4f 5f       	subi	r20, 0xFF	; 255
    7756:	5f 4f       	sbci	r21, 0xFF	; 255
    7758:	ed b7       	in	r30, 0x3d	; 61
    775a:	fe b7       	in	r31, 0x3e	; 62
    775c:	32 83       	std	Z+2, r19	; 0x02
    775e:	21 83       	std	Z+1, r18	; 0x01
    7760:	84 e4       	ldi	r24, 0x44	; 68
    7762:	94 e0       	ldi	r25, 0x04	; 4
    7764:	fa 01       	movw	r30, r20
    7766:	93 83       	std	Z+3, r25	; 0x03
    7768:	82 83       	std	Z+2, r24	; 0x02
    776a:	b5 83       	std	Z+5, r27	; 0x05
    776c:	a4 83       	std	Z+4, r26	; 0x04
    776e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    7772:	8d b7       	in	r24, 0x3d	; 61
    7774:	9e b7       	in	r25, 0x3e	; 62
    7776:	06 96       	adiw	r24, 0x06	; 6
    7778:	0f b6       	in	r0, 0x3f	; 63
    777a:	f8 94       	cli
    777c:	9e bf       	out	0x3e, r25	; 62
    777e:	0f be       	out	0x3f, r0	; 63
    7780:	8d bf       	out	0x3d, r24	; 61
    7782:	ce 01       	movw	r24, r28
    7784:	8b 55       	subi	r24, 0x5B	; 91
    7786:	9f 4f       	sbci	r25, 0xFF	; 255
    7788:	6f ec       	ldi	r22, 0xCF	; 207
    778a:	75 e0       	ldi	r23, 0x05	; 5
    778c:	42 e0       	ldi	r20, 0x02	; 2
    778e:	52 e0       	ldi	r21, 0x02	; 2
    7790:	0e 94 85 22 	call	0x450a	; 0x450a <CreateReport>

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
    7794:	eb e6       	ldi	r30, 0x6B	; 107
    7796:	fc e0       	ldi	r31, 0x0C	; 12
    7798:	01 90       	ld	r0, Z+
    779a:	00 20       	and	r0, r0
    779c:	e9 f7       	brne	.-6      	; 0x7798 <systemGenerateReport+0xd5c>
    779e:	31 97       	sbiw	r30, 0x01	; 1
    77a0:	eb 56       	subi	r30, 0x6B	; 107
    77a2:	fc 40       	sbci	r31, 0x0C	; 12
    77a4:	97 e1       	ldi	r25, 0x17	; 23
    77a6:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    77a8:	19 16       	cp	r1, r25
    77aa:	84 f4       	brge	.+32     	; 0x77cc <systemGenerateReport+0xd90>
    77ac:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    77ae:	20 e2       	ldi	r18, 0x20	; 32
    77b0:	04 c0       	rjmp	.+8      	; 0x77ba <systemGenerateReport+0xd7e>
    77b2:	d8 01       	movw	r26, r16
    77b4:	2d 93       	st	X+, r18
    77b6:	8d 01       	movw	r16, r26

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    77b8:	8f 5f       	subi	r24, 0xFF	; 255
    77ba:	89 17       	cp	r24, r25
    77bc:	d0 f3       	brcs	.-12     	; 0x77b2 <systemGenerateReport+0xd76>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    77be:	fe 01       	movw	r30, r28
    77c0:	e7 59       	subi	r30, 0x97	; 151
    77c2:	ff 4f       	sbci	r31, 0xFF	; 255
    77c4:	e9 0f       	add	r30, r25
    77c6:	f1 1d       	adc	r31, r1
    77c8:	10 82       	st	Z, r1
    77ca:	06 c0       	rjmp	.+12     	; 0x77d8 <systemGenerateReport+0xd9c>
     }else{
	 strTab[0]=' ';
    77cc:	fe 01       	movw	r30, r28
    77ce:	e7 59       	subi	r30, 0x97	; 151
    77d0:	ff 4f       	sbci	r31, 0xFF	; 255
    77d2:	80 e2       	ldi	r24, 0x20	; 32
    77d4:	80 83       	st	Z, r24
	 strTab[1]=0;
    77d6:	11 82       	std	Z+1, r1	; 0x01
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
    77d8:	e0 e8       	ldi	r30, 0x80	; 128
    77da:	ff e0       	ldi	r31, 0x0F	; 15
    77dc:	01 90       	ld	r0, Z+
    77de:	00 20       	and	r0, r0
    77e0:	e9 f7       	brne	.-6      	; 0x77dc <systemGenerateReport+0xda0>
    77e2:	31 97       	sbiw	r30, 0x01	; 1
    77e4:	e0 58       	subi	r30, 0x80	; 128
    77e6:	ff 40       	sbci	r31, 0x0F	; 15
    77e8:	9f e0       	ldi	r25, 0x0F	; 15
    77ea:	9e 1b       	sub	r25, r30
    77ec:	fe 01       	movw	r30, r28
    77ee:	e3 58       	subi	r30, 0x83	; 131
    77f0:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    77f2:	19 16       	cp	r1, r25
    77f4:	74 f4       	brge	.+28     	; 0x7812 <systemGenerateReport+0xdd6>
    77f6:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    77f8:	20 e2       	ldi	r18, 0x20	; 32
    77fa:	02 c0       	rjmp	.+4      	; 0x7800 <systemGenerateReport+0xdc4>
    77fc:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    77fe:	8f 5f       	subi	r24, 0xFF	; 255
    7800:	89 17       	cp	r24, r25
    7802:	e0 f3       	brcs	.-8      	; 0x77fc <systemGenerateReport+0xdc0>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7804:	fe 01       	movw	r30, r28
    7806:	e3 58       	subi	r30, 0x83	; 131
    7808:	ff 4f       	sbci	r31, 0xFF	; 255
    780a:	e9 0f       	add	r30, r25
    780c:	f1 1d       	adc	r31, r1
    780e:	10 82       	st	Z, r1
    7810:	03 c0       	rjmp	.+6      	; 0x7818 <systemGenerateReport+0xddc>
     }else{
	 strTab[0]=' ';
    7812:	80 e2       	ldi	r24, 0x20	; 32
    7814:	80 83       	st	Z, r24
	 strTab[1]=0;
    7816:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7818:	e1 99       	sbic	0x1c, 1	; 28
    781a:	fe cf       	rjmp	.-4      	; 0x7818 <systemGenerateReport+0xddc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    781c:	ff ba       	out	0x1f, r15	; 31
    781e:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7820:	e0 9a       	sbi	0x1c, 0	; 28
    7822:	8d b3       	in	r24, 0x1d	; 29
    7824:	9e 01       	movw	r18, r28
    7826:	2b 55       	subi	r18, 0x5B	; 91
    7828:	3f 4f       	sbci	r19, 0xFF	; 255
    782a:	4b e6       	ldi	r20, 0x6B	; 107
    782c:	5c e0       	ldi	r21, 0x0C	; 12
    782e:	de 01       	movw	r26, r28
    7830:	a7 59       	subi	r26, 0x97	; 151
    7832:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s%s%s%s"),strTabSpace,strDeltaVolume,strTabSpace2,strDeltaMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7834:	81 30       	cpi	r24, 0x01	; 1
    7836:	31 f5       	brne	.+76     	; 0x7884 <systemGenerateReport+0xe48>
    7838:	ed b7       	in	r30, 0x3d	; 61
    783a:	fe b7       	in	r31, 0x3e	; 62
    783c:	3c 97       	sbiw	r30, 0x0c	; 12
    783e:	0f b6       	in	r0, 0x3f	; 63
    7840:	f8 94       	cli
    7842:	fe bf       	out	0x3e, r31	; 62
    7844:	0f be       	out	0x3f, r0	; 63
    7846:	ed bf       	out	0x3d, r30	; 61
    7848:	6d b7       	in	r22, 0x3d	; 61
    784a:	7e b7       	in	r23, 0x3e	; 62
    784c:	6f 5f       	subi	r22, 0xFF	; 255
    784e:	7f 4f       	sbci	r23, 0xFF	; 255
    7850:	32 83       	std	Z+2, r19	; 0x02
    7852:	21 83       	std	Z+1, r18	; 0x01
    7854:	8b e3       	ldi	r24, 0x3B	; 59
    7856:	94 e0       	ldi	r25, 0x04	; 4
    7858:	fb 01       	movw	r30, r22
    785a:	93 83       	std	Z+3, r25	; 0x03
    785c:	82 83       	std	Z+2, r24	; 0x02
    785e:	b5 83       	std	Z+5, r27	; 0x05
    7860:	a4 83       	std	Z+4, r26	; 0x04
    7862:	57 83       	std	Z+7, r21	; 0x07
    7864:	46 83       	std	Z+6, r20	; 0x06
    7866:	ce 01       	movw	r24, r28
    7868:	83 58       	subi	r24, 0x83	; 131
    786a:	9f 4f       	sbci	r25, 0xFF	; 255
    786c:	91 87       	std	Z+9, r25	; 0x09
    786e:	80 87       	std	Z+8, r24	; 0x08
    7870:	80 e8       	ldi	r24, 0x80	; 128
    7872:	9f e0       	ldi	r25, 0x0F	; 15
    7874:	93 87       	std	Z+11, r25	; 0x0b
    7876:	82 87       	std	Z+10, r24	; 0x0a
    7878:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    787c:	8d b7       	in	r24, 0x3d	; 61
    787e:	9e b7       	in	r25, 0x3e	; 62
    7880:	0c 96       	adiw	r24, 0x0c	; 12
    7882:	1c c0       	rjmp	.+56     	; 0x78bc <systemGenerateReport+0xe80>
          else sprintf_P(strReport,PSTR("%s%s"),strTabSpace,strDeltaVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    7884:	ed b7       	in	r30, 0x3d	; 61
    7886:	fe b7       	in	r31, 0x3e	; 62
    7888:	38 97       	sbiw	r30, 0x08	; 8
    788a:	0f b6       	in	r0, 0x3f	; 63
    788c:	f8 94       	cli
    788e:	fe bf       	out	0x3e, r31	; 62
    7890:	0f be       	out	0x3f, r0	; 63
    7892:	ed bf       	out	0x3d, r30	; 61
    7894:	6d b7       	in	r22, 0x3d	; 61
    7896:	7e b7       	in	r23, 0x3e	; 62
    7898:	6f 5f       	subi	r22, 0xFF	; 255
    789a:	7f 4f       	sbci	r23, 0xFF	; 255
    789c:	32 83       	std	Z+2, r19	; 0x02
    789e:	21 83       	std	Z+1, r18	; 0x01
    78a0:	86 e3       	ldi	r24, 0x36	; 54
    78a2:	94 e0       	ldi	r25, 0x04	; 4
    78a4:	fb 01       	movw	r30, r22
    78a6:	93 83       	std	Z+3, r25	; 0x03
    78a8:	82 83       	std	Z+2, r24	; 0x02
    78aa:	b5 83       	std	Z+5, r27	; 0x05
    78ac:	a4 83       	std	Z+4, r26	; 0x04
    78ae:	57 83       	std	Z+7, r21	; 0x07
    78b0:	46 83       	std	Z+6, r20	; 0x06
    78b2:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    78b6:	8d b7       	in	r24, 0x3d	; 61
    78b8:	9e b7       	in	r25, 0x3e	; 62
    78ba:	08 96       	adiw	r24, 0x08	; 8
    78bc:	0f b6       	in	r0, 0x3f	; 63
    78be:	f8 94       	cli
    78c0:	9e bf       	out	0x3e, r25	; 62
    78c2:	0f be       	out	0x3f, r0	; 63
    78c4:	8d bf       	out	0x3d, r24	; 61
    78c6:	ce 01       	movw	r24, r28
    78c8:	8b 55       	subi	r24, 0x5B	; 91
    78ca:	9f 4f       	sbci	r25, 0xFF	; 255
    78cc:	6f ec       	ldi	r22, 0xCF	; 207
    78ce:	75 e0       	ldi	r23, 0x05	; 5
    78d0:	42 e0       	ldi	r20, 0x02	; 2
    78d2:	52 e0       	ldi	r21, 0x02	; 2
    78d4:	0e 94 85 22 	call	0x450a	; 0x450a <CreateReport>

          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    78d8:	87 e0       	ldi	r24, 0x07	; 7
    78da:	6f ec       	ldi	r22, 0xCF	; 207
    78dc:	75 e0       	ldi	r23, 0x05	; 5
    78de:	41 e0       	ldi	r20, 0x01	; 1
    78e0:	22 e0       	ldi	r18, 0x02	; 2
    78e2:	32 e0       	ldi	r19, 0x02	; 2
    78e4:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    78e8:	8b e0       	ldi	r24, 0x0B	; 11
    78ea:	6f ec       	ldi	r22, 0xCF	; 207
    78ec:	75 e0       	ldi	r23, 0x05	; 5
    78ee:	4a e2       	ldi	r20, 0x2A	; 42
    78f0:	22 e0       	ldi	r18, 0x02	; 2
    78f2:	32 e0       	ldi	r19, 0x02	; 2
    78f4:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    78f8:	89 e0       	ldi	r24, 0x09	; 9
    78fa:	6f ec       	ldi	r22, 0xCF	; 207
    78fc:	75 e0       	ldi	r23, 0x05	; 5
    78fe:	41 e0       	ldi	r20, 0x01	; 1
    7900:	22 e0       	ldi	r18, 0x02	; 2
    7902:	32 e0       	ldi	r19, 0x02	; 2
    7904:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    7908:	8c e0       	ldi	r24, 0x0C	; 12
    790a:	6f ec       	ldi	r22, 0xCF	; 207
    790c:	75 e0       	ldi	r23, 0x05	; 5
    790e:	41 e0       	ldi	r20, 0x01	; 1
    7910:	22 e0       	ldi	r18, 0x02	; 2
    7912:	32 e0       	ldi	r19, 0x02	; 2
    7914:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>


          cmdPrint=0b00000000;
    7918:	10 92 cb 01 	sts	0x01CB, r1
		  LengthMessage81=RepPos+1;
    791c:	80 91 02 02 	lds	r24, 0x0202
    7920:	90 91 03 02 	lds	r25, 0x0203
    7924:	01 96       	adiw	r24, 0x01	; 1
    7926:	90 93 a1 01 	sts	0x01A1, r25
    792a:	80 93 a0 01 	sts	0x01A0, r24

		  IsFreePrinting=True;
    792e:	81 e0       	ldi	r24, 0x01	; 1
    7930:	80 93 bf 01 	sts	0x01BF, r24
	      IsBusyFreePrinting=True;
    7934:	80 93 ca 01 	sts	0x01CA, r24

	      stGenerateReport=grWaitPrinted2;
    7938:	89 e0       	ldi	r24, 0x09	; 9
    793a:	91 c3       	rjmp	.+1826   	; 0x805e <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted2:
	 
          if (IsBusyFreePrinting==False)stGenerateReport=grGenerateReportData;
    793c:	80 91 ca 01 	lds	r24, 0x01CA
    7940:	88 23       	and	r24, r24
    7942:	09 f0       	breq	.+2      	; 0x7946 <systemGenerateReport+0xf0a>
    7944:	94 c3       	rjmp	.+1832   	; 0x806e <systemGenerateReport+0x1632>
    7946:	86 e0       	ldi	r24, 0x06	; 6
    7948:	8a c3       	rjmp	.+1812   	; 0x805e <systemGenerateReport+0x1622>
	      break;
     case grCreateReportFooter:
          RepPos=0;
    794a:	10 92 03 02 	sts	0x0203, r1
    794e:	10 92 02 02 	sts	0x0202, r1
    7952:	ef ec       	ldi	r30, 0xCF	; 207
    7954:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    7956:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7958:	97 e0       	ldi	r25, 0x07	; 7
    795a:	e0 36       	cpi	r30, 0x60	; 96
    795c:	f9 07       	cpc	r31, r25
    795e:	d9 f7       	brne	.-10     	; 0x7956 <systemGenerateReport+0xf1a>
    7960:	fe 01       	movw	r30, r28
    7962:	eb 55       	subi	r30, 0x5B	; 91
    7964:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    7966:	ce 01       	movw	r24, r28
    7968:	8b 50       	subi	r24, 0x0B	; 11
    796a:	9f 4f       	sbci	r25, 0xFF	; 255
    796c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    796e:	e8 17       	cp	r30, r24
    7970:	f9 07       	cpc	r31, r25
    7972:	e1 f7       	brne	.-8      	; 0x796c <systemGenerateReport+0xf30>
     case grCreateReportFooter:
          RepPos=0;
		  FillChar(PrintBuffer,sizeof(PrintBuffer),0);
		  FillChar(strReport,sizeof(strReport),0);

		  RemZeroLead(strTotalMoney);
    7974:	8b e3       	ldi	r24, 0x3B	; 59
    7976:	9c e0       	ldi	r25, 0x0C	; 12
    7978:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
		  RemZeroLead(strTotalVolume);
    797c:	06 eb       	ldi	r16, 0xB6	; 182
    797e:	1b e0       	ldi	r17, 0x0B	; 11
    7980:	c8 01       	movw	r24, r16
    7982:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>

		  FormatTotalizerMoney(strTotalMoney);
    7986:	8b e3       	ldi	r24, 0x3B	; 59
    7988:	9c e0       	ldi	r25, 0x0C	; 12
    798a:	0e 94 ea 34 	call	0x69d4	; 0x69d4 <FormatTotalizerMoney>
		  FormatCurrency(strTotalMoney);
    798e:	8b e3       	ldi	r24, 0x3B	; 59
    7990:	9c e0       	ldi	r25, 0x0C	; 12
    7992:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>
		  FormatTotalizerVolume(strTotalVolume);
    7996:	c8 01       	movw	r24, r16
    7998:	0e 94 dd 34 	call	0x69ba	; 0x69ba <FormatTotalizerVolume>
		  FormatCurrency(strTotalVolume);
    799c:	c8 01       	movw	r24, r16
    799e:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>

          //Test
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    79a2:	81 e0       	ldi	r24, 0x01	; 1
    79a4:	6f ec       	ldi	r22, 0xCF	; 207
    79a6:	75 e0       	ldi	r23, 0x05	; 5
    79a8:	41 e0       	ldi	r20, 0x01	; 1
    79aa:	22 e0       	ldi	r18, 0x02	; 2
    79ac:	32 e0       	ldi	r19, 0x02	; 2
    79ae:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    79b2:	8b e0       	ldi	r24, 0x0B	; 11
    79b4:	6f ec       	ldi	r22, 0xCF	; 207
    79b6:	75 e0       	ldi	r23, 0x05	; 5
    79b8:	4a e2       	ldi	r20, 0x2A	; 42
    79ba:	22 e0       	ldi	r18, 0x02	; 2
    79bc:	32 e0       	ldi	r19, 0x02	; 2
    79be:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    79c2:	83 e0       	ldi	r24, 0x03	; 3
    79c4:	6f ec       	ldi	r22, 0xCF	; 207
    79c6:	75 e0       	ldi	r23, 0x05	; 5
    79c8:	41 e0       	ldi	r20, 0x01	; 1
    79ca:	22 e0       	ldi	r18, 0x02	; 2
    79cc:	32 e0       	ldi	r19, 0x02	; 2
    79ce:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    79d2:	8c e0       	ldi	r24, 0x0C	; 12
    79d4:	6f ec       	ldi	r22, 0xCF	; 207
    79d6:	75 e0       	ldi	r23, 0x05	; 5
    79d8:	41 e0       	ldi	r20, 0x01	; 1
    79da:	22 e0       	ldi	r18, 0x02	; 2
    79dc:	32 e0       	ldi	r19, 0x02	; 2
    79de:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
    79e2:	d8 01       	movw	r26, r16
    79e4:	0d 90       	ld	r0, X+
    79e6:	00 20       	and	r0, r0
    79e8:	e9 f7       	brne	.-6      	; 0x79e4 <systemGenerateReport+0xfa8>
    79ea:	8d 01       	movw	r16, r26
    79ec:	01 50       	subi	r16, 0x01	; 1
    79ee:	10 40       	sbci	r17, 0x00	; 0
    79f0:	06 5b       	subi	r16, 0xB6	; 182
    79f2:	1b 40       	sbci	r17, 0x0B	; 11
    79f4:	91 e1       	ldi	r25, 0x11	; 17
    79f6:	90 1b       	sub	r25, r16
    79f8:	de 01       	movw	r26, r28
    79fa:	a7 59       	subi	r26, 0x97	; 151
    79fc:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    79fe:	19 16       	cp	r1, r25
    7a00:	7c f4       	brge	.+30     	; 0x7a20 <systemGenerateReport+0xfe4>
    7a02:	fd 01       	movw	r30, r26
    7a04:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7a06:	20 e2       	ldi	r18, 0x20	; 32
    7a08:	02 c0       	rjmp	.+4      	; 0x7a0e <systemGenerateReport+0xfd2>
    7a0a:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7a0c:	8f 5f       	subi	r24, 0xFF	; 255
    7a0e:	89 17       	cp	r24, r25
    7a10:	e0 f3       	brcs	.-8      	; 0x7a0a <systemGenerateReport+0xfce>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7a12:	fe 01       	movw	r30, r28
    7a14:	e7 59       	subi	r30, 0x97	; 151
    7a16:	ff 4f       	sbci	r31, 0xFF	; 255
    7a18:	e9 0f       	add	r30, r25
    7a1a:	f1 1d       	adc	r31, r1
    7a1c:	10 82       	st	Z, r1
    7a1e:	04 c0       	rjmp	.+8      	; 0x7a28 <systemGenerateReport+0xfec>
     }else{
	 strTab[0]=' ';
    7a20:	80 e2       	ldi	r24, 0x20	; 32
    7a22:	8c 93       	st	X, r24
	 strTab[1]=0;
    7a24:	11 96       	adiw	r26, 0x01	; 1
    7a26:	1c 92       	st	X, r1
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    7a28:	eb e3       	ldi	r30, 0x3B	; 59
    7a2a:	fc e0       	ldi	r31, 0x0C	; 12
    7a2c:	01 90       	ld	r0, Z+
    7a2e:	00 20       	and	r0, r0
    7a30:	e9 f7       	brne	.-6      	; 0x7a2c <systemGenerateReport+0xff0>
    7a32:	31 97       	sbiw	r30, 0x01	; 1
    7a34:	eb 53       	subi	r30, 0x3B	; 59
    7a36:	fc 40       	sbci	r31, 0x0C	; 12
    7a38:	9f e0       	ldi	r25, 0x0F	; 15
    7a3a:	9e 1b       	sub	r25, r30
    7a3c:	fe 01       	movw	r30, r28
    7a3e:	e3 58       	subi	r30, 0x83	; 131
    7a40:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7a42:	19 16       	cp	r1, r25
    7a44:	74 f4       	brge	.+28     	; 0x7a62 <systemGenerateReport+0x1026>
    7a46:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7a48:	20 e2       	ldi	r18, 0x20	; 32
    7a4a:	02 c0       	rjmp	.+4      	; 0x7a50 <systemGenerateReport+0x1014>
    7a4c:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7a4e:	8f 5f       	subi	r24, 0xFF	; 255
    7a50:	89 17       	cp	r24, r25
    7a52:	e0 f3       	brcs	.-8      	; 0x7a4c <systemGenerateReport+0x1010>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7a54:	fe 01       	movw	r30, r28
    7a56:	e3 58       	subi	r30, 0x83	; 131
    7a58:	ff 4f       	sbci	r31, 0xFF	; 255
    7a5a:	e9 0f       	add	r30, r25
    7a5c:	f1 1d       	adc	r31, r1
    7a5e:	10 82       	st	Z, r1
    7a60:	03 c0       	rjmp	.+6      	; 0x7a68 <systemGenerateReport+0x102c>
     }else{
	 strTab[0]=' ';
    7a62:	80 e2       	ldi	r24, 0x20	; 32
    7a64:	80 83       	st	Z, r24
	 strTab[1]=0;
    7a66:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7a68:	e1 99       	sbic	0x1c, 1	; 28
    7a6a:	fe cf       	rjmp	.-4      	; 0x7a68 <systemGenerateReport+0x102c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7a6c:	e1 ec       	ldi	r30, 0xC1	; 193
    7a6e:	f3 e0       	ldi	r31, 0x03	; 3
    7a70:	ff bb       	out	0x1f, r31	; 31
    7a72:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7a74:	e0 9a       	sbi	0x1c, 0	; 28
    7a76:	8d b3       	in	r24, 0x1d	; 29
    7a78:	9e 01       	movw	r18, r28
    7a7a:	2b 55       	subi	r18, 0x5B	; 91
    7a7c:	3f 4f       	sbci	r19, 0xFF	; 255
    7a7e:	46 eb       	ldi	r20, 0xB6	; 182
    7a80:	5b e0       	ldi	r21, 0x0B	; 11
    7a82:	de 01       	movw	r26, r28
    7a84:	a7 59       	subi	r26, 0x97	; 151
    7a86:	bf 4f       	sbci	r27, 0xFF	; 255

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7a88:	81 30       	cpi	r24, 0x01	; 1
    7a8a:	41 f5       	brne	.+80     	; 0x7adc <systemGenerateReport+0x10a0>
    7a8c:	8d b7       	in	r24, 0x3d	; 61
    7a8e:	9e b7       	in	r25, 0x3e	; 62
    7a90:	0c 97       	sbiw	r24, 0x0c	; 12
    7a92:	0f b6       	in	r0, 0x3f	; 63
    7a94:	f8 94       	cli
    7a96:	9e bf       	out	0x3e, r25	; 62
    7a98:	0f be       	out	0x3f, r0	; 63
    7a9a:	8d bf       	out	0x3d, r24	; 61
    7a9c:	6d b7       	in	r22, 0x3d	; 61
    7a9e:	7e b7       	in	r23, 0x3e	; 62
    7aa0:	6f 5f       	subi	r22, 0xFF	; 255
    7aa2:	7f 4f       	sbci	r23, 0xFF	; 255
    7aa4:	ed b7       	in	r30, 0x3d	; 61
    7aa6:	fe b7       	in	r31, 0x3e	; 62
    7aa8:	32 83       	std	Z+2, r19	; 0x02
    7aaa:	21 83       	std	Z+1, r18	; 0x01
    7aac:	87 e2       	ldi	r24, 0x27	; 39
    7aae:	94 e0       	ldi	r25, 0x04	; 4
    7ab0:	fb 01       	movw	r30, r22
    7ab2:	93 83       	std	Z+3, r25	; 0x03
    7ab4:	82 83       	std	Z+2, r24	; 0x02
    7ab6:	b5 83       	std	Z+5, r27	; 0x05
    7ab8:	a4 83       	std	Z+4, r26	; 0x04
    7aba:	57 83       	std	Z+7, r21	; 0x07
    7abc:	46 83       	std	Z+6, r20	; 0x06
    7abe:	ce 01       	movw	r24, r28
    7ac0:	83 58       	subi	r24, 0x83	; 131
    7ac2:	9f 4f       	sbci	r25, 0xFF	; 255
    7ac4:	91 87       	std	Z+9, r25	; 0x09
    7ac6:	80 87       	std	Z+8, r24	; 0x08
    7ac8:	8b e3       	ldi	r24, 0x3B	; 59
    7aca:	9c e0       	ldi	r25, 0x0C	; 12
    7acc:	93 87       	std	Z+11, r25	; 0x0b
    7ace:	82 87       	std	Z+10, r24	; 0x0a
    7ad0:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    7ad4:	8d b7       	in	r24, 0x3d	; 61
    7ad6:	9e b7       	in	r25, 0x3e	; 62
    7ad8:	0c 96       	adiw	r24, 0x0c	; 12
    7ada:	1c c0       	rjmp	.+56     	; 0x7b14 <systemGenerateReport+0x10d8>
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    7adc:	ed b7       	in	r30, 0x3d	; 61
    7ade:	fe b7       	in	r31, 0x3e	; 62
    7ae0:	38 97       	sbiw	r30, 0x08	; 8
    7ae2:	0f b6       	in	r0, 0x3f	; 63
    7ae4:	f8 94       	cli
    7ae6:	fe bf       	out	0x3e, r31	; 62
    7ae8:	0f be       	out	0x3f, r0	; 63
    7aea:	ed bf       	out	0x3d, r30	; 61
    7aec:	6d b7       	in	r22, 0x3d	; 61
    7aee:	7e b7       	in	r23, 0x3e	; 62
    7af0:	6f 5f       	subi	r22, 0xFF	; 255
    7af2:	7f 4f       	sbci	r23, 0xFF	; 255
    7af4:	32 83       	std	Z+2, r19	; 0x02
    7af6:	21 83       	std	Z+1, r18	; 0x01
    7af8:	8c e1       	ldi	r24, 0x1C	; 28
    7afa:	94 e0       	ldi	r25, 0x04	; 4
    7afc:	fb 01       	movw	r30, r22
    7afe:	93 83       	std	Z+3, r25	; 0x03
    7b00:	82 83       	std	Z+2, r24	; 0x02
    7b02:	b5 83       	std	Z+5, r27	; 0x05
    7b04:	a4 83       	std	Z+4, r26	; 0x04
    7b06:	57 83       	std	Z+7, r21	; 0x07
    7b08:	46 83       	std	Z+6, r20	; 0x06
    7b0a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    7b0e:	8d b7       	in	r24, 0x3d	; 61
    7b10:	9e b7       	in	r25, 0x3e	; 62
    7b12:	08 96       	adiw	r24, 0x08	; 8
    7b14:	0f b6       	in	r0, 0x3f	; 63
    7b16:	f8 94       	cli
    7b18:	9e bf       	out	0x3e, r25	; 62
    7b1a:	0f be       	out	0x3f, r0	; 63
    7b1c:	8d bf       	out	0x3d, r24	; 61
    7b1e:	ce 01       	movw	r24, r28
    7b20:	8b 55       	subi	r24, 0x5B	; 91
    7b22:	9f 4f       	sbci	r25, 0xFF	; 255
    7b24:	6f ec       	ldi	r22, 0xCF	; 207
    7b26:	75 e0       	ldi	r23, 0x05	; 5
    7b28:	42 e0       	ldi	r20, 0x02	; 2
    7b2a:	52 e0       	ldi	r21, 0x02	; 2
    7b2c:	0e 94 85 22 	call	0x450a	; 0x450a <CreateReport>

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      
    7b30:	84 e0       	ldi	r24, 0x04	; 4
    7b32:	6f ec       	ldi	r22, 0xCF	; 207
    7b34:	75 e0       	ldi	r23, 0x05	; 5
    7b36:	41 e0       	ldi	r20, 0x01	; 1
    7b38:	22 e0       	ldi	r18, 0x02	; 2
    7b3a:	32 e0       	ldi	r19, 0x02	; 2
    7b3c:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    7b40:	8b e0       	ldi	r24, 0x0B	; 11
    7b42:	6f ec       	ldi	r22, 0xCF	; 207
    7b44:	75 e0       	ldi	r23, 0x05	; 5
    7b46:	4a e2       	ldi	r20, 0x2A	; 42
    7b48:	22 e0       	ldi	r18, 0x02	; 2
    7b4a:	32 e0       	ldi	r19, 0x02	; 2
    7b4c:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    7b50:	86 e0       	ldi	r24, 0x06	; 6
    7b52:	6f ec       	ldi	r22, 0xCF	; 207
    7b54:	75 e0       	ldi	r23, 0x05	; 5
    7b56:	41 e0       	ldi	r20, 0x01	; 1
    7b58:	22 e0       	ldi	r18, 0x02	; 2
    7b5a:	32 e0       	ldi	r19, 0x02	; 2
    7b5c:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    7b60:	8c e0       	ldi	r24, 0x0C	; 12
    7b62:	6f ec       	ldi	r22, 0xCF	; 207
    7b64:	75 e0       	ldi	r23, 0x05	; 5
    7b66:	41 e0       	ldi	r20, 0x01	; 1
    7b68:	22 e0       	ldi	r18, 0x02	; 2
    7b6a:	32 e0       	ldi	r19, 0x02	; 2
    7b6c:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    7b70:	ee 24       	eor	r14, r14

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7b72:	b8 e2       	ldi	r27, 0x28	; 40
    7b74:	2b 2e       	mov	r2, r27
    7b76:	31 2c       	mov	r3, r1
    7b78:	2c 0e       	add	r2, r28
    7b7a:	3d 1e       	adc	r3, r29
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    7b7c:	a7 e3       	ldi	r26, 0x37	; 55
    7b7e:	6a 2e       	mov	r6, r26
    7b80:	71 2c       	mov	r7, r1
    7b82:	6c 0e       	add	r6, r28
    7b84:	7d 1e       	adc	r7, r29
    7b86:	d3 01       	movw	r26, r6
    7b88:	1f 96       	adiw	r26, 0x0f	; 15
    7b8a:	cb 50       	subi	r28, 0x0B	; 11
    7b8c:	df 4f       	sbci	r29, 0xFF	; 255
    7b8e:	b9 83       	std	Y+1, r27	; 0x01
    7b90:	a8 83       	st	Y, r26
    7b92:	c5 5f       	subi	r28, 0xF5	; 245
    7b94:	d0 40       	sbci	r29, 0x00	; 0
    7b96:	f6 e4       	ldi	r31, 0x46	; 70
    7b98:	4f 2e       	mov	r4, r31
    7b9a:	51 2c       	mov	r5, r1
    7b9c:	4c 0e       	add	r4, r28
    7b9e:	5d 1e       	adc	r5, r29
    7ba0:	f2 01       	movw	r30, r4
    7ba2:	3f 96       	adiw	r30, 0x0f	; 15
    7ba4:	c9 50       	subi	r28, 0x09	; 9
    7ba6:	df 4f       	sbci	r29, 0xFF	; 255
    7ba8:	f9 83       	std	Y+1, r31	; 0x01
    7baa:	e8 83       	st	Y, r30
    7bac:	c7 5f       	subi	r28, 0xF7	; 247
    7bae:	d0 40       	sbci	r29, 0x00	; 0
    7bb0:	ed e7       	ldi	r30, 0x7D	; 125
    7bb2:	8e 2e       	mov	r8, r30
    7bb4:	91 2c       	mov	r9, r1
    7bb6:	8c 0e       	add	r8, r28
    7bb8:	9d 1e       	adc	r9, r29
    7bba:	e3 c1       	rjmp	.+966    	; 0x7f82 <systemGenerateReport+0x1546>
    7bbc:	f5 01       	movw	r30, r10
    7bbe:	ec 5f       	subi	r30, 0xFC	; 252
    7bc0:	fd 4f       	sbci	r31, 0xFD	; 253
    7bc2:	80 81       	ld	r24, Z
    7bc4:	80 53       	subi	r24, 0x30	; 48
    7bc6:	8a 30       	cpi	r24, 0x0A	; 10
    7bc8:	08 f0       	brcs	.+2      	; 0x7bcc <systemGenerateReport+0x1190>
    7bca:	80 e0       	ldi	r24, 0x00	; 0
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
		      xGrade=Ord(GradeList[iTotal]);
    7bcc:	80 93 11 02 	sts	0x0211, r24
			  if (xGrade>0){
    7bd0:	88 23       	and	r24, r24
    7bd2:	09 f4       	brne	.+2      	; 0x7bd6 <systemGenerateReport+0x119a>
    7bd4:	d5 c1       	rjmp	.+938    	; 0x7f80 <systemGenerateReport+0x1544>
			      GetProductName(xGrade,strProduct);
    7bd6:	61 e4       	ldi	r22, 0x41	; 65
    7bd8:	79 e0       	ldi	r23, 0x09	; 9
    7bda:	0e 94 57 2e 	call	0x5cae	; 0x5cae <GetProductName>
    7bde:	e6 eb       	ldi	r30, 0xB6	; 182
    7be0:	fb e0       	ldi	r31, 0x0B	; 11
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    7be2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7be4:	8b e0       	ldi	r24, 0x0B	; 11
    7be6:	ea 3c       	cpi	r30, 0xCA	; 202
    7be8:	f8 07       	cpc	r31, r24
    7bea:	d9 f7       	brne	.-10     	; 0x7be2 <systemGenerateReport+0x11a6>
    7bec:	eb e3       	ldi	r30, 0x3B	; 59
    7bee:	fc e0       	ldi	r31, 0x0C	; 12
	     strMemory[i]=data;
    7bf0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7bf2:	9c e0       	ldi	r25, 0x0C	; 12
    7bf4:	ef 34       	cpi	r30, 0x4F	; 79
    7bf6:	f9 07       	cpc	r31, r25
    7bf8:	d9 f7       	brne	.-10     	; 0x7bf0 <systemGenerateReport+0x11b4>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    7bfa:	81 e0       	ldi	r24, 0x01	; 1
    7bfc:	80 93 13 02 	sts	0x0213, r24

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7c00:	79 e1       	ldi	r23, 0x19	; 25
    7c02:	c7 2e       	mov	r12, r23
    7c04:	d1 2c       	mov	r13, r1
    7c06:	cc 0e       	add	r12, r28
    7c08:	dd 1e       	adc	r13, r29
    7c0a:	e6 c0       	rjmp	.+460    	; 0x7dd8 <systemGenerateReport+0x139c>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    7c0c:	ce 01       	movw	r24, r28
    7c0e:	07 96       	adiw	r24, 0x07	; 7
    7c10:	65 e4       	ldi	r22, 0x45	; 69
    7c12:	70 e0       	ldi	r23, 0x00	; 0
    7c14:	48 e0       	ldi	r20, 0x08	; 8
    7c16:	50 e0       	ldi	r21, 0x00	; 0
    7c18:	28 ef       	ldi	r18, 0xF8	; 248
    7c1a:	32 e1       	ldi	r19, 0x12	; 18
    7c1c:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
    7c20:	80 91 13 02 	lds	r24, 0x0213
    7c24:	fe 01       	movw	r30, r28
    7c26:	e8 0f       	add	r30, r24
    7c28:	f1 1d       	adc	r31, r1
    7c2a:	86 81       	ldd	r24, Z+6	; 0x06
    7c2c:	80 93 10 02 	sts	0x0210, r24
					  if (PumpNum>0){
    7c30:	88 23       	and	r24, r24
    7c32:	09 f4       	brne	.+2      	; 0x7c36 <systemGenerateReport+0x11fa>
    7c34:	cc c0       	rjmp	.+408    	; 0x7dce <systemGenerateReport+0x1392>
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    7c36:	81 e0       	ldi	r24, 0x01	; 1
    7c38:	c3 c0       	rjmp	.+390    	; 0x7dc0 <systemGenerateReport+0x1384>
    7c3a:	60 91 13 02 	lds	r22, 0x0213
    7c3e:	a6 e0       	ldi	r26, 0x06	; 6
    7c40:	6a 9f       	mul	r22, r26
    7c42:	b0 01       	movw	r22, r0
    7c44:	11 24       	eor	r1, r1
    7c46:	61 5b       	subi	r22, 0xB1	; 177
    7c48:	7f 4f       	sbci	r23, 0xFF	; 255
    7c4a:	ce 01       	movw	r24, r28
    7c4c:	01 96       	adiw	r24, 0x01	; 1
    7c4e:	46 e0       	ldi	r20, 0x06	; 6
    7c50:	50 e0       	ldi	r21, 0x00	; 0
    7c52:	28 ef       	ldi	r18, 0xF8	; 248
    7c54:	32 e1       	ldi	r19, 0x12	; 18
    7c56:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
							  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
							  //Found Grade
						      if (PProductID[xNozzle-1]==xGrade){
    7c5a:	80 91 12 02 	lds	r24, 0x0212
    7c5e:	fe 01       	movw	r30, r28
    7c60:	e8 0f       	add	r30, r24
    7c62:	f1 1d       	adc	r31, r1
    7c64:	90 81       	ld	r25, Z
    7c66:	80 91 11 02 	lds	r24, 0x0211
    7c6a:	98 17       	cp	r25, r24
    7c6c:	09 f0       	breq	.+2      	; 0x7c70 <systemGenerateReport+0x1234>
    7c6e:	a5 c0       	rjmp	.+330    	; 0x7dba <systemGenerateReport+0x137e>
    7c70:	e0 e8       	ldi	r30, 0x80	; 128
    7c72:	ff e0       	ldi	r31, 0x0F	; 15
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    7c74:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7c76:	bf e0       	ldi	r27, 0x0F	; 15
    7c78:	ef 38       	cpi	r30, 0x8F	; 143
    7c7a:	fb 07       	cpc	r31, r27
    7c7c:	d9 f7       	brne	.-10     	; 0x7c74 <systemGenerateReport+0x1238>
    7c7e:	eb e6       	ldi	r30, 0x6B	; 107
    7c80:	fc e0       	ldi	r31, 0x0C	; 12
	     strMemory[i]=data;
    7c82:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7c84:	8c e0       	ldi	r24, 0x0C	; 12
    7c86:	ea 37       	cpi	r30, 0x7A	; 122
    7c88:	f8 07       	cpc	r31, r24
    7c8a:	d9 f7       	brne	.-10     	; 0x7c82 <systemGenerateReport+0x1246>
    7c8c:	f6 01       	movw	r30, r12
	     strMemory[i]=data;
    7c8e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7c90:	e2 15       	cp	r30, r2
    7c92:	f3 05       	cpc	r31, r3
    7c94:	e1 f7       	brne	.-8      	; 0x7c8e <systemGenerateReport+0x1252>
    7c96:	f1 01       	movw	r30, r2
	     strMemory[i]=data;
    7c98:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7c9a:	e6 15       	cp	r30, r6
    7c9c:	f7 05       	cpc	r31, r7
    7c9e:	e1 f7       	brne	.-8      	; 0x7c98 <systemGenerateReport+0x125c>
    7ca0:	f3 01       	movw	r30, r6
	     strMemory[i]=data;
    7ca2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7ca4:	cb 50       	subi	r28, 0x0B	; 11
    7ca6:	df 4f       	sbci	r29, 0xFF	; 255
    7ca8:	a8 81       	ld	r26, Y
    7caa:	b9 81       	ldd	r27, Y+1	; 0x01
    7cac:	c5 5f       	subi	r28, 0xF5	; 245
    7cae:	d0 40       	sbci	r29, 0x00	; 0
    7cb0:	ea 17       	cp	r30, r26
    7cb2:	fb 07       	cpc	r31, r27
    7cb4:	b1 f7       	brne	.-20     	; 0x7ca2 <systemGenerateReport+0x1266>
    7cb6:	f2 01       	movw	r30, r4
	     strMemory[i]=data;
    7cb8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7cba:	c9 50       	subi	r28, 0x09	; 9
    7cbc:	df 4f       	sbci	r29, 0xFF	; 255
    7cbe:	88 81       	ld	r24, Y
    7cc0:	99 81       	ldd	r25, Y+1	; 0x01
    7cc2:	c7 5f       	subi	r28, 0xF7	; 247
    7cc4:	d0 40       	sbci	r29, 0x00	; 0
    7cc6:	e8 17       	cp	r30, r24
    7cc8:	f9 07       	cpc	r31, r25
    7cca:	b1 f7       	brne	.-20     	; 0x7cb8 <systemGenerateReport+0x127c>
								  FillChar(strLastVolume,sizeof(strLastVolume),0);
								  FillChar(strLastMoney,sizeof(strLastMoney),0);
								  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
								  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

								  PumpNozzle=xNozzle;
    7ccc:	80 91 12 02 	lds	r24, 0x0212
    7cd0:	80 93 0f 02 	sts	0x020F, r24
								  
								  FIPAddr=GetFIPAddr(PumpNum); 
    7cd4:	80 91 10 02 	lds	r24, 0x0210
    7cd8:	0e 94 dd 1d 	call	0x3bba	; 0x3bba <GetFIPAddr>
								  if (FIPAddr>0){
    7cdc:	88 23       	and	r24, r24
    7cde:	11 f1       	breq	.+68     	; 0x7d24 <systemGenerateReport+0x12e8>
									  FIPAddr=FIPAddr-1;							  							  							      
    7ce0:	f8 2e       	mov	r15, r24
    7ce2:	fa 94       	dec	r15
									  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    7ce4:	80 e0       	ldi	r24, 0x00	; 0
    7ce6:	60 e0       	ldi	r22, 0x00	; 0
    7ce8:	4f 2d       	mov	r20, r15
    7cea:	20 91 0f 02 	lds	r18, 0x020F
    7cee:	86 01       	movw	r16, r12
    7cf0:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    7cf4:	81 e0       	ldi	r24, 0x01	; 1
    7cf6:	60 e0       	ldi	r22, 0x00	; 0
    7cf8:	4f 2d       	mov	r20, r15
    7cfa:	20 91 0f 02 	lds	r18, 0x020F
    7cfe:	81 01       	movw	r16, r2
    7d00:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <GetTotalizerData>

									  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    7d04:	80 e0       	ldi	r24, 0x00	; 0
    7d06:	61 e0       	ldi	r22, 0x01	; 1
    7d08:	4f 2d       	mov	r20, r15
    7d0a:	20 91 0f 02 	lds	r18, 0x020F
    7d0e:	83 01       	movw	r16, r6
    7d10:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    7d14:	81 e0       	ldi	r24, 0x01	; 1
    7d16:	61 e0       	ldi	r22, 0x01	; 1
    7d18:	4f 2d       	mov	r20, r15
    7d1a:	20 91 0f 02 	lds	r18, 0x020F
    7d1e:	82 01       	movw	r16, r4
    7d20:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <GetTotalizerData>
								  }

								  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    7d24:	80 e0       	ldi	r24, 0x00	; 0
    7d26:	b3 01       	movw	r22, r6
    7d28:	a6 01       	movw	r20, r12
    7d2a:	2b e6       	ldi	r18, 0x6B	; 107
    7d2c:	3c e0       	ldi	r19, 0x0C	; 12
    7d2e:	0e 94 ef 29 	call	0x53de	; 0x53de <StrCalc>
								  if (IsMinus(strDeltaVolume)==True)
    7d32:	8b e6       	ldi	r24, 0x6B	; 107
    7d34:	9c e0       	ldi	r25, 0x0C	; 12
    7d36:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <IsMinus>
    7d3a:	81 30       	cpi	r24, 0x01	; 1
    7d3c:	21 f4       	brne	.+8      	; 0x7d46 <systemGenerateReport+0x130a>
								      NormalizeOverflow(strDeltaVolume);
    7d3e:	8b e6       	ldi	r24, 0x6B	; 107
    7d40:	9c e0       	ldi	r25, 0x0C	; 12
    7d42:	0e 94 86 2d 	call	0x5b0c	; 0x5b0c <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7d46:	e1 99       	sbic	0x1c, 1	; 28
    7d48:	fe cf       	rjmp	.-4      	; 0x7d46 <systemGenerateReport+0x130a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7d4a:	a7 e3       	ldi	r26, 0x37	; 55
    7d4c:	b1 e0       	ldi	r27, 0x01	; 1
    7d4e:	bf bb       	out	0x1f, r27	; 31
    7d50:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7d52:	e0 9a       	sbi	0x1c, 0	; 28
    7d54:	8d b3       	in	r24, 0x1d	; 29


								  //Calculate Wayne Estimated Total Money
								  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    7d56:	82 30       	cpi	r24, 0x02	; 2
    7d58:	79 f4       	brne	.+30     	; 0x7d78 <systemGenerateReport+0x133c>
						              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    7d5a:	ce 01       	movw	r24, r28
    7d5c:	0f 96       	adiw	r24, 0x0f	; 15
    7d5e:	60 91 10 02 	lds	r22, 0x0210
    7d62:	40 91 0f 02 	lds	r20, 0x020F
    7d66:	0e 94 cd 24 	call	0x499a	; 0x499a <GetProductPrice>
									  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    7d6a:	82 e0       	ldi	r24, 0x02	; 2
    7d6c:	be 01       	movw	r22, r28
    7d6e:	61 5f       	subi	r22, 0xF1	; 241
    7d70:	7f 4f       	sbci	r23, 0xFF	; 255
    7d72:	4b e6       	ldi	r20, 0x6B	; 107
    7d74:	5c e0       	ldi	r21, 0x0C	; 12
    7d76:	03 c0       	rjmp	.+6      	; 0x7d7e <systemGenerateReport+0x1342>
								  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    7d78:	80 e0       	ldi	r24, 0x00	; 0
    7d7a:	b2 01       	movw	r22, r4
    7d7c:	a1 01       	movw	r20, r2
    7d7e:	20 e8       	ldi	r18, 0x80	; 128
    7d80:	3f e0       	ldi	r19, 0x0F	; 15
    7d82:	0e 94 ef 29 	call	0x53de	; 0x53de <StrCalc>
								  //StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
								  if (IsMinus(strDeltaMoney)==True)
    7d86:	80 e8       	ldi	r24, 0x80	; 128
    7d88:	9f e0       	ldi	r25, 0x0F	; 15
    7d8a:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <IsMinus>
    7d8e:	81 30       	cpi	r24, 0x01	; 1
    7d90:	21 f4       	brne	.+8      	; 0x7d9a <systemGenerateReport+0x135e>
								      NormalizeOverflow(strDeltaMoney);
    7d92:	80 e8       	ldi	r24, 0x80	; 128
    7d94:	9f e0       	ldi	r25, 0x0F	; 15
    7d96:	0e 94 86 2d 	call	0x5b0c	; 0x5b0c <NormalizeOverflow>
		  
								  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    7d9a:	81 e0       	ldi	r24, 0x01	; 1
    7d9c:	66 eb       	ldi	r22, 0xB6	; 182
    7d9e:	7b e0       	ldi	r23, 0x0B	; 11
    7da0:	4b e6       	ldi	r20, 0x6B	; 107
    7da2:	5c e0       	ldi	r21, 0x0C	; 12
    7da4:	9b 01       	movw	r18, r22
    7da6:	0e 94 ef 29 	call	0x53de	; 0x53de <StrCalc>
								  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    7daa:	81 e0       	ldi	r24, 0x01	; 1
    7dac:	6b e3       	ldi	r22, 0x3B	; 59
    7dae:	7c e0       	ldi	r23, 0x0C	; 12
    7db0:	40 e8       	ldi	r20, 0x80	; 128
    7db2:	5f e0       	ldi	r21, 0x0F	; 15
    7db4:	9b 01       	movw	r18, r22
    7db6:	0e 94 ef 29 	call	0x53de	; 0x53de <StrCalc>

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
					  if (PumpNum>0){
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    7dba:	80 91 12 02 	lds	r24, 0x0212
    7dbe:	8f 5f       	subi	r24, 0xFF	; 255
    7dc0:	80 93 12 02 	sts	0x0212, r24
    7dc4:	80 91 12 02 	lds	r24, 0x0212
    7dc8:	87 30       	cpi	r24, 0x07	; 7
    7dca:	08 f4       	brcc	.+2      	; 0x7dce <systemGenerateReport+0x1392>
    7dcc:	36 cf       	rjmp	.-404    	; 0x7c3a <systemGenerateReport+0x11fe>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    7dce:	80 91 13 02 	lds	r24, 0x0213
    7dd2:	8f 5f       	subi	r24, 0xFF	; 255
    7dd4:	80 93 13 02 	sts	0x0213, r24
    7dd8:	80 91 13 02 	lds	r24, 0x0213
    7ddc:	89 30       	cpi	r24, 0x09	; 9
    7dde:	08 f4       	brcc	.+2      	; 0x7de2 <systemGenerateReport+0x13a6>
    7de0:	15 cf       	rjmp	.-470    	; 0x7c0c <systemGenerateReport+0x11d0>
							  }
						  }
					  }				  
				  }

				  RemZeroLead(strTotalMoney);
    7de2:	8b e3       	ldi	r24, 0x3B	; 59
    7de4:	9c e0       	ldi	r25, 0x0C	; 12
    7de6:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
				  RemZeroLead(strTotalVolume);
    7dea:	06 eb       	ldi	r16, 0xB6	; 182
    7dec:	1b e0       	ldi	r17, 0x0B	; 11
    7dee:	c8 01       	movw	r24, r16
    7df0:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>

				  FormatTotalizerMoney(strTotalMoney);
    7df4:	8b e3       	ldi	r24, 0x3B	; 59
    7df6:	9c e0       	ldi	r25, 0x0C	; 12
    7df8:	0e 94 ea 34 	call	0x69d4	; 0x69d4 <FormatTotalizerMoney>
				  FormatCurrency(strTotalMoney);
    7dfc:	8b e3       	ldi	r24, 0x3B	; 59
    7dfe:	9c e0       	ldi	r25, 0x0C	; 12
    7e00:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>

				  FormatTotalizerVolume(strTotalVolume);
    7e04:	c8 01       	movw	r24, r16
    7e06:	0e 94 dd 34 	call	0x69ba	; 0x69ba <FormatTotalizerVolume>
				  FormatCurrency(strTotalVolume);
    7e0a:	c8 01       	movw	r24, r16
    7e0c:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>
		          //Test
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
    7e10:	e1 e4       	ldi	r30, 0x41	; 65
    7e12:	f9 e0       	ldi	r31, 0x09	; 9
    7e14:	01 90       	ld	r0, Z+
    7e16:	00 20       	and	r0, r0
    7e18:	e9 f7       	brne	.-6      	; 0x7e14 <systemGenerateReport+0x13d8>
    7e1a:	31 97       	sbiw	r30, 0x01	; 1
    7e1c:	e1 54       	subi	r30, 0x41	; 65
    7e1e:	f9 40       	sbci	r31, 0x09	; 9
    7e20:	d8 01       	movw	r26, r16
    7e22:	0d 90       	ld	r0, X+
    7e24:	00 20       	and	r0, r0
    7e26:	e9 f7       	brne	.-6      	; 0x7e22 <systemGenerateReport+0x13e6>
    7e28:	8d 01       	movw	r16, r26
    7e2a:	01 50       	subi	r16, 0x01	; 1
    7e2c:	10 40       	sbci	r17, 0x00	; 0
    7e2e:	06 5b       	subi	r16, 0xB6	; 182
    7e30:	1b 40       	sbci	r17, 0x0B	; 11
    7e32:	8e 2f       	mov	r24, r30
    7e34:	81 95       	neg	r24
    7e36:	80 1b       	sub	r24, r16
    7e38:	8b 5e       	subi	r24, 0xEB	; 235
    7e3a:	de 01       	movw	r26, r28
    7e3c:	a7 59       	subi	r26, 0x97	; 151
    7e3e:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7e40:	18 16       	cp	r1, r24
    7e42:	7c f4       	brge	.+30     	; 0x7e62 <systemGenerateReport+0x1426>
    7e44:	fd 01       	movw	r30, r26
    7e46:	90 e0       	ldi	r25, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7e48:	20 e2       	ldi	r18, 0x20	; 32
    7e4a:	02 c0       	rjmp	.+4      	; 0x7e50 <systemGenerateReport+0x1414>
    7e4c:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7e4e:	9f 5f       	subi	r25, 0xFF	; 255
    7e50:	98 17       	cp	r25, r24
    7e52:	e0 f3       	brcs	.-8      	; 0x7e4c <systemGenerateReport+0x1410>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7e54:	fe 01       	movw	r30, r28
    7e56:	e7 59       	subi	r30, 0x97	; 151
    7e58:	ff 4f       	sbci	r31, 0xFF	; 255
    7e5a:	e8 0f       	add	r30, r24
    7e5c:	f1 1d       	adc	r31, r1
    7e5e:	10 82       	st	Z, r1
    7e60:	04 c0       	rjmp	.+8      	; 0x7e6a <systemGenerateReport+0x142e>
     }else{
	 strTab[0]=' ';
    7e62:	80 e2       	ldi	r24, 0x20	; 32
    7e64:	8c 93       	st	X, r24
	 strTab[1]=0;
    7e66:	11 96       	adiw	r26, 0x01	; 1
    7e68:	1c 92       	st	X, r1
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    7e6a:	eb e3       	ldi	r30, 0x3B	; 59
    7e6c:	fc e0       	ldi	r31, 0x0C	; 12
    7e6e:	01 90       	ld	r0, Z+
    7e70:	00 20       	and	r0, r0
    7e72:	e9 f7       	brne	.-6      	; 0x7e6e <systemGenerateReport+0x1432>
    7e74:	31 97       	sbiw	r30, 0x01	; 1
    7e76:	eb 53       	subi	r30, 0x3B	; 59
    7e78:	fc 40       	sbci	r31, 0x0C	; 12
    7e7a:	9f e0       	ldi	r25, 0x0F	; 15
    7e7c:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7e7e:	19 16       	cp	r1, r25
    7e80:	6c f4       	brge	.+26     	; 0x7e9c <systemGenerateReport+0x1460>
    7e82:	f4 01       	movw	r30, r8
    7e84:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7e86:	20 e2       	ldi	r18, 0x20	; 32
    7e88:	02 c0       	rjmp	.+4      	; 0x7e8e <systemGenerateReport+0x1452>
    7e8a:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7e8c:	8f 5f       	subi	r24, 0xFF	; 255
    7e8e:	89 17       	cp	r24, r25
    7e90:	e0 f3       	brcs	.-8      	; 0x7e8a <systemGenerateReport+0x144e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7e92:	f4 01       	movw	r30, r8
    7e94:	e9 0f       	add	r30, r25
    7e96:	f1 1d       	adc	r31, r1
    7e98:	10 82       	st	Z, r1
    7e9a:	04 c0       	rjmp	.+8      	; 0x7ea4 <systemGenerateReport+0x1468>
     }else{
	 strTab[0]=' ';
    7e9c:	80 e2       	ldi	r24, 0x20	; 32
    7e9e:	f4 01       	movw	r30, r8
    7ea0:	80 83       	st	Z, r24
	 strTab[1]=0;
    7ea2:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7ea4:	e1 99       	sbic	0x1c, 1	; 28
    7ea6:	fe cf       	rjmp	.-4      	; 0x7ea4 <systemGenerateReport+0x1468>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7ea8:	81 ec       	ldi	r24, 0xC1	; 193
    7eaa:	93 e0       	ldi	r25, 0x03	; 3
    7eac:	9f bb       	out	0x1f, r25	; 31
    7eae:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7eb0:	e0 9a       	sbi	0x1c, 0	; 28
    7eb2:	8d b3       	in	r24, 0x1d	; 29
    7eb4:	9e 01       	movw	r18, r28
    7eb6:	2b 55       	subi	r18, 0x5B	; 91
    7eb8:	3f 4f       	sbci	r19, 0xFF	; 255
    7eba:	46 eb       	ldi	r20, 0xB6	; 182
    7ebc:	5b e0       	ldi	r21, 0x0B	; 11
    7ebe:	61 e4       	ldi	r22, 0x41	; 65
    7ec0:	c6 2e       	mov	r12, r22
    7ec2:	69 e0       	ldi	r22, 0x09	; 9
    7ec4:	d6 2e       	mov	r13, r22
    7ec6:	de 01       	movw	r26, r28
    7ec8:	a7 59       	subi	r26, 0x97	; 151
    7eca:	bf 4f       	sbci	r27, 0xFF	; 255
    7ecc:	b5 01       	movw	r22, r10
    7ece:	6f 5f       	subi	r22, 0xFF	; 255
    7ed0:	7f 4f       	sbci	r23, 0xFF	; 255

			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);

				  //PrintMoney
		          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%d.%s%s%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);
    7ed2:	81 30       	cpi	r24, 0x01	; 1
    7ed4:	39 f5       	brne	.+78     	; 0x7f24 <systemGenerateReport+0x14e8>
    7ed6:	ed b7       	in	r30, 0x3d	; 61
    7ed8:	fe b7       	in	r31, 0x3e	; 62
    7eda:	70 97       	sbiw	r30, 0x10	; 16
    7edc:	0f b6       	in	r0, 0x3f	; 63
    7ede:	f8 94       	cli
    7ee0:	fe bf       	out	0x3e, r31	; 62
    7ee2:	0f be       	out	0x3f, r0	; 63
    7ee4:	ed bf       	out	0x3d, r30	; 61
    7ee6:	0d b7       	in	r16, 0x3d	; 61
    7ee8:	1e b7       	in	r17, 0x3e	; 62
    7eea:	0f 5f       	subi	r16, 0xFF	; 255
    7eec:	1f 4f       	sbci	r17, 0xFF	; 255
    7eee:	32 83       	std	Z+2, r19	; 0x02
    7ef0:	21 83       	std	Z+1, r18	; 0x01
    7ef2:	8e e0       	ldi	r24, 0x0E	; 14
    7ef4:	94 e0       	ldi	r25, 0x04	; 4
    7ef6:	f8 01       	movw	r30, r16
    7ef8:	93 83       	std	Z+3, r25	; 0x03
    7efa:	82 83       	std	Z+2, r24	; 0x02
    7efc:	75 83       	std	Z+5, r23	; 0x05
    7efe:	64 83       	std	Z+4, r22	; 0x04
    7f00:	d7 82       	std	Z+7, r13	; 0x07
    7f02:	c6 82       	std	Z+6, r12	; 0x06
    7f04:	b1 87       	std	Z+9, r27	; 0x09
    7f06:	a0 87       	std	Z+8, r26	; 0x08
    7f08:	53 87       	std	Z+11, r21	; 0x0b
    7f0a:	42 87       	std	Z+10, r20	; 0x0a
    7f0c:	95 86       	std	Z+13, r9	; 0x0d
    7f0e:	84 86       	std	Z+12, r8	; 0x0c
    7f10:	8b e3       	ldi	r24, 0x3B	; 59
    7f12:	9c e0       	ldi	r25, 0x0C	; 12
    7f14:	97 87       	std	Z+15, r25	; 0x0f
    7f16:	86 87       	std	Z+14, r24	; 0x0e
    7f18:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    7f1c:	8d b7       	in	r24, 0x3d	; 61
    7f1e:	9e b7       	in	r25, 0x3e	; 62
    7f20:	40 96       	adiw	r24, 0x10	; 16
    7f22:	20 c0       	rjmp	.+64     	; 0x7f64 <systemGenerateReport+0x1528>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);
    7f24:	ed b7       	in	r30, 0x3d	; 61
    7f26:	fe b7       	in	r31, 0x3e	; 62
    7f28:	3c 97       	sbiw	r30, 0x0c	; 12
    7f2a:	0f b6       	in	r0, 0x3f	; 63
    7f2c:	f8 94       	cli
    7f2e:	fe bf       	out	0x3e, r31	; 62
    7f30:	0f be       	out	0x3f, r0	; 63
    7f32:	ed bf       	out	0x3d, r30	; 61
    7f34:	0d b7       	in	r16, 0x3d	; 61
    7f36:	1e b7       	in	r17, 0x3e	; 62
    7f38:	0f 5f       	subi	r16, 0xFF	; 255
    7f3a:	1f 4f       	sbci	r17, 0xFF	; 255
    7f3c:	32 83       	std	Z+2, r19	; 0x02
    7f3e:	21 83       	std	Z+1, r18	; 0x01
    7f40:	84 e0       	ldi	r24, 0x04	; 4
    7f42:	94 e0       	ldi	r25, 0x04	; 4
    7f44:	f8 01       	movw	r30, r16
    7f46:	93 83       	std	Z+3, r25	; 0x03
    7f48:	82 83       	std	Z+2, r24	; 0x02
    7f4a:	75 83       	std	Z+5, r23	; 0x05
    7f4c:	64 83       	std	Z+4, r22	; 0x04
    7f4e:	d7 82       	std	Z+7, r13	; 0x07
    7f50:	c6 82       	std	Z+6, r12	; 0x06
    7f52:	b1 87       	std	Z+9, r27	; 0x09
    7f54:	a0 87       	std	Z+8, r26	; 0x08
    7f56:	53 87       	std	Z+11, r21	; 0x0b
    7f58:	42 87       	std	Z+10, r20	; 0x0a
    7f5a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    7f5e:	8d b7       	in	r24, 0x3d	; 61
    7f60:	9e b7       	in	r25, 0x3e	; 62
    7f62:	0c 96       	adiw	r24, 0x0c	; 12
    7f64:	0f b6       	in	r0, 0x3f	; 63
    7f66:	f8 94       	cli
    7f68:	9e bf       	out	0x3e, r25	; 62
    7f6a:	0f be       	out	0x3f, r0	; 63
    7f6c:	8d bf       	out	0x3d, r24	; 61

				  CreateReport(strReport,PrintBuffer,&RepPos);
    7f6e:	ce 01       	movw	r24, r28
    7f70:	8b 55       	subi	r24, 0x5B	; 91
    7f72:	9f 4f       	sbci	r25, 0xFF	; 255
    7f74:	6f ec       	ldi	r22, 0xCF	; 207
    7f76:	75 e0       	ldi	r23, 0x05	; 5
    7f78:	42 e0       	ldi	r20, 0x02	; 2
    7f7a:	52 e0       	ldi	r21, 0x02	; 2
    7f7c:	0e 94 85 22 	call	0x450a	; 0x450a <CreateReport>
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
    7f80:	e3 94       	inc	r14
    7f82:	e4 e0       	ldi	r30, 0x04	; 4
    7f84:	f2 e0       	ldi	r31, 0x02	; 2
    7f86:	01 90       	ld	r0, Z+
    7f88:	00 20       	and	r0, r0
    7f8a:	e9 f7       	brne	.-6      	; 0x7f86 <systemGenerateReport+0x154a>
    7f8c:	31 97       	sbiw	r30, 0x01	; 1
    7f8e:	e4 50       	subi	r30, 0x04	; 4
    7f90:	f2 40       	sbci	r31, 0x02	; 2
    7f92:	ae 2c       	mov	r10, r14
    7f94:	bb 24       	eor	r11, r11
    7f96:	ae 16       	cp	r10, r30
    7f98:	bf 06       	cpc	r11, r31
    7f9a:	08 f4       	brcc	.+2      	; 0x7f9e <systemGenerateReport+0x1562>
    7f9c:	0f ce       	rjmp	.-994    	; 0x7bbc <systemGenerateReport+0x1180>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);

				  CreateReport(strReport,PrintBuffer,&RepPos);
               }
		  }
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7f9e:	87 e0       	ldi	r24, 0x07	; 7
    7fa0:	6f ec       	ldi	r22, 0xCF	; 207
    7fa2:	75 e0       	ldi	r23, 0x05	; 5
    7fa4:	41 e0       	ldi	r20, 0x01	; 1
    7fa6:	22 e0       	ldi	r18, 0x02	; 2
    7fa8:	32 e0       	ldi	r19, 0x02	; 2
    7faa:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    7fae:	8b e0       	ldi	r24, 0x0B	; 11
    7fb0:	6f ec       	ldi	r22, 0xCF	; 207
    7fb2:	75 e0       	ldi	r23, 0x05	; 5
    7fb4:	4a e2       	ldi	r20, 0x2A	; 42
    7fb6:	22 e0       	ldi	r18, 0x02	; 2
    7fb8:	32 e0       	ldi	r19, 0x02	; 2
    7fba:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    7fbe:	89 e0       	ldi	r24, 0x09	; 9
    7fc0:	6f ec       	ldi	r22, 0xCF	; 207
    7fc2:	75 e0       	ldi	r23, 0x05	; 5
    7fc4:	41 e0       	ldi	r20, 0x01	; 1
    7fc6:	22 e0       	ldi	r18, 0x02	; 2
    7fc8:	32 e0       	ldi	r19, 0x02	; 2
    7fca:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    7fce:	8c e0       	ldi	r24, 0x0C	; 12
    7fd0:	6f ec       	ldi	r22, 0xCF	; 207
    7fd2:	75 e0       	ldi	r23, 0x05	; 5
    7fd4:	41 e0       	ldi	r20, 0x01	; 1
    7fd6:	22 e0       	ldi	r18, 0x02	; 2
    7fd8:	32 e0       	ldi	r19, 0x02	; 2
    7fda:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
		  InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7fde:	8c e0       	ldi	r24, 0x0C	; 12
    7fe0:	6f ec       	ldi	r22, 0xCF	; 207
    7fe2:	75 e0       	ldi	r23, 0x05	; 5
    7fe4:	41 e0       	ldi	r20, 0x01	; 1
    7fe6:	22 e0       	ldi	r18, 0x02	; 2
    7fe8:	32 e0       	ldi	r19, 0x02	; 2
    7fea:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    7fee:	8c e0       	ldi	r24, 0x0C	; 12
    7ff0:	6f ec       	ldi	r22, 0xCF	; 207
    7ff2:	75 e0       	ldi	r23, 0x05	; 5
    7ff4:	41 e0       	ldi	r20, 0x01	; 1
    7ff6:	22 e0       	ldi	r18, 0x02	; 2
    7ff8:	32 e0       	ldi	r19, 0x02	; 2
    7ffa:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    7ffe:	8c e0       	ldi	r24, 0x0C	; 12
    8000:	6f ec       	ldi	r22, 0xCF	; 207
    8002:	75 e0       	ldi	r23, 0x05	; 5
    8004:	41 e0       	ldi	r20, 0x01	; 1
    8006:	22 e0       	ldi	r18, 0x02	; 2
    8008:	32 e0       	ldi	r19, 0x02	; 2
    800a:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    800e:	8c e0       	ldi	r24, 0x0C	; 12
    8010:	6f ec       	ldi	r22, 0xCF	; 207
    8012:	75 e0       	ldi	r23, 0x05	; 5
    8014:	41 e0       	ldi	r20, 0x01	; 1
    8016:	22 e0       	ldi	r18, 0x02	; 2
    8018:	32 e0       	ldi	r19, 0x02	; 2
    801a:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>
    801e:	8c e0       	ldi	r24, 0x0C	; 12
    8020:	6f ec       	ldi	r22, 0xCF	; 207
    8022:	75 e0       	ldi	r23, 0x05	; 5
    8024:	41 e0       	ldi	r20, 0x01	; 1
    8026:	22 e0       	ldi	r18, 0x02	; 2
    8028:	32 e0       	ldi	r19, 0x02	; 2
    802a:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <InserBorder>


          cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    802e:	80 e3       	ldi	r24, 0x30	; 48
    8030:	80 93 cb 01 	sts	0x01CB, r24
		  LengthMessage81=RepPos+1;
    8034:	80 91 02 02 	lds	r24, 0x0202
    8038:	90 91 03 02 	lds	r25, 0x0203
    803c:	01 96       	adiw	r24, 0x01	; 1
    803e:	90 93 a1 01 	sts	0x01A1, r25
    8042:	80 93 a0 01 	sts	0x01A0, r24
		  IsFreePrinting=True;
    8046:	81 e0       	ldi	r24, 0x01	; 1
    8048:	80 93 bf 01 	sts	0x01BF, r24
	      IsBusyFreePrinting=True; 
    804c:	80 93 ca 01 	sts	0x01CA, r24
         	       
	      stGenerateReport=grWaitPrinted3;
    8050:	8b e0       	ldi	r24, 0x0B	; 11
    8052:	05 c0       	rjmp	.+10     	; 0x805e <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted3:
          if (IsBusyFreePrinting==False)stGenerateReport=grFinishGenerateReport;
    8054:	80 91 ca 01 	lds	r24, 0x01CA
    8058:	88 23       	and	r24, r24
    805a:	49 f4       	brne	.+18     	; 0x806e <systemGenerateReport+0x1632>
    805c:	8c e0       	ldi	r24, 0x0C	; 12
    805e:	80 93 14 02 	sts	0x0214, r24
    8062:	05 c0       	rjmp	.+10     	; 0x806e <systemGenerateReport+0x1632>
	      break;
     case grFinishGenerateReport:
	      IsFinishPrintingTotalizer=True;
    8064:	81 e0       	ldi	r24, 0x01	; 1
    8066:	80 93 9a 01 	sts	0x019A, r24
          stGenerateReport=grScanAction;
    806a:	10 92 14 02 	sts	0x0214, r1
	      break;
	 }
}
    806e:	c8 50       	subi	r28, 0x08	; 8
    8070:	df 4f       	sbci	r29, 0xFF	; 255
    8072:	0f b6       	in	r0, 0x3f	; 63
    8074:	f8 94       	cli
    8076:	de bf       	out	0x3e, r29	; 62
    8078:	0f be       	out	0x3f, r0	; 63
    807a:	cd bf       	out	0x3d, r28	; 61
    807c:	cf 91       	pop	r28
    807e:	df 91       	pop	r29
    8080:	1f 91       	pop	r17
    8082:	0f 91       	pop	r16
    8084:	ff 90       	pop	r15
    8086:	ef 90       	pop	r14
    8088:	df 90       	pop	r13
    808a:	cf 90       	pop	r12
    808c:	bf 90       	pop	r11
    808e:	af 90       	pop	r10
    8090:	9f 90       	pop	r9
    8092:	8f 90       	pop	r8
    8094:	7f 90       	pop	r7
    8096:	6f 90       	pop	r6
    8098:	5f 90       	pop	r5
    809a:	4f 90       	pop	r4
    809c:	3f 90       	pop	r3
    809e:	2f 90       	pop	r2
    80a0:	08 95       	ret

000080a2 <UpdateCardID>:
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 


void UpdateCardID(){
    80a2:	cf 93       	push	r28
    80a4:	df 93       	push	r29
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
    80a6:	e4 ea       	ldi	r30, 0xA4	; 164
    80a8:	ff e0       	ldi	r31, 0x0F	; 15
    80aa:	01 90       	ld	r0, Z+
    80ac:	00 20       	and	r0, r0
    80ae:	e9 f7       	brne	.-6      	; 0x80aa <UpdateCardID+0x8>
    80b0:	31 97       	sbiw	r30, 0x01	; 1
    80b2:	e4 5a       	subi	r30, 0xA4	; 164
    80b4:	ff 40       	sbci	r31, 0x0F	; 15
    80b6:	af ee       	ldi	r26, 0xEF	; 239
    80b8:	be e0       	ldi	r27, 0x0E	; 14
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 


void UpdateCardID(){
    80ba:	f0 e0       	ldi	r31, 0x00	; 0
    80bc:	ef 01       	movw	r28, r30
    80be:	c0 57       	subi	r28, 0x70	; 112
    80c0:	d0 4f       	sbci	r29, 0xF0	; 240
    80c2:	20 e0       	ldi	r18, 0x00	; 0
    80c4:	30 e0       	ldi	r19, 0x00	; 0
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
	    if (i<(20-LengthID))strCardID[i]=' ';
    80c6:	44 e1       	ldi	r20, 0x14	; 20
    80c8:	50 e0       	ldi	r21, 0x00	; 0
    80ca:	4e 1b       	sub	r20, r30
    80cc:	5f 0b       	sbc	r21, r31
    80ce:	90 e2       	ldi	r25, 0x20	; 32
    80d0:	24 17       	cp	r18, r20
    80d2:	35 07       	cpc	r19, r21
    80d4:	14 f4       	brge	.+4      	; 0x80da <UpdateCardID+0x38>
    80d6:	9c 93       	st	X, r25
    80d8:	02 c0       	rjmp	.+4      	; 0x80de <UpdateCardID+0x3c>
		else strCardID[i]=strRFID[i-(20-LengthID)];
    80da:	88 81       	ld	r24, Y
    80dc:	8c 93       	st	X, r24
    80de:	2f 5f       	subi	r18, 0xFF	; 255
    80e0:	3f 4f       	sbci	r19, 0xFF	; 255
    80e2:	11 96       	adiw	r26, 0x01	; 1
    80e4:	21 96       	adiw	r28, 0x01	; 1


void UpdateCardID(){
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
    80e6:	24 31       	cpi	r18, 0x14	; 20
    80e8:	31 05       	cpc	r19, r1
    80ea:	91 f7       	brne	.-28     	; 0x80d0 <UpdateCardID+0x2e>
	    if (i<(20-LengthID))strCardID[i]=' ';
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;
    80ec:	10 92 03 0f 	sts	0x0F03, r1

}
    80f0:	df 91       	pop	r29
    80f2:	cf 91       	pop	r28
    80f4:	08 95       	ret

000080f6 <GenerateTransactionNum>:
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    80f6:	cf 92       	push	r12
    80f8:	df 92       	push	r13
    80fa:	ef 92       	push	r14
    80fc:	ff 92       	push	r15
    80fe:	0f 93       	push	r16
    8100:	1f 93       	push	r17
    8102:	df 93       	push	r29
    8104:	cf 93       	push	r28
    8106:	cd b7       	in	r28, 0x3d	; 61
    8108:	de b7       	in	r29, 0x3e	; 62
    810a:	27 97       	sbiw	r28, 0x07	; 7
    810c:	0f b6       	in	r0, 0x3f	; 63
    810e:	f8 94       	cli
    8110:	de bf       	out	0x3e, r29	; 62
    8112:	0f be       	out	0x3f, r0	; 63
    8114:	cd bf       	out	0x3d, r28	; 61
    8116:	6c 01       	movw	r12, r24
    8118:	fe 01       	movw	r30, r28
    811a:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    811c:	ce 01       	movw	r24, r28
    811e:	08 96       	adiw	r24, 0x08	; 8
	     strMemory[i]=data;
    8120:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8122:	e8 17       	cp	r30, r24
    8124:	f9 07       	cpc	r31, r25
    8126:	e1 f7       	brne	.-8      	; 0x8120 <GenerateTransactionNum+0x2a>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8128:	8e 01       	movw	r16, r28
    812a:	0f 5f       	subi	r16, 0xFF	; 255
    812c:	1f 4f       	sbci	r17, 0xFF	; 255
    812e:	c8 01       	movw	r24, r16
    8130:	68 e3       	ldi	r22, 0x38	; 56
    8132:	71 e0       	ldi	r23, 0x01	; 1
    8134:	47 e0       	ldi	r20, 0x07	; 7
    8136:	50 e0       	ldi	r21, 0x00	; 0
    8138:	28 ef       	ldi	r18, 0xF8	; 248
    813a:	32 e1       	ldi	r19, 0x12	; 18
    813c:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
     char i,PTransNum[7],cNum,xNum=0,xAdd=0,Length=0;
	 FillChar(PTransNum,sizeof(PTransNum),0);//"999999"->"000000"
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);
    8140:	f8 01       	movw	r30, r16
    8142:	01 90       	ld	r0, Z+
    8144:	00 20       	and	r0, r0
    8146:	e9 f7       	brne	.-6      	; 0x8142 <GenerateTransactionNum+0x4c>
    8148:	31 97       	sbiw	r30, 0x01	; 1
    814a:	e0 1b       	sub	r30, r16
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    814c:	f0 e0       	ldi	r31, 0x00	; 0
    814e:	0e 0f       	add	r16, r30
    8150:	1f 1f       	adc	r17, r31
    8152:	31 97       	sbiw	r30, 0x01	; 1
    8154:	76 01       	movw	r14, r12
    8156:	ee 0e       	add	r14, r30
    8158:	ff 1e       	adc	r15, r31
    815a:	31 96       	adiw	r30, 0x01	; 1
    815c:	61 e0       	ldi	r22, 0x01	; 1
    815e:	19 c0       	rjmp	.+50     	; 0x8192 <GenerateTransactionNum+0x9c>
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
	     xNum=PTransNum[Length-i-1]-'0';		 
		 cNum='0'+((xNum+xAdd)%10);
    8160:	d8 01       	movw	r26, r16
    8162:	2c 91       	ld	r18, X
    8164:	20 53       	subi	r18, 0x30	; 48
    8166:	30 e0       	ldi	r19, 0x00	; 0
    8168:	26 0f       	add	r18, r22
    816a:	31 1d       	adc	r19, r1
    816c:	c9 01       	movw	r24, r18
    816e:	6a e0       	ldi	r22, 0x0A	; 10
    8170:	70 e0       	ldi	r23, 0x00	; 0
    8172:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    8176:	48 2f       	mov	r20, r24
    8178:	40 5d       	subi	r20, 0xD0	; 208
		 xAdd=((xNum+xAdd)/10);
    817a:	c9 01       	movw	r24, r18
    817c:	6a e0       	ldi	r22, 0x0A	; 10
    817e:	70 e0       	ldi	r23, 0x00	; 0
    8180:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
		 PTransNum[Length-i-1]=cNum;
    8184:	d8 01       	movw	r26, r16
    8186:	4c 93       	st	X, r20
		 sTransNumber[Length-i-1]=cNum;
    8188:	d7 01       	movw	r26, r14
    818a:	4c 93       	st	X, r20
    818c:	08 94       	sec
    818e:	e1 08       	sbc	r14, r1
    8190:	f1 08       	sbc	r15, r1
    8192:	01 50       	subi	r16, 0x01	; 1
    8194:	10 40       	sbci	r17, 0x00	; 0
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
    8196:	0c 17       	cp	r16, r28
    8198:	1d 07       	cpc	r17, r29
    819a:	11 f7       	brne	.-60     	; 0x8160 <GenerateTransactionNum+0x6a>
		 cNum='0'+((xNum+xAdd)%10);
		 xAdd=((xNum+xAdd)/10);
		 PTransNum[Length-i-1]=cNum;
		 sTransNumber[Length-i-1]=cNum;
	 }
	 sTransNumber[Length]=0;
    819c:	ce 0e       	add	r12, r30
    819e:	df 1e       	adc	r13, r31
    81a0:	d6 01       	movw	r26, r12
    81a2:	1c 92       	st	X, r1
	 PTransNum[Length]=0;
    81a4:	be 01       	movw	r22, r28
    81a6:	6f 5f       	subi	r22, 0xFF	; 255
    81a8:	7f 4f       	sbci	r23, 0xFF	; 255
    81aa:	e6 0f       	add	r30, r22
    81ac:	f7 1f       	adc	r31, r23
    81ae:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    81b0:	88 e3       	ldi	r24, 0x38	; 56
    81b2:	91 e0       	ldi	r25, 0x01	; 1
    81b4:	47 e0       	ldi	r20, 0x07	; 7
    81b6:	50 e0       	ldi	r21, 0x00	; 0
    81b8:	20 e0       	ldi	r18, 0x00	; 0
    81ba:	33 e1       	ldi	r19, 0x13	; 19
    81bc:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}
    81c0:	27 96       	adiw	r28, 0x07	; 7
    81c2:	0f b6       	in	r0, 0x3f	; 63
    81c4:	f8 94       	cli
    81c6:	de bf       	out	0x3e, r29	; 62
    81c8:	0f be       	out	0x3f, r0	; 63
    81ca:	cd bf       	out	0x3d, r28	; 61
    81cc:	cf 91       	pop	r28
    81ce:	df 91       	pop	r29
    81d0:	1f 91       	pop	r17
    81d2:	0f 91       	pop	r16
    81d4:	ff 90       	pop	r15
    81d6:	ef 90       	pop	r14
    81d8:	df 90       	pop	r13
    81da:	cf 90       	pop	r12
    81dc:	08 95       	ret

000081de <GetParameter>:
	}
  return  PosFound;
}


void GetParameter(char *GFlow,char FLength,char *GCmd,char *GPumpID, char *GeniCSum){
    81de:	8f 92       	push	r8
    81e0:	9f 92       	push	r9
    81e2:	af 92       	push	r10
    81e4:	bf 92       	push	r11
    81e6:	cf 92       	push	r12
    81e8:	df 92       	push	r13
    81ea:	ef 92       	push	r14
    81ec:	ff 92       	push	r15
    81ee:	0f 93       	push	r16
    81f0:	1f 93       	push	r17
    81f2:	df 93       	push	r29
    81f4:	cf 93       	push	r28
    81f6:	cd b7       	in	r28, 0x3d	; 61
    81f8:	de b7       	in	r29, 0x3e	; 62
    81fa:	a7 97       	sbiw	r28, 0x27	; 39
    81fc:	0f b6       	in	r0, 0x3f	; 63
    81fe:	f8 94       	cli
    8200:	de bf       	out	0x3e, r29	; 62
    8202:	0f be       	out	0x3f, r0	; 63
    8204:	cd bf       	out	0x3d, r28	; 61
    8206:	79 01       	movw	r14, r18
    8208:	48 01       	movw	r8, r16
    820a:	e6 2f       	mov	r30, r22
    820c:	f0 e0       	ldi	r31, 0x00	; 0
    820e:	31 97       	sbiw	r30, 0x01	; 1
    8210:	e8 0f       	add	r30, r24
    8212:	f9 1f       	adc	r31, r25
    8214:	9e 01       	movw	r18, r28
    8216:	26 5f       	subi	r18, 0xF6	; 246
    8218:	3f 4f       	sbci	r19, 0xFF	; 255
    821a:	d9 01       	movw	r26, r18
    821c:	03 c0       	rjmp	.+6      	; 0x8224 <GetParameter+0x46>
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
	     SGeniusFlow[i]=GFlow[FLength-i-1];
    821e:	80 81       	ld	r24, Z
    8220:	8d 93       	st	X+, r24
    8222:	31 97       	sbiw	r30, 0x01	; 1
char SGeniusFlow[30];
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
    8224:	8a 2f       	mov	r24, r26
    8226:	82 1b       	sub	r24, r18
    8228:	86 17       	cp	r24, r22
    822a:	c8 f3       	brcs	.-14     	; 0x821e <GetParameter+0x40>
	     SGeniusFlow[i]=GFlow[FLength-i-1];
	 }SGeniusFlow[FLength]=0;
    822c:	c6 2e       	mov	r12, r22
    822e:	dd 24       	eor	r13, r13
    8230:	ea e0       	ldi	r30, 0x0A	; 10
    8232:	ae 2e       	mov	r10, r30
    8234:	b1 2c       	mov	r11, r1
    8236:	ac 0e       	add	r10, r28
    8238:	bd 1e       	adc	r11, r29
    823a:	f5 01       	movw	r30, r10
    823c:	ec 0d       	add	r30, r12
    823e:	fd 1d       	adc	r31, r13
    8240:	10 82       	st	Z, r1

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
    8242:	8a 85       	ldd	r24, Y+10	; 0x0a
    8244:	fa 01       	movw	r30, r20
    8246:	80 83       	st	Z, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8248:	8b 85       	ldd	r24, Y+11	; 0x0b
    824a:	89 83       	std	Y+1, r24	; 0x01
    824c:	8c 85       	ldd	r24, Y+12	; 0x0c
    824e:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    8250:	1b 82       	std	Y+3, r1	; 0x03
	 }SGeniusFlow[FLength]=0;

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
	 StrPosCopy(SGeniusFlow,sPumpID,1,2);
	 xPumpID=atoi(sPumpID);
    8252:	ce 01       	movw	r24, r28
    8254:	01 96       	adiw	r24, 0x01	; 1
    8256:	0e 94 3d b5 	call	0x16a7a	; 0x16a7a <atoi>
	 *GPumpID=xPumpID;
    825a:	f7 01       	movw	r30, r14
    825c:	80 83       	st	Z, r24
	 sprintf_P(strSub,PSTR(":"));
    825e:	00 d0       	rcall	.+0      	; 0x8260 <GetParameter+0x82>
    8260:	00 d0       	rcall	.+0      	; 0x8262 <GetParameter+0x84>
    8262:	77 e0       	ldi	r23, 0x07	; 7
    8264:	e7 2e       	mov	r14, r23
    8266:	f1 2c       	mov	r15, r1
    8268:	ec 0e       	add	r14, r28
    826a:	fd 1e       	adc	r15, r29
    826c:	ed b7       	in	r30, 0x3d	; 61
    826e:	fe b7       	in	r31, 0x3e	; 62
    8270:	f2 82       	std	Z+2, r15	; 0x02
    8272:	e1 82       	std	Z+1, r14	; 0x01
    8274:	8e e7       	ldi	r24, 0x7E	; 126
    8276:	93 e0       	ldi	r25, 0x03	; 3
    8278:	94 83       	std	Z+4, r25	; 0x04
    827a:	83 83       	std	Z+3, r24	; 0x03
    827c:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	 if (Pos(strSub,SGeniusFlow)<FLength){
    8280:	0f 90       	pop	r0
    8282:	0f 90       	pop	r0
    8284:	0f 90       	pop	r0
    8286:	0f 90       	pop	r0
    8288:	c7 01       	movw	r24, r14
    828a:	b5 01       	movw	r22, r10
    828c:	0e 94 4e 22 	call	0x449c	; 0x449c <Pos>
    8290:	8c 15       	cp	r24, r12
    8292:	9d 05       	cpc	r25, r13
    8294:	4c f5       	brge	.+82     	; 0x82e8 <GetParameter+0x10a>
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
    8296:	c7 01       	movw	r24, r14
    8298:	b5 01       	movw	r22, r10
    829a:	0e 94 4e 22 	call	0x449c	; 0x449c <Pos>
    829e:	8c 01       	movw	r16, r24
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
    82a0:	c7 01       	movw	r24, r14
    82a2:	b5 01       	movw	r22, r10
    82a4:	0e 94 4e 22 	call	0x449c	; 0x449c <Pos>
    82a8:	a6 01       	movw	r20, r12
    82aa:	40 1b       	sub	r20, r16
    82ac:	51 0b       	sbc	r21, r17
    82ae:	d5 01       	movw	r26, r10
    82b0:	a8 0f       	add	r26, r24
    82b2:	b9 1f       	adc	r27, r25
    82b4:	20 e0       	ldi	r18, 0x00	; 0
    82b6:	30 e0       	ldi	r19, 0x00	; 0
    82b8:	be 01       	movw	r22, r28
    82ba:	6c 5f       	subi	r22, 0xFC	; 252
    82bc:	7f 4f       	sbci	r23, 0xFF	; 255
    82be:	07 c0       	rjmp	.+14     	; 0x82ce <GetParameter+0xf0>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    82c0:	fb 01       	movw	r30, r22
    82c2:	e2 0f       	add	r30, r18
    82c4:	f3 1f       	adc	r31, r19
    82c6:	8c 91       	ld	r24, X
    82c8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    82ca:	2f 5f       	subi	r18, 0xFF	; 255
    82cc:	3f 4f       	sbci	r19, 0xFF	; 255
    82ce:	11 96       	adiw	r26, 0x01	; 1
    82d0:	24 17       	cp	r18, r20
    82d2:	35 07       	cpc	r19, r21
    82d4:	a8 f3       	brcs	.-22     	; 0x82c0 <GetParameter+0xe2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    82d6:	46 0f       	add	r20, r22
    82d8:	57 1f       	adc	r21, r23
    82da:	fa 01       	movw	r30, r20
    82dc:	10 82       	st	Z, r1
	 *GPumpID=xPumpID;
	 sprintf_P(strSub,PSTR(":"));
	 if (Pos(strSub,SGeniusFlow)<FLength){
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
		 xCsum=atoi(sCSum);
    82de:	cb 01       	movw	r24, r22
    82e0:	0e 94 3d b5 	call	0x16a7a	; 0x16a7a <atoi>
	     *GeniCSum=xCsum;
    82e4:	f4 01       	movw	r30, r8
    82e6:	80 83       	st	Z, r24
	 sprintf_P(strSend,PSTR("%d"),xPumpID);
	 _uart_print(1,1,strSend);
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 _uart_print(1,1,strSend);
*/
}
    82e8:	a7 96       	adiw	r28, 0x27	; 39
    82ea:	0f b6       	in	r0, 0x3f	; 63
    82ec:	f8 94       	cli
    82ee:	de bf       	out	0x3e, r29	; 62
    82f0:	0f be       	out	0x3f, r0	; 63
    82f2:	cd bf       	out	0x3d, r28	; 61
    82f4:	cf 91       	pop	r28
    82f6:	df 91       	pop	r29
    82f8:	1f 91       	pop	r17
    82fa:	0f 91       	pop	r16
    82fc:	ff 90       	pop	r15
    82fe:	ef 90       	pop	r14
    8300:	df 90       	pop	r13
    8302:	cf 90       	pop	r12
    8304:	bf 90       	pop	r11
    8306:	af 90       	pop	r10
    8308:	9f 90       	pop	r9
    830a:	8f 90       	pop	r8
    830c:	08 95       	ret

0000830e <GeniusProtocol>:
   return Result;	 
}

//enum eGeniusProtocolCommand{GP_PUMP_STATUS,GP_PUMP_LAST_TRANSACTION,GP_PUMP_STOP,GP_PUMP_RESUME,GP_PUMP_PRESET};

void GeniusProtocol(char dataIn){
    830e:	ff 92       	push	r15
    8310:	0f 93       	push	r16
    8312:	1f 93       	push	r17
    8314:	df 93       	push	r29
    8316:	cf 93       	push	r28
    8318:	cd b7       	in	r28, 0x3d	; 61
    831a:	de b7       	in	r29, 0x3e	; 62
    831c:	67 97       	sbiw	r28, 0x17	; 23
    831e:	0f b6       	in	r0, 0x3f	; 63
    8320:	f8 94       	cli
    8322:	de bf       	out	0x3e, r29	; 62
    8324:	0f be       	out	0x3f, r0	; 63
    8326:	cd bf       	out	0x3d, r28	; 61
    8328:	f8 2e       	mov	r15, r24
	 char i,GeniCmd,GeniPumpID,GeniCSum;//,sCmd[7];
	 char strSend[20];

    //_uart(1,1,dataIn);

	if (dataIn==0x0D){	
    832a:	8d e0       	ldi	r24, 0x0D	; 13
    832c:	f8 16       	cp	r15, r24
    832e:	09 f0       	breq	.+2      	; 0x8332 <GeniusProtocol+0x24>
    8330:	45 c0       	rjmp	.+138    	; 0x83bc <GeniusProtocol+0xae>
	    GetParameter(Geniflow,FlowLength,&GeniCmd,&GeniPumpID,&GeniCSum);
    8332:	8f ed       	ldi	r24, 0xDF	; 223
    8334:	91 e0       	ldi	r25, 0x01	; 1
    8336:	60 91 de 01 	lds	r22, 0x01DE
    833a:	ae 01       	movw	r20, r28
    833c:	4f 5f       	subi	r20, 0xFF	; 255
    833e:	5f 4f       	sbci	r21, 0xFF	; 255
    8340:	9e 01       	movw	r18, r28
    8342:	2e 5f       	subi	r18, 0xFE	; 254
    8344:	3f 4f       	sbci	r19, 0xFF	; 255
    8346:	8e 01       	movw	r16, r28
    8348:	0d 5f       	subi	r16, 0xFD	; 253
    834a:	1f 4f       	sbci	r17, 0xFF	; 255
    834c:	0e 94 ef 40 	call	0x81de	; 0x81de <GetParameter>
		FlowLength=0;
    8350:	10 92 de 01 	sts	0x01DE, r1
		IsGeniusFlow=False;
    8354:	10 92 dd 01 	sts	0x01DD, r1
		FillChar(strSend,0,sizeof(strSend));
		sprintf_P(strSend,PSTR("%c%.2d:"),GeniCmd,GeniPumpID);
    8358:	ad b7       	in	r26, 0x3d	; 61
    835a:	be b7       	in	r27, 0x3e	; 62
    835c:	18 97       	sbiw	r26, 0x08	; 8
    835e:	0f b6       	in	r0, 0x3f	; 63
    8360:	f8 94       	cli
    8362:	be bf       	out	0x3e, r27	; 62
    8364:	0f be       	out	0x3f, r0	; 63
    8366:	ad bf       	out	0x3d, r26	; 61
    8368:	ed b7       	in	r30, 0x3d	; 61
    836a:	fe b7       	in	r31, 0x3e	; 62
    836c:	31 96       	adiw	r30, 0x01	; 1
    836e:	8e 01       	movw	r16, r28
    8370:	0c 5f       	subi	r16, 0xFC	; 252
    8372:	1f 4f       	sbci	r17, 0xFF	; 255
    8374:	12 96       	adiw	r26, 0x02	; 2
    8376:	1c 93       	st	X, r17
    8378:	0e 93       	st	-X, r16
    837a:	11 97       	sbiw	r26, 0x01	; 1
    837c:	80 e7       	ldi	r24, 0x70	; 112
    837e:	93 e0       	ldi	r25, 0x03	; 3
    8380:	93 83       	std	Z+3, r25	; 0x03
    8382:	82 83       	std	Z+2, r24	; 0x02
    8384:	89 81       	ldd	r24, Y+1	; 0x01
    8386:	84 83       	std	Z+4, r24	; 0x04
    8388:	15 82       	std	Z+5, r1	; 0x05
    838a:	8a 81       	ldd	r24, Y+2	; 0x02
    838c:	86 83       	std	Z+6, r24	; 0x06
    838e:	17 82       	std	Z+7, r1	; 0x07
    8390:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		//_uart_print(1,1,strSend);


		if ((SumChecksum(strSend))==GeniCSum){
    8394:	8d b7       	in	r24, 0x3d	; 61
    8396:	9e b7       	in	r25, 0x3e	; 62
    8398:	08 96       	adiw	r24, 0x08	; 8
    839a:	0f b6       	in	r0, 0x3f	; 63
    839c:	f8 94       	cli
    839e:	9e bf       	out	0x3e, r25	; 62
    83a0:	0f be       	out	0x3f, r0	; 63
    83a2:	8d bf       	out	0x3d, r24	; 61
    83a4:	c8 01       	movw	r24, r16
    83a6:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <SumChecksum>
    83aa:	9b 81       	ldd	r25, Y+3	; 0x03
    83ac:	89 17       	cp	r24, r25
    83ae:	31 f4       	brne	.+12     	; 0x83bc <GeniusProtocol+0xae>
		     switch(GeniCmd){
    83b0:	89 81       	ldd	r24, Y+1	; 0x01
    83b2:	84 35       	cpi	r24, 0x54	; 84
    83b4:	19 f4       	brne	.+6      	; 0x83bc <GeniusProtocol+0xae>
			 case 'C'://PumpStatus
			      GeniusSendPumpStatus(GeniPumpID);
			      break;
             case 'T'://Transaction Request: T01:239<0D>
			      GeniusSendLastTransaction(GeniPumpID);
    83b6:	8a 81       	ldd	r24, Y+2	; 0x02
    83b8:	0e 94 c2 2e 	call	0x5d84	; 0x5d84 <GeniusSendLastTransaction>
    83bc:	e1 ef       	ldi	r30, 0xF1	; 241
    83be:	f1 e0       	ldi	r31, 0x01	; 1
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
	    Geniflow[i]=Geniflow[i-1];	
    83c0:	80 81       	ld	r24, Z
    83c2:	81 83       	std	Z+1, r24	; 0x01
    83c4:	31 97       	sbiw	r30, 0x01	; 1
			      break;
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
    83c6:	91 e0       	ldi	r25, 0x01	; 1
    83c8:	ee 3d       	cpi	r30, 0xDE	; 222
    83ca:	f9 07       	cpc	r31, r25
    83cc:	c9 f7       	brne	.-14     	; 0x83c0 <GeniusProtocol+0xb2>
	    Geniflow[i]=Geniflow[i-1];	
	}Geniflow[0]=dataIn;
    83ce:	f1 82       	std	Z+1, r15	; 0x01

	if (IsGeniusCommand(dataIn)==True)IsGeniusFlow=True;
    83d0:	8f 2d       	mov	r24, r15
    83d2:	0e 94 09 22 	call	0x4412	; 0x4412 <IsGeniusCommand>
    83d6:	81 30       	cpi	r24, 0x01	; 1
    83d8:	11 f4       	brne	.+4      	; 0x83de <GeniusProtocol+0xd0>
    83da:	80 93 dd 01 	sts	0x01DD, r24
	if (IsGeniusFlow==True)FlowLength++;
    83de:	80 91 dd 01 	lds	r24, 0x01DD
    83e2:	81 30       	cpi	r24, 0x01	; 1
    83e4:	29 f4       	brne	.+10     	; 0x83f0 <GeniusProtocol+0xe2>
    83e6:	80 91 de 01 	lds	r24, 0x01DE
    83ea:	8f 5f       	subi	r24, 0xFF	; 255
    83ec:	80 93 de 01 	sts	0x01DE, r24
	Geniflow[3]=Geniflow[2];
	Geniflow[2]=Geniflow[1];
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}
    83f0:	67 96       	adiw	r28, 0x17	; 23
    83f2:	0f b6       	in	r0, 0x3f	; 63
    83f4:	f8 94       	cli
    83f6:	de bf       	out	0x3e, r29	; 62
    83f8:	0f be       	out	0x3f, r0	; 63
    83fa:	cd bf       	out	0x3d, r28	; 61
    83fc:	cf 91       	pop	r28
    83fe:	df 91       	pop	r29
    8400:	1f 91       	pop	r17
    8402:	0f 91       	pop	r16
    8404:	ff 90       	pop	r15
    8406:	08 95       	ret

00008408 <__vector_30>:
}

// NotSuccessful! 


ISR(USART1_RX_vect){
    8408:	1f 92       	push	r1
    840a:	0f 92       	push	r0
    840c:	0f b6       	in	r0, 0x3f	; 63
    840e:	0f 92       	push	r0
    8410:	0b b6       	in	r0, 0x3b	; 59
    8412:	0f 92       	push	r0
    8414:	11 24       	eor	r1, r1
    8416:	1f 93       	push	r17
    8418:	2f 93       	push	r18
    841a:	3f 93       	push	r19
    841c:	4f 93       	push	r20
    841e:	5f 93       	push	r21
    8420:	6f 93       	push	r22
    8422:	7f 93       	push	r23
    8424:	8f 93       	push	r24
    8426:	9f 93       	push	r25
    8428:	af 93       	push	r26
    842a:	bf 93       	push	r27
    842c:	ef 93       	push	r30
    842e:	ff 93       	push	r31
	char dataTX1,serialSend[12];
	static char IsAdvanZProtocol=False;
	unsigned int i;
	dataTX1 = UDR1;
    8430:	10 91 9c 00 	lds	r17, 0x009C

	//NewPacket
	if (IsNewPacket==True){
    8434:	80 91 9b 01 	lds	r24, 0x019B
    8438:	81 30       	cpi	r24, 0x01	; 1
    843a:	51 f4       	brne	.+20     	; 0x8450 <__vector_30+0x48>
	    if (dataTX1==0x01){
    843c:	11 30       	cpi	r17, 0x01	; 1
    843e:	41 f4       	brne	.+16     	; 0x8450 <__vector_30+0x48>
		    char_count=0;
    8440:	10 92 9d 01 	sts	0x019D, r1
    8444:	10 92 9c 01 	sts	0x019C, r1
            IsNewPacket=False;
    8448:	10 92 9b 01 	sts	0x019B, r1
			IsAdvanZProtocol=True;
    844c:	10 93 a5 03 	sts	0x03A5, r17
			}
	}
    //Save data to buffer if AdvanZ MSG
	if (IsAdvanZProtocol==True){
    8450:	80 91 a5 03 	lds	r24, 0x03A5
    8454:	81 30       	cpi	r24, 0x01	; 1
    8456:	69 f4       	brne	.+26     	; 0x8472 <__vector_30+0x6a>
	    rcv_trans[char_count]=dataTX1;
    8458:	80 91 9c 01 	lds	r24, 0x019C
    845c:	90 91 9d 01 	lds	r25, 0x019D
    8460:	fc 01       	movw	r30, r24
    8462:	ed 57       	subi	r30, 0x7D	; 125
    8464:	f3 4f       	sbci	r31, 0xF3	; 243
    8466:	10 83       	st	Z, r17
	    char_count++; 
    8468:	01 96       	adiw	r24, 0x01	; 1
    846a:	90 93 9d 01 	sts	0x019D, r25
    846e:	80 93 9c 01 	sts	0x019C, r24
	}

	if (dataTX1==0x02){
    8472:	12 30       	cpi	r17, 0x02	; 2
    8474:	b1 f5       	brne	.+108    	; 0x84e2 <__vector_30+0xda>
		transLength=char_count;
    8476:	60 91 9c 01 	lds	r22, 0x019C
    847a:	70 91 9d 01 	lds	r23, 0x019D
    847e:	70 93 9f 01 	sts	0x019F, r23
    8482:	60 93 9e 01 	sts	0x019E, r22
		char_count=0;
    8486:	10 92 9d 01 	sts	0x019D, r1
    848a:	10 92 9c 01 	sts	0x019C, r1
		IsAdvanZProtocol=False;
    848e:	10 92 a5 03 	sts	0x03A5, r1

		//MessageIdentification
        if (MsgCode!=MSG_NONE)MsgCode=MSG_NONE;
	    MsgCode=((rcv_trans[35]-'0')*10)+(rcv_trans[36]-'0');
    8492:	20 91 a7 0c 	lds	r18, 0x0CA7
    8496:	20 51       	subi	r18, 0x10	; 16
    8498:	80 91 a6 0c 	lds	r24, 0x0CA6
    849c:	3a e0       	ldi	r19, 0x0A	; 10
    849e:	83 9f       	mul	r24, r19
    84a0:	c0 01       	movw	r24, r0
    84a2:	11 24       	eor	r1, r1
    84a4:	28 0f       	add	r18, r24
    84a6:	20 93 24 01 	sts	0x0124, r18
     
	    IdentifyMessage(rcv_trans[0],transLength);
    84aa:	80 91 83 0c 	lds	r24, 0x0C83
    84ae:	0e 94 ef 18 	call	0x31de	; 0x31de <IdentifyMessage>
		IsNewPacket=True;
    84b2:	21 e0       	ldi	r18, 0x01	; 1
    84b4:	20 93 9b 01 	sts	0x019B, r18

		if ((rcv_trans[35]=='8')&&(rcv_trans[36]=='1')){
    84b8:	80 91 a6 0c 	lds	r24, 0x0CA6
    84bc:	88 33       	cpi	r24, 0x38	; 56
    84be:	89 f4       	brne	.+34     	; 0x84e2 <__vector_30+0xda>
    84c0:	80 91 a7 0c 	lds	r24, 0x0CA7
    84c4:	81 33       	cpi	r24, 0x31	; 49
    84c6:	69 f4       	brne	.+26     	; 0x84e2 <__vector_30+0xda>
		   LengthMessage81=transLength-12-44;
    84c8:	80 91 9e 01 	lds	r24, 0x019E
    84cc:	90 91 9f 01 	lds	r25, 0x019F
    84d0:	c8 97       	sbiw	r24, 0x38	; 56
    84d2:	90 93 a1 01 	sts	0x01A1, r25
    84d6:	80 93 a0 01 	sts	0x01A0, r24
		   IsMessage81=True;
    84da:	20 93 bd 01 	sts	0x01BD, r18
		   IsCompleteFilling=True;
    84de:	20 93 c0 01 	sts	0x01C0, r18
		

	}//Endif(dataTX1==0x02)

	//ConfigDetection: iConf?<0D><0A>
	if (IsNewPacket!=True)ConfigProtocol(dataTX1);
    84e2:	80 91 9b 01 	lds	r24, 0x019B
    84e6:	81 30       	cpi	r24, 0x01	; 1
    84e8:	19 f0       	breq	.+6      	; 0x84f0 <__vector_30+0xe8>
    84ea:	81 2f       	mov	r24, r17
    84ec:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <ConfigProtocol>
	//GeniusDetection: [CMD][MSG][CSUM][0x0D]
	if ((IFType==IT_STANDALONE)&&(IsNewPacket!=True))GeniusProtocol(dataTX1);		
    84f0:	80 91 10 01 	lds	r24, 0x0110
    84f4:	82 30       	cpi	r24, 0x02	; 2
    84f6:	39 f4       	brne	.+14     	; 0x8506 <__vector_30+0xfe>
    84f8:	80 91 9b 01 	lds	r24, 0x019B
    84fc:	81 30       	cpi	r24, 0x01	; 1
    84fe:	19 f0       	breq	.+6      	; 0x8506 <__vector_30+0xfe>
    8500:	81 2f       	mov	r24, r17
    8502:	0e 94 87 41 	call	0x830e	; 0x830e <GeniusProtocol>
    //_uart(0,1,dataTX1);
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}
    8506:	ff 91       	pop	r31
    8508:	ef 91       	pop	r30
    850a:	bf 91       	pop	r27
    850c:	af 91       	pop	r26
    850e:	9f 91       	pop	r25
    8510:	8f 91       	pop	r24
    8512:	7f 91       	pop	r23
    8514:	6f 91       	pop	r22
    8516:	5f 91       	pop	r21
    8518:	4f 91       	pop	r20
    851a:	3f 91       	pop	r19
    851c:	2f 91       	pop	r18
    851e:	1f 91       	pop	r17
    8520:	0f 90       	pop	r0
    8522:	0b be       	out	0x3b, r0	; 59
    8524:	0f 90       	pop	r0
    8526:	0f be       	out	0x3f, r0	; 63
    8528:	0f 90       	pop	r0
    852a:	1f 90       	pop	r1
    852c:	18 95       	reti

0000852e <procMessage99>:
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}

char procMessage99(){//<STX>[IFT IDSeq N Srce IPDest IPMsg CodeTran NoShiftDateTimeIsland IDFIP IDProduct IDDescriptionPriceVolumeAmountMOP TypeMOP NameCard IDCard HolderBalance Type Balance MeterVolume MeterAmount Current TimePrint Count Checksum ETX
    852e:	0f 93       	push	r16
    8530:	1f 93       	push	r17
     char Result;
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
    8532:	80 91 83 0c 	lds	r24, 0x0C83
    8536:	81 30       	cpi	r24, 0x01	; 1
    8538:	09 f0       	breq	.+2      	; 0x853c <procMessage99+0xe>
    853a:	2e c2       	rjmp	.+1116   	; 0x8998 <procMessage99+0x46a>
    853c:	80 91 9e 01 	lds	r24, 0x019E
    8540:	90 91 9f 01 	lds	r25, 0x019F
    8544:	8a 57       	subi	r24, 0x7A	; 122
    8546:	91 40       	sbci	r25, 0x01	; 1
    8548:	08 f4       	brcc	.+2      	; 0x854c <procMessage99+0x1e>
    854a:	26 c2       	rjmp	.+1100   	; 0x8998 <procMessage99+0x46a>
    854c:	20 e0       	ldi	r18, 0x00	; 0
    854e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8550:	f9 01       	movw	r30, r18
    8552:	e7 52       	subi	r30, 0x27	; 39
    8554:	f0 4f       	sbci	r31, 0xF0	; 240
    8556:	d9 01       	movw	r26, r18
    8558:	ad 57       	subi	r26, 0x7D	; 125
    855a:	b3 4f       	sbci	r27, 0xF3	; 243
    855c:	95 96       	adiw	r26, 0x25	; 37
    855e:	8c 91       	ld	r24, X
    8560:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8562:	2f 5f       	subi	r18, 0xFF	; 255
    8564:	3f 4f       	sbci	r19, 0xFF	; 255
    8566:	26 30       	cpi	r18, 0x06	; 6
    8568:	31 05       	cpc	r19, r1
    856a:	91 f7       	brne	.-28     	; 0x8550 <procMessage99+0x22>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    856c:	10 92 df 0f 	sts	0x0FDF, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8570:	80 91 ae 0c 	lds	r24, 0x0CAE
    8574:	80 93 bb 0f 	sts	0x0FBB, r24
	 }Dest[Length]=0;
    8578:	10 92 bc 0f 	sts	0x0FBC, r1
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
       StrPosCopy(rcv_trans,strTranNo,37,6);//Transaction Number
       StrPosCopy(rcv_trans,strShift,43,1);
       Shift=(CharPosCopy(rcv_trans,43)-'0');
    857c:	80 53       	subi	r24, 0x30	; 48
    857e:	80 93 d0 01 	sts	0x01D0, r24
    8582:	20 e0       	ldi	r18, 0x00	; 0
    8584:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8586:	f9 01       	movw	r30, r18
    8588:	ef 5a       	subi	r30, 0xAF	; 175
    858a:	f6 4f       	sbci	r31, 0xF6	; 246
    858c:	d9 01       	movw	r26, r18
    858e:	ad 57       	subi	r26, 0x7D	; 125
    8590:	b3 4f       	sbci	r27, 0xF3	; 243
    8592:	9c 96       	adiw	r26, 0x2c	; 44
    8594:	8c 91       	ld	r24, X
    8596:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8598:	2f 5f       	subi	r18, 0xFF	; 255
    859a:	3f 4f       	sbci	r19, 0xFF	; 255
    859c:	2a 30       	cpi	r18, 0x0A	; 10
    859e:	31 05       	cpc	r19, r1
    85a0:	91 f7       	brne	.-28     	; 0x8586 <procMessage99+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    85a2:	10 92 5b 09 	sts	0x095B, r1
    85a6:	20 e0       	ldi	r18, 0x00	; 0
    85a8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    85aa:	f9 01       	movw	r30, r18
    85ac:	e3 5d       	subi	r30, 0xD3	; 211
    85ae:	fa 4f       	sbci	r31, 0xFA	; 250
    85b0:	d9 01       	movw	r26, r18
    85b2:	ad 57       	subi	r26, 0x7D	; 125
    85b4:	b3 4f       	sbci	r27, 0xF3	; 243
    85b6:	d6 96       	adiw	r26, 0x36	; 54
    85b8:	8c 91       	ld	r24, X
    85ba:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    85bc:	2f 5f       	subi	r18, 0xFF	; 255
    85be:	3f 4f       	sbci	r19, 0xFF	; 255
    85c0:	28 30       	cpi	r18, 0x08	; 8
    85c2:	31 05       	cpc	r19, r1
    85c4:	91 f7       	brne	.-28     	; 0x85aa <procMessage99+0x7c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    85c6:	10 92 35 05 	sts	0x0535, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    85ca:	80 91 c1 0c 	lds	r24, 0x0CC1
    85ce:	80 93 5d 0c 	sts	0x0C5D, r24
    85d2:	80 91 c2 0c 	lds	r24, 0x0CC2
    85d6:	80 93 5e 0c 	sts	0x0C5E, r24
	 }Dest[Length]=0;
    85da:	10 92 5f 0c 	sts	0x0C5F, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    85de:	80 91 c3 0c 	lds	r24, 0x0CC3
    85e2:	80 93 86 09 	sts	0x0986, r24
    85e6:	80 91 c4 0c 	lds	r24, 0x0CC4
    85ea:	80 93 87 09 	sts	0x0987, r24
	 }Dest[Length]=0;
    85ee:	10 92 88 09 	sts	0x0988, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    85f2:	80 91 c5 0c 	lds	r24, 0x0CC5
    85f6:	80 93 1a 0c 	sts	0x0C1A, r24
    85fa:	80 91 c6 0c 	lds	r24, 0x0CC6
    85fe:	80 93 1b 0c 	sts	0x0C1B, r24
	 }Dest[Length]=0;
    8602:	10 92 1c 0c 	sts	0x0C1C, r1
    8606:	20 e0       	ldi	r18, 0x00	; 0
    8608:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    860a:	f9 01       	movw	r30, r18
    860c:	e5 53       	subi	r30, 0x35	; 53
    860e:	f4 4f       	sbci	r31, 0xF4	; 244
    8610:	d9 01       	movw	r26, r18
    8612:	a9 53       	subi	r26, 0x39	; 57
    8614:	b3 4f       	sbci	r27, 0xF3	; 243
    8616:	8c 91       	ld	r24, X
    8618:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    861a:	2f 5f       	subi	r18, 0xFF	; 255
    861c:	3f 4f       	sbci	r19, 0xFF	; 255
    861e:	2f 30       	cpi	r18, 0x0F	; 15
    8620:	31 05       	cpc	r19, r1
    8622:	99 f7       	brne	.-26     	; 0x860a <procMessage99+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8624:	10 92 da 0b 	sts	0x0BDA, r1
    8628:	20 e0       	ldi	r18, 0x00	; 0
    862a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    862c:	f9 01       	movw	r30, r18
    862e:	ef 57       	subi	r30, 0x7F	; 127
    8630:	f8 4f       	sbci	r31, 0xF8	; 248
    8632:	d9 01       	movw	r26, r18
    8634:	aa 52       	subi	r26, 0x2A	; 42
    8636:	b3 4f       	sbci	r27, 0xF3	; 243
    8638:	8c 91       	ld	r24, X
    863a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    863c:	2f 5f       	subi	r18, 0xFF	; 255
    863e:	3f 4f       	sbci	r19, 0xFF	; 255
    8640:	28 30       	cpi	r18, 0x08	; 8
    8642:	31 05       	cpc	r19, r1
    8644:	99 f7       	brne	.-26     	; 0x862c <procMessage99+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8646:	10 92 89 07 	sts	0x0789, r1
    864a:	20 e0       	ldi	r18, 0x00	; 0
    864c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    864e:	f9 01       	movw	r30, r18
    8650:	eb 5a       	subi	r30, 0xAB	; 171
    8652:	fa 4f       	sbci	r31, 0xFA	; 250
    8654:	d9 01       	movw	r26, r18
    8656:	a2 52       	subi	r26, 0x22	; 34
    8658:	b3 4f       	sbci	r27, 0xF3	; 243
    865a:	8c 91       	ld	r24, X
    865c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    865e:	2f 5f       	subi	r18, 0xFF	; 255
    8660:	3f 4f       	sbci	r19, 0xFF	; 255
    8662:	28 30       	cpi	r18, 0x08	; 8
    8664:	31 05       	cpc	r19, r1
    8666:	99 f7       	brne	.-26     	; 0x864e <procMessage99+0x120>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8668:	10 92 5d 05 	sts	0x055D, r1
    866c:	20 e0       	ldi	r18, 0x00	; 0
    866e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8670:	f9 01       	movw	r30, r18
    8672:	e7 5e       	subi	r30, 0xE7	; 231
    8674:	f0 4f       	sbci	r31, 0xF0	; 240
    8676:	d9 01       	movw	r26, r18
    8678:	aa 51       	subi	r26, 0x1A	; 26
    867a:	b3 4f       	sbci	r27, 0xF3	; 243
    867c:	8c 91       	ld	r24, X
    867e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8680:	2f 5f       	subi	r18, 0xFF	; 255
    8682:	3f 4f       	sbci	r19, 0xFF	; 255
    8684:	2a 30       	cpi	r18, 0x0A	; 10
    8686:	31 05       	cpc	r19, r1
    8688:	99 f7       	brne	.-26     	; 0x8670 <procMessage99+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    868a:	10 92 23 0f 	sts	0x0F23, r1

	   //FillChar(strAmount,sizeof(strAmount),0);
       StrPosCopy(rcv_trans,strAmount,99,10);

       //StrPosCopy(rcv_trans,strMOPType,109,1);
       MOPType=(CharPosCopy(rcv_trans,109)-'0');
    868e:	80 91 f0 0c 	lds	r24, 0x0CF0
    8692:	80 53       	subi	r24, 0x30	; 48
    8694:	80 93 cf 01 	sts	0x01CF, r24
    8698:	20 e0       	ldi	r18, 0x00	; 0
    869a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    869c:	f9 01       	movw	r30, r18
    869e:	e0 5a       	subi	r30, 0xA0	; 160
    86a0:	f8 4f       	sbci	r31, 0xF8	; 248
    86a2:	d9 01       	movw	r26, r18
    86a4:	af 50       	subi	r26, 0x0F	; 15
    86a6:	b3 4f       	sbci	r27, 0xF3	; 243
    86a8:	8c 91       	ld	r24, X
    86aa:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    86ac:	2f 5f       	subi	r18, 0xFF	; 255
    86ae:	3f 4f       	sbci	r19, 0xFF	; 255
    86b0:	24 31       	cpi	r18, 0x14	; 20
    86b2:	31 05       	cpc	r19, r1
    86b4:	99 f7       	brne	.-26     	; 0x869c <procMessage99+0x16e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    86b6:	10 92 74 07 	sts	0x0774, r1
    86ba:	20 e0       	ldi	r18, 0x00	; 0
    86bc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    86be:	f9 01       	movw	r30, r18
    86c0:	e1 51       	subi	r30, 0x11	; 17
    86c2:	f1 4f       	sbci	r31, 0xF1	; 241
    86c4:	d9 01       	movw	r26, r18
    86c6:	ab 5f       	subi	r26, 0xFB	; 251
    86c8:	b2 4f       	sbci	r27, 0xF2	; 242
    86ca:	8c 91       	ld	r24, X
    86cc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    86ce:	2f 5f       	subi	r18, 0xFF	; 255
    86d0:	3f 4f       	sbci	r19, 0xFF	; 255
    86d2:	24 31       	cpi	r18, 0x14	; 20
    86d4:	31 05       	cpc	r19, r1
    86d6:	99 f7       	brne	.-26     	; 0x86be <procMessage99+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    86d8:	10 92 03 0f 	sts	0x0F03, r1
    86dc:	20 e0       	ldi	r18, 0x00	; 0
    86de:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    86e0:	f9 01       	movw	r30, r18
    86e2:	ec 5f       	subi	r30, 0xFC	; 252
    86e4:	fa 4f       	sbci	r31, 0xFA	; 250
    86e6:	d9 01       	movw	r26, r18
    86e8:	a7 5e       	subi	r26, 0xE7	; 231
    86ea:	b2 4f       	sbci	r27, 0xF2	; 242
    86ec:	8c 91       	ld	r24, X
    86ee:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    86f0:	2f 5f       	subi	r18, 0xFF	; 255
    86f2:	3f 4f       	sbci	r19, 0xFF	; 255
    86f4:	28 32       	cpi	r18, 0x28	; 40
    86f6:	31 05       	cpc	r19, r1
    86f8:	99 f7       	brne	.-26     	; 0x86e0 <procMessage99+0x1b2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    86fa:	10 92 2c 05 	sts	0x052C, r1
    86fe:	20 e0       	ldi	r18, 0x00	; 0
    8700:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8702:	f9 01       	movw	r30, r18
    8704:	e5 5c       	subi	r30, 0xC5	; 197
    8706:	fa 4f       	sbci	r31, 0xFA	; 250
    8708:	d9 01       	movw	r26, r18
    870a:	af 5b       	subi	r26, 0xBF	; 191
    870c:	b2 4f       	sbci	r27, 0xF2	; 242
    870e:	8c 91       	ld	r24, X
    8710:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8712:	2f 5f       	subi	r18, 0xFF	; 255
    8714:	3f 4f       	sbci	r19, 0xFF	; 255
    8716:	29 31       	cpi	r18, 0x19	; 25
    8718:	31 05       	cpc	r19, r1
    871a:	99 f7       	brne	.-26     	; 0x8702 <procMessage99+0x1d4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    871c:	10 92 54 05 	sts	0x0554, r1
    8720:	20 e0       	ldi	r18, 0x00	; 0
    8722:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8724:	f9 01       	movw	r30, r18
    8726:	e5 5b       	subi	r30, 0xB5	; 181
    8728:	f0 4f       	sbci	r31, 0xF0	; 240
    872a:	d9 01       	movw	r26, r18
    872c:	a6 5a       	subi	r26, 0xA6	; 166
    872e:	b2 4f       	sbci	r27, 0xF2	; 242
    8730:	8c 91       	ld	r24, X
    8732:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8734:	2f 5f       	subi	r18, 0xFF	; 255
    8736:	3f 4f       	sbci	r19, 0xFF	; 255
    8738:	2d 30       	cpi	r18, 0x0D	; 13
    873a:	31 05       	cpc	r19, r1
    873c:	99 f7       	brne	.-26     	; 0x8724 <procMessage99+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    873e:	10 92 58 0f 	sts	0x0F58, r1
    8742:	20 e0       	ldi	r18, 0x00	; 0
    8744:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8746:	f9 01       	movw	r30, r18
    8748:	e4 59       	subi	r30, 0x94	; 148
    874a:	fa 4f       	sbci	r31, 0xFA	; 250
    874c:	d9 01       	movw	r26, r18
    874e:	a9 59       	subi	r26, 0x99	; 153
    8750:	b2 4f       	sbci	r27, 0xF2	; 242
    8752:	8c 91       	ld	r24, X
    8754:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8756:	2f 5f       	subi	r18, 0xFF	; 255
    8758:	3f 4f       	sbci	r19, 0xFF	; 255
    875a:	2d 30       	cpi	r18, 0x0D	; 13
    875c:	31 05       	cpc	r19, r1
    875e:	99 f7       	brne	.-26     	; 0x8746 <procMessage99+0x218>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8760:	10 92 79 05 	sts	0x0579, r1
    8764:	20 e0       	ldi	r18, 0x00	; 0
    8766:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8768:	f9 01       	movw	r30, r18
    876a:	e1 5b       	subi	r30, 0xB1	; 177
    876c:	f3 4f       	sbci	r31, 0xF3	; 243
    876e:	d9 01       	movw	r26, r18
    8770:	ac 58       	subi	r26, 0x8C	; 140
    8772:	b2 4f       	sbci	r27, 0xF2	; 242
    8774:	8c 91       	ld	r24, X
    8776:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8778:	2f 5f       	subi	r18, 0xFF	; 255
    877a:	3f 4f       	sbci	r19, 0xFF	; 255
    877c:	2d 30       	cpi	r18, 0x0D	; 13
    877e:	31 05       	cpc	r19, r1
    8780:	99 f7       	brne	.-26     	; 0x8768 <procMessage99+0x23a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8782:	10 92 5c 0c 	sts	0x0C5C, r1
    8786:	20 e0       	ldi	r18, 0x00	; 0
    8788:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    878a:	f9 01       	movw	r30, r18
    878c:	e7 57       	subi	r30, 0x77	; 119
    878e:	f6 4f       	sbci	r31, 0xF6	; 246
    8790:	d9 01       	movw	r26, r18
    8792:	af 57       	subi	r26, 0x7F	; 127
    8794:	b2 4f       	sbci	r27, 0xF2	; 242
    8796:	8c 91       	ld	r24, X
    8798:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    879a:	2f 5f       	subi	r18, 0xFF	; 255
    879c:	3f 4f       	sbci	r19, 0xFF	; 255
    879e:	23 31       	cpi	r18, 0x13	; 19
    87a0:	31 05       	cpc	r19, r1
    87a2:	99 f7       	brne	.-26     	; 0x878a <procMessage99+0x25c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    87a4:	10 92 9c 09 	sts	0x099C, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    87a8:	80 91 94 0d 	lds	r24, 0x0D94
    87ac:	80 93 d6 0f 	sts	0x0FD6, r24
    87b0:	80 91 95 0d 	lds	r24, 0x0D95
    87b4:	80 93 d7 0f 	sts	0x0FD7, r24
	 }Dest[Length]=0;
    87b8:	10 92 d8 0f 	sts	0x0FD8, r1
    87bc:	20 e0       	ldi	r18, 0x00	; 0
    87be:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    87c0:	f9 01       	movw	r30, r18
    87c2:	e6 58       	subi	r30, 0x86	; 134
    87c4:	f3 4f       	sbci	r31, 0xF3	; 243
    87c6:	d9 01       	movw	r26, r18
    87c8:	aa 56       	subi	r26, 0x6A	; 106
    87ca:	b2 4f       	sbci	r27, 0xF2	; 242
    87cc:	8c 91       	ld	r24, X
    87ce:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    87d0:	2f 5f       	subi	r18, 0xFF	; 255
    87d2:	3f 4f       	sbci	r19, 0xFF	; 255
    87d4:	28 30       	cpi	r18, 0x08	; 8
    87d6:	31 05       	cpc	r19, r1
    87d8:	99 f7       	brne	.-26     	; 0x87c0 <procMessage99+0x292>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    87da:	10 92 82 0c 	sts	0x0C82, r1
    87de:	20 e0       	ldi	r18, 0x00	; 0
    87e0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    87e2:	f9 01       	movw	r30, r18
    87e4:	e5 56       	subi	r30, 0x65	; 101
    87e6:	fb 4f       	sbci	r31, 0xFB	; 251
    87e8:	d9 01       	movw	r26, r18
    87ea:	a2 56       	subi	r26, 0x62	; 98
    87ec:	b2 4f       	sbci	r27, 0xF2	; 242
    87ee:	8c 91       	ld	r24, X
    87f0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    87f2:	2f 5f       	subi	r18, 0xFF	; 255
    87f4:	3f 4f       	sbci	r19, 0xFF	; 255
    87f6:	28 30       	cpi	r18, 0x08	; 8
    87f8:	31 05       	cpc	r19, r1
    87fa:	99 f7       	brne	.-26     	; 0x87e2 <procMessage99+0x2b4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    87fc:	10 92 a3 04 	sts	0x04A3, r1
    8800:	20 e0       	ldi	r18, 0x00	; 0
    8802:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8804:	f9 01       	movw	r30, r18
    8806:	e9 53       	subi	r30, 0x39	; 57
    8808:	fb 4f       	sbci	r31, 0xFB	; 251
    880a:	d9 01       	movw	r26, r18
    880c:	aa 55       	subi	r26, 0x5A	; 90
    880e:	b2 4f       	sbci	r27, 0xF2	; 242
    8810:	8c 91       	ld	r24, X
    8812:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8814:	2f 5f       	subi	r18, 0xFF	; 255
    8816:	3f 4f       	sbci	r19, 0xFF	; 255
    8818:	24 31       	cpi	r18, 0x14	; 20
    881a:	31 05       	cpc	r19, r1
    881c:	99 f7       	brne	.-26     	; 0x8804 <procMessage99+0x2d6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    881e:	10 92 db 04 	sts	0x04DB, r1
    8822:	20 e0       	ldi	r18, 0x00	; 0
    8824:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8826:	f9 01       	movw	r30, r18
    8828:	ec 55       	subi	r30, 0x5C	; 92
    882a:	fb 4f       	sbci	r31, 0xFB	; 251
    882c:	d9 01       	movw	r26, r18
    882e:	a6 54       	subi	r26, 0x46	; 70
    8830:	b2 4f       	sbci	r27, 0xF2	; 242
    8832:	8c 91       	ld	r24, X
    8834:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8836:	2f 5f       	subi	r18, 0xFF	; 255
    8838:	3f 4f       	sbci	r19, 0xFF	; 255
    883a:	2e 31       	cpi	r18, 0x1E	; 30
    883c:	31 05       	cpc	r19, r1
    883e:	99 f7       	brne	.-26     	; 0x8826 <procMessage99+0x2f8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8840:	10 92 c2 04 	sts	0x04C2, r1
    8844:	20 e0       	ldi	r18, 0x00	; 0
    8846:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8848:	f9 01       	movw	r30, r18
    884a:	e2 52       	subi	r30, 0x22	; 34
    884c:	f4 4f       	sbci	r31, 0xF4	; 244
    884e:	d9 01       	movw	r26, r18
    8850:	a8 52       	subi	r26, 0x28	; 40
    8852:	b2 4f       	sbci	r27, 0xF2	; 242
    8854:	8c 91       	ld	r24, X
    8856:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8858:	2f 5f       	subi	r18, 0xFF	; 255
    885a:	3f 4f       	sbci	r19, 0xFF	; 255
    885c:	28 30       	cpi	r18, 0x08	; 8
    885e:	31 05       	cpc	r19, r1
    8860:	99 f7       	brne	.-26     	; 0x8848 <procMessage99+0x31a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8862:	10 92 e6 0b 	sts	0x0BE6, r1
    8866:	20 e0       	ldi	r18, 0x00	; 0
    8868:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    886a:	f9 01       	movw	r30, r18
    886c:	e2 5a       	subi	r30, 0xA2	; 162
    886e:	fa 4f       	sbci	r31, 0xFA	; 250
    8870:	d9 01       	movw	r26, r18
    8872:	a0 52       	subi	r26, 0x20	; 32
    8874:	b2 4f       	sbci	r27, 0xF2	; 242
    8876:	8c 91       	ld	r24, X
    8878:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    887a:	2f 5f       	subi	r18, 0xFF	; 255
    887c:	3f 4f       	sbci	r19, 0xFF	; 255
    887e:	2a 30       	cpi	r18, 0x0A	; 10
    8880:	31 05       	cpc	r19, r1
    8882:	99 f7       	brne	.-26     	; 0x886a <procMessage99+0x33c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8884:	10 92 68 05 	sts	0x0568, r1
    8888:	20 e0       	ldi	r18, 0x00	; 0
    888a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    888c:	f9 01       	movw	r30, r18
    888e:	e0 5c       	subi	r30, 0xC0	; 192
    8890:	f0 4f       	sbci	r31, 0xF0	; 240
    8892:	d9 01       	movw	r26, r18
    8894:	a6 51       	subi	r26, 0x16	; 22
    8896:	b2 4f       	sbci	r27, 0xF2	; 242
    8898:	8c 91       	ld	r24, X
    889a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    889c:	2f 5f       	subi	r18, 0xFF	; 255
    889e:	3f 4f       	sbci	r19, 0xFF	; 255
    88a0:	2a 30       	cpi	r18, 0x0A	; 10
    88a2:	31 05       	cpc	r19, r1
    88a4:	99 f7       	brne	.-26     	; 0x888c <procMessage99+0x35e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    88a6:	10 92 4a 0f 	sts	0x0F4A, r1
    88aa:	20 e0       	ldi	r18, 0x00	; 0
    88ac:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    88ae:	f9 01       	movw	r30, r18
    88b0:	e7 54       	subi	r30, 0x47	; 71
    88b2:	f6 4f       	sbci	r31, 0xF6	; 246
    88b4:	d9 01       	movw	r26, r18
    88b6:	ac 50       	subi	r26, 0x0C	; 12
    88b8:	b2 4f       	sbci	r27, 0xF2	; 242
    88ba:	8c 91       	ld	r24, X
    88bc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    88be:	2f 5f       	subi	r18, 0xFF	; 255
    88c0:	3f 4f       	sbci	r19, 0xFF	; 255
    88c2:	24 31       	cpi	r18, 0x14	; 20
    88c4:	31 05       	cpc	r19, r1
    88c6:	99 f7       	brne	.-26     	; 0x88ae <procMessage99+0x380>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    88c8:	10 92 cd 09 	sts	0x09CD, r1
    88cc:	20 e0       	ldi	r18, 0x00	; 0
    88ce:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    88d0:	f9 01       	movw	r30, r18
    88d2:	e5 50       	subi	r30, 0x05	; 5
    88d4:	f4 4f       	sbci	r31, 0xF4	; 244
    88d6:	d9 01       	movw	r26, r18
    88d8:	a8 5f       	subi	r26, 0xF8	; 248
    88da:	b1 4f       	sbci	r27, 0xF1	; 241
    88dc:	8c 91       	ld	r24, X
    88de:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    88e0:	2f 5f       	subi	r18, 0xFF	; 255
    88e2:	3f 4f       	sbci	r19, 0xFF	; 255
    88e4:	2a 30       	cpi	r18, 0x0A	; 10
    88e6:	31 05       	cpc	r19, r1
    88e8:	99 f7       	brne	.-26     	; 0x88d0 <procMessage99+0x3a2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    88ea:	10 92 05 0c 	sts	0x0C05, r1
    88ee:	20 e0       	ldi	r18, 0x00	; 0
    88f0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    88f2:	f9 01       	movw	r30, r18
    88f4:	e6 58       	subi	r30, 0x86	; 134
    88f6:	fa 4f       	sbci	r31, 0xFA	; 250
    88f8:	d9 01       	movw	r26, r18
    88fa:	ae 5e       	subi	r26, 0xEE	; 238
    88fc:	b1 4f       	sbci	r27, 0xF1	; 241
    88fe:	8c 91       	ld	r24, X
    8900:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8902:	2f 5f       	subi	r18, 0xFF	; 255
    8904:	3f 4f       	sbci	r19, 0xFF	; 255
    8906:	28 30       	cpi	r18, 0x08	; 8
    8908:	31 05       	cpc	r19, r1
    890a:	99 f7       	brne	.-26     	; 0x88f2 <procMessage99+0x3c4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    890c:	10 92 82 05 	sts	0x0582, r1
    8910:	20 e0       	ldi	r18, 0x00	; 0
    8912:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8914:	f9 01       	movw	r30, r18
    8916:	e5 53       	subi	r30, 0x35	; 53
    8918:	f0 4f       	sbci	r31, 0xF0	; 240
    891a:	d9 01       	movw	r26, r18
    891c:	a6 5e       	subi	r26, 0xE6	; 230
    891e:	b1 4f       	sbci	r27, 0xF1	; 241
    8920:	8c 91       	ld	r24, X
    8922:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8924:	2f 5f       	subi	r18, 0xFF	; 255
    8926:	3f 4f       	sbci	r19, 0xFF	; 255
    8928:	2a 30       	cpi	r18, 0x0A	; 10
    892a:	31 05       	cpc	r19, r1
    892c:	99 f7       	brne	.-26     	; 0x8914 <procMessage99+0x3e6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    892e:	10 92 d5 0f 	sts	0x0FD5, r1
    8932:	20 e0       	ldi	r18, 0x00	; 0
    8934:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8936:	f9 01       	movw	r30, r18
    8938:	e3 5a       	subi	r30, 0xA3	; 163
    893a:	f0 4f       	sbci	r31, 0xF0	; 240
    893c:	d9 01       	movw	r26, r18
    893e:	ac 5d       	subi	r26, 0xDC	; 220
    8940:	b1 4f       	sbci	r27, 0xF1	; 241
    8942:	8c 91       	ld	r24, X
    8944:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8946:	2f 5f       	subi	r18, 0xFF	; 255
    8948:	3f 4f       	sbci	r19, 0xFF	; 255
    894a:	24 31       	cpi	r18, 0x14	; 20
    894c:	31 05       	cpc	r19, r1
    894e:	99 f7       	brne	.-26     	; 0x8936 <procMessage99+0x408>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8950:	10 92 71 0f 	sts	0x0F71, r1
    8954:	20 e0       	ldi	r18, 0x00	; 0
    8956:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8958:	f9 01       	movw	r30, r18
    895a:	e3 55       	subi	r30, 0x53	; 83
    895c:	fa 4f       	sbci	r31, 0xFA	; 250
    895e:	d9 01       	movw	r26, r18
    8960:	a8 5c       	subi	r26, 0xC8	; 200
    8962:	b1 4f       	sbci	r27, 0xF1	; 241
    8964:	8c 91       	ld	r24, X
    8966:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8968:	2f 5f       	subi	r18, 0xFF	; 255
    896a:	3f 4f       	sbci	r19, 0xFF	; 255
    896c:	2e 31       	cpi	r18, 0x1E	; 30
    896e:	31 05       	cpc	r19, r1
    8970:	99 f7       	brne	.-26     	; 0x8958 <procMessage99+0x42a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8972:	10 92 cb 05 	sts	0x05CB, r1
       StrPosCopy(rcv_trans,strCorporateName,437,30);
	   //


	   //FIP Detection LocalAccount Null Filling
	   if ((nLocalAccount>0)&&(LocalAccountFIP[0]==atoi(strFIP_ID))){
    8976:	80 91 a4 01 	lds	r24, 0x01A4
    897a:	88 23       	and	r24, r24
    897c:	69 f0       	breq	.+26     	; 0x8998 <procMessage99+0x46a>
    897e:	00 91 36 05 	lds	r16, 0x0536
    8982:	10 e0       	ldi	r17, 0x00	; 0
    8984:	86 e8       	ldi	r24, 0x86	; 134
    8986:	99 e0       	ldi	r25, 0x09	; 9
    8988:	0e 94 3d b5 	call	0x16a7a	; 0x16a7a <atoi>
    898c:	08 17       	cp	r16, r24
    898e:	19 07       	cpc	r17, r25
    8990:	19 f4       	brne	.+6      	; 0x8998 <procMessage99+0x46a>
	        IsCompleteFilling=True;
    8992:	81 e0       	ldi	r24, 0x01	; 1
    8994:	80 93 c0 01 	sts	0x01C0, r24
	   }

	  }
     return Result;     
}
    8998:	80 e0       	ldi	r24, 0x00	; 0
    899a:	1f 91       	pop	r17
    899c:	0f 91       	pop	r16
    899e:	08 95       	ret

000089a0 <GetMessageID>:
		  }
       IsStandaloneAcknoledge=True;
	  }
}

char GetMessageID(char *strMessageFlow){
    89a0:	0f 93       	push	r16
    89a2:	1f 93       	push	r17
    89a4:	df 93       	push	r29
    89a6:	cf 93       	push	r28
    89a8:	00 d0       	rcall	.+0      	; 0x89aa <GetMessageID+0xa>
    89aa:	0f 92       	push	r0
    89ac:	cd b7       	in	r28, 0x3d	; 61
    89ae:	de b7       	in	r29, 0x3e	; 62
    89b0:	fc 01       	movw	r30, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    89b2:	80 81       	ld	r24, Z
    89b4:	89 83       	std	Y+1, r24	; 0x01
    89b6:	81 81       	ldd	r24, Z+1	; 0x01
    89b8:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    89ba:	1b 82       	std	Y+3, r1	; 0x03
}

char GetMessageID(char *strMessageFlow){
     char Result,strMsgID[3];
	 StrPosCopy(strMessageFlow,strMsgID,0,2);
	 RemZeroLead(strMsgID);
    89bc:	8e 01       	movw	r16, r28
    89be:	0f 5f       	subi	r16, 0xFF	; 255
    89c0:	1f 4f       	sbci	r17, 0xFF	; 255
    89c2:	c8 01       	movw	r24, r16
    89c4:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
	 Result=atoi(strMsgID);
    89c8:	c8 01       	movw	r24, r16
    89ca:	0e 94 3d b5 	call	0x16a7a	; 0x16a7a <atoi>
  return Result;
}
    89ce:	0f 90       	pop	r0
    89d0:	0f 90       	pop	r0
    89d2:	0f 90       	pop	r0
    89d4:	cf 91       	pop	r28
    89d6:	df 91       	pop	r29
    89d8:	1f 91       	pop	r17
    89da:	0f 91       	pop	r16
    89dc:	08 95       	ret

000089de <FTestChar>:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
	     break;
	}
}

char FTestChar(){
    89de:	0f 93       	push	r16
    89e0:	1f 93       	push	r17
    89e2:	df 93       	push	r29
    89e4:	cf 93       	push	r28
    89e6:	cd b7       	in	r28, 0x3d	; 61
    89e8:	de b7       	in	r29, 0x3e	; 62
    89ea:	64 97       	sbiw	r28, 0x14	; 20
    89ec:	0f b6       	in	r0, 0x3f	; 63
    89ee:	f8 94       	cli
    89f0:	de bf       	out	0x3e, r29	; 62
    89f2:	0f be       	out	0x3f, r0	; 63
    89f4:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],Result;
static char i=0;
     Result=MENU_NONE;
     sprintf_P(lcdteks,PSTR("D:%d C:%c  "),i,i);
    89f6:	20 91 70 03 	lds	r18, 0x0370
    89fa:	8d b7       	in	r24, 0x3d	; 61
    89fc:	9e b7       	in	r25, 0x3e	; 62
    89fe:	08 97       	sbiw	r24, 0x08	; 8
    8a00:	0f b6       	in	r0, 0x3f	; 63
    8a02:	f8 94       	cli
    8a04:	9e bf       	out	0x3e, r25	; 62
    8a06:	0f be       	out	0x3f, r0	; 63
    8a08:	8d bf       	out	0x3d, r24	; 61
    8a0a:	ed b7       	in	r30, 0x3d	; 61
    8a0c:	fe b7       	in	r31, 0x3e	; 62
    8a0e:	31 96       	adiw	r30, 0x01	; 1
    8a10:	8e 01       	movw	r16, r28
    8a12:	0f 5f       	subi	r16, 0xFF	; 255
    8a14:	1f 4f       	sbci	r17, 0xFF	; 255
    8a16:	ad b7       	in	r26, 0x3d	; 61
    8a18:	be b7       	in	r27, 0x3e	; 62
    8a1a:	12 96       	adiw	r26, 0x02	; 2
    8a1c:	1c 93       	st	X, r17
    8a1e:	0e 93       	st	-X, r16
    8a20:	11 97       	sbiw	r26, 0x01	; 1
    8a22:	8b e0       	ldi	r24, 0x0B	; 11
    8a24:	9c e1       	ldi	r25, 0x1C	; 28
    8a26:	93 83       	std	Z+3, r25	; 0x03
    8a28:	82 83       	std	Z+2, r24	; 0x02
    8a2a:	24 83       	std	Z+4, r18	; 0x04
    8a2c:	15 82       	std	Z+5, r1	; 0x05
    8a2e:	26 83       	std	Z+6, r18	; 0x06
    8a30:	17 82       	std	Z+7, r1	; 0x07
    8a32:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
     lcd_print(1,1,lcdteks);
    8a36:	8d b7       	in	r24, 0x3d	; 61
    8a38:	9e b7       	in	r25, 0x3e	; 62
    8a3a:	08 96       	adiw	r24, 0x08	; 8
    8a3c:	0f b6       	in	r0, 0x3f	; 63
    8a3e:	f8 94       	cli
    8a40:	9e bf       	out	0x3e, r25	; 62
    8a42:	0f be       	out	0x3f, r0	; 63
    8a44:	8d bf       	out	0x3d, r24	; 61
    8a46:	81 e0       	ldi	r24, 0x01	; 1
    8a48:	61 e0       	ldi	r22, 0x01	; 1
    8a4a:	a8 01       	movw	r20, r16
    8a4c:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
	 if (i==0xFF)Result=MENU_DONE;
    8a50:	20 91 70 03 	lds	r18, 0x0370
	 i++;
    8a54:	2f 5f       	subi	r18, 0xFF	; 255
    8a56:	20 93 70 03 	sts	0x0370, r18
    8a5a:	21 50       	subi	r18, 0x01	; 1
    8a5c:	88 ee       	ldi	r24, 0xE8	; 232
    8a5e:	9d ef       	ldi	r25, 0xFD	; 253
    8a60:	49 e1       	ldi	r20, 0x19	; 25
    8a62:	50 e0       	ldi	r21, 0x00	; 0
    8a64:	fa 01       	movw	r30, r20
    8a66:	31 97       	sbiw	r30, 0x01	; 1
    8a68:	f1 f7       	brne	.-4      	; 0x8a66 <FTestChar+0x88>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8a6a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8a6c:	d9 f7       	brne	.-10     	; 0x8a64 <FTestChar+0x86>
    8a6e:	80 e0       	ldi	r24, 0x00	; 0
    8a70:	2f 3f       	cpi	r18, 0xFF	; 255
    8a72:	09 f4       	brne	.+2      	; 0x8a76 <FTestChar+0x98>
    8a74:	81 e0       	ldi	r24, 0x01	; 1
     _delay_ms(6500);
  return Result;
}
    8a76:	64 96       	adiw	r28, 0x14	; 20
    8a78:	0f b6       	in	r0, 0x3f	; 63
    8a7a:	f8 94       	cli
    8a7c:	de bf       	out	0x3e, r29	; 62
    8a7e:	0f be       	out	0x3f, r0	; 63
    8a80:	cd bf       	out	0x3d, r28	; 61
    8a82:	cf 91       	pop	r28
    8a84:	df 91       	pop	r29
    8a86:	1f 91       	pop	r17
    8a88:	0f 91       	pop	r16
    8a8a:	08 95       	ret

00008a8c <DisplayPumpStatus>:
		  break;         	 
	 }
  return Result;	 
}

void DisplayPumpStatus(){
    8a8c:	0f 93       	push	r16
    8a8e:	1f 93       	push	r17
    8a90:	df 93       	push	r29
    8a92:	cf 93       	push	r28
    8a94:	cd b7       	in	r28, 0x3d	; 61
    8a96:	de b7       	in	r29, 0x3e	; 62
    8a98:	a8 97       	sbiw	r28, 0x28	; 40
    8a9a:	0f b6       	in	r0, 0x3f	; 63
    8a9c:	f8 94       	cli
    8a9e:	de bf       	out	0x3e, r29	; 62
    8aa0:	0f be       	out	0x3f, r0	; 63
    8aa2:	cd bf       	out	0x3d, r28	; 61
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
    8aa4:	80 91 11 01 	lds	r24, 0x0111
    8aa8:	81 30       	cpi	r24, 0x01	; 1
    8aaa:	09 f0       	breq	.+2      	; 0x8aae <DisplayPumpStatus+0x22>
    8aac:	4a c0       	rjmp	.+148    	; 0x8b42 <DisplayPumpStatus+0xb6>
	     IsNewPumpStatus=False;
    8aae:	10 92 11 01 	sts	0x0111, r1
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    8ab2:	80 93 bf 03 	sts	0x03BF, r24
    8ab6:	10 92 c0 03 	sts	0x03C0, r1
    8aba:	80 91 65 00 	lds	r24, 0x0065
    8abe:	8d 7f       	andi	r24, 0xFD	; 253
    8ac0:	80 93 65 00 	sts	0x0065, r24
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
    8ac4:	80 91 5f 01 	lds	r24, 0x015F
    8ac8:	48 2f       	mov	r20, r24
    8aca:	50 e0       	ldi	r21, 0x00	; 0
    8acc:	20 e0       	ldi	r18, 0x00	; 0
    8ace:	30 e0       	ldi	r19, 0x00	; 0
    8ad0:	be 01       	movw	r22, r28
    8ad2:	6f 5f       	subi	r22, 0xFF	; 255
    8ad4:	7f 4f       	sbci	r23, 0xFF	; 255
    8ad6:	0a c0       	rjmp	.+20     	; 0x8aec <DisplayPumpStatus+0x60>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8ad8:	fb 01       	movw	r30, r22
    8ada:	e2 0f       	add	r30, r18
    8adc:	f3 1f       	adc	r31, r19
    8ade:	d9 01       	movw	r26, r18
    8ae0:	ae 5e       	subi	r26, 0xEE	; 238
    8ae2:	be 4f       	sbci	r27, 0xFE	; 254
    8ae4:	8c 91       	ld	r24, X
    8ae6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8ae8:	2f 5f       	subi	r18, 0xFF	; 255
    8aea:	3f 4f       	sbci	r19, 0xFF	; 255
    8aec:	24 17       	cp	r18, r20
    8aee:	35 07       	cpc	r19, r21
    8af0:	98 f3       	brcs	.-26     	; 0x8ad8 <DisplayPumpStatus+0x4c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8af2:	46 0f       	add	r20, r22
    8af4:	57 1f       	adc	r21, r23
    8af6:	da 01       	movw	r26, r20
    8af8:	1c 92       	st	X, r1

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
    8afa:	00 d0       	rcall	.+0      	; 0x8afc <DisplayPumpStatus+0x70>
    8afc:	00 d0       	rcall	.+0      	; 0x8afe <DisplayPumpStatus+0x72>
    8afe:	00 d0       	rcall	.+0      	; 0x8b00 <DisplayPumpStatus+0x74>
    8b00:	ed b7       	in	r30, 0x3d	; 61
    8b02:	fe b7       	in	r31, 0x3e	; 62
    8b04:	31 96       	adiw	r30, 0x01	; 1
    8b06:	8e 01       	movw	r16, r28
    8b08:	0b 5e       	subi	r16, 0xEB	; 235
    8b0a:	1f 4f       	sbci	r17, 0xFF	; 255
    8b0c:	ad b7       	in	r26, 0x3d	; 61
    8b0e:	be b7       	in	r27, 0x3e	; 62
    8b10:	12 96       	adiw	r26, 0x02	; 2
    8b12:	1c 93       	st	X, r17
    8b14:	0e 93       	st	-X, r16
    8b16:	11 97       	sbiw	r26, 0x01	; 1
    8b18:	8f e9       	ldi	r24, 0x9F	; 159
    8b1a:	92 e2       	ldi	r25, 0x22	; 34
    8b1c:	93 83       	std	Z+3, r25	; 0x03
    8b1e:	82 83       	std	Z+2, r24	; 0x02
    8b20:	75 83       	std	Z+5, r23	; 0x05
    8b22:	64 83       	std	Z+4, r22	; 0x04
    8b24:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
         lcd_print(4,1,lcdteks);
    8b28:	ed b7       	in	r30, 0x3d	; 61
    8b2a:	fe b7       	in	r31, 0x3e	; 62
    8b2c:	36 96       	adiw	r30, 0x06	; 6
    8b2e:	0f b6       	in	r0, 0x3f	; 63
    8b30:	f8 94       	cli
    8b32:	fe bf       	out	0x3e, r31	; 62
    8b34:	0f be       	out	0x3f, r0	; 63
    8b36:	ed bf       	out	0x3d, r30	; 61
    8b38:	84 e0       	ldi	r24, 0x04	; 4
    8b3a:	61 e0       	ldi	r22, 0x01	; 1
    8b3c:	a8 01       	movw	r20, r16
    8b3e:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
     	 }
}
    8b42:	a8 96       	adiw	r28, 0x28	; 40
    8b44:	0f b6       	in	r0, 0x3f	; 63
    8b46:	f8 94       	cli
    8b48:	de bf       	out	0x3e, r29	; 62
    8b4a:	0f be       	out	0x3f, r0	; 63
    8b4c:	cd bf       	out	0x3d, r28	; 61
    8b4e:	cf 91       	pop	r28
    8b50:	df 91       	pop	r29
    8b52:	1f 91       	pop	r17
    8b54:	0f 91       	pop	r16
    8b56:	08 95       	ret

00008b58 <FViewFreeMessage>:
char FViewFreeMessage(){
static char stFreeMessage=fmInit;
       char Result=MENU_NONE;
     
	 Result=MENU_NONE;
	 switch(stFreeMessage){
    8b58:	80 91 59 03 	lds	r24, 0x0359
    8b5c:	81 30       	cpi	r24, 0x01	; 1
    8b5e:	49 f0       	breq	.+18     	; 0x8b72 <FViewFreeMessage+0x1a>
    8b60:	81 30       	cpi	r24, 0x01	; 1
    8b62:	28 f0       	brcs	.+10     	; 0x8b6e <FViewFreeMessage+0x16>
    8b64:	82 30       	cpi	r24, 0x02	; 2
    8b66:	19 f1       	breq	.+70     	; 0x8bae <FViewFreeMessage+0x56>
    8b68:	83 30       	cpi	r24, 0x03	; 3
    8b6a:	71 f5       	brne	.+92     	; 0x8bc8 <FViewFreeMessage+0x70>
    8b6c:	29 c0       	rjmp	.+82     	; 0x8bc0 <FViewFreeMessage+0x68>
	 case fmInit:
	      stFreeMessage=fmDisplayFreeMessage;
    8b6e:	81 e0       	ldi	r24, 0x01	; 1
    8b70:	23 c0       	rjmp	.+70     	; 0x8bb8 <FViewFreeMessage+0x60>
	      break;
     case fmDisplayFreeMessage:
		  lcd_clear();
    8b72:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_print(1,1,AdvanZ.Message09.strFreeMessageLine1);
    8b76:	81 e0       	ldi	r24, 0x01	; 1
    8b78:	61 e0       	ldi	r22, 0x01	; 1
    8b7a:	46 ee       	ldi	r20, 0xE6	; 230
    8b7c:	59 e0       	ldi	r21, 0x09	; 9
    8b7e:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_print(2,1,AdvanZ.Message09.strFreeMessageLine2);
    8b82:	82 e0       	ldi	r24, 0x02	; 2
    8b84:	61 e0       	ldi	r22, 0x01	; 1
    8b86:	4b ef       	ldi	r20, 0xFB	; 251
    8b88:	59 e0       	ldi	r21, 0x09	; 9
    8b8a:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_print(3,1,AdvanZ.Message09.strFreeMessageLine3);
    8b8e:	83 e0       	ldi	r24, 0x03	; 3
    8b90:	61 e0       	ldi	r22, 0x01	; 1
    8b92:	40 e1       	ldi	r20, 0x10	; 16
    8b94:	5a e0       	ldi	r21, 0x0A	; 10
    8b96:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_print(4,1,AdvanZ.Message09.strFreeMessageLine4);
    8b9a:	84 e0       	ldi	r24, 0x04	; 4
    8b9c:	61 e0       	ldi	r22, 0x01	; 1
    8b9e:	45 e2       	ldi	r20, 0x25	; 37
    8ba0:	5a e0       	ldi	r21, 0x0A	; 10
    8ba2:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
	      TimDisplay=0;
    8ba6:	10 92 a7 01 	sts	0x01A7, r1
	      stFreeMessage=fmDelayViewMesage;
    8baa:	82 e0       	ldi	r24, 0x02	; 2
    8bac:	05 c0       	rjmp	.+10     	; 0x8bb8 <FViewFreeMessage+0x60>
	      break;
	 case fmDelayViewMesage:  
	      if (TimDisplay>TIM_FREE_MESSAGE)stFreeMessage=fmFinishFreeMessage;
    8bae:	80 91 a7 01 	lds	r24, 0x01A7
    8bb2:	8b 30       	cpi	r24, 0x0B	; 11
    8bb4:	48 f0       	brcs	.+18     	; 0x8bc8 <FViewFreeMessage+0x70>
    8bb6:	83 e0       	ldi	r24, 0x03	; 3
    8bb8:	80 93 59 03 	sts	0x0359, r24
    8bbc:	80 e0       	ldi	r24, 0x00	; 0
    8bbe:	08 95       	ret
	      break;
     case fmFinishFreeMessage:
          stFreeMessage=fmInit;
    8bc0:	10 92 59 03 	sts	0x0359, r1
    8bc4:	81 e0       	ldi	r24, 0x01	; 1
    8bc6:	08 95       	ret
    8bc8:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;
}
    8bca:	08 95       	ret

00008bcc <_scr_idle>:
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
		break;
	 }
}

void _scr_idle(void){
    8bcc:	cf 92       	push	r12
    8bce:	df 92       	push	r13
    8bd0:	ef 92       	push	r14
    8bd2:	ff 92       	push	r15
    8bd4:	0f 93       	push	r16
    8bd6:	1f 93       	push	r17
    8bd8:	df 93       	push	r29
    8bda:	cf 93       	push	r28
    8bdc:	cd b7       	in	r28, 0x3d	; 61
    8bde:	de b7       	in	r29, 0x3e	; 62
    8be0:	a8 97       	sbiw	r28, 0x28	; 40
    8be2:	0f b6       	in	r0, 0x3f	; 63
    8be4:	f8 94       	cli
    8be6:	de bf       	out	0x3e, r29	; 62
    8be8:	0f be       	out	0x3f, r0	; 63
    8bea:	cd bf       	out	0x3d, r28	; 61
char strCodeName[10],strVersion[10],lcdteks[20];
    sprintf_P(strCodeName,PSTR(CODE_NAME)); 
    8bec:	00 d0       	rcall	.+0      	; 0x8bee <_scr_idle+0x22>
    8bee:	00 d0       	rcall	.+0      	; 0x8bf0 <_scr_idle+0x24>
    8bf0:	6e 01       	movw	r12, r28
    8bf2:	08 94       	sec
    8bf4:	c1 1c       	adc	r12, r1
    8bf6:	d1 1c       	adc	r13, r1
    8bf8:	ad b7       	in	r26, 0x3d	; 61
    8bfa:	be b7       	in	r27, 0x3e	; 62
    8bfc:	12 96       	adiw	r26, 0x02	; 2
    8bfe:	dc 92       	st	X, r13
    8c00:	ce 92       	st	-X, r12
    8c02:	11 97       	sbiw	r26, 0x01	; 1
    8c04:	88 e2       	ldi	r24, 0x28	; 40
    8c06:	92 e2       	ldi	r25, 0x22	; 34
    8c08:	14 96       	adiw	r26, 0x04	; 4
    8c0a:	9c 93       	st	X, r25
    8c0c:	8e 93       	st	-X, r24
    8c0e:	13 97       	sbiw	r26, 0x03	; 3
    8c10:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    sprintf_P(strVersion,PSTR(VERSION_NUM)); 
    8c14:	fb e0       	ldi	r31, 0x0B	; 11
    8c16:	ef 2e       	mov	r14, r31
    8c18:	f1 2c       	mov	r15, r1
    8c1a:	ec 0e       	add	r14, r28
    8c1c:	fd 1e       	adc	r15, r29
    8c1e:	ed b7       	in	r30, 0x3d	; 61
    8c20:	fe b7       	in	r31, 0x3e	; 62
    8c22:	f2 82       	std	Z+2, r15	; 0x02
    8c24:	e1 82       	std	Z+1, r14	; 0x01
    8c26:	81 e2       	ldi	r24, 0x21	; 33
    8c28:	92 e2       	ldi	r25, 0x22	; 34
    8c2a:	94 83       	std	Z+4, r25	; 0x04
    8c2c:	83 83       	std	Z+3, r24	; 0x03
    8c2e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    sprintf_P(lcdteks,PSTR("%s %s"),strCodeName,strVersion); 
    8c32:	00 d0       	rcall	.+0      	; 0x8c34 <_scr_idle+0x68>
    8c34:	00 d0       	rcall	.+0      	; 0x8c36 <_scr_idle+0x6a>
    8c36:	ed b7       	in	r30, 0x3d	; 61
    8c38:	fe b7       	in	r31, 0x3e	; 62
    8c3a:	31 96       	adiw	r30, 0x01	; 1
    8c3c:	8e 01       	movw	r16, r28
    8c3e:	0b 5e       	subi	r16, 0xEB	; 235
    8c40:	1f 4f       	sbci	r17, 0xFF	; 255
    8c42:	ad b7       	in	r26, 0x3d	; 61
    8c44:	be b7       	in	r27, 0x3e	; 62
    8c46:	12 96       	adiw	r26, 0x02	; 2
    8c48:	1c 93       	st	X, r17
    8c4a:	0e 93       	st	-X, r16
    8c4c:	11 97       	sbiw	r26, 0x01	; 1
    8c4e:	8b e1       	ldi	r24, 0x1B	; 27
    8c50:	92 e2       	ldi	r25, 0x22	; 34
    8c52:	93 83       	std	Z+3, r25	; 0x03
    8c54:	82 83       	std	Z+2, r24	; 0x02
    8c56:	d5 82       	std	Z+5, r13	; 0x05
    8c58:	c4 82       	std	Z+4, r12	; 0x04
    8c5a:	f7 82       	std	Z+7, r15	; 0x07
    8c5c:	e6 82       	std	Z+6, r14	; 0x06
    8c5e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	lcd_clear();
    8c62:	ed b7       	in	r30, 0x3d	; 61
    8c64:	fe b7       	in	r31, 0x3e	; 62
    8c66:	38 96       	adiw	r30, 0x08	; 8
    8c68:	0f b6       	in	r0, 0x3f	; 63
    8c6a:	f8 94       	cli
    8c6c:	fe bf       	out	0x3e, r31	; 62
    8c6e:	0f be       	out	0x3f, r0	; 63
    8c70:	ed bf       	out	0x3d, r30	; 61
    8c72:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
	lcd_print(1,1,lcdteks);
    8c76:	81 e0       	ldi	r24, 0x01	; 1
    8c78:	61 e0       	ldi	r22, 0x01	; 1
    8c7a:	a8 01       	movw	r20, r16
    8c7c:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
}
    8c80:	a8 96       	adiw	r28, 0x28	; 40
    8c82:	0f b6       	in	r0, 0x3f	; 63
    8c84:	f8 94       	cli
    8c86:	de bf       	out	0x3e, r29	; 62
    8c88:	0f be       	out	0x3f, r0	; 63
    8c8a:	cd bf       	out	0x3d, r28	; 61
    8c8c:	cf 91       	pop	r28
    8c8e:	df 91       	pop	r29
    8c90:	1f 91       	pop	r17
    8c92:	0f 91       	pop	r16
    8c94:	ff 90       	pop	r15
    8c96:	ef 90       	pop	r14
    8c98:	df 90       	pop	r13
    8c9a:	cf 90       	pop	r12
    8c9c:	08 95       	ret

00008c9e <_scr_pump>:
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);

}
void _scr_pump(void){
    8c9e:	8f 92       	push	r8
    8ca0:	9f 92       	push	r9
    8ca2:	af 92       	push	r10
    8ca4:	bf 92       	push	r11
    8ca6:	cf 92       	push	r12
    8ca8:	df 92       	push	r13
    8caa:	ef 92       	push	r14
    8cac:	ff 92       	push	r15
    8cae:	0f 93       	push	r16
    8cb0:	1f 93       	push	r17
    8cb2:	df 93       	push	r29
    8cb4:	cf 93       	push	r28
    8cb6:	cd b7       	in	r28, 0x3d	; 61
    8cb8:	de b7       	in	r29, 0x3e	; 62
    8cba:	6c 97       	sbiw	r28, 0x1c	; 28
    8cbc:	0f b6       	in	r0, 0x3f	; 63
    8cbe:	f8 94       	cli
    8cc0:	de bf       	out	0x3e, r29	; 62
    8cc2:	0f be       	out	0x3f, r0	; 63
    8cc4:	cd bf       	out	0x3d, r28	; 61
	 //char strPumpL[3],strPumpR[3];
	 char __pump_id[8];
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
    8cc6:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
    8cca:	84 ec       	ldi	r24, 0xC4	; 196
    8ccc:	99 e0       	ldi	r25, 0x09	; 9
    8cce:	01 97       	sbiw	r24, 0x01	; 1
    8cd0:	f1 f7       	brne	.-4      	; 0x8cce <_scr_pump+0x30>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8cd2:	8e 01       	movw	r16, r28
    8cd4:	0f 5f       	subi	r16, 0xFF	; 255
    8cd6:	1f 4f       	sbci	r17, 0xFF	; 255
    8cd8:	c8 01       	movw	r24, r16
    8cda:	65 e4       	ldi	r22, 0x45	; 69
    8cdc:	70 e0       	ldi	r23, 0x00	; 0
    8cde:	48 e0       	ldi	r20, 0x08	; 8
    8ce0:	50 e0       	ldi	r21, 0x00	; 0
    8ce2:	28 ef       	ldi	r18, 0xF8	; 248
    8ce4:	32 e1       	ldi	r19, 0x12	; 18
    8ce6:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
    8cea:	78 01       	movw	r14, r16
    8cec:	01 e0       	ldi	r16, 0x01	; 1
    8cee:	10 e0       	ldi	r17, 0x00	; 0
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    8cf0:	89 e0       	ldi	r24, 0x09	; 9
    8cf2:	c8 2e       	mov	r12, r24
    8cf4:	d1 2c       	mov	r13, r1
    8cf6:	cc 0e       	add	r12, r28
    8cf8:	dd 1e       	adc	r13, r29
    8cfa:	b8 e4       	ldi	r27, 0x48	; 72
    8cfc:	8b 2e       	mov	r8, r27
    8cfe:	bd e0       	ldi	r27, 0x0D	; 13
    8d00:	9b 2e       	mov	r9, r27
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    8d02:	a5 e0       	ldi	r26, 0x05	; 5
    8d04:	aa 2e       	mov	r10, r26
    8d06:	b1 2c       	mov	r11, r1
    8d08:	ac 0e       	add	r10, r28
    8d0a:	bd 1e       	adc	r11, r29
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    8d0c:	8d b7       	in	r24, 0x3d	; 61
    8d0e:	9e b7       	in	r25, 0x3e	; 62
    8d10:	0c 97       	sbiw	r24, 0x0c	; 12
    8d12:	0f b6       	in	r0, 0x3f	; 63
    8d14:	f8 94       	cli
    8d16:	9e bf       	out	0x3e, r25	; 62
    8d18:	0f be       	out	0x3f, r0	; 63
    8d1a:	8d bf       	out	0x3d, r24	; 61
    8d1c:	ed b7       	in	r30, 0x3d	; 61
    8d1e:	fe b7       	in	r31, 0x3e	; 62
    8d20:	31 96       	adiw	r30, 0x01	; 1
    8d22:	ad b7       	in	r26, 0x3d	; 61
    8d24:	be b7       	in	r27, 0x3e	; 62
    8d26:	12 96       	adiw	r26, 0x02	; 2
    8d28:	dc 92       	st	X, r13
    8d2a:	ce 92       	st	-X, r12
    8d2c:	11 97       	sbiw	r26, 0x01	; 1
    8d2e:	93 82       	std	Z+3, r9	; 0x03
    8d30:	82 82       	std	Z+2, r8	; 0x02
    8d32:	15 83       	std	Z+5, r17	; 0x05
    8d34:	04 83       	std	Z+4, r16	; 0x04
    8d36:	d7 01       	movw	r26, r14
    8d38:	8c 91       	ld	r24, X
    8d3a:	86 83       	std	Z+6, r24	; 0x06
    8d3c:	17 82       	std	Z+7, r1	; 0x07
    8d3e:	0c 5f       	subi	r16, 0xFC	; 252
    8d40:	1f 4f       	sbci	r17, 0xFF	; 255
    8d42:	11 87       	std	Z+9, r17	; 0x09
    8d44:	00 87       	std	Z+8, r16	; 0x08
    8d46:	04 50       	subi	r16, 0x04	; 4
    8d48:	10 40       	sbci	r17, 0x00	; 0
    8d4a:	14 96       	adiw	r26, 0x04	; 4
    8d4c:	8c 91       	ld	r24, X
    8d4e:	82 87       	std	Z+10, r24	; 0x0a
    8d50:	13 86       	std	Z+11, r1	; 0x0b
    8d52:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			 lcd_print((i+1),1,lcdteks);
    8d56:	8d b7       	in	r24, 0x3d	; 61
    8d58:	9e b7       	in	r25, 0x3e	; 62
    8d5a:	0c 96       	adiw	r24, 0x0c	; 12
    8d5c:	0f b6       	in	r0, 0x3f	; 63
    8d5e:	f8 94       	cli
    8d60:	9e bf       	out	0x3e, r25	; 62
    8d62:	0f be       	out	0x3f, r0	; 63
    8d64:	8d bf       	out	0x3d, r24	; 61
    8d66:	80 2f       	mov	r24, r16
    8d68:	61 e0       	ldi	r22, 0x01	; 1
    8d6a:	a6 01       	movw	r20, r12
    8d6c:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    8d70:	08 94       	sec
    8d72:	e1 1c       	adc	r14, r1
    8d74:	f1 1c       	adc	r15, r1
    8d76:	0f 5f       	subi	r16, 0xFF	; 255
    8d78:	1f 4f       	sbci	r17, 0xFF	; 255
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    8d7a:	ea 14       	cp	r14, r10
    8d7c:	fb 04       	cpc	r15, r11
    8d7e:	31 f6       	brne	.-116    	; 0x8d0c <_scr_pump+0x6e>
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
			 lcd_print((i+1),1,lcdteks);
		}
        lcd_printf(4,15,PSTR("*)Exit"));
    8d80:	84 e0       	ldi	r24, 0x04	; 4
    8d82:	6f e0       	ldi	r22, 0x0F	; 15
    8d84:	41 e4       	ldi	r20, 0x41	; 65
    8d86:	5d e0       	ldi	r21, 0x0D	; 13
    8d88:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
}
    8d8c:	6c 96       	adiw	r28, 0x1c	; 28
    8d8e:	0f b6       	in	r0, 0x3f	; 63
    8d90:	f8 94       	cli
    8d92:	de bf       	out	0x3e, r29	; 62
    8d94:	0f be       	out	0x3f, r0	; 63
    8d96:	cd bf       	out	0x3d, r28	; 61
    8d98:	cf 91       	pop	r28
    8d9a:	df 91       	pop	r29
    8d9c:	1f 91       	pop	r17
    8d9e:	0f 91       	pop	r16
    8da0:	ff 90       	pop	r15
    8da2:	ef 90       	pop	r14
    8da4:	df 90       	pop	r13
    8da6:	cf 90       	pop	r12
    8da8:	bf 90       	pop	r11
    8daa:	af 90       	pop	r10
    8dac:	9f 90       	pop	r9
    8dae:	8f 90       	pop	r8
    8db0:	08 95       	ret

00008db2 <_menu_host>:
			lcd_print(__x, __y, __buff);
		}
	}
}

void _menu_host(void){
    8db2:	2f 92       	push	r2
    8db4:	3f 92       	push	r3
    8db6:	4f 92       	push	r4
    8db8:	5f 92       	push	r5
    8dba:	6f 92       	push	r6
    8dbc:	7f 92       	push	r7
    8dbe:	8f 92       	push	r8
    8dc0:	9f 92       	push	r9
    8dc2:	af 92       	push	r10
    8dc4:	bf 92       	push	r11
    8dc6:	cf 92       	push	r12
    8dc8:	df 92       	push	r13
    8dca:	ef 92       	push	r14
    8dcc:	ff 92       	push	r15
    8dce:	0f 93       	push	r16
    8dd0:	1f 93       	push	r17
    8dd2:	df 93       	push	r29
    8dd4:	cf 93       	push	r28
    8dd6:	cd b7       	in	r28, 0x3d	; 61
    8dd8:	de b7       	in	r29, 0x3e	; 62
    8dda:	6d 97       	sbiw	r28, 0x1d	; 29
    8ddc:	0f b6       	in	r0, 0x3f	; 63
    8dde:	f8 94       	cli
    8de0:	de bf       	out	0x3e, r29	; 62
    8de2:	0f be       	out	0x3f, r0	; 63
    8de4:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8de6:	e1 99       	sbic	0x1c, 1	; 28
    8de8:	fe cf       	rjmp	.-4      	; 0x8de6 <_menu_host+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8dea:	21 ec       	ldi	r18, 0xC1	; 193
    8dec:	33 e0       	ldi	r19, 0x03	; 3
    8dee:	3f bb       	out	0x1f, r19	; 31
    8df0:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8df2:	e0 9a       	sbi	0x1c, 0	; 28
    8df4:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[4];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];
	static char TermID;

	__value[0] = eeprom_read_byte(&DefPrintMoney);
    8df6:	89 83       	std	Y+1, r24	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8df8:	e1 99       	sbic	0x1c, 1	; 28
    8dfa:	fe cf       	rjmp	.-4      	; 0x8df8 <_menu_host+0x46>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8dfc:	f7 e3       	ldi	r31, 0x37	; 55
    8dfe:	2f 2e       	mov	r2, r31
    8e00:	f0 e0       	ldi	r31, 0x00	; 0
    8e02:	3f 2e       	mov	r3, r31
    8e04:	3f ba       	out	0x1f, r3	; 31
    8e06:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8e08:	e0 9a       	sbi	0x1c, 0	; 28
    8e0a:	8d b3       	in	r24, 0x1d	; 29
	__value[1] = eeprom_read_byte(&DefShowDateTime);
    8e0c:	8a 83       	std	Y+2, r24	; 0x02
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8e0e:	e1 99       	sbic	0x1c, 1	; 28
    8e10:	fe cf       	rjmp	.-4      	; 0x8e0e <_menu_host+0x5c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8e12:	e8 e3       	ldi	r30, 0x38	; 56
    8e14:	4e 2e       	mov	r4, r30
    8e16:	e0 e0       	ldi	r30, 0x00	; 0
    8e18:	5e 2e       	mov	r5, r30
    8e1a:	5f ba       	out	0x1f, r5	; 31
    8e1c:	4e ba       	out	0x1e, r4	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8e1e:	e0 9a       	sbi	0x1c, 0	; 28
    8e20:	8d b3       	in	r24, 0x1d	; 29
	__value[2] = eeprom_read_byte(&DefNotifScreen);
    8e22:	8b 83       	std	Y+3, r24	; 0x03
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8e24:	e1 99       	sbic	0x1c, 1	; 28
    8e26:	fe cf       	rjmp	.-4      	; 0x8e24 <_menu_host+0x72>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8e28:	70 e0       	ldi	r23, 0x00	; 0
    8e2a:	67 2e       	mov	r6, r23
    8e2c:	70 e0       	ldi	r23, 0x00	; 0
    8e2e:	77 2e       	mov	r7, r23
    8e30:	7f ba       	out	0x1f, r7	; 31
    8e32:	6e ba       	out	0x1e, r6	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8e34:	e0 9a       	sbi	0x1c, 0	; 28
    8e36:	8d b3       	in	r24, 0x1d	; 29
	TermID= eeprom_read_byte(&DefIFT_ID);
    8e38:	80 93 d1 02 	sts	0x02D1, r24


	lcd_clear();_delay_ms(10);
    8e3c:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
    8e40:	84 ec       	ldi	r24, 0xC4	; 196
    8e42:	99 e0       	ldi	r25, 0x09	; 9
    8e44:	01 97       	sbiw	r24, 0x01	; 1
    8e46:	f1 f7       	brne	.-4      	; 0x8e44 <_menu_host+0x92>
	lcd_printf(1, 1, PSTR("1)Money :"));
    8e48:	81 e0       	ldi	r24, 0x01	; 1
    8e4a:	61 e0       	ldi	r22, 0x01	; 1
    8e4c:	46 e4       	ldi	r20, 0x46	; 70
    8e4e:	5b e0       	ldi	r21, 0x0B	; 11
    8e50:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)D/T   :"));
    8e54:	82 e0       	ldi	r24, 0x02	; 2
    8e56:	61 e0       	ldi	r22, 0x01	; 1
    8e58:	4c e3       	ldi	r20, 0x3C	; 60
    8e5a:	5b e0       	ldi	r21, 0x0B	; 11
    8e5c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
    8e60:	83 e0       	ldi	r24, 0x03	; 3
    8e62:	61 e0       	ldi	r22, 0x01	; 1
    8e64:	47 e2       	ldi	r20, 0x27	; 39
    8e66:	5b e0       	ldi	r21, 0x0B	; 11
    8e68:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    8e6c:	00 d0       	rcall	.+0      	; 0x8e6e <_menu_host+0xbc>
    8e6e:	00 d0       	rcall	.+0      	; 0x8e70 <_menu_host+0xbe>
    8e70:	00 d0       	rcall	.+0      	; 0x8e72 <_menu_host+0xc0>
    8e72:	ed b7       	in	r30, 0x3d	; 61
    8e74:	fe b7       	in	r31, 0x3e	; 62
    8e76:	31 96       	adiw	r30, 0x01	; 1
    8e78:	8e 01       	movw	r16, r28
    8e7a:	06 5f       	subi	r16, 0xF6	; 246
    8e7c:	1f 4f       	sbci	r17, 0xFF	; 255
    8e7e:	ad b7       	in	r26, 0x3d	; 61
    8e80:	be b7       	in	r27, 0x3e	; 62
    8e82:	12 96       	adiw	r26, 0x02	; 2
    8e84:	1c 93       	st	X, r17
    8e86:	0e 93       	st	-X, r16
    8e88:	11 97       	sbiw	r26, 0x01	; 1
    8e8a:	8a e1       	ldi	r24, 0x1A	; 26
    8e8c:	9b e0       	ldi	r25, 0x0B	; 11
    8e8e:	93 83       	std	Z+3, r25	; 0x03
    8e90:	82 83       	std	Z+2, r24	; 0x02
    8e92:	80 91 d1 02 	lds	r24, 0x02D1
    8e96:	84 83       	std	Z+4, r24	; 0x04
    8e98:	15 82       	std	Z+5, r1	; 0x05
    8e9a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		 lcd_print(4, 1,lcdteks);
    8e9e:	ed b7       	in	r30, 0x3d	; 61
    8ea0:	fe b7       	in	r31, 0x3e	; 62
    8ea2:	36 96       	adiw	r30, 0x06	; 6
    8ea4:	0f b6       	in	r0, 0x3f	; 63
    8ea6:	f8 94       	cli
    8ea8:	fe bf       	out	0x3e, r31	; 62
    8eaa:	0f be       	out	0x3f, r0	; 63
    8eac:	ed bf       	out	0x3d, r30	; 61
    8eae:	84 e0       	ldi	r24, 0x04	; 4
    8eb0:	61 e0       	ldi	r22, 0x01	; 1
    8eb2:	a8 01       	movw	r20, r16
    8eb4:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
	lcd_printf(4, 15, PSTR("#)Save"));
    8eb8:	84 e0       	ldi	r24, 0x04	; 4
    8eba:	6f e0       	ldi	r22, 0x0F	; 15
    8ebc:	43 e1       	ldi	r20, 0x13	; 19
    8ebe:	5b e0       	ldi	r21, 0x0B	; 11
    8ec0:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
    8ec4:	68 ef       	ldi	r22, 0xF8	; 248
    8ec6:	e6 2e       	mov	r14, r22
    8ec8:	62 e0       	ldi	r22, 0x02	; 2
    8eca:	f6 2e       	mov	r15, r22
    8ecc:	6e 01       	movw	r12, r28
    8ece:	08 94       	sec
    8ed0:	c1 1c       	adc	r12, r1
    8ed2:	d1 1c       	adc	r13, r1

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
		__y = pgm_read_byte(&__hostloc[__i][1]);
		_f_inttostr(__buff, __value[__i]);
    8ed4:	55 e0       	ldi	r21, 0x05	; 5
    8ed6:	a5 2e       	mov	r10, r21
    8ed8:	b1 2c       	mov	r11, r1
    8eda:	ac 0e       	add	r10, r28
    8edc:	bd 1e       	adc	r11, r29
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
		 lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
    8ede:	f7 01       	movw	r30, r14
    8ee0:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__hostloc[__i][1]);
    8ee2:	08 94       	sec
    8ee4:	e1 1c       	adc	r14, r1
    8ee6:	f1 1c       	adc	r15, r1
    8ee8:	f7 01       	movw	r30, r14
    8eea:	14 91       	lpm	r17, Z+
		_f_inttostr(__buff, __value[__i]);
    8eec:	d6 01       	movw	r26, r12
    8eee:	4d 91       	ld	r20, X+
    8ef0:	6d 01       	movw	r12, r26
    8ef2:	50 e0       	ldi	r21, 0x00	; 0
    8ef4:	60 e0       	ldi	r22, 0x00	; 0
    8ef6:	70 e0       	ldi	r23, 0x00	; 0
    8ef8:	c5 01       	movw	r24, r10
    8efa:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_f_inttostr>
		lcd_print(__x, __y, __buff);
    8efe:	80 2f       	mov	r24, r16
    8f00:	61 2f       	mov	r22, r17
    8f02:	a5 01       	movw	r20, r10
    8f04:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    8f08:	08 94       	sec
    8f0a:	e1 1c       	adc	r14, r1
    8f0c:	f1 1c       	adc	r15, r1
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
		 lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
    8f0e:	be ef       	ldi	r27, 0xFE	; 254
    8f10:	eb 16       	cp	r14, r27
    8f12:	b2 e0       	ldi	r27, 0x02	; 2
    8f14:	fb 06       	cpc	r15, r27
    8f16:	19 f7       	brne	.-58     	; 0x8ede <_menu_host+0x12c>
			lcd_print(__x, __y, __buff);
		}else
		if (__num=='4'){
		    if (TermID<=99)TermID++;
			else TermID=1;
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    8f18:	4a e0       	ldi	r20, 0x0A	; 10
    8f1a:	a4 2e       	mov	r10, r20
    8f1c:	b1 2c       	mov	r11, r1
    8f1e:	ac 0e       	add	r10, r28
    8f20:	bd 1e       	adc	r11, r29
    8f22:	36 e0       	ldi	r19, 0x06	; 6
    8f24:	83 2e       	mov	r8, r19
    8f26:	3b e0       	ldi	r19, 0x0B	; 11
    8f28:	93 2e       	mov	r9, r19
			eeprom_write_byte(&DefNotifScreen, __value[2]);
			eeprom_write_byte(&DefIFT_ID,TermID);
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
			if(__value[__num - 0x31] == 1)
    8f2a:	6e 01       	movw	r12, r28
    8f2c:	08 94       	sec
    8f2e:	c1 1c       	adc	r12, r1
    8f30:	d1 1c       	adc	r13, r1
				__value[__num - 0x31] = 0;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
			_f_inttostr(__buff, __value[__num - 0x31]);
    8f32:	25 e0       	ldi	r18, 0x05	; 5
    8f34:	e2 2e       	mov	r14, r18
    8f36:	f1 2c       	mov	r15, r1
    8f38:	ec 0e       	add	r14, r28
    8f3a:	fd 1e       	adc	r15, r29
		_f_inttostr(__buff, __value[__i]);
		lcd_print(__x, __y, __buff);
	}

	while(1){
		__key = _key_scan(1);
    8f3c:	81 e0       	ldi	r24, 0x01	; 1
    8f3e:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    8f42:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    8f44:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
    8f48:	98 2f       	mov	r25, r24

		if(__key == _KEY_CANCEL)
    8f4a:	17 3e       	cpi	r17, 0xE7	; 231
    8f4c:	09 f4       	brne	.+2      	; 0x8f50 <_menu_host+0x19e>
    8f4e:	95 c0       	rjmp	.+298    	; 0x907a <_menu_host+0x2c8>
			return;
		if(__key==_KEY_ENTER){
    8f50:	17 3b       	cpi	r17, 0xB7	; 183
    8f52:	09 f0       	breq	.+2      	; 0x8f56 <_menu_host+0x1a4>
    8f54:	30 c0       	rjmp	.+96     	; 0x8fb6 <_menu_host+0x204>
			eeprom_write_byte(&DefPrintMoney, __value[0]);
    8f56:	89 81       	ldd	r24, Y+1	; 0x01
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8f58:	e1 99       	sbic	0x1c, 1	; 28
    8f5a:	fe cf       	rjmp	.-4      	; 0x8f58 <_menu_host+0x1a6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8f5c:	e1 ec       	ldi	r30, 0xC1	; 193
    8f5e:	f3 e0       	ldi	r31, 0x03	; 3
    8f60:	ff bb       	out	0x1f, r31	; 31
    8f62:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    8f64:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8f66:	0f b6       	in	r0, 0x3f	; 63
    8f68:	f8 94       	cli
    8f6a:	e2 9a       	sbi	0x1c, 2	; 28
    8f6c:	e1 9a       	sbi	0x1c, 1	; 28
    8f6e:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefShowDateTime, __value[1]);
    8f70:	8a 81       	ldd	r24, Y+2	; 0x02
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8f72:	e1 99       	sbic	0x1c, 1	; 28
    8f74:	fe cf       	rjmp	.-4      	; 0x8f72 <_menu_host+0x1c0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8f76:	3f ba       	out	0x1f, r3	; 31
    8f78:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    8f7a:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8f7c:	0f b6       	in	r0, 0x3f	; 63
    8f7e:	f8 94       	cli
    8f80:	e2 9a       	sbi	0x1c, 2	; 28
    8f82:	e1 9a       	sbi	0x1c, 1	; 28
    8f84:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefNotifScreen, __value[2]);
    8f86:	8b 81       	ldd	r24, Y+3	; 0x03
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8f88:	e1 99       	sbic	0x1c, 1	; 28
    8f8a:	fe cf       	rjmp	.-4      	; 0x8f88 <_menu_host+0x1d6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8f8c:	5f ba       	out	0x1f, r5	; 31
    8f8e:	4e ba       	out	0x1e, r4	; 30
#endif
    EEDR = __value;
    8f90:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8f92:	0f b6       	in	r0, 0x3f	; 63
    8f94:	f8 94       	cli
    8f96:	e2 9a       	sbi	0x1c, 2	; 28
    8f98:	e1 9a       	sbi	0x1c, 1	; 28
    8f9a:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefIFT_ID,TermID);
    8f9c:	80 91 d1 02 	lds	r24, 0x02D1
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8fa0:	e1 99       	sbic	0x1c, 1	; 28
    8fa2:	fe cf       	rjmp	.-4      	; 0x8fa0 <_menu_host+0x1ee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8fa4:	7f ba       	out	0x1f, r7	; 31
    8fa6:	6e ba       	out	0x1e, r6	; 30
#endif
    EEDR = __value;
    8fa8:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8faa:	0f b6       	in	r0, 0x3f	; 63
    8fac:	f8 94       	cli
    8fae:	e2 9a       	sbi	0x1c, 2	; 28
    8fb0:	e1 9a       	sbi	0x1c, 1	; 28
    8fb2:	0f be       	out	0x3f, r0	; 63
    8fb4:	62 c0       	rjmp	.+196    	; 0x907a <_menu_host+0x2c8>
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
    8fb6:	81 53       	subi	r24, 0x31	; 49
    8fb8:	83 30       	cpi	r24, 0x03	; 3
    8fba:	58 f5       	brcc	.+86     	; 0x9012 <_menu_host+0x260>
			if(__value[__num - 0x31] == 1)
    8fbc:	a9 2f       	mov	r26, r25
    8fbe:	b0 e0       	ldi	r27, 0x00	; 0
    8fc0:	d1 97       	sbiw	r26, 0x31	; 49
    8fc2:	f6 01       	movw	r30, r12
    8fc4:	ea 0f       	add	r30, r26
    8fc6:	fb 1f       	adc	r31, r27
    8fc8:	80 81       	ld	r24, Z
    8fca:	81 30       	cpi	r24, 0x01	; 1
    8fcc:	11 f4       	brne	.+4      	; 0x8fd2 <_menu_host+0x220>
				__value[__num - 0x31] = 0;
    8fce:	10 82       	st	Z, r1
    8fd0:	02 c0       	rjmp	.+4      	; 0x8fd6 <_menu_host+0x224>
			else
				__value[__num - 0x31]++;
    8fd2:	8f 5f       	subi	r24, 0xFF	; 255
    8fd4:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
    8fd6:	29 2f       	mov	r18, r25
    8fd8:	30 e0       	ldi	r19, 0x00	; 0
    8fda:	21 53       	subi	r18, 0x31	; 49
    8fdc:	30 40       	sbci	r19, 0x00	; 0
    8fde:	22 0f       	add	r18, r18
    8fe0:	33 1f       	adc	r19, r19
    8fe2:	c9 01       	movw	r24, r18
    8fe4:	88 50       	subi	r24, 0x08	; 8
    8fe6:	9d 4f       	sbci	r25, 0xFD	; 253
    8fe8:	fc 01       	movw	r30, r24
    8fea:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
    8fec:	27 50       	subi	r18, 0x07	; 7
    8fee:	3d 4f       	sbci	r19, 0xFD	; 253
    8ff0:	f9 01       	movw	r30, r18
    8ff2:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __value[__num - 0x31]);
    8ff4:	ac 0d       	add	r26, r12
    8ff6:	bd 1d       	adc	r27, r13
    8ff8:	4c 91       	ld	r20, X
    8ffa:	50 e0       	ldi	r21, 0x00	; 0
    8ffc:	60 e0       	ldi	r22, 0x00	; 0
    8ffe:	70 e0       	ldi	r23, 0x00	; 0
    9000:	c7 01       	movw	r24, r14
    9002:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_f_inttostr>
			lcd_print(__x, __y, __buff);
    9006:	80 2f       	mov	r24, r16
    9008:	61 2f       	mov	r22, r17
    900a:	a7 01       	movw	r20, r14
    900c:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    9010:	95 cf       	rjmp	.-214    	; 0x8f3c <_menu_host+0x18a>
		}else
		if (__num=='4'){
    9012:	94 33       	cpi	r25, 0x34	; 52
    9014:	09 f0       	breq	.+2      	; 0x9018 <_menu_host+0x266>
    9016:	92 cf       	rjmp	.-220    	; 0x8f3c <_menu_host+0x18a>
		    if (TermID<=99)TermID++;
    9018:	80 91 d1 02 	lds	r24, 0x02D1
    901c:	84 36       	cpi	r24, 0x64	; 100
    901e:	10 f4       	brcc	.+4      	; 0x9024 <_menu_host+0x272>
    9020:	8f 5f       	subi	r24, 0xFF	; 255
    9022:	01 c0       	rjmp	.+2      	; 0x9026 <_menu_host+0x274>
			else TermID=1;
    9024:	81 e0       	ldi	r24, 0x01	; 1
    9026:	80 93 d1 02 	sts	0x02D1, r24
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    902a:	00 d0       	rcall	.+0      	; 0x902c <_menu_host+0x27a>
    902c:	00 d0       	rcall	.+0      	; 0x902e <_menu_host+0x27c>
    902e:	00 d0       	rcall	.+0      	; 0x9030 <_menu_host+0x27e>
    9030:	ed b7       	in	r30, 0x3d	; 61
    9032:	fe b7       	in	r31, 0x3e	; 62
    9034:	31 96       	adiw	r30, 0x01	; 1
    9036:	ad b7       	in	r26, 0x3d	; 61
    9038:	be b7       	in	r27, 0x3e	; 62
    903a:	12 96       	adiw	r26, 0x02	; 2
    903c:	bc 92       	st	X, r11
    903e:	ae 92       	st	-X, r10
    9040:	11 97       	sbiw	r26, 0x01	; 1
    9042:	93 82       	std	Z+3, r9	; 0x03
    9044:	82 82       	std	Z+2, r8	; 0x02
    9046:	80 91 d1 02 	lds	r24, 0x02D1
    904a:	84 83       	std	Z+4, r24	; 0x04
    904c:	15 82       	std	Z+5, r1	; 0x05
    904e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		 lcd_print(4, 1,lcdteks);lcd_printf(4, 15, PSTR("#)Save"));
    9052:	ed b7       	in	r30, 0x3d	; 61
    9054:	fe b7       	in	r31, 0x3e	; 62
    9056:	36 96       	adiw	r30, 0x06	; 6
    9058:	0f b6       	in	r0, 0x3f	; 63
    905a:	f8 94       	cli
    905c:	fe bf       	out	0x3e, r31	; 62
    905e:	0f be       	out	0x3f, r0	; 63
    9060:	ed bf       	out	0x3d, r30	; 61
    9062:	84 e0       	ldi	r24, 0x04	; 4
    9064:	61 e0       	ldi	r22, 0x01	; 1
    9066:	a5 01       	movw	r20, r10
    9068:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    906c:	84 e0       	ldi	r24, 0x04	; 4
    906e:	6f e0       	ldi	r22, 0x0F	; 15
    9070:	4f ef       	ldi	r20, 0xFF	; 255
    9072:	5a e0       	ldi	r21, 0x0A	; 10
    9074:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
    9078:	61 cf       	rjmp	.-318    	; 0x8f3c <_menu_host+0x18a>
		 
		}

	}
}
    907a:	6d 96       	adiw	r28, 0x1d	; 29
    907c:	0f b6       	in	r0, 0x3f	; 63
    907e:	f8 94       	cli
    9080:	de bf       	out	0x3e, r29	; 62
    9082:	0f be       	out	0x3f, r0	; 63
    9084:	cd bf       	out	0x3d, r28	; 61
    9086:	cf 91       	pop	r28
    9088:	df 91       	pop	r29
    908a:	1f 91       	pop	r17
    908c:	0f 91       	pop	r16
    908e:	ff 90       	pop	r15
    9090:	ef 90       	pop	r14
    9092:	df 90       	pop	r13
    9094:	cf 90       	pop	r12
    9096:	bf 90       	pop	r11
    9098:	af 90       	pop	r10
    909a:	9f 90       	pop	r9
    909c:	8f 90       	pop	r8
    909e:	7f 90       	pop	r7
    90a0:	6f 90       	pop	r6
    90a2:	5f 90       	pop	r5
    90a4:	4f 90       	pop	r4
    90a6:	3f 90       	pop	r3
    90a8:	2f 90       	pop	r2
    90aa:	08 95       	ret

000090ac <FSettingHost>:
char FSettingPrinter(){
     _menu_printer();
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
    90ac:	0e 94 d9 46 	call	0x8db2	; 0x8db2 <_menu_host>
	 return MENU_DONE;
}
    90b0:	81 e0       	ldi	r24, 0x01	; 1
    90b2:	08 95       	ret

000090b4 <_menu_pumpprodinput>:
//**********************************************************************
// subrutin merubah produk
// parameter di simpan di __pump_prod
//**********************************************************************

void _menu_pumpprodinput(unsigned char __select){
    90b4:	8f 92       	push	r8
    90b6:	9f 92       	push	r9
    90b8:	af 92       	push	r10
    90ba:	bf 92       	push	r11
    90bc:	cf 92       	push	r12
    90be:	df 92       	push	r13
    90c0:	ef 92       	push	r14
    90c2:	ff 92       	push	r15
    90c4:	0f 93       	push	r16
    90c6:	1f 93       	push	r17
    90c8:	df 93       	push	r29
    90ca:	cf 93       	push	r28
    90cc:	cd b7       	in	r28, 0x3d	; 61
    90ce:	de b7       	in	r29, 0x3e	; 62
    90d0:	a7 97       	sbiw	r28, 0x27	; 39
    90d2:	0f b6       	in	r0, 0x3f	; 63
    90d4:	f8 94       	cli
    90d6:	de bf       	out	0x3e, r29	; 62
    90d8:	0f be       	out	0x3f, r0	; 63
    90da:	cd bf       	out	0x3d, r28	; 61
    90dc:	b8 2e       	mov	r11, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    90de:	8e 01       	movw	r16, r28
    90e0:	04 5f       	subi	r16, 0xF4	; 244
    90e2:	1f 4f       	sbci	r17, 0xFF	; 255
    90e4:	c8 01       	movw	r24, r16
    90e6:	65 e4       	ldi	r22, 0x45	; 69
    90e8:	70 e0       	ldi	r23, 0x00	; 0
    90ea:	48 e0       	ldi	r20, 0x08	; 8
    90ec:	50 e0       	ldi	r21, 0x00	; 0
    90ee:	28 ef       	ldi	r18, 0xF8	; 248
    90f0:	32 e1       	ldi	r19, 0x12	; 18
    90f2:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
	char 			__pump_prod[6],__pump_id[8];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];

	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	eeprom_read_block((void*) &__pump_prod, (const void*) &DefNozzleMap[__select], 6);
    90f6:	86 e0       	ldi	r24, 0x06	; 6
    90f8:	b8 9e       	mul	r11, r24
    90fa:	40 01       	movw	r8, r0
    90fc:	11 24       	eor	r1, r1
    90fe:	85 e5       	ldi	r24, 0x55	; 85
    9100:	90 e0       	ldi	r25, 0x00	; 0
    9102:	88 0e       	add	r8, r24
    9104:	99 1e       	adc	r9, r25
    9106:	26 e0       	ldi	r18, 0x06	; 6
    9108:	c2 2e       	mov	r12, r18
    910a:	d1 2c       	mov	r13, r1
    910c:	cc 0e       	add	r12, r28
    910e:	dd 1e       	adc	r13, r29
    9110:	c6 01       	movw	r24, r12
    9112:	b4 01       	movw	r22, r8
    9114:	46 e0       	ldi	r20, 0x06	; 6
    9116:	50 e0       	ldi	r21, 0x00	; 0
    9118:	28 ef       	ldi	r18, 0xF8	; 248
    911a:	32 e1       	ldi	r19, 0x12	; 18
    911c:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>

	lcd_clear();_delay_ms(10);
    9120:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
    9124:	84 ec       	ldi	r24, 0xC4	; 196
    9126:	99 e0       	ldi	r25, 0x09	; 9
    9128:	01 97       	sbiw	r24, 0x01	; 1
    912a:	f1 f7       	brne	.-4      	; 0x9128 <_menu_pumpprodinput+0x74>
    sprintf_P(lcdteks, PSTR("Product FIP%.2d"),__pump_id[__select]);
    912c:	00 d0       	rcall	.+0      	; 0x912e <_menu_pumpprodinput+0x7a>
    912e:	00 d0       	rcall	.+0      	; 0x9130 <_menu_pumpprodinput+0x7c>
    9130:	00 d0       	rcall	.+0      	; 0x9132 <_menu_pumpprodinput+0x7e>
    9132:	ed b7       	in	r30, 0x3d	; 61
    9134:	fe b7       	in	r31, 0x3e	; 62
    9136:	31 96       	adiw	r30, 0x01	; 1
    9138:	94 e1       	ldi	r25, 0x14	; 20
    913a:	e9 2e       	mov	r14, r25
    913c:	f1 2c       	mov	r15, r1
    913e:	ec 0e       	add	r14, r28
    9140:	fd 1e       	adc	r15, r29
    9142:	ad b7       	in	r26, 0x3d	; 61
    9144:	be b7       	in	r27, 0x3e	; 62
    9146:	12 96       	adiw	r26, 0x02	; 2
    9148:	fc 92       	st	X, r15
    914a:	ee 92       	st	-X, r14
    914c:	11 97       	sbiw	r26, 0x01	; 1
    914e:	88 ef       	ldi	r24, 0xF8	; 248
    9150:	9b e0       	ldi	r25, 0x0B	; 11
    9152:	93 83       	std	Z+3, r25	; 0x03
    9154:	82 83       	std	Z+2, r24	; 0x02
    9156:	0b 0d       	add	r16, r11
    9158:	11 1d       	adc	r17, r1
    915a:	d8 01       	movw	r26, r16
    915c:	8c 91       	ld	r24, X
    915e:	84 83       	std	Z+4, r24	; 0x04
    9160:	15 82       	std	Z+5, r1	; 0x05
    9162:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    lcd_print(1, 1,lcdteks);
    9166:	ed b7       	in	r30, 0x3d	; 61
    9168:	fe b7       	in	r31, 0x3e	; 62
    916a:	36 96       	adiw	r30, 0x06	; 6
    916c:	0f b6       	in	r0, 0x3f	; 63
    916e:	f8 94       	cli
    9170:	fe bf       	out	0x3e, r31	; 62
    9172:	0f be       	out	0x3f, r0	; 63
    9174:	ed bf       	out	0x3d, r30	; 61
    9176:	81 e0       	ldi	r24, 0x01	; 1
    9178:	61 e0       	ldi	r22, 0x01	; 1
    917a:	a7 01       	movw	r20, r14
    917c:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
    9180:	82 e0       	ldi	r24, 0x02	; 2
    9182:	61 e0       	ldi	r22, 0x01	; 1
    9184:	44 ee       	ldi	r20, 0xE4	; 228
    9186:	5b e0       	ldi	r21, 0x0B	; 11
    9188:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
    918c:	83 e0       	ldi	r24, 0x03	; 3
    918e:	61 e0       	ldi	r22, 0x01	; 1
    9190:	40 ed       	ldi	r20, 0xD0	; 208
    9192:	5b e0       	ldi	r21, 0x0B	; 11
    9194:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));
    9198:	84 e0       	ldi	r24, 0x04	; 4
    919a:	61 e0       	ldi	r22, 0x01	; 1
    919c:	4b eb       	ldi	r20, 0xBB	; 187
    919e:	5b e0       	ldi	r21, 0x0B	; 11
    91a0:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
    91a4:	84 ed       	ldi	r24, 0xD4	; 212
    91a6:	e8 2e       	mov	r14, r24
    91a8:	82 e0       	ldi	r24, 0x02	; 2
    91aa:	f8 2e       	mov	r15, r24

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prodloc[__i][0]);
		__y = pgm_read_byte(&__prodloc[__i][1]);
		_f_inttostr(__buff, __pump_prod[__i]);
    91ac:	5e 01       	movw	r10, r28
    91ae:	08 94       	sec
    91b0:	a1 1c       	adc	r10, r1
    91b2:	b1 1c       	adc	r11, r1
	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prodloc[__i][0]);
    91b4:	f7 01       	movw	r30, r14
    91b6:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__prodloc[__i][1]);
    91b8:	08 94       	sec
    91ba:	e1 1c       	adc	r14, r1
    91bc:	f1 1c       	adc	r15, r1
    91be:	f7 01       	movw	r30, r14
    91c0:	14 91       	lpm	r17, Z+
		_f_inttostr(__buff, __pump_prod[__i]);
    91c2:	d6 01       	movw	r26, r12
    91c4:	4d 91       	ld	r20, X+
    91c6:	6d 01       	movw	r12, r26
    91c8:	50 e0       	ldi	r21, 0x00	; 0
    91ca:	60 e0       	ldi	r22, 0x00	; 0
    91cc:	70 e0       	ldi	r23, 0x00	; 0
    91ce:	c5 01       	movw	r24, r10
    91d0:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_f_inttostr>
		lcd_print(__x+1, __y, __buff);
    91d4:	80 2f       	mov	r24, r16
    91d6:	8f 5f       	subi	r24, 0xFF	; 255
    91d8:	61 2f       	mov	r22, r17
    91da:	a5 01       	movw	r20, r10
    91dc:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    91e0:	08 94       	sec
    91e2:	e1 1c       	adc	r14, r1
    91e4:	f1 1c       	adc	r15, r1

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(__i = 0; __i < 6; __i++){
    91e6:	b0 ee       	ldi	r27, 0xE0	; 224
    91e8:	eb 16       	cp	r14, r27
    91ea:	b2 e0       	ldi	r27, 0x02	; 2
    91ec:	fb 06       	cpc	r15, r27
    91ee:	11 f7       	brne	.-60     	; 0x91b4 <_menu_pumpprodinput+0x100>
		if(__key == _KEY_ENTER){
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
			if(__pump_prod[__num - '1'] == 6)
    91f0:	06 e0       	ldi	r16, 0x06	; 6
    91f2:	c0 2e       	mov	r12, r16
    91f4:	d1 2c       	mov	r13, r1
    91f6:	cc 0e       	add	r12, r28
    91f8:	dd 1e       	adc	r13, r29
			else
				__pump_prod[__num - '1']++;

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
			_f_inttostr(__buff, __pump_prod[__num - 0x31]);
    91fa:	7e 01       	movw	r14, r28
    91fc:	08 94       	sec
    91fe:	e1 1c       	adc	r14, r1
    9200:	f1 1c       	adc	r15, r1
		lcd_print(__x+1, __y, __buff);
	}

	while(1){
		
		__key = _key_scan(1);
    9202:	81 e0       	ldi	r24, 0x01	; 1
    9204:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    9208:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    920a:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
    920e:	98 2f       	mov	r25, r24
		if(__key == _KEY_CANCEL)
    9210:	17 3e       	cpi	r17, 0xE7	; 231
    9212:	09 f4       	brne	.+2      	; 0x9216 <_menu_pumpprodinput+0x162>
    9214:	3c c0       	rjmp	.+120    	; 0x928e <_menu_pumpprodinput+0x1da>
			return;
		if(__key == _KEY_ENTER){
    9216:	17 3b       	cpi	r17, 0xB7	; 183
    9218:	59 f4       	brne	.+22     	; 0x9230 <_menu_pumpprodinput+0x17c>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    921a:	c4 01       	movw	r24, r8
    921c:	be 01       	movw	r22, r28
    921e:	6a 5f       	subi	r22, 0xFA	; 250
    9220:	7f 4f       	sbci	r23, 0xFF	; 255
    9222:	46 e0       	ldi	r20, 0x06	; 6
    9224:	50 e0       	ldi	r21, 0x00	; 0
    9226:	20 e0       	ldi	r18, 0x00	; 0
    9228:	33 e1       	ldi	r19, 0x13	; 19
    922a:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    922e:	2f c0       	rjmp	.+94     	; 0x928e <_menu_pumpprodinput+0x1da>
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
    9230:	81 53       	subi	r24, 0x31	; 49
    9232:	86 30       	cpi	r24, 0x06	; 6
    9234:	30 f7       	brcc	.-52     	; 0x9202 <_menu_pumpprodinput+0x14e>
			if(__pump_prod[__num - '1'] == 6)
    9236:	a9 2f       	mov	r26, r25
    9238:	b0 e0       	ldi	r27, 0x00	; 0
    923a:	d1 97       	sbiw	r26, 0x31	; 49
    923c:	f6 01       	movw	r30, r12
    923e:	ea 0f       	add	r30, r26
    9240:	fb 1f       	adc	r31, r27
    9242:	80 81       	ld	r24, Z
    9244:	86 30       	cpi	r24, 0x06	; 6
    9246:	11 f4       	brne	.+4      	; 0x924c <_menu_pumpprodinput+0x198>
				__pump_prod[__num - '1'] = 0;
    9248:	10 82       	st	Z, r1
    924a:	02 c0       	rjmp	.+4      	; 0x9250 <_menu_pumpprodinput+0x19c>
			else
				__pump_prod[__num - '1']++;
    924c:	8f 5f       	subi	r24, 0xFF	; 255
    924e:	80 83       	st	Z, r24

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
    9250:	29 2f       	mov	r18, r25
    9252:	30 e0       	ldi	r19, 0x00	; 0
    9254:	21 53       	subi	r18, 0x31	; 49
    9256:	30 40       	sbci	r19, 0x00	; 0
    9258:	22 0f       	add	r18, r18
    925a:	33 1f       	adc	r19, r19
    925c:	c9 01       	movw	r24, r18
    925e:	8c 52       	subi	r24, 0x2C	; 44
    9260:	9d 4f       	sbci	r25, 0xFD	; 253
    9262:	fc 01       	movw	r30, r24
    9264:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
    9266:	2b 52       	subi	r18, 0x2B	; 43
    9268:	3d 4f       	sbci	r19, 0xFD	; 253
    926a:	f9 01       	movw	r30, r18
    926c:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __pump_prod[__num - 0x31]);
    926e:	ac 0d       	add	r26, r12
    9270:	bd 1d       	adc	r27, r13
    9272:	4c 91       	ld	r20, X
    9274:	50 e0       	ldi	r21, 0x00	; 0
    9276:	60 e0       	ldi	r22, 0x00	; 0
    9278:	70 e0       	ldi	r23, 0x00	; 0
    927a:	c7 01       	movw	r24, r14
    927c:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_f_inttostr>
			lcd_print(__x+1, __y, __buff);
    9280:	80 2f       	mov	r24, r16
    9282:	8f 5f       	subi	r24, 0xFF	; 255
    9284:	61 2f       	mov	r22, r17
    9286:	a7 01       	movw	r20, r14
    9288:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    928c:	ba cf       	rjmp	.-140    	; 0x9202 <_menu_pumpprodinput+0x14e>
		}
	}
}
    928e:	a7 96       	adiw	r28, 0x27	; 39
    9290:	0f b6       	in	r0, 0x3f	; 63
    9292:	f8 94       	cli
    9294:	de bf       	out	0x3e, r29	; 62
    9296:	0f be       	out	0x3f, r0	; 63
    9298:	cd bf       	out	0x3d, r28	; 61
    929a:	cf 91       	pop	r28
    929c:	df 91       	pop	r29
    929e:	1f 91       	pop	r17
    92a0:	0f 91       	pop	r16
    92a2:	ff 90       	pop	r15
    92a4:	ef 90       	pop	r14
    92a6:	df 90       	pop	r13
    92a8:	cf 90       	pop	r12
    92aa:	bf 90       	pop	r11
    92ac:	af 90       	pop	r10
    92ae:	9f 90       	pop	r9
    92b0:	8f 90       	pop	r8
    92b2:	08 95       	ret

000092b4 <_menu_pumpprod>:
	       break;
	   }	   
	}
}

void _menu_pumpprod(void){
    92b4:	cf 93       	push	r28
    92b6:	df 93       	push	r29
    92b8:	c4 ec       	ldi	r28, 0xC4	; 196
    92ba:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;
	//char __pump_id[8];
	while(1){
		lcd_clear();_delay_ms(10);
    92bc:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
    92c0:	ce 01       	movw	r24, r28
    92c2:	01 97       	sbiw	r24, 0x01	; 1
    92c4:	f1 f7       	brne	.-4      	; 0x92c2 <_menu_pumpprod+0xe>
		_scr_pump();
    92c6:	0e 94 4f 46 	call	0x8c9e	; 0x8c9e <_scr_pump>
		while(1){
			__key = _key_scan(1);
    92ca:	81 e0       	ldi	r24, 0x01	; 1
    92cc:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
			if( __key == _KEY_1 || __key == _KEY_2 || __key == _KEY_3 ||
    92d0:	8e 3e       	cpi	r24, 0xEE	; 238
    92d2:	71 f0       	breq	.+28     	; 0x92f0 <_menu_pumpprod+0x3c>
    92d4:	8e 3d       	cpi	r24, 0xDE	; 222
    92d6:	61 f0       	breq	.+24     	; 0x92f0 <_menu_pumpprod+0x3c>
    92d8:	8e 3b       	cpi	r24, 0xBE	; 190
    92da:	51 f0       	breq	.+20     	; 0x92f0 <_menu_pumpprod+0x3c>
    92dc:	8d 3e       	cpi	r24, 0xED	; 237
    92de:	41 f0       	breq	.+16     	; 0x92f0 <_menu_pumpprod+0x3c>
    92e0:	8d 3d       	cpi	r24, 0xDD	; 221
    92e2:	31 f0       	breq	.+12     	; 0x92f0 <_menu_pumpprod+0x3c>
    92e4:	8d 3b       	cpi	r24, 0xBD	; 189
    92e6:	21 f0       	breq	.+8      	; 0x92f0 <_menu_pumpprod+0x3c>
    92e8:	8b 3e       	cpi	r24, 0xEB	; 235
    92ea:	11 f0       	breq	.+4      	; 0x92f0 <_menu_pumpprod+0x3c>
    92ec:	8b 3d       	cpi	r24, 0xDB	; 219
    92ee:	31 f4       	brne	.+12     	; 0x92fc <_menu_pumpprod+0x48>
				__key == _KEY_4 || __key == _KEY_5 || __key == _KEY_6 ||
				__key == _KEY_7 || __key == _KEY_8){
				_menu_pumpprodinput(_key_btn(__key) - 0x31);
    92f0:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
    92f4:	81 53       	subi	r24, 0x31	; 49
    92f6:	0e 94 5a 48 	call	0x90b4	; 0x90b4 <_menu_pumpprodinput>
    92fa:	e0 cf       	rjmp	.-64     	; 0x92bc <_menu_pumpprod+0x8>
				break;
			}
			if(__key == _KEY_CANCEL)
    92fc:	87 3e       	cpi	r24, 0xE7	; 231
    92fe:	29 f7       	brne	.-54     	; 0x92ca <_menu_pumpprod+0x16>
				return;
		}
	}
}
    9300:	df 91       	pop	r29
    9302:	cf 91       	pop	r28
    9304:	08 95       	ret

00009306 <FMenuPumpLabel>:
		       break;		         
	      }
	 }     
}

void FMenuPumpLabel(){
    9306:	6f 92       	push	r6
    9308:	7f 92       	push	r7
    930a:	8f 92       	push	r8
    930c:	9f 92       	push	r9
    930e:	af 92       	push	r10
    9310:	bf 92       	push	r11
    9312:	cf 92       	push	r12
    9314:	df 92       	push	r13
    9316:	ef 92       	push	r14
    9318:	ff 92       	push	r15
    931a:	1f 93       	push	r17
    931c:	df 93       	push	r29
    931e:	cf 93       	push	r28
    9320:	cd b7       	in	r28, 0x3d	; 61
    9322:	de b7       	in	r29, 0x3e	; 62
    9324:	2d 97       	sbiw	r28, 0x0d	; 13
    9326:	0f b6       	in	r0, 0x3f	; 63
    9328:	f8 94       	cli
    932a:	de bf       	out	0x3e, r29	; 62
    932c:	0f be       	out	0x3f, r0	; 63
    932e:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9330:	76 e0       	ldi	r23, 0x06	; 6
    9332:	c7 2e       	mov	r12, r23
    9334:	d1 2c       	mov	r13, r1
    9336:	cc 0e       	add	r12, r28
    9338:	dd 1e       	adc	r13, r29
    933a:	c6 01       	movw	r24, r12
    933c:	6d e4       	ldi	r22, 0x4D	; 77
    933e:	70 e0       	ldi	r23, 0x00	; 0
    9340:	48 e0       	ldi	r20, 0x08	; 8
    9342:	50 e0       	ldi	r21, 0x00	; 0
    9344:	28 ef       	ldi	r18, 0xF8	; 248
    9346:	32 e1       	ldi	r19, 0x12	; 18
    9348:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
	char PPumpLabel[8];
	unsigned char i, xPos,yPos,KeyPressed,KeyChar,strLabel[5];
	static char MaxCountId=16;

	eeprom_read_block((void*) &PPumpLabel, (const void*) &DefPumpLabel, 8);
	MaxCountId=99;
    934c:	83 e6       	ldi	r24, 0x63	; 99
    934e:	80 93 56 01 	sts	0x0156, r24
	lcd_clear();_delay_ms(10);
    9352:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
    9356:	84 ec       	ldi	r24, 0xC4	; 196
    9358:	99 e0       	ldi	r25, 0x09	; 9
    935a:	01 97       	sbiw	r24, 0x01	; 1
    935c:	f1 f7       	brne	.-4      	; 0x935a <FMenuPumpLabel+0x54>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
    935e:	81 e0       	ldi	r24, 0x01	; 1
    9360:	61 e0       	ldi	r22, 0x01	; 1
    9362:	43 ef       	ldi	r20, 0xF3	; 243
    9364:	5c e0       	ldi	r21, 0x0C	; 12
    9366:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
    936a:	82 e0       	ldi	r24, 0x02	; 2
    936c:	61 e0       	ldi	r22, 0x01	; 1
    936e:	47 ee       	ldi	r20, 0xE7	; 231
    9370:	5c e0       	ldi	r21, 0x0C	; 12
    9372:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
    9376:	83 e0       	ldi	r24, 0x03	; 3
    9378:	61 e0       	ldi	r22, 0x01	; 1
    937a:	42 ed       	ldi	r20, 0xD2	; 210
    937c:	5c e0       	ldi	r21, 0x0C	; 12
    937e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    9382:	84 e0       	ldi	r24, 0x04	; 4
    9384:	61 e0       	ldi	r22, 0x01	; 1
    9386:	4d eb       	ldi	r20, 0xBD	; 189
    9388:	5c e0       	ldi	r21, 0x0C	; 12
    938a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
    938e:	76 01       	movw	r14, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    9390:	5e 01       	movw	r10, r28
    9392:	08 94       	sec
    9394:	a1 1c       	adc	r10, r1
    9396:	b1 1c       	adc	r11, r1
    9398:	68 eb       	ldi	r22, 0xB8	; 184
    939a:	66 2e       	mov	r6, r22
    939c:	6c e0       	ldi	r22, 0x0C	; 12
    939e:	76 2e       	mov	r7, r22
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    93a0:	5e e0       	ldi	r21, 0x0E	; 14
    93a2:	85 2e       	mov	r8, r21
    93a4:	91 2c       	mov	r9, r1
    93a6:	8c 0e       	add	r8, r28
    93a8:	9d 1e       	adc	r9, r29
	MaxCountId=99;
	lcd_clear();_delay_ms(10);
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    93aa:	1e 2d       	mov	r17, r14
    93ac:	1c 19       	sub	r17, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    93ae:	00 d0       	rcall	.+0      	; 0x93b0 <FMenuPumpLabel+0xaa>
    93b0:	00 d0       	rcall	.+0      	; 0x93b2 <FMenuPumpLabel+0xac>
    93b2:	00 d0       	rcall	.+0      	; 0x93b4 <FMenuPumpLabel+0xae>
    93b4:	ed b7       	in	r30, 0x3d	; 61
    93b6:	fe b7       	in	r31, 0x3e	; 62
    93b8:	31 96       	adiw	r30, 0x01	; 1
    93ba:	ad b7       	in	r26, 0x3d	; 61
    93bc:	be b7       	in	r27, 0x3e	; 62
    93be:	12 96       	adiw	r26, 0x02	; 2
    93c0:	bc 92       	st	X, r11
    93c2:	ae 92       	st	-X, r10
    93c4:	11 97       	sbiw	r26, 0x01	; 1
    93c6:	73 82       	std	Z+3, r7	; 0x03
    93c8:	62 82       	std	Z+2, r6	; 0x02
    93ca:	d7 01       	movw	r26, r14
    93cc:	8d 91       	ld	r24, X+
    93ce:	7d 01       	movw	r14, r26
    93d0:	84 83       	std	Z+4, r24	; 0x04
    93d2:	15 82       	std	Z+5, r1	; 0x05
    93d4:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		xPos=1+(i%4);
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
    93d8:	ed b7       	in	r30, 0x3d	; 61
    93da:	fe b7       	in	r31, 0x3e	; 62
    93dc:	36 96       	adiw	r30, 0x06	; 6
    93de:	0f b6       	in	r0, 0x3f	; 63
    93e0:	f8 94       	cli
    93e2:	fe bf       	out	0x3e, r31	; 62
    93e4:	0f be       	out	0x3f, r0	; 63
    93e6:	ed bf       	out	0x3d, r30	; 61
    93e8:	61 2f       	mov	r22, r17
    93ea:	66 95       	lsr	r22
    93ec:	66 95       	lsr	r22
    93ee:	66 0f       	add	r22, r22
    93f0:	66 0f       	add	r22, r22
    93f2:	66 0f       	add	r22, r22
    93f4:	6b 5f       	subi	r22, 0xFB	; 251
    93f6:	13 70       	andi	r17, 0x03	; 3
    93f8:	81 2f       	mov	r24, r17
    93fa:	8f 5f       	subi	r24, 0xFF	; 255
    93fc:	a5 01       	movw	r20, r10
    93fe:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    9402:	e8 14       	cp	r14, r8
    9404:	f9 04       	cpc	r15, r9
    9406:	89 f6       	brne	.-94     	; 0x93aa <FMenuPumpLabel+0xa4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    9408:	46 e0       	ldi	r20, 0x06	; 6
    940a:	c4 2e       	mov	r12, r20
    940c:	d1 2c       	mov	r13, r1
    940e:	cc 0e       	add	r12, r28
    9410:	dd 1e       	adc	r13, r29
			   PPumpLabel[i] = 0;
			else
			   PPumpLabel[i]++;
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    9412:	7e 01       	movw	r14, r28
    9414:	08 94       	sec
    9416:	e1 1c       	adc	r14, r1
    9418:	f1 1c       	adc	r15, r1
    941a:	33 eb       	ldi	r19, 0xB3	; 179
    941c:	a3 2e       	mov	r10, r19
    941e:	3c e0       	ldi	r19, 0x0C	; 12
    9420:	b3 2e       	mov	r11, r19
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
	}

	while(1){
		KeyPressed = _key_scan(1);
    9422:	81 e0       	ldi	r24, 0x01	; 1
    9424:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    9428:	18 2f       	mov	r17, r24
		KeyChar    = _key_btn(KeyPressed);
    942a:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
		if(KeyPressed == _KEY_CANCEL)break;
    942e:	17 3e       	cpi	r17, 0xE7	; 231
    9430:	09 f4       	brne	.+2      	; 0x9434 <FMenuPumpLabel+0x12e>
    9432:	4b c0       	rjmp	.+150    	; 0x94ca <FMenuPumpLabel+0x1c4>
		else
		if(KeyPressed == _KEY_ENTER){
    9434:	17 3b       	cpi	r17, 0xB7	; 183
    9436:	61 f4       	brne	.+24     	; 0x9450 <FMenuPumpLabel+0x14a>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    9438:	8d e4       	ldi	r24, 0x4D	; 77
    943a:	90 e0       	ldi	r25, 0x00	; 0
    943c:	be 01       	movw	r22, r28
    943e:	6a 5f       	subi	r22, 0xFA	; 250
    9440:	7f 4f       	sbci	r23, 0xFF	; 255
    9442:	48 e0       	ldi	r20, 0x08	; 8
    9444:	50 e0       	ldi	r21, 0x00	; 0
    9446:	20 e0       	ldi	r18, 0x00	; 0
    9448:	33 e1       	ldi	r19, 0x13	; 19
    944a:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    944e:	3d c0       	rjmp	.+122    	; 0x94ca <FMenuPumpLabel+0x1c4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
    9450:	18 2f       	mov	r17, r24
    9452:	11 53       	subi	r17, 0x31	; 49
    9454:	18 30       	cpi	r17, 0x08	; 8
    9456:	28 f7       	brcc	.-54     	; 0x9422 <FMenuPumpLabel+0x11c>
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    9458:	a1 2f       	mov	r26, r17
    945a:	b0 e0       	ldi	r27, 0x00	; 0
    945c:	f6 01       	movw	r30, r12
    945e:	ea 0f       	add	r30, r26
    9460:	fb 1f       	adc	r31, r27
    9462:	90 81       	ld	r25, Z
    9464:	80 91 56 01 	lds	r24, 0x0156
    9468:	98 17       	cp	r25, r24
    946a:	11 f4       	brne	.+4      	; 0x9470 <FMenuPumpLabel+0x16a>
			   PPumpLabel[i] = 0;
    946c:	10 82       	st	Z, r1
    946e:	02 c0       	rjmp	.+4      	; 0x9474 <FMenuPumpLabel+0x16e>
			else
			   PPumpLabel[i]++;
    9470:	9f 5f       	subi	r25, 0xFF	; 255
    9472:	90 83       	st	Z, r25
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    9474:	00 d0       	rcall	.+0      	; 0x9476 <FMenuPumpLabel+0x170>
    9476:	00 d0       	rcall	.+0      	; 0x9478 <FMenuPumpLabel+0x172>
    9478:	00 d0       	rcall	.+0      	; 0x947a <FMenuPumpLabel+0x174>
    947a:	2d b7       	in	r18, 0x3d	; 61
    947c:	3e b7       	in	r19, 0x3e	; 62
    947e:	2f 5f       	subi	r18, 0xFF	; 255
    9480:	3f 4f       	sbci	r19, 0xFF	; 255
    9482:	ed b7       	in	r30, 0x3d	; 61
    9484:	fe b7       	in	r31, 0x3e	; 62
    9486:	f2 82       	std	Z+2, r15	; 0x02
    9488:	e1 82       	std	Z+1, r14	; 0x01
    948a:	f9 01       	movw	r30, r18
    948c:	b3 82       	std	Z+3, r11	; 0x03
    948e:	a2 82       	std	Z+2, r10	; 0x02
    9490:	ac 0d       	add	r26, r12
    9492:	bd 1d       	adc	r27, r13
    9494:	8c 91       	ld	r24, X
    9496:	84 83       	std	Z+4, r24	; 0x04
    9498:	15 82       	std	Z+5, r1	; 0x05
    949a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
            lcd_print(xPos,yPos,strLabel);
    949e:	8d b7       	in	r24, 0x3d	; 61
    94a0:	9e b7       	in	r25, 0x3e	; 62
    94a2:	06 96       	adiw	r24, 0x06	; 6
    94a4:	0f b6       	in	r0, 0x3f	; 63
    94a6:	f8 94       	cli
    94a8:	9e bf       	out	0x3e, r25	; 62
    94aa:	0f be       	out	0x3f, r0	; 63
    94ac:	8d bf       	out	0x3d, r24	; 61
    94ae:	61 2f       	mov	r22, r17
    94b0:	66 95       	lsr	r22
    94b2:	66 95       	lsr	r22
    94b4:	66 0f       	add	r22, r22
    94b6:	66 0f       	add	r22, r22
    94b8:	66 0f       	add	r22, r22
    94ba:	6b 5f       	subi	r22, 0xFB	; 251
    94bc:	13 70       	andi	r17, 0x03	; 3
    94be:	81 2f       	mov	r24, r17
    94c0:	8f 5f       	subi	r24, 0xFF	; 255
    94c2:	a7 01       	movw	r20, r14
    94c4:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    94c8:	ac cf       	rjmp	.-168    	; 0x9422 <FMenuPumpLabel+0x11c>
		}
	}
}
    94ca:	2d 96       	adiw	r28, 0x0d	; 13
    94cc:	0f b6       	in	r0, 0x3f	; 63
    94ce:	f8 94       	cli
    94d0:	de bf       	out	0x3e, r29	; 62
    94d2:	0f be       	out	0x3f, r0	; 63
    94d4:	cd bf       	out	0x3d, r28	; 61
    94d6:	cf 91       	pop	r28
    94d8:	df 91       	pop	r29
    94da:	1f 91       	pop	r17
    94dc:	ff 90       	pop	r15
    94de:	ef 90       	pop	r14
    94e0:	df 90       	pop	r13
    94e2:	cf 90       	pop	r12
    94e4:	bf 90       	pop	r11
    94e6:	af 90       	pop	r10
    94e8:	9f 90       	pop	r9
    94ea:	8f 90       	pop	r8
    94ec:	7f 90       	pop	r7
    94ee:	6f 90       	pop	r6
    94f0:	08 95       	ret

000094f2 <system_stop>:
	return Result;
}

void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
    94f2:	84 e0       	ldi	r24, 0x04	; 4
    94f4:	61 e0       	ldi	r22, 0x01	; 1
    94f6:	4f e2       	ldi	r20, 0x2F	; 47
    94f8:	52 e2       	ldi	r21, 0x22	; 34
    94fa:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    94fe:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    9500:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    9502:	85 e0       	ldi	r24, 0x05	; 5
    9504:	90 e0       	ldi	r25, 0x00	; 0
    9506:	90 93 d7 01 	sts	0x01D7, r25
    950a:	80 93 d6 01 	sts	0x01D6, r24
void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
	 system_beep(5);
	 while(1){
		__key = _key_scan(1);
    950e:	81 e0       	ldi	r24, 0x01	; 1
    9510:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
		__num = _key_btn(__key);
    9514:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
    9518:	80 53       	subi	r24, 0x30	; 48
    951a:	8a 30       	cpi	r24, 0x0A	; 10
    951c:	20 f0       	brcs	.+8      	; 0x9526 <system_stop+0x34>
    951e:	80 91 b3 01 	lds	r24, 0x01B3
    9522:	81 30       	cpi	r24, 0x01	; 1
    9524:	a1 f7       	brne	.-24     	; 0x950e <system_stop+0x1c>
    9526:	08 95       	ret

00009528 <systemForceType>:
	 }
}

char systemForceType(){
     char Result,KeyChar;
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
    9528:	84 e0       	ldi	r24, 0x04	; 4
    952a:	61 e0       	ldi	r22, 0x01	; 1
    952c:	44 e4       	ldi	r20, 0x44	; 68
    952e:	52 e2       	ldi	r21, 0x22	; 34
    9530:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    9534:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    9536:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    9538:	81 e0       	ldi	r24, 0x01	; 1
    953a:	90 e0       	ldi	r25, 0x00	; 0
    953c:	90 93 d7 01 	sts	0x01D7, r25
    9540:	80 93 d6 01 	sts	0x01D6, r24
    9544:	80 e5       	ldi	r24, 0x50	; 80
    9546:	93 ec       	ldi	r25, 0xC3	; 195
    9548:	01 97       	sbiw	r24, 0x01	; 1
    954a:	f1 f7       	brne	.-4      	; 0x9548 <systemForceType+0x20>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    954c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    954e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    9550:	82 e0       	ldi	r24, 0x02	; 2
    9552:	90 e0       	ldi	r25, 0x00	; 0
    9554:	90 93 d7 01 	sts	0x01D7, r25
    9558:	80 93 d6 01 	sts	0x01D6, r24
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
	 system_beep(1);
	 _delay_ms(200);
	 system_beep(2);
	 while(1){
	    KeyChar=_key_btn(_key_scan(1));
    955c:	81 e0       	ldi	r24, 0x01	; 1
    955e:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    9562:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
    9566:	98 2f       	mov	r25, r24
		if ((KeyChar=='1')||(KeyChar=='2')){
    9568:	81 53       	subi	r24, 0x31	; 49
    956a:	82 30       	cpi	r24, 0x02	; 2
    956c:	b8 f7       	brcc	.-18     	; 0x955c <systemForceType+0x34>
		    Result=KeyChar;
			break;
		}
	 }
	return Result;
}
    956e:	89 2f       	mov	r24, r25
    9570:	08 95       	ret

00009572 <_f_punctuation>:
				__string[__i++] = 0x30;
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}
void _f_punctuation(char* __string, unsigned char __mode, unsigned char __length, unsigned char __decimal){
    9572:	bf 92       	push	r11
    9574:	cf 92       	push	r12
    9576:	df 92       	push	r13
    9578:	ef 92       	push	r14
    957a:	ff 92       	push	r15
    957c:	0f 93       	push	r16
    957e:	1f 93       	push	r17
    9580:	df 93       	push	r29
    9582:	cf 93       	push	r28
    9584:	cd b7       	in	r28, 0x3d	; 61
    9586:	de b7       	in	r29, 0x3e	; 62
    9588:	2f 97       	sbiw	r28, 0x0f	; 15
    958a:	0f b6       	in	r0, 0x3f	; 63
    958c:	f8 94       	cli
    958e:	de bf       	out	0x3e, r29	; 62
    9590:	0f be       	out	0x3f, r0	; 63
    9592:	cd bf       	out	0x3d, r28	; 61
    9594:	8c 01       	movw	r16, r24
    9596:	c6 2e       	mov	r12, r22
    9598:	d4 2e       	mov	r13, r20
    959a:	62 2f       	mov	r22, r18
	char __buff[15] = {"000000000000000"};
    959c:	de 01       	movw	r26, r28
    959e:	11 96       	adiw	r26, 0x01	; 1
    95a0:	e0 e0       	ldi	r30, 0x00	; 0
    95a2:	f1 e0       	ldi	r31, 0x01	; 1
    95a4:	8f e0       	ldi	r24, 0x0F	; 15
    95a6:	01 90       	ld	r0, Z+
    95a8:	0d 92       	st	X+, r0
    95aa:	81 50       	subi	r24, 0x01	; 1
    95ac:	e1 f7       	brne	.-8      	; 0x95a6 <_f_punctuation+0x34>
	char  __point = 0,  __len;
	unsigned char __i, __ii,__counter = 0;

	__len = strlen(__string);
    95ae:	f8 01       	movw	r30, r16
    95b0:	01 90       	ld	r0, Z+
    95b2:	00 20       	and	r0, r0
    95b4:	e9 f7       	brne	.-6      	; 0x95b0 <_f_punctuation+0x3e>
    95b6:	31 97       	sbiw	r30, 0x01	; 1
    95b8:	3e 2f       	mov	r19, r30
    95ba:	30 1b       	sub	r19, r16
	if(__mode == 0){
    95bc:	cc 20       	and	r12, r12
    95be:	11 f5       	brne	.+68     	; 0x9604 <_f_punctuation+0x92>
		__buff[__length] = '\0';
    95c0:	8d 2d       	mov	r24, r13
    95c2:	90 e0       	ldi	r25, 0x00	; 0
    95c4:	fe 01       	movw	r30, r28
    95c6:	e8 0f       	add	r30, r24
    95c8:	f9 1f       	adc	r31, r25
    95ca:	11 82       	std	Z+1, r1	; 0x01
		for(__i = __length, __ii = __len - 1; __i > (__length - __len); __i--, __ii--)
    95cc:	23 2f       	mov	r18, r19
    95ce:	21 50       	subi	r18, 0x01	; 1
    95d0:	4d 2d       	mov	r20, r13
    95d2:	bc 01       	movw	r22, r24
    95d4:	63 1b       	sub	r22, r19
    95d6:	71 09       	sbc	r23, r1
    95d8:	09 c0       	rjmp	.+18     	; 0x95ec <_f_punctuation+0x7a>
			__buff[__i - 1] = __string[__ii];
    95da:	ac 0f       	add	r26, r28
    95dc:	bd 1f       	adc	r27, r29
    95de:	f8 01       	movw	r30, r16
    95e0:	e2 0f       	add	r30, r18
    95e2:	f1 1d       	adc	r31, r1
    95e4:	80 81       	ld	r24, Z
    95e6:	8c 93       	st	X, r24
	unsigned char __i, __ii,__counter = 0;

	__len = strlen(__string);
	if(__mode == 0){
		__buff[__length] = '\0';
		for(__i = __length, __ii = __len - 1; __i > (__length - __len); __i--, __ii--)
    95e8:	41 50       	subi	r20, 0x01	; 1
    95ea:	21 50       	subi	r18, 0x01	; 1
    95ec:	a4 2f       	mov	r26, r20
    95ee:	b0 e0       	ldi	r27, 0x00	; 0
    95f0:	6a 17       	cp	r22, r26
    95f2:	7b 07       	cpc	r23, r27
    95f4:	94 f3       	brlt	.-28     	; 0x95da <_f_punctuation+0x68>
			__buff[__i - 1] = __string[__ii];
		strcpy(__string, __buff);
    95f6:	c8 01       	movw	r24, r16
    95f8:	be 01       	movw	r22, r28
    95fa:	6f 5f       	subi	r22, 0xFF	; 255
    95fc:	7f 4f       	sbci	r23, 0xFF	; 255
    95fe:	0e 94 6b b5 	call	0x16ad6	; 0x16ad6 <strcpy>
    9602:	90 c0       	rjmp	.+288    	; 0x9724 <_f_punctuation+0x1b2>
	}
	else{
		if(__decimal > 0){
    9604:	66 23       	and	r22, r22
    9606:	61 f1       	breq	.+88     	; 0x9660 <_f_punctuation+0xee>
    9608:	a3 2f       	mov	r26, r19
    960a:	b0 e0       	ldi	r27, 0x00	; 0
    960c:	11 97       	sbiw	r26, 0x01	; 1
    960e:	a0 0f       	add	r26, r16
    9610:	b1 1f       	adc	r27, r17
    9612:	90 e0       	ldi	r25, 0x00	; 0
    9614:	ae 01       	movw	r20, r28
    9616:	4f 5f       	subi	r20, 0xFF	; 255
    9618:	5f 4f       	sbci	r21, 0xFF	; 255
			for(__i = 0; __i < __decimal; __i++){
				if(__i < __len)
					__buff[__counter++] = __string[__len - 1 - __i];
				else
					__buff[__counter++] = '0';
    961a:	20 e3       	ldi	r18, 0x30	; 48
    961c:	0e c0       	rjmp	.+28     	; 0x963a <_f_punctuation+0xc8>
    961e:	e9 2f       	mov	r30, r25
    9620:	f0 e0       	ldi	r31, 0x00	; 0
		strcpy(__string, __buff);
	}
	else{
		if(__decimal > 0){
			for(__i = 0; __i < __decimal; __i++){
				if(__i < __len)
    9622:	93 17       	cp	r25, r19
    9624:	28 f4       	brcc	.+10     	; 0x9630 <_f_punctuation+0xbe>
					__buff[__counter++] = __string[__len - 1 - __i];
    9626:	e4 0f       	add	r30, r20
    9628:	f5 1f       	adc	r31, r21
    962a:	8c 91       	ld	r24, X
    962c:	80 83       	st	Z, r24
    962e:	03 c0       	rjmp	.+6      	; 0x9636 <_f_punctuation+0xc4>
				else
					__buff[__counter++] = '0';
    9630:	e4 0f       	add	r30, r20
    9632:	f5 1f       	adc	r31, r21
    9634:	20 83       	st	Z, r18
			__buff[__i - 1] = __string[__ii];
		strcpy(__string, __buff);
	}
	else{
		if(__decimal > 0){
			for(__i = 0; __i < __decimal; __i++){
    9636:	9f 5f       	subi	r25, 0xFF	; 255
    9638:	11 97       	sbiw	r26, 0x01	; 1
    963a:	96 17       	cp	r25, r22
    963c:	80 f3       	brcs	.-32     	; 0x961e <_f_punctuation+0xac>
				if(__i < __len)
					__buff[__counter++] = __string[__len - 1 - __i];
				else
					__buff[__counter++] = '0';
			}
			__buff[__counter++] = ',';
    963e:	de 01       	movw	r26, r28
    9640:	11 96       	adiw	r26, 0x01	; 1
    9642:	fd 01       	movw	r30, r26
    9644:	e6 0f       	add	r30, r22
    9646:	f1 1d       	adc	r31, r1
    9648:	8c e2       	ldi	r24, 0x2C	; 44
    964a:	80 83       	st	Z, r24
    964c:	56 2f       	mov	r21, r22
    964e:	5f 5f       	subi	r21, 0xFF	; 255
		}
		if(__decimal > 0 && __len <= 2)
    9650:	33 30       	cpi	r19, 0x03	; 3
    9652:	48 f4       	brcc	.+18     	; 0x9666 <_f_punctuation+0xf4>
			__buff[__counter++] = '0';
    9654:	a5 0f       	add	r26, r21
    9656:	b1 1d       	adc	r27, r1
    9658:	80 e3       	ldi	r24, 0x30	; 48
    965a:	8c 93       	st	X, r24
    965c:	5f 5f       	subi	r21, 0xFF	; 255
    965e:	32 c0       	rjmp	.+100    	; 0x96c4 <_f_punctuation+0x152>
		else{
			if(__len > 1){
    9660:	32 30       	cpi	r19, 0x02	; 2
    9662:	68 f1       	brcs	.+90     	; 0x96be <_f_punctuation+0x14c>
    9664:	50 e0       	ldi	r21, 0x00	; 0
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
    9666:	31 50       	subi	r19, 0x01	; 1
    9668:	b3 2e       	mov	r11, r19
    966a:	b6 1a       	sub	r11, r22
    966c:	3f 5f       	subi	r19, 0xFF	; 255
    966e:	70 e0       	ldi	r23, 0x00	; 0
    9670:	40 e0       	ldi	r20, 0x00	; 0
    9672:	23 2f       	mov	r18, r19
    9674:	30 e0       	ldi	r19, 0x00	; 0
    9676:	26 1b       	sub	r18, r22
    9678:	31 09       	sbc	r19, r1
						__i++, __point++, __ii--){
					if(__point == 3){
						__point = 0;
						__buff[__counter++] = '.';
    967a:	7e 01       	movw	r14, r28
    967c:	08 94       	sec
    967e:	e1 1c       	adc	r14, r1
    9680:	f1 1c       	adc	r15, r1
    9682:	6e e2       	ldi	r22, 0x2E	; 46
    9684:	14 c0       	rjmp	.+40     	; 0x96ae <_f_punctuation+0x13c>
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
						__i++, __point++, __ii--){
					if(__point == 3){
    9686:	73 30       	cpi	r23, 0x03	; 3
    9688:	31 f4       	brne	.+12     	; 0x9696 <_f_punctuation+0x124>
						__point = 0;
						__buff[__counter++] = '.';
    968a:	f7 01       	movw	r30, r14
    968c:	e5 0f       	add	r30, r21
    968e:	f1 1d       	adc	r31, r1
    9690:	60 83       	st	Z, r22
    9692:	5f 5f       	subi	r21, 0xFF	; 255
    9694:	70 e0       	ldi	r23, 0x00	; 0
					}
					__buff[__counter++] = __string[__ii];
    9696:	f7 01       	movw	r30, r14
    9698:	e5 0f       	add	r30, r21
    969a:	f1 1d       	adc	r31, r1
    969c:	c8 01       	movw	r24, r16
    969e:	8a 0f       	add	r24, r26
    96a0:	91 1d       	adc	r25, r1
    96a2:	dc 01       	movw	r26, r24
    96a4:	8c 91       	ld	r24, X
    96a6:	80 83       	st	Z, r24
    96a8:	5f 5f       	subi	r21, 0xFF	; 255
		if(__decimal > 0 && __len <= 2)
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
						__i++, __point++, __ii--){
    96aa:	4f 5f       	subi	r20, 0xFF	; 255
    96ac:	7f 5f       	subi	r23, 0xFF	; 255
    96ae:	ab 2d       	mov	r26, r11
    96b0:	a4 1b       	sub	r26, r20
		}
		if(__decimal > 0 && __len <= 2)
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
    96b2:	84 2f       	mov	r24, r20
    96b4:	90 e0       	ldi	r25, 0x00	; 0
    96b6:	82 17       	cp	r24, r18
    96b8:	93 07       	cpc	r25, r19
    96ba:	2c f3       	brlt	.-54     	; 0x9686 <_f_punctuation+0x114>
    96bc:	03 c0       	rjmp	.+6      	; 0x96c4 <_f_punctuation+0x152>
					}
					__buff[__counter++] = __string[__ii];
				}
			}
			else
				__buff[__counter++] = '0';
    96be:	80 e3       	ldi	r24, 0x30	; 48
    96c0:	89 83       	std	Y+1, r24	; 0x01
    96c2:	51 e0       	ldi	r21, 0x01	; 1
		}
		if(__mode == 1){
    96c4:	91 e0       	ldi	r25, 0x01	; 1
    96c6:	c9 16       	cp	r12, r25
    96c8:	79 f4       	brne	.+30     	; 0x96e8 <_f_punctuation+0x176>
    96ca:	fe 01       	movw	r30, r28
    96cc:	31 96       	adiw	r30, 0x01	; 1
    96ce:	e5 0f       	add	r30, r21
    96d0:	f1 1d       	adc	r31, r1
    96d2:	d8 01       	movw	r26, r16
    96d4:	02 c0       	rjmp	.+4      	; 0x96da <_f_punctuation+0x168>
			for(__i = 0; __i < __counter; __i++)
				__string[__i] = __buff[__counter - 1 - __i];
    96d6:	80 81       	ld	r24, Z
    96d8:	8d 93       	st	X+, r24
    96da:	31 97       	sbiw	r30, 0x01	; 1
			}
			else
				__buff[__counter++] = '0';
		}
		if(__mode == 1){
			for(__i = 0; __i < __counter; __i++)
    96dc:	ec 17       	cp	r30, r28
    96de:	fd 07       	cpc	r31, r29
    96e0:	d1 f7       	brne	.-12     	; 0x96d6 <_f_punctuation+0x164>
				__string[__i] = __buff[__counter - 1 - __i];
			__string[__counter] = '\0';
    96e2:	05 0f       	add	r16, r21
    96e4:	11 1d       	adc	r17, r1
    96e6:	1c c0       	rjmp	.+56     	; 0x9720 <_f_punctuation+0x1ae>
		}
		if(__mode == 2){
    96e8:	f2 e0       	ldi	r31, 0x02	; 2
    96ea:	cf 16       	cp	r12, r31
    96ec:	d9 f4       	brne	.+54     	; 0x9724 <_f_punctuation+0x1b2>
    96ee:	f8 01       	movw	r30, r16
    96f0:	80 e0       	ldi	r24, 0x00	; 0
			for(__i = 0; __i < __length; __i++)
				__string[__i] = 0x20;
    96f2:	90 e2       	ldi	r25, 0x20	; 32
    96f4:	02 c0       	rjmp	.+4      	; 0x96fa <_f_punctuation+0x188>
    96f6:	91 93       	st	Z+, r25
			for(__i = 0; __i < __counter; __i++)
				__string[__i] = __buff[__counter - 1 - __i];
			__string[__counter] = '\0';
		}
		if(__mode == 2){
			for(__i = 0; __i < __length; __i++)
    96f8:	8f 5f       	subi	r24, 0xFF	; 255
    96fa:	8d 15       	cp	r24, r13
    96fc:	e0 f3       	brcs	.-8      	; 0x96f6 <_f_punctuation+0x184>
				__string[__i] = 0x20;
			for(__i = 0, __ii = __length - 1; __i < __counter; __i++, __ii--)
    96fe:	de 01       	movw	r26, r28
    9700:	11 96       	adiw	r26, 0x01	; 1
    9702:	9d 2d       	mov	r25, r13
    9704:	91 50       	subi	r25, 0x01	; 1
    9706:	29 2f       	mov	r18, r25
    9708:	25 1b       	sub	r18, r21
    970a:	06 c0       	rjmp	.+12     	; 0x9718 <_f_punctuation+0x1a6>
				__string[__ii] = __buff[__i];
    970c:	f8 01       	movw	r30, r16
    970e:	e9 0f       	add	r30, r25
    9710:	f1 1d       	adc	r31, r1
    9712:	8d 91       	ld	r24, X+
    9714:	80 83       	st	Z, r24
			__string[__counter] = '\0';
		}
		if(__mode == 2){
			for(__i = 0; __i < __length; __i++)
				__string[__i] = 0x20;
			for(__i = 0, __ii = __length - 1; __i < __counter; __i++, __ii--)
    9716:	91 50       	subi	r25, 0x01	; 1
    9718:	92 17       	cp	r25, r18
    971a:	c1 f7       	brne	.-16     	; 0x970c <_f_punctuation+0x19a>
				__string[__ii] = __buff[__i];
			__string[__length] = '\0';
    971c:	0d 0d       	add	r16, r13
    971e:	11 1d       	adc	r17, r1
    9720:	f8 01       	movw	r30, r16
    9722:	10 82       	st	Z, r1
		}
	}
}
    9724:	2f 96       	adiw	r28, 0x0f	; 15
    9726:	0f b6       	in	r0, 0x3f	; 63
    9728:	f8 94       	cli
    972a:	de bf       	out	0x3e, r29	; 62
    972c:	0f be       	out	0x3f, r0	; 63
    972e:	cd bf       	out	0x3d, r28	; 61
    9730:	cf 91       	pop	r28
    9732:	df 91       	pop	r29
    9734:	1f 91       	pop	r17
    9736:	0f 91       	pop	r16
    9738:	ff 90       	pop	r15
    973a:	ef 90       	pop	r14
    973c:	df 90       	pop	r13
    973e:	cf 90       	pop	r12
    9740:	bf 90       	pop	r11
    9742:	08 95       	ret

00009744 <_menu_printer>:
}

//*************************************************************************
//  ngeset printer

void _menu_printer(void){
    9744:	2f 92       	push	r2
    9746:	3f 92       	push	r3
    9748:	4f 92       	push	r4
    974a:	5f 92       	push	r5
    974c:	6f 92       	push	r6
    974e:	7f 92       	push	r7
    9750:	8f 92       	push	r8
    9752:	9f 92       	push	r9
    9754:	af 92       	push	r10
    9756:	bf 92       	push	r11
    9758:	cf 92       	push	r12
    975a:	df 92       	push	r13
    975c:	ef 92       	push	r14
    975e:	ff 92       	push	r15
    9760:	0f 93       	push	r16
    9762:	1f 93       	push	r17
    9764:	df 93       	push	r29
    9766:	cf 93       	push	r28
    9768:	cd b7       	in	r28, 0x3d	; 61
    976a:	de b7       	in	r29, 0x3e	; 62
    976c:	2c 97       	sbiw	r28, 0x0c	; 12
    976e:	0f b6       	in	r0, 0x3f	; 63
    9770:	f8 94       	cli
    9772:	de bf       	out	0x3e, r29	; 62
    9774:	0f be       	out	0x3f, r0	; 63
    9776:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9778:	e1 99       	sbic	0x1c, 1	; 28
    977a:	fe cf       	rjmp	.-4      	; 0x9778 <_menu_printer+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    977c:	80 e3       	ldi	r24, 0x30	; 48
    977e:	90 e0       	ldi	r25, 0x00	; 0
    9780:	9f bb       	out	0x1f, r25	; 31
    9782:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9784:	e0 9a       	sbi	0x1c, 0	; 28
    9786:	5d b3       	in	r21, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9788:	e1 99       	sbic	0x1c, 1	; 28
    978a:	fe cf       	rjmp	.-4      	; 0x9788 <_menu_printer+0x44>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    978c:	e5 e3       	ldi	r30, 0x35	; 53
    978e:	f0 e0       	ldi	r31, 0x00	; 0
    9790:	ff bb       	out	0x1f, r31	; 31
    9792:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9794:	e0 9a       	sbi	0x1c, 0	; 28
    9796:	4d b3       	in	r20, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9798:	e1 99       	sbic	0x1c, 1	; 28
    979a:	fe cf       	rjmp	.-4      	; 0x9798 <_menu_printer+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    979c:	84 e3       	ldi	r24, 0x34	; 52
    979e:	90 e0       	ldi	r25, 0x00	; 0
    97a0:	9f bb       	out	0x1f, r25	; 31
    97a2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    97a4:	e0 9a       	sbi	0x1c, 0	; 28
    97a6:	3d b3       	in	r19, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    97a8:	e1 99       	sbic	0x1c, 1	; 28
    97aa:	fe cf       	rjmp	.-4      	; 0x97a8 <_menu_printer+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    97ac:	e3 e3       	ldi	r30, 0x33	; 51
    97ae:	f0 e0       	ldi	r31, 0x00	; 0
    97b0:	ff bb       	out	0x1f, r31	; 31
    97b2:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    97b4:	e0 9a       	sbi	0x1c, 0	; 28
    97b6:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    97b8:	e1 99       	sbic	0x1c, 1	; 28
    97ba:	fe cf       	rjmp	.-4      	; 0x97b8 <_menu_printer+0x74>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    97bc:	11 e3       	ldi	r17, 0x31	; 49
    97be:	21 2e       	mov	r2, r17
    97c0:	10 e0       	ldi	r17, 0x00	; 0
    97c2:	31 2e       	mov	r3, r17
    97c4:	3f ba       	out	0x1f, r3	; 31
    97c6:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    97c8:	e0 9a       	sbi	0x1c, 0	; 28
    97ca:	9d b3       	in	r25, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    97cc:	e1 99       	sbic	0x1c, 1	; 28
    97ce:	fe cf       	rjmp	.-4      	; 0x97cc <_menu_printer+0x88>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    97d0:	b2 e3       	ldi	r27, 0x32	; 50
    97d2:	4b 2e       	mov	r4, r27
    97d4:	b0 e0       	ldi	r27, 0x00	; 0
    97d6:	5b 2e       	mov	r5, r27
    97d8:	5f ba       	out	0x1f, r5	; 31
    97da:	4e ba       	out	0x1e, r4	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    97dc:	e0 9a       	sbi	0x1c, 0	; 28
    97de:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[6];
	char	__i, __x, __y, __lmt, __start, __key, __num, __buff[6];
//	char lcdteks[20];

	__value[0] = eeprom_read_byte(&DefPrinterType);
    97e0:	59 83       	std	Y+1, r21	; 0x01
	__value[1] = eeprom_read_byte(&DefPrintSize);
    97e2:	4a 83       	std	Y+2, r20	; 0x02
	__value[2] = eeprom_read_byte(&DefPrintLogo);
    97e4:	3b 83       	std	Y+3, r19	; 0x03
	__value[3] = eeprom_read_byte(&DefPrintAutoCut);
    97e6:	2c 83       	std	Y+4, r18	; 0x04
	__value[4] = eeprom_read_byte(&DefPrintScrollEnd);
    97e8:	9d 83       	std	Y+5, r25	; 0x05
	__value[5] = eeprom_read_byte(&DefPrintScrollSpace);
    97ea:	8e 83       	std	Y+6, r24	; 0x06

	lcd_clear();
    97ec:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
    97f0:	81 e0       	ldi	r24, 0x01	; 1
    97f2:	61 e0       	ldi	r22, 0x01	; 1
    97f4:	43 e8       	ldi	r20, 0x83	; 131
    97f6:	5b e0       	ldi	r21, 0x0B	; 11
    97f8:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
    97fc:	82 e0       	ldi	r24, 0x02	; 2
    97fe:	61 e0       	ldi	r22, 0x01	; 1
    9800:	40 e7       	ldi	r20, 0x70	; 112
    9802:	5b e0       	ldi	r21, 0x0B	; 11
    9804:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
    9808:	83 e0       	ldi	r24, 0x03	; 3
    980a:	61 e0       	ldi	r22, 0x01	; 1
    980c:	40 e6       	ldi	r20, 0x60	; 96
    980e:	5b e0       	ldi	r21, 0x0B	; 11
    9810:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));
    9814:	84 e0       	ldi	r24, 0x04	; 4
    9816:	61 e0       	ldi	r22, 0x01	; 1
    9818:	40 e5       	ldi	r20, 0x50	; 80
    981a:	5b e0       	ldi	r21, 0x0B	; 11
    981c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
    9820:	00 ee       	ldi	r16, 0xE0	; 224
    9822:	12 e0       	ldi	r17, 0x02	; 2
    9824:	4e 01       	movw	r8, r28
    9826:	08 94       	sec
    9828:	81 1c       	adc	r8, r1
    982a:	91 1c       	adc	r9, r1
    982c:	74 01       	movw	r14, r8

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
		__y = pgm_read_byte(&__prntloc[__i][1]);
		_f_inttostr(__buff, __value[__i]);
    982e:	a7 e0       	ldi	r26, 0x07	; 7
    9830:	ca 2e       	mov	r12, r26
    9832:	d1 2c       	mov	r13, r1
    9834:	cc 0e       	add	r12, r28
    9836:	dd 1e       	adc	r13, r29
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
    9838:	f8 01       	movw	r30, r16
    983a:	a4 90       	lpm	r10, Z+
		__y = pgm_read_byte(&__prntloc[__i][1]);
    983c:	0f 5f       	subi	r16, 0xFF	; 255
    983e:	1f 4f       	sbci	r17, 0xFF	; 255
    9840:	f8 01       	movw	r30, r16
    9842:	b4 90       	lpm	r11, Z+
    9844:	01 50       	subi	r16, 0x01	; 1
    9846:	10 40       	sbci	r17, 0x00	; 0
		_f_inttostr(__buff, __value[__i]);
    9848:	f7 01       	movw	r30, r14
    984a:	40 81       	ld	r20, Z
    984c:	50 e0       	ldi	r21, 0x00	; 0
    984e:	60 e0       	ldi	r22, 0x00	; 0
    9850:	70 e0       	ldi	r23, 0x00	; 0
    9852:	c6 01       	movw	r24, r12
    9854:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_f_inttostr>
		if(__i == 4)_f_punctuation(__buff, 0, 2, 0);
    9858:	8e 2d       	mov	r24, r14
    985a:	88 19       	sub	r24, r8
    985c:	84 30       	cpi	r24, 0x04	; 4
    985e:	31 f4       	brne	.+12     	; 0x986c <_menu_printer+0x128>
    9860:	c6 01       	movw	r24, r12
    9862:	60 e0       	ldi	r22, 0x00	; 0
    9864:	42 e0       	ldi	r20, 0x02	; 2
    9866:	20 e0       	ldi	r18, 0x00	; 0
    9868:	0e 94 b9 4a 	call	0x9572	; 0x9572 <_f_punctuation>
		lcd_print(__x, __y, __buff);
    986c:	8a 2d       	mov	r24, r10
    986e:	6b 2d       	mov	r22, r11
    9870:	a6 01       	movw	r20, r12
    9872:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    9876:	0e 5f       	subi	r16, 0xFE	; 254
    9878:	1f 4f       	sbci	r17, 0xFF	; 255
    987a:	08 94       	sec
    987c:	e1 1c       	adc	r14, r1
    987e:	f1 1c       	adc	r15, r1
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
    9880:	f2 e0       	ldi	r31, 0x02	; 2
    9882:	0c 3e       	cpi	r16, 0xEC	; 236
    9884:	1f 07       	cpc	r17, r31
    9886:	c1 f6       	brne	.-80     	; 0x9838 <_menu_printer+0xf4>

		}
		if(__num >= 0x31 && __num <= 0x36){
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
			if(__value[__num - 0x31] == __lmt)
    9888:	3e 01       	movw	r6, r28
    988a:	08 94       	sec
    988c:	61 1c       	adc	r6, r1
    988e:	71 1c       	adc	r7, r1
				__value[__num - 0x31] = __start;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
			_f_inttostr(__buff, __value[__num - 0x31]);
    9890:	f7 e0       	ldi	r31, 0x07	; 7
    9892:	cf 2e       	mov	r12, r31
    9894:	d1 2c       	mov	r13, r1
    9896:	cc 0e       	add	r12, r28
    9898:	dd 1e       	adc	r13, r29
		__key = _key_scan(1);
		__num = _key_btn(__key);
		if(__key == _KEY_CANCEL)
			return;
		if(__key==_KEY_ENTER){
			eeprom_write_byte(&DefPrinterType, __value[0]);
    989a:	89 80       	ldd	r8, Y+1	; 0x01
			eeprom_write_byte(&DefPrintSize, __value[1]);
    989c:	9a 80       	ldd	r9, Y+2	; 0x02
			eeprom_write_byte(&DefPrintLogo, __value[2]);
    989e:	ab 80       	ldd	r10, Y+3	; 0x03
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
    98a0:	bc 80       	ldd	r11, Y+4	; 0x04
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
    98a2:	ed 80       	ldd	r14, Y+5	; 0x05
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);
    98a4:	fe 80       	ldd	r15, Y+6	; 0x06
	}
    //sprintf_P(lcdteks,PSTR("6)Space :%.2d"),__value[5]);
	//lcd_print(2,10,lcdteks);

	while(1){	
		__key = _key_scan(1);
    98a6:	81 e0       	ldi	r24, 0x01	; 1
    98a8:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    98ac:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    98ae:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
    98b2:	08 2f       	mov	r16, r24
		if(__key == _KEY_CANCEL)
    98b4:	17 3e       	cpi	r17, 0xE7	; 231
    98b6:	09 f4       	brne	.+2      	; 0x98ba <_menu_printer+0x176>
    98b8:	85 c0       	rjmp	.+266    	; 0x99c4 <_menu_printer+0x280>
			return;
		if(__key==_KEY_ENTER){
    98ba:	17 3b       	cpi	r17, 0xB7	; 183
    98bc:	09 f0       	breq	.+2      	; 0x98c0 <_menu_printer+0x17c>
    98be:	44 c0       	rjmp	.+136    	; 0x9948 <_menu_printer+0x204>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    98c0:	e1 99       	sbic	0x1c, 1	; 28
    98c2:	fe cf       	rjmp	.-4      	; 0x98c0 <_menu_printer+0x17c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    98c4:	80 e3       	ldi	r24, 0x30	; 48
    98c6:	90 e0       	ldi	r25, 0x00	; 0
    98c8:	9f bb       	out	0x1f, r25	; 31
    98ca:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    98cc:	8d ba       	out	0x1d, r8	; 29

    __asm__ __volatile__ (
    98ce:	0f b6       	in	r0, 0x3f	; 63
    98d0:	f8 94       	cli
    98d2:	e2 9a       	sbi	0x1c, 2	; 28
    98d4:	e1 9a       	sbi	0x1c, 1	; 28
    98d6:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    98d8:	e1 99       	sbic	0x1c, 1	; 28
    98da:	fe cf       	rjmp	.-4      	; 0x98d8 <_menu_printer+0x194>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    98dc:	e5 e3       	ldi	r30, 0x35	; 53
    98de:	f0 e0       	ldi	r31, 0x00	; 0
    98e0:	ff bb       	out	0x1f, r31	; 31
    98e2:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    98e4:	9d ba       	out	0x1d, r9	; 29

    __asm__ __volatile__ (
    98e6:	0f b6       	in	r0, 0x3f	; 63
    98e8:	f8 94       	cli
    98ea:	e2 9a       	sbi	0x1c, 2	; 28
    98ec:	e1 9a       	sbi	0x1c, 1	; 28
    98ee:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    98f0:	e1 99       	sbic	0x1c, 1	; 28
    98f2:	fe cf       	rjmp	.-4      	; 0x98f0 <_menu_printer+0x1ac>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    98f4:	84 e3       	ldi	r24, 0x34	; 52
    98f6:	90 e0       	ldi	r25, 0x00	; 0
    98f8:	9f bb       	out	0x1f, r25	; 31
    98fa:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    98fc:	ad ba       	out	0x1d, r10	; 29

    __asm__ __volatile__ (
    98fe:	0f b6       	in	r0, 0x3f	; 63
    9900:	f8 94       	cli
    9902:	e2 9a       	sbi	0x1c, 2	; 28
    9904:	e1 9a       	sbi	0x1c, 1	; 28
    9906:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9908:	e1 99       	sbic	0x1c, 1	; 28
    990a:	fe cf       	rjmp	.-4      	; 0x9908 <_menu_printer+0x1c4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    990c:	e3 e3       	ldi	r30, 0x33	; 51
    990e:	f0 e0       	ldi	r31, 0x00	; 0
    9910:	ff bb       	out	0x1f, r31	; 31
    9912:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    9914:	bd ba       	out	0x1d, r11	; 29

    __asm__ __volatile__ (
    9916:	0f b6       	in	r0, 0x3f	; 63
    9918:	f8 94       	cli
    991a:	e2 9a       	sbi	0x1c, 2	; 28
    991c:	e1 9a       	sbi	0x1c, 1	; 28
    991e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9920:	e1 99       	sbic	0x1c, 1	; 28
    9922:	fe cf       	rjmp	.-4      	; 0x9920 <_menu_printer+0x1dc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9924:	3f ba       	out	0x1f, r3	; 31
    9926:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    9928:	ed ba       	out	0x1d, r14	; 29

    __asm__ __volatile__ (
    992a:	0f b6       	in	r0, 0x3f	; 63
    992c:	f8 94       	cli
    992e:	e2 9a       	sbi	0x1c, 2	; 28
    9930:	e1 9a       	sbi	0x1c, 1	; 28
    9932:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9934:	e1 99       	sbic	0x1c, 1	; 28
    9936:	fe cf       	rjmp	.-4      	; 0x9934 <_menu_printer+0x1f0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9938:	5f ba       	out	0x1f, r5	; 31
    993a:	4e ba       	out	0x1e, r4	; 30
#endif
    EEDR = __value;
    993c:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
    993e:	0f b6       	in	r0, 0x3f	; 63
    9940:	f8 94       	cli
    9942:	e2 9a       	sbi	0x1c, 2	; 28
    9944:	e1 9a       	sbi	0x1c, 1	; 28
    9946:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);

		}
		if(__num >= 0x31 && __num <= 0x36){
    9948:	80 2f       	mov	r24, r16
    994a:	81 53       	subi	r24, 0x31	; 49
    994c:	86 30       	cpi	r24, 0x06	; 6
    994e:	08 f0       	brcs	.+2      	; 0x9952 <_menu_printer+0x20e>
    9950:	aa cf       	rjmp	.-172    	; 0x98a6 <_menu_printer+0x162>
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
    9952:	a0 2f       	mov	r26, r16
    9954:	b0 e0       	ldi	r27, 0x00	; 0
    9956:	d1 97       	sbiw	r26, 0x31	; 49
    9958:	fd 01       	movw	r30, r26
    995a:	e4 51       	subi	r30, 0x14	; 20
    995c:	fd 4f       	sbci	r31, 0xFD	; 253
    995e:	24 91       	lpm	r18, Z+
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
    9960:	fd 01       	movw	r30, r26
    9962:	ee 50       	subi	r30, 0x0E	; 14
    9964:	fd 4f       	sbci	r31, 0xFD	; 253
    9966:	94 91       	lpm	r25, Z+
			if(__value[__num - 0x31] == __lmt)
    9968:	f3 01       	movw	r30, r6
    996a:	ea 0f       	add	r30, r26
    996c:	fb 1f       	adc	r31, r27
    996e:	80 81       	ld	r24, Z
    9970:	82 17       	cp	r24, r18
    9972:	11 f4       	brne	.+4      	; 0x9978 <_menu_printer+0x234>
				__value[__num - 0x31] = __start;
    9974:	90 83       	st	Z, r25
    9976:	02 c0       	rjmp	.+4      	; 0x997c <_menu_printer+0x238>
			else
				__value[__num - 0x31]++;
    9978:	8f 5f       	subi	r24, 0xFF	; 255
    997a:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
    997c:	9d 01       	movw	r18, r26
    997e:	22 0f       	add	r18, r18
    9980:	33 1f       	adc	r19, r19
    9982:	c9 01       	movw	r24, r18
    9984:	80 52       	subi	r24, 0x20	; 32
    9986:	9d 4f       	sbci	r25, 0xFD	; 253
    9988:	fc 01       	movw	r30, r24
    998a:	f4 90       	lpm	r15, Z+
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
    998c:	2f 51       	subi	r18, 0x1F	; 31
    998e:	3d 4f       	sbci	r19, 0xFD	; 253
    9990:	f9 01       	movw	r30, r18
    9992:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __value[__num - 0x31]);
    9994:	a6 0d       	add	r26, r6
    9996:	b7 1d       	adc	r27, r7
    9998:	4c 91       	ld	r20, X
    999a:	50 e0       	ldi	r21, 0x00	; 0
    999c:	60 e0       	ldi	r22, 0x00	; 0
    999e:	70 e0       	ldi	r23, 0x00	; 0
    99a0:	c6 01       	movw	r24, r12
    99a2:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_f_inttostr>
			if((__num == 0x35)||(__num == 0x36))
    99a6:	05 53       	subi	r16, 0x35	; 53
    99a8:	02 30       	cpi	r16, 0x02	; 2
    99aa:	30 f4       	brcc	.+12     	; 0x99b8 <_menu_printer+0x274>
				_f_punctuation(__buff, 0, 2, 0);
    99ac:	c6 01       	movw	r24, r12
    99ae:	60 e0       	ldi	r22, 0x00	; 0
    99b0:	42 e0       	ldi	r20, 0x02	; 2
    99b2:	20 e0       	ldi	r18, 0x00	; 0
    99b4:	0e 94 b9 4a 	call	0x9572	; 0x9572 <_f_punctuation>
			lcd_print(__x, __y, __buff);
    99b8:	8f 2d       	mov	r24, r15
    99ba:	61 2f       	mov	r22, r17
    99bc:	a6 01       	movw	r20, r12
    99be:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    99c2:	6b cf       	rjmp	.-298    	; 0x989a <_menu_printer+0x156>
		}
	}
}
    99c4:	2c 96       	adiw	r28, 0x0c	; 12
    99c6:	0f b6       	in	r0, 0x3f	; 63
    99c8:	f8 94       	cli
    99ca:	de bf       	out	0x3e, r29	; 62
    99cc:	0f be       	out	0x3f, r0	; 63
    99ce:	cd bf       	out	0x3d, r28	; 61
    99d0:	cf 91       	pop	r28
    99d2:	df 91       	pop	r29
    99d4:	1f 91       	pop	r17
    99d6:	0f 91       	pop	r16
    99d8:	ff 90       	pop	r15
    99da:	ef 90       	pop	r14
    99dc:	df 90       	pop	r13
    99de:	cf 90       	pop	r12
    99e0:	bf 90       	pop	r11
    99e2:	af 90       	pop	r10
    99e4:	9f 90       	pop	r9
    99e6:	8f 90       	pop	r8
    99e8:	7f 90       	pop	r7
    99ea:	6f 90       	pop	r6
    99ec:	5f 90       	pop	r5
    99ee:	4f 90       	pop	r4
    99f0:	3f 90       	pop	r3
    99f2:	2f 90       	pop	r2
    99f4:	08 95       	ret

000099f6 <FSettingPrinter>:
char FSettingDatetime(){
     _menu_datetime();
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
    99f6:	0e 94 a2 4b 	call	0x9744	; 0x9744 <_menu_printer>
	 return MENU_DONE;
}
    99fa:	81 e0       	ldi	r24, 0x01	; 1
    99fc:	08 95       	ret

000099fe <SendPrint>:
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}

void SendPrint(char xSend,char xSendLead){
    99fe:	1f 93       	push	r17
    9a00:	18 2f       	mov	r17, r24
static char zSend;     
	 if (xSend==0x19){
    9a02:	89 31       	cpi	r24, 0x19	; 25
    9a04:	59 f4       	brne	.+22     	; 0x9a1c <SendPrint+0x1e>
	     if (zSend==xSendLead)_uart(_COM_PRINTER,1,xSendLead);
    9a06:	40 91 89 02 	lds	r20, 0x0289
    9a0a:	46 17       	cp	r20, r22
    9a0c:	19 f4       	brne	.+6      	; 0x9a14 <SendPrint+0x16>
    9a0e:	80 e0       	ldi	r24, 0x00	; 0
    9a10:	61 e0       	ldi	r22, 0x01	; 1
    9a12:	07 c0       	rjmp	.+14     	; 0x9a22 <SendPrint+0x24>
		 else _uart(_COM_PRINTER,1,' ');	 
    9a14:	80 e0       	ldi	r24, 0x00	; 0
    9a16:	61 e0       	ldi	r22, 0x01	; 1
    9a18:	40 e2       	ldi	r20, 0x20	; 32
    9a1a:	03 c0       	rjmp	.+6      	; 0x9a22 <SendPrint+0x24>
	 } 
	 else _uart(_COM_PRINTER,1,xSend);
    9a1c:	80 e0       	ldi	r24, 0x00	; 0
    9a1e:	61 e0       	ldi	r22, 0x01	; 1
    9a20:	41 2f       	mov	r20, r17
    9a22:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	 zSend=xSend;
    9a26:	10 93 89 02 	sts	0x0289, r17
}
    9a2a:	1f 91       	pop	r17
    9a2c:	08 95       	ret

00009a2e <CarriegeReturn>:
	      break;	 
	 }
}

void CarriegeReturn(){
     _uart(_COM_PRINTER, 1, 0x0D);     
    9a2e:	80 e0       	ldi	r24, 0x00	; 0
    9a30:	61 e0       	ldi	r22, 0x01	; 1
    9a32:	4d e0       	ldi	r20, 0x0D	; 13
    9a34:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
     _uart(_COM_PRINTER, 1, 0x0A);
    9a38:	80 e0       	ldi	r24, 0x00	; 0
    9a3a:	61 e0       	ldi	r22, 0x01	; 1
    9a3c:	4a e0       	ldi	r20, 0x0A	; 10
    9a3e:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>

}
    9a42:	08 95       	ret

00009a44 <InitPrinter>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9a44:	e1 99       	sbic	0x1c, 1	; 28
    9a46:	fe cf       	rjmp	.-4      	; 0x9a44 <InitPrinter>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9a48:	80 e3       	ldi	r24, 0x30	; 48
    9a4a:	90 e0       	ldi	r25, 0x00	; 0
    9a4c:	9f bb       	out	0x1f, r25	; 31
    9a4e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9a50:	e0 9a       	sbi	0x1c, 0	; 28
    9a52:	8d b3       	in	r24, 0x1d	; 29
void InitPrinter(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
    //Custom Printer TG02
	//Density Lowest: 1D 7C 00
	if (PrinterType==PT_CUSTOM_TG02){
    9a54:	81 30       	cpi	r24, 0x01	; 1
    9a56:	71 f5       	brne	.+92     	; 0x9ab4 <InitPrinter+0x70>
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x7C);_uart(_COM_PRINTER, 1, 0x00);
    9a58:	80 e0       	ldi	r24, 0x00	; 0
    9a5a:	61 e0       	ldi	r22, 0x01	; 1
    9a5c:	4d e1       	ldi	r20, 0x1D	; 29
    9a5e:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9a62:	80 e0       	ldi	r24, 0x00	; 0
    9a64:	61 e0       	ldi	r22, 0x01	; 1
    9a66:	4c e7       	ldi	r20, 0x7C	; 124
    9a68:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9a6c:	80 e0       	ldi	r24, 0x00	; 0
    9a6e:	61 e0       	ldi	r22, 0x01	; 1
    9a70:	40 e0       	ldi	r20, 0x00	; 0
    9a72:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
		//Double Strike ON : 1B 47 01
		_uart(_COM_PRINTER, 1, 0x1B);_uart(_COM_PRINTER, 1, 0x47);_uart(_COM_PRINTER, 1, 0x01);
    9a76:	80 e0       	ldi	r24, 0x00	; 0
    9a78:	61 e0       	ldi	r22, 0x01	; 1
    9a7a:	4b e1       	ldi	r20, 0x1B	; 27
    9a7c:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9a80:	80 e0       	ldi	r24, 0x00	; 0
    9a82:	61 e0       	ldi	r22, 0x01	; 1
    9a84:	47 e4       	ldi	r20, 0x47	; 71
    9a86:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9a8a:	80 e0       	ldi	r24, 0x00	; 0
    9a8c:	61 e0       	ldi	r22, 0x01	; 1
    9a8e:	41 e0       	ldi	r20, 0x01	; 1
    9a90:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x01);   
    9a94:	80 e0       	ldi	r24, 0x00	; 0
    9a96:	61 e0       	ldi	r22, 0x01	; 1
    9a98:	4d e1       	ldi	r20, 0x1D	; 29
    9a9a:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9a9e:	80 e0       	ldi	r24, 0x00	; 0
    9aa0:	61 e0       	ldi	r22, 0x01	; 1
    9aa2:	41 e2       	ldi	r20, 0x21	; 33
    9aa4:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9aa8:	80 e0       	ldi	r24, 0x00	; 0
    9aaa:	61 e0       	ldi	r22, 0x01	; 1
    9aac:	41 e0       	ldi	r20, 0x01	; 1
    9aae:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9ab2:	08 95       	ret
		}
    else
	if (PrinterType==PT_CUSTOM_CUBE){
    9ab4:	82 30       	cpi	r24, 0x02	; 2
    9ab6:	69 f5       	brne	.+90     	; 0x9b12 <InitPrinter+0xce>
        //Print Density 0%
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x7C);_uart(_COM_PRINTER, 1, 0x04);
    9ab8:	80 e0       	ldi	r24, 0x00	; 0
    9aba:	61 e0       	ldi	r22, 0x01	; 1
    9abc:	4d e1       	ldi	r20, 0x1D	; 29
    9abe:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9ac2:	80 e0       	ldi	r24, 0x00	; 0
    9ac4:	61 e0       	ldi	r22, 0x01	; 1
    9ac6:	4c e7       	ldi	r20, 0x7C	; 124
    9ac8:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9acc:	80 e0       	ldi	r24, 0x00	; 0
    9ace:	61 e0       	ldi	r22, 0x01	; 1
    9ad0:	44 e0       	ldi	r20, 0x04	; 4
    9ad2:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
		//Double Strike OFF : 1B 47 00
		_uart(_COM_PRINTER, 1, 0x1B);_uart(_COM_PRINTER, 1, 0x47);_uart(_COM_PRINTER, 1, 0x00);
    9ad6:	80 e0       	ldi	r24, 0x00	; 0
    9ad8:	61 e0       	ldi	r22, 0x01	; 1
    9ada:	4b e1       	ldi	r20, 0x1B	; 27
    9adc:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9ae0:	80 e0       	ldi	r24, 0x00	; 0
    9ae2:	61 e0       	ldi	r22, 0x01	; 1
    9ae4:	47 e4       	ldi	r20, 0x47	; 71
    9ae6:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9aea:	80 e0       	ldi	r24, 0x00	; 0
    9aec:	61 e0       	ldi	r22, 0x01	; 1
    9aee:	40 e0       	ldi	r20, 0x00	; 0
    9af0:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);   
    9af4:	80 e0       	ldi	r24, 0x00	; 0
    9af6:	61 e0       	ldi	r22, 0x01	; 1
    9af8:	4d e1       	ldi	r20, 0x1D	; 29
    9afa:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9afe:	80 e0       	ldi	r24, 0x00	; 0
    9b00:	61 e0       	ldi	r22, 0x01	; 1
    9b02:	41 e2       	ldi	r20, 0x21	; 33
    9b04:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9b08:	80 e0       	ldi	r24, 0x00	; 0
    9b0a:	61 e0       	ldi	r22, 0x01	; 1
    9b0c:	40 e0       	ldi	r20, 0x00	; 0
    9b0e:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9b12:	08 95       	ret

00009b14 <PrintNormalHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9b14:	e1 99       	sbic	0x1c, 1	; 28
    9b16:	fe cf       	rjmp	.-4      	; 0x9b14 <PrintNormalHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9b18:	80 e3       	ldi	r24, 0x30	; 48
    9b1a:	90 e0       	ldi	r25, 0x00	; 0
    9b1c:	9f bb       	out	0x1f, r25	; 31
    9b1e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9b20:	e0 9a       	sbi	0x1c, 0	; 28
    9b22:	8d b3       	in	r24, 0x1d	; 29
}

void PrintNormalHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    9b24:	82 30       	cpi	r24, 0x02	; 2
    9b26:	79 f4       	brne	.+30     	; 0x9b46 <PrintNormalHeight+0x32>
	     _uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);
    9b28:	80 e0       	ldi	r24, 0x00	; 0
    9b2a:	61 e0       	ldi	r22, 0x01	; 1
    9b2c:	4d e1       	ldi	r20, 0x1D	; 29
    9b2e:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9b32:	80 e0       	ldi	r24, 0x00	; 0
    9b34:	61 e0       	ldi	r22, 0x01	; 1
    9b36:	41 e2       	ldi	r20, 0x21	; 33
    9b38:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9b3c:	80 e0       	ldi	r24, 0x00	; 0
    9b3e:	61 e0       	ldi	r22, 0x01	; 1
    9b40:	40 e0       	ldi	r20, 0x00	; 0
    9b42:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9b46:	08 95       	ret

00009b48 <PrintDoubleHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9b48:	e1 99       	sbic	0x1c, 1	; 28
    9b4a:	fe cf       	rjmp	.-4      	; 0x9b48 <PrintDoubleHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9b4c:	80 e3       	ldi	r24, 0x30	; 48
    9b4e:	90 e0       	ldi	r25, 0x00	; 0
    9b50:	9f bb       	out	0x1f, r25	; 31
    9b52:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9b54:	e0 9a       	sbi	0x1c, 0	; 28
    9b56:	8d b3       	in	r24, 0x1d	; 29
//void SetPrinterCharacterWidth

void PrintDoubleHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    9b58:	82 30       	cpi	r24, 0x02	; 2
    9b5a:	79 f4       	brne	.+30     	; 0x9b7a <PrintDoubleHeight+0x32>
	     _uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x01);
    9b5c:	80 e0       	ldi	r24, 0x00	; 0
    9b5e:	61 e0       	ldi	r22, 0x01	; 1
    9b60:	4d e1       	ldi	r20, 0x1D	; 29
    9b62:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9b66:	80 e0       	ldi	r24, 0x00	; 0
    9b68:	61 e0       	ldi	r22, 0x01	; 1
    9b6a:	41 e2       	ldi	r20, 0x21	; 33
    9b6c:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9b70:	80 e0       	ldi	r24, 0x00	; 0
    9b72:	61 e0       	ldi	r22, 0x01	; 1
    9b74:	41 e0       	ldi	r20, 0x01	; 1
    9b76:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    9b7a:	08 95       	ret

00009b7c <PaperCut>:

	 return Result;
}


void PaperCut(){
    9b7c:	1f 93       	push	r17
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9b7e:	e1 99       	sbic	0x1c, 1	; 28
    9b80:	fe cf       	rjmp	.-4      	; 0x9b7e <PaperCut+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9b82:	83 e3       	ldi	r24, 0x33	; 51
    9b84:	90 e0       	ldi	r25, 0x00	; 0
    9b86:	9f bb       	out	0x1f, r25	; 31
    9b88:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9b8a:	e0 9a       	sbi	0x1c, 0	; 28
    9b8c:	1d b3       	in	r17, 0x1d	; 29
     char CutType;
     CutType= eeprom_read_byte(&DefPrintAutoCut);
     _uart(_COM_PRINTER, 1, 0x1B);
    9b8e:	80 e0       	ldi	r24, 0x00	; 0
    9b90:	61 e0       	ldi	r22, 0x01	; 1
    9b92:	4b e1       	ldi	r20, 0x1B	; 27
    9b94:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	 if(CutType== 1) { _uart(_COM_PRINTER, 1, 0x6D);}
    9b98:	11 30       	cpi	r17, 0x01	; 1
    9b9a:	21 f4       	brne	.+8      	; 0x9ba4 <PaperCut+0x28>
    9b9c:	80 e0       	ldi	r24, 0x00	; 0
    9b9e:	61 e0       	ldi	r22, 0x01	; 1
    9ba0:	4d e6       	ldi	r20, 0x6D	; 109
    9ba2:	05 c0       	rjmp	.+10     	; 0x9bae <PaperCut+0x32>
	 if(CutType== 2) {_uart(_COM_PRINTER, 1, 0x69);}
    9ba4:	12 30       	cpi	r17, 0x02	; 2
    9ba6:	29 f4       	brne	.+10     	; 0x9bb2 <PaperCut+0x36>
    9ba8:	80 e0       	ldi	r24, 0x00	; 0
    9baa:	61 e0       	ldi	r22, 0x01	; 1
    9bac:	49 e6       	ldi	r20, 0x69	; 105
    9bae:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>

}
    9bb2:	1f 91       	pop	r17
    9bb4:	08 95       	ret

00009bb6 <sendMessage98>:
		        break;
	       }//EndSwitch
return Result;
}

void sendMessage98(char PumpID){
    9bb6:	ff 92       	push	r15
    9bb8:	0f 93       	push	r16
    9bba:	1f 93       	push	r17
    9bbc:	df 93       	push	r29
    9bbe:	cf 93       	push	r28
    9bc0:	cd b7       	in	r28, 0x3d	; 61
    9bc2:	de b7       	in	r29, 0x3e	; 62
    9bc4:	ea 97       	sbiw	r28, 0x3a	; 58
    9bc6:	0f b6       	in	r0, 0x3f	; 63
    9bc8:	f8 94       	cli
    9bca:	de bf       	out	0x3e, r29	; 62
    9bcc:	0f be       	out	0x3f, r0	; 63
    9bce:	cd bf       	out	0x3d, r28	; 61
    9bd0:	f8 2e       	mov	r15, r24
	char __pump_id[8];
	char strSend[50];
	char xFIP_ID;
	
	_uart(1, 1,0x01);
    9bd2:	81 e0       	ldi	r24, 0x01	; 1
    9bd4:	61 e0       	ldi	r22, 0x01	; 1
    9bd6:	41 e0       	ldi	r20, 0x01	; 1
    9bd8:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    UpdateIFT_ID(); //ReadIFT_ID
    9bdc:	0e 94 0d 1c 	call	0x381a	; 0x381a <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9be0:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9be4:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9be8:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <UpdateServerIP>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9bec:	ce 01       	movw	r24, r28
    9bee:	01 96       	adiw	r24, 0x01	; 1
    9bf0:	65 e4       	ldi	r22, 0x45	; 69
    9bf2:	70 e0       	ldi	r23, 0x00	; 0
    9bf4:	48 e0       	ldi	r20, 0x08	; 8
    9bf6:	50 e0       	ldi	r21, 0x00	; 0
    9bf8:	28 ef       	ldi	r18, 0xF8	; 248
    9bfa:	32 e1       	ldi	r19, 0x12	; 18
    9bfc:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	xFIP_ID=__pump_id[PumpID-1];
	//if (xFIP_ID>16)xFIP_ID=16;
	sprintf_P(strSend,PSTR("%s%s%s%s98%.2dF968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,xFIP_ID);
    9c00:	8d b7       	in	r24, 0x3d	; 61
    9c02:	9e b7       	in	r25, 0x3e	; 62
    9c04:	0e 97       	sbiw	r24, 0x0e	; 14
    9c06:	0f b6       	in	r0, 0x3f	; 63
    9c08:	f8 94       	cli
    9c0a:	9e bf       	out	0x3e, r25	; 62
    9c0c:	0f be       	out	0x3f, r0	; 63
    9c0e:	8d bf       	out	0x3d, r24	; 61
    9c10:	ad b7       	in	r26, 0x3d	; 61
    9c12:	be b7       	in	r27, 0x3e	; 62
    9c14:	11 96       	adiw	r26, 0x01	; 1
    9c16:	8e 01       	movw	r16, r28
    9c18:	07 5f       	subi	r16, 0xF7	; 247
    9c1a:	1f 4f       	sbci	r17, 0xFF	; 255
    9c1c:	ed b7       	in	r30, 0x3d	; 61
    9c1e:	fe b7       	in	r31, 0x3e	; 62
    9c20:	12 83       	std	Z+2, r17	; 0x02
    9c22:	01 83       	std	Z+1, r16	; 0x01
    9c24:	82 e4       	ldi	r24, 0x42	; 66
    9c26:	9d e1       	ldi	r25, 0x1D	; 29
    9c28:	13 96       	adiw	r26, 0x03	; 3
    9c2a:	9c 93       	st	X, r25
    9c2c:	8e 93       	st	-X, r24
    9c2e:	12 97       	sbiw	r26, 0x02	; 2
    9c30:	8c ec       	ldi	r24, 0xCC	; 204
    9c32:	95 e0       	ldi	r25, 0x05	; 5
    9c34:	15 96       	adiw	r26, 0x05	; 5
    9c36:	9c 93       	st	X, r25
    9c38:	8e 93       	st	-X, r24
    9c3a:	14 97       	sbiw	r26, 0x04	; 4
    9c3c:	89 e3       	ldi	r24, 0x39	; 57
    9c3e:	9f e0       	ldi	r25, 0x0F	; 15
    9c40:	17 96       	adiw	r26, 0x07	; 7
    9c42:	9c 93       	st	X, r25
    9c44:	8e 93       	st	-X, r24
    9c46:	16 97       	sbiw	r26, 0x06	; 6
    9c48:	88 ea       	ldi	r24, 0xA8	; 168
    9c4a:	99 e0       	ldi	r25, 0x09	; 9
    9c4c:	19 96       	adiw	r26, 0x09	; 9
    9c4e:	9c 93       	st	X, r25
    9c50:	8e 93       	st	-X, r24
    9c52:	18 97       	sbiw	r26, 0x08	; 8
    9c54:	85 ed       	ldi	r24, 0xD5	; 213
    9c56:	99 e0       	ldi	r25, 0x09	; 9
    9c58:	1b 96       	adiw	r26, 0x0b	; 11
    9c5a:	9c 93       	st	X, r25
    9c5c:	8e 93       	st	-X, r24
    9c5e:	1a 97       	sbiw	r26, 0x0a	; 10
    9c60:	fe 01       	movw	r30, r28
    9c62:	ef 0d       	add	r30, r15
    9c64:	f1 1d       	adc	r31, r1
    9c66:	80 81       	ld	r24, Z
    9c68:	1c 96       	adiw	r26, 0x0c	; 12
    9c6a:	8c 93       	st	X, r24
    9c6c:	1c 97       	sbiw	r26, 0x0c	; 12
    9c6e:	1d 96       	adiw	r26, 0x0d	; 13
    9c70:	1c 92       	st	X, r1
    9c72:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	_uart_print(1, 0,strSend);
    9c76:	8d b7       	in	r24, 0x3d	; 61
    9c78:	9e b7       	in	r25, 0x3e	; 62
    9c7a:	0e 96       	adiw	r24, 0x0e	; 14
    9c7c:	0f b6       	in	r0, 0x3f	; 63
    9c7e:	f8 94       	cli
    9c80:	9e bf       	out	0x3e, r25	; 62
    9c82:	0f be       	out	0x3f, r0	; 63
    9c84:	8d bf       	out	0x3d, r24	; 61
    9c86:	81 e0       	ldi	r24, 0x01	; 1
    9c88:	60 e0       	ldi	r22, 0x00	; 0
    9c8a:	a8 01       	movw	r20, r16
    9c8c:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	_uart(1, 1,0x02);
    9c90:	81 e0       	ldi	r24, 0x01	; 1
    9c92:	61 e0       	ldi	r22, 0x01	; 1
    9c94:	42 e0       	ldi	r20, 0x02	; 2
    9c96:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	IsBusyMsg11=True;
    9c9a:	81 e0       	ldi	r24, 0x01	; 1
    9c9c:	80 93 c4 01 	sts	0x01C4, r24
}
    9ca0:	ea 96       	adiw	r28, 0x3a	; 58
    9ca2:	0f b6       	in	r0, 0x3f	; 63
    9ca4:	f8 94       	cli
    9ca6:	de bf       	out	0x3e, r29	; 62
    9ca8:	0f be       	out	0x3f, r0	; 63
    9caa:	cd bf       	out	0x3d, r28	; 61
    9cac:	cf 91       	pop	r28
    9cae:	df 91       	pop	r29
    9cb0:	1f 91       	pop	r17
    9cb2:	0f 91       	pop	r16
    9cb4:	ff 90       	pop	r15
    9cb6:	08 95       	ret

00009cb8 <sendMessage94>:
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage94(){//Void Transaction Message
    9cb8:	0f 93       	push	r16
    9cba:	1f 93       	push	r17
    9cbc:	df 93       	push	r29
    9cbe:	cf 93       	push	r28
    9cc0:	cd b7       	in	r28, 0x3d	; 61
    9cc2:	de b7       	in	r29, 0x3e	; 62
    9cc4:	c0 55       	subi	r28, 0x50	; 80
    9cc6:	d0 40       	sbci	r29, 0x00	; 0
    9cc8:	0f b6       	in	r0, 0x3f	; 63
    9cca:	f8 94       	cli
    9ccc:	de bf       	out	0x3e, r29	; 62
    9cce:	0f be       	out	0x3f, r0	; 63
    9cd0:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9cd2:	81 e0       	ldi	r24, 0x01	; 1
    9cd4:	61 e0       	ldi	r22, 0x01	; 1
    9cd6:	41 e0       	ldi	r20, 0x01	; 1
    9cd8:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9cdc:	0e 94 0d 1c 	call	0x381a	; 0x381a <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9ce0:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9ce4:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9ce8:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s94"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9cec:	8d b7       	in	r24, 0x3d	; 61
    9cee:	9e b7       	in	r25, 0x3e	; 62
    9cf0:	0c 97       	sbiw	r24, 0x0c	; 12
    9cf2:	0f b6       	in	r0, 0x3f	; 63
    9cf4:	f8 94       	cli
    9cf6:	9e bf       	out	0x3e, r25	; 62
    9cf8:	0f be       	out	0x3f, r0	; 63
    9cfa:	8d bf       	out	0x3d, r24	; 61
    9cfc:	ed b7       	in	r30, 0x3d	; 61
    9cfe:	fe b7       	in	r31, 0x3e	; 62
    9d00:	31 96       	adiw	r30, 0x01	; 1
    9d02:	8e 01       	movw	r16, r28
    9d04:	0f 5f       	subi	r16, 0xFF	; 255
    9d06:	1f 4f       	sbci	r17, 0xFF	; 255
    9d08:	ad b7       	in	r26, 0x3d	; 61
    9d0a:	be b7       	in	r27, 0x3e	; 62
    9d0c:	12 96       	adiw	r26, 0x02	; 2
    9d0e:	1c 93       	st	X, r17
    9d10:	0e 93       	st	-X, r16
    9d12:	11 97       	sbiw	r26, 0x01	; 1
    9d14:	8a ed       	ldi	r24, 0xDA	; 218
    9d16:	90 e2       	ldi	r25, 0x20	; 32
    9d18:	93 83       	std	Z+3, r25	; 0x03
    9d1a:	82 83       	std	Z+2, r24	; 0x02
    9d1c:	8c ec       	ldi	r24, 0xCC	; 204
    9d1e:	95 e0       	ldi	r25, 0x05	; 5
    9d20:	95 83       	std	Z+5, r25	; 0x05
    9d22:	84 83       	std	Z+4, r24	; 0x04
    9d24:	89 e3       	ldi	r24, 0x39	; 57
    9d26:	9f e0       	ldi	r25, 0x0F	; 15
    9d28:	97 83       	std	Z+7, r25	; 0x07
    9d2a:	86 83       	std	Z+6, r24	; 0x06
    9d2c:	88 ea       	ldi	r24, 0xA8	; 168
    9d2e:	99 e0       	ldi	r25, 0x09	; 9
    9d30:	91 87       	std	Z+9, r25	; 0x09
    9d32:	80 87       	std	Z+8, r24	; 0x08
    9d34:	85 ed       	ldi	r24, 0xD5	; 213
    9d36:	99 e0       	ldi	r25, 0x09	; 9
    9d38:	93 87       	std	Z+11, r25	; 0x0b
    9d3a:	82 87       	std	Z+10, r24	; 0x0a
    9d3c:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    9d40:	ed b7       	in	r30, 0x3d	; 61
    9d42:	fe b7       	in	r31, 0x3e	; 62
    9d44:	3c 96       	adiw	r30, 0x0c	; 12
    9d46:	0f b6       	in	r0, 0x3f	; 63
    9d48:	f8 94       	cli
    9d4a:	fe bf       	out	0x3e, r31	; 62
    9d4c:	0f be       	out	0x3f, r0	; 63
    9d4e:	ed bf       	out	0x3d, r30	; 61
    9d50:	81 e0       	ldi	r24, 0x01	; 1
    9d52:	60 e0       	ldi	r22, 0x00	; 0
    9d54:	a8 01       	movw	r20, r16
    9d56:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s"),strInvoiceNumber,strDateTime);
    9d5a:	8d b7       	in	r24, 0x3d	; 61
    9d5c:	9e b7       	in	r25, 0x3e	; 62
    9d5e:	08 97       	sbiw	r24, 0x08	; 8
    9d60:	0f b6       	in	r0, 0x3f	; 63
    9d62:	f8 94       	cli
    9d64:	9e bf       	out	0x3e, r25	; 62
    9d66:	0f be       	out	0x3f, r0	; 63
    9d68:	8d bf       	out	0x3d, r24	; 61
    9d6a:	ed b7       	in	r30, 0x3d	; 61
    9d6c:	fe b7       	in	r31, 0x3e	; 62
    9d6e:	31 96       	adiw	r30, 0x01	; 1
    9d70:	ad b7       	in	r26, 0x3d	; 61
    9d72:	be b7       	in	r27, 0x3e	; 62
    9d74:	12 96       	adiw	r26, 0x02	; 2
    9d76:	1c 93       	st	X, r17
    9d78:	0e 93       	st	-X, r16
    9d7a:	11 97       	sbiw	r26, 0x01	; 1
    9d7c:	85 ed       	ldi	r24, 0xD5	; 213
    9d7e:	90 e2       	ldi	r25, 0x20	; 32
    9d80:	93 83       	std	Z+3, r25	; 0x03
    9d82:	82 83       	std	Z+2, r24	; 0x02
    9d84:	86 e3       	ldi	r24, 0x36	; 54
    9d86:	99 e0       	ldi	r25, 0x09	; 9
    9d88:	95 83       	std	Z+5, r25	; 0x05
    9d8a:	84 83       	std	Z+4, r24	; 0x04
    9d8c:	85 e2       	ldi	r24, 0x25	; 37
    9d8e:	9f e0       	ldi	r25, 0x0F	; 15
    9d90:	97 83       	std	Z+7, r25	; 0x07
    9d92:	86 83       	std	Z+6, r24	; 0x06
    9d94:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    9d98:	ed b7       	in	r30, 0x3d	; 61
    9d9a:	fe b7       	in	r31, 0x3e	; 62
    9d9c:	38 96       	adiw	r30, 0x08	; 8
    9d9e:	0f b6       	in	r0, 0x3f	; 63
    9da0:	f8 94       	cli
    9da2:	fe bf       	out	0x3e, r31	; 62
    9da4:	0f be       	out	0x3f, r0	; 63
    9da6:	ed bf       	out	0x3d, r30	; 61
    9da8:	81 e0       	ldi	r24, 0x01	; 1
    9daa:	60 e0       	ldi	r22, 0x00	; 0
    9dac:	a8 01       	movw	r20, r16
    9dae:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	sprintf_P(strSend,PSTR("E9445512"));
    9db2:	00 d0       	rcall	.+0      	; 0x9db4 <sendMessage94+0xfc>
    9db4:	00 d0       	rcall	.+0      	; 0x9db6 <sendMessage94+0xfe>
    9db6:	ad b7       	in	r26, 0x3d	; 61
    9db8:	be b7       	in	r27, 0x3e	; 62
    9dba:	12 96       	adiw	r26, 0x02	; 2
    9dbc:	1c 93       	st	X, r17
    9dbe:	0e 93       	st	-X, r16
    9dc0:	11 97       	sbiw	r26, 0x01	; 1
    9dc2:	8c ec       	ldi	r24, 0xCC	; 204
    9dc4:	90 e2       	ldi	r25, 0x20	; 32
    9dc6:	14 96       	adiw	r26, 0x04	; 4
    9dc8:	9c 93       	st	X, r25
    9dca:	8e 93       	st	-X, r24
    9dcc:	13 97       	sbiw	r26, 0x03	; 3
    9dce:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
    9dd2:	0f 90       	pop	r0
    9dd4:	0f 90       	pop	r0
    9dd6:	0f 90       	pop	r0
    9dd8:	0f 90       	pop	r0
    9dda:	81 e0       	ldi	r24, 0x01	; 1
    9ddc:	60 e0       	ldi	r22, 0x00	; 0
    9dde:	a8 01       	movw	r20, r16
    9de0:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	_uart(1, 1,0x02);
    9de4:	81 e0       	ldi	r24, 0x01	; 1
    9de6:	61 e0       	ldi	r22, 0x01	; 1
    9de8:	42 e0       	ldi	r20, 0x02	; 2
    9dea:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
}
    9dee:	c0 5b       	subi	r28, 0xB0	; 176
    9df0:	df 4f       	sbci	r29, 0xFF	; 255
    9df2:	0f b6       	in	r0, 0x3f	; 63
    9df4:	f8 94       	cli
    9df6:	de bf       	out	0x3e, r29	; 62
    9df8:	0f be       	out	0x3f, r0	; 63
    9dfa:	cd bf       	out	0x3d, r28	; 61
    9dfc:	cf 91       	pop	r28
    9dfe:	df 91       	pop	r29
    9e00:	1f 91       	pop	r17
    9e02:	0f 91       	pop	r16
    9e04:	08 95       	ret

00009e06 <sendMessage92>:
	sprintf_P(strSend,PSTR("E9445512"));
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage92(){
    9e06:	0f 93       	push	r16
    9e08:	1f 93       	push	r17
    9e0a:	df 93       	push	r29
    9e0c:	cf 93       	push	r28
    9e0e:	cd b7       	in	r28, 0x3d	; 61
    9e10:	de b7       	in	r29, 0x3e	; 62
    9e12:	c0 55       	subi	r28, 0x50	; 80
    9e14:	d0 40       	sbci	r29, 0x00	; 0
    9e16:	0f b6       	in	r0, 0x3f	; 63
    9e18:	f8 94       	cli
    9e1a:	de bf       	out	0x3e, r29	; 62
    9e1c:	0f be       	out	0x3f, r0	; 63
    9e1e:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9e20:	81 e0       	ldi	r24, 0x01	; 1
    9e22:	61 e0       	ldi	r22, 0x01	; 1
    9e24:	41 e0       	ldi	r20, 0x01	; 1
    9e26:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9e2a:	0e 94 0d 1c 	call	0x381a	; 0x381a <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9e2e:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9e32:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9e36:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s92"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9e3a:	8d b7       	in	r24, 0x3d	; 61
    9e3c:	9e b7       	in	r25, 0x3e	; 62
    9e3e:	0c 97       	sbiw	r24, 0x0c	; 12
    9e40:	0f b6       	in	r0, 0x3f	; 63
    9e42:	f8 94       	cli
    9e44:	9e bf       	out	0x3e, r25	; 62
    9e46:	0f be       	out	0x3f, r0	; 63
    9e48:	8d bf       	out	0x3d, r24	; 61
    9e4a:	ed b7       	in	r30, 0x3d	; 61
    9e4c:	fe b7       	in	r31, 0x3e	; 62
    9e4e:	31 96       	adiw	r30, 0x01	; 1
    9e50:	8e 01       	movw	r16, r28
    9e52:	0f 5f       	subi	r16, 0xFF	; 255
    9e54:	1f 4f       	sbci	r17, 0xFF	; 255
    9e56:	ad b7       	in	r26, 0x3d	; 61
    9e58:	be b7       	in	r27, 0x3e	; 62
    9e5a:	12 96       	adiw	r26, 0x02	; 2
    9e5c:	1c 93       	st	X, r17
    9e5e:	0e 93       	st	-X, r16
    9e60:	11 97       	sbiw	r26, 0x01	; 1
    9e62:	8e ef       	ldi	r24, 0xFE	; 254
    9e64:	90 e2       	ldi	r25, 0x20	; 32
    9e66:	93 83       	std	Z+3, r25	; 0x03
    9e68:	82 83       	std	Z+2, r24	; 0x02
    9e6a:	8c ec       	ldi	r24, 0xCC	; 204
    9e6c:	95 e0       	ldi	r25, 0x05	; 5
    9e6e:	95 83       	std	Z+5, r25	; 0x05
    9e70:	84 83       	std	Z+4, r24	; 0x04
    9e72:	89 e3       	ldi	r24, 0x39	; 57
    9e74:	9f e0       	ldi	r25, 0x0F	; 15
    9e76:	97 83       	std	Z+7, r25	; 0x07
    9e78:	86 83       	std	Z+6, r24	; 0x06
    9e7a:	88 ea       	ldi	r24, 0xA8	; 168
    9e7c:	99 e0       	ldi	r25, 0x09	; 9
    9e7e:	91 87       	std	Z+9, r25	; 0x09
    9e80:	80 87       	std	Z+8, r24	; 0x08
    9e82:	85 ed       	ldi	r24, 0xD5	; 213
    9e84:	99 e0       	ldi	r25, 0x09	; 9
    9e86:	93 87       	std	Z+11, r25	; 0x0b
    9e88:	82 87       	std	Z+10, r24	; 0x0a
    9e8a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    9e8e:	ed b7       	in	r30, 0x3d	; 61
    9e90:	fe b7       	in	r31, 0x3e	; 62
    9e92:	3c 96       	adiw	r30, 0x0c	; 12
    9e94:	0f b6       	in	r0, 0x3f	; 63
    9e96:	f8 94       	cli
    9e98:	fe bf       	out	0x3e, r31	; 62
    9e9a:	0f be       	out	0x3f, r0	; 63
    9e9c:	ed bf       	out	0x3d, r30	; 61
    9e9e:	81 e0       	ldi	r24, 0x01	; 1
    9ea0:	60 e0       	ldi	r22, 0x00	; 0
    9ea2:	a8 01       	movw	r20, r16
    9ea4:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s%s%s"),strTranNo,strFIP_ID,strCardType,strCardID);
    9ea8:	8d b7       	in	r24, 0x3d	; 61
    9eaa:	9e b7       	in	r25, 0x3e	; 62
    9eac:	0c 97       	sbiw	r24, 0x0c	; 12
    9eae:	0f b6       	in	r0, 0x3f	; 63
    9eb0:	f8 94       	cli
    9eb2:	9e bf       	out	0x3e, r25	; 62
    9eb4:	0f be       	out	0x3f, r0	; 63
    9eb6:	8d bf       	out	0x3d, r24	; 61
    9eb8:	ed b7       	in	r30, 0x3d	; 61
    9eba:	fe b7       	in	r31, 0x3e	; 62
    9ebc:	31 96       	adiw	r30, 0x01	; 1
    9ebe:	ad b7       	in	r26, 0x3d	; 61
    9ec0:	be b7       	in	r27, 0x3e	; 62
    9ec2:	12 96       	adiw	r26, 0x02	; 2
    9ec4:	1c 93       	st	X, r17
    9ec6:	0e 93       	st	-X, r16
    9ec8:	11 97       	sbiw	r26, 0x01	; 1
    9eca:	85 ef       	ldi	r24, 0xF5	; 245
    9ecc:	90 e2       	ldi	r25, 0x20	; 32
    9ece:	93 83       	std	Z+3, r25	; 0x03
    9ed0:	82 83       	std	Z+2, r24	; 0x02
    9ed2:	89 ed       	ldi	r24, 0xD9	; 217
    9ed4:	9f e0       	ldi	r25, 0x0F	; 15
    9ed6:	95 83       	std	Z+5, r25	; 0x05
    9ed8:	84 83       	std	Z+4, r24	; 0x04
    9eda:	86 e8       	ldi	r24, 0x86	; 134
    9edc:	99 e0       	ldi	r25, 0x09	; 9
    9ede:	97 83       	std	Z+7, r25	; 0x07
    9ee0:	86 83       	std	Z+6, r24	; 0x06
    9ee2:	85 ef       	ldi	r24, 0xF5	; 245
    9ee4:	9f e0       	ldi	r25, 0x0F	; 15
    9ee6:	91 87       	std	Z+9, r25	; 0x09
    9ee8:	80 87       	std	Z+8, r24	; 0x08
    9eea:	8f ee       	ldi	r24, 0xEF	; 239
    9eec:	9e e0       	ldi	r25, 0x0E	; 14
    9eee:	93 87       	std	Z+11, r25	; 0x0b
    9ef0:	82 87       	std	Z+10, r24	; 0x0a
    9ef2:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    9ef6:	ed b7       	in	r30, 0x3d	; 61
    9ef8:	fe b7       	in	r31, 0x3e	; 62
    9efa:	3c 96       	adiw	r30, 0x0c	; 12
    9efc:	0f b6       	in	r0, 0x3f	; 63
    9efe:	f8 94       	cli
    9f00:	fe bf       	out	0x3e, r31	; 62
    9f02:	0f be       	out	0x3f, r0	; 63
    9f04:	ed bf       	out	0x3d, r30	; 61
    9f06:	81 e0       	ldi	r24, 0x01	; 1
    9f08:	60 e0       	ldi	r22, 0x00	; 0
    9f0a:	a8 01       	movw	r20, r16
    9f0c:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s%s"),strApprovalCode,strInvoiceNumber,strDateTime);
    9f10:	8d b7       	in	r24, 0x3d	; 61
    9f12:	9e b7       	in	r25, 0x3e	; 62
    9f14:	0a 97       	sbiw	r24, 0x0a	; 10
    9f16:	0f b6       	in	r0, 0x3f	; 63
    9f18:	f8 94       	cli
    9f1a:	9e bf       	out	0x3e, r25	; 62
    9f1c:	0f be       	out	0x3f, r0	; 63
    9f1e:	8d bf       	out	0x3d, r24	; 61
    9f20:	ed b7       	in	r30, 0x3d	; 61
    9f22:	fe b7       	in	r31, 0x3e	; 62
    9f24:	31 96       	adiw	r30, 0x01	; 1
    9f26:	ad b7       	in	r26, 0x3d	; 61
    9f28:	be b7       	in	r27, 0x3e	; 62
    9f2a:	12 96       	adiw	r26, 0x02	; 2
    9f2c:	1c 93       	st	X, r17
    9f2e:	0e 93       	st	-X, r16
    9f30:	11 97       	sbiw	r26, 0x01	; 1
    9f32:	8e ee       	ldi	r24, 0xEE	; 238
    9f34:	90 e2       	ldi	r25, 0x20	; 32
    9f36:	93 83       	std	Z+3, r25	; 0x03
    9f38:	82 83       	std	Z+2, r24	; 0x02
    9f3a:	8e ec       	ldi	r24, 0xCE	; 206
    9f3c:	99 e0       	ldi	r25, 0x09	; 9
    9f3e:	95 83       	std	Z+5, r25	; 0x05
    9f40:	84 83       	std	Z+4, r24	; 0x04
    9f42:	86 e3       	ldi	r24, 0x36	; 54
    9f44:	99 e0       	ldi	r25, 0x09	; 9
    9f46:	97 83       	std	Z+7, r25	; 0x07
    9f48:	86 83       	std	Z+6, r24	; 0x06
    9f4a:	85 e2       	ldi	r24, 0x25	; 37
    9f4c:	9f e0       	ldi	r25, 0x0F	; 15
    9f4e:	91 87       	std	Z+9, r25	; 0x09
    9f50:	80 87       	std	Z+8, r24	; 0x08
    9f52:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    9f56:	ed b7       	in	r30, 0x3d	; 61
    9f58:	fe b7       	in	r31, 0x3e	; 62
    9f5a:	3a 96       	adiw	r30, 0x0a	; 10
    9f5c:	0f b6       	in	r0, 0x3f	; 63
    9f5e:	f8 94       	cli
    9f60:	fe bf       	out	0x3e, r31	; 62
    9f62:	0f be       	out	0x3f, r0	; 63
    9f64:	ed bf       	out	0x3d, r30	; 61
    9f66:	81 e0       	ldi	r24, 0x01	; 1
    9f68:	60 e0       	ldi	r22, 0x00	; 0
    9f6a:	a8 01       	movw	r20, r16
    9f6c:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("E9445512"));
    9f70:	00 d0       	rcall	.+0      	; 0x9f72 <sendMessage92+0x16c>
    9f72:	00 d0       	rcall	.+0      	; 0x9f74 <sendMessage92+0x16e>
    9f74:	ad b7       	in	r26, 0x3d	; 61
    9f76:	be b7       	in	r27, 0x3e	; 62
    9f78:	12 96       	adiw	r26, 0x02	; 2
    9f7a:	1c 93       	st	X, r17
    9f7c:	0e 93       	st	-X, r16
    9f7e:	11 97       	sbiw	r26, 0x01	; 1
    9f80:	85 ee       	ldi	r24, 0xE5	; 229
    9f82:	90 e2       	ldi	r25, 0x20	; 32
    9f84:	14 96       	adiw	r26, 0x04	; 4
    9f86:	9c 93       	st	X, r25
    9f88:	8e 93       	st	-X, r24
    9f8a:	13 97       	sbiw	r26, 0x03	; 3
    9f8c:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
    9f90:	0f 90       	pop	r0
    9f92:	0f 90       	pop	r0
    9f94:	0f 90       	pop	r0
    9f96:	0f 90       	pop	r0
    9f98:	81 e0       	ldi	r24, 0x01	; 1
    9f9a:	60 e0       	ldi	r22, 0x00	; 0
    9f9c:	a8 01       	movw	r20, r16
    9f9e:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	_uart(1, 1,0x02);
    9fa2:	81 e0       	ldi	r24, 0x01	; 1
    9fa4:	61 e0       	ldi	r22, 0x01	; 1
    9fa6:	42 e0       	ldi	r20, 0x02	; 2
    9fa8:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
}
    9fac:	c0 5b       	subi	r28, 0xB0	; 176
    9fae:	df 4f       	sbci	r29, 0xFF	; 255
    9fb0:	0f b6       	in	r0, 0x3f	; 63
    9fb2:	f8 94       	cli
    9fb4:	de bf       	out	0x3e, r29	; 62
    9fb6:	0f be       	out	0x3f, r0	; 63
    9fb8:	cd bf       	out	0x3d, r28	; 61
    9fba:	cf 91       	pop	r28
    9fbc:	df 91       	pop	r29
    9fbe:	1f 91       	pop	r17
    9fc0:	0f 91       	pop	r16
    9fc2:	08 95       	ret

00009fc4 <sendMessage90>:
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage90(){
    9fc4:	0f 93       	push	r16
    9fc6:	1f 93       	push	r17
    9fc8:	df 93       	push	r29
    9fca:	cf 93       	push	r28
    9fcc:	cd b7       	in	r28, 0x3d	; 61
    9fce:	de b7       	in	r29, 0x3e	; 62
    9fd0:	c0 55       	subi	r28, 0x50	; 80
    9fd2:	d0 40       	sbci	r29, 0x00	; 0
    9fd4:	0f b6       	in	r0, 0x3f	; 63
    9fd6:	f8 94       	cli
    9fd8:	de bf       	out	0x3e, r29	; 62
    9fda:	0f be       	out	0x3f, r0	; 63
    9fdc:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9fde:	81 e0       	ldi	r24, 0x01	; 1
    9fe0:	61 e0       	ldi	r22, 0x01	; 1
    9fe2:	41 e0       	ldi	r20, 0x01	; 1
    9fe4:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9fe8:	0e 94 0d 1c 	call	0x381a	; 0x381a <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9fec:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9ff0:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9ff4:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s90"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9ff8:	8d b7       	in	r24, 0x3d	; 61
    9ffa:	9e b7       	in	r25, 0x3e	; 62
    9ffc:	0c 97       	sbiw	r24, 0x0c	; 12
    9ffe:	0f b6       	in	r0, 0x3f	; 63
    a000:	f8 94       	cli
    a002:	9e bf       	out	0x3e, r25	; 62
    a004:	0f be       	out	0x3f, r0	; 63
    a006:	8d bf       	out	0x3d, r24	; 61
    a008:	ed b7       	in	r30, 0x3d	; 61
    a00a:	fe b7       	in	r31, 0x3e	; 62
    a00c:	31 96       	adiw	r30, 0x01	; 1
    a00e:	8e 01       	movw	r16, r28
    a010:	0f 5f       	subi	r16, 0xFF	; 255
    a012:	1f 4f       	sbci	r17, 0xFF	; 255
    a014:	ad b7       	in	r26, 0x3d	; 61
    a016:	be b7       	in	r27, 0x3e	; 62
    a018:	12 96       	adiw	r26, 0x02	; 2
    a01a:	1c 93       	st	X, r17
    a01c:	0e 93       	st	-X, r16
    a01e:	11 97       	sbiw	r26, 0x01	; 1
    a020:	87 e1       	ldi	r24, 0x17	; 23
    a022:	91 e2       	ldi	r25, 0x21	; 33
    a024:	93 83       	std	Z+3, r25	; 0x03
    a026:	82 83       	std	Z+2, r24	; 0x02
    a028:	8c ec       	ldi	r24, 0xCC	; 204
    a02a:	95 e0       	ldi	r25, 0x05	; 5
    a02c:	95 83       	std	Z+5, r25	; 0x05
    a02e:	84 83       	std	Z+4, r24	; 0x04
    a030:	89 e3       	ldi	r24, 0x39	; 57
    a032:	9f e0       	ldi	r25, 0x0F	; 15
    a034:	97 83       	std	Z+7, r25	; 0x07
    a036:	86 83       	std	Z+6, r24	; 0x06
    a038:	88 ea       	ldi	r24, 0xA8	; 168
    a03a:	99 e0       	ldi	r25, 0x09	; 9
    a03c:	91 87       	std	Z+9, r25	; 0x09
    a03e:	80 87       	std	Z+8, r24	; 0x08
    a040:	85 ed       	ldi	r24, 0xD5	; 213
    a042:	99 e0       	ldi	r25, 0x09	; 9
    a044:	93 87       	std	Z+11, r25	; 0x0b
    a046:	82 87       	std	Z+10, r24	; 0x0a
    a048:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a04c:	ed b7       	in	r30, 0x3d	; 61
    a04e:	fe b7       	in	r31, 0x3e	; 62
    a050:	3c 96       	adiw	r30, 0x0c	; 12
    a052:	0f b6       	in	r0, 0x3f	; 63
    a054:	f8 94       	cli
    a056:	fe bf       	out	0x3e, r31	; 62
    a058:	0f be       	out	0x3f, r0	; 63
    a05a:	ed bf       	out	0x3d, r30	; 61
    a05c:	81 e0       	ldi	r24, 0x01	; 1
    a05e:	60 e0       	ldi	r22, 0x00	; 0
    a060:	a8 01       	movw	r20, r16
    a062:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strRef1);
    a066:	8d b7       	in	r24, 0x3d	; 61
    a068:	9e b7       	in	r25, 0x3e	; 62
    a06a:	08 97       	sbiw	r24, 0x08	; 8
    a06c:	0f b6       	in	r0, 0x3f	; 63
    a06e:	f8 94       	cli
    a070:	9e bf       	out	0x3e, r25	; 62
    a072:	0f be       	out	0x3f, r0	; 63
    a074:	8d bf       	out	0x3d, r24	; 61
    a076:	ed b7       	in	r30, 0x3d	; 61
    a078:	fe b7       	in	r31, 0x3e	; 62
    a07a:	31 96       	adiw	r30, 0x01	; 1
    a07c:	ad b7       	in	r26, 0x3d	; 61
    a07e:	be b7       	in	r27, 0x3e	; 62
    a080:	12 96       	adiw	r26, 0x02	; 2
    a082:	1c 93       	st	X, r17
    a084:	0e 93       	st	-X, r16
    a086:	11 97       	sbiw	r26, 0x01	; 1
    a088:	82 e1       	ldi	r24, 0x12	; 18
    a08a:	91 e2       	ldi	r25, 0x21	; 33
    a08c:	93 83       	std	Z+3, r25	; 0x03
    a08e:	82 83       	std	Z+2, r24	; 0x02
    a090:	86 e8       	ldi	r24, 0x86	; 134
    a092:	99 e0       	ldi	r25, 0x09	; 9
    a094:	95 83       	std	Z+5, r25	; 0x05
    a096:	84 83       	std	Z+4, r24	; 0x04
    a098:	80 ee       	ldi	r24, 0xE0	; 224
    a09a:	9f e0       	ldi	r25, 0x0F	; 15
    a09c:	97 83       	std	Z+7, r25	; 0x07
    a09e:	86 83       	std	Z+6, r24	; 0x06
    a0a0:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a0a4:	ed b7       	in	r30, 0x3d	; 61
    a0a6:	fe b7       	in	r31, 0x3e	; 62
    a0a8:	38 96       	adiw	r30, 0x08	; 8
    a0aa:	0f b6       	in	r0, 0x3f	; 63
    a0ac:	f8 94       	cli
    a0ae:	fe bf       	out	0x3e, r31	; 62
    a0b0:	0f be       	out	0x3f, r0	; 63
    a0b2:	ed bf       	out	0x3d, r30	; 61
    a0b4:	81 e0       	ldi	r24, 0x01	; 1
    a0b6:	60 e0       	ldi	r22, 0x00	; 0
    a0b8:	a8 01       	movw	r20, r16
    a0ba:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	sprintf_P(strSend,PSTR("E9445512"));
    a0be:	00 d0       	rcall	.+0      	; 0xa0c0 <sendMessage90+0xfc>
    a0c0:	00 d0       	rcall	.+0      	; 0xa0c2 <sendMessage90+0xfe>
    a0c2:	ad b7       	in	r26, 0x3d	; 61
    a0c4:	be b7       	in	r27, 0x3e	; 62
    a0c6:	12 96       	adiw	r26, 0x02	; 2
    a0c8:	1c 93       	st	X, r17
    a0ca:	0e 93       	st	-X, r16
    a0cc:	11 97       	sbiw	r26, 0x01	; 1
    a0ce:	89 e0       	ldi	r24, 0x09	; 9
    a0d0:	91 e2       	ldi	r25, 0x21	; 33
    a0d2:	14 96       	adiw	r26, 0x04	; 4
    a0d4:	9c 93       	st	X, r25
    a0d6:	8e 93       	st	-X, r24
    a0d8:	13 97       	sbiw	r26, 0x03	; 3
    a0da:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a0de:	0f 90       	pop	r0
    a0e0:	0f 90       	pop	r0
    a0e2:	0f 90       	pop	r0
    a0e4:	0f 90       	pop	r0
    a0e6:	81 e0       	ldi	r24, 0x01	; 1
    a0e8:	60 e0       	ldi	r22, 0x00	; 0
    a0ea:	a8 01       	movw	r20, r16
    a0ec:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	_uart(1, 1,0x02);
    a0f0:	81 e0       	ldi	r24, 0x01	; 1
    a0f2:	61 e0       	ldi	r22, 0x01	; 1
    a0f4:	42 e0       	ldi	r20, 0x02	; 2
    a0f6:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
}
    a0fa:	c0 5b       	subi	r28, 0xB0	; 176
    a0fc:	df 4f       	sbci	r29, 0xFF	; 255
    a0fe:	0f b6       	in	r0, 0x3f	; 63
    a100:	f8 94       	cli
    a102:	de bf       	out	0x3e, r29	; 62
    a104:	0f be       	out	0x3f, r0	; 63
    a106:	cd bf       	out	0x3d, r28	; 61
    a108:	cf 91       	pop	r28
    a10a:	df 91       	pop	r29
    a10c:	1f 91       	pop	r17
    a10e:	0f 91       	pop	r16
    a110:	08 95       	ret

0000a112 <sendMessage58>:

	_uart_printf(1,0,PSTR("AF968CFFB"));
	_uart(1, 1,0x02);
}

void sendMessage58(){
    a112:	cf 92       	push	r12
    a114:	df 92       	push	r13
    a116:	ef 92       	push	r14
    a118:	ff 92       	push	r15
    a11a:	0f 93       	push	r16
    a11c:	1f 93       	push	r17
    a11e:	df 93       	push	r29
    a120:	cf 93       	push	r28
    a122:	cd b7       	in	r28, 0x3d	; 61
    a124:	de b7       	in	r29, 0x3e	; 62
    a126:	c0 55       	subi	r28, 0x50	; 80
    a128:	d0 40       	sbci	r29, 0x00	; 0
    a12a:	0f b6       	in	r0, 0x3f	; 63
    a12c:	f8 94       	cli
    a12e:	de bf       	out	0x3e, r29	; 62
    a130:	0f be       	out	0x3f, r0	; 63
    a132:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    a134:	81 e0       	ldi	r24, 0x01	; 1
    a136:	61 e0       	ldi	r22, 0x01	; 1
    a138:	41 e0       	ldi	r20, 0x01	; 1
    a13a:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a13e:	0e 94 0d 1c 	call	0x381a	; 0x381a <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a142:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a146:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a14a:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <UpdateServerIP>
	UpdateCardID();  //ReadCardID
    a14e:	0e 94 51 40 	call	0x80a2	; 0x80a2 <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%s%s%s58"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a152:	8d b7       	in	r24, 0x3d	; 61
    a154:	9e b7       	in	r25, 0x3e	; 62
    a156:	0c 97       	sbiw	r24, 0x0c	; 12
    a158:	0f b6       	in	r0, 0x3f	; 63
    a15a:	f8 94       	cli
    a15c:	9e bf       	out	0x3e, r25	; 62
    a15e:	0f be       	out	0x3f, r0	; 63
    a160:	8d bf       	out	0x3d, r24	; 61
    a162:	ed b7       	in	r30, 0x3d	; 61
    a164:	fe b7       	in	r31, 0x3e	; 62
    a166:	31 96       	adiw	r30, 0x01	; 1
    a168:	8e 01       	movw	r16, r28
    a16a:	0f 5f       	subi	r16, 0xFF	; 255
    a16c:	1f 4f       	sbci	r17, 0xFF	; 255
    a16e:	ad b7       	in	r26, 0x3d	; 61
    a170:	be b7       	in	r27, 0x3e	; 62
    a172:	12 96       	adiw	r26, 0x02	; 2
    a174:	1c 93       	st	X, r17
    a176:	0e 93       	st	-X, r16
    a178:	11 97       	sbiw	r26, 0x01	; 1
    a17a:	8e e4       	ldi	r24, 0x4E	; 78
    a17c:	91 e2       	ldi	r25, 0x21	; 33
    a17e:	93 83       	std	Z+3, r25	; 0x03
    a180:	82 83       	std	Z+2, r24	; 0x02
    a182:	8c ec       	ldi	r24, 0xCC	; 204
    a184:	95 e0       	ldi	r25, 0x05	; 5
    a186:	95 83       	std	Z+5, r25	; 0x05
    a188:	84 83       	std	Z+4, r24	; 0x04
    a18a:	89 e3       	ldi	r24, 0x39	; 57
    a18c:	9f e0       	ldi	r25, 0x0F	; 15
    a18e:	97 83       	std	Z+7, r25	; 0x07
    a190:	86 83       	std	Z+6, r24	; 0x06
    a192:	88 ea       	ldi	r24, 0xA8	; 168
    a194:	99 e0       	ldi	r25, 0x09	; 9
    a196:	91 87       	std	Z+9, r25	; 0x09
    a198:	80 87       	std	Z+8, r24	; 0x08
    a19a:	85 ed       	ldi	r24, 0xD5	; 213
    a19c:	99 e0       	ldi	r25, 0x09	; 9
    a19e:	93 87       	std	Z+11, r25	; 0x0b
    a1a0:	82 87       	std	Z+10, r24	; 0x0a
    a1a2:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a1a6:	8d b7       	in	r24, 0x3d	; 61
    a1a8:	9e b7       	in	r25, 0x3e	; 62
    a1aa:	0c 96       	adiw	r24, 0x0c	; 12
    a1ac:	0f b6       	in	r0, 0x3f	; 63
    a1ae:	f8 94       	cli
    a1b0:	9e bf       	out	0x3e, r25	; 62
    a1b2:	0f be       	out	0x3f, r0	; 63
    a1b4:	8d bf       	out	0x3d, r24	; 61
    a1b6:	81 e0       	ldi	r24, 0x01	; 1
    a1b8:	60 e0       	ldi	r22, 0x00	; 0
    a1ba:	a8 01       	movw	r20, r16
    a1bc:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	AddSpaceLead(strBalanceValue,13);
    a1c0:	92 e7       	ldi	r25, 0x72	; 114
    a1c2:	e9 2e       	mov	r14, r25
    a1c4:	9f e0       	ldi	r25, 0x0F	; 15
    a1c6:	f9 2e       	mov	r15, r25
    a1c8:	c7 01       	movw	r24, r14
    a1ca:	6d e0       	ldi	r22, 0x0D	; 13
    a1cc:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <AddSpaceLead>
	AddSpaceLead(strOdometer,10);
    a1d0:	83 ea       	ldi	r24, 0xA3	; 163
    a1d2:	c8 2e       	mov	r12, r24
    a1d4:	85 e0       	ldi	r24, 0x05	; 5
    a1d6:	d8 2e       	mov	r13, r24
    a1d8:	c6 01       	movw	r24, r12
    a1da:	6a e0       	ldi	r22, 0x0A	; 10
    a1dc:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <AddSpaceLead>
	sprintf_P(strSend,PSTR("%s%s%d%s%s"),strCardID,strFIP_ID,NozzleID,strBalanceType,strBalanceValue);
    a1e0:	ad b7       	in	r26, 0x3d	; 61
    a1e2:	be b7       	in	r27, 0x3e	; 62
    a1e4:	1e 97       	sbiw	r26, 0x0e	; 14
    a1e6:	0f b6       	in	r0, 0x3f	; 63
    a1e8:	f8 94       	cli
    a1ea:	be bf       	out	0x3e, r27	; 62
    a1ec:	0f be       	out	0x3f, r0	; 63
    a1ee:	ad bf       	out	0x3d, r26	; 61
    a1f0:	ed b7       	in	r30, 0x3d	; 61
    a1f2:	fe b7       	in	r31, 0x3e	; 62
    a1f4:	31 96       	adiw	r30, 0x01	; 1
    a1f6:	12 96       	adiw	r26, 0x02	; 2
    a1f8:	1c 93       	st	X, r17
    a1fa:	0e 93       	st	-X, r16
    a1fc:	11 97       	sbiw	r26, 0x01	; 1
    a1fe:	83 e4       	ldi	r24, 0x43	; 67
    a200:	91 e2       	ldi	r25, 0x21	; 33
    a202:	93 83       	std	Z+3, r25	; 0x03
    a204:	82 83       	std	Z+2, r24	; 0x02
    a206:	8f ee       	ldi	r24, 0xEF	; 239
    a208:	9e e0       	ldi	r25, 0x0E	; 14
    a20a:	95 83       	std	Z+5, r25	; 0x05
    a20c:	84 83       	std	Z+4, r24	; 0x04
    a20e:	86 e8       	ldi	r24, 0x86	; 134
    a210:	99 e0       	ldi	r25, 0x09	; 9
    a212:	97 83       	std	Z+7, r25	; 0x07
    a214:	86 83       	std	Z+6, r24	; 0x06
    a216:	80 91 50 09 	lds	r24, 0x0950
    a21a:	80 87       	std	Z+8, r24	; 0x08
    a21c:	11 86       	std	Z+9, r1	; 0x09
    a21e:	83 e8       	ldi	r24, 0x83	; 131
    a220:	95 e0       	ldi	r25, 0x05	; 5
    a222:	93 87       	std	Z+11, r25	; 0x0b
    a224:	82 87       	std	Z+10, r24	; 0x0a
    a226:	f5 86       	std	Z+13, r15	; 0x0d
    a228:	e4 86       	std	Z+12, r14	; 0x0c
    a22a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a22e:	8d b7       	in	r24, 0x3d	; 61
    a230:	9e b7       	in	r25, 0x3e	; 62
    a232:	0e 96       	adiw	r24, 0x0e	; 14
    a234:	0f b6       	in	r0, 0x3f	; 63
    a236:	f8 94       	cli
    a238:	9e bf       	out	0x3e, r25	; 62
    a23a:	0f be       	out	0x3f, r0	; 63
    a23c:	8d bf       	out	0x3d, r24	; 61
    a23e:	81 e0       	ldi	r24, 0x01	; 1
    a240:	60 e0       	ldi	r22, 0x00	; 0
    a242:	a8 01       	movw	r20, r16
    a244:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>

	CardType=0;
    a248:	10 92 69 05 	sts	0x0569, r1
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    a24c:	ad b7       	in	r26, 0x3d	; 61
    a24e:	be b7       	in	r27, 0x3e	; 62
    a250:	18 97       	sbiw	r26, 0x08	; 8
    a252:	0f b6       	in	r0, 0x3f	; 63
    a254:	f8 94       	cli
    a256:	be bf       	out	0x3e, r27	; 62
    a258:	0f be       	out	0x3f, r0	; 63
    a25a:	ad bf       	out	0x3d, r26	; 61
    a25c:	ed b7       	in	r30, 0x3d	; 61
    a25e:	fe b7       	in	r31, 0x3e	; 62
    a260:	31 96       	adiw	r30, 0x01	; 1
    a262:	12 96       	adiw	r26, 0x02	; 2
    a264:	1c 93       	st	X, r17
    a266:	0e 93       	st	-X, r16
    a268:	11 97       	sbiw	r26, 0x01	; 1
    a26a:	82 e2       	ldi	r24, 0x22	; 34
    a26c:	91 e2       	ldi	r25, 0x21	; 33
    a26e:	93 83       	std	Z+3, r25	; 0x03
    a270:	82 83       	std	Z+2, r24	; 0x02
    a272:	15 82       	std	Z+5, r1	; 0x05
    a274:	14 82       	std	Z+4, r1	; 0x04
    a276:	d7 82       	std	Z+7, r13	; 0x07
    a278:	c6 82       	std	Z+6, r12	; 0x06
    a27a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a27e:	8d b7       	in	r24, 0x3d	; 61
    a280:	9e b7       	in	r25, 0x3e	; 62
    a282:	08 96       	adiw	r24, 0x08	; 8
    a284:	0f b6       	in	r0, 0x3f	; 63
    a286:	f8 94       	cli
    a288:	9e bf       	out	0x3e, r25	; 62
    a28a:	0f be       	out	0x3f, r0	; 63
    a28c:	8d bf       	out	0x3d, r24	; 61
    a28e:	81 e0       	ldi	r24, 0x01	; 1
    a290:	60 e0       	ldi	r22, 0x00	; 0
    a292:	a8 01       	movw	r20, r16
    a294:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	_uart(1, 1,0x02);
    a298:	81 e0       	ldi	r24, 0x01	; 1
    a29a:	61 e0       	ldi	r22, 0x01	; 1
    a29c:	42 e0       	ldi	r20, 0x02	; 2
    a29e:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
}
    a2a2:	c0 5b       	subi	r28, 0xB0	; 176
    a2a4:	df 4f       	sbci	r29, 0xFF	; 255
    a2a6:	0f b6       	in	r0, 0x3f	; 63
    a2a8:	f8 94       	cli
    a2aa:	de bf       	out	0x3e, r29	; 62
    a2ac:	0f be       	out	0x3f, r0	; 63
    a2ae:	cd bf       	out	0x3d, r28	; 61
    a2b0:	cf 91       	pop	r28
    a2b2:	df 91       	pop	r29
    a2b4:	1f 91       	pop	r17
    a2b6:	0f 91       	pop	r16
    a2b8:	ff 90       	pop	r15
    a2ba:	ef 90       	pop	r14
    a2bc:	df 90       	pop	r13
    a2be:	cf 90       	pop	r12
    a2c0:	08 95       	ret

0000a2c2 <sendMessage32>:
	_uart(1, 1,0x02);
}



void sendMessage32(){//Msg32: <01>[ID][Seq][SrcIP][DestIP][MsgCode][FIP][PaymentType][Ref1][Ref2][Ref3][Ref4]<02>
    a2c2:	0f 93       	push	r16
    a2c4:	1f 93       	push	r17
    a2c6:	df 93       	push	r29
    a2c8:	cf 93       	push	r28
    a2ca:	cd b7       	in	r28, 0x3d	; 61
    a2cc:	de b7       	in	r29, 0x3e	; 62
    a2ce:	c0 55       	subi	r28, 0x50	; 80
    a2d0:	d0 40       	sbci	r29, 0x00	; 0
    a2d2:	0f b6       	in	r0, 0x3f	; 63
    a2d4:	f8 94       	cli
    a2d6:	de bf       	out	0x3e, r29	; 62
    a2d8:	0f be       	out	0x3f, r0	; 63
    a2da:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	UpdateIFT_ID(); //ReadIFT_ID
    a2dc:	0e 94 0d 1c 	call	0x381a	; 0x381a <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a2e0:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a2e4:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a2e8:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <UpdateServerIP>
	_uart(1, 1,0x01);
    a2ec:	81 e0       	ldi	r24, 0x01	; 1
    a2ee:	61 e0       	ldi	r22, 0x01	; 1
    a2f0:	41 e0       	ldi	r20, 0x01	; 1
    a2f2:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	sprintf_P(strSend,PSTR("%s%s%s%s32"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a2f6:	8d b7       	in	r24, 0x3d	; 61
    a2f8:	9e b7       	in	r25, 0x3e	; 62
    a2fa:	0c 97       	sbiw	r24, 0x0c	; 12
    a2fc:	0f b6       	in	r0, 0x3f	; 63
    a2fe:	f8 94       	cli
    a300:	9e bf       	out	0x3e, r25	; 62
    a302:	0f be       	out	0x3f, r0	; 63
    a304:	8d bf       	out	0x3d, r24	; 61
    a306:	ed b7       	in	r30, 0x3d	; 61
    a308:	fe b7       	in	r31, 0x3e	; 62
    a30a:	31 96       	adiw	r30, 0x01	; 1
    a30c:	8e 01       	movw	r16, r28
    a30e:	0f 5f       	subi	r16, 0xFF	; 255
    a310:	1f 4f       	sbci	r17, 0xFF	; 255
    a312:	ad b7       	in	r26, 0x3d	; 61
    a314:	be b7       	in	r27, 0x3e	; 62
    a316:	12 96       	adiw	r26, 0x02	; 2
    a318:	1c 93       	st	X, r17
    a31a:	0e 93       	st	-X, r16
    a31c:	11 97       	sbiw	r26, 0x01	; 1
    a31e:	89 e8       	ldi	r24, 0x89	; 137
    a320:	91 e2       	ldi	r25, 0x21	; 33
    a322:	93 83       	std	Z+3, r25	; 0x03
    a324:	82 83       	std	Z+2, r24	; 0x02
    a326:	8c ec       	ldi	r24, 0xCC	; 204
    a328:	95 e0       	ldi	r25, 0x05	; 5
    a32a:	95 83       	std	Z+5, r25	; 0x05
    a32c:	84 83       	std	Z+4, r24	; 0x04
    a32e:	89 e3       	ldi	r24, 0x39	; 57
    a330:	9f e0       	ldi	r25, 0x0F	; 15
    a332:	97 83       	std	Z+7, r25	; 0x07
    a334:	86 83       	std	Z+6, r24	; 0x06
    a336:	88 ea       	ldi	r24, 0xA8	; 168
    a338:	99 e0       	ldi	r25, 0x09	; 9
    a33a:	91 87       	std	Z+9, r25	; 0x09
    a33c:	80 87       	std	Z+8, r24	; 0x08
    a33e:	85 ed       	ldi	r24, 0xD5	; 213
    a340:	99 e0       	ldi	r25, 0x09	; 9
    a342:	93 87       	std	Z+11, r25	; 0x0b
    a344:	82 87       	std	Z+10, r24	; 0x0a
    a346:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a34a:	ed b7       	in	r30, 0x3d	; 61
    a34c:	fe b7       	in	r31, 0x3e	; 62
    a34e:	3c 96       	adiw	r30, 0x0c	; 12
    a350:	0f b6       	in	r0, 0x3f	; 63
    a352:	f8 94       	cli
    a354:	fe bf       	out	0x3e, r31	; 62
    a356:	0f be       	out	0x3f, r0	; 63
    a358:	ed bf       	out	0x3d, r30	; 61
    a35a:	81 e0       	ldi	r24, 0x01	; 1
    a35c:	60 e0       	ldi	r22, 0x00	; 0
    a35e:	a8 01       	movw	r20, r16
    a360:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s%s%s"),strFIP_ID,strPaymentType,strRef1,strRef2);
    a364:	8d b7       	in	r24, 0x3d	; 61
    a366:	9e b7       	in	r25, 0x3e	; 62
    a368:	0c 97       	sbiw	r24, 0x0c	; 12
    a36a:	0f b6       	in	r0, 0x3f	; 63
    a36c:	f8 94       	cli
    a36e:	9e bf       	out	0x3e, r25	; 62
    a370:	0f be       	out	0x3f, r0	; 63
    a372:	8d bf       	out	0x3d, r24	; 61
    a374:	ed b7       	in	r30, 0x3d	; 61
    a376:	fe b7       	in	r31, 0x3e	; 62
    a378:	31 96       	adiw	r30, 0x01	; 1
    a37a:	ad b7       	in	r26, 0x3d	; 61
    a37c:	be b7       	in	r27, 0x3e	; 62
    a37e:	12 96       	adiw	r26, 0x02	; 2
    a380:	1c 93       	st	X, r17
    a382:	0e 93       	st	-X, r16
    a384:	11 97       	sbiw	r26, 0x01	; 1
    a386:	80 e8       	ldi	r24, 0x80	; 128
    a388:	91 e2       	ldi	r25, 0x21	; 33
    a38a:	93 83       	std	Z+3, r25	; 0x03
    a38c:	82 83       	std	Z+2, r24	; 0x02
    a38e:	86 e8       	ldi	r24, 0x86	; 134
    a390:	99 e0       	ldi	r25, 0x09	; 9
    a392:	95 83       	std	Z+5, r25	; 0x05
    a394:	84 83       	std	Z+4, r24	; 0x04
    a396:	83 e3       	ldi	r24, 0x33	; 51
    a398:	99 e0       	ldi	r25, 0x09	; 9
    a39a:	97 83       	std	Z+7, r25	; 0x07
    a39c:	86 83       	std	Z+6, r24	; 0x06
    a39e:	80 ee       	ldi	r24, 0xE0	; 224
    a3a0:	9f e0       	ldi	r25, 0x0F	; 15
    a3a2:	91 87       	std	Z+9, r25	; 0x09
    a3a4:	80 87       	std	Z+8, r24	; 0x08
    a3a6:	84 e0       	ldi	r24, 0x04	; 4
    a3a8:	9f e0       	ldi	r25, 0x0F	; 15
    a3aa:	93 87       	std	Z+11, r25	; 0x0b
    a3ac:	82 87       	std	Z+10, r24	; 0x0a
    a3ae:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a3b2:	ed b7       	in	r30, 0x3d	; 61
    a3b4:	fe b7       	in	r31, 0x3e	; 62
    a3b6:	3c 96       	adiw	r30, 0x0c	; 12
    a3b8:	0f b6       	in	r0, 0x3f	; 63
    a3ba:	f8 94       	cli
    a3bc:	fe bf       	out	0x3e, r31	; 62
    a3be:	0f be       	out	0x3f, r0	; 63
    a3c0:	ed bf       	out	0x3d, r30	; 61
    a3c2:	81 e0       	ldi	r24, 0x01	; 1
    a3c4:	60 e0       	ldi	r22, 0x00	; 0
    a3c6:	a8 01       	movw	r20, r16
    a3c8:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s"),strRef3,strRef4);
    a3cc:	8d b7       	in	r24, 0x3d	; 61
    a3ce:	9e b7       	in	r25, 0x3e	; 62
    a3d0:	08 97       	sbiw	r24, 0x08	; 8
    a3d2:	0f b6       	in	r0, 0x3f	; 63
    a3d4:	f8 94       	cli
    a3d6:	9e bf       	out	0x3e, r25	; 62
    a3d8:	0f be       	out	0x3f, r0	; 63
    a3da:	8d bf       	out	0x3d, r24	; 61
    a3dc:	ed b7       	in	r30, 0x3d	; 61
    a3de:	fe b7       	in	r31, 0x3e	; 62
    a3e0:	31 96       	adiw	r30, 0x01	; 1
    a3e2:	ad b7       	in	r26, 0x3d	; 61
    a3e4:	be b7       	in	r27, 0x3e	; 62
    a3e6:	12 96       	adiw	r26, 0x02	; 2
    a3e8:	1c 93       	st	X, r17
    a3ea:	0e 93       	st	-X, r16
    a3ec:	11 97       	sbiw	r26, 0x01	; 1
    a3ee:	8b e7       	ldi	r24, 0x7B	; 123
    a3f0:	91 e2       	ldi	r25, 0x21	; 33
    a3f2:	93 83       	std	Z+3, r25	; 0x03
    a3f4:	82 83       	std	Z+2, r24	; 0x02
    a3f6:	86 e2       	ldi	r24, 0x26	; 38
    a3f8:	9c e0       	ldi	r25, 0x0C	; 12
    a3fa:	95 83       	std	Z+5, r25	; 0x05
    a3fc:	84 83       	std	Z+4, r24	; 0x04
    a3fe:	85 e8       	ldi	r24, 0x85	; 133
    a400:	95 e0       	ldi	r25, 0x05	; 5
    a402:	97 83       	std	Z+7, r25	; 0x07
    a404:	86 83       	std	Z+6, r24	; 0x06
    a406:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a40a:	ed b7       	in	r30, 0x3d	; 61
    a40c:	fe b7       	in	r31, 0x3e	; 62
    a40e:	38 96       	adiw	r30, 0x08	; 8
    a410:	0f b6       	in	r0, 0x3f	; 63
    a412:	f8 94       	cli
    a414:	fe bf       	out	0x3e, r31	; 62
    a416:	0f be       	out	0x3f, r0	; 63
    a418:	ed bf       	out	0x3d, r30	; 61
    a41a:	81 e0       	ldi	r24, 0x01	; 1
    a41c:	60 e0       	ldi	r22, 0x00	; 0
    a41e:	a8 01       	movw	r20, r16
    a420:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	sprintf_P(strSend,PSTR("F968CFFB"));
    a424:	00 d0       	rcall	.+0      	; 0xa426 <sendMessage32+0x164>
    a426:	00 d0       	rcall	.+0      	; 0xa428 <sendMessage32+0x166>
    a428:	ad b7       	in	r26, 0x3d	; 61
    a42a:	be b7       	in	r27, 0x3e	; 62
    a42c:	12 96       	adiw	r26, 0x02	; 2
    a42e:	1c 93       	st	X, r17
    a430:	0e 93       	st	-X, r16
    a432:	11 97       	sbiw	r26, 0x01	; 1
    a434:	82 e7       	ldi	r24, 0x72	; 114
    a436:	91 e2       	ldi	r25, 0x21	; 33
    a438:	14 96       	adiw	r26, 0x04	; 4
    a43a:	9c 93       	st	X, r25
    a43c:	8e 93       	st	-X, r24
    a43e:	13 97       	sbiw	r26, 0x03	; 3
    a440:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a444:	0f 90       	pop	r0
    a446:	0f 90       	pop	r0
    a448:	0f 90       	pop	r0
    a44a:	0f 90       	pop	r0
    a44c:	81 e0       	ldi	r24, 0x01	; 1
    a44e:	60 e0       	ldi	r22, 0x00	; 0
    a450:	a8 01       	movw	r20, r16
    a452:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	_uart(1, 1,0x02);
    a456:	81 e0       	ldi	r24, 0x01	; 1
    a458:	61 e0       	ldi	r22, 0x01	; 1
    a45a:	42 e0       	ldi	r20, 0x02	; 2
    a45c:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>

}
    a460:	c0 5b       	subi	r28, 0xB0	; 176
    a462:	df 4f       	sbci	r29, 0xFF	; 255
    a464:	0f b6       	in	r0, 0x3f	; 63
    a466:	f8 94       	cli
    a468:	de bf       	out	0x3e, r29	; 62
    a46a:	0f be       	out	0x3f, r0	; 63
    a46c:	cd bf       	out	0x3d, r28	; 61
    a46e:	cf 91       	pop	r28
    a470:	df 91       	pop	r29
    a472:	1f 91       	pop	r17
    a474:	0f 91       	pop	r16
    a476:	08 95       	ret

0000a478 <sendMessage28>:
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage28(){//Msg28: <01>[0103192.168.016.070192.168.016.18024[FIP][CardID]F968CFFB]<02>
    a478:	0f 93       	push	r16
    a47a:	1f 93       	push	r17
    a47c:	df 93       	push	r29
    a47e:	cf 93       	push	r28
    a480:	cd b7       	in	r28, 0x3d	; 61
    a482:	de b7       	in	r29, 0x3e	; 62
    a484:	ec 97       	sbiw	r28, 0x3c	; 60
    a486:	0f b6       	in	r0, 0x3f	; 63
    a488:	f8 94       	cli
    a48a:	de bf       	out	0x3e, r29	; 62
    a48c:	0f be       	out	0x3f, r0	; 63
    a48e:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a490:	81 e0       	ldi	r24, 0x01	; 1
    a492:	61 e0       	ldi	r22, 0x01	; 1
    a494:	41 e0       	ldi	r20, 0x01	; 1
    a496:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a49a:	0e 94 0d 1c 	call	0x381a	; 0x381a <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a49e:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a4a2:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a4a6:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s28"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a4aa:	8d b7       	in	r24, 0x3d	; 61
    a4ac:	9e b7       	in	r25, 0x3e	; 62
    a4ae:	0c 97       	sbiw	r24, 0x0c	; 12
    a4b0:	0f b6       	in	r0, 0x3f	; 63
    a4b2:	f8 94       	cli
    a4b4:	9e bf       	out	0x3e, r25	; 62
    a4b6:	0f be       	out	0x3f, r0	; 63
    a4b8:	8d bf       	out	0x3d, r24	; 61
    a4ba:	ed b7       	in	r30, 0x3d	; 61
    a4bc:	fe b7       	in	r31, 0x3e	; 62
    a4be:	31 96       	adiw	r30, 0x01	; 1
    a4c0:	8e 01       	movw	r16, r28
    a4c2:	0f 5f       	subi	r16, 0xFF	; 255
    a4c4:	1f 4f       	sbci	r17, 0xFF	; 255
    a4c6:	ad b7       	in	r26, 0x3d	; 61
    a4c8:	be b7       	in	r27, 0x3e	; 62
    a4ca:	12 96       	adiw	r26, 0x02	; 2
    a4cc:	1c 93       	st	X, r17
    a4ce:	0e 93       	st	-X, r16
    a4d0:	11 97       	sbiw	r26, 0x01	; 1
    a4d2:	81 ea       	ldi	r24, 0xA1	; 161
    a4d4:	91 e2       	ldi	r25, 0x21	; 33
    a4d6:	93 83       	std	Z+3, r25	; 0x03
    a4d8:	82 83       	std	Z+2, r24	; 0x02
    a4da:	8c ec       	ldi	r24, 0xCC	; 204
    a4dc:	95 e0       	ldi	r25, 0x05	; 5
    a4de:	95 83       	std	Z+5, r25	; 0x05
    a4e0:	84 83       	std	Z+4, r24	; 0x04
    a4e2:	89 e3       	ldi	r24, 0x39	; 57
    a4e4:	9f e0       	ldi	r25, 0x0F	; 15
    a4e6:	97 83       	std	Z+7, r25	; 0x07
    a4e8:	86 83       	std	Z+6, r24	; 0x06
    a4ea:	88 ea       	ldi	r24, 0xA8	; 168
    a4ec:	99 e0       	ldi	r25, 0x09	; 9
    a4ee:	91 87       	std	Z+9, r25	; 0x09
    a4f0:	80 87       	std	Z+8, r24	; 0x08
    a4f2:	85 ed       	ldi	r24, 0xD5	; 213
    a4f4:	99 e0       	ldi	r25, 0x09	; 9
    a4f6:	93 87       	std	Z+11, r25	; 0x0b
    a4f8:	82 87       	std	Z+10, r24	; 0x0a
    a4fa:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a4fe:	8d b7       	in	r24, 0x3d	; 61
    a500:	9e b7       	in	r25, 0x3e	; 62
    a502:	0c 96       	adiw	r24, 0x0c	; 12
    a504:	0f b6       	in	r0, 0x3f	; 63
    a506:	f8 94       	cli
    a508:	9e bf       	out	0x3e, r25	; 62
    a50a:	0f be       	out	0x3f, r0	; 63
    a50c:	8d bf       	out	0x3d, r24	; 61
    a50e:	81 e0       	ldi	r24, 0x01	; 1
    a510:	60 e0       	ldi	r22, 0x00	; 0
    a512:	a8 01       	movw	r20, r16
    a514:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	UpdateCardID();
    a518:	0e 94 51 40 	call	0x80a2	; 0x80a2 <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strFIP_ID,strCardID);
    a51c:	ad b7       	in	r26, 0x3d	; 61
    a51e:	be b7       	in	r27, 0x3e	; 62
    a520:	18 97       	sbiw	r26, 0x08	; 8
    a522:	0f b6       	in	r0, 0x3f	; 63
    a524:	f8 94       	cli
    a526:	be bf       	out	0x3e, r27	; 62
    a528:	0f be       	out	0x3f, r0	; 63
    a52a:	ad bf       	out	0x3d, r26	; 61
    a52c:	ed b7       	in	r30, 0x3d	; 61
    a52e:	fe b7       	in	r31, 0x3e	; 62
    a530:	31 96       	adiw	r30, 0x01	; 1
    a532:	12 96       	adiw	r26, 0x02	; 2
    a534:	1c 93       	st	X, r17
    a536:	0e 93       	st	-X, r16
    a538:	11 97       	sbiw	r26, 0x01	; 1
    a53a:	84 e9       	ldi	r24, 0x94	; 148
    a53c:	91 e2       	ldi	r25, 0x21	; 33
    a53e:	93 83       	std	Z+3, r25	; 0x03
    a540:	82 83       	std	Z+2, r24	; 0x02
    a542:	86 e8       	ldi	r24, 0x86	; 134
    a544:	99 e0       	ldi	r25, 0x09	; 9
    a546:	95 83       	std	Z+5, r25	; 0x05
    a548:	84 83       	std	Z+4, r24	; 0x04
    a54a:	8f ee       	ldi	r24, 0xEF	; 239
    a54c:	9e e0       	ldi	r25, 0x0E	; 14
    a54e:	97 83       	std	Z+7, r25	; 0x07
    a550:	86 83       	std	Z+6, r24	; 0x06
    a552:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a556:	8d b7       	in	r24, 0x3d	; 61
    a558:	9e b7       	in	r25, 0x3e	; 62
    a55a:	08 96       	adiw	r24, 0x08	; 8
    a55c:	0f b6       	in	r0, 0x3f	; 63
    a55e:	f8 94       	cli
    a560:	9e bf       	out	0x3e, r25	; 62
    a562:	0f be       	out	0x3f, r0	; 63
    a564:	8d bf       	out	0x3d, r24	; 61
    a566:	81 e0       	ldi	r24, 0x01	; 1
    a568:	60 e0       	ldi	r22, 0x00	; 0
    a56a:	a8 01       	movw	r20, r16
    a56c:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	_uart(1, 1,0x02);
    a570:	81 e0       	ldi	r24, 0x01	; 1
    a572:	61 e0       	ldi	r22, 0x01	; 1
    a574:	42 e0       	ldi	r20, 0x02	; 2
    a576:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
}
    a57a:	ec 96       	adiw	r28, 0x3c	; 60
    a57c:	0f b6       	in	r0, 0x3f	; 63
    a57e:	f8 94       	cli
    a580:	de bf       	out	0x3e, r29	; 62
    a582:	0f be       	out	0x3f, r0	; 63
    a584:	cd bf       	out	0x3d, r28	; 61
    a586:	cf 91       	pop	r28
    a588:	df 91       	pop	r29
    a58a:	1f 91       	pop	r17
    a58c:	0f 91       	pop	r16
    a58e:	08 95       	ret

0000a590 <sendMessage24>:
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage24(){//Msg24: <01>[0103192.168.016.070192.168.016.18022[CardID]F968CFFB]<02>
    a590:	0f 93       	push	r16
    a592:	1f 93       	push	r17
    a594:	df 93       	push	r29
    a596:	cf 93       	push	r28
    a598:	cd b7       	in	r28, 0x3d	; 61
    a59a:	de b7       	in	r29, 0x3e	; 62
    a59c:	ec 97       	sbiw	r28, 0x3c	; 60
    a59e:	0f b6       	in	r0, 0x3f	; 63
    a5a0:	f8 94       	cli
    a5a2:	de bf       	out	0x3e, r29	; 62
    a5a4:	0f be       	out	0x3f, r0	; 63
    a5a6:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a5a8:	81 e0       	ldi	r24, 0x01	; 1
    a5aa:	61 e0       	ldi	r22, 0x01	; 1
    a5ac:	41 e0       	ldi	r20, 0x01	; 1
    a5ae:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a5b2:	0e 94 0d 1c 	call	0x381a	; 0x381a <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a5b6:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a5ba:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a5be:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s24"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a5c2:	8d b7       	in	r24, 0x3d	; 61
    a5c4:	9e b7       	in	r25, 0x3e	; 62
    a5c6:	0c 97       	sbiw	r24, 0x0c	; 12
    a5c8:	0f b6       	in	r0, 0x3f	; 63
    a5ca:	f8 94       	cli
    a5cc:	9e bf       	out	0x3e, r25	; 62
    a5ce:	0f be       	out	0x3f, r0	; 63
    a5d0:	8d bf       	out	0x3d, r24	; 61
    a5d2:	ed b7       	in	r30, 0x3d	; 61
    a5d4:	fe b7       	in	r31, 0x3e	; 62
    a5d6:	31 96       	adiw	r30, 0x01	; 1
    a5d8:	8e 01       	movw	r16, r28
    a5da:	0f 5f       	subi	r16, 0xFF	; 255
    a5dc:	1f 4f       	sbci	r17, 0xFF	; 255
    a5de:	ad b7       	in	r26, 0x3d	; 61
    a5e0:	be b7       	in	r27, 0x3e	; 62
    a5e2:	12 96       	adiw	r26, 0x02	; 2
    a5e4:	1c 93       	st	X, r17
    a5e6:	0e 93       	st	-X, r16
    a5e8:	11 97       	sbiw	r26, 0x01	; 1
    a5ea:	89 eb       	ldi	r24, 0xB9	; 185
    a5ec:	91 e2       	ldi	r25, 0x21	; 33
    a5ee:	93 83       	std	Z+3, r25	; 0x03
    a5f0:	82 83       	std	Z+2, r24	; 0x02
    a5f2:	8c ec       	ldi	r24, 0xCC	; 204
    a5f4:	95 e0       	ldi	r25, 0x05	; 5
    a5f6:	95 83       	std	Z+5, r25	; 0x05
    a5f8:	84 83       	std	Z+4, r24	; 0x04
    a5fa:	89 e3       	ldi	r24, 0x39	; 57
    a5fc:	9f e0       	ldi	r25, 0x0F	; 15
    a5fe:	97 83       	std	Z+7, r25	; 0x07
    a600:	86 83       	std	Z+6, r24	; 0x06
    a602:	88 ea       	ldi	r24, 0xA8	; 168
    a604:	99 e0       	ldi	r25, 0x09	; 9
    a606:	91 87       	std	Z+9, r25	; 0x09
    a608:	80 87       	std	Z+8, r24	; 0x08
    a60a:	85 ed       	ldi	r24, 0xD5	; 213
    a60c:	99 e0       	ldi	r25, 0x09	; 9
    a60e:	93 87       	std	Z+11, r25	; 0x0b
    a610:	82 87       	std	Z+10, r24	; 0x0a
    a612:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a616:	8d b7       	in	r24, 0x3d	; 61
    a618:	9e b7       	in	r25, 0x3e	; 62
    a61a:	0c 96       	adiw	r24, 0x0c	; 12
    a61c:	0f b6       	in	r0, 0x3f	; 63
    a61e:	f8 94       	cli
    a620:	9e bf       	out	0x3e, r25	; 62
    a622:	0f be       	out	0x3f, r0	; 63
    a624:	8d bf       	out	0x3d, r24	; 61
    a626:	81 e0       	ldi	r24, 0x01	; 1
    a628:	60 e0       	ldi	r22, 0x00	; 0
    a62a:	a8 01       	movw	r20, r16
    a62c:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	UpdateCardID();
    a630:	0e 94 51 40 	call	0x80a2	; 0x80a2 <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    a634:	ad b7       	in	r26, 0x3d	; 61
    a636:	be b7       	in	r27, 0x3e	; 62
    a638:	18 97       	sbiw	r26, 0x08	; 8
    a63a:	0f b6       	in	r0, 0x3f	; 63
    a63c:	f8 94       	cli
    a63e:	be bf       	out	0x3e, r27	; 62
    a640:	0f be       	out	0x3f, r0	; 63
    a642:	ad bf       	out	0x3d, r26	; 61
    a644:	ed b7       	in	r30, 0x3d	; 61
    a646:	fe b7       	in	r31, 0x3e	; 62
    a648:	31 96       	adiw	r30, 0x01	; 1
    a64a:	12 96       	adiw	r26, 0x02	; 2
    a64c:	1c 93       	st	X, r17
    a64e:	0e 93       	st	-X, r16
    a650:	11 97       	sbiw	r26, 0x01	; 1
    a652:	8c ea       	ldi	r24, 0xAC	; 172
    a654:	91 e2       	ldi	r25, 0x21	; 33
    a656:	93 83       	std	Z+3, r25	; 0x03
    a658:	82 83       	std	Z+2, r24	; 0x02
    a65a:	8f ee       	ldi	r24, 0xEF	; 239
    a65c:	9e e0       	ldi	r25, 0x0E	; 14
    a65e:	95 83       	std	Z+5, r25	; 0x05
    a660:	84 83       	std	Z+4, r24	; 0x04
    a662:	86 e8       	ldi	r24, 0x86	; 134
    a664:	99 e0       	ldi	r25, 0x09	; 9
    a666:	97 83       	std	Z+7, r25	; 0x07
    a668:	86 83       	std	Z+6, r24	; 0x06
    a66a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a66e:	8d b7       	in	r24, 0x3d	; 61
    a670:	9e b7       	in	r25, 0x3e	; 62
    a672:	08 96       	adiw	r24, 0x08	; 8
    a674:	0f b6       	in	r0, 0x3f	; 63
    a676:	f8 94       	cli
    a678:	9e bf       	out	0x3e, r25	; 62
    a67a:	0f be       	out	0x3f, r0	; 63
    a67c:	8d bf       	out	0x3d, r24	; 61
    a67e:	81 e0       	ldi	r24, 0x01	; 1
    a680:	60 e0       	ldi	r22, 0x00	; 0
    a682:	a8 01       	movw	r20, r16
    a684:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	_uart(1, 1,0x02);
    a688:	81 e0       	ldi	r24, 0x01	; 1
    a68a:	61 e0       	ldi	r22, 0x01	; 1
    a68c:	42 e0       	ldi	r20, 0x02	; 2
    a68e:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
}
    a692:	ec 96       	adiw	r28, 0x3c	; 60
    a694:	0f b6       	in	r0, 0x3f	; 63
    a696:	f8 94       	cli
    a698:	de bf       	out	0x3e, r29	; 62
    a69a:	0f be       	out	0x3f, r0	; 63
    a69c:	cd bf       	out	0x3d, r28	; 61
    a69e:	cf 91       	pop	r28
    a6a0:	df 91       	pop	r29
    a6a2:	1f 91       	pop	r17
    a6a4:	0f 91       	pop	r16
    a6a6:	08 95       	ret

0000a6a8 <sendMessage22>:
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
	IsNewPacket=True;
}

void sendMessage22(){//Msg22: <01>[0103192.168.016.070192.168.016.18022[CardID]F968CFFB]<02>
    a6a8:	0f 93       	push	r16
    a6aa:	1f 93       	push	r17
    a6ac:	df 93       	push	r29
    a6ae:	cf 93       	push	r28
    a6b0:	cd b7       	in	r28, 0x3d	; 61
    a6b2:	de b7       	in	r29, 0x3e	; 62
    a6b4:	ec 97       	sbiw	r28, 0x3c	; 60
    a6b6:	0f b6       	in	r0, 0x3f	; 63
    a6b8:	f8 94       	cli
    a6ba:	de bf       	out	0x3e, r29	; 62
    a6bc:	0f be       	out	0x3f, r0	; 63
    a6be:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a6c0:	81 e0       	ldi	r24, 0x01	; 1
    a6c2:	61 e0       	ldi	r22, 0x01	; 1
    a6c4:	41 e0       	ldi	r20, 0x01	; 1
    a6c6:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a6ca:	0e 94 0d 1c 	call	0x381a	; 0x381a <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a6ce:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a6d2:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a6d6:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s22"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a6da:	8d b7       	in	r24, 0x3d	; 61
    a6dc:	9e b7       	in	r25, 0x3e	; 62
    a6de:	0c 97       	sbiw	r24, 0x0c	; 12
    a6e0:	0f b6       	in	r0, 0x3f	; 63
    a6e2:	f8 94       	cli
    a6e4:	9e bf       	out	0x3e, r25	; 62
    a6e6:	0f be       	out	0x3f, r0	; 63
    a6e8:	8d bf       	out	0x3d, r24	; 61
    a6ea:	ed b7       	in	r30, 0x3d	; 61
    a6ec:	fe b7       	in	r31, 0x3e	; 62
    a6ee:	31 96       	adiw	r30, 0x01	; 1
    a6f0:	8e 01       	movw	r16, r28
    a6f2:	0f 5f       	subi	r16, 0xFF	; 255
    a6f4:	1f 4f       	sbci	r17, 0xFF	; 255
    a6f6:	ad b7       	in	r26, 0x3d	; 61
    a6f8:	be b7       	in	r27, 0x3e	; 62
    a6fa:	12 96       	adiw	r26, 0x02	; 2
    a6fc:	1c 93       	st	X, r17
    a6fe:	0e 93       	st	-X, r16
    a700:	11 97       	sbiw	r26, 0x01	; 1
    a702:	8f ec       	ldi	r24, 0xCF	; 207
    a704:	91 e2       	ldi	r25, 0x21	; 33
    a706:	93 83       	std	Z+3, r25	; 0x03
    a708:	82 83       	std	Z+2, r24	; 0x02
    a70a:	8c ec       	ldi	r24, 0xCC	; 204
    a70c:	95 e0       	ldi	r25, 0x05	; 5
    a70e:	95 83       	std	Z+5, r25	; 0x05
    a710:	84 83       	std	Z+4, r24	; 0x04
    a712:	89 e3       	ldi	r24, 0x39	; 57
    a714:	9f e0       	ldi	r25, 0x0F	; 15
    a716:	97 83       	std	Z+7, r25	; 0x07
    a718:	86 83       	std	Z+6, r24	; 0x06
    a71a:	88 ea       	ldi	r24, 0xA8	; 168
    a71c:	99 e0       	ldi	r25, 0x09	; 9
    a71e:	91 87       	std	Z+9, r25	; 0x09
    a720:	80 87       	std	Z+8, r24	; 0x08
    a722:	85 ed       	ldi	r24, 0xD5	; 213
    a724:	99 e0       	ldi	r25, 0x09	; 9
    a726:	93 87       	std	Z+11, r25	; 0x0b
    a728:	82 87       	std	Z+10, r24	; 0x0a
    a72a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a72e:	8d b7       	in	r24, 0x3d	; 61
    a730:	9e b7       	in	r25, 0x3e	; 62
    a732:	0c 96       	adiw	r24, 0x0c	; 12
    a734:	0f b6       	in	r0, 0x3f	; 63
    a736:	f8 94       	cli
    a738:	9e bf       	out	0x3e, r25	; 62
    a73a:	0f be       	out	0x3f, r0	; 63
    a73c:	8d bf       	out	0x3d, r24	; 61
    a73e:	81 e0       	ldi	r24, 0x01	; 1
    a740:	60 e0       	ldi	r22, 0x00	; 0
    a742:	a8 01       	movw	r20, r16
    a744:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	UpdateCardID();
    a748:	0e 94 51 40 	call	0x80a2	; 0x80a2 <UpdateCardID>
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    a74c:	00 d0       	rcall	.+0      	; 0xa74e <sendMessage22+0xa6>
    a74e:	00 d0       	rcall	.+0      	; 0xa750 <sendMessage22+0xa8>
    a750:	00 d0       	rcall	.+0      	; 0xa752 <sendMessage22+0xaa>
    a752:	ed b7       	in	r30, 0x3d	; 61
    a754:	fe b7       	in	r31, 0x3e	; 62
    a756:	31 96       	adiw	r30, 0x01	; 1
    a758:	ad b7       	in	r26, 0x3d	; 61
    a75a:	be b7       	in	r27, 0x3e	; 62
    a75c:	12 96       	adiw	r26, 0x02	; 2
    a75e:	1c 93       	st	X, r17
    a760:	0e 93       	st	-X, r16
    a762:	11 97       	sbiw	r26, 0x01	; 1
    a764:	84 ec       	ldi	r24, 0xC4	; 196
    a766:	91 e2       	ldi	r25, 0x21	; 33
    a768:	93 83       	std	Z+3, r25	; 0x03
    a76a:	82 83       	std	Z+2, r24	; 0x02
    a76c:	8f ee       	ldi	r24, 0xEF	; 239
    a76e:	9e e0       	ldi	r25, 0x0E	; 14
    a770:	95 83       	std	Z+5, r25	; 0x05
    a772:	84 83       	std	Z+4, r24	; 0x04
    a774:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a778:	8d b7       	in	r24, 0x3d	; 61
    a77a:	9e b7       	in	r25, 0x3e	; 62
    a77c:	06 96       	adiw	r24, 0x06	; 6
    a77e:	0f b6       	in	r0, 0x3f	; 63
    a780:	f8 94       	cli
    a782:	9e bf       	out	0x3e, r25	; 62
    a784:	0f be       	out	0x3f, r0	; 63
    a786:	8d bf       	out	0x3d, r24	; 61
    a788:	81 e0       	ldi	r24, 0x01	; 1
    a78a:	60 e0       	ldi	r22, 0x00	; 0
    a78c:	a8 01       	movw	r20, r16
    a78e:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	_uart(1, 1,0x02);
    a792:	81 e0       	ldi	r24, 0x01	; 1
    a794:	61 e0       	ldi	r22, 0x01	; 1
    a796:	42 e0       	ldi	r20, 0x02	; 2
    a798:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
}
    a79c:	ec 96       	adiw	r28, 0x3c	; 60
    a79e:	0f b6       	in	r0, 0x3f	; 63
    a7a0:	f8 94       	cli
    a7a2:	de bf       	out	0x3e, r29	; 62
    a7a4:	0f be       	out	0x3f, r0	; 63
    a7a6:	cd bf       	out	0x3d, r28	; 61
    a7a8:	cf 91       	pop	r28
    a7aa:	df 91       	pop	r29
    a7ac:	1f 91       	pop	r17
    a7ae:	0f 91       	pop	r16
    a7b0:	08 95       	ret

0000a7b2 <sendMessage10>:
     _uart_print(1, 0,strSend);
	 _uart(1, 1,0x02);
}

/*Subrutine Msg10*/
void sendMessage10(){//Msg10: <01>[0103192.168.016.070192.168.016.18010F968CFFB]<02>
    a7b2:	0f 93       	push	r16
    a7b4:	1f 93       	push	r17
    a7b6:	df 93       	push	r29
    a7b8:	cf 93       	push	r28
    a7ba:	cd b7       	in	r28, 0x3d	; 61
    a7bc:	de b7       	in	r29, 0x3e	; 62
    a7be:	ec 97       	sbiw	r28, 0x3c	; 60
    a7c0:	0f b6       	in	r0, 0x3f	; 63
    a7c2:	f8 94       	cli
    a7c4:	de bf       	out	0x3e, r29	; 62
    a7c6:	0f be       	out	0x3f, r0	; 63
    a7c8:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a7ca:	81 e0       	ldi	r24, 0x01	; 1
    a7cc:	61 e0       	ldi	r22, 0x01	; 1
    a7ce:	41 e0       	ldi	r20, 0x01	; 1
    a7d0:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a7d4:	0e 94 0d 1c 	call	0x381a	; 0x381a <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a7d8:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a7dc:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a7e0:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s10F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a7e4:	8d b7       	in	r24, 0x3d	; 61
    a7e6:	9e b7       	in	r25, 0x3e	; 62
    a7e8:	0c 97       	sbiw	r24, 0x0c	; 12
    a7ea:	0f b6       	in	r0, 0x3f	; 63
    a7ec:	f8 94       	cli
    a7ee:	9e bf       	out	0x3e, r25	; 62
    a7f0:	0f be       	out	0x3f, r0	; 63
    a7f2:	8d bf       	out	0x3d, r24	; 61
    a7f4:	ed b7       	in	r30, 0x3d	; 61
    a7f6:	fe b7       	in	r31, 0x3e	; 62
    a7f8:	31 96       	adiw	r30, 0x01	; 1
    a7fa:	8e 01       	movw	r16, r28
    a7fc:	0f 5f       	subi	r16, 0xFF	; 255
    a7fe:	1f 4f       	sbci	r17, 0xFF	; 255
    a800:	ad b7       	in	r26, 0x3d	; 61
    a802:	be b7       	in	r27, 0x3e	; 62
    a804:	12 96       	adiw	r26, 0x02	; 2
    a806:	1c 93       	st	X, r17
    a808:	0e 93       	st	-X, r16
    a80a:	11 97       	sbiw	r26, 0x01	; 1
    a80c:	8a ed       	ldi	r24, 0xDA	; 218
    a80e:	91 e2       	ldi	r25, 0x21	; 33
    a810:	93 83       	std	Z+3, r25	; 0x03
    a812:	82 83       	std	Z+2, r24	; 0x02
    a814:	8c ec       	ldi	r24, 0xCC	; 204
    a816:	95 e0       	ldi	r25, 0x05	; 5
    a818:	95 83       	std	Z+5, r25	; 0x05
    a81a:	84 83       	std	Z+4, r24	; 0x04
    a81c:	89 e3       	ldi	r24, 0x39	; 57
    a81e:	9f e0       	ldi	r25, 0x0F	; 15
    a820:	97 83       	std	Z+7, r25	; 0x07
    a822:	86 83       	std	Z+6, r24	; 0x06
    a824:	88 ea       	ldi	r24, 0xA8	; 168
    a826:	99 e0       	ldi	r25, 0x09	; 9
    a828:	91 87       	std	Z+9, r25	; 0x09
    a82a:	80 87       	std	Z+8, r24	; 0x08
    a82c:	85 ed       	ldi	r24, 0xD5	; 213
    a82e:	99 e0       	ldi	r25, 0x09	; 9
    a830:	93 87       	std	Z+11, r25	; 0x0b
    a832:	82 87       	std	Z+10, r24	; 0x0a
    a834:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
    a838:	8d b7       	in	r24, 0x3d	; 61
    a83a:	9e b7       	in	r25, 0x3e	; 62
    a83c:	0c 96       	adiw	r24, 0x0c	; 12
    a83e:	0f b6       	in	r0, 0x3f	; 63
    a840:	f8 94       	cli
    a842:	9e bf       	out	0x3e, r25	; 62
    a844:	0f be       	out	0x3f, r0	; 63
    a846:	8d bf       	out	0x3d, r24	; 61
    a848:	81 e0       	ldi	r24, 0x01	; 1
    a84a:	60 e0       	ldi	r22, 0x00	; 0
    a84c:	a8 01       	movw	r20, r16
    a84e:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	_uart(1, 1,0x02);
    a852:	81 e0       	ldi	r24, 0x01	; 1
    a854:	61 e0       	ldi	r22, 0x01	; 1
    a856:	42 e0       	ldi	r20, 0x02	; 2
    a858:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	IsNewPacket=True;
    a85c:	81 e0       	ldi	r24, 0x01	; 1
    a85e:	80 93 9b 01 	sts	0x019B, r24
}
    a862:	ec 96       	adiw	r28, 0x3c	; 60
    a864:	0f b6       	in	r0, 0x3f	; 63
    a866:	f8 94       	cli
    a868:	de bf       	out	0x3e, r29	; 62
    a86a:	0f be       	out	0x3f, r0	; 63
    a86c:	cd bf       	out	0x3d, r28	; 61
    a86e:	cf 91       	pop	r28
    a870:	df 91       	pop	r29
    a872:	1f 91       	pop	r17
    a874:	0f 91       	pop	r16
    a876:	08 95       	ret

0000a878 <sendMessage04>:
     

//}

/*Subrutine Msg04*/
void sendMessage04(){   //      <STX>[IFTID][Seq][No][SrceIP][DestIP][MsgCode][ReceiptNo][Value][Checksum][ETX]
    a878:	0f 93       	push	r16
    a87a:	1f 93       	push	r17
    a87c:	df 93       	push	r29
    a87e:	cf 93       	push	r28
    a880:	cd b7       	in	r28, 0x3d	; 61
    a882:	de b7       	in	r29, 0x3e	; 62
    a884:	ec 97       	sbiw	r28, 0x3c	; 60
    a886:	0f b6       	in	r0, 0x3f	; 63
    a888:	f8 94       	cli
    a88a:	de bf       	out	0x3e, r29	; 62
    a88c:	0f be       	out	0x3f, r0	; 63
    a88e:	cd bf       	out	0x3d, r28	; 61
                        //Msg04: <01>[01][03][192.168.000.101][192.168.000.001][04][000001]0F968CFFB]<02>
	 char strSend[60];
	 _uart(1, 1,0x01);
    a890:	81 e0       	ldi	r24, 0x01	; 1
    a892:	61 e0       	ldi	r22, 0x01	; 1
    a894:	41 e0       	ldi	r20, 0x01	; 1
    a896:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	 UpdateIFT_ID(); //ReadIFT_ID
    a89a:	0e 94 0d 1c 	call	0x381a	; 0x381a <UpdateIFT_ID>
	 UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a89e:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <UpdateSeqNum>
	 UpdateClientIP();//ReadSourceIP
    a8a2:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <UpdateClientIP>
	 UpdateServerIP();//ReadDestIP
    a8a6:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <UpdateServerIP>
	 //strTranNo = strReceiptNum
	 sprintf_P(strSend,PSTR("%s%s%s%s04%s1F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,strTranNo);
    a8aa:	8d b7       	in	r24, 0x3d	; 61
    a8ac:	9e b7       	in	r25, 0x3e	; 62
    a8ae:	0e 97       	sbiw	r24, 0x0e	; 14
    a8b0:	0f b6       	in	r0, 0x3f	; 63
    a8b2:	f8 94       	cli
    a8b4:	9e bf       	out	0x3e, r25	; 62
    a8b6:	0f be       	out	0x3f, r0	; 63
    a8b8:	8d bf       	out	0x3d, r24	; 61
    a8ba:	ed b7       	in	r30, 0x3d	; 61
    a8bc:	fe b7       	in	r31, 0x3e	; 62
    a8be:	31 96       	adiw	r30, 0x01	; 1
    a8c0:	8e 01       	movw	r16, r28
    a8c2:	0f 5f       	subi	r16, 0xFF	; 255
    a8c4:	1f 4f       	sbci	r17, 0xFF	; 255
    a8c6:	ad b7       	in	r26, 0x3d	; 61
    a8c8:	be b7       	in	r27, 0x3e	; 62
    a8ca:	12 96       	adiw	r26, 0x02	; 2
    a8cc:	1c 93       	st	X, r17
    a8ce:	0e 93       	st	-X, r16
    a8d0:	11 97       	sbiw	r26, 0x01	; 1
    a8d2:	8d ee       	ldi	r24, 0xED	; 237
    a8d4:	91 e2       	ldi	r25, 0x21	; 33
    a8d6:	93 83       	std	Z+3, r25	; 0x03
    a8d8:	82 83       	std	Z+2, r24	; 0x02
    a8da:	8c ec       	ldi	r24, 0xCC	; 204
    a8dc:	95 e0       	ldi	r25, 0x05	; 5
    a8de:	95 83       	std	Z+5, r25	; 0x05
    a8e0:	84 83       	std	Z+4, r24	; 0x04
    a8e2:	89 e3       	ldi	r24, 0x39	; 57
    a8e4:	9f e0       	ldi	r25, 0x0F	; 15
    a8e6:	97 83       	std	Z+7, r25	; 0x07
    a8e8:	86 83       	std	Z+6, r24	; 0x06
    a8ea:	88 ea       	ldi	r24, 0xA8	; 168
    a8ec:	99 e0       	ldi	r25, 0x09	; 9
    a8ee:	91 87       	std	Z+9, r25	; 0x09
    a8f0:	80 87       	std	Z+8, r24	; 0x08
    a8f2:	85 ed       	ldi	r24, 0xD5	; 213
    a8f4:	99 e0       	ldi	r25, 0x09	; 9
    a8f6:	93 87       	std	Z+11, r25	; 0x0b
    a8f8:	82 87       	std	Z+10, r24	; 0x0a
    a8fa:	89 ed       	ldi	r24, 0xD9	; 217
    a8fc:	9f e0       	ldi	r25, 0x0F	; 15
    a8fe:	95 87       	std	Z+13, r25	; 0x0d
    a900:	84 87       	std	Z+12, r24	; 0x0c
    a902:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
     _uart_print(1, 0,strSend);
    a906:	8d b7       	in	r24, 0x3d	; 61
    a908:	9e b7       	in	r25, 0x3e	; 62
    a90a:	0e 96       	adiw	r24, 0x0e	; 14
    a90c:	0f b6       	in	r0, 0x3f	; 63
    a90e:	f8 94       	cli
    a910:	9e bf       	out	0x3e, r25	; 62
    a912:	0f be       	out	0x3f, r0	; 63
    a914:	8d bf       	out	0x3d, r24	; 61
    a916:	81 e0       	ldi	r24, 0x01	; 1
    a918:	60 e0       	ldi	r22, 0x00	; 0
    a91a:	a8 01       	movw	r20, r16
    a91c:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	 _uart(1, 1,0x02);
    a920:	81 e0       	ldi	r24, 0x01	; 1
    a922:	61 e0       	ldi	r22, 0x01	; 1
    a924:	42 e0       	ldi	r20, 0x02	; 2
    a926:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
}
    a92a:	ec 96       	adiw	r28, 0x3c	; 60
    a92c:	0f b6       	in	r0, 0x3f	; 63
    a92e:	f8 94       	cli
    a930:	de bf       	out	0x3e, r29	; 62
    a932:	0f be       	out	0x3f, r0	; 63
    a934:	cd bf       	out	0x3d, r28	; 61
    a936:	cf 91       	pop	r28
    a938:	df 91       	pop	r29
    a93a:	1f 91       	pop	r17
    a93c:	0f 91       	pop	r16
    a93e:	08 95       	ret

0000a940 <FreePrinting>:
	 } 
	 else _uart(_COM_PRINTER,1,xSend);
	 zSend=xSend;
}

void FreePrinting(){
    a940:	0f 93       	push	r16
    a942:	1f 93       	push	r17
static char iPrinted=0,iHeader=0,iFooter=0,PrintCopy=0,iMargin=0,iScroll=0,nScroll=0;
static char strHeader[41];
static unsigned int iSend=0,LSend=0,iLoop=0;

     //Normalize FreePrintIdleState
     if ((IsFreePrinting==True)&&(stFreePrinting!=fpInit)){
    a944:	20 91 bf 01 	lds	r18, 0x01BF
    a948:	21 30       	cpi	r18, 0x01	; 1
    a94a:	31 f4       	brne	.+12     	; 0xa958 <FreePrinting+0x18>
    a94c:	80 91 25 01 	lds	r24, 0x0125
    a950:	81 30       	cpi	r24, 0x01	; 1
    a952:	11 f0       	breq	.+4      	; 0xa958 <FreePrinting+0x18>
	     stFreePrinting=fpInit;
    a954:	20 93 25 01 	sts	0x0125, r18
	 }

	 switch (stFreePrinting){
    a958:	80 91 25 01 	lds	r24, 0x0125
    a95c:	90 e0       	ldi	r25, 0x00	; 0
    a95e:	fc 01       	movw	r30, r24
    a960:	31 97       	sbiw	r30, 0x01	; 1
    a962:	e5 31       	cpi	r30, 0x15	; 21
    a964:	f1 05       	cpc	r31, r1
    a966:	08 f0       	brcs	.+2      	; 0xa96a <FreePrinting+0x2a>
    a968:	7e c2       	rjmp	.+1276   	; 0xae66 <FreePrinting+0x526>
    a96a:	ec 59       	subi	r30, 0x9C	; 156
    a96c:	ff 4f       	sbci	r31, 0xFF	; 255
    a96e:	ee 0f       	add	r30, r30
    a970:	ff 1f       	adc	r31, r31
    a972:	05 90       	lpm	r0, Z+
    a974:	f4 91       	lpm	r31, Z+
    a976:	e0 2d       	mov	r30, r0
    a978:	09 94       	ijmp
     case fpInit:
	      //_uart_printf(0,1,PSTR("fpInit"));
	      if (IsFreePrinting==True){
    a97a:	21 30       	cpi	r18, 0x01	; 1
    a97c:	09 f0       	breq	.+2      	; 0xa980 <FreePrinting+0x40>
    a97e:	73 c2       	rjmp	.+1254   	; 0xae66 <FreePrinting+0x526>
		      IsFreePrinting=False;
    a980:	10 92 bf 01 	sts	0x01BF, r1
			  IsBusyFreePrinting=True;
    a984:	20 93 ca 01 	sts	0x01CA, r18
			  IsBusyPrint=False;
    a988:	10 92 c9 01 	sts	0x01C9, r1
			  iPrinted=0,iFooter=0;
    a98c:	10 92 88 02 	sts	0x0288, r1
    a990:	10 92 86 02 	sts	0x0286, r1

			  PrintCopy=(cmdPrint&0x0F);
    a994:	80 91 cb 01 	lds	r24, 0x01CB
    a998:	8f 70       	andi	r24, 0x0F	; 15
    a99a:	80 93 85 02 	sts	0x0285, r24

			  //cmdPrint=cmdPrint|0b00100000;
			  //PrintCopy=2;

			  stFreePrinting=fpInitHeader;
    a99e:	82 e0       	ldi	r24, 0x02	; 2
    a9a0:	80 93 25 01 	sts	0x0125, r24
			  InitPrinter();
    a9a4:	0e 94 22 4d 	call	0x9a44	; 0x9a44 <InitPrinter>
    a9a8:	5e c2       	rjmp	.+1212   	; 0xae66 <FreePrinting+0x526>
			  }
	      break;
     case fpInitHeader:
	      //_uart_printf(0,1,PSTR("fpInitHeader"));
		  iHeader=0;
    a9aa:	10 92 87 02 	sts	0x0287, r1
	      if (((cmdPrint&0b10000000)>>7)==1){
    a9ae:	80 91 cb 01 	lds	r24, 0x01CB
    a9b2:	88 1f       	adc	r24, r24
    a9b4:	88 27       	eor	r24, r24
    a9b6:	88 1f       	adc	r24, r24
    a9b8:	90 e0       	ldi	r25, 0x00	; 0
    a9ba:	81 30       	cpi	r24, 0x01	; 1
    a9bc:	91 05       	cpc	r25, r1
    a9be:	21 f1       	breq	.+72     	; 0xaa08 <FreePrinting+0xc8>
		      stFreePrinting=fpLoadHeader;
			  }
		  else
	      if (((cmdPrint&0b10000000)>>7)==0) stFreePrinting=fpInitMessage;	      
    a9c0:	89 2b       	or	r24, r25
    a9c2:	09 f0       	breq	.+2      	; 0xa9c6 <FreePrinting+0x86>
    a9c4:	50 c2       	rjmp	.+1184   	; 0xae66 <FreePrinting+0x526>
    a9c6:	85 e0       	ldi	r24, 0x05	; 5
    a9c8:	80 93 25 01 	sts	0x0125, r24
    a9cc:	4c c2       	rjmp	.+1176   	; 0xae66 <FreePrinting+0x526>
    a9ce:	60 91 87 02 	lds	r22, 0x0287
    a9d2:	89 e2       	ldi	r24, 0x29	; 41
    a9d4:	68 9f       	mul	r22, r24
    a9d6:	b0 01       	movw	r22, r0
    a9d8:	11 24       	eor	r1, r1
    a9da:	69 5d       	subi	r22, 0xD9	; 217
    a9dc:	7d 4f       	sbci	r23, 0xFD	; 253
    a9de:	89 e5       	ldi	r24, 0x59	; 89
    a9e0:	92 e0       	ldi	r25, 0x02	; 2
    a9e2:	48 e2       	ldi	r20, 0x28	; 40
    a9e4:	50 e0       	ldi	r21, 0x00	; 0
    a9e6:	28 ef       	ldi	r18, 0xF8	; 248
    a9e8:	32 e1       	ldi	r19, 0x12	; 18
    a9ea:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
	      break;
     case fpLoadHeader:
	      //_uart_printf(0,1,PSTR("fpLoadHeader"));
          //Header 1
	      eeprom_read_block((void*) &strHeader, (const void*) &DefHeaderFooter[iHeader], 40);
		  iHeader++;
    a9ee:	00 91 87 02 	lds	r16, 0x0287
    a9f2:	0f 5f       	subi	r16, 0xFF	; 255
    a9f4:	00 93 87 02 	sts	0x0287, r16
		  if (iHeader<6){
    a9f8:	06 30       	cpi	r16, 0x06	; 6
    a9fa:	28 f7       	brcc	.-54     	; 0xa9c6 <FreePrinting+0x86>
		      if (SpaceOnly(strHeader)==True){
    a9fc:	89 e5       	ldi	r24, 0x59	; 89
    a9fe:	92 e0       	ldi	r25, 0x02	; 2
    aa00:	0e 94 90 24 	call	0x4920	; 0x4920 <SpaceOnly>
    aa04:	81 30       	cpi	r24, 0x01	; 1
    aa06:	11 f4       	brne	.+4      	; 0xaa0c <FreePrinting+0xcc>
			      stFreePrinting=fpLoadHeader;
    aa08:	83 e0       	ldi	r24, 0x03	; 3
    aa0a:	de cf       	rjmp	.-68     	; 0xa9c8 <FreePrinting+0x88>
				  }	      
			  else{
			      stFreePrinting=fpPrintHeader;
    aa0c:	84 e0       	ldi	r24, 0x04	; 4
    aa0e:	80 93 25 01 	sts	0x0125, r24
			      iSend=0;
    aa12:	10 92 58 02 	sts	0x0258, r1
    aa16:	10 92 57 02 	sts	0x0257, r1
				  iLoop=0;
    aa1a:	10 92 54 02 	sts	0x0254, r1
    aa1e:	10 92 53 02 	sts	0x0253, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    aa22:	01 30       	cpi	r16, 0x01	; 1
    aa24:	19 f4       	brne	.+6      	; 0xaa2c <FreePrinting+0xec>
    aa26:	0e 94 a4 4d 	call	0x9b48	; 0x9b48 <PrintDoubleHeight>
    aa2a:	1d c2       	rjmp	.+1082   	; 0xae66 <FreePrinting+0x526>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    aa2c:	02 30       	cpi	r16, 0x02	; 2
    aa2e:	09 f0       	breq	.+2      	; 0xaa32 <FreePrinting+0xf2>
    aa30:	1a c2       	rjmp	.+1076   	; 0xae66 <FreePrinting+0x526>
    aa32:	0e 94 8a 4d 	call	0x9b14	; 0x9b14 <PrintNormalHeight>
    aa36:	17 c2       	rjmp	.+1070   	; 0xae66 <FreePrinting+0x526>
		  {stFreePrinting=fpInitMessage;
		  }
	      break;
     case fpPrintHeader:
	      //_uart_printf(0,1,PSTR("fpPrintHeader"));
		  if (iSend<40){
    aa38:	80 91 57 02 	lds	r24, 0x0257
    aa3c:	90 91 58 02 	lds	r25, 0x0258
    aa40:	88 97       	sbiw	r24, 0x28	; 40
    aa42:	78 f4       	brcc	.+30     	; 0xaa62 <FreePrinting+0x122>
		      iLoop++;
    aa44:	80 91 53 02 	lds	r24, 0x0253
    aa48:	90 91 54 02 	lds	r25, 0x0254
    aa4c:	01 96       	adiw	r24, 0x01	; 1
    aa4e:	90 93 54 02 	sts	0x0254, r25
    aa52:	80 93 53 02 	sts	0x0253, r24
			  if ((iLoop%PRINT_DELAY)==0){
			     //_uart(_COM_PRINTER,1,strHeader[iSend]);
		         //iSend++;
				 TimPrintBusy=0;
    aa56:	10 92 cd 01 	sts	0x01CD, r1
    aa5a:	10 92 cc 01 	sts	0x01CC, r1
				 stFreePrinting=fpCheckPrintStatusHeader;
    aa5e:	82 e1       	ldi	r24, 0x12	; 18
    aa60:	b3 cf       	rjmp	.-154    	; 0xa9c8 <FreePrinting+0x88>
				 }
			  }
          else{ 
		     stFreePrinting=fpLoadHeader;
    aa62:	83 e0       	ldi	r24, 0x03	; 3
    aa64:	57 c1       	rjmp	.+686    	; 0xad14 <FreePrinting+0x3d4>
			 CarriegeReturn();
		  }
	      break;

     case fpCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    aa66:	80 91 c9 01 	lds	r24, 0x01C9
    aa6a:	88 23       	and	r24, r24
    aa6c:	09 f0       	breq	.+2      	; 0xaa70 <FreePrinting+0x130>
    aa6e:	71 c1       	rjmp	.+738    	; 0xad52 <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    aa70:	e0 91 57 02 	lds	r30, 0x0257
    aa74:	f0 91 58 02 	lds	r31, 0x0258
    aa78:	e7 5a       	subi	r30, 0xA7	; 167
    aa7a:	fd 4f       	sbci	r31, 0xFD	; 253
    aa7c:	61 e0       	ldi	r22, 0x01	; 1
    aa7e:	40 81       	ld	r20, Z
    aa80:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
		      iSend++;
    aa84:	80 91 57 02 	lds	r24, 0x0257
    aa88:	90 91 58 02 	lds	r25, 0x0258
    aa8c:	01 96       	adiw	r24, 0x01	; 1
    aa8e:	90 93 58 02 	sts	0x0258, r25
    aa92:	80 93 57 02 	sts	0x0257, r24
		      stFreePrinting=fpPrintHeader;
    aa96:	84 e0       	ldi	r24, 0x04	; 4
    aa98:	5a c1       	rjmp	.+692    	; 0xad4e <FreePrinting+0x40e>
			  }
	      break;

     case fpInitMessage:
	      //_uart_printf(0,1,PSTR("fpInitMessage"));
	      iSend=0;iLoop=0;
    aa9a:	10 92 58 02 	sts	0x0258, r1
    aa9e:	10 92 57 02 	sts	0x0257, r1
    aaa2:	10 92 54 02 	sts	0x0254, r1
    aaa6:	10 92 53 02 	sts	0x0253, r1
          stFreePrinting=fpPrintMessage; 
    aaaa:	08 e0       	ldi	r16, 0x08	; 8
    aaac:	00 93 25 01 	sts	0x0125, r16
		  CarriegeReturn();
    aab0:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		  if (iPrinted>0) stFreePrinting=fpInitDuplicate;
    aab4:	80 91 88 02 	lds	r24, 0x0288
    aab8:	88 23       	and	r24, r24
    aaba:	11 f0       	breq	.+4      	; 0xaac0 <FreePrinting+0x180>
    aabc:	86 e0       	ldi	r24, 0x06	; 6
    aabe:	84 cf       	rjmp	.-248    	; 0xa9c8 <FreePrinting+0x88>
		  else stFreePrinting=fpPrintMessage; 
    aac0:	00 93 25 01 	sts	0x0125, r16
    aac4:	d0 c1       	rjmp	.+928    	; 0xae66 <FreePrinting+0x526>
	      break;
     case fpInitDuplicate:
	      //_uart_printf(0,1,PSTR("fpInitDuplicate"));
          if (iPrinted>0)sprintf_P(strHeader,PSTR("             DUPLICATE COPY        "));
    aac6:	80 91 88 02 	lds	r24, 0x0288
    aaca:	29 e5       	ldi	r18, 0x59	; 89
    aacc:	32 e0       	ldi	r19, 0x02	; 2
    aace:	88 23       	and	r24, r24
    aad0:	49 f0       	breq	.+18     	; 0xaae4 <FreePrinting+0x1a4>
    aad2:	00 d0       	rcall	.+0      	; 0xaad4 <FreePrinting+0x194>
    aad4:	00 d0       	rcall	.+0      	; 0xaad6 <FreePrinting+0x196>
    aad6:	ed b7       	in	r30, 0x3d	; 61
    aad8:	fe b7       	in	r31, 0x3e	; 62
    aada:	32 83       	std	Z+2, r19	; 0x02
    aadc:	21 83       	std	Z+1, r18	; 0x01
    aade:	8f e1       	ldi	r24, 0x1F	; 31
    aae0:	96 e0       	ldi	r25, 0x06	; 6
    aae2:	08 c0       	rjmp	.+16     	; 0xaaf4 <FreePrinting+0x1b4>
          else           sprintf_P(strHeader,PSTR("                                   "));
    aae4:	00 d0       	rcall	.+0      	; 0xaae6 <FreePrinting+0x1a6>
    aae6:	00 d0       	rcall	.+0      	; 0xaae8 <FreePrinting+0x1a8>
    aae8:	ed b7       	in	r30, 0x3d	; 61
    aaea:	fe b7       	in	r31, 0x3e	; 62
    aaec:	32 83       	std	Z+2, r19	; 0x02
    aaee:	21 83       	std	Z+1, r18	; 0x01
    aaf0:	8b ef       	ldi	r24, 0xFB	; 251
    aaf2:	95 e0       	ldi	r25, 0x05	; 5
    aaf4:	94 83       	std	Z+4, r25	; 0x04
    aaf6:	83 83       	std	Z+3, r24	; 0x03
    aaf8:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    aafc:	0f 90       	pop	r0
    aafe:	0f 90       	pop	r0
    ab00:	0f 90       	pop	r0
    ab02:	0f 90       	pop	r0
		  iSend=0;
    ab04:	10 92 58 02 	sts	0x0258, r1
    ab08:	10 92 57 02 	sts	0x0257, r1
		  iLoop=0;
    ab0c:	10 92 54 02 	sts	0x0254, r1
    ab10:	10 92 53 02 	sts	0x0253, r1
		  LSend=strlen(strHeader);
    ab14:	e9 e5       	ldi	r30, 0x59	; 89
    ab16:	f2 e0       	ldi	r31, 0x02	; 2
    ab18:	01 90       	ld	r0, Z+
    ab1a:	00 20       	and	r0, r0
    ab1c:	e9 f7       	brne	.-6      	; 0xab18 <FreePrinting+0x1d8>
    ab1e:	31 97       	sbiw	r30, 0x01	; 1
    ab20:	e9 55       	subi	r30, 0x59	; 89
    ab22:	f2 40       	sbci	r31, 0x02	; 2
    ab24:	f0 93 56 02 	sts	0x0256, r31
    ab28:	e0 93 55 02 	sts	0x0255, r30
          stFreePrinting=fpPrintDuplicate; 
    ab2c:	87 e0       	ldi	r24, 0x07	; 7
    ab2e:	4c cf       	rjmp	.-360    	; 0xa9c8 <FreePrinting+0x88>
	      break;
     case fpPrintDuplicate:
	      //_uart_printf(0,1,PSTR("fpPrintDuplicate"));
		  if (iSend<LSend){
    ab30:	20 91 57 02 	lds	r18, 0x0257
    ab34:	30 91 58 02 	lds	r19, 0x0258
    ab38:	80 91 55 02 	lds	r24, 0x0255
    ab3c:	90 91 56 02 	lds	r25, 0x0256
    ab40:	28 17       	cp	r18, r24
    ab42:	39 07       	cpc	r19, r25
    ab44:	78 f4       	brcc	.+30     	; 0xab64 <FreePrinting+0x224>
		      iLoop++;
    ab46:	80 91 53 02 	lds	r24, 0x0253
    ab4a:	90 91 54 02 	lds	r25, 0x0254
    ab4e:	01 96       	adiw	r24, 0x01	; 1
    ab50:	90 93 54 02 	sts	0x0254, r25
    ab54:	80 93 53 02 	sts	0x0253, r24
			  if((iLoop%PRINT_DELAY)==0){
			     //_uart(_COM_PRINTER,1,strHeader[iSend]);
				 //iSend++;
				 TimPrintBusy=0;
    ab58:	10 92 cd 01 	sts	0x01CD, r1
    ab5c:	10 92 cc 01 	sts	0x01CC, r1
                 stFreePrinting=fpCheckPrintStatusDuplicate;
    ab60:	85 e1       	ldi	r24, 0x15	; 21
    ab62:	32 cf       	rjmp	.-412    	; 0xa9c8 <FreePrinting+0x88>
				 }
			  }
          else {
		     iSend=0;
    ab64:	10 92 58 02 	sts	0x0258, r1
    ab68:	10 92 57 02 	sts	0x0257, r1
		     stFreePrinting=fpPrintMessage;
    ab6c:	88 e0       	ldi	r24, 0x08	; 8
    ab6e:	d2 c0       	rjmp	.+420    	; 0xad14 <FreePrinting+0x3d4>
			 CarriegeReturn();	      
			 }
	      break;
     case fpCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    ab70:	80 91 c9 01 	lds	r24, 0x01C9
    ab74:	88 23       	and	r24, r24
    ab76:	09 f0       	breq	.+2      	; 0xab7a <FreePrinting+0x23a>
    ab78:	ec c0       	rjmp	.+472    	; 0xad52 <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    ab7a:	e0 91 57 02 	lds	r30, 0x0257
    ab7e:	f0 91 58 02 	lds	r31, 0x0258
    ab82:	e7 5a       	subi	r30, 0xA7	; 167
    ab84:	fd 4f       	sbci	r31, 0xFD	; 253
    ab86:	61 e0       	ldi	r22, 0x01	; 1
    ab88:	40 81       	ld	r20, Z
    ab8a:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
		      iSend++;
    ab8e:	80 91 57 02 	lds	r24, 0x0257
    ab92:	90 91 58 02 	lds	r25, 0x0258
    ab96:	01 96       	adiw	r24, 0x01	; 1
    ab98:	90 93 58 02 	sts	0x0258, r25
    ab9c:	80 93 57 02 	sts	0x0257, r24
		      stFreePrinting=fpPrintDuplicate;
    aba0:	87 e0       	ldi	r24, 0x07	; 7
    aba2:	d5 c0       	rjmp	.+426    	; 0xad4e <FreePrinting+0x40e>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;

     case fpPrintMessage:
		  if (iSend<LengthMessage81){
    aba4:	20 91 57 02 	lds	r18, 0x0257
    aba8:	30 91 58 02 	lds	r19, 0x0258
    abac:	80 91 a0 01 	lds	r24, 0x01A0
    abb0:	90 91 a1 01 	lds	r25, 0x01A1
    abb4:	28 17       	cp	r18, r24
    abb6:	39 07       	cpc	r19, r25
    abb8:	78 f4       	brcc	.+30     	; 0xabd8 <FreePrinting+0x298>
		      iLoop++;
    abba:	80 91 53 02 	lds	r24, 0x0253
    abbe:	90 91 54 02 	lds	r25, 0x0254
    abc2:	01 96       	adiw	r24, 0x01	; 1
    abc4:	90 93 54 02 	sts	0x0254, r25
    abc8:	80 93 53 02 	sts	0x0253, r24
			  if((iLoop%PRINT_DELAY)==0){
			     TimPrintBusy=0;
    abcc:	10 92 cd 01 	sts	0x01CD, r1
    abd0:	10 92 cc 01 	sts	0x01CC, r1
				 stFreePrinting=fpCheckPrintStatusMessage;
    abd4:	83 e1       	ldi	r24, 0x13	; 19
    abd6:	f8 ce       	rjmp	.-528    	; 0xa9c8 <FreePrinting+0x88>
				 }
			  }
          else stFreePrinting=fpInitFooter;
    abd8:	8b e0       	ldi	r24, 0x0B	; 11
    abda:	f6 ce       	rjmp	.-532    	; 0xa9c8 <FreePrinting+0x88>
	      break;
     
     case fpCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    abdc:	80 91 c9 01 	lds	r24, 0x01C9
    abe0:	88 23       	and	r24, r24
    abe2:	09 f0       	breq	.+2      	; 0xabe6 <FreePrinting+0x2a6>
    abe4:	b6 c0       	rjmp	.+364    	; 0xad52 <FreePrinting+0x412>
              if ((PrintBuffer[iSend]!=0x0D)||(PrintBuffer[iSend]!=0x0A))
			      SendPrint(PrintBuffer[iSend],PrintBuffer[iSend+1]);
    abe6:	e0 91 57 02 	lds	r30, 0x0257
    abea:	f0 91 58 02 	lds	r31, 0x0258
    abee:	e1 53       	subi	r30, 0x31	; 49
    abf0:	fa 4f       	sbci	r31, 0xFA	; 250
    abf2:	80 81       	ld	r24, Z
    abf4:	61 81       	ldd	r22, Z+1	; 0x01
    abf6:	0e 94 ff 4c 	call	0x99fe	; 0x99fe <SendPrint>
			     // _uart(_COM_PRINTER,1,PrintBuffer[iSend]);
              if ((PrintBuffer[iSend]==0x0D)||(PrintBuffer[iSend+1]==0x0A))
    abfa:	e0 91 57 02 	lds	r30, 0x0257
    abfe:	f0 91 58 02 	lds	r31, 0x0258
    ac02:	e1 53       	subi	r30, 0x31	; 49
    ac04:	fa 4f       	sbci	r31, 0xFA	; 250
    ac06:	80 81       	ld	r24, Z
    ac08:	8d 30       	cpi	r24, 0x0D	; 13
    ac0a:	19 f0       	breq	.+6      	; 0xac12 <FreePrinting+0x2d2>
    ac0c:	81 81       	ldd	r24, Z+1	; 0x01
    ac0e:	8a 30       	cpi	r24, 0x0A	; 10
    ac10:	11 f4       	brne	.+4      	; 0xac16 <FreePrinting+0x2d6>
			     CarriegeReturn();
    ac12:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
             iSend++;
    ac16:	80 91 57 02 	lds	r24, 0x0257
    ac1a:	90 91 58 02 	lds	r25, 0x0258
    ac1e:	01 96       	adiw	r24, 0x01	; 1
    ac20:	90 93 58 02 	sts	0x0258, r25
    ac24:	80 93 57 02 	sts	0x0257, r24
		     stFreePrinting=fpPrintMessage;
    ac28:	88 e0       	ldi	r24, 0x08	; 8
    ac2a:	91 c0       	rjmp	.+290    	; 0xad4e <FreePrinting+0x40e>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;
     //SpaceAdded
	 case fpInitSpace:
	      iLoop=0;
    ac2c:	10 92 54 02 	sts	0x0254, r1
    ac30:	10 92 53 02 	sts	0x0253, r1
		  iMargin=0;
    ac34:	10 92 84 02 	sts	0x0284, r1
		  stFreePrinting=fpPrintMargin;
    ac38:	8a e0       	ldi	r24, 0x0A	; 10
    ac3a:	c6 ce       	rjmp	.-628    	; 0xa9c8 <FreePrinting+0x88>
	      break;
	 case fpPrintMargin:
		  if (iMargin<PRINT_MARGIN){
    ac3c:	80 91 84 02 	lds	r24, 0x0284
    ac40:	85 30       	cpi	r24, 0x05	; 5
    ac42:	90 f4       	brcc	.+36     	; 0xac68 <FreePrinting+0x328>
		      iMargin++;
    ac44:	8f 5f       	subi	r24, 0xFF	; 255
    ac46:	80 93 84 02 	sts	0x0284, r24
		      iLoop++;
    ac4a:	80 91 53 02 	lds	r24, 0x0253
    ac4e:	90 91 54 02 	lds	r25, 0x0254
    ac52:	01 96       	adiw	r24, 0x01	; 1
    ac54:	90 93 54 02 	sts	0x0254, r25
    ac58:	80 93 53 02 	sts	0x0253, r24
	          if ((iLoop%PRINT_DELAY)==0)_uart(_COM_PRINTER,1,' ');
    ac5c:	80 e0       	ldi	r24, 0x00	; 0
    ac5e:	61 e0       	ldi	r22, 0x01	; 1
    ac60:	40 e2       	ldi	r20, 0x20	; 32
    ac62:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    ac66:	ff c0       	rjmp	.+510    	; 0xae66 <FreePrinting+0x526>
			 }
          else stFreePrinting=fpPrintMessage;
    ac68:	88 e0       	ldi	r24, 0x08	; 8
    ac6a:	ae ce       	rjmp	.-676    	; 0xa9c8 <FreePrinting+0x88>
	      break;
     case fpInitFooter:
	      //_uart_printf(0,1,PSTR("fpInitFooter"));
          if (((cmdPrint&0b01000000)>>6)==1){
    ac6c:	80 91 cb 01 	lds	r24, 0x01CB
    ac70:	86 ff       	sbrs	r24, 6
    ac72:	06 c0       	rjmp	.+12     	; 0xac80 <FreePrinting+0x340>
		      stFreePrinting=fpLoadFooter;
    ac74:	8c e0       	ldi	r24, 0x0C	; 12
    ac76:	80 93 25 01 	sts	0x0125, r24
			  iFooter=0;
    ac7a:	10 92 86 02 	sts	0x0286, r1
    ac7e:	f3 c0       	rjmp	.+486    	; 0xae66 <FreePrinting+0x526>
			  }
		  else
	      if (((cmdPrint&0b01000000)>>6)==0) stFreePrinting=fpPaperCut;//fpInitScroll;	                
    ac80:	80 e1       	ldi	r24, 0x10	; 16
    ac82:	a2 ce       	rjmp	.-700    	; 0xa9c8 <FreePrinting+0x88>
    ac84:	60 91 86 02 	lds	r22, 0x0286
    ac88:	89 e2       	ldi	r24, 0x29	; 41
    ac8a:	68 9f       	mul	r22, r24
    ac8c:	b0 01       	movw	r22, r0
    ac8e:	11 24       	eor	r1, r1
    ac90:	63 5e       	subi	r22, 0xE3	; 227
    ac92:	7c 4f       	sbci	r23, 0xFC	; 252
    ac94:	89 e5       	ldi	r24, 0x59	; 89
    ac96:	92 e0       	ldi	r25, 0x02	; 2
    ac98:	48 e2       	ldi	r20, 0x28	; 40
    ac9a:	50 e0       	ldi	r21, 0x00	; 0
    ac9c:	28 ef       	ldi	r18, 0xF8	; 248
    ac9e:	32 e1       	ldi	r19, 0x12	; 18
    aca0:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
	      break;
     case fpLoadFooter:
	 	  //_uart_printf(0,1,PSTR("fpLoadFooter"));
          //Footer 1
	      eeprom_read_block((void*) &strHeader, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    aca4:	80 91 86 02 	lds	r24, 0x0286
    aca8:	8f 5f       	subi	r24, 0xFF	; 255
    acaa:	80 93 86 02 	sts	0x0286, r24
		  if (iFooter<4){
    acae:	84 30       	cpi	r24, 0x04	; 4
    acb0:	90 f4       	brcc	.+36     	; 0xacd6 <FreePrinting+0x396>
		      if (SpaceOnly(strHeader)==True){
    acb2:	89 e5       	ldi	r24, 0x59	; 89
    acb4:	92 e0       	ldi	r25, 0x02	; 2
    acb6:	0e 94 90 24 	call	0x4920	; 0x4920 <SpaceOnly>
    acba:	81 30       	cpi	r24, 0x01	; 1
    acbc:	11 f4       	brne	.+4      	; 0xacc2 <FreePrinting+0x382>
			      stFreePrinting=fpLoadFooter;
    acbe:	8c e0       	ldi	r24, 0x0C	; 12
    acc0:	83 ce       	rjmp	.-762    	; 0xa9c8 <FreePrinting+0x88>
				  }
			  else{
			      iSend=0;
    acc2:	10 92 58 02 	sts	0x0258, r1
    acc6:	10 92 57 02 	sts	0x0257, r1
				  iLoop=0;
    acca:	10 92 54 02 	sts	0x0254, r1
    acce:	10 92 53 02 	sts	0x0253, r1
				  stFreePrinting=fpPrintFooter;
    acd2:	8d e0       	ldi	r24, 0x0D	; 13
    acd4:	79 ce       	rjmp	.-782    	; 0xa9c8 <FreePrinting+0x88>
			      }
		  }else{
		    CarriegeReturn();
    acd6:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			iPrinted++;
    acda:	80 91 88 02 	lds	r24, 0x0288
    acde:	8f 5f       	subi	r24, 0xFF	; 255
    ace0:	80 93 88 02 	sts	0x0288, r24

			//if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_CUBE){
			    stFreePrinting=fpInitScroll;
    ace4:	8e e0       	ldi	r24, 0x0E	; 14
    ace6:	70 ce       	rjmp	.-800    	; 0xa9c8 <FreePrinting+0x88>
			//}else stFreePrinting=fpPaperCut;

			}
	      break;
     case fpPrintFooter:
		  if (iSend<40){
    ace8:	80 91 57 02 	lds	r24, 0x0257
    acec:	90 91 58 02 	lds	r25, 0x0258
    acf0:	88 97       	sbiw	r24, 0x28	; 40
    acf2:	78 f4       	brcc	.+30     	; 0xad12 <FreePrinting+0x3d2>
		      iLoop++;
    acf4:	80 91 53 02 	lds	r24, 0x0253
    acf8:	90 91 54 02 	lds	r25, 0x0254
    acfc:	01 96       	adiw	r24, 0x01	; 1
    acfe:	90 93 54 02 	sts	0x0254, r25
    ad02:	80 93 53 02 	sts	0x0253, r24
			  if((iLoop%PRINT_DELAY)==0){
		        //_uart(_COM_PRINTER,1,strHeader[iSend]);
		        //iSend++;
				TimPrintBusy=0;
    ad06:	10 92 cd 01 	sts	0x01CD, r1
    ad0a:	10 92 cc 01 	sts	0x01CC, r1
				stFreePrinting=fpCheckPrintStatusFooter;
    ad0e:	84 e1       	ldi	r24, 0x14	; 20
    ad10:	5b ce       	rjmp	.-842    	; 0xa9c8 <FreePrinting+0x88>
				}
			  }
          else {
		      stFreePrinting=fpLoadFooter;
    ad12:	8c e0       	ldi	r24, 0x0C	; 12
    ad14:	80 93 25 01 	sts	0x0125, r24
			  CarriegeReturn();
    ad18:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
    ad1c:	a4 c0       	rjmp	.+328    	; 0xae66 <FreePrinting+0x526>
			  }
	      break;
     
	 case fpCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    ad1e:	80 91 c9 01 	lds	r24, 0x01C9
    ad22:	88 23       	and	r24, r24
    ad24:	b1 f4       	brne	.+44     	; 0xad52 <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    ad26:	e0 91 57 02 	lds	r30, 0x0257
    ad2a:	f0 91 58 02 	lds	r31, 0x0258
    ad2e:	e7 5a       	subi	r30, 0xA7	; 167
    ad30:	fd 4f       	sbci	r31, 0xFD	; 253
    ad32:	61 e0       	ldi	r22, 0x01	; 1
    ad34:	40 81       	ld	r20, Z
    ad36:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
		      iSend++;
    ad3a:	80 91 57 02 	lds	r24, 0x0257
    ad3e:	90 91 58 02 	lds	r25, 0x0258
    ad42:	01 96       	adiw	r24, 0x01	; 1
    ad44:	90 93 58 02 	sts	0x0258, r25
    ad48:	80 93 57 02 	sts	0x0257, r24
		      stFreePrinting=fpPrintFooter;
    ad4c:	8d e0       	ldi	r24, 0x0D	; 13
    ad4e:	80 93 25 01 	sts	0x0125, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    ad52:	80 91 cc 01 	lds	r24, 0x01CC
    ad56:	90 91 cd 01 	lds	r25, 0x01CD
    ad5a:	0b 97       	sbiw	r24, 0x0b	; 11
    ad5c:	0c f4       	brge	.+2      	; 0xad60 <FreePrinting+0x420>
    ad5e:	83 c0       	rjmp	.+262    	; 0xae66 <FreePrinting+0x526>
		      IsPrintERROR=True;
    ad60:	81 e0       	ldi	r24, 0x01	; 1
    ad62:	80 93 c7 01 	sts	0x01C7, r24
		      stFreePrinting=fpFinishFreePrinting;
    ad66:	81 e1       	ldi	r24, 0x11	; 17
    ad68:	2f ce       	rjmp	.-930    	; 0xa9c8 <FreePrinting+0x88>
			  }
	      break;

     case fpInitScroll:
	      iScroll=0;
    ad6a:	10 92 83 02 	sts	0x0283, r1
		  iSend=0;
    ad6e:	10 92 58 02 	sts	0x0258, r1
    ad72:	10 92 57 02 	sts	0x0257, r1
		  if (iPrinted<PrintCopy)
    ad76:	90 91 88 02 	lds	r25, 0x0288
    ad7a:	80 91 85 02 	lds	r24, 0x0285
    ad7e:	98 17       	cp	r25, r24
    ad80:	28 f4       	brcc	.+10     	; 0xad8c <FreePrinting+0x44c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ad82:	e1 99       	sbic	0x1c, 1	; 28
    ad84:	fe cf       	rjmp	.-4      	; 0xad82 <FreePrinting+0x442>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ad86:	82 e3       	ldi	r24, 0x32	; 50
    ad88:	90 e0       	ldi	r25, 0x00	; 0
    ad8a:	04 c0       	rjmp	.+8      	; 0xad94 <FreePrinting+0x454>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ad8c:	e1 99       	sbic	0x1c, 1	; 28
    ad8e:	fe cf       	rjmp	.-4      	; 0xad8c <FreePrinting+0x44c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ad90:	81 e3       	ldi	r24, 0x31	; 49
    ad92:	90 e0       	ldi	r25, 0x00	; 0
    ad94:	9f bb       	out	0x1f, r25	; 31
    ad96:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ad98:	e0 9a       	sbi	0x1c, 0	; 28
    ad9a:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  else if (iPrinted>=PrintCopy)
		  	  nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    ad9c:	80 93 82 02 	sts	0x0282, r24

          stFreePrinting=fpScrollPaper;
    ada0:	8f e0       	ldi	r24, 0x0F	; 15
    ada2:	12 ce       	rjmp	.-988    	; 0xa9c8 <FreePrinting+0x88>
	      break;
     case fpScrollPaper:
	      if (iScroll>nScroll)stFreePrinting=fpPaperCut;
    ada4:	90 91 83 02 	lds	r25, 0x0283
    ada8:	80 91 82 02 	lds	r24, 0x0282
    adac:	89 17       	cp	r24, r25
    adae:	18 f4       	brcc	.+6      	; 0xadb6 <FreePrinting+0x476>
    adb0:	80 e1       	ldi	r24, 0x10	; 16
    adb2:	80 93 25 01 	sts	0x0125, r24
		  iSend++;
    adb6:	80 91 57 02 	lds	r24, 0x0257
    adba:	90 91 58 02 	lds	r25, 0x0258
    adbe:	01 96       	adiw	r24, 0x01	; 1
    adc0:	90 93 58 02 	sts	0x0258, r25
    adc4:	80 93 57 02 	sts	0x0257, r24
		  if (iSend%PRINT_DELAY==0){
		      CarriegeReturn();
    adc8:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			  iScroll++;
    adcc:	80 91 83 02 	lds	r24, 0x0283
    add0:	8f 5f       	subi	r24, 0xFF	; 255
    add2:	80 93 83 02 	sts	0x0283, r24
    add6:	47 c0       	rjmp	.+142    	; 0xae66 <FreePrinting+0x526>
			  }
	      break;
     case fpPaperCut:
		  //_uart_printf(0,1,PSTR("fpPaperCut"));
		  //iPrinted++;
          if (iPrinted<PrintCopy){
    add8:	90 91 88 02 	lds	r25, 0x0288
    addc:	80 91 85 02 	lds	r24, 0x0285
    ade0:	98 17       	cp	r25, r24
    ade2:	20 f4       	brcc	.+8      	; 0xadec <FreePrinting+0x4ac>
		      CarriegeReturn();
    ade4:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
              stFreePrinting=fpInitHeader;
    ade8:	82 e0       	ldi	r24, 0x02	; 2
    adea:	07 c0       	rjmp	.+14     	; 0xadfa <FreePrinting+0x4ba>
			  }
          else{
		      if (IFType==IT_SLAVE)sendMessage04();
    adec:	80 91 10 01 	lds	r24, 0x0110
    adf0:	81 30       	cpi	r24, 0x01	; 1
    adf2:	11 f4       	brne	.+4      	; 0xadf8 <FreePrinting+0x4b8>
    adf4:	0e 94 3c 54 	call	0xa878	; 0xa878 <sendMessage04>
		      stFreePrinting=fpFinishFreePrinting;
    adf8:	81 e1       	ldi	r24, 0x11	; 17
    adfa:	80 93 25 01 	sts	0x0125, r24
			  }

		  if (((cmdPrint&0b00100000)>>5)==1){
    adfe:	80 91 cb 01 	lds	r24, 0x01CB
    ae02:	85 ff       	sbrs	r24, 5
    ae04:	30 c0       	rjmp	.+96     	; 0xae66 <FreePrinting+0x526>
		      if (iPrinted==0){
    ae06:	80 91 88 02 	lds	r24, 0x0288
    ae0a:	88 23       	and	r24, r24
    ae0c:	31 f4       	brne	.+12     	; 0xae1a <FreePrinting+0x4da>
			      CarriegeReturn();_delay_ms(50);
    ae0e:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
    ae12:	84 ed       	ldi	r24, 0xD4	; 212
    ae14:	90 e3       	ldi	r25, 0x30	; 48
    ae16:	01 97       	sbiw	r24, 0x01	; 1
    ae18:	f1 f7       	brne	.-4      	; 0xae16 <FreePrinting+0x4d6>
				 }
              //HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
		      if ((iPrinted==PrintCopy)){
    ae1a:	90 91 88 02 	lds	r25, 0x0288
    ae1e:	80 91 85 02 	lds	r24, 0x0285
    ae22:	98 17       	cp	r25, r24
    ae24:	b1 f4       	brne	.+44     	; 0xae52 <FreePrinting+0x512>
			      // if (((cmdPrint&0b00010000)>>4)==1){
				       CarriegeReturn();_delay_ms(50);
    ae26:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
    ae2a:	04 ed       	ldi	r16, 0xD4	; 212
    ae2c:	10 e3       	ldi	r17, 0x30	; 48
    ae2e:	c8 01       	movw	r24, r16
    ae30:	01 97       	sbiw	r24, 0x01	; 1
    ae32:	f1 f7       	brne	.-4      	; 0xae30 <FreePrinting+0x4f0>
					   CarriegeReturn();_delay_ms(50);
    ae34:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
    ae38:	c8 01       	movw	r24, r16
    ae3a:	01 97       	sbiw	r24, 0x01	; 1
    ae3c:	f1 f7       	brne	.-4      	; 0xae3a <FreePrinting+0x4fa>
					   CarriegeReturn();_delay_ms(50);
    ae3e:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
    ae42:	c8 01       	movw	r24, r16
    ae44:	01 97       	sbiw	r24, 0x01	; 1
    ae46:	f1 f7       	brne	.-4      	; 0xae44 <FreePrinting+0x504>
					   CarriegeReturn();_delay_ms(50);
    ae48:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
    ae4c:	c8 01       	movw	r24, r16
    ae4e:	01 97       	sbiw	r24, 0x01	; 1
    ae50:	f1 f7       	brne	.-4      	; 0xae4e <FreePrinting+0x50e>
				   //}
				 }
		      PaperCut();
    ae52:	0e 94 be 4d 	call	0x9b7c	; 0x9b7c <PaperCut>
    ae56:	07 c0       	rjmp	.+14     	; 0xae66 <FreePrinting+0x526>
		   }
	      break;
     case fpFinishFreePrinting:
	 	  //_uart_printf(0,1,PSTR("fpFinished"));
		  IsBusyFreePrinting=False;
    ae58:	10 92 ca 01 	sts	0x01CA, r1
	      stFreePrinting=fpInit;
    ae5c:	81 e0       	ldi	r24, 0x01	; 1
    ae5e:	80 93 25 01 	sts	0x0125, r24
		  iPrinted=0;
    ae62:	10 92 88 02 	sts	0x0288, r1
	      break;
	 }//EndCase
}
    ae66:	1f 91       	pop	r17
    ae68:	0f 91       	pop	r16
    ae6a:	08 95       	ret

0000ae6c <PrintIdle>:
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);   
		}
}

void PrintIdle(){
    ae6c:	cf 93       	push	r28
    ae6e:	df 93       	push	r29
		_uart_print(1,1,strSend);
	 }
	 #endif

     //Normalize PrintIdleState
     if ((IsPrinting==True)&&(stPrintIdle!=piIdle)){
    ae70:	80 91 c3 01 	lds	r24, 0x01C3
    ae74:	81 30       	cpi	r24, 0x01	; 1
    ae76:	31 f4       	brne	.+12     	; 0xae84 <PrintIdle+0x18>
    ae78:	80 91 c6 02 	lds	r24, 0x02C6
    ae7c:	88 23       	and	r24, r24
    ae7e:	11 f0       	breq	.+4      	; 0xae84 <PrintIdle+0x18>
	     stPrintIdle=piIdle;
    ae80:	10 92 c6 02 	sts	0x02C6, r1
	 }

     switch(stPrintIdle){
    ae84:	80 91 c6 02 	lds	r24, 0x02C6
    ae88:	e8 2f       	mov	r30, r24
    ae8a:	f0 e0       	ldi	r31, 0x00	; 0
    ae8c:	e5 31       	cpi	r30, 0x15	; 21
    ae8e:	f1 05       	cpc	r31, r1
    ae90:	08 f0       	brcs	.+2      	; 0xae94 <PrintIdle+0x28>
    ae92:	0f c7       	rjmp	.+3614   	; 0xbcb2 <PrintIdle+0xe46>
    ae94:	e7 58       	subi	r30, 0x87	; 135
    ae96:	ff 4f       	sbci	r31, 0xFF	; 255
    ae98:	ee 0f       	add	r30, r30
    ae9a:	ff 1f       	adc	r31, r31
    ae9c:	05 90       	lpm	r0, Z+
    ae9e:	f4 91       	lpm	r31, Z+
    aea0:	e0 2d       	mov	r30, r0
    aea2:	09 94       	ijmp
	 case piIdle:
	      if (IsPrinting==True){
    aea4:	80 91 c3 01 	lds	r24, 0x01C3
    aea8:	81 30       	cpi	r24, 0x01	; 1
    aeaa:	09 f0       	breq	.+2      	; 0xaeae <PrintIdle+0x42>
    aeac:	02 c7       	rjmp	.+3588   	; 0xbcb2 <PrintIdle+0xe46>
		      IsPrinting=False;
    aeae:	10 92 c3 01 	sts	0x01C3, r1
			  IsBusyIdlePrinting=True;
    aeb2:	80 93 c8 01 	sts	0x01C8, r24
			  IsBusyPrint=False;
    aeb6:	10 92 c9 01 	sts	0x01C9, r1
			  iPrinted=0;
    aeba:	10 92 8b 02 	sts	0x028B, r1
			  PrintCopy=0;
    aebe:	10 92 8a 02 	sts	0x028A, r1
		      stPrintIdle=piInit;
    aec2:	80 93 c6 02 	sts	0x02C6, r24
			  InitPrinter();
    aec6:	0e 94 22 4d 	call	0x9a44	; 0x9a44 <InitPrinter>
			  IsSignedField=False;
    aeca:	10 92 92 02 	sts	0x0292, r1
    aece:	f1 c6       	rjmp	.+3554   	; 0xbcb2 <PrintIdle+0xe46>
			  }
	      break;
	 case piInit:
	      iHeader=0;
    aed0:	10 92 c5 02 	sts	0x02C5, r1
		  CarriegeReturn();
    aed4:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
    aed8:	1d c0       	rjmp	.+58     	; 0xaf14 <PrintIdle+0xa8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    aeda:	60 91 c5 02 	lds	r22, 0x02C5
    aede:	89 e2       	ldi	r24, 0x29	; 41
    aee0:	68 9f       	mul	r22, r24
    aee2:	b0 01       	movw	r22, r0
    aee4:	11 24       	eor	r1, r1
    aee6:	69 5d       	subi	r22, 0xD9	; 217
    aee8:	7d 4f       	sbci	r23, 0xFD	; 253
    aeea:	85 e9       	ldi	r24, 0x95	; 149
    aeec:	92 e0       	ldi	r25, 0x02	; 2
    aeee:	49 e2       	ldi	r20, 0x29	; 41
    aef0:	50 e0       	ldi	r21, 0x00	; 0
    aef2:	28 ef       	ldi	r18, 0xF8	; 248
    aef4:	32 e1       	ldi	r19, 0x12	; 18
    aef6:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
		  stPrintIdle=piLoadHeader;
	      break;
     case piLoadHeader:
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[iHeader], sizeof(DefHeaderFooter[iHeader]));
		  iHeader++;
    aefa:	80 91 c5 02 	lds	r24, 0x02C5
    aefe:	8f 5f       	subi	r24, 0xFF	; 255
    af00:	80 93 c5 02 	sts	0x02C5, r24
		  if (iHeader<6){
    af04:	86 30       	cpi	r24, 0x06	; 6
    af06:	00 f5       	brcc	.+64     	; 0xaf48 <PrintIdle+0xdc>
		      if (SpaceOnly(strPrint)==True){
    af08:	85 e9       	ldi	r24, 0x95	; 149
    af0a:	92 e0       	ldi	r25, 0x02	; 2
    af0c:	0e 94 90 24 	call	0x4920	; 0x4920 <SpaceOnly>
    af10:	81 30       	cpi	r24, 0x01	; 1
    af12:	11 f4       	brne	.+4      	; 0xaf18 <PrintIdle+0xac>
			      stPrintIdle=piLoadHeader;
    af14:	82 e0       	ldi	r24, 0x02	; 2
    af16:	a2 c6       	rjmp	.+3396   	; 0xbc5c <PrintIdle+0xdf0>
				  }	      
			  else{
			      stPrintIdle=piPrintHeader;
    af18:	83 e0       	ldi	r24, 0x03	; 3
    af1a:	80 93 c6 02 	sts	0x02C6, r24
			      iSend=0;
    af1e:	10 92 91 02 	sts	0x0291, r1
    af22:	10 92 90 02 	sts	0x0290, r1
				  iLoop=0;
    af26:	10 92 8d 02 	sts	0x028D, r1
    af2a:	10 92 8c 02 	sts	0x028C, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    af2e:	80 91 c5 02 	lds	r24, 0x02C5
    af32:	81 30       	cpi	r24, 0x01	; 1
    af34:	19 f4       	brne	.+6      	; 0xaf3c <PrintIdle+0xd0>
    af36:	0e 94 a4 4d 	call	0x9b48	; 0x9b48 <PrintDoubleHeight>
    af3a:	bb c6       	rjmp	.+3446   	; 0xbcb2 <PrintIdle+0xe46>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    af3c:	82 30       	cpi	r24, 0x02	; 2
    af3e:	09 f0       	breq	.+2      	; 0xaf42 <PrintIdle+0xd6>
    af40:	b8 c6       	rjmp	.+3440   	; 0xbcb2 <PrintIdle+0xe46>
    af42:	0e 94 8a 4d 	call	0x9b14	; 0x9b14 <PrintNormalHeight>
    af46:	b5 c6       	rjmp	.+3434   	; 0xbcb2 <PrintIdle+0xe46>
			   }
		  }else{stPrintIdle=piInitDuplicate; //stPrintIdle=piInitMessage;//
    af48:	84 e0       	ldi	r24, 0x04	; 4
    af4a:	88 c6       	rjmp	.+3344   	; 0xbc5c <PrintIdle+0xdf0>
		        //else stPrintIdle=piInitMessage;
		  }
	      break;
	 case piPrintHeader:
		  if (iSend<40){
    af4c:	80 91 90 02 	lds	r24, 0x0290
    af50:	90 91 91 02 	lds	r25, 0x0291
    af54:	88 97       	sbiw	r24, 0x28	; 40
    af56:	78 f4       	brcc	.+30     	; 0xaf76 <PrintIdle+0x10a>
		      iLoop++;
    af58:	80 91 8c 02 	lds	r24, 0x028C
    af5c:	90 91 8d 02 	lds	r25, 0x028D
    af60:	01 96       	adiw	r24, 0x01	; 1
    af62:	90 93 8d 02 	sts	0x028D, r25
    af66:	80 93 8c 02 	sts	0x028C, r24
			  if ((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    af6a:	10 92 cd 01 	sts	0x01CD, r1
    af6e:	10 92 cc 01 	sts	0x01CC, r1
				 stPrintIdle=piCheckPrintStatusHeader;
    af72:	8b e0       	ldi	r24, 0x0B	; 11
    af74:	73 c6       	rjmp	.+3302   	; 0xbc5c <PrintIdle+0xdf0>
				 }
			  }
          else{ 
		     stPrintIdle=piLoadHeader;
    af76:	82 e0       	ldi	r24, 0x02	; 2
    af78:	01 c6       	rjmp	.+3074   	; 0xbb7c <PrintIdle+0xd10>
			 CarriegeReturn();
		  }
	      break;
     case piCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    af7a:	80 91 c9 01 	lds	r24, 0x01C9
    af7e:	88 23       	and	r24, r24
    af80:	09 f0       	breq	.+2      	; 0xaf84 <PrintIdle+0x118>
    af82:	62 c6       	rjmp	.+3268   	; 0xbc48 <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    af84:	e0 91 90 02 	lds	r30, 0x0290
    af88:	f0 91 91 02 	lds	r31, 0x0291
    af8c:	eb 56       	subi	r30, 0x6B	; 107
    af8e:	fd 4f       	sbci	r31, 0xFD	; 253
    af90:	61 e0       	ldi	r22, 0x01	; 1
    af92:	40 81       	ld	r20, Z
    af94:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
		      iSend++;
    af98:	80 91 90 02 	lds	r24, 0x0290
    af9c:	90 91 91 02 	lds	r25, 0x0291
    afa0:	01 96       	adiw	r24, 0x01	; 1
    afa2:	90 93 91 02 	sts	0x0291, r25
    afa6:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintHeader;
    afaa:	83 e0       	ldi	r24, 0x03	; 3
    afac:	4b c6       	rjmp	.+3222   	; 0xbc44 <PrintIdle+0xdd8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitDuplicate:
          if ((iPrinted>0)||(IsReprintTicket==True)){
    afae:	80 91 8b 02 	lds	r24, 0x028B
    afb2:	88 23       	and	r24, r24
    afb4:	21 f4       	brne	.+8      	; 0xafbe <PrintIdle+0x152>
    afb6:	80 91 92 01 	lds	r24, 0x0192
    afba:	81 30       	cpi	r24, 0x01	; 1
    afbc:	a9 f4       	brne	.+42     	; 0xafe8 <PrintIdle+0x17c>
		      IsReprintTicket=False;
    afbe:	10 92 92 01 	sts	0x0192, r1
		      CarriegeReturn(); 
    afc2:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		      sprintf_P(strPrint,PSTR("             DUPLICATE COPY        "));
    afc6:	00 d0       	rcall	.+0      	; 0xafc8 <PrintIdle+0x15c>
    afc8:	00 d0       	rcall	.+0      	; 0xafca <PrintIdle+0x15e>
    afca:	85 e9       	ldi	r24, 0x95	; 149
    afcc:	92 e0       	ldi	r25, 0x02	; 2
    afce:	ad b7       	in	r26, 0x3d	; 61
    afd0:	be b7       	in	r27, 0x3e	; 62
    afd2:	12 96       	adiw	r26, 0x02	; 2
    afd4:	9c 93       	st	X, r25
    afd6:	8e 93       	st	-X, r24
    afd8:	11 97       	sbiw	r26, 0x01	; 1
    afda:	8a e0       	ldi	r24, 0x0A	; 10
    afdc:	9a e0       	ldi	r25, 0x0A	; 10
    afde:	14 96       	adiw	r26, 0x04	; 4
    afe0:	9c 93       	st	X, r25
    afe2:	8e 93       	st	-X, r24
    afe4:	13 97       	sbiw	r26, 0x03	; 3
    afe6:	0c c0       	rjmp	.+24     	; 0xb000 <PrintIdle+0x194>
		      }
          else{           sprintf_P(strPrint,PSTR(" "));
    afe8:	00 d0       	rcall	.+0      	; 0xafea <PrintIdle+0x17e>
    afea:	00 d0       	rcall	.+0      	; 0xafec <PrintIdle+0x180>
    afec:	85 e9       	ldi	r24, 0x95	; 149
    afee:	92 e0       	ldi	r25, 0x02	; 2
    aff0:	ed b7       	in	r30, 0x3d	; 61
    aff2:	fe b7       	in	r31, 0x3e	; 62
    aff4:	92 83       	std	Z+2, r25	; 0x02
    aff6:	81 83       	std	Z+1, r24	; 0x01
    aff8:	88 e0       	ldi	r24, 0x08	; 8
    affa:	9a e0       	ldi	r25, 0x0A	; 10
    affc:	94 83       	std	Z+4, r25	; 0x04
    affe:	83 83       	std	Z+3, r24	; 0x03
    b000:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    b004:	0f 90       	pop	r0
    b006:	0f 90       	pop	r0
    b008:	0f 90       	pop	r0
    b00a:	0f 90       	pop	r0
		      }
		  iSend=0;
    b00c:	10 92 91 02 	sts	0x0291, r1
    b010:	10 92 90 02 	sts	0x0290, r1
		  iLoop=0;
    b014:	10 92 8d 02 	sts	0x028D, r1
    b018:	10 92 8c 02 	sts	0x028C, r1
		  LSend=strlen(strPrint);
    b01c:	e5 e9       	ldi	r30, 0x95	; 149
    b01e:	f2 e0       	ldi	r31, 0x02	; 2
    b020:	01 90       	ld	r0, Z+
    b022:	00 20       	and	r0, r0
    b024:	e9 f7       	brne	.-6      	; 0xb020 <PrintIdle+0x1b4>
    b026:	31 97       	sbiw	r30, 0x01	; 1
    b028:	e5 59       	subi	r30, 0x95	; 149
    b02a:	f2 40       	sbci	r31, 0x02	; 2
    b02c:	f0 93 8f 02 	sts	0x028F, r31
    b030:	e0 93 8e 02 	sts	0x028E, r30
          stPrintIdle=piPrintDuplicate; 
    b034:	85 e0       	ldi	r24, 0x05	; 5
    b036:	12 c6       	rjmp	.+3108   	; 0xbc5c <PrintIdle+0xdf0>
	      break;
     case piPrintDuplicate:
		  if (iSend<LSend){
    b038:	20 91 90 02 	lds	r18, 0x0290
    b03c:	30 91 91 02 	lds	r19, 0x0291
    b040:	80 91 8e 02 	lds	r24, 0x028E
    b044:	90 91 8f 02 	lds	r25, 0x028F
    b048:	28 17       	cp	r18, r24
    b04a:	39 07       	cpc	r19, r25
    b04c:	78 f4       	brcc	.+30     	; 0xb06c <PrintIdle+0x200>
		      iLoop++;
    b04e:	80 91 8c 02 	lds	r24, 0x028C
    b052:	90 91 8d 02 	lds	r25, 0x028D
    b056:	01 96       	adiw	r24, 0x01	; 1
    b058:	90 93 8d 02 	sts	0x028D, r25
    b05c:	80 93 8c 02 	sts	0x028C, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    b060:	10 92 cd 01 	sts	0x01CD, r1
    b064:	10 92 cc 01 	sts	0x01CC, r1
                 stPrintIdle=piCheckPrintStatusDuplicate;
    b068:	86 e0       	ldi	r24, 0x06	; 6
    b06a:	f8 c5       	rjmp	.+3056   	; 0xbc5c <PrintIdle+0xdf0>
				 }
			  }
          else {
		     iSend=0;
    b06c:	10 92 91 02 	sts	0x0291, r1
    b070:	10 92 90 02 	sts	0x0290, r1
		     stPrintIdle=piInitMessage;
    b074:	87 e0       	ldi	r24, 0x07	; 7
    b076:	f2 c5       	rjmp	.+3044   	; 0xbc5c <PrintIdle+0xdf0>
			 }
	      break;
     case piCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    b078:	80 91 c9 01 	lds	r24, 0x01C9
    b07c:	88 23       	and	r24, r24
    b07e:	09 f0       	breq	.+2      	; 0xb082 <PrintIdle+0x216>
    b080:	e3 c5       	rjmp	.+3014   	; 0xbc48 <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    b082:	e0 91 90 02 	lds	r30, 0x0290
    b086:	f0 91 91 02 	lds	r31, 0x0291
    b08a:	eb 56       	subi	r30, 0x6B	; 107
    b08c:	fd 4f       	sbci	r31, 0xFD	; 253
    b08e:	61 e0       	ldi	r22, 0x01	; 1
    b090:	40 81       	ld	r20, Z
    b092:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
    b096:	84 ec       	ldi	r24, 0xC4	; 196
    b098:	99 e0       	ldi	r25, 0x09	; 9
    b09a:	01 97       	sbiw	r24, 0x01	; 1
    b09c:	f1 f7       	brne	.-4      	; 0xb09a <PrintIdle+0x22e>
			  _delay_ms(10);
		      iSend++;
    b09e:	80 91 90 02 	lds	r24, 0x0290
    b0a2:	90 91 91 02 	lds	r25, 0x0291
    b0a6:	01 96       	adiw	r24, 0x01	; 1
    b0a8:	90 93 91 02 	sts	0x0291, r25
    b0ac:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintDuplicate;
    b0b0:	85 e0       	ldi	r24, 0x05	; 5
    b0b2:	c8 c5       	rjmp	.+2960   	; 0xbc44 <PrintIdle+0xdd8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitMessage:
	      iSend=0;iLoop=0;
    b0b4:	10 92 91 02 	sts	0x0291, r1
    b0b8:	10 92 90 02 	sts	0x0290, r1
    b0bc:	10 92 8d 02 	sts	0x028D, r1
    b0c0:	10 92 8c 02 	sts	0x028C, r1
		  iMessage=0;
    b0c4:	10 92 94 02 	sts	0x0294, r1
		  switch(MOPType){
    b0c8:	80 91 cf 01 	lds	r24, 0x01CF
    b0cc:	83 30       	cpi	r24, 0x03	; 3
    b0ce:	81 f0       	breq	.+32     	; 0xb0f0 <PrintIdle+0x284>
    b0d0:	84 30       	cpi	r24, 0x04	; 4
    b0d2:	28 f4       	brcc	.+10     	; 0xb0de <PrintIdle+0x272>
    b0d4:	81 30       	cpi	r24, 0x01	; 1
    b0d6:	61 f0       	breq	.+24     	; 0xb0f0 <PrintIdle+0x284>
    b0d8:	82 30       	cpi	r24, 0x02	; 2
    b0da:	40 f4       	brcc	.+16     	; 0xb0ec <PrintIdle+0x280>
    b0dc:	10 c0       	rjmp	.+32     	; 0xb0fe <PrintIdle+0x292>
    b0de:	88 30       	cpi	r24, 0x08	; 8
    b0e0:	49 f0       	breq	.+18     	; 0xb0f4 <PrintIdle+0x288>
    b0e2:	89 30       	cpi	r24, 0x09	; 9
    b0e4:	61 f0       	breq	.+24     	; 0xb0fe <PrintIdle+0x292>
    b0e6:	87 30       	cpi	r24, 0x07	; 7
    b0e8:	51 f4       	brne	.+20     	; 0xb0fe <PrintIdle+0x292>
    b0ea:	02 c0       	rjmp	.+4      	; 0xb0f0 <PrintIdle+0x284>
		  case MOP_CASH:
		       MessageLine=10;
			   PrintCopy=1;
		       break;
          case MOP_CREDIT_CARD:
		       MessageLine=10;
    b0ec:	8a e0       	ldi	r24, 0x0A	; 10
    b0ee:	03 c0       	rjmp	.+6      	; 0xb0f6 <PrintIdle+0x28a>
          case MOP_LOCAL_ACCOUNT:
		       MessageLine=20;
			   PrintCopy=2;
		       break;
          case MOP_VOUCHER:
		       MessageLine=20;
    b0f0:	84 e1       	ldi	r24, 0x14	; 20
    b0f2:	01 c0       	rjmp	.+2      	; 0xb0f6 <PrintIdle+0x28a>
			   PrintCopy=2;
		       break;
          case MOP_PUMP_TEST:
		       MessageLine=12;
    b0f4:	8c e0       	ldi	r24, 0x0C	; 12
    b0f6:	80 93 93 02 	sts	0x0293, r24
			   PrintCopy=2;
    b0fa:	82 e0       	ldi	r24, 0x02	; 2
    b0fc:	04 c0       	rjmp	.+8      	; 0xb106 <PrintIdle+0x29a>
          case MOP_VOID_CARD:
		       MessageLine=10;
			   PrintCopy=1;
		       break;          
          default:
		       MessageLine=10;
    b0fe:	8a e0       	ldi	r24, 0x0A	; 10
    b100:	80 93 93 02 	sts	0x0293, r24
			   PrintCopy=1;
    b104:	81 e0       	ldi	r24, 0x01	; 1
    b106:	80 93 8a 02 	sts	0x028A, r24
		       break; 
		  }
		  //LoyaltyDetection
          if ((strlen(strLoyCardID)>0)&&(SpaceOnly(strLoyCardID)==False)){
    b10a:	80 91 c7 04 	lds	r24, 0x04C7
    b10e:	88 23       	and	r24, r24
    b110:	49 f0       	breq	.+18     	; 0xb124 <PrintIdle+0x2b8>
    b112:	87 ec       	ldi	r24, 0xC7	; 199
    b114:	94 e0       	ldi	r25, 0x04	; 4
    b116:	0e 94 90 24 	call	0x4920	; 0x4920 <SpaceOnly>
    b11a:	88 23       	and	r24, r24
    b11c:	19 f4       	brne	.+6      	; 0xb124 <PrintIdle+0x2b8>
		       MessageLine=33;
    b11e:	81 e2       	ldi	r24, 0x21	; 33
    b120:	80 93 93 02 	sts	0x0293, r24
		  }
          //stPrintIdle=piLoadMessage;
		  stPrintIdle=piFormatingMessage;
    b124:	88 e0       	ldi	r24, 0x08	; 8
    b126:	9a c5       	rjmp	.+2868   	; 0xbc5c <PrintIdle+0xdf0>
	      break;
     case piFormatingMessage:
	      if (iPrinted==0){
    b128:	80 91 8b 02 	lds	r24, 0x028B
    b12c:	88 23       	and	r24, r24
    b12e:	09 f0       	breq	.+2      	; 0xb132 <PrintIdle+0x2c6>
    b130:	c8 c4       	rjmp	.+2448   	; 0xbac2 <PrintIdle+0xc56>

		      FormatDate(DATE_LONG_YEAR,strDate);
    b132:	61 e5       	ldi	r22, 0x51	; 81
    b134:	79 e0       	ldi	r23, 0x09	; 9
    b136:	0e 94 64 25 	call	0x4ac8	; 0x4ac8 <FormatDate>
              RemZeroLead(strIslandID);
    b13a:	8d e5       	ldi	r24, 0x5D	; 93
    b13c:	9c e0       	ldi	r25, 0x0C	; 12
    b13e:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
			  RemZeroLead(strFIP_ID);
    b142:	86 e8       	ldi	r24, 0x86	; 134
    b144:	99 e0       	ldi	r25, 0x09	; 9
    b146:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
		      RemZeroLead(strPrice);              
    b14a:	81 e8       	ldi	r24, 0x81	; 129
    b14c:	97 e0       	ldi	r25, 0x07	; 7
    b14e:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
              if (IFType==IT_SLAVE)
    b152:	80 91 10 01 	lds	r24, 0x0110
    b156:	81 30       	cpi	r24, 0x01	; 1
    b158:	21 f4       	brne	.+8      	; 0xb162 <PrintIdle+0x2f6>
			      RemZeroLead(strVolume);
    b15a:	85 e5       	ldi	r24, 0x55	; 85
    b15c:	95 e0       	ldi	r25, 0x05	; 5
    b15e:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
              RemZeroLead(strAmount);
    b162:	89 e1       	ldi	r24, 0x19	; 25
    b164:	9f e0       	ldi	r25, 0x0F	; 15
    b166:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>

			  RemDecimal(strPrice);
    b16a:	81 e8       	ldi	r24, 0x81	; 129
    b16c:	97 e0       	ldi	r25, 0x07	; 7
    b16e:	0e 94 ad 24 	call	0x495a	; 0x495a <RemDecimal>
			  RemDecimal(strAmount);
    b172:	89 e1       	ldi	r24, 0x19	; 25
    b174:	9f e0       	ldi	r25, 0x0F	; 15
    b176:	0e 94 ad 24 	call	0x495a	; 0x495a <RemDecimal>
	  
			  FormatCurrency(strPrice);
    b17a:	81 e8       	ldi	r24, 0x81	; 129
    b17c:	97 e0       	ldi	r25, 0x07	; 7
    b17e:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>
			  FormatCurrency(strAmount);
    b182:	89 e1       	ldi	r24, 0x19	; 25
    b184:	9f e0       	ldi	r25, 0x0F	; 15
    b186:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>
              if (IFType==IT_SLAVE){
    b18a:	80 91 10 01 	lds	r24, 0x0110
    b18e:	81 30       	cpi	r24, 0x01	; 1
    b190:	09 f0       	breq	.+2      	; 0xb194 <PrintIdle+0x328>
    b192:	97 c4       	rjmp	.+2350   	; 0xbac2 <PrintIdle+0xc56>
		          RemSpaceLag(strCardID);
    b194:	8f ee       	ldi	r24, 0xEF	; 239
    b196:	9e e0       	ldi	r25, 0x0E	; 14
    b198:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		          RemSpaceLag(strCardHolder);
    b19c:	84 e0       	ldi	r24, 0x04	; 4
    b19e:	95 e0       	ldi	r25, 0x05	; 5
    b1a0:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		          RemSpaceLag(strMOPName);
    b1a4:	80 e6       	ldi	r24, 0x60	; 96
    b1a6:	97 e0       	ldi	r25, 0x07	; 7
    b1a8:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		          RemSpaceLag(strLoyCardHolder);
    b1ac:	84 ea       	ldi	r24, 0xA4	; 164
    b1ae:	94 e0       	ldi	r25, 0x04	; 4
    b1b0:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		          RemSpaceLag(strCorporateID);
    b1b4:	8d e5       	ldi	r24, 0x5D	; 93
    b1b6:	9f e0       	ldi	r25, 0x0F	; 15
    b1b8:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		          RemSpaceLag(strCorporateName);
    b1bc:	8d ea       	ldi	r24, 0xAD	; 173
    b1be:	95 e0       	ldi	r25, 0x05	; 5
    b1c0:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		          RemSpaceLag(strLoyRedeemPoints);
    b1c4:	8a e7       	ldi	r24, 0x7A	; 122
    b1c6:	95 e0       	ldi	r25, 0x05	; 5
    b1c8:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		          RemSpaceLag(strLoyCurrMonConsumeV);
    b1cc:	80 e4       	ldi	r24, 0x40	; 64
    b1ce:	9f e0       	ldi	r25, 0x0F	; 15
    b1d0:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
				  RemSpaceLag(strLoyCurrMonConsumeA);
    b1d4:	8e e5       	ldi	r24, 0x5E	; 94
    b1d6:	95 e0       	ldi	r25, 0x05	; 5
    b1d8:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		          FormatCurrency(strLoyCurrMonConsumeV);              
    b1dc:	80 e4       	ldi	r24, 0x40	; 64
    b1de:	9f e0       	ldi	r25, 0x0F	; 15
    b1e0:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>
		          FormatCurrency(strLoyCurrMonConsumeA);
    b1e4:	8e e5       	ldi	r24, 0x5E	; 94
    b1e6:	95 e0       	ldi	r25, 0x05	; 5
    b1e8:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>
    b1ec:	6a c4       	rjmp	.+2260   	; 0xbac2 <PrintIdle+0xc56>
			   }
		  }
          stPrintIdle=piLoadMessage;
	      break;
     case piLoadMessage:
	      switch(iMessage){
    b1ee:	80 91 94 02 	lds	r24, 0x0294
    b1f2:	e8 2f       	mov	r30, r24
    b1f4:	f0 e0       	ldi	r31, 0x00	; 0
    b1f6:	e5 32       	cpi	r30, 0x25	; 37
    b1f8:	f1 05       	cpc	r31, r1
    b1fa:	08 f0       	brcs	.+2      	; 0xb1fe <PrintIdle+0x392>
    b1fc:	26 c4       	rjmp	.+2124   	; 0xba4a <PrintIdle+0xbde>
    b1fe:	e2 57       	subi	r30, 0x72	; 114
    b200:	ff 4f       	sbci	r31, 0xFF	; 255
    b202:	ee 0f       	add	r30, r30
    b204:	ff 1f       	adc	r31, r31
    b206:	05 90       	lpm	r0, Z+
    b208:	f4 91       	lpm	r31, Z+
    b20a:	e0 2d       	mov	r30, r0
    b20c:	09 94       	ijmp
		  case 0:
		       CarriegeReturn();
    b20e:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Shift: %s  No.Trans: %s "),strShift,strTranNo);
    b212:	8d b7       	in	r24, 0x3d	; 61
    b214:	9e b7       	in	r25, 0x3e	; 62
    b216:	08 97       	sbiw	r24, 0x08	; 8
    b218:	0f b6       	in	r0, 0x3f	; 63
    b21a:	f8 94       	cli
    b21c:	9e bf       	out	0x3e, r25	; 62
    b21e:	0f be       	out	0x3f, r0	; 63
    b220:	8d bf       	out	0x3d, r24	; 61
    b222:	ed b7       	in	r30, 0x3d	; 61
    b224:	fe b7       	in	r31, 0x3e	; 62
    b226:	31 96       	adiw	r30, 0x01	; 1
    b228:	85 e9       	ldi	r24, 0x95	; 149
    b22a:	92 e0       	ldi	r25, 0x02	; 2
    b22c:	ad b7       	in	r26, 0x3d	; 61
    b22e:	be b7       	in	r27, 0x3e	; 62
    b230:	12 96       	adiw	r26, 0x02	; 2
    b232:	9c 93       	st	X, r25
    b234:	8e 93       	st	-X, r24
    b236:	11 97       	sbiw	r26, 0x01	; 1
    b238:	89 ee       	ldi	r24, 0xE9	; 233
    b23a:	99 e0       	ldi	r25, 0x09	; 9
    b23c:	93 83       	std	Z+3, r25	; 0x03
    b23e:	82 83       	std	Z+2, r24	; 0x02
    b240:	8b eb       	ldi	r24, 0xBB	; 187
    b242:	9f e0       	ldi	r25, 0x0F	; 15
    b244:	95 83       	std	Z+5, r25	; 0x05
    b246:	84 83       	std	Z+4, r24	; 0x04
    b248:	89 ed       	ldi	r24, 0xD9	; 217
    b24a:	9f e0       	ldi	r25, 0x0F	; 15
    b24c:	1f c0       	rjmp	.+62     	; 0xb28c <PrintIdle+0x420>
		       break;
		  case 1:
		       //FormatDate(strDate);
			   CarriegeReturn();
    b24e:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Waktu: %s %s "),strDate,strTime);
    b252:	8d b7       	in	r24, 0x3d	; 61
    b254:	9e b7       	in	r25, 0x3e	; 62
    b256:	08 97       	sbiw	r24, 0x08	; 8
    b258:	0f b6       	in	r0, 0x3f	; 63
    b25a:	f8 94       	cli
    b25c:	9e bf       	out	0x3e, r25	; 62
    b25e:	0f be       	out	0x3f, r0	; 63
    b260:	8d bf       	out	0x3d, r24	; 61
    b262:	ed b7       	in	r30, 0x3d	; 61
    b264:	fe b7       	in	r31, 0x3e	; 62
    b266:	31 96       	adiw	r30, 0x01	; 1
    b268:	85 e9       	ldi	r24, 0x95	; 149
    b26a:	92 e0       	ldi	r25, 0x02	; 2
    b26c:	ad b7       	in	r26, 0x3d	; 61
    b26e:	be b7       	in	r27, 0x3e	; 62
    b270:	12 96       	adiw	r26, 0x02	; 2
    b272:	9c 93       	st	X, r25
    b274:	8e 93       	st	-X, r24
    b276:	11 97       	sbiw	r26, 0x01	; 1
    b278:	85 ed       	ldi	r24, 0xD5	; 213
    b27a:	99 e0       	ldi	r25, 0x09	; 9
    b27c:	93 83       	std	Z+3, r25	; 0x03
    b27e:	82 83       	std	Z+2, r24	; 0x02
    b280:	81 e5       	ldi	r24, 0x51	; 81
    b282:	99 e0       	ldi	r25, 0x09	; 9
    b284:	95 83       	std	Z+5, r25	; 0x05
    b286:	84 83       	std	Z+4, r24	; 0x04
    b288:	8d e2       	ldi	r24, 0x2D	; 45
    b28a:	95 e0       	ldi	r25, 0x05	; 5
    b28c:	97 83       	std	Z+7, r25	; 0x07
    b28e:	86 83       	std	Z+6, r24	; 0x06
    b290:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    b294:	ed b7       	in	r30, 0x3d	; 61
    b296:	fe b7       	in	r31, 0x3e	; 62
    b298:	38 96       	adiw	r30, 0x08	; 8
    b29a:	b9 c3       	rjmp	.+1906   	; 0xba0e <PrintIdle+0xba2>
		       break;
		  case 2:
		       CarriegeReturn();
    b29c:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b2a0:	00 d0       	rcall	.+0      	; 0xb2a2 <PrintIdle+0x436>
    b2a2:	00 d0       	rcall	.+0      	; 0xb2a4 <PrintIdle+0x438>
    b2a4:	85 e9       	ldi	r24, 0x95	; 149
    b2a6:	92 e0       	ldi	r25, 0x02	; 2
    b2a8:	ad b7       	in	r26, 0x3d	; 61
    b2aa:	be b7       	in	r27, 0x3e	; 62
    b2ac:	12 96       	adiw	r26, 0x02	; 2
    b2ae:	9c 93       	st	X, r25
    b2b0:	8e 93       	st	-X, r24
    b2b2:	11 97       	sbiw	r26, 0x01	; 1
    b2b4:	82 eb       	ldi	r24, 0xB2	; 178
    b2b6:	99 e0       	ldi	r25, 0x09	; 9
    b2b8:	be c3       	rjmp	.+1916   	; 0xba36 <PrintIdle+0xbca>
		       break;
		  case 3:
		       CarriegeReturn();
    b2ba:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			   //RemZeroLead(strIslandID);
			   //RemZeroLead(strFIP_ID);
		       sprintf_P(strPrint,PSTR("      Pulau/Pompa : [%s]-%s"),strIslandID,strFIP_ID);
    b2be:	ed b7       	in	r30, 0x3d	; 61
    b2c0:	fe b7       	in	r31, 0x3e	; 62
    b2c2:	38 97       	sbiw	r30, 0x08	; 8
    b2c4:	0f b6       	in	r0, 0x3f	; 63
    b2c6:	f8 94       	cli
    b2c8:	fe bf       	out	0x3e, r31	; 62
    b2ca:	0f be       	out	0x3f, r0	; 63
    b2cc:	ed bf       	out	0x3d, r30	; 61
    b2ce:	31 96       	adiw	r30, 0x01	; 1
    b2d0:	85 e9       	ldi	r24, 0x95	; 149
    b2d2:	92 e0       	ldi	r25, 0x02	; 2
    b2d4:	ad b7       	in	r26, 0x3d	; 61
    b2d6:	be b7       	in	r27, 0x3e	; 62
    b2d8:	12 96       	adiw	r26, 0x02	; 2
    b2da:	9c 93       	st	X, r25
    b2dc:	8e 93       	st	-X, r24
    b2de:	11 97       	sbiw	r26, 0x01	; 1
    b2e0:	86 e9       	ldi	r24, 0x96	; 150
    b2e2:	99 e0       	ldi	r25, 0x09	; 9
    b2e4:	93 83       	std	Z+3, r25	; 0x03
    b2e6:	82 83       	std	Z+2, r24	; 0x02
    b2e8:	8d e5       	ldi	r24, 0x5D	; 93
    b2ea:	9c e0       	ldi	r25, 0x0C	; 12
    b2ec:	95 83       	std	Z+5, r25	; 0x05
    b2ee:	84 83       	std	Z+4, r24	; 0x04
    b2f0:	86 e8       	ldi	r24, 0x86	; 134
    b2f2:	99 e0       	ldi	r25, 0x09	; 9
    b2f4:	cb cf       	rjmp	.-106    	; 0xb28c <PrintIdle+0x420>
		       break;
		  case 4:
		       CarriegeReturn();
    b2f6:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Produk      : %s"),strDescription);
    b2fa:	00 d0       	rcall	.+0      	; 0xb2fc <PrintIdle+0x490>
    b2fc:	00 d0       	rcall	.+0      	; 0xb2fe <PrintIdle+0x492>
    b2fe:	00 d0       	rcall	.+0      	; 0xb300 <PrintIdle+0x494>
    b300:	ed b7       	in	r30, 0x3d	; 61
    b302:	fe b7       	in	r31, 0x3e	; 62
    b304:	31 96       	adiw	r30, 0x01	; 1
    b306:	85 e9       	ldi	r24, 0x95	; 149
    b308:	92 e0       	ldi	r25, 0x02	; 2
    b30a:	ad b7       	in	r26, 0x3d	; 61
    b30c:	be b7       	in	r27, 0x3e	; 62
    b30e:	12 96       	adiw	r26, 0x02	; 2
    b310:	9c 93       	st	X, r25
    b312:	8e 93       	st	-X, r24
    b314:	11 97       	sbiw	r26, 0x01	; 1
    b316:	8f e7       	ldi	r24, 0x7F	; 127
    b318:	99 e0       	ldi	r25, 0x09	; 9
    b31a:	93 83       	std	Z+3, r25	; 0x03
    b31c:	82 83       	std	Z+2, r24	; 0x02
    b31e:	8b ec       	ldi	r24, 0xCB	; 203
    b320:	9b e0       	ldi	r25, 0x0B	; 11
    b322:	6e c3       	rjmp	.+1756   	; 0xba00 <PrintIdle+0xb94>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b324:	e1 99       	sbic	0x1c, 1	; 28
    b326:	fe cf       	rjmp	.-4      	; 0xb324 <PrintIdle+0x4b8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b328:	81 ec       	ldi	r24, 0xC1	; 193
    b32a:	93 e0       	ldi	r25, 0x03	; 3
    b32c:	9f bb       	out	0x1f, r25	; 31
    b32e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b330:	e0 9a       	sbi	0x1c, 0	; 28
    b332:	8d b3       	in	r24, 0x1d	; 29
    b334:	c5 e9       	ldi	r28, 0x95	; 149
    b336:	d2 e0       	ldi	r29, 0x02	; 2
		       break;
		  case 5:
		       //RemZeroLead(strPrice);
               //FormatCurrency(strPrice);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    b338:	81 30       	cpi	r24, 0x01	; 1
    b33a:	a9 f4       	brne	.+42     	; 0xb366 <PrintIdle+0x4fa>
			   	   CarriegeReturn();
    b33c:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Harga/L     : Rp.%s"),strPrice);
    b340:	00 d0       	rcall	.+0      	; 0xb342 <PrintIdle+0x4d6>
    b342:	00 d0       	rcall	.+0      	; 0xb344 <PrintIdle+0x4d8>
    b344:	00 d0       	rcall	.+0      	; 0xb346 <PrintIdle+0x4da>
    b346:	ed b7       	in	r30, 0x3d	; 61
    b348:	fe b7       	in	r31, 0x3e	; 62
    b34a:	31 96       	adiw	r30, 0x01	; 1
    b34c:	ad b7       	in	r26, 0x3d	; 61
    b34e:	be b7       	in	r27, 0x3e	; 62
    b350:	12 96       	adiw	r26, 0x02	; 2
    b352:	dc 93       	st	X, r29
    b354:	ce 93       	st	-X, r28
    b356:	11 97       	sbiw	r26, 0x01	; 1
    b358:	85 e6       	ldi	r24, 0x65	; 101
    b35a:	99 e0       	ldi	r25, 0x09	; 9
    b35c:	93 83       	std	Z+3, r25	; 0x03
    b35e:	82 83       	std	Z+2, r24	; 0x02
    b360:	81 e8       	ldi	r24, 0x81	; 129
    b362:	97 e0       	ldi	r25, 0x07	; 7
    b364:	4d c3       	rjmp	.+1690   	; 0xba00 <PrintIdle+0xb94>
			   }else sprintf_P(strPrint,PSTR(""));
    b366:	00 d0       	rcall	.+0      	; 0xb368 <PrintIdle+0x4fc>
    b368:	00 d0       	rcall	.+0      	; 0xb36a <PrintIdle+0x4fe>
    b36a:	ad b7       	in	r26, 0x3d	; 61
    b36c:	be b7       	in	r27, 0x3e	; 62
    b36e:	12 96       	adiw	r26, 0x02	; 2
    b370:	dc 93       	st	X, r29
    b372:	ce 93       	st	-X, r28
    b374:	11 97       	sbiw	r26, 0x01	; 1
    b376:	84 e6       	ldi	r24, 0x64	; 100
    b378:	99 e0       	ldi	r25, 0x09	; 9
    b37a:	5d c3       	rjmp	.+1722   	; 0xba36 <PrintIdle+0xbca>

		       break;
		  case 6:
		       //RemZeroLead(strVolume);
		       CarriegeReturn();
    b37c:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Jml Liter   : %s L"),strVolume);
    b380:	00 d0       	rcall	.+0      	; 0xb382 <PrintIdle+0x516>
    b382:	00 d0       	rcall	.+0      	; 0xb384 <PrintIdle+0x518>
    b384:	00 d0       	rcall	.+0      	; 0xb386 <PrintIdle+0x51a>
    b386:	ed b7       	in	r30, 0x3d	; 61
    b388:	fe b7       	in	r31, 0x3e	; 62
    b38a:	31 96       	adiw	r30, 0x01	; 1
    b38c:	85 e9       	ldi	r24, 0x95	; 149
    b38e:	92 e0       	ldi	r25, 0x02	; 2
    b390:	ad b7       	in	r26, 0x3d	; 61
    b392:	be b7       	in	r27, 0x3e	; 62
    b394:	12 96       	adiw	r26, 0x02	; 2
    b396:	9c 93       	st	X, r25
    b398:	8e 93       	st	-X, r24
    b39a:	11 97       	sbiw	r26, 0x01	; 1
    b39c:	8b e4       	ldi	r24, 0x4B	; 75
    b39e:	99 e0       	ldi	r25, 0x09	; 9
    b3a0:	93 83       	std	Z+3, r25	; 0x03
    b3a2:	82 83       	std	Z+2, r24	; 0x02
    b3a4:	85 e5       	ldi	r24, 0x55	; 85
    b3a6:	95 e0       	ldi	r25, 0x05	; 5
    b3a8:	2b c3       	rjmp	.+1622   	; 0xba00 <PrintIdle+0xb94>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b3aa:	e1 99       	sbic	0x1c, 1	; 28
    b3ac:	fe cf       	rjmp	.-4      	; 0xb3aa <PrintIdle+0x53e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b3ae:	81 ec       	ldi	r24, 0xC1	; 193
    b3b0:	93 e0       	ldi	r25, 0x03	; 3
    b3b2:	9f bb       	out	0x1f, r25	; 31
    b3b4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b3b6:	e0 9a       	sbi	0x1c, 0	; 28
    b3b8:	8d b3       	in	r24, 0x1d	; 29
    b3ba:	c5 e9       	ldi	r28, 0x95	; 149
    b3bc:	d2 e0       	ldi	r29, 0x02	; 2
		       break;
		  case 7:
		       //RemZeroLead(strAmount);		       
			   //FormatCurrency(strAmount);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    b3be:	81 30       	cpi	r24, 0x01	; 1
    b3c0:	a9 f4       	brne	.+42     	; 0xb3ec <PrintIdle+0x580>
			   	   CarriegeReturn();
    b3c2:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Jml Rupiah  : Rp.%s"),strAmount);
    b3c6:	00 d0       	rcall	.+0      	; 0xb3c8 <PrintIdle+0x55c>
    b3c8:	00 d0       	rcall	.+0      	; 0xb3ca <PrintIdle+0x55e>
    b3ca:	00 d0       	rcall	.+0      	; 0xb3cc <PrintIdle+0x560>
    b3cc:	ed b7       	in	r30, 0x3d	; 61
    b3ce:	fe b7       	in	r31, 0x3e	; 62
    b3d0:	31 96       	adiw	r30, 0x01	; 1
    b3d2:	ad b7       	in	r26, 0x3d	; 61
    b3d4:	be b7       	in	r27, 0x3e	; 62
    b3d6:	12 96       	adiw	r26, 0x02	; 2
    b3d8:	dc 93       	st	X, r29
    b3da:	ce 93       	st	-X, r28
    b3dc:	11 97       	sbiw	r26, 0x01	; 1
    b3de:	81 e3       	ldi	r24, 0x31	; 49
    b3e0:	99 e0       	ldi	r25, 0x09	; 9
    b3e2:	93 83       	std	Z+3, r25	; 0x03
    b3e4:	82 83       	std	Z+2, r24	; 0x02
    b3e6:	89 e1       	ldi	r24, 0x19	; 25
    b3e8:	9f e0       	ldi	r25, 0x0F	; 15
    b3ea:	0a c3       	rjmp	.+1556   	; 0xba00 <PrintIdle+0xb94>
			   }else sprintf_P(strPrint,PSTR(""));
    b3ec:	00 d0       	rcall	.+0      	; 0xb3ee <PrintIdle+0x582>
    b3ee:	00 d0       	rcall	.+0      	; 0xb3f0 <PrintIdle+0x584>
    b3f0:	ad b7       	in	r26, 0x3d	; 61
    b3f2:	be b7       	in	r27, 0x3e	; 62
    b3f4:	12 96       	adiw	r26, 0x02	; 2
    b3f6:	dc 93       	st	X, r29
    b3f8:	ce 93       	st	-X, r28
    b3fa:	11 97       	sbiw	r26, 0x01	; 1
    b3fc:	80 e3       	ldi	r24, 0x30	; 48
    b3fe:	99 e0       	ldi	r25, 0x09	; 9
    b400:	1a c3       	rjmp	.+1588   	; 0xba36 <PrintIdle+0xbca>

		       break;
		  case 8:
		       if ((strlen(strLicPlate)>0)&&(SpaceOnly(strLicPlate)==False)){
    b402:	c0 e6       	ldi	r28, 0x60	; 96
    b404:	dc e0       	ldi	r29, 0x0C	; 12
    b406:	80 91 60 0c 	lds	r24, 0x0C60
    b40a:	88 23       	and	r24, r24
    b40c:	09 f4       	brne	.+2      	; 0xb410 <PrintIdle+0x5a4>
    b40e:	18 c2       	rjmp	.+1072   	; 0xb840 <PrintIdle+0x9d4>
    b410:	ce 01       	movw	r24, r28
    b412:	0e 94 90 24 	call	0x4920	; 0x4920 <SpaceOnly>
    b416:	88 23       	and	r24, r24
    b418:	09 f0       	breq	.+2      	; 0xb41c <PrintIdle+0x5b0>
    b41a:	12 c2       	rjmp	.+1060   	; 0xb840 <PrintIdle+0x9d4>
			       CarriegeReturn();
    b41c:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      No.Polisi   : %s"),strLicPlate);
    b420:	00 d0       	rcall	.+0      	; 0xb422 <PrintIdle+0x5b6>
    b422:	00 d0       	rcall	.+0      	; 0xb424 <PrintIdle+0x5b8>
    b424:	00 d0       	rcall	.+0      	; 0xb426 <PrintIdle+0x5ba>
    b426:	ed b7       	in	r30, 0x3d	; 61
    b428:	fe b7       	in	r31, 0x3e	; 62
    b42a:	31 96       	adiw	r30, 0x01	; 1
    b42c:	85 e9       	ldi	r24, 0x95	; 149
    b42e:	92 e0       	ldi	r25, 0x02	; 2
    b430:	ad b7       	in	r26, 0x3d	; 61
    b432:	be b7       	in	r27, 0x3e	; 62
    b434:	12 96       	adiw	r26, 0x02	; 2
    b436:	9c 93       	st	X, r25
    b438:	8e 93       	st	-X, r24
    b43a:	11 97       	sbiw	r26, 0x01	; 1
    b43c:	89 e1       	ldi	r24, 0x19	; 25
    b43e:	99 e0       	ldi	r25, 0x09	; 9
    b440:	1f c0       	rjmp	.+62     	; 0xb480 <PrintIdle+0x614>
                   ClearMem(strLicPlate);
				   }
               else ClearMem(strPrint);
		       break;
		  case 9:
		       if ((strlen(strOdometer)>0)&&(SpaceOnly(strOdometer)==False)){
    b442:	c3 ea       	ldi	r28, 0xA3	; 163
    b444:	d5 e0       	ldi	r29, 0x05	; 5
    b446:	80 91 a3 05 	lds	r24, 0x05A3
    b44a:	88 23       	and	r24, r24
    b44c:	09 f4       	brne	.+2      	; 0xb450 <PrintIdle+0x5e4>
    b44e:	f8 c1       	rjmp	.+1008   	; 0xb840 <PrintIdle+0x9d4>
    b450:	ce 01       	movw	r24, r28
    b452:	0e 94 90 24 	call	0x4920	; 0x4920 <SpaceOnly>
    b456:	88 23       	and	r24, r24
    b458:	09 f0       	breq	.+2      	; 0xb45c <PrintIdle+0x5f0>
    b45a:	f2 c1       	rjmp	.+996    	; 0xb840 <PrintIdle+0x9d4>
			       CarriegeReturn();
    b45c:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("      Odometer    : %s"),strOdometer);
    b460:	00 d0       	rcall	.+0      	; 0xb462 <PrintIdle+0x5f6>
    b462:	00 d0       	rcall	.+0      	; 0xb464 <PrintIdle+0x5f8>
    b464:	00 d0       	rcall	.+0      	; 0xb466 <PrintIdle+0x5fa>
    b466:	ed b7       	in	r30, 0x3d	; 61
    b468:	fe b7       	in	r31, 0x3e	; 62
    b46a:	31 96       	adiw	r30, 0x01	; 1
    b46c:	85 e9       	ldi	r24, 0x95	; 149
    b46e:	92 e0       	ldi	r25, 0x02	; 2
    b470:	ad b7       	in	r26, 0x3d	; 61
    b472:	be b7       	in	r27, 0x3e	; 62
    b474:	12 96       	adiw	r26, 0x02	; 2
    b476:	9c 93       	st	X, r25
    b478:	8e 93       	st	-X, r24
    b47a:	11 97       	sbiw	r26, 0x01	; 1
    b47c:	82 e0       	ldi	r24, 0x02	; 2
    b47e:	99 e0       	ldi	r25, 0x09	; 9
    b480:	93 83       	std	Z+3, r25	; 0x03
    b482:	82 83       	std	Z+2, r24	; 0x02
    b484:	d5 83       	std	Z+5, r29	; 0x05
    b486:	c4 83       	std	Z+4, r28	; 0x04
    b488:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
				   ClearMem(strOdometer);
    b48c:	ed b7       	in	r30, 0x3d	; 61
    b48e:	fe b7       	in	r31, 0x3e	; 62
    b490:	36 96       	adiw	r30, 0x06	; 6
    b492:	0f b6       	in	r0, 0x3f	; 63
    b494:	f8 94       	cli
    b496:	fe bf       	out	0x3e, r31	; 62
    b498:	0f be       	out	0x3f, r0	; 63
    b49a:	ed bf       	out	0x3d, r30	; 61
    b49c:	ce 01       	movw	r24, r28
    b49e:	0e 94 f9 ae 	call	0x15df2	; 0x15df2 <ClearMem>
    b4a2:	d3 c2       	rjmp	.+1446   	; 0xba4a <PrintIdle+0xbde>
			   }else ClearMem(strPrint);
		       break;
		  case 10:
		       CarriegeReturn();
    b4a4:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b4a8:	00 d0       	rcall	.+0      	; 0xb4aa <PrintIdle+0x63e>
    b4aa:	00 d0       	rcall	.+0      	; 0xb4ac <PrintIdle+0x640>
    b4ac:	85 e9       	ldi	r24, 0x95	; 149
    b4ae:	92 e0       	ldi	r25, 0x02	; 2
    b4b0:	ad b7       	in	r26, 0x3d	; 61
    b4b2:	be b7       	in	r27, 0x3e	; 62
    b4b4:	12 96       	adiw	r26, 0x02	; 2
    b4b6:	9c 93       	st	X, r25
    b4b8:	8e 93       	st	-X, r24
    b4ba:	11 97       	sbiw	r26, 0x01	; 1
    b4bc:	8f ed       	ldi	r24, 0xDF	; 223
    b4be:	98 e0       	ldi	r25, 0x08	; 8
    b4c0:	ba c2       	rjmp	.+1396   	; 0xba36 <PrintIdle+0xbca>
		       break;
          //ChangeMOPPrint
		  case 11:
			   if ((MOPType==MOP_LOCAL_ACCOUNT)||(MOPType==MOP_DEBIT_CARD)||(MOPType==MOP_LOYALTY_LOCAL_ACCOUNT)){
    b4c2:	80 91 cf 01 	lds	r24, 0x01CF
    b4c6:	81 30       	cpi	r24, 0x01	; 1
    b4c8:	21 f0       	breq	.+8      	; 0xb4d2 <PrintIdle+0x666>
    b4ca:	83 30       	cpi	r24, 0x03	; 3
    b4cc:	11 f0       	breq	.+4      	; 0xb4d2 <PrintIdle+0x666>
    b4ce:	86 30       	cpi	r24, 0x06	; 6
    b4d0:	b9 f4       	brne	.+46     	; 0xb500 <PrintIdle+0x694>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    b4d2:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Kartu ID : %s"),strCardID);
    b4d6:	00 d0       	rcall	.+0      	; 0xb4d8 <PrintIdle+0x66c>
    b4d8:	00 d0       	rcall	.+0      	; 0xb4da <PrintIdle+0x66e>
    b4da:	00 d0       	rcall	.+0      	; 0xb4dc <PrintIdle+0x670>
    b4dc:	ed b7       	in	r30, 0x3d	; 61
    b4de:	fe b7       	in	r31, 0x3e	; 62
    b4e0:	31 96       	adiw	r30, 0x01	; 1
    b4e2:	85 e9       	ldi	r24, 0x95	; 149
    b4e4:	92 e0       	ldi	r25, 0x02	; 2
    b4e6:	ad b7       	in	r26, 0x3d	; 61
    b4e8:	be b7       	in	r27, 0x3e	; 62
    b4ea:	12 96       	adiw	r26, 0x02	; 2
    b4ec:	9c 93       	st	X, r25
    b4ee:	8e 93       	st	-X, r24
    b4f0:	11 97       	sbiw	r26, 0x01	; 1
    b4f2:	8d ec       	ldi	r24, 0xCD	; 205
    b4f4:	98 e0       	ldi	r25, 0x08	; 8
    b4f6:	93 83       	std	Z+3, r25	; 0x03
    b4f8:	82 83       	std	Z+2, r24	; 0x02
    b4fa:	8f ee       	ldi	r24, 0xEF	; 239
    b4fc:	9e e0       	ldi	r25, 0x0E	; 14
    b4fe:	18 c0       	rjmp	.+48     	; 0xb530 <PrintIdle+0x6c4>
				   IsSignedField=True;
				   }
	           else
			   if (MOPType==MOP_VOUCHER){
    b500:	87 30       	cpi	r24, 0x07	; 7
    b502:	f1 f4       	brne	.+60     	; 0xb540 <PrintIdle+0x6d4>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    b504:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Voucher No: %s"),strVoucherNum);
    b508:	00 d0       	rcall	.+0      	; 0xb50a <PrintIdle+0x69e>
    b50a:	00 d0       	rcall	.+0      	; 0xb50c <PrintIdle+0x6a0>
    b50c:	00 d0       	rcall	.+0      	; 0xb50e <PrintIdle+0x6a2>
    b50e:	ed b7       	in	r30, 0x3d	; 61
    b510:	fe b7       	in	r31, 0x3e	; 62
    b512:	31 96       	adiw	r30, 0x01	; 1
    b514:	85 e9       	ldi	r24, 0x95	; 149
    b516:	92 e0       	ldi	r25, 0x02	; 2
    b518:	ad b7       	in	r26, 0x3d	; 61
    b51a:	be b7       	in	r27, 0x3e	; 62
    b51c:	12 96       	adiw	r26, 0x02	; 2
    b51e:	9c 93       	st	X, r25
    b520:	8e 93       	st	-X, r24
    b522:	11 97       	sbiw	r26, 0x01	; 1
    b524:	8a eb       	ldi	r24, 0xBA	; 186
    b526:	98 e0       	ldi	r25, 0x08	; 8
    b528:	93 83       	std	Z+3, r25	; 0x03
    b52a:	82 83       	std	Z+2, r24	; 0x02
    b52c:	8f e8       	ldi	r24, 0x8F	; 143
    b52e:	9f e0       	ldi	r25, 0x0F	; 15
    b530:	95 83       	std	Z+5, r25	; 0x05
    b532:	84 83       	std	Z+4, r24	; 0x04
    b534:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
				   IsSignedField=True;
    b538:	81 e0       	ldi	r24, 0x01	; 1
    b53a:	80 93 92 02 	sts	0x0292, r24
    b53e:	64 c2       	rjmp	.+1224   	; 0xba08 <PrintIdle+0xb9c>
    b540:	c5 e9       	ldi	r28, 0x95	; 149
    b542:	d2 e0       	ldi	r29, 0x02	; 2
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b544:	88 30       	cpi	r24, 0x08	; 8
    b546:	09 f0       	breq	.+2      	; 0xb54a <PrintIdle+0x6de>
    b548:	a9 cf       	rjmp	.-174    	; 0xb49c <PrintIdle+0x630>
			       CarriegeReturn();
    b54a:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("          *** PUMP TEST ***       "));
    b54e:	00 d0       	rcall	.+0      	; 0xb550 <PrintIdle+0x6e4>
    b550:	00 d0       	rcall	.+0      	; 0xb552 <PrintIdle+0x6e6>
    b552:	ad b7       	in	r26, 0x3d	; 61
    b554:	be b7       	in	r27, 0x3e	; 62
    b556:	12 96       	adiw	r26, 0x02	; 2
    b558:	dc 93       	st	X, r29
    b55a:	ce 93       	st	-X, r28
    b55c:	11 97       	sbiw	r26, 0x01	; 1
    b55e:	87 e9       	ldi	r24, 0x97	; 151
    b560:	98 e0       	ldi	r25, 0x08	; 8
    b562:	14 96       	adiw	r26, 0x04	; 4
    b564:	9c 93       	st	X, r25
    b566:	8e 93       	st	-X, r24
    b568:	13 97       	sbiw	r26, 0x03	; 3
    b56a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
				   IsSignedField=False;
    b56e:	10 92 92 02 	sts	0x0292, r1
    b572:	67 c2       	rjmp	.+1230   	; 0xba42 <PrintIdle+0xbd6>
				   }
               else ClearMem(strPrint);
		       break;
          case 12:
			   if (MOPType==MOP_LOCAL_ACCOUNT) {
    b574:	80 91 cf 01 	lds	r24, 0x01CF
    b578:	81 30       	cpi	r24, 0x01	; 1
    b57a:	99 f4       	brne	.+38     	; 0xb5a2 <PrintIdle+0x736>
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    b57c:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Nama     : %s"),strCardHolder);
    b580:	00 d0       	rcall	.+0      	; 0xb582 <PrintIdle+0x716>
    b582:	00 d0       	rcall	.+0      	; 0xb584 <PrintIdle+0x718>
    b584:	00 d0       	rcall	.+0      	; 0xb586 <PrintIdle+0x71a>
    b586:	ed b7       	in	r30, 0x3d	; 61
    b588:	fe b7       	in	r31, 0x3e	; 62
    b58a:	31 96       	adiw	r30, 0x01	; 1
    b58c:	85 e9       	ldi	r24, 0x95	; 149
    b58e:	92 e0       	ldi	r25, 0x02	; 2
    b590:	ad b7       	in	r26, 0x3d	; 61
    b592:	be b7       	in	r27, 0x3e	; 62
    b594:	12 96       	adiw	r26, 0x02	; 2
    b596:	9c 93       	st	X, r25
    b598:	8e 93       	st	-X, r24
    b59a:	11 97       	sbiw	r26, 0x01	; 1
    b59c:	85 e8       	ldi	r24, 0x85	; 133
    b59e:	98 e0       	ldi	r25, 0x08	; 8
    b5a0:	3a c0       	rjmp	.+116    	; 0xb616 <PrintIdle+0x7aa>
				   }
               else 
               if (MOPType==MOP_DEBIT_CARD) {//EDCApprovalCode
    b5a2:	83 30       	cpi	r24, 0x03	; 3
    b5a4:	e9 f5       	brne	.+122    	; 0xb620 <PrintIdle+0x7b4>
			       if (IsPrintApprovalCode==True){
    b5a6:	80 91 b1 01 	lds	r24, 0x01B1
    b5aa:	81 30       	cpi	r24, 0x01	; 1
    b5ac:	11 f5       	brne	.+68     	; 0xb5f2 <PrintIdle+0x786>
				       IsPrintApprovalCode=False;
    b5ae:	10 92 b1 01 	sts	0x01B1, r1
					   FillChar(strCardHolder,0,sizeof(strCardHolder));
					   sprintf_P(strCardHolder,PSTR("%s  "),strApprovalCode);
    b5b2:	00 d0       	rcall	.+0      	; 0xb5b4 <PrintIdle+0x748>
    b5b4:	00 d0       	rcall	.+0      	; 0xb5b6 <PrintIdle+0x74a>
    b5b6:	00 d0       	rcall	.+0      	; 0xb5b8 <PrintIdle+0x74c>
    b5b8:	ed b7       	in	r30, 0x3d	; 61
    b5ba:	fe b7       	in	r31, 0x3e	; 62
    b5bc:	31 96       	adiw	r30, 0x01	; 1
    b5be:	84 e0       	ldi	r24, 0x04	; 4
    b5c0:	95 e0       	ldi	r25, 0x05	; 5
    b5c2:	ad b7       	in	r26, 0x3d	; 61
    b5c4:	be b7       	in	r27, 0x3e	; 62
    b5c6:	12 96       	adiw	r26, 0x02	; 2
    b5c8:	9c 93       	st	X, r25
    b5ca:	8e 93       	st	-X, r24
    b5cc:	11 97       	sbiw	r26, 0x01	; 1
    b5ce:	80 e8       	ldi	r24, 0x80	; 128
    b5d0:	98 e0       	ldi	r25, 0x08	; 8
    b5d2:	93 83       	std	Z+3, r25	; 0x03
    b5d4:	82 83       	std	Z+2, r24	; 0x02
    b5d6:	8e ec       	ldi	r24, 0xCE	; 206
    b5d8:	99 e0       	ldi	r25, 0x09	; 9
    b5da:	95 83       	std	Z+5, r25	; 0x05
    b5dc:	84 83       	std	Z+4, r24	; 0x04
    b5de:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    b5e2:	ed b7       	in	r30, 0x3d	; 61
    b5e4:	fe b7       	in	r31, 0x3e	; 62
    b5e6:	36 96       	adiw	r30, 0x06	; 6
    b5e8:	0f b6       	in	r0, 0x3f	; 63
    b5ea:	f8 94       	cli
    b5ec:	fe bf       	out	0x3e, r31	; 62
    b5ee:	0f be       	out	0x3f, r0	; 63
    b5f0:	ed bf       	out	0x3d, r30	; 61
				   }
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    b5f2:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Appr Code: %s"),strCardHolder);
    b5f6:	00 d0       	rcall	.+0      	; 0xb5f8 <PrintIdle+0x78c>
    b5f8:	00 d0       	rcall	.+0      	; 0xb5fa <PrintIdle+0x78e>
    b5fa:	00 d0       	rcall	.+0      	; 0xb5fc <PrintIdle+0x790>
    b5fc:	ed b7       	in	r30, 0x3d	; 61
    b5fe:	fe b7       	in	r31, 0x3e	; 62
    b600:	31 96       	adiw	r30, 0x01	; 1
    b602:	85 e9       	ldi	r24, 0x95	; 149
    b604:	92 e0       	ldi	r25, 0x02	; 2
    b606:	ad b7       	in	r26, 0x3d	; 61
    b608:	be b7       	in	r27, 0x3e	; 62
    b60a:	12 96       	adiw	r26, 0x02	; 2
    b60c:	9c 93       	st	X, r25
    b60e:	8e 93       	st	-X, r24
    b610:	11 97       	sbiw	r26, 0x01	; 1
    b612:	8e e6       	ldi	r24, 0x6E	; 110
    b614:	98 e0       	ldi	r25, 0x08	; 8
    b616:	93 83       	std	Z+3, r25	; 0x03
    b618:	82 83       	std	Z+2, r24	; 0x02
    b61a:	84 e0       	ldi	r24, 0x04	; 4
    b61c:	95 e0       	ldi	r25, 0x05	; 5
    b61e:	f0 c1       	rjmp	.+992    	; 0xba00 <PrintIdle+0xb94>
				   }
               else
			   if (MOPType==MOP_VOUCHER){
    b620:	87 30       	cpi	r24, 0x07	; 7
    b622:	79 f4       	brne	.+30     	; 0xb642 <PrintIdle+0x7d6>
			       CarriegeReturn();
    b624:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("  "));
    b628:	00 d0       	rcall	.+0      	; 0xb62a <PrintIdle+0x7be>
    b62a:	00 d0       	rcall	.+0      	; 0xb62c <PrintIdle+0x7c0>
    b62c:	85 e9       	ldi	r24, 0x95	; 149
    b62e:	92 e0       	ldi	r25, 0x02	; 2
    b630:	ad b7       	in	r26, 0x3d	; 61
    b632:	be b7       	in	r27, 0x3e	; 62
    b634:	12 96       	adiw	r26, 0x02	; 2
    b636:	9c 93       	st	X, r25
    b638:	8e 93       	st	-X, r24
    b63a:	11 97       	sbiw	r26, 0x01	; 1
    b63c:	8b e6       	ldi	r24, 0x6B	; 107
    b63e:	98 e0       	ldi	r25, 0x08	; 8
    b640:	fa c1       	rjmp	.+1012   	; 0xba36 <PrintIdle+0xbca>
    b642:	c5 e9       	ldi	r28, 0x95	; 149
    b644:	d2 e0       	ldi	r29, 0x02	; 2
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b646:	88 30       	cpi	r24, 0x08	; 8
    b648:	09 f0       	breq	.+2      	; 0xb64c <PrintIdle+0x7e0>
    b64a:	28 cf       	rjmp	.-432    	; 0xb49c <PrintIdle+0x630>
			       CarriegeReturn();
    b64c:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                 "));
    b650:	00 d0       	rcall	.+0      	; 0xb652 <PrintIdle+0x7e6>
    b652:	00 d0       	rcall	.+0      	; 0xb654 <PrintIdle+0x7e8>
    b654:	ed b7       	in	r30, 0x3d	; 61
    b656:	fe b7       	in	r31, 0x3e	; 62
    b658:	d2 83       	std	Z+2, r29	; 0x02
    b65a:	c1 83       	std	Z+1, r28	; 0x01
    b65c:	89 e5       	ldi	r24, 0x59	; 89
    b65e:	98 e0       	ldi	r25, 0x08	; 8
    b660:	25 c0       	rjmp	.+74     	; 0xb6ac <PrintIdle+0x840>
				   }
               else ClearMem(strPrint);
		       break;
          case 13:
		       if (IsSignedField==True){
    b662:	80 91 92 02 	lds	r24, 0x0292
    b666:	c5 e9       	ldi	r28, 0x95	; 149
    b668:	d2 e0       	ldi	r29, 0x02	; 2
    b66a:	81 30       	cpi	r24, 0x01	; 1
    b66c:	09 f0       	breq	.+2      	; 0xb670 <PrintIdle+0x804>
    b66e:	16 cf       	rjmp	.-468    	; 0xb49c <PrintIdle+0x630>
			       CarriegeReturn();
    b670:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b674:	00 d0       	rcall	.+0      	; 0xb676 <PrintIdle+0x80a>
    b676:	00 d0       	rcall	.+0      	; 0xb678 <PrintIdle+0x80c>
    b678:	ad b7       	in	r26, 0x3d	; 61
    b67a:	be b7       	in	r27, 0x3e	; 62
    b67c:	12 96       	adiw	r26, 0x02	; 2
    b67e:	dc 93       	st	X, r29
    b680:	ce 93       	st	-X, r28
    b682:	11 97       	sbiw	r26, 0x01	; 1
    b684:	82 e4       	ldi	r24, 0x42	; 66
    b686:	98 e0       	ldi	r25, 0x08	; 8
    b688:	d6 c1       	rjmp	.+940    	; 0xba36 <PrintIdle+0xbca>
               }else ClearMem(strPrint);
		       break;
          case 14:
		       if (IsSignedField==True){
    b68a:	80 91 92 02 	lds	r24, 0x0292
    b68e:	c5 e9       	ldi	r28, 0x95	; 149
    b690:	d2 e0       	ldi	r29, 0x02	; 2
    b692:	81 30       	cpi	r24, 0x01	; 1
    b694:	09 f0       	breq	.+2      	; 0xb698 <PrintIdle+0x82c>
    b696:	02 cf       	rjmp	.-508    	; 0xb49c <PrintIdle+0x630>
			       CarriegeReturn();
    b698:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b69c:	00 d0       	rcall	.+0      	; 0xb69e <PrintIdle+0x832>
    b69e:	00 d0       	rcall	.+0      	; 0xb6a0 <PrintIdle+0x834>
    b6a0:	ed b7       	in	r30, 0x3d	; 61
    b6a2:	fe b7       	in	r31, 0x3e	; 62
    b6a4:	d2 83       	std	Z+2, r29	; 0x02
    b6a6:	c1 83       	std	Z+1, r28	; 0x01
    b6a8:	8b e2       	ldi	r24, 0x2B	; 43
    b6aa:	98 e0       	ldi	r25, 0x08	; 8
    b6ac:	94 83       	std	Z+4, r25	; 0x04
    b6ae:	83 83       	std	Z+3, r24	; 0x03
    b6b0:	c6 c1       	rjmp	.+908    	; 0xba3e <PrintIdle+0xbd2>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 17:
		       if (IsSignedField==True){
    b6b2:	80 91 92 02 	lds	r24, 0x0292
    b6b6:	c5 e9       	ldi	r28, 0x95	; 149
    b6b8:	d2 e0       	ldi	r29, 0x02	; 2
    b6ba:	81 30       	cpi	r24, 0x01	; 1
    b6bc:	09 f0       	breq	.+2      	; 0xb6c0 <PrintIdle+0x854>
    b6be:	ee ce       	rjmp	.-548    	; 0xb49c <PrintIdle+0x630>
			       CarriegeReturn();
    b6c0:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Tanda Tangan  (______________)"));
    b6c4:	00 d0       	rcall	.+0      	; 0xb6c6 <PrintIdle+0x85a>
    b6c6:	00 d0       	rcall	.+0      	; 0xb6c8 <PrintIdle+0x85c>
    b6c8:	ad b7       	in	r26, 0x3d	; 61
    b6ca:	be b7       	in	r27, 0x3e	; 62
    b6cc:	12 96       	adiw	r26, 0x02	; 2
    b6ce:	dc 93       	st	X, r29
    b6d0:	ce 93       	st	-X, r28
    b6d2:	11 97       	sbiw	r26, 0x01	; 1
    b6d4:	88 e0       	ldi	r24, 0x08	; 8
    b6d6:	98 e0       	ldi	r25, 0x08	; 8
    b6d8:	ae c1       	rjmp	.+860    	; 0xba36 <PrintIdle+0xbca>
               }else ClearMem(strPrint);
		       break;
          case 18:
		       if (IsSignedField==True){
    b6da:	80 91 92 02 	lds	r24, 0x0292
    b6de:	81 30       	cpi	r24, 0x01	; 1
    b6e0:	09 f0       	breq	.+2      	; 0xb6e4 <PrintIdle+0x878>
    b6e2:	ae c0       	rjmp	.+348    	; 0xb840 <PrintIdle+0x9d4>
			       IsSignedField=False;
    b6e4:	10 92 92 02 	sts	0x0292, r1
    b6e8:	ab c0       	rjmp	.+342    	; 0xb840 <PrintIdle+0x9d4>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 19://PrintMOP Name
		       if (MOPType!=MOP_CASH){
    b6ea:	80 91 cf 01 	lds	r24, 0x01CF
    b6ee:	c5 e9       	ldi	r28, 0x95	; 149
    b6f0:	d2 e0       	ldi	r29, 0x02	; 2
    b6f2:	88 23       	and	r24, r24
    b6f4:	09 f4       	brne	.+2      	; 0xb6f8 <PrintIdle+0x88c>
    b6f6:	d2 ce       	rjmp	.-604    	; 0xb49c <PrintIdle+0x630>
			       CarriegeReturn();
    b6f8:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			       //RemSpaceLag(strMOPName);
			       sprintf_P(strPrint,PSTR("    .%s"),strMOPName);
    b6fc:	00 d0       	rcall	.+0      	; 0xb6fe <PrintIdle+0x892>
    b6fe:	00 d0       	rcall	.+0      	; 0xb700 <PrintIdle+0x894>
    b700:	00 d0       	rcall	.+0      	; 0xb702 <PrintIdle+0x896>
    b702:	ed b7       	in	r30, 0x3d	; 61
    b704:	fe b7       	in	r31, 0x3e	; 62
    b706:	31 96       	adiw	r30, 0x01	; 1
    b708:	ad b7       	in	r26, 0x3d	; 61
    b70a:	be b7       	in	r27, 0x3e	; 62
    b70c:	12 96       	adiw	r26, 0x02	; 2
    b70e:	dc 93       	st	X, r29
    b710:	ce 93       	st	-X, r28
    b712:	11 97       	sbiw	r26, 0x01	; 1
    b714:	80 e0       	ldi	r24, 0x00	; 0
    b716:	98 e0       	ldi	r25, 0x08	; 8
    b718:	93 83       	std	Z+3, r25	; 0x03
    b71a:	82 83       	std	Z+2, r24	; 0x02
    b71c:	80 e6       	ldi	r24, 0x60	; 96
    b71e:	97 e0       	ldi	r25, 0x07	; 7
    b720:	6f c1       	rjmp	.+734    	; 0xba00 <PrintIdle+0xb94>
			   }else ClearMem(strPrint);
		       break;
		  case 20:
		       if (MOPType!=MOP_CASH){
    b722:	80 91 cf 01 	lds	r24, 0x01CF
    b726:	c5 e9       	ldi	r28, 0x95	; 149
    b728:	d2 e0       	ldi	r29, 0x02	; 2
    b72a:	88 23       	and	r24, r24
    b72c:	09 f4       	brne	.+2      	; 0xb730 <PrintIdle+0x8c4>
    b72e:	b6 ce       	rjmp	.-660    	; 0xb49c <PrintIdle+0x630>
			       CarriegeReturn();
    b730:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("    ------------------------------"));
    b734:	00 d0       	rcall	.+0      	; 0xb736 <PrintIdle+0x8ca>
    b736:	00 d0       	rcall	.+0      	; 0xb738 <PrintIdle+0x8cc>
    b738:	ad b7       	in	r26, 0x3d	; 61
    b73a:	be b7       	in	r27, 0x3e	; 62
    b73c:	12 96       	adiw	r26, 0x02	; 2
    b73e:	dc 93       	st	X, r29
    b740:	ce 93       	st	-X, r28
    b742:	11 97       	sbiw	r26, 0x01	; 1
    b744:	8d ed       	ldi	r24, 0xDD	; 221
    b746:	97 e0       	ldi	r25, 0x07	; 7
    b748:	76 c1       	rjmp	.+748    	; 0xba36 <PrintIdle+0xbca>
			   }else ClearMem(strPrint);
		       break;          
          //Loyalty
		  case 21:
		       CarriegeReturn();
    b74a:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("         LOYALTY INFORMATION      "));
    b74e:	00 d0       	rcall	.+0      	; 0xb750 <PrintIdle+0x8e4>
    b750:	00 d0       	rcall	.+0      	; 0xb752 <PrintIdle+0x8e6>
    b752:	85 e9       	ldi	r24, 0x95	; 149
    b754:	92 e0       	ldi	r25, 0x02	; 2
    b756:	ed b7       	in	r30, 0x3d	; 61
    b758:	fe b7       	in	r31, 0x3e	; 62
    b75a:	92 83       	std	Z+2, r25	; 0x02
    b75c:	81 83       	std	Z+1, r24	; 0x01
    b75e:	8a eb       	ldi	r24, 0xBA	; 186
    b760:	97 e0       	ldi	r25, 0x07	; 7
    b762:	a4 cf       	rjmp	.-184    	; 0xb6ac <PrintIdle+0x840>
		       break; 			            
		  case 22:
		       CarriegeReturn();
    b764:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Card ID      : %s"),strLoyCardID);
    b768:	00 d0       	rcall	.+0      	; 0xb76a <PrintIdle+0x8fe>
    b76a:	00 d0       	rcall	.+0      	; 0xb76c <PrintIdle+0x900>
    b76c:	00 d0       	rcall	.+0      	; 0xb76e <PrintIdle+0x902>
    b76e:	ed b7       	in	r30, 0x3d	; 61
    b770:	fe b7       	in	r31, 0x3e	; 62
    b772:	31 96       	adiw	r30, 0x01	; 1
    b774:	85 e9       	ldi	r24, 0x95	; 149
    b776:	92 e0       	ldi	r25, 0x02	; 2
    b778:	ad b7       	in	r26, 0x3d	; 61
    b77a:	be b7       	in	r27, 0x3e	; 62
    b77c:	12 96       	adiw	r26, 0x02	; 2
    b77e:	9c 93       	st	X, r25
    b780:	8e 93       	st	-X, r24
    b782:	11 97       	sbiw	r26, 0x01	; 1
    b784:	83 ea       	ldi	r24, 0xA3	; 163
    b786:	97 e0       	ldi	r25, 0x07	; 7
    b788:	93 83       	std	Z+3, r25	; 0x03
    b78a:	82 83       	std	Z+2, r24	; 0x02
    b78c:	87 ec       	ldi	r24, 0xC7	; 199
    b78e:	94 e0       	ldi	r25, 0x04	; 4
    b790:	37 c1       	rjmp	.+622    	; 0xba00 <PrintIdle+0xb94>
		       break;
		  case 23:
		       CarriegeReturn();
    b792:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			   //RemSpaceLag(strLoyCardHolder);
		       sprintf_P(strPrint,PSTR("     Card Holder  : %s "),strLoyCardHolder);
    b796:	00 d0       	rcall	.+0      	; 0xb798 <PrintIdle+0x92c>
    b798:	00 d0       	rcall	.+0      	; 0xb79a <PrintIdle+0x92e>
    b79a:	00 d0       	rcall	.+0      	; 0xb79c <PrintIdle+0x930>
    b79c:	ed b7       	in	r30, 0x3d	; 61
    b79e:	fe b7       	in	r31, 0x3e	; 62
    b7a0:	31 96       	adiw	r30, 0x01	; 1
    b7a2:	85 e9       	ldi	r24, 0x95	; 149
    b7a4:	92 e0       	ldi	r25, 0x02	; 2
    b7a6:	ad b7       	in	r26, 0x3d	; 61
    b7a8:	be b7       	in	r27, 0x3e	; 62
    b7aa:	12 96       	adiw	r26, 0x02	; 2
    b7ac:	9c 93       	st	X, r25
    b7ae:	8e 93       	st	-X, r24
    b7b0:	11 97       	sbiw	r26, 0x01	; 1
    b7b2:	8b e8       	ldi	r24, 0x8B	; 139
    b7b4:	97 e0       	ldi	r25, 0x07	; 7
    b7b6:	93 83       	std	Z+3, r25	; 0x03
    b7b8:	82 83       	std	Z+2, r24	; 0x02
    b7ba:	84 ea       	ldi	r24, 0xA4	; 164
    b7bc:	94 e0       	ldi	r25, 0x04	; 4
    b7be:	20 c1       	rjmp	.+576    	; 0xba00 <PrintIdle+0xb94>
		       break;
		  case 24:
		       if ((strlen(strCorporateID)>0)&&(SpaceOnly(strCorporateID)==False)){
    b7c0:	cd e5       	ldi	r28, 0x5D	; 93
    b7c2:	df e0       	ldi	r29, 0x0F	; 15
    b7c4:	80 91 5d 0f 	lds	r24, 0x0F5D
    b7c8:	88 23       	and	r24, r24
    b7ca:	d1 f1       	breq	.+116    	; 0xb840 <PrintIdle+0x9d4>
    b7cc:	ce 01       	movw	r24, r28
    b7ce:	0e 94 90 24 	call	0x4920	; 0x4920 <SpaceOnly>
    b7d2:	88 23       	and	r24, r24
    b7d4:	a9 f5       	brne	.+106    	; 0xb840 <PrintIdle+0x9d4>
		           CarriegeReturn();
    b7d6:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
				   //RemSpaceLag(strCorporateID);
		           sprintf_P(strPrint,PSTR("     Corp ID      : %s"),strCorporateID);
    b7da:	00 d0       	rcall	.+0      	; 0xb7dc <PrintIdle+0x970>
    b7dc:	00 d0       	rcall	.+0      	; 0xb7de <PrintIdle+0x972>
    b7de:	00 d0       	rcall	.+0      	; 0xb7e0 <PrintIdle+0x974>
    b7e0:	ed b7       	in	r30, 0x3d	; 61
    b7e2:	fe b7       	in	r31, 0x3e	; 62
    b7e4:	31 96       	adiw	r30, 0x01	; 1
    b7e6:	85 e9       	ldi	r24, 0x95	; 149
    b7e8:	92 e0       	ldi	r25, 0x02	; 2
    b7ea:	ad b7       	in	r26, 0x3d	; 61
    b7ec:	be b7       	in	r27, 0x3e	; 62
    b7ee:	12 96       	adiw	r26, 0x02	; 2
    b7f0:	9c 93       	st	X, r25
    b7f2:	8e 93       	st	-X, r24
    b7f4:	11 97       	sbiw	r26, 0x01	; 1
    b7f6:	84 e7       	ldi	r24, 0x74	; 116
    b7f8:	97 e0       	ldi	r25, 0x07	; 7
    b7fa:	1d c0       	rjmp	.+58     	; 0xb836 <PrintIdle+0x9ca>
			   }else ClearMem(strPrint);
		       break;
		  case 25:
		       if ((strlen(strCorporateName)>0)&&(SpaceOnly(strCorporateName)==False)){
    b7fc:	cd ea       	ldi	r28, 0xAD	; 173
    b7fe:	d5 e0       	ldi	r29, 0x05	; 5
    b800:	80 91 ad 05 	lds	r24, 0x05AD
    b804:	88 23       	and	r24, r24
    b806:	e1 f0       	breq	.+56     	; 0xb840 <PrintIdle+0x9d4>
    b808:	ce 01       	movw	r24, r28
    b80a:	0e 94 90 24 	call	0x4920	; 0x4920 <SpaceOnly>
    b80e:	88 23       	and	r24, r24
    b810:	b9 f4       	brne	.+46     	; 0xb840 <PrintIdle+0x9d4>
		           CarriegeReturn();
    b812:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
				   //RemSpaceLag(strCorporateName);
		           sprintf_P(strPrint,PSTR("     Corp Name    : %s"),strCorporateName);
    b816:	00 d0       	rcall	.+0      	; 0xb818 <PrintIdle+0x9ac>
    b818:	00 d0       	rcall	.+0      	; 0xb81a <PrintIdle+0x9ae>
    b81a:	00 d0       	rcall	.+0      	; 0xb81c <PrintIdle+0x9b0>
    b81c:	ed b7       	in	r30, 0x3d	; 61
    b81e:	fe b7       	in	r31, 0x3e	; 62
    b820:	31 96       	adiw	r30, 0x01	; 1
    b822:	85 e9       	ldi	r24, 0x95	; 149
    b824:	92 e0       	ldi	r25, 0x02	; 2
    b826:	ad b7       	in	r26, 0x3d	; 61
    b828:	be b7       	in	r27, 0x3e	; 62
    b82a:	12 96       	adiw	r26, 0x02	; 2
    b82c:	9c 93       	st	X, r25
    b82e:	8e 93       	st	-X, r24
    b830:	11 97       	sbiw	r26, 0x01	; 1
    b832:	8d e5       	ldi	r24, 0x5D	; 93
    b834:	97 e0       	ldi	r25, 0x07	; 7
    b836:	93 83       	std	Z+3, r25	; 0x03
    b838:	82 83       	std	Z+2, r24	; 0x02
    b83a:	d5 83       	std	Z+5, r29	; 0x05
    b83c:	c4 83       	std	Z+4, r28	; 0x04
    b83e:	e2 c0       	rjmp	.+452    	; 0xba04 <PrintIdle+0xb98>
			   }else ClearMem(strPrint);
    b840:	85 e9       	ldi	r24, 0x95	; 149
    b842:	92 e0       	ldi	r25, 0x02	; 2
    b844:	2c ce       	rjmp	.-936    	; 0xb49e <PrintIdle+0x632>
		       break;
		  case 26:
		       CarriegeReturn();
    b846:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Gain Points  : %s"),strGainPoints);
    b84a:	00 d0       	rcall	.+0      	; 0xb84c <PrintIdle+0x9e0>
    b84c:	00 d0       	rcall	.+0      	; 0xb84e <PrintIdle+0x9e2>
    b84e:	00 d0       	rcall	.+0      	; 0xb850 <PrintIdle+0x9e4>
    b850:	ed b7       	in	r30, 0x3d	; 61
    b852:	fe b7       	in	r31, 0x3e	; 62
    b854:	31 96       	adiw	r30, 0x01	; 1
    b856:	85 e9       	ldi	r24, 0x95	; 149
    b858:	92 e0       	ldi	r25, 0x02	; 2
    b85a:	ad b7       	in	r26, 0x3d	; 61
    b85c:	be b7       	in	r27, 0x3e	; 62
    b85e:	12 96       	adiw	r26, 0x02	; 2
    b860:	9c 93       	st	X, r25
    b862:	8e 93       	st	-X, r24
    b864:	11 97       	sbiw	r26, 0x01	; 1
    b866:	86 e4       	ldi	r24, 0x46	; 70
    b868:	97 e0       	ldi	r25, 0x07	; 7
    b86a:	93 83       	std	Z+3, r25	; 0x03
    b86c:	82 83       	std	Z+2, r24	; 0x02
    b86e:	8b e9       	ldi	r24, 0x9B	; 155
    b870:	94 e0       	ldi	r25, 0x04	; 4
    b872:	c6 c0       	rjmp	.+396    	; 0xba00 <PrintIdle+0xb94>
		       break;
		  case 27:
		       CarriegeReturn();
    b874:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Prev Points  : %s"),strPrevPoints);
    b878:	00 d0       	rcall	.+0      	; 0xb87a <PrintIdle+0xa0e>
    b87a:	00 d0       	rcall	.+0      	; 0xb87c <PrintIdle+0xa10>
    b87c:	00 d0       	rcall	.+0      	; 0xb87e <PrintIdle+0xa12>
    b87e:	ed b7       	in	r30, 0x3d	; 61
    b880:	fe b7       	in	r31, 0x3e	; 62
    b882:	31 96       	adiw	r30, 0x01	; 1
    b884:	85 e9       	ldi	r24, 0x95	; 149
    b886:	92 e0       	ldi	r25, 0x02	; 2
    b888:	ad b7       	in	r26, 0x3d	; 61
    b88a:	be b7       	in	r27, 0x3e	; 62
    b88c:	12 96       	adiw	r26, 0x02	; 2
    b88e:	9c 93       	st	X, r25
    b890:	8e 93       	st	-X, r24
    b892:	11 97       	sbiw	r26, 0x01	; 1
    b894:	8f e2       	ldi	r24, 0x2F	; 47
    b896:	97 e0       	ldi	r25, 0x07	; 7
    b898:	93 83       	std	Z+3, r25	; 0x03
    b89a:	82 83       	std	Z+2, r24	; 0x02
    b89c:	8a e7       	ldi	r24, 0x7A	; 122
    b89e:	9c e0       	ldi	r25, 0x0C	; 12
    b8a0:	af c0       	rjmp	.+350    	; 0xba00 <PrintIdle+0xb94>
		       break;
		  case 28:
		       CarriegeReturn();
    b8a2:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Curr Points  : %s"),strLoyCurrentPoints);
    b8a6:	00 d0       	rcall	.+0      	; 0xb8a8 <PrintIdle+0xa3c>
    b8a8:	00 d0       	rcall	.+0      	; 0xb8aa <PrintIdle+0xa3e>
    b8aa:	00 d0       	rcall	.+0      	; 0xb8ac <PrintIdle+0xa40>
    b8ac:	ed b7       	in	r30, 0x3d	; 61
    b8ae:	fe b7       	in	r31, 0x3e	; 62
    b8b0:	31 96       	adiw	r30, 0x01	; 1
    b8b2:	85 e9       	ldi	r24, 0x95	; 149
    b8b4:	92 e0       	ldi	r25, 0x02	; 2
    b8b6:	ad b7       	in	r26, 0x3d	; 61
    b8b8:	be b7       	in	r27, 0x3e	; 62
    b8ba:	12 96       	adiw	r26, 0x02	; 2
    b8bc:	9c 93       	st	X, r25
    b8be:	8e 93       	st	-X, r24
    b8c0:	11 97       	sbiw	r26, 0x01	; 1
    b8c2:	88 e1       	ldi	r24, 0x18	; 24
    b8c4:	97 e0       	ldi	r25, 0x07	; 7
    b8c6:	93 83       	std	Z+3, r25	; 0x03
    b8c8:	82 83       	std	Z+2, r24	; 0x02
    b8ca:	8e ed       	ldi	r24, 0xDE	; 222
    b8cc:	9b e0       	ldi	r25, 0x0B	; 11
    b8ce:	98 c0       	rjmp	.+304    	; 0xba00 <PrintIdle+0xb94>
		       break;
		  case 29:
		       CarriegeReturn();
    b8d0:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Expiry       : %s"),strLoyExpiry);
    b8d4:	00 d0       	rcall	.+0      	; 0xb8d6 <PrintIdle+0xa6a>
    b8d6:	00 d0       	rcall	.+0      	; 0xb8d8 <PrintIdle+0xa6c>
    b8d8:	00 d0       	rcall	.+0      	; 0xb8da <PrintIdle+0xa6e>
    b8da:	ed b7       	in	r30, 0x3d	; 61
    b8dc:	fe b7       	in	r31, 0x3e	; 62
    b8de:	31 96       	adiw	r30, 0x01	; 1
    b8e0:	85 e9       	ldi	r24, 0x95	; 149
    b8e2:	92 e0       	ldi	r25, 0x02	; 2
    b8e4:	ad b7       	in	r26, 0x3d	; 61
    b8e6:	be b7       	in	r27, 0x3e	; 62
    b8e8:	12 96       	adiw	r26, 0x02	; 2
    b8ea:	9c 93       	st	X, r25
    b8ec:	8e 93       	st	-X, r24
    b8ee:	11 97       	sbiw	r26, 0x01	; 1
    b8f0:	81 e0       	ldi	r24, 0x01	; 1
    b8f2:	97 e0       	ldi	r25, 0x07	; 7
    b8f4:	93 83       	std	Z+3, r25	; 0x03
    b8f6:	82 83       	std	Z+2, r24	; 0x02
    b8f8:	8b ec       	ldi	r24, 0xCB	; 203
    b8fa:	9f e0       	ldi	r25, 0x0F	; 15
    b8fc:	81 c0       	rjmp	.+258    	; 0xba00 <PrintIdle+0xb94>
		       break;
		  case 30:
		       CarriegeReturn();
    b8fe:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			   //RemSpaceLag(strLoyRedeemPoints);
		       sprintf_P(strPrint,PSTR("     Total Redeem : %s"),strLoyRedeemPoints);
    b902:	00 d0       	rcall	.+0      	; 0xb904 <PrintIdle+0xa98>
    b904:	00 d0       	rcall	.+0      	; 0xb906 <PrintIdle+0xa9a>
    b906:	00 d0       	rcall	.+0      	; 0xb908 <PrintIdle+0xa9c>
    b908:	ed b7       	in	r30, 0x3d	; 61
    b90a:	fe b7       	in	r31, 0x3e	; 62
    b90c:	31 96       	adiw	r30, 0x01	; 1
    b90e:	85 e9       	ldi	r24, 0x95	; 149
    b910:	92 e0       	ldi	r25, 0x02	; 2
    b912:	ad b7       	in	r26, 0x3d	; 61
    b914:	be b7       	in	r27, 0x3e	; 62
    b916:	12 96       	adiw	r26, 0x02	; 2
    b918:	9c 93       	st	X, r25
    b91a:	8e 93       	st	-X, r24
    b91c:	11 97       	sbiw	r26, 0x01	; 1
    b91e:	8a ee       	ldi	r24, 0xEA	; 234
    b920:	96 e0       	ldi	r25, 0x06	; 6
    b922:	93 83       	std	Z+3, r25	; 0x03
    b924:	82 83       	std	Z+2, r24	; 0x02
    b926:	8a e7       	ldi	r24, 0x7A	; 122
    b928:	95 e0       	ldi	r25, 0x05	; 5
    b92a:	6a c0       	rjmp	.+212    	; 0xba00 <PrintIdle+0xb94>
		       break;
		  case 31:
		       CarriegeReturn();
    b92c:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeV);
			   //FormatCurrency(strLoyCurrMonConsumeV);
		       sprintf_P(strPrint,PSTR("     Month Cons V : %s L"),strLoyCurrMonConsumeV);
    b930:	00 d0       	rcall	.+0      	; 0xb932 <PrintIdle+0xac6>
    b932:	00 d0       	rcall	.+0      	; 0xb934 <PrintIdle+0xac8>
    b934:	00 d0       	rcall	.+0      	; 0xb936 <PrintIdle+0xaca>
    b936:	ed b7       	in	r30, 0x3d	; 61
    b938:	fe b7       	in	r31, 0x3e	; 62
    b93a:	31 96       	adiw	r30, 0x01	; 1
    b93c:	85 e9       	ldi	r24, 0x95	; 149
    b93e:	92 e0       	ldi	r25, 0x02	; 2
    b940:	ad b7       	in	r26, 0x3d	; 61
    b942:	be b7       	in	r27, 0x3e	; 62
    b944:	12 96       	adiw	r26, 0x02	; 2
    b946:	9c 93       	st	X, r25
    b948:	8e 93       	st	-X, r24
    b94a:	11 97       	sbiw	r26, 0x01	; 1
    b94c:	81 ed       	ldi	r24, 0xD1	; 209
    b94e:	96 e0       	ldi	r25, 0x06	; 6
    b950:	93 83       	std	Z+3, r25	; 0x03
    b952:	82 83       	std	Z+2, r24	; 0x02
    b954:	80 e4       	ldi	r24, 0x40	; 64
    b956:	9f e0       	ldi	r25, 0x0F	; 15
    b958:	53 c0       	rjmp	.+166    	; 0xba00 <PrintIdle+0xb94>
		       break;
		  case 32:
		       CarriegeReturn();
    b95a:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeA);
			   //FormatCurrency(strLoyCurrMonConsumeA);
		       sprintf_P(strPrint,PSTR("     Month Cons A : Rp.%s"),strLoyCurrMonConsumeA);
    b95e:	00 d0       	rcall	.+0      	; 0xb960 <PrintIdle+0xaf4>
    b960:	00 d0       	rcall	.+0      	; 0xb962 <PrintIdle+0xaf6>
    b962:	00 d0       	rcall	.+0      	; 0xb964 <PrintIdle+0xaf8>
    b964:	ed b7       	in	r30, 0x3d	; 61
    b966:	fe b7       	in	r31, 0x3e	; 62
    b968:	31 96       	adiw	r30, 0x01	; 1
    b96a:	85 e9       	ldi	r24, 0x95	; 149
    b96c:	92 e0       	ldi	r25, 0x02	; 2
    b96e:	ad b7       	in	r26, 0x3d	; 61
    b970:	be b7       	in	r27, 0x3e	; 62
    b972:	12 96       	adiw	r26, 0x02	; 2
    b974:	9c 93       	st	X, r25
    b976:	8e 93       	st	-X, r24
    b978:	11 97       	sbiw	r26, 0x01	; 1
    b97a:	87 eb       	ldi	r24, 0xB7	; 183
    b97c:	96 e0       	ldi	r25, 0x06	; 6
    b97e:	93 83       	std	Z+3, r25	; 0x03
    b980:	82 83       	std	Z+2, r24	; 0x02
    b982:	8e e5       	ldi	r24, 0x5E	; 94
    b984:	95 e0       	ldi	r25, 0x05	; 5
    b986:	3c c0       	rjmp	.+120    	; 0xba00 <PrintIdle+0xb94>
		       break;
		  case 33://EndOfLoyalty
		       CarriegeReturn();
    b988:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b98c:	00 d0       	rcall	.+0      	; 0xb98e <PrintIdle+0xb22>
    b98e:	00 d0       	rcall	.+0      	; 0xb990 <PrintIdle+0xb24>
    b990:	85 e9       	ldi	r24, 0x95	; 149
    b992:	92 e0       	ldi	r25, 0x02	; 2
    b994:	ad b7       	in	r26, 0x3d	; 61
    b996:	be b7       	in	r27, 0x3e	; 62
    b998:	12 96       	adiw	r26, 0x02	; 2
    b99a:	9c 93       	st	X, r25
    b99c:	8e 93       	st	-X, r24
    b99e:	11 97       	sbiw	r26, 0x01	; 1
    b9a0:	84 e9       	ldi	r24, 0x94	; 148
    b9a2:	96 e0       	ldi	r25, 0x06	; 6
    b9a4:	48 c0       	rjmp	.+144    	; 0xba36 <PrintIdle+0xbca>
		       break;
		  case 34:
		       CarriegeReturn();
    b9a6:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Dsc: %s"),strSurchargeDesc);
    b9aa:	00 d0       	rcall	.+0      	; 0xb9ac <PrintIdle+0xb40>
    b9ac:	00 d0       	rcall	.+0      	; 0xb9ae <PrintIdle+0xb42>
    b9ae:	00 d0       	rcall	.+0      	; 0xb9b0 <PrintIdle+0xb44>
    b9b0:	ed b7       	in	r30, 0x3d	; 61
    b9b2:	fe b7       	in	r31, 0x3e	; 62
    b9b4:	31 96       	adiw	r30, 0x01	; 1
    b9b6:	85 e9       	ldi	r24, 0x95	; 149
    b9b8:	92 e0       	ldi	r25, 0x02	; 2
    b9ba:	ad b7       	in	r26, 0x3d	; 61
    b9bc:	be b7       	in	r27, 0x3e	; 62
    b9be:	12 96       	adiw	r26, 0x02	; 2
    b9c0:	9c 93       	st	X, r25
    b9c2:	8e 93       	st	-X, r24
    b9c4:	11 97       	sbiw	r26, 0x01	; 1
    b9c6:	8d e7       	ldi	r24, 0x7D	; 125
    b9c8:	96 e0       	ldi	r25, 0x06	; 6
    b9ca:	93 83       	std	Z+3, r25	; 0x03
    b9cc:	82 83       	std	Z+2, r24	; 0x02
    b9ce:	89 eb       	ldi	r24, 0xB9	; 185
    b9d0:	99 e0       	ldi	r25, 0x09	; 9
    b9d2:	16 c0       	rjmp	.+44     	; 0xba00 <PrintIdle+0xb94>
		       break;
		  case 35:
		       CarriegeReturn();
    b9d4:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Amt: %s"),strSurchargeAmount);
    b9d8:	00 d0       	rcall	.+0      	; 0xb9da <PrintIdle+0xb6e>
    b9da:	00 d0       	rcall	.+0      	; 0xb9dc <PrintIdle+0xb70>
    b9dc:	00 d0       	rcall	.+0      	; 0xb9de <PrintIdle+0xb72>
    b9de:	ed b7       	in	r30, 0x3d	; 61
    b9e0:	fe b7       	in	r31, 0x3e	; 62
    b9e2:	31 96       	adiw	r30, 0x01	; 1
    b9e4:	85 e9       	ldi	r24, 0x95	; 149
    b9e6:	92 e0       	ldi	r25, 0x02	; 2
    b9e8:	ad b7       	in	r26, 0x3d	; 61
    b9ea:	be b7       	in	r27, 0x3e	; 62
    b9ec:	12 96       	adiw	r26, 0x02	; 2
    b9ee:	9c 93       	st	X, r25
    b9f0:	8e 93       	st	-X, r24
    b9f2:	11 97       	sbiw	r26, 0x01	; 1
    b9f4:	86 e6       	ldi	r24, 0x66	; 102
    b9f6:	96 e0       	ldi	r25, 0x06	; 6
    b9f8:	93 83       	std	Z+3, r25	; 0x03
    b9fa:	82 83       	std	Z+2, r24	; 0x02
    b9fc:	8b ef       	ldi	r24, 0xFB	; 251
    b9fe:	9b e0       	ldi	r25, 0x0B	; 11
    ba00:	95 83       	std	Z+5, r25	; 0x05
    ba02:	84 83       	std	Z+4, r24	; 0x04
    ba04:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    ba08:	ed b7       	in	r30, 0x3d	; 61
    ba0a:	fe b7       	in	r31, 0x3e	; 62
    ba0c:	36 96       	adiw	r30, 0x06	; 6
    ba0e:	0f b6       	in	r0, 0x3f	; 63
    ba10:	f8 94       	cli
    ba12:	fe bf       	out	0x3e, r31	; 62
    ba14:	0f be       	out	0x3f, r0	; 63
    ba16:	ed bf       	out	0x3d, r30	; 61
    ba18:	18 c0       	rjmp	.+48     	; 0xba4a <PrintIdle+0xbde>
		       break;
		  case 36:
		       CarriegeReturn();
    ba1a:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    ba1e:	00 d0       	rcall	.+0      	; 0xba20 <PrintIdle+0xbb4>
    ba20:	00 d0       	rcall	.+0      	; 0xba22 <PrintIdle+0xbb6>
    ba22:	85 e9       	ldi	r24, 0x95	; 149
    ba24:	92 e0       	ldi	r25, 0x02	; 2
    ba26:	ad b7       	in	r26, 0x3d	; 61
    ba28:	be b7       	in	r27, 0x3e	; 62
    ba2a:	12 96       	adiw	r26, 0x02	; 2
    ba2c:	9c 93       	st	X, r25
    ba2e:	8e 93       	st	-X, r24
    ba30:	11 97       	sbiw	r26, 0x01	; 1
    ba32:	83 e4       	ldi	r24, 0x43	; 67
    ba34:	96 e0       	ldi	r25, 0x06	; 6
    ba36:	14 96       	adiw	r26, 0x04	; 4
    ba38:	9c 93       	st	X, r25
    ba3a:	8e 93       	st	-X, r24
    ba3c:	13 97       	sbiw	r26, 0x03	; 3
    ba3e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    ba42:	0f 90       	pop	r0
    ba44:	0f 90       	pop	r0
    ba46:	0f 90       	pop	r0
    ba48:	0f 90       	pop	r0
		       break;
		  }
		  iLoop=0;iSend=0;LSend=strlen(strPrint);
    ba4a:	10 92 8d 02 	sts	0x028D, r1
    ba4e:	10 92 8c 02 	sts	0x028C, r1
    ba52:	10 92 91 02 	sts	0x0291, r1
    ba56:	10 92 90 02 	sts	0x0290, r1
    ba5a:	e5 e9       	ldi	r30, 0x95	; 149
    ba5c:	f2 e0       	ldi	r31, 0x02	; 2
    ba5e:	01 90       	ld	r0, Z+
    ba60:	00 20       	and	r0, r0
    ba62:	e9 f7       	brne	.-6      	; 0xba5e <PrintIdle+0xbf2>
    ba64:	31 97       	sbiw	r30, 0x01	; 1
    ba66:	e5 59       	subi	r30, 0x95	; 149
    ba68:	f2 40       	sbci	r31, 0x02	; 2
    ba6a:	f0 93 8f 02 	sts	0x028F, r31
    ba6e:	e0 93 8e 02 	sts	0x028E, r30
          stPrintIdle=piPrintMessage;
    ba72:	8a e0       	ldi	r24, 0x0A	; 10
    ba74:	f3 c0       	rjmp	.+486    	; 0xbc5c <PrintIdle+0xdf0>
	      break;
     case piPrintMessage:
	      if (iSend<LSend){
    ba76:	20 91 90 02 	lds	r18, 0x0290
    ba7a:	30 91 91 02 	lds	r19, 0x0291
    ba7e:	80 91 8e 02 	lds	r24, 0x028E
    ba82:	90 91 8f 02 	lds	r25, 0x028F
    ba86:	28 17       	cp	r18, r24
    ba88:	39 07       	cpc	r19, r25
    ba8a:	78 f4       	brcc	.+30     	; 0xbaaa <PrintIdle+0xc3e>
		      iLoop++;
    ba8c:	80 91 8c 02 	lds	r24, 0x028C
    ba90:	90 91 8d 02 	lds	r25, 0x028D
    ba94:	01 96       	adiw	r24, 0x01	; 1
    ba96:	90 93 8d 02 	sts	0x028D, r25
    ba9a:	80 93 8c 02 	sts	0x028C, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    ba9e:	10 92 cd 01 	sts	0x01CD, r1
    baa2:	10 92 cc 01 	sts	0x01CC, r1
				 stPrintIdle=piCheckPrintStatusMessage;
    baa6:	8c e0       	ldi	r24, 0x0C	; 12
    baa8:	d9 c0       	rjmp	.+434    	; 0xbc5c <PrintIdle+0xdf0>
				 }
			  }
          else{iMessage++;
    baaa:	80 91 94 02 	lds	r24, 0x0294
    baae:	8f 5f       	subi	r24, 0xFF	; 255
    bab0:	80 93 94 02 	sts	0x0294, r24
		      if (iMessage>MessageLine){
    bab4:	90 91 93 02 	lds	r25, 0x0293
    bab8:	98 17       	cp	r25, r24
    baba:	18 f4       	brcc	.+6      	; 0xbac2 <PrintIdle+0xc56>
			      iFooter=0;
    babc:	10 92 c4 02 	sts	0x02C4, r1
    bac0:	5c c0       	rjmp	.+184    	; 0xbb7a <PrintIdle+0xd0e>
				  stPrintIdle=piLoadFooter;
				  CarriegeReturn();
			  }
			  else stPrintIdle=piLoadMessage;
    bac2:	89 e0       	ldi	r24, 0x09	; 9
    bac4:	cb c0       	rjmp	.+406    	; 0xbc5c <PrintIdle+0xdf0>
			  }
	      break;
     case piCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    bac6:	80 91 c9 01 	lds	r24, 0x01C9
    baca:	88 23       	and	r24, r24
    bacc:	09 f0       	breq	.+2      	; 0xbad0 <PrintIdle+0xc64>
    bace:	bc c0       	rjmp	.+376    	; 0xbc48 <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    bad0:	e0 91 90 02 	lds	r30, 0x0290
    bad4:	f0 91 91 02 	lds	r31, 0x0291
    bad8:	eb 56       	subi	r30, 0x6B	; 107
    bada:	fd 4f       	sbci	r31, 0xFD	; 253
    badc:	61 e0       	ldi	r22, 0x01	; 1
    bade:	40 81       	ld	r20, Z
    bae0:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
		      iSend++;
    bae4:	80 91 90 02 	lds	r24, 0x0290
    bae8:	90 91 91 02 	lds	r25, 0x0291
    baec:	01 96       	adiw	r24, 0x01	; 1
    baee:	90 93 91 02 	sts	0x0291, r25
    baf2:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintMessage;
    baf6:	8a e0       	ldi	r24, 0x0A	; 10
    baf8:	a5 c0       	rjmp	.+330    	; 0xbc44 <PrintIdle+0xdd8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    bafa:	60 91 c4 02 	lds	r22, 0x02C4
    bafe:	89 e2       	ldi	r24, 0x29	; 41
    bb00:	68 9f       	mul	r22, r24
    bb02:	b0 01       	movw	r22, r0
    bb04:	11 24       	eor	r1, r1
    bb06:	63 5e       	subi	r22, 0xE3	; 227
    bb08:	7c 4f       	sbci	r23, 0xFC	; 252
    bb0a:	85 e9       	ldi	r24, 0x95	; 149
    bb0c:	92 e0       	ldi	r25, 0x02	; 2
    bb0e:	48 e2       	ldi	r20, 0x28	; 40
    bb10:	50 e0       	ldi	r21, 0x00	; 0
    bb12:	28 ef       	ldi	r18, 0xF8	; 248
    bb14:	32 e1       	ldi	r19, 0x12	; 18
    bb16:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
	      break;
		       
     case piLoadFooter:
	      FillChar(strPrint,0,sizeof(strPrint));
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    bb1a:	80 91 c4 02 	lds	r24, 0x02C4
    bb1e:	8f 5f       	subi	r24, 0xFF	; 255
    bb20:	80 93 c4 02 	sts	0x02C4, r24
		  if (iFooter<=4){
    bb24:	85 30       	cpi	r24, 0x05	; 5
    bb26:	90 f4       	brcc	.+36     	; 0xbb4c <PrintIdle+0xce0>
		      if (SpaceOnly(strPrint)==True){
    bb28:	85 e9       	ldi	r24, 0x95	; 149
    bb2a:	92 e0       	ldi	r25, 0x02	; 2
    bb2c:	0e 94 90 24 	call	0x4920	; 0x4920 <SpaceOnly>
    bb30:	81 30       	cpi	r24, 0x01	; 1
    bb32:	11 f4       	brne	.+4      	; 0xbb38 <PrintIdle+0xccc>
			      stPrintIdle=piLoadFooter;
    bb34:	8e e0       	ldi	r24, 0x0E	; 14
    bb36:	92 c0       	rjmp	.+292    	; 0xbc5c <PrintIdle+0xdf0>
				  }
			  else{
			      iSend=0;
    bb38:	10 92 91 02 	sts	0x0291, r1
    bb3c:	10 92 90 02 	sts	0x0290, r1
				  iLoop=0;
    bb40:	10 92 8d 02 	sts	0x028D, r1
    bb44:	10 92 8c 02 	sts	0x028C, r1
				  stPrintIdle=piPrintFooter;
    bb48:	8f e0       	ldi	r24, 0x0F	; 15
    bb4a:	88 c0       	rjmp	.+272    	; 0xbc5c <PrintIdle+0xdf0>
				  //RemSpaceLag(strPrint);
				  //CarriegeReturn();
			      }
		  }else{stPrintIdle=piInitScroll;
    bb4c:	81 e1       	ldi	r24, 0x11	; 17
    bb4e:	86 c0       	rjmp	.+268    	; 0xbc5c <PrintIdle+0xdf0>
		        //iPrinted++;
			}
	      break;
     case piPrintFooter:
		  if (iSend<40){
    bb50:	80 91 90 02 	lds	r24, 0x0290
    bb54:	90 91 91 02 	lds	r25, 0x0291
    bb58:	88 97       	sbiw	r24, 0x28	; 40
    bb5a:	78 f4       	brcc	.+30     	; 0xbb7a <PrintIdle+0xd0e>
		      iLoop++;
    bb5c:	80 91 8c 02 	lds	r24, 0x028C
    bb60:	90 91 8d 02 	lds	r25, 0x028D
    bb64:	01 96       	adiw	r24, 0x01	; 1
    bb66:	90 93 8d 02 	sts	0x028D, r25
    bb6a:	80 93 8c 02 	sts	0x028C, r24
			  if((iLoop%PRINT_DELAY)==0){
				TimPrintBusy=0;
    bb6e:	10 92 cd 01 	sts	0x01CD, r1
    bb72:	10 92 cc 01 	sts	0x01CC, r1
				stPrintIdle=piCheckPrintStatusFooter;
    bb76:	8d e0       	ldi	r24, 0x0D	; 13
    bb78:	71 c0       	rjmp	.+226    	; 0xbc5c <PrintIdle+0xdf0>
				}
			  }
          else {
		      stPrintIdle=piLoadFooter;
    bb7a:	8e e0       	ldi	r24, 0x0E	; 14
    bb7c:	80 93 c6 02 	sts	0x02C6, r24
			  CarriegeReturn();
    bb80:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
    bb84:	96 c0       	rjmp	.+300    	; 0xbcb2 <PrintIdle+0xe46>
			  }
	      break;
     case piCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    bb86:	80 91 c9 01 	lds	r24, 0x01C9
    bb8a:	88 23       	and	r24, r24
    bb8c:	09 f0       	breq	.+2      	; 0xbb90 <PrintIdle+0xd24>
    bb8e:	5c c0       	rjmp	.+184    	; 0xbc48 <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    bb90:	e0 91 90 02 	lds	r30, 0x0290
    bb94:	f0 91 91 02 	lds	r31, 0x0291
    bb98:	eb 56       	subi	r30, 0x6B	; 107
    bb9a:	fd 4f       	sbci	r31, 0xFD	; 253
    bb9c:	61 e0       	ldi	r22, 0x01	; 1
    bb9e:	40 81       	ld	r20, Z
    bba0:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
		      iSend++;
    bba4:	80 91 90 02 	lds	r24, 0x0290
    bba8:	90 91 91 02 	lds	r25, 0x0291
    bbac:	01 96       	adiw	r24, 0x01	; 1
    bbae:	90 93 91 02 	sts	0x0291, r25
    bbb2:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintFooter;
    bbb6:	8f e0       	ldi	r24, 0x0F	; 15
    bbb8:	45 c0       	rjmp	.+138    	; 0xbc44 <PrintIdle+0xdd8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitScroll:
	      iPrinted++;
    bbba:	90 91 8b 02 	lds	r25, 0x028B
    bbbe:	9f 5f       	subi	r25, 0xFF	; 255
    bbc0:	90 93 8b 02 	sts	0x028B, r25
		  iScroll=0;
    bbc4:	10 92 c3 02 	sts	0x02C3, r1
		  iLoop=0;
    bbc8:	10 92 8d 02 	sts	0x028D, r1
    bbcc:	10 92 8c 02 	sts	0x028C, r1
		  if (iPrinted<PrintCopy){
    bbd0:	80 91 8a 02 	lds	r24, 0x028A
    bbd4:	98 17       	cp	r25, r24
    bbd6:	28 f4       	brcc	.+10     	; 0xbbe2 <PrintIdle+0xd76>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    bbd8:	e1 99       	sbic	0x1c, 1	; 28
    bbda:	fe cf       	rjmp	.-4      	; 0xbbd8 <PrintIdle+0xd6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    bbdc:	82 e3       	ldi	r24, 0x32	; 50
    bbde:	90 e0       	ldi	r25, 0x00	; 0
    bbe0:	04 c0       	rjmp	.+8      	; 0xbbea <PrintIdle+0xd7e>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    bbe2:	e1 99       	sbic	0x1c, 1	; 28
    bbe4:	fe cf       	rjmp	.-4      	; 0xbbe2 <PrintIdle+0xd76>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    bbe6:	81 e3       	ldi	r24, 0x31	; 49
    bbe8:	90 e0       	ldi	r25, 0x00	; 0
    bbea:	9f bb       	out	0x1f, r25	; 31
    bbec:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    bbee:	e0 9a       	sbi	0x1c, 0	; 28
    bbf0:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  }else if (iPrinted>=PrintCopy){		  	  
		      nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    bbf2:	80 93 c2 02 	sts	0x02C2, r24
		  if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_TG02){
		      _uart_printf(0,1,PSTR("----Scrolled2-----"));

		      stPrintIdle=piPaperCut;
		  }*/
          stPrintIdle=piScrollPaper;              
    bbf6:	80 e1       	ldi	r24, 0x10	; 16
    bbf8:	31 c0       	rjmp	.+98     	; 0xbc5c <PrintIdle+0xdf0>
	      break;
     case piScrollPaper:
	      iLoop++;
    bbfa:	80 91 8c 02 	lds	r24, 0x028C
    bbfe:	90 91 8d 02 	lds	r25, 0x028D
    bc02:	01 96       	adiw	r24, 0x01	; 1
    bc04:	90 93 8d 02 	sts	0x028D, r25
    bc08:	80 93 8c 02 	sts	0x028C, r24
		  if (iLoop%PRINT_DELAY==0){
			  TimPrintBusy=0;
    bc0c:	10 92 cd 01 	sts	0x01CD, r1
    bc10:	10 92 cc 01 	sts	0x01CC, r1
			  stPrintIdle=piCheckPrintStatusScroll;
    bc14:	82 e1       	ldi	r24, 0x12	; 18
    bc16:	80 93 c6 02 	sts	0x02C6, r24
			  }
	      if (iScroll>nScroll)stPrintIdle=piPaperCut;
    bc1a:	90 91 c3 02 	lds	r25, 0x02C3
    bc1e:	80 91 c2 02 	lds	r24, 0x02C2
    bc22:	89 17       	cp	r24, r25
    bc24:	08 f0       	brcs	.+2      	; 0xbc28 <PrintIdle+0xdbc>
    bc26:	45 c0       	rjmp	.+138    	; 0xbcb2 <PrintIdle+0xe46>
    bc28:	83 e1       	ldi	r24, 0x13	; 19
    bc2a:	18 c0       	rjmp	.+48     	; 0xbc5c <PrintIdle+0xdf0>
	      break;
     case piCheckPrintStatusScroll:
	      if (IsBusyPrint==False){
    bc2c:	80 91 c9 01 	lds	r24, 0x01C9
    bc30:	88 23       	and	r24, r24
    bc32:	51 f4       	brne	.+20     	; 0xbc48 <PrintIdle+0xddc>
		      iScroll++;
    bc34:	80 91 c3 02 	lds	r24, 0x02C3
    bc38:	8f 5f       	subi	r24, 0xFF	; 255
    bc3a:	80 93 c3 02 	sts	0x02C3, r24
		      CarriegeReturn();
    bc3e:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		      stPrintIdle=piScrollPaper;
    bc42:	80 e1       	ldi	r24, 0x10	; 16
    bc44:	80 93 c6 02 	sts	0x02C6, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    bc48:	80 91 cc 01 	lds	r24, 0x01CC
    bc4c:	90 91 cd 01 	lds	r25, 0x01CD
    bc50:	0b 97       	sbiw	r24, 0x0b	; 11
    bc52:	7c f1       	brlt	.+94     	; 0xbcb2 <PrintIdle+0xe46>
		      IsPrintERROR=True;
    bc54:	81 e0       	ldi	r24, 0x01	; 1
    bc56:	80 93 c7 01 	sts	0x01C7, r24
		      stPrintIdle=piFinishPrintIdle;
    bc5a:	84 e1       	ldi	r24, 0x14	; 20
    bc5c:	80 93 c6 02 	sts	0x02C6, r24
    bc60:	28 c0       	rjmp	.+80     	; 0xbcb2 <PrintIdle+0xe46>
	      break;
     case piPaperCut:
	      //sprintf_P(strSend,PSTR("i:%d Copy:%d"),iPrinted,PrintCopy);
		  //_uart_print(0,1,strSend);

          if (iPrinted>=PrintCopy){
    bc62:	90 91 8b 02 	lds	r25, 0x028B
    bc66:	80 91 8a 02 	lds	r24, 0x028A
    bc6a:	98 17       	cp	r25, r24
    bc6c:	10 f0       	brcs	.+4      	; 0xbc72 <PrintIdle+0xe06>
		      stPrintIdle=piFinishPrintIdle;
    bc6e:	84 e1       	ldi	r24, 0x14	; 20
    bc70:	05 c0       	rjmp	.+10     	; 0xbc7c <PrintIdle+0xe10>
			  }
		  else {CarriegeReturn();
    bc72:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		        CarriegeReturn();
    bc76:	0e 94 17 4d 	call	0x9a2e	; 0x9a2e <CarriegeReturn>
		        stPrintIdle=piInit;
    bc7a:	81 e0       	ldi	r24, 0x01	; 1
    bc7c:	80 93 c6 02 	sts	0x02C6, r24
		       }
		  PaperCut();
    bc80:	0e 94 be 4d 	call	0x9b7c	; 0x9b7c <PaperCut>
    bc84:	16 c0       	rjmp	.+44     	; 0xbcb2 <PrintIdle+0xe46>
	      break;
     case piFinishPrintIdle:	      
	      switch(IFType){
    bc86:	80 91 10 01 	lds	r24, 0x0110
    bc8a:	81 30       	cpi	r24, 0x01	; 1
    bc8c:	19 f0       	breq	.+6      	; 0xbc94 <PrintIdle+0xe28>
    bc8e:	82 30       	cpi	r24, 0x02	; 2
    bc90:	61 f4       	brne	.+24     	; 0xbcaa <PrintIdle+0xe3e>
    bc92:	03 c0       	rjmp	.+6      	; 0xbc9a <PrintIdle+0xe2e>
		  case IT_SLAVE:
		       sendMessage04();
    bc94:	0e 94 3c 54 	call	0xa878	; 0xa878 <sendMessage04>
    bc98:	08 c0       	rjmp	.+16     	; 0xbcaa <PrintIdle+0xe3e>
		       break;
		  case IT_STANDALONE:
		  
		       UpdateStandaloneStatus((atoi(strFIP_ID)&0x0F),PS_PRINTED);
    bc9a:	86 e8       	ldi	r24, 0x86	; 134
    bc9c:	99 e0       	ldi	r25, 0x09	; 9
    bc9e:	0e 94 3d b5 	call	0x16a7a	; 0x16a7a <atoi>
    bca2:	8f 70       	andi	r24, 0x0F	; 15
    bca4:	61 e1       	ldi	r22, 0x11	; 17
    bca6:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <UpdateStandaloneStatus>
			   //strPumpStatus[FIPAddr]=GetPumpStatusLabel(PUMP_OFF);			   
			   //IsNewPumpStatus=True;//UpdateDisplay

		       break;
		  }
		  IsBusyIdlePrinting=False;
    bcaa:	10 92 c8 01 	sts	0x01C8, r1
          stPrintIdle=piIdle;
    bcae:	10 92 c6 02 	sts	0x02C6, r1
	      break;	 
	 }
}
    bcb2:	df 91       	pop	r29
    bcb4:	cf 91       	pop	r28
    bcb6:	08 95       	ret

0000bcb8 <systemPrinting>:
     

}

void systemPrinting(){
	 FreePrinting();
    bcb8:	0e 94 a0 54 	call	0xa940	; 0xa940 <FreePrinting>
	 PrintIdle();
    bcbc:	0e 94 36 57 	call	0xae6c	; 0xae6c <PrintIdle>
}
    bcc0:	08 95       	ret

0000bcc2 <procMessage11>:
}




void procMessage11(){
    bcc2:	af 92       	push	r10
    bcc4:	bf 92       	push	r11
    bcc6:	cf 92       	push	r12
    bcc8:	df 92       	push	r13
    bcca:	ef 92       	push	r14
    bccc:	ff 92       	push	r15
    bcce:	0f 93       	push	r16
    bcd0:	1f 93       	push	r17
    bcd2:	df 93       	push	r29
    bcd4:	cf 93       	push	r28
    bcd6:	cd b7       	in	r28, 0x3d	; 61
    bcd8:	de b7       	in	r29, 0x3e	; 62
    bcda:	c5 55       	subi	r28, 0x55	; 85
    bcdc:	d0 40       	sbci	r29, 0x00	; 0
    bcde:	0f b6       	in	r0, 0x3f	; 63
    bce0:	f8 94       	cli
    bce2:	de bf       	out	0x3e, r29	; 62
    bce4:	0f be       	out	0x3f, r0	; 63
    bce6:	cd bf       	out	0x3d, r28	; 61
    bce8:	20 e0       	ldi	r18, 0x00	; 0
    bcea:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bcec:	ae 01       	movw	r20, r28
    bcee:	46 5f       	subi	r20, 0xF6	; 246
    bcf0:	5f 4f       	sbci	r21, 0xFF	; 255
    bcf2:	fa 01       	movw	r30, r20
    bcf4:	e2 0f       	add	r30, r18
    bcf6:	f3 1f       	adc	r31, r19
    bcf8:	d9 01       	movw	r26, r18
    bcfa:	ad 57       	subi	r26, 0x7D	; 125
    bcfc:	b3 4f       	sbci	r27, 0xF3	; 243
    bcfe:	9b 96       	adiw	r26, 0x2b	; 43
    bd00:	8c 91       	ld	r24, X
    bd02:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd04:	2f 5f       	subi	r18, 0xFF	; 255
    bd06:	3f 4f       	sbci	r19, 0xFF	; 255
    bd08:	2a 30       	cpi	r18, 0x0A	; 10
    bd0a:	31 05       	cpc	r19, r1
    bd0c:	91 f7       	brne	.-28     	; 0xbcf2 <procMessage11+0x30>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bd0e:	fa 01       	movw	r30, r20
    bd10:	12 86       	std	Z+10, r1	; 0x0a
     char buffHeader[41];
	 char strProductName[13],strProductPrice[9],strTime[12],strDate[10];

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
    bd12:	81 e0       	ldi	r24, 0x01	; 1
    bd14:	ba 01       	movw	r22, r20
    bd16:	0e 94 64 25 	call	0x4ac8	; 0x4ac8 <FormatDate>
    bd1a:	20 e0       	ldi	r18, 0x00	; 0
    bd1c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bd1e:	ae 01       	movw	r20, r28
    bd20:	4c 5e       	subi	r20, 0xEC	; 236
    bd22:	5f 4f       	sbci	r21, 0xFF	; 255
    bd24:	fa 01       	movw	r30, r20
    bd26:	e2 0f       	add	r30, r18
    bd28:	f3 1f       	adc	r31, r19
    bd2a:	d9 01       	movw	r26, r18
    bd2c:	ad 57       	subi	r26, 0x7D	; 125
    bd2e:	b3 4f       	sbci	r27, 0xF3	; 243
    bd30:	d6 96       	adiw	r26, 0x36	; 54
    bd32:	8c 91       	ld	r24, X
    bd34:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd36:	2f 5f       	subi	r18, 0xFF	; 255
    bd38:	3f 4f       	sbci	r19, 0xFF	; 255
    bd3a:	28 30       	cpi	r18, 0x08	; 8
    bd3c:	31 05       	cpc	r19, r1
    bd3e:	91 f7       	brne	.-28     	; 0xbd24 <procMessage11+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bd40:	1c 8e       	std	Y+28, r1	; 0x1c

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
	 StrPosCopy(rcv_trans,strTime,54,8);
	 _datetime(_DATETIME_WRITE,strDate,strTime);
    bd42:	81 e0       	ldi	r24, 0x01	; 1
    bd44:	be 01       	movw	r22, r28
    bd46:	66 5f       	subi	r22, 0xF6	; 246
    bd48:	7f 4f       	sbci	r23, 0xFF	; 255
    bd4a:	0e 94 c9 b2 	call	0x16592	; 0x16592 <_datetime>
	  
     clearString(buffHeader);
    bd4e:	8e 01       	movw	r16, r28
    bd50:	03 5d       	subi	r16, 0xD3	; 211
    bd52:	1f 4f       	sbci	r17, 0xFF	; 255
    bd54:	c8 01       	movw	r24, r16
    bd56:	0e 94 1f 27 	call	0x4e3e	; 0x4e3e <clearString>
    bd5a:	20 e0       	ldi	r18, 0x00	; 0
    bd5c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bd5e:	f8 01       	movw	r30, r16
    bd60:	e2 0f       	add	r30, r18
    bd62:	f3 1f       	adc	r31, r19
    bd64:	d9 01       	movw	r26, r18
    bd66:	ad 57       	subi	r26, 0x7D	; 125
    bd68:	b3 4f       	sbci	r27, 0xF3	; 243
    bd6a:	de 96       	adiw	r26, 0x3e	; 62
    bd6c:	8c 91       	ld	r24, X
    bd6e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd70:	2f 5f       	subi	r18, 0xFF	; 255
    bd72:	3f 4f       	sbci	r19, 0xFF	; 255
    bd74:	28 32       	cpi	r18, 0x28	; 40
    bd76:	31 05       	cpc	r19, r1
    bd78:	91 f7       	brne	.-28     	; 0xbd5e <procMessage11+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bd7a:	fe 01       	movw	r30, r28
    bd7c:	eb 5a       	subi	r30, 0xAB	; 171
    bd7e:	ff 4f       	sbci	r31, 0xFF	; 255
    bd80:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    bd82:	87 e2       	ldi	r24, 0x27	; 39
    bd84:	92 e0       	ldi	r25, 0x02	; 2
    bd86:	b8 01       	movw	r22, r16
    bd88:	48 e2       	ldi	r20, 0x28	; 40
    bd8a:	50 e0       	ldi	r21, 0x00	; 0
    bd8c:	20 e0       	ldi	r18, 0x00	; 0
    bd8e:	33 e1       	ldi	r19, 0x13	; 19
    bd90:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    bd94:	20 e0       	ldi	r18, 0x00	; 0
    bd96:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bd98:	be 01       	movw	r22, r28
    bd9a:	63 5d       	subi	r22, 0xD3	; 211
    bd9c:	7f 4f       	sbci	r23, 0xFF	; 255
    bd9e:	fb 01       	movw	r30, r22
    bda0:	e2 0f       	add	r30, r18
    bda2:	f3 1f       	adc	r31, r19
    bda4:	d9 01       	movw	r26, r18
    bda6:	a7 51       	subi	r26, 0x17	; 23
    bda8:	b3 4f       	sbci	r27, 0xF3	; 243
    bdaa:	8c 91       	ld	r24, X
    bdac:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bdae:	2f 5f       	subi	r18, 0xFF	; 255
    bdb0:	3f 4f       	sbci	r19, 0xFF	; 255
    bdb2:	28 32       	cpi	r18, 0x28	; 40
    bdb4:	31 05       	cpc	r19, r1
    bdb6:	99 f7       	brne	.-26     	; 0xbd9e <procMessage11+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bdb8:	fe 01       	movw	r30, r28
    bdba:	eb 5a       	subi	r30, 0xAB	; 171
    bdbc:	ff 4f       	sbci	r31, 0xFF	; 255
    bdbe:	10 82       	st	Z, r1
    bdc0:	80 e5       	ldi	r24, 0x50	; 80
    bdc2:	92 e0       	ldi	r25, 0x02	; 2
    bdc4:	48 e2       	ldi	r20, 0x28	; 40
    bdc6:	50 e0       	ldi	r21, 0x00	; 0
    bdc8:	20 e0       	ldi	r18, 0x00	; 0
    bdca:	33 e1       	ldi	r19, 0x13	; 19
    bdcc:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    bdd0:	20 e0       	ldi	r18, 0x00	; 0
    bdd2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bdd4:	be 01       	movw	r22, r28
    bdd6:	63 5d       	subi	r22, 0xD3	; 211
    bdd8:	7f 4f       	sbci	r23, 0xFF	; 255
    bdda:	fb 01       	movw	r30, r22
    bddc:	e2 0f       	add	r30, r18
    bdde:	f3 1f       	adc	r31, r19
    bde0:	d9 01       	movw	r26, r18
    bde2:	af 5e       	subi	r26, 0xEF	; 239
    bde4:	b2 4f       	sbci	r27, 0xF2	; 242
    bde6:	8c 91       	ld	r24, X
    bde8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bdea:	2f 5f       	subi	r18, 0xFF	; 255
    bdec:	3f 4f       	sbci	r19, 0xFF	; 255
    bdee:	28 32       	cpi	r18, 0x28	; 40
    bdf0:	31 05       	cpc	r19, r1
    bdf2:	99 f7       	brne	.-26     	; 0xbdda <procMessage11+0x118>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bdf4:	fe 01       	movw	r30, r28
    bdf6:	eb 5a       	subi	r30, 0xAB	; 171
    bdf8:	ff 4f       	sbci	r31, 0xFF	; 255
    bdfa:	10 82       	st	Z, r1
    bdfc:	89 e7       	ldi	r24, 0x79	; 121
    bdfe:	92 e0       	ldi	r25, 0x02	; 2
    be00:	48 e2       	ldi	r20, 0x28	; 40
    be02:	50 e0       	ldi	r21, 0x00	; 0
    be04:	20 e0       	ldi	r18, 0x00	; 0
    be06:	33 e1       	ldi	r19, 0x13	; 19
    be08:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    be0c:	20 e0       	ldi	r18, 0x00	; 0
    be0e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    be10:	be 01       	movw	r22, r28
    be12:	63 5d       	subi	r22, 0xD3	; 211
    be14:	7f 4f       	sbci	r23, 0xFF	; 255
    be16:	fb 01       	movw	r30, r22
    be18:	e2 0f       	add	r30, r18
    be1a:	f3 1f       	adc	r31, r19
    be1c:	d9 01       	movw	r26, r18
    be1e:	a7 5c       	subi	r26, 0xC7	; 199
    be20:	b2 4f       	sbci	r27, 0xF2	; 242
    be22:	8c 91       	ld	r24, X
    be24:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    be26:	2f 5f       	subi	r18, 0xFF	; 255
    be28:	3f 4f       	sbci	r19, 0xFF	; 255
    be2a:	28 32       	cpi	r18, 0x28	; 40
    be2c:	31 05       	cpc	r19, r1
    be2e:	99 f7       	brne	.-26     	; 0xbe16 <procMessage11+0x154>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    be30:	fe 01       	movw	r30, r28
    be32:	eb 5a       	subi	r30, 0xAB	; 171
    be34:	ff 4f       	sbci	r31, 0xFF	; 255
    be36:	10 82       	st	Z, r1
    be38:	82 ea       	ldi	r24, 0xA2	; 162
    be3a:	92 e0       	ldi	r25, 0x02	; 2
    be3c:	48 e2       	ldi	r20, 0x28	; 40
    be3e:	50 e0       	ldi	r21, 0x00	; 0
    be40:	20 e0       	ldi	r18, 0x00	; 0
    be42:	33 e1       	ldi	r19, 0x13	; 19
    be44:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    be48:	20 e0       	ldi	r18, 0x00	; 0
    be4a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    be4c:	be 01       	movw	r22, r28
    be4e:	63 5d       	subi	r22, 0xD3	; 211
    be50:	7f 4f       	sbci	r23, 0xFF	; 255
    be52:	fb 01       	movw	r30, r22
    be54:	e2 0f       	add	r30, r18
    be56:	f3 1f       	adc	r31, r19
    be58:	d9 01       	movw	r26, r18
    be5a:	af 59       	subi	r26, 0x9F	; 159
    be5c:	b2 4f       	sbci	r27, 0xF2	; 242
    be5e:	8c 91       	ld	r24, X
    be60:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    be62:	2f 5f       	subi	r18, 0xFF	; 255
    be64:	3f 4f       	sbci	r19, 0xFF	; 255
    be66:	28 32       	cpi	r18, 0x28	; 40
    be68:	31 05       	cpc	r19, r1
    be6a:	99 f7       	brne	.-26     	; 0xbe52 <procMessage11+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    be6c:	fe 01       	movw	r30, r28
    be6e:	eb 5a       	subi	r30, 0xAB	; 171
    be70:	ff 4f       	sbci	r31, 0xFF	; 255
    be72:	10 82       	st	Z, r1
    be74:	8b ec       	ldi	r24, 0xCB	; 203
    be76:	92 e0       	ldi	r25, 0x02	; 2
    be78:	48 e2       	ldi	r20, 0x28	; 40
    be7a:	50 e0       	ldi	r21, 0x00	; 0
    be7c:	20 e0       	ldi	r18, 0x00	; 0
    be7e:	33 e1       	ldi	r19, 0x13	; 19
    be80:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    be84:	20 e0       	ldi	r18, 0x00	; 0
    be86:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    be88:	be 01       	movw	r22, r28
    be8a:	63 5d       	subi	r22, 0xD3	; 211
    be8c:	7f 4f       	sbci	r23, 0xFF	; 255
    be8e:	fb 01       	movw	r30, r22
    be90:	e2 0f       	add	r30, r18
    be92:	f3 1f       	adc	r31, r19
    be94:	d9 01       	movw	r26, r18
    be96:	a7 57       	subi	r26, 0x77	; 119
    be98:	b2 4f       	sbci	r27, 0xF2	; 242
    be9a:	8c 91       	ld	r24, X
    be9c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    be9e:	2f 5f       	subi	r18, 0xFF	; 255
    bea0:	3f 4f       	sbci	r19, 0xFF	; 255
    bea2:	28 32       	cpi	r18, 0x28	; 40
    bea4:	31 05       	cpc	r19, r1
    bea6:	99 f7       	brne	.-26     	; 0xbe8e <procMessage11+0x1cc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bea8:	fe 01       	movw	r30, r28
    beaa:	eb 5a       	subi	r30, 0xAB	; 171
    beac:	ff 4f       	sbci	r31, 0xFF	; 255
    beae:	10 82       	st	Z, r1
    beb0:	84 ef       	ldi	r24, 0xF4	; 244
    beb2:	92 e0       	ldi	r25, 0x02	; 2
    beb4:	48 e2       	ldi	r20, 0x28	; 40
    beb6:	50 e0       	ldi	r21, 0x00	; 0
    beb8:	20 e0       	ldi	r18, 0x00	; 0
    beba:	33 e1       	ldi	r19, 0x13	; 19
    bebc:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    bec0:	20 e0       	ldi	r18, 0x00	; 0
    bec2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bec4:	be 01       	movw	r22, r28
    bec6:	63 5d       	subi	r22, 0xD3	; 211
    bec8:	7f 4f       	sbci	r23, 0xFF	; 255
    beca:	fb 01       	movw	r30, r22
    becc:	e2 0f       	add	r30, r18
    bece:	f3 1f       	adc	r31, r19
    bed0:	d9 01       	movw	r26, r18
    bed2:	af 54       	subi	r26, 0x4F	; 79
    bed4:	b2 4f       	sbci	r27, 0xF2	; 242
    bed6:	8c 91       	ld	r24, X
    bed8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    beda:	2f 5f       	subi	r18, 0xFF	; 255
    bedc:	3f 4f       	sbci	r19, 0xFF	; 255
    bede:	28 32       	cpi	r18, 0x28	; 40
    bee0:	31 05       	cpc	r19, r1
    bee2:	99 f7       	brne	.-26     	; 0xbeca <procMessage11+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bee4:	fe 01       	movw	r30, r28
    bee6:	eb 5a       	subi	r30, 0xAB	; 171
    bee8:	ff 4f       	sbci	r31, 0xFF	; 255
    beea:	10 82       	st	Z, r1
    beec:	8d e1       	ldi	r24, 0x1D	; 29
    beee:	93 e0       	ldi	r25, 0x03	; 3
    bef0:	48 e2       	ldi	r20, 0x28	; 40
    bef2:	50 e0       	ldi	r21, 0x00	; 0
    bef4:	20 e0       	ldi	r18, 0x00	; 0
    bef6:	33 e1       	ldi	r19, 0x13	; 19
    bef8:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    befc:	20 e0       	ldi	r18, 0x00	; 0
    befe:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bf00:	be 01       	movw	r22, r28
    bf02:	63 5d       	subi	r22, 0xD3	; 211
    bf04:	7f 4f       	sbci	r23, 0xFF	; 255
    bf06:	fb 01       	movw	r30, r22
    bf08:	e2 0f       	add	r30, r18
    bf0a:	f3 1f       	adc	r31, r19
    bf0c:	d9 01       	movw	r26, r18
    bf0e:	a7 52       	subi	r26, 0x27	; 39
    bf10:	b2 4f       	sbci	r27, 0xF2	; 242
    bf12:	8c 91       	ld	r24, X
    bf14:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bf16:	2f 5f       	subi	r18, 0xFF	; 255
    bf18:	3f 4f       	sbci	r19, 0xFF	; 255
    bf1a:	28 32       	cpi	r18, 0x28	; 40
    bf1c:	31 05       	cpc	r19, r1
    bf1e:	99 f7       	brne	.-26     	; 0xbf06 <procMessage11+0x244>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bf20:	fe 01       	movw	r30, r28
    bf22:	eb 5a       	subi	r30, 0xAB	; 171
    bf24:	ff 4f       	sbci	r31, 0xFF	; 255
    bf26:	10 82       	st	Z, r1
    bf28:	86 e4       	ldi	r24, 0x46	; 70
    bf2a:	93 e0       	ldi	r25, 0x03	; 3
    bf2c:	48 e2       	ldi	r20, 0x28	; 40
    bf2e:	50 e0       	ldi	r21, 0x00	; 0
    bf30:	20 e0       	ldi	r18, 0x00	; 0
    bf32:	33 e1       	ldi	r19, 0x13	; 19
    bf34:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    bf38:	20 e0       	ldi	r18, 0x00	; 0
    bf3a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bf3c:	be 01       	movw	r22, r28
    bf3e:	63 5d       	subi	r22, 0xD3	; 211
    bf40:	7f 4f       	sbci	r23, 0xFF	; 255
    bf42:	fb 01       	movw	r30, r22
    bf44:	e2 0f       	add	r30, r18
    bf46:	f3 1f       	adc	r31, r19
    bf48:	d9 01       	movw	r26, r18
    bf4a:	af 5f       	subi	r26, 0xFF	; 255
    bf4c:	b1 4f       	sbci	r27, 0xF1	; 241
    bf4e:	8c 91       	ld	r24, X
    bf50:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bf52:	2f 5f       	subi	r18, 0xFF	; 255
    bf54:	3f 4f       	sbci	r19, 0xFF	; 255
    bf56:	28 32       	cpi	r18, 0x28	; 40
    bf58:	31 05       	cpc	r19, r1
    bf5a:	99 f7       	brne	.-26     	; 0xbf42 <procMessage11+0x280>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bf5c:	fe 01       	movw	r30, r28
    bf5e:	eb 5a       	subi	r30, 0xAB	; 171
    bf60:	ff 4f       	sbci	r31, 0xFF	; 255
    bf62:	10 82       	st	Z, r1
    bf64:	8f e6       	ldi	r24, 0x6F	; 111
    bf66:	93 e0       	ldi	r25, 0x03	; 3
    bf68:	48 e2       	ldi	r20, 0x28	; 40
    bf6a:	50 e0       	ldi	r21, 0x00	; 0
    bf6c:	20 e0       	ldi	r18, 0x00	; 0
    bf6e:	33 e1       	ldi	r19, 0x13	; 19
    bf70:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    bf74:	20 e0       	ldi	r18, 0x00	; 0
    bf76:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bf78:	be 01       	movw	r22, r28
    bf7a:	63 5d       	subi	r22, 0xD3	; 211
    bf7c:	7f 4f       	sbci	r23, 0xFF	; 255
    bf7e:	fb 01       	movw	r30, r22
    bf80:	e2 0f       	add	r30, r18
    bf82:	f3 1f       	adc	r31, r19
    bf84:	d9 01       	movw	r26, r18
    bf86:	a7 5d       	subi	r26, 0xD7	; 215
    bf88:	b1 4f       	sbci	r27, 0xF1	; 241
    bf8a:	8c 91       	ld	r24, X
    bf8c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bf8e:	2f 5f       	subi	r18, 0xFF	; 255
    bf90:	3f 4f       	sbci	r19, 0xFF	; 255
    bf92:	28 32       	cpi	r18, 0x28	; 40
    bf94:	31 05       	cpc	r19, r1
    bf96:	99 f7       	brne	.-26     	; 0xbf7e <procMessage11+0x2bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bf98:	fe 01       	movw	r30, r28
    bf9a:	eb 5a       	subi	r30, 0xAB	; 171
    bf9c:	ff 4f       	sbci	r31, 0xFF	; 255
    bf9e:	10 82       	st	Z, r1
    bfa0:	88 e9       	ldi	r24, 0x98	; 152
    bfa2:	93 e0       	ldi	r25, 0x03	; 3
    bfa4:	48 e2       	ldi	r20, 0x28	; 40
    bfa6:	50 e0       	ldi	r21, 0x00	; 0
    bfa8:	20 e0       	ldi	r18, 0x00	; 0
    bfaa:	33 e1       	ldi	r19, 0x13	; 19
    bfac:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    bfb0:	0b eb       	ldi	r16, 0xBB	; 187
    bfb2:	10 e0       	ldi	r17, 0x00	; 0
    bfb4:	69 e6       	ldi	r22, 0x69	; 105
    bfb6:	e6 2e       	mov	r14, r22
    bfb8:	6e e0       	ldi	r22, 0x0E	; 14
    bfba:	f6 2e       	mov	r15, r22
    bfbc:	50 e2       	ldi	r21, 0x20	; 32
    bfbe:	c5 2e       	mov	r12, r21
    bfc0:	d1 2c       	mov	r13, r1
    bfc2:	cc 0e       	add	r12, r28
    bfc4:	dd 1e       	adc	r13, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bfc6:	4c e2       	ldi	r20, 0x2C	; 44
    bfc8:	a4 2e       	mov	r10, r20
    bfca:	b1 2c       	mov	r11, r1
    bfcc:	ac 0e       	add	r10, r28
    bfce:	bd 1e       	adc	r11, r29
    bfd0:	f6 01       	movw	r30, r12
    bfd2:	d7 01       	movw	r26, r14
	    Dest[i]=Source[IdxSource+i];
    bfd4:	8d 91       	ld	r24, X+
    bfd6:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bfd8:	ea 15       	cp	r30, r10
    bfda:	fb 05       	cpc	r31, r11
    bfdc:	d9 f7       	brne	.-10     	; 0xbfd4 <procMessage11+0x312>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bfde:	1c a6       	std	Y+44, r1	; 0x2c
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
    bfe0:	c6 01       	movw	r24, r12
    bfe2:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
    bfe6:	c8 01       	movw	r24, r16
    bfe8:	b6 01       	movw	r22, r12
    bfea:	4c e0       	ldi	r20, 0x0C	; 12
    bfec:	50 e0       	ldi	r21, 0x00	; 0
    bfee:	20 e0       	ldi	r18, 0x00	; 0
    bff0:	33 e1       	ldi	r19, 0x13	; 19
    bff2:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    bff6:	03 5f       	subi	r16, 0xF3	; 243
    bff8:	1f 4f       	sbci	r17, 0xFF	; 255
    bffa:	8c e0       	ldi	r24, 0x0C	; 12
    bffc:	90 e0       	ldi	r25, 0x00	; 0
    bffe:	e8 0e       	add	r14, r24
    c000:	f9 1e       	adc	r15, r25
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    c002:	91 e0       	ldi	r25, 0x01	; 1
    c004:	09 30       	cpi	r16, 0x09	; 9
    c006:	19 07       	cpc	r17, r25
    c008:	19 f7       	brne	.-58     	; 0xbfd0 <procMessage11+0x30e>
    c00a:	05 e8       	ldi	r16, 0x85	; 133
    c00c:	10 e0       	ldi	r17, 0x00	; 0
    c00e:	31 eb       	ldi	r19, 0xB1	; 177
    c010:	e3 2e       	mov	r14, r19
    c012:	3e e0       	ldi	r19, 0x0E	; 14
    c014:	f3 2e       	mov	r15, r19
    c016:	6e 01       	movw	r12, r28
    c018:	08 94       	sec
    c01a:	c1 1c       	adc	r12, r1
    c01c:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c01e:	29 e0       	ldi	r18, 0x09	; 9
    c020:	a2 2e       	mov	r10, r18
    c022:	b1 2c       	mov	r11, r1
    c024:	ac 0e       	add	r10, r28
    c026:	bd 1e       	adc	r11, r29
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    c028:	f6 01       	movw	r30, r12
    c02a:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    c02c:	8d 91       	ld	r24, X+
    c02e:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c030:	ea 15       	cp	r30, r10
    c032:	fb 05       	cpc	r31, r11
    c034:	d9 f7       	brne	.-10     	; 0xc02c <procMessage11+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c036:	19 86       	std	Y+9, r1	; 0x09
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
        StrPosCopy(rcv_trans,strProductPrice,(558+(i*8)),8);
		RemSpaceLag(strProductPrice);
    c038:	c6 01       	movw	r24, r12
    c03a:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		RemZeroLead(strProductPrice);
    c03e:	c6 01       	movw	r24, r12
    c040:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
		RemDecimal(strProductPrice);
    c044:	c6 01       	movw	r24, r12
    c046:	0e 94 ad 24 	call	0x495a	; 0x495a <RemDecimal>
    c04a:	c8 01       	movw	r24, r16
    c04c:	b6 01       	movw	r22, r12
    c04e:	48 e0       	ldi	r20, 0x08	; 8
    c050:	50 e0       	ldi	r21, 0x00	; 0
    c052:	20 e0       	ldi	r18, 0x00	; 0
    c054:	33 e1       	ldi	r19, 0x13	; 19
    c056:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
    c05a:	07 5f       	subi	r16, 0xF7	; 247
    c05c:	1f 4f       	sbci	r17, 0xFF	; 255
    c05e:	e8 e0       	ldi	r30, 0x08	; 8
    c060:	f0 e0       	ldi	r31, 0x00	; 0
    c062:	ee 0e       	add	r14, r30
    c064:	ff 1e       	adc	r15, r31
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
    c066:	f0 e0       	ldi	r31, 0x00	; 0
    c068:	0b 3b       	cpi	r16, 0xBB	; 187
    c06a:	1f 07       	cpc	r17, r31
    c06c:	e9 f6       	brne	.-70     	; 0xc028 <procMessage11+0x366>
		RemSpaceLag(strProductPrice);
		RemZeroLead(strProductPrice);
		RemDecimal(strProductPrice);
        eeprom_write_block((const void*) &strProductPrice, (void*) &DefProductPrice[i], 8);
	 }
}
    c06e:	cb 5a       	subi	r28, 0xAB	; 171
    c070:	df 4f       	sbci	r29, 0xFF	; 255
    c072:	0f b6       	in	r0, 0x3f	; 63
    c074:	f8 94       	cli
    c076:	de bf       	out	0x3e, r29	; 62
    c078:	0f be       	out	0x3f, r0	; 63
    c07a:	cd bf       	out	0x3d, r28	; 61
    c07c:	cf 91       	pop	r28
    c07e:	df 91       	pop	r29
    c080:	1f 91       	pop	r17
    c082:	0f 91       	pop	r16
    c084:	ff 90       	pop	r15
    c086:	ef 90       	pop	r14
    c088:	df 90       	pop	r13
    c08a:	cf 90       	pop	r12
    c08c:	bf 90       	pop	r11
    c08e:	af 90       	pop	r10
    c090:	08 95       	ret

0000c092 <FCloseShift>:
	 }
  return Result;
}


char FCloseShift(char ShiftType){//SHIFT_NONE,NEW_SHIFT,CONTINUE_SHIFT
    c092:	df 92       	push	r13
    c094:	ef 92       	push	r14
    c096:	ff 92       	push	r15
    c098:	0f 93       	push	r16
    c09a:	1f 93       	push	r17
    c09c:	df 93       	push	r29
    c09e:	cf 93       	push	r28
    c0a0:	cd b7       	in	r28, 0x3d	; 61
    c0a2:	de b7       	in	r29, 0x3e	; 62
    c0a4:	64 97       	sbiw	r28, 0x14	; 20
    c0a6:	0f b6       	in	r0, 0x3f	; 63
    c0a8:	f8 94       	cli
    c0aa:	de bf       	out	0x3e, r29	; 62
    c0ac:	0f be       	out	0x3f, r0	; 63
    c0ae:	cd bf       	out	0x3d, r28	; 61
    c0b0:	18 2f       	mov	r17, r24
	 char KeyPressed;
	 char FIPAddr;


	 Result=MENU_NONE;
	 switch(stCloseShift){
    c0b2:	80 91 20 03 	lds	r24, 0x0320
    c0b6:	87 30       	cpi	r24, 0x07	; 7
    c0b8:	09 f4       	brne	.+2      	; 0xc0bc <FCloseShift+0x2a>
    c0ba:	a6 c1       	rjmp	.+844    	; 0xc408 <FCloseShift+0x376>
    c0bc:	88 30       	cpi	r24, 0x08	; 8
    c0be:	78 f4       	brcc	.+30     	; 0xc0de <FCloseShift+0x4c>
    c0c0:	84 30       	cpi	r24, 0x04	; 4
    c0c2:	09 f4       	brne	.+2      	; 0xc0c6 <FCloseShift+0x34>
    c0c4:	68 c0       	rjmp	.+208    	; 0xc196 <FCloseShift+0x104>
    c0c6:	85 30       	cpi	r24, 0x05	; 5
    c0c8:	18 f4       	brcc	.+6      	; 0xc0d0 <FCloseShift+0x3e>
    c0ca:	88 23       	and	r24, r24
    c0cc:	c1 f0       	breq	.+48     	; 0xc0fe <FCloseShift+0x6c>
    c0ce:	22 c2       	rjmp	.+1092   	; 0xc514 <FCloseShift+0x482>
    c0d0:	85 30       	cpi	r24, 0x05	; 5
    c0d2:	09 f4       	brne	.+2      	; 0xc0d6 <FCloseShift+0x44>
    c0d4:	a6 c0       	rjmp	.+332    	; 0xc222 <FCloseShift+0x190>
    c0d6:	86 30       	cpi	r24, 0x06	; 6
    c0d8:	09 f0       	breq	.+2      	; 0xc0dc <FCloseShift+0x4a>
    c0da:	1c c2       	rjmp	.+1080   	; 0xc514 <FCloseShift+0x482>
    c0dc:	a8 c0       	rjmp	.+336    	; 0xc22e <FCloseShift+0x19c>
    c0de:	8a 30       	cpi	r24, 0x0A	; 10
    c0e0:	09 f4       	brne	.+2      	; 0xc0e4 <FCloseShift+0x52>
    c0e2:	d6 c1       	rjmp	.+940    	; 0xc490 <FCloseShift+0x3fe>
    c0e4:	8b 30       	cpi	r24, 0x0B	; 11
    c0e6:	20 f4       	brcc	.+8      	; 0xc0f0 <FCloseShift+0x5e>
    c0e8:	88 30       	cpi	r24, 0x08	; 8
    c0ea:	09 f0       	breq	.+2      	; 0xc0ee <FCloseShift+0x5c>
    c0ec:	13 c2       	rjmp	.+1062   	; 0xc514 <FCloseShift+0x482>
    c0ee:	92 c1       	rjmp	.+804    	; 0xc414 <FCloseShift+0x382>
    c0f0:	8b 30       	cpi	r24, 0x0B	; 11
    c0f2:	09 f4       	brne	.+2      	; 0xc0f6 <FCloseShift+0x64>
    c0f4:	0b c2       	rjmp	.+1046   	; 0xc50c <FCloseShift+0x47a>
    c0f6:	8c 30       	cpi	r24, 0x0C	; 12
    c0f8:	09 f0       	breq	.+2      	; 0xc0fc <FCloseShift+0x6a>
    c0fa:	0c c2       	rjmp	.+1048   	; 0xc514 <FCloseShift+0x482>
    c0fc:	d2 c1       	rjmp	.+932    	; 0xc4a2 <FCloseShift+0x410>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c0fe:	e1 99       	sbic	0x1c, 1	; 28
    c100:	fe cf       	rjmp	.-4      	; 0xc0fe <FCloseShift+0x6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c102:	89 e4       	ldi	r24, 0x49	; 73
    c104:	91 e0       	ldi	r25, 0x01	; 1
    c106:	9f bb       	out	0x1f, r25	; 31
    c108:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c10a:	e0 9a       	sbi	0x1c, 0	; 28
    c10c:	8d b3       	in	r24, 0x1d	; 29
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
    c10e:	80 93 60 01 	sts	0x0160, r24
		  IsPumpBusy=False;
    c112:	10 92 1f 03 	sts	0x031F, r1
    c116:	ff 24       	eor	r15, r15
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
    c118:	dd 24       	eor	r13, r13
    c11a:	d3 94       	inc	r13
    c11c:	36 c0       	rjmp	.+108    	; 0xc18a <FCloseShift+0xf8>
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
		       if ((strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_NONE))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_OFF))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_BUSY)))
    c11e:	0f 2d       	mov	r16, r15
    c120:	10 e0       	ldi	r17, 0x00	; 0
    c122:	f8 01       	movw	r30, r16
    c124:	ee 5e       	subi	r30, 0xEE	; 238
    c126:	fe 4f       	sbci	r31, 0xFE	; 254
    c128:	e0 80       	ld	r14, Z
    c12a:	8e e0       	ldi	r24, 0x0E	; 14
    c12c:	0e 94 95 13 	call	0x272a	; 0x272a <GetPumpStatusLabel>
    c130:	e8 16       	cp	r14, r24
    c132:	81 f0       	breq	.+32     	; 0xc154 <FCloseShift+0xc2>
    c134:	86 e0       	ldi	r24, 0x06	; 6
    c136:	0e 94 95 13 	call	0x272a	; 0x272a <GetPumpStatusLabel>
    c13a:	e8 16       	cp	r14, r24
    c13c:	59 f0       	breq	.+22     	; 0xc154 <FCloseShift+0xc2>
    c13e:	89 e0       	ldi	r24, 0x09	; 9
    c140:	0e 94 95 13 	call	0x272a	; 0x272a <GetPumpStatusLabel>
    c144:	e8 16       	cp	r14, r24
    c146:	31 f0       	breq	.+12     	; 0xc154 <FCloseShift+0xc2>
				    UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c148:	8f 2d       	mov	r24, r15
    c14a:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <GetPumpID>
    c14e:	66 e0       	ldi	r22, 0x06	; 6
    c150:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <UpdateStandaloneStatus>
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    c154:	84 e1       	ldi	r24, 0x14	; 20
    c156:	0e 94 95 13 	call	0x272a	; 0x272a <GetPumpStatusLabel>
    c15a:	f8 01       	movw	r30, r16
    c15c:	ee 5e       	subi	r30, 0xEE	; 238
    c15e:	fe 4f       	sbci	r31, 0xFE	; 254
    c160:	90 81       	ld	r25, Z
    c162:	98 17       	cp	r25, r24
    c164:	31 f4       	brne	.+12     	; 0xc172 <FCloseShift+0xe0>
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c166:	8f 2d       	mov	r24, r15
    c168:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <GetPumpID>
    c16c:	66 e0       	ldi	r22, 0x06	; 6
    c16e:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <UpdateStandaloneStatus>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
    c172:	89 e0       	ldi	r24, 0x09	; 9
    c174:	0e 94 95 13 	call	0x272a	; 0x272a <GetPumpStatusLabel>
    c178:	0e 5e       	subi	r16, 0xEE	; 238
    c17a:	1e 4f       	sbci	r17, 0xFE	; 254
    c17c:	d8 01       	movw	r26, r16
    c17e:	9c 91       	ld	r25, X
    c180:	98 17       	cp	r25, r24
    c182:	11 f4       	brne	.+4      	; 0xc188 <FCloseShift+0xf6>
			       IsPumpBusy=True;
    c184:	d0 92 1f 03 	sts	0x031F, r13
	 switch(stCloseShift){
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
    c188:	f3 94       	inc	r15
    c18a:	80 91 60 01 	lds	r24, 0x0160
    c18e:	f8 16       	cp	r15, r24
    c190:	30 f2       	brcs	.-116    	; 0xc11e <FCloseShift+0x8c>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
			   }

          stCloseShift=csSendTotalizerALL;
    c192:	84 e0       	ldi	r24, 0x04	; 4
    c194:	b8 c1       	rjmp	.+880    	; 0xc506 <FCloseShift+0x474>
			  */
	      break;
     case csWaitPumpLocked:	     
	      break;
     case csSendTotalizerALL:
	      lcd_clear();
    c196:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("Totalizer.."));
    c19a:	81 e0       	ldi	r24, 0x01	; 1
    c19c:	61 e0       	ldi	r22, 0x01	; 1
    c19e:	4f e9       	ldi	r20, 0x9F	; 159
    c1a0:	55 e1       	ldi	r21, 0x15	; 21
    c1a2:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  
		  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    c1a6:	00 91 60 01 	lds	r16, 0x0160
    c1aa:	10 e0       	ldi	r17, 0x00	; 0
    c1ac:	82 e1       	ldi	r24, 0x12	; 18
    c1ae:	91 e0       	ldi	r25, 0x01	; 1
    c1b0:	0e 94 f0 30 	call	0x61e0	; 0x61e0 <CountTotalizerSatus>
    c1b4:	00 d0       	rcall	.+0      	; 0xc1b6 <FCloseShift+0x124>
    c1b6:	00 d0       	rcall	.+0      	; 0xc1b8 <FCloseShift+0x126>
    c1b8:	00 d0       	rcall	.+0      	; 0xc1ba <FCloseShift+0x128>
    c1ba:	ed b7       	in	r30, 0x3d	; 61
    c1bc:	fe b7       	in	r31, 0x3e	; 62
    c1be:	31 96       	adiw	r30, 0x01	; 1
    c1c0:	7e 01       	movw	r14, r28
    c1c2:	08 94       	sec
    c1c4:	e1 1c       	adc	r14, r1
    c1c6:	f1 1c       	adc	r15, r1
    c1c8:	ad b7       	in	r26, 0x3d	; 61
    c1ca:	be b7       	in	r27, 0x3e	; 62
    c1cc:	12 96       	adiw	r26, 0x02	; 2
    c1ce:	fc 92       	st	X, r15
    c1d0:	ee 92       	st	-X, r14
    c1d2:	11 97       	sbiw	r26, 0x01	; 1
    c1d4:	21 e9       	ldi	r18, 0x91	; 145
    c1d6:	35 e1       	ldi	r19, 0x15	; 21
    c1d8:	33 83       	std	Z+3, r19	; 0x03
    c1da:	22 83       	std	Z+2, r18	; 0x02
    c1dc:	08 1b       	sub	r16, r24
    c1de:	11 09       	sbc	r17, r1
    c1e0:	15 83       	std	Z+5, r17	; 0x05
    c1e2:	04 83       	std	Z+4, r16	; 0x04
    c1e4:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(2,1,lcdteks);
    c1e8:	ed b7       	in	r30, 0x3d	; 61
    c1ea:	fe b7       	in	r31, 0x3e	; 62
    c1ec:	36 96       	adiw	r30, 0x06	; 6
    c1ee:	0f b6       	in	r0, 0x3f	; 63
    c1f0:	f8 94       	cli
    c1f2:	fe bf       	out	0x3e, r31	; 62
    c1f4:	0f be       	out	0x3f, r0	; 63
    c1f6:	ed bf       	out	0x3d, r30	; 61
    c1f8:	82 e0       	ldi	r24, 0x02	; 2
    c1fa:	61 e0       	ldi	r22, 0x01	; 1
    c1fc:	a7 01       	movw	r20, r14
    c1fe:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>


          IsNewPumpStatus=True;
    c202:	11 e0       	ldi	r17, 0x01	; 1
    c204:	10 93 11 01 	sts	0x0111, r17
		  DisplayPumpStatus(); 
    c208:	0e 94 46 45 	call	0x8a8c	; 0x8a8c <DisplayPumpStatus>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    c20c:	95 e0       	ldi	r25, 0x05	; 5
    c20e:	90 93 8a 07 	sts	0x078A, r25
	 PoolMsg=plMsg;
    c212:	82 e1       	ldi	r24, 0x12	; 18
    c214:	80 93 3c 0f 	sts	0x0F3C, r24
     IsControlPooling=True;
    c218:	10 93 97 01 	sts	0x0197, r17
          IsNewPumpStatus=True;
		  DisplayPumpStatus(); 
		  //SendCommand
	      //SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);          
		  SendPoolingCommand(SC_TOTALIZER,PUMP_ALL);
		  stCloseShift=csDisplayPumpStatus;
    c21c:	90 93 20 03 	sts	0x0320, r25
    c220:	79 c1       	rjmp	.+754    	; 0xc514 <FCloseShift+0x482>
	      break;
     case csDisplayPumpStatus:
		  DisplayPumpStatus(); 
    c222:	0e 94 46 45 	call	0x8a8c	; 0x8a8c <DisplayPumpStatus>
		  TimDisplay=0;         
    c226:	10 92 a7 01 	sts	0x01A7, r1
          stCloseShift=csWaitTotalizerComplete;
    c22a:	86 e0       	ldi	r24, 0x06	; 6
    c22c:	6c c1       	rjmp	.+728    	; 0xc506 <FCloseShift+0x474>
	      break;
     case csWaitTotalizerComplete:
	      KeyPressed=_key_scan(1);
    c22e:	81 e0       	ldi	r24, 0x01	; 1
    c230:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    c234:	d8 2e       	mov	r13, r24
		  if (IsNewPumpStatus==True){
    c236:	80 91 11 01 	lds	r24, 0x0111
    c23a:	81 30       	cpi	r24, 0x01	; 1
    c23c:	89 f5       	brne	.+98     	; 0xc2a0 <FCloseShift+0x20e>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    c23e:	00 91 60 01 	lds	r16, 0x0160
    c242:	10 e0       	ldi	r17, 0x00	; 0
    c244:	82 e1       	ldi	r24, 0x12	; 18
    c246:	91 e0       	ldi	r25, 0x01	; 1
    c248:	0e 94 f0 30 	call	0x61e0	; 0x61e0 <CountTotalizerSatus>
    c24c:	00 d0       	rcall	.+0      	; 0xc24e <FCloseShift+0x1bc>
    c24e:	00 d0       	rcall	.+0      	; 0xc250 <FCloseShift+0x1be>
    c250:	00 d0       	rcall	.+0      	; 0xc252 <FCloseShift+0x1c0>
    c252:	ed b7       	in	r30, 0x3d	; 61
    c254:	fe b7       	in	r31, 0x3e	; 62
    c256:	31 96       	adiw	r30, 0x01	; 1
    c258:	7e 01       	movw	r14, r28
    c25a:	08 94       	sec
    c25c:	e1 1c       	adc	r14, r1
    c25e:	f1 1c       	adc	r15, r1
    c260:	ad b7       	in	r26, 0x3d	; 61
    c262:	be b7       	in	r27, 0x3e	; 62
    c264:	12 96       	adiw	r26, 0x02	; 2
    c266:	fc 92       	st	X, r15
    c268:	ee 92       	st	-X, r14
    c26a:	11 97       	sbiw	r26, 0x01	; 1
    c26c:	23 e8       	ldi	r18, 0x83	; 131
    c26e:	35 e1       	ldi	r19, 0x15	; 21
    c270:	33 83       	std	Z+3, r19	; 0x03
    c272:	22 83       	std	Z+2, r18	; 0x02
    c274:	08 1b       	sub	r16, r24
    c276:	11 09       	sbc	r17, r1
    c278:	15 83       	std	Z+5, r17	; 0x05
    c27a:	04 83       	std	Z+4, r16	; 0x04
    c27c:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			  lcd_print(2,1,lcdteks);
    c280:	ed b7       	in	r30, 0x3d	; 61
    c282:	fe b7       	in	r31, 0x3e	; 62
    c284:	36 96       	adiw	r30, 0x06	; 6
    c286:	0f b6       	in	r0, 0x3f	; 63
    c288:	f8 94       	cli
    c28a:	fe bf       	out	0x3e, r31	; 62
    c28c:	0f be       	out	0x3f, r0	; 63
    c28e:	ed bf       	out	0x3d, r30	; 61
    c290:	82 e0       	ldi	r24, 0x02	; 2
    c292:	61 e0       	ldi	r22, 0x01	; 1
    c294:	a7 01       	movw	r20, r14
    c296:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  	  stCloseShift=csDisplayPumpStatus;	 
    c29a:	85 e0       	ldi	r24, 0x05	; 5
    c29c:	80 93 20 03 	sts	0x0320, r24
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
    c2a0:	82 e1       	ldi	r24, 0x12	; 18
    c2a2:	91 e0       	ldi	r25, 0x01	; 1
    c2a4:	0e 94 f0 30 	call	0x61e0	; 0x61e0 <CountTotalizerSatus>
    c2a8:	90 91 60 01 	lds	r25, 0x0160
    c2ac:	89 17       	cp	r24, r25
    c2ae:	a0 f0       	brcs	.+40     	; 0xc2d8 <FCloseShift+0x246>
    c2b0:	80 91 a7 01 	lds	r24, 0x01A7
    c2b4:	86 30       	cpi	r24, 0x06	; 6
    c2b6:	80 f0       	brcs	.+32     	; 0xc2d8 <FCloseShift+0x246>
    c2b8:	10 e0       	ldi	r17, 0x00	; 0
    c2ba:	07 c0       	rjmp	.+14     	; 0xc2ca <FCloseShift+0x238>
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c2bc:	81 2f       	mov	r24, r17
    c2be:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <GetPumpID>
    c2c2:	66 e0       	ldi	r22, 0x06	; 6
    c2c4:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <UpdateStandaloneStatus>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
			  lcd_print(2,1,lcdteks);
		  	  stCloseShift=csDisplayPumpStatus;	 
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
    c2c8:	1f 5f       	subi	r17, 0xFF	; 255
    c2ca:	80 91 60 01 	lds	r24, 0x0160
    c2ce:	18 17       	cp	r17, r24
    c2d0:	a8 f3       	brcs	.-22     	; 0xc2bc <FCloseShift+0x22a>
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);

		      stCloseShift=csGenerateReport;		      
    c2d2:	88 e0       	ldi	r24, 0x08	; 8
    c2d4:	80 93 20 03 	sts	0x0320, r24
			  }
          //sprintf_P(lcdteks,PSTR("TimSend:%d"),TimDisplay);
		  //lcd_print(3,1,lcdteks);

          if ((TimDisplay>15)&&(IsPumpBusy!=True)){
    c2d8:	80 91 a7 01 	lds	r24, 0x01A7
    c2dc:	80 31       	cpi	r24, 0x10	; 16
    c2de:	08 f4       	brcc	.+2      	; 0xc2e2 <FCloseShift+0x250>
    c2e0:	67 c0       	rjmp	.+206    	; 0xc3b0 <FCloseShift+0x31e>
    c2e2:	80 91 1f 03 	lds	r24, 0x031F
    c2e6:	81 30       	cpi	r24, 0x01	; 1
    c2e8:	09 f4       	brne	.+2      	; 0xc2ec <FCloseShift+0x25a>
    c2ea:	62 c0       	rjmp	.+196    	; 0xc3b0 <FCloseShift+0x31e>
		      if(CountNoPumpSatus(strPumpStatus)>=eeprom_read_byte(&DefActivePump)){
    c2ec:	82 e1       	ldi	r24, 0x12	; 18
    c2ee:	91 e0       	ldi	r25, 0x01	; 1
    c2f0:	0e 94 91 16 	call	0x2d22	; 0x2d22 <CountNoPumpSatus>
    c2f4:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c2f6:	e1 99       	sbic	0x1c, 1	; 28
    c2f8:	fe cf       	rjmp	.-4      	; 0xc2f6 <FCloseShift+0x264>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c2fa:	89 e4       	ldi	r24, 0x49	; 73
    c2fc:	91 e0       	ldi	r25, 0x01	; 1
    c2fe:	9f bb       	out	0x1f, r25	; 31
    c300:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c302:	e0 9a       	sbi	0x1c, 0	; 28
    c304:	8d b3       	in	r24, 0x1d	; 29
    c306:	28 17       	cp	r18, r24
    c308:	08 f4       	brcc	.+2      	; 0xc30c <FCloseShift+0x27a>
    c30a:	52 c0       	rjmp	.+164    	; 0xc3b0 <FCloseShift+0x31e>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
    c30c:	00 91 60 01 	lds	r16, 0x0160
    c310:	10 e0       	ldi	r17, 0x00	; 0
    c312:	82 e1       	ldi	r24, 0x12	; 18
    c314:	91 e0       	ldi	r25, 0x01	; 1
    c316:	0e 94 91 16 	call	0x2d22	; 0x2d22 <CountNoPumpSatus>
    c31a:	00 d0       	rcall	.+0      	; 0xc31c <FCloseShift+0x28a>
    c31c:	00 d0       	rcall	.+0      	; 0xc31e <FCloseShift+0x28c>
    c31e:	00 d0       	rcall	.+0      	; 0xc320 <FCloseShift+0x28e>
    c320:	ed b7       	in	r30, 0x3d	; 61
    c322:	fe b7       	in	r31, 0x3e	; 62
    c324:	31 96       	adiw	r30, 0x01	; 1
    c326:	7e 01       	movw	r14, r28
    c328:	08 94       	sec
    c32a:	e1 1c       	adc	r14, r1
    c32c:	f1 1c       	adc	r15, r1
    c32e:	ad b7       	in	r26, 0x3d	; 61
    c330:	be b7       	in	r27, 0x3e	; 62
    c332:	12 96       	adiw	r26, 0x02	; 2
    c334:	fc 92       	st	X, r15
    c336:	ee 92       	st	-X, r14
    c338:	11 97       	sbiw	r26, 0x01	; 1
    c33a:	2f e6       	ldi	r18, 0x6F	; 111
    c33c:	35 e1       	ldi	r19, 0x15	; 21
    c33e:	33 83       	std	Z+3, r19	; 0x03
    c340:	22 83       	std	Z+2, r18	; 0x02
    c342:	08 1b       	sub	r16, r24
    c344:	11 09       	sbc	r17, r1
    c346:	15 83       	std	Z+5, r17	; 0x05
    c348:	04 83       	std	Z+4, r16	; 0x04
    c34a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    c34e:	ed b7       	in	r30, 0x3d	; 61
    c350:	fe b7       	in	r31, 0x3e	; 62
    c352:	36 96       	adiw	r30, 0x06	; 6
    c354:	0f b6       	in	r0, 0x3f	; 63
    c356:	f8 94       	cli
    c358:	fe bf       	out	0x3e, r31	; 62
    c35a:	0f be       	out	0x3f, r0	; 63
    c35c:	ed bf       	out	0x3d, r30	; 61
    c35e:	83 e0       	ldi	r24, 0x03	; 3
    c360:	61 e0       	ldi	r22, 0x01	; 1
    c362:	a7 01       	movw	r20, r14
    c364:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    c368:	10 e0       	ldi	r17, 0x00	; 0
    c36a:	11 c0       	rjmp	.+34     	; 0xc38e <FCloseShift+0x2fc>
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    c36c:	84 e1       	ldi	r24, 0x14	; 20
    c36e:	0e 94 95 13 	call	0x272a	; 0x272a <GetPumpStatusLabel>
    c372:	e1 2f       	mov	r30, r17
    c374:	f0 e0       	ldi	r31, 0x00	; 0
    c376:	ee 5e       	subi	r30, 0xEE	; 238
    c378:	fe 4f       	sbci	r31, 0xFE	; 254
    c37a:	90 81       	ld	r25, Z
    c37c:	98 17       	cp	r25, r24
    c37e:	31 f4       	brne	.+12     	; 0xc38c <FCloseShift+0x2fa>
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c380:	81 2f       	mov	r24, r17
    c382:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <GetPumpID>
    c386:	66 e0       	ldi	r22, 0x06	; 6
    c388:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <UpdateStandaloneStatus>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
			  lcd_print(3,1,lcdteks);
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
    c38c:	1f 5f       	subi	r17, 0xFF	; 255
    c38e:	80 91 60 01 	lds	r24, 0x0160
    c392:	18 17       	cp	r17, r24
    c394:	58 f3       	brcs	.-42     	; 0xc36c <FCloseShift+0x2da>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c396:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c398:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c39a:	81 e0       	ldi	r24, 0x01	; 1
    c39c:	90 e0       	ldi	r25, 0x00	; 0
    c39e:	90 93 d7 01 	sts	0x01D7, r25
    c3a2:	80 93 d6 01 	sts	0x01D6, r24
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
			  }

			  system_beep(1);
			  TimDisplay=0;
    c3a6:	10 92 a7 01 	sts	0x01A7, r1
			  stCloseShift=csNoPumpFound;		     
    c3aa:	87 e0       	ldi	r24, 0x07	; 7
    c3ac:	80 93 20 03 	sts	0x0320, r24
			  }			  
		  }
		  if (KeyPressed==_KEY_CANCEL){
    c3b0:	f7 ee       	ldi	r31, 0xE7	; 231
    c3b2:	df 16       	cp	r13, r31
    c3b4:	09 f0       	breq	.+2      	; 0xc3b8 <FCloseShift+0x326>
    c3b6:	ae c0       	rjmp	.+348    	; 0xc514 <FCloseShift+0x482>
			  sprintf_P(lcdteks,PSTR("Cancel"));
    c3b8:	00 d0       	rcall	.+0      	; 0xc3ba <FCloseShift+0x328>
    c3ba:	00 d0       	rcall	.+0      	; 0xc3bc <FCloseShift+0x32a>
    c3bc:	8e 01       	movw	r16, r28
    c3be:	0f 5f       	subi	r16, 0xFF	; 255
    c3c0:	1f 4f       	sbci	r17, 0xFF	; 255
    c3c2:	ad b7       	in	r26, 0x3d	; 61
    c3c4:	be b7       	in	r27, 0x3e	; 62
    c3c6:	12 96       	adiw	r26, 0x02	; 2
    c3c8:	1c 93       	st	X, r17
    c3ca:	0e 93       	st	-X, r16
    c3cc:	11 97       	sbiw	r26, 0x01	; 1
    c3ce:	88 e6       	ldi	r24, 0x68	; 104
    c3d0:	95 e1       	ldi	r25, 0x15	; 21
    c3d2:	14 96       	adiw	r26, 0x04	; 4
    c3d4:	9c 93       	st	X, r25
    c3d6:	8e 93       	st	-X, r24
    c3d8:	13 97       	sbiw	r26, 0x03	; 3
    c3da:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    c3de:	0f 90       	pop	r0
    c3e0:	0f 90       	pop	r0
    c3e2:	0f 90       	pop	r0
    c3e4:	0f 90       	pop	r0
    c3e6:	83 e0       	ldi	r24, 0x03	; 3
    c3e8:	61 e0       	ldi	r22, 0x01	; 1
    c3ea:	a8 01       	movw	r20, r16
    c3ec:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c3f0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c3f2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c3f4:	81 e0       	ldi	r24, 0x01	; 1
    c3f6:	90 e0       	ldi	r25, 0x00	; 0
    c3f8:	90 93 d7 01 	sts	0x01D7, r25
    c3fc:	80 93 d6 01 	sts	0x01D6, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
			  sprintf_P(lcdteks,PSTR("Cancel"));
			  lcd_print(3,1,lcdteks);
			  system_beep(1);
			  TimDisplay=0;
    c400:	10 92 a7 01 	sts	0x01A7, r1
			  stCloseShift=csNoPumpFound;		     		  
    c404:	87 e0       	ldi	r24, 0x07	; 7
    c406:	7f c0       	rjmp	.+254    	; 0xc506 <FCloseShift+0x474>
		  }
	      break;
     case csNoPumpFound:
	      if (TimDisplay>TIM_DISPLAY){
    c408:	80 91 a7 01 	lds	r24, 0x01A7
    c40c:	8b 30       	cpi	r24, 0x0B	; 11
    c40e:	08 f4       	brcc	.+2      	; 0xc412 <FCloseShift+0x380>
    c410:	81 c0       	rjmp	.+258    	; 0xc514 <FCloseShift+0x482>
    c412:	78 c0       	rjmp	.+240    	; 0xc504 <FCloseShift+0x472>
		      stCloseShift=csFinishCloseShift;
		  }	      
	      break;
     case csGenerateReport:
		  lcd_printf(1,1,PSTR("Printing Totalizer"));
    c414:	81 e0       	ldi	r24, 0x01	; 1
    c416:	61 e0       	ldi	r22, 0x01	; 1
    c418:	45 e5       	ldi	r20, 0x55	; 85
    c41a:	55 e1       	ldi	r21, 0x15	; 21
    c41c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          _datetime(0, strSystemDate, strSystemTime);
    c420:	0a e9       	ldi	r16, 0x9A	; 154
    c422:	15 e0       	ldi	r17, 0x05	; 5
    c424:	7d e1       	ldi	r23, 0x1D	; 29
    c426:	e7 2e       	mov	r14, r23
    c428:	7c e0       	ldi	r23, 0x0C	; 12
    c42a:	f7 2e       	mov	r15, r23
    c42c:	80 e0       	ldi	r24, 0x00	; 0
    c42e:	b8 01       	movw	r22, r16
    c430:	a7 01       	movw	r20, r14
    c432:	0e 94 c9 b2 	call	0x16592	; 0x16592 <_datetime>
		  sprintf_P(CurrentShiftDateTime,PSTR("%s %s"),strSystemDate,strSystemTime);
    c436:	ed b7       	in	r30, 0x3d	; 61
    c438:	fe b7       	in	r31, 0x3e	; 62
    c43a:	38 97       	sbiw	r30, 0x08	; 8
    c43c:	0f b6       	in	r0, 0x3f	; 63
    c43e:	f8 94       	cli
    c440:	fe bf       	out	0x3e, r31	; 62
    c442:	0f be       	out	0x3f, r0	; 63
    c444:	ed bf       	out	0x3d, r30	; 61
    c446:	31 96       	adiw	r30, 0x01	; 1
    c448:	81 e7       	ldi	r24, 0x71	; 113
    c44a:	99 e0       	ldi	r25, 0x09	; 9
    c44c:	ad b7       	in	r26, 0x3d	; 61
    c44e:	be b7       	in	r27, 0x3e	; 62
    c450:	12 96       	adiw	r26, 0x02	; 2
    c452:	9c 93       	st	X, r25
    c454:	8e 93       	st	-X, r24
    c456:	11 97       	sbiw	r26, 0x01	; 1
    c458:	8f e4       	ldi	r24, 0x4F	; 79
    c45a:	95 e1       	ldi	r25, 0x15	; 21
    c45c:	93 83       	std	Z+3, r25	; 0x03
    c45e:	82 83       	std	Z+2, r24	; 0x02
    c460:	15 83       	std	Z+5, r17	; 0x05
    c462:	04 83       	std	Z+4, r16	; 0x04
    c464:	f7 82       	std	Z+7, r15	; 0x07
    c466:	e6 82       	std	Z+6, r14	; 0x06
    c468:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  IsGenerateReport=True;
    c46c:	81 e0       	ldi	r24, 0x01	; 1
    c46e:	80 93 99 01 	sts	0x0199, r24
		  IsFinishPrintingTotalizer=False;
    c472:	10 92 9a 01 	sts	0x019A, r1
		  stCloseShift=csWaitPrintTotalizerComplete;
    c476:	8a e0       	ldi	r24, 0x0A	; 10
    c478:	80 93 20 03 	sts	0x0320, r24
    c47c:	80 e0       	ldi	r24, 0x00	; 0
    c47e:	ed b7       	in	r30, 0x3d	; 61
    c480:	fe b7       	in	r31, 0x3e	; 62
    c482:	38 96       	adiw	r30, 0x08	; 8
    c484:	0f b6       	in	r0, 0x3f	; 63
    c486:	f8 94       	cli
    c488:	fe bf       	out	0x3e, r31	; 62
    c48a:	0f be       	out	0x3f, r0	; 63
    c48c:	ed bf       	out	0x3d, r30	; 61
    c48e:	43 c0       	rjmp	.+134    	; 0xc516 <FCloseShift+0x484>
	      break;
     case csWaitTotalizerALL:
	      break;
     case csWaitPrintTotalizerComplete:
	      if (IsFinishPrintingTotalizer==True){
    c490:	80 91 9a 01 	lds	r24, 0x019A
    c494:	81 30       	cpi	r24, 0x01	; 1
    c496:	09 f0       	breq	.+2      	; 0xc49a <FCloseShift+0x408>
    c498:	3d c0       	rjmp	.+122    	; 0xc514 <FCloseShift+0x482>
		      IsFinishPrintingTotalizer=False;
    c49a:	10 92 9a 01 	sts	0x019A, r1
		      stCloseShift=csDumpShift;
    c49e:	8c e0       	ldi	r24, 0x0C	; 12
    c4a0:	32 c0       	rjmp	.+100    	; 0xc506 <FCloseShift+0x474>
		  }
	      break;
     case csDumpShift://Increment CurrentShift save Current to Last
		  lcd_printf(1,1,PSTR("Saving ShiftData.. "));
    c4a2:	81 e0       	ldi	r24, 0x01	; 1
    c4a4:	61 e0       	ldi	r22, 0x01	; 1
    c4a6:	4b e3       	ldi	r20, 0x3B	; 59
    c4a8:	55 e1       	ldi	r21, 0x15	; 21
    c4aa:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	      if (ShiftType==CONTINUE_SHIFT)//Shift=Shift+1
    c4ae:	12 30       	cpi	r17, 0x02	; 2
    c4b0:	71 f4       	brne	.+28     	; 0xc4ce <FCloseShift+0x43c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c4b2:	e1 99       	sbic	0x1c, 1	; 28
    c4b4:	fe cf       	rjmp	.-4      	; 0xc4b2 <FCloseShift+0x420>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c4b6:	2f e3       	ldi	r18, 0x3F	; 63
    c4b8:	31 e0       	ldi	r19, 0x01	; 1
    c4ba:	3f bb       	out	0x1f, r19	; 31
    c4bc:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c4be:	e0 9a       	sbi	0x1c, 0	; 28
    c4c0:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c4c2:	e1 99       	sbic	0x1c, 1	; 28
    c4c4:	fe cf       	rjmp	.-4      	; 0xc4c2 <FCloseShift+0x430>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c4c6:	3f bb       	out	0x1f, r19	; 31
    c4c8:	2e bb       	out	0x1e, r18	; 30
		      eeprom_write_byte(&DefShift,eeprom_read_byte(&DefShift)+1);	 
    c4ca:	8f 5f       	subi	r24, 0xFF	; 255
    c4cc:	09 c0       	rjmp	.+18     	; 0xc4e0 <FCloseShift+0x44e>
          else if (ShiftType==NEW_SHIFT)//Shift=1
    c4ce:	11 30       	cpi	r17, 0x01	; 1
    c4d0:	69 f4       	brne	.+26     	; 0xc4ec <FCloseShift+0x45a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c4d2:	e1 99       	sbic	0x1c, 1	; 28
    c4d4:	fe cf       	rjmp	.-4      	; 0xc4d2 <FCloseShift+0x440>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c4d6:	8f e3       	ldi	r24, 0x3F	; 63
    c4d8:	91 e0       	ldi	r25, 0x01	; 1
    c4da:	9f bb       	out	0x1f, r25	; 31
    c4dc:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    c4de:	81 e0       	ldi	r24, 0x01	; 1
    c4e0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    c4e2:	0f b6       	in	r0, 0x3f	; 63
    c4e4:	f8 94       	cli
    c4e6:	e2 9a       	sbi	0x1c, 2	; 28
    c4e8:	e1 9a       	sbi	0x1c, 1	; 28
    c4ea:	0f be       	out	0x3f, r0	; 63
		      eeprom_write_byte(&DefShift,1);	 

          SaveTotalizerCurrentToLast();
    c4ec:	0e 94 09 29 	call	0x5212	; 0x5212 <SaveTotalizerCurrentToLast>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    c4f0:	83 e4       	ldi	r24, 0x43	; 67
    c4f2:	98 e0       	ldi	r25, 0x08	; 8
    c4f4:	61 e7       	ldi	r22, 0x71	; 113
    c4f6:	79 e0       	ldi	r23, 0x09	; 9
    c4f8:	44 e1       	ldi	r20, 0x14	; 20
    c4fa:	50 e0       	ldi	r21, 0x00	; 0
    c4fc:	20 e0       	ldi	r18, 0x00	; 0
    c4fe:	33 e1       	ldi	r19, 0x13	; 19
    c500:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
          eeprom_write_block((const void*) &CurrentShiftDateTime, (void*) &DefLastShiftDateTime,sizeof(DefLastShiftDateTime));
		  stCloseShift=csFinishCloseShift;
    c504:	8b e0       	ldi	r24, 0x0B	; 11
    c506:	80 93 20 03 	sts	0x0320, r24
    c50a:	04 c0       	rjmp	.+8      	; 0xc514 <FCloseShift+0x482>
	      break;
     case csFinishCloseShift:
          stCloseShift=csInitCloseShift;
    c50c:	10 92 20 03 	sts	0x0320, r1
    c510:	81 e0       	ldi	r24, 0x01	; 1
    c512:	01 c0       	rjmp	.+2      	; 0xc516 <FCloseShift+0x484>
    c514:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 //_uart_printf(0,1,PSTR("Close Shift"));	
   return Result;
}
    c516:	64 96       	adiw	r28, 0x14	; 20
    c518:	0f b6       	in	r0, 0x3f	; 63
    c51a:	f8 94       	cli
    c51c:	de bf       	out	0x3e, r29	; 62
    c51e:	0f be       	out	0x3f, r0	; 63
    c520:	cd bf       	out	0x3d, r28	; 61
    c522:	cf 91       	pop	r28
    c524:	df 91       	pop	r29
    c526:	1f 91       	pop	r17
    c528:	0f 91       	pop	r16
    c52a:	ff 90       	pop	r15
    c52c:	ef 90       	pop	r14
    c52e:	df 90       	pop	r13
    c530:	08 95       	ret

0000c532 <FMenuShift>:
     char SubMenu,KeyChar,KeyPressed;

     char Result;

Result=MENU_NONE;
     switch(stMenuShift){
    c532:	80 91 21 03 	lds	r24, 0x0321
    c536:	82 30       	cpi	r24, 0x02	; 2
    c538:	09 f4       	brne	.+2      	; 0xc53c <FMenuShift+0xa>
    c53a:	48 c0       	rjmp	.+144    	; 0xc5cc <FMenuShift+0x9a>
    c53c:	83 30       	cpi	r24, 0x03	; 3
    c53e:	30 f4       	brcc	.+12     	; 0xc54c <FMenuShift+0x1a>
    c540:	88 23       	and	r24, r24
    c542:	69 f0       	breq	.+26     	; 0xc55e <FMenuShift+0x2c>
    c544:	81 30       	cpi	r24, 0x01	; 1
    c546:	09 f0       	breq	.+2      	; 0xc54a <FMenuShift+0x18>
    c548:	50 c0       	rjmp	.+160    	; 0xc5ea <FMenuShift+0xb8>
    c54a:	25 c0       	rjmp	.+74     	; 0xc596 <FMenuShift+0x64>
    c54c:	84 30       	cpi	r24, 0x04	; 4
    c54e:	09 f4       	brne	.+2      	; 0xc552 <FMenuShift+0x20>
    c550:	4c c0       	rjmp	.+152    	; 0xc5ea <FMenuShift+0xb8>
    c552:	84 30       	cpi	r24, 0x04	; 4
    c554:	e8 f1       	brcs	.+122    	; 0xc5d0 <FMenuShift+0x9e>
    c556:	85 30       	cpi	r24, 0x05	; 5
    c558:	09 f0       	breq	.+2      	; 0xc55c <FMenuShift+0x2a>
    c55a:	47 c0       	rjmp	.+142    	; 0xc5ea <FMenuShift+0xb8>
    c55c:	42 c0       	rjmp	.+132    	; 0xc5e2 <FMenuShift+0xb0>
	 case msInitMenuShift:
	      lcd_clear();
    c55e:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Close Shift"));
    c562:	81 e0       	ldi	r24, 0x01	; 1
    c564:	61 e0       	ldi	r22, 0x01	; 1
    c566:	4e ec       	ldi	r20, 0xCE	; 206
    c568:	55 e1       	ldi	r21, 0x15	; 21
    c56a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Close Day  "));
    c56e:	82 e0       	ldi	r24, 0x02	; 2
    c570:	61 e0       	ldi	r22, 0x01	; 1
    c572:	40 ec       	ldi	r20, 0xC0	; 192
    c574:	55 e1       	ldi	r21, 0x15	; 21
    c576:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(3,1,PSTR("3.Lock Pump  "));
    c57a:	83 e0       	ldi	r24, 0x03	; 3
    c57c:	61 e0       	ldi	r22, 0x01	; 1
    c57e:	42 eb       	ldi	r20, 0xB2	; 178
    c580:	55 e1       	ldi	r21, 0x15	; 21
    c582:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit"));
    c586:	84 e0       	ldi	r24, 0x04	; 4
    c588:	61 e0       	ldi	r22, 0x01	; 1
    c58a:	4b ea       	ldi	r20, 0xAB	; 171
    c58c:	55 e1       	ldi	r21, 0x15	; 21
    c58e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  stMenuShift=msSelectShift;
    c592:	81 e0       	ldi	r24, 0x01	; 1
    c594:	18 c0       	rjmp	.+48     	; 0xc5c6 <FMenuShift+0x94>
	      break;
     case msSelectShift:
          KeyPressed=_key_scan(1);
    c596:	81 e0       	ldi	r24, 0x01	; 1
    c598:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    c59c:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
          switch(KeyChar){
    c5a0:	82 33       	cpi	r24, 0x32	; 50
    c5a2:	61 f0       	breq	.+24     	; 0xc5bc <FMenuShift+0x8a>
    c5a4:	83 33       	cpi	r24, 0x33	; 51
    c5a6:	28 f4       	brcc	.+10     	; 0xc5b2 <FMenuShift+0x80>
    c5a8:	8a 32       	cpi	r24, 0x2A	; 42
    c5aa:	61 f0       	breq	.+24     	; 0xc5c4 <FMenuShift+0x92>
    c5ac:	81 33       	cpi	r24, 0x31	; 49
    c5ae:	e9 f4       	brne	.+58     	; 0xc5ea <FMenuShift+0xb8>
    c5b0:	03 c0       	rjmp	.+6      	; 0xc5b8 <FMenuShift+0x86>
    c5b2:	83 33       	cpi	r24, 0x33	; 51
    c5b4:	d1 f4       	brne	.+52     	; 0xc5ea <FMenuShift+0xb8>
    c5b6:	04 c0       	rjmp	.+8      	; 0xc5c0 <FMenuShift+0x8e>
		  case '1':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseShift;
    c5b8:	82 e0       	ldi	r24, 0x02	; 2
    c5ba:	05 c0       	rjmp	.+10     	; 0xc5c6 <FMenuShift+0x94>
		       break; 
		  case '2':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseDay;
    c5bc:	83 e0       	ldi	r24, 0x03	; 3
    c5be:	03 c0       	rjmp	.+6      	; 0xc5c6 <FMenuShift+0x94>
		       break; 
		  case '3':
		       SubMenu=MENU_NONE;
		       stMenuShift=msLockPump;
    c5c0:	84 e0       	ldi	r24, 0x04	; 4
    c5c2:	01 c0       	rjmp	.+2      	; 0xc5c6 <FMenuShift+0x94>
		       break; 
		  case '*':
		       stMenuShift=msExitShift;
    c5c4:	85 e0       	ldi	r24, 0x05	; 5
    c5c6:	80 93 21 03 	sts	0x0321, r24
    c5ca:	09 c0       	rjmp	.+18     	; 0xc5de <FMenuShift+0xac>
		       break; 			   		  
		  }
		  break;
     case msCloseShift:
	      SubMenu=FCloseShift(CONTINUE_SHIFT);
    c5cc:	82 e0       	ldi	r24, 0x02	; 2
    c5ce:	01 c0       	rjmp	.+2      	; 0xc5d2 <FMenuShift+0xa0>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
		  //IsGenerateReport=True;		  
	      break;
     case msCloseDay:
	      SubMenu=FCloseShift(NEW_SHIFT);
    c5d0:	81 e0       	ldi	r24, 0x01	; 1
    c5d2:	0e 94 49 60 	call	0xc092	; 0xc092 <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
    c5d6:	81 30       	cpi	r24, 0x01	; 1
    c5d8:	41 f4       	brne	.+16     	; 0xc5ea <FMenuShift+0xb8>
    c5da:	10 92 21 03 	sts	0x0321, r1
    c5de:	80 e0       	ldi	r24, 0x00	; 0
    c5e0:	08 95       	ret
     case msLockPump:
	      SubMenu=FLockPump();
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
	      break;
     case msExitShift:
          stMenuShift=msInitMenuShift;
    c5e2:	10 92 21 03 	sts	0x0321, r1
    c5e6:	81 e0       	ldi	r24, 0x01	; 1
    c5e8:	08 95       	ret
    c5ea:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 } 
   return Result;
}
    c5ec:	08 95       	ret

0000c5ee <DisplayDateTime>:

void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}

void DisplayDateTime(){
    c5ee:	cf 92       	push	r12
    c5f0:	df 92       	push	r13
    c5f2:	ef 92       	push	r14
    c5f4:	ff 92       	push	r15
    c5f6:	0f 93       	push	r16
    c5f8:	1f 93       	push	r17
    c5fa:	df 93       	push	r29
    c5fc:	cf 93       	push	r28
    c5fe:	cd b7       	in	r28, 0x3d	; 61
    c600:	de b7       	in	r29, 0x3e	; 62
    c602:	64 97       	sbiw	r28, 0x14	; 20
    c604:	0f b6       	in	r0, 0x3f	; 63
    c606:	f8 94       	cli
    c608:	de bf       	out	0x3e, r29	; 62
    c60a:	0f be       	out	0x3f, r0	; 63
    c60c:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20];
	 _datetime(0, strSystemDate, strSystemTime);
    c60e:	fa e9       	ldi	r31, 0x9A	; 154
    c610:	ef 2e       	mov	r14, r31
    c612:	f5 e0       	ldi	r31, 0x05	; 5
    c614:	ff 2e       	mov	r15, r31
    c616:	ed e1       	ldi	r30, 0x1D	; 29
    c618:	ce 2e       	mov	r12, r30
    c61a:	ec e0       	ldi	r30, 0x0C	; 12
    c61c:	de 2e       	mov	r13, r30
    c61e:	80 e0       	ldi	r24, 0x00	; 0
    c620:	b7 01       	movw	r22, r14
    c622:	a6 01       	movw	r20, r12
    c624:	0e 94 c9 b2 	call	0x16592	; 0x16592 <_datetime>
	 sprintf_P(lcdteks,PSTR("%s %s"),strSystemDate,strSystemTime);
    c628:	8d b7       	in	r24, 0x3d	; 61
    c62a:	9e b7       	in	r25, 0x3e	; 62
    c62c:	08 97       	sbiw	r24, 0x08	; 8
    c62e:	0f b6       	in	r0, 0x3f	; 63
    c630:	f8 94       	cli
    c632:	9e bf       	out	0x3e, r25	; 62
    c634:	0f be       	out	0x3f, r0	; 63
    c636:	8d bf       	out	0x3d, r24	; 61
    c638:	ed b7       	in	r30, 0x3d	; 61
    c63a:	fe b7       	in	r31, 0x3e	; 62
    c63c:	31 96       	adiw	r30, 0x01	; 1
    c63e:	8e 01       	movw	r16, r28
    c640:	0f 5f       	subi	r16, 0xFF	; 255
    c642:	1f 4f       	sbci	r17, 0xFF	; 255
    c644:	ad b7       	in	r26, 0x3d	; 61
    c646:	be b7       	in	r27, 0x3e	; 62
    c648:	12 96       	adiw	r26, 0x02	; 2
    c64a:	1c 93       	st	X, r17
    c64c:	0e 93       	st	-X, r16
    c64e:	11 97       	sbiw	r26, 0x01	; 1
    c650:	87 e1       	ldi	r24, 0x17	; 23
    c652:	9c e1       	ldi	r25, 0x1C	; 28
    c654:	93 83       	std	Z+3, r25	; 0x03
    c656:	82 83       	std	Z+2, r24	; 0x02
    c658:	f5 82       	std	Z+5, r15	; 0x05
    c65a:	e4 82       	std	Z+4, r14	; 0x04
    c65c:	d7 82       	std	Z+7, r13	; 0x07
    c65e:	c6 82       	std	Z+6, r12	; 0x06
    c660:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	 lcd_print(2, 1, lcdteks);
    c664:	8d b7       	in	r24, 0x3d	; 61
    c666:	9e b7       	in	r25, 0x3e	; 62
    c668:	08 96       	adiw	r24, 0x08	; 8
    c66a:	0f b6       	in	r0, 0x3f	; 63
    c66c:	f8 94       	cli
    c66e:	9e bf       	out	0x3e, r25	; 62
    c670:	0f be       	out	0x3f, r0	; 63
    c672:	8d bf       	out	0x3d, r24	; 61
    c674:	82 e0       	ldi	r24, 0x02	; 2
    c676:	61 e0       	ldi	r22, 0x01	; 1
    c678:	a8 01       	movw	r20, r16
    c67a:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
}
    c67e:	64 96       	adiw	r28, 0x14	; 20
    c680:	0f b6       	in	r0, 0x3f	; 63
    c682:	f8 94       	cli
    c684:	de bf       	out	0x3e, r29	; 62
    c686:	0f be       	out	0x3f, r0	; 63
    c688:	cd bf       	out	0x3d, r28	; 61
    c68a:	cf 91       	pop	r28
    c68c:	df 91       	pop	r29
    c68e:	1f 91       	pop	r17
    c690:	0f 91       	pop	r16
    c692:	ff 90       	pop	r15
    c694:	ef 90       	pop	r14
    c696:	df 90       	pop	r13
    c698:	cf 90       	pop	r12
    c69a:	08 95       	ret

0000c69c <_menu_datetime>:
		}
	}
}


void _menu_datetime(void){
    c69c:	8f 92       	push	r8
    c69e:	9f 92       	push	r9
    c6a0:	af 92       	push	r10
    c6a2:	bf 92       	push	r11
    c6a4:	cf 92       	push	r12
    c6a6:	df 92       	push	r13
    c6a8:	ef 92       	push	r14
    c6aa:	ff 92       	push	r15
    c6ac:	0f 93       	push	r16
    c6ae:	1f 93       	push	r17
    c6b0:	df 93       	push	r29
    c6b2:	cf 93       	push	r28
    c6b4:	cd b7       	in	r28, 0x3d	; 61
    c6b6:	de b7       	in	r29, 0x3e	; 62
    c6b8:	c2 54       	subi	r28, 0x42	; 66
    c6ba:	d0 40       	sbci	r29, 0x00	; 0
    c6bc:	0f b6       	in	r0, 0x3f	; 63
    c6be:	f8 94       	cli
    c6c0:	de bf       	out	0x3e, r29	; 62
    c6c2:	0f be       	out	0x3f, r0	; 63
    c6c4:	cd bf       	out	0x3d, r28	; 61
	char	__key, __chr;
	char	__date[9];
	char	__time[9];
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};
    c6c6:	de 01       	movw	r26, r28
    c6c8:	53 96       	adiw	r26, 0x13	; 19
    c6ca:	e6 e2       	ldi	r30, 0x26	; 38
    c6cc:	f1 e0       	ldi	r31, 0x01	; 1
    c6ce:	80 e3       	ldi	r24, 0x30	; 48
    c6d0:	01 90       	ld	r0, Z+
    c6d2:	0d 92       	st	X+, r0
    c6d4:	81 50       	subi	r24, 0x01	; 1
    c6d6:	e1 f7       	brne	.-8      	; 0xc6d0 <_menu_datetime+0x34>

	_datetime(_DATETIME_READ, __date, __time);
    c6d8:	8e 01       	movw	r16, r28
    c6da:	0f 5f       	subi	r16, 0xFF	; 255
    c6dc:	1f 4f       	sbci	r17, 0xFF	; 255
    c6de:	b8 01       	movw	r22, r16
    c6e0:	ae 01       	movw	r20, r28
    c6e2:	46 5f       	subi	r20, 0xF6	; 246
    c6e4:	5f 4f       	sbci	r21, 0xFF	; 255
    c6e6:	0e 94 c9 b2 	call	0x16592	; 0x16592 <_datetime>
    c6ea:	e5 e1       	ldi	r30, 0x15	; 21
    c6ec:	8e 2e       	mov	r8, r30
    c6ee:	91 2c       	mov	r9, r1
    c6f0:	8c 0e       	add	r8, r28
    c6f2:	9d 1e       	adc	r9, r29
    c6f4:	d4 01       	movw	r26, r8
    c6f6:	20 e0       	ldi	r18, 0x00	; 0
    c6f8:	30 e0       	ldi	r19, 0x00	; 0
    c6fa:	40 e0       	ldi	r20, 0x00	; 0
    c6fc:	50 e0       	ldi	r21, 0x00	; 0
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
    c6fe:	22 30       	cpi	r18, 0x02	; 2
    c700:	31 05       	cpc	r19, r1
    c702:	19 f0       	breq	.+6      	; 0xc70a <_menu_datetime+0x6e>
    c704:	24 30       	cpi	r18, 0x04	; 4
    c706:	31 05       	cpc	r19, r1
    c708:	11 f4       	brne	.+4      	; 0xc70e <_menu_datetime+0x72>
			__ii++;
    c70a:	4f 5f       	subi	r20, 0xFF	; 255
    c70c:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __date[__ii];
    c70e:	f8 01       	movw	r30, r16
    c710:	e4 0f       	add	r30, r20
    c712:	f5 1f       	adc	r31, r21
    c714:	80 81       	ld	r24, Z
    c716:	8c 93       	st	X, r24
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};

	_datetime(_DATETIME_READ, __date, __time);
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    c718:	2f 5f       	subi	r18, 0xFF	; 255
    c71a:	3f 4f       	sbci	r19, 0xFF	; 255
    c71c:	14 96       	adiw	r26, 0x04	; 4
    c71e:	26 30       	cpi	r18, 0x06	; 6
    c720:	31 05       	cpc	r19, r1
    c722:	19 f0       	breq	.+6      	; 0xc72a <_menu_datetime+0x8e>
    c724:	4f 5f       	subi	r20, 0xFF	; 255
    c726:	5f 4f       	sbci	r21, 0xFF	; 255
    c728:	ea cf       	rjmp	.-44     	; 0xc6fe <_menu_datetime+0x62>
    c72a:	7d e2       	ldi	r23, 0x2D	; 45
    c72c:	a7 2e       	mov	r10, r23
    c72e:	b1 2c       	mov	r11, r1
    c730:	ac 0e       	add	r10, r28
    c732:	bd 1e       	adc	r11, r29
    c734:	d5 01       	movw	r26, r10
    c736:	40 e0       	ldi	r20, 0x00	; 0
    c738:	50 e0       	ldi	r21, 0x00	; 0
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
    c73a:	6a e0       	ldi	r22, 0x0A	; 10
    c73c:	e6 2e       	mov	r14, r22
    c73e:	f1 2c       	mov	r15, r1
    c740:	ec 0e       	add	r14, r28
    c742:	fd 1e       	adc	r15, r29
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
    c744:	28 30       	cpi	r18, 0x08	; 8
    c746:	31 05       	cpc	r19, r1
    c748:	19 f0       	breq	.+6      	; 0xc750 <_menu_datetime+0xb4>
    c74a:	2a 30       	cpi	r18, 0x0A	; 10
    c74c:	31 05       	cpc	r19, r1
    c74e:	11 f4       	brne	.+4      	; 0xc754 <_menu_datetime+0xb8>
			__ii++;
    c750:	4f 5f       	subi	r20, 0xFF	; 255
    c752:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __time[__ii];
    c754:	f7 01       	movw	r30, r14
    c756:	e4 0f       	add	r30, r20
    c758:	f5 1f       	adc	r31, r21
    c75a:	80 81       	ld	r24, Z
    c75c:	8c 93       	st	X, r24
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    c75e:	2f 5f       	subi	r18, 0xFF	; 255
    c760:	3f 4f       	sbci	r19, 0xFF	; 255
    c762:	14 96       	adiw	r26, 0x04	; 4
    c764:	2c 30       	cpi	r18, 0x0C	; 12
    c766:	31 05       	cpc	r19, r1
    c768:	19 f0       	breq	.+6      	; 0xc770 <_menu_datetime+0xd4>
    c76a:	4f 5f       	subi	r20, 0xFF	; 255
    c76c:	5f 4f       	sbci	r21, 0xFF	; 255
    c76e:	ea cf       	rjmp	.-44     	; 0xc744 <_menu_datetime+0xa8>
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
	}

	lcd_clear();_delay_ms(10);
    c770:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
    c774:	84 ec       	ldi	r24, 0xC4	; 196
    c776:	99 e0       	ldi	r25, 0x09	; 9
    c778:	01 97       	sbiw	r24, 0x01	; 1
    c77a:	f1 f7       	brne	.-4      	; 0xc778 <_menu_datetime+0xdc>
	lcd_printf(1, 1, PSTR("DATE : "));
    c77c:	81 e0       	ldi	r24, 0x01	; 1
    c77e:	61 e0       	ldi	r22, 0x01	; 1
    c780:	43 eb       	ldi	r20, 0xB3	; 179
    c782:	5b e0       	ldi	r21, 0x0B	; 11
    c784:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	lcd_printf(2, 1, PSTR("TIME : "));
    c788:	82 e0       	ldi	r24, 0x02	; 2
    c78a:	61 e0       	ldi	r22, 0x01	; 1
    c78c:	4b ea       	ldi	r20, 0xAB	; 171
    c78e:	5b e0       	ldi	r21, 0x0B	; 11
    c790:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	lcd_print(1, 8, __date);
    c794:	81 e0       	ldi	r24, 0x01	; 1
    c796:	68 e0       	ldi	r22, 0x08	; 8
    c798:	8e 01       	movw	r16, r28
    c79a:	0f 5f       	subi	r16, 0xFF	; 255
    c79c:	1f 4f       	sbci	r17, 0xFF	; 255
    c79e:	a8 01       	movw	r20, r16
    c7a0:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
	lcd_print(2, 8, __time);
    c7a4:	82 e0       	ldi	r24, 0x02	; 2
    c7a6:	68 e0       	ldi	r22, 0x08	; 8
    c7a8:	a7 01       	movw	r20, r14
    c7aa:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
	lcd_printf(4, 1, PSTR("*)Cancel      #)Save"));
    c7ae:	84 e0       	ldi	r24, 0x04	; 4
    c7b0:	61 e0       	ldi	r22, 0x01	; 1
    c7b2:	46 e9       	ldi	r20, 0x96	; 150
    c7b4:	5b e0       	ldi	r21, 0x0B	; 11
    c7b6:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>

	__i = 0;
	lcd_xy(__map[__i][0], __map[__i][1]);
    c7ba:	8b 89       	ldd	r24, Y+19	; 0x13
    c7bc:	6c 89       	ldd	r22, Y+20	; 0x14
    c7be:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
	CURSOR_SHOW;
    c7c2:	8f e0       	ldi	r24, 0x0F	; 15
    c7c4:	0e 94 b1 ad 	call	0x15b62	; 0x15b62 <lcd_command>
    c7c8:	ee 24       	eor	r14, r14
    c7ca:	ff 24       	eor	r15, r15
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    c7cc:	68 01       	movw	r12, r16
	lcd_xy(__map[__i][0], __map[__i][1]);
	CURSOR_SHOW;

	while(1){
		
		__key = _key_scan(1);
    c7ce:	81 e0       	ldi	r24, 0x01	; 1
    c7d0:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    c7d4:	18 2f       	mov	r17, r24
		__chr = _key_btn(__key);
    c7d6:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
    c7da:	48 2f       	mov	r20, r24
		if(__chr >= 0x30 && __chr <= 0x39){
    c7dc:	80 53       	subi	r24, 0x30	; 48
    c7de:	8a 30       	cpi	r24, 0x0A	; 10
    c7e0:	08 f0       	brcs	.+2      	; 0xc7e4 <_menu_datetime+0x148>
    c7e2:	72 c0       	rjmp	.+228    	; 0xc8c8 <_menu_datetime+0x22c>
			if(__i == 0 || __i == 2 || __i == 6 || __i == 8 || __i == 10){
    c7e4:	e1 14       	cp	r14, r1
    c7e6:	f1 04       	cpc	r15, r1
    c7e8:	81 f0       	breq	.+32     	; 0xc80a <_menu_datetime+0x16e>
    c7ea:	82 e0       	ldi	r24, 0x02	; 2
    c7ec:	e8 16       	cp	r14, r24
    c7ee:	f1 04       	cpc	r15, r1
    c7f0:	61 f0       	breq	.+24     	; 0xc80a <_menu_datetime+0x16e>
    c7f2:	96 e0       	ldi	r25, 0x06	; 6
    c7f4:	e9 16       	cp	r14, r25
    c7f6:	f1 04       	cpc	r15, r1
    c7f8:	41 f0       	breq	.+16     	; 0xc80a <_menu_datetime+0x16e>
    c7fa:	a8 e0       	ldi	r26, 0x08	; 8
    c7fc:	ea 16       	cp	r14, r26
    c7fe:	f1 04       	cpc	r15, r1
    c800:	21 f0       	breq	.+8      	; 0xc80a <_menu_datetime+0x16e>
    c802:	ba e0       	ldi	r27, 0x0A	; 10
    c804:	eb 16       	cp	r14, r27
    c806:	f1 04       	cpc	r15, r1
    c808:	81 f4       	brne	.+32     	; 0xc82a <_menu_datetime+0x18e>
				if((__chr - 0x30) <= __map[__i][3])
    c80a:	84 2f       	mov	r24, r20
    c80c:	90 e0       	ldi	r25, 0x00	; 0
    c80e:	c0 97       	sbiw	r24, 0x30	; 48
    c810:	f7 01       	movw	r30, r14
    c812:	ee 0f       	add	r30, r30
    c814:	ff 1f       	adc	r31, r31
    c816:	ee 0f       	add	r30, r30
    c818:	ff 1f       	adc	r31, r31
    c81a:	ec 0d       	add	r30, r12
    c81c:	fd 1d       	adc	r31, r13
    c81e:	25 89       	ldd	r18, Z+21	; 0x15
    c820:	30 e0       	ldi	r19, 0x00	; 0
    c822:	28 17       	cp	r18, r24
    c824:	39 07       	cpc	r19, r25
    c826:	84 f5       	brge	.+96     	; 0xc888 <_menu_datetime+0x1ec>
    c828:	4f c0       	rjmp	.+158    	; 0xc8c8 <_menu_datetime+0x22c>
					goto CETAK;
				else
					goto LEWAT;
			}
			if(__i == 1){
    c82a:	81 e0       	ldi	r24, 0x01	; 1
    c82c:	e8 16       	cp	r14, r24
    c82e:	f1 04       	cpc	r15, r1
    c830:	61 f4       	brne	.+24     	; 0xc84a <_menu_datetime+0x1ae>
				if((__map[0][2] - 0x30) < __map[0][3])
    c832:	2d 89       	ldd	r18, Y+21	; 0x15
    c834:	30 e0       	ldi	r19, 0x00	; 0
    c836:	2f 52       	subi	r18, 0x2F	; 47
    c838:	30 40       	sbci	r19, 0x00	; 0
    c83a:	8e 89       	ldd	r24, Y+22	; 0x16
    c83c:	90 e0       	ldi	r25, 0x00	; 0
    c83e:	82 17       	cp	r24, r18
    c840:	93 07       	cpc	r25, r19
    c842:	14 f5       	brge	.+68     	; 0xc888 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[0][2] - 0x30) >= __map[0][3]){
					if(__chr < 0x32)
    c844:	42 33       	cpi	r20, 0x32	; 50
    c846:	00 f1       	brcs	.+64     	; 0xc888 <_menu_datetime+0x1ec>
    c848:	3f c0       	rjmp	.+126    	; 0xc8c8 <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 3){
    c84a:	93 e0       	ldi	r25, 0x03	; 3
    c84c:	e9 16       	cp	r14, r25
    c84e:	f1 04       	cpc	r15, r1
    c850:	61 f4       	brne	.+24     	; 0xc86a <_menu_datetime+0x1ce>
				if((__map[2][2] - 0x30) < __map[2][3])
    c852:	2d 8d       	ldd	r18, Y+29	; 0x1d
    c854:	30 e0       	ldi	r19, 0x00	; 0
    c856:	2f 52       	subi	r18, 0x2F	; 47
    c858:	30 40       	sbci	r19, 0x00	; 0
    c85a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    c85c:	90 e0       	ldi	r25, 0x00	; 0
    c85e:	82 17       	cp	r24, r18
    c860:	93 07       	cpc	r25, r19
    c862:	94 f4       	brge	.+36     	; 0xc888 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[2][2] - 0x30) >= __map[2][3]){
					if(__chr < 0x33)
    c864:	43 33       	cpi	r20, 0x33	; 51
    c866:	80 f0       	brcs	.+32     	; 0xc888 <_menu_datetime+0x1ec>
    c868:	2f c0       	rjmp	.+94     	; 0xc8c8 <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 7){
    c86a:	a7 e0       	ldi	r26, 0x07	; 7
    c86c:	ea 16       	cp	r14, r26
    c86e:	f1 04       	cpc	r15, r1
    c870:	59 f4       	brne	.+22     	; 0xc888 <_menu_datetime+0x1ec>
				if((__map[6][2] - 0x30) < __map[6][3])
    c872:	2d a5       	ldd	r18, Y+45	; 0x2d
    c874:	30 e0       	ldi	r19, 0x00	; 0
    c876:	2f 52       	subi	r18, 0x2F	; 47
    c878:	30 40       	sbci	r19, 0x00	; 0
    c87a:	8e a5       	ldd	r24, Y+46	; 0x2e
    c87c:	90 e0       	ldi	r25, 0x00	; 0
    c87e:	82 17       	cp	r24, r18
    c880:	93 07       	cpc	r25, r19
    c882:	14 f4       	brge	.+4      	; 0xc888 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[6][2] - 0x30) >= __map[6][3]){
					if(__chr < 0x34)
    c884:	44 33       	cpi	r20, 0x34	; 52
    c886:	00 f5       	brcc	.+64     	; 0xc8c8 <_menu_datetime+0x22c>
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    c888:	f7 01       	movw	r30, r14
    c88a:	ee 0f       	add	r30, r30
    c88c:	ff 1f       	adc	r31, r31
    c88e:	ee 0f       	add	r30, r30
    c890:	ff 1f       	adc	r31, r31
    c892:	ec 0d       	add	r30, r12
    c894:	fd 1d       	adc	r31, r13
    c896:	44 8b       	std	Z+20, r20	; 0x14
			_lcd(__chr);
    c898:	84 2f       	mov	r24, r20
    c89a:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
			__i++;
    c89e:	08 94       	sec
    c8a0:	e1 1c       	adc	r14, r1
    c8a2:	f1 1c       	adc	r15, r1
    c8a4:	bc e0       	ldi	r27, 0x0C	; 12
    c8a6:	eb 16       	cp	r14, r27
    c8a8:	f1 04       	cpc	r15, r1
    c8aa:	1c f0       	brlt	.+6      	; 0xc8b2 <_menu_datetime+0x216>
    c8ac:	8b e0       	ldi	r24, 0x0B	; 11
    c8ae:	e8 2e       	mov	r14, r24
    c8b0:	f1 2c       	mov	r15, r1
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
    c8b2:	f7 01       	movw	r30, r14
    c8b4:	ee 0f       	add	r30, r30
    c8b6:	ff 1f       	adc	r31, r31
    c8b8:	ee 0f       	add	r30, r30
    c8ba:	ff 1f       	adc	r31, r31
    c8bc:	ec 0d       	add	r30, r12
    c8be:	fd 1d       	adc	r31, r13
    c8c0:	82 89       	ldd	r24, Z+18	; 0x12
    c8c2:	63 89       	ldd	r22, Z+19	; 0x13
    c8c4:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
LEWAT:		;
		}
		if(__key == _KEY_SHIFT){
    c8c8:	1b 37       	cpi	r17, 0x7B	; 123
    c8ca:	59 f4       	brne	.+22     	; 0xc8e2 <_menu_datetime+0x246>
			__i++;
    c8cc:	08 94       	sec
    c8ce:	e1 1c       	adc	r14, r1
    c8d0:	f1 1c       	adc	r15, r1
    c8d2:	8c e0       	ldi	r24, 0x0C	; 12
    c8d4:	e8 16       	cp	r14, r24
    c8d6:	f1 04       	cpc	r15, r1
    c8d8:	6c f0       	brlt	.+26     	; 0xc8f4 <_menu_datetime+0x258>
    c8da:	bb e0       	ldi	r27, 0x0B	; 11
    c8dc:	eb 2e       	mov	r14, r27
    c8de:	f1 2c       	mov	r15, r1
    c8e0:	09 c0       	rjmp	.+18     	; 0xc8f4 <_menu_datetime+0x258>
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CLEAR){
    c8e2:	17 37       	cpi	r17, 0x77	; 119
    c8e4:	99 f4       	brne	.+38     	; 0xc90c <_menu_datetime+0x270>
			__i--;
    c8e6:	08 94       	sec
    c8e8:	e1 08       	sbc	r14, r1
    c8ea:	f1 08       	sbc	r15, r1
    c8ec:	f7 fe       	sbrs	r15, 7
    c8ee:	02 c0       	rjmp	.+4      	; 0xc8f4 <_menu_datetime+0x258>
    c8f0:	ee 24       	eor	r14, r14
    c8f2:	ff 24       	eor	r15, r15
			if(__i <= 0)
				__i = 0;
			lcd_xy(__map[__i][0], __map[__i][1]);
    c8f4:	f7 01       	movw	r30, r14
    c8f6:	ee 0f       	add	r30, r30
    c8f8:	ff 1f       	adc	r31, r31
    c8fa:	ee 0f       	add	r30, r30
    c8fc:	ff 1f       	adc	r31, r31
    c8fe:	ec 0d       	add	r30, r12
    c900:	fd 1d       	adc	r31, r13
    c902:	82 89       	ldd	r24, Z+18	; 0x12
    c904:	63 89       	ldd	r22, Z+19	; 0x13
    c906:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
    c90a:	61 cf       	rjmp	.-318    	; 0xc7ce <_menu_datetime+0x132>
		}
		if(__key == _KEY_CANCEL)
    c90c:	17 3e       	cpi	r17, 0xE7	; 231
    c90e:	09 f4       	brne	.+2      	; 0xc912 <_menu_datetime+0x276>
    c910:	49 c0       	rjmp	.+146    	; 0xc9a4 <_menu_datetime+0x308>
			break;
		if(__key == _KEY_ENTER){
    c912:	17 3b       	cpi	r17, 0xB7	; 183
    c914:	09 f0       	breq	.+2      	; 0xc918 <_menu_datetime+0x27c>
    c916:	5b cf       	rjmp	.-330    	; 0xc7ce <_menu_datetime+0x132>
    c918:	20 e0       	ldi	r18, 0x00	; 0
    c91a:	30 e0       	ldi	r19, 0x00	; 0
    c91c:	40 e0       	ldi	r20, 0x00	; 0
    c91e:	50 e0       	ldi	r21, 0x00	; 0
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
    c920:	be 01       	movw	r22, r28
    c922:	6f 5f       	subi	r22, 0xFF	; 255
    c924:	7f 4f       	sbci	r23, 0xFF	; 255
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
    c926:	22 30       	cpi	r18, 0x02	; 2
    c928:	31 05       	cpc	r19, r1
    c92a:	19 f0       	breq	.+6      	; 0xc932 <_menu_datetime+0x296>
    c92c:	24 30       	cpi	r18, 0x04	; 4
    c92e:	31 05       	cpc	r19, r1
    c930:	11 f4       	brne	.+4      	; 0xc936 <_menu_datetime+0x29a>
					__ii++;
    c932:	4f 5f       	subi	r20, 0xFF	; 255
    c934:	5f 4f       	sbci	r21, 0xFF	; 255
				__date[__ii] = __map[__i][2];
    c936:	fb 01       	movw	r30, r22
    c938:	e4 0f       	add	r30, r20
    c93a:	f5 1f       	adc	r31, r21
    c93c:	d4 01       	movw	r26, r8
    c93e:	8c 91       	ld	r24, X
    c940:	80 83       	st	Z, r24
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    c942:	2f 5f       	subi	r18, 0xFF	; 255
    c944:	3f 4f       	sbci	r19, 0xFF	; 255
    c946:	84 e0       	ldi	r24, 0x04	; 4
    c948:	90 e0       	ldi	r25, 0x00	; 0
    c94a:	88 0e       	add	r8, r24
    c94c:	99 1e       	adc	r9, r25
    c94e:	26 30       	cpi	r18, 0x06	; 6
    c950:	31 05       	cpc	r19, r1
    c952:	19 f0       	breq	.+6      	; 0xc95a <_menu_datetime+0x2be>
    c954:	4f 5f       	subi	r20, 0xFF	; 255
    c956:	5f 4f       	sbci	r21, 0xFF	; 255
    c958:	e6 cf       	rjmp	.-52     	; 0xc926 <_menu_datetime+0x28a>
    c95a:	60 e0       	ldi	r22, 0x00	; 0
    c95c:	70 e0       	ldi	r23, 0x00	; 0
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
    c95e:	ae 01       	movw	r20, r28
    c960:	46 5f       	subi	r20, 0xF6	; 246
    c962:	5f 4f       	sbci	r21, 0xFF	; 255
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
    c964:	28 30       	cpi	r18, 0x08	; 8
    c966:	31 05       	cpc	r19, r1
    c968:	19 f0       	breq	.+6      	; 0xc970 <_menu_datetime+0x2d4>
    c96a:	2a 30       	cpi	r18, 0x0A	; 10
    c96c:	31 05       	cpc	r19, r1
    c96e:	11 f4       	brne	.+4      	; 0xc974 <_menu_datetime+0x2d8>
					__ii++;
    c970:	6f 5f       	subi	r22, 0xFF	; 255
    c972:	7f 4f       	sbci	r23, 0xFF	; 255
				__time[__ii] = __map[__i][2];
    c974:	fa 01       	movw	r30, r20
    c976:	e6 0f       	add	r30, r22
    c978:	f7 1f       	adc	r31, r23
    c97a:	d5 01       	movw	r26, r10
    c97c:	8c 91       	ld	r24, X
    c97e:	80 83       	st	Z, r24
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    c980:	2f 5f       	subi	r18, 0xFF	; 255
    c982:	3f 4f       	sbci	r19, 0xFF	; 255
    c984:	84 e0       	ldi	r24, 0x04	; 4
    c986:	90 e0       	ldi	r25, 0x00	; 0
    c988:	a8 0e       	add	r10, r24
    c98a:	b9 1e       	adc	r11, r25
    c98c:	2c 30       	cpi	r18, 0x0C	; 12
    c98e:	31 05       	cpc	r19, r1
    c990:	19 f0       	breq	.+6      	; 0xc998 <_menu_datetime+0x2fc>
    c992:	6f 5f       	subi	r22, 0xFF	; 255
    c994:	7f 4f       	sbci	r23, 0xFF	; 255
    c996:	e6 cf       	rjmp	.-52     	; 0xc964 <_menu_datetime+0x2c8>
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
			}
			_datetime(_DATETIME_WRITE, __date, __time);
    c998:	81 e0       	ldi	r24, 0x01	; 1
    c99a:	be 01       	movw	r22, r28
    c99c:	6f 5f       	subi	r22, 0xFF	; 255
    c99e:	7f 4f       	sbci	r23, 0xFF	; 255
    c9a0:	0e 94 c9 b2 	call	0x16592	; 0x16592 <_datetime>
			break;
		}
	}
	CURSOR_HIDE;
    c9a4:	8c e0       	ldi	r24, 0x0C	; 12
    c9a6:	0e 94 b1 ad 	call	0x15b62	; 0x15b62 <lcd_command>
}
    c9aa:	ce 5b       	subi	r28, 0xBE	; 190
    c9ac:	df 4f       	sbci	r29, 0xFF	; 255
    c9ae:	0f b6       	in	r0, 0x3f	; 63
    c9b0:	f8 94       	cli
    c9b2:	de bf       	out	0x3e, r29	; 62
    c9b4:	0f be       	out	0x3f, r0	; 63
    c9b6:	cd bf       	out	0x3d, r28	; 61
    c9b8:	cf 91       	pop	r28
    c9ba:	df 91       	pop	r29
    c9bc:	1f 91       	pop	r17
    c9be:	0f 91       	pop	r16
    c9c0:	ff 90       	pop	r15
    c9c2:	ef 90       	pop	r14
    c9c4:	df 90       	pop	r13
    c9c6:	cf 90       	pop	r12
    c9c8:	bf 90       	pop	r11
    c9ca:	af 90       	pop	r10
    c9cc:	9f 90       	pop	r9
    c9ce:	8f 90       	pop	r8
    c9d0:	08 95       	ret

0000c9d2 <FSettingDatetime>:
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
    c9d2:	0e 94 4e 63 	call	0xc69c	; 0xc69c <_menu_datetime>
     return MENU_DONE;
}
    c9d6:	81 e0       	ldi	r24, 0x01	; 1
    c9d8:	08 95       	ret

0000c9da <menu_FIP>:
	 }
  return Result;
}


char menu_FIP(char *xFIP,char *sFIPUsed){
    c9da:	4f 92       	push	r4
    c9dc:	5f 92       	push	r5
    c9de:	6f 92       	push	r6
    c9e0:	7f 92       	push	r7
    c9e2:	8f 92       	push	r8
    c9e4:	9f 92       	push	r9
    c9e6:	af 92       	push	r10
    c9e8:	bf 92       	push	r11
    c9ea:	cf 92       	push	r12
    c9ec:	df 92       	push	r13
    c9ee:	ef 92       	push	r14
    c9f0:	ff 92       	push	r15
    c9f2:	0f 93       	push	r16
    c9f4:	1f 93       	push	r17
    c9f6:	df 93       	push	r29
    c9f8:	cf 93       	push	r28
    c9fa:	cd b7       	in	r28, 0x3d	; 61
    c9fc:	de b7       	in	r29, 0x3e	; 62
    c9fe:	a2 97       	sbiw	r28, 0x22	; 34
    ca00:	0f b6       	in	r0, 0x3f	; 63
    ca02:	f8 94       	cli
    ca04:	de bf       	out	0x3e, r29	; 62
    ca06:	0f be       	out	0x3f, r0	; 63
    ca08:	cd bf       	out	0x3d, r28	; 61
    ca0a:	7c 01       	movw	r14, r24
    ca0c:	8b 01       	movw	r16, r22
       char Result=FIP_NONE;
       char FIP[8],strPumpL[3],strPumpR[3],lcdteks[20];
static char KeyPressed=0,KeyChar,KeyCharLast=' ',FIP_Used=0;
static unsigned int iLoop;

       switch(stEnterFIP){
    ca0e:	80 91 58 03 	lds	r24, 0x0358
    ca12:	81 30       	cpi	r24, 0x01	; 1
    ca14:	09 f4       	brne	.+2      	; 0xca18 <menu_FIP+0x3e>
    ca16:	cf c0       	rjmp	.+414    	; 0xcbb6 <menu_FIP+0x1dc>
    ca18:	81 30       	cpi	r24, 0x01	; 1
    ca1a:	20 f0       	brcs	.+8      	; 0xca24 <menu_FIP+0x4a>
    ca1c:	82 30       	cpi	r24, 0x02	; 2
    ca1e:	09 f0       	breq	.+2      	; 0xca22 <menu_FIP+0x48>
    ca20:	55 c1       	rjmp	.+682    	; 0xcccc <menu_FIP+0x2f2>
    ca22:	52 c1       	rjmp	.+676    	; 0xccc8 <menu_FIP+0x2ee>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    ca24:	8e 01       	movw	r16, r28
    ca26:	09 5f       	subi	r16, 0xF9	; 249
    ca28:	1f 4f       	sbci	r17, 0xFF	; 255
    ca2a:	c8 01       	movw	r24, r16
    ca2c:	65 e4       	ldi	r22, 0x45	; 69
    ca2e:	70 e0       	ldi	r23, 0x00	; 0
    ca30:	48 e0       	ldi	r20, 0x08	; 8
    ca32:	50 e0       	ldi	r21, 0x00	; 0
    ca34:	28 ef       	ldi	r18, 0xF8	; 248
    ca36:	32 e1       	ldi	r19, 0x12	; 18
    ca38:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
    ca3c:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
    ca40:	f8 01       	movw	r30, r16
    ca42:	20 e0       	ldi	r18, 0x00	; 0
    ca44:	30 e0       	ldi	r19, 0x00	; 0
    ca46:	07 c0       	rjmp	.+14     	; 0xca56 <menu_FIP+0x7c>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
    ca48:	80 81       	ld	r24, Z
    ca4a:	84 36       	cpi	r24, 0x64	; 100
    ca4c:	08 f0       	brcs	.+2      	; 0xca50 <menu_FIP+0x76>
    ca4e:	10 82       	st	Z, r1
    ca50:	2f 5f       	subi	r18, 0xFF	; 255
    ca52:	3f 4f       	sbci	r19, 0xFF	; 255
    ca54:	31 96       	adiw	r30, 0x01	; 1

       switch(stEnterFIP){
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
    ca56:	28 30       	cpi	r18, 0x08	; 8
    ca58:	31 05       	cpc	r19, r1
    ca5a:	b0 f3       	brcs	.-20     	; 0xca48 <menu_FIP+0x6e>
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    ca5c:	10 92 54 03 	sts	0x0354, r1
    ca60:	10 92 53 03 	sts	0x0353, r1
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    ca64:	5e 01       	movw	r10, r28
    ca66:	08 94       	sec
    ca68:	a1 1c       	adc	r10, r1
    ca6a:	b1 1c       	adc	r11, r1
    ca6c:	0d e5       	ldi	r16, 0x5D	; 93
    ca6e:	c0 2e       	mov	r12, r16
    ca70:	0d e0       	ldi	r16, 0x0D	; 13
    ca72:	d0 2e       	mov	r13, r16
    ca74:	17 e0       	ldi	r17, 0x07	; 7
    ca76:	41 2e       	mov	r4, r17
    ca78:	51 2c       	mov	r5, r1
    ca7a:	4c 0e       	add	r4, r28
    ca7c:	5d 1e       	adc	r5, r29
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    ca7e:	b4 e0       	ldi	r27, 0x04	; 4
    ca80:	eb 2e       	mov	r14, r27
    ca82:	f1 2c       	mov	r15, r1
    ca84:	ec 0e       	add	r14, r28
    ca86:	fd 1e       	adc	r15, r29
    ca88:	ab e0       	ldi	r26, 0x0B	; 11
    ca8a:	6a 2e       	mov	r6, r26
    ca8c:	71 2c       	mov	r7, r1
    ca8e:	6c 0e       	add	r6, r28
    ca90:	7d 1e       	adc	r7, r29
    ca92:	8e 01       	movw	r16, r28
    ca94:	01 5f       	subi	r16, 0xF1	; 241
    ca96:	1f 4f       	sbci	r17, 0xFF	; 255
    ca98:	ff e9       	ldi	r31, 0x9F	; 159
    ca9a:	8f 2e       	mov	r8, r31
    ca9c:	fb e1       	ldi	r31, 0x1B	; 27
    ca9e:	9f 2e       	mov	r9, r31
    caa0:	64 c0       	rjmp	.+200    	; 0xcb6a <menu_FIP+0x190>
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    caa2:	00 d0       	rcall	.+0      	; 0xcaa4 <menu_FIP+0xca>
    caa4:	00 d0       	rcall	.+0      	; 0xcaa6 <menu_FIP+0xcc>
    caa6:	00 d0       	rcall	.+0      	; 0xcaa8 <menu_FIP+0xce>
    caa8:	2d b7       	in	r18, 0x3d	; 61
    caaa:	3e b7       	in	r19, 0x3e	; 62
    caac:	2f 5f       	subi	r18, 0xFF	; 255
    caae:	3f 4f       	sbci	r19, 0xFF	; 255
    cab0:	ed b7       	in	r30, 0x3d	; 61
    cab2:	fe b7       	in	r31, 0x3e	; 62
    cab4:	b2 82       	std	Z+2, r11	; 0x02
    cab6:	a1 82       	std	Z+1, r10	; 0x01
    cab8:	f9 01       	movw	r30, r18
    caba:	d3 82       	std	Z+3, r13	; 0x03
    cabc:	c2 82       	std	Z+2, r12	; 0x02
    cabe:	a4 0d       	add	r26, r4
    cac0:	b5 1d       	adc	r27, r5
    cac2:	8c 91       	ld	r24, X
    cac4:	84 83       	std	Z+4, r24	; 0x04
    cac6:	15 82       	std	Z+5, r1	; 0x05
    cac8:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    cacc:	ad b7       	in	r26, 0x3d	; 61
    cace:	be b7       	in	r27, 0x3e	; 62
    cad0:	11 96       	adiw	r26, 0x01	; 1
    cad2:	ed b7       	in	r30, 0x3d	; 61
    cad4:	fe b7       	in	r31, 0x3e	; 62
    cad6:	f2 82       	std	Z+2, r15	; 0x02
    cad8:	e1 82       	std	Z+1, r14	; 0x01
    cada:	13 96       	adiw	r26, 0x03	; 3
    cadc:	dc 92       	st	X, r13
    cade:	ce 92       	st	-X, r12
    cae0:	12 97       	sbiw	r26, 0x02	; 2
    cae2:	e0 91 53 03 	lds	r30, 0x0353
    cae6:	f0 91 54 03 	lds	r31, 0x0354
    caea:	e6 0d       	add	r30, r6
    caec:	f7 1d       	adc	r31, r7
    caee:	80 81       	ld	r24, Z
    caf0:	14 96       	adiw	r26, 0x04	; 4
    caf2:	8c 93       	st	X, r24
    caf4:	14 97       	sbiw	r26, 0x04	; 4
    caf6:	15 96       	adiw	r26, 0x05	; 5
    caf8:	1c 92       	st	X, r1
    cafa:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    cafe:	80 91 53 03 	lds	r24, 0x0353
    cb02:	90 91 54 03 	lds	r25, 0x0354
    cb06:	00 d0       	rcall	.+0      	; 0xcb08 <menu_FIP+0x12e>
    cb08:	00 d0       	rcall	.+0      	; 0xcb0a <menu_FIP+0x130>
    cb0a:	00 d0       	rcall	.+0      	; 0xcb0c <menu_FIP+0x132>
    cb0c:	ed b7       	in	r30, 0x3d	; 61
    cb0e:	fe b7       	in	r31, 0x3e	; 62
    cb10:	31 96       	adiw	r30, 0x01	; 1
    cb12:	ad b7       	in	r26, 0x3d	; 61
    cb14:	be b7       	in	r27, 0x3e	; 62
    cb16:	12 96       	adiw	r26, 0x02	; 2
    cb18:	1c 93       	st	X, r17
    cb1a:	0e 93       	st	-X, r16
    cb1c:	11 97       	sbiw	r26, 0x01	; 1
    cb1e:	93 82       	std	Z+3, r9	; 0x03
    cb20:	82 82       	std	Z+2, r8	; 0x02
    cb22:	01 96       	adiw	r24, 0x01	; 1
    cb24:	95 83       	std	Z+5, r25	; 0x05
    cb26:	84 83       	std	Z+4, r24	; 0x04
    cb28:	b7 82       	std	Z+7, r11	; 0x07
    cb2a:	a6 82       	std	Z+6, r10	; 0x06
    cb2c:	04 96       	adiw	r24, 0x04	; 4
    cb2e:	91 87       	std	Z+9, r25	; 0x09
    cb30:	80 87       	std	Z+8, r24	; 0x08
    cb32:	f3 86       	std	Z+11, r15	; 0x0b
    cb34:	e2 86       	std	Z+10, r14	; 0x0a
    cb36:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
                //sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
			    lcd_print((iLoop+1),1,lcdteks);
    cb3a:	ed b7       	in	r30, 0x3d	; 61
    cb3c:	fe b7       	in	r31, 0x3e	; 62
    cb3e:	3c 96       	adiw	r30, 0x0c	; 12
    cb40:	0f b6       	in	r0, 0x3f	; 63
    cb42:	f8 94       	cli
    cb44:	fe bf       	out	0x3e, r31	; 62
    cb46:	0f be       	out	0x3f, r0	; 63
    cb48:	ed bf       	out	0x3d, r30	; 61
    cb4a:	80 91 53 03 	lds	r24, 0x0353
    cb4e:	8f 5f       	subi	r24, 0xFF	; 255
    cb50:	61 e0       	ldi	r22, 0x01	; 1
    cb52:	a8 01       	movw	r20, r16
    cb54:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    cb58:	80 91 53 03 	lds	r24, 0x0353
    cb5c:	90 91 54 03 	lds	r25, 0x0354
    cb60:	01 96       	adiw	r24, 0x01	; 1
    cb62:	90 93 54 03 	sts	0x0354, r25
    cb66:	80 93 53 03 	sts	0x0353, r24
    cb6a:	a0 91 53 03 	lds	r26, 0x0353
    cb6e:	b0 91 54 03 	lds	r27, 0x0354
    cb72:	a4 30       	cpi	r26, 0x04	; 4
    cb74:	b1 05       	cpc	r27, r1
    cb76:	08 f4       	brcc	.+2      	; 0xcb7a <menu_FIP+0x1a0>
    cb78:	94 cf       	rjmp	.-216    	; 0xcaa2 <menu_FIP+0xc8>
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
                //sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
			    lcd_print((iLoop+1),1,lcdteks);
			}
		    lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
    cb7a:	81 e0       	ldi	r24, 0x01	; 1
    cb7c:	6f e0       	ldi	r22, 0x0F	; 15
    cb7e:	49 e9       	ldi	r20, 0x99	; 153
    cb80:	5b e1       	ldi	r21, 0x1B	; 27
    cb82:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		    lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
    cb86:	82 e0       	ldi	r24, 0x02	; 2
    cb88:	6f e0       	ldi	r22, 0x0F	; 15
    cb8a:	43 e9       	ldi	r20, 0x93	; 147
    cb8c:	5b e1       	ldi	r21, 0x1B	; 27
    cb8e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		    lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
    cb92:	83 e0       	ldi	r24, 0x03	; 3
    cb94:	6f e0       	ldi	r22, 0x0F	; 15
    cb96:	4d e8       	ldi	r20, 0x8D	; 141
    cb98:	5b e1       	ldi	r21, 0x1B	; 27
    cb9a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	        lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
    cb9e:	84 e0       	ldi	r24, 0x04	; 4
    cba0:	6f e0       	ldi	r22, 0x0F	; 15
    cba2:	46 e8       	ldi	r20, 0x86	; 134
    cba4:	5b e1       	ldi	r21, 0x1B	; 27
    cba6:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		    iLoop=0;
    cbaa:	10 92 54 03 	sts	0x0354, r1
    cbae:	10 92 53 03 	sts	0x0353, r1
		    stEnterFIP=efFIPInput;
    cbb2:	81 e0       	ldi	r24, 0x01	; 1
    cbb4:	86 c0       	rjmp	.+268    	; 0xccc2 <menu_FIP+0x2e8>
	        break;
	   case efFIPInput:
		    iLoop++;
    cbb6:	80 91 53 03 	lds	r24, 0x0353
    cbba:	90 91 54 03 	lds	r25, 0x0354
    cbbe:	01 96       	adiw	r24, 0x01	; 1
    cbc0:	90 93 54 03 	sts	0x0354, r25
    cbc4:	80 93 53 03 	sts	0x0353, r24
		    KeyPressed=_key_scan(1);
    cbc8:	81 e0       	ldi	r24, 0x01	; 1
    cbca:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    cbce:	80 93 57 03 	sts	0x0357, r24
		    KeyChar=_key_btn(KeyPressed);
    cbd2:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
    cbd6:	98 2f       	mov	r25, r24
    cbd8:	80 93 56 03 	sts	0x0356, r24
		    if ((KeyChar>='1')&&(KeyChar<='8')){
    cbdc:	81 53       	subi	r24, 0x31	; 49
    cbde:	88 30       	cpi	r24, 0x08	; 8
    cbe0:	60 f4       	brcc	.+24     	; 0xcbfa <menu_FIP+0x220>
		 	     if (KeyCharLast!=KeyChar){
    cbe2:	80 91 5a 01 	lds	r24, 0x015A
    cbe6:	89 17       	cp	r24, r25
    cbe8:	41 f0       	breq	.+16     	; 0xcbfa <menu_FIP+0x220>
				     KeyCharLast=KeyChar;
    cbea:	90 93 5a 01 	sts	0x015A, r25
				     iLoop=1000;
    cbee:	88 ee       	ldi	r24, 0xE8	; 232
    cbf0:	93 e0       	ldi	r25, 0x03	; 3
    cbf2:	90 93 54 03 	sts	0x0354, r25
    cbf6:	80 93 53 03 	sts	0x0353, r24
                 }
		    }
 		    if ((iLoop%2000)==0){
    cbfa:	80 91 53 03 	lds	r24, 0x0353
    cbfe:	90 91 54 03 	lds	r25, 0x0354
    cc02:	60 ed       	ldi	r22, 0xD0	; 208
    cc04:	77 e0       	ldi	r23, 0x07	; 7
    cc06:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
    cc0a:	89 2b       	or	r24, r25
    cc0c:	39 f4       	brne	.+14     	; 0xcc1c <menu_FIP+0x242>
		        lcd_xy(1,19);_lcd('_'); 
    cc0e:	81 e0       	ldi	r24, 0x01	; 1
    cc10:	63 e1       	ldi	r22, 0x13	; 19
    cc12:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
    cc16:	8f e5       	ldi	r24, 0x5F	; 95
    cc18:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
			   }
           if ((iLoop%2000)==1000){
    cc1c:	80 91 53 03 	lds	r24, 0x0353
    cc20:	90 91 54 03 	lds	r25, 0x0354
    cc24:	60 ed       	ldi	r22, 0xD0	; 208
    cc26:	77 e0       	ldi	r23, 0x07	; 7
    cc28:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
    cc2c:	88 5e       	subi	r24, 0xE8	; 232
    cc2e:	93 40       	sbci	r25, 0x03	; 3
    cc30:	41 f4       	brne	.+16     	; 0xcc42 <menu_FIP+0x268>
			    lcd_xy(1,19);_lcd(KeyCharLast); 
    cc32:	81 e0       	ldi	r24, 0x01	; 1
    cc34:	63 e1       	ldi	r22, 0x13	; 19
    cc36:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
    cc3a:	80 91 5a 01 	lds	r24, 0x015A
    cc3e:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
			   }

		   if (((KeyChar>='1')&&(KeyChar<='8'))||(KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')){ 
    cc42:	80 91 56 03 	lds	r24, 0x0356
    cc46:	81 53       	subi	r24, 0x31	; 49
    cc48:	88 30       	cpi	r24, 0x08	; 8
    cc4a:	40 f0       	brcs	.+16     	; 0xcc5c <menu_FIP+0x282>
    cc4c:	80 91 57 03 	lds	r24, 0x0357
    cc50:	87 3b       	cpi	r24, 0xB7	; 183
    cc52:	a1 f5       	brne	.+104    	; 0xccbc <menu_FIP+0x2e2>
    cc54:	80 91 5a 01 	lds	r24, 0x015A
    cc58:	80 32       	cpi	r24, 0x20	; 32
    cc5a:	c1 f1       	breq	.+112    	; 0xcccc <menu_FIP+0x2f2>
		         FIP_Used=FIP[KeyCharLast-'1'];
    cc5c:	80 91 5a 01 	lds	r24, 0x015A
    cc60:	fe 01       	movw	r30, r28
    cc62:	ba 97       	sbiw	r30, 0x2a	; 42
    cc64:	e8 0f       	add	r30, r24
    cc66:	f1 1d       	adc	r31, r1
    cc68:	20 81       	ld	r18, Z
    cc6a:	20 93 55 03 	sts	0x0355, r18
				 if (FIP_Used<=99){
    cc6e:	24 36       	cpi	r18, 0x64	; 100
    cc70:	00 f5       	brcc	.+64     	; 0xccb2 <menu_FIP+0x2d8>
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    cc72:	00 d0       	rcall	.+0      	; 0xcc74 <menu_FIP+0x29a>
    cc74:	00 d0       	rcall	.+0      	; 0xcc76 <menu_FIP+0x29c>
    cc76:	00 d0       	rcall	.+0      	; 0xcc78 <menu_FIP+0x29e>
    cc78:	ed b7       	in	r30, 0x3d	; 61
    cc7a:	fe b7       	in	r31, 0x3e	; 62
    cc7c:	31 96       	adiw	r30, 0x01	; 1
    cc7e:	ad b7       	in	r26, 0x3d	; 61
    cc80:	be b7       	in	r27, 0x3e	; 62
    cc82:	12 96       	adiw	r26, 0x02	; 2
    cc84:	1c 93       	st	X, r17
    cc86:	0e 93       	st	-X, r16
    cc88:	11 97       	sbiw	r26, 0x01	; 1
    cc8a:	8d e5       	ldi	r24, 0x5D	; 93
    cc8c:	9d e0       	ldi	r25, 0x0D	; 13
    cc8e:	93 83       	std	Z+3, r25	; 0x03
    cc90:	82 83       	std	Z+2, r24	; 0x02
    cc92:	24 83       	std	Z+4, r18	; 0x04
    cc94:	15 82       	std	Z+5, r1	; 0x05
    cc96:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		   if (((KeyChar>='1')&&(KeyChar<='8'))||(KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')){ 
		         FIP_Used=FIP[KeyCharLast-'1'];
				 if (FIP_Used<=99){
                    leadingZero(FIP_Used,sFIPUsed);
					 //sprintf_P(sFIPUsed,PSTR("%.2d"),FIP_Used);
					 xFIP[0]=FIP_Used;
    cc9a:	80 91 55 03 	lds	r24, 0x0355
    cc9e:	f7 01       	movw	r30, r14
    cca0:	80 83       	st	Z, r24
    cca2:	8d b7       	in	r24, 0x3d	; 61
    cca4:	9e b7       	in	r25, 0x3e	; 62
    cca6:	06 96       	adiw	r24, 0x06	; 6
    cca8:	0f b6       	in	r0, 0x3f	; 63
    ccaa:	f8 94       	cli
    ccac:	9e bf       	out	0x3e, r25	; 62
    ccae:	0f be       	out	0x3f, r0	; 63
    ccb0:	8d bf       	out	0x3d, r24	; 61
					 }
				 Result=FIP_DONE;
                 stEnterFIP=efExitFIPInput;
    ccb2:	82 e0       	ldi	r24, 0x02	; 2
    ccb4:	80 93 58 03 	sts	0x0358, r24
    ccb8:	80 e0       	ldi	r24, 0x00	; 0
    ccba:	09 c0       	rjmp	.+18     	; 0xccce <menu_FIP+0x2f4>
		   }
		   else
		   if (KeyPressed==_KEY_CANCEL){
    ccbc:	87 3e       	cpi	r24, 0xE7	; 231
    ccbe:	31 f4       	brne	.+12     	; 0xcccc <menu_FIP+0x2f2>
               Result=FIP_CANCEL;
			   stEnterFIP=efExitFIPInput;
    ccc0:	82 e0       	ldi	r24, 0x02	; 2
    ccc2:	80 93 58 03 	sts	0x0358, r24
    ccc6:	03 c0       	rjmp	.+6      	; 0xccce <menu_FIP+0x2f4>
		   }
	       break;
      case efExitFIPInput:
           stEnterFIP=efInit;
    ccc8:	10 92 58 03 	sts	0x0358, r1
    cccc:	81 e0       	ldi	r24, 0x01	; 1
	       break;
	 }
return Result;
}
    ccce:	a2 96       	adiw	r28, 0x22	; 34
    ccd0:	0f b6       	in	r0, 0x3f	; 63
    ccd2:	f8 94       	cli
    ccd4:	de bf       	out	0x3e, r29	; 62
    ccd6:	0f be       	out	0x3f, r0	; 63
    ccd8:	cd bf       	out	0x3d, r28	; 61
    ccda:	cf 91       	pop	r28
    ccdc:	df 91       	pop	r29
    ccde:	1f 91       	pop	r17
    cce0:	0f 91       	pop	r16
    cce2:	ff 90       	pop	r15
    cce4:	ef 90       	pop	r14
    cce6:	df 90       	pop	r13
    cce8:	cf 90       	pop	r12
    ccea:	bf 90       	pop	r11
    ccec:	af 90       	pop	r10
    ccee:	9f 90       	pop	r9
    ccf0:	8f 90       	pop	r8
    ccf2:	7f 90       	pop	r7
    ccf4:	6f 90       	pop	r6
    ccf6:	5f 90       	pop	r5
    ccf8:	4f 90       	pop	r4
    ccfa:	08 95       	ret

0000ccfc <FMenuEDCTransaction>:
	      break;
	 }
	 return Result;
}

char FMenuEDCTransaction(){
    ccfc:	0f 93       	push	r16
    ccfe:	1f 93       	push	r17
static char KeyPressed=0,FIP_Used=0,FIPResult;
       char lcdteks[20],Result=MENU_NONE;
//static unsigned int iLoop=0;

Result=MENU_NONE;
	 switch(stEtransaction){
    cd00:	80 91 4b 03 	lds	r24, 0x034B
    cd04:	85 30       	cpi	r24, 0x05	; 5
    cd06:	09 f4       	brne	.+2      	; 0xcd0a <FMenuEDCTransaction+0xe>
    cd08:	9f c0       	rjmp	.+318    	; 0xce48 <FMenuEDCTransaction+0x14c>
    cd0a:	86 30       	cpi	r24, 0x06	; 6
    cd0c:	90 f4       	brcc	.+36     	; 0xcd32 <FMenuEDCTransaction+0x36>
    cd0e:	82 30       	cpi	r24, 0x02	; 2
    cd10:	09 f4       	brne	.+2      	; 0xcd14 <FMenuEDCTransaction+0x18>
    cd12:	57 c0       	rjmp	.+174    	; 0xcdc2 <FMenuEDCTransaction+0xc6>
    cd14:	83 30       	cpi	r24, 0x03	; 3
    cd16:	30 f4       	brcc	.+12     	; 0xcd24 <FMenuEDCTransaction+0x28>
    cd18:	88 23       	and	r24, r24
    cd1a:	f1 f0       	breq	.+60     	; 0xcd58 <FMenuEDCTransaction+0x5c>
    cd1c:	81 30       	cpi	r24, 0x01	; 1
    cd1e:	09 f0       	breq	.+2      	; 0xcd22 <FMenuEDCTransaction+0x26>
    cd20:	dd c0       	rjmp	.+442    	; 0xcedc <FMenuEDCTransaction+0x1e0>
    cd22:	36 c0       	rjmp	.+108    	; 0xcd90 <FMenuEDCTransaction+0x94>
    cd24:	83 30       	cpi	r24, 0x03	; 3
    cd26:	09 f4       	brne	.+2      	; 0xcd2a <FMenuEDCTransaction+0x2e>
    cd28:	5e c0       	rjmp	.+188    	; 0xcde6 <FMenuEDCTransaction+0xea>
    cd2a:	84 30       	cpi	r24, 0x04	; 4
    cd2c:	09 f0       	breq	.+2      	; 0xcd30 <FMenuEDCTransaction+0x34>
    cd2e:	d6 c0       	rjmp	.+428    	; 0xcedc <FMenuEDCTransaction+0x1e0>
    cd30:	83 c0       	rjmp	.+262    	; 0xce38 <FMenuEDCTransaction+0x13c>
    cd32:	88 30       	cpi	r24, 0x08	; 8
    cd34:	09 f4       	brne	.+2      	; 0xcd38 <FMenuEDCTransaction+0x3c>
    cd36:	c2 c0       	rjmp	.+388    	; 0xcebc <FMenuEDCTransaction+0x1c0>
    cd38:	89 30       	cpi	r24, 0x09	; 9
    cd3a:	38 f4       	brcc	.+14     	; 0xcd4a <FMenuEDCTransaction+0x4e>
    cd3c:	86 30       	cpi	r24, 0x06	; 6
    cd3e:	09 f4       	brne	.+2      	; 0xcd42 <FMenuEDCTransaction+0x46>
    cd40:	98 c0       	rjmp	.+304    	; 0xce72 <FMenuEDCTransaction+0x176>
    cd42:	87 30       	cpi	r24, 0x07	; 7
    cd44:	09 f0       	breq	.+2      	; 0xcd48 <FMenuEDCTransaction+0x4c>
    cd46:	ca c0       	rjmp	.+404    	; 0xcedc <FMenuEDCTransaction+0x1e0>
    cd48:	96 c0       	rjmp	.+300    	; 0xce76 <FMenuEDCTransaction+0x17a>
    cd4a:	89 30       	cpi	r24, 0x09	; 9
    cd4c:	09 f4       	brne	.+2      	; 0xcd50 <FMenuEDCTransaction+0x54>
    cd4e:	bc c0       	rjmp	.+376    	; 0xcec8 <FMenuEDCTransaction+0x1cc>
    cd50:	8a 30       	cpi	r24, 0x0A	; 10
    cd52:	09 f0       	breq	.+2      	; 0xcd56 <FMenuEDCTransaction+0x5a>
    cd54:	c3 c0       	rjmp	.+390    	; 0xcedc <FMenuEDCTransaction+0x1e0>
    cd56:	be c0       	rjmp	.+380    	; 0xced4 <FMenuEDCTransaction+0x1d8>
	 case etInit:
	      lcd_clear();
    cd58:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Card Type"));
    cd5c:	81 e0       	ldi	r24, 0x01	; 1
    cd5e:	61 e0       	ldi	r22, 0x01	; 1
    cd60:	41 e1       	ldi	r20, 0x11	; 17
    cd62:	5a e1       	ldi	r21, 0x1A	; 26
    cd64:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          lcd_printf(1,1,PSTR("1.Debit/Flash Card  "));
    cd68:	81 e0       	ldi	r24, 0x01	; 1
    cd6a:	61 e0       	ldi	r22, 0x01	; 1
    cd6c:	4c ef       	ldi	r20, 0xFC	; 252
    cd6e:	59 e1       	ldi	r21, 0x19	; 25
    cd70:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Credit Card       "));
    cd74:	82 e0       	ldi	r24, 0x02	; 2
    cd76:	61 e0       	ldi	r22, 0x01	; 1
    cd78:	47 ee       	ldi	r20, 0xE7	; 231
    cd7a:	59 e1       	ldi	r21, 0x19	; 25
    cd7c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
    cd80:	84 e0       	ldi	r24, 0x04	; 4
    cd82:	61 e0       	ldi	r22, 0x01	; 1
    cd84:	42 ed       	ldi	r20, 0xD2	; 210
    cd86:	59 e1       	ldi	r21, 0x19	; 25
    cd88:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  stEtransaction=etInputEDC;
    cd8c:	81 e0       	ldi	r24, 0x01	; 1
    cd8e:	6e c0       	rjmp	.+220    	; 0xce6c <FMenuEDCTransaction+0x170>
	      break;
     case etInputEDC:
	 	  KeyPressed=_key_scan(1);
    cd90:	81 e0       	ldi	r24, 0x01	; 1
    cd92:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    cd96:	80 93 49 03 	sts	0x0349, r24
		  KeyChar=_key_btn(KeyPressed);
    cd9a:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
    cd9e:	98 2f       	mov	r25, r24
    cda0:	80 93 4a 03 	sts	0x034A, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
    cda4:	81 53       	subi	r24, 0x31	; 49
    cda6:	82 30       	cpi	r24, 0x02	; 2
    cda8:	30 f4       	brcc	.+12     	; 0xcdb6 <FMenuEDCTransaction+0xba>
		       EDCType=KeyChar-'0';
    cdaa:	90 53       	subi	r25, 0x30	; 48
    cdac:	90 93 ca 0b 	sts	0x0BCA, r25
		       stEtransaction=etSelectFIP;
    cdb0:	82 e0       	ldi	r24, 0x02	; 2
    cdb2:	80 93 4b 03 	sts	0x034B, r24
		     }
		  if (KeyPressed==_KEY_CANCEL)stEtransaction=etExitEDCTransaction;
    cdb6:	80 91 49 03 	lds	r24, 0x0349
    cdba:	87 3e       	cpi	r24, 0xE7	; 231
    cdbc:	09 f0       	breq	.+2      	; 0xcdc0 <FMenuEDCTransaction+0xc4>
    cdbe:	8e c0       	rjmp	.+284    	; 0xcedc <FMenuEDCTransaction+0x1e0>
    cdc0:	87 c0       	rjmp	.+270    	; 0xced0 <FMenuEDCTransaction+0x1d4>
	      break;
	 case etSelectFIP:
	      FIPResult=menu_FIP(FIP_Used,strFIP_ID);
    cdc2:	80 e0       	ldi	r24, 0x00	; 0
    cdc4:	90 e0       	ldi	r25, 0x00	; 0
    cdc6:	66 e8       	ldi	r22, 0x86	; 134
    cdc8:	79 e0       	ldi	r23, 0x09	; 9
    cdca:	0e 94 ed 64 	call	0xc9da	; 0xc9da <menu_FIP>
    cdce:	80 93 48 03 	sts	0x0348, r24
		  if (FIPResult==FIP_DONE)stEtransaction=etInitMessage90;
    cdd2:	88 23       	and	r24, r24
    cdd4:	11 f4       	brne	.+4      	; 0xcdda <FMenuEDCTransaction+0xde>
    cdd6:	83 e0       	ldi	r24, 0x03	; 3
    cdd8:	49 c0       	rjmp	.+146    	; 0xce6c <FMenuEDCTransaction+0x170>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
    cdda:	82 30       	cpi	r24, 0x02	; 2
    cddc:	09 f0       	breq	.+2      	; 0xcde0 <FMenuEDCTransaction+0xe4>
    cdde:	7e c0       	rjmp	.+252    	; 0xcedc <FMenuEDCTransaction+0x1e0>
    cde0:	10 92 4b 03 	sts	0x034B, r1
    cde4:	7b c0       	rjmp	.+246    	; 0xcedc <FMenuEDCTransaction+0x1e0>
    cde6:	e0 ee       	ldi	r30, 0xE0	; 224
    cde8:	ff e0       	ldi	r31, 0x0F	; 15
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    cdea:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    cdec:	8f e0       	ldi	r24, 0x0F	; 15
    cdee:	e5 3f       	cpi	r30, 0xF5	; 245
    cdf0:	f8 07       	cpc	r31, r24
    cdf2:	d9 f7       	brne	.-10     	; 0xcdea <FMenuEDCTransaction+0xee>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
	      break;
     case etInitMessage90:
	      FillChar(strRef1,sizeof(strRef1),0);
	      if (EDCType==1){
    cdf4:	80 91 ca 0b 	lds	r24, 0x0BCA
    cdf8:	81 30       	cpi	r24, 0x01	; 1
    cdfa:	19 f4       	brne	.+6      	; 0xce02 <FMenuEDCTransaction+0x106>
		      AddSpaceLag(strRef1,20);
    cdfc:	cf 01       	movw	r24, r30
    cdfe:	45 97       	sbiw	r24, 0x15	; 21
    ce00:	16 c0       	rjmp	.+44     	; 0xce2e <FMenuEDCTransaction+0x132>
          }
		  else
	      if (EDCType==2){
    ce02:	82 30       	cpi	r24, 0x02	; 2
    ce04:	b9 f4       	brne	.+46     	; 0xce34 <FMenuEDCTransaction+0x138>
		      sprintf_P(strRef1,PSTR("CREDITCARD"));
    ce06:	00 d0       	rcall	.+0      	; 0xce08 <FMenuEDCTransaction+0x10c>
    ce08:	00 d0       	rcall	.+0      	; 0xce0a <FMenuEDCTransaction+0x10e>
    ce0a:	8f 01       	movw	r16, r30
    ce0c:	05 51       	subi	r16, 0x15	; 21
    ce0e:	10 40       	sbci	r17, 0x00	; 0
    ce10:	ed b7       	in	r30, 0x3d	; 61
    ce12:	fe b7       	in	r31, 0x3e	; 62
    ce14:	12 83       	std	Z+2, r17	; 0x02
    ce16:	01 83       	std	Z+1, r16	; 0x01
    ce18:	87 ec       	ldi	r24, 0xC7	; 199
    ce1a:	99 e1       	ldi	r25, 0x19	; 25
    ce1c:	94 83       	std	Z+4, r25	; 0x04
    ce1e:	83 83       	std	Z+3, r24	; 0x03
    ce20:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			  AddSpaceLag(strRef1,20);
    ce24:	0f 90       	pop	r0
    ce26:	0f 90       	pop	r0
    ce28:	0f 90       	pop	r0
    ce2a:	0f 90       	pop	r0
    ce2c:	c8 01       	movw	r24, r16
    ce2e:	64 e1       	ldi	r22, 0x14	; 20
    ce30:	0e 94 3c 2e 	call	0x5c78	; 0x5c78 <AddSpaceLag>
		  }	 
	      stEtransaction=etSendingMessage90;
    ce34:	84 e0       	ldi	r24, 0x04	; 4
    ce36:	1a c0       	rjmp	.+52     	; 0xce6c <FMenuEDCTransaction+0x170>
	      break;
     case etSendingMessage90:
          sendMessage90();
    ce38:	0e 94 e2 4f 	call	0x9fc4	; 0x9fc4 <sendMessage90>
		  TimSend=0;
    ce3c:	10 92 a9 01 	sts	0x01A9, r1
    ce40:	10 92 a8 01 	sts	0x01A8, r1
          stEtransaction=etWaitReply;
    ce44:	85 e0       	ldi	r24, 0x05	; 5
    ce46:	12 c0       	rjmp	.+36     	; 0xce6c <FMenuEDCTransaction+0x170>
	      break;
     case etWaitReply:
	      if (TimSend>TIM_SEND*2)stEtransaction=etNoConnection;
    ce48:	80 91 a8 01 	lds	r24, 0x01A8
    ce4c:	90 91 a9 01 	lds	r25, 0x01A9
    ce50:	45 97       	sbiw	r24, 0x15	; 21
    ce52:	18 f0       	brcs	.+6      	; 0xce5a <FMenuEDCTransaction+0x15e>
    ce54:	88 e0       	ldi	r24, 0x08	; 8
    ce56:	80 93 4b 03 	sts	0x034B, r24
		  if ((IsMessage91==True)||(IsMessage09==True))
    ce5a:	80 91 be 01 	lds	r24, 0x01BE
    ce5e:	81 30       	cpi	r24, 0x01	; 1
    ce60:	21 f0       	breq	.+8      	; 0xce6a <FMenuEDCTransaction+0x16e>
    ce62:	80 91 ba 01 	lds	r24, 0x01BA
    ce66:	81 30       	cpi	r24, 0x01	; 1
    ce68:	c9 f5       	brne	.+114    	; 0xcedc <FMenuEDCTransaction+0x1e0>
		       stEtransaction=etSuccesEDC;
    ce6a:	86 e0       	ldi	r24, 0x06	; 6
    ce6c:	80 93 4b 03 	sts	0x034B, r24
    ce70:	35 c0       	rjmp	.+106    	; 0xcedc <FMenuEDCTransaction+0x1e0>
	      break;
     case etSuccesEDC:
	      stEtransaction=etDisplayFreeMessage;
    ce72:	87 e0       	ldi	r24, 0x07	; 7
    ce74:	fb cf       	rjmp	.-10     	; 0xce6c <FMenuEDCTransaction+0x170>
	      break;
     case etDisplayFreeMessage:
	      if (IsMessage09==True){
    ce76:	80 91 ba 01 	lds	r24, 0x01BA
    ce7a:	81 30       	cpi	r24, 0x01	; 1
    ce7c:	19 f5       	brne	.+70     	; 0xcec4 <FMenuEDCTransaction+0x1c8>
		      IsMessage09=False;
    ce7e:	10 92 ba 01 	sts	0x01BA, r1
	          procMessage09();
    ce82:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <procMessage09>
		      lcd_clear();
    ce86:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		      lcd_print(1,1,AdvanZ.Message09.strFreeMessageLine1);
    ce8a:	81 e0       	ldi	r24, 0x01	; 1
    ce8c:	61 e0       	ldi	r22, 0x01	; 1
    ce8e:	46 ee       	ldi	r20, 0xE6	; 230
    ce90:	59 e0       	ldi	r21, 0x09	; 9
    ce92:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		      lcd_print(2,1,AdvanZ.Message09.strFreeMessageLine2);
    ce96:	82 e0       	ldi	r24, 0x02	; 2
    ce98:	61 e0       	ldi	r22, 0x01	; 1
    ce9a:	4b ef       	ldi	r20, 0xFB	; 251
    ce9c:	59 e0       	ldi	r21, 0x09	; 9
    ce9e:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		      lcd_print(3,1,AdvanZ.Message09.strFreeMessageLine3);
    cea2:	83 e0       	ldi	r24, 0x03	; 3
    cea4:	61 e0       	ldi	r22, 0x01	; 1
    cea6:	40 e1       	ldi	r20, 0x10	; 16
    cea8:	5a e0       	ldi	r21, 0x0A	; 10
    ceaa:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			  lcd_print(4,1,AdvanZ.Message09.strFreeMessageLine4);
    ceae:	84 e0       	ldi	r24, 0x04	; 4
    ceb0:	61 e0       	ldi	r22, 0x01	; 1
    ceb2:	45 e2       	ldi	r20, 0x25	; 37
    ceb4:	5a e0       	ldi	r21, 0x0A	; 10
    ceb6:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    ceba:	02 c0       	rjmp	.+4      	; 0xcec0 <FMenuEDCTransaction+0x1c4>
			  TimDisplay=0;
			  }
		  stEtransaction=etDelayExit;
	      break;
     case etNoConnection:
	      lcd_clear();
    cebc:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  TimDisplay=0;
    cec0:	10 92 a7 01 	sts	0x01A7, r1
		  stEtransaction=etDelayExit;
    cec4:	89 e0       	ldi	r24, 0x09	; 9
    cec6:	d2 cf       	rjmp	.-92     	; 0xce6c <FMenuEDCTransaction+0x170>
	      break;
     case etDelayExit:
	      if (TimDisplay>8)stEtransaction=etExitEDCTransaction;
    cec8:	80 91 a7 01 	lds	r24, 0x01A7
    cecc:	89 30       	cpi	r24, 0x09	; 9
    cece:	30 f0       	brcs	.+12     	; 0xcedc <FMenuEDCTransaction+0x1e0>
    ced0:	8a e0       	ldi	r24, 0x0A	; 10
    ced2:	cc cf       	rjmp	.-104    	; 0xce6c <FMenuEDCTransaction+0x170>
	      break;
     case etExitEDCTransaction:
	      stEtransaction=etInit;
    ced4:	10 92 4b 03 	sts	0x034B, r1
    ced8:	81 e0       	ldi	r24, 0x01	; 1
    ceda:	01 c0       	rjmp	.+2      	; 0xcede <FMenuEDCTransaction+0x1e2>
    cedc:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    cede:	1f 91       	pop	r17
    cee0:	0f 91       	pop	r16
    cee2:	08 95       	ret

0000cee4 <FMenuLoyalty>:
	      break;
	 }
  return Result;
}

char FMenuLoyalty(){
    cee4:	cf 92       	push	r12
    cee6:	df 92       	push	r13
    cee8:	ef 92       	push	r14
    ceea:	ff 92       	push	r15
    ceec:	0f 93       	push	r16
    ceee:	1f 93       	push	r17
    cef0:	df 93       	push	r29
    cef2:	cf 93       	push	r28
    cef4:	cd b7       	in	r28, 0x3d	; 61
    cef6:	de b7       	in	r29, 0x3e	; 62
    cef8:	64 97       	sbiw	r28, 0x14	; 20
    cefa:	0f b6       	in	r0, 0x3f	; 63
    cefc:	f8 94       	cli
    cefe:	de bf       	out	0x3e, r29	; 62
    cf00:	0f be       	out	0x3f, r0	; 63
    cf02:	cd bf       	out	0x3d, r28	; 61
       char FIPResult,FIP_USED;
	   char Result=MENU_NONE;
	   char KeyChar;

     Result=MENU_NONE;
	 switch(stLoyalty){
    cf04:	00 91 4f 03 	lds	r16, 0x034F
    cf08:	07 30       	cpi	r16, 0x07	; 7
    cf0a:	09 f4       	brne	.+2      	; 0xcf0e <FMenuLoyalty+0x2a>
    cf0c:	08 c1       	rjmp	.+528    	; 0xd11e <FMenuLoyalty+0x23a>
    cf0e:	08 30       	cpi	r16, 0x08	; 8
    cf10:	98 f4       	brcc	.+38     	; 0xcf38 <FMenuLoyalty+0x54>
    cf12:	03 30       	cpi	r16, 0x03	; 3
    cf14:	09 f4       	brne	.+2      	; 0xcf18 <FMenuLoyalty+0x34>
    cf16:	5d c0       	rjmp	.+186    	; 0xcfd2 <FMenuLoyalty+0xee>
    cf18:	04 30       	cpi	r16, 0x04	; 4
    cf1a:	38 f4       	brcc	.+14     	; 0xcf2a <FMenuLoyalty+0x46>
    cf1c:	01 30       	cpi	r16, 0x01	; 1
    cf1e:	09 f4       	brne	.+2      	; 0xcf22 <FMenuLoyalty+0x3e>
    cf20:	42 c0       	rjmp	.+132    	; 0xcfa6 <FMenuLoyalty+0xc2>
    cf22:	02 30       	cpi	r16, 0x02	; 2
    cf24:	08 f0       	brcs	.+2      	; 0xcf28 <FMenuLoyalty+0x44>
    cf26:	63 c0       	rjmp	.+198    	; 0xcfee <FMenuLoyalty+0x10a>
    cf28:	20 c0       	rjmp	.+64     	; 0xcf6a <FMenuLoyalty+0x86>
    cf2a:	05 30       	cpi	r16, 0x05	; 5
    cf2c:	09 f4       	brne	.+2      	; 0xcf30 <FMenuLoyalty+0x4c>
    cf2e:	a4 c0       	rjmp	.+328    	; 0xd078 <FMenuLoyalty+0x194>
    cf30:	06 30       	cpi	r16, 0x06	; 6
    cf32:	08 f0       	brcs	.+2      	; 0xcf36 <FMenuLoyalty+0x52>
    cf34:	be c0       	rjmp	.+380    	; 0xd0b2 <FMenuLoyalty+0x1ce>
    cf36:	8e c0       	rjmp	.+284    	; 0xd054 <FMenuLoyalty+0x170>
    cf38:	0b 30       	cpi	r16, 0x0B	; 11
    cf3a:	09 f4       	brne	.+2      	; 0xcf3e <FMenuLoyalty+0x5a>
    cf3c:	3e c1       	rjmp	.+636    	; 0xd1ba <FMenuLoyalty+0x2d6>
    cf3e:	0c 30       	cpi	r16, 0x0C	; 12
    cf40:	38 f4       	brcc	.+14     	; 0xcf50 <FMenuLoyalty+0x6c>
    cf42:	09 30       	cpi	r16, 0x09	; 9
    cf44:	09 f4       	brne	.+2      	; 0xcf48 <FMenuLoyalty+0x64>
    cf46:	f6 c0       	rjmp	.+492    	; 0xd134 <FMenuLoyalty+0x250>
    cf48:	0a 30       	cpi	r16, 0x0A	; 10
    cf4a:	08 f0       	brcs	.+2      	; 0xcf4e <FMenuLoyalty+0x6a>
    cf4c:	18 c1       	rjmp	.+560    	; 0xd17e <FMenuLoyalty+0x29a>
    cf4e:	ea c0       	rjmp	.+468    	; 0xd124 <FMenuLoyalty+0x240>
    cf50:	0d 30       	cpi	r16, 0x0D	; 13
    cf52:	09 f4       	brne	.+2      	; 0xcf56 <FMenuLoyalty+0x72>
    cf54:	f6 c1       	rjmp	.+1004   	; 0xd342 <FMenuLoyalty+0x45e>
    cf56:	0d 30       	cpi	r16, 0x0D	; 13
    cf58:	08 f4       	brcc	.+2      	; 0xcf5c <FMenuLoyalty+0x78>
    cf5a:	ff c1       	rjmp	.+1022   	; 0xd35a <FMenuLoyalty+0x476>
    cf5c:	0e 30       	cpi	r16, 0x0E	; 14
    cf5e:	09 f4       	brne	.+2      	; 0xcf62 <FMenuLoyalty+0x7e>
    cf60:	0e c2       	rjmp	.+1052   	; 0xd37e <FMenuLoyalty+0x49a>
    cf62:	0f 30       	cpi	r16, 0x0F	; 15
    cf64:	09 f0       	breq	.+2      	; 0xcf68 <FMenuLoyalty+0x84>
    cf66:	17 c2       	rjmp	.+1070   	; 0xd396 <FMenuLoyalty+0x4b2>
    cf68:	10 c2       	rjmp	.+1056   	; 0xd38a <FMenuLoyalty+0x4a6>
	 case mlInit:
	      lcd_clear();
    cf6a:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("  Menu Loyalty   "));
    cf6e:	81 e0       	ldi	r24, 0x01	; 1
    cf70:	61 e0       	ldi	r22, 0x01	; 1
    cf72:	4e ef       	ldi	r20, 0xFE	; 254
    cf74:	5a e1       	ldi	r21, 0x1A	; 26
    cf76:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          lcd_printf(1,1,PSTR("1.Enquiry        "));
    cf7a:	81 e0       	ldi	r24, 0x01	; 1
    cf7c:	61 e0       	ldi	r22, 0x01	; 1
    cf7e:	4c ee       	ldi	r20, 0xEC	; 236
    cf80:	5a e1       	ldi	r21, 0x1A	; 26
    cf82:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Loyalty Update "));
    cf86:	82 e0       	ldi	r24, 0x02	; 2
    cf88:	61 e0       	ldi	r22, 0x01	; 1
    cf8a:	4a ed       	ldi	r20, 0xDA	; 218
    cf8c:	5a e1       	ldi	r21, 0x1A	; 26
    cf8e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back          "));
    cf92:	84 e0       	ldi	r24, 0x04	; 4
    cf94:	61 e0       	ldi	r22, 0x01	; 1
    cf96:	48 ec       	ldi	r20, 0xC8	; 200
    cf98:	5a e1       	ldi	r21, 0x1A	; 26
    cf9a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  IsLoyaltyUpdate=False;
    cf9e:	10 92 4c 03 	sts	0x034C, r1
		  stLoyalty=mlLoyaltySelect;
    cfa2:	81 e0       	ldi	r24, 0x01	; 1
    cfa4:	0a c0       	rjmp	.+20     	; 0xcfba <FMenuLoyalty+0xd6>
	      break;
	 case mlLoyaltySelect:
	 	  KeyPressed=_key_scan(1);
    cfa6:	81 e0       	ldi	r24, 0x01	; 1
    cfa8:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    cfac:	80 93 4e 03 	sts	0x034E, r24
		  if (KeyPressed==_KEY_1){
    cfb0:	8e 3e       	cpi	r24, 0xEE	; 238
    cfb2:	31 f4       	brne	.+12     	; 0xcfc0 <FMenuLoyalty+0xdc>
		      IsLoyaltyUpdate=False;
    cfb4:	10 92 4c 03 	sts	0x034C, r1
		      stLoyalty=mlShowEnquiry;
    cfb8:	84 e0       	ldi	r24, 0x04	; 4
    cfba:	80 93 4f 03 	sts	0x034F, r24
    cfbe:	eb c1       	rjmp	.+982    	; 0xd396 <FMenuLoyalty+0x4b2>
			  }
		  else
		  if (KeyPressed==_KEY_2){
    cfc0:	8e 3d       	cpi	r24, 0xDE	; 222
    cfc2:	19 f4       	brne	.+6      	; 0xcfca <FMenuLoyalty+0xe6>
		      IsLoyaltyUpdate=True;
    cfc4:	00 93 4c 03 	sts	0x034C, r16
    cfc8:	6b c0       	rjmp	.+214    	; 0xd0a0 <FMenuLoyalty+0x1bc>
			  stLoyalty=mlSelectFIP;
			  }
		  if (KeyPressed==_KEY_CANCEL)stLoyalty=mlExitLoyalty;
    cfca:	87 3e       	cpi	r24, 0xE7	; 231
    cfcc:	09 f4       	brne	.+2      	; 0xcfd0 <FMenuLoyalty+0xec>
    cfce:	db c1       	rjmp	.+950    	; 0xd386 <FMenuLoyalty+0x4a2>
    cfd0:	e2 c1       	rjmp	.+964    	; 0xd396 <FMenuLoyalty+0x4b2>
	      break;
     case mlSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
    cfd2:	8d e4       	ldi	r24, 0x4D	; 77
    cfd4:	93 e0       	ldi	r25, 0x03	; 3
    cfd6:	66 e8       	ldi	r22, 0x86	; 134
    cfd8:	79 e0       	ldi	r23, 0x09	; 9
    cfda:	0e 94 ed 64 	call	0xc9da	; 0xc9da <menu_FIP>
		  if (FIPResult==FIP_DONE)stLoyalty=mlUpdateLoyalty;
    cfde:	88 23       	and	r24, r24
    cfe0:	11 f4       	brne	.+4      	; 0xcfe6 <FMenuLoyalty+0x102>
    cfe2:	82 e0       	ldi	r24, 0x02	; 2
    cfe4:	ea cf       	rjmp	.-44     	; 0xcfba <FMenuLoyalty+0xd6>
		  else
		  if (FIPResult==FIP_CANCEL)stLoyalty=mlInit;
    cfe6:	82 30       	cpi	r24, 0x02	; 2
    cfe8:	09 f0       	breq	.+2      	; 0xcfec <FMenuLoyalty+0x108>
    cfea:	d5 c1       	rjmp	.+938    	; 0xd396 <FMenuLoyalty+0x4b2>
    cfec:	5b c0       	rjmp	.+182    	; 0xd0a4 <FMenuLoyalty+0x1c0>
	      break;
     case mlUpdateLoyalty: 
	      lcd_clear();
    cfee:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("FIP:%s"),strFIP_ID);
    cff2:	00 d0       	rcall	.+0      	; 0xcff4 <FMenuLoyalty+0x110>
    cff4:	00 d0       	rcall	.+0      	; 0xcff6 <FMenuLoyalty+0x112>
    cff6:	00 d0       	rcall	.+0      	; 0xcff8 <FMenuLoyalty+0x114>
    cff8:	ed b7       	in	r30, 0x3d	; 61
    cffa:	fe b7       	in	r31, 0x3e	; 62
    cffc:	31 96       	adiw	r30, 0x01	; 1
    cffe:	8e 01       	movw	r16, r28
    d000:	0f 5f       	subi	r16, 0xFF	; 255
    d002:	1f 4f       	sbci	r17, 0xFF	; 255
    d004:	ad b7       	in	r26, 0x3d	; 61
    d006:	be b7       	in	r27, 0x3e	; 62
    d008:	12 96       	adiw	r26, 0x02	; 2
    d00a:	1c 93       	st	X, r17
    d00c:	0e 93       	st	-X, r16
    d00e:	11 97       	sbiw	r26, 0x01	; 1
    d010:	81 ec       	ldi	r24, 0xC1	; 193
    d012:	9a e1       	ldi	r25, 0x1A	; 26
    d014:	93 83       	std	Z+3, r25	; 0x03
    d016:	82 83       	std	Z+2, r24	; 0x02
    d018:	86 e8       	ldi	r24, 0x86	; 134
    d01a:	99 e0       	ldi	r25, 0x09	; 9
    d01c:	95 83       	std	Z+5, r25	; 0x05
    d01e:	84 83       	std	Z+4, r24	; 0x04
    d020:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    d024:	8d b7       	in	r24, 0x3d	; 61
    d026:	9e b7       	in	r25, 0x3e	; 62
    d028:	06 96       	adiw	r24, 0x06	; 6
    d02a:	0f b6       	in	r0, 0x3f	; 63
    d02c:	f8 94       	cli
    d02e:	9e bf       	out	0x3e, r25	; 62
    d030:	0f be       	out	0x3f, r0	; 63
    d032:	8d bf       	out	0x3d, r24	; 61
    d034:	81 e0       	ldi	r24, 0x01	; 1
    d036:	61 e0       	ldi	r22, 0x01	; 1
    d038:	42 eb       	ldi	r20, 0xB2	; 178
    d03a:	5a e1       	ldi	r21, 0x1A	; 26
    d03c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_print(2,1,lcdteks);
    d040:	82 e0       	ldi	r24, 0x02	; 2
    d042:	61 e0       	ldi	r22, 0x01	; 1
    d044:	a8 01       	movw	r20, r16
    d046:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    d04a:	84 e0       	ldi	r24, 0x04	; 4
    d04c:	61 e0       	ldi	r22, 0x01	; 1
    d04e:	4f e9       	ldi	r20, 0x9F	; 159
    d050:	5a e1       	ldi	r21, 0x1A	; 26
    d052:	0c c0       	rjmp	.+24     	; 0xd06c <FMenuLoyalty+0x188>
		  IsRFIDDetected=False;
	      stLoyalty=mlInputRFID;
	      break;
	 case mlShowEnquiry:
	      lcd_clear();
    d054:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    d058:	81 e0       	ldi	r24, 0x01	; 1
    d05a:	61 e0       	ldi	r22, 0x01	; 1
    d05c:	40 e9       	ldi	r20, 0x90	; 144
    d05e:	5a e1       	ldi	r21, 0x1A	; 26
    d060:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    d064:	84 e0       	ldi	r24, 0x04	; 4
    d066:	61 e0       	ldi	r22, 0x01	; 1
    d068:	4d e7       	ldi	r20, 0x7D	; 125
    d06a:	5a e1       	ldi	r21, 0x1A	; 26
    d06c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  IsRFIDDetected=False;
    d070:	10 92 af 01 	sts	0x01AF, r1
		  stLoyalty=mlInputRFID;
    d074:	85 e0       	ldi	r24, 0x05	; 5
    d076:	a1 cf       	rjmp	.-190    	; 0xcfba <FMenuLoyalty+0xd6>
	      break;
     case mlInputRFID:
	      if (IsRFIDDetected==True){
    d078:	80 91 af 01 	lds	r24, 0x01AF
    d07c:	81 30       	cpi	r24, 0x01	; 1
    d07e:	29 f4       	brne	.+10     	; 0xd08a <FMenuLoyalty+0x1a6>
		      IsRFIDDetected=False;
    d080:	10 92 af 01 	sts	0x01AF, r1
		      stLoyalty=mlShowProsesRFID;
    d084:	86 e0       	ldi	r24, 0x06	; 6
    d086:	80 93 4f 03 	sts	0x034F, r24
		  }
	 	  KeyPressed=_key_scan(1);
    d08a:	81 e0       	ldi	r24, 0x01	; 1
    d08c:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    d090:	80 93 4e 03 	sts	0x034E, r24
		  if (KeyPressed==_KEY_CANCEL){
    d094:	87 3e       	cpi	r24, 0xE7	; 231
    d096:	49 f4       	brne	.+18     	; 0xd0aa <FMenuLoyalty+0x1c6>
		      if (IsLoyaltyUpdate==True)
    d098:	80 91 4c 03 	lds	r24, 0x034C
    d09c:	81 30       	cpi	r24, 0x01	; 1
    d09e:	11 f4       	brne	.+4      	; 0xd0a4 <FMenuLoyalty+0x1c0>
			       stLoyalty=mlSelectFIP;
    d0a0:	83 e0       	ldi	r24, 0x03	; 3
    d0a2:	8b cf       	rjmp	.-234    	; 0xcfba <FMenuLoyalty+0xd6>
			  else stLoyalty=mlInit;
    d0a4:	10 92 4f 03 	sts	0x034F, r1
    d0a8:	76 c1       	rjmp	.+748    	; 0xd396 <FMenuLoyalty+0x4b2>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stLoyalty=mlExitLoyalty;
    d0aa:	87 3b       	cpi	r24, 0xB7	; 183
    d0ac:	09 f0       	breq	.+2      	; 0xd0b0 <FMenuLoyalty+0x1cc>
    d0ae:	73 c1       	rjmp	.+742    	; 0xd396 <FMenuLoyalty+0x4b2>
    d0b0:	6a c1       	rjmp	.+724    	; 0xd386 <FMenuLoyalty+0x4a2>
	      break;
     case mlShowProsesRFID:
	      lcd_clear();
    d0b2:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("ID:%s"),strRFID);
    d0b6:	00 d0       	rcall	.+0      	; 0xd0b8 <FMenuLoyalty+0x1d4>
    d0b8:	00 d0       	rcall	.+0      	; 0xd0ba <FMenuLoyalty+0x1d6>
    d0ba:	00 d0       	rcall	.+0      	; 0xd0bc <FMenuLoyalty+0x1d8>
    d0bc:	ed b7       	in	r30, 0x3d	; 61
    d0be:	fe b7       	in	r31, 0x3e	; 62
    d0c0:	31 96       	adiw	r30, 0x01	; 1
    d0c2:	8e 01       	movw	r16, r28
    d0c4:	0f 5f       	subi	r16, 0xFF	; 255
    d0c6:	1f 4f       	sbci	r17, 0xFF	; 255
    d0c8:	ad b7       	in	r26, 0x3d	; 61
    d0ca:	be b7       	in	r27, 0x3e	; 62
    d0cc:	12 96       	adiw	r26, 0x02	; 2
    d0ce:	1c 93       	st	X, r17
    d0d0:	0e 93       	st	-X, r16
    d0d2:	11 97       	sbiw	r26, 0x01	; 1
    d0d4:	87 e7       	ldi	r24, 0x77	; 119
    d0d6:	9a e1       	ldi	r25, 0x1A	; 26
    d0d8:	93 83       	std	Z+3, r25	; 0x03
    d0da:	82 83       	std	Z+2, r24	; 0x02
    d0dc:	84 ea       	ldi	r24, 0xA4	; 164
    d0de:	9f e0       	ldi	r25, 0x0F	; 15
    d0e0:	95 83       	std	Z+5, r25	; 0x05
    d0e2:	84 83       	std	Z+4, r24	; 0x04
    d0e4:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print (1,1,lcdteks);	      
    d0e8:	8d b7       	in	r24, 0x3d	; 61
    d0ea:	9e b7       	in	r25, 0x3e	; 62
    d0ec:	06 96       	adiw	r24, 0x06	; 6
    d0ee:	0f b6       	in	r0, 0x3f	; 63
    d0f0:	f8 94       	cli
    d0f2:	9e bf       	out	0x3e, r25	; 62
    d0f4:	0f be       	out	0x3f, r0	; 63
    d0f6:	8d bf       	out	0x3d, r24	; 61
    d0f8:	81 e0       	ldi	r24, 0x01	; 1
    d0fa:	61 e0       	ldi	r22, 0x01	; 1
    d0fc:	a8 01       	movw	r20, r16
    d0fe:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_printf(2,1,PSTR("Proses"));	      
    d102:	82 e0       	ldi	r24, 0x02	; 2
    d104:	61 e0       	ldi	r22, 0x01	; 1
    d106:	40 e7       	ldi	r20, 0x70	; 112
    d108:	5a e1       	ldi	r21, 0x1A	; 26
    d10a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  if (IsLoyaltyUpdate==True)stLoyalty=mlSendMessage24;
    d10e:	80 91 4c 03 	lds	r24, 0x034C
    d112:	81 30       	cpi	r24, 0x01	; 1
    d114:	11 f4       	brne	.+4      	; 0xd11a <FMenuLoyalty+0x236>
    d116:	88 e0       	ldi	r24, 0x08	; 8
    d118:	50 cf       	rjmp	.-352    	; 0xcfba <FMenuLoyalty+0xd6>
		  else stLoyalty=mlSendMessage22;
    d11a:	87 e0       	ldi	r24, 0x07	; 7
    d11c:	4e cf       	rjmp	.-356    	; 0xcfba <FMenuLoyalty+0xd6>
	      break;
     case mlSendMessage22:
	      sendMessage22();
    d11e:	0e 94 54 53 	call	0xa6a8	; 0xa6a8 <sendMessage22>
    d122:	02 c0       	rjmp	.+4      	; 0xd128 <FMenuLoyalty+0x244>
		  TimSend=0;		  
          stLoyalty=mlWaitReply;
	      break;
     case mlSendMessage24:
	      sendMessage24();
    d124:	0e 94 c8 52 	call	0xa590	; 0xa590 <sendMessage24>
		  TimSend=0;		  
    d128:	10 92 a9 01 	sts	0x01A9, r1
    d12c:	10 92 a8 01 	sts	0x01A8, r1
          stLoyalty=mlWaitReply;
    d130:	89 e0       	ldi	r24, 0x09	; 9
    d132:	43 cf       	rjmp	.-378    	; 0xcfba <FMenuLoyalty+0xd6>
	      break;
     case mlWaitReply:
	      if (TimSend>(TIM_SEND*3))
    d134:	80 91 a8 01 	lds	r24, 0x01A8
    d138:	90 91 a9 01 	lds	r25, 0x01A9
    d13c:	4f 97       	sbiw	r24, 0x1f	; 31
    d13e:	18 f0       	brcs	.+6      	; 0xd146 <FMenuLoyalty+0x262>
		      stLoyalty=mlNoConnection;
    d140:	8c e0       	ldi	r24, 0x0C	; 12
    d142:	80 93 4f 03 	sts	0x034F, r24
	      if (IsMessage23==True){
    d146:	80 91 b9 01 	lds	r24, 0x01B9
    d14a:	81 30       	cpi	r24, 0x01	; 1
    d14c:	39 f4       	brne	.+14     	; 0xd15c <FMenuLoyalty+0x278>
		      IsMessage23=False;
    d14e:	10 92 b9 01 	sts	0x01B9, r1
			  procMessage23();
    d152:	0e 94 a0 17 	call	0x2f40	; 0x2f40 <procMessage23>
			  stLoyalty=mlDispEnquiry;
    d156:	8b e0       	ldi	r24, 0x0B	; 11
    d158:	80 93 4f 03 	sts	0x034F, r24
		  }
	      if (IsMessage09==True){
    d15c:	80 91 ba 01 	lds	r24, 0x01BA
    d160:	81 30       	cpi	r24, 0x01	; 1
    d162:	39 f4       	brne	.+14     	; 0xd172 <FMenuLoyalty+0x28e>
		      IsMessage09=False;
    d164:	10 92 ba 01 	sts	0x01BA, r1
	          procMessage09();
    d168:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <procMessage09>
              stLoyalty=mlDisplayFreeMessage;
    d16c:	8a e0       	ldi	r24, 0x0A	; 10
    d16e:	80 93 4f 03 	sts	0x034F, r24
		  }
	      if (IsMessage99==True){
    d172:	80 91 b6 01 	lds	r24, 0x01B6
    d176:	81 30       	cpi	r24, 0x01	; 1
    d178:	09 f0       	breq	.+2      	; 0xd17c <FMenuLoyalty+0x298>
    d17a:	0d c1       	rjmp	.+538    	; 0xd396 <FMenuLoyalty+0x4b2>
    d17c:	1c c0       	rjmp	.+56     	; 0xd1b6 <FMenuLoyalty+0x2d2>
              stLoyalty=mlDelayExitLoyalty;
		  }
	      break;
     case mlDisplayFreeMessage:
		  lcd_clear();
    d17e:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_print(1,1,AdvanZ.Message09.strFreeMessageLine1);
    d182:	81 e0       	ldi	r24, 0x01	; 1
    d184:	61 e0       	ldi	r22, 0x01	; 1
    d186:	46 ee       	ldi	r20, 0xE6	; 230
    d188:	59 e0       	ldi	r21, 0x09	; 9
    d18a:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_print(2,1,AdvanZ.Message09.strFreeMessageLine2);
    d18e:	82 e0       	ldi	r24, 0x02	; 2
    d190:	61 e0       	ldi	r22, 0x01	; 1
    d192:	4b ef       	ldi	r20, 0xFB	; 251
    d194:	59 e0       	ldi	r21, 0x09	; 9
    d196:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_print(3,1,AdvanZ.Message09.strFreeMessageLine3);
    d19a:	83 e0       	ldi	r24, 0x03	; 3
    d19c:	61 e0       	ldi	r22, 0x01	; 1
    d19e:	40 e1       	ldi	r20, 0x10	; 16
    d1a0:	5a e0       	ldi	r21, 0x0A	; 10
    d1a2:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_print(4,1,AdvanZ.Message09.strFreeMessageLine4);
    d1a6:	84 e0       	ldi	r24, 0x04	; 4
    d1a8:	61 e0       	ldi	r22, 0x01	; 1
    d1aa:	45 e2       	ldi	r20, 0x25	; 37
    d1ac:	5a e0       	ldi	r21, 0x0A	; 10
    d1ae:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  TimDisplay=0;
    d1b2:	10 92 a7 01 	sts	0x01A7, r1
		  stLoyalty=mlDelayExitLoyalty;
    d1b6:	8e e0       	ldi	r24, 0x0E	; 14
    d1b8:	00 cf       	rjmp	.-512    	; 0xcfba <FMenuLoyalty+0xd6>
	      break;
     case mlDispEnquiry:	      
	      lcd_clear();
    d1ba:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  RemSpaceLag(strCardID);RemSpaceLag(strCardHolder);
    d1be:	2f ee       	ldi	r18, 0xEF	; 239
    d1c0:	c2 2e       	mov	r12, r18
    d1c2:	2e e0       	ldi	r18, 0x0E	; 14
    d1c4:	d2 2e       	mov	r13, r18
    d1c6:	c6 01       	movw	r24, r12
    d1c8:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
    d1cc:	94 e0       	ldi	r25, 0x04	; 4
    d1ce:	e9 2e       	mov	r14, r25
    d1d0:	95 e0       	ldi	r25, 0x05	; 5
    d1d2:	f9 2e       	mov	r15, r25
    d1d4:	c7 01       	movw	r24, r14
    d1d6:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("%s:%s"),strCardID,strCardHolder);
    d1da:	ad b7       	in	r26, 0x3d	; 61
    d1dc:	be b7       	in	r27, 0x3e	; 62
    d1de:	18 97       	sbiw	r26, 0x08	; 8
    d1e0:	0f b6       	in	r0, 0x3f	; 63
    d1e2:	f8 94       	cli
    d1e4:	be bf       	out	0x3e, r27	; 62
    d1e6:	0f be       	out	0x3f, r0	; 63
    d1e8:	ad bf       	out	0x3d, r26	; 61
    d1ea:	ed b7       	in	r30, 0x3d	; 61
    d1ec:	fe b7       	in	r31, 0x3e	; 62
    d1ee:	31 96       	adiw	r30, 0x01	; 1
    d1f0:	8e 01       	movw	r16, r28
    d1f2:	0f 5f       	subi	r16, 0xFF	; 255
    d1f4:	1f 4f       	sbci	r17, 0xFF	; 255
    d1f6:	12 96       	adiw	r26, 0x02	; 2
    d1f8:	1c 93       	st	X, r17
    d1fa:	0e 93       	st	-X, r16
    d1fc:	11 97       	sbiw	r26, 0x01	; 1
    d1fe:	8a e6       	ldi	r24, 0x6A	; 106
    d200:	9a e1       	ldi	r25, 0x1A	; 26
    d202:	93 83       	std	Z+3, r25	; 0x03
    d204:	82 83       	std	Z+2, r24	; 0x02
    d206:	d5 82       	std	Z+5, r13	; 0x05
    d208:	c4 82       	std	Z+4, r12	; 0x04
    d20a:	f7 82       	std	Z+7, r15	; 0x07
    d20c:	e6 82       	std	Z+6, r14	; 0x06
    d20e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(1,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d212:	8d b7       	in	r24, 0x3d	; 61
    d214:	9e b7       	in	r25, 0x3e	; 62
    d216:	08 96       	adiw	r24, 0x08	; 8
    d218:	0f b6       	in	r0, 0x3f	; 63
    d21a:	f8 94       	cli
    d21c:	9e bf       	out	0x3e, r25	; 62
    d21e:	0f be       	out	0x3f, r0	; 63
    d220:	8d bf       	out	0x3d, r24	; 61
    d222:	81 e0       	ldi	r24, 0x01	; 1
    d224:	61 e0       	ldi	r22, 0x01	; 1
    d226:	a8 01       	movw	r20, r16
    d228:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    d22c:	8e ed       	ldi	r24, 0xDE	; 222
    d22e:	e8 2e       	mov	r14, r24
    d230:	8b e0       	ldi	r24, 0x0B	; 11
    d232:	f8 2e       	mov	r15, r24
    d234:	c7 01       	movw	r24, r14
    d236:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Points:%s"),strLoyCurrentPoints);
    d23a:	00 d0       	rcall	.+0      	; 0xd23c <FMenuLoyalty+0x358>
    d23c:	00 d0       	rcall	.+0      	; 0xd23e <FMenuLoyalty+0x35a>
    d23e:	00 d0       	rcall	.+0      	; 0xd240 <FMenuLoyalty+0x35c>
    d240:	ed b7       	in	r30, 0x3d	; 61
    d242:	fe b7       	in	r31, 0x3e	; 62
    d244:	31 96       	adiw	r30, 0x01	; 1
    d246:	ad b7       	in	r26, 0x3d	; 61
    d248:	be b7       	in	r27, 0x3e	; 62
    d24a:	12 96       	adiw	r26, 0x02	; 2
    d24c:	1c 93       	st	X, r17
    d24e:	0e 93       	st	-X, r16
    d250:	11 97       	sbiw	r26, 0x01	; 1
    d252:	80 e6       	ldi	r24, 0x60	; 96
    d254:	9a e1       	ldi	r25, 0x1A	; 26
    d256:	93 83       	std	Z+3, r25	; 0x03
    d258:	82 83       	std	Z+2, r24	; 0x02
    d25a:	f5 82       	std	Z+5, r15	; 0x05
    d25c:	e4 82       	std	Z+4, r14	; 0x04
    d25e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(2,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d262:	8d b7       	in	r24, 0x3d	; 61
    d264:	9e b7       	in	r25, 0x3e	; 62
    d266:	06 96       	adiw	r24, 0x06	; 6
    d268:	0f b6       	in	r0, 0x3f	; 63
    d26a:	f8 94       	cli
    d26c:	9e bf       	out	0x3e, r25	; 62
    d26e:	0f be       	out	0x3f, r0	; 63
    d270:	8d bf       	out	0x3d, r24	; 61
    d272:	82 e0       	ldi	r24, 0x02	; 2
    d274:	61 e0       	ldi	r22, 0x01	; 1
    d276:	a8 01       	movw	r20, r16
    d278:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    d27c:	c7 01       	movw	r24, r14
    d27e:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("CM Amt:%s"),strLoyCurrMonConsumeA);
    d282:	00 d0       	rcall	.+0      	; 0xd284 <FMenuLoyalty+0x3a0>
    d284:	00 d0       	rcall	.+0      	; 0xd286 <FMenuLoyalty+0x3a2>
    d286:	00 d0       	rcall	.+0      	; 0xd288 <FMenuLoyalty+0x3a4>
    d288:	ed b7       	in	r30, 0x3d	; 61
    d28a:	fe b7       	in	r31, 0x3e	; 62
    d28c:	31 96       	adiw	r30, 0x01	; 1
    d28e:	ad b7       	in	r26, 0x3d	; 61
    d290:	be b7       	in	r27, 0x3e	; 62
    d292:	12 96       	adiw	r26, 0x02	; 2
    d294:	1c 93       	st	X, r17
    d296:	0e 93       	st	-X, r16
    d298:	11 97       	sbiw	r26, 0x01	; 1
    d29a:	86 e5       	ldi	r24, 0x56	; 86
    d29c:	9a e1       	ldi	r25, 0x1A	; 26
    d29e:	93 83       	std	Z+3, r25	; 0x03
    d2a0:	82 83       	std	Z+2, r24	; 0x02
    d2a2:	8e e5       	ldi	r24, 0x5E	; 94
    d2a4:	95 e0       	ldi	r25, 0x05	; 5
    d2a6:	95 83       	std	Z+5, r25	; 0x05
    d2a8:	84 83       	std	Z+4, r24	; 0x04
    d2aa:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(3,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d2ae:	8d b7       	in	r24, 0x3d	; 61
    d2b0:	9e b7       	in	r25, 0x3e	; 62
    d2b2:	06 96       	adiw	r24, 0x06	; 6
    d2b4:	0f b6       	in	r0, 0x3f	; 63
    d2b6:	f8 94       	cli
    d2b8:	9e bf       	out	0x3e, r25	; 62
    d2ba:	0f be       	out	0x3f, r0	; 63
    d2bc:	8d bf       	out	0x3d, r24	; 61
    d2be:	83 e0       	ldi	r24, 0x03	; 3
    d2c0:	61 e0       	ldi	r22, 0x01	; 1
    d2c2:	a8 01       	movw	r20, r16
    d2c4:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    d2c8:	c7 01       	movw	r24, r14
    d2ca:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Cm Vol:%s"),strLoyCurrMonConsumeV);
    d2ce:	00 d0       	rcall	.+0      	; 0xd2d0 <FMenuLoyalty+0x3ec>
    d2d0:	00 d0       	rcall	.+0      	; 0xd2d2 <FMenuLoyalty+0x3ee>
    d2d2:	00 d0       	rcall	.+0      	; 0xd2d4 <FMenuLoyalty+0x3f0>
    d2d4:	ed b7       	in	r30, 0x3d	; 61
    d2d6:	fe b7       	in	r31, 0x3e	; 62
    d2d8:	31 96       	adiw	r30, 0x01	; 1
    d2da:	ad b7       	in	r26, 0x3d	; 61
    d2dc:	be b7       	in	r27, 0x3e	; 62
    d2de:	12 96       	adiw	r26, 0x02	; 2
    d2e0:	1c 93       	st	X, r17
    d2e2:	0e 93       	st	-X, r16
    d2e4:	11 97       	sbiw	r26, 0x01	; 1
    d2e6:	8c e4       	ldi	r24, 0x4C	; 76
    d2e8:	9a e1       	ldi	r25, 0x1A	; 26
    d2ea:	93 83       	std	Z+3, r25	; 0x03
    d2ec:	82 83       	std	Z+2, r24	; 0x02
    d2ee:	80 e4       	ldi	r24, 0x40	; 64
    d2f0:	9f e0       	ldi	r25, 0x0F	; 15
    d2f2:	95 83       	std	Z+5, r25	; 0x05
    d2f4:	84 83       	std	Z+4, r24	; 0x04
    d2f6:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(4,1,lcdteks);
    d2fa:	8d b7       	in	r24, 0x3d	; 61
    d2fc:	9e b7       	in	r25, 0x3e	; 62
    d2fe:	06 96       	adiw	r24, 0x06	; 6
    d300:	0f b6       	in	r0, 0x3f	; 63
    d302:	f8 94       	cli
    d304:	9e bf       	out	0x3e, r25	; 62
    d306:	0f be       	out	0x3f, r0	; 63
    d308:	8d bf       	out	0x3d, r24	; 61
    d30a:	84 e0       	ldi	r24, 0x04	; 4
    d30c:	61 e0       	ldi	r22, 0x01	; 1
    d30e:	a8 01       	movw	r20, r16
    d310:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  TimDisplay=0;
    d314:	10 92 a7 01 	sts	0x01A7, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    d318:	e1 99       	sbic	0x1c, 1	; 28
    d31a:	fe cf       	rjmp	.-4      	; 0xd318 <FMenuLoyalty+0x434>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    d31c:	88 e3       	ldi	r24, 0x38	; 56
    d31e:	90 e0       	ldi	r25, 0x00	; 0
    d320:	9f bb       	out	0x1f, r25	; 31
    d322:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    d324:	e0 9a       	sbi	0x1c, 0	; 28
    d326:	8d b3       	in	r24, 0x1d	; 29

		  if (eeprom_read_byte(&DefNotifScreen)==1) {
    d328:	81 30       	cpi	r24, 0x01	; 1
    d32a:	09 f0       	breq	.+2      	; 0xd32e <FMenuLoyalty+0x44a>
    d32c:	44 cf       	rjmp	.-376    	; 0xd1b6 <FMenuLoyalty+0x2d2>
		      stLoyalty=mlPressAnyKey;
    d32e:	8d e0       	ldi	r24, 0x0D	; 13
    d330:	80 93 4f 03 	sts	0x034F, r24
			  lcd_printf(2,1,PSTR("Press Any Key"));
    d334:	82 e0       	ldi	r24, 0x02	; 2
    d336:	61 e0       	ldi	r22, 0x01	; 1
    d338:	4e e3       	ldi	r20, 0x3E	; 62
    d33a:	5a e1       	ldi	r21, 0x1A	; 26
    d33c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
    d340:	2a c0       	rjmp	.+84     	; 0xd396 <FMenuLoyalty+0x4b2>
          } else stLoyalty=mlDelayExitLoyalty;
		  break;
     case mlPressAnyKey:
	      KeyPressed=_key_scan(1);
    d342:	81 e0       	ldi	r24, 0x01	; 1
    d344:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    d348:	80 93 4e 03 	sts	0x034E, r24
	      KeyChar=_key_btn(KeyPressed);
    d34c:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
	      switch(KeyChar){		  
    d350:	83 32       	cpi	r24, 0x23	; 35
    d352:	c9 f0       	breq	.+50     	; 0xd386 <FMenuLoyalty+0x4a2>
    d354:	8a 32       	cpi	r24, 0x2A	; 42
    d356:	f9 f4       	brne	.+62     	; 0xd396 <FMenuLoyalty+0x4b2>
    d358:	16 c0       	rjmp	.+44     	; 0xd386 <FMenuLoyalty+0x4a2>
               stLoyalty=mlExitLoyalty;
		       break;		  
		  }
	      break;
     case mlNoConnection:
	      lcd_clear();
    d35a:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
    d35e:	82 e0       	ldi	r24, 0x02	; 2
    d360:	61 e0       	ldi	r22, 0x01	; 1
    d362:	40 e3       	ldi	r20, 0x30	; 48
    d364:	5a e1       	ldi	r21, 0x1A	; 26
    d366:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
    d36a:	83 e0       	ldi	r24, 0x03	; 3
    d36c:	61 e0       	ldi	r22, 0x01	; 1
    d36e:	42 e2       	ldi	r20, 0x22	; 34
    d370:	5a e1       	ldi	r21, 0x1A	; 26
    d372:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  TimDisplay=5;
    d376:	85 e0       	ldi	r24, 0x05	; 5
    d378:	80 93 a7 01 	sts	0x01A7, r24
    d37c:	1c cf       	rjmp	.-456    	; 0xd1b6 <FMenuLoyalty+0x2d2>
		  stLoyalty=mlDelayExitLoyalty;
	      break;
     case mlDelayExitLoyalty:
          if(TimDisplay>=10)stLoyalty=mlExitLoyalty;
    d37e:	80 91 a7 01 	lds	r24, 0x01A7
    d382:	8a 30       	cpi	r24, 0x0A	; 10
    d384:	40 f0       	brcs	.+16     	; 0xd396 <FMenuLoyalty+0x4b2>
    d386:	8f e0       	ldi	r24, 0x0F	; 15
    d388:	18 ce       	rjmp	.-976    	; 0xcfba <FMenuLoyalty+0xd6>
	      break;
	 case mlExitLoyalty:
	      lcd_clear();
    d38a:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
	      stLoyalty=mlInit;
    d38e:	10 92 4f 03 	sts	0x034F, r1
    d392:	81 e0       	ldi	r24, 0x01	; 1
    d394:	01 c0       	rjmp	.+2      	; 0xd398 <FMenuLoyalty+0x4b4>
    d396:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 return Result;
}
    d398:	64 96       	adiw	r28, 0x14	; 20
    d39a:	0f b6       	in	r0, 0x3f	; 63
    d39c:	f8 94       	cli
    d39e:	de bf       	out	0x3e, r29	; 62
    d3a0:	0f be       	out	0x3f, r0	; 63
    d3a2:	cd bf       	out	0x3d, r28	; 61
    d3a4:	cf 91       	pop	r28
    d3a6:	df 91       	pop	r29
    d3a8:	1f 91       	pop	r17
    d3aa:	0f 91       	pop	r16
    d3ac:	ff 90       	pop	r15
    d3ae:	ef 90       	pop	r14
    d3b0:	df 90       	pop	r13
    d3b2:	cf 90       	pop	r12
    d3b4:	08 95       	ret

0000d3b6 <ValidateRestoreCode>:
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
     WrapCode(strKeyStamp);
}

char ValidateRestoreCode(char *sKeyStamp, char *sRestoreCode){//==RC_VALID
    d3b6:	ef 92       	push	r14
    d3b8:	ff 92       	push	r15
    d3ba:	0f 93       	push	r16
    d3bc:	1f 93       	push	r17
    d3be:	cf 93       	push	r28
    d3c0:	df 93       	push	r29
    d3c2:	ec 01       	movw	r28, r24
    d3c4:	7b 01       	movw	r14, r22

	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //_uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
    d3c6:	08 81       	ld	r16, Y
    d3c8:	00 53       	subi	r16, 0x30	; 48
    d3ca:	10 e0       	ldi	r17, 0x00	; 0
    d3cc:	04 c0       	rjmp	.+8      	; 0xd3d6 <ValidateRestoreCode+0x20>
	 for (i=0;i<nSum;i++){
         WrapCode(sKeyStamp);
    d3ce:	ce 01       	movw	r24, r28
    d3d0:	0e 94 75 31 	call	0x62ea	; 0x62ea <WrapCode>
	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //_uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
	 for (i=0;i<nSum;i++){
    d3d4:	1f 5f       	subi	r17, 0xFF	; 255
    d3d6:	10 17       	cp	r17, r16
    d3d8:	d0 f3       	brcs	.-12     	; 0xd3ce <ValidateRestoreCode+0x18>
	 //_uart_print(1,1,strSend);
     
	 //sprintf_P(strSend,PSTR("WrapStamp:%s"),sRestoreCode);
	 //_uart_print(1,1,strSend);

	 if (strcmp(sKeyStamp,sRestoreCode)==0)
    d3da:	ce 01       	movw	r24, r28
    d3dc:	b7 01       	movw	r22, r14
    d3de:	0e 94 62 b5 	call	0x16ac4	; 0x16ac4 <strcmp>
    d3e2:	00 97       	sbiw	r24, 0x00	; 0
    d3e4:	11 f0       	breq	.+4      	; 0xd3ea <ValidateRestoreCode+0x34>
    d3e6:	82 e0       	ldi	r24, 0x02	; 2
    d3e8:	01 c0       	rjmp	.+2      	; 0xd3ec <ValidateRestoreCode+0x36>
    d3ea:	81 e0       	ldi	r24, 0x01	; 1
	     Result=RC_VALID;	 
     else Result=RC_INVALID;

   return Result;
}
    d3ec:	df 91       	pop	r29
    d3ee:	cf 91       	pop	r28
    d3f0:	1f 91       	pop	r17
    d3f2:	0f 91       	pop	r16
    d3f4:	ff 90       	pop	r15
    d3f6:	ef 90       	pop	r14
    d3f8:	08 95       	ret

0000d3fa <ValidateGeniusCode>:
          }
	 }sTemp[iAdd]=0;
	 sprintf_P(strSource,PSTR("%s"),sTemp);
}

char ValidateGeniusCode(char *sDate, char *sGenCode){//==GC_VALID
    d3fa:	ef 92       	push	r14
    d3fc:	ff 92       	push	r15
    d3fe:	0f 93       	push	r16
    d400:	1f 93       	push	r17
    d402:	df 93       	push	r29
    d404:	cf 93       	push	r28
    d406:	cd b7       	in	r28, 0x3d	; 61
    d408:	de b7       	in	r29, 0x3e	; 62
    d40a:	2a 97       	sbiw	r28, 0x0a	; 10
    d40c:	0f b6       	in	r0, 0x3f	; 63
    d40e:	f8 94       	cli
    d410:	de bf       	out	0x3e, r29	; 62
    d412:	0f be       	out	0x3f, r0	; 63
    d414:	cd bf       	out	0x3d, r28	; 61
    d416:	7b 01       	movw	r14, r22

         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("[%s]"),sGenCode); 
         _uart_print(1,1,strSend);
		 #endif
	 if (strlen(sGenCode)==8){//Length musti  8
    d418:	fb 01       	movw	r30, r22
    d41a:	01 90       	ld	r0, Z+
    d41c:	00 20       	and	r0, r0
    d41e:	e9 f7       	brne	.-6      	; 0xd41a <ValidateGeniusCode+0x20>
    d420:	39 97       	sbiw	r30, 0x09	; 9
    d422:	e6 17       	cp	r30, r22
    d424:	f7 07       	cpc	r31, r23
    d426:	11 f0       	breq	.+4      	; 0xd42c <ValidateGeniusCode+0x32>
    d428:	80 e0       	ldi	r24, 0x00	; 0
    d42a:	11 c0       	rjmp	.+34     	; 0xd44e <ValidateGeniusCode+0x54>
	     //sDate: 05012001		 
		 GenerateGeniusCode(sDate,sGenCode[0],sAutoGen);
    d42c:	fb 01       	movw	r30, r22
    d42e:	60 81       	ld	r22, Z
    d430:	8e 01       	movw	r16, r28
    d432:	0f 5f       	subi	r16, 0xFF	; 255
    d434:	1f 4f       	sbci	r17, 0xFF	; 255
    d436:	a8 01       	movw	r20, r16
    d438:	0e 94 73 32 	call	0x64e6	; 0x64e6 <GenerateGeniusCode>
         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("%s|%s"),sAutoGen,sGenCode); 
         _uart_print(1,1,strSend);
		 #endif

         if (strcmp(sAutoGen,sGenCode)==0)
    d43c:	c8 01       	movw	r24, r16
    d43e:	b7 01       	movw	r22, r14
    d440:	0e 94 62 b5 	call	0x16ac4	; 0x16ac4 <strcmp>
    d444:	00 97       	sbiw	r24, 0x00	; 0
    d446:	11 f0       	breq	.+4      	; 0xd44c <ValidateGeniusCode+0x52>
    d448:	82 e0       	ldi	r24, 0x02	; 2
    d44a:	01 c0       	rjmp	.+2      	; 0xd44e <ValidateGeniusCode+0x54>
    d44c:	81 e0       	ldi	r24, 0x01	; 1
         else Result=GC_INVALID;
	 }


   return Result;
}
    d44e:	2a 96       	adiw	r28, 0x0a	; 10
    d450:	0f b6       	in	r0, 0x3f	; 63
    d452:	f8 94       	cli
    d454:	de bf       	out	0x3e, r29	; 62
    d456:	0f be       	out	0x3f, r0	; 63
    d458:	cd bf       	out	0x3d, r28	; 61
    d45a:	cf 91       	pop	r28
    d45c:	df 91       	pop	r29
    d45e:	1f 91       	pop	r17
    d460:	0f 91       	pop	r16
    d462:	ff 90       	pop	r15
    d464:	ef 90       	pop	r14
    d466:	08 95       	ret

0000d468 <FMenuSettingServerIP>:
		       break;     
		  }//EndSwitch	 
    return Result;
}

char FMenuSettingServerIP(){
    d468:	0f 93       	push	r16
    d46a:	1f 93       	push	r17
    d46c:	df 93       	push	r29
    d46e:	cf 93       	push	r28
    d470:	cd b7       	in	r28, 0x3d	; 61
    d472:	de b7       	in	r29, 0x3e	; 62
    d474:	64 97       	sbiw	r28, 0x14	; 20
    d476:	0f b6       	in	r0, 0x3f	; 63
    d478:	f8 94       	cli
    d47a:	de bf       	out	0x3e, r29	; 62
    d47c:	0f be       	out	0x3f, r0	; 63
    d47e:	cd bf       	out	0x3d, r28	; 61
     //Server IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
	 Result=MENU_NONE;
    d480:	10 92 01 03 	sts	0x0301, r1
     switch(stClientIP){
    d484:	80 91 58 01 	lds	r24, 0x0158
    d488:	82 30       	cpi	r24, 0x02	; 2
    d48a:	09 f4       	brne	.+2      	; 0xd48e <FMenuSettingServerIP+0x26>
    d48c:	7b c0       	rjmp	.+246    	; 0xd584 <FMenuSettingServerIP+0x11c>
    d48e:	83 30       	cpi	r24, 0x03	; 3
    d490:	20 f4       	brcc	.+8      	; 0xd49a <FMenuSettingServerIP+0x32>
    d492:	81 30       	cpi	r24, 0x01	; 1
    d494:	09 f0       	breq	.+2      	; 0xd498 <FMenuSettingServerIP+0x30>
    d496:	65 c2       	rjmp	.+1226   	; 0xd962 <FMenuSettingServerIP+0x4fa>
    d498:	07 c0       	rjmp	.+14     	; 0xd4a8 <FMenuSettingServerIP+0x40>
    d49a:	83 30       	cpi	r24, 0x03	; 3
    d49c:	09 f4       	brne	.+2      	; 0xd4a0 <FMenuSettingServerIP+0x38>
    d49e:	5c c2       	rjmp	.+1208   	; 0xd958 <FMenuSettingServerIP+0x4f0>
    d4a0:	84 30       	cpi	r24, 0x04	; 4
    d4a2:	09 f0       	breq	.+2      	; 0xd4a6 <FMenuSettingServerIP+0x3e>
    d4a4:	5e c2       	rjmp	.+1212   	; 0xd962 <FMenuSettingServerIP+0x4fa>
    d4a6:	4a c2       	rjmp	.+1172   	; 0xd93c <FMenuSettingServerIP+0x4d4>
		  case cipInit:
			   lcd_clear();
    d4a8:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
	           lcd_printf(1,1,PSTR("Server IP"));
    d4ac:	81 e0       	ldi	r24, 0x01	; 1
    d4ae:	61 e0       	ldi	r22, 0x01	; 1
    d4b0:	4a e0       	ldi	r20, 0x0A	; 10
    d4b2:	53 e1       	ldi	r21, 0x13	; 19
    d4b4:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d4b8:	88 ef       	ldi	r24, 0xF8	; 248
    d4ba:	92 e0       	ldi	r25, 0x02	; 2
    d4bc:	6c e2       	ldi	r22, 0x2C	; 44
    d4be:	70 e0       	ldi	r23, 0x00	; 0
    d4c0:	44 e0       	ldi	r20, 0x04	; 4
    d4c2:	50 e0       	ldi	r21, 0x00	; 0
    d4c4:	28 ef       	ldi	r18, 0xF8	; 248
    d4c6:	32 e1       	ldi	r19, 0x12	; 18
    d4c8:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    d4cc:	8d b7       	in	r24, 0x3d	; 61
    d4ce:	9e b7       	in	r25, 0x3e	; 62
    d4d0:	0c 97       	sbiw	r24, 0x0c	; 12
    d4d2:	0f b6       	in	r0, 0x3f	; 63
    d4d4:	f8 94       	cli
    d4d6:	9e bf       	out	0x3e, r25	; 62
    d4d8:	0f be       	out	0x3f, r0	; 63
    d4da:	8d bf       	out	0x3d, r24	; 61
    d4dc:	ed b7       	in	r30, 0x3d	; 61
    d4de:	fe b7       	in	r31, 0x3e	; 62
    d4e0:	31 96       	adiw	r30, 0x01	; 1
    d4e2:	8e 01       	movw	r16, r28
    d4e4:	0f 5f       	subi	r16, 0xFF	; 255
    d4e6:	1f 4f       	sbci	r17, 0xFF	; 255
    d4e8:	ad b7       	in	r26, 0x3d	; 61
    d4ea:	be b7       	in	r27, 0x3e	; 62
    d4ec:	12 96       	adiw	r26, 0x02	; 2
    d4ee:	1c 93       	st	X, r17
    d4f0:	0e 93       	st	-X, r16
    d4f2:	11 97       	sbiw	r26, 0x01	; 1
    d4f4:	89 ef       	ldi	r24, 0xF9	; 249
    d4f6:	92 e1       	ldi	r25, 0x12	; 18
    d4f8:	93 83       	std	Z+3, r25	; 0x03
    d4fa:	82 83       	std	Z+2, r24	; 0x02
    d4fc:	80 91 f8 02 	lds	r24, 0x02F8
    d500:	84 83       	std	Z+4, r24	; 0x04
    d502:	15 82       	std	Z+5, r1	; 0x05
    d504:	80 91 f9 02 	lds	r24, 0x02F9
    d508:	86 83       	std	Z+6, r24	; 0x06
    d50a:	17 82       	std	Z+7, r1	; 0x07
    d50c:	80 91 fa 02 	lds	r24, 0x02FA
    d510:	80 87       	std	Z+8, r24	; 0x08
    d512:	11 86       	std	Z+9, r1	; 0x09
    d514:	80 91 fb 02 	lds	r24, 0x02FB
    d518:	82 87       	std	Z+10, r24	; 0x0a
    d51a:	13 86       	std	Z+11, r1	; 0x0b
    d51c:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    d520:	ed b7       	in	r30, 0x3d	; 61
    d522:	fe b7       	in	r31, 0x3e	; 62
    d524:	3c 96       	adiw	r30, 0x0c	; 12
    d526:	0f b6       	in	r0, 0x3f	; 63
    d528:	f8 94       	cli
    d52a:	fe bf       	out	0x3e, r31	; 62
    d52c:	0f be       	out	0x3f, r0	; 63
    d52e:	ed bf       	out	0x3d, r30	; 61
    d530:	82 e0       	ldi	r24, 0x02	; 2
    d532:	61 e0       	ldi	r22, 0x01	; 1
    d534:	a8 01       	movw	r20, r16
    d536:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    d53a:	83 e0       	ldi	r24, 0x03	; 3
    d53c:	61 e0       	ldi	r22, 0x01	; 1
    d53e:	44 ee       	ldi	r20, 0xE4	; 228
    d540:	52 e1       	ldi	r21, 0x12	; 18
    d542:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    d546:	84 e0       	ldi	r24, 0x04	; 4
    d548:	61 e0       	ldi	r22, 0x01	; 1
    d54a:	4f ec       	ldi	r20, 0xCF	; 207
    d54c:	52 e1       	ldi	r21, 0x12	; 18
    d54e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
               iLoop=0;
    d552:	10 92 f7 02 	sts	0x02F7, r1
    d556:	10 92 f6 02 	sts	0x02F6, r1
			   y=3,x=8;
    d55a:	83 e0       	ldi	r24, 0x03	; 3
    d55c:	80 93 fe 02 	sts	0x02FE, r24
    d560:	88 e0       	ldi	r24, 0x08	; 8
    d562:	80 93 ff 02 	sts	0x02FF, r24
			   iInput=0; iBlok=0;
    d566:	10 92 fd 02 	sts	0x02FD, r1
    d56a:	10 92 f5 02 	sts	0x02F5, r1
    d56e:	10 92 f4 02 	sts	0x02F4, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d572:	80 e3       	ldi	r24, 0x30	; 48
    d574:	80 93 03 03 	sts	0x0303, r24
    d578:	80 93 04 03 	sts	0x0304, r24
    d57c:	80 93 05 03 	sts	0x0305, r24
			   stClientIP=cipInputIP; 
    d580:	82 e0       	ldi	r24, 0x02	; 2
    d582:	e7 c1       	rjmp	.+974    	; 0xd952 <FMenuSettingServerIP+0x4ea>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    d584:	80 91 f6 02 	lds	r24, 0x02F6
    d588:	90 91 f7 02 	lds	r25, 0x02F7
    d58c:	01 96       	adiw	r24, 0x01	; 1
    d58e:	90 93 f7 02 	sts	0x02F7, r25
    d592:	80 93 f6 02 	sts	0x02F6, r24
			   if ((iLoop%2000)==0){
    d596:	60 ed       	ldi	r22, 0xD0	; 208
    d598:	77 e0       	ldi	r23, 0x07	; 7
    d59a:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
    d59e:	89 2b       	or	r24, r25
    d5a0:	81 f4       	brne	.+32     	; 0xd5c2 <FMenuSettingServerIP+0x15a>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    d5a2:	80 91 f4 02 	lds	r24, 0x02F4
    d5a6:	90 91 f5 02 	lds	r25, 0x02F5
    d5aa:	88 0f       	add	r24, r24
    d5ac:	99 1f       	adc	r25, r25
    d5ae:	88 0f       	add	r24, r24
    d5b0:	99 1f       	adc	r25, r25
    d5b2:	60 91 ff 02 	lds	r22, 0x02FF
    d5b6:	68 0f       	add	r22, r24
    d5b8:	80 91 fe 02 	lds	r24, 0x02FE
    d5bc:	4f e5       	ldi	r20, 0x5F	; 95
    d5be:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    d5c2:	80 91 f6 02 	lds	r24, 0x02F6
    d5c6:	90 91 f7 02 	lds	r25, 0x02F7
    d5ca:	60 ed       	ldi	r22, 0xD0	; 208
    d5cc:	77 e0       	ldi	r23, 0x07	; 7
    d5ce:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
    d5d2:	88 5e       	subi	r24, 0xE8	; 232
    d5d4:	93 40       	sbci	r25, 0x03	; 3
    d5d6:	81 f4       	brne	.+32     	; 0xd5f8 <FMenuSettingServerIP+0x190>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    d5d8:	80 91 f4 02 	lds	r24, 0x02F4
    d5dc:	90 91 f5 02 	lds	r25, 0x02F5
    d5e0:	88 0f       	add	r24, r24
    d5e2:	99 1f       	adc	r25, r25
    d5e4:	88 0f       	add	r24, r24
    d5e6:	99 1f       	adc	r25, r25
    d5e8:	60 91 ff 02 	lds	r22, 0x02FF
    d5ec:	68 0f       	add	r22, r24
    d5ee:	80 91 fe 02 	lds	r24, 0x02FE
    d5f2:	40 e2       	ldi	r20, 0x20	; 32
    d5f4:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    d5f8:	81 e0       	ldi	r24, 0x01	; 1
    d5fa:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    d5fe:	80 93 fc 02 	sts	0x02FC, r24
			   keyChar=_key_btn(keyPressed);
    d602:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
    d606:	28 2f       	mov	r18, r24
    d608:	80 93 00 03 	sts	0x0300, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    d60c:	80 53       	subi	r24, 0x30	; 48
    d60e:	8a 30       	cpi	r24, 0x0A	; 10
    d610:	08 f0       	brcs	.+2      	; 0xd614 <FMenuSettingServerIP+0x1ac>
    d612:	d6 c0       	rjmp	.+428    	; 0xd7c0 <FMenuSettingServerIP+0x358>
    d614:	80 e5       	ldi	r24, 0x50	; 80
    d616:	93 ec       	ldi	r25, 0xC3	; 195
    d618:	01 97       	sbiw	r24, 0x01	; 1
    d61a:	f1 f7       	brne	.-4      	; 0xd618 <FMenuSettingServerIP+0x1b0>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    d61c:	80 91 fd 02 	lds	r24, 0x02FD
    d620:	e8 2f       	mov	r30, r24
    d622:	f0 e0       	ldi	r31, 0x00	; 0
    d624:	ed 5f       	subi	r30, 0xFD	; 253
    d626:	fc 4f       	sbci	r31, 0xFC	; 252
    d628:	20 83       	st	Z, r18
				   iInput++;                    
    d62a:	8f 5f       	subi	r24, 0xFF	; 255
    d62c:	80 93 fd 02 	sts	0x02FD, r24
				   for (i=1;i<(iInput+1);i++){
    d630:	81 e0       	ldi	r24, 0x01	; 1
    d632:	1c c0       	rjmp	.+56     	; 0xd66c <FMenuSettingServerIP+0x204>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    d634:	80 91 ff 02 	lds	r24, 0x02FF
    d638:	68 0f       	add	r22, r24
    d63a:	63 50       	subi	r22, 0x03	; 3
    d63c:	80 91 f4 02 	lds	r24, 0x02F4
    d640:	90 91 f5 02 	lds	r25, 0x02F5
    d644:	88 0f       	add	r24, r24
    d646:	99 1f       	adc	r25, r25
    d648:	88 0f       	add	r24, r24
    d64a:	99 1f       	adc	r25, r25
    d64c:	68 0f       	add	r22, r24
    d64e:	80 91 fe 02 	lds	r24, 0x02FE
    d652:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
    d656:	e0 91 02 03 	lds	r30, 0x0302
    d65a:	f0 e0       	ldi	r31, 0x00	; 0
    d65c:	ee 5f       	subi	r30, 0xFE	; 254
    d65e:	fc 4f       	sbci	r31, 0xFC	; 252
    d660:	80 81       	ld	r24, Z
    d662:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    d666:	80 91 02 03 	lds	r24, 0x0302
    d66a:	8f 5f       	subi	r24, 0xFF	; 255
    d66c:	80 93 02 03 	sts	0x0302, r24
    d670:	70 91 fd 02 	lds	r23, 0x02FD
    d674:	60 91 02 03 	lds	r22, 0x0302
    d678:	27 2f       	mov	r18, r23
    d67a:	30 e0       	ldi	r19, 0x00	; 0
    d67c:	86 2f       	mov	r24, r22
    d67e:	90 e0       	ldi	r25, 0x00	; 0
    d680:	28 17       	cp	r18, r24
    d682:	39 07       	cpc	r19, r25
    d684:	bc f6       	brge	.-82     	; 0xd634 <FMenuSettingServerIP+0x1cc>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    d686:	73 30       	cpi	r23, 0x03	; 3
    d688:	08 f4       	brcc	.+2      	; 0xd68c <FMenuSettingServerIP+0x224>
    d68a:	91 c0       	rjmp	.+290    	; 0xd7ae <FMenuSettingServerIP+0x346>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d68c:	40 91 f4 02 	lds	r20, 0x02F4
    d690:	50 91 f5 02 	lds	r21, 0x02F5
    d694:	fa 01       	movw	r30, r20
    d696:	e8 50       	subi	r30, 0x08	; 8
    d698:	fd 4f       	sbci	r31, 0xFD	; 253
    d69a:	20 91 05 03 	lds	r18, 0x0305
    d69e:	20 5d       	subi	r18, 0xD0	; 208
    d6a0:	80 91 03 03 	lds	r24, 0x0303
    d6a4:	34 e6       	ldi	r19, 0x64	; 100
    d6a6:	83 9f       	mul	r24, r19
    d6a8:	c0 01       	movw	r24, r0
    d6aa:	11 24       	eor	r1, r1
    d6ac:	28 0f       	add	r18, r24
    d6ae:	80 91 04 03 	lds	r24, 0x0304
    d6b2:	3a e0       	ldi	r19, 0x0A	; 10
    d6b4:	83 9f       	mul	r24, r19
    d6b6:	c0 01       	movw	r24, r0
    d6b8:	11 24       	eor	r1, r1
    d6ba:	28 0f       	add	r18, r24
    d6bc:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d6be:	80 e3       	ldi	r24, 0x30	; 48
    d6c0:	80 93 03 03 	sts	0x0303, r24
    d6c4:	80 93 04 03 	sts	0x0304, r24
    d6c8:	80 93 05 03 	sts	0x0305, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    d6cc:	44 0f       	add	r20, r20
    d6ce:	55 1f       	adc	r21, r21
    d6d0:	44 0f       	add	r20, r20
    d6d2:	55 1f       	adc	r21, r21
    d6d4:	60 91 ff 02 	lds	r22, 0x02FF
    d6d8:	64 0f       	add	r22, r20
    d6da:	67 1b       	sub	r22, r23
    d6dc:	80 91 fe 02 	lds	r24, 0x02FE
    d6e0:	4b ec       	ldi	r20, 0xCB	; 203
    d6e2:	52 e1       	ldi	r21, 0x12	; 18
    d6e4:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d6e8:	00 d0       	rcall	.+0      	; 0xd6ea <FMenuSettingServerIP+0x282>
    d6ea:	00 d0       	rcall	.+0      	; 0xd6ec <FMenuSettingServerIP+0x284>
    d6ec:	00 d0       	rcall	.+0      	; 0xd6ee <FMenuSettingServerIP+0x286>
    d6ee:	ad b7       	in	r26, 0x3d	; 61
    d6f0:	be b7       	in	r27, 0x3e	; 62
    d6f2:	11 96       	adiw	r26, 0x01	; 1
    d6f4:	8e 01       	movw	r16, r28
    d6f6:	0f 5f       	subi	r16, 0xFF	; 255
    d6f8:	1f 4f       	sbci	r17, 0xFF	; 255
    d6fa:	ed b7       	in	r30, 0x3d	; 61
    d6fc:	fe b7       	in	r31, 0x3e	; 62
    d6fe:	12 83       	std	Z+2, r17	; 0x02
    d700:	01 83       	std	Z+1, r16	; 0x01
    d702:	88 ec       	ldi	r24, 0xC8	; 200
    d704:	92 e1       	ldi	r25, 0x12	; 18
    d706:	13 96       	adiw	r26, 0x03	; 3
    d708:	9c 93       	st	X, r25
    d70a:	8e 93       	st	-X, r24
    d70c:	12 97       	sbiw	r26, 0x02	; 2
    d70e:	e0 91 f4 02 	lds	r30, 0x02F4
    d712:	f0 91 f5 02 	lds	r31, 0x02F5
    d716:	e8 50       	subi	r30, 0x08	; 8
    d718:	fd 4f       	sbci	r31, 0xFD	; 253
    d71a:	80 81       	ld	r24, Z
    d71c:	14 96       	adiw	r26, 0x04	; 4
    d71e:	8c 93       	st	X, r24
    d720:	14 97       	sbiw	r26, 0x04	; 4
    d722:	15 96       	adiw	r26, 0x05	; 5
    d724:	1c 92       	st	X, r1
    d726:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d72a:	f8 01       	movw	r30, r16
    d72c:	01 90       	ld	r0, Z+
    d72e:	00 20       	and	r0, r0
    d730:	e9 f7       	brne	.-6      	; 0xd72c <FMenuSettingServerIP+0x2c4>
    d732:	31 97       	sbiw	r30, 0x01	; 1
    d734:	e0 1b       	sub	r30, r16
    d736:	f1 0b       	sbc	r31, r17
    d738:	8d b7       	in	r24, 0x3d	; 61
    d73a:	9e b7       	in	r25, 0x3e	; 62
    d73c:	06 96       	adiw	r24, 0x06	; 6
    d73e:	0f b6       	in	r0, 0x3f	; 63
    d740:	f8 94       	cli
    d742:	9e bf       	out	0x3e, r25	; 62
    d744:	0f be       	out	0x3f, r0	; 63
    d746:	8d bf       	out	0x3d, r24	; 61
    d748:	60 91 ff 02 	lds	r22, 0x02FF
    d74c:	6f 5f       	subi	r22, 0xFF	; 255
    d74e:	80 91 f4 02 	lds	r24, 0x02F4
    d752:	90 91 f5 02 	lds	r25, 0x02F5
    d756:	88 0f       	add	r24, r24
    d758:	99 1f       	adc	r25, r25
    d75a:	88 0f       	add	r24, r24
    d75c:	99 1f       	adc	r25, r25
    d75e:	68 0f       	add	r22, r24
    d760:	6e 1b       	sub	r22, r30
    d762:	80 91 fe 02 	lds	r24, 0x02FE
    d766:	a8 01       	movw	r20, r16
    d768:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d76c:	80 91 f4 02 	lds	r24, 0x02F4
    d770:	90 91 f5 02 	lds	r25, 0x02F5
    d774:	00 97       	sbiw	r24, 0x00	; 0
    d776:	81 f0       	breq	.+32     	; 0xd798 <FMenuSettingServerIP+0x330>
    d778:	60 91 ff 02 	lds	r22, 0x02FF
    d77c:	6f 5f       	subi	r22, 0xFF	; 255
    d77e:	81 50       	subi	r24, 0x01	; 1
    d780:	90 4c       	sbci	r25, 0xC0	; 192
    d782:	88 0f       	add	r24, r24
    d784:	99 1f       	adc	r25, r25
    d786:	88 0f       	add	r24, r24
    d788:	99 1f       	adc	r25, r25
    d78a:	68 0f       	add	r22, r24
    d78c:	80 91 fe 02 	lds	r24, 0x02FE
    d790:	46 ec       	ldi	r20, 0xC6	; 198
    d792:	52 e1       	ldi	r21, 0x12	; 18
    d794:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
					   iInput=0;
    d798:	10 92 fd 02 	sts	0x02FD, r1
					   iBlok++;
    d79c:	80 91 f4 02 	lds	r24, 0x02F4
    d7a0:	90 91 f5 02 	lds	r25, 0x02F5
    d7a4:	01 96       	adiw	r24, 0x01	; 1
    d7a6:	90 93 f5 02 	sts	0x02F5, r25
    d7aa:	80 93 f4 02 	sts	0x02F4, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    d7ae:	80 91 f4 02 	lds	r24, 0x02F4
    d7b2:	90 91 f5 02 	lds	r25, 0x02F5
    d7b6:	04 97       	sbiw	r24, 0x04	; 4
    d7b8:	18 f0       	brcs	.+6      	; 0xd7c0 <FMenuSettingServerIP+0x358>
    d7ba:	84 e0       	ldi	r24, 0x04	; 4
    d7bc:	80 93 58 01 	sts	0x0158, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    d7c0:	80 91 fc 02 	lds	r24, 0x02FC
    d7c4:	87 3e       	cpi	r24, 0xE7	; 231
    d7c6:	09 f4       	brne	.+2      	; 0xd7ca <FMenuSettingServerIP+0x362>
    d7c8:	c3 c0       	rjmp	.+390    	; 0xd950 <FMenuSettingServerIP+0x4e8>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    d7ca:	87 3b       	cpi	r24, 0xB7	; 183
    d7cc:	09 f0       	breq	.+2      	; 0xd7d0 <FMenuSettingServerIP+0x368>
    d7ce:	c9 c0       	rjmp	.+402    	; 0xd962 <FMenuSettingServerIP+0x4fa>
			       //NextInput
			       if (iBlok<4){
    d7d0:	40 91 f4 02 	lds	r20, 0x02F4
    d7d4:	50 91 f5 02 	lds	r21, 0x02F5
    d7d8:	44 30       	cpi	r20, 0x04	; 4
    d7da:	51 05       	cpc	r21, r1
    d7dc:	08 f0       	brcs	.+2      	; 0xd7e0 <FMenuSettingServerIP+0x378>
    d7de:	a6 c0       	rjmp	.+332    	; 0xd92c <FMenuSettingServerIP+0x4c4>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    d7e0:	80 91 fd 02 	lds	r24, 0x02FD
    d7e4:	81 30       	cpi	r24, 0x01	; 1
    d7e6:	41 f4       	brne	.+16     	; 0xd7f8 <FMenuSettingServerIP+0x390>
    d7e8:	fa 01       	movw	r30, r20
    d7ea:	e8 50       	subi	r30, 0x08	; 8
    d7ec:	fd 4f       	sbci	r31, 0xFD	; 253
    d7ee:	80 91 03 03 	lds	r24, 0x0303
    d7f2:	80 53       	subi	r24, 0x30	; 48
    d7f4:	80 83       	st	Z, r24
    d7f6:	22 c0       	rjmp	.+68     	; 0xd83c <FMenuSettingServerIP+0x3d4>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    d7f8:	82 30       	cpi	r24, 0x02	; 2
    d7fa:	49 f4       	brne	.+18     	; 0xd80e <FMenuSettingServerIP+0x3a6>
    d7fc:	fa 01       	movw	r30, r20
    d7fe:	e8 50       	subi	r30, 0x08	; 8
    d800:	fd 4f       	sbci	r31, 0xFD	; 253
    d802:	20 91 04 03 	lds	r18, 0x0304
    d806:	20 51       	subi	r18, 0x10	; 16
    d808:	80 91 03 03 	lds	r24, 0x0303
    d80c:	11 c0       	rjmp	.+34     	; 0xd830 <FMenuSettingServerIP+0x3c8>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d80e:	83 30       	cpi	r24, 0x03	; 3
    d810:	a9 f4       	brne	.+42     	; 0xd83c <FMenuSettingServerIP+0x3d4>
    d812:	fa 01       	movw	r30, r20
    d814:	e8 50       	subi	r30, 0x08	; 8
    d816:	fd 4f       	sbci	r31, 0xFD	; 253
    d818:	20 91 05 03 	lds	r18, 0x0305
    d81c:	20 5d       	subi	r18, 0xD0	; 208
    d81e:	80 91 03 03 	lds	r24, 0x0303
    d822:	34 e6       	ldi	r19, 0x64	; 100
    d824:	83 9f       	mul	r24, r19
    d826:	c0 01       	movw	r24, r0
    d828:	11 24       	eor	r1, r1
    d82a:	28 0f       	add	r18, r24
    d82c:	80 91 04 03 	lds	r24, 0x0304
    d830:	3a e0       	ldi	r19, 0x0A	; 10
    d832:	83 9f       	mul	r24, r19
    d834:	c0 01       	movw	r24, r0
    d836:	11 24       	eor	r1, r1
    d838:	28 0f       	add	r18, r24
    d83a:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d83c:	80 e3       	ldi	r24, 0x30	; 48
    d83e:	80 93 03 03 	sts	0x0303, r24
    d842:	80 93 04 03 	sts	0x0304, r24
    d846:	80 93 05 03 	sts	0x0305, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    d84a:	60 91 ff 02 	lds	r22, 0x02FF
    d84e:	63 50       	subi	r22, 0x03	; 3
    d850:	44 0f       	add	r20, r20
    d852:	55 1f       	adc	r21, r21
    d854:	44 0f       	add	r20, r20
    d856:	55 1f       	adc	r21, r21
    d858:	64 0f       	add	r22, r20
    d85a:	80 91 fe 02 	lds	r24, 0x02FE
    d85e:	42 ec       	ldi	r20, 0xC2	; 194
    d860:	52 e1       	ldi	r21, 0x12	; 18
    d862:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d866:	00 d0       	rcall	.+0      	; 0xd868 <FMenuSettingServerIP+0x400>
    d868:	00 d0       	rcall	.+0      	; 0xd86a <FMenuSettingServerIP+0x402>
    d86a:	00 d0       	rcall	.+0      	; 0xd86c <FMenuSettingServerIP+0x404>
    d86c:	ad b7       	in	r26, 0x3d	; 61
    d86e:	be b7       	in	r27, 0x3e	; 62
    d870:	11 96       	adiw	r26, 0x01	; 1
    d872:	8e 01       	movw	r16, r28
    d874:	0f 5f       	subi	r16, 0xFF	; 255
    d876:	1f 4f       	sbci	r17, 0xFF	; 255
    d878:	ed b7       	in	r30, 0x3d	; 61
    d87a:	fe b7       	in	r31, 0x3e	; 62
    d87c:	12 83       	std	Z+2, r17	; 0x02
    d87e:	01 83       	std	Z+1, r16	; 0x01
    d880:	8f eb       	ldi	r24, 0xBF	; 191
    d882:	92 e1       	ldi	r25, 0x12	; 18
    d884:	13 96       	adiw	r26, 0x03	; 3
    d886:	9c 93       	st	X, r25
    d888:	8e 93       	st	-X, r24
    d88a:	12 97       	sbiw	r26, 0x02	; 2
    d88c:	e0 91 f4 02 	lds	r30, 0x02F4
    d890:	f0 91 f5 02 	lds	r31, 0x02F5
    d894:	e8 50       	subi	r30, 0x08	; 8
    d896:	fd 4f       	sbci	r31, 0xFD	; 253
    d898:	80 81       	ld	r24, Z
    d89a:	14 96       	adiw	r26, 0x04	; 4
    d89c:	8c 93       	st	X, r24
    d89e:	14 97       	sbiw	r26, 0x04	; 4
    d8a0:	15 96       	adiw	r26, 0x05	; 5
    d8a2:	1c 92       	st	X, r1
    d8a4:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d8a8:	f8 01       	movw	r30, r16
    d8aa:	01 90       	ld	r0, Z+
    d8ac:	00 20       	and	r0, r0
    d8ae:	e9 f7       	brne	.-6      	; 0xd8aa <FMenuSettingServerIP+0x442>
    d8b0:	31 97       	sbiw	r30, 0x01	; 1
    d8b2:	e0 1b       	sub	r30, r16
    d8b4:	f1 0b       	sbc	r31, r17
    d8b6:	8d b7       	in	r24, 0x3d	; 61
    d8b8:	9e b7       	in	r25, 0x3e	; 62
    d8ba:	06 96       	adiw	r24, 0x06	; 6
    d8bc:	0f b6       	in	r0, 0x3f	; 63
    d8be:	f8 94       	cli
    d8c0:	9e bf       	out	0x3e, r25	; 62
    d8c2:	0f be       	out	0x3f, r0	; 63
    d8c4:	8d bf       	out	0x3d, r24	; 61
    d8c6:	60 91 ff 02 	lds	r22, 0x02FF
    d8ca:	6f 5f       	subi	r22, 0xFF	; 255
    d8cc:	80 91 f4 02 	lds	r24, 0x02F4
    d8d0:	90 91 f5 02 	lds	r25, 0x02F5
    d8d4:	88 0f       	add	r24, r24
    d8d6:	99 1f       	adc	r25, r25
    d8d8:	88 0f       	add	r24, r24
    d8da:	99 1f       	adc	r25, r25
    d8dc:	68 0f       	add	r22, r24
    d8de:	6e 1b       	sub	r22, r30
    d8e0:	80 91 fe 02 	lds	r24, 0x02FE
    d8e4:	a8 01       	movw	r20, r16
    d8e6:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d8ea:	80 91 f4 02 	lds	r24, 0x02F4
    d8ee:	90 91 f5 02 	lds	r25, 0x02F5
    d8f2:	00 97       	sbiw	r24, 0x00	; 0
    d8f4:	81 f0       	breq	.+32     	; 0xd916 <FMenuSettingServerIP+0x4ae>
    d8f6:	60 91 ff 02 	lds	r22, 0x02FF
    d8fa:	6f 5f       	subi	r22, 0xFF	; 255
    d8fc:	81 50       	subi	r24, 0x01	; 1
    d8fe:	90 4c       	sbci	r25, 0xC0	; 192
    d900:	88 0f       	add	r24, r24
    d902:	99 1f       	adc	r25, r25
    d904:	88 0f       	add	r24, r24
    d906:	99 1f       	adc	r25, r25
    d908:	68 0f       	add	r22, r24
    d90a:	80 91 fe 02 	lds	r24, 0x02FE
    d90e:	4d eb       	ldi	r20, 0xBD	; 189
    d910:	52 e1       	ldi	r21, 0x12	; 18
    d912:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				       iInput=0;
    d916:	10 92 fd 02 	sts	0x02FD, r1
					   iBlok++;	   
    d91a:	80 91 f4 02 	lds	r24, 0x02F4
    d91e:	90 91 f5 02 	lds	r25, 0x02F5
    d922:	01 96       	adiw	r24, 0x01	; 1
    d924:	90 93 f5 02 	sts	0x02F5, r25
    d928:	80 93 f4 02 	sts	0x02F4, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    d92c:	80 91 f4 02 	lds	r24, 0x02F4
    d930:	90 91 f5 02 	lds	r25, 0x02F5
    d934:	04 97       	sbiw	r24, 0x04	; 4
    d936:	a8 f0       	brcs	.+42     	; 0xd962 <FMenuSettingServerIP+0x4fa>
    d938:	84 e0       	ldi	r24, 0x04	; 4
    d93a:	0b c0       	rjmp	.+22     	; 0xd952 <FMenuSettingServerIP+0x4ea>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    d93c:	8c e2       	ldi	r24, 0x2C	; 44
    d93e:	90 e0       	ldi	r25, 0x00	; 0
    d940:	68 ef       	ldi	r22, 0xF8	; 248
    d942:	72 e0       	ldi	r23, 0x02	; 2
    d944:	44 e0       	ldi	r20, 0x04	; 4
    d946:	50 e0       	ldi	r21, 0x00	; 0
    d948:	20 e0       	ldi	r18, 0x00	; 0
    d94a:	33 e1       	ldi	r19, 0x13	; 19
    d94c:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
			   }
		       break;
          case cipStoreIPblok:
		       //UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefServerIP,4);
			   stClientIP=cipExit;
    d950:	83 e0       	ldi	r24, 0x03	; 3
    d952:	80 93 58 01 	sts	0x0158, r24
    d956:	05 c0       	rjmp	.+10     	; 0xd962 <FMenuSettingServerIP+0x4fa>
		       break; 
          case cipExit://Cancel IPConfig
			   stClientIP=cipInit;
    d958:	81 e0       	ldi	r24, 0x01	; 1
    d95a:	80 93 58 01 	sts	0x0158, r24
			   Result=MENU_DONE;
    d95e:	80 93 01 03 	sts	0x0301, r24
		       break;     
		  }//EndSwitch	 
	return Result;
}
    d962:	80 91 01 03 	lds	r24, 0x0301
    d966:	64 96       	adiw	r28, 0x14	; 20
    d968:	0f b6       	in	r0, 0x3f	; 63
    d96a:	f8 94       	cli
    d96c:	de bf       	out	0x3e, r29	; 62
    d96e:	0f be       	out	0x3f, r0	; 63
    d970:	cd bf       	out	0x3d, r28	; 61
    d972:	cf 91       	pop	r28
    d974:	df 91       	pop	r29
    d976:	1f 91       	pop	r17
    d978:	0f 91       	pop	r16
    d97a:	08 95       	ret

0000d97c <FMenuSettingClientIP>:





char FMenuSettingClientIP(){
    d97c:	0f 93       	push	r16
    d97e:	1f 93       	push	r17
    d980:	df 93       	push	r29
    d982:	cf 93       	push	r28
    d984:	cd b7       	in	r28, 0x3d	; 61
    d986:	de b7       	in	r29, 0x3e	; 62
    d988:	64 97       	sbiw	r28, 0x14	; 20
    d98a:	0f b6       	in	r0, 0x3f	; 63
    d98c:	f8 94       	cli
    d98e:	de bf       	out	0x3e, r29	; 62
    d990:	0f be       	out	0x3f, r0	; 63
    d992:	cd bf       	out	0x3d, r28	; 61
     //Client IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
     Result=MENU_NONE;
    d994:	10 92 13 03 	sts	0x0313, r1
	 switch(stClientIP){
    d998:	80 91 59 01 	lds	r24, 0x0159
    d99c:	82 30       	cpi	r24, 0x02	; 2
    d99e:	09 f4       	brne	.+2      	; 0xd9a2 <FMenuSettingClientIP+0x26>
    d9a0:	7b c0       	rjmp	.+246    	; 0xda98 <FMenuSettingClientIP+0x11c>
    d9a2:	83 30       	cpi	r24, 0x03	; 3
    d9a4:	20 f4       	brcc	.+8      	; 0xd9ae <FMenuSettingClientIP+0x32>
    d9a6:	81 30       	cpi	r24, 0x01	; 1
    d9a8:	09 f0       	breq	.+2      	; 0xd9ac <FMenuSettingClientIP+0x30>
    d9aa:	65 c2       	rjmp	.+1226   	; 0xde76 <FMenuSettingClientIP+0x4fa>
    d9ac:	07 c0       	rjmp	.+14     	; 0xd9bc <FMenuSettingClientIP+0x40>
    d9ae:	83 30       	cpi	r24, 0x03	; 3
    d9b0:	09 f4       	brne	.+2      	; 0xd9b4 <FMenuSettingClientIP+0x38>
    d9b2:	5c c2       	rjmp	.+1208   	; 0xde6c <FMenuSettingClientIP+0x4f0>
    d9b4:	84 30       	cpi	r24, 0x04	; 4
    d9b6:	09 f0       	breq	.+2      	; 0xd9ba <FMenuSettingClientIP+0x3e>
    d9b8:	5e c2       	rjmp	.+1212   	; 0xde76 <FMenuSettingClientIP+0x4fa>
    d9ba:	4a c2       	rjmp	.+1172   	; 0xde50 <FMenuSettingClientIP+0x4d4>
		  case cipInit:
			   lcd_clear();
    d9bc:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
	           lcd_printf(1,1,PSTR("Client IP"));
    d9c0:	81 e0       	ldi	r24, 0x01	; 1
    d9c2:	61 e0       	ldi	r22, 0x01	; 1
    d9c4:	41 e6       	ldi	r20, 0x61	; 97
    d9c6:	53 e1       	ldi	r21, 0x13	; 19
    d9c8:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d9cc:	8a e0       	ldi	r24, 0x0A	; 10
    d9ce:	93 e0       	ldi	r25, 0x03	; 3
    d9d0:	68 e2       	ldi	r22, 0x28	; 40
    d9d2:	70 e0       	ldi	r23, 0x00	; 0
    d9d4:	44 e0       	ldi	r20, 0x04	; 4
    d9d6:	50 e0       	ldi	r21, 0x00	; 0
    d9d8:	28 ef       	ldi	r18, 0xF8	; 248
    d9da:	32 e1       	ldi	r19, 0x12	; 18
    d9dc:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    d9e0:	8d b7       	in	r24, 0x3d	; 61
    d9e2:	9e b7       	in	r25, 0x3e	; 62
    d9e4:	0c 97       	sbiw	r24, 0x0c	; 12
    d9e6:	0f b6       	in	r0, 0x3f	; 63
    d9e8:	f8 94       	cli
    d9ea:	9e bf       	out	0x3e, r25	; 62
    d9ec:	0f be       	out	0x3f, r0	; 63
    d9ee:	8d bf       	out	0x3d, r24	; 61
    d9f0:	ed b7       	in	r30, 0x3d	; 61
    d9f2:	fe b7       	in	r31, 0x3e	; 62
    d9f4:	31 96       	adiw	r30, 0x01	; 1
    d9f6:	8e 01       	movw	r16, r28
    d9f8:	0f 5f       	subi	r16, 0xFF	; 255
    d9fa:	1f 4f       	sbci	r17, 0xFF	; 255
    d9fc:	ad b7       	in	r26, 0x3d	; 61
    d9fe:	be b7       	in	r27, 0x3e	; 62
    da00:	12 96       	adiw	r26, 0x02	; 2
    da02:	1c 93       	st	X, r17
    da04:	0e 93       	st	-X, r16
    da06:	11 97       	sbiw	r26, 0x01	; 1
    da08:	80 e5       	ldi	r24, 0x50	; 80
    da0a:	93 e1       	ldi	r25, 0x13	; 19
    da0c:	93 83       	std	Z+3, r25	; 0x03
    da0e:	82 83       	std	Z+2, r24	; 0x02
    da10:	80 91 0a 03 	lds	r24, 0x030A
    da14:	84 83       	std	Z+4, r24	; 0x04
    da16:	15 82       	std	Z+5, r1	; 0x05
    da18:	80 91 0b 03 	lds	r24, 0x030B
    da1c:	86 83       	std	Z+6, r24	; 0x06
    da1e:	17 82       	std	Z+7, r1	; 0x07
    da20:	80 91 0c 03 	lds	r24, 0x030C
    da24:	80 87       	std	Z+8, r24	; 0x08
    da26:	11 86       	std	Z+9, r1	; 0x09
    da28:	80 91 0d 03 	lds	r24, 0x030D
    da2c:	82 87       	std	Z+10, r24	; 0x0a
    da2e:	13 86       	std	Z+11, r1	; 0x0b
    da30:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    da34:	ed b7       	in	r30, 0x3d	; 61
    da36:	fe b7       	in	r31, 0x3e	; 62
    da38:	3c 96       	adiw	r30, 0x0c	; 12
    da3a:	0f b6       	in	r0, 0x3f	; 63
    da3c:	f8 94       	cli
    da3e:	fe bf       	out	0x3e, r31	; 62
    da40:	0f be       	out	0x3f, r0	; 63
    da42:	ed bf       	out	0x3d, r30	; 61
    da44:	82 e0       	ldi	r24, 0x02	; 2
    da46:	61 e0       	ldi	r22, 0x01	; 1
    da48:	a8 01       	movw	r20, r16
    da4a:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    da4e:	83 e0       	ldi	r24, 0x03	; 3
    da50:	61 e0       	ldi	r22, 0x01	; 1
    da52:	4b e3       	ldi	r20, 0x3B	; 59
    da54:	53 e1       	ldi	r21, 0x13	; 19
    da56:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    da5a:	84 e0       	ldi	r24, 0x04	; 4
    da5c:	61 e0       	ldi	r22, 0x01	; 1
    da5e:	46 e2       	ldi	r20, 0x26	; 38
    da60:	53 e1       	ldi	r21, 0x13	; 19
    da62:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
               iLoop=0;
    da66:	10 92 09 03 	sts	0x0309, r1
    da6a:	10 92 08 03 	sts	0x0308, r1
			   y=3,x=8;
    da6e:	83 e0       	ldi	r24, 0x03	; 3
    da70:	80 93 10 03 	sts	0x0310, r24
    da74:	88 e0       	ldi	r24, 0x08	; 8
    da76:	80 93 11 03 	sts	0x0311, r24
			   iInput=0; iBlok=0;
    da7a:	10 92 0f 03 	sts	0x030F, r1
    da7e:	10 92 07 03 	sts	0x0307, r1
    da82:	10 92 06 03 	sts	0x0306, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    da86:	80 e3       	ldi	r24, 0x30	; 48
    da88:	80 93 15 03 	sts	0x0315, r24
    da8c:	80 93 16 03 	sts	0x0316, r24
    da90:	80 93 17 03 	sts	0x0317, r24
			   stClientIP=cipInputIP; 
    da94:	82 e0       	ldi	r24, 0x02	; 2
    da96:	e7 c1       	rjmp	.+974    	; 0xde66 <FMenuSettingClientIP+0x4ea>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    da98:	80 91 08 03 	lds	r24, 0x0308
    da9c:	90 91 09 03 	lds	r25, 0x0309
    daa0:	01 96       	adiw	r24, 0x01	; 1
    daa2:	90 93 09 03 	sts	0x0309, r25
    daa6:	80 93 08 03 	sts	0x0308, r24
			   if ((iLoop%2000)==0){
    daaa:	60 ed       	ldi	r22, 0xD0	; 208
    daac:	77 e0       	ldi	r23, 0x07	; 7
    daae:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
    dab2:	89 2b       	or	r24, r25
    dab4:	81 f4       	brne	.+32     	; 0xdad6 <FMenuSettingClientIP+0x15a>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    dab6:	80 91 06 03 	lds	r24, 0x0306
    daba:	90 91 07 03 	lds	r25, 0x0307
    dabe:	88 0f       	add	r24, r24
    dac0:	99 1f       	adc	r25, r25
    dac2:	88 0f       	add	r24, r24
    dac4:	99 1f       	adc	r25, r25
    dac6:	60 91 11 03 	lds	r22, 0x0311
    daca:	68 0f       	add	r22, r24
    dacc:	80 91 10 03 	lds	r24, 0x0310
    dad0:	4f e5       	ldi	r20, 0x5F	; 95
    dad2:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    dad6:	80 91 08 03 	lds	r24, 0x0308
    dada:	90 91 09 03 	lds	r25, 0x0309
    dade:	60 ed       	ldi	r22, 0xD0	; 208
    dae0:	77 e0       	ldi	r23, 0x07	; 7
    dae2:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
    dae6:	88 5e       	subi	r24, 0xE8	; 232
    dae8:	93 40       	sbci	r25, 0x03	; 3
    daea:	81 f4       	brne	.+32     	; 0xdb0c <FMenuSettingClientIP+0x190>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    daec:	80 91 06 03 	lds	r24, 0x0306
    daf0:	90 91 07 03 	lds	r25, 0x0307
    daf4:	88 0f       	add	r24, r24
    daf6:	99 1f       	adc	r25, r25
    daf8:	88 0f       	add	r24, r24
    dafa:	99 1f       	adc	r25, r25
    dafc:	60 91 11 03 	lds	r22, 0x0311
    db00:	68 0f       	add	r22, r24
    db02:	80 91 10 03 	lds	r24, 0x0310
    db06:	40 e2       	ldi	r20, 0x20	; 32
    db08:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    db0c:	81 e0       	ldi	r24, 0x01	; 1
    db0e:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    db12:	80 93 0e 03 	sts	0x030E, r24
			   keyChar=_key_btn(keyPressed);
    db16:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
    db1a:	28 2f       	mov	r18, r24
    db1c:	80 93 12 03 	sts	0x0312, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    db20:	80 53       	subi	r24, 0x30	; 48
    db22:	8a 30       	cpi	r24, 0x0A	; 10
    db24:	08 f0       	brcs	.+2      	; 0xdb28 <FMenuSettingClientIP+0x1ac>
    db26:	d6 c0       	rjmp	.+428    	; 0xdcd4 <FMenuSettingClientIP+0x358>
    db28:	80 e5       	ldi	r24, 0x50	; 80
    db2a:	93 ec       	ldi	r25, 0xC3	; 195
    db2c:	01 97       	sbiw	r24, 0x01	; 1
    db2e:	f1 f7       	brne	.-4      	; 0xdb2c <FMenuSettingClientIP+0x1b0>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    db30:	80 91 0f 03 	lds	r24, 0x030F
    db34:	e8 2f       	mov	r30, r24
    db36:	f0 e0       	ldi	r31, 0x00	; 0
    db38:	eb 5e       	subi	r30, 0xEB	; 235
    db3a:	fc 4f       	sbci	r31, 0xFC	; 252
    db3c:	20 83       	st	Z, r18
				   iInput++;                    
    db3e:	8f 5f       	subi	r24, 0xFF	; 255
    db40:	80 93 0f 03 	sts	0x030F, r24
				   for (i=1;i<(iInput+1);i++){
    db44:	81 e0       	ldi	r24, 0x01	; 1
    db46:	1c c0       	rjmp	.+56     	; 0xdb80 <FMenuSettingClientIP+0x204>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    db48:	80 91 11 03 	lds	r24, 0x0311
    db4c:	68 0f       	add	r22, r24
    db4e:	63 50       	subi	r22, 0x03	; 3
    db50:	80 91 06 03 	lds	r24, 0x0306
    db54:	90 91 07 03 	lds	r25, 0x0307
    db58:	88 0f       	add	r24, r24
    db5a:	99 1f       	adc	r25, r25
    db5c:	88 0f       	add	r24, r24
    db5e:	99 1f       	adc	r25, r25
    db60:	68 0f       	add	r22, r24
    db62:	80 91 10 03 	lds	r24, 0x0310
    db66:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
    db6a:	e0 91 14 03 	lds	r30, 0x0314
    db6e:	f0 e0       	ldi	r31, 0x00	; 0
    db70:	ec 5e       	subi	r30, 0xEC	; 236
    db72:	fc 4f       	sbci	r31, 0xFC	; 252
    db74:	80 81       	ld	r24, Z
    db76:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    db7a:	80 91 14 03 	lds	r24, 0x0314
    db7e:	8f 5f       	subi	r24, 0xFF	; 255
    db80:	80 93 14 03 	sts	0x0314, r24
    db84:	70 91 0f 03 	lds	r23, 0x030F
    db88:	60 91 14 03 	lds	r22, 0x0314
    db8c:	27 2f       	mov	r18, r23
    db8e:	30 e0       	ldi	r19, 0x00	; 0
    db90:	86 2f       	mov	r24, r22
    db92:	90 e0       	ldi	r25, 0x00	; 0
    db94:	28 17       	cp	r18, r24
    db96:	39 07       	cpc	r19, r25
    db98:	bc f6       	brge	.-82     	; 0xdb48 <FMenuSettingClientIP+0x1cc>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    db9a:	73 30       	cpi	r23, 0x03	; 3
    db9c:	08 f4       	brcc	.+2      	; 0xdba0 <FMenuSettingClientIP+0x224>
    db9e:	91 c0       	rjmp	.+290    	; 0xdcc2 <FMenuSettingClientIP+0x346>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    dba0:	40 91 06 03 	lds	r20, 0x0306
    dba4:	50 91 07 03 	lds	r21, 0x0307
    dba8:	fa 01       	movw	r30, r20
    dbaa:	e6 5f       	subi	r30, 0xF6	; 246
    dbac:	fc 4f       	sbci	r31, 0xFC	; 252
    dbae:	20 91 17 03 	lds	r18, 0x0317
    dbb2:	20 5d       	subi	r18, 0xD0	; 208
    dbb4:	80 91 15 03 	lds	r24, 0x0315
    dbb8:	34 e6       	ldi	r19, 0x64	; 100
    dbba:	83 9f       	mul	r24, r19
    dbbc:	c0 01       	movw	r24, r0
    dbbe:	11 24       	eor	r1, r1
    dbc0:	28 0f       	add	r18, r24
    dbc2:	80 91 16 03 	lds	r24, 0x0316
    dbc6:	3a e0       	ldi	r19, 0x0A	; 10
    dbc8:	83 9f       	mul	r24, r19
    dbca:	c0 01       	movw	r24, r0
    dbcc:	11 24       	eor	r1, r1
    dbce:	28 0f       	add	r18, r24
    dbd0:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    dbd2:	80 e3       	ldi	r24, 0x30	; 48
    dbd4:	80 93 15 03 	sts	0x0315, r24
    dbd8:	80 93 16 03 	sts	0x0316, r24
    dbdc:	80 93 17 03 	sts	0x0317, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    dbe0:	44 0f       	add	r20, r20
    dbe2:	55 1f       	adc	r21, r21
    dbe4:	44 0f       	add	r20, r20
    dbe6:	55 1f       	adc	r21, r21
    dbe8:	60 91 11 03 	lds	r22, 0x0311
    dbec:	64 0f       	add	r22, r20
    dbee:	67 1b       	sub	r22, r23
    dbf0:	80 91 10 03 	lds	r24, 0x0310
    dbf4:	42 e2       	ldi	r20, 0x22	; 34
    dbf6:	53 e1       	ldi	r21, 0x13	; 19
    dbf8:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    dbfc:	00 d0       	rcall	.+0      	; 0xdbfe <FMenuSettingClientIP+0x282>
    dbfe:	00 d0       	rcall	.+0      	; 0xdc00 <FMenuSettingClientIP+0x284>
    dc00:	00 d0       	rcall	.+0      	; 0xdc02 <FMenuSettingClientIP+0x286>
    dc02:	ad b7       	in	r26, 0x3d	; 61
    dc04:	be b7       	in	r27, 0x3e	; 62
    dc06:	11 96       	adiw	r26, 0x01	; 1
    dc08:	8e 01       	movw	r16, r28
    dc0a:	0f 5f       	subi	r16, 0xFF	; 255
    dc0c:	1f 4f       	sbci	r17, 0xFF	; 255
    dc0e:	ed b7       	in	r30, 0x3d	; 61
    dc10:	fe b7       	in	r31, 0x3e	; 62
    dc12:	12 83       	std	Z+2, r17	; 0x02
    dc14:	01 83       	std	Z+1, r16	; 0x01
    dc16:	8f e1       	ldi	r24, 0x1F	; 31
    dc18:	93 e1       	ldi	r25, 0x13	; 19
    dc1a:	13 96       	adiw	r26, 0x03	; 3
    dc1c:	9c 93       	st	X, r25
    dc1e:	8e 93       	st	-X, r24
    dc20:	12 97       	sbiw	r26, 0x02	; 2
    dc22:	e0 91 06 03 	lds	r30, 0x0306
    dc26:	f0 91 07 03 	lds	r31, 0x0307
    dc2a:	e6 5f       	subi	r30, 0xF6	; 246
    dc2c:	fc 4f       	sbci	r31, 0xFC	; 252
    dc2e:	80 81       	ld	r24, Z
    dc30:	14 96       	adiw	r26, 0x04	; 4
    dc32:	8c 93       	st	X, r24
    dc34:	14 97       	sbiw	r26, 0x04	; 4
    dc36:	15 96       	adiw	r26, 0x05	; 5
    dc38:	1c 92       	st	X, r1
    dc3a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    dc3e:	f8 01       	movw	r30, r16
    dc40:	01 90       	ld	r0, Z+
    dc42:	00 20       	and	r0, r0
    dc44:	e9 f7       	brne	.-6      	; 0xdc40 <FMenuSettingClientIP+0x2c4>
    dc46:	31 97       	sbiw	r30, 0x01	; 1
    dc48:	e0 1b       	sub	r30, r16
    dc4a:	f1 0b       	sbc	r31, r17
    dc4c:	8d b7       	in	r24, 0x3d	; 61
    dc4e:	9e b7       	in	r25, 0x3e	; 62
    dc50:	06 96       	adiw	r24, 0x06	; 6
    dc52:	0f b6       	in	r0, 0x3f	; 63
    dc54:	f8 94       	cli
    dc56:	9e bf       	out	0x3e, r25	; 62
    dc58:	0f be       	out	0x3f, r0	; 63
    dc5a:	8d bf       	out	0x3d, r24	; 61
    dc5c:	60 91 11 03 	lds	r22, 0x0311
    dc60:	6f 5f       	subi	r22, 0xFF	; 255
    dc62:	80 91 06 03 	lds	r24, 0x0306
    dc66:	90 91 07 03 	lds	r25, 0x0307
    dc6a:	88 0f       	add	r24, r24
    dc6c:	99 1f       	adc	r25, r25
    dc6e:	88 0f       	add	r24, r24
    dc70:	99 1f       	adc	r25, r25
    dc72:	68 0f       	add	r22, r24
    dc74:	6e 1b       	sub	r22, r30
    dc76:	80 91 10 03 	lds	r24, 0x0310
    dc7a:	a8 01       	movw	r20, r16
    dc7c:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    dc80:	80 91 06 03 	lds	r24, 0x0306
    dc84:	90 91 07 03 	lds	r25, 0x0307
    dc88:	00 97       	sbiw	r24, 0x00	; 0
    dc8a:	81 f0       	breq	.+32     	; 0xdcac <FMenuSettingClientIP+0x330>
    dc8c:	60 91 11 03 	lds	r22, 0x0311
    dc90:	6f 5f       	subi	r22, 0xFF	; 255
    dc92:	81 50       	subi	r24, 0x01	; 1
    dc94:	90 4c       	sbci	r25, 0xC0	; 192
    dc96:	88 0f       	add	r24, r24
    dc98:	99 1f       	adc	r25, r25
    dc9a:	88 0f       	add	r24, r24
    dc9c:	99 1f       	adc	r25, r25
    dc9e:	68 0f       	add	r22, r24
    dca0:	80 91 10 03 	lds	r24, 0x0310
    dca4:	4d e1       	ldi	r20, 0x1D	; 29
    dca6:	53 e1       	ldi	r21, 0x13	; 19
    dca8:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
					   iInput=0;
    dcac:	10 92 0f 03 	sts	0x030F, r1
					   iBlok++;
    dcb0:	80 91 06 03 	lds	r24, 0x0306
    dcb4:	90 91 07 03 	lds	r25, 0x0307
    dcb8:	01 96       	adiw	r24, 0x01	; 1
    dcba:	90 93 07 03 	sts	0x0307, r25
    dcbe:	80 93 06 03 	sts	0x0306, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    dcc2:	80 91 06 03 	lds	r24, 0x0306
    dcc6:	90 91 07 03 	lds	r25, 0x0307
    dcca:	04 97       	sbiw	r24, 0x04	; 4
    dccc:	18 f0       	brcs	.+6      	; 0xdcd4 <FMenuSettingClientIP+0x358>
    dcce:	84 e0       	ldi	r24, 0x04	; 4
    dcd0:	80 93 59 01 	sts	0x0159, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    dcd4:	80 91 0e 03 	lds	r24, 0x030E
    dcd8:	87 3e       	cpi	r24, 0xE7	; 231
    dcda:	09 f4       	brne	.+2      	; 0xdcde <FMenuSettingClientIP+0x362>
    dcdc:	c3 c0       	rjmp	.+390    	; 0xde64 <FMenuSettingClientIP+0x4e8>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    dcde:	87 3b       	cpi	r24, 0xB7	; 183
    dce0:	09 f0       	breq	.+2      	; 0xdce4 <FMenuSettingClientIP+0x368>
    dce2:	c9 c0       	rjmp	.+402    	; 0xde76 <FMenuSettingClientIP+0x4fa>
			       //NextInput
			       if (iBlok<4){
    dce4:	40 91 06 03 	lds	r20, 0x0306
    dce8:	50 91 07 03 	lds	r21, 0x0307
    dcec:	44 30       	cpi	r20, 0x04	; 4
    dcee:	51 05       	cpc	r21, r1
    dcf0:	08 f0       	brcs	.+2      	; 0xdcf4 <FMenuSettingClientIP+0x378>
    dcf2:	a6 c0       	rjmp	.+332    	; 0xde40 <FMenuSettingClientIP+0x4c4>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    dcf4:	80 91 0f 03 	lds	r24, 0x030F
    dcf8:	81 30       	cpi	r24, 0x01	; 1
    dcfa:	41 f4       	brne	.+16     	; 0xdd0c <FMenuSettingClientIP+0x390>
    dcfc:	fa 01       	movw	r30, r20
    dcfe:	e6 5f       	subi	r30, 0xF6	; 246
    dd00:	fc 4f       	sbci	r31, 0xFC	; 252
    dd02:	80 91 15 03 	lds	r24, 0x0315
    dd06:	80 53       	subi	r24, 0x30	; 48
    dd08:	80 83       	st	Z, r24
    dd0a:	22 c0       	rjmp	.+68     	; 0xdd50 <FMenuSettingClientIP+0x3d4>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    dd0c:	82 30       	cpi	r24, 0x02	; 2
    dd0e:	49 f4       	brne	.+18     	; 0xdd22 <FMenuSettingClientIP+0x3a6>
    dd10:	fa 01       	movw	r30, r20
    dd12:	e6 5f       	subi	r30, 0xF6	; 246
    dd14:	fc 4f       	sbci	r31, 0xFC	; 252
    dd16:	20 91 16 03 	lds	r18, 0x0316
    dd1a:	20 51       	subi	r18, 0x10	; 16
    dd1c:	80 91 15 03 	lds	r24, 0x0315
    dd20:	11 c0       	rjmp	.+34     	; 0xdd44 <FMenuSettingClientIP+0x3c8>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    dd22:	83 30       	cpi	r24, 0x03	; 3
    dd24:	a9 f4       	brne	.+42     	; 0xdd50 <FMenuSettingClientIP+0x3d4>
    dd26:	fa 01       	movw	r30, r20
    dd28:	e6 5f       	subi	r30, 0xF6	; 246
    dd2a:	fc 4f       	sbci	r31, 0xFC	; 252
    dd2c:	20 91 17 03 	lds	r18, 0x0317
    dd30:	20 5d       	subi	r18, 0xD0	; 208
    dd32:	80 91 15 03 	lds	r24, 0x0315
    dd36:	34 e6       	ldi	r19, 0x64	; 100
    dd38:	83 9f       	mul	r24, r19
    dd3a:	c0 01       	movw	r24, r0
    dd3c:	11 24       	eor	r1, r1
    dd3e:	28 0f       	add	r18, r24
    dd40:	80 91 16 03 	lds	r24, 0x0316
    dd44:	3a e0       	ldi	r19, 0x0A	; 10
    dd46:	83 9f       	mul	r24, r19
    dd48:	c0 01       	movw	r24, r0
    dd4a:	11 24       	eor	r1, r1
    dd4c:	28 0f       	add	r18, r24
    dd4e:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    dd50:	80 e3       	ldi	r24, 0x30	; 48
    dd52:	80 93 15 03 	sts	0x0315, r24
    dd56:	80 93 16 03 	sts	0x0316, r24
    dd5a:	80 93 17 03 	sts	0x0317, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    dd5e:	60 91 11 03 	lds	r22, 0x0311
    dd62:	63 50       	subi	r22, 0x03	; 3
    dd64:	44 0f       	add	r20, r20
    dd66:	55 1f       	adc	r21, r21
    dd68:	44 0f       	add	r20, r20
    dd6a:	55 1f       	adc	r21, r21
    dd6c:	64 0f       	add	r22, r20
    dd6e:	80 91 10 03 	lds	r24, 0x0310
    dd72:	49 e1       	ldi	r20, 0x19	; 25
    dd74:	53 e1       	ldi	r21, 0x13	; 19
    dd76:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    dd7a:	00 d0       	rcall	.+0      	; 0xdd7c <FMenuSettingClientIP+0x400>
    dd7c:	00 d0       	rcall	.+0      	; 0xdd7e <FMenuSettingClientIP+0x402>
    dd7e:	00 d0       	rcall	.+0      	; 0xdd80 <FMenuSettingClientIP+0x404>
    dd80:	ad b7       	in	r26, 0x3d	; 61
    dd82:	be b7       	in	r27, 0x3e	; 62
    dd84:	11 96       	adiw	r26, 0x01	; 1
    dd86:	8e 01       	movw	r16, r28
    dd88:	0f 5f       	subi	r16, 0xFF	; 255
    dd8a:	1f 4f       	sbci	r17, 0xFF	; 255
    dd8c:	ed b7       	in	r30, 0x3d	; 61
    dd8e:	fe b7       	in	r31, 0x3e	; 62
    dd90:	12 83       	std	Z+2, r17	; 0x02
    dd92:	01 83       	std	Z+1, r16	; 0x01
    dd94:	86 e1       	ldi	r24, 0x16	; 22
    dd96:	93 e1       	ldi	r25, 0x13	; 19
    dd98:	13 96       	adiw	r26, 0x03	; 3
    dd9a:	9c 93       	st	X, r25
    dd9c:	8e 93       	st	-X, r24
    dd9e:	12 97       	sbiw	r26, 0x02	; 2
    dda0:	e0 91 06 03 	lds	r30, 0x0306
    dda4:	f0 91 07 03 	lds	r31, 0x0307
    dda8:	e6 5f       	subi	r30, 0xF6	; 246
    ddaa:	fc 4f       	sbci	r31, 0xFC	; 252
    ddac:	80 81       	ld	r24, Z
    ddae:	14 96       	adiw	r26, 0x04	; 4
    ddb0:	8c 93       	st	X, r24
    ddb2:	14 97       	sbiw	r26, 0x04	; 4
    ddb4:	15 96       	adiw	r26, 0x05	; 5
    ddb6:	1c 92       	st	X, r1
    ddb8:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    ddbc:	f8 01       	movw	r30, r16
    ddbe:	01 90       	ld	r0, Z+
    ddc0:	00 20       	and	r0, r0
    ddc2:	e9 f7       	brne	.-6      	; 0xddbe <FMenuSettingClientIP+0x442>
    ddc4:	31 97       	sbiw	r30, 0x01	; 1
    ddc6:	e0 1b       	sub	r30, r16
    ddc8:	f1 0b       	sbc	r31, r17
    ddca:	8d b7       	in	r24, 0x3d	; 61
    ddcc:	9e b7       	in	r25, 0x3e	; 62
    ddce:	06 96       	adiw	r24, 0x06	; 6
    ddd0:	0f b6       	in	r0, 0x3f	; 63
    ddd2:	f8 94       	cli
    ddd4:	9e bf       	out	0x3e, r25	; 62
    ddd6:	0f be       	out	0x3f, r0	; 63
    ddd8:	8d bf       	out	0x3d, r24	; 61
    ddda:	60 91 11 03 	lds	r22, 0x0311
    ddde:	6f 5f       	subi	r22, 0xFF	; 255
    dde0:	80 91 06 03 	lds	r24, 0x0306
    dde4:	90 91 07 03 	lds	r25, 0x0307
    dde8:	88 0f       	add	r24, r24
    ddea:	99 1f       	adc	r25, r25
    ddec:	88 0f       	add	r24, r24
    ddee:	99 1f       	adc	r25, r25
    ddf0:	68 0f       	add	r22, r24
    ddf2:	6e 1b       	sub	r22, r30
    ddf4:	80 91 10 03 	lds	r24, 0x0310
    ddf8:	a8 01       	movw	r20, r16
    ddfa:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    ddfe:	80 91 06 03 	lds	r24, 0x0306
    de02:	90 91 07 03 	lds	r25, 0x0307
    de06:	00 97       	sbiw	r24, 0x00	; 0
    de08:	81 f0       	breq	.+32     	; 0xde2a <FMenuSettingClientIP+0x4ae>
    de0a:	60 91 11 03 	lds	r22, 0x0311
    de0e:	6f 5f       	subi	r22, 0xFF	; 255
    de10:	81 50       	subi	r24, 0x01	; 1
    de12:	90 4c       	sbci	r25, 0xC0	; 192
    de14:	88 0f       	add	r24, r24
    de16:	99 1f       	adc	r25, r25
    de18:	88 0f       	add	r24, r24
    de1a:	99 1f       	adc	r25, r25
    de1c:	68 0f       	add	r22, r24
    de1e:	80 91 10 03 	lds	r24, 0x0310
    de22:	44 e1       	ldi	r20, 0x14	; 20
    de24:	53 e1       	ldi	r21, 0x13	; 19
    de26:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				       iInput=0;
    de2a:	10 92 0f 03 	sts	0x030F, r1
					   iBlok++;	   
    de2e:	80 91 06 03 	lds	r24, 0x0306
    de32:	90 91 07 03 	lds	r25, 0x0307
    de36:	01 96       	adiw	r24, 0x01	; 1
    de38:	90 93 07 03 	sts	0x0307, r25
    de3c:	80 93 06 03 	sts	0x0306, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    de40:	80 91 06 03 	lds	r24, 0x0306
    de44:	90 91 07 03 	lds	r25, 0x0307
    de48:	04 97       	sbiw	r24, 0x04	; 4
    de4a:	a8 f0       	brcs	.+42     	; 0xde76 <FMenuSettingClientIP+0x4fa>
    de4c:	84 e0       	ldi	r24, 0x04	; 4
    de4e:	0b c0       	rjmp	.+22     	; 0xde66 <FMenuSettingClientIP+0x4ea>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    de50:	88 e2       	ldi	r24, 0x28	; 40
    de52:	90 e0       	ldi	r25, 0x00	; 0
    de54:	6a e0       	ldi	r22, 0x0A	; 10
    de56:	73 e0       	ldi	r23, 0x03	; 3
    de58:	44 e0       	ldi	r20, 0x04	; 4
    de5a:	50 e0       	ldi	r21, 0x00	; 0
    de5c:	20 e0       	ldi	r18, 0x00	; 0
    de5e:	33 e1       	ldi	r19, 0x13	; 19
    de60:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
			   }
		       break;
          case cipStoreIPblok://UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefClientIP,4);
			   stClientIP=cipExit;
    de64:	83 e0       	ldi	r24, 0x03	; 3
    de66:	80 93 59 01 	sts	0x0159, r24
    de6a:	05 c0       	rjmp	.+10     	; 0xde76 <FMenuSettingClientIP+0x4fa>
		       break; 
          case cipExit://Cancel IPConfig
		       stClientIP=cipInit;
    de6c:	81 e0       	ldi	r24, 0x01	; 1
    de6e:	80 93 59 01 	sts	0x0159, r24
		       Result=MENU_DONE;
    de72:	80 93 13 03 	sts	0x0313, r24
		       break;     
		  }//EndSwitch	 
    return Result;
}
    de76:	80 91 13 03 	lds	r24, 0x0313
    de7a:	64 96       	adiw	r28, 0x14	; 20
    de7c:	0f b6       	in	r0, 0x3f	; 63
    de7e:	f8 94       	cli
    de80:	de bf       	out	0x3e, r29	; 62
    de82:	0f be       	out	0x3f, r0	; 63
    de84:	cd bf       	out	0x3d, r28	; 61
    de86:	cf 91       	pop	r28
    de88:	df 91       	pop	r29
    de8a:	1f 91       	pop	r17
    de8c:	0f 91       	pop	r16
    de8e:	08 95       	ret

0000de90 <DisplayStandaloneSequence>:
	 i++;
     _delay_ms(6500);
  return Result;
}

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
    de90:	df 93       	push	r29
    de92:	cf 93       	push	r28
    de94:	cd b7       	in	r28, 0x3d	; 61
    de96:	de b7       	in	r29, 0x3e	; 62
    de98:	28 97       	sbiw	r28, 0x08	; 8
    de9a:	0f b6       	in	r0, 0x3f	; 63
    de9c:	f8 94       	cli
    de9e:	de bf       	out	0x3e, r29	; 62
    dea0:	0f be       	out	0x3f, r0	; 63
    dea2:	cd bf       	out	0x3d, r28	; 61
    dea4:	58 2f       	mov	r21, r24
	 MapSequence[3]='/';
	 MapSequence[4]='-';
	 MapSequence[5]=164;//0x5C;
	 MapSequence[6]='|';
	 MapSequence[7]='/';
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    dea6:	80 91 96 01 	lds	r24, 0x0196
    deaa:	88 23       	and	r24, r24
    deac:	a1 f4       	brne	.+40     	; 0xded6 <DisplayStandaloneSequence+0x46>

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
     char MapSequence[8];

     //sprintf_P(MapSequence,PSTR("-\|/-|/"));
	 MapSequence[0]='-';
    deae:	3d e2       	ldi	r19, 0x2D	; 45
    deb0:	39 83       	std	Y+1, r19	; 0x01
	 MapSequence[1]='`';//0x5C;
    deb2:	80 e6       	ldi	r24, 0x60	; 96
    deb4:	8a 83       	std	Y+2, r24	; 0x02
	 MapSequence[2]='|';
    deb6:	2c e7       	ldi	r18, 0x7C	; 124
    deb8:	2b 83       	std	Y+3, r18	; 0x03
	 MapSequence[3]='/';
    deba:	9f e2       	ldi	r25, 0x2F	; 47
    debc:	9c 83       	std	Y+4, r25	; 0x04
	 MapSequence[4]='-';
    debe:	3d 83       	std	Y+5, r19	; 0x05
	 MapSequence[5]=164;//0x5C;
    dec0:	84 ea       	ldi	r24, 0xA4	; 164
    dec2:	8e 83       	std	Y+6, r24	; 0x06
	 MapSequence[6]='|';
    dec4:	2f 83       	std	Y+7, r18	; 0x07
	 MapSequence[7]='/';
    dec6:	98 87       	std	Y+8, r25	; 0x08
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    dec8:	47 70       	andi	r20, 0x07	; 7
    deca:	fe 01       	movw	r30, r28
    decc:	e4 0f       	add	r30, r20
    dece:	f1 1d       	adc	r31, r1
    ded0:	85 2f       	mov	r24, r21
    ded2:	41 81       	ldd	r20, Z+1	; 0x01
    ded4:	08 c0       	rjmp	.+16     	; 0xdee6 <DisplayStandaloneSequence+0x56>
	 else if (IsPoolingRestarted==True){
    ded6:	80 91 96 01 	lds	r24, 0x0196
    deda:	81 30       	cpi	r24, 0x01	; 1
    dedc:	31 f4       	brne	.+12     	; 0xdeea <DisplayStandaloneSequence+0x5a>
	          IsPoolingRestarted=False;
    dede:	10 92 96 01 	sts	0x0196, r1
	          lcd_put(x,y,'X');     
    dee2:	85 2f       	mov	r24, r21
    dee4:	48 e5       	ldi	r20, 0x58	; 88
    dee6:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
			  }

}
    deea:	28 96       	adiw	r28, 0x08	; 8
    deec:	0f b6       	in	r0, 0x3f	; 63
    deee:	f8 94       	cli
    def0:	de bf       	out	0x3e, r29	; 62
    def2:	0f be       	out	0x3f, r0	; 63
    def4:	cd bf       	out	0x3d, r28	; 61
    def6:	cf 91       	pop	r28
    def8:	df 91       	pop	r29
    defa:	08 95       	ret

0000defc <FSettingPumpPooling>:
	      break;
	 }
     return Result;
}

char FSettingPumpPooling(){//Parameter: PumpCount,
    defc:	0f 93       	push	r16
    defe:	1f 93       	push	r17
    df00:	df 93       	push	r29
    df02:	cf 93       	push	r28
    df04:	cd b7       	in	r28, 0x3d	; 61
    df06:	de b7       	in	r29, 0x3e	; 62
    df08:	6a 97       	sbiw	r28, 0x1a	; 26
    df0a:	0f b6       	in	r0, 0x3f	; 63
    df0c:	f8 94       	cli
    df0e:	de bf       	out	0x3e, r29	; 62
    df10:	0f be       	out	0x3f, r0	; 63
    df12:	cd bf       	out	0x3d, r28	; 61
static char stPumpPooling=ppInitMenu;
char i,lcdteks[20];
char KeyChar,Addr=0,PPoolingSetting[6];
     Result=MENU_NONE;

     switch(stPumpPooling){
    df14:	80 91 df 02 	lds	r24, 0x02DF
    df18:	82 30       	cpi	r24, 0x02	; 2
    df1a:	09 f4       	brne	.+2      	; 0xdf1e <FSettingPumpPooling+0x22>
    df1c:	1b c1       	rjmp	.+566    	; 0xe154 <FSettingPumpPooling+0x258>
    df1e:	83 30       	cpi	r24, 0x03	; 3
    df20:	30 f4       	brcc	.+12     	; 0xdf2e <FSettingPumpPooling+0x32>
    df22:	88 23       	and	r24, r24
    df24:	59 f0       	breq	.+22     	; 0xdf3c <FSettingPumpPooling+0x40>
    df26:	81 30       	cpi	r24, 0x01	; 1
    df28:	09 f0       	breq	.+2      	; 0xdf2c <FSettingPumpPooling+0x30>
    df2a:	1b c2       	rjmp	.+1078   	; 0xe362 <FSettingPumpPooling+0x466>
    df2c:	09 c1       	rjmp	.+530    	; 0xe140 <FSettingPumpPooling+0x244>
    df2e:	83 30       	cpi	r24, 0x03	; 3
    df30:	09 f4       	brne	.+2      	; 0xdf34 <FSettingPumpPooling+0x38>
    df32:	06 c2       	rjmp	.+1036   	; 0xe340 <FSettingPumpPooling+0x444>
    df34:	84 30       	cpi	r24, 0x04	; 4
    df36:	09 f0       	breq	.+2      	; 0xdf3a <FSettingPumpPooling+0x3e>
    df38:	14 c2       	rjmp	.+1064   	; 0xe362 <FSettingPumpPooling+0x466>
    df3a:	0f c2       	rjmp	.+1054   	; 0xe35a <FSettingPumpPooling+0x45e>
	 case ppInitMenu:
          lcd_clear();
    df3c:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
    df40:	20 e0       	ldi	r18, 0x00	; 0
    df42:	30 e0       	ldi	r19, 0x00	; 0
		  for (i=0;i<6;i++){
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
    df44:	ae 01       	movw	r20, r28
    df46:	4f 5f       	subi	r20, 0xFF	; 255
    df48:	5f 4f       	sbci	r21, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    df4a:	e1 99       	sbic	0x1c, 1	; 28
    df4c:	fe cf       	rjmp	.-4      	; 0xdf4a <FSettingPumpPooling+0x4e>
    df4e:	c9 01       	movw	r24, r18
    df50:	8c 5b       	subi	r24, 0xBC	; 188
    df52:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    df54:	9f bb       	out	0x1f, r25	; 31
    df56:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    df58:	e0 9a       	sbi	0x1c, 0	; 28
    df5a:	8d b3       	in	r24, 0x1d	; 29
    df5c:	fa 01       	movw	r30, r20
    df5e:	e2 0f       	add	r30, r18
    df60:	f3 1f       	adc	r31, r19
    df62:	80 83       	st	Z, r24
    df64:	2f 5f       	subi	r18, 0xFF	; 255
    df66:	3f 4f       	sbci	r19, 0xFF	; 255
     Result=MENU_NONE;

     switch(stPumpPooling){
	 case ppInitMenu:
          lcd_clear();
		  for (i=0;i<6;i++){
    df68:	26 30       	cpi	r18, 0x06	; 6
    df6a:	31 05       	cpc	r19, r1
    df6c:	71 f7       	brne	.-36     	; 0xdf4a <FSettingPumpPooling+0x4e>
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
		  }

		  sprintf_P(lcdteks,PSTR("1.MaxPump:%d"),PPoolingSetting[0]);lcd_print(1,1,lcdteks);
    df6e:	00 d0       	rcall	.+0      	; 0xdf70 <FSettingPumpPooling+0x74>
    df70:	00 d0       	rcall	.+0      	; 0xdf72 <FSettingPumpPooling+0x76>
    df72:	00 d0       	rcall	.+0      	; 0xdf74 <FSettingPumpPooling+0x78>
    df74:	ed b7       	in	r30, 0x3d	; 61
    df76:	fe b7       	in	r31, 0x3e	; 62
    df78:	31 96       	adiw	r30, 0x01	; 1
    df7a:	8e 01       	movw	r16, r28
    df7c:	09 5f       	subi	r16, 0xF9	; 249
    df7e:	1f 4f       	sbci	r17, 0xFF	; 255
    df80:	ad b7       	in	r26, 0x3d	; 61
    df82:	be b7       	in	r27, 0x3e	; 62
    df84:	12 96       	adiw	r26, 0x02	; 2
    df86:	1c 93       	st	X, r17
    df88:	0e 93       	st	-X, r16
    df8a:	11 97       	sbiw	r26, 0x01	; 1
    df8c:	83 ea       	ldi	r24, 0xA3	; 163
    df8e:	9d e0       	ldi	r25, 0x0D	; 13
    df90:	93 83       	std	Z+3, r25	; 0x03
    df92:	82 83       	std	Z+2, r24	; 0x02
    df94:	89 81       	ldd	r24, Y+1	; 0x01
    df96:	84 83       	std	Z+4, r24	; 0x04
    df98:	15 82       	std	Z+5, r1	; 0x05
    df9a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    df9e:	ed b7       	in	r30, 0x3d	; 61
    dfa0:	fe b7       	in	r31, 0x3e	; 62
    dfa2:	36 96       	adiw	r30, 0x06	; 6
    dfa4:	0f b6       	in	r0, 0x3f	; 63
    dfa6:	f8 94       	cli
    dfa8:	fe bf       	out	0x3e, r31	; 62
    dfaa:	0f be       	out	0x3f, r0	; 63
    dfac:	ed bf       	out	0x3d, r30	; 61
    dfae:	81 e0       	ldi	r24, 0x01	; 1
    dfb0:	61 e0       	ldi	r22, 0x01	; 1
    dfb2:	a8 01       	movw	r20, r16
    dfb4:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
          sprintf_P(lcdteks,PSTR("2.nNoPump:%d"),PPoolingSetting[1]);lcd_print(2,1,lcdteks);
    dfb8:	00 d0       	rcall	.+0      	; 0xdfba <FSettingPumpPooling+0xbe>
    dfba:	00 d0       	rcall	.+0      	; 0xdfbc <FSettingPumpPooling+0xc0>
    dfbc:	00 d0       	rcall	.+0      	; 0xdfbe <FSettingPumpPooling+0xc2>
    dfbe:	ed b7       	in	r30, 0x3d	; 61
    dfc0:	fe b7       	in	r31, 0x3e	; 62
    dfc2:	31 96       	adiw	r30, 0x01	; 1
    dfc4:	ad b7       	in	r26, 0x3d	; 61
    dfc6:	be b7       	in	r27, 0x3e	; 62
    dfc8:	12 96       	adiw	r26, 0x02	; 2
    dfca:	1c 93       	st	X, r17
    dfcc:	0e 93       	st	-X, r16
    dfce:	11 97       	sbiw	r26, 0x01	; 1
    dfd0:	86 e9       	ldi	r24, 0x96	; 150
    dfd2:	9d e0       	ldi	r25, 0x0D	; 13
    dfd4:	93 83       	std	Z+3, r25	; 0x03
    dfd6:	82 83       	std	Z+2, r24	; 0x02
    dfd8:	8a 81       	ldd	r24, Y+2	; 0x02
    dfda:	84 83       	std	Z+4, r24	; 0x04
    dfdc:	15 82       	std	Z+5, r1	; 0x05
    dfde:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    dfe2:	ed b7       	in	r30, 0x3d	; 61
    dfe4:	fe b7       	in	r31, 0x3e	; 62
    dfe6:	36 96       	adiw	r30, 0x06	; 6
    dfe8:	0f b6       	in	r0, 0x3f	; 63
    dfea:	f8 94       	cli
    dfec:	fe bf       	out	0x3e, r31	; 62
    dfee:	0f be       	out	0x3f, r0	; 63
    dff0:	ed bf       	out	0x3d, r30	; 61
    dff2:	82 e0       	ldi	r24, 0x02	; 2
    dff4:	61 e0       	ldi	r22, 0x01	; 1
    dff6:	a8 01       	movw	r20, r16
    dff8:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
          sprintf_P(lcdteks,PSTR("3.TrySend:%d"),PPoolingSetting[2]);lcd_print(3,1,lcdteks);
    dffc:	00 d0       	rcall	.+0      	; 0xdffe <FSettingPumpPooling+0x102>
    dffe:	00 d0       	rcall	.+0      	; 0xe000 <FSettingPumpPooling+0x104>
    e000:	00 d0       	rcall	.+0      	; 0xe002 <FSettingPumpPooling+0x106>
    e002:	ed b7       	in	r30, 0x3d	; 61
    e004:	fe b7       	in	r31, 0x3e	; 62
    e006:	31 96       	adiw	r30, 0x01	; 1
    e008:	ad b7       	in	r26, 0x3d	; 61
    e00a:	be b7       	in	r27, 0x3e	; 62
    e00c:	12 96       	adiw	r26, 0x02	; 2
    e00e:	1c 93       	st	X, r17
    e010:	0e 93       	st	-X, r16
    e012:	11 97       	sbiw	r26, 0x01	; 1
    e014:	89 e8       	ldi	r24, 0x89	; 137
    e016:	9d e0       	ldi	r25, 0x0D	; 13
    e018:	93 83       	std	Z+3, r25	; 0x03
    e01a:	82 83       	std	Z+2, r24	; 0x02
    e01c:	8b 81       	ldd	r24, Y+3	; 0x03
    e01e:	84 83       	std	Z+4, r24	; 0x04
    e020:	15 82       	std	Z+5, r1	; 0x05
    e022:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    e026:	ed b7       	in	r30, 0x3d	; 61
    e028:	fe b7       	in	r31, 0x3e	; 62
    e02a:	36 96       	adiw	r30, 0x06	; 6
    e02c:	0f b6       	in	r0, 0x3f	; 63
    e02e:	f8 94       	cli
    e030:	fe bf       	out	0x3e, r31	; 62
    e032:	0f be       	out	0x3f, r0	; 63
    e034:	ed bf       	out	0x3d, r30	; 61
    e036:	83 e0       	ldi	r24, 0x03	; 3
    e038:	61 e0       	ldi	r22, 0x01	; 1
    e03a:	a8 01       	movw	r20, r16
    e03c:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
          sprintf_P(lcdteks,PSTR("4.TimPool:%d"),PPoolingSetting[3]);lcd_print(4,1,lcdteks);
    e040:	00 d0       	rcall	.+0      	; 0xe042 <FSettingPumpPooling+0x146>
    e042:	00 d0       	rcall	.+0      	; 0xe044 <FSettingPumpPooling+0x148>
    e044:	00 d0       	rcall	.+0      	; 0xe046 <FSettingPumpPooling+0x14a>
    e046:	ed b7       	in	r30, 0x3d	; 61
    e048:	fe b7       	in	r31, 0x3e	; 62
    e04a:	31 96       	adiw	r30, 0x01	; 1
    e04c:	ad b7       	in	r26, 0x3d	; 61
    e04e:	be b7       	in	r27, 0x3e	; 62
    e050:	12 96       	adiw	r26, 0x02	; 2
    e052:	1c 93       	st	X, r17
    e054:	0e 93       	st	-X, r16
    e056:	11 97       	sbiw	r26, 0x01	; 1
    e058:	8c e7       	ldi	r24, 0x7C	; 124
    e05a:	9d e0       	ldi	r25, 0x0D	; 13
    e05c:	93 83       	std	Z+3, r25	; 0x03
    e05e:	82 83       	std	Z+2, r24	; 0x02
    e060:	8c 81       	ldd	r24, Y+4	; 0x04
    e062:	84 83       	std	Z+4, r24	; 0x04
    e064:	15 82       	std	Z+5, r1	; 0x05
    e066:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    e06a:	ed b7       	in	r30, 0x3d	; 61
    e06c:	fe b7       	in	r31, 0x3e	; 62
    e06e:	36 96       	adiw	r30, 0x06	; 6
    e070:	0f b6       	in	r0, 0x3f	; 63
    e072:	f8 94       	cli
    e074:	fe bf       	out	0x3e, r31	; 62
    e076:	0f be       	out	0x3f, r0	; 63
    e078:	ed bf       	out	0x3d, r30	; 61
    e07a:	84 e0       	ldi	r24, 0x04	; 4
    e07c:	61 e0       	ldi	r22, 0x01	; 1
    e07e:	a8 01       	movw	r20, r16
    e080:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
          sprintf_P(lcdteks,PSTR("5.Dly:%d"),PPoolingSetting[4]);lcd_print(1,13,lcdteks);
    e084:	00 d0       	rcall	.+0      	; 0xe086 <FSettingPumpPooling+0x18a>
    e086:	00 d0       	rcall	.+0      	; 0xe088 <FSettingPumpPooling+0x18c>
    e088:	00 d0       	rcall	.+0      	; 0xe08a <FSettingPumpPooling+0x18e>
    e08a:	ed b7       	in	r30, 0x3d	; 61
    e08c:	fe b7       	in	r31, 0x3e	; 62
    e08e:	31 96       	adiw	r30, 0x01	; 1
    e090:	ad b7       	in	r26, 0x3d	; 61
    e092:	be b7       	in	r27, 0x3e	; 62
    e094:	12 96       	adiw	r26, 0x02	; 2
    e096:	1c 93       	st	X, r17
    e098:	0e 93       	st	-X, r16
    e09a:	11 97       	sbiw	r26, 0x01	; 1
    e09c:	83 e7       	ldi	r24, 0x73	; 115
    e09e:	9d e0       	ldi	r25, 0x0D	; 13
    e0a0:	93 83       	std	Z+3, r25	; 0x03
    e0a2:	82 83       	std	Z+2, r24	; 0x02
    e0a4:	8d 81       	ldd	r24, Y+5	; 0x05
    e0a6:	84 83       	std	Z+4, r24	; 0x04
    e0a8:	15 82       	std	Z+5, r1	; 0x05
    e0aa:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    e0ae:	ed b7       	in	r30, 0x3d	; 61
    e0b0:	fe b7       	in	r31, 0x3e	; 62
    e0b2:	36 96       	adiw	r30, 0x06	; 6
    e0b4:	0f b6       	in	r0, 0x3f	; 63
    e0b6:	f8 94       	cli
    e0b8:	fe bf       	out	0x3e, r31	; 62
    e0ba:	0f be       	out	0x3f, r0	; 63
    e0bc:	ed bf       	out	0x3d, r30	; 61
    e0be:	81 e0       	ldi	r24, 0x01	; 1
    e0c0:	6d e0       	ldi	r22, 0x0D	; 13
    e0c2:	a8 01       	movw	r20, r16
    e0c4:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
          sprintf_P(lcdteks,PSTR("6.Act:%d"),PPoolingSetting[5]);lcd_print(2,13,lcdteks);
    e0c8:	00 d0       	rcall	.+0      	; 0xe0ca <FSettingPumpPooling+0x1ce>
    e0ca:	00 d0       	rcall	.+0      	; 0xe0cc <FSettingPumpPooling+0x1d0>
    e0cc:	00 d0       	rcall	.+0      	; 0xe0ce <FSettingPumpPooling+0x1d2>
    e0ce:	ed b7       	in	r30, 0x3d	; 61
    e0d0:	fe b7       	in	r31, 0x3e	; 62
    e0d2:	31 96       	adiw	r30, 0x01	; 1
    e0d4:	ad b7       	in	r26, 0x3d	; 61
    e0d6:	be b7       	in	r27, 0x3e	; 62
    e0d8:	12 96       	adiw	r26, 0x02	; 2
    e0da:	1c 93       	st	X, r17
    e0dc:	0e 93       	st	-X, r16
    e0de:	11 97       	sbiw	r26, 0x01	; 1
    e0e0:	8a e6       	ldi	r24, 0x6A	; 106
    e0e2:	9d e0       	ldi	r25, 0x0D	; 13
    e0e4:	93 83       	std	Z+3, r25	; 0x03
    e0e6:	82 83       	std	Z+2, r24	; 0x02
    e0e8:	8e 81       	ldd	r24, Y+6	; 0x06
    e0ea:	84 83       	std	Z+4, r24	; 0x04
    e0ec:	15 82       	std	Z+5, r1	; 0x05
    e0ee:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    e0f2:	ed b7       	in	r30, 0x3d	; 61
    e0f4:	fe b7       	in	r31, 0x3e	; 62
    e0f6:	36 96       	adiw	r30, 0x06	; 6
    e0f8:	0f b6       	in	r0, 0x3f	; 63
    e0fa:	f8 94       	cli
    e0fc:	fe bf       	out	0x3e, r31	; 62
    e0fe:	0f be       	out	0x3f, r0	; 63
    e100:	ed bf       	out	0x3d, r30	; 61
    e102:	82 e0       	ldi	r24, 0x02	; 2
    e104:	6d e0       	ldi	r22, 0x0D	; 13
    e106:	a8 01       	movw	r20, r16
    e108:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
          sprintf_P(lcdteks,PSTR("[*]Exit"));lcd_print(4,13,lcdteks);
    e10c:	00 d0       	rcall	.+0      	; 0xe10e <FSettingPumpPooling+0x212>
    e10e:	00 d0       	rcall	.+0      	; 0xe110 <FSettingPumpPooling+0x214>
    e110:	ad b7       	in	r26, 0x3d	; 61
    e112:	be b7       	in	r27, 0x3e	; 62
    e114:	12 96       	adiw	r26, 0x02	; 2
    e116:	1c 93       	st	X, r17
    e118:	0e 93       	st	-X, r16
    e11a:	11 97       	sbiw	r26, 0x01	; 1
    e11c:	82 e6       	ldi	r24, 0x62	; 98
    e11e:	9d e0       	ldi	r25, 0x0D	; 13
    e120:	14 96       	adiw	r26, 0x04	; 4
    e122:	9c 93       	st	X, r25
    e124:	8e 93       	st	-X, r24
    e126:	13 97       	sbiw	r26, 0x03	; 3
    e128:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    e12c:	0f 90       	pop	r0
    e12e:	0f 90       	pop	r0
    e130:	0f 90       	pop	r0
    e132:	0f 90       	pop	r0
    e134:	84 e0       	ldi	r24, 0x04	; 4
    e136:	6d e0       	ldi	r22, 0x0D	; 13
    e138:	a8 01       	movw	r20, r16
    e13a:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    e13e:	08 c0       	rjmp	.+16     	; 0xe150 <FSettingPumpPooling+0x254>

          stPumpPooling=ppPoolingSettingInput;
	      break;
     case ppDisplaySequence:
          IsNewPoolingSequence=False;
    e140:	10 92 94 01 	sts	0x0194, r1
		  DisplayStandaloneSequence(3,14,iSequencePooling);
    e144:	83 e0       	ldi	r24, 0x03	; 3
    e146:	6e e0       	ldi	r22, 0x0E	; 14
    e148:	40 91 93 01 	lds	r20, 0x0193
    e14c:	0e 94 48 6f 	call	0xde90	; 0xde90 <DisplayStandaloneSequence>
          stPumpPooling=ppPoolingSettingInput;
    e150:	82 e0       	ldi	r24, 0x02	; 2
    e152:	f3 c0       	rjmp	.+486    	; 0xe33a <FSettingPumpPooling+0x43e>
	      break;
     case ppPoolingSettingInput:
	      if(IsNewPoolingSequence==True)stPumpPooling=ppDisplaySequence;
    e154:	80 91 94 01 	lds	r24, 0x0194
    e158:	81 30       	cpi	r24, 0x01	; 1
    e15a:	11 f4       	brne	.+4      	; 0xe160 <FSettingPumpPooling+0x264>
    e15c:	80 93 df 02 	sts	0x02DF, r24

          KeyChar=_key_btn(_key_scan(1));
    e160:	81 e0       	ldi	r24, 0x01	; 1
    e162:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    e166:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    e16a:	48 2f       	mov	r20, r24
    e16c:	41 53       	subi	r20, 0x31	; 49
    e16e:	46 30       	cpi	r20, 0x06	; 6
    e170:	10 f0       	brcs	.+4      	; 0xe176 <FSettingPumpPooling+0x27a>
    e172:	40 e0       	ldi	r20, 0x00	; 0
    e174:	06 c0       	rjmp	.+12     	; 0xe182 <FSettingPumpPooling+0x286>
		      Addr=KeyChar-'1';
			  TimSend=0;
    e176:	10 92 a9 01 	sts	0x01A9, r1
    e17a:	10 92 a8 01 	sts	0x01A8, r1
			  IsStandaloneAcknoledge=False;
    e17e:	10 92 95 01 	sts	0x0195, r1
          }
		  switch(KeyChar){
    e182:	83 33       	cpi	r24, 0x33	; 51
    e184:	09 f4       	brne	.+2      	; 0xe188 <FSettingPumpPooling+0x28c>
    e186:	67 c0       	rjmp	.+206    	; 0xe256 <FSettingPumpPooling+0x35a>
    e188:	84 33       	cpi	r24, 0x34	; 52
    e18a:	48 f4       	brcc	.+18     	; 0xe19e <FSettingPumpPooling+0x2a2>
    e18c:	81 33       	cpi	r24, 0x31	; 49
    e18e:	89 f0       	breq	.+34     	; 0xe1b2 <FSettingPumpPooling+0x2b6>
    e190:	82 33       	cpi	r24, 0x32	; 50
    e192:	08 f0       	brcs	.+2      	; 0xe196 <FSettingPumpPooling+0x29a>
    e194:	3d c0       	rjmp	.+122    	; 0xe210 <FSettingPumpPooling+0x314>
    e196:	8a 32       	cpi	r24, 0x2A	; 42
    e198:	09 f0       	breq	.+2      	; 0xe19c <FSettingPumpPooling+0x2a0>
    e19a:	e3 c0       	rjmp	.+454    	; 0xe362 <FSettingPumpPooling+0x466>
    e19c:	cd c0       	rjmp	.+410    	; 0xe338 <FSettingPumpPooling+0x43c>
    e19e:	85 33       	cpi	r24, 0x35	; 53
    e1a0:	09 f4       	brne	.+2      	; 0xe1a4 <FSettingPumpPooling+0x2a8>
    e1a2:	91 c0       	rjmp	.+290    	; 0xe2c6 <FSettingPumpPooling+0x3ca>
    e1a4:	85 33       	cpi	r24, 0x35	; 53
    e1a6:	08 f4       	brcc	.+2      	; 0xe1aa <FSettingPumpPooling+0x2ae>
    e1a8:	78 c0       	rjmp	.+240    	; 0xe29a <FSettingPumpPooling+0x39e>
    e1aa:	86 33       	cpi	r24, 0x36	; 54
    e1ac:	09 f0       	breq	.+2      	; 0xe1b0 <FSettingPumpPooling+0x2b4>
    e1ae:	d9 c0       	rjmp	.+434    	; 0xe362 <FSettingPumpPooling+0x466>
    e1b0:	a0 c0       	rjmp	.+320    	; 0xe2f2 <FSettingPumpPooling+0x3f6>
		  case '1'://MaxPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%17);
    e1b2:	24 2f       	mov	r18, r20
    e1b4:	30 e0       	ldi	r19, 0x00	; 0
    e1b6:	fe 01       	movw	r30, r28
    e1b8:	31 96       	adiw	r30, 0x01	; 1
    e1ba:	e2 0f       	add	r30, r18
    e1bc:	f3 1f       	adc	r31, r19
    e1be:	80 81       	ld	r24, Z
    e1c0:	90 e0       	ldi	r25, 0x00	; 0
    e1c2:	01 96       	adiw	r24, 0x01	; 1
    e1c4:	61 e1       	ldi	r22, 0x11	; 17
    e1c6:	70 e0       	ldi	r23, 0x00	; 0
    e1c8:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    e1cc:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    e1ce:	88 23       	and	r24, r24
    e1d0:	11 f4       	brne	.+4      	; 0xe1d6 <FSettingPumpPooling+0x2da>
    e1d2:	81 e0       	ldi	r24, 0x01	; 1
    e1d4:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
    e1d6:	2c 0f       	add	r18, r28
    e1d8:	3d 1f       	adc	r19, r29
    e1da:	f9 01       	movw	r30, r18
    e1dc:	21 81       	ldd	r18, Z+1	; 0x01
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e1de:	85 e1       	ldi	r24, 0x15	; 21
    e1e0:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    e1e4:	20 93 3c 0f 	sts	0x0F3C, r18
     IsControlPooling=True;
    e1e8:	81 e0       	ldi	r24, 0x01	; 1
    e1ea:	80 93 97 01 	sts	0x0197, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e1ee:	e1 99       	sbic	0x1c, 1	; 28
    e1f0:	fe cf       	rjmp	.-4      	; 0xe1ee <FSettingPumpPooling+0x2f2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e1f2:	84 2f       	mov	r24, r20
    e1f4:	90 e0       	ldi	r25, 0x00	; 0
    e1f6:	8c 5b       	subi	r24, 0xBC	; 188
    e1f8:	9e 4f       	sbci	r25, 0xFE	; 254
    e1fa:	9f bb       	out	0x1f, r25	; 31
    e1fc:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    e1fe:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    e200:	0f b6       	in	r0, 0x3f	; 63
    e202:	f8 94       	cli
    e204:	e2 9a       	sbi	0x1c, 2	; 28
    e206:	e1 9a       	sbi	0x1c, 1	; 28
    e208:	0f be       	out	0x3f, r0	; 63
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   PumpCountMax=PPoolingSetting[Addr];
    e20a:	20 93 5f 01 	sts	0x015F, r18
    e20e:	21 c0       	rjmp	.+66     	; 0xe252 <FSettingPumpPooling+0x356>
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '2'://NoPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e210:	fe 01       	movw	r30, r28
    e212:	e4 0f       	add	r30, r20
    e214:	f1 1d       	adc	r31, r1
    e216:	81 81       	ldd	r24, Z+1	; 0x01
    e218:	90 e0       	ldi	r25, 0x00	; 0
    e21a:	01 96       	adiw	r24, 0x01	; 1
    e21c:	65 e1       	ldi	r22, 0x15	; 21
    e21e:	70 e0       	ldi	r23, 0x00	; 0
    e220:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    e224:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e226:	84 e1       	ldi	r24, 0x14	; 20
    e228:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    e22c:	20 93 3c 0f 	sts	0x0F3C, r18
     IsControlPooling=True;
    e230:	81 e0       	ldi	r24, 0x01	; 1
    e232:	80 93 97 01 	sts	0x0197, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e236:	e1 99       	sbic	0x1c, 1	; 28
    e238:	fe cf       	rjmp	.-4      	; 0xe236 <FSettingPumpPooling+0x33a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e23a:	84 2f       	mov	r24, r20
    e23c:	90 e0       	ldi	r25, 0x00	; 0
    e23e:	8c 5b       	subi	r24, 0xBC	; 188
    e240:	9e 4f       	sbci	r25, 0xFE	; 254
    e242:	9f bb       	out	0x1f, r25	; 31
    e244:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    e246:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    e248:	0f b6       	in	r0, 0x3f	; 63
    e24a:	f8 94       	cli
    e24c:	e2 9a       	sbi	0x1c, 2	; 28
    e24e:	e1 9a       	sbi	0x1c, 1	; 28
    e250:	0f be       	out	0x3f, r0	; 63
			   //SendSlaveCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
    e252:	83 e0       	ldi	r24, 0x03	; 3
    e254:	72 c0       	rjmp	.+228    	; 0xe33a <FSettingPumpPooling+0x43e>
		       break;
		  case '3'://TrySend
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e256:	24 2f       	mov	r18, r20
    e258:	30 e0       	ldi	r19, 0x00	; 0
    e25a:	fe 01       	movw	r30, r28
    e25c:	31 96       	adiw	r30, 0x01	; 1
    e25e:	e2 0f       	add	r30, r18
    e260:	f3 1f       	adc	r31, r19
    e262:	80 81       	ld	r24, Z
    e264:	90 e0       	ldi	r25, 0x00	; 0
    e266:	01 96       	adiw	r24, 0x01	; 1
    e268:	65 e1       	ldi	r22, 0x15	; 21
    e26a:	70 e0       	ldi	r23, 0x00	; 0
    e26c:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    e270:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    e272:	88 23       	and	r24, r24
    e274:	11 f4       	brne	.+4      	; 0xe27a <FSettingPumpPooling+0x37e>
    e276:	81 e0       	ldi	r24, 0x01	; 1
    e278:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
    e27a:	2c 0f       	add	r18, r28
    e27c:	3d 1f       	adc	r19, r29
    e27e:	d9 01       	movw	r26, r18
    e280:	11 96       	adiw	r26, 0x01	; 1
    e282:	2c 91       	ld	r18, X
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e284:	86 e1       	ldi	r24, 0x16	; 22
    e286:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    e28a:	20 93 3c 0f 	sts	0x0F3C, r18
     IsControlPooling=True;
    e28e:	81 e0       	ldi	r24, 0x01	; 1
    e290:	80 93 97 01 	sts	0x0197, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e294:	e1 99       	sbic	0x1c, 1	; 28
    e296:	fe cf       	rjmp	.-4      	; 0xe294 <FSettingPumpPooling+0x398>
    e298:	d0 cf       	rjmp	.-96     	; 0xe23a <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '4'://TimPool
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e29a:	fe 01       	movw	r30, r28
    e29c:	e4 0f       	add	r30, r20
    e29e:	f1 1d       	adc	r31, r1
    e2a0:	81 81       	ldd	r24, Z+1	; 0x01
    e2a2:	90 e0       	ldi	r25, 0x00	; 0
    e2a4:	01 96       	adiw	r24, 0x01	; 1
    e2a6:	65 e1       	ldi	r22, 0x15	; 21
    e2a8:	70 e0       	ldi	r23, 0x00	; 0
    e2aa:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    e2ae:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e2b0:	87 e1       	ldi	r24, 0x17	; 23
    e2b2:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    e2b6:	20 93 3c 0f 	sts	0x0F3C, r18
     IsControlPooling=True;
    e2ba:	81 e0       	ldi	r24, 0x01	; 1
    e2bc:	80 93 97 01 	sts	0x0197, r24
    e2c0:	e1 99       	sbic	0x1c, 1	; 28
    e2c2:	fe cf       	rjmp	.-4      	; 0xe2c0 <FSettingPumpPooling+0x3c4>
    e2c4:	ba cf       	rjmp	.-140    	; 0xe23a <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '5'://DelayNextPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%41); 
    e2c6:	fe 01       	movw	r30, r28
    e2c8:	e4 0f       	add	r30, r20
    e2ca:	f1 1d       	adc	r31, r1
    e2cc:	81 81       	ldd	r24, Z+1	; 0x01
    e2ce:	90 e0       	ldi	r25, 0x00	; 0
    e2d0:	01 96       	adiw	r24, 0x01	; 1
    e2d2:	69 e2       	ldi	r22, 0x29	; 41
    e2d4:	70 e0       	ldi	r23, 0x00	; 0
    e2d6:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    e2da:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e2dc:	88 e1       	ldi	r24, 0x18	; 24
    e2de:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    e2e2:	20 93 3c 0f 	sts	0x0F3C, r18
     IsControlPooling=True;
    e2e6:	81 e0       	ldi	r24, 0x01	; 1
    e2e8:	80 93 97 01 	sts	0x0197, r24
    e2ec:	e1 99       	sbic	0x1c, 1	; 28
    e2ee:	fe cf       	rjmp	.-4      	; 0xe2ec <FSettingPumpPooling+0x3f0>
    e2f0:	a4 cf       	rjmp	.-184    	; 0xe23a <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
               stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '6'://ActivePump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%(1+eeprom_read_byte(&DefPoolingPumpMax))); 			       
    e2f2:	fe 01       	movw	r30, r28
    e2f4:	e4 0f       	add	r30, r20
    e2f6:	f1 1d       	adc	r31, r1
    e2f8:	21 81       	ldd	r18, Z+1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e2fa:	e1 99       	sbic	0x1c, 1	; 28
    e2fc:	fe cf       	rjmp	.-4      	; 0xe2fa <FSettingPumpPooling+0x3fe>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e2fe:	84 e4       	ldi	r24, 0x44	; 68
    e300:	91 e0       	ldi	r25, 0x01	; 1
    e302:	9f bb       	out	0x1f, r25	; 31
    e304:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e306:	e0 9a       	sbi	0x1c, 0	; 28
    e308:	6d b3       	in	r22, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e30a:	e1 99       	sbic	0x1c, 1	; 28
    e30c:	fe cf       	rjmp	.-4      	; 0xe30a <FSettingPumpPooling+0x40e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e30e:	84 2f       	mov	r24, r20
    e310:	90 e0       	ldi	r25, 0x00	; 0
    e312:	8c 5b       	subi	r24, 0xBC	; 188
    e314:	9e 4f       	sbci	r25, 0xFE	; 254
    e316:	9f bb       	out	0x1f, r25	; 31
    e318:	8e bb       	out	0x1e, r24	; 30
    e31a:	82 2f       	mov	r24, r18
    e31c:	90 e0       	ldi	r25, 0x00	; 0
    e31e:	70 e0       	ldi	r23, 0x00	; 0
    e320:	6f 5f       	subi	r22, 0xFF	; 255
    e322:	7f 4f       	sbci	r23, 0xFF	; 255
    e324:	01 96       	adiw	r24, 0x01	; 1
    e326:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
#endif
    EEDR = __value;
    e32a:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    e32c:	0f b6       	in	r0, 0x3f	; 63
    e32e:	f8 94       	cli
    e330:	e2 9a       	sbi	0x1c, 2	; 28
    e332:	e1 9a       	sbi	0x1c, 1	; 28
    e334:	0f be       	out	0x3f, r0	; 63
    e336:	0e c0       	rjmp	.+28     	; 0xe354 <FSettingPumpPooling+0x458>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   stPumpPooling=ppInitMenu;
		       break;
		  case '*'://Exit
		       stPumpPooling=ppExitSettingPooling;		            
    e338:	84 e0       	ldi	r24, 0x04	; 4
    e33a:	80 93 df 02 	sts	0x02DF, r24
    e33e:	11 c0       	rjmp	.+34     	; 0xe362 <FSettingPumpPooling+0x466>
		       break;
		  }  
	      break;
     case ppWaitPoolingRespond:	    
	      if ((IsStandaloneAcknoledge==True)||(TimSend>5))stPumpPooling=ppInitMenu;
    e340:	80 91 95 01 	lds	r24, 0x0195
    e344:	81 30       	cpi	r24, 0x01	; 1
    e346:	31 f0       	breq	.+12     	; 0xe354 <FSettingPumpPooling+0x458>
    e348:	80 91 a8 01 	lds	r24, 0x01A8
    e34c:	90 91 a9 01 	lds	r25, 0x01A9
    e350:	06 97       	sbiw	r24, 0x06	; 6
    e352:	38 f0       	brcs	.+14     	; 0xe362 <FSettingPumpPooling+0x466>
    e354:	10 92 df 02 	sts	0x02DF, r1
    e358:	04 c0       	rjmp	.+8      	; 0xe362 <FSettingPumpPooling+0x466>
	      break;
     case ppExitSettingPooling:
          stPumpPooling=ppInitMenu;
    e35a:	10 92 df 02 	sts	0x02DF, r1
    e35e:	81 e0       	ldi	r24, 0x01	; 1
    e360:	01 c0       	rjmp	.+2      	; 0xe364 <FSettingPumpPooling+0x468>
    e362:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
    }
return Result;
}
    e364:	6a 96       	adiw	r28, 0x1a	; 26
    e366:	0f b6       	in	r0, 0x3f	; 63
    e368:	f8 94       	cli
    e36a:	de bf       	out	0x3e, r29	; 62
    e36c:	0f be       	out	0x3f, r0	; 63
    e36e:	cd bf       	out	0x3d, r28	; 61
    e370:	cf 91       	pop	r28
    e372:	df 91       	pop	r29
    e374:	1f 91       	pop	r17
    e376:	0f 91       	pop	r16
    e378:	08 95       	ret

0000e37a <DisplayTicker>:
	 lcd_print(2, 1, lcdteks);
}

void DisplayTicker(){
static char stDisplayTicker=tiRight;
	switch(stDisplayTicker){
    e37a:	80 91 71 03 	lds	r24, 0x0371
    e37e:	81 30       	cpi	r24, 0x01	; 1
    e380:	81 f0       	breq	.+32     	; 0xe3a2 <DisplayTicker+0x28>
    e382:	81 30       	cpi	r24, 0x01	; 1
    e384:	28 f0       	brcs	.+10     	; 0xe390 <DisplayTicker+0x16>
    e386:	82 30       	cpi	r24, 0x02	; 2
    e388:	91 f0       	breq	.+36     	; 0xe3ae <DisplayTicker+0x34>
    e38a:	83 30       	cpi	r24, 0x03	; 3
    e38c:	09 f5       	brne	.+66     	; 0xe3d0 <DisplayTicker+0x56>
    e38e:	1a c0       	rjmp	.+52     	; 0xe3c4 <DisplayTicker+0x4a>
	case tiRight:
	     lcd_put(4, 1, '>');
    e390:	84 e0       	ldi	r24, 0x04	; 4
    e392:	61 e0       	ldi	r22, 0x01	; 1
    e394:	4e e3       	ldi	r20, 0x3E	; 62
    e396:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
		 TimTicker=0;
    e39a:	10 92 a5 01 	sts	0x01A5, r1
         stDisplayTicker=tiDelayRight;
    e39e:	81 e0       	ldi	r24, 0x01	; 1
    e3a0:	0e c0       	rjmp	.+28     	; 0xe3be <DisplayTicker+0x44>
	break;
	case tiDelayRight:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiLeft;	     
    e3a2:	80 91 a5 01 	lds	r24, 0x01A5
    e3a6:	8b 30       	cpi	r24, 0x0B	; 11
    e3a8:	98 f0       	brcs	.+38     	; 0xe3d0 <DisplayTicker+0x56>
    e3aa:	82 e0       	ldi	r24, 0x02	; 2
    e3ac:	08 c0       	rjmp	.+16     	; 0xe3be <DisplayTicker+0x44>
	     break;
	case tiLeft:
	     lcd_put(4, 1, '<');
    e3ae:	84 e0       	ldi	r24, 0x04	; 4
    e3b0:	61 e0       	ldi	r22, 0x01	; 1
    e3b2:	4c e3       	ldi	r20, 0x3C	; 60
    e3b4:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
         TimTicker=0;
    e3b8:	10 92 a5 01 	sts	0x01A5, r1
         stDisplayTicker=tiDelayLeft;
    e3bc:	83 e0       	ldi	r24, 0x03	; 3
    e3be:	80 93 71 03 	sts	0x0371, r24
    e3c2:	08 95       	ret
	break;
	case tiDelayLeft:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
    e3c4:	80 91 a5 01 	lds	r24, 0x01A5
    e3c8:	8b 30       	cpi	r24, 0x0B	; 11
    e3ca:	10 f0       	brcs	.+4      	; 0xe3d0 <DisplayTicker+0x56>
    e3cc:	10 92 71 03 	sts	0x0371, r1
    e3d0:	08 95       	ret

0000e3d2 <DisplayIdle>:
	          lcd_put(x,y,'X');     
			  }

}

void DisplayIdle(){
    e3d2:	6f 92       	push	r6
    e3d4:	7f 92       	push	r7
    e3d6:	8f 92       	push	r8
    e3d8:	9f 92       	push	r9
    e3da:	af 92       	push	r10
    e3dc:	bf 92       	push	r11
    e3de:	cf 92       	push	r12
    e3e0:	df 92       	push	r13
    e3e2:	ff 92       	push	r15
    e3e4:	0f 93       	push	r16
    e3e6:	1f 93       	push	r17
    e3e8:	df 93       	push	r29
    e3ea:	cf 93       	push	r28
    e3ec:	cd b7       	in	r28, 0x3d	; 61
    e3ee:	de b7       	in	r29, 0x3e	; 62
    e3f0:	67 97       	sbiw	r28, 0x17	; 23
    e3f2:	0f b6       	in	r0, 0x3f	; 63
    e3f4:	f8 94       	cli
    e3f6:	de bf       	out	0x3e, r29	; 62
    e3f8:	0f be       	out	0x3f, r0	; 63
    e3fa:	cd bf       	out	0x3d, r28	; 61
static unsigned int iLoopDisplayIdle=0;
static char stDispIdle=diScan;
     char i,iDisp;
     char lcdteks[20],sFIP[3];

     iLoopDisplayIdle++;
    e3fc:	80 91 6e 03 	lds	r24, 0x036E
    e400:	90 91 6f 03 	lds	r25, 0x036F
    e404:	01 96       	adiw	r24, 0x01	; 1
    e406:	90 93 6f 03 	sts	0x036F, r25
    e40a:	80 93 6e 03 	sts	0x036E, r24
     //Setting DateTime ON

	if ((iLoopDisplayIdle%50)==0){
    e40e:	62 e3       	ldi	r22, 0x32	; 50
    e410:	70 e0       	ldi	r23, 0x00	; 0
    e412:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
    e416:	89 2b       	or	r24, r25
    e418:	29 f5       	brne	.+74     	; 0xe464 <DisplayIdle+0x92>
	   if (IFType==IT_STANDALONE)DisplayPumpStatus();
    e41a:	80 91 10 01 	lds	r24, 0x0110
    e41e:	82 30       	cpi	r24, 0x02	; 2
    e420:	11 f4       	brne	.+4      	; 0xe426 <DisplayIdle+0x54>
    e422:	0e 94 46 45 	call	0x8a8c	; 0x8a8c <DisplayPumpStatus>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e426:	e1 99       	sbic	0x1c, 1	; 28
    e428:	fe cf       	rjmp	.-4      	; 0xe426 <DisplayIdle+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e42a:	87 e3       	ldi	r24, 0x37	; 55
    e42c:	90 e0       	ldi	r25, 0x00	; 0
    e42e:	9f bb       	out	0x1f, r25	; 31
    e430:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e432:	e0 9a       	sbi	0x1c, 0	; 28
    e434:	8d b3       	in	r24, 0x1d	; 29
	   if(eeprom_read_byte(&DefShowDateTime)) DisplayDateTime();
    e436:	88 23       	and	r24, r24
    e438:	19 f0       	breq	.+6      	; 0xe440 <DisplayIdle+0x6e>
    e43a:	0e 94 f7 62 	call	0xc5ee	; 0xc5ee <DisplayDateTime>
    e43e:	02 c0       	rjmp	.+4      	; 0xe444 <DisplayIdle+0x72>
       else DisplayTicker();
    e440:	0e 94 bd 71 	call	0xe37a	; 0xe37a <DisplayTicker>
	   //Display Standalone Sequnece
	   
	   if((IFType==IT_STANDALONE)&&(IsNewPoolingSequence==True)){
    e444:	80 91 10 01 	lds	r24, 0x0110
    e448:	82 30       	cpi	r24, 0x02	; 2
    e44a:	61 f4       	brne	.+24     	; 0xe464 <DisplayIdle+0x92>
    e44c:	80 91 94 01 	lds	r24, 0x0194
    e450:	81 30       	cpi	r24, 0x01	; 1
    e452:	41 f4       	brne	.+16     	; 0xe464 <DisplayIdle+0x92>
	       IsNewPoolingSequence=False;
    e454:	10 92 94 01 	sts	0x0194, r1
		   DisplayStandaloneSequence(4,18,iSequencePooling);
    e458:	84 e0       	ldi	r24, 0x04	; 4
    e45a:	62 e1       	ldi	r22, 0x12	; 18
    e45c:	40 91 93 01 	lds	r20, 0x0193
    e460:	0e 94 48 6f 	call	0xde90	; 0xde90 <DisplayStandaloneSequence>

	 }
     //DisplayPumpStatus Standalone Mode

	 //Display Printing FIP
	 switch (stDispIdle){
    e464:	f0 90 6d 03 	lds	r15, 0x036D
    e468:	ff 20       	and	r15, r15
    e46a:	29 f0       	breq	.+10     	; 0xe476 <DisplayIdle+0xa4>
    e46c:	81 e0       	ldi	r24, 0x01	; 1
    e46e:	f8 16       	cp	r15, r24
    e470:	09 f0       	breq	.+2      	; 0xe474 <DisplayIdle+0xa2>
    e472:	58 c0       	rjmp	.+176    	; 0xe524 <DisplayIdle+0x152>
    e474:	2f c0       	rjmp	.+94     	; 0xe4d4 <DisplayIdle+0x102>
	 case diScan:
	      if (IsBusyIdlePrinting==True){
    e476:	f0 90 c8 01 	lds	r15, 0x01C8
    e47a:	91 e0       	ldi	r25, 0x01	; 1
    e47c:	f9 16       	cp	r15, r25
    e47e:	09 f0       	breq	.+2      	; 0xe482 <DisplayIdle+0xb0>
    e480:	51 c0       	rjmp	.+162    	; 0xe524 <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("Printing FIP%s "),strFIP_ID);
    e482:	00 d0       	rcall	.+0      	; 0xe484 <DisplayIdle+0xb2>
    e484:	00 d0       	rcall	.+0      	; 0xe486 <DisplayIdle+0xb4>
    e486:	00 d0       	rcall	.+0      	; 0xe488 <DisplayIdle+0xb6>
    e488:	ed b7       	in	r30, 0x3d	; 61
    e48a:	fe b7       	in	r31, 0x3e	; 62
    e48c:	31 96       	adiw	r30, 0x01	; 1
    e48e:	8e 01       	movw	r16, r28
    e490:	0c 5f       	subi	r16, 0xFC	; 252
    e492:	1f 4f       	sbci	r17, 0xFF	; 255
    e494:	ad b7       	in	r26, 0x3d	; 61
    e496:	be b7       	in	r27, 0x3e	; 62
    e498:	12 96       	adiw	r26, 0x02	; 2
    e49a:	1c 93       	st	X, r17
    e49c:	0e 93       	st	-X, r16
    e49e:	11 97       	sbiw	r26, 0x01	; 1
    e4a0:	8b ef       	ldi	r24, 0xFB	; 251
    e4a2:	9b e1       	ldi	r25, 0x1B	; 27
    e4a4:	93 83       	std	Z+3, r25	; 0x03
    e4a6:	82 83       	std	Z+2, r24	; 0x02
    e4a8:	86 e8       	ldi	r24, 0x86	; 134
    e4aa:	99 e0       	ldi	r25, 0x09	; 9
    e4ac:	95 83       	std	Z+5, r25	; 0x05
    e4ae:	84 83       	std	Z+4, r24	; 0x04
    e4b0:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    e4b4:	ed b7       	in	r30, 0x3d	; 61
    e4b6:	fe b7       	in	r31, 0x3e	; 62
    e4b8:	36 96       	adiw	r30, 0x06	; 6
    e4ba:	0f b6       	in	r0, 0x3f	; 63
    e4bc:	f8 94       	cli
    e4be:	fe bf       	out	0x3e, r31	; 62
    e4c0:	0f be       	out	0x3f, r0	; 63
    e4c2:	ed bf       	out	0x3d, r30	; 61
    e4c4:	83 e0       	ldi	r24, 0x03	; 3
    e4c6:	61 e0       	ldi	r22, 0x01	; 1
    e4c8:	a8 01       	movw	r20, r16
    e4ca:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			   stDispIdle=diWaitNoBusy;
    e4ce:	f0 92 6d 03 	sts	0x036D, r15
    e4d2:	28 c0       	rjmp	.+80     	; 0xe524 <DisplayIdle+0x152>
		  }         
	      break;
     case diWaitNoBusy:
	      if (IsBusyIdlePrinting==False){
    e4d4:	80 91 c8 01 	lds	r24, 0x01C8
    e4d8:	88 23       	and	r24, r24
    e4da:	21 f5       	brne	.+72     	; 0xe524 <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("                    "));
    e4dc:	00 d0       	rcall	.+0      	; 0xe4de <DisplayIdle+0x10c>
    e4de:	00 d0       	rcall	.+0      	; 0xe4e0 <DisplayIdle+0x10e>
    e4e0:	8e 01       	movw	r16, r28
    e4e2:	0c 5f       	subi	r16, 0xFC	; 252
    e4e4:	1f 4f       	sbci	r17, 0xFF	; 255
    e4e6:	ad b7       	in	r26, 0x3d	; 61
    e4e8:	be b7       	in	r27, 0x3e	; 62
    e4ea:	12 96       	adiw	r26, 0x02	; 2
    e4ec:	1c 93       	st	X, r17
    e4ee:	0e 93       	st	-X, r16
    e4f0:	11 97       	sbiw	r26, 0x01	; 1
    e4f2:	86 ee       	ldi	r24, 0xE6	; 230
    e4f4:	9b e1       	ldi	r25, 0x1B	; 27
    e4f6:	14 96       	adiw	r26, 0x04	; 4
    e4f8:	9c 93       	st	X, r25
    e4fa:	8e 93       	st	-X, r24
    e4fc:	13 97       	sbiw	r26, 0x03	; 3
    e4fe:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    e502:	0f 90       	pop	r0
    e504:	0f 90       	pop	r0
    e506:	0f 90       	pop	r0
    e508:	0f 90       	pop	r0
    e50a:	83 e0       	ldi	r24, 0x03	; 3
    e50c:	61 e0       	ldi	r22, 0x01	; 1
    e50e:	a8 01       	movw	r20, r16
    e510:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			   stDispIdle=diScan;
    e514:	10 92 6d 03 	sts	0x036D, r1
			   if (nLocalAccount>0)IsViewFillingFIP=True;
    e518:	80 91 a4 01 	lds	r24, 0x01A4
    e51c:	88 23       	and	r24, r24
    e51e:	11 f0       	breq	.+4      	; 0xe524 <DisplayIdle+0x152>
    e520:	f0 92 ad 01 	sts	0x01AD, r15
		  }
	      break;     
	 }
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
    e524:	80 91 ad 01 	lds	r24, 0x01AD
    e528:	81 30       	cpi	r24, 0x01	; 1
    e52a:	09 f0       	breq	.+2      	; 0xe52e <DisplayIdle+0x15c>
    e52c:	69 c0       	rjmp	.+210    	; 0xe600 <DisplayIdle+0x22e>
	     IsViewFillingFIP=False;
    e52e:	10 92 ad 01 	sts	0x01AD, r1
		 if (nLocalAccount>0){
    e532:	80 91 a4 01 	lds	r24, 0x01A4
    e536:	88 23       	and	r24, r24
    e538:	09 f4       	brne	.+2      	; 0xe53c <DisplayIdle+0x16a>
    e53a:	5c c0       	rjmp	.+184    	; 0xe5f4 <DisplayIdle+0x222>
		     lcd_printf(3,1,PSTR("@FIP:"));
    e53c:	83 e0       	ldi	r24, 0x03	; 3
    e53e:	61 e0       	ldi	r22, 0x01	; 1
    e540:	40 ee       	ldi	r20, 0xE0	; 224
    e542:	5b e1       	ldi	r21, 0x1B	; 27
    e544:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
    e548:	ff 24       	eor	r15, r15
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    e54a:	5e 01       	movw	r10, r28
    e54c:	08 94       	sec
    e54e:	a1 1c       	adc	r10, r1
    e550:	b1 1c       	adc	r11, r1
    e552:	3b ed       	ldi	r19, 0xDB	; 219
    e554:	63 2e       	mov	r6, r19
    e556:	3b e1       	ldi	r19, 0x1B	; 27
    e558:	73 2e       	mov	r7, r19
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    e55a:	24 e0       	ldi	r18, 0x04	; 4
    e55c:	c2 2e       	mov	r12, r18
    e55e:	d1 2c       	mov	r13, r1
    e560:	cc 0e       	add	r12, r28
    e562:	dd 1e       	adc	r13, r29
    e564:	97 ed       	ldi	r25, 0xD7	; 215
    e566:	89 2e       	mov	r8, r25
    e568:	9b e1       	ldi	r25, 0x1B	; 27
    e56a:	99 2e       	mov	r9, r25
    e56c:	3d c0       	rjmp	.+122    	; 0xe5e8 <DisplayIdle+0x216>
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    e56e:	0f 2d       	mov	r16, r15
    e570:	10 e0       	ldi	r17, 0x00	; 0
    e572:	00 d0       	rcall	.+0      	; 0xe574 <DisplayIdle+0x1a2>
    e574:	00 d0       	rcall	.+0      	; 0xe576 <DisplayIdle+0x1a4>
    e576:	00 d0       	rcall	.+0      	; 0xe578 <DisplayIdle+0x1a6>
    e578:	ad b7       	in	r26, 0x3d	; 61
    e57a:	be b7       	in	r27, 0x3e	; 62
    e57c:	11 96       	adiw	r26, 0x01	; 1
    e57e:	ed b7       	in	r30, 0x3d	; 61
    e580:	fe b7       	in	r31, 0x3e	; 62
    e582:	b2 82       	std	Z+2, r11	; 0x02
    e584:	a1 82       	std	Z+1, r10	; 0x01
    e586:	13 96       	adiw	r26, 0x03	; 3
    e588:	7c 92       	st	X, r7
    e58a:	6e 92       	st	-X, r6
    e58c:	12 97       	sbiw	r26, 0x02	; 2
    e58e:	f8 01       	movw	r30, r16
    e590:	ea 5c       	subi	r30, 0xCA	; 202
    e592:	fa 4f       	sbci	r31, 0xFA	; 250
    e594:	80 81       	ld	r24, Z
    e596:	14 96       	adiw	r26, 0x04	; 4
    e598:	8c 93       	st	X, r24
    e59a:	14 97       	sbiw	r26, 0x04	; 4
    e59c:	15 96       	adiw	r26, 0x05	; 5
    e59e:	1c 92       	st	X, r1
    e5a0:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    e5a4:	ed b7       	in	r30, 0x3d	; 61
    e5a6:	fe b7       	in	r31, 0x3e	; 62
    e5a8:	31 96       	adiw	r30, 0x01	; 1
    e5aa:	ad b7       	in	r26, 0x3d	; 61
    e5ac:	be b7       	in	r27, 0x3e	; 62
    e5ae:	12 96       	adiw	r26, 0x02	; 2
    e5b0:	dc 92       	st	X, r13
    e5b2:	ce 92       	st	-X, r12
    e5b4:	11 97       	sbiw	r26, 0x01	; 1
    e5b6:	93 82       	std	Z+3, r9	; 0x03
    e5b8:	82 82       	std	Z+2, r8	; 0x02
    e5ba:	b5 82       	std	Z+5, r11	; 0x05
    e5bc:	a4 82       	std	Z+4, r10	; 0x04
    e5be:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			      lcd_print(3,6+(iDisp*3),lcdteks);
    e5c2:	ed b7       	in	r30, 0x3d	; 61
    e5c4:	fe b7       	in	r31, 0x3e	; 62
    e5c6:	36 96       	adiw	r30, 0x06	; 6
    e5c8:	0f b6       	in	r0, 0x3f	; 63
    e5ca:	f8 94       	cli
    e5cc:	fe bf       	out	0x3e, r31	; 62
    e5ce:	0f be       	out	0x3f, r0	; 63
    e5d0:	ed bf       	out	0x3d, r30	; 61
    e5d2:	b8 01       	movw	r22, r16
    e5d4:	66 0f       	add	r22, r22
    e5d6:	77 1f       	adc	r23, r23
    e5d8:	60 0f       	add	r22, r16
    e5da:	71 1f       	adc	r23, r17
    e5dc:	6a 5f       	subi	r22, 0xFA	; 250
    e5de:	83 e0       	ldi	r24, 0x03	; 3
    e5e0:	a6 01       	movw	r20, r12
    e5e2:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
    e5e6:	f3 94       	inc	r15
    e5e8:	80 91 a4 01 	lds	r24, 0x01A4
    e5ec:	f8 16       	cp	r15, r24
    e5ee:	08 f4       	brcc	.+2      	; 0xe5f2 <DisplayIdle+0x220>
    e5f0:	be cf       	rjmp	.-132    	; 0xe56e <DisplayIdle+0x19c>
    e5f2:	06 c0       	rjmp	.+12     	; 0xe600 <DisplayIdle+0x22e>
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
			      lcd_print(3,6+(iDisp*3),lcdteks);
		     }
		 }else{
		 lcd_printf(3,1,PSTR("                    "));
    e5f4:	83 e0       	ldi	r24, 0x03	; 3
    e5f6:	61 e0       	ldi	r22, 0x01	; 1
    e5f8:	42 ec       	ldi	r20, 0xC2	; 194
    e5fa:	5b e1       	ldi	r21, 0x1B	; 27
    e5fc:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		 }    
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
    e600:	80 91 c0 01 	lds	r24, 0x01C0
    e604:	81 30       	cpi	r24, 0x01	; 1
    e606:	c1 f4       	brne	.+48     	; 0xe638 <DisplayIdle+0x266>
	     IsCompleteFilling=False;
    e608:	10 92 c0 01 	sts	0x01C0, r1
	     if (nLocalAccount>0){
    e60c:	90 91 a4 01 	lds	r25, 0x01A4
    e610:	99 23       	and	r25, r25
    e612:	91 f0       	breq	.+36     	; 0xe638 <DisplayIdle+0x266>
    e614:	e6 e3       	ldi	r30, 0x36	; 54
    e616:	f5 e0       	ldi	r31, 0x05	; 5
			 for(i=0;i<nLocalAccount;i++){//Shift data
    e618:	29 2f       	mov	r18, r25
    e61a:	30 e0       	ldi	r19, 0x00	; 0
    e61c:	2e 0f       	add	r18, r30
    e61e:	3f 1f       	adc	r19, r31
    e620:	02 c0       	rjmp	.+4      	; 0xe626 <DisplayIdle+0x254>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
    e622:	81 81       	ldd	r24, Z+1	; 0x01
    e624:	81 93       	st	Z+, r24
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
	     IsCompleteFilling=False;
	     if (nLocalAccount>0){
			 for(i=0;i<nLocalAccount;i++){//Shift data
    e626:	e2 17       	cp	r30, r18
    e628:	f3 07       	cpc	r31, r19
    e62a:	d9 f7       	brne	.-10     	; 0xe622 <DisplayIdle+0x250>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
			 }
			 nLocalAccount--;
    e62c:	91 50       	subi	r25, 0x01	; 1
    e62e:	90 93 a4 01 	sts	0x01A4, r25
             IsViewFillingFIP=True; 
    e632:	81 e0       	ldi	r24, 0x01	; 1
    e634:	80 93 ad 01 	sts	0x01AD, r24
		 }
	 }
}
    e638:	67 96       	adiw	r28, 0x17	; 23
    e63a:	0f b6       	in	r0, 0x3f	; 63
    e63c:	f8 94       	cli
    e63e:	de bf       	out	0x3e, r29	; 62
    e640:	0f be       	out	0x3f, r0	; 63
    e642:	cd bf       	out	0x3d, r28	; 61
    e644:	cf 91       	pop	r28
    e646:	df 91       	pop	r29
    e648:	1f 91       	pop	r17
    e64a:	0f 91       	pop	r16
    e64c:	ff 90       	pop	r15
    e64e:	df 90       	pop	r13
    e650:	cf 90       	pop	r12
    e652:	bf 90       	pop	r11
    e654:	af 90       	pop	r10
    e656:	9f 90       	pop	r9
    e658:	8f 90       	pop	r8
    e65a:	7f 90       	pop	r7
    e65c:	6f 90       	pop	r6
    e65e:	08 95       	ret

0000e660 <systemMaster>:
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
}

void systemMaster(){
  	_spi_init(1, 0);         //Master
    e660:	81 e0       	ldi	r24, 0x01	; 1
    e662:	60 e0       	ldi	r22, 0x00	; 0
    e664:	0e 94 d2 b0 	call	0x161a4	; 0x161a4 <_spi_init>
    _spi_enable(_SPI_SLAVE); //Enable SS 
    e668:	81 e0       	ldi	r24, 0x01	; 1
    e66a:	0e 94 e5 b0 	call	0x161ca	; 0x161ca <_spi_enable>
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
    e66e:	bb 98       	cbi	0x17, 3	; 23
    e670:	c3 9a       	sbi	0x18, 3	; 24
	sbi(DDRB,2);             //MOSI Output
    e672:	ba 9a       	sbi	0x17, 2	; 23
}
    e674:	08 95       	ret

0000e676 <systemSlave>:




void systemSlave(){
    _spi_enable(_SPI_NONE);	
    e676:	80 e0       	ldi	r24, 0x00	; 0
    e678:	0e 94 e5 b0 	call	0x161ca	; 0x161ca <_spi_enable>
  	_spi_init(0, 1);         //Slave
    e67c:	80 e0       	ldi	r24, 0x00	; 0
    e67e:	61 e0       	ldi	r22, 0x01	; 1
    e680:	0e 94 d2 b0 	call	0x161a4	; 0x161a4 <_spi_init>
	sbi(DDRB,3);             //MISO Output
    e684:	bb 9a       	sbi	0x17, 3	; 23
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    e686:	bb 9a       	sbi	0x17, 3	; 23
    e688:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    e68a:	ba 98       	cbi	0x17, 2	; 23
    e68c:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    e68e:	b9 98       	cbi	0x17, 1	; 23
    e690:	c1 9a       	sbi	0x18, 1	; 24
}
    e692:	08 95       	ret

0000e694 <EDCSendByte>:
    _spi_enable(_SPI_SLAVE); //Enable SS 
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
	sbi(DDRB,2);             //MOSI Output
}

void EDCSendByte(char EDCData){
    e694:	1f 93       	push	r17
    e696:	18 2f       	mov	r17, r24
     systemMaster();	 
    e698:	0e 94 30 73 	call	0xe660	; 0xe660 <systemMaster>
     _spi(EDCData);
    e69c:	81 2f       	mov	r24, r17
    e69e:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <_spi>
     systemSlave();
    e6a2:	0e 94 3b 73 	call	0xe676	; 0xe676 <systemSlave>
}
    e6a6:	1f 91       	pop	r17
    e6a8:	08 95       	ret

0000e6aa <SendEDCMessage>:
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}

void SendEDCMessage(){
    e6aa:	cf 92       	push	r12
    e6ac:	df 92       	push	r13
    e6ae:	ef 92       	push	r14
    e6b0:	ff 92       	push	r15
    e6b2:	0f 93       	push	r16
    e6b4:	1f 93       	push	r17
    e6b6:	df 93       	push	r29
    e6b8:	cf 93       	push	r28
    e6ba:	cd b7       	in	r28, 0x3d	; 61
    e6bc:	de b7       	in	r29, 0x3e	; 62
    e6be:	ec 97       	sbiw	r28, 0x3c	; 60
    e6c0:	0f b6       	in	r0, 0x3f	; 63
    e6c2:	f8 94       	cli
    e6c4:	de bf       	out	0x3e, r29	; 62
    e6c6:	0f be       	out	0x3f, r0	; 63
    e6c8:	cd bf       	out	0x3d, r28	; 61

     //GenerateData
	 //sprintf_P(strAmount,PSTR("%d"),100);//Testing Only
	 //AddZeroLead(strAmount,8);
	 //_uart_printf(0,0,PSTR("StrStatus:"));_uart_print(0,1,strStatus);
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     
    e6ca:	8d b7       	in	r24, 0x3d	; 61
    e6cc:	9e b7       	in	r25, 0x3e	; 62
    e6ce:	42 97       	sbiw	r24, 0x12	; 18
    e6d0:	0f b6       	in	r0, 0x3f	; 63
    e6d2:	f8 94       	cli
    e6d4:	9e bf       	out	0x3e, r25	; 62
    e6d6:	0f be       	out	0x3f, r0	; 63
    e6d8:	8d bf       	out	0x3d, r24	; 61
    e6da:	ed b7       	in	r30, 0x3d	; 61
    e6dc:	fe b7       	in	r31, 0x3e	; 62
    e6de:	31 96       	adiw	r30, 0x01	; 1
    e6e0:	8e 01       	movw	r16, r28
    e6e2:	0f 5f       	subi	r16, 0xFF	; 255
    e6e4:	1f 4f       	sbci	r17, 0xFF	; 255
    e6e6:	ad b7       	in	r26, 0x3d	; 61
    e6e8:	be b7       	in	r27, 0x3e	; 62
    e6ea:	12 96       	adiw	r26, 0x02	; 2
    e6ec:	1c 93       	st	X, r17
    e6ee:	0e 93       	st	-X, r16
    e6f0:	11 97       	sbiw	r26, 0x01	; 1
    e6f2:	8f ea       	ldi	r24, 0xAF	; 175
    e6f4:	9b e1       	ldi	r25, 0x1B	; 27
    e6f6:	93 83       	std	Z+3, r25	; 0x03
    e6f8:	82 83       	std	Z+2, r24	; 0x02
    e6fa:	89 ed       	ldi	r24, 0xD9	; 217
    e6fc:	9f e0       	ldi	r25, 0x0F	; 15
    e6fe:	95 83       	std	Z+5, r25	; 0x05
    e700:	84 83       	std	Z+4, r24	; 0x04
    e702:	86 e8       	ldi	r24, 0x86	; 134
    e704:	99 e0       	ldi	r25, 0x09	; 9
    e706:	97 83       	std	Z+7, r25	; 0x07
    e708:	86 83       	std	Z+6, r24	; 0x06
    e70a:	8b ec       	ldi	r24, 0xCB	; 203
    e70c:	9b e0       	ldi	r25, 0x0B	; 11
    e70e:	91 87       	std	Z+9, r25	; 0x09
    e710:	80 87       	std	Z+8, r24	; 0x08
    e712:	81 e8       	ldi	r24, 0x81	; 129
    e714:	97 e0       	ldi	r25, 0x07	; 7
    e716:	93 87       	std	Z+11, r25	; 0x0b
    e718:	82 87       	std	Z+10, r24	; 0x0a
    e71a:	85 e5       	ldi	r24, 0x55	; 85
    e71c:	95 e0       	ldi	r25, 0x05	; 5
    e71e:	95 87       	std	Z+13, r25	; 0x0d
    e720:	84 87       	std	Z+12, r24	; 0x0c
    e722:	89 e1       	ldi	r24, 0x19	; 25
    e724:	9f e0       	ldi	r25, 0x0F	; 15
    e726:	97 87       	std	Z+15, r25	; 0x0f
    e728:	86 87       	std	Z+14, r24	; 0x0e
    e72a:	8a e6       	ldi	r24, 0x6A	; 106
    e72c:	95 e0       	ldi	r25, 0x05	; 5
    e72e:	91 8b       	std	Z+17, r25	; 0x11
    e730:	80 8b       	std	Z+16, r24	; 0x10
    e732:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>

	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
    e736:	8d b7       	in	r24, 0x3d	; 61
    e738:	9e b7       	in	r25, 0x3e	; 62
    e73a:	42 96       	adiw	r24, 0x12	; 18
    e73c:	0f b6       	in	r0, 0x3f	; 63
    e73e:	f8 94       	cli
    e740:	9e bf       	out	0x3e, r25	; 62
    e742:	0f be       	out	0x3f, r0	; 63
    e744:	8d bf       	out	0x3d, r24	; 61
    e746:	82 e0       	ldi	r24, 0x02	; 2
    e748:	0e 94 4a 73 	call	0xe694	; 0xe694 <EDCSendByte>
    e74c:	52 e0       	ldi	r21, 0x02	; 2
    e74e:	e5 2e       	mov	r14, r21
    e750:	ff 24       	eor	r15, r15
    e752:	44 ec       	ldi	r20, 0xC4	; 196
    e754:	c4 2e       	mov	r12, r20
    e756:	49 e0       	ldi	r20, 0x09	; 9
    e758:	d4 2e       	mov	r13, r20
    e75a:	0a c0       	rjmp	.+20     	; 0xe770 <SendEDCMessage+0xc6>
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
    e75c:	a0 0f       	add	r26, r16
    e75e:	b1 1f       	adc	r27, r17
    e760:	8c 91       	ld	r24, X
     systemSlave();
}

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
    e762:	e8 26       	eor	r14, r24
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
    e764:	0e 94 4a 73 	call	0xe694	; 0xe694 <EDCSendByte>
    e768:	c6 01       	movw	r24, r12
    e76a:	01 97       	sbiw	r24, 0x01	; 1
    e76c:	f1 f7       	brne	.-4      	; 0xe76a <SendEDCMessage+0xc0>
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     

	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
    e76e:	f3 94       	inc	r15
    e770:	f8 01       	movw	r30, r16
    e772:	01 90       	ld	r0, Z+
    e774:	00 20       	and	r0, r0
    e776:	e9 f7       	brne	.-6      	; 0xe772 <SendEDCMessage+0xc8>
    e778:	31 97       	sbiw	r30, 0x01	; 1
    e77a:	e0 1b       	sub	r30, r16
    e77c:	f1 0b       	sbc	r31, r17
    e77e:	af 2d       	mov	r26, r15
    e780:	b0 e0       	ldi	r27, 0x00	; 0
    e782:	ae 17       	cp	r26, r30
    e784:	bf 07       	cpc	r27, r31
    e786:	50 f3       	brcs	.-44     	; 0xe75c <SendEDCMessage+0xb2>
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
		  //_uart(0,1,SerialEDC[i]);
		  _delay_ms(10);//min:8
	 }
     EDCSendByte(0x03);
    e788:	83 e0       	ldi	r24, 0x03	; 3
    e78a:	0e 94 4a 73 	call	0xe694	; 0xe694 <EDCSendByte>
	 xCRC=CalcLRC(xCRC,0x03);	      
	 EDCSendByte(xCRC);
    e78e:	83 e0       	ldi	r24, 0x03	; 3
    e790:	8e 25       	eor	r24, r14
    e792:	0e 94 4a 73 	call	0xe694	; 0xe694 <EDCSendByte>
}
    e796:	ec 96       	adiw	r28, 0x3c	; 60
    e798:	0f b6       	in	r0, 0x3f	; 63
    e79a:	f8 94       	cli
    e79c:	de bf       	out	0x3e, r29	; 62
    e79e:	0f be       	out	0x3f, r0	; 63
    e7a0:	cd bf       	out	0x3d, r28	; 61
    e7a2:	cf 91       	pop	r28
    e7a4:	df 91       	pop	r29
    e7a6:	1f 91       	pop	r17
    e7a8:	0f 91       	pop	r16
    e7aa:	ff 90       	pop	r15
    e7ac:	ef 90       	pop	r14
    e7ae:	df 90       	pop	r13
    e7b0:	cf 90       	pop	r12
    e7b2:	08 95       	ret

0000e7b4 <SendSlaveCommand>:
void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
	 PoolMsg=plMsg;
     IsControlPooling=True;
}
void SendSlaveCommand(char SlaveCommand,char SlaveMessage){     
    e7b4:	0f 93       	push	r16
    e7b6:	1f 93       	push	r17
    e7b8:	18 2f       	mov	r17, r24
    e7ba:	06 2f       	mov	r16, r22
	 systemMaster();
    e7bc:	0e 94 30 73 	call	0xe660	; 0xe660 <systemMaster>
	 _spi(0x05);
    e7c0:	85 e0       	ldi	r24, 0x05	; 5
    e7c2:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <_spi>
	 _spi(SlaveCommand);
    e7c6:	81 2f       	mov	r24, r17
    e7c8:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <_spi>
	 _spi(SlaveMessage);
    e7cc:	80 2f       	mov	r24, r16
    e7ce:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <_spi>
	 _spi(0x06);
    e7d2:	86 e0       	ldi	r24, 0x06	; 6
    e7d4:	0e 94 fc b0 	call	0x161f8	; 0x161f8 <_spi>
	 systemSlave();
    e7d8:	0e 94 3b 73 	call	0xe676	; 0xe676 <systemSlave>
}
    e7dc:	1f 91       	pop	r17
    e7de:	0f 91       	pop	r16
    e7e0:	08 95       	ret

0000e7e2 <FSettingPumpID>:
     if ((*Value)>MinValue){
	     (*Value)--;
	 }else *Value=MaxValue;
}

char FSettingPumpID(){
    e7e2:	9f 92       	push	r9
    e7e4:	af 92       	push	r10
    e7e6:	bf 92       	push	r11
    e7e8:	cf 92       	push	r12
    e7ea:	df 92       	push	r13
    e7ec:	ef 92       	push	r14
    e7ee:	ff 92       	push	r15
    e7f0:	0f 93       	push	r16
    e7f2:	1f 93       	push	r17
    e7f4:	df 93       	push	r29
    e7f6:	cf 93       	push	r28
    e7f8:	cd b7       	in	r28, 0x3d	; 61
    e7fa:	de b7       	in	r29, 0x3e	; 62
    e7fc:	64 97       	sbiw	r28, 0x14	; 20
    e7fe:	0f b6       	in	r0, 0x3f	; 63
    e800:	f8 94       	cli
    e802:	de bf       	out	0x3e, r29	; 62
    e804:	0f be       	out	0x3f, r0	; 63
    e806:	cd bf       	out	0x3d, r28	; 61
	 char iLoop,Result,KeyChar,KeyPressed,i,j,CheckPump;
	 char lcdteks[20];
	 static char Idx,PPumpId[8],MsgPumpId,PumpCount;
     
	 Result=MENU_NONE;
	 switch (stMenuPumpID){
    e808:	80 91 de 02 	lds	r24, 0x02DE
    e80c:	85 30       	cpi	r24, 0x05	; 5
    e80e:	09 f4       	brne	.+2      	; 0xe812 <FSettingPumpID+0x30>
    e810:	88 c1       	rjmp	.+784    	; 0xeb22 <FSettingPumpID+0x340>
    e812:	86 30       	cpi	r24, 0x06	; 6
    e814:	90 f4       	brcc	.+36     	; 0xe83a <FSettingPumpID+0x58>
    e816:	82 30       	cpi	r24, 0x02	; 2
    e818:	09 f4       	brne	.+2      	; 0xe81c <FSettingPumpID+0x3a>
    e81a:	8f c0       	rjmp	.+286    	; 0xe93a <FSettingPumpID+0x158>
    e81c:	83 30       	cpi	r24, 0x03	; 3
    e81e:	30 f4       	brcc	.+12     	; 0xe82c <FSettingPumpID+0x4a>
    e820:	88 23       	and	r24, r24
    e822:	f1 f0       	breq	.+60     	; 0xe860 <FSettingPumpID+0x7e>
    e824:	81 30       	cpi	r24, 0x01	; 1
    e826:	09 f0       	breq	.+2      	; 0xe82a <FSettingPumpID+0x48>
    e828:	73 c2       	rjmp	.+1254   	; 0xed10 <FSettingPumpID+0x52e>
    e82a:	2d c0       	rjmp	.+90     	; 0xe886 <FSettingPumpID+0xa4>
    e82c:	83 30       	cpi	r24, 0x03	; 3
    e82e:	09 f4       	brne	.+2      	; 0xe832 <FSettingPumpID+0x50>
    e830:	51 c1       	rjmp	.+674    	; 0xead4 <FSettingPumpID+0x2f2>
    e832:	84 30       	cpi	r24, 0x04	; 4
    e834:	09 f0       	breq	.+2      	; 0xe838 <FSettingPumpID+0x56>
    e836:	6c c2       	rjmp	.+1240   	; 0xed10 <FSettingPumpID+0x52e>
    e838:	6d c1       	rjmp	.+730    	; 0xeb14 <FSettingPumpID+0x332>
    e83a:	88 30       	cpi	r24, 0x08	; 8
    e83c:	09 f4       	brne	.+2      	; 0xe840 <FSettingPumpID+0x5e>
    e83e:	fc c1       	rjmp	.+1016   	; 0xec38 <FSettingPumpID+0x456>
    e840:	89 30       	cpi	r24, 0x09	; 9
    e842:	38 f4       	brcc	.+14     	; 0xe852 <FSettingPumpID+0x70>
    e844:	86 30       	cpi	r24, 0x06	; 6
    e846:	09 f4       	brne	.+2      	; 0xe84a <FSettingPumpID+0x68>
    e848:	9b c1       	rjmp	.+822    	; 0xeb80 <FSettingPumpID+0x39e>
    e84a:	87 30       	cpi	r24, 0x07	; 7
    e84c:	09 f0       	breq	.+2      	; 0xe850 <FSettingPumpID+0x6e>
    e84e:	60 c2       	rjmp	.+1216   	; 0xed10 <FSettingPumpID+0x52e>
    e850:	45 c2       	rjmp	.+1162   	; 0xecdc <FSettingPumpID+0x4fa>
    e852:	89 30       	cpi	r24, 0x09	; 9
    e854:	09 f4       	brne	.+2      	; 0xe858 <FSettingPumpID+0x76>
    e856:	4a c2       	rjmp	.+1172   	; 0xecec <FSettingPumpID+0x50a>
    e858:	8a 30       	cpi	r24, 0x0A	; 10
    e85a:	09 f0       	breq	.+2      	; 0xe85e <FSettingPumpID+0x7c>
    e85c:	59 c2       	rjmp	.+1202   	; 0xed10 <FSettingPumpID+0x52e>
    e85e:	4c c2       	rjmp	.+1176   	; 0xecf8 <FSettingPumpID+0x516>
	 case mpInitPumpId:	      
	      //Disable PumpPooling
		  if (IFType==IT_STANDALONE)SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    e860:	80 91 10 01 	lds	r24, 0x0110
    e864:	82 30       	cpi	r24, 0x02	; 2
    e866:	21 f4       	brne	.+8      	; 0xe870 <FSettingPumpID+0x8e>
    e868:	8f e1       	ldi	r24, 0x1F	; 31
    e86a:	60 e0       	ldi	r22, 0x00	; 0
    e86c:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    e870:	84 ed       	ldi	r24, 0xD4	; 212
    e872:	92 e0       	ldi	r25, 0x02	; 2
    e874:	65 e4       	ldi	r22, 0x45	; 69
    e876:	70 e0       	ldi	r23, 0x00	; 0
    e878:	48 e0       	ldi	r20, 0x08	; 8
    e87a:	50 e0       	ldi	r21, 0x00	; 0
    e87c:	28 ef       	ldi	r18, 0xF8	; 248
    e87e:	32 e1       	ldi	r19, 0x12	; 18
    e880:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
    e884:	4c c1       	rjmp	.+664    	; 0xeb1e <FSettingPumpID+0x33c>
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
    e886:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
    e88a:	b4 ed       	ldi	r27, 0xD4	; 212
    e88c:	eb 2e       	mov	r14, r27
    e88e:	b2 e0       	ldi	r27, 0x02	; 2
    e890:	fb 2e       	mov	r15, r27
    e892:	01 e0       	ldi	r16, 0x01	; 1
    e894:	10 e0       	ldi	r17, 0x00	; 0
		  for (iLoop=0;iLoop<4;iLoop++){
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    e896:	6e 01       	movw	r12, r28
    e898:	08 94       	sec
    e89a:	c1 1c       	adc	r12, r1
    e89c:	d1 1c       	adc	r13, r1
    e89e:	af e9       	ldi	r26, 0x9F	; 159
    e8a0:	aa 2e       	mov	r10, r26
    e8a2:	ac e0       	ldi	r26, 0x0C	; 12
    e8a4:	ba 2e       	mov	r11, r26
    e8a6:	8d b7       	in	r24, 0x3d	; 61
    e8a8:	9e b7       	in	r25, 0x3e	; 62
    e8aa:	0c 97       	sbiw	r24, 0x0c	; 12
    e8ac:	0f b6       	in	r0, 0x3f	; 63
    e8ae:	f8 94       	cli
    e8b0:	9e bf       	out	0x3e, r25	; 62
    e8b2:	0f be       	out	0x3f, r0	; 63
    e8b4:	8d bf       	out	0x3d, r24	; 61
    e8b6:	ed b7       	in	r30, 0x3d	; 61
    e8b8:	fe b7       	in	r31, 0x3e	; 62
    e8ba:	31 96       	adiw	r30, 0x01	; 1
    e8bc:	ad b7       	in	r26, 0x3d	; 61
    e8be:	be b7       	in	r27, 0x3e	; 62
    e8c0:	12 96       	adiw	r26, 0x02	; 2
    e8c2:	dc 92       	st	X, r13
    e8c4:	ce 92       	st	-X, r12
    e8c6:	11 97       	sbiw	r26, 0x01	; 1
    e8c8:	b3 82       	std	Z+3, r11	; 0x03
    e8ca:	a2 82       	std	Z+2, r10	; 0x02
    e8cc:	15 83       	std	Z+5, r17	; 0x05
    e8ce:	04 83       	std	Z+4, r16	; 0x04
    e8d0:	d7 01       	movw	r26, r14
    e8d2:	8c 91       	ld	r24, X
    e8d4:	86 83       	std	Z+6, r24	; 0x06
    e8d6:	17 82       	std	Z+7, r1	; 0x07
    e8d8:	0c 5f       	subi	r16, 0xFC	; 252
    e8da:	1f 4f       	sbci	r17, 0xFF	; 255
    e8dc:	11 87       	std	Z+9, r17	; 0x09
    e8de:	00 87       	std	Z+8, r16	; 0x08
    e8e0:	04 50       	subi	r16, 0x04	; 4
    e8e2:	10 40       	sbci	r17, 0x00	; 0
    e8e4:	14 96       	adiw	r26, 0x04	; 4
    e8e6:	8c 91       	ld	r24, X
    e8e8:	82 87       	std	Z+10, r24	; 0x0a
    e8ea:	13 86       	std	Z+11, r1	; 0x0b
    e8ec:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			  lcd_print((iLoop+1),1,lcdteks);
    e8f0:	ed b7       	in	r30, 0x3d	; 61
    e8f2:	fe b7       	in	r31, 0x3e	; 62
    e8f4:	3c 96       	adiw	r30, 0x0c	; 12
    e8f6:	0f b6       	in	r0, 0x3f	; 63
    e8f8:	f8 94       	cli
    e8fa:	fe bf       	out	0x3e, r31	; 62
    e8fc:	0f be       	out	0x3f, r0	; 63
    e8fe:	ed bf       	out	0x3d, r30	; 61
    e900:	80 2f       	mov	r24, r16
    e902:	61 e0       	ldi	r22, 0x01	; 1
    e904:	a6 01       	movw	r20, r12
    e906:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    e90a:	08 94       	sec
    e90c:	e1 1c       	adc	r14, r1
    e90e:	f1 1c       	adc	r15, r1
    e910:	0f 5f       	subi	r16, 0xFF	; 255
    e912:	1f 4f       	sbci	r17, 0xFF	; 255
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
		  for (iLoop=0;iLoop<4;iLoop++){
    e914:	f8 ed       	ldi	r31, 0xD8	; 216
    e916:	ef 16       	cp	r14, r31
    e918:	f2 e0       	ldi	r31, 0x02	; 2
    e91a:	ff 06       	cpc	r15, r31
    e91c:	21 f6       	brne	.-120    	; 0xe8a6 <FSettingPumpID+0xc4>
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
			  lcd_print((iLoop+1),1,lcdteks);
          }
          lcd_printf(3,15,PSTR("*)Back"));
    e91e:	83 e0       	ldi	r24, 0x03	; 3
    e920:	6f e0       	ldi	r22, 0x0F	; 15
    e922:	48 e9       	ldi	r20, 0x98	; 152
    e924:	5c e0       	ldi	r21, 0x0C	; 12
    e926:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	      lcd_printf(4,15,PSTR("#)Save"));
    e92a:	84 e0       	ldi	r24, 0x04	; 4
    e92c:	6f e0       	ldi	r22, 0x0F	; 15
    e92e:	41 e9       	ldi	r20, 0x91	; 145
    e930:	5c e0       	ldi	r21, 0x0C	; 12
    e932:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          stMenuPumpID=mpSelectInput;
    e936:	82 e0       	ldi	r24, 0x02	; 2
    e938:	d6 c1       	rjmp	.+940    	; 0xece6 <FSettingPumpID+0x504>
	      break;
     case mpSelectInput:
	      KeyPressed=_key_scan(1);
    e93a:	81 e0       	ldi	r24, 0x01	; 1
    e93c:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    e940:	98 2e       	mov	r9, r24
	      KeyChar=_key_btn(KeyPressed);
    e942:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
    e946:	98 2f       	mov	r25, r24
          if ((KeyChar>='1') && (KeyChar<='8')){
    e948:	81 53       	subi	r24, 0x31	; 49
    e94a:	88 30       	cpi	r24, 0x08	; 8
    e94c:	08 f0       	brcs	.+2      	; 0xe950 <FSettingPumpID+0x16e>
    e94e:	85 c0       	rjmp	.+266    	; 0xea5a <FSettingPumpID+0x278>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
    e950:	80 91 10 01 	lds	r24, 0x0110
    e954:	81 30       	cpi	r24, 0x01	; 1
    e956:	19 f0       	breq	.+6      	; 0xe95e <FSettingPumpID+0x17c>
    e958:	82 30       	cpi	r24, 0x02	; 2
    e95a:	a1 f5       	brne	.+104    	; 0xe9c4 <FSettingPumpID+0x1e2>
    e95c:	17 c0       	rjmp	.+46     	; 0xe98c <FSettingPumpID+0x1aa>
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
    e95e:	80 91 dd 02 	lds	r24, 0x02DD
    e962:	88 23       	and	r24, r24
    e964:	41 f4       	brne	.+16     	; 0xe976 <FSettingPumpID+0x194>
    e966:	e9 2f       	mov	r30, r25
    e968:	f0 e0       	ldi	r31, 0x00	; 0
    e96a:	ed 55       	subi	r30, 0x5D	; 93
    e96c:	fd 4f       	sbci	r31, 0xFD	; 253
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    e96e:	80 81       	ld	r24, Z
    e970:	83 36       	cpi	r24, 0x63	; 99
    e972:	c8 f4       	brcc	.+50     	; 0xe9a6 <FSettingPumpID+0x1c4>
    e974:	16 c0       	rjmp	.+44     	; 0xe9a2 <FSettingPumpID+0x1c0>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
    e976:	81 30       	cpi	r24, 0x01	; 1
    e978:	29 f5       	brne	.+74     	; 0xe9c4 <FSettingPumpID+0x1e2>
    e97a:	e9 2f       	mov	r30, r25
    e97c:	f0 e0       	ldi	r31, 0x00	; 0
    e97e:	ed 55       	subi	r30, 0x5D	; 93
    e980:	fd 4f       	sbci	r31, 0xFD	; 253
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    e982:	80 81       	ld	r24, Z
    e984:	88 23       	and	r24, r24
    e986:	d1 f4       	brne	.+52     	; 0xe9bc <FSettingPumpID+0x1da>
	     (*Value)--;
	 }else *Value=MaxValue;
    e988:	83 e6       	ldi	r24, 0x63	; 99
    e98a:	1b c0       	rjmp	.+54     	; 0xe9c2 <FSettingPumpID+0x1e0>
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
    e98c:	80 91 dd 02 	lds	r24, 0x02DD
    e990:	88 23       	and	r24, r24
    e992:	59 f4       	brne	.+22     	; 0xe9aa <FSettingPumpID+0x1c8>
    e994:	e9 2f       	mov	r30, r25
    e996:	f0 e0       	ldi	r31, 0x00	; 0
    e998:	ed 55       	subi	r30, 0x5D	; 93
    e99a:	fd 4f       	sbci	r31, 0xFD	; 253
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    e99c:	80 81       	ld	r24, Z
    e99e:	80 31       	cpi	r24, 0x10	; 16
    e9a0:	10 f4       	brcc	.+4      	; 0xe9a6 <FSettingPumpID+0x1c4>
	     (*Value)++;
    e9a2:	8f 5f       	subi	r24, 0xFF	; 255
    e9a4:	0e c0       	rjmp	.+28     	; 0xe9c2 <FSettingPumpID+0x1e0>
	 }else *Value=MinValue;
    e9a6:	10 82       	st	Z, r1
    e9a8:	0d c0       	rjmp	.+26     	; 0xe9c4 <FSettingPumpID+0x1e2>
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
    e9aa:	81 30       	cpi	r24, 0x01	; 1
    e9ac:	59 f4       	brne	.+22     	; 0xe9c4 <FSettingPumpID+0x1e2>
    e9ae:	e9 2f       	mov	r30, r25
    e9b0:	f0 e0       	ldi	r31, 0x00	; 0
    e9b2:	ed 55       	subi	r30, 0x5D	; 93
    e9b4:	fd 4f       	sbci	r31, 0xFD	; 253
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    e9b6:	80 81       	ld	r24, Z
    e9b8:	88 23       	and	r24, r24
    e9ba:	11 f0       	breq	.+4      	; 0xe9c0 <FSettingPumpID+0x1de>
	     (*Value)--;
    e9bc:	81 50       	subi	r24, 0x01	; 1
    e9be:	01 c0       	rjmp	.+2      	; 0xe9c2 <FSettingPumpID+0x1e0>
	 }else *Value=MaxValue;
    e9c0:	80 e1       	ldi	r24, 0x10	; 16
    e9c2:	80 83       	st	Z, r24
    e9c4:	f4 ed       	ldi	r31, 0xD4	; 212
    e9c6:	ef 2e       	mov	r14, r31
    e9c8:	f2 e0       	ldi	r31, 0x02	; 2
    e9ca:	ff 2e       	mov	r15, r31
    e9cc:	01 e0       	ldi	r16, 0x01	; 1
    e9ce:	10 e0       	ldi	r17, 0x00	; 0
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    e9d0:	6e 01       	movw	r12, r28
    e9d2:	08 94       	sec
    e9d4:	c1 1c       	adc	r12, r1
    e9d6:	d1 1c       	adc	r13, r1
    e9d8:	ed e7       	ldi	r30, 0x7D	; 125
    e9da:	ae 2e       	mov	r10, r30
    e9dc:	ec e0       	ldi	r30, 0x0C	; 12
    e9de:	be 2e       	mov	r11, r30
    e9e0:	8d b7       	in	r24, 0x3d	; 61
    e9e2:	9e b7       	in	r25, 0x3e	; 62
    e9e4:	0c 97       	sbiw	r24, 0x0c	; 12
    e9e6:	0f b6       	in	r0, 0x3f	; 63
    e9e8:	f8 94       	cli
    e9ea:	9e bf       	out	0x3e, r25	; 62
    e9ec:	0f be       	out	0x3f, r0	; 63
    e9ee:	8d bf       	out	0x3d, r24	; 61
    e9f0:	ed b7       	in	r30, 0x3d	; 61
    e9f2:	fe b7       	in	r31, 0x3e	; 62
    e9f4:	31 96       	adiw	r30, 0x01	; 1
    e9f6:	ad b7       	in	r26, 0x3d	; 61
    e9f8:	be b7       	in	r27, 0x3e	; 62
    e9fa:	12 96       	adiw	r26, 0x02	; 2
    e9fc:	dc 92       	st	X, r13
    e9fe:	ce 92       	st	-X, r12
    ea00:	11 97       	sbiw	r26, 0x01	; 1
    ea02:	b3 82       	std	Z+3, r11	; 0x03
    ea04:	a2 82       	std	Z+2, r10	; 0x02
    ea06:	15 83       	std	Z+5, r17	; 0x05
    ea08:	04 83       	std	Z+4, r16	; 0x04
    ea0a:	d7 01       	movw	r26, r14
    ea0c:	8c 91       	ld	r24, X
    ea0e:	86 83       	std	Z+6, r24	; 0x06
    ea10:	17 82       	std	Z+7, r1	; 0x07
    ea12:	0c 5f       	subi	r16, 0xFC	; 252
    ea14:	1f 4f       	sbci	r17, 0xFF	; 255
    ea16:	11 87       	std	Z+9, r17	; 0x09
    ea18:	00 87       	std	Z+8, r16	; 0x08
    ea1a:	04 50       	subi	r16, 0x04	; 4
    ea1c:	10 40       	sbci	r17, 0x00	; 0
    ea1e:	14 96       	adiw	r26, 0x04	; 4
    ea20:	8c 91       	ld	r24, X
    ea22:	82 87       	std	Z+10, r24	; 0x0a
    ea24:	13 86       	std	Z+11, r1	; 0x0b
    ea26:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
				  lcd_print((iLoop+1),1,lcdteks);
    ea2a:	ed b7       	in	r30, 0x3d	; 61
    ea2c:	fe b7       	in	r31, 0x3e	; 62
    ea2e:	3c 96       	adiw	r30, 0x0c	; 12
    ea30:	0f b6       	in	r0, 0x3f	; 63
    ea32:	f8 94       	cli
    ea34:	fe bf       	out	0x3e, r31	; 62
    ea36:	0f be       	out	0x3f, r0	; 63
    ea38:	ed bf       	out	0x3d, r30	; 61
    ea3a:	80 2f       	mov	r24, r16
    ea3c:	61 e0       	ldi	r22, 0x01	; 1
    ea3e:	a6 01       	movw	r20, r12
    ea40:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    ea44:	08 94       	sec
    ea46:	e1 1c       	adc	r14, r1
    ea48:	f1 1c       	adc	r15, r1
    ea4a:	0f 5f       	subi	r16, 0xFF	; 255
    ea4c:	1f 4f       	sbci	r17, 0xFF	; 255
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
    ea4e:	f8 ed       	ldi	r31, 0xD8	; 216
    ea50:	ef 16       	cp	r14, r31
    ea52:	f2 e0       	ldi	r31, 0x02	; 2
    ea54:	ff 06       	cpc	r15, r31
    ea56:	21 f6       	brne	.-120    	; 0xe9e0 <FSettingPumpID+0x1fe>
    ea58:	2b c0       	rjmp	.+86     	; 0xeab0 <FSettingPumpID+0x2ce>
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
    ea5a:	93 32       	cpi	r25, 0x23	; 35
    ea5c:	21 f5       	brne	.+72     	; 0xeaa6 <FSettingPumpID+0x2c4>
    ea5e:	40 e0       	ldi	r20, 0x00	; 0
    ea60:	20 e0       	ldi	r18, 0x00	; 0
    ea62:	30 e0       	ldi	r19, 0x00	; 0
    ea64:	52 2f       	mov	r21, r18
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
    ea66:	f9 01       	movw	r30, r18
    ea68:	ec 52       	subi	r30, 0x2C	; 44
    ea6a:	fd 4f       	sbci	r31, 0xFD	; 253
    ea6c:	e0 81       	ld	r30, Z
				   if (CheckPump>0){
    ea6e:	ee 23       	and	r30, r30
    ea70:	69 f0       	breq	.+26     	; 0xea8c <FSettingPumpID+0x2aa>
    ea72:	a4 ed       	ldi	r26, 0xD4	; 212
    ea74:	b2 e0       	ldi	r27, 0x02	; 2
    ea76:	90 e0       	ldi	r25, 0x00	; 0
				      for(j=0;j<8;j++){					      
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
    ea78:	59 17       	cp	r21, r25
    ea7a:	21 f0       	breq	.+8      	; 0xea84 <FSettingPumpID+0x2a2>
    ea7c:	8c 91       	ld	r24, X
    ea7e:	e8 17       	cp	r30, r24
    ea80:	09 f4       	brne	.+2      	; 0xea84 <FSettingPumpID+0x2a2>
						       PumpCount++;
    ea82:	4f 5f       	subi	r20, 0xFF	; 255
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
				   if (CheckPump>0){
				      for(j=0;j<8;j++){					      
    ea84:	9f 5f       	subi	r25, 0xFF	; 255
    ea86:	11 96       	adiw	r26, 0x01	; 1
    ea88:	98 30       	cpi	r25, 0x08	; 8
    ea8a:	b1 f7       	brne	.-20     	; 0xea78 <FSettingPumpID+0x296>
    ea8c:	2f 5f       	subi	r18, 0xFF	; 255
    ea8e:	3f 4f       	sbci	r19, 0xFF	; 255
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
    ea90:	28 30       	cpi	r18, 0x08	; 8
    ea92:	31 05       	cpc	r19, r1
    ea94:	39 f7       	brne	.-50     	; 0xea64 <FSettingPumpID+0x282>
    ea96:	40 93 d2 02 	sts	0x02D2, r20
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
						       PumpCount++;
					  }
				    }				     
				  }			       			  			  
			  if (PumpCount>0) stMenuPumpID=mpSaveFailed;
    ea9a:	44 23       	and	r20, r20
    ea9c:	11 f0       	breq	.+4      	; 0xeaa2 <FSettingPumpID+0x2c0>
    ea9e:	83 e0       	ldi	r24, 0x03	; 3
    eaa0:	05 c0       	rjmp	.+10     	; 0xeaac <FSettingPumpID+0x2ca>
			  else stMenuPumpID=mpSavingPumpId;
    eaa2:	85 e0       	ldi	r24, 0x05	; 5
    eaa4:	03 c0       	rjmp	.+6      	; 0xeaac <FSettingPumpID+0x2ca>
		  }	
		  else if (KeyChar=='*'){
    eaa6:	9a 32       	cpi	r25, 0x2A	; 42
    eaa8:	19 f4       	brne	.+6      	; 0xeab0 <FSettingPumpID+0x2ce>
		      stMenuPumpID=mpExitPumpId;
    eaaa:	8a e0       	ldi	r24, 0x0A	; 10
    eaac:	80 93 de 02 	sts	0x02DE, r24
		  }
		  if (KeyPressed==_KEY_SHIFT){
    eab0:	8b e7       	ldi	r24, 0x7B	; 123
    eab2:	98 16       	cp	r9, r24
    eab4:	09 f0       	breq	.+2      	; 0xeab8 <FSettingPumpID+0x2d6>
    eab6:	2c c1       	rjmp	.+600    	; 0xed10 <FSettingPumpID+0x52e>
		      if (IsShift==False)IsShift=True;
    eab8:	80 91 dd 02 	lds	r24, 0x02DD
    eabc:	88 23       	and	r24, r24
    eabe:	21 f4       	brne	.+8      	; 0xeac8 <FSettingPumpID+0x2e6>
    eac0:	81 e0       	ldi	r24, 0x01	; 1
    eac2:	80 93 dd 02 	sts	0x02DD, r24
    eac6:	24 c1       	rjmp	.+584    	; 0xed10 <FSettingPumpID+0x52e>
			  else
			  if (IsShift==True)IsShift=False;
    eac8:	81 30       	cpi	r24, 0x01	; 1
    eaca:	09 f0       	breq	.+2      	; 0xeace <FSettingPumpID+0x2ec>
    eacc:	21 c1       	rjmp	.+578    	; 0xed10 <FSettingPumpID+0x52e>
    eace:	10 92 dd 02 	sts	0x02DD, r1
    ead2:	1e c1       	rjmp	.+572    	; 0xed10 <FSettingPumpID+0x52e>
		  }
	      break;
     case mpSaveFailed:
	      lcd_clear();
    ead4:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("      Warning!      "));
    ead8:	81 e0       	ldi	r24, 0x01	; 1
    eada:	61 e0       	ldi	r22, 0x01	; 1
    eadc:	48 e6       	ldi	r20, 0x68	; 104
    eade:	5c e0       	ldi	r21, 0x0C	; 12
    eae0:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
    eae4:	82 e0       	ldi	r24, 0x02	; 2
    eae6:	61 e0       	ldi	r22, 0x01	; 1
    eae8:	43 e5       	ldi	r20, 0x53	; 83
    eaea:	5c e0       	ldi	r21, 0x0C	; 12
    eaec:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
    eaf0:	83 e0       	ldi	r24, 0x03	; 3
    eaf2:	61 e0       	ldi	r22, 0x01	; 1
    eaf4:	4e e3       	ldi	r20, 0x3E	; 62
    eaf6:	5c e0       	ldi	r21, 0x0C	; 12
    eaf8:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    eafc:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    eafe:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    eb00:	82 e0       	ldi	r24, 0x02	; 2
    eb02:	90 e0       	ldi	r25, 0x00	; 0
    eb04:	90 93 d7 01 	sts	0x01D7, r25
    eb08:	80 93 d6 01 	sts	0x01D6, r24
	      lcd_clear();
		  lcd_printf(1,1,PSTR("      Warning!      "));
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
		  system_beep(2);
	      TimDisplay=0;
    eb0c:	10 92 a7 01 	sts	0x01A7, r1
	      stMenuPumpID=mpDisplayFailed;
    eb10:	84 e0       	ldi	r24, 0x04	; 4
    eb12:	e9 c0       	rjmp	.+466    	; 0xece6 <FSettingPumpID+0x504>
          break;	 
     case mpDisplayFailed:
	      if (TimDisplay>6) stMenuPumpID=mpDisplayPumpId;
    eb14:	80 91 a7 01 	lds	r24, 0x01A7
    eb18:	87 30       	cpi	r24, 0x07	; 7
    eb1a:	08 f4       	brcc	.+2      	; 0xeb1e <FSettingPumpID+0x33c>
    eb1c:	f9 c0       	rjmp	.+498    	; 0xed10 <FSettingPumpID+0x52e>
    eb1e:	81 e0       	ldi	r24, 0x01	; 1
    eb20:	e2 c0       	rjmp	.+452    	; 0xece6 <FSettingPumpID+0x504>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    eb22:	85 e4       	ldi	r24, 0x45	; 69
    eb24:	90 e0       	ldi	r25, 0x00	; 0
    eb26:	64 ed       	ldi	r22, 0xD4	; 212
    eb28:	72 e0       	ldi	r23, 0x02	; 2
    eb2a:	48 e0       	ldi	r20, 0x08	; 8
    eb2c:	50 e0       	ldi	r21, 0x00	; 0
    eb2e:	20 e0       	ldi	r18, 0x00	; 0
    eb30:	33 e1       	ldi	r19, 0x13	; 19
    eb32:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
	      break;
     case mpSavingPumpId:
	      eeprom_write_block((const void*) &PPumpId, (void*) &DefPumpMap, 8);
		  if (IFType==IT_STANDALONE){
    eb36:	80 91 10 01 	lds	r24, 0x0110
    eb3a:	82 30       	cpi	r24, 0x02	; 2
    eb3c:	e9 f4       	brne	.+58     	; 0xeb78 <FSettingPumpID+0x396>
		      //SendConfig to Slave
			  lcd_clear();
    eb3e:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
              lcd_printf(1,1,PSTR("-PumpID-"));
    eb42:	81 e0       	ldi	r24, 0x01	; 1
    eb44:	61 e0       	ldi	r22, 0x01	; 1
    eb46:	45 e3       	ldi	r20, 0x35	; 53
    eb48:	5c e0       	ldi	r21, 0x0C	; 12
    eb4a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
              lcd_printf(2,1,PSTR("Saving.."));
    eb4e:	82 e0       	ldi	r24, 0x02	; 2
    eb50:	61 e0       	ldi	r22, 0x01	; 1
    eb52:	4c e2       	ldi	r20, 0x2C	; 44
    eb54:	5c e0       	ldi	r21, 0x0C	; 12
    eb56:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			  Idx=0;
    eb5a:	10 92 dc 02 	sts	0x02DC, r1
			  PumpCount=0;
    eb5e:	10 92 d2 02 	sts	0x02D2, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    eb62:	84 ed       	ldi	r24, 0xD4	; 212
    eb64:	92 e0       	ldi	r25, 0x02	; 2
    eb66:	65 e4       	ldi	r22, 0x45	; 69
    eb68:	70 e0       	ldi	r23, 0x00	; 0
    eb6a:	48 e0       	ldi	r20, 0x08	; 8
    eb6c:	50 e0       	ldi	r21, 0x00	; 0
    eb6e:	28 ef       	ldi	r18, 0xF8	; 248
    eb70:	32 e1       	ldi	r19, 0x12	; 18
    eb72:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
    eb76:	b6 c0       	rjmp	.+364    	; 0xece4 <FSettingPumpID+0x502>
              eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
              stMenuPumpID=mpSendConfigToSlave;
		  }else if (IFType==IT_SLAVE){
    eb78:	81 30       	cpi	r24, 0x01	; 1
    eb7a:	09 f0       	breq	.+2      	; 0xeb7e <FSettingPumpID+0x39c>
    eb7c:	c9 c0       	rjmp	.+402    	; 0xed10 <FSettingPumpID+0x52e>
    eb7e:	ba c0       	rjmp	.+372    	; 0xecf4 <FSettingPumpID+0x512>
		      //SendConfig to Slave              
              stMenuPumpID=mpExitPumpId;
		  }
	      break;
     case mpSendConfigToSlave:
	      IsStandaloneAcknoledge=False;
    eb80:	10 92 95 01 	sts	0x0195, r1
	      if (PPumpId[Idx]!=0){
    eb84:	90 91 dc 02 	lds	r25, 0x02DC
    eb88:	29 2f       	mov	r18, r25
    eb8a:	30 e0       	ldi	r19, 0x00	; 0
    eb8c:	f9 01       	movw	r30, r18
    eb8e:	ec 52       	subi	r30, 0x2C	; 44
    eb90:	fd 4f       	sbci	r31, 0xFD	; 253
    eb92:	60 81       	ld	r22, Z
    eb94:	66 23       	and	r22, r22
    eb96:	81 f0       	breq	.+32     	; 0xebb8 <FSettingPumpID+0x3d6>
		      PumpCount++;
    eb98:	80 91 d2 02 	lds	r24, 0x02D2
    eb9c:	8f 5f       	subi	r24, 0xFF	; 255
    eb9e:	80 93 d2 02 	sts	0x02D2, r24
		      MsgPumpId=((Idx<<4)|(0x0F&PPumpId[Idx]));//[Idx][PumpId]
    eba2:	6f 70       	andi	r22, 0x0F	; 15
    eba4:	74 e0       	ldi	r23, 0x04	; 4
    eba6:	22 0f       	add	r18, r18
    eba8:	33 1f       	adc	r19, r19
    ebaa:	7a 95       	dec	r23
    ebac:	e1 f7       	brne	.-8      	; 0xeba6 <FSettingPumpID+0x3c4>
    ebae:	62 2b       	or	r22, r18
    ebb0:	60 93 d3 02 	sts	0x02D3, r22
	         //SendPoolingCommand(SC_SET_PUMPID,MsgPumpId);
			  SendSlaveCommand(SC_SET_PUMPID,MsgPumpId);
    ebb4:	8d e1       	ldi	r24, 0x1D	; 29
    ebb6:	02 c0       	rjmp	.+4      	; 0xebbc <FSettingPumpID+0x3da>
		  }else SendSlaveCommand(SC_CLEAR_PUMPID,Idx);//SendPoolingCommand(SC_CLEAR_PUMPID,Idx);
    ebb8:	8e e1       	ldi	r24, 0x1E	; 30
    ebba:	69 2f       	mov	r22, r25
    ebbc:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
		  sprintf_P(lcdteks,PSTR("Id[%d]=%.2d  "),Idx+1,PPumpId[Idx]);
    ebc0:	e0 91 dc 02 	lds	r30, 0x02DC
    ebc4:	f0 e0       	ldi	r31, 0x00	; 0
    ebc6:	ad b7       	in	r26, 0x3d	; 61
    ebc8:	be b7       	in	r27, 0x3e	; 62
    ebca:	18 97       	sbiw	r26, 0x08	; 8
    ebcc:	0f b6       	in	r0, 0x3f	; 63
    ebce:	f8 94       	cli
    ebd0:	be bf       	out	0x3e, r27	; 62
    ebd2:	0f be       	out	0x3f, r0	; 63
    ebd4:	ad bf       	out	0x3d, r26	; 61
    ebd6:	2d b7       	in	r18, 0x3d	; 61
    ebd8:	3e b7       	in	r19, 0x3e	; 62
    ebda:	2f 5f       	subi	r18, 0xFF	; 255
    ebdc:	3f 4f       	sbci	r19, 0xFF	; 255
    ebde:	8e 01       	movw	r16, r28
    ebe0:	0f 5f       	subi	r16, 0xFF	; 255
    ebe2:	1f 4f       	sbci	r17, 0xFF	; 255
    ebe4:	12 96       	adiw	r26, 0x02	; 2
    ebe6:	1c 93       	st	X, r17
    ebe8:	0e 93       	st	-X, r16
    ebea:	11 97       	sbiw	r26, 0x01	; 1
    ebec:	8e e1       	ldi	r24, 0x1E	; 30
    ebee:	9c e0       	ldi	r25, 0x0C	; 12
    ebf0:	d9 01       	movw	r26, r18
    ebf2:	13 96       	adiw	r26, 0x03	; 3
    ebf4:	9c 93       	st	X, r25
    ebf6:	8e 93       	st	-X, r24
    ebf8:	12 97       	sbiw	r26, 0x02	; 2
    ebfa:	31 96       	adiw	r30, 0x01	; 1
    ebfc:	15 96       	adiw	r26, 0x05	; 5
    ebfe:	fc 93       	st	X, r31
    ec00:	ee 93       	st	-X, r30
    ec02:	14 97       	sbiw	r26, 0x04	; 4
    ec04:	31 97       	sbiw	r30, 0x01	; 1
    ec06:	ec 52       	subi	r30, 0x2C	; 44
    ec08:	fd 4f       	sbci	r31, 0xFD	; 253
    ec0a:	80 81       	ld	r24, Z
    ec0c:	16 96       	adiw	r26, 0x06	; 6
    ec0e:	8c 93       	st	X, r24
    ec10:	16 97       	sbiw	r26, 0x06	; 6
    ec12:	17 96       	adiw	r26, 0x07	; 7
    ec14:	1c 92       	st	X, r1
    ec16:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(3,1,lcdteks);
    ec1a:	ed b7       	in	r30, 0x3d	; 61
    ec1c:	fe b7       	in	r31, 0x3e	; 62
    ec1e:	38 96       	adiw	r30, 0x08	; 8
    ec20:	0f b6       	in	r0, 0x3f	; 63
    ec22:	f8 94       	cli
    ec24:	fe bf       	out	0x3e, r31	; 62
    ec26:	0f be       	out	0x3f, r0	; 63
    ec28:	ed bf       	out	0x3d, r30	; 61
    ec2a:	83 e0       	ldi	r24, 0x03	; 3
    ec2c:	61 e0       	ldi	r22, 0x01	; 1
    ec2e:	a8 01       	movw	r20, r16
    ec30:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
          stMenuPumpID=mpWaitSlaveReply;
    ec34:	88 e0       	ldi	r24, 0x08	; 8
    ec36:	57 c0       	rjmp	.+174    	; 0xece6 <FSettingPumpID+0x504>
	      break;
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
    ec38:	81 e0       	ldi	r24, 0x01	; 1
    ec3a:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
	      KeyChar=_key_btn(KeyPressed);
    ec3e:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
		  if (KeyChar=='*'){
    ec42:	8a 32       	cpi	r24, 0x2A	; 42
    ec44:	99 f4       	brne	.+38     	; 0xec6c <FSettingPumpID+0x48a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    ec46:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    ec48:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    ec4a:	82 e0       	ldi	r24, 0x02	; 2
    ec4c:	90 e0       	ldi	r25, 0x00	; 0
    ec4e:	90 93 d7 01 	sts	0x01D7, r25
    ec52:	80 93 d6 01 	sts	0x01D6, r24
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
	      KeyChar=_key_btn(KeyPressed);
		  if (KeyChar=='*'){
		      system_beep(2);
		      lcd_printf(2,1,PSTR("Cancel     "));
    ec56:	82 e0       	ldi	r24, 0x02	; 2
    ec58:	61 e0       	ldi	r22, 0x01	; 1
    ec5a:	42 e1       	ldi	r20, 0x12	; 18
    ec5c:	5c e0       	ldi	r21, 0x0C	; 12
    ec5e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			  TimDisplay=0;
    ec62:	10 92 a7 01 	sts	0x01A7, r1
		      stMenuPumpID=mpDelayExitPumpId;
    ec66:	89 e0       	ldi	r24, 0x09	; 9
    ec68:	80 93 de 02 	sts	0x02DE, r24
			  }
          if (IsStandaloneAcknoledge==True){
    ec6c:	80 91 95 01 	lds	r24, 0x0195
    ec70:	81 30       	cpi	r24, 0x01	; 1
    ec72:	09 f0       	breq	.+2      	; 0xec76 <FSettingPumpID+0x494>
    ec74:	4d c0       	rjmp	.+154    	; 0xed10 <FSettingPumpID+0x52e>
		      Idx++;
    ec76:	80 91 dc 02 	lds	r24, 0x02DC
    ec7a:	8f 5f       	subi	r24, 0xFF	; 255
    ec7c:	80 93 dc 02 	sts	0x02DC, r24
		      if (Idx<8){//Finish, Send MaxPumpCount
    ec80:	88 30       	cpi	r24, 0x08	; 8
    ec82:	10 f5       	brcc	.+68     	; 0xecc8 <FSettingPumpID+0x4e6>
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
    ec84:	20 91 d2 02 	lds	r18, 0x02D2
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ec88:	e1 99       	sbic	0x1c, 1	; 28
    ec8a:	fe cf       	rjmp	.-4      	; 0xec88 <FSettingPumpID+0x4a6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ec8c:	84 e4       	ldi	r24, 0x44	; 68
    ec8e:	91 e0       	ldi	r25, 0x01	; 1
    ec90:	9f bb       	out	0x1f, r25	; 31
    ec92:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    ec94:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    ec96:	0f b6       	in	r0, 0x3f	; 63
    ec98:	f8 94       	cli
    ec9a:	e2 9a       	sbi	0x1c, 2	; 28
    ec9c:	e1 9a       	sbi	0x1c, 1	; 28
    ec9e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    eca0:	e1 99       	sbic	0x1c, 1	; 28
    eca2:	fe cf       	rjmp	.-4      	; 0xeca0 <FSettingPumpID+0x4be>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eca4:	9f bb       	out	0x1f, r25	; 31
    eca6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    eca8:	e0 9a       	sbi	0x1c, 0	; 28
    ecaa:	9d b3       	in	r25, 0x1d	; 29
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    ecac:	90 93 5f 01 	sts	0x015F, r25
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    ecb0:	85 e1       	ldi	r24, 0x15	; 21
    ecb2:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    ecb6:	90 93 3c 0f 	sts	0x0F3C, r25
     IsControlPooling=True;
    ecba:	81 e0       	ldi	r24, 0x01	; 1
    ecbc:	80 93 97 01 	sts	0x0197, r24
		      Idx++;
		      if (Idx<8){//Finish, Send MaxPumpCount
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
                  SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PumpCountMax);
			      TimDisplay=0;		 
    ecc0:	10 92 a7 01 	sts	0x01A7, r1
				  stMenuPumpID=mpDelaySaveConfig;
    ecc4:	87 e0       	ldi	r24, 0x07	; 7
    ecc6:	0f c0       	rjmp	.+30     	; 0xece6 <FSettingPumpID+0x504>
			  }else{lcd_printf(2,1,PSTR("Completed"));
    ecc8:	82 e0       	ldi	r24, 0x02	; 2
    ecca:	61 e0       	ldi	r22, 0x01	; 1
    eccc:	48 e0       	ldi	r20, 0x08	; 8
    ecce:	5c e0       	ldi	r21, 0x0C	; 12
    ecd0:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
					TimDisplay=0;
    ecd4:	10 92 a7 01 	sts	0x01A7, r1
				    stMenuPumpID=mpDelayExitPumpId;
    ecd8:	89 e0       	ldi	r24, 0x09	; 9
    ecda:	05 c0       	rjmp	.+10     	; 0xece6 <FSettingPumpID+0x504>
				   }
			  }		  
	      break;
     case mpDelaySaveConfig:
	      if (TimDisplay>2)stMenuPumpID=mpSendConfigToSlave;
    ecdc:	80 91 a7 01 	lds	r24, 0x01A7
    ece0:	83 30       	cpi	r24, 0x03	; 3
    ece2:	b0 f0       	brcs	.+44     	; 0xed10 <FSettingPumpID+0x52e>
    ece4:	86 e0       	ldi	r24, 0x06	; 6
    ece6:	80 93 de 02 	sts	0x02DE, r24
    ecea:	12 c0       	rjmp	.+36     	; 0xed10 <FSettingPumpID+0x52e>
	      break;
     case mpDelayExitPumpId:
	      if (TimDisplay>8)stMenuPumpID=mpExitPumpId;
    ecec:	80 91 a7 01 	lds	r24, 0x01A7
    ecf0:	89 30       	cpi	r24, 0x09	; 9
    ecf2:	70 f0       	brcs	.+28     	; 0xed10 <FSettingPumpID+0x52e>
    ecf4:	8a e0       	ldi	r24, 0x0A	; 10
    ecf6:	f7 cf       	rjmp	.-18     	; 0xece6 <FSettingPumpID+0x504>
	      break;
     case mpExitPumpId:
	      if (IFType==IT_STANDALONE)
    ecf8:	80 91 10 01 	lds	r24, 0x0110
    ecfc:	82 30       	cpi	r24, 0x02	; 2
    ecfe:	21 f4       	brne	.+8      	; 0xed08 <FSettingPumpID+0x526>
		      SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    ed00:	80 e2       	ldi	r24, 0x20	; 32
    ed02:	60 e0       	ldi	r22, 0x00	; 0
    ed04:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
	      Result=MENU_DONE;
          stMenuPumpID=mpInitPumpId;
    ed08:	10 92 de 02 	sts	0x02DE, r1
    ed0c:	81 e0       	ldi	r24, 0x01	; 1
    ed0e:	01 c0       	rjmp	.+2      	; 0xed12 <FSettingPumpID+0x530>
    ed10:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
    ed12:	64 96       	adiw	r28, 0x14	; 20
    ed14:	0f b6       	in	r0, 0x3f	; 63
    ed16:	f8 94       	cli
    ed18:	de bf       	out	0x3e, r29	; 62
    ed1a:	0f be       	out	0x3f, r0	; 63
    ed1c:	cd bf       	out	0x3d, r28	; 61
    ed1e:	cf 91       	pop	r28
    ed20:	df 91       	pop	r29
    ed22:	1f 91       	pop	r17
    ed24:	0f 91       	pop	r16
    ed26:	ff 90       	pop	r15
    ed28:	ef 90       	pop	r14
    ed2a:	df 90       	pop	r13
    ed2c:	cf 90       	pop	r12
    ed2e:	bf 90       	pop	r11
    ed30:	af 90       	pop	r10
    ed32:	9f 90       	pop	r9
    ed34:	08 95       	ret

0000ed36 <_menu_pumpid>:

void _menu_pumpid(void){
	while(1){
	   if (FSettingPumpID()==MENU_DONE){
    ed36:	0e 94 f1 73 	call	0xe7e2	; 0xe7e2 <FSettingPumpID>
    ed3a:	81 30       	cpi	r24, 0x01	; 1
    ed3c:	e1 f7       	brne	.-8      	; 0xed36 <_menu_pumpid>
	       break;
	   }	   
	}
}
    ed3e:	08 95       	ret

0000ed40 <_menu_pump>:
        lcd_printf(4,15,PSTR("*)Exit"));
}



void _menu_pump(void){
    ed40:	cf 93       	push	r28
    ed42:	df 93       	push	r29
    ed44:	c4 ec       	ldi	r28, 0xC4	; 196
    ed46:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;

	while(1){
		lcd_clear();_delay_ms(10);
    ed48:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
    ed4c:	ce 01       	movw	r24, r28
    ed4e:	01 97       	sbiw	r24, 0x01	; 1
    ed50:	f1 f7       	brne	.-4      	; 0xed4e <_menu_pump+0xe>
		lcd_printf(1, 1, PSTR("1)ID"));
    ed52:	81 e0       	ldi	r24, 0x01	; 1
    ed54:	61 e0       	ldi	r22, 0x01	; 1
    ed56:	4c e3       	ldi	r20, 0x3C	; 60
    ed58:	5d e0       	ldi	r21, 0x0D	; 13
    ed5a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Product"));
    ed5e:	82 e0       	ldi	r24, 0x02	; 2
    ed60:	61 e0       	ldi	r22, 0x01	; 1
    ed62:	42 e3       	ldi	r20, 0x32	; 50
    ed64:	5d e0       	ldi	r21, 0x0D	; 13
    ed66:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    ed6a:	84 e0       	ldi	r24, 0x04	; 4
    ed6c:	61 e0       	ldi	r22, 0x01	; 1
    ed6e:	4b e2       	ldi	r20, 0x2B	; 43
    ed70:	5d e0       	ldi	r21, 0x0D	; 13
    ed72:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>

		while(1){
			__key = _key_scan(1);
    ed76:	81 e0       	ldi	r24, 0x01	; 1
    ed78:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
			if(__key == _KEY_CANCEL)
    ed7c:	87 3e       	cpi	r24, 0xE7	; 231
    ed7e:	51 f0       	breq	.+20     	; 0xed94 <_menu_pump+0x54>
				return;
			if(__key == _KEY_1){
    ed80:	8e 3e       	cpi	r24, 0xEE	; 238
    ed82:	19 f4       	brne	.+6      	; 0xed8a <_menu_pump+0x4a>
				_menu_pumpid();
    ed84:	0e 94 9b 76 	call	0xed36	; 0xed36 <_menu_pumpid>
    ed88:	df cf       	rjmp	.-66     	; 0xed48 <_menu_pump+0x8>
				break;
			}
			if(__key == _KEY_2){
    ed8a:	8e 3d       	cpi	r24, 0xDE	; 222
    ed8c:	a1 f7       	brne	.-24     	; 0xed76 <_menu_pump+0x36>
				_menu_pumpprod();
    ed8e:	0e 94 5a 49 	call	0x92b4	; 0x92b4 <_menu_pumpprod>
    ed92:	da cf       	rjmp	.-76     	; 0xed48 <_menu_pump+0x8>
				break;
			}
		}
	}
}
    ed94:	df 91       	pop	r29
    ed96:	cf 91       	pop	r28
    ed98:	08 95       	ret

0000ed9a <FMenuPumpType>:





void FMenuPumpType(){
    ed9a:	cf 92       	push	r12
    ed9c:	df 92       	push	r13
    ed9e:	ef 92       	push	r14
    eda0:	ff 92       	push	r15
    eda2:	0f 93       	push	r16
    eda4:	1f 93       	push	r17
    eda6:	df 93       	push	r29
    eda8:	cf 93       	push	r28
    edaa:	cd b7       	in	r28, 0x3d	; 61
    edac:	de b7       	in	r29, 0x3e	; 62
    edae:	a8 97       	sbiw	r28, 0x28	; 40
    edb0:	0f b6       	in	r0, 0x3f	; 63
    edb2:	f8 94       	cli
    edb4:	de bf       	out	0x3e, r29	; 62
    edb6:	0f be       	out	0x3f, r0	; 63
    edb8:	cd bf       	out	0x3d, r28	; 61
     stPumpType=ptInitMenu;
	 IsRunPumpType=True;
	 while(IsRunPumpType==True){
		  switch(stPumpType){
		  case ptInitMenu:
		       lcd_clear();
    edba:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
			   lcd_printf(1,1,PSTR("-Dispenser Brand-"));
    edbe:	81 e0       	ldi	r24, 0x01	; 1
    edc0:	61 e0       	ldi	r22, 0x01	; 1
    edc2:	49 e1       	ldi	r20, 0x19	; 25
    edc4:	5d e0       	ldi	r21, 0x0D	; 13
    edc6:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    edca:	e1 99       	sbic	0x1c, 1	; 28
    edcc:	fe cf       	rjmp	.-4      	; 0xedca <FMenuPumpType+0x30>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    edce:	87 e3       	ldi	r24, 0x37	; 55
    edd0:	91 e0       	ldi	r25, 0x01	; 1
    edd2:	9f bb       	out	0x1f, r25	; 31
    edd4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    edd6:	e0 9a       	sbi	0x1c, 0	; 28
    edd8:	0d b3       	in	r16, 0x1d	; 29
			   IdxType=eeprom_read_byte(&DefDispenserBrand);
			   //Brand Selection
			   if (IdxType>=3) IdxType=0;
    edda:	03 30       	cpi	r16, 0x03	; 3
    eddc:	08 f0       	brcs	.+2      	; 0xede0 <FMenuPumpType+0x46>
    edde:	00 e0       	ldi	r16, 0x00	; 0
               strcpy_P(DispenserBrandName,(PGM_P)pgm_read_word(&(DefListDispenserName[IdxType])));
    ede0:	10 e0       	ldi	r17, 0x00	; 0
    ede2:	f8 01       	movw	r30, r16
    ede4:	ee 0f       	add	r30, r30
    ede6:	ff 1f       	adc	r31, r31
    ede8:	e5 5d       	subi	r30, 0xD5	; 213
    edea:	fc 4f       	sbci	r31, 0xFC	; 252
    edec:	65 91       	lpm	r22, Z+
    edee:	74 91       	lpm	r23, Z+
    edf0:	85 e1       	ldi	r24, 0x15	; 21
    edf2:	c8 2e       	mov	r12, r24
    edf4:	d1 2c       	mov	r13, r1
    edf6:	cc 0e       	add	r12, r28
    edf8:	dd 1e       	adc	r13, r29
    edfa:	c6 01       	movw	r24, r12
    edfc:	0e 94 5b b5 	call	0x16ab6	; 0x16ab6 <strcpy_P>
			   sprintf_P(lcdteks,PSTR("%d.%s"),IdxType+1,DispenserBrandName);
    ee00:	8d b7       	in	r24, 0x3d	; 61
    ee02:	9e b7       	in	r25, 0x3e	; 62
    ee04:	08 97       	sbiw	r24, 0x08	; 8
    ee06:	0f b6       	in	r0, 0x3f	; 63
    ee08:	f8 94       	cli
    ee0a:	9e bf       	out	0x3e, r25	; 62
    ee0c:	0f be       	out	0x3f, r0	; 63
    ee0e:	8d bf       	out	0x3d, r24	; 61
    ee10:	ed b7       	in	r30, 0x3d	; 61
    ee12:	fe b7       	in	r31, 0x3e	; 62
    ee14:	31 96       	adiw	r30, 0x01	; 1
    ee16:	7e 01       	movw	r14, r28
    ee18:	08 94       	sec
    ee1a:	e1 1c       	adc	r14, r1
    ee1c:	f1 1c       	adc	r15, r1
    ee1e:	ad b7       	in	r26, 0x3d	; 61
    ee20:	be b7       	in	r27, 0x3e	; 62
    ee22:	12 96       	adiw	r26, 0x02	; 2
    ee24:	fc 92       	st	X, r15
    ee26:	ee 92       	st	-X, r14
    ee28:	11 97       	sbiw	r26, 0x01	; 1
    ee2a:	83 e1       	ldi	r24, 0x13	; 19
    ee2c:	9d e0       	ldi	r25, 0x0D	; 13
    ee2e:	93 83       	std	Z+3, r25	; 0x03
    ee30:	82 83       	std	Z+2, r24	; 0x02
    ee32:	0f 5f       	subi	r16, 0xFF	; 255
    ee34:	1f 4f       	sbci	r17, 0xFF	; 255
    ee36:	15 83       	std	Z+5, r17	; 0x05
    ee38:	04 83       	std	Z+4, r16	; 0x04
    ee3a:	d7 82       	std	Z+7, r13	; 0x07
    ee3c:	c6 82       	std	Z+6, r12	; 0x06
    ee3e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			   lcd_print(2,1,lcdteks);
    ee42:	8d b7       	in	r24, 0x3d	; 61
    ee44:	9e b7       	in	r25, 0x3e	; 62
    ee46:	08 96       	adiw	r24, 0x08	; 8
    ee48:	0f b6       	in	r0, 0x3f	; 63
    ee4a:	f8 94       	cli
    ee4c:	9e bf       	out	0x3e, r25	; 62
    ee4e:	0f be       	out	0x3f, r0	; 63
    ee50:	8d bf       	out	0x3d, r24	; 61
    ee52:	82 e0       	ldi	r24, 0x02	; 2
    ee54:	61 e0       	ldi	r22, 0x01	; 1
    ee56:	a7 01       	movw	r20, r14
    ee58:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Exit  [#]Change "));
    ee5c:	84 e0       	ldi	r24, 0x04	; 4
    ee5e:	61 e0       	ldi	r22, 0x01	; 1
    ee60:	4f ef       	ldi	r20, 0xFF	; 255
    ee62:	5c e0       	ldi	r21, 0x0C	; 12
    ee64:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			   if (IFType==IT_STANDALONE)
    ee68:	80 91 10 01 	lds	r24, 0x0110
    ee6c:	82 30       	cpi	r24, 0x02	; 2
    ee6e:	21 f4       	brne	.+8      	; 0xee78 <FMenuPumpType+0xde>
			       SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    ee70:	8f e1       	ldi	r24, 0x1F	; 31
    ee72:	60 e0       	ldi	r22, 0x00	; 0
    ee74:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
			   stPumpType=ptSelectBrand;
	 		   break;
          case ptSelectBrand:
		       KeyPressed = _key_scan(1);
    ee78:	81 e0       	ldi	r24, 0x01	; 1
    ee7a:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
		       KeyChar    = _key_btn(KeyPressed);
    ee7e:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>

			   if (KeyChar=='#'){
    ee82:	83 32       	cpi	r24, 0x23	; 35
    ee84:	09 f0       	breq	.+2      	; 0xee88 <FMenuPumpType+0xee>
    ee86:	2d c0       	rjmp	.+90     	; 0xeee2 <FMenuPumpType+0x148>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ee88:	e1 99       	sbic	0x1c, 1	; 28
    ee8a:	fe cf       	rjmp	.-4      	; 0xee88 <FMenuPumpType+0xee>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ee8c:	07 e3       	ldi	r16, 0x37	; 55
    ee8e:	11 e0       	ldi	r17, 0x01	; 1
    ee90:	1f bb       	out	0x1f, r17	; 31
    ee92:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ee94:	e0 9a       	sbi	0x1c, 0	; 28
    ee96:	8d b3       	in	r24, 0x1d	; 29
			       DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
				   if (DispenserBrand<ST_WAYNE_DART)
    ee98:	82 30       	cpi	r24, 0x02	; 2
    ee9a:	20 f4       	brcc	.+8      	; 0xeea4 <FMenuPumpType+0x10a>
				        DispenserBrand++;
    ee9c:	8f 5f       	subi	r24, 0xFF	; 255
    ee9e:	80 93 61 01 	sts	0x0161, r24
    eea2:	02 c0       	rjmp	.+4      	; 0xeea8 <FMenuPumpType+0x10e>
				   else DispenserBrand=ST_NONE;
    eea4:	10 92 61 01 	sts	0x0161, r1
                   //Apply DecimalSetting  
				   SetDispenser(DispenserBrand);
    eea8:	80 91 61 01 	lds	r24, 0x0161
    eeac:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <SetDispenser>

			       eeprom_write_byte(&DefDispenserBrand,DispenserBrand);
    eeb0:	80 91 61 01 	lds	r24, 0x0161
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    eeb4:	e1 99       	sbic	0x1c, 1	; 28
    eeb6:	fe cf       	rjmp	.-4      	; 0xeeb4 <FMenuPumpType+0x11a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eeb8:	1f bb       	out	0x1f, r17	; 31
    eeba:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    eebc:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    eebe:	0f b6       	in	r0, 0x3f	; 63
    eec0:	f8 94       	cli
    eec2:	e2 9a       	sbi	0x1c, 2	; 28
    eec4:	e1 9a       	sbi	0x1c, 1	; 28
    eec6:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    eec8:	e1 99       	sbic	0x1c, 1	; 28
    eeca:	fe cf       	rjmp	.-4      	; 0xeec8 <FMenuPumpType+0x12e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eecc:	1f bb       	out	0x1f, r17	; 31
    eece:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    eed0:	e0 9a       	sbi	0x1c, 0	; 28
    eed2:	6d b3       	in	r22, 0x1d	; 29
				   //SendPoolingCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
				   SendSlaveCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
    eed4:	8c e1       	ldi	r24, 0x1C	; 28
    eed6:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
				   IsSetPumpType=True;//False;
    eeda:	81 e0       	ldi	r24, 0x01	; 1
    eedc:	80 93 23 01 	sts	0x0123, r24
    eee0:	0c c0       	rjmp	.+24     	; 0xeefa <FMenuPumpType+0x160>
			       stPumpType=ptUpdated;			   
			   }else
			   if (KeyChar=='*'){
    eee2:	8a 32       	cpi	r24, 0x2A	; 42
    eee4:	09 f0       	breq	.+2      	; 0xeee8 <FMenuPumpType+0x14e>
    eee6:	c8 cf       	rjmp	.-112    	; 0xee78 <FMenuPumpType+0xde>
			       IsRunPumpType=False;
				   if (IFType==IT_STANDALONE)SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    eee8:	80 91 10 01 	lds	r24, 0x0110
    eeec:	82 30       	cpi	r24, 0x02	; 2
    eeee:	51 f4       	brne	.+20     	; 0xef04 <FMenuPumpType+0x16a>
    eef0:	80 e2       	ldi	r24, 0x20	; 32
    eef2:	60 e0       	ldi	r22, 0x00	; 0
    eef4:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
    eef8:	05 c0       	rjmp	.+10     	; 0xef04 <FMenuPumpType+0x16a>
			   }
		       break;
          case ptUpdated:
		       if (IsSetPumpType==True){
    eefa:	80 91 23 01 	lds	r24, 0x0123
    eefe:	81 30       	cpi	r24, 0x01	; 1
    ef00:	e1 f7       	brne	.-8      	; 0xeefa <FMenuPumpType+0x160>
    ef02:	5b cf       	rjmp	.-330    	; 0xedba <FMenuPumpType+0x20>
			       stPumpType=ptInitMenu;
			   }
		       break;		         
	      }
	 }     
}
    ef04:	a8 96       	adiw	r28, 0x28	; 40
    ef06:	0f b6       	in	r0, 0x3f	; 63
    ef08:	f8 94       	cli
    ef0a:	de bf       	out	0x3e, r29	; 62
    ef0c:	0f be       	out	0x3f, r0	; 63
    ef0e:	cd bf       	out	0x3d, r28	; 61
    ef10:	cf 91       	pop	r28
    ef12:	df 91       	pop	r29
    ef14:	1f 91       	pop	r17
    ef16:	0f 91       	pop	r16
    ef18:	ff 90       	pop	r15
    ef1a:	ef 90       	pop	r14
    ef1c:	df 90       	pop	r13
    ef1e:	cf 90       	pop	r12
    ef20:	08 95       	ret

0000ef22 <FSettingPump>:
   return Result;
}

char FSettingPump(){
	 char __key,Result;
		lcd_clear();_delay_ms(10);
    ef22:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
    ef26:	84 ec       	ldi	r24, 0xC4	; 196
    ef28:	99 e0       	ldi	r25, 0x09	; 9
    ef2a:	01 97       	sbiw	r24, 0x01	; 1
    ef2c:	f1 f7       	brne	.-4      	; 0xef2a <FSettingPump+0x8>
		lcd_printf(1,1, PSTR("1)ID     "));
    ef2e:	81 e0       	ldi	r24, 0x01	; 1
    ef30:	61 e0       	ldi	r22, 0x01	; 1
    ef32:	4d e8       	ldi	r20, 0x8D	; 141
    ef34:	51 e1       	ldi	r21, 0x11	; 17
    ef36:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		lcd_printf(2,1, PSTR("2)Product"));
    ef3a:	82 e0       	ldi	r24, 0x02	; 2
    ef3c:	61 e0       	ldi	r22, 0x01	; 1
    ef3e:	43 e8       	ldi	r20, 0x83	; 131
    ef40:	51 e1       	ldi	r21, 0x11	; 17
    ef42:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		if (IFType==IT_STANDALONE){
    ef46:	80 91 10 01 	lds	r24, 0x0110
    ef4a:	82 30       	cpi	r24, 0x02	; 2
    ef4c:	61 f4       	brne	.+24     	; 0xef66 <FSettingPump+0x44>
		    lcd_printf(3,1, PSTR("3)Label  "));
    ef4e:	83 e0       	ldi	r24, 0x03	; 3
    ef50:	61 e0       	ldi	r22, 0x01	; 1
    ef52:	49 e7       	ldi	r20, 0x79	; 121
    ef54:	51 e1       	ldi	r21, 0x11	; 17
    ef56:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		    lcd_printf(4,1, PSTR("4)Brand  *)Exit"));
    ef5a:	84 e0       	ldi	r24, 0x04	; 4
    ef5c:	61 e0       	ldi	r22, 0x01	; 1
    ef5e:	49 e6       	ldi	r20, 0x69	; 105
    ef60:	51 e1       	ldi	r21, 0x11	; 17
    ef62:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		}

		while(1){
			__key = _key_scan(1);
    ef66:	81 e0       	ldi	r24, 0x01	; 1
    ef68:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
			if(__key == _KEY_CANCEL)
    ef6c:	87 3e       	cpi	r24, 0xE7	; 231
    ef6e:	d9 f0       	breq	.+54     	; 0xefa6 <FSettingPump+0x84>
				break;
			if(__key == _KEY_1){
    ef70:	8e 3e       	cpi	r24, 0xEE	; 238
    ef72:	19 f4       	brne	.+6      	; 0xef7a <FSettingPump+0x58>
				_menu_pumpid();
    ef74:	0e 94 9b 76 	call	0xed36	; 0xed36 <_menu_pumpid>
    ef78:	16 c0       	rjmp	.+44     	; 0xefa6 <FSettingPump+0x84>
				break;
			}
			if(__key == _KEY_2){
    ef7a:	8e 3d       	cpi	r24, 0xDE	; 222
    ef7c:	19 f4       	brne	.+6      	; 0xef84 <FSettingPump+0x62>
				_menu_pumpprod();
    ef7e:	0e 94 5a 49 	call	0x92b4	; 0x92b4 <_menu_pumpprod>
    ef82:	11 c0       	rjmp	.+34     	; 0xefa6 <FSettingPump+0x84>
				break;
			}

			if((__key == _KEY_3)&&(IFType==IT_STANDALONE)){
    ef84:	8e 3b       	cpi	r24, 0xBE	; 190
    ef86:	39 f4       	brne	.+14     	; 0xef96 <FSettingPump+0x74>
    ef88:	80 91 10 01 	lds	r24, 0x0110
    ef8c:	82 30       	cpi	r24, 0x02	; 2
    ef8e:	59 f7       	brne	.-42     	; 0xef66 <FSettingPump+0x44>
			    FMenuPumpLabel();
    ef90:	0e 94 83 49 	call	0x9306	; 0x9306 <FMenuPumpLabel>
    ef94:	08 c0       	rjmp	.+16     	; 0xefa6 <FSettingPump+0x84>
				break;
			}
			if((__key == _KEY_4)&&(IFType==IT_STANDALONE)){
    ef96:	8d 3e       	cpi	r24, 0xED	; 237
    ef98:	31 f7       	brne	.-52     	; 0xef66 <FSettingPump+0x44>
    ef9a:	80 91 10 01 	lds	r24, 0x0110
    ef9e:	82 30       	cpi	r24, 0x02	; 2
    efa0:	11 f7       	brne	.-60     	; 0xef66 <FSettingPump+0x44>
			    FMenuPumpType();
    efa2:	0e 94 cd 76 	call	0xed9a	; 0xed9a <FMenuPumpType>

		}

	Result=MENU_DONE;
	return Result;
}
    efa6:	81 e0       	ldi	r24, 0x01	; 1
    efa8:	08 95       	ret

0000efaa <InitializeConnection>:
void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
	 ActivePump=eeprom_read_byte(&DefActivePump);
}

void InitializeConnection(){
    efaa:	af 92       	push	r10
    efac:	bf 92       	push	r11
    efae:	cf 92       	push	r12
    efb0:	df 92       	push	r13
    efb2:	ef 92       	push	r14
    efb4:	ff 92       	push	r15
    efb6:	0f 93       	push	r16
    efb8:	1f 93       	push	r17
    efba:	df 93       	push	r29
    efbc:	cf 93       	push	r28
    efbe:	cd b7       	in	r28, 0x3d	; 61
    efc0:	de b7       	in	r29, 0x3e	; 62
    efc2:	64 97       	sbiw	r28, 0x14	; 20
    efc4:	0f b6       	in	r0, 0x3f	; 63
    efc6:	f8 94       	cli
    efc8:	de bf       	out	0x3e, r29	; 62
    efca:	0f be       	out	0x3f, r0	; 63
    efcc:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    efce:	e1 99       	sbic	0x1c, 1	; 28
    efd0:	fe cf       	rjmp	.-4      	; 0xefce <InitializeConnection+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    efd2:	46 e3       	ldi	r20, 0x36	; 54
    efd4:	a4 2e       	mov	r10, r20
    efd6:	41 e0       	ldi	r20, 0x01	; 1
    efd8:	b4 2e       	mov	r11, r20
    efda:	bf ba       	out	0x1f, r11	; 31
    efdc:	ae ba       	out	0x1e, r10	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    efde:	e0 9a       	sbi	0x1c, 0	; 28
    efe0:	9d b3       	in	r25, 0x1d	; 29
	unsigned int tConnect=0;
	char ForceType=IT_NONE,iCon=0,iTry=0;
	char lcdteks[20];
	IFType=eeprom_read_byte(&DefInitIFT);
    efe2:	90 93 10 01 	sts	0x0110, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    efe6:	e1 99       	sbic	0x1c, 1	; 28
    efe8:	fe cf       	rjmp	.-4      	; 0xefe6 <InitializeConnection+0x3c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    efea:	37 e3       	ldi	r19, 0x37	; 55
    efec:	c3 2e       	mov	r12, r19
    efee:	31 e0       	ldi	r19, 0x01	; 1
    eff0:	d3 2e       	mov	r13, r19
    eff2:	df ba       	out	0x1f, r13	; 31
    eff4:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    eff6:	e0 9a       	sbi	0x1c, 0	; 28
    eff8:	8d b3       	in	r24, 0x1d	; 29
	DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    effa:	80 93 61 01 	sts	0x0161, r24

	//SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);

    //Send Msg10
	if  (IFType==IT_SLAVE){
    effe:	91 30       	cpi	r25, 0x01	; 1
    f000:	09 f0       	breq	.+2      	; 0xf004 <InitializeConnection+0x5a>
    f002:	59 c0       	rjmp	.+178    	; 0xf0b6 <InitializeConnection+0x10c>
	     SendSlaveCommand(SC_SLAVE,ST_NONE);
    f004:	81 e0       	ldi	r24, 0x01	; 1
    f006:	60 e0       	ldi	r22, 0x00	; 0
    f008:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
		 char_count=0;
    f00c:	10 92 9d 01 	sts	0x019D, r1
    f010:	10 92 9c 01 	sts	0x019C, r1
		 if (IsPowerOn==True){
    f014:	80 91 9a 04 	lds	r24, 0x049A
    f018:	81 30       	cpi	r24, 0x01	; 1
    f01a:	59 f4       	brne	.+22     	; 0xf032 <InitializeConnection+0x88>
		     IsPowerOn=False;
    f01c:	10 92 9a 04 	sts	0x049A, r1
    f020:	80 e5       	ldi	r24, 0x50	; 80
    f022:	93 ec       	ldi	r25, 0xC3	; 195
    f024:	29 e1       	ldi	r18, 0x19	; 25
    f026:	30 e0       	ldi	r19, 0x00	; 0
    f028:	f9 01       	movw	r30, r18
    f02a:	31 97       	sbiw	r30, 0x01	; 1
    f02c:	f1 f7       	brne	.-4      	; 0xf02a <InitializeConnection+0x80>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    f02e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    f030:	d9 f7       	brne	.-10     	; 0xf028 <InitializeConnection+0x7e>
		     _delay_ms(5000);
			 }
         sendMessage10();
    f032:	0e 94 d9 53 	call	0xa7b2	; 0xa7b2 <sendMessage10>
         lcd_printf(4,1,PSTR("Connect         "));
    f036:	84 e0       	ldi	r24, 0x04	; 4
    f038:	61 e0       	ldi	r22, 0x01	; 1
    f03a:	46 e8       	ldi	r20, 0x86	; 134
    f03c:	5c e1       	ldi	r21, 0x1C	; 28
    f03e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		 lcd_printf(4,1,PSTR("Connect"));
    f042:	84 e0       	ldi	r24, 0x04	; 4
    f044:	61 e0       	ldi	r22, 0x01	; 1
    f046:	4e e7       	ldi	r20, 0x7E	; 126
    f048:	5c e1       	ldi	r21, 0x1C	; 28
    f04a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
    f04e:	10 92 b7 01 	sts	0x01B7, r1
    f052:	ee 24       	eor	r14, r14
    f054:	ff 24       	eor	r15, r15
    f056:	10 e0       	ldi	r17, 0x00	; 0
    f058:	00 e0       	ldi	r16, 0x00	; 0
    f05a:	29 c0       	rjmp	.+82     	; 0xf0ae <InitializeConnection+0x104>
		  //SlaveIdentification		  
		 while (IsMessage11==False){
		        lcd_put(4,(8+iCon),'.');
    f05c:	61 2f       	mov	r22, r17
    f05e:	68 5f       	subi	r22, 0xF8	; 248
    f060:	84 e0       	ldi	r24, 0x04	; 4
    f062:	4e e2       	ldi	r20, 0x2E	; 46
    f064:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
                tConnect++;
    f068:	08 94       	sec
    f06a:	e1 1c       	adc	r14, r1
    f06c:	f1 1c       	adc	r15, r1
			    if ((tConnect%800)==0)iCon++;
    f06e:	c7 01       	movw	r24, r14
    f070:	60 e2       	ldi	r22, 0x20	; 32
    f072:	73 e0       	ldi	r23, 0x03	; 3
    f074:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
    f078:	89 2b       	or	r24, r25
    f07a:	09 f4       	brne	.+2      	; 0xf07e <InitializeConnection+0xd4>
    f07c:	1f 5f       	subi	r17, 0xFF	; 255
			    if (iCon>8){
    f07e:	19 30       	cpi	r17, 0x09	; 9
    f080:	70 f0       	brcs	.+28     	; 0xf09e <InitializeConnection+0xf4>
			        lcd_printf(4,1,PSTR("Connect         "));
    f082:	84 e0       	ldi	r24, 0x04	; 4
    f084:	61 e0       	ldi	r22, 0x01	; 1
    f086:	4d e6       	ldi	r20, 0x6D	; 109
    f088:	5c e1       	ldi	r21, 0x1C	; 28
    f08a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				    sendMessage10();
    f08e:	0e 94 d9 53 	call	0xa7b2	; 0xa7b2 <sendMessage10>
				    SendSlaveCommand(SC_SLAVE,ST_NONE);
    f092:	81 e0       	ldi	r24, 0x01	; 1
    f094:	60 e0       	ldi	r22, 0x00	; 0
    f096:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
			        iCon=0;
				    iTry++;}
    f09a:	0f 5f       	subi	r16, 0xFF	; 255
    f09c:	10 e0       	ldi	r17, 0x00	; 0
			    if (iTry>3){
    f09e:	04 30       	cpi	r16, 0x04	; 4
    f0a0:	30 f0       	brcs	.+12     	; 0xf0ae <InitializeConnection+0x104>
			        //IsErrorTCPIP=True;
				    IsAdvanzStartupInfo=False;		
    f0a2:	10 92 c1 01 	sts	0x01C1, r1
					IFType=IT_STANDALONE;
    f0a6:	82 e0       	ldi	r24, 0x02	; 2
    f0a8:	80 93 10 01 	sts	0x0110, r24
    f0ac:	04 c0       	rjmp	.+8      	; 0xf0b6 <InitializeConnection+0x10c>
         lcd_printf(4,1,PSTR("Connect         "));
		 lcd_printf(4,1,PSTR("Connect"));
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
		  //SlaveIdentification		  
		 while (IsMessage11==False){
    f0ae:	80 91 b7 01 	lds	r24, 0x01B7
    f0b2:	88 23       	and	r24, r24
    f0b4:	99 f2       	breq	.-90     	; 0xf05c <InitializeConnection+0xb2>
				    break;
			    }
            }//EndWhile
		}

	if (IFType==IT_STANDALONE){
    f0b6:	80 91 10 01 	lds	r24, 0x0110
    f0ba:	82 30       	cpi	r24, 0x02	; 2
    f0bc:	09 f0       	breq	.+2      	; 0xf0c0 <InitializeConnection+0x116>
    f0be:	72 c0       	rjmp	.+228    	; 0xf1a4 <InitializeConnection+0x1fa>
        IsStandAloneDetected=False;		
    f0c0:	10 92 b3 01 	sts	0x01B3, r1
		SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f0c4:	60 91 61 01 	lds	r22, 0x0161
    f0c8:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
		tConnect=0,iCon=0,iTry=0;
	    lcd_clear();
    f0cc:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
	    lcd_printf(1,1,PSTR("Scan Pump"));
    f0d0:	81 e0       	ldi	r24, 0x01	; 1
    f0d2:	61 e0       	ldi	r22, 0x01	; 1
    f0d4:	43 e6       	ldi	r20, 0x63	; 99
    f0d6:	5c e1       	ldi	r21, 0x1C	; 28
    f0d8:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f0dc:	e1 99       	sbic	0x1c, 1	; 28
    f0de:	fe cf       	rjmp	.-4      	; 0xf0dc <InitializeConnection+0x132>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f0e0:	df ba       	out	0x1f, r13	; 31
    f0e2:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f0e4:	e0 9a       	sbi	0x1c, 0	; 28
    f0e6:	8d b3       	in	r24, 0x1d	; 29
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
    f0e8:	e8 2f       	mov	r30, r24
    f0ea:	f0 e0       	ldi	r31, 0x00	; 0
    f0ec:	ee 0f       	add	r30, r30
    f0ee:	ff 1f       	adc	r31, r31
    f0f0:	e5 5d       	subi	r30, 0xD5	; 213
    f0f2:	fc 4f       	sbci	r31, 0xFC	; 252
    f0f4:	65 91       	lpm	r22, Z+
    f0f6:	74 91       	lpm	r23, Z+
    f0f8:	8e 01       	movw	r16, r28
    f0fa:	0f 5f       	subi	r16, 0xFF	; 255
    f0fc:	1f 4f       	sbci	r17, 0xFF	; 255
    f0fe:	c8 01       	movw	r24, r16
    f100:	0e 94 5b b5 	call	0x16ab6	; 0x16ab6 <strcpy_P>
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
    f104:	00 d0       	rcall	.+0      	; 0xf106 <InitializeConnection+0x15c>
    f106:	00 d0       	rcall	.+0      	; 0xf108 <InitializeConnection+0x15e>
    f108:	00 d0       	rcall	.+0      	; 0xf10a <InitializeConnection+0x160>
    f10a:	ed b7       	in	r30, 0x3d	; 61
    f10c:	fe b7       	in	r31, 0x3e	; 62
    f10e:	31 96       	adiw	r30, 0x01	; 1
    f110:	ad b7       	in	r26, 0x3d	; 61
    f112:	be b7       	in	r27, 0x3e	; 62
    f114:	12 96       	adiw	r26, 0x02	; 2
    f116:	1c 93       	st	X, r17
    f118:	0e 93       	st	-X, r16
    f11a:	11 97       	sbiw	r26, 0x01	; 1
    f11c:	80 e6       	ldi	r24, 0x60	; 96
    f11e:	9c e1       	ldi	r25, 0x1C	; 28
    f120:	93 83       	std	Z+3, r25	; 0x03
    f122:	82 83       	std	Z+2, r24	; 0x02
    f124:	15 83       	std	Z+5, r17	; 0x05
    f126:	04 83       	std	Z+4, r16	; 0x04
    f128:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	    lcd_print(2,1,lcdteks);
    f12c:	8d b7       	in	r24, 0x3d	; 61
    f12e:	9e b7       	in	r25, 0x3e	; 62
    f130:	06 96       	adiw	r24, 0x06	; 6
    f132:	0f b6       	in	r0, 0x3f	; 63
    f134:	f8 94       	cli
    f136:	9e bf       	out	0x3e, r25	; 62
    f138:	0f be       	out	0x3f, r0	; 63
    f13a:	8d bf       	out	0x3d, r24	; 61
    f13c:	82 e0       	ldi	r24, 0x02	; 2
    f13e:	61 e0       	ldi	r22, 0x01	; 1
    f140:	a8 01       	movw	r20, r16
    f142:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
    f146:	00 e0       	ldi	r16, 0x00	; 0
    f148:	10 e0       	ldi	r17, 0x00	; 0
    f14a:	ff 24       	eor	r15, r15
    f14c:	dd 24       	eor	r13, r13
    f14e:	26 c0       	rjmp	.+76     	; 0xf19c <InitializeConnection+0x1f2>

	    while (IsStandAloneDetected==False){
		       lcd_put(4,(1+iCon),'.');
    f150:	ef 2c       	mov	r14, r15
    f152:	e3 94       	inc	r14
    f154:	84 e0       	ldi	r24, 0x04	; 4
    f156:	6e 2d       	mov	r22, r14
    f158:	4e e2       	ldi	r20, 0x2E	; 46
    f15a:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
		       tConnect++;
    f15e:	0f 5f       	subi	r16, 0xFF	; 255
    f160:	1f 4f       	sbci	r17, 0xFF	; 255
		       if ((tConnect%100)==0)iCon++;
    f162:	c8 01       	movw	r24, r16
    f164:	64 e6       	ldi	r22, 0x64	; 100
    f166:	70 e0       	ldi	r23, 0x00	; 0
    f168:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
    f16c:	89 2b       	or	r24, r25
    f16e:	09 f4       	brne	.+2      	; 0xf172 <InitializeConnection+0x1c8>
    f170:	fe 2c       	mov	r15, r14
		       if (iCon>16){
    f172:	90 e1       	ldi	r25, 0x10	; 16
    f174:	9f 15       	cp	r25, r15
    f176:	78 f4       	brcc	.+30     	; 0xf196 <InitializeConnection+0x1ec>
			       lcd_printf(4,1,PSTR("                   "));
    f178:	84 e0       	ldi	r24, 0x04	; 4
    f17a:	61 e0       	ldi	r22, 0x01	; 1
    f17c:	4c e4       	ldi	r20, 0x4C	; 76
    f17e:	5c e1       	ldi	r21, 0x1C	; 28
    f180:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				   //IsStandaloneAcknoledge=False;
		           SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f184:	82 e0       	ldi	r24, 0x02	; 2
    f186:	60 91 61 01 	lds	r22, 0x0161
    f18a:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
                   //InitStandalone();

			       DisplayPumpStatus();
    f18e:	0e 94 46 45 	call	0x8a8c	; 0x8a8c <DisplayPumpStatus>
			       iCon=0;
			       iTry++;}
    f192:	d3 94       	inc	r13
    f194:	ff 24       	eor	r15, r15
		           if (iTry>3) break; 
    f196:	a3 e0       	ldi	r26, 0x03	; 3
    f198:	ad 15       	cp	r26, r13
    f19a:	20 f0       	brcs	.+8      	; 0xf1a4 <InitializeConnection+0x1fa>
	    lcd_printf(1,1,PSTR("Scan Pump"));
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
	    lcd_print(2,1,lcdteks);

	    while (IsStandAloneDetected==False){
    f19c:	80 91 b3 01 	lds	r24, 0x01B3
    f1a0:	88 23       	and	r24, r24
    f1a2:	b1 f2       	breq	.-84     	; 0xf150 <InitializeConnection+0x1a6>
			       iCon=0;
			       iTry++;}
		           if (iTry>3) break; 
	    }
	}//EndIf
	if(IsMessage11==True){
    f1a4:	80 91 b7 01 	lds	r24, 0x01B7
    f1a8:	81 30       	cpi	r24, 0x01	; 1
    f1aa:	b9 f4       	brne	.+46     	; 0xf1da <InitializeConnection+0x230>
	   lcd_printf(4,1,PSTR("Connected"));
    f1ac:	84 e0       	ldi	r24, 0x04	; 4
    f1ae:	61 e0       	ldi	r22, 0x01	; 1
    f1b0:	42 e4       	ldi	r20, 0x42	; 66
    f1b2:	5c e1       	ldi	r21, 0x1C	; 28
    f1b4:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f1b8:	e1 99       	sbic	0x1c, 1	; 28
    f1ba:	fe cf       	rjmp	.-4      	; 0xf1b8 <InitializeConnection+0x20e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f1bc:	bf ba       	out	0x1f, r11	; 31
    f1be:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f1c0:	11 e0       	ldi	r17, 0x01	; 1
    f1c2:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    f1c4:	0f b6       	in	r0, 0x3f	; 63
    f1c6:	f8 94       	cli
    f1c8:	e2 9a       	sbi	0x1c, 2	; 28
    f1ca:	e1 9a       	sbi	0x1c, 1	; 28
    f1cc:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_SLAVE);
	   IFType=IT_SLAVE;
    f1ce:	10 93 10 01 	sts	0x0110, r17
	   //IsErrorTCPIP=False;
	   procMessage11();
    f1d2:	0e 94 61 5e 	call	0xbcc2	; 0xbcc2 <procMessage11>
	   IsAdvanzStartupInfo=True;
    f1d6:	10 93 c1 01 	sts	0x01C1, r17
	}
	if(IsStandAloneDetected==True){
    f1da:	80 91 b3 01 	lds	r24, 0x01B3
    f1de:	81 30       	cpi	r24, 0x01	; 1
    f1e0:	99 f4       	brne	.+38     	; 0xf208 <InitializeConnection+0x25e>
	   lcd_printf(4,1,PSTR("PumpFound"));
    f1e2:	84 e0       	ldi	r24, 0x04	; 4
    f1e4:	61 e0       	ldi	r22, 0x01	; 1
    f1e6:	48 e3       	ldi	r20, 0x38	; 56
    f1e8:	5c e1       	ldi	r21, 0x1C	; 28
    f1ea:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f1ee:	e1 99       	sbic	0x1c, 1	; 28
    f1f0:	fe cf       	rjmp	.-4      	; 0xf1ee <InitializeConnection+0x244>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f1f2:	bf ba       	out	0x1f, r11	; 31
    f1f4:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f1f6:	82 e0       	ldi	r24, 0x02	; 2
    f1f8:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    f1fa:	0f b6       	in	r0, 0x3f	; 63
    f1fc:	f8 94       	cli
    f1fe:	e2 9a       	sbi	0x1c, 2	; 28
    f200:	e1 9a       	sbi	0x1c, 1	; 28
    f202:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_STANDALONE);
	   IFType=IT_STANDALONE;
    f204:	80 93 10 01 	sts	0x0110, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f208:	e1 99       	sbic	0x1c, 1	; 28
    f20a:	fe cf       	rjmp	.-4      	; 0xf208 <InitializeConnection+0x25e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f20c:	85 e3       	ldi	r24, 0x35	; 53
    f20e:	91 e0       	ldi	r25, 0x01	; 1
    f210:	9f bb       	out	0x1f, r25	; 31
    f212:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f214:	e0 9a       	sbi	0x1c, 0	; 28
    f216:	8d b3       	in	r24, 0x1d	; 29
	}
	//PrintStatus
	if (eeprom_read_byte(&DefPrintInitialize)==True)GeneratePrintInit();
    f218:	81 30       	cpi	r24, 0x01	; 1
    f21a:	11 f4       	brne	.+4      	; 0xf220 <InitializeConnection+0x276>
    f21c:	0e 94 36 33 	call	0x666c	; 0x666c <GeneratePrintInit>
	if ((IsStandAloneDetected==False)&&(IsMessage11==False)){		
    f220:	80 91 b3 01 	lds	r24, 0x01B3
    f224:	88 23       	and	r24, r24
    f226:	09 f0       	breq	.+2      	; 0xf22a <InitializeConnection+0x280>
    f228:	38 c0       	rjmp	.+112    	; 0xf29a <InitializeConnection+0x2f0>
    f22a:	80 91 b7 01 	lds	r24, 0x01B7
    f22e:	88 23       	and	r24, r24
    f230:	09 f0       	breq	.+2      	; 0xf234 <InitializeConnection+0x28a>
    f232:	33 c0       	rjmp	.+102    	; 0xf29a <InitializeConnection+0x2f0>
		 lcd_printf(2,1,PSTR("TCP/IP Error"));
    f234:	82 e0       	ldi	r24, 0x02	; 2
    f236:	61 e0       	ldi	r22, 0x01	; 1
    f238:	4b e2       	ldi	r20, 0x2B	; 43
    f23a:	5c e1       	ldi	r21, 0x1C	; 28
    f23c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		 lcd_printf(3,1,PSTR("No Pump Found"));
    f240:	83 e0       	ldi	r24, 0x03	; 3
    f242:	61 e0       	ldi	r22, 0x01	; 1
    f244:	4d e1       	ldi	r20, 0x1D	; 29
    f246:	5c e1       	ldi	r21, 0x1C	; 28
    f248:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
    f24c:	80 e2       	ldi	r24, 0x20	; 32
    f24e:	9e e4       	ldi	r25, 0x4E	; 78
    f250:	29 e1       	ldi	r18, 0x19	; 25
    f252:	30 e0       	ldi	r19, 0x00	; 0
    f254:	f9 01       	movw	r30, r18
    f256:	31 97       	sbiw	r30, 0x01	; 1
    f258:	f1 f7       	brne	.-4      	; 0xf256 <InitializeConnection+0x2ac>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    f25a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    f25c:	d9 f7       	brne	.-10     	; 0xf254 <InitializeConnection+0x2aa>
		 _delay_ms(2000);
		 ForceType=systemForceType();
    f25e:	0e 94 94 4a 	call	0x9528	; 0x9528 <systemForceType>
		 if (ForceType=='1'){
    f262:	81 33       	cpi	r24, 0x31	; 49
    f264:	29 f4       	brne	.+10     	; 0xf270 <InitializeConnection+0x2c6>
		     IFType=IT_SLAVE;
    f266:	81 e0       	ldi	r24, 0x01	; 1
    f268:	80 93 10 01 	sts	0x0110, r24
			 SendSlaveCommand(SC_SLAVE,ST_NONE);
    f26c:	60 e0       	ldi	r22, 0x00	; 0
    f26e:	07 c0       	rjmp	.+14     	; 0xf27e <InitializeConnection+0x2d4>
         }
		 else
		 if (ForceType=='2'){
    f270:	82 33       	cpi	r24, 0x32	; 50
    f272:	39 f4       	brne	.+14     	; 0xf282 <InitializeConnection+0x2d8>
		     IFType=IT_STANDALONE;
    f274:	82 e0       	ldi	r24, 0x02	; 2
    f276:	80 93 10 01 	sts	0x0110, r24
			 SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f27a:	60 91 61 01 	lds	r22, 0x0161
    f27e:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>

			 //SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,eeprom_read_byte(&DefPoolingPumpMax));

			 //InitStandalone();
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
    f282:	80 91 10 01 	lds	r24, 0x0110
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f286:	e1 99       	sbic	0x1c, 1	; 28
    f288:	fe cf       	rjmp	.-4      	; 0xf286 <InitializeConnection+0x2dc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f28a:	bf ba       	out	0x1f, r11	; 31
    f28c:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f28e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    f290:	0f b6       	in	r0, 0x3f	; 63
    f292:	f8 94       	cli
    f294:	e2 9a       	sbi	0x1c, 2	; 28
    f296:	e1 9a       	sbi	0x1c, 1	; 28
    f298:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f29a:	e1 99       	sbic	0x1c, 1	; 28
    f29c:	fe cf       	rjmp	.-4      	; 0xf29a <InitializeConnection+0x2f0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f29e:	84 e4       	ldi	r24, 0x44	; 68
    f2a0:	91 e0       	ldi	r25, 0x01	; 1
    f2a2:	9f bb       	out	0x1f, r25	; 31
    f2a4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f2a6:	e0 9a       	sbi	0x1c, 0	; 28
    f2a8:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    f2aa:	80 93 5f 01 	sts	0x015F, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f2ae:	e1 99       	sbic	0x1c, 1	; 28
    f2b0:	fe cf       	rjmp	.-4      	; 0xf2ae <InitializeConnection+0x304>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f2b2:	89 e4       	ldi	r24, 0x49	; 73
    f2b4:	91 e0       	ldi	r25, 0x01	; 1
    f2b6:	9f bb       	out	0x1f, r25	; 31
    f2b8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f2ba:	e0 9a       	sbi	0x1c, 0	; 28
    f2bc:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    f2be:	80 93 60 01 	sts	0x0160, r24
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
	}
	InitMemory();
	//SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
}
    f2c2:	64 96       	adiw	r28, 0x14	; 20
    f2c4:	0f b6       	in	r0, 0x3f	; 63
    f2c6:	f8 94       	cli
    f2c8:	de bf       	out	0x3e, r29	; 62
    f2ca:	0f be       	out	0x3f, r0	; 63
    f2cc:	cd bf       	out	0x3d, r28	; 61
    f2ce:	cf 91       	pop	r28
    f2d0:	df 91       	pop	r29
    f2d2:	1f 91       	pop	r17
    f2d4:	0f 91       	pop	r16
    f2d6:	ff 90       	pop	r15
    f2d8:	ef 90       	pop	r14
    f2da:	df 90       	pop	r13
    f2dc:	cf 90       	pop	r12
    f2de:	bf 90       	pop	r11
    f2e0:	af 90       	pop	r10
    f2e2:	08 95       	ret

0000f2e4 <StoreStandaloneTransData>:
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
}
         
			                                         //      STX     MSGID  PumpID              6        8        8
void StoreStandaloneTransData(char *strRawTransData){//  [0x50,0x05]  01      01      1       004500   00000200  00000012 [0x06,0x60] = 24
    f2e4:	2f 92       	push	r2
    f2e6:	3f 92       	push	r3
    f2e8:	4f 92       	push	r4
    f2ea:	5f 92       	push	r5
    f2ec:	6f 92       	push	r6
    f2ee:	7f 92       	push	r7
    f2f0:	8f 92       	push	r8
    f2f2:	9f 92       	push	r9
    f2f4:	af 92       	push	r10
    f2f6:	bf 92       	push	r11
    f2f8:	cf 92       	push	r12
    f2fa:	df 92       	push	r13
    f2fc:	ef 92       	push	r14
    f2fe:	ff 92       	push	r15
    f300:	0f 93       	push	r16
    f302:	1f 93       	push	r17
    f304:	df 93       	push	r29
    f306:	cf 93       	push	r28
    f308:	cd b7       	in	r28, 0x3d	; 61
    f30a:	de b7       	in	r29, 0x3e	; 62
    f30c:	e1 97       	sbiw	r28, 0x31	; 49
    f30e:	0f b6       	in	r0, 0x3f	; 63
    f310:	f8 94       	cli
    f312:	de bf       	out	0x3e, r29	; 62
    f314:	0f be       	out	0x3f, r0	; 63
    f316:	cd bf       	out	0x3d, r28	; 61
    f318:	7c 01       	movw	r14, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f31a:	dc 01       	movw	r26, r24
    f31c:	12 96       	adiw	r26, 0x02	; 2
    f31e:	8c 91       	ld	r24, X
    f320:	12 97       	sbiw	r26, 0x02	; 2
    f322:	89 83       	std	Y+1, r24	; 0x01
    f324:	13 96       	adiw	r26, 0x03	; 3
    f326:	8c 91       	ld	r24, X
    f328:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    f32a:	1b 82       	std	Y+3, r1	; 0x03
	 char strSend[30];
	 char TransDigit;
	 char FIPAddr;
      
	 StrPosCopy(strRawTransData,strPumpID,2,2);
	 RemZeroLead(strPumpID);
    f32c:	8e 01       	movw	r16, r28
    f32e:	0f 5f       	subi	r16, 0xFF	; 255
    f330:	1f 4f       	sbci	r17, 0xFF	; 255
    f332:	c8 01       	movw	r24, r16
    f334:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
	 iPumpID=atoi(strPumpID); 
    f338:	c8 01       	movw	r24, r16
    f33a:	0e 94 3d b5 	call	0x16a7a	; 0x16a7a <atoi>
    f33e:	38 2e       	mov	r3, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    f340:	0e 94 dd 1d 	call	0x3bba	; 0x3bba <GetFIPAddr>
    f344:	d8 2e       	mov	r13, r24
	 if (FIPAddr>0){
    f346:	88 23       	and	r24, r24
    f348:	09 f4       	brne	.+2      	; 0xf34c <StoreStandaloneTransData+0x68>
    f34a:	1a c2       	rjmp	.+1076   	; 0xf780 <StoreStandaloneTransData+0x49c>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    f34c:	f7 01       	movw	r30, r14
    f34e:	f4 81       	ldd	r31, Z+4	; 0x04
    f350:	f9 ab       	std	Y+49, r31	; 0x31

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f352:	d7 01       	movw	r26, r14
    f354:	15 96       	adiw	r26, 0x05	; 5
    f356:	2c 90       	ld	r2, X
    f358:	e4 e0       	ldi	r30, 0x04	; 4
    f35a:	8e 2e       	mov	r8, r30
    f35c:	91 2c       	mov	r9, r1
    f35e:	8c 0e       	add	r8, r28
    f360:	9d 1e       	adc	r9, r29
    f362:	f4 01       	movw	r30, r8
    f364:	ce 01       	movw	r24, r28
    f366:	0b 96       	adiw	r24, 0x0b	; 11
	     strMemory[i]=data;
    f368:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f36a:	e8 17       	cp	r30, r24
    f36c:	f9 07       	cpc	r31, r25
    f36e:	e1 f7       	brne	.-8      	; 0xf368 <StoreStandaloneTransData+0x84>
    f370:	7d e1       	ldi	r23, 0x1D	; 29
    f372:	67 2e       	mov	r6, r23
    f374:	71 2c       	mov	r7, r1
    f376:	6c 0e       	add	r6, r28
    f378:	7d 1e       	adc	r7, r29
    f37a:	93 01       	movw	r18, r6
	     strMemory[i]=data;
    f37c:	ce 01       	movw	r24, r28
    f37e:	87 96       	adiw	r24, 0x27	; 39
    f380:	f9 01       	movw	r30, r18
    f382:	11 92       	st	Z+, r1
    f384:	9f 01       	movw	r18, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f386:	e8 17       	cp	r30, r24
    f388:	f9 07       	cpc	r31, r25
    f38a:	d1 f7       	brne	.-12     	; 0xf380 <StoreStandaloneTransData+0x9c>
    f38c:	2f 01       	movw	r4, r30
	     strMemory[i]=data;
    f38e:	ce 01       	movw	r24, r28
    f390:	c1 96       	adiw	r24, 0x31	; 49
    f392:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f394:	e8 17       	cp	r30, r24
    f396:	f9 07       	cpc	r31, r25
    f398:	e1 f7       	brne	.-8      	; 0xf392 <StoreStandaloneTransData+0xae>
    f39a:	a7 01       	movw	r20, r14
    f39c:	d7 01       	movw	r26, r14
    f39e:	f4 01       	movw	r30, r8
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3a0:	be 01       	movw	r22, r28
    f3a2:	66 5f       	subi	r22, 0xF6	; 246
    f3a4:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f3a6:	16 96       	adiw	r26, 0x06	; 6
    f3a8:	8c 91       	ld	r24, X
    f3aa:	16 97       	sbiw	r26, 0x06	; 6
    f3ac:	81 93       	st	Z+, r24
    f3ae:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3b0:	e6 17       	cp	r30, r22
    f3b2:	f7 07       	cpc	r31, r23
    f3b4:	c1 f7       	brne	.-16     	; 0xf3a6 <StoreStandaloneTransData+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f3b6:	1a 86       	std	Y+10, r1	; 0x0a
    f3b8:	d7 01       	movw	r26, r14
    f3ba:	f3 01       	movw	r30, r6
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3bc:	be 01       	movw	r22, r28
    f3be:	6b 5d       	subi	r22, 0xDB	; 219
    f3c0:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f3c2:	1c 96       	adiw	r26, 0x0c	; 12
    f3c4:	8c 91       	ld	r24, X
    f3c6:	1c 97       	sbiw	r26, 0x0c	; 12
    f3c8:	81 93       	st	Z+, r24
    f3ca:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3cc:	e6 17       	cp	r30, r22
    f3ce:	f7 07       	cpc	r31, r23
    f3d0:	c1 f7       	brne	.-16     	; 0xf3c2 <StoreStandaloneTransData+0xde>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f3d2:	1d a2       	std	Y+37, r1	; 0x25
    f3d4:	f9 01       	movw	r30, r18
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3d6:	be 01       	movw	r22, r28
    f3d8:	69 5d       	subi	r22, 0xD9	; 217
    f3da:	7f 4f       	sbci	r23, 0xFF	; 255
    f3dc:	9e 01       	movw	r18, r28
    f3de:	21 5d       	subi	r18, 0xD1	; 209
    f3e0:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f3e2:	da 01       	movw	r26, r20
    f3e4:	54 96       	adiw	r26, 0x14	; 20
    f3e6:	8c 91       	ld	r24, X
    f3e8:	81 93       	st	Z+, r24
    f3ea:	4f 5f       	subi	r20, 0xFF	; 255
    f3ec:	5f 4f       	sbci	r21, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3ee:	e2 17       	cp	r30, r18
    f3f0:	f3 07       	cpc	r31, r19
    f3f2:	b9 f7       	brne	.-18     	; 0xf3e2 <StoreStandaloneTransData+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f3f4:	1f a6       	std	Y+47, r1	; 0x2f
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    f3f6:	f7 01       	movw	r30, r14
    f3f8:	84 8d       	ldd	r24, Z+28	; 0x1c
    f3fa:	80 53       	subi	r24, 0x30	; 48
    f3fc:	8a 30       	cpi	r24, 0x0A	; 10
    f3fe:	98 f4       	brcc	.+38     	; 0xf426 <StoreStandaloneTransData+0x142>

		 TransDigit=Ord(CharPosCopy(strRawTransData,28));
		 //Normalize7Digit
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //_uart_print(1,1,strSend);
		 if  (TransDigit==8){
    f400:	88 30       	cpi	r24, 0x08	; 8
    f402:	89 f4       	brne	.+34     	; 0xf426 <StoreStandaloneTransData+0x142>
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
    f404:	fb 01       	movw	r30, r22
    f406:	01 90       	ld	r0, Z+
    f408:	00 20       	and	r0, r0
    f40a:	e9 f7       	brne	.-6      	; 0xf406 <StoreStandaloneTransData+0x122>
    f40c:	e6 1b       	sub	r30, r22
    f40e:	f7 0b       	sbc	r31, r23
    f410:	32 97       	sbiw	r30, 0x02	; 2
    f412:	80 e0       	ldi	r24, 0x00	; 0
    f414:	90 e0       	ldi	r25, 0x00	; 0
    f416:	01 c0       	rjmp	.+2      	; 0xf41a <StoreStandaloneTransData+0x136>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f418:	01 96       	adiw	r24, 0x01	; 1
    f41a:	8e 17       	cp	r24, r30
    f41c:	9f 07       	cpc	r25, r31
    f41e:	e0 f3       	brcs	.-8      	; 0xf418 <StoreStandaloneTransData+0x134>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f420:	ec 0f       	add	r30, r28
    f422:	fd 1f       	adc	r31, r29
    f424:	17 a2       	std	Z+39, r1	; 0x27
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //_uart_print(1,1,strSend);
		 if  (TransDigit==8){
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
		 }
		 RemZeroLead(strPPU);
    f426:	64 e0       	ldi	r22, 0x04	; 4
    f428:	e6 2e       	mov	r14, r22
    f42a:	f1 2c       	mov	r15, r1
    f42c:	ec 0e       	add	r14, r28
    f42e:	fd 1e       	adc	r15, r29
    f430:	c7 01       	movw	r24, r14
    f432:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
		 RemZeroLead(strPVolume);
    f436:	5d e1       	ldi	r21, 0x1D	; 29
    f438:	a5 2e       	mov	r10, r21
    f43a:	b1 2c       	mov	r11, r1
    f43c:	ac 0e       	add	r10, r28
    f43e:	bd 1e       	adc	r11, r29
    f440:	c5 01       	movw	r24, r10
    f442:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
		 RemZeroLead(strPMoney);
    f446:	8e 01       	movw	r16, r28
    f448:	09 5d       	subi	r16, 0xD9	; 217
    f44a:	1f 4f       	sbci	r17, 0xFF	; 255
    f44c:	c8 01       	movw	r24, r16
    f44e:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
		 //sprintf_P(strSend,PSTR("Money: %s"),strPMoney);
		 //_uart_print(1,1,strSend);


		 //Void Detection
		 if (atoi(strPMoney)==0)TransactionStatus=TS_VOID;
    f452:	c8 01       	movw	r24, r16
    f454:	0e 94 3d b5 	call	0x16a7a	; 0x16a7a <atoi>
    f458:	89 2b       	or	r24, r25
    f45a:	09 f0       	breq	.+2      	; 0xf45e <StoreStandaloneTransData+0x17a>
    f45c:	46 c1       	rjmp	.+652    	; 0xf6ea <StoreStandaloneTransData+0x406>
		 else TransactionStatus=TS_NEW;
		 
		 if (TransactionStatus==TS_VOID){//RejectData
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
    f45e:	83 2d       	mov	r24, r3
    f460:	8f 70       	andi	r24, 0x0F	; 15
    f462:	63 e1       	ldi	r22, 0x13	; 19
    f464:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <UpdateStandaloneStatus>
    f468:	8b c1       	rjmp	.+790    	; 0xf780 <StoreStandaloneTransData+0x49c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f46a:	e1 99       	sbic	0x1c, 1	; 28
    f46c:	fe cf       	rjmp	.-4      	; 0xf46a <StoreStandaloneTransData+0x186>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f46e:	8f e3       	ldi	r24, 0x3F	; 63
    f470:	91 e0       	ldi	r25, 0x01	; 1
    f472:	9f bb       	out	0x1f, r25	; 31
    f474:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f476:	e0 9a       	sbi	0x1c, 0	; 28
    f478:	2d b3       	in	r18, 0x1d	; 29
			 //_uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    f47a:	00 d0       	rcall	.+0      	; 0xf47c <StoreStandaloneTransData+0x198>
    f47c:	00 d0       	rcall	.+0      	; 0xf47e <StoreStandaloneTransData+0x19a>
    f47e:	00 d0       	rcall	.+0      	; 0xf480 <StoreStandaloneTransData+0x19c>
    f480:	ed b7       	in	r30, 0x3d	; 61
    f482:	fe b7       	in	r31, 0x3e	; 62
    f484:	31 96       	adiw	r30, 0x01	; 1
    f486:	8b eb       	ldi	r24, 0xBB	; 187
    f488:	9f e0       	ldi	r25, 0x0F	; 15
    f48a:	ad b7       	in	r26, 0x3d	; 61
    f48c:	be b7       	in	r27, 0x3e	; 62
    f48e:	12 96       	adiw	r26, 0x02	; 2
    f490:	9c 93       	st	X, r25
    f492:	8e 93       	st	-X, r24
    f494:	11 97       	sbiw	r26, 0x01	; 1
    f496:	86 ec       	ldi	r24, 0xC6	; 198
    f498:	92 e2       	ldi	r25, 0x22	; 34
    f49a:	93 83       	std	Z+3, r25	; 0x03
    f49c:	82 83       	std	Z+2, r24	; 0x02
    f49e:	24 83       	std	Z+4, r18	; 0x04
    f4a0:	15 82       	std	Z+5, r1	; 0x05
    f4a2:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
    f4a6:	e9 ed       	ldi	r30, 0xD9	; 217
    f4a8:	ff e0       	ldi	r31, 0x0F	; 15
    f4aa:	df 01       	movw	r26, r30
    f4ac:	0d 90       	ld	r0, X+
    f4ae:	00 20       	and	r0, r0
    f4b0:	e9 f7       	brne	.-6      	; 0xf4ac <StoreStandaloneTransData+0x1c8>
    f4b2:	9d 01       	movw	r18, r26
    f4b4:	21 50       	subi	r18, 0x01	; 1
    f4b6:	30 40       	sbci	r19, 0x00	; 0
    f4b8:	2e 1b       	sub	r18, r30
    f4ba:	3f 0b       	sbc	r19, r31
    f4bc:	85 e3       	ldi	r24, 0x35	; 53
    f4be:	90 e0       	ldi	r25, 0x00	; 0
    f4c0:	c8 9e       	mul	r12, r24
    f4c2:	d0 01       	movw	r26, r0
    f4c4:	c9 9e       	mul	r12, r25
    f4c6:	b0 0d       	add	r27, r0
    f4c8:	d8 9e       	mul	r13, r24
    f4ca:	b0 0d       	add	r27, r0
    f4cc:	11 24       	eor	r1, r1
    f4ce:	a2 57       	subi	r26, 0x72	; 114
    f4d0:	b8 4f       	sbci	r27, 0xF8	; 248
    f4d2:	4d b7       	in	r20, 0x3d	; 61
    f4d4:	5e b7       	in	r21, 0x3e	; 62
    f4d6:	4a 5f       	subi	r20, 0xFA	; 250
    f4d8:	5f 4f       	sbci	r21, 0xFF	; 255
    f4da:	0f b6       	in	r0, 0x3f	; 63
    f4dc:	f8 94       	cli
    f4de:	5e bf       	out	0x3e, r21	; 62
    f4e0:	0f be       	out	0x3f, r0	; 63
    f4e2:	4d bf       	out	0x3d, r20	; 61
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f4e4:	a9 01       	movw	r20, r18
    f4e6:	4e 0f       	add	r20, r30
    f4e8:	5f 1f       	adc	r21, r31
    f4ea:	02 c0       	rjmp	.+4      	; 0xf4f0 <StoreStandaloneTransData+0x20c>
	    Dest[i]=Source[IdxSource+i];
    f4ec:	81 91       	ld	r24, Z+
    f4ee:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f4f0:	e4 17       	cp	r30, r20
    f4f2:	f5 07       	cpc	r31, r21
    f4f4:	d9 f7       	brne	.-10     	; 0xf4ec <StoreStandaloneTransData+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f4f6:	85 e3       	ldi	r24, 0x35	; 53
    f4f8:	90 e0       	ldi	r25, 0x00	; 0
    f4fa:	dc 01       	movw	r26, r24
    f4fc:	ca 9e       	mul	r12, r26
    f4fe:	c0 01       	movw	r24, r0
    f500:	cb 9e       	mul	r12, r27
    f502:	90 0d       	add	r25, r0
    f504:	da 9e       	mul	r13, r26
    f506:	90 0d       	add	r25, r0
    f508:	11 24       	eor	r1, r1
    f50a:	fc 01       	movw	r30, r24
    f50c:	e5 57       	subi	r30, 0x75	; 117
    f50e:	f8 4f       	sbci	r31, 0xF8	; 248
    f510:	e2 0f       	add	r30, r18
    f512:	f3 1f       	adc	r31, r19
    f514:	13 82       	std	Z+3, r1	; 0x03
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
    f516:	fe 01       	movw	r30, r28
    f518:	3b 96       	adiw	r30, 0x0b	; 11
    f51a:	df 01       	movw	r26, r30
    f51c:	0d 90       	ld	r0, X+
    f51e:	00 20       	and	r0, r0
    f520:	e9 f7       	brne	.-6      	; 0xf51c <StoreStandaloneTransData+0x238>
    f522:	11 97       	sbiw	r26, 0x01	; 1
    f524:	ae 1b       	sub	r26, r30
    f526:	bf 0b       	sbc	r27, r31
    f528:	bf 01       	movw	r22, r30
    f52a:	9c 01       	movw	r18, r24
    f52c:	2b 56       	subi	r18, 0x6B	; 107
    f52e:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f530:	af 01       	movw	r20, r30
    f532:	4a 0f       	add	r20, r26
    f534:	5b 1f       	adc	r21, r27
    f536:	06 c0       	rjmp	.+12     	; 0xf544 <StoreStandaloneTransData+0x260>
	    Dest[i]=Source[IdxSource+i];
    f538:	fb 01       	movw	r30, r22
    f53a:	81 91       	ld	r24, Z+
    f53c:	bf 01       	movw	r22, r30
    f53e:	f9 01       	movw	r30, r18
    f540:	81 93       	st	Z+, r24
    f542:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f544:	64 17       	cp	r22, r20
    f546:	75 07       	cpc	r23, r21
    f548:	b9 f7       	brne	.-18     	; 0xf538 <StoreStandaloneTransData+0x254>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f54a:	85 e3       	ldi	r24, 0x35	; 53
    f54c:	90 e0       	ldi	r25, 0x00	; 0
    f54e:	9c 01       	movw	r18, r24
    f550:	c2 9e       	mul	r12, r18
    f552:	c0 01       	movw	r24, r0
    f554:	c3 9e       	mul	r12, r19
    f556:	90 0d       	add	r25, r0
    f558:	d2 9e       	mul	r13, r18
    f55a:	90 0d       	add	r25, r0
    f55c:	11 24       	eor	r1, r1
    f55e:	fc 01       	movw	r30, r24
    f560:	e5 57       	subi	r30, 0x75	; 117
    f562:	f8 4f       	sbci	r31, 0xF8	; 248
    f564:	ea 0f       	add	r30, r26
    f566:	fb 1f       	adc	r31, r27
    f568:	12 86       	std	Z+10, r1	; 0x0a
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
    f56a:	fe 01       	movw	r30, r28
    f56c:	74 96       	adiw	r30, 0x14	; 20
    f56e:	df 01       	movw	r26, r30
    f570:	0d 90       	ld	r0, X+
    f572:	00 20       	and	r0, r0
    f574:	e9 f7       	brne	.-6      	; 0xf570 <StoreStandaloneTransData+0x28c>
    f576:	11 97       	sbiw	r26, 0x01	; 1
    f578:	ae 1b       	sub	r26, r30
    f57a:	bf 0b       	sbc	r27, r31
    f57c:	bf 01       	movw	r22, r30
    f57e:	9c 01       	movw	r18, r24
    f580:	22 56       	subi	r18, 0x62	; 98
    f582:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f584:	af 01       	movw	r20, r30
    f586:	4a 0f       	add	r20, r26
    f588:	5b 1f       	adc	r21, r27
    f58a:	06 c0       	rjmp	.+12     	; 0xf598 <StoreStandaloneTransData+0x2b4>
	    Dest[i]=Source[IdxSource+i];
    f58c:	fb 01       	movw	r30, r22
    f58e:	81 91       	ld	r24, Z+
    f590:	bf 01       	movw	r22, r30
    f592:	f9 01       	movw	r30, r18
    f594:	81 93       	st	Z+, r24
    f596:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f598:	64 17       	cp	r22, r20
    f59a:	75 07       	cpc	r23, r21
    f59c:	b9 f7       	brne	.-18     	; 0xf58c <StoreStandaloneTransData+0x2a8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f59e:	85 e3       	ldi	r24, 0x35	; 53
    f5a0:	90 e0       	ldi	r25, 0x00	; 0
    f5a2:	c8 9e       	mul	r12, r24
    f5a4:	70 01       	movw	r14, r0
    f5a6:	c9 9e       	mul	r12, r25
    f5a8:	f0 0c       	add	r15, r0
    f5aa:	d8 9e       	mul	r13, r24
    f5ac:	f0 0c       	add	r15, r0
    f5ae:	11 24       	eor	r1, r1
    f5b0:	87 01       	movw	r16, r14
    f5b2:	05 57       	subi	r16, 0x75	; 117
    f5b4:	18 4f       	sbci	r17, 0xF8	; 248
    f5b6:	a0 0f       	add	r26, r16
    f5b8:	b1 1f       	adc	r27, r17
    f5ba:	53 96       	adiw	r26, 0x13	; 19
    f5bc:	1c 92       	st	X, r1
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
			 //Grade Nozzle Shift
			 RecPumpData[FIPAddr].Grade=PGrade;
    f5be:	f0 ed       	ldi	r31, 0xD0	; 208
    f5c0:	2f 0e       	add	r2, r31
    f5c2:	d8 01       	movw	r26, r16
    f5c4:	2c 92       	st	X, r2
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
    f5c6:	b9 a9       	ldd	r27, Y+49	; 0x31
    f5c8:	b0 53       	subi	r27, 0x30	; 48
    f5ca:	f8 01       	movw	r30, r16
    f5cc:	b1 83       	std	Z+1, r27	; 0x01
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
    f5ce:	8b eb       	ldi	r24, 0xBB	; 187
    f5d0:	9f e0       	ldi	r25, 0x0F	; 15
    f5d2:	0e 94 3d b5 	call	0x16a7a	; 0x16a7a <atoi>
    f5d6:	d8 01       	movw	r26, r16
    f5d8:	12 96       	adiw	r26, 0x02	; 2
    f5da:	8c 93       	st	X, r24
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
    f5dc:	fe 01       	movw	r30, r28
    f5de:	34 96       	adiw	r30, 0x04	; 4
    f5e0:	df 01       	movw	r26, r30
    f5e2:	0d 90       	ld	r0, X+
    f5e4:	00 20       	and	r0, r0
    f5e6:	e9 f7       	brne	.-6      	; 0xf5e2 <StoreStandaloneTransData+0x2fe>
    f5e8:	11 97       	sbiw	r26, 0x01	; 1
    f5ea:	ae 1b       	sub	r26, r30
    f5ec:	bf 0b       	sbc	r27, r31
    f5ee:	97 01       	movw	r18, r14
    f5f0:	29 55       	subi	r18, 0x59	; 89
    f5f2:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f5f4:	af 01       	movw	r20, r30
    f5f6:	4a 0f       	add	r20, r26
    f5f8:	5b 1f       	adc	r21, r27
    f5fa:	06 c0       	rjmp	.+12     	; 0xf608 <StoreStandaloneTransData+0x324>
	    Dest[i]=Source[IdxSource+i];
    f5fc:	f4 01       	movw	r30, r8
    f5fe:	81 91       	ld	r24, Z+
    f600:	4f 01       	movw	r8, r30
    f602:	f9 01       	movw	r30, r18
    f604:	81 93       	st	Z+, r24
    f606:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f608:	84 16       	cp	r8, r20
    f60a:	95 06       	cpc	r9, r21
    f60c:	b9 f7       	brne	.-18     	; 0xf5fc <StoreStandaloneTransData+0x318>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f60e:	85 e3       	ldi	r24, 0x35	; 53
    f610:	90 e0       	ldi	r25, 0x00	; 0
    f612:	9c 01       	movw	r18, r24
    f614:	c2 9e       	mul	r12, r18
    f616:	c0 01       	movw	r24, r0
    f618:	c3 9e       	mul	r12, r19
    f61a:	90 0d       	add	r25, r0
    f61c:	d2 9e       	mul	r13, r18
    f61e:	90 0d       	add	r25, r0
    f620:	11 24       	eor	r1, r1
    f622:	fc 01       	movw	r30, r24
    f624:	e5 57       	subi	r30, 0x75	; 117
    f626:	f8 4f       	sbci	r31, 0xF8	; 248
    f628:	ea 0f       	add	r30, r26
    f62a:	fb 1f       	adc	r31, r27
    f62c:	14 8e       	std	Z+28, r1	; 0x1c
			 RecPumpData[FIPAddr].Grade=PGrade;
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
    f62e:	fe 01       	movw	r30, r28
    f630:	7d 96       	adiw	r30, 0x1d	; 29
    f632:	df 01       	movw	r26, r30
    f634:	0d 90       	ld	r0, X+
    f636:	00 20       	and	r0, r0
    f638:	e9 f7       	brne	.-6      	; 0xf634 <StoreStandaloneTransData+0x350>
    f63a:	11 97       	sbiw	r26, 0x01	; 1
    f63c:	ae 1b       	sub	r26, r30
    f63e:	bf 0b       	sbc	r27, r31
    f640:	9c 01       	movw	r18, r24
    f642:	22 55       	subi	r18, 0x52	; 82
    f644:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f646:	af 01       	movw	r20, r30
    f648:	4a 0f       	add	r20, r26
    f64a:	5b 1f       	adc	r21, r27
    f64c:	06 c0       	rjmp	.+12     	; 0xf65a <StoreStandaloneTransData+0x376>
	    Dest[i]=Source[IdxSource+i];
    f64e:	f3 01       	movw	r30, r6
    f650:	81 91       	ld	r24, Z+
    f652:	3f 01       	movw	r6, r30
    f654:	f9 01       	movw	r30, r18
    f656:	81 93       	st	Z+, r24
    f658:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f65a:	64 16       	cp	r6, r20
    f65c:	75 06       	cpc	r7, r21
    f65e:	b9 f7       	brne	.-18     	; 0xf64e <StoreStandaloneTransData+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f660:	85 e3       	ldi	r24, 0x35	; 53
    f662:	90 e0       	ldi	r25, 0x00	; 0
    f664:	9c 01       	movw	r18, r24
    f666:	c2 9e       	mul	r12, r18
    f668:	c0 01       	movw	r24, r0
    f66a:	c3 9e       	mul	r12, r19
    f66c:	90 0d       	add	r25, r0
    f66e:	d2 9e       	mul	r13, r18
    f670:	90 0d       	add	r25, r0
    f672:	11 24       	eor	r1, r1
    f674:	fc 01       	movw	r30, r24
    f676:	e5 57       	subi	r30, 0x75	; 117
    f678:	f8 4f       	sbci	r31, 0xF8	; 248
    f67a:	ea 0f       	add	r30, r26
    f67c:	fb 1f       	adc	r31, r27
    f67e:	13 a2       	std	Z+35, r1	; 0x23
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));
    f680:	fe 01       	movw	r30, r28
    f682:	b7 96       	adiw	r30, 0x27	; 39
    f684:	df 01       	movw	r26, r30
    f686:	0d 90       	ld	r0, X+
    f688:	00 20       	and	r0, r0
    f68a:	e9 f7       	brne	.-6      	; 0xf686 <StoreStandaloneTransData+0x3a2>
    f68c:	11 97       	sbiw	r26, 0x01	; 1
    f68e:	ae 1b       	sub	r26, r30
    f690:	bf 0b       	sbc	r27, r31
    f692:	9c 01       	movw	r18, r24
    f694:	29 54       	subi	r18, 0x49	; 73
    f696:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f698:	af 01       	movw	r20, r30
    f69a:	4a 0f       	add	r20, r26
    f69c:	5b 1f       	adc	r21, r27
    f69e:	06 c0       	rjmp	.+12     	; 0xf6ac <StoreStandaloneTransData+0x3c8>
	    Dest[i]=Source[IdxSource+i];
    f6a0:	f2 01       	movw	r30, r4
    f6a2:	81 91       	ld	r24, Z+
    f6a4:	2f 01       	movw	r4, r30
    f6a6:	f9 01       	movw	r30, r18
    f6a8:	81 93       	st	Z+, r24
    f6aa:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f6ac:	44 16       	cp	r4, r20
    f6ae:	55 06       	cpc	r5, r21
    f6b0:	b9 f7       	brne	.-18     	; 0xf6a0 <StoreStandaloneTransData+0x3bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f6b2:	85 e3       	ldi	r24, 0x35	; 53
    f6b4:	90 e0       	ldi	r25, 0x00	; 0
    f6b6:	c8 9e       	mul	r12, r24
    f6b8:	f0 01       	movw	r30, r0
    f6ba:	c9 9e       	mul	r12, r25
    f6bc:	f0 0d       	add	r31, r0
    f6be:	d8 9e       	mul	r13, r24
    f6c0:	f0 0d       	add	r31, r0
    f6c2:	11 24       	eor	r1, r1
    f6c4:	e5 57       	subi	r30, 0x75	; 117
    f6c6:	f8 4f       	sbci	r31, 0xF8	; 248
    f6c8:	ea 0f       	add	r30, r26
    f6ca:	fb 1f       	adc	r31, r27
    f6cc:	14 a6       	std	Z+44, r1	; 0x2c
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));

			 UpdateStandaloneStatus((iPumpID&0x0F),PS_PRINT_READY);
    f6ce:	83 2d       	mov	r24, r3
    f6d0:	8f 70       	andi	r24, 0x0F	; 15
    f6d2:	60 e1       	ldi	r22, 0x10	; 16
    f6d4:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <UpdateStandaloneStatus>
			 
			 SetIncomingTransStatus(iPumpID,TS_NEW);		 
    f6d8:	83 2d       	mov	r24, r3
    f6da:	62 e0       	ldi	r22, 0x02	; 2
    f6dc:	0e 94 ad 1a 	call	0x355a	; 0x355a <SetIncomingTransStatus>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
    f6e0:	8b e0       	ldi	r24, 0x0B	; 11
    f6e2:	63 2d       	mov	r22, r3
    f6e4:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
    f6e8:	4b c0       	rjmp	.+150    	; 0xf780 <StoreStandaloneTransData+0x49c>
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
		 }
		 else 
		 if (TransactionStatus=TS_NEW){ 
			 //Update ReprintReady
			 ReprintReady[FIPAddr]=True;//Ready for Printing
    f6ea:	da 94       	dec	r13
    f6ec:	cd 2c       	mov	r12, r13
    f6ee:	dd 24       	eor	r13, r13
    f6f0:	f6 01       	movw	r30, r12
    f6f2:	ee 57       	subi	r30, 0x7E	; 126
    f6f4:	fe 4f       	sbci	r31, 0xFE	; 254
    f6f6:	81 e0       	ldi	r24, 0x01	; 1
    f6f8:	80 83       	st	Z, r24
			  
			 FormatPrice(strPPU);
    f6fa:	c7 01       	movw	r24, r14
    f6fc:	0e 94 11 35 	call	0x6a22	; 0x6a22 <FormatPrice>
			 FormatMoney(strPMoney);
    f700:	c8 01       	movw	r24, r16
    f702:	0e 94 04 35 	call	0x6a08	; 0x6a08 <FormatMoney>
			 FormatVolume(strPVolume);
    f706:	c5 01       	movw	r24, r10
    f708:	0e 94 f7 34 	call	0x69ee	; 0x69ee <FormatVolume>

			 //_uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
    f70c:	89 ed       	ldi	r24, 0xD9	; 217
    f70e:	9f e0       	ldi	r25, 0x0F	; 15
    f710:	0e 94 7b 40 	call	0x80f6	; 0x80f6 <GenerateTransactionNum>
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
    f714:	00 d0       	rcall	.+0      	; 0xf716 <StoreStandaloneTransData+0x432>
    f716:	00 d0       	rcall	.+0      	; 0xf718 <StoreStandaloneTransData+0x434>
    f718:	00 d0       	rcall	.+0      	; 0xf71a <StoreStandaloneTransData+0x436>
    f71a:	ed b7       	in	r30, 0x3d	; 61
    f71c:	fe b7       	in	r31, 0x3e	; 62
    f71e:	31 96       	adiw	r30, 0x01	; 1
    f720:	ce 01       	movw	r24, r28
    f722:	0b 96       	adiw	r24, 0x0b	; 11
    f724:	ad b7       	in	r26, 0x3d	; 61
    f726:	be b7       	in	r27, 0x3e	; 62
    f728:	12 96       	adiw	r26, 0x02	; 2
    f72a:	9c 93       	st	X, r25
    f72c:	8e 93       	st	-X, r24
    f72e:	11 97       	sbiw	r26, 0x01	; 1
    f730:	8c ec       	ldi	r24, 0xCC	; 204
    f732:	92 e2       	ldi	r25, 0x22	; 34
    f734:	93 83       	std	Z+3, r25	; 0x03
    f736:	82 83       	std	Z+2, r24	; 0x02
    f738:	8a e9       	ldi	r24, 0x9A	; 154
    f73a:	95 e0       	ldi	r25, 0x05	; 5
    f73c:	95 83       	std	Z+5, r25	; 0x05
    f73e:	84 83       	std	Z+4, r24	; 0x04
    f740:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
    f744:	ed b7       	in	r30, 0x3d	; 61
    f746:	fe b7       	in	r31, 0x3e	; 62
    f748:	31 96       	adiw	r30, 0x01	; 1
    f74a:	ce 01       	movw	r24, r28
    f74c:	44 96       	adiw	r24, 0x14	; 20
    f74e:	ad b7       	in	r26, 0x3d	; 61
    f750:	be b7       	in	r27, 0x3e	; 62
    f752:	12 96       	adiw	r26, 0x02	; 2
    f754:	9c 93       	st	X, r25
    f756:	8e 93       	st	-X, r24
    f758:	11 97       	sbiw	r26, 0x01	; 1
    f75a:	89 ec       	ldi	r24, 0xC9	; 201
    f75c:	92 e2       	ldi	r25, 0x22	; 34
    f75e:	93 83       	std	Z+3, r25	; 0x03
    f760:	82 83       	std	Z+2, r24	; 0x02
    f762:	8d e1       	ldi	r24, 0x1D	; 29
    f764:	9c e0       	ldi	r25, 0x0C	; 12
    f766:	95 83       	std	Z+5, r25	; 0x05
    f768:	84 83       	std	Z+4, r24	; 0x04
    f76a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    f76e:	ed b7       	in	r30, 0x3d	; 61
    f770:	fe b7       	in	r31, 0x3e	; 62
    f772:	36 96       	adiw	r30, 0x06	; 6
    f774:	0f b6       	in	r0, 0x3f	; 63
    f776:	f8 94       	cli
    f778:	fe bf       	out	0x3e, r31	; 62
    f77a:	0f be       	out	0x3f, r0	; 63
    f77c:	ed bf       	out	0x3d, r30	; 61
    f77e:	75 ce       	rjmp	.-790    	; 0xf46a <StoreStandaloneTransData+0x186>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
		 }		 
	 }    
     //_uart_print(0,1,strRawTransData);
}
    f780:	e1 96       	adiw	r28, 0x31	; 49
    f782:	0f b6       	in	r0, 0x3f	; 63
    f784:	f8 94       	cli
    f786:	de bf       	out	0x3e, r29	; 62
    f788:	0f be       	out	0x3f, r0	; 63
    f78a:	cd bf       	out	0x3d, r28	; 61
    f78c:	cf 91       	pop	r28
    f78e:	df 91       	pop	r29
    f790:	1f 91       	pop	r17
    f792:	0f 91       	pop	r16
    f794:	ff 90       	pop	r15
    f796:	ef 90       	pop	r14
    f798:	df 90       	pop	r13
    f79a:	cf 90       	pop	r12
    f79c:	bf 90       	pop	r11
    f79e:	af 90       	pop	r10
    f7a0:	9f 90       	pop	r9
    f7a2:	8f 90       	pop	r8
    f7a4:	7f 90       	pop	r7
    f7a6:	6f 90       	pop	r6
    f7a8:	5f 90       	pop	r5
    f7aa:	4f 90       	pop	r4
    f7ac:	3f 90       	pop	r3
    f7ae:	2f 90       	pop	r2
    f7b0:	08 95       	ret

0000f7b2 <StoreStandaloneTotalizerData>:
	  systemEDC();
	  systemConfigProtocol();
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}

void StoreStandaloneTotalizerData(char *strRawTransData){//Sending FlowSPI_Protocol <STX>   [MsgID][PumpID][Volume1][Amount1][Volume2][Amount2][Volume3][Amount3][Volume4][Amount4][Volume5][Amount5][Volume6][Amount6]<ETX>
    f7b2:	2f 92       	push	r2
    f7b4:	3f 92       	push	r3
    f7b6:	4f 92       	push	r4
    f7b8:	5f 92       	push	r5
    f7ba:	7f 92       	push	r7
    f7bc:	8f 92       	push	r8
    f7be:	9f 92       	push	r9
    f7c0:	af 92       	push	r10
    f7c2:	bf 92       	push	r11
    f7c4:	cf 92       	push	r12
    f7c6:	df 92       	push	r13
    f7c8:	ef 92       	push	r14
    f7ca:	ff 92       	push	r15
    f7cc:	0f 93       	push	r16
    f7ce:	1f 93       	push	r17
    f7d0:	df 93       	push	r29
    f7d2:	cf 93       	push	r28
    f7d4:	cd b7       	in	r28, 0x3d	; 61
    f7d6:	de b7       	in	r29, 0x3e	; 62
    f7d8:	a1 97       	sbiw	r28, 0x21	; 33
    f7da:	0f b6       	in	r0, 0x3f	; 63
    f7dc:	f8 94       	cli
    f7de:	de bf       	out	0x3e, r29	; 62
    f7e0:	0f be       	out	0x3f, r0	; 63
    f7e2:	cd bf       	out	0x3d, r28	; 61
    f7e4:	8c 01       	movw	r16, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f7e6:	fc 01       	movw	r30, r24
    f7e8:	82 81       	ldd	r24, Z+2	; 0x02
    f7ea:	89 83       	std	Y+1, r24	; 0x01
    f7ec:	83 81       	ldd	r24, Z+3	; 0x03
    f7ee:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    f7f0:	1b 82       	std	Y+3, r1	; 0x03
	 //    _uart(1,1,strRawTransData[i]); 
	 // }

     StrPosCopy(strRawTransData,strPumpID,2,2);
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
    f7f2:	ce 01       	movw	r24, r28
    f7f4:	01 96       	adiw	r24, 0x01	; 1
    f7f6:	0e 94 3d b5 	call	0x16a7a	; 0x16a7a <atoi>
    f7fa:	c8 2e       	mov	r12, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    f7fc:	0e 94 dd 1d 	call	0x3bba	; 0x3bba <GetFIPAddr>
	 if (FIPAddr>0){
    f800:	88 23       	and	r24, r24
    f802:	09 f4       	brne	.+2      	; 0xf806 <StoreStandaloneTotalizerData+0x54>
    f804:	44 c0       	rjmp	.+136    	; 0xf88e <StoreStandaloneTotalizerData+0xdc>
	     FIPAddr=FIPAddr-1;
    f806:	78 2e       	mov	r7, r24
    f808:	7a 94       	dec	r7
    f80a:	80 e1       	ldi	r24, 0x10	; 16
    f80c:	e8 2e       	mov	r14, r24
    f80e:	f1 2c       	mov	r15, r1
    f810:	e0 0e       	add	r14, r16
    f812:	f1 1e       	adc	r15, r17
    f814:	dd 24       	eor	r13, r13
    f816:	d3 94       	inc	r13
    f818:	14 e0       	ldi	r17, 0x04	; 4
    f81a:	81 2e       	mov	r8, r17
    f81c:	91 2c       	mov	r9, r1
    f81e:	8c 0e       	add	r8, r28
    f820:	9d 1e       	adc	r9, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f822:	b0 e1       	ldi	r27, 0x10	; 16
    f824:	2b 2e       	mov	r2, r27
    f826:	31 2c       	mov	r3, r1
    f828:	2c 0e       	add	r2, r28
    f82a:	3d 1e       	adc	r3, r29
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f82c:	a3 e1       	ldi	r26, 0x13	; 19
    f82e:	aa 2e       	mov	r10, r26
    f830:	b1 2c       	mov	r11, r1
    f832:	ac 0e       	add	r10, r28
    f834:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f836:	ff e1       	ldi	r31, 0x1F	; 31
    f838:	4f 2e       	mov	r4, r31
    f83a:	51 2c       	mov	r5, r1
    f83c:	4c 0e       	add	r4, r28
    f83e:	5d 1e       	adc	r5, r29
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
	 
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
    f840:	d7 01       	movw	r26, r14
    f842:	1c 97       	sbiw	r26, 0x0c	; 12
    f844:	f4 01       	movw	r30, r8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f846:	8d 91       	ld	r24, X+
    f848:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f84a:	e2 15       	cp	r30, r2
    f84c:	f3 05       	cpc	r31, r3
    f84e:	d9 f7       	brne	.-10     	; 0xf846 <StoreStandaloneTotalizerData+0x94>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f850:	18 8a       	std	Y+16, r1	; 0x10
    f852:	f5 01       	movw	r30, r10
    f854:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f856:	8d 91       	ld	r24, X+
    f858:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f85a:	e4 15       	cp	r30, r4
    f85c:	f5 05       	cpc	r31, r5
    f85e:	d9 f7       	brne	.-10     	; 0xf856 <StoreStandaloneTotalizerData+0xa4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f860:	1f 8e       	std	Y+31, r1	; 0x1f

		 for (iGrade=1;iGrade<=6;iGrade++){          
			  StrPosCopy(strRawTransData,strGVolume,(4+((iGrade-1)*24)),12);
			  StrPosCopy(strRawTransData,strGMoney,(16+((iGrade-1)*24)),12);
			  
			  SetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strGVolume);
    f862:	80 e0       	ldi	r24, 0x00	; 0
    f864:	61 e0       	ldi	r22, 0x01	; 1
    f866:	47 2d       	mov	r20, r7
    f868:	2d 2d       	mov	r18, r13
    f86a:	84 01       	movw	r16, r8
    f86c:	0e 94 48 28 	call	0x5090	; 0x5090 <SetTotalizerData>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
    f870:	81 e0       	ldi	r24, 0x01	; 1
    f872:	61 e0       	ldi	r22, 0x01	; 1
    f874:	47 2d       	mov	r20, r7
    f876:	2d 2d       	mov	r18, r13
    f878:	85 01       	movw	r16, r10
    f87a:	0e 94 48 28 	call	0x5090	; 0x5090 <SetTotalizerData>
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
		 //_uart_printf(1,1,PSTR("Totalizer:"));

		 for (iGrade=1;iGrade<=6;iGrade++){          
    f87e:	d3 94       	inc	r13
    f880:	88 e1       	ldi	r24, 0x18	; 24
    f882:	90 e0       	ldi	r25, 0x00	; 0
    f884:	e8 0e       	add	r14, r24
    f886:	f9 1e       	adc	r15, r25
    f888:	97 e0       	ldi	r25, 0x07	; 7
    f88a:	d9 16       	cp	r13, r25
    f88c:	c9 f6       	brne	.-78     	; 0xf840 <StoreStandaloneTotalizerData+0x8e>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
			  //sprintf_P(strSend,PSTR("Nozzle:%d Volume:%s Money:%s"),iGrade,strGVolume,strGMoney);
			  //_uart_print(0,1,strSend);
		 }	
	}
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
    f88e:	8d e0       	ldi	r24, 0x0D	; 13
    f890:	6c 2d       	mov	r22, r12
    f892:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
    f896:	8c 2d       	mov	r24, r12
    f898:	8f 70       	andi	r24, 0x0F	; 15
    f89a:	64 e1       	ldi	r22, 0x14	; 20
    f89c:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <UpdateStandaloneStatus>
}
    f8a0:	a1 96       	adiw	r28, 0x21	; 33
    f8a2:	0f b6       	in	r0, 0x3f	; 63
    f8a4:	f8 94       	cli
    f8a6:	de bf       	out	0x3e, r29	; 62
    f8a8:	0f be       	out	0x3f, r0	; 63
    f8aa:	cd bf       	out	0x3d, r28	; 61
    f8ac:	cf 91       	pop	r28
    f8ae:	df 91       	pop	r29
    f8b0:	1f 91       	pop	r17
    f8b2:	0f 91       	pop	r16
    f8b4:	ff 90       	pop	r15
    f8b6:	ef 90       	pop	r14
    f8b8:	df 90       	pop	r13
    f8ba:	cf 90       	pop	r12
    f8bc:	bf 90       	pop	r11
    f8be:	af 90       	pop	r10
    f8c0:	9f 90       	pop	r9
    f8c2:	8f 90       	pop	r8
    f8c4:	7f 90       	pop	r7
    f8c6:	5f 90       	pop	r5
    f8c8:	4f 90       	pop	r4
    f8ca:	3f 90       	pop	r3
    f8cc:	2f 90       	pop	r2
    f8ce:	08 95       	ret

0000f8d0 <ScanStandaloneFlow>:
	 _spi(SlaveMessage);
	 _spi(0x06);
	 systemSlave();
}

void ScanStandaloneFlow(char data){  //<STX>[PumpID][STA]<ETX> --> 0x07 0xF1 0xF2 0x08
    f8d0:	0f 93       	push	r16
    f8d2:	1f 93       	push	r17
    f8d4:	08 2f       	mov	r16, r24

      DataPumpID=0;
      DataPumpStatus=0;
	  MixData=0;
      //Shift data
      zDataFlow[4]=zDataFlow[3];
    f8d6:	80 91 b7 03 	lds	r24, 0x03B7
    f8da:	80 93 b8 03 	sts	0x03B8, r24
	  zDataFlow[3]=zDataFlow[2];
    f8de:	80 91 b6 03 	lds	r24, 0x03B6
    f8e2:	80 93 b7 03 	sts	0x03B7, r24
	  zDataFlow[2]=zDataFlow[1];
    f8e6:	80 91 b5 03 	lds	r24, 0x03B5
    f8ea:	80 93 b6 03 	sts	0x03B6, r24
      zDataFlow[1]=zDataFlow[0];
    f8ee:	90 91 b4 03 	lds	r25, 0x03B4
    f8f2:	90 93 b5 03 	sts	0x03B5, r25
      zDataFlow[0]=data;
    f8f6:	00 93 b4 03 	sts	0x03B4, r16

      //Scan UpdatedPumpStatus Flow
	  //<STX>[ID][STA]<ETX>: 0x07[ID STA]0x08
	  if((zDataFlow[2]==0x07)&&(zDataFlow[0]==0x08)){
    f8fa:	87 30       	cpi	r24, 0x07	; 7
    f8fc:	79 f4       	brne	.+30     	; 0xf91c <ScanStandaloneFlow+0x4c>
    f8fe:	08 30       	cpi	r16, 0x08	; 8
    f900:	69 f4       	brne	.+26     	; 0xf91c <ScanStandaloneFlow+0x4c>
          MixData=zDataFlow[1];
	      DataPumpID=((MixData&0xF0)>>4);
		  DataPumpStatus=(MixData&0x0F);
    f902:	19 2f       	mov	r17, r25
    f904:	1f 70       	andi	r17, 0x0F	; 15
		  UpdateStandaloneStatus(DataPumpID,DataPumpStatus);
    f906:	89 2f       	mov	r24, r25
    f908:	82 95       	swap	r24
    f90a:	8f 70       	andi	r24, 0x0F	; 15
    f90c:	61 2f       	mov	r22, r17
    f90e:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <UpdateStandaloneStatus>
		  if (DataPumpStatus!=PUMP_NONE)IsStandAloneDetected=True;
    f912:	1e 30       	cpi	r17, 0x0E	; 14
    f914:	19 f0       	breq	.+6      	; 0xf91c <ScanStandaloneFlow+0x4c>
    f916:	81 e0       	ldi	r24, 0x01	; 1
    f918:	80 93 b3 01 	sts	0x01B3, r24
		  //sprintf_P(strSend,PSTR("PS:%d Id:%d"),MixData,DataPumpID);
		  //_uart_print(0,1,strSend);
	  }

	  //Scan Transaction Completion FEOT
	  if (IsStandaloneTrans==True){
    f91c:	80 91 b4 01 	lds	r24, 0x01B4
    f920:	81 30       	cpi	r24, 0x01	; 1
    f922:	69 f4       	brne	.+26     	; 0xf93e <ScanStandaloneFlow+0x6e>
	      strStandReceived[iFlow]=data;
    f924:	80 91 b2 03 	lds	r24, 0x03B2
    f928:	90 91 b3 03 	lds	r25, 0x03B3
    f92c:	fc 01       	movw	r30, r24
    f92e:	ea 51       	subi	r30, 0x1A	; 26
    f930:	fb 4f       	sbci	r31, 0xFB	; 251
    f932:	00 83       	st	Z, r16
		  iFlow++;
    f934:	01 96       	adiw	r24, 0x01	; 1
    f936:	90 93 b3 03 	sts	0x03B3, r25
    f93a:	80 93 b2 03 	sts	0x03B2, r24
	  }
	  if((zDataFlow[1]==0x05)&&(zDataFlow[0]==0x50)){
    f93e:	80 91 b5 03 	lds	r24, 0x03B5
    f942:	85 30       	cpi	r24, 0x05	; 5
    f944:	61 f4       	brne	.+24     	; 0xf95e <ScanStandaloneFlow+0x8e>
    f946:	80 91 b4 03 	lds	r24, 0x03B4
    f94a:	80 35       	cpi	r24, 0x50	; 80
    f94c:	41 f5       	brne	.+80     	; 0xf99e <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=True;
    f94e:	81 e0       	ldi	r24, 0x01	; 1
    f950:	80 93 b4 01 	sts	0x01B4, r24
		  iFlow=0;
    f954:	10 92 b3 03 	sts	0x03B3, r1
    f958:	10 92 b2 03 	sts	0x03B2, r1
    f95c:	20 c0       	rjmp	.+64     	; 0xf99e <ScanStandaloneFlow+0xce>
	  }
	  if((zDataFlow[1]==0x06)&&(zDataFlow[0]==0x60)){
    f95e:	86 30       	cpi	r24, 0x06	; 6
    f960:	f1 f4       	brne	.+60     	; 0xf99e <ScanStandaloneFlow+0xce>
    f962:	80 91 b4 03 	lds	r24, 0x03B4
    f966:	80 36       	cpi	r24, 0x60	; 96
    f968:	d1 f4       	brne	.+52     	; 0xf99e <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=False;
    f96a:	10 92 b4 01 	sts	0x01B4, r1
	      strStandReceived[iFlow]=0;
    f96e:	e0 91 b2 03 	lds	r30, 0x03B2
    f972:	f0 91 b3 03 	lds	r31, 0x03B3
    f976:	ea 51       	subi	r30, 0x1A	; 26
    f978:	fb 4f       	sbci	r31, 0xFB	; 251
    f97a:	10 82       	st	Z, r1

		  //_uart_print(1,1,strStandReceived);

		  MsgIDx=GetMessageID(strStandReceived);
    f97c:	86 ee       	ldi	r24, 0xE6	; 230
    f97e:	94 e0       	ldi	r25, 0x04	; 4
    f980:	0e 94 d0 44 	call	0x89a0	; 0x89a0 <GetMessageID>
          if (MsgIDx==0x01)StoreStandaloneTransData(strStandReceived);
    f984:	81 30       	cpi	r24, 0x01	; 1
    f986:	29 f4       	brne	.+10     	; 0xf992 <ScanStandaloneFlow+0xc2>
    f988:	86 ee       	ldi	r24, 0xE6	; 230
    f98a:	94 e0       	ldi	r25, 0x04	; 4
    f98c:	0e 94 72 79 	call	0xf2e4	; 0xf2e4 <StoreStandaloneTransData>
    f990:	06 c0       	rjmp	.+12     	; 0xf99e <ScanStandaloneFlow+0xce>
		  else
          if (MsgIDx==0x02)StoreStandaloneTotalizerData(strStandReceived);
    f992:	82 30       	cpi	r24, 0x02	; 2
    f994:	21 f4       	brne	.+8      	; 0xf99e <ScanStandaloneFlow+0xce>
    f996:	86 ee       	ldi	r24, 0xE6	; 230
    f998:	94 e0       	ldi	r25, 0x04	; 4
    f99a:	0e 94 d9 7b 	call	0xf7b2	; 0xf7b2 <StoreStandaloneTotalizerData>
	  }
	  //AcknoledgeCommand
	  if ((zDataFlow[3]==0x09)&&(zDataFlow[0]==0x0A)){
    f99e:	80 91 b7 03 	lds	r24, 0x03B7
    f9a2:	89 30       	cpi	r24, 0x09	; 9
    f9a4:	c1 f5       	brne	.+112    	; 0xfa16 <ScanStandaloneFlow+0x146>
    f9a6:	80 91 b4 03 	lds	r24, 0x03B4
    f9aa:	8a 30       	cpi	r24, 0x0A	; 10
    f9ac:	a1 f5       	brne	.+104    	; 0xfa16 <ScanStandaloneFlow+0x146>
	      
	      AcknoledgePump=zDataFlow[1];
    f9ae:	90 91 b5 03 	lds	r25, 0x03B5
    f9b2:	90 93 3f 0f 	sts	0x0F3F, r25
	      AcknoledgeCommand=zDataFlow[2];	  
    f9b6:	80 91 b6 03 	lds	r24, 0x03B6
    f9ba:	80 93 80 07 	sts	0x0780, r24
		  switch(AcknoledgeCommand){
    f9be:	89 31       	cpi	r24, 0x19	; 25
    f9c0:	51 f0       	breq	.+20     	; 0xf9d6 <ScanStandaloneFlow+0x106>
    f9c2:	8a 31       	cpi	r24, 0x1A	; 26
    f9c4:	18 f4       	brcc	.+6      	; 0xf9cc <ScanStandaloneFlow+0xfc>
    f9c6:	85 30       	cpi	r24, 0x05	; 5
    f9c8:	19 f5       	brne	.+70     	; 0xfa10 <ScanStandaloneFlow+0x140>
    f9ca:	17 c0       	rjmp	.+46     	; 0xf9fa <ScanStandaloneFlow+0x12a>
    f9cc:	8a 31       	cpi	r24, 0x1A	; 26
    f9ce:	c9 f0       	breq	.+50     	; 0xfa02 <ScanStandaloneFlow+0x132>
    f9d0:	8c 31       	cpi	r24, 0x1C	; 28
    f9d2:	f1 f4       	brne	.+60     	; 0xfa10 <ScanStandaloneFlow+0x140>
    f9d4:	1a c0       	rjmp	.+52     	; 0xfa0a <ScanStandaloneFlow+0x13a>
		  case SC_LIVE_SEQUENCE:
		       iSequencePooling=AcknoledgePump;
    f9d6:	90 93 93 01 	sts	0x0193, r25
			   IsNewPoolingSequence=True;
    f9da:	81 e0       	ldi	r24, 0x01	; 1
    f9dc:	80 93 94 01 	sts	0x0194, r24
			   //SendPoolingCommand()
			   if (IsControlPooling==True){
    f9e0:	80 91 97 01 	lds	r24, 0x0197
    f9e4:	81 30       	cpi	r24, 0x01	; 1
    f9e6:	a1 f4       	brne	.+40     	; 0xfa10 <ScanStandaloneFlow+0x140>
			       IsControlPooling=False;
    f9e8:	10 92 97 01 	sts	0x0197, r1
				   SendSlaveCommand(PoolCmd,PoolMsg);
    f9ec:	80 91 8a 07 	lds	r24, 0x078A
    f9f0:	60 91 3c 0f 	lds	r22, 0x0F3C
    f9f4:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
    f9f8:	0b c0       	rjmp	.+22     	; 0xfa10 <ScanStandaloneFlow+0x140>
                }
		       break;
          case SC_TOTALIZER:
		       IsTotalizerReceived=True;
    f9fa:	81 e0       	ldi	r24, 0x01	; 1
    f9fc:	80 93 c5 01 	sts	0x01C5, r24
    fa00:	07 c0       	rjmp	.+14     	; 0xfa10 <ScanStandaloneFlow+0x140>
		       break;
		  case SC_POOL_RESTARTED:
		       IsPoolingRestarted=True;
    fa02:	81 e0       	ldi	r24, 0x01	; 1
    fa04:	80 93 96 01 	sts	0x0196, r24
    fa08:	03 c0       	rjmp	.+6      	; 0xfa10 <ScanStandaloneFlow+0x140>
		       break;
          case SC_SET_PUMP_TYPE:
		       IsSetPumpType=True;
    fa0a:	81 e0       	ldi	r24, 0x01	; 1
    fa0c:	80 93 23 01 	sts	0x0123, r24
		       break;
		  }
       IsStandaloneAcknoledge=True;
    fa10:	81 e0       	ldi	r24, 0x01	; 1
    fa12:	80 93 95 01 	sts	0x0195, r24
	  }
}
    fa16:	1f 91       	pop	r17
    fa18:	0f 91       	pop	r16
    fa1a:	08 95       	ret

0000fa1c <__vector_17>:
//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  _uart_print(1,0,SerialSend);
	 }
}

ISR(SPI_STC_vect){
    fa1c:	1f 92       	push	r1
    fa1e:	0f 92       	push	r0
    fa20:	0f b6       	in	r0, 0x3f	; 63
    fa22:	0f 92       	push	r0
    fa24:	0b b6       	in	r0, 0x3b	; 59
    fa26:	0f 92       	push	r0
    fa28:	11 24       	eor	r1, r1
    fa2a:	1f 93       	push	r17
    fa2c:	2f 93       	push	r18
    fa2e:	3f 93       	push	r19
    fa30:	4f 93       	push	r20
    fa32:	5f 93       	push	r21
    fa34:	6f 93       	push	r22
    fa36:	7f 93       	push	r23
    fa38:	8f 93       	push	r24
    fa3a:	9f 93       	push	r25
    fa3c:	af 93       	push	r26
    fa3e:	bf 93       	push	r27
    fa40:	ef 93       	push	r30
    fa42:	ff 93       	push	r31
char dataSPI;
//char Reply=0;
    //_uart(0,1,SPDR);
	dataSPI=SPDR;
    fa44:	1f b1       	in	r17, 0x0f	; 15
	ScanRFIDFlow(dataSPI);
    fa46:	81 2f       	mov	r24, r17
    fa48:	0e 94 94 14 	call	0x2928	; 0x2928 <ScanRFIDFlow>
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
    fa4c:	80 91 10 01 	lds	r24, 0x0110
    fa50:	81 30       	cpi	r24, 0x01	; 1
    fa52:	21 f4       	brne	.+8      	; 0xfa5c <__vector_17+0x40>
    fa54:	81 2f       	mov	r24, r17
    fa56:	0e 94 d2 13 	call	0x27a4	; 0x27a4 <ScanEDCFlow>
    fa5a:	05 c0       	rjmp	.+10     	; 0xfa66 <__vector_17+0x4a>
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
    fa5c:	82 30       	cpi	r24, 0x02	; 2
    fa5e:	19 f4       	brne	.+6      	; 0xfa66 <__vector_17+0x4a>
    fa60:	81 2f       	mov	r24, r17
    fa62:	0e 94 68 7c 	call	0xf8d0	; 0xf8d0 <ScanStandaloneFlow>
}
    fa66:	ff 91       	pop	r31
    fa68:	ef 91       	pop	r30
    fa6a:	bf 91       	pop	r27
    fa6c:	af 91       	pop	r26
    fa6e:	9f 91       	pop	r25
    fa70:	8f 91       	pop	r24
    fa72:	7f 91       	pop	r23
    fa74:	6f 91       	pop	r22
    fa76:	5f 91       	pop	r21
    fa78:	4f 91       	pop	r20
    fa7a:	3f 91       	pop	r19
    fa7c:	2f 91       	pop	r18
    fa7e:	1f 91       	pop	r17
    fa80:	0f 90       	pop	r0
    fa82:	0b be       	out	0x3b, r0	; 59
    fa84:	0f 90       	pop	r0
    fa86:	0f be       	out	0x3f, r0	; 63
    fa88:	0f 90       	pop	r0
    fa8a:	1f 90       	pop	r1
    fa8c:	18 95       	reti

0000fa8e <UserInput>:
void ShowMessage(char *Message){//Display Message on Line3
     char i;
}


char UserInput(char TypeUI,char xPos, char yPos,char *strResult, unsigned int MaxValue, char MaxLength){
    fa8e:	8f 92       	push	r8
    fa90:	9f 92       	push	r9
    fa92:	af 92       	push	r10
    fa94:	bf 92       	push	r11
    fa96:	cf 92       	push	r12
    fa98:	df 92       	push	r13
    fa9a:	ef 92       	push	r14
    fa9c:	ff 92       	push	r15
    fa9e:	0f 93       	push	r16
    faa0:	1f 93       	push	r17
    faa2:	cf 93       	push	r28
    faa4:	df 93       	push	r29
    faa6:	f8 2e       	mov	r15, r24
    faa8:	96 2e       	mov	r9, r22
    faaa:	d4 2e       	mov	r13, r20
    faac:	e9 01       	movw	r28, r18
    faae:	58 01       	movw	r10, r16
    fab0:	8e 2c       	mov	r8, r14
	 static char iHit=0,IsShifted=False,IsSameKey=False,IsNextKey=False,IsNewKey=False,IsFirst=False;//,KeyByte=0;
	 static unsigned int iLoop=0,KeyTimeout;//,TimerPressed=0,NewKeyTimeout;
	        unsigned int NumbValue=0;
	 char KeyPressed=0,KeyChar=0,iDisp=0;
     Result=USER_NONE;
	 switch(stUserInput){// 100 ->199 500 90
    fab2:	10 91 6b 03 	lds	r17, 0x036B
    fab6:	12 30       	cpi	r17, 0x02	; 2
    fab8:	09 f4       	brne	.+2      	; 0xfabc <UserInput+0x2e>
    faba:	2c c2       	rjmp	.+1112   	; 0xff14 <UserInput+0x486>
    fabc:	13 30       	cpi	r17, 0x03	; 3
    fabe:	30 f4       	brcc	.+12     	; 0xfacc <UserInput+0x3e>
    fac0:	11 23       	and	r17, r17
    fac2:	59 f0       	breq	.+22     	; 0xfada <UserInput+0x4c>
    fac4:	11 30       	cpi	r17, 0x01	; 1
    fac6:	09 f0       	breq	.+2      	; 0xfaca <UserInput+0x3c>
    fac8:	f5 c2       	rjmp	.+1514   	; 0x100b4 <UserInput+0x626>
    faca:	2c c0       	rjmp	.+88     	; 0xfb24 <UserInput+0x96>
    facc:	13 30       	cpi	r17, 0x03	; 3
    face:	09 f4       	brne	.+2      	; 0xfad2 <UserInput+0x44>
    fad0:	76 c2       	rjmp	.+1260   	; 0xffbe <UserInput+0x530>
    fad2:	14 30       	cpi	r17, 0x04	; 4
    fad4:	09 f0       	breq	.+2      	; 0xfad8 <UserInput+0x4a>
    fad6:	ee c2       	rjmp	.+1500   	; 0x100b4 <UserInput+0x626>
    fad8:	ef c2       	rjmp	.+1502   	; 0x100b8 <UserInput+0x62a>
	 case uiInit:
	      iLoop=0;
    fada:	10 92 5d 03 	sts	0x035D, r1
    fade:	10 92 5c 03 	sts	0x035C, r1
		  stUserInput=uiInput;
		  xChar=xPos;yChar=yPos;
    fae2:	60 93 6a 03 	sts	0x036A, r22
    fae6:	40 93 69 03 	sts	0x0369, r20
          iValuePos=0;
    faea:	10 92 68 03 	sts	0x0368, r1
		  KeyTimeout=0;
    faee:	10 92 5b 03 	sts	0x035B, r1
    faf2:	10 92 5a 03 	sts	0x035A, r1
		  IsSameKey=False;
    faf6:	10 92 61 03 	sts	0x0361, r1
		  IsNextKey=False;
    fafa:	10 92 60 03 	sts	0x0360, r1
		  IsNewKey=False;
    fafe:	10 92 5f 03 	sts	0x035F, r1
		  IsShifted=True;
    fb02:	91 e0       	ldi	r25, 0x01	; 1
    fb04:	90 93 62 03 	sts	0x0362, r25
		  zKeyChar=' ';
    fb08:	80 e2       	ldi	r24, 0x20	; 32
    fb0a:	80 93 67 03 	sts	0x0367, r24
		  iHit=0;
    fb0e:	10 92 63 03 	sts	0x0363, r1
		  IsFirst=False;
    fb12:	10 92 5e 03 	sts	0x035E, r1
		  IsDelete=False;
    fb16:	10 92 64 03 	sts	0x0364, r1
		  Result=USER_NO_DATA;
		  stUserInput=uiInput;
    fb1a:	90 93 6b 03 	sts	0x036B, r25
    fb1e:	35 e0       	ldi	r19, 0x05	; 5
    fb20:	e3 2e       	mov	r14, r19
    fb22:	ce c2       	rjmp	.+1436   	; 0x100c0 <UserInput+0x632>
	      break;
	 case uiInput:
	      KeyPressed=_key_scan(1);                  //  _  ABC DEF GHI JKL MNO PQRS TUV WXYZ
    fb24:	81 e0       	ldi	r24, 0x01	; 1
    fb26:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
    fb2a:	c8 2e       	mov	r12, r24
		  KeyChar= _key_btn(KeyPressed);            //  1   2   3   4   5   6   7    8   9
    fb2c:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
    fb30:	e8 2e       	mov	r14, r24
		  if (KeyPressed==_KEY_SHIFT){
    fb32:	2b e7       	ldi	r18, 0x7B	; 123
    fb34:	c2 16       	cp	r12, r18
    fb36:	59 f4       	brne	.+22     	; 0xfb4e <UserInput+0xc0>
		      if (IsShifted==False)IsShifted=True;
    fb38:	80 91 62 03 	lds	r24, 0x0362
    fb3c:	88 23       	and	r24, r24
    fb3e:	19 f4       	brne	.+6      	; 0xfb46 <UserInput+0xb8>
    fb40:	10 93 62 03 	sts	0x0362, r17
    fb44:	04 c0       	rjmp	.+8      	; 0xfb4e <UserInput+0xc0>
			  else
		      if (IsShifted==True)IsShifted=False;
    fb46:	81 30       	cpi	r24, 0x01	; 1
    fb48:	11 f4       	brne	.+4      	; 0xfb4e <UserInput+0xc0>
    fb4a:	10 92 62 03 	sts	0x0362, r1
			  }
          
		  if (IsSameKey==True){
    fb4e:	80 91 61 03 	lds	r24, 0x0361
    fb52:	81 30       	cpi	r24, 0x01	; 1
    fb54:	e9 f4       	brne	.+58     	; 0xfb90 <UserInput+0x102>
		      KeyTimeout++;
    fb56:	80 91 5a 03 	lds	r24, 0x035A
    fb5a:	90 91 5b 03 	lds	r25, 0x035B
    fb5e:	01 96       	adiw	r24, 0x01	; 1
    fb60:	90 93 5b 03 	sts	0x035B, r25
    fb64:	80 93 5a 03 	sts	0x035A, r24
              if (KeyTimeout>1000){
    fb68:	89 5e       	subi	r24, 0xE9	; 233
    fb6a:	93 40       	sbci	r25, 0x03	; 3
    fb6c:	88 f0       	brcs	.+34     	; 0xfb90 <UserInput+0x102>
			      if (TypeUI==UI_ALPHANUM_PASSWORD)lcd_put(xChar,yChar,'*');
    fb6e:	f5 e0       	ldi	r31, 0x05	; 5
    fb70:	ff 16       	cp	r15, r31
    fb72:	39 f4       	brne	.+14     	; 0xfb82 <UserInput+0xf4>
    fb74:	80 91 6a 03 	lds	r24, 0x036A
    fb78:	60 91 69 03 	lds	r22, 0x0369
    fb7c:	4a e2       	ldi	r20, 0x2A	; 42
    fb7e:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>

		          IsNextKey=True;
    fb82:	81 e0       	ldi	r24, 0x01	; 1
    fb84:	80 93 60 03 	sts	0x0360, r24
				  iLoop=0;
    fb88:	10 92 5d 03 	sts	0x035D, r1
    fb8c:	10 92 5c 03 	sts	0x035C, r1
			     }
              }
 
 		  //if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<=MaxLength))||(IsNextKey==True)){
		  if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<MaxLength))||(IsNextKey==True)){
    fb90:	8e 2d       	mov	r24, r14
    fb92:	80 53       	subi	r24, 0x30	; 48
    fb94:	8a 30       	cpi	r24, 0x0A	; 10
    fb96:	20 f4       	brcc	.+8      	; 0xfba0 <UserInput+0x112>
    fb98:	80 91 68 03 	lds	r24, 0x0368
    fb9c:	88 15       	cp	r24, r8
    fb9e:	40 f0       	brcs	.+16     	; 0xfbb0 <UserInput+0x122>
    fba0:	80 91 60 03 	lds	r24, 0x0360
    fba4:	81 30       	cpi	r24, 0x01	; 1
    fba6:	21 f0       	breq	.+8      	; 0xfbb0 <UserInput+0x122>
    fba8:	ee 24       	eor	r14, r14
    fbaa:	00 e0       	ldi	r16, 0x00	; 0
    fbac:	10 e0       	ldi	r17, 0x00	; 0
    fbae:	be c0       	rjmp	.+380    	; 0xfd2c <UserInput+0x29e>
    fbb0:	84 e2       	ldi	r24, 0x24	; 36
    fbb2:	94 ef       	ldi	r25, 0xF4	; 244
    fbb4:	01 97       	sbiw	r24, 0x01	; 1
    fbb6:	f1 f7       	brne	.-4      	; 0xfbb4 <UserInput+0x126>
		       _delay_ms(250);
		       strResult[iValuePos]=KeyChar;
    fbb8:	80 91 68 03 	lds	r24, 0x0368
    fbbc:	fe 01       	movw	r30, r28
    fbbe:	e8 0f       	add	r30, r24
    fbc0:	f1 1d       	adc	r31, r1
    fbc2:	e0 82       	st	Z, r14
		       strResult[iValuePos+1]=0;
    fbc4:	11 82       	std	Z+1, r1	; 0x01

			   if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)) 
    fbc6:	8f 2d       	mov	r24, r15
    fbc8:	81 50       	subi	r24, 0x01	; 1
    fbca:	82 30       	cpi	r24, 0x02	; 2
    fbcc:	30 f0       	brcs	.+12     	; 0xfbda <UserInput+0x14c>
    fbce:	24 e0       	ldi	r18, 0x04	; 4
    fbd0:	f2 16       	cp	r15, r18
    fbd2:	19 f0       	breq	.+6      	; 0xfbda <UserInput+0x14c>
    fbd4:	00 e0       	ldi	r16, 0x00	; 0
    fbd6:	10 e0       	ldi	r17, 0x00	; 0
    fbd8:	04 c0       	rjmp	.+8      	; 0xfbe2 <UserInput+0x154>
			        NumbValue=atoi(strResult);
    fbda:	ce 01       	movw	r24, r28
    fbdc:	0e 94 3d b5 	call	0x16a7a	; 0x16a7a <atoi>
    fbe0:	8c 01       	movw	r16, r24
			   else NumbValue=0;
				
			   if ((TypeUI==UI_ALPHANUM_R)||(TypeUI==UI_ALPHANUM_PASSWORD)){
    fbe2:	83 e0       	ldi	r24, 0x03	; 3
    fbe4:	f8 16       	cp	r15, r24
    fbe6:	21 f0       	breq	.+8      	; 0xfbf0 <UserInput+0x162>
    fbe8:	e5 e0       	ldi	r30, 0x05	; 5
    fbea:	fe 16       	cp	r15, r30
    fbec:	09 f0       	breq	.+2      	; 0xfbf0 <UserInput+0x162>
    fbee:	63 c0       	rjmp	.+198    	; 0xfcb6 <UserInput+0x228>
			       if (KeyChar!=zKeyChar){
    fbf0:	80 91 67 03 	lds	r24, 0x0367
    fbf4:	e8 16       	cp	r14, r24
    fbf6:	71 f0       	breq	.+28     	; 0xfc14 <UserInput+0x186>
					   IsSameKey=False;
    fbf8:	10 92 61 03 	sts	0x0361, r1
					   IsNewKey=True;
    fbfc:	81 e0       	ldi	r24, 0x01	; 1
    fbfe:	80 93 5f 03 	sts	0x035F, r24
				       iHit=0;
    fc02:	10 92 63 03 	sts	0x0363, r1
					   iLoop=1000;
    fc06:	88 ee       	ldi	r24, 0xE8	; 232
    fc08:	93 e0       	ldi	r25, 0x03	; 3
    fc0a:	90 93 5d 03 	sts	0x035D, r25
    fc0e:	80 93 5c 03 	sts	0x035C, r24
    fc12:	51 c0       	rjmp	.+162    	; 0xfcb6 <UserInput+0x228>
				   }
                   else{
				   if (IsNewKey==True){
    fc14:	80 91 5f 03 	lds	r24, 0x035F
    fc18:	81 30       	cpi	r24, 0x01	; 1
    fc1a:	71 f4       	brne	.+28     	; 0xfc38 <UserInput+0x1aa>
					   IsNewKey=False;
    fc1c:	10 92 5f 03 	sts	0x035F, r1
					   yChar--;
    fc20:	80 91 69 03 	lds	r24, 0x0369
    fc24:	81 50       	subi	r24, 0x01	; 1
    fc26:	80 93 69 03 	sts	0x0369, r24
					   if (iValuePos>0) iValuePos--;
    fc2a:	80 91 68 03 	lds	r24, 0x0368
    fc2e:	88 23       	and	r24, r24
    fc30:	19 f0       	breq	.+6      	; 0xfc38 <UserInput+0x1aa>
    fc32:	81 50       	subi	r24, 0x01	; 1
    fc34:	80 93 68 03 	sts	0x0368, r24
					   }
				   KeyTimeout=0;
    fc38:	10 92 5b 03 	sts	0x035B, r1
    fc3c:	10 92 5a 03 	sts	0x035A, r1
				   IsSameKey=True;
    fc40:	81 e0       	ldi	r24, 0x01	; 1
    fc42:	80 93 61 03 	sts	0x0361, r24
				   if (iHit<pgm_read_byte(&MaxKeyHit[(zKeyChar-'0')])) iHit++;
    fc46:	80 91 63 03 	lds	r24, 0x0363
    fc4a:	e0 91 67 03 	lds	r30, 0x0367
    fc4e:	f0 e0       	ldi	r31, 0x00	; 0
    fc50:	e2 53       	subi	r30, 0x32	; 50
    fc52:	fd 4f       	sbci	r31, 0xFD	; 253
    fc54:	e4 91       	lpm	r30, Z+
    fc56:	8e 17       	cp	r24, r30
    fc58:	20 f4       	brcc	.+8      	; 0xfc62 <UserInput+0x1d4>
    fc5a:	8f 5f       	subi	r24, 0xFF	; 255
    fc5c:	80 93 63 03 	sts	0x0363, r24
    fc60:	02 c0       	rjmp	.+4      	; 0xfc66 <UserInput+0x1d8>
                   else iHit=0;
    fc62:	10 92 63 03 	sts	0x0363, r1
				   iLoop=1000;
    fc66:	88 ee       	ldi	r24, 0xE8	; 232
    fc68:	93 e0       	ldi	r25, 0x03	; 3
    fc6a:	90 93 5d 03 	sts	0x035D, r25
    fc6e:	80 93 5c 03 	sts	0x035C, r24

                   zAlphaChar=AlphaChar;
    fc72:	80 91 65 03 	lds	r24, 0x0365
    fc76:	80 93 66 03 	sts	0x0366, r24
			       AlphaChar=_table_alphanum(IsShifted,KeyPressed,iHit);			   
    fc7a:	80 91 62 03 	lds	r24, 0x0362
    fc7e:	6c 2d       	mov	r22, r12
    fc80:	40 91 63 03 	lds	r20, 0x0363
    fc84:	0e 94 b1 af 	call	0x15f62	; 0x15f62 <_table_alphanum>
    fc88:	80 93 65 03 	sts	0x0365, r24
                   
				   if (IsNextKey==True){
    fc8c:	80 91 60 03 	lds	r24, 0x0360
    fc90:	81 30       	cpi	r24, 0x01	; 1
    fc92:	41 f4       	brne	.+16     	; 0xfca4 <UserInput+0x216>
                       AlphaChar=zAlphaChar;       
    fc94:	80 91 66 03 	lds	r24, 0x0366
    fc98:	80 93 65 03 	sts	0x0365, r24
					   IsNextKey=False;
    fc9c:	10 92 60 03 	sts	0x0360, r1
					   IsSameKey=False;
    fca0:	10 92 61 03 	sts	0x0361, r1
				   }   
				   strResult[iValuePos]=AlphaChar;
    fca4:	80 91 68 03 	lds	r24, 0x0368
    fca8:	fe 01       	movw	r30, r28
    fcaa:	e8 0f       	add	r30, r24
    fcac:	f1 1d       	adc	r31, r1
    fcae:	80 91 65 03 	lds	r24, 0x0365
    fcb2:	80 83       	st	Z, r24
		           strResult[iValuePos+1]=0;
    fcb4:	11 82       	std	Z+1, r1	; 0x01
				 }//endElse 
				 
			   }//EndAlphaNum

			 if (TypeUI==UI_NUMBER_L){
    fcb6:	f2 e0       	ldi	r31, 0x02	; 2
    fcb8:	ff 16       	cp	r15, r31
    fcba:	71 f4       	brne	.+28     	; 0xfcd8 <UserInput+0x24a>
			    if ((NumbValue<=MaxValue)||(MaxValue==0)){
    fcbc:	a0 16       	cp	r10, r16
    fcbe:	b1 06       	cpc	r11, r17
    fcc0:	18 f4       	brcc	.+6      	; 0xfcc8 <UserInput+0x23a>
    fcc2:	a1 14       	cp	r10, r1
    fcc4:	b1 04       	cpc	r11, r1
    fcc6:	71 f5       	brne	.+92     	; 0xfd24 <UserInput+0x296>
				     iValuePos++;
    fcc8:	80 91 68 03 	lds	r24, 0x0368
    fccc:	8f 5f       	subi	r24, 0xFF	; 255
    fcce:	80 93 68 03 	sts	0x0368, r24
					 stUserInput=uiInputDisp;
    fcd2:	83 e0       	ldi	r24, 0x03	; 3
    fcd4:	80 93 6b 03 	sts	0x036B, r24
				} 
			 }
  
			   if ((NumbValue<=MaxValue)||(MaxValue==0)){
    fcd8:	a0 16       	cp	r10, r16
    fcda:	b1 06       	cpc	r11, r17
    fcdc:	18 f4       	brcc	.+6      	; 0xfce4 <UserInput+0x256>
    fcde:	a1 14       	cp	r10, r1
    fce0:	b1 04       	cpc	r11, r1
    fce2:	01 f5       	brne	.+64     	; 0xfd24 <UserInput+0x296>
			       if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    fce4:	21 e0       	ldi	r18, 0x01	; 1
    fce6:	f2 16       	cp	r15, r18
    fce8:	49 f0       	breq	.+18     	; 0xfcfc <UserInput+0x26e>
    fcea:	83 e0       	ldi	r24, 0x03	; 3
    fcec:	f8 16       	cp	r15, r24
    fcee:	31 f0       	breq	.+12     	; 0xfcfc <UserInput+0x26e>
    fcf0:	e4 e0       	ldi	r30, 0x04	; 4
    fcf2:	fe 16       	cp	r15, r30
    fcf4:	19 f0       	breq	.+6      	; 0xfcfc <UserInput+0x26e>
    fcf6:	f5 e0       	ldi	r31, 0x05	; 5
    fcf8:	ff 16       	cp	r15, r31
    fcfa:	a1 f4       	brne	.+40     	; 0xfd24 <UserInput+0x296>
				       (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
				      if (IsSameKey==False){
    fcfc:	80 91 61 03 	lds	r24, 0x0361
    fd00:	88 23       	and	r24, r24
    fd02:	69 f4       	brne	.+26     	; 0xfd1e <UserInput+0x290>
					      IsFirst=True;
    fd04:	81 e0       	ldi	r24, 0x01	; 1
    fd06:	80 93 5e 03 	sts	0x035E, r24
					      iValuePos++;
    fd0a:	80 91 68 03 	lds	r24, 0x0368
    fd0e:	8f 5f       	subi	r24, 0xFF	; 255
    fd10:	80 93 68 03 	sts	0x0368, r24
						  //FullEntry
						  if (iValuePos==MaxLength)Result=USER_FULL_ENTRY;
					      yChar++;
    fd14:	80 91 69 03 	lds	r24, 0x0369
    fd18:	8f 5f       	subi	r24, 0xFF	; 255
    fd1a:	80 93 69 03 	sts	0x0369, r24
						  //yChar=(yChar+1;//Max Display

						  }
                  stUserInput=uiInputDisp;
    fd1e:	83 e0       	ldi	r24, 0x03	; 3
    fd20:	80 93 6b 03 	sts	0x036B, r24
				  }
			   }
              zKeyChar=KeyChar;
    fd24:	e0 92 67 03 	sts	0x0367, r14
    fd28:	24 e0       	ldi	r18, 0x04	; 4
    fd2a:	e2 2e       	mov	r14, r18
             Result=USER_ENTRY;
             }//EndKeyChar
			 
                 
              if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)){
    fd2c:	2f 2d       	mov	r18, r15
    fd2e:	21 50       	subi	r18, 0x01	; 1
    fd30:	22 30       	cpi	r18, 0x02	; 2
    fd32:	18 f0       	brcs	.+6      	; 0xfd3a <UserInput+0x2ac>
    fd34:	84 e0       	ldi	r24, 0x04	; 4
    fd36:	f8 16       	cp	r15, r24
    fd38:	89 f4       	brne	.+34     	; 0xfd5c <UserInput+0x2ce>
                   if((NumbValue>MaxValue)||(iValuePos==MaxLength)){
    fd3a:	a0 16       	cp	r10, r16
    fd3c:	b1 06       	cpc	r11, r17
    fd3e:	20 f0       	brcs	.+8      	; 0xfd48 <UserInput+0x2ba>
    fd40:	80 91 68 03 	lds	r24, 0x0368
    fd44:	88 15       	cp	r24, r8
    fd46:	51 f4       	brne	.+20     	; 0xfd5c <UserInput+0x2ce>
			           if (MaxValue>0)system_beep(1);
    fd48:	ab 28       	or	r10, r11
    fd4a:	41 f0       	breq	.+16     	; 0xfd5c <UserInput+0x2ce>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    fd4c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    fd4e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    fd50:	81 e0       	ldi	r24, 0x01	; 1
    fd52:	90 e0       	ldi	r25, 0x00	; 0
    fd54:	90 93 d7 01 	sts	0x01D7, r25
    fd58:	80 93 d6 01 	sts	0x01D6, r24
			           if (MaxValue>0)system_beep(1);
				   }
                 }
		  
		  //CANCEL OK
		  if (KeyPressed==_KEY_CANCEL){
    fd5c:	e7 ee       	ldi	r30, 0xE7	; 231
    fd5e:	ce 16       	cp	r12, r30
    fd60:	71 f4       	brne	.+28     	; 0xfd7e <UserInput+0x2f0>
		      if (iValuePos>0){
    fd62:	80 91 68 03 	lds	r24, 0x0368
    fd66:	88 23       	and	r24, r24
    fd68:	41 f0       	breq	.+16     	; 0xfd7a <UserInput+0x2ec>
			      iLoop=1999;
    fd6a:	8f ec       	ldi	r24, 0xCF	; 207
    fd6c:	97 e0       	ldi	r25, 0x07	; 7
    fd6e:	90 93 5d 03 	sts	0x035D, r25
    fd72:	80 93 5c 03 	sts	0x035C, r24
				  stUserInput=uiClearDisplay;
    fd76:	82 e0       	ldi	r24, 0x02	; 2
    fd78:	26 c0       	rjmp	.+76     	; 0xfdc6 <UserInput+0x338>
				  }
			  else{
			      UserInputResult=USER_CANCEL;
    fd7a:	81 e0       	ldi	r24, 0x01	; 1
    fd7c:	21 c0       	rjmp	.+66     	; 0xfdc0 <UserInput+0x332>
			      stUserInput=uiFinished;
				  }
		  }
		  else {
		  if (KeyPressed==_KEY_ENTER){
    fd7e:	f7 eb       	ldi	r31, 0xB7	; 183
    fd80:	cf 16       	cp	r12, r31
    fd82:	19 f5       	brne	.+70     	; 0xfdca <UserInput+0x33c>
		      strResult[iValuePos]=0;
    fd84:	80 91 68 03 	lds	r24, 0x0368
    fd88:	fe 01       	movw	r30, r28
    fd8a:	e8 0f       	add	r30, r24
    fd8c:	f1 1d       	adc	r31, r1
    fd8e:	10 82       	st	Z, r1
			  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)){
    fd90:	22 30       	cpi	r18, 0x02	; 2
    fd92:	a8 f4       	brcc	.+42     	; 0xfdbe <UserInput+0x330>
			       if (iValuePos==0)sprintf_P(strResult,PSTR("0"));
    fd94:	88 23       	and	r24, r24
    fd96:	81 f4       	brne	.+32     	; 0xfdb8 <UserInput+0x32a>
    fd98:	00 d0       	rcall	.+0      	; 0xfd9a <UserInput+0x30c>
    fd9a:	00 d0       	rcall	.+0      	; 0xfd9c <UserInput+0x30e>
    fd9c:	ed b7       	in	r30, 0x3d	; 61
    fd9e:	fe b7       	in	r31, 0x3e	; 62
    fda0:	d2 83       	std	Z+2, r29	; 0x02
    fda2:	c1 83       	std	Z+1, r28	; 0x01
    fda4:	80 ec       	ldi	r24, 0xC0	; 192
    fda6:	9b e1       	ldi	r25, 0x1B	; 27
    fda8:	94 83       	std	Z+4, r25	; 0x04
    fdaa:	83 83       	std	Z+3, r24	; 0x03
    fdac:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    fdb0:	0f 90       	pop	r0
    fdb2:	0f 90       	pop	r0
    fdb4:	0f 90       	pop	r0
    fdb6:	0f 90       	pop	r0
			       RemZeroLead(strResult);
    fdb8:	ce 01       	movw	r24, r28
    fdba:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
				  }
		      UserInputResult=USER_OK;
    fdbe:	83 e0       	ldi	r24, 0x03	; 3
    fdc0:	80 93 6c 03 	sts	0x036C, r24
		      stUserInput=uiFinished;
    fdc4:	84 e0       	ldi	r24, 0x04	; 4
    fdc6:	80 93 6b 03 	sts	0x036B, r24
			  }
		  }//EndElse

		  if ((iLoop%2000)==0){
    fdca:	80 91 5c 03 	lds	r24, 0x035C
    fdce:	90 91 5d 03 	lds	r25, 0x035D
    fdd2:	60 ed       	ldi	r22, 0xD0	; 208
    fdd4:	77 e0       	ldi	r23, 0x07	; 7
    fdd6:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
    fdda:	89 2b       	or	r24, r25
    fddc:	09 f0       	breq	.+2      	; 0xfde0 <UserInput+0x352>
    fdde:	4b c0       	rjmp	.+150    	; 0xfe76 <UserInput+0x3e8>
		      if (IsSameKey==True)
    fde0:	80 91 61 03 	lds	r24, 0x0361
    fde4:	81 30       	cpi	r24, 0x01	; 1
    fde6:	c9 f4       	brne	.+50     	; 0xfe1a <UserInput+0x38c>
			      //lcd_put(xChar,yChar,AlphaChar); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),AlphaChar); 
    fde8:	20 91 68 03 	lds	r18, 0x0368
    fdec:	82 2f       	mov	r24, r18
    fdee:	90 e0       	ldi	r25, 0x00	; 0
    fdf0:	01 97       	sbiw	r24, 0x01	; 1
    fdf2:	8d 0d       	add	r24, r13
    fdf4:	91 1d       	adc	r25, r1
    fdf6:	64 e1       	ldi	r22, 0x14	; 20
    fdf8:	70 e0       	ldi	r23, 0x00	; 0
    fdfa:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    fdfe:	36 2f       	mov	r19, r22
    fe00:	82 2f       	mov	r24, r18
    fe02:	64 e1       	ldi	r22, 0x14	; 20
    fe04:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    fe08:	6d 2d       	mov	r22, r13
    fe0a:	69 0f       	add	r22, r25
    fe0c:	89 2d       	mov	r24, r9
    fe0e:	83 0f       	add	r24, r19
    fe10:	40 91 65 03 	lds	r20, 0x0365
    fe14:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
    fe18:	2e c0       	rjmp	.+92     	; 0xfe76 <UserInput+0x3e8>
			  else {
			      if((TypeUI==UI_ALPHANUM_PASSWORD)&&(iValuePos>0))lcd_put(xChar,yChar-1,'*'); 
    fe1a:	f5 e0       	ldi	r31, 0x05	; 5
    fe1c:	ff 16       	cp	r15, r31
    fe1e:	61 f4       	brne	.+24     	; 0xfe38 <UserInput+0x3aa>
    fe20:	80 91 68 03 	lds	r24, 0x0368
    fe24:	88 23       	and	r24, r24
    fe26:	41 f0       	breq	.+16     	; 0xfe38 <UserInput+0x3aa>
    fe28:	60 91 69 03 	lds	r22, 0x0369
    fe2c:	61 50       	subi	r22, 0x01	; 1
    fe2e:	80 91 6a 03 	lds	r24, 0x036A
    fe32:	4a e2       	ldi	r20, 0x2A	; 42
    fe34:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
			      //lcd_put(xChar,yChar,'_'); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),'_'); 
    fe38:	20 91 68 03 	lds	r18, 0x0368
    fe3c:	82 2f       	mov	r24, r18
    fe3e:	90 e0       	ldi	r25, 0x00	; 0
    fe40:	01 97       	sbiw	r24, 0x01	; 1
    fe42:	8d 0d       	add	r24, r13
    fe44:	91 1d       	adc	r25, r1
    fe46:	64 e1       	ldi	r22, 0x14	; 20
    fe48:	70 e0       	ldi	r23, 0x00	; 0
    fe4a:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    fe4e:	36 2f       	mov	r19, r22
    fe50:	82 2f       	mov	r24, r18
    fe52:	64 e1       	ldi	r22, 0x14	; 20
    fe54:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    fe58:	6d 2d       	mov	r22, r13
    fe5a:	69 0f       	add	r22, r25
    fe5c:	89 2d       	mov	r24, r9
    fe5e:	83 0f       	add	r24, r19
    fe60:	4f e5       	ldi	r20, 0x5F	; 95
    fe62:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>

				  if (IsFirst==True){
    fe66:	80 91 5e 03 	lds	r24, 0x035E
    fe6a:	81 30       	cpi	r24, 0x01	; 1
    fe6c:	21 f4       	brne	.+8      	; 0xfe76 <UserInput+0x3e8>
				      IsFirst=False;
    fe6e:	10 92 5e 03 	sts	0x035E, r1
				      zKeyChar=0;
    fe72:	10 92 67 03 	sts	0x0367, r1
					  }
				  }
			  }
          if ((iLoop%2000)==1000){
    fe76:	80 91 5c 03 	lds	r24, 0x035C
    fe7a:	90 91 5d 03 	lds	r25, 0x035D
    fe7e:	60 ed       	ldi	r22, 0xD0	; 208
    fe80:	77 e0       	ldi	r23, 0x07	; 7
    fe82:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
    fe86:	88 5e       	subi	r24, 0xE8	; 232
    fe88:	93 40       	sbci	r25, 0x03	; 3
    fe8a:	d1 f5       	brne	.+116    	; 0xff00 <UserInput+0x472>
		      if (IsSameKey==True){
    fe8c:	80 91 61 03 	lds	r24, 0x0361
    fe90:	81 30       	cpi	r24, 0x01	; 1
    fe92:	f9 f4       	brne	.+62     	; 0xfed2 <UserInput+0x444>
			      if (TypeUI!=UI_NUM_PASSWORD)
    fe94:	84 e0       	ldi	r24, 0x04	; 4
    fe96:	f8 16       	cp	r15, r24
    fe98:	b1 f0       	breq	.+44     	; 0xfec6 <UserInput+0x438>
				       //lcd_put(xChar,yChar,AlphaChar); 
					   lcd_put(xPos+((yPos+iValuePos-1)/20),yChar%21,AlphaChar); 
    fe9a:	80 91 68 03 	lds	r24, 0x0368
    fe9e:	90 e0       	ldi	r25, 0x00	; 0
    fea0:	01 97       	sbiw	r24, 0x01	; 1
    fea2:	8d 0d       	add	r24, r13
    fea4:	91 1d       	adc	r25, r1
    fea6:	64 e1       	ldi	r22, 0x14	; 20
    fea8:	70 e0       	ldi	r23, 0x00	; 0
    feaa:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    feae:	26 2f       	mov	r18, r22
    feb0:	80 91 69 03 	lds	r24, 0x0369
    feb4:	65 e1       	ldi	r22, 0x15	; 21
    feb6:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    feba:	89 2d       	mov	r24, r9
    febc:	82 0f       	add	r24, r18
    febe:	69 2f       	mov	r22, r25
    fec0:	40 91 65 03 	lds	r20, 0x0365
    fec4:	1b c0       	rjmp	.+54     	; 0xfefc <UserInput+0x46e>
					   
				  else lcd_put(xChar,yChar,'*'); 
    fec6:	80 91 6a 03 	lds	r24, 0x036A
    feca:	60 91 69 03 	lds	r22, 0x0369
    fece:	4a e2       	ldi	r20, 0x2A	; 42
    fed0:	15 c0       	rjmp	.+42     	; 0xfefc <UserInput+0x46e>
			  }
			  //else lcd_put(xChar,yChar,' '); 
			  else lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); 			  
    fed2:	20 91 68 03 	lds	r18, 0x0368
    fed6:	82 2f       	mov	r24, r18
    fed8:	90 e0       	ldi	r25, 0x00	; 0
    feda:	01 97       	sbiw	r24, 0x01	; 1
    fedc:	8d 0d       	add	r24, r13
    fede:	91 1d       	adc	r25, r1
    fee0:	64 e1       	ldi	r22, 0x14	; 20
    fee2:	70 e0       	ldi	r23, 0x00	; 0
    fee4:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    fee8:	36 2f       	mov	r19, r22
    feea:	82 2f       	mov	r24, r18
    feec:	64 e1       	ldi	r22, 0x14	; 20
    feee:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    fef2:	d9 0e       	add	r13, r25
    fef4:	89 2d       	mov	r24, r9
    fef6:	83 0f       	add	r24, r19
    fef8:	6d 2d       	mov	r22, r13
    fefa:	40 e2       	ldi	r20, 0x20	; 32
    fefc:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
			  }
          iLoop++;
    ff00:	80 91 5c 03 	lds	r24, 0x035C
    ff04:	90 91 5d 03 	lds	r25, 0x035D
    ff08:	01 96       	adiw	r24, 0x01	; 1
    ff0a:	90 93 5d 03 	sts	0x035D, r25
    ff0e:	80 93 5c 03 	sts	0x035C, r24
    ff12:	d6 c0       	rjmp	.+428    	; 0x100c0 <UserInput+0x632>
          break;
     case uiClearDisplay:
          if (TypeUI==UI_NUMBER_L){
    ff14:	e2 e0       	ldi	r30, 0x02	; 2
    ff16:	8e 17       	cp	r24, r30
    ff18:	99 f4       	brne	.+38     	; 0xff40 <UserInput+0x4b2>
		      lcd_put(xChar,(yChar-iValuePos),' '); // 123_ 1_
    ff1a:	60 91 69 03 	lds	r22, 0x0369
    ff1e:	80 91 68 03 	lds	r24, 0x0368
    ff22:	68 1b       	sub	r22, r24
    ff24:	80 91 6a 03 	lds	r24, 0x036A
    ff28:	40 e2       	ldi	r20, 0x20	; 32
    ff2a:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
		      strResult[iValuePos]=0;
    ff2e:	80 91 68 03 	lds	r24, 0x0368
    ff32:	c8 0f       	add	r28, r24
    ff34:	d1 1d       	adc	r29, r1
    ff36:	18 82       	st	Y, r1
		      iValuePos--;
    ff38:	81 50       	subi	r24, 0x01	; 1
    ff3a:	80 93 68 03 	sts	0x0368, r24
    ff3e:	33 c0       	rjmp	.+102    	; 0xffa6 <UserInput+0x518>
			  }
          else
		  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    ff40:	f1 e0       	ldi	r31, 0x01	; 1
    ff42:	8f 17       	cp	r24, r31
    ff44:	49 f0       	breq	.+18     	; 0xff58 <UserInput+0x4ca>
    ff46:	23 e0       	ldi	r18, 0x03	; 3
    ff48:	82 17       	cp	r24, r18
    ff4a:	31 f0       	breq	.+12     	; 0xff58 <UserInput+0x4ca>
    ff4c:	84 e0       	ldi	r24, 0x04	; 4
    ff4e:	f8 16       	cp	r15, r24
    ff50:	19 f0       	breq	.+6      	; 0xff58 <UserInput+0x4ca>
    ff52:	e5 e0       	ldi	r30, 0x05	; 5
    ff54:	fe 16       	cp	r15, r30
    ff56:	39 f5       	brne	.+78     	; 0xffa6 <UserInput+0x518>
		      (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
		      //lcd_put(xChar,yChar,' '); // 123_ 1_
			  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); // 123_ 1_
    ff58:	20 91 68 03 	lds	r18, 0x0368
    ff5c:	82 2f       	mov	r24, r18
    ff5e:	90 e0       	ldi	r25, 0x00	; 0
    ff60:	01 97       	sbiw	r24, 0x01	; 1
    ff62:	8d 0d       	add	r24, r13
    ff64:	91 1d       	adc	r25, r1
    ff66:	64 e1       	ldi	r22, 0x14	; 20
    ff68:	70 e0       	ldi	r23, 0x00	; 0
    ff6a:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
    ff6e:	36 2f       	mov	r19, r22
    ff70:	82 2f       	mov	r24, r18
    ff72:	64 e1       	ldi	r22, 0x14	; 20
    ff74:	0e 94 72 b8 	call	0x170e4	; 0x170e4 <__udivmodqi4>
    ff78:	d9 0e       	add	r13, r25
    ff7a:	89 2d       	mov	r24, r9
    ff7c:	83 0f       	add	r24, r19
    ff7e:	6d 2d       	mov	r22, r13
    ff80:	40 e2       	ldi	r20, 0x20	; 32
    ff82:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
			  
		      strResult[iValuePos]=0;
    ff86:	80 91 68 03 	lds	r24, 0x0368
    ff8a:	c8 0f       	add	r28, r24
    ff8c:	d1 1d       	adc	r29, r1
    ff8e:	18 82       	st	Y, r1
		      iValuePos--;
    ff90:	81 50       	subi	r24, 0x01	; 1
    ff92:	80 93 68 03 	sts	0x0368, r24
			  yChar--;
    ff96:	80 91 69 03 	lds	r24, 0x0369
    ff9a:	81 50       	subi	r24, 0x01	; 1
    ff9c:	80 93 69 03 	sts	0x0369, r24
			  IsDelete=True;
    ffa0:	81 e0       	ldi	r24, 0x01	; 1
    ffa2:	80 93 64 03 	sts	0x0364, r24
		  }
		  if (iValuePos==0)Result=USER_NO_DATA;		  
    ffa6:	80 91 68 03 	lds	r24, 0x0368
    ffaa:	88 23       	and	r24, r24
    ffac:	19 f4       	brne	.+6      	; 0xffb4 <UserInput+0x526>
    ffae:	95 e0       	ldi	r25, 0x05	; 5
    ffb0:	e9 2e       	mov	r14, r25
    ffb2:	01 c0       	rjmp	.+2      	; 0xffb6 <UserInput+0x528>
    ffb4:	ee 24       	eor	r14, r14
		  stUserInput=uiInputDisp;//Redraw
    ffb6:	83 e0       	ldi	r24, 0x03	; 3
    ffb8:	80 93 6b 03 	sts	0x036B, r24
    ffbc:	81 c0       	rjmp	.+258    	; 0x100c0 <UserInput+0x632>
	      break;      
     case uiInputDisp:
	      if(TypeUI==UI_ALPHANUM_PASSWORD){
    ffbe:	f5 e0       	ldi	r31, 0x05	; 5
    ffc0:	8f 17       	cp	r24, r31
    ffc2:	19 f5       	brne	.+70     	; 0x1000a <UserInput+0x57c>
			  if (iValuePos>0){
    ffc4:	80 91 68 03 	lds	r24, 0x0368
    ffc8:	88 23       	and	r24, r24
    ffca:	a9 f0       	breq	.+42     	; 0xfff6 <UserInput+0x568>
                  lcd_put(xChar,(yChar-2),'*');
    ffcc:	60 91 69 03 	lds	r22, 0x0369
    ffd0:	62 50       	subi	r22, 0x02	; 2
    ffd2:	80 91 6a 03 	lds	r24, 0x036A
    ffd6:	4a e2       	ldi	r20, 0x2A	; 42
    ffd8:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
			      if (IsDelete==True){
    ffdc:	80 91 64 03 	lds	r24, 0x0364
    ffe0:	60 91 69 03 	lds	r22, 0x0369
    ffe4:	81 30       	cpi	r24, 0x01	; 1
    ffe6:	71 f0       	breq	.+28     	; 0x10004 <UserInput+0x576>
				      IsDelete=False;
			          lcd_put(xChar,(yChar-1),'*');
			          }
				  else lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
    ffe8:	61 50       	subi	r22, 0x01	; 1
    ffea:	80 91 68 03 	lds	r24, 0x0368
    ffee:	c8 0f       	add	r28, r24
    fff0:	d1 1d       	adc	r29, r1
    fff2:	21 97       	sbiw	r28, 0x01	; 1
    fff4:	4d c0       	rjmp	.+154    	; 0x10090 <UserInput+0x602>
			      }
			  else{ if(IsDelete==True){
    fff6:	80 91 64 03 	lds	r24, 0x0364
    fffa:	60 91 69 03 	lds	r22, 0x0369
    fffe:	81 30       	cpi	r24, 0x01	; 1
   10000:	09 f0       	breq	.+2      	; 0x10004 <UserInput+0x576>
   10002:	45 c0       	rjmp	.+138    	; 0x1008e <UserInput+0x600>
			           IsDelete=False;
   10004:	10 92 64 03 	sts	0x0364, r1
   10008:	4c c0       	rjmp	.+152    	; 0x100a2 <UserInput+0x614>
					   lcd_put(xChar,(yChar-1),'*');
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
   1000a:	22 e0       	ldi	r18, 0x02	; 2
   1000c:	82 17       	cp	r24, r18
   1000e:	a1 f4       	brne	.+40     	; 0x10038 <UserInput+0x5aa>
   10010:	10 e0       	ldi	r17, 0x00	; 0
   10012:	0d c0       	rjmp	.+26     	; 0x1002e <UserInput+0x5a0>
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
   10014:	60 91 69 03 	lds	r22, 0x0369
   10018:	68 1b       	sub	r22, r24
   1001a:	61 0f       	add	r22, r17
   1001c:	fe 01       	movw	r30, r28
   1001e:	e1 0f       	add	r30, r17
   10020:	f1 1d       	adc	r31, r1
   10022:	80 91 6a 03 	lds	r24, 0x036A
   10026:	40 81       	ld	r20, Z
   10028:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
   1002c:	1f 5f       	subi	r17, 0xFF	; 255
   1002e:	80 91 68 03 	lds	r24, 0x0368
   10032:	18 17       	cp	r17, r24
   10034:	78 f3       	brcs	.-34     	; 0x10014 <UserInput+0x586>
   10036:	3b c0       	rjmp	.+118    	; 0x100ae <UserInput+0x620>
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
		      }
		  }else
	      if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)){
   10038:	81 e0       	ldi	r24, 0x01	; 1
   1003a:	f8 16       	cp	r15, r24
   1003c:	19 f0       	breq	.+6      	; 0x10044 <UserInput+0x5b6>
   1003e:	e3 e0       	ldi	r30, 0x03	; 3
   10040:	fe 16       	cp	r15, r30
   10042:	51 f5       	brne	.+84     	; 0x10098 <UserInput+0x60a>
		      
			  //if (iValuePos>0) lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
			  if (iValuePos>0) lcd_put(xPos+((yPos+iValuePos-1)/21),yPos+((iValuePos-1)%20),strResult[iValuePos-1]);			  
   10044:	20 91 68 03 	lds	r18, 0x0368
   10048:	4d 2d       	mov	r20, r13
   1004a:	50 e0       	ldi	r21, 0x00	; 0
   1004c:	22 23       	and	r18, r18
   1004e:	c1 f0       	breq	.+48     	; 0x10080 <UserInput+0x5f2>
   10050:	30 e0       	ldi	r19, 0x00	; 0
   10052:	f9 01       	movw	r30, r18
   10054:	31 97       	sbiw	r30, 0x01	; 1
   10056:	cf 01       	movw	r24, r30
   10058:	84 0f       	add	r24, r20
   1005a:	95 1f       	adc	r25, r21
   1005c:	65 e1       	ldi	r22, 0x15	; 21
   1005e:	70 e0       	ldi	r23, 0x00	; 0
   10060:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
   10064:	46 2f       	mov	r20, r22
   10066:	cf 01       	movw	r24, r30
   10068:	64 e1       	ldi	r22, 0x14	; 20
   1006a:	70 e0       	ldi	r23, 0x00	; 0
   1006c:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
   10070:	d8 0e       	add	r13, r24
   10072:	c2 0f       	add	r28, r18
   10074:	d3 1f       	adc	r29, r19
   10076:	21 97       	sbiw	r28, 0x01	; 1
   10078:	89 2d       	mov	r24, r9
   1007a:	84 0f       	add	r24, r20
   1007c:	6d 2d       	mov	r22, r13
   1007e:	0a c0       	rjmp	.+20     	; 0x10094 <UserInput+0x606>
			  else{ if ((yChar-1)>=yPos)lcd_put(xChar,(yChar-1),strResult[iValuePos]);
   10080:	60 91 69 03 	lds	r22, 0x0369
   10084:	86 2f       	mov	r24, r22
   10086:	90 e0       	ldi	r25, 0x00	; 0
   10088:	48 17       	cp	r20, r24
   1008a:	59 07       	cpc	r21, r25
   1008c:	84 f4       	brge	.+32     	; 0x100ae <UserInput+0x620>
   1008e:	61 50       	subi	r22, 0x01	; 1
   10090:	80 91 6a 03 	lds	r24, 0x036A
   10094:	48 81       	ld	r20, Y
   10096:	09 c0       	rjmp	.+18     	; 0x100aa <UserInput+0x61c>
			  }
		  }else
		  //DisplayAsterik *
		  if (TypeUI==UI_NUM_PASSWORD){
   10098:	f4 e0       	ldi	r31, 0x04	; 4
   1009a:	ff 16       	cp	r15, r31
   1009c:	41 f4       	brne	.+16     	; 0x100ae <UserInput+0x620>
		      lcd_put(xChar,(yChar-1),'*');
   1009e:	60 91 69 03 	lds	r22, 0x0369
   100a2:	61 50       	subi	r22, 0x01	; 1
   100a4:	80 91 6a 03 	lds	r24, 0x036A
   100a8:	4a e2       	ldi	r20, 0x2A	; 42
   100aa:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
		  }

          stUserInput=uiInput;
   100ae:	81 e0       	ldi	r24, 0x01	; 1
   100b0:	80 93 6b 03 	sts	0x036B, r24
   100b4:	ee 24       	eor	r14, r14
   100b6:	04 c0       	rjmp	.+8      	; 0x100c0 <UserInput+0x632>
	      break;	 
     case uiFinished:
	      Result=UserInputResult;
   100b8:	e0 90 6c 03 	lds	r14, 0x036C
	      stUserInput=uiInit;
   100bc:	10 92 6b 03 	sts	0x036B, r1
	      break;
	 }
	 return Result;
}
   100c0:	8e 2d       	mov	r24, r14
   100c2:	df 91       	pop	r29
   100c4:	cf 91       	pop	r28
   100c6:	1f 91       	pop	r17
   100c8:	0f 91       	pop	r16
   100ca:	ff 90       	pop	r15
   100cc:	ef 90       	pop	r14
   100ce:	df 90       	pop	r13
   100d0:	cf 90       	pop	r12
   100d2:	bf 90       	pop	r11
   100d4:	af 90       	pop	r10
   100d6:	9f 90       	pop	r9
   100d8:	8f 90       	pop	r8
   100da:	08 95       	ret

000100dc <TestUserInput>:
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//_uart_print(0,1,strSend);
}


char TestUserInput(){
   100dc:	6f 92       	push	r6
   100de:	7f 92       	push	r7
   100e0:	8f 92       	push	r8
   100e2:	9f 92       	push	r9
   100e4:	af 92       	push	r10
   100e6:	bf 92       	push	r11
   100e8:	cf 92       	push	r12
   100ea:	df 92       	push	r13
   100ec:	ef 92       	push	r14
   100ee:	ff 92       	push	r15
   100f0:	0f 93       	push	r16
   100f2:	1f 93       	push	r17
   100f4:	df 93       	push	r29
   100f6:	cf 93       	push	r28
   100f8:	cd b7       	in	r28, 0x3d	; 61
   100fa:	de b7       	in	r29, 0x3e	; 62
   100fc:	ce 56       	subi	r28, 0x6E	; 110
   100fe:	d0 40       	sbci	r29, 0x00	; 0
   10100:	0f b6       	in	r0, 0x3f	; 63
   10102:	f8 94       	cli
   10104:	de bf       	out	0x3e, r29	; 62
   10106:	0f be       	out	0x3f, r0	; 63
   10108:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],strSend[30];
char SVolume[15],SMoney[15],STotalVolume[15],STotalMoney[15];
char Result;

char uiResult;
	uiResult=UserInput(UI_ALPHANUM_R,2,1,strNumber,0,10);
   1010a:	e3 ef       	ldi	r30, 0xF3	; 243
   1010c:	6e 2e       	mov	r6, r30
   1010e:	e1 e0       	ldi	r30, 0x01	; 1
   10110:	7e 2e       	mov	r7, r30
   10112:	83 e0       	ldi	r24, 0x03	; 3
   10114:	62 e0       	ldi	r22, 0x02	; 2
   10116:	41 e0       	ldi	r20, 0x01	; 1
   10118:	93 01       	movw	r18, r6
   1011a:	00 e0       	ldi	r16, 0x00	; 0
   1011c:	10 e0       	ldi	r17, 0x00	; 0
   1011e:	7a e0       	ldi	r23, 0x0A	; 10
   10120:	e7 2e       	mov	r14, r23
   10122:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
	Result=MENU_NONE;
    if (uiResult==USER_OK){
   10126:	83 30       	cpi	r24, 0x03	; 3
   10128:	09 f0       	breq	.+2      	; 0x1012c <TestUserInput+0x50>
   1012a:	ed c1       	rjmp	.+986    	; 0x10506 <TestUserInput+0x42a>
	    sprintf_P(lcdteks,PSTR("Data:%s"),strNumber);
   1012c:	00 d0       	rcall	.+0      	; 0x1012e <TestUserInput+0x52>
   1012e:	00 d0       	rcall	.+0      	; 0x10130 <TestUserInput+0x54>
   10130:	00 d0       	rcall	.+0      	; 0x10132 <TestUserInput+0x56>
   10132:	ed b7       	in	r30, 0x3d	; 61
   10134:	fe b7       	in	r31, 0x3e	; 62
   10136:	31 96       	adiw	r30, 0x01	; 1
   10138:	8e 01       	movw	r16, r28
   1013a:	03 5c       	subi	r16, 0xC3	; 195
   1013c:	1f 4f       	sbci	r17, 0xFF	; 255
   1013e:	ad b7       	in	r26, 0x3d	; 61
   10140:	be b7       	in	r27, 0x3e	; 62
   10142:	12 96       	adiw	r26, 0x02	; 2
   10144:	1c 93       	st	X, r17
   10146:	0e 93       	st	-X, r16
   10148:	11 97       	sbiw	r26, 0x01	; 1
   1014a:	84 ef       	ldi	r24, 0xF4	; 244
   1014c:	93 e0       	ldi	r25, 0x03	; 3
   1014e:	93 83       	std	Z+3, r25	; 0x03
   10150:	82 83       	std	Z+2, r24	; 0x02
   10152:	75 82       	std	Z+5, r7	; 0x05
   10154:	64 82       	std	Z+4, r6	; 0x04
   10156:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	   lcd_print(3,1,lcdteks);
   1015a:	8d b7       	in	r24, 0x3d	; 61
   1015c:	9e b7       	in	r25, 0x3e	; 62
   1015e:	06 96       	adiw	r24, 0x06	; 6
   10160:	0f b6       	in	r0, 0x3f	; 63
   10162:	f8 94       	cli
   10164:	9e bf       	out	0x3e, r25	; 62
   10166:	0f be       	out	0x3f, r0	; 63
   10168:	8d bf       	out	0x3d, r24	; 61
   1016a:	83 e0       	ldi	r24, 0x03	; 3
   1016c:	61 e0       	ldi	r22, 0x01	; 1
   1016e:	a8 01       	movw	r20, r16
   10170:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
	   //FormatCurrency(strNumber);
	   //FormatMoney(strNumber);
	   //RemZeroLead(strNumber);
	   sprintf_P(SVolume,PSTR("%s"),strNumber);
   10174:	00 d0       	rcall	.+0      	; 0x10176 <TestUserInput+0x9a>
   10176:	00 d0       	rcall	.+0      	; 0x10178 <TestUserInput+0x9c>
   10178:	00 d0       	rcall	.+0      	; 0x1017a <TestUserInput+0x9e>
   1017a:	ed b7       	in	r30, 0x3d	; 61
   1017c:	fe b7       	in	r31, 0x3e	; 62
   1017e:	31 96       	adiw	r30, 0x01	; 1
   10180:	7e 01       	movw	r14, r28
   10182:	08 94       	sec
   10184:	e1 1c       	adc	r14, r1
   10186:	f1 1c       	adc	r15, r1
   10188:	ad b7       	in	r26, 0x3d	; 61
   1018a:	be b7       	in	r27, 0x3e	; 62
   1018c:	12 96       	adiw	r26, 0x02	; 2
   1018e:	fc 92       	st	X, r15
   10190:	ee 92       	st	-X, r14
   10192:	11 97       	sbiw	r26, 0x01	; 1
   10194:	81 ef       	ldi	r24, 0xF1	; 241
   10196:	93 e0       	ldi	r25, 0x03	; 3
   10198:	93 83       	std	Z+3, r25	; 0x03
   1019a:	82 83       	std	Z+2, r24	; 0x02
   1019c:	75 82       	std	Z+5, r7	; 0x05
   1019e:	64 82       	std	Z+4, r6	; 0x04
   101a0:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	   sprintf_P(SMoney,PSTR("%s"),strNumber);
   101a4:	ed b7       	in	r30, 0x3d	; 61
   101a6:	fe b7       	in	r31, 0x3e	; 62
   101a8:	31 96       	adiw	r30, 0x01	; 1
   101aa:	60 e1       	ldi	r22, 0x10	; 16
   101ac:	a6 2e       	mov	r10, r22
   101ae:	b1 2c       	mov	r11, r1
   101b0:	ac 0e       	add	r10, r28
   101b2:	bd 1e       	adc	r11, r29
   101b4:	ad b7       	in	r26, 0x3d	; 61
   101b6:	be b7       	in	r27, 0x3e	; 62
   101b8:	12 96       	adiw	r26, 0x02	; 2
   101ba:	bc 92       	st	X, r11
   101bc:	ae 92       	st	-X, r10
   101be:	11 97       	sbiw	r26, 0x01	; 1
   101c0:	8e ee       	ldi	r24, 0xEE	; 238
   101c2:	93 e0       	ldi	r25, 0x03	; 3
   101c4:	93 83       	std	Z+3, r25	; 0x03
   101c6:	82 83       	std	Z+2, r24	; 0x02
   101c8:	75 82       	std	Z+5, r7	; 0x05
   101ca:	64 82       	std	Z+4, r6	; 0x04
   101cc:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	   sprintf_P(STotalVolume,PSTR("%s"),strNumber);
   101d0:	ed b7       	in	r30, 0x3d	; 61
   101d2:	fe b7       	in	r31, 0x3e	; 62
   101d4:	31 96       	adiw	r30, 0x01	; 1
   101d6:	5f e1       	ldi	r21, 0x1F	; 31
   101d8:	85 2e       	mov	r8, r21
   101da:	91 2c       	mov	r9, r1
   101dc:	8c 0e       	add	r8, r28
   101de:	9d 1e       	adc	r9, r29
   101e0:	ad b7       	in	r26, 0x3d	; 61
   101e2:	be b7       	in	r27, 0x3e	; 62
   101e4:	12 96       	adiw	r26, 0x02	; 2
   101e6:	9c 92       	st	X, r9
   101e8:	8e 92       	st	-X, r8
   101ea:	11 97       	sbiw	r26, 0x01	; 1
   101ec:	8b ee       	ldi	r24, 0xEB	; 235
   101ee:	93 e0       	ldi	r25, 0x03	; 3
   101f0:	93 83       	std	Z+3, r25	; 0x03
   101f2:	82 83       	std	Z+2, r24	; 0x02
   101f4:	75 82       	std	Z+5, r7	; 0x05
   101f6:	64 82       	std	Z+4, r6	; 0x04
   101f8:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	   sprintf_P(STotalMoney,PSTR("%s"),strNumber);
   101fc:	ed b7       	in	r30, 0x3d	; 61
   101fe:	fe b7       	in	r31, 0x3e	; 62
   10200:	31 96       	adiw	r30, 0x01	; 1
   10202:	4e e2       	ldi	r20, 0x2E	; 46
   10204:	c4 2e       	mov	r12, r20
   10206:	d1 2c       	mov	r13, r1
   10208:	cc 0e       	add	r12, r28
   1020a:	dd 1e       	adc	r13, r29
   1020c:	ad b7       	in	r26, 0x3d	; 61
   1020e:	be b7       	in	r27, 0x3e	; 62
   10210:	12 96       	adiw	r26, 0x02	; 2
   10212:	dc 92       	st	X, r13
   10214:	ce 92       	st	-X, r12
   10216:	11 97       	sbiw	r26, 0x01	; 1
   10218:	88 ee       	ldi	r24, 0xE8	; 232
   1021a:	93 e0       	ldi	r25, 0x03	; 3
   1021c:	93 83       	std	Z+3, r25	; 0x03
   1021e:	82 83       	std	Z+2, r24	; 0x02
   10220:	75 82       	std	Z+5, r7	; 0x05
   10222:	64 82       	std	Z+4, r6	; 0x04
   10224:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>

	   sprintf_P(lcdteks,PSTR("Formated:%s"),strNumber);
   10228:	ed b7       	in	r30, 0x3d	; 61
   1022a:	fe b7       	in	r31, 0x3e	; 62
   1022c:	31 96       	adiw	r30, 0x01	; 1
   1022e:	ad b7       	in	r26, 0x3d	; 61
   10230:	be b7       	in	r27, 0x3e	; 62
   10232:	12 96       	adiw	r26, 0x02	; 2
   10234:	1c 93       	st	X, r17
   10236:	0e 93       	st	-X, r16
   10238:	11 97       	sbiw	r26, 0x01	; 1
   1023a:	8c ed       	ldi	r24, 0xDC	; 220
   1023c:	93 e0       	ldi	r25, 0x03	; 3
   1023e:	93 83       	std	Z+3, r25	; 0x03
   10240:	82 83       	std	Z+2, r24	; 0x02
   10242:	75 82       	std	Z+5, r7	; 0x05
   10244:	64 82       	std	Z+4, r6	; 0x04
   10246:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
       lcd_print(4,1,lcdteks);
   1024a:	8d b7       	in	r24, 0x3d	; 61
   1024c:	9e b7       	in	r25, 0x3e	; 62
   1024e:	06 96       	adiw	r24, 0x06	; 6
   10250:	0f b6       	in	r0, 0x3f	; 63
   10252:	f8 94       	cli
   10254:	9e bf       	out	0x3e, r25	; 62
   10256:	0f be       	out	0x3f, r0	; 63
   10258:	8d bf       	out	0x3d, r24	; 61
   1025a:	84 e0       	ldi	r24, 0x04	; 4
   1025c:	61 e0       	ldi	r22, 0x01	; 1
   1025e:	a8 01       	movw	r20, r16
   10260:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
	   sprintf_P(strSend,PSTR("Raw:%s"),strNumber);
   10264:	00 d0       	rcall	.+0      	; 0x10266 <TestUserInput+0x18a>
   10266:	00 d0       	rcall	.+0      	; 0x10268 <TestUserInput+0x18c>
   10268:	00 d0       	rcall	.+0      	; 0x1026a <TestUserInput+0x18e>
   1026a:	ed b7       	in	r30, 0x3d	; 61
   1026c:	fe b7       	in	r31, 0x3e	; 62
   1026e:	31 96       	adiw	r30, 0x01	; 1
   10270:	8e 01       	movw	r16, r28
   10272:	0f 5a       	subi	r16, 0xAF	; 175
   10274:	1f 4f       	sbci	r17, 0xFF	; 255
   10276:	ad b7       	in	r26, 0x3d	; 61
   10278:	be b7       	in	r27, 0x3e	; 62
   1027a:	12 96       	adiw	r26, 0x02	; 2
   1027c:	1c 93       	st	X, r17
   1027e:	0e 93       	st	-X, r16
   10280:	11 97       	sbiw	r26, 0x01	; 1
   10282:	85 ed       	ldi	r24, 0xD5	; 213
   10284:	93 e0       	ldi	r25, 0x03	; 3
   10286:	93 83       	std	Z+3, r25	; 0x03
   10288:	82 83       	std	Z+2, r24	; 0x02
   1028a:	75 82       	std	Z+5, r7	; 0x05
   1028c:	64 82       	std	Z+4, r6	; 0x04
   1028e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	   _uart_print(0,1,strSend);
   10292:	8d b7       	in	r24, 0x3d	; 61
   10294:	9e b7       	in	r25, 0x3e	; 62
   10296:	06 96       	adiw	r24, 0x06	; 6
   10298:	0f b6       	in	r0, 0x3f	; 63
   1029a:	f8 94       	cli
   1029c:	9e bf       	out	0x3e, r25	; 62
   1029e:	0f be       	out	0x3f, r0	; 63
   102a0:	8d bf       	out	0x3d, r24	; 61
   102a2:	80 e0       	ldi	r24, 0x00	; 0
   102a4:	61 e0       	ldi	r22, 0x01	; 1
   102a6:	a8 01       	movw	r20, r16
   102a8:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>

	   RemoveMinus(strNumber);
   102ac:	c3 01       	movw	r24, r6
   102ae:	0e 94 ef 23 	call	0x47de	; 0x47de <RemoveMinus>

	   sprintf_P(strSend,PSTR("Minus:%s"),strNumber);
   102b2:	00 d0       	rcall	.+0      	; 0x102b4 <TestUserInput+0x1d8>
   102b4:	00 d0       	rcall	.+0      	; 0x102b6 <TestUserInput+0x1da>
   102b6:	00 d0       	rcall	.+0      	; 0x102b8 <TestUserInput+0x1dc>
   102b8:	ed b7       	in	r30, 0x3d	; 61
   102ba:	fe b7       	in	r31, 0x3e	; 62
   102bc:	31 96       	adiw	r30, 0x01	; 1
   102be:	ad b7       	in	r26, 0x3d	; 61
   102c0:	be b7       	in	r27, 0x3e	; 62
   102c2:	12 96       	adiw	r26, 0x02	; 2
   102c4:	1c 93       	st	X, r17
   102c6:	0e 93       	st	-X, r16
   102c8:	11 97       	sbiw	r26, 0x01	; 1
   102ca:	8c ec       	ldi	r24, 0xCC	; 204
   102cc:	93 e0       	ldi	r25, 0x03	; 3
   102ce:	93 83       	std	Z+3, r25	; 0x03
   102d0:	82 83       	std	Z+2, r24	; 0x02
   102d2:	75 82       	std	Z+5, r7	; 0x05
   102d4:	64 82       	std	Z+4, r6	; 0x04
   102d6:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	   _uart_print(0,1,strSend);
   102da:	8d b7       	in	r24, 0x3d	; 61
   102dc:	9e b7       	in	r25, 0x3e	; 62
   102de:	06 96       	adiw	r24, 0x06	; 6
   102e0:	0f b6       	in	r0, 0x3f	; 63
   102e2:	f8 94       	cli
   102e4:	9e bf       	out	0x3e, r25	; 62
   102e6:	0f be       	out	0x3f, r0	; 63
   102e8:	8d bf       	out	0x3d, r24	; 61
   102ea:	80 e0       	ldi	r24, 0x00	; 0
   102ec:	61 e0       	ldi	r22, 0x01	; 1
   102ee:	a8 01       	movw	r20, r16
   102f0:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>

       
	   RemZeroLead(strNumber);
   102f4:	c3 01       	movw	r24, r6
   102f6:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
	   sprintf_P(strSend,PSTR("Removed:%s"),strNumber);
   102fa:	00 d0       	rcall	.+0      	; 0x102fc <TestUserInput+0x220>
   102fc:	00 d0       	rcall	.+0      	; 0x102fe <TestUserInput+0x222>
   102fe:	00 d0       	rcall	.+0      	; 0x10300 <TestUserInput+0x224>
   10300:	ed b7       	in	r30, 0x3d	; 61
   10302:	fe b7       	in	r31, 0x3e	; 62
   10304:	31 96       	adiw	r30, 0x01	; 1
   10306:	ad b7       	in	r26, 0x3d	; 61
   10308:	be b7       	in	r27, 0x3e	; 62
   1030a:	12 96       	adiw	r26, 0x02	; 2
   1030c:	1c 93       	st	X, r17
   1030e:	0e 93       	st	-X, r16
   10310:	11 97       	sbiw	r26, 0x01	; 1
   10312:	81 ec       	ldi	r24, 0xC1	; 193
   10314:	93 e0       	ldi	r25, 0x03	; 3
   10316:	93 83       	std	Z+3, r25	; 0x03
   10318:	82 83       	std	Z+2, r24	; 0x02
   1031a:	75 82       	std	Z+5, r7	; 0x05
   1031c:	64 82       	std	Z+4, r6	; 0x04
   1031e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	   _uart_print(0,1,strSend);
   10322:	8d b7       	in	r24, 0x3d	; 61
   10324:	9e b7       	in	r25, 0x3e	; 62
   10326:	06 96       	adiw	r24, 0x06	; 6
   10328:	0f b6       	in	r0, 0x3f	; 63
   1032a:	f8 94       	cli
   1032c:	9e bf       	out	0x3e, r25	; 62
   1032e:	0f be       	out	0x3f, r0	; 63
   10330:	8d bf       	out	0x3d, r24	; 61
   10332:	80 e0       	ldi	r24, 0x00	; 0
   10334:	61 e0       	ldi	r22, 0x01	; 1
   10336:	a8 01       	movw	r20, r16
   10338:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>

RemZeroLead(SVolume);
   1033c:	c7 01       	movw	r24, r14
   1033e:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
RemZeroLead(SMoney);
   10342:	c5 01       	movw	r24, r10
   10344:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
RemZeroLead(STotalVolume);
   10348:	c4 01       	movw	r24, r8
   1034a:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
RemZeroLead(STotalMoney);
   1034e:	c6 01       	movw	r24, r12
   10350:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
       
	   
	   FormatVolume(SVolume); 
   10354:	c7 01       	movw	r24, r14
   10356:	0e 94 f7 34 	call	0x69ee	; 0x69ee <FormatVolume>
	   FormatMoney(SMoney);
   1035a:	c5 01       	movw	r24, r10
   1035c:	0e 94 04 35 	call	0x6a08	; 0x6a08 <FormatMoney>
	   FormatTotalizerMoney(STotalVolume);
   10360:	c4 01       	movw	r24, r8
   10362:	0e 94 ea 34 	call	0x69d4	; 0x69d4 <FormatTotalizerMoney>
	   FormatTotalizerVolume(STotalMoney);
   10366:	c6 01       	movw	r24, r12
   10368:	0e 94 dd 34 	call	0x69ba	; 0x69ba <FormatTotalizerVolume>

	   sprintf_P(strSend,PSTR("Volume:%s"),SVolume);
   1036c:	00 d0       	rcall	.+0      	; 0x1036e <TestUserInput+0x292>
   1036e:	00 d0       	rcall	.+0      	; 0x10370 <TestUserInput+0x294>
   10370:	00 d0       	rcall	.+0      	; 0x10372 <TestUserInput+0x296>
   10372:	ed b7       	in	r30, 0x3d	; 61
   10374:	fe b7       	in	r31, 0x3e	; 62
   10376:	31 96       	adiw	r30, 0x01	; 1
   10378:	ad b7       	in	r26, 0x3d	; 61
   1037a:	be b7       	in	r27, 0x3e	; 62
   1037c:	12 96       	adiw	r26, 0x02	; 2
   1037e:	1c 93       	st	X, r17
   10380:	0e 93       	st	-X, r16
   10382:	11 97       	sbiw	r26, 0x01	; 1
   10384:	87 eb       	ldi	r24, 0xB7	; 183
   10386:	93 e0       	ldi	r25, 0x03	; 3
   10388:	93 83       	std	Z+3, r25	; 0x03
   1038a:	82 83       	std	Z+2, r24	; 0x02
   1038c:	f5 82       	std	Z+5, r15	; 0x05
   1038e:	e4 82       	std	Z+4, r14	; 0x04
   10390:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	   _uart_print(0,1,strSend);
   10394:	8d b7       	in	r24, 0x3d	; 61
   10396:	9e b7       	in	r25, 0x3e	; 62
   10398:	06 96       	adiw	r24, 0x06	; 6
   1039a:	0f b6       	in	r0, 0x3f	; 63
   1039c:	f8 94       	cli
   1039e:	9e bf       	out	0x3e, r25	; 62
   103a0:	0f be       	out	0x3f, r0	; 63
   103a2:	8d bf       	out	0x3d, r24	; 61
   103a4:	80 e0       	ldi	r24, 0x00	; 0
   103a6:	61 e0       	ldi	r22, 0x01	; 1
   103a8:	a8 01       	movw	r20, r16
   103aa:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	   sprintf_P(strSend,PSTR("Money:%s"),SMoney);
   103ae:	00 d0       	rcall	.+0      	; 0x103b0 <TestUserInput+0x2d4>
   103b0:	00 d0       	rcall	.+0      	; 0x103b2 <TestUserInput+0x2d6>
   103b2:	00 d0       	rcall	.+0      	; 0x103b4 <TestUserInput+0x2d8>
   103b4:	ed b7       	in	r30, 0x3d	; 61
   103b6:	fe b7       	in	r31, 0x3e	; 62
   103b8:	31 96       	adiw	r30, 0x01	; 1
   103ba:	ad b7       	in	r26, 0x3d	; 61
   103bc:	be b7       	in	r27, 0x3e	; 62
   103be:	12 96       	adiw	r26, 0x02	; 2
   103c0:	1c 93       	st	X, r17
   103c2:	0e 93       	st	-X, r16
   103c4:	11 97       	sbiw	r26, 0x01	; 1
   103c6:	8e ea       	ldi	r24, 0xAE	; 174
   103c8:	93 e0       	ldi	r25, 0x03	; 3
   103ca:	93 83       	std	Z+3, r25	; 0x03
   103cc:	82 83       	std	Z+2, r24	; 0x02
   103ce:	b5 82       	std	Z+5, r11	; 0x05
   103d0:	a4 82       	std	Z+4, r10	; 0x04
   103d2:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	   _uart_print(0,1,strSend);
   103d6:	8d b7       	in	r24, 0x3d	; 61
   103d8:	9e b7       	in	r25, 0x3e	; 62
   103da:	06 96       	adiw	r24, 0x06	; 6
   103dc:	0f b6       	in	r0, 0x3f	; 63
   103de:	f8 94       	cli
   103e0:	9e bf       	out	0x3e, r25	; 62
   103e2:	0f be       	out	0x3f, r0	; 63
   103e4:	8d bf       	out	0x3d, r24	; 61
   103e6:	80 e0       	ldi	r24, 0x00	; 0
   103e8:	61 e0       	ldi	r22, 0x01	; 1
   103ea:	a8 01       	movw	r20, r16
   103ec:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	   sprintf_P(strSend,PSTR("TVolume:%s"),STotalVolume);
   103f0:	00 d0       	rcall	.+0      	; 0x103f2 <TestUserInput+0x316>
   103f2:	00 d0       	rcall	.+0      	; 0x103f4 <TestUserInput+0x318>
   103f4:	00 d0       	rcall	.+0      	; 0x103f6 <TestUserInput+0x31a>
   103f6:	ed b7       	in	r30, 0x3d	; 61
   103f8:	fe b7       	in	r31, 0x3e	; 62
   103fa:	31 96       	adiw	r30, 0x01	; 1
   103fc:	ad b7       	in	r26, 0x3d	; 61
   103fe:	be b7       	in	r27, 0x3e	; 62
   10400:	12 96       	adiw	r26, 0x02	; 2
   10402:	1c 93       	st	X, r17
   10404:	0e 93       	st	-X, r16
   10406:	11 97       	sbiw	r26, 0x01	; 1
   10408:	83 ea       	ldi	r24, 0xA3	; 163
   1040a:	93 e0       	ldi	r25, 0x03	; 3
   1040c:	93 83       	std	Z+3, r25	; 0x03
   1040e:	82 83       	std	Z+2, r24	; 0x02
   10410:	95 82       	std	Z+5, r9	; 0x05
   10412:	84 82       	std	Z+4, r8	; 0x04
   10414:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	   _uart_print(0,1,strSend);
   10418:	8d b7       	in	r24, 0x3d	; 61
   1041a:	9e b7       	in	r25, 0x3e	; 62
   1041c:	06 96       	adiw	r24, 0x06	; 6
   1041e:	0f b6       	in	r0, 0x3f	; 63
   10420:	f8 94       	cli
   10422:	9e bf       	out	0x3e, r25	; 62
   10424:	0f be       	out	0x3f, r0	; 63
   10426:	8d bf       	out	0x3d, r24	; 61
   10428:	80 e0       	ldi	r24, 0x00	; 0
   1042a:	61 e0       	ldi	r22, 0x01	; 1
   1042c:	a8 01       	movw	r20, r16
   1042e:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	   sprintf_P(strSend,PSTR("TMoney:%s"),STotalMoney);
   10432:	00 d0       	rcall	.+0      	; 0x10434 <TestUserInput+0x358>
   10434:	00 d0       	rcall	.+0      	; 0x10436 <TestUserInput+0x35a>
   10436:	00 d0       	rcall	.+0      	; 0x10438 <TestUserInput+0x35c>
   10438:	ed b7       	in	r30, 0x3d	; 61
   1043a:	fe b7       	in	r31, 0x3e	; 62
   1043c:	31 96       	adiw	r30, 0x01	; 1
   1043e:	ad b7       	in	r26, 0x3d	; 61
   10440:	be b7       	in	r27, 0x3e	; 62
   10442:	12 96       	adiw	r26, 0x02	; 2
   10444:	1c 93       	st	X, r17
   10446:	0e 93       	st	-X, r16
   10448:	11 97       	sbiw	r26, 0x01	; 1
   1044a:	89 e9       	ldi	r24, 0x99	; 153
   1044c:	93 e0       	ldi	r25, 0x03	; 3
   1044e:	93 83       	std	Z+3, r25	; 0x03
   10450:	82 83       	std	Z+2, r24	; 0x02
   10452:	d5 82       	std	Z+5, r13	; 0x05
   10454:	c4 82       	std	Z+4, r12	; 0x04
   10456:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	   _uart_print(0,1,strSend);
   1045a:	8d b7       	in	r24, 0x3d	; 61
   1045c:	9e b7       	in	r25, 0x3e	; 62
   1045e:	06 96       	adiw	r24, 0x06	; 6
   10460:	0f b6       	in	r0, 0x3f	; 63
   10462:	f8 94       	cli
   10464:	9e bf       	out	0x3e, r25	; 62
   10466:	0f be       	out	0x3f, r0	; 63
   10468:	8d bf       	out	0x3d, r24	; 61
   1046a:	80 e0       	ldi	r24, 0x00	; 0
   1046c:	61 e0       	ldi	r22, 0x01	; 1
   1046e:	a8 01       	movw	r20, r16
   10470:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>

	   FormatCurrency(SMoney);
   10474:	c5 01       	movw	r24, r10
   10476:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>
	   FormatCurrency(STotalMoney);
   1047a:	c6 01       	movw	r24, r12
   1047c:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>
    
	   sprintf_P(strSend,PSTR("FmtMoney:%s"),SMoney);
   10480:	00 d0       	rcall	.+0      	; 0x10482 <TestUserInput+0x3a6>
   10482:	00 d0       	rcall	.+0      	; 0x10484 <TestUserInput+0x3a8>
   10484:	00 d0       	rcall	.+0      	; 0x10486 <TestUserInput+0x3aa>
   10486:	ed b7       	in	r30, 0x3d	; 61
   10488:	fe b7       	in	r31, 0x3e	; 62
   1048a:	31 96       	adiw	r30, 0x01	; 1
   1048c:	ad b7       	in	r26, 0x3d	; 61
   1048e:	be b7       	in	r27, 0x3e	; 62
   10490:	12 96       	adiw	r26, 0x02	; 2
   10492:	1c 93       	st	X, r17
   10494:	0e 93       	st	-X, r16
   10496:	11 97       	sbiw	r26, 0x01	; 1
   10498:	8d e8       	ldi	r24, 0x8D	; 141
   1049a:	93 e0       	ldi	r25, 0x03	; 3
   1049c:	93 83       	std	Z+3, r25	; 0x03
   1049e:	82 83       	std	Z+2, r24	; 0x02
   104a0:	b5 82       	std	Z+5, r11	; 0x05
   104a2:	a4 82       	std	Z+4, r10	; 0x04
   104a4:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	   _uart_print(0,1,strSend);
   104a8:	8d b7       	in	r24, 0x3d	; 61
   104aa:	9e b7       	in	r25, 0x3e	; 62
   104ac:	06 96       	adiw	r24, 0x06	; 6
   104ae:	0f b6       	in	r0, 0x3f	; 63
   104b0:	f8 94       	cli
   104b2:	9e bf       	out	0x3e, r25	; 62
   104b4:	0f be       	out	0x3f, r0	; 63
   104b6:	8d bf       	out	0x3d, r24	; 61
   104b8:	80 e0       	ldi	r24, 0x00	; 0
   104ba:	61 e0       	ldi	r22, 0x01	; 1
   104bc:	a8 01       	movw	r20, r16
   104be:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	   sprintf_P(strSend,PSTR("FmtTMoney:%s"),STotalMoney);
   104c2:	00 d0       	rcall	.+0      	; 0x104c4 <TestUserInput+0x3e8>
   104c4:	00 d0       	rcall	.+0      	; 0x104c6 <TestUserInput+0x3ea>
   104c6:	00 d0       	rcall	.+0      	; 0x104c8 <TestUserInput+0x3ec>
   104c8:	ed b7       	in	r30, 0x3d	; 61
   104ca:	fe b7       	in	r31, 0x3e	; 62
   104cc:	31 96       	adiw	r30, 0x01	; 1
   104ce:	ad b7       	in	r26, 0x3d	; 61
   104d0:	be b7       	in	r27, 0x3e	; 62
   104d2:	12 96       	adiw	r26, 0x02	; 2
   104d4:	1c 93       	st	X, r17
   104d6:	0e 93       	st	-X, r16
   104d8:	11 97       	sbiw	r26, 0x01	; 1
   104da:	80 e8       	ldi	r24, 0x80	; 128
   104dc:	93 e0       	ldi	r25, 0x03	; 3
   104de:	93 83       	std	Z+3, r25	; 0x03
   104e0:	82 83       	std	Z+2, r24	; 0x02
   104e2:	d5 82       	std	Z+5, r13	; 0x05
   104e4:	c4 82       	std	Z+4, r12	; 0x04
   104e6:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	   _uart_print(0,1,strSend);
   104ea:	8d b7       	in	r24, 0x3d	; 61
   104ec:	9e b7       	in	r25, 0x3e	; 62
   104ee:	06 96       	adiw	r24, 0x06	; 6
   104f0:	0f b6       	in	r0, 0x3f	; 63
   104f2:	f8 94       	cli
   104f4:	9e bf       	out	0x3e, r25	; 62
   104f6:	0f be       	out	0x3f, r0	; 63
   104f8:	8d bf       	out	0x3d, r24	; 61
   104fa:	80 e0       	ldi	r24, 0x00	; 0
   104fc:	61 e0       	ldi	r22, 0x01	; 1
   104fe:	a8 01       	movw	r20, r16
   10500:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
   10504:	02 c0       	rjmp	.+4      	; 0x1050a <TestUserInput+0x42e>


   	
	}else    
	if (uiResult==USER_CANCEL){
   10506:	81 30       	cpi	r24, 0x01	; 1
   10508:	11 f0       	breq	.+4      	; 0x1050e <TestUserInput+0x432>
   1050a:	80 e0       	ldi	r24, 0x00	; 0
   1050c:	0b c0       	rjmp	.+22     	; 0x10524 <TestUserInput+0x448>
	   lcd_clear();
   1050e:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
   10512:	fe 01       	movw	r30, r28
   10514:	fd 96       	adiw	r30, 0x3d	; 61

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10516:	cf 01       	movw	r24, r30
   10518:	0f 96       	adiw	r24, 0x0f	; 15
	     strMemory[i]=data;
   1051a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   1051c:	e8 17       	cp	r30, r24
   1051e:	f9 07       	cpc	r31, r25
   10520:	e1 f7       	brne	.-8      	; 0x1051a <TestUserInput+0x43e>
   10522:	81 e0       	ldi	r24, 0x01	; 1
       Result=MENU_DONE;   
	   //lcd_printf(1,1,PSTR("InputNumber:"));
       //lcd_printf(2,1,PSTR("_         "));
	}
  return Result;
}
   10524:	c2 59       	subi	r28, 0x92	; 146
   10526:	df 4f       	sbci	r29, 0xFF	; 255
   10528:	0f b6       	in	r0, 0x3f	; 63
   1052a:	f8 94       	cli
   1052c:	de bf       	out	0x3e, r29	; 62
   1052e:	0f be       	out	0x3f, r0	; 63
   10530:	cd bf       	out	0x3d, r28	; 61
   10532:	cf 91       	pop	r28
   10534:	df 91       	pop	r29
   10536:	1f 91       	pop	r17
   10538:	0f 91       	pop	r16
   1053a:	ff 90       	pop	r15
   1053c:	ef 90       	pop	r14
   1053e:	df 90       	pop	r13
   10540:	cf 90       	pop	r12
   10542:	bf 90       	pop	r11
   10544:	af 90       	pop	r10
   10546:	9f 90       	pop	r9
   10548:	8f 90       	pop	r8
   1054a:	7f 90       	pop	r7
   1054c:	6f 90       	pop	r6
   1054e:	08 95       	ret

00010550 <FSettingDec>:

	Result=MENU_DONE;
	return Result;
}

char FSettingDec(){
   10550:	df 92       	push	r13
   10552:	ef 92       	push	r14
   10554:	ff 92       	push	r15
   10556:	0f 93       	push	r16
   10558:	1f 93       	push	r17
   1055a:	df 93       	push	r29
   1055c:	cf 93       	push	r28
   1055e:	cd b7       	in	r28, 0x3d	; 61
   10560:	de b7       	in	r29, 0x3e	; 62
   10562:	64 97       	sbiw	r28, 0x14	; 20
   10564:	0f b6       	in	r0, 0x3f	; 63
   10566:	f8 94       	cli
   10568:	de bf       	out	0x3e, r29	; 62
   1056a:	0f be       	out	0x3f, r0	; 63
   1056c:	cd bf       	out	0x3d, r28	; 61
static char stSettingDecimal=sdInitDisplay;
     char PDecimalConfig[4],Addr,KeyChar,Result;
	 char lcdteks[20];

     Result=MENU_NONE;
	 switch(stSettingDecimal){
   1056e:	80 91 e3 02 	lds	r24, 0x02E3
   10572:	82 30       	cpi	r24, 0x02	; 2
   10574:	09 f4       	brne	.+2      	; 0x10578 <FSettingDec+0x28>
   10576:	c7 c0       	rjmp	.+398    	; 0x10706 <FSettingDec+0x1b6>
   10578:	83 30       	cpi	r24, 0x03	; 3
   1057a:	30 f4       	brcc	.+12     	; 0x10588 <FSettingDec+0x38>
   1057c:	88 23       	and	r24, r24
   1057e:	71 f0       	breq	.+28     	; 0x1059c <FSettingDec+0x4c>
   10580:	81 30       	cpi	r24, 0x01	; 1
   10582:	09 f0       	breq	.+2      	; 0x10586 <FSettingDec+0x36>
   10584:	c3 c1       	rjmp	.+902    	; 0x1090c <FSettingDec+0x3bc>
   10586:	92 c0       	rjmp	.+292    	; 0x106ac <FSettingDec+0x15c>
   10588:	84 30       	cpi	r24, 0x04	; 4
   1058a:	09 f4       	brne	.+2      	; 0x1058e <FSettingDec+0x3e>
   1058c:	b3 c1       	rjmp	.+870    	; 0x108f4 <FSettingDec+0x3a4>
   1058e:	84 30       	cpi	r24, 0x04	; 4
   10590:	08 f4       	brcc	.+2      	; 0x10594 <FSettingDec+0x44>
   10592:	68 c1       	rjmp	.+720    	; 0x10864 <FSettingDec+0x314>
   10594:	85 30       	cpi	r24, 0x05	; 5
   10596:	09 f0       	breq	.+2      	; 0x1059a <FSettingDec+0x4a>
   10598:	b9 c1       	rjmp	.+882    	; 0x1090c <FSettingDec+0x3bc>
   1059a:	b4 c1       	rjmp	.+872    	; 0x10904 <FSettingDec+0x3b4>
	 case sdInitDisplay:
	      lcd_clear();         //"12345678901234567890
   1059c:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   105a0:	e1 99       	sbic	0x1c, 1	; 28
   105a2:	fe cf       	rjmp	.-4      	; 0x105a0 <FSettingDec+0x50>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   105a4:	89 e3       	ldi	r24, 0x39	; 57
   105a6:	90 e0       	ldi	r25, 0x00	; 0
   105a8:	9f bb       	out	0x1f, r25	; 31
   105aa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   105ac:	e0 9a       	sbi	0x1c, 0	; 28
   105ae:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   105b0:	e1 99       	sbic	0x1c, 1	; 28
   105b2:	fe cf       	rjmp	.-4      	; 0x105b0 <FSettingDec+0x60>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   105b4:	8a e3       	ldi	r24, 0x3A	; 58
   105b6:	90 e0       	ldi	r25, 0x00	; 0
   105b8:	9f bb       	out	0x1f, r25	; 31
   105ba:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   105bc:	e0 9a       	sbi	0x1c, 0	; 28
   105be:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   105c0:	e1 99       	sbic	0x1c, 1	; 28
   105c2:	fe cf       	rjmp	.-4      	; 0x105c0 <FSettingDec+0x70>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   105c4:	8b e3       	ldi	r24, 0x3B	; 59
   105c6:	90 e0       	ldi	r25, 0x00	; 0
   105c8:	9f bb       	out	0x1f, r25	; 31
   105ca:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   105cc:	e0 9a       	sbi	0x1c, 0	; 28
   105ce:	fd b2       	in	r15, 0x1d	; 29
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalPrice);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalVolume);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMoney);

		  sprintf_P(lcdteks,PSTR("1.Price :%d"),PDecimalConfig[0]);
   105d0:	00 d0       	rcall	.+0      	; 0x105d2 <FSettingDec+0x82>
   105d2:	00 d0       	rcall	.+0      	; 0x105d4 <FSettingDec+0x84>
   105d4:	00 d0       	rcall	.+0      	; 0x105d6 <FSettingDec+0x86>
   105d6:	ed b7       	in	r30, 0x3d	; 61
   105d8:	fe b7       	in	r31, 0x3e	; 62
   105da:	31 96       	adiw	r30, 0x01	; 1
   105dc:	8e 01       	movw	r16, r28
   105de:	0f 5f       	subi	r16, 0xFF	; 255
   105e0:	1f 4f       	sbci	r17, 0xFF	; 255
   105e2:	ad b7       	in	r26, 0x3d	; 61
   105e4:	be b7       	in	r27, 0x3e	; 62
   105e6:	12 96       	adiw	r26, 0x02	; 2
   105e8:	1c 93       	st	X, r17
   105ea:	0e 93       	st	-X, r16
   105ec:	11 97       	sbiw	r26, 0x01	; 1
   105ee:	8d e5       	ldi	r24, 0x5D	; 93
   105f0:	91 e1       	ldi	r25, 0x11	; 17
   105f2:	93 83       	std	Z+3, r25	; 0x03
   105f4:	82 83       	std	Z+2, r24	; 0x02
   105f6:	24 83       	std	Z+4, r18	; 0x04
   105f8:	15 82       	std	Z+5, r1	; 0x05
   105fa:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   105fe:	8d b7       	in	r24, 0x3d	; 61
   10600:	9e b7       	in	r25, 0x3e	; 62
   10602:	06 96       	adiw	r24, 0x06	; 6
   10604:	0f b6       	in	r0, 0x3f	; 63
   10606:	f8 94       	cli
   10608:	9e bf       	out	0x3e, r25	; 62
   1060a:	0f be       	out	0x3f, r0	; 63
   1060c:	8d bf       	out	0x3d, r24	; 61
   1060e:	81 e0       	ldi	r24, 0x01	; 1
   10610:	61 e0       	ldi	r22, 0x01	; 1
   10612:	a8 01       	movw	r20, r16
   10614:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.Volume:%d"),PDecimalConfig[1]);
   10618:	00 d0       	rcall	.+0      	; 0x1061a <FSettingDec+0xca>
   1061a:	00 d0       	rcall	.+0      	; 0x1061c <FSettingDec+0xcc>
   1061c:	00 d0       	rcall	.+0      	; 0x1061e <FSettingDec+0xce>
   1061e:	ed b7       	in	r30, 0x3d	; 61
   10620:	fe b7       	in	r31, 0x3e	; 62
   10622:	31 96       	adiw	r30, 0x01	; 1
   10624:	ad b7       	in	r26, 0x3d	; 61
   10626:	be b7       	in	r27, 0x3e	; 62
   10628:	12 96       	adiw	r26, 0x02	; 2
   1062a:	1c 93       	st	X, r17
   1062c:	0e 93       	st	-X, r16
   1062e:	11 97       	sbiw	r26, 0x01	; 1
   10630:	81 e5       	ldi	r24, 0x51	; 81
   10632:	91 e1       	ldi	r25, 0x11	; 17
   10634:	93 83       	std	Z+3, r25	; 0x03
   10636:	82 83       	std	Z+2, r24	; 0x02
   10638:	e4 82       	std	Z+4, r14	; 0x04
   1063a:	15 82       	std	Z+5, r1	; 0x05
   1063c:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   10640:	8d b7       	in	r24, 0x3d	; 61
   10642:	9e b7       	in	r25, 0x3e	; 62
   10644:	06 96       	adiw	r24, 0x06	; 6
   10646:	0f b6       	in	r0, 0x3f	; 63
   10648:	f8 94       	cli
   1064a:	9e bf       	out	0x3e, r25	; 62
   1064c:	0f be       	out	0x3f, r0	; 63
   1064e:	8d bf       	out	0x3d, r24	; 61
   10650:	82 e0       	ldi	r24, 0x02	; 2
   10652:	61 e0       	ldi	r22, 0x01	; 1
   10654:	a8 01       	movw	r20, r16
   10656:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Money :%d"),PDecimalConfig[2]);
   1065a:	00 d0       	rcall	.+0      	; 0x1065c <FSettingDec+0x10c>
   1065c:	00 d0       	rcall	.+0      	; 0x1065e <FSettingDec+0x10e>
   1065e:	00 d0       	rcall	.+0      	; 0x10660 <FSettingDec+0x110>
   10660:	ed b7       	in	r30, 0x3d	; 61
   10662:	fe b7       	in	r31, 0x3e	; 62
   10664:	31 96       	adiw	r30, 0x01	; 1
   10666:	ad b7       	in	r26, 0x3d	; 61
   10668:	be b7       	in	r27, 0x3e	; 62
   1066a:	12 96       	adiw	r26, 0x02	; 2
   1066c:	1c 93       	st	X, r17
   1066e:	0e 93       	st	-X, r16
   10670:	11 97       	sbiw	r26, 0x01	; 1
   10672:	85 e4       	ldi	r24, 0x45	; 69
   10674:	91 e1       	ldi	r25, 0x11	; 17
   10676:	93 83       	std	Z+3, r25	; 0x03
   10678:	82 83       	std	Z+2, r24	; 0x02
   1067a:	f4 82       	std	Z+4, r15	; 0x04
   1067c:	15 82       	std	Z+5, r1	; 0x05
   1067e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   10682:	8d b7       	in	r24, 0x3d	; 61
   10684:	9e b7       	in	r25, 0x3e	; 62
   10686:	06 96       	adiw	r24, 0x06	; 6
   10688:	0f b6       	in	r0, 0x3f	; 63
   1068a:	f8 94       	cli
   1068c:	9e bf       	out	0x3e, r25	; 62
   1068e:	0f be       	out	0x3f, r0	; 63
   10690:	8d bf       	out	0x3d, r24	; 61
   10692:	83 e0       	ldi	r24, 0x03	; 3
   10694:	61 e0       	ldi	r22, 0x01	; 1
   10696:	a8 01       	movw	r20, r16
   10698:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]Back  [#]Next"));
   1069c:	84 e0       	ldi	r24, 0x04	; 4
   1069e:	61 e0       	ldi	r22, 0x01	; 1
   106a0:	44 e3       	ldi	r20, 0x34	; 52
   106a2:	51 e1       	ldi	r21, 0x11	; 17
   106a4:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  stSettingDecimal=sdSelectKey1;
   106a8:	81 e0       	ldi	r24, 0x01	; 1
   106aa:	29 c1       	rjmp	.+594    	; 0x108fe <FSettingDec+0x3ae>
		  break;
     case sdSelectKey1:
          KeyChar=_key_btn(_key_scan(1));
   106ac:	81 e0       	ldi	r24, 0x01	; 1
   106ae:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   106b2:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='3')){
   106b6:	98 2f       	mov	r25, r24
   106b8:	91 53       	subi	r25, 0x31	; 49
   106ba:	93 30       	cpi	r25, 0x03	; 3
   106bc:	e0 f4       	brcc	.+56     	; 0x106f6 <FSettingDec+0x1a6>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalPrice+Addr);
   106be:	29 2f       	mov	r18, r25
   106c0:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   106c2:	e1 99       	sbic	0x1c, 1	; 28
   106c4:	fe cf       	rjmp	.-4      	; 0x106c2 <FSettingDec+0x172>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   106c6:	c9 01       	movw	r24, r18
   106c8:	87 5c       	subi	r24, 0xC7	; 199
   106ca:	9f 4f       	sbci	r25, 0xFF	; 255
   106cc:	9f bb       	out	0x1f, r25	; 31
   106ce:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   106d0:	e0 9a       	sbi	0x1c, 0	; 28
   106d2:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   106d4:	e1 99       	sbic	0x1c, 1	; 28
   106d6:	fe cf       	rjmp	.-4      	; 0x106d4 <FSettingDec+0x184>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   106d8:	27 5c       	subi	r18, 0xC7	; 199
   106da:	3f 4f       	sbci	r19, 0xFF	; 255
   106dc:	3f bb       	out	0x1f, r19	; 31
   106de:	2e bb       	out	0x1e, r18	; 30
			  PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
   106e0:	90 e0       	ldi	r25, 0x00	; 0
   106e2:	01 96       	adiw	r24, 0x01	; 1
   106e4:	83 70       	andi	r24, 0x03	; 3
   106e6:	90 70       	andi	r25, 0x00	; 0
#endif
    EEDR = __value;
   106e8:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   106ea:	0f b6       	in	r0, 0x3f	; 63
   106ec:	f8 94       	cli
   106ee:	e2 9a       	sbi	0x1c, 2	; 28
   106f0:	e1 9a       	sbi	0x1c, 1	; 28
   106f2:	0f be       	out	0x3f, r0	; 63
   106f4:	f6 c0       	rjmp	.+492    	; 0x108e2 <FSettingDec+0x392>

			  eeprom_write_byte(&DefDecimalPrice+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay;
		  }else if (KeyChar=='*') stSettingDecimal=sdExitSettingDecimal;
   106f6:	8a 32       	cpi	r24, 0x2A	; 42
   106f8:	11 f4       	brne	.+4      	; 0x106fe <FSettingDec+0x1ae>
   106fa:	85 e0       	ldi	r24, 0x05	; 5
   106fc:	00 c1       	rjmp	.+512    	; 0x108fe <FSettingDec+0x3ae>
		  else if (KeyChar=='#') stSettingDecimal=sdInitDisplay2;
   106fe:	83 32       	cpi	r24, 0x23	; 35
   10700:	09 f0       	breq	.+2      	; 0x10704 <FSettingDec+0x1b4>
   10702:	04 c1       	rjmp	.+520    	; 0x1090c <FSettingDec+0x3bc>
   10704:	fb c0       	rjmp	.+502    	; 0x108fc <FSettingDec+0x3ac>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10706:	e1 99       	sbic	0x1c, 1	; 28
   10708:	fe cf       	rjmp	.-4      	; 0x10706 <FSettingDec+0x1b6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1070a:	8c e3       	ldi	r24, 0x3C	; 60
   1070c:	90 e0       	ldi	r25, 0x00	; 0
   1070e:	9f bb       	out	0x1f, r25	; 31
   10710:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10712:	e0 9a       	sbi	0x1c, 0	; 28
   10714:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10716:	e1 99       	sbic	0x1c, 1	; 28
   10718:	fe cf       	rjmp	.-4      	; 0x10716 <FSettingDec+0x1c6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1071a:	8d e3       	ldi	r24, 0x3D	; 61
   1071c:	90 e0       	ldi	r25, 0x00	; 0
   1071e:	9f bb       	out	0x1f, r25	; 31
   10720:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10722:	e0 9a       	sbi	0x1c, 0	; 28
   10724:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10726:	e1 99       	sbic	0x1c, 1	; 28
   10728:	fe cf       	rjmp	.-4      	; 0x10726 <FSettingDec+0x1d6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1072a:	8e e3       	ldi	r24, 0x3E	; 62
   1072c:	90 e0       	ldi	r25, 0x00	; 0
   1072e:	9f bb       	out	0x1f, r25	; 31
   10730:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10732:	e0 9a       	sbi	0x1c, 0	; 28
   10734:	dd b2       	in	r13, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10736:	e1 99       	sbic	0x1c, 1	; 28
   10738:	fe cf       	rjmp	.-4      	; 0x10736 <FSettingDec+0x1e6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1073a:	8f e3       	ldi	r24, 0x3F	; 63
   1073c:	90 e0       	ldi	r25, 0x00	; 0
   1073e:	9f bb       	out	0x1f, r25	; 31
   10740:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10742:	e0 9a       	sbi	0x1c, 0	; 28
   10744:	fd b2       	in	r15, 0x1d	; 29
     case sdInitDisplay2:
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalTotalVolume);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalTotalMoney);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMark);
		  PDecimalConfig[3]=eeprom_read_byte(&DefCurrencyMark);
		  sprintf_P(lcdteks,PSTR("1.T.Volume:%d  5.Test"),PDecimalConfig[0]);
   10746:	00 d0       	rcall	.+0      	; 0x10748 <FSettingDec+0x1f8>
   10748:	00 d0       	rcall	.+0      	; 0x1074a <FSettingDec+0x1fa>
   1074a:	00 d0       	rcall	.+0      	; 0x1074c <FSettingDec+0x1fc>
   1074c:	ed b7       	in	r30, 0x3d	; 61
   1074e:	fe b7       	in	r31, 0x3e	; 62
   10750:	31 96       	adiw	r30, 0x01	; 1
   10752:	8e 01       	movw	r16, r28
   10754:	0f 5f       	subi	r16, 0xFF	; 255
   10756:	1f 4f       	sbci	r17, 0xFF	; 255
   10758:	ad b7       	in	r26, 0x3d	; 61
   1075a:	be b7       	in	r27, 0x3e	; 62
   1075c:	12 96       	adiw	r26, 0x02	; 2
   1075e:	1c 93       	st	X, r17
   10760:	0e 93       	st	-X, r16
   10762:	11 97       	sbiw	r26, 0x01	; 1
   10764:	8e e1       	ldi	r24, 0x1E	; 30
   10766:	91 e1       	ldi	r25, 0x11	; 17
   10768:	93 83       	std	Z+3, r25	; 0x03
   1076a:	82 83       	std	Z+2, r24	; 0x02
   1076c:	24 83       	std	Z+4, r18	; 0x04
   1076e:	15 82       	std	Z+5, r1	; 0x05
   10770:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   10774:	8d b7       	in	r24, 0x3d	; 61
   10776:	9e b7       	in	r25, 0x3e	; 62
   10778:	06 96       	adiw	r24, 0x06	; 6
   1077a:	0f b6       	in	r0, 0x3f	; 63
   1077c:	f8 94       	cli
   1077e:	9e bf       	out	0x3e, r25	; 62
   10780:	0f be       	out	0x3f, r0	; 63
   10782:	8d bf       	out	0x3d, r24	; 61
   10784:	81 e0       	ldi	r24, 0x01	; 1
   10786:	61 e0       	ldi	r22, 0x01	; 1
   10788:	a8 01       	movw	r20, r16
   1078a:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.T.Money :%d "),PDecimalConfig[1]);
   1078e:	00 d0       	rcall	.+0      	; 0x10790 <FSettingDec+0x240>
   10790:	00 d0       	rcall	.+0      	; 0x10792 <FSettingDec+0x242>
   10792:	00 d0       	rcall	.+0      	; 0x10794 <FSettingDec+0x244>
   10794:	ed b7       	in	r30, 0x3d	; 61
   10796:	fe b7       	in	r31, 0x3e	; 62
   10798:	31 96       	adiw	r30, 0x01	; 1
   1079a:	ad b7       	in	r26, 0x3d	; 61
   1079c:	be b7       	in	r27, 0x3e	; 62
   1079e:	12 96       	adiw	r26, 0x02	; 2
   107a0:	1c 93       	st	X, r17
   107a2:	0e 93       	st	-X, r16
   107a4:	11 97       	sbiw	r26, 0x01	; 1
   107a6:	8f e0       	ldi	r24, 0x0F	; 15
   107a8:	91 e1       	ldi	r25, 0x11	; 17
   107aa:	93 83       	std	Z+3, r25	; 0x03
   107ac:	82 83       	std	Z+2, r24	; 0x02
   107ae:	e4 82       	std	Z+4, r14	; 0x04
   107b0:	15 82       	std	Z+5, r1	; 0x05
   107b2:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   107b6:	8d b7       	in	r24, 0x3d	; 61
   107b8:	9e b7       	in	r25, 0x3e	; 62
   107ba:	06 96       	adiw	r24, 0x06	; 6
   107bc:	0f b6       	in	r0, 0x3f	; 63
   107be:	f8 94       	cli
   107c0:	9e bf       	out	0x3e, r25	; 62
   107c2:	0f be       	out	0x3f, r0	; 63
   107c4:	8d bf       	out	0x3d, r24	; 61
   107c6:	82 e0       	ldi	r24, 0x02	; 2
   107c8:	61 e0       	ldi	r22, 0x01	; 1
   107ca:	a8 01       	movw	r20, r16
   107cc:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Decimal :%c "),PDecimalConfig[2]);
   107d0:	00 d0       	rcall	.+0      	; 0x107d2 <FSettingDec+0x282>
   107d2:	00 d0       	rcall	.+0      	; 0x107d4 <FSettingDec+0x284>
   107d4:	00 d0       	rcall	.+0      	; 0x107d6 <FSettingDec+0x286>
   107d6:	ed b7       	in	r30, 0x3d	; 61
   107d8:	fe b7       	in	r31, 0x3e	; 62
   107da:	31 96       	adiw	r30, 0x01	; 1
   107dc:	ad b7       	in	r26, 0x3d	; 61
   107de:	be b7       	in	r27, 0x3e	; 62
   107e0:	12 96       	adiw	r26, 0x02	; 2
   107e2:	1c 93       	st	X, r17
   107e4:	0e 93       	st	-X, r16
   107e6:	11 97       	sbiw	r26, 0x01	; 1
   107e8:	80 e0       	ldi	r24, 0x00	; 0
   107ea:	91 e1       	ldi	r25, 0x11	; 17
   107ec:	93 83       	std	Z+3, r25	; 0x03
   107ee:	82 83       	std	Z+2, r24	; 0x02
   107f0:	d4 82       	std	Z+4, r13	; 0x04
   107f2:	15 82       	std	Z+5, r1	; 0x05
   107f4:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   107f8:	8d b7       	in	r24, 0x3d	; 61
   107fa:	9e b7       	in	r25, 0x3e	; 62
   107fc:	06 96       	adiw	r24, 0x06	; 6
   107fe:	0f b6       	in	r0, 0x3f	; 63
   10800:	f8 94       	cli
   10802:	9e bf       	out	0x3e, r25	; 62
   10804:	0f be       	out	0x3f, r0	; 63
   10806:	8d bf       	out	0x3d, r24	; 61
   10808:	83 e0       	ldi	r24, 0x03	; 3
   1080a:	61 e0       	ldi	r22, 0x01	; 1
   1080c:	a8 01       	movw	r20, r16
   1080e:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("4.Sparator:%c "),PDecimalConfig[3]);
   10812:	00 d0       	rcall	.+0      	; 0x10814 <FSettingDec+0x2c4>
   10814:	00 d0       	rcall	.+0      	; 0x10816 <FSettingDec+0x2c6>
   10816:	00 d0       	rcall	.+0      	; 0x10818 <FSettingDec+0x2c8>
   10818:	ed b7       	in	r30, 0x3d	; 61
   1081a:	fe b7       	in	r31, 0x3e	; 62
   1081c:	31 96       	adiw	r30, 0x01	; 1
   1081e:	ad b7       	in	r26, 0x3d	; 61
   10820:	be b7       	in	r27, 0x3e	; 62
   10822:	12 96       	adiw	r26, 0x02	; 2
   10824:	1c 93       	st	X, r17
   10826:	0e 93       	st	-X, r16
   10828:	11 97       	sbiw	r26, 0x01	; 1
   1082a:	81 ef       	ldi	r24, 0xF1	; 241
   1082c:	90 e1       	ldi	r25, 0x10	; 16
   1082e:	93 83       	std	Z+3, r25	; 0x03
   10830:	82 83       	std	Z+2, r24	; 0x02
   10832:	f4 82       	std	Z+4, r15	; 0x04
   10834:	15 82       	std	Z+5, r1	; 0x05
   10836:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(4,1,lcdteks);
   1083a:	8d b7       	in	r24, 0x3d	; 61
   1083c:	9e b7       	in	r25, 0x3e	; 62
   1083e:	06 96       	adiw	r24, 0x06	; 6
   10840:	0f b6       	in	r0, 0x3f	; 63
   10842:	f8 94       	cli
   10844:	9e bf       	out	0x3e, r25	; 62
   10846:	0f be       	out	0x3f, r0	; 63
   10848:	8d bf       	out	0x3d, r24	; 61
   1084a:	84 e0       	ldi	r24, 0x04	; 4
   1084c:	61 e0       	ldi	r22, 0x01	; 1
   1084e:	a8 01       	movw	r20, r16
   10850:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_printf(4,14,PSTR("*)Back"));
   10854:	84 e0       	ldi	r24, 0x04	; 4
   10856:	6e e0       	ldi	r22, 0x0E	; 14
   10858:	4a ee       	ldi	r20, 0xEA	; 234
   1085a:	50 e1       	ldi	r21, 0x10	; 16
   1085c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	      stSettingDecimal=sdSelectKey2;
   10860:	83 e0       	ldi	r24, 0x03	; 3
   10862:	4d c0       	rjmp	.+154    	; 0x108fe <FSettingDec+0x3ae>
	      break;
     case sdSelectKey2:
          KeyChar=_key_btn(_key_scan(1));
   10864:	81 e0       	ldi	r24, 0x01	; 1
   10866:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   1086a:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   1086e:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
   10870:	98 2f       	mov	r25, r24
   10872:	91 53       	subi	r25, 0x31	; 49
   10874:	92 30       	cpi	r25, 0x02	; 2
   10876:	b0 f4       	brcc	.+44     	; 0x108a4 <FSettingDec+0x354>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
   10878:	29 2f       	mov	r18, r25
   1087a:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1087c:	e1 99       	sbic	0x1c, 1	; 28
   1087e:	fe cf       	rjmp	.-4      	; 0x1087c <FSettingDec+0x32c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10880:	c9 01       	movw	r24, r18
   10882:	84 5c       	subi	r24, 0xC4	; 196
   10884:	9f 4f       	sbci	r25, 0xFF	; 255
   10886:	9f bb       	out	0x1f, r25	; 31
   10888:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1088a:	e0 9a       	sbi	0x1c, 0	; 28
   1088c:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1088e:	e1 99       	sbic	0x1c, 1	; 28
   10890:	fe cf       	rjmp	.-4      	; 0x1088e <FSettingDec+0x33e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10892:	24 5c       	subi	r18, 0xC4	; 196
   10894:	3f 4f       	sbci	r19, 0xFF	; 255
   10896:	3f bb       	out	0x1f, r19	; 31
   10898:	2e bb       	out	0x1e, r18	; 30
		      PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
   1089a:	90 e0       	ldi	r25, 0x00	; 0
   1089c:	01 96       	adiw	r24, 0x01	; 1
   1089e:	83 70       	andi	r24, 0x03	; 3
   108a0:	90 70       	andi	r25, 0x00	; 0
   108a2:	16 c0       	rjmp	.+44     	; 0x108d0 <FSettingDec+0x380>

			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if ((KeyChar>='3')&&(KeyChar<='4')){
   108a4:	83 53       	subi	r24, 0x33	; 51
   108a6:	82 30       	cpi	r24, 0x02	; 2
   108a8:	d0 f4       	brcc	.+52     	; 0x108de <FSettingDec+0x38e>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
   108aa:	09 2f       	mov	r16, r25
   108ac:	10 e0       	ldi	r17, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   108ae:	e1 99       	sbic	0x1c, 1	; 28
   108b0:	fe cf       	rjmp	.-4      	; 0x108ae <FSettingDec+0x35e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   108b2:	c8 01       	movw	r24, r16
   108b4:	84 5c       	subi	r24, 0xC4	; 196
   108b6:	9f 4f       	sbci	r25, 0xFF	; 255
   108b8:	9f bb       	out	0x1f, r25	; 31
   108ba:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   108bc:	e0 9a       	sbi	0x1c, 0	; 28
   108be:	8d b3       	in	r24, 0x1d	; 29
			  PDecimalConfig[Addr]=SelectMark(PDecimalConfig[Addr]);
   108c0:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <SelectMark>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   108c4:	e1 99       	sbic	0x1c, 1	; 28
   108c6:	fe cf       	rjmp	.-4      	; 0x108c4 <FSettingDec+0x374>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   108c8:	04 5c       	subi	r16, 0xC4	; 196
   108ca:	1f 4f       	sbci	r17, 0xFF	; 255
   108cc:	1f bb       	out	0x1f, r17	; 31
   108ce:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   108d0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   108d2:	0f b6       	in	r0, 0x3f	; 63
   108d4:	f8 94       	cli
   108d6:	e2 9a       	sbi	0x1c, 2	; 28
   108d8:	e1 9a       	sbi	0x1c, 1	; 28
   108da:	0f be       	out	0x3f, r0	; 63
   108dc:	0f c0       	rjmp	.+30     	; 0x108fc <FSettingDec+0x3ac>
			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if (KeyChar=='*') stSettingDecimal=sdInitDisplay;
   108de:	2a 32       	cpi	r18, 0x2A	; 42
   108e0:	19 f4       	brne	.+6      	; 0x108e8 <FSettingDec+0x398>
   108e2:	10 92 e3 02 	sts	0x02E3, r1
   108e6:	12 c0       	rjmp	.+36     	; 0x1090c <FSettingDec+0x3bc>
		  else if (KeyChar=='5'){
   108e8:	25 33       	cpi	r18, 0x35	; 53
   108ea:	81 f4       	brne	.+32     	; 0x1090c <FSettingDec+0x3bc>
		          lcd_clear();
   108ec:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		          stSettingDecimal=sdTestInput;
   108f0:	84 e0       	ldi	r24, 0x04	; 4
   108f2:	05 c0       	rjmp	.+10     	; 0x108fe <FSettingDec+0x3ae>
				  }
          break;
     case sdTestInput:
	      if (TestUserInput()==MENU_DONE)stSettingDecimal=sdInitDisplay2;
   108f4:	0e 94 6e 80 	call	0x100dc	; 0x100dc <TestUserInput>
   108f8:	81 30       	cpi	r24, 0x01	; 1
   108fa:	41 f4       	brne	.+16     	; 0x1090c <FSettingDec+0x3bc>
   108fc:	82 e0       	ldi	r24, 0x02	; 2
   108fe:	80 93 e3 02 	sts	0x02E3, r24
   10902:	04 c0       	rjmp	.+8      	; 0x1090c <FSettingDec+0x3bc>
	      break;
	 case sdExitSettingDecimal:
          stSettingDecimal=sdInitDisplay;
   10904:	10 92 e3 02 	sts	0x02E3, r1
   10908:	81 e0       	ldi	r24, 0x01	; 1
   1090a:	01 c0       	rjmp	.+2      	; 0x1090e <FSettingDec+0x3be>
   1090c:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
    return Result;
}
   1090e:	64 96       	adiw	r28, 0x14	; 20
   10910:	0f b6       	in	r0, 0x3f	; 63
   10912:	f8 94       	cli
   10914:	de bf       	out	0x3e, r29	; 62
   10916:	0f be       	out	0x3f, r0	; 63
   10918:	cd bf       	out	0x3d, r28	; 61
   1091a:	cf 91       	pop	r28
   1091c:	df 91       	pop	r29
   1091e:	1f 91       	pop	r17
   10920:	0f 91       	pop	r16
   10922:	ff 90       	pop	r15
   10924:	ef 90       	pop	r14
   10926:	df 90       	pop	r13
   10928:	08 95       	ret

0001092a <FTestCalculation>:
	 }
  return Result;
}


void FTestCalculation(){
   1092a:	cf 92       	push	r12
   1092c:	df 92       	push	r13
   1092e:	ef 92       	push	r14
   10930:	ff 92       	push	r15
   10932:	0f 93       	push	r16
   10934:	1f 93       	push	r17
   10936:	df 93       	push	r29
   10938:	cf 93       	push	r28
   1093a:	cd b7       	in	r28, 0x3d	; 61
   1093c:	de b7       	in	r29, 0x3e	; 62
   1093e:	64 97       	sbiw	r28, 0x14	; 20
   10940:	0f b6       	in	r0, 0x3f	; 63
   10942:	f8 94       	cli
   10944:	de bf       	out	0x3e, r29	; 62
   10946:	0f be       	out	0x3f, r0	; 63
   10948:	cd bf       	out	0x3d, r28	; 61
static char stTestCalc=tcInitData,uiResult=USER_NONE;
static char InputA[20],InputB[20],OutputC[20];
     char lcdteks[20],KeyChar;
     
	 switch(stTestCalc){
   1094a:	80 91 52 02 	lds	r24, 0x0252
   1094e:	82 30       	cpi	r24, 0x02	; 2
   10950:	09 f4       	brne	.+2      	; 0x10954 <FTestCalculation+0x2a>
   10952:	4b c0       	rjmp	.+150    	; 0x109ea <FTestCalculation+0xc0>
   10954:	83 30       	cpi	r24, 0x03	; 3
   10956:	30 f4       	brcc	.+12     	; 0x10964 <FTestCalculation+0x3a>
   10958:	88 23       	and	r24, r24
   1095a:	71 f0       	breq	.+28     	; 0x10978 <FTestCalculation+0x4e>
   1095c:	81 30       	cpi	r24, 0x01	; 1
   1095e:	09 f0       	breq	.+2      	; 0x10962 <FTestCalculation+0x38>
   10960:	e7 c0       	rjmp	.+462    	; 0x10b30 <FTestCalculation+0x206>
   10962:	2f c0       	rjmp	.+94     	; 0x109c2 <FTestCalculation+0x98>
   10964:	84 30       	cpi	r24, 0x04	; 4
   10966:	09 f4       	brne	.+2      	; 0x1096a <FTestCalculation+0x40>
   10968:	82 c0       	rjmp	.+260    	; 0x10a6e <FTestCalculation+0x144>
   1096a:	84 30       	cpi	r24, 0x04	; 4
   1096c:	08 f4       	brcc	.+2      	; 0x10970 <FTestCalculation+0x46>
   1096e:	6d c0       	rjmp	.+218    	; 0x10a4a <FTestCalculation+0x120>
   10970:	85 30       	cpi	r24, 0x05	; 5
   10972:	09 f0       	breq	.+2      	; 0x10976 <FTestCalculation+0x4c>
   10974:	dd c0       	rjmp	.+442    	; 0x10b30 <FTestCalculation+0x206>
   10976:	d1 c0       	rjmp	.+418    	; 0x10b1a <FTestCalculation+0x1f0>
	 case tcInitData:
	      lcd_clear();
   10978:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("Operation Multiply"));
   1097c:	81 e0       	ldi	r24, 0x01	; 1
   1097e:	61 e0       	ldi	r22, 0x01	; 1
   10980:	4c ed       	ldi	r20, 0xDC	; 220
   10982:	55 e0       	ldi	r21, 0x05	; 5
   10984:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2,1,PSTR("InA:_"));
   10988:	82 e0       	ldi	r24, 0x02	; 2
   1098a:	61 e0       	ldi	r22, 0x01	; 1
   1098c:	46 ed       	ldi	r20, 0xD6	; 214
   1098e:	55 e0       	ldi	r21, 0x05	; 5
   10990:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   10994:	ad e3       	ldi	r26, 0x3D	; 61
   10996:	b2 e0       	ldi	r27, 0x02	; 2
   10998:	fd 01       	movw	r30, r26
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   1099a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   1099c:	82 e0       	ldi	r24, 0x02	; 2
   1099e:	e1 35       	cpi	r30, 0x51	; 81
   109a0:	f8 07       	cpc	r31, r24
   109a2:	d9 f7       	brne	.-10     	; 0x1099a <FTestCalculation+0x70>
   109a4:	74 97       	sbiw	r30, 0x14	; 20
	     strMemory[i]=data;
   109a6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   109a8:	92 e0       	ldi	r25, 0x02	; 2
   109aa:	e1 35       	cpi	r30, 0x51	; 81
   109ac:	f9 07       	cpc	r31, r25
   109ae:	d9 f7       	brne	.-10     	; 0x109a6 <FTestCalculation+0x7c>
	     strMemory[i]=data;
   109b0:	1d 92       	st	X+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   109b2:	82 e0       	ldi	r24, 0x02	; 2
   109b4:	a1 35       	cpi	r26, 0x51	; 81
   109b6:	b8 07       	cpc	r27, r24
   109b8:	d9 f7       	brne	.-10     	; 0x109b0 <FTestCalculation+0x86>
		  lcd_printf(2,1,PSTR("InA:_"));
		  FillChar(InputA,sizeof(InputA),0);
		  FillChar(InputA,sizeof(InputB),0);
		  FillChar(InputA,sizeof(OutputC),0);

		  uiResult=USER_NONE;
   109ba:	10 92 51 02 	sts	0x0251, r1
          stTestCalc=tcInputA;
   109be:	81 e0       	ldi	r24, 0x01	; 1
   109c0:	11 c0       	rjmp	.+34     	; 0x109e4 <FTestCalculation+0xba>
	      break;
     case tcInputA:
	      uiResult=UserInput(UI_ALPHANUM_R,2,5,InputA,0,15);
   109c2:	83 e0       	ldi	r24, 0x03	; 3
   109c4:	62 e0       	ldi	r22, 0x02	; 2
   109c6:	45 e0       	ldi	r20, 0x05	; 5
   109c8:	2d e3       	ldi	r18, 0x3D	; 61
   109ca:	32 e0       	ldi	r19, 0x02	; 2
   109cc:	00 e0       	ldi	r16, 0x00	; 0
   109ce:	10 e0       	ldi	r17, 0x00	; 0
   109d0:	9f e0       	ldi	r25, 0x0F	; 15
   109d2:	e9 2e       	mov	r14, r25
   109d4:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
   109d8:	80 93 51 02 	sts	0x0251, r24
	      if (uiResult==USER_OK)stTestCalc=tcDispInputA;
   109dc:	83 30       	cpi	r24, 0x03	; 3
   109de:	09 f0       	breq	.+2      	; 0x109e2 <FTestCalculation+0xb8>
   109e0:	a7 c0       	rjmp	.+334    	; 0x10b30 <FTestCalculation+0x206>
   109e2:	82 e0       	ldi	r24, 0x02	; 2
   109e4:	80 93 52 02 	sts	0x0252, r24
   109e8:	a3 c0       	rjmp	.+326    	; 0x10b30 <FTestCalculation+0x206>
	      break;
     case tcDispInputA:
	      sprintf_P(lcdteks,PSTR("InA:%s"),InputA);
   109ea:	00 d0       	rcall	.+0      	; 0x109ec <FTestCalculation+0xc2>
   109ec:	00 d0       	rcall	.+0      	; 0x109ee <FTestCalculation+0xc4>
   109ee:	00 d0       	rcall	.+0      	; 0x109f0 <FTestCalculation+0xc6>
   109f0:	ed b7       	in	r30, 0x3d	; 61
   109f2:	fe b7       	in	r31, 0x3e	; 62
   109f4:	31 96       	adiw	r30, 0x01	; 1
   109f6:	8e 01       	movw	r16, r28
   109f8:	0f 5f       	subi	r16, 0xFF	; 255
   109fa:	1f 4f       	sbci	r17, 0xFF	; 255
   109fc:	ad b7       	in	r26, 0x3d	; 61
   109fe:	be b7       	in	r27, 0x3e	; 62
   10a00:	12 96       	adiw	r26, 0x02	; 2
   10a02:	1c 93       	st	X, r17
   10a04:	0e 93       	st	-X, r16
   10a06:	11 97       	sbiw	r26, 0x01	; 1
   10a08:	8f ec       	ldi	r24, 0xCF	; 207
   10a0a:	95 e0       	ldi	r25, 0x05	; 5
   10a0c:	93 83       	std	Z+3, r25	; 0x03
   10a0e:	82 83       	std	Z+2, r24	; 0x02
   10a10:	8d e3       	ldi	r24, 0x3D	; 61
   10a12:	92 e0       	ldi	r25, 0x02	; 2
   10a14:	95 83       	std	Z+5, r25	; 0x05
   10a16:	84 83       	std	Z+4, r24	; 0x04
   10a18:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   10a1c:	8d b7       	in	r24, 0x3d	; 61
   10a1e:	9e b7       	in	r25, 0x3e	; 62
   10a20:	06 96       	adiw	r24, 0x06	; 6
   10a22:	0f b6       	in	r0, 0x3f	; 63
   10a24:	f8 94       	cli
   10a26:	9e bf       	out	0x3e, r25	; 62
   10a28:	0f be       	out	0x3f, r0	; 63
   10a2a:	8d bf       	out	0x3d, r24	; 61
   10a2c:	82 e0       	ldi	r24, 0x02	; 2
   10a2e:	61 e0       	ldi	r22, 0x01	; 1
   10a30:	a8 01       	movw	r20, r16
   10a32:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_printf(3,1,PSTR("InB:_"));
   10a36:	83 e0       	ldi	r24, 0x03	; 3
   10a38:	61 e0       	ldi	r22, 0x01	; 1
   10a3a:	49 ec       	ldi	r20, 0xC9	; 201
   10a3c:	55 e0       	ldi	r21, 0x05	; 5
   10a3e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  uiResult=USER_NONE;
   10a42:	10 92 51 02 	sts	0x0251, r1
          stTestCalc=tcInputB;
   10a46:	83 e0       	ldi	r24, 0x03	; 3
   10a48:	cd cf       	rjmp	.-102    	; 0x109e4 <FTestCalculation+0xba>
	      break;
     case tcInputB:
	 	  uiResult=UserInput(UI_ALPHANUM_R,3,5,InputB,0,15);
   10a4a:	83 e0       	ldi	r24, 0x03	; 3
   10a4c:	63 e0       	ldi	r22, 0x03	; 3
   10a4e:	45 e0       	ldi	r20, 0x05	; 5
   10a50:	29 e2       	ldi	r18, 0x29	; 41
   10a52:	32 e0       	ldi	r19, 0x02	; 2
   10a54:	00 e0       	ldi	r16, 0x00	; 0
   10a56:	10 e0       	ldi	r17, 0x00	; 0
   10a58:	bf e0       	ldi	r27, 0x0F	; 15
   10a5a:	eb 2e       	mov	r14, r27
   10a5c:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
   10a60:	80 93 51 02 	sts	0x0251, r24
	      if (uiResult==USER_OK)stTestCalc=tcCalcualte;
   10a64:	83 30       	cpi	r24, 0x03	; 3
   10a66:	09 f0       	breq	.+2      	; 0x10a6a <FTestCalculation+0x140>
   10a68:	63 c0       	rjmp	.+198    	; 0x10b30 <FTestCalculation+0x206>
   10a6a:	84 e0       	ldi	r24, 0x04	; 4
   10a6c:	bb cf       	rjmp	.-138    	; 0x109e4 <FTestCalculation+0xba>
	      break;
     case tcCalcualte:
	      sprintf_P(lcdteks,PSTR("InB:%s"),InputB);
   10a6e:	00 d0       	rcall	.+0      	; 0x10a70 <FTestCalculation+0x146>
   10a70:	00 d0       	rcall	.+0      	; 0x10a72 <FTestCalculation+0x148>
   10a72:	00 d0       	rcall	.+0      	; 0x10a74 <FTestCalculation+0x14a>
   10a74:	ed b7       	in	r30, 0x3d	; 61
   10a76:	fe b7       	in	r31, 0x3e	; 62
   10a78:	31 96       	adiw	r30, 0x01	; 1
   10a7a:	8e 01       	movw	r16, r28
   10a7c:	0f 5f       	subi	r16, 0xFF	; 255
   10a7e:	1f 4f       	sbci	r17, 0xFF	; 255
   10a80:	ad b7       	in	r26, 0x3d	; 61
   10a82:	be b7       	in	r27, 0x3e	; 62
   10a84:	12 96       	adiw	r26, 0x02	; 2
   10a86:	1c 93       	st	X, r17
   10a88:	0e 93       	st	-X, r16
   10a8a:	11 97       	sbiw	r26, 0x01	; 1
   10a8c:	82 ec       	ldi	r24, 0xC2	; 194
   10a8e:	95 e0       	ldi	r25, 0x05	; 5
   10a90:	93 83       	std	Z+3, r25	; 0x03
   10a92:	82 83       	std	Z+2, r24	; 0x02
   10a94:	a9 e2       	ldi	r26, 0x29	; 41
   10a96:	ea 2e       	mov	r14, r26
   10a98:	a2 e0       	ldi	r26, 0x02	; 2
   10a9a:	fa 2e       	mov	r15, r26
   10a9c:	f5 82       	std	Z+5, r15	; 0x05
   10a9e:	e4 82       	std	Z+4, r14	; 0x04
   10aa0:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   10aa4:	8d b7       	in	r24, 0x3d	; 61
   10aa6:	9e b7       	in	r25, 0x3e	; 62
   10aa8:	06 96       	adiw	r24, 0x06	; 6
   10aaa:	0f b6       	in	r0, 0x3f	; 63
   10aac:	f8 94       	cli
   10aae:	9e bf       	out	0x3e, r25	; 62
   10ab0:	0f be       	out	0x3f, r0	; 63
   10ab2:	8d bf       	out	0x3d, r24	; 61
   10ab4:	83 e0       	ldi	r24, 0x03	; 3
   10ab6:	61 e0       	ldi	r22, 0x01	; 1
   10ab8:	a8 01       	movw	r20, r16
   10aba:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  //StrCalc(TMINUS,InputA,InputB,OutputC);
		  //StrCalc(TPLUS,InputA,InputB,OutputC);
		  StrCalc(TMULTIPLY,InputA,InputB,OutputC);
   10abe:	f5 e1       	ldi	r31, 0x15	; 21
   10ac0:	cf 2e       	mov	r12, r31
   10ac2:	f2 e0       	ldi	r31, 0x02	; 2
   10ac4:	df 2e       	mov	r13, r31
   10ac6:	82 e0       	ldi	r24, 0x02	; 2
   10ac8:	6d e3       	ldi	r22, 0x3D	; 61
   10aca:	72 e0       	ldi	r23, 0x02	; 2
   10acc:	a7 01       	movw	r20, r14
   10ace:	96 01       	movw	r18, r12
   10ad0:	0e 94 ef 29 	call	0x53de	; 0x53de <StrCalc>
	      sprintf_P(lcdteks,PSTR("A+B:%s"),OutputC);
   10ad4:	00 d0       	rcall	.+0      	; 0x10ad6 <FTestCalculation+0x1ac>
   10ad6:	00 d0       	rcall	.+0      	; 0x10ad8 <FTestCalculation+0x1ae>
   10ad8:	00 d0       	rcall	.+0      	; 0x10ada <FTestCalculation+0x1b0>
   10ada:	ed b7       	in	r30, 0x3d	; 61
   10adc:	fe b7       	in	r31, 0x3e	; 62
   10ade:	31 96       	adiw	r30, 0x01	; 1
   10ae0:	ad b7       	in	r26, 0x3d	; 61
   10ae2:	be b7       	in	r27, 0x3e	; 62
   10ae4:	12 96       	adiw	r26, 0x02	; 2
   10ae6:	1c 93       	st	X, r17
   10ae8:	0e 93       	st	-X, r16
   10aea:	11 97       	sbiw	r26, 0x01	; 1
   10aec:	8b eb       	ldi	r24, 0xBB	; 187
   10aee:	95 e0       	ldi	r25, 0x05	; 5
   10af0:	93 83       	std	Z+3, r25	; 0x03
   10af2:	82 83       	std	Z+2, r24	; 0x02
   10af4:	d5 82       	std	Z+5, r13	; 0x05
   10af6:	c4 82       	std	Z+4, r12	; 0x04
   10af8:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(4,1,lcdteks);
   10afc:	8d b7       	in	r24, 0x3d	; 61
   10afe:	9e b7       	in	r25, 0x3e	; 62
   10b00:	06 96       	adiw	r24, 0x06	; 6
   10b02:	0f b6       	in	r0, 0x3f	; 63
   10b04:	f8 94       	cli
   10b06:	9e bf       	out	0x3e, r25	; 62
   10b08:	0f be       	out	0x3f, r0	; 63
   10b0a:	8d bf       	out	0x3d, r24	; 61
   10b0c:	84 e0       	ldi	r24, 0x04	; 4
   10b0e:	61 e0       	ldi	r22, 0x01	; 1
   10b10:	a8 01       	movw	r20, r16
   10b12:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
          stTestCalc=tcWaitEnter;
   10b16:	85 e0       	ldi	r24, 0x05	; 5
   10b18:	65 cf       	rjmp	.-310    	; 0x109e4 <FTestCalculation+0xba>
	      break;
     case tcWaitEnter:
	      KeyChar= _key_btn(_key_scan(1));       
   10b1a:	81 e0       	ldi	r24, 0x01	; 1
   10b1c:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   10b20:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
		  if (KeyChar=='#')stTestCalc=tcInitData;
   10b24:	83 32       	cpi	r24, 0x23	; 35
   10b26:	11 f0       	breq	.+4      	; 0x10b2c <FTestCalculation+0x202>
		  else
		  if (KeyChar=='*')stTestCalc=tcInitData;
   10b28:	8a 32       	cpi	r24, 0x2A	; 42
   10b2a:	11 f4       	brne	.+4      	; 0x10b30 <FTestCalculation+0x206>
   10b2c:	10 92 52 02 	sts	0x0252, r1
	      break;	 
	 }
}
   10b30:	64 96       	adiw	r28, 0x14	; 20
   10b32:	0f b6       	in	r0, 0x3f	; 63
   10b34:	f8 94       	cli
   10b36:	de bf       	out	0x3e, r29	; 62
   10b38:	0f be       	out	0x3f, r0	; 63
   10b3a:	cd bf       	out	0x3d, r28	; 61
   10b3c:	cf 91       	pop	r28
   10b3e:	df 91       	pop	r29
   10b40:	1f 91       	pop	r17
   10b42:	0f 91       	pop	r16
   10b44:	ff 90       	pop	r15
   10b46:	ef 90       	pop	r14
   10b48:	df 90       	pop	r13
   10b4a:	cf 90       	pop	r12
   10b4c:	08 95       	ret

00010b4e <FMenuTicket>:
	    StrResult[2]='0'+Val;
	    StrResult[3]=0;
		}   
}

char FMenuTicket(){
   10b4e:	ef 92       	push	r14
   10b50:	0f 93       	push	r16
   10b52:	1f 93       	push	r17
   10b54:	df 93       	push	r29
   10b56:	cf 93       	push	r28
   10b58:	cd b7       	in	r28, 0x3d	; 61
   10b5a:	de b7       	in	r29, 0x3e	; 62
   10b5c:	64 97       	sbiw	r28, 0x14	; 20
   10b5e:	0f b6       	in	r0, 0x3f	; 63
   10b60:	f8 94       	cli
   10b62:	de bf       	out	0x3e, r29	; 62
   10b64:	0f be       	out	0x3f, r0	; 63
   10b66:	cd bf       	out	0x3d, r28	; 61
static char uiResult=USER_NONE,iPos,iSend,KeyPressed,KeyChar,FIP_Used,zFIP_Used;
static unsigned int iLoop=0;
     char Result=MENU_NONE,lcdteks[20];

    Result=MENU_NONE;   
    switch(stMenuTicket){
   10b68:	80 91 d0 02 	lds	r24, 0x02D0
   10b6c:	86 30       	cpi	r24, 0x06	; 6
   10b6e:	09 f4       	brne	.+2      	; 0x10b72 <FMenuTicket+0x24>
   10b70:	c8 c0       	rjmp	.+400    	; 0x10d02 <FMenuTicket+0x1b4>
   10b72:	87 30       	cpi	r24, 0x07	; 7
   10b74:	90 f4       	brcc	.+36     	; 0x10b9a <FMenuTicket+0x4c>
   10b76:	82 30       	cpi	r24, 0x02	; 2
   10b78:	09 f4       	brne	.+2      	; 0x10b7c <FMenuTicket+0x2e>
   10b7a:	3f c0       	rjmp	.+126    	; 0x10bfa <FMenuTicket+0xac>
   10b7c:	83 30       	cpi	r24, 0x03	; 3
   10b7e:	30 f4       	brcc	.+12     	; 0x10b8c <FMenuTicket+0x3e>
   10b80:	88 23       	and	r24, r24
   10b82:	09 f1       	breq	.+66     	; 0x10bc6 <FMenuTicket+0x78>
   10b84:	81 30       	cpi	r24, 0x01	; 1
   10b86:	09 f0       	breq	.+2      	; 0x10b8a <FMenuTicket+0x3c>
   10b88:	33 c1       	rjmp	.+614    	; 0x10df0 <FMenuTicket+0x2a2>
   10b8a:	1f c0       	rjmp	.+62     	; 0x10bca <FMenuTicket+0x7c>
   10b8c:	84 30       	cpi	r24, 0x04	; 4
   10b8e:	09 f4       	brne	.+2      	; 0x10b92 <FMenuTicket+0x44>
   10b90:	8d c0       	rjmp	.+282    	; 0x10cac <FMenuTicket+0x15e>
   10b92:	85 30       	cpi	r24, 0x05	; 5
   10b94:	08 f0       	brcs	.+2      	; 0x10b98 <FMenuTicket+0x4a>
   10b96:	af c0       	rjmp	.+350    	; 0x10cf6 <FMenuTicket+0x1a8>
   10b98:	51 c0       	rjmp	.+162    	; 0x10c3c <FMenuTicket+0xee>
   10b9a:	89 30       	cpi	r24, 0x09	; 9
   10b9c:	09 f4       	brne	.+2      	; 0x10ba0 <FMenuTicket+0x52>
   10b9e:	03 c1       	rjmp	.+518    	; 0x10da6 <FMenuTicket+0x258>
   10ba0:	8a 30       	cpi	r24, 0x0A	; 10
   10ba2:	38 f4       	brcc	.+14     	; 0x10bb2 <FMenuTicket+0x64>
   10ba4:	87 30       	cpi	r24, 0x07	; 7
   10ba6:	09 f4       	brne	.+2      	; 0x10baa <FMenuTicket+0x5c>
   10ba8:	df c0       	rjmp	.+446    	; 0x10d68 <FMenuTicket+0x21a>
   10baa:	88 30       	cpi	r24, 0x08	; 8
   10bac:	09 f0       	breq	.+2      	; 0x10bb0 <FMenuTicket+0x62>
   10bae:	20 c1       	rjmp	.+576    	; 0x10df0 <FMenuTicket+0x2a2>
   10bb0:	cb c0       	rjmp	.+406    	; 0x10d48 <FMenuTicket+0x1fa>
   10bb2:	8b 30       	cpi	r24, 0x0B	; 11
   10bb4:	09 f4       	brne	.+2      	; 0x10bb8 <FMenuTicket+0x6a>
   10bb6:	fd c0       	rjmp	.+506    	; 0x10db2 <FMenuTicket+0x264>
   10bb8:	8b 30       	cpi	r24, 0x0B	; 11
   10bba:	08 f4       	brcc	.+2      	; 0x10bbe <FMenuTicket+0x70>
   10bbc:	13 c1       	rjmp	.+550    	; 0x10de4 <FMenuTicket+0x296>
   10bbe:	8c 30       	cpi	r24, 0x0C	; 12
   10bc0:	09 f0       	breq	.+2      	; 0x10bc4 <FMenuTicket+0x76>
   10bc2:	16 c1       	rjmp	.+556    	; 0x10df0 <FMenuTicket+0x2a2>
   10bc4:	11 c1       	rjmp	.+546    	; 0x10de8 <FMenuTicket+0x29a>
	case mtInit:
		 stMenuTicket=mtPlatNo;
   10bc6:	81 e0       	ldi	r24, 0x01	; 1
   10bc8:	81 c0       	rjmp	.+258    	; 0x10ccc <FMenuTicket+0x17e>
	     break;
    case mtPlatNo:
	     lcd_clear();
   10bca:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
	     lcd_printf(1,1,PSTR("Input Plat No: "));
   10bce:	81 e0       	ldi	r24, 0x01	; 1
   10bd0:	61 e0       	ldi	r22, 0x01	; 1
   10bd2:	4f ee       	ldi	r20, 0xEF	; 239
   10bd4:	5a e0       	ldi	r21, 0x0A	; 10
   10bd6:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	     lcd_printf(2,1,PSTR("_"));
   10bda:	82 e0       	ldi	r24, 0x02	; 2
   10bdc:	61 e0       	ldi	r22, 0x01	; 1
   10bde:	4d ee       	ldi	r20, 0xED	; 237
   10be0:	5a e0       	ldi	r21, 0x0A	; 10
   10be2:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   10be6:	84 e0       	ldi	r24, 0x04	; 4
   10be8:	61 e0       	ldi	r22, 0x01	; 1
   10bea:	48 ed       	ldi	r20, 0xD8	; 216
   10bec:	5a e0       	ldi	r21, 0x0A	; 10
   10bee:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		 uiResult=USER_NONE;
   10bf2:	10 92 cf 02 	sts	0x02CF, r1
		 stMenuTicket=mtInputPlatNo;
   10bf6:	82 e0       	ldi	r24, 0x02	; 2
   10bf8:	69 c0       	rjmp	.+210    	; 0x10ccc <FMenuTicket+0x17e>
	     break;
    case mtInputPlatNo:
	     uiResult=UserInput(UI_ALPHANUM_R,2,1,strLicPlate,0,10);
   10bfa:	83 e0       	ldi	r24, 0x03	; 3
   10bfc:	62 e0       	ldi	r22, 0x02	; 2
   10bfe:	41 e0       	ldi	r20, 0x01	; 1
   10c00:	20 e6       	ldi	r18, 0x60	; 96
   10c02:	3c e0       	ldi	r19, 0x0C	; 12
   10c04:	00 e0       	ldi	r16, 0x00	; 0
   10c06:	10 e0       	ldi	r17, 0x00	; 0
   10c08:	7a e0       	ldi	r23, 0x0A	; 10
   10c0a:	e7 2e       	mov	r14, r23
   10c0c:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
   10c10:	80 93 cf 02 	sts	0x02CF, r24
		 if (uiResult==USER_OK)stMenuTicket=mtOdometer;
   10c14:	83 30       	cpi	r24, 0x03	; 3
   10c16:	09 f4       	brne	.+2      	; 0x10c1a <FMenuTicket+0xcc>
   10c18:	59 c0       	rjmp	.+178    	; 0x10ccc <FMenuTicket+0x17e>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtExitMenuTicket;
   10c1a:	81 30       	cpi	r24, 0x01	; 1
   10c1c:	09 f4       	brne	.+2      	; 0x10c20 <FMenuTicket+0xd2>
   10c1e:	e2 c0       	rjmp	.+452    	; 0x10de4 <FMenuTicket+0x296>
         else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10c20:	84 30       	cpi	r24, 0x04	; 4
   10c22:	21 f4       	brne	.+8      	; 0x10c2c <FMenuTicket+0xde>
   10c24:	61 e0       	ldi	r22, 0x01	; 1
   10c26:	43 ec       	ldi	r20, 0xC3	; 195
   10c28:	5a e0       	ldi	r21, 0x0A	; 10
   10c2a:	62 c0       	rjmp	.+196    	; 0x10cf0 <FMenuTicket+0x1a2>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10c2c:	85 30       	cpi	r24, 0x05	; 5
   10c2e:	09 f0       	breq	.+2      	; 0x10c32 <FMenuTicket+0xe4>
   10c30:	df c0       	rjmp	.+446    	; 0x10df0 <FMenuTicket+0x2a2>
   10c32:	84 e0       	ldi	r24, 0x04	; 4
   10c34:	61 e0       	ldi	r22, 0x01	; 1
   10c36:	4e ea       	ldi	r20, 0xAE	; 174
   10c38:	5a e0       	ldi	r21, 0x0A	; 10
   10c3a:	5a c0       	rjmp	.+180    	; 0x10cf0 <FMenuTicket+0x1a2>
	     break;
    case mtOdometer:
	     lcd_clear();
   10c3c:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		 sprintf_P(lcdteks,PSTR("Plat No: %s "),strLicPlate);
   10c40:	00 d0       	rcall	.+0      	; 0x10c42 <FMenuTicket+0xf4>
   10c42:	00 d0       	rcall	.+0      	; 0x10c44 <FMenuTicket+0xf6>
   10c44:	00 d0       	rcall	.+0      	; 0x10c46 <FMenuTicket+0xf8>
   10c46:	ed b7       	in	r30, 0x3d	; 61
   10c48:	fe b7       	in	r31, 0x3e	; 62
   10c4a:	31 96       	adiw	r30, 0x01	; 1
   10c4c:	8e 01       	movw	r16, r28
   10c4e:	0f 5f       	subi	r16, 0xFF	; 255
   10c50:	1f 4f       	sbci	r17, 0xFF	; 255
   10c52:	ad b7       	in	r26, 0x3d	; 61
   10c54:	be b7       	in	r27, 0x3e	; 62
   10c56:	12 96       	adiw	r26, 0x02	; 2
   10c58:	1c 93       	st	X, r17
   10c5a:	0e 93       	st	-X, r16
   10c5c:	11 97       	sbiw	r26, 0x01	; 1
   10c5e:	81 ea       	ldi	r24, 0xA1	; 161
   10c60:	9a e0       	ldi	r25, 0x0A	; 10
   10c62:	93 83       	std	Z+3, r25	; 0x03
   10c64:	82 83       	std	Z+2, r24	; 0x02
   10c66:	80 e6       	ldi	r24, 0x60	; 96
   10c68:	9c e0       	ldi	r25, 0x0C	; 12
   10c6a:	95 83       	std	Z+5, r25	; 0x05
   10c6c:	84 83       	std	Z+4, r24	; 0x04
   10c6e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	     lcd_print(1,1,lcdteks);
   10c72:	8d b7       	in	r24, 0x3d	; 61
   10c74:	9e b7       	in	r25, 0x3e	; 62
   10c76:	06 96       	adiw	r24, 0x06	; 6
   10c78:	0f b6       	in	r0, 0x3f	; 63
   10c7a:	f8 94       	cli
   10c7c:	9e bf       	out	0x3e, r25	; 62
   10c7e:	0f be       	out	0x3f, r0	; 63
   10c80:	8d bf       	out	0x3d, r24	; 61
   10c82:	81 e0       	ldi	r24, 0x01	; 1
   10c84:	61 e0       	ldi	r22, 0x01	; 1
   10c86:	a8 01       	movw	r20, r16
   10c88:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
	     lcd_printf(2,1,PSTR("Odometer:_ "));
   10c8c:	82 e0       	ldi	r24, 0x02	; 2
   10c8e:	61 e0       	ldi	r22, 0x01	; 1
   10c90:	45 e9       	ldi	r20, 0x95	; 149
   10c92:	5a e0       	ldi	r21, 0x0A	; 10
   10c94:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   10c98:	84 e0       	ldi	r24, 0x04	; 4
   10c9a:	61 e0       	ldi	r22, 0x01	; 1
   10c9c:	40 e8       	ldi	r20, 0x80	; 128
   10c9e:	5a e0       	ldi	r21, 0x0A	; 10
   10ca0:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		 uiResult=USER_NONE;
   10ca4:	10 92 cf 02 	sts	0x02CF, r1
		 stMenuTicket=mtInputOdometer;
   10ca8:	84 e0       	ldi	r24, 0x04	; 4
   10caa:	10 c0       	rjmp	.+32     	; 0x10ccc <FMenuTicket+0x17e>
	     break;
    case mtInputOdometer:
	     uiResult=UserInput(UI_NUMBER_R,2,10,strOdometer,0,10);
   10cac:	81 e0       	ldi	r24, 0x01	; 1
   10cae:	62 e0       	ldi	r22, 0x02	; 2
   10cb0:	4a e0       	ldi	r20, 0x0A	; 10
   10cb2:	23 ea       	ldi	r18, 0xA3	; 163
   10cb4:	35 e0       	ldi	r19, 0x05	; 5
   10cb6:	00 e0       	ldi	r16, 0x00	; 0
   10cb8:	10 e0       	ldi	r17, 0x00	; 0
   10cba:	5a e0       	ldi	r21, 0x0A	; 10
   10cbc:	e5 2e       	mov	r14, r21
   10cbe:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
   10cc2:	80 93 cf 02 	sts	0x02CF, r24
		 if (uiResult==USER_OK)stMenuTicket=mtFIP;
   10cc6:	83 30       	cpi	r24, 0x03	; 3
   10cc8:	21 f4       	brne	.+8      	; 0x10cd2 <FMenuTicket+0x184>
   10cca:	85 e0       	ldi	r24, 0x05	; 5
   10ccc:	80 93 d0 02 	sts	0x02D0, r24
   10cd0:	8f c0       	rjmp	.+286    	; 0x10df0 <FMenuTicket+0x2a2>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtPlatNo;
   10cd2:	81 30       	cpi	r24, 0x01	; 1
   10cd4:	d9 f3       	breq	.-10     	; 0x10ccc <FMenuTicket+0x17e>
		 else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10cd6:	84 30       	cpi	r24, 0x04	; 4
   10cd8:	21 f4       	brne	.+8      	; 0x10ce2 <FMenuTicket+0x194>
   10cda:	61 e0       	ldi	r22, 0x01	; 1
   10cdc:	4b e6       	ldi	r20, 0x6B	; 107
   10cde:	5a e0       	ldi	r21, 0x0A	; 10
   10ce0:	07 c0       	rjmp	.+14     	; 0x10cf0 <FMenuTicket+0x1a2>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10ce2:	85 30       	cpi	r24, 0x05	; 5
   10ce4:	09 f0       	breq	.+2      	; 0x10ce8 <FMenuTicket+0x19a>
   10ce6:	84 c0       	rjmp	.+264    	; 0x10df0 <FMenuTicket+0x2a2>
   10ce8:	84 e0       	ldi	r24, 0x04	; 4
   10cea:	61 e0       	ldi	r22, 0x01	; 1
   10cec:	46 e5       	ldi	r20, 0x56	; 86
   10cee:	5a e0       	ldi	r21, 0x0A	; 10
   10cf0:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   10cf4:	7d c0       	rjmp	.+250    	; 0x10df0 <FMenuTicket+0x2a2>
	     break;
    case mtFIP:
	     lcd_clear();
   10cf6:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		 _scr_pump();
   10cfa:	0e 94 4f 46 	call	0x8c9e	; 0x8c9e <_scr_pump>
		 stMenuTicket=mtInputFIP;
   10cfe:	86 e0       	ldi	r24, 0x06	; 6
   10d00:	e5 cf       	rjmp	.-54     	; 0x10ccc <FMenuTicket+0x17e>
	     break;
    case mtInputFIP:
	     KeyPressed=_key_scan(1);
   10d02:	81 e0       	ldi	r24, 0x01	; 1
   10d04:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   10d08:	80 93 cc 02 	sts	0x02CC, r24
		 KeyChar=_key_btn(KeyPressed);
   10d0c:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   10d10:	80 93 cb 02 	sts	0x02CB, r24
		 if ((KeyChar>='1')&&(KeyChar<='8')){
   10d14:	81 53       	subi	r24, 0x31	; 49
   10d16:	88 30       	cpi	r24, 0x08	; 8
   10d18:	40 f4       	brcc	.+16     	; 0x10d2a <FMenuTicket+0x1dc>
		     FIP_Used=KeyChar-'0';
   10d1a:	8f 5f       	subi	r24, 0xFF	; 255
   10d1c:	80 93 ca 02 	sts	0x02CA, r24
			 zFIP_Used=FIP_Used;
   10d20:	80 93 c9 02 	sts	0x02C9, r24
		     stMenuTicket=mtSendMsg98;
   10d24:	87 e0       	ldi	r24, 0x07	; 7
   10d26:	80 93 d0 02 	sts	0x02D0, r24
		 }
		 if (KeyPressed==_KEY_CANCEL){
   10d2a:	80 91 cc 02 	lds	r24, 0x02CC
   10d2e:	87 3e       	cpi	r24, 0xE7	; 231
   10d30:	11 f4       	brne	.+4      	; 0x10d36 <FMenuTicket+0x1e8>
             stMenuTicket=mtOdometer;
   10d32:	83 e0       	ldi	r24, 0x03	; 3
   10d34:	cb cf       	rjmp	.-106    	; 0x10ccc <FMenuTicket+0x17e>
		 }else
		 if (KeyPressed==_KEY_ENTER){
   10d36:	87 3b       	cpi	r24, 0xB7	; 183
   10d38:	09 f0       	breq	.+2      	; 0x10d3c <FMenuTicket+0x1ee>
   10d3a:	5a c0       	rjmp	.+180    	; 0x10df0 <FMenuTicket+0x2a2>
		     FIP_Used=zFIP_Used;
   10d3c:	80 91 c9 02 	lds	r24, 0x02C9
   10d40:	80 93 ca 02 	sts	0x02CA, r24
             stMenuTicket=mtInitWaitMessage99;
   10d44:	88 e0       	ldi	r24, 0x08	; 8
   10d46:	c2 cf       	rjmp	.-124    	; 0x10ccc <FMenuTicket+0x17e>
		 }
	     break;	
    case mtInitWaitMessage99:
	     lcd_clear();
   10d48:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		 lcd_printf(2,1,PSTR("Send Request"));
   10d4c:	82 e0       	ldi	r24, 0x02	; 2
   10d4e:	61 e0       	ldi	r22, 0x01	; 1
   10d50:	49 e4       	ldi	r20, 0x49	; 73
   10d52:	5a e0       	ldi	r21, 0x0A	; 10
   10d54:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		 lcd_printf(3,1,PSTR("Proses"));
   10d58:	83 e0       	ldi	r24, 0x03	; 3
   10d5a:	61 e0       	ldi	r22, 0x01	; 1
   10d5c:	42 e4       	ldi	r20, 0x42	; 66
   10d5e:	5a e0       	ldi	r21, 0x0A	; 10
   10d60:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
         stMenuTicket=mtSendMsg98;
   10d64:	87 e0       	ldi	r24, 0x07	; 7
   10d66:	b2 cf       	rjmp	.-156    	; 0x10ccc <FMenuTicket+0x17e>
	     break;
    case mtSendMsg98:
	     iPos=0;
   10d68:	10 92 ce 02 	sts	0x02CE, r1
		 iSend=0;
   10d6c:	10 92 cd 02 	sts	0x02CD, r1
		 IsMessage99=False;
   10d70:	10 92 b6 01 	sts	0x01B6, r1
		 TimSend=0;
   10d74:	10 92 a9 01 	sts	0x01A9, r1
   10d78:	10 92 a8 01 	sts	0x01A8, r1
		 iLoop=0;
   10d7c:	10 92 c8 02 	sts	0x02C8, r1
   10d80:	10 92 c7 02 	sts	0x02C7, r1
		 if (IFType==IT_SLAVE)sendMessage98(FIP_Used);
   10d84:	80 91 10 01 	lds	r24, 0x0110
   10d88:	81 30       	cpi	r24, 0x01	; 1
   10d8a:	29 f4       	brne	.+10     	; 0x10d96 <FMenuTicket+0x248>
   10d8c:	80 91 ca 02 	lds	r24, 0x02CA
   10d90:	0e 94 db 4d 	call	0x9bb6	; 0x9bb6 <sendMessage98>
   10d94:	27 c0       	rjmp	.+78     	; 0x10de4 <FMenuTicket+0x296>
		 else 
		 if (IFType==IT_STANDALONE)PrintStandalone(FIP_Used,False);
   10d96:	82 30       	cpi	r24, 0x02	; 2
   10d98:	29 f5       	brne	.+74     	; 0x10de4 <FMenuTicket+0x296>
   10d9a:	80 91 ca 02 	lds	r24, 0x02CA
   10d9e:	60 e0       	ldi	r22, 0x00	; 0
   10da0:	0e 94 93 21 	call	0x4326	; 0x4326 <PrintStandalone>
   10da4:	1f c0       	rjmp	.+62     	; 0x10de4 <FMenuTicket+0x296>
	                     stMenuTicket=mtSendMsg98;
				  }
			 }
		 }
		 */
		 if (IsMessage99==True){ 
   10da6:	80 91 b6 01 	lds	r24, 0x01B6
   10daa:	81 30       	cpi	r24, 0x01	; 1
   10dac:	09 f5       	brne	.+66     	; 0x10df0 <FMenuTicket+0x2a2>
		    stMenuTicket=mtMessage99Received;
   10dae:	8a e0       	ldi	r24, 0x0A	; 10
   10db0:	8d cf       	rjmp	.-230    	; 0x10ccc <FMenuTicket+0x17e>
	     break;
    case mtMessage99Received:
	     stMenuTicket=mtExitMenuTicket;
		 break;
    case mtNoConnection:
	     lcd_clear();
   10db2:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		 lcd_printf(2,1,PSTR("Error No Connection"));
   10db6:	82 e0       	ldi	r24, 0x02	; 2
   10db8:	61 e0       	ldi	r22, 0x01	; 1
   10dba:	4e e2       	ldi	r20, 0x2E	; 46
   10dbc:	5a e0       	ldi	r21, 0x0A	; 10
   10dbe:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   10dc2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   10dc4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   10dc6:	82 e0       	ldi	r24, 0x02	; 2
   10dc8:	90 e0       	ldi	r25, 0x00	; 0
   10dca:	90 93 d7 01 	sts	0x01D7, r25
   10dce:	80 93 d6 01 	sts	0x01D6, r24
   10dd2:	80 e2       	ldi	r24, 0x20	; 32
   10dd4:	9e e4       	ldi	r25, 0x4E	; 78
   10dd6:	29 e1       	ldi	r18, 0x19	; 25
   10dd8:	30 e0       	ldi	r19, 0x00	; 0
   10dda:	f9 01       	movw	r30, r18
   10ddc:	31 97       	sbiw	r30, 0x01	; 1
   10dde:	f1 f7       	brne	.-4      	; 0x10ddc <FMenuTicket+0x28e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   10de0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   10de2:	d9 f7       	brne	.-10     	; 0x10dda <FMenuTicket+0x28c>
    case mtNoConnection:
	     lcd_clear();
		 lcd_printf(2,1,PSTR("Error No Connection"));
		 system_beep(2);
		 _delay_ms(2000);
         stMenuTicket=mtExitMenuTicket;
   10de4:	8c e0       	ldi	r24, 0x0C	; 12
   10de6:	72 cf       	rjmp	.-284    	; 0x10ccc <FMenuTicket+0x17e>
	     break;
    case mtExitMenuTicket:
	     Result=MENU_DONE;
	     stMenuTicket=mtInit;
   10de8:	10 92 d0 02 	sts	0x02D0, r1
   10dec:	81 e0       	ldi	r24, 0x01	; 1
   10dee:	01 c0       	rjmp	.+2      	; 0x10df2 <FMenuTicket+0x2a4>
   10df0:	80 e0       	ldi	r24, 0x00	; 0
	     break;
	}
  return Result;
}
   10df2:	64 96       	adiw	r28, 0x14	; 20
   10df4:	0f b6       	in	r0, 0x3f	; 63
   10df6:	f8 94       	cli
   10df8:	de bf       	out	0x3e, r29	; 62
   10dfa:	0f be       	out	0x3f, r0	; 63
   10dfc:	cd bf       	out	0x3d, r28	; 61
   10dfe:	cf 91       	pop	r28
   10e00:	df 91       	pop	r29
   10e02:	1f 91       	pop	r17
   10e04:	0f 91       	pop	r16
   10e06:	ef 90       	pop	r14
   10e08:	08 95       	ret

00010e0a <FSettingOperator>:
char FSettingHost(){
     _menu_host();
	 return MENU_DONE;
}

char FSettingOperator(){//Change Active Operator, Change Password
   10e0a:	ef 92       	push	r14
   10e0c:	0f 93       	push	r16
   10e0e:	1f 93       	push	r17
   10e10:	df 93       	push	r29
   10e12:	cf 93       	push	r28
   10e14:	cd b7       	in	r28, 0x3d	; 61
   10e16:	de b7       	in	r29, 0x3e	; 62
   10e18:	e5 97       	sbiw	r28, 0x35	; 53
   10e1a:	0f b6       	in	r0, 0x3f	; 63
   10e1c:	f8 94       	cli
   10e1e:	de bf       	out	0x3e, r29	; 62
   10e20:	0f be       	out	0x3f, r0	; 63
   10e22:	cd bf       	out	0x3d, r28	; 61
	        char KeyPressed,KeyChar,lcdteks[20],strPassword[15];
			char strOperatorName[18];
			char uiResult=USER_NONE,Result=MENU_NONE;
     //_menu_user();
	 Result=MENU_NONE;
	 switch(stSettingOperator){
   10e24:	80 91 e2 02 	lds	r24, 0x02E2
   10e28:	87 30       	cpi	r24, 0x07	; 7
   10e2a:	09 f4       	brne	.+2      	; 0x10e2e <FSettingOperator+0x24>
   10e2c:	75 c1       	rjmp	.+746    	; 0x11118 <FSettingOperator+0x30e>
   10e2e:	88 30       	cpi	r24, 0x08	; 8
   10e30:	90 f4       	brcc	.+36     	; 0x10e56 <FSettingOperator+0x4c>
   10e32:	83 30       	cpi	r24, 0x03	; 3
   10e34:	09 f4       	brne	.+2      	; 0x10e38 <FSettingOperator+0x2e>
   10e36:	9a c0       	rjmp	.+308    	; 0x10f6c <FSettingOperator+0x162>
   10e38:	84 30       	cpi	r24, 0x04	; 4
   10e3a:	30 f4       	brcc	.+12     	; 0x10e48 <FSettingOperator+0x3e>
   10e3c:	81 30       	cpi	r24, 0x01	; 1
   10e3e:	a1 f1       	breq	.+104    	; 0x10ea8 <FSettingOperator+0x9e>
   10e40:	82 30       	cpi	r24, 0x02	; 2
   10e42:	08 f0       	brcs	.+2      	; 0x10e46 <FSettingOperator+0x3c>
   10e44:	44 c0       	rjmp	.+136    	; 0x10ece <FSettingOperator+0xc4>
   10e46:	20 c0       	rjmp	.+64     	; 0x10e88 <FSettingOperator+0x7e>
   10e48:	85 30       	cpi	r24, 0x05	; 5
   10e4a:	09 f4       	brne	.+2      	; 0x10e4e <FSettingOperator+0x44>
   10e4c:	36 c1       	rjmp	.+620    	; 0x110ba <FSettingOperator+0x2b0>
   10e4e:	86 30       	cpi	r24, 0x06	; 6
   10e50:	08 f0       	brcs	.+2      	; 0x10e54 <FSettingOperator+0x4a>
   10e52:	4f c1       	rjmp	.+670    	; 0x110f2 <FSettingOperator+0x2e8>
   10e54:	f9 c0       	rjmp	.+498    	; 0x11048 <FSettingOperator+0x23e>
   10e56:	8b 30       	cpi	r24, 0x0B	; 11
   10e58:	09 f4       	brne	.+2      	; 0x10e5c <FSettingOperator+0x52>
   10e5a:	20 c2       	rjmp	.+1088   	; 0x1129c <FSettingOperator+0x492>
   10e5c:	8c 30       	cpi	r24, 0x0C	; 12
   10e5e:	38 f4       	brcc	.+14     	; 0x10e6e <FSettingOperator+0x64>
   10e60:	89 30       	cpi	r24, 0x09	; 9
   10e62:	09 f4       	brne	.+2      	; 0x10e66 <FSettingOperator+0x5c>
   10e64:	a7 c1       	rjmp	.+846    	; 0x111b4 <FSettingOperator+0x3aa>
   10e66:	8a 30       	cpi	r24, 0x0A	; 10
   10e68:	08 f0       	brcs	.+2      	; 0x10e6c <FSettingOperator+0x62>
   10e6a:	d7 c1       	rjmp	.+942    	; 0x1121a <FSettingOperator+0x410>
   10e6c:	75 c1       	rjmp	.+746    	; 0x11158 <FSettingOperator+0x34e>
   10e6e:	8d 30       	cpi	r24, 0x0D	; 13
   10e70:	09 f4       	brne	.+2      	; 0x10e74 <FSettingOperator+0x6a>
   10e72:	a1 c2       	rjmp	.+1346   	; 0x113b6 <FSettingOperator+0x5ac>
   10e74:	8d 30       	cpi	r24, 0x0D	; 13
   10e76:	08 f4       	brcc	.+2      	; 0x10e7a <FSettingOperator+0x70>
   10e78:	18 c2       	rjmp	.+1072   	; 0x112aa <FSettingOperator+0x4a0>
   10e7a:	8e 30       	cpi	r24, 0x0E	; 14
   10e7c:	09 f4       	brne	.+2      	; 0x10e80 <FSettingOperator+0x76>
   10e7e:	a0 c2       	rjmp	.+1344   	; 0x113c0 <FSettingOperator+0x5b6>
   10e80:	8f 30       	cpi	r24, 0x0F	; 15
   10e82:	09 f0       	breq	.+2      	; 0x10e86 <FSettingOperator+0x7c>
   10e84:	a8 c2       	rjmp	.+1360   	; 0x113d6 <FSettingOperator+0x5cc>
   10e86:	a3 c2       	rjmp	.+1350   	; 0x113ce <FSettingOperator+0x5c4>
	 case soMenuOption:
	      lcd_clear();
   10e88:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Change Operator"));
   10e8c:	81 e0       	ldi	r24, 0x01	; 1
   10e8e:	61 e0       	ldi	r22, 0x01	; 1
   10e90:	48 ed       	ldi	r20, 0xD8	; 216
   10e92:	50 e1       	ldi	r21, 0x10	; 16
   10e94:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Change Password"));
   10e98:	82 e0       	ldi	r24, 0x02	; 2
   10e9a:	61 e0       	ldi	r22, 0x01	; 1
   10e9c:	46 ec       	ldi	r20, 0xC6	; 198
   10e9e:	50 e1       	ldi	r21, 0x10	; 16
   10ea0:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          stSettingOperator=soMenuOptionInput;
   10ea4:	81 e0       	ldi	r24, 0x01	; 1
   10ea6:	6d c2       	rjmp	.+1242   	; 0x11382 <FSettingOperator+0x578>
	      break;
     case soMenuOptionInput:
	      KeyPressed=_key_scan(1);
   10ea8:	81 e0       	ldi	r24, 0x01	; 1
   10eaa:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   10eae:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
		  switch(KeyChar){
   10eb2:	81 33       	cpi	r24, 0x31	; 49
   10eb4:	31 f0       	breq	.+12     	; 0x10ec2 <FSettingOperator+0xb8>
   10eb6:	82 33       	cpi	r24, 0x32	; 50
   10eb8:	31 f0       	breq	.+12     	; 0x10ec6 <FSettingOperator+0xbc>
   10eba:	8a 32       	cpi	r24, 0x2A	; 42
   10ebc:	09 f0       	breq	.+2      	; 0x10ec0 <FSettingOperator+0xb6>
   10ebe:	8b c2       	rjmp	.+1302   	; 0x113d6 <FSettingOperator+0x5cc>
   10ec0:	04 c0       	rjmp	.+8      	; 0x10eca <FSettingOperator+0xc0>
		  case '1':
		       stSettingOperator=soChangeOperatorInit;
   10ec2:	82 e0       	ldi	r24, 0x02	; 2
   10ec4:	5e c2       	rjmp	.+1212   	; 0x11382 <FSettingOperator+0x578>
		       break;
          case '2':
		       stSettingOperator=soChangePasswordInit;
   10ec6:	85 e0       	ldi	r24, 0x05	; 5
   10ec8:	5c c2       	rjmp	.+1208   	; 0x11382 <FSettingOperator+0x578>
		       break;
          case '*':
		       stSettingOperator=soExitSettingOperator;
   10eca:	8f e0       	ldi	r24, 0x0F	; 15
   10ecc:	5a c2       	rjmp	.+1204   	; 0x11382 <FSettingOperator+0x578>
		       break;
		  }
	      break;
     case soChangeOperatorInit:
	      lcd_clear();		  
   10ece:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   10ed2:	8e 01       	movw	r16, r28
   10ed4:	00 5f       	subi	r16, 0xF0	; 240
   10ed6:	1f 4f       	sbci	r17, 0xFF	; 255
   10ed8:	c8 01       	movw	r24, r16
   10eda:	65 e1       	ldi	r22, 0x15	; 21
   10edc:	70 e0       	ldi	r23, 0x00	; 0
   10ede:	42 e1       	ldi	r20, 0x12	; 18
   10ee0:	50 e0       	ldi	r21, 0x00	; 0
   10ee2:	28 ef       	ldi	r18, 0xF8	; 248
   10ee4:	32 e1       	ldi	r19, 0x12	; 18
   10ee6:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10eea:	98 01       	movw	r18, r16
   10eec:	ce 01       	movw	r24, r28
   10eee:	4f 96       	adiw	r24, 0x1f	; 31
	    Dest[i]=Source[IdxSource+i];
   10ef0:	0f 5f       	subi	r16, 0xFF	; 255
   10ef2:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10ef4:	08 17       	cp	r16, r24
   10ef6:	19 07       	cpc	r17, r25
   10ef8:	d9 f7       	brne	.-10     	; 0x10ef0 <FSettingOperator+0xe6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10efa:	1f 8e       	std	Y+31, r1	; 0x1f
     case soChangeOperatorInit:
	      lcd_clear();		  
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);

		  sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
   10efc:	00 d0       	rcall	.+0      	; 0x10efe <FSettingOperator+0xf4>
   10efe:	00 d0       	rcall	.+0      	; 0x10f00 <FSettingOperator+0xf6>
   10f00:	00 d0       	rcall	.+0      	; 0x10f02 <FSettingOperator+0xf8>
   10f02:	ed b7       	in	r30, 0x3d	; 61
   10f04:	fe b7       	in	r31, 0x3e	; 62
   10f06:	31 96       	adiw	r30, 0x01	; 1
   10f08:	8e 01       	movw	r16, r28
   10f0a:	0e 5d       	subi	r16, 0xDE	; 222
   10f0c:	1f 4f       	sbci	r17, 0xFF	; 255
   10f0e:	ad b7       	in	r26, 0x3d	; 61
   10f10:	be b7       	in	r27, 0x3e	; 62
   10f12:	12 96       	adiw	r26, 0x02	; 2
   10f14:	1c 93       	st	X, r17
   10f16:	0e 93       	st	-X, r16
   10f18:	11 97       	sbiw	r26, 0x01	; 1
   10f1a:	83 ec       	ldi	r24, 0xC3	; 195
   10f1c:	90 e1       	ldi	r25, 0x10	; 16
   10f1e:	93 83       	std	Z+3, r25	; 0x03
   10f20:	82 83       	std	Z+2, r24	; 0x02
   10f22:	24 83       	std	Z+4, r18	; 0x04
   10f24:	35 83       	std	Z+5, r19	; 0x05
   10f26:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_printf(1,1,PSTR("Name:"));
   10f2a:	8d b7       	in	r24, 0x3d	; 61
   10f2c:	9e b7       	in	r25, 0x3e	; 62
   10f2e:	06 96       	adiw	r24, 0x06	; 6
   10f30:	0f b6       	in	r0, 0x3f	; 63
   10f32:	f8 94       	cli
   10f34:	9e bf       	out	0x3e, r25	; 62
   10f36:	0f be       	out	0x3f, r0	; 63
   10f38:	8d bf       	out	0x3d, r24	; 61
   10f3a:	81 e0       	ldi	r24, 0x01	; 1
   10f3c:	61 e0       	ldi	r22, 0x01	; 1
   10f3e:	4d eb       	ldi	r20, 0xBD	; 189
   10f40:	50 e1       	ldi	r21, 0x10	; 16
   10f42:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_print (1,6,lcdteks);
   10f46:	81 e0       	ldi	r24, 0x01	; 1
   10f48:	66 e0       	ldi	r22, 0x06	; 6
   10f4a:	a8 01       	movw	r20, r16
   10f4c:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_printf(2,1,PSTR("New :_              "));
   10f50:	82 e0       	ldi	r24, 0x02	; 2
   10f52:	61 e0       	ldi	r22, 0x01	; 1
   10f54:	48 ea       	ldi	r20, 0xA8	; 168
   10f56:	50 e1       	ldi	r21, 0x10	; 16
   10f58:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10f5c:	84 e0       	ldi	r24, 0x04	; 4
   10f5e:	61 e0       	ldi	r22, 0x01	; 1
   10f60:	43 e9       	ldi	r20, 0x93	; 147
   10f62:	50 e1       	ldi	r21, 0x10	; 16
   10f64:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          stSettingOperator=soOperatorNameInput;
   10f68:	83 e0       	ldi	r24, 0x03	; 3
   10f6a:	0b c2       	rjmp	.+1046   	; 0x11382 <FSettingOperator+0x578>
	      break;
     case soOperatorNameInput:
          uiResult=USER_NONE;
	      uiResult=UserInput(UI_ALPHANUM_R,2,6,AdvanZ.Message09.strFreeMessageLine1,0,16);
   10f6c:	83 e0       	ldi	r24, 0x03	; 3
   10f6e:	62 e0       	ldi	r22, 0x02	; 2
   10f70:	46 e0       	ldi	r20, 0x06	; 6
   10f72:	26 ee       	ldi	r18, 0xE6	; 230
   10f74:	39 e0       	ldi	r19, 0x09	; 9
   10f76:	00 e0       	ldi	r16, 0x00	; 0
   10f78:	10 e0       	ldi	r17, 0x00	; 0
   10f7a:	b0 e1       	ldi	r27, 0x10	; 16
   10f7c:	eb 2e       	mov	r14, r27
   10f7e:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
		  switch(uiResult){
   10f82:	83 30       	cpi	r24, 0x03	; 3
   10f84:	51 f0       	breq	.+20     	; 0x10f9a <FSettingOperator+0x190>
   10f86:	84 30       	cpi	r24, 0x04	; 4
   10f88:	08 f4       	brcc	.+2      	; 0x10f8c <FSettingOperator+0x182>
   10f8a:	f5 c0       	rjmp	.+490    	; 0x11176 <FSettingOperator+0x36c>
   10f8c:	84 30       	cpi	r24, 0x04	; 4
   10f8e:	09 f4       	brne	.+2      	; 0x10f92 <FSettingOperator+0x188>
   10f90:	51 c0       	rjmp	.+162    	; 0x11034 <FSettingOperator+0x22a>
   10f92:	85 30       	cpi	r24, 0x05	; 5
   10f94:	09 f0       	breq	.+2      	; 0x10f98 <FSettingOperator+0x18e>
   10f96:	1f c2       	rjmp	.+1086   	; 0x113d6 <FSettingOperator+0x5cc>
   10f98:	52 c0       	rjmp	.+164    	; 0x1103e <FSettingOperator+0x234>
		  case USER_OK:
		       lcd_clear();
   10f9a:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
   10f9e:	20 e0       	ldi	r18, 0x00	; 0
   10fa0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   10fa2:	ae 01       	movw	r20, r28
   10fa4:	40 5f       	subi	r20, 0xF0	; 240
   10fa6:	5f 4f       	sbci	r21, 0xFF	; 255
   10fa8:	fa 01       	movw	r30, r20
   10faa:	e2 0f       	add	r30, r18
   10fac:	f3 1f       	adc	r31, r19
   10fae:	d9 01       	movw	r26, r18
   10fb0:	aa 51       	subi	r26, 0x1A	; 26
   10fb2:	b6 4f       	sbci	r27, 0xF6	; 246
   10fb4:	8c 91       	ld	r24, X
   10fb6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10fb8:	2f 5f       	subi	r18, 0xFF	; 255
   10fba:	3f 4f       	sbci	r19, 0xFF	; 255
   10fbc:	2f 30       	cpi	r18, 0x0F	; 15
   10fbe:	31 05       	cpc	r19, r1
   10fc0:	99 f7       	brne	.-26     	; 0x10fa8 <FSettingOperator+0x19e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10fc2:	1f 8e       	std	Y+31, r1	; 0x1f
	      uiResult=UserInput(UI_ALPHANUM_R,2,6,AdvanZ.Message09.strFreeMessageLine1,0,16);
		  switch(uiResult){
		  case USER_OK:
		       lcd_clear();
			   StrPosCopy(AdvanZ.Message09.strFreeMessageLine1,strOperatorName,0,15);
		       sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
   10fc4:	00 d0       	rcall	.+0      	; 0x10fc6 <FSettingOperator+0x1bc>
   10fc6:	00 d0       	rcall	.+0      	; 0x10fc8 <FSettingOperator+0x1be>
   10fc8:	00 d0       	rcall	.+0      	; 0x10fca <FSettingOperator+0x1c0>
   10fca:	ed b7       	in	r30, 0x3d	; 61
   10fcc:	fe b7       	in	r31, 0x3e	; 62
   10fce:	31 96       	adiw	r30, 0x01	; 1
   10fd0:	8e 01       	movw	r16, r28
   10fd2:	0e 5d       	subi	r16, 0xDE	; 222
   10fd4:	1f 4f       	sbci	r17, 0xFF	; 255
   10fd6:	ad b7       	in	r26, 0x3d	; 61
   10fd8:	be b7       	in	r27, 0x3e	; 62
   10fda:	12 96       	adiw	r26, 0x02	; 2
   10fdc:	1c 93       	st	X, r17
   10fde:	0e 93       	st	-X, r16
   10fe0:	11 97       	sbiw	r26, 0x01	; 1
   10fe2:	80 e9       	ldi	r24, 0x90	; 144
   10fe4:	90 e1       	ldi	r25, 0x10	; 16
   10fe6:	93 83       	std	Z+3, r25	; 0x03
   10fe8:	82 83       	std	Z+2, r24	; 0x02
   10fea:	55 83       	std	Z+5, r21	; 0x05
   10fec:	44 83       	std	Z+4, r20	; 0x04
   10fee:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			   lcd_printf(1,1,PSTR("New Operator:"));
   10ff2:	8d b7       	in	r24, 0x3d	; 61
   10ff4:	9e b7       	in	r25, 0x3e	; 62
   10ff6:	06 96       	adiw	r24, 0x06	; 6
   10ff8:	0f b6       	in	r0, 0x3f	; 63
   10ffa:	f8 94       	cli
   10ffc:	9e bf       	out	0x3e, r25	; 62
   10ffe:	0f be       	out	0x3f, r0	; 63
   11000:	8d bf       	out	0x3d, r24	; 61
   11002:	81 e0       	ldi	r24, 0x01	; 1
   11004:	61 e0       	ldi	r22, 0x01	; 1
   11006:	42 e8       	ldi	r20, 0x82	; 130
   11008:	50 e1       	ldi	r21, 0x10	; 16
   1100a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			   lcd_print (2,1,lcdteks);
   1100e:	82 e0       	ldi	r24, 0x02	; 2
   11010:	61 e0       	ldi	r22, 0x01	; 1
   11012:	a8 01       	movw	r20, r16
   11014:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			   lcd_printf(3,1,PSTR("Save?"));
   11018:	83 e0       	ldi	r24, 0x03	; 3
   1101a:	61 e0       	ldi	r22, 0x01	; 1
   1101c:	4c e7       	ldi	r20, 0x7C	; 124
   1101e:	50 e1       	ldi	r21, 0x10	; 16
   11020:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]No    [#]Yes"));
   11024:	84 e0       	ldi	r24, 0x04	; 4
   11026:	61 e0       	ldi	r22, 0x01	; 1
   11028:	4c e6       	ldi	r20, 0x6C	; 108
   1102a:	50 e1       	ldi	r21, 0x10	; 16
   1102c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
               stSettingOperator=soIsSaveOperatorName;
   11030:	84 e0       	ldi	r24, 0x04	; 4
   11032:	a7 c1       	rjmp	.+846    	; 0x11382 <FSettingOperator+0x578>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11034:	84 e0       	ldi	r24, 0x04	; 4
   11036:	61 e0       	ldi	r22, 0x01	; 1
   11038:	47 e5       	ldi	r20, 0x57	; 87
   1103a:	50 e1       	ldi	r21, 0x10	; 16
   1103c:	2c c1       	rjmp	.+600    	; 0x11296 <FSettingOperator+0x48c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1103e:	84 e0       	ldi	r24, 0x04	; 4
   11040:	61 e0       	ldi	r22, 0x01	; 1
   11042:	42 e4       	ldi	r20, 0x42	; 66
   11044:	50 e1       	ldi	r21, 0x10	; 16
   11046:	27 c1       	rjmp	.+590    	; 0x11296 <FSettingOperator+0x48c>
		       break;
		  }
	      break;
     case soIsSaveOperatorName:
          KeyPressed=_key_scan(1);
   11048:	81 e0       	ldi	r24, 0x01	; 1
   1104a:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   1104e:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
		  switch(KeyChar){
   11052:	83 32       	cpi	r24, 0x23	; 35
   11054:	09 f0       	breq	.+2      	; 0x11058 <FSettingOperator+0x24e>
   11056:	56 c0       	rjmp	.+172    	; 0x11104 <FSettingOperator+0x2fa>
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
   11058:	20 e0       	ldi	r18, 0x00	; 0
   1105a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1105c:	8e 01       	movw	r16, r28
   1105e:	00 5f       	subi	r16, 0xF0	; 240
   11060:	1f 4f       	sbci	r17, 0xFF	; 255
   11062:	f8 01       	movw	r30, r16
   11064:	e2 0f       	add	r30, r18
   11066:	f3 1f       	adc	r31, r19
   11068:	d9 01       	movw	r26, r18
   1106a:	aa 51       	subi	r26, 0x1A	; 26
   1106c:	b6 4f       	sbci	r27, 0xF6	; 246
   1106e:	8c 91       	ld	r24, X
   11070:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11072:	2f 5f       	subi	r18, 0xFF	; 255
   11074:	3f 4f       	sbci	r19, 0xFF	; 255
   11076:	2f 30       	cpi	r18, 0x0F	; 15
   11078:	31 05       	cpc	r19, r1
   1107a:	99 f7       	brne	.-26     	; 0x11062 <FSettingOperator+0x258>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   1107c:	1f 8e       	std	Y+31, r1	; 0x1f
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
          case '#':
		       StrPosCopy(AdvanZ.Message09.strFreeMessageLine1,strOperatorName,0,15);
               AddSpaceLag(strOperatorName,18); 
   1107e:	c8 01       	movw	r24, r16
   11080:	62 e1       	ldi	r22, 0x12	; 18
   11082:	0e 94 3c 2e 	call	0x5c78	; 0x5c78 <AddSpaceLag>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   11086:	85 e1       	ldi	r24, 0x15	; 21
   11088:	90 e0       	ldi	r25, 0x00	; 0
   1108a:	b8 01       	movw	r22, r16
   1108c:	42 e1       	ldi	r20, 0x12	; 18
   1108e:	50 e0       	ldi	r21, 0x00	; 0
   11090:	20 e0       	ldi	r18, 0x00	; 0
   11092:	33 e1       	ldi	r19, 0x13	; 19
   11094:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
		       eeprom_write_block((const void*) &strOperatorName, (void*) &DefOperatorName,18);
		       lcd_printf(3,1,PSTR("Saved "));
   11098:	83 e0       	ldi	r24, 0x03	; 3
   1109a:	61 e0       	ldi	r22, 0x01	; 1
   1109c:	4b e3       	ldi	r20, 0x3B	; 59
   1109e:	50 e1       	ldi	r21, 0x10	; 16
   110a0:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			   TimDisplay=0;
   110a4:	10 92 a7 01 	sts	0x01A7, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   110a8:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   110aa:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   110ac:	81 e0       	ldi	r24, 0x01	; 1
   110ae:	90 e0       	ldi	r25, 0x00	; 0
   110b0:	90 93 d7 01 	sts	0x01D7, r25
   110b4:	80 93 d6 01 	sts	0x01D6, r24
   110b8:	49 c1       	rjmp	.+658    	; 0x1134c <FSettingOperator+0x542>
		       stSettingOperator=soDelayDisplaySaved;
		       break;
		  }	      
		  break;
     case soChangePasswordInit:
	      lcd_clear();
   110ba:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("-Change Password-"));
   110be:	81 e0       	ldi	r24, 0x01	; 1
   110c0:	61 e0       	ldi	r22, 0x01	; 1
   110c2:	49 e2       	ldi	r20, 0x29	; 41
   110c4:	50 e1       	ldi	r21, 0x10	; 16
   110c6:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Supervisor"));
   110ca:	82 e0       	ldi	r24, 0x02	; 2
   110cc:	61 e0       	ldi	r22, 0x01	; 1
   110ce:	4c e1       	ldi	r20, 0x1C	; 28
   110d0:	50 e1       	ldi	r21, 0x10	; 16
   110d2:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Administrator"));
   110d6:	83 e0       	ldi	r24, 0x03	; 3
   110d8:	61 e0       	ldi	r22, 0x01	; 1
   110da:	4c e0       	ldi	r20, 0x0C	; 12
   110dc:	50 e1       	ldi	r21, 0x10	; 16
   110de:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back     "));
   110e2:	84 e0       	ldi	r24, 0x04	; 4
   110e4:	61 e0       	ldi	r22, 0x01	; 1
   110e6:	4f ef       	ldi	r20, 0xFF	; 255
   110e8:	5f e0       	ldi	r21, 0x0F	; 15
   110ea:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          stSettingOperator=soChangePasswordInput; 
   110ee:	86 e0       	ldi	r24, 0x06	; 6
   110f0:	48 c1       	rjmp	.+656    	; 0x11382 <FSettingOperator+0x578>
	      break;
     case soChangePasswordInput:
          KeyPressed=_key_scan(1);
   110f2:	81 e0       	ldi	r24, 0x01	; 1
   110f4:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   110f8:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
		  switch(KeyChar){
   110fc:	81 33       	cpi	r24, 0x31	; 49
   110fe:	31 f0       	breq	.+12     	; 0x1110c <FSettingOperator+0x302>
   11100:	82 33       	cpi	r24, 0x32	; 50
   11102:	31 f0       	breq	.+12     	; 0x11110 <FSettingOperator+0x306>
   11104:	8a 32       	cpi	r24, 0x2A	; 42
   11106:	09 f0       	breq	.+2      	; 0x1110a <FSettingOperator+0x300>
   11108:	66 c1       	rjmp	.+716    	; 0x113d6 <FSettingOperator+0x5cc>
   1110a:	5e c1       	rjmp	.+700    	; 0x113c8 <FSettingOperator+0x5be>
		  case '1':		 
		       PassType=PT_SUPERVISOR;
   1110c:	81 e0       	ldi	r24, 0x01	; 1
   1110e:	01 c0       	rjmp	.+2      	; 0x11112 <FSettingOperator+0x308>
		       stSettingOperator=soOldPasswordDisplay;
		       break;
          case '2':		       
		       PassType=PT_ADMINISTRATOR;
   11110:	82 e0       	ldi	r24, 0x02	; 2
   11112:	80 93 e1 02 	sts	0x02E1, r24
   11116:	75 c0       	rjmp	.+234    	; 0x11202 <FSettingOperator+0x3f8>
		       stSettingOperator=soMenuOption;
		       break;
		  }	      
	      break;
     case soOldPasswordDisplay:
	 	  lcd_clear();
   11118:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
	      if (PassType==PT_SUPERVISOR){
   1111c:	80 91 e1 02 	lds	r24, 0x02E1
   11120:	81 30       	cpi	r24, 0x01	; 1
   11122:	21 f4       	brne	.+8      	; 0x1112c <FSettingOperator+0x322>
		      lcd_printf(1,1,PSTR("-Supervisor-"));              
   11124:	61 e0       	ldi	r22, 0x01	; 1
   11126:	42 ef       	ldi	r20, 0xF2	; 242
   11128:	5f e0       	ldi	r21, 0x0F	; 15
   1112a:	06 c0       	rjmp	.+12     	; 0x11138 <FSettingOperator+0x32e>
		  }else if (PassType==PT_ADMINISTRATOR){		       
   1112c:	82 30       	cpi	r24, 0x02	; 2
   1112e:	31 f4       	brne	.+12     	; 0x1113c <FSettingOperator+0x332>
		       lcd_printf(1,1,PSTR("-Administrator-"));			   
   11130:	81 e0       	ldi	r24, 0x01	; 1
   11132:	61 e0       	ldi	r22, 0x01	; 1
   11134:	42 ee       	ldi	r20, 0xE2	; 226
   11136:	5f e0       	ldi	r21, 0x0F	; 15
   11138:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  }
		      lcd_printf(2,1,PSTR("Old:_"));
   1113c:	82 e0       	ldi	r24, 0x02	; 2
   1113e:	61 e0       	ldi	r22, 0x01	; 1
   11140:	4c ed       	ldi	r20, 0xDC	; 220
   11142:	5f e0       	ldi	r21, 0x0F	; 15
   11144:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11148:	84 e0       	ldi	r24, 0x04	; 4
   1114a:	61 e0       	ldi	r22, 0x01	; 1
   1114c:	47 ec       	ldi	r20, 0xC7	; 199
   1114e:	5f e0       	ldi	r21, 0x0F	; 15
   11150:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>

          stSettingOperator=soOldPasswordEntry;
   11154:	88 e0       	ldi	r24, 0x08	; 8
   11156:	15 c1       	rjmp	.+554    	; 0x11382 <FSettingOperator+0x578>
	      break;
     case soOldPasswordEntry:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,AdvanZ.Message09.strFreeMessageLine1,0,8);           
   11158:	84 e0       	ldi	r24, 0x04	; 4
   1115a:	62 e0       	ldi	r22, 0x02	; 2
   1115c:	45 e0       	ldi	r20, 0x05	; 5
   1115e:	26 ee       	ldi	r18, 0xE6	; 230
   11160:	39 e0       	ldi	r19, 0x09	; 9
   11162:	00 e0       	ldi	r16, 0x00	; 0
   11164:	10 e0       	ldi	r17, 0x00	; 0
   11166:	a8 e0       	ldi	r26, 0x08	; 8
   11168:	ea 2e       	mov	r14, r26
   1116a:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
		  switch(uiResult){
   1116e:	83 30       	cpi	r24, 0x03	; 3
   11170:	61 f0       	breq	.+24     	; 0x1118a <FSettingOperator+0x380>
   11172:	84 30       	cpi	r24, 0x04	; 4
   11174:	20 f4       	brcc	.+8      	; 0x1117e <FSettingOperator+0x374>
   11176:	81 30       	cpi	r24, 0x01	; 1
   11178:	09 f0       	breq	.+2      	; 0x1117c <FSettingOperator+0x372>
   1117a:	2d c1       	rjmp	.+602    	; 0x113d6 <FSettingOperator+0x5cc>
   1117c:	25 c1       	rjmp	.+586    	; 0x113c8 <FSettingOperator+0x5be>
   1117e:	84 30       	cpi	r24, 0x04	; 4
   11180:	79 f0       	breq	.+30     	; 0x111a0 <FSettingOperator+0x396>
   11182:	85 30       	cpi	r24, 0x05	; 5
   11184:	09 f0       	breq	.+2      	; 0x11188 <FSettingOperator+0x37e>
   11186:	27 c1       	rjmp	.+590    	; 0x113d6 <FSettingOperator+0x5cc>
   11188:	10 c0       	rjmp	.+32     	; 0x111aa <FSettingOperator+0x3a0>
		  case USER_OK:
		       lcd_printf(2,1,PSTR("New:_               "));
   1118a:	82 e0       	ldi	r24, 0x02	; 2
   1118c:	61 e0       	ldi	r22, 0x01	; 1
   1118e:	42 eb       	ldi	r20, 0xB2	; 178
   11190:	5f e0       	ldi	r21, 0x0F	; 15
   11192:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11196:	84 e0       	ldi	r24, 0x04	; 4
   11198:	61 e0       	ldi	r22, 0x01	; 1
   1119a:	4d e9       	ldi	r20, 0x9D	; 157
   1119c:	5f e0       	ldi	r21, 0x0F	; 15
   1119e:	6e c0       	rjmp	.+220    	; 0x1127c <FSettingOperator+0x472>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   111a0:	84 e0       	ldi	r24, 0x04	; 4
   111a2:	61 e0       	ldi	r22, 0x01	; 1
   111a4:	48 e8       	ldi	r20, 0x88	; 136
   111a6:	5f e0       	ldi	r21, 0x0F	; 15
   111a8:	76 c0       	rjmp	.+236    	; 0x11296 <FSettingOperator+0x48c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   111aa:	84 e0       	ldi	r24, 0x04	; 4
   111ac:	61 e0       	ldi	r22, 0x01	; 1
   111ae:	43 e7       	ldi	r20, 0x73	; 115
   111b0:	5f e0       	ldi	r21, 0x0F	; 15
   111b2:	71 c0       	rjmp	.+226    	; 0x11296 <FSettingOperator+0x48c>
		       break;
		  }
	      break;
     case soNewPasswordEntry1:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,AdvanZ.Message09.strFreeMessageLine2,0,8);           
   111b4:	84 e0       	ldi	r24, 0x04	; 4
   111b6:	62 e0       	ldi	r22, 0x02	; 2
   111b8:	45 e0       	ldi	r20, 0x05	; 5
   111ba:	2b ef       	ldi	r18, 0xFB	; 251
   111bc:	39 e0       	ldi	r19, 0x09	; 9
   111be:	00 e0       	ldi	r16, 0x00	; 0
   111c0:	10 e0       	ldi	r17, 0x00	; 0
   111c2:	f8 e0       	ldi	r31, 0x08	; 8
   111c4:	ef 2e       	mov	r14, r31
   111c6:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
		  switch(uiResult){
   111ca:	83 30       	cpi	r24, 0x03	; 3
   111cc:	61 f0       	breq	.+24     	; 0x111e6 <FSettingOperator+0x3dc>
   111ce:	84 30       	cpi	r24, 0x04	; 4
   111d0:	20 f4       	brcc	.+8      	; 0x111da <FSettingOperator+0x3d0>
   111d2:	81 30       	cpi	r24, 0x01	; 1
   111d4:	09 f0       	breq	.+2      	; 0x111d8 <FSettingOperator+0x3ce>
   111d6:	ff c0       	rjmp	.+510    	; 0x113d6 <FSettingOperator+0x5cc>
   111d8:	14 c0       	rjmp	.+40     	; 0x11202 <FSettingOperator+0x3f8>
   111da:	84 30       	cpi	r24, 0x04	; 4
   111dc:	a1 f0       	breq	.+40     	; 0x11206 <FSettingOperator+0x3fc>
   111de:	85 30       	cpi	r24, 0x05	; 5
   111e0:	09 f0       	breq	.+2      	; 0x111e4 <FSettingOperator+0x3da>
   111e2:	f9 c0       	rjmp	.+498    	; 0x113d6 <FSettingOperator+0x5cc>
   111e4:	15 c0       	rjmp	.+42     	; 0x11210 <FSettingOperator+0x406>
		  case USER_OK:
		       lcd_printf(3,1,PSTR("New:_               "));
   111e6:	83 e0       	ldi	r24, 0x03	; 3
   111e8:	61 e0       	ldi	r22, 0x01	; 1
   111ea:	4e e5       	ldi	r20, 0x5E	; 94
   111ec:	5f e0       	ldi	r21, 0x0F	; 15
   111ee:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   111f2:	84 e0       	ldi	r24, 0x04	; 4
   111f4:	61 e0       	ldi	r22, 0x01	; 1
   111f6:	49 e4       	ldi	r20, 0x49	; 73
   111f8:	5f e0       	ldi	r21, 0x0F	; 15
   111fa:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		       stSettingOperator=soNewPasswordEntry2;
   111fe:	8a e0       	ldi	r24, 0x0A	; 10
   11200:	c0 c0       	rjmp	.+384    	; 0x11382 <FSettingOperator+0x578>
		       break;
		  case USER_CANCEL:		       
			   stSettingOperator=soOldPasswordDisplay;
   11202:	87 e0       	ldi	r24, 0x07	; 7
   11204:	be c0       	rjmp	.+380    	; 0x11382 <FSettingOperator+0x578>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11206:	84 e0       	ldi	r24, 0x04	; 4
   11208:	61 e0       	ldi	r22, 0x01	; 1
   1120a:	44 e3       	ldi	r20, 0x34	; 52
   1120c:	5f e0       	ldi	r21, 0x0F	; 15
   1120e:	43 c0       	rjmp	.+134    	; 0x11296 <FSettingOperator+0x48c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11210:	84 e0       	ldi	r24, 0x04	; 4
   11212:	61 e0       	ldi	r22, 0x01	; 1
   11214:	4f e1       	ldi	r20, 0x1F	; 31
   11216:	5f e0       	ldi	r21, 0x0F	; 15
   11218:	3e c0       	rjmp	.+124    	; 0x11296 <FSettingOperator+0x48c>
		       break;
		  }	      
	      break;
     case soNewPasswordEntry2:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,3,5,AdvanZ.Message09.strFreeMessageLine3,0,8);           
   1121a:	84 e0       	ldi	r24, 0x04	; 4
   1121c:	63 e0       	ldi	r22, 0x03	; 3
   1121e:	45 e0       	ldi	r20, 0x05	; 5
   11220:	20 e1       	ldi	r18, 0x10	; 16
   11222:	3a e0       	ldi	r19, 0x0A	; 10
   11224:	00 e0       	ldi	r16, 0x00	; 0
   11226:	10 e0       	ldi	r17, 0x00	; 0
   11228:	e8 e0       	ldi	r30, 0x08	; 8
   1122a:	ee 2e       	mov	r14, r30
   1122c:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
		  switch(uiResult){
   11230:	83 30       	cpi	r24, 0x03	; 3
   11232:	61 f0       	breq	.+24     	; 0x1124c <FSettingOperator+0x442>
   11234:	84 30       	cpi	r24, 0x04	; 4
   11236:	20 f4       	brcc	.+8      	; 0x11240 <FSettingOperator+0x436>
   11238:	81 30       	cpi	r24, 0x01	; 1
   1123a:	09 f0       	breq	.+2      	; 0x1123e <FSettingOperator+0x434>
   1123c:	cc c0       	rjmp	.+408    	; 0x113d6 <FSettingOperator+0x5cc>
   1123e:	12 c0       	rjmp	.+36     	; 0x11264 <FSettingOperator+0x45a>
   11240:	84 30       	cpi	r24, 0x04	; 4
   11242:	01 f1       	breq	.+64     	; 0x11284 <FSettingOperator+0x47a>
   11244:	85 30       	cpi	r24, 0x05	; 5
   11246:	09 f0       	breq	.+2      	; 0x1124a <FSettingOperator+0x440>
   11248:	c6 c0       	rjmp	.+396    	; 0x113d6 <FSettingOperator+0x5cc>
   1124a:	21 c0       	rjmp	.+66     	; 0x1128e <FSettingOperator+0x484>
		  case USER_OK:
		       lcd_clear();
   1124c:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
               lcd_printf(1,1,PSTR("Validating.."));
   11250:	81 e0       	ldi	r24, 0x01	; 1
   11252:	61 e0       	ldi	r22, 0x01	; 1
   11254:	42 e1       	ldi	r20, 0x12	; 18
   11256:	5f e0       	ldi	r21, 0x0F	; 15
   11258:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			   TimDisplay=0;
   1125c:	10 92 a7 01 	sts	0x01A7, r1
		       stSettingOperator=soDispValidatePassword;
   11260:	8b e0       	ldi	r24, 0x0B	; 11
   11262:	8f c0       	rjmp	.+286    	; 0x11382 <FSettingOperator+0x578>
		       break;
		  case USER_CANCEL:
               lcd_clear();
   11264:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
               lcd_printf(2,1,PSTR("New:_               "));
   11268:	82 e0       	ldi	r24, 0x02	; 2
   1126a:	61 e0       	ldi	r22, 0x01	; 1
   1126c:	4d ef       	ldi	r20, 0xFD	; 253
   1126e:	5e e0       	ldi	r21, 0x0E	; 14
   11270:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11274:	84 e0       	ldi	r24, 0x04	; 4
   11276:	61 e0       	ldi	r22, 0x01	; 1
   11278:	48 ee       	ldi	r20, 0xE8	; 232
   1127a:	5e e0       	ldi	r21, 0x0E	; 14
   1127c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		       stSettingOperator=soNewPasswordEntry1;
   11280:	89 e0       	ldi	r24, 0x09	; 9
   11282:	7f c0       	rjmp	.+254    	; 0x11382 <FSettingOperator+0x578>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11284:	84 e0       	ldi	r24, 0x04	; 4
   11286:	61 e0       	ldi	r22, 0x01	; 1
   11288:	43 ed       	ldi	r20, 0xD3	; 211
   1128a:	5e e0       	ldi	r21, 0x0E	; 14
   1128c:	04 c0       	rjmp	.+8      	; 0x11296 <FSettingOperator+0x48c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1128e:	84 e0       	ldi	r24, 0x04	; 4
   11290:	61 e0       	ldi	r22, 0x01	; 1
   11292:	4e eb       	ldi	r20, 0xBE	; 190
   11294:	5e e0       	ldi	r21, 0x0E	; 14
   11296:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   1129a:	9d c0       	rjmp	.+314    	; 0x113d6 <FSettingOperator+0x5cc>
		       break;
		  }	      
	      break;
     case soDispValidatePassword:
	      if (TimDisplay>3)stSettingOperator=soValidatePassword;
   1129c:	80 91 a7 01 	lds	r24, 0x01A7
   112a0:	84 30       	cpi	r24, 0x04	; 4
   112a2:	08 f4       	brcc	.+2      	; 0x112a6 <FSettingOperator+0x49c>
   112a4:	98 c0       	rjmp	.+304    	; 0x113d6 <FSettingOperator+0x5cc>
   112a6:	8c e0       	ldi	r24, 0x0C	; 12
   112a8:	6c c0       	rjmp	.+216    	; 0x11382 <FSettingOperator+0x578>
	      break;
     case soValidatePassword:
          if (PassType==PT_SUPERVISOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSysPassword, 10);		      			   
   112aa:	80 91 e1 02 	lds	r24, 0x02E1
   112ae:	81 30       	cpi	r24, 0x01	; 1
   112b0:	29 f4       	brne	.+10     	; 0x112bc <FSettingOperator+0x4b2>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   112b2:	ce 01       	movw	r24, r28
   112b4:	01 96       	adiw	r24, 0x01	; 1
   112b6:	6b e0       	ldi	r22, 0x0B	; 11
   112b8:	70 e0       	ldi	r23, 0x00	; 0
   112ba:	06 c0       	rjmp	.+12     	; 0x112c8 <FSettingOperator+0x4be>
		  else 
		  if (PassType==PT_ADMINISTRATOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSpvPassword, 10);    
   112bc:	82 30       	cpi	r24, 0x02	; 2
   112be:	51 f4       	brne	.+20     	; 0x112d4 <FSettingOperator+0x4ca>
   112c0:	ce 01       	movw	r24, r28
   112c2:	01 96       	adiw	r24, 0x01	; 1
   112c4:	61 e0       	ldi	r22, 0x01	; 1
   112c6:	70 e0       	ldi	r23, 0x00	; 0
   112c8:	4a e0       	ldi	r20, 0x0A	; 10
   112ca:	50 e0       	ldi	r21, 0x00	; 0
   112cc:	28 ef       	ldi	r18, 0xF8	; 248
   112ce:	32 e1       	ldi	r19, 0x12	; 18
   112d0:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
		  
		  //Check Old Validity
		  if (strcmp(strPassword,AdvanZ.Message09.strFreeMessageLine1)==0){//OldMessage Valid
   112d4:	ce 01       	movw	r24, r28
   112d6:	01 96       	adiw	r24, 0x01	; 1
   112d8:	66 ee       	ldi	r22, 0xE6	; 230
   112da:	79 e0       	ldi	r23, 0x09	; 9
   112dc:	0e 94 62 b5 	call	0x16ac4	; 0x16ac4 <strcmp>
   112e0:	00 97       	sbiw	r24, 0x00	; 0
   112e2:	09 f0       	breq	.+2      	; 0x112e6 <FSettingOperator+0x4dc>
   112e4:	51 c0       	rjmp	.+162    	; 0x11388 <FSettingOperator+0x57e>
              if (strcmp(AdvanZ.Message09.strFreeMessageLine2,AdvanZ.Message09.strFreeMessageLine3)==0){
   112e6:	8b ef       	ldi	r24, 0xFB	; 251
   112e8:	99 e0       	ldi	r25, 0x09	; 9
   112ea:	60 e1       	ldi	r22, 0x10	; 16
   112ec:	7a e0       	ldi	r23, 0x0A	; 10
   112ee:	0e 94 62 b5 	call	0x16ac4	; 0x16ac4 <strcmp>
   112f2:	00 97       	sbiw	r24, 0x00	; 0
   112f4:	69 f5       	brne	.+90     	; 0x11350 <FSettingOperator+0x546>
                  
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &AdvanZ.Message09.strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
   112f6:	80 91 e1 02 	lds	r24, 0x02E1
   112fa:	81 30       	cpi	r24, 0x01	; 1
   112fc:	19 f4       	brne	.+6      	; 0x11304 <FSettingOperator+0x4fa>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   112fe:	8b e0       	ldi	r24, 0x0B	; 11
   11300:	90 e0       	ldi	r25, 0x00	; 0
   11302:	04 c0       	rjmp	.+8      	; 0x1130c <FSettingOperator+0x502>
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &AdvanZ.Message09.strFreeMessageLine2, (void*) &DefSpvPassword, 10);    
   11304:	82 30       	cpi	r24, 0x02	; 2
   11306:	51 f4       	brne	.+20     	; 0x1131c <FSettingOperator+0x512>
   11308:	81 e0       	ldi	r24, 0x01	; 1
   1130a:	90 e0       	ldi	r25, 0x00	; 0
   1130c:	6b ef       	ldi	r22, 0xFB	; 251
   1130e:	79 e0       	ldi	r23, 0x09	; 9
   11310:	4a e0       	ldi	r20, 0x0A	; 10
   11312:	50 e0       	ldi	r21, 0x00	; 0
   11314:	20 e0       	ldi	r18, 0x00	; 0
   11316:	33 e1       	ldi	r19, 0x13	; 19
   11318:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1131c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1131e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11320:	81 e0       	ldi	r24, 0x01	; 1
   11322:	90 e0       	ldi	r25, 0x00	; 0
   11324:	90 93 d7 01 	sts	0x01D7, r25
   11328:	80 93 d6 01 	sts	0x01D6, r24
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &AdvanZ.Message09.strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &AdvanZ.Message09.strFreeMessageLine2, (void*) &DefSpvPassword, 10);    

			      system_beep(1);
				  lcd_clear();
   1132c:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
			      lcd_printf(2,1,PSTR("     Completed      "));
   11330:	82 e0       	ldi	r24, 0x02	; 2
   11332:	61 e0       	ldi	r22, 0x01	; 1
   11334:	49 ea       	ldi	r20, 0xA9	; 169
   11336:	5e e0       	ldi	r21, 0x0E	; 14
   11338:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
   1133c:	83 e0       	ldi	r24, 0x03	; 3
   1133e:	61 e0       	ldi	r22, 0x01	; 1
   11340:	44 e9       	ldi	r20, 0x94	; 148
   11342:	5e e0       	ldi	r21, 0x0E	; 14
   11344:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				  TimDisplay=0;
   11348:	10 92 a7 01 	sts	0x01A7, r1
				  stSettingOperator=soDelayDisplaySaved;
   1134c:	8e e0       	ldi	r24, 0x0E	; 14
   1134e:	19 c0       	rjmp	.+50     	; 0x11382 <FSettingOperator+0x578>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11350:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   11352:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11354:	82 e0       	ldi	r24, 0x02	; 2
   11356:	90 e0       	ldi	r25, 0x00	; 0
   11358:	90 93 d7 01 	sts	0x01D7, r25
   1135c:	80 93 d6 01 	sts	0x01D6, r24
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
				  TimDisplay=0;
				  stSettingOperator=soDelayDisplaySaved;
			  }else {
			  system_beep(2);
		      TimDisplay=0;
   11360:	10 92 a7 01 	sts	0x01A7, r1
		      lcd_clear();
   11364:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		      lcd_printf(2,1,PSTR("      ERROR         "));
   11368:	82 e0       	ldi	r24, 0x02	; 2
   1136a:	61 e0       	ldi	r22, 0x01	; 1
   1136c:	4f e7       	ldi	r20, 0x7F	; 127
   1136e:	5e e0       	ldi	r21, 0x0E	; 14
   11370:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		      lcd_printf(3,1,PSTR("Invalid New Password"));
   11374:	83 e0       	ldi	r24, 0x03	; 3
   11376:	61 e0       	ldi	r22, 0x01	; 1
   11378:	4a e6       	ldi	r20, 0x6A	; 106
   1137a:	5e e0       	ldi	r21, 0x0E	; 14
   1137c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		      stSettingOperator=soDisplayInvalidPassword;
   11380:	8d e0       	ldi	r24, 0x0D	; 13
   11382:	80 93 e2 02 	sts	0x02E2, r24
   11386:	27 c0       	rjmp	.+78     	; 0x113d6 <FSettingOperator+0x5cc>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11388:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1138a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1138c:	82 e0       	ldi	r24, 0x02	; 2
   1138e:	90 e0       	ldi	r25, 0x00	; 0
   11390:	90 93 d7 01 	sts	0x01D7, r25
   11394:	80 93 d6 01 	sts	0x01D6, r24
		      stSettingOperator=soDisplayInvalidPassword;
			  }
		  }else {
		   //InvalidOld Password
		   system_beep(2);
		   TimDisplay=0;
   11398:	10 92 a7 01 	sts	0x01A7, r1
		   lcd_clear();
   1139c:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		   lcd_printf(2,1,PSTR("      ERROR         "));
   113a0:	82 e0       	ldi	r24, 0x02	; 2
   113a2:	61 e0       	ldi	r22, 0x01	; 1
   113a4:	45 e5       	ldi	r20, 0x55	; 85
   113a6:	5e e0       	ldi	r21, 0x0E	; 14
   113a8:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		   lcd_printf(3,1,PSTR("Invalid Old Password"));
   113ac:	83 e0       	ldi	r24, 0x03	; 3
   113ae:	61 e0       	ldi	r22, 0x01	; 1
   113b0:	40 e4       	ldi	r20, 0x40	; 64
   113b2:	5e e0       	ldi	r21, 0x0E	; 14
   113b4:	e3 cf       	rjmp	.-58     	; 0x1137c <FSettingOperator+0x572>
		   stSettingOperator=soDisplayInvalidPassword;
		   }
	      break;
     case soDisplayInvalidPassword:
	      if (TimDisplay>6)stSettingOperator=soMenuOption;
   113b6:	80 91 a7 01 	lds	r24, 0x01A7
   113ba:	87 30       	cpi	r24, 0x07	; 7
   113bc:	60 f0       	brcs	.+24     	; 0x113d6 <FSettingOperator+0x5cc>
   113be:	04 c0       	rjmp	.+8      	; 0x113c8 <FSettingOperator+0x5be>
	      break;
     case soDelayDisplaySaved:
	      if (TimDisplay>4)stSettingOperator=soMenuOption;
   113c0:	80 91 a7 01 	lds	r24, 0x01A7
   113c4:	85 30       	cpi	r24, 0x05	; 5
   113c6:	38 f0       	brcs	.+14     	; 0x113d6 <FSettingOperator+0x5cc>
   113c8:	10 92 e2 02 	sts	0x02E2, r1
   113cc:	04 c0       	rjmp	.+8      	; 0x113d6 <FSettingOperator+0x5cc>
	      break;
	 case soExitSettingOperator:
	      stSettingOperator=soMenuOption;
   113ce:	10 92 e2 02 	sts	0x02E2, r1
   113d2:	81 e0       	ldi	r24, 0x01	; 1
   113d4:	01 c0       	rjmp	.+2      	; 0x113d8 <FSettingOperator+0x5ce>
   113d6:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
   113d8:	e5 96       	adiw	r28, 0x35	; 53
   113da:	0f b6       	in	r0, 0x3f	; 63
   113dc:	f8 94       	cli
   113de:	de bf       	out	0x3e, r29	; 62
   113e0:	0f be       	out	0x3f, r0	; 63
   113e2:	cd bf       	out	0x3d, r28	; 61
   113e4:	cf 91       	pop	r28
   113e6:	df 91       	pop	r29
   113e8:	1f 91       	pop	r17
   113ea:	0f 91       	pop	r16
   113ec:	ef 90       	pop	r14
   113ee:	08 95       	ret

000113f0 <FSettingProduct>:

void menu_product(){

}

char FSettingProduct(){//Using strDescription
   113f0:	6f 92       	push	r6
   113f2:	7f 92       	push	r7
   113f4:	8f 92       	push	r8
   113f6:	9f 92       	push	r9
   113f8:	af 92       	push	r10
   113fa:	bf 92       	push	r11
   113fc:	cf 92       	push	r12
   113fe:	df 92       	push	r13
   11400:	ef 92       	push	r14
   11402:	ff 92       	push	r15
   11404:	0f 93       	push	r16
   11406:	1f 93       	push	r17
   11408:	df 93       	push	r29
   1140a:	cf 93       	push	r28
   1140c:	cd b7       	in	r28, 0x3d	; 61
   1140e:	de b7       	in	r29, 0x3e	; 62
   11410:	a1 97       	sbiw	r28, 0x21	; 33
   11412:	0f b6       	in	r0, 0x3f	; 63
   11414:	f8 94       	cli
   11416:	de bf       	out	0x3e, r29	; 62
   11418:	0f be       	out	0x3f, r0	; 63
   1141a:	cd bf       	out	0x3d, r28	; 61
     char i;//,x,y;
	 char strProductName[13],lcdteks[20];
	 char Result=MENU_NONE;
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
   1141c:	80 91 ef 02 	lds	r24, 0x02EF
   11420:	83 30       	cpi	r24, 0x03	; 3
   11422:	09 f4       	brne	.+2      	; 0x11426 <FSettingProduct+0x36>
   11424:	ff c0       	rjmp	.+510    	; 0x11624 <FSettingProduct+0x234>
   11426:	84 30       	cpi	r24, 0x04	; 4
   11428:	38 f4       	brcc	.+14     	; 0x11438 <FSettingProduct+0x48>
   1142a:	81 30       	cpi	r24, 0x01	; 1
   1142c:	09 f4       	brne	.+2      	; 0x11430 <FSettingProduct+0x40>
   1142e:	72 c0       	rjmp	.+228    	; 0x11514 <FSettingProduct+0x124>
   11430:	82 30       	cpi	r24, 0x02	; 2
   11432:	08 f0       	brcs	.+2      	; 0x11436 <FSettingProduct+0x46>
   11434:	82 c0       	rjmp	.+260    	; 0x1153a <FSettingProduct+0x14a>
   11436:	0a c0       	rjmp	.+20     	; 0x1144c <FSettingProduct+0x5c>
   11438:	85 30       	cpi	r24, 0x05	; 5
   1143a:	09 f4       	brne	.+2      	; 0x1143e <FSettingProduct+0x4e>
   1143c:	83 c1       	rjmp	.+774    	; 0x11744 <FSettingProduct+0x354>
   1143e:	85 30       	cpi	r24, 0x05	; 5
   11440:	08 f4       	brcc	.+2      	; 0x11444 <FSettingProduct+0x54>
   11442:	a2 c1       	rjmp	.+836    	; 0x11788 <FSettingProduct+0x398>
   11444:	86 30       	cpi	r24, 0x06	; 6
   11446:	09 f0       	breq	.+2      	; 0x1144a <FSettingProduct+0x5a>
   11448:	c9 c1       	rjmp	.+914    	; 0x117dc <FSettingProduct+0x3ec>
   1144a:	c4 c1       	rjmp	.+904    	; 0x117d4 <FSettingProduct+0x3e4>
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   1144c:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
   11450:	bb eb       	ldi	r27, 0xBB	; 187
   11452:	cb 2e       	mov	r12, r27
   11454:	b0 e0       	ldi	r27, 0x00	; 0
   11456:	db 2e       	mov	r13, r27
   11458:	a1 e0       	ldi	r26, 0x01	; 1
   1145a:	ea 2e       	mov	r14, r26
   1145c:	f1 2c       	mov	r15, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   1145e:	4e 01       	movw	r8, r28
   11460:	08 94       	sec
   11462:	81 1c       	adc	r8, r1
   11464:	91 1c       	adc	r9, r1
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   11466:	fe e0       	ldi	r31, 0x0E	; 14
   11468:	af 2e       	mov	r10, r31
   1146a:	b1 2c       	mov	r11, r1
   1146c:	ac 0e       	add	r10, r28
   1146e:	bd 1e       	adc	r11, r29
   11470:	ef e0       	ldi	r30, 0x0F	; 15
   11472:	6e 2e       	mov	r6, r30
   11474:	e2 e1       	ldi	r30, 0x12	; 18
   11476:	7e 2e       	mov	r7, r30
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   11478:	0a e0       	ldi	r16, 0x0A	; 10
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   1147a:	1e 2d       	mov	r17, r14
   1147c:	11 50       	subi	r17, 0x01	; 1
   1147e:	c4 01       	movw	r24, r8
   11480:	b6 01       	movw	r22, r12
   11482:	4d e0       	ldi	r20, 0x0D	; 13
   11484:	50 e0       	ldi	r21, 0x00	; 0
   11486:	28 ef       	ldi	r18, 0xF8	; 248
   11488:	32 e1       	ldi	r19, 0x12	; 18
   1148a:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   1148e:	8d b7       	in	r24, 0x3d	; 61
   11490:	9e b7       	in	r25, 0x3e	; 62
   11492:	08 97       	sbiw	r24, 0x08	; 8
   11494:	0f b6       	in	r0, 0x3f	; 63
   11496:	f8 94       	cli
   11498:	9e bf       	out	0x3e, r25	; 62
   1149a:	0f be       	out	0x3f, r0	; 63
   1149c:	8d bf       	out	0x3d, r24	; 61
   1149e:	ed b7       	in	r30, 0x3d	; 61
   114a0:	fe b7       	in	r31, 0x3e	; 62
   114a2:	31 96       	adiw	r30, 0x01	; 1
   114a4:	ad b7       	in	r26, 0x3d	; 61
   114a6:	be b7       	in	r27, 0x3e	; 62
   114a8:	12 96       	adiw	r26, 0x02	; 2
   114aa:	bc 92       	st	X, r11
   114ac:	ae 92       	st	-X, r10
   114ae:	11 97       	sbiw	r26, 0x01	; 1
   114b0:	73 82       	std	Z+3, r7	; 0x03
   114b2:	62 82       	std	Z+2, r6	; 0x02
   114b4:	f5 82       	std	Z+5, r15	; 0x05
   114b6:	e4 82       	std	Z+4, r14	; 0x04
   114b8:	97 82       	std	Z+7, r9	; 0x07
   114ba:	86 82       	std	Z+6, r8	; 0x06
   114bc:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   114c0:	8d b7       	in	r24, 0x3d	; 61
   114c2:	9e b7       	in	r25, 0x3e	; 62
   114c4:	08 96       	adiw	r24, 0x08	; 8
   114c6:	0f b6       	in	r0, 0x3f	; 63
   114c8:	f8 94       	cli
   114ca:	9e bf       	out	0x3e, r25	; 62
   114cc:	0f be       	out	0x3f, r0	; 63
   114ce:	8d bf       	out	0x3d, r24	; 61
   114d0:	61 2f       	mov	r22, r17
   114d2:	66 95       	lsr	r22
   114d4:	66 95       	lsr	r22
   114d6:	60 9f       	mul	r22, r16
   114d8:	b0 01       	movw	r22, r0
   114da:	11 24       	eor	r1, r1
   114dc:	6f 5f       	subi	r22, 0xFF	; 255
   114de:	13 70       	andi	r17, 0x03	; 3
   114e0:	81 2f       	mov	r24, r17
   114e2:	8f 5f       	subi	r24, 0xFF	; 255
   114e4:	a5 01       	movw	r20, r10
   114e6:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
   114ea:	ad e0       	ldi	r26, 0x0D	; 13
   114ec:	b0 e0       	ldi	r27, 0x00	; 0
   114ee:	ca 0e       	add	r12, r26
   114f0:	db 1e       	adc	r13, r27
   114f2:	08 94       	sec
   114f4:	e1 1c       	adc	r14, r1
   114f6:	f1 1c       	adc	r15, r1
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
   114f8:	b9 e0       	ldi	r27, 0x09	; 9
   114fa:	cb 16       	cp	r12, r27
   114fc:	b1 e0       	ldi	r27, 0x01	; 1
   114fe:	db 06       	cpc	r13, r27
   11500:	09 f0       	breq	.+2      	; 0x11504 <FSettingProduct+0x114>
   11502:	bb cf       	rjmp	.-138    	; 0x1147a <FSettingProduct+0x8a>
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
		  }
		  lcd_printf(4,11,PSTR("*)Back"));
   11504:	84 e0       	ldi	r24, 0x04	; 4
   11506:	6b e0       	ldi	r22, 0x0B	; 11
   11508:	48 e0       	ldi	r20, 0x08	; 8
   1150a:	52 e1       	ldi	r21, 0x12	; 18
   1150c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          stMenuProduct=mpChangeProduct;
   11510:	81 e0       	ldi	r24, 0x01	; 1
   11512:	5a c1       	rjmp	.+692    	; 0x117c8 <FSettingProduct+0x3d8>
	      break;
     case mpChangeProduct:
		  KeyPressed=_key_scan(1);
   11514:	81 e0       	ldi	r24, 0x01	; 1
   11516:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   1151a:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   1151c:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   11520:	81 53       	subi	r24, 0x31	; 49
   11522:	86 30       	cpi	r24, 0x06	; 6
   11524:	28 f4       	brcc	.+10     	; 0x11530 <FSettingProduct+0x140>
		      ProdID=KeyChar-'1';
   11526:	80 93 ee 02 	sts	0x02EE, r24
			  stMenuProduct=mpDispPrice;
   1152a:	82 e0       	ldi	r24, 0x02	; 2
   1152c:	80 93 ef 02 	sts	0x02EF, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
   11530:	17 3e       	cpi	r17, 0xE7	; 231
   11532:	09 f0       	breq	.+2      	; 0x11536 <FSettingProduct+0x146>
   11534:	53 c1       	rjmp	.+678    	; 0x117dc <FSettingProduct+0x3ec>
		      stMenuProduct=mpExitMenuProduct;
   11536:	86 e0       	ldi	r24, 0x06	; 6
   11538:	47 c1       	rjmp	.+654    	; 0x117c8 <FSettingProduct+0x3d8>
   1153a:	60 91 ee 02 	lds	r22, 0x02EE
   1153e:	8d e0       	ldi	r24, 0x0D	; 13
   11540:	68 9f       	mul	r22, r24
   11542:	b0 01       	movw	r22, r0
   11544:	11 24       	eor	r1, r1
   11546:	65 54       	subi	r22, 0x45	; 69
   11548:	7f 4f       	sbci	r23, 0xFF	; 255
   1154a:	7e 01       	movw	r14, r28
   1154c:	08 94       	sec
   1154e:	e1 1c       	adc	r14, r1
   11550:	f1 1c       	adc	r15, r1
   11552:	c7 01       	movw	r24, r14
   11554:	4d e0       	ldi	r20, 0x0D	; 13
   11556:	50 e0       	ldi	r21, 0x00	; 0
   11558:	28 ef       	ldi	r18, 0xF8	; 248
   1155a:	32 e1       	ldi	r19, 0x12	; 18
   1155c:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
		  }
	      break;
     case mpDispPrice:
	 	  eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		  eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[ProdID], 9);
		  sprintf_P(lcdteks,PSTR("1)%s"),strProductName);
   11560:	74 ee       	ldi	r23, 0xE4	; 228
   11562:	c7 2e       	mov	r12, r23
   11564:	72 e0       	ldi	r23, 0x02	; 2
   11566:	d7 2e       	mov	r13, r23
   11568:	60 91 ee 02 	lds	r22, 0x02EE
   1156c:	89 e0       	ldi	r24, 0x09	; 9
   1156e:	68 9f       	mul	r22, r24
   11570:	b0 01       	movw	r22, r0
   11572:	11 24       	eor	r1, r1
   11574:	6b 57       	subi	r22, 0x7B	; 123
   11576:	7f 4f       	sbci	r23, 0xFF	; 255
   11578:	c6 01       	movw	r24, r12
   1157a:	49 e0       	ldi	r20, 0x09	; 9
   1157c:	50 e0       	ldi	r21, 0x00	; 0
   1157e:	28 ef       	ldi	r18, 0xF8	; 248
   11580:	32 e1       	ldi	r19, 0x12	; 18
   11582:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
   11586:	00 d0       	rcall	.+0      	; 0x11588 <FSettingProduct+0x198>
   11588:	00 d0       	rcall	.+0      	; 0x1158a <FSettingProduct+0x19a>
   1158a:	00 d0       	rcall	.+0      	; 0x1158c <FSettingProduct+0x19c>
   1158c:	ed b7       	in	r30, 0x3d	; 61
   1158e:	fe b7       	in	r31, 0x3e	; 62
   11590:	31 96       	adiw	r30, 0x01	; 1
   11592:	8e 01       	movw	r16, r28
   11594:	02 5f       	subi	r16, 0xF2	; 242
   11596:	1f 4f       	sbci	r17, 0xFF	; 255
   11598:	ad b7       	in	r26, 0x3d	; 61
   1159a:	be b7       	in	r27, 0x3e	; 62
   1159c:	12 96       	adiw	r26, 0x02	; 2
   1159e:	1c 93       	st	X, r17
   115a0:	0e 93       	st	-X, r16
   115a2:	11 97       	sbiw	r26, 0x01	; 1
   115a4:	83 e0       	ldi	r24, 0x03	; 3
   115a6:	92 e1       	ldi	r25, 0x12	; 18
   115a8:	93 83       	std	Z+3, r25	; 0x03
   115aa:	82 83       	std	Z+2, r24	; 0x02
   115ac:	f5 82       	std	Z+5, r15	; 0x05
   115ae:	e4 82       	std	Z+4, r14	; 0x04
   115b0:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_clear();lcd_print(1,1,lcdteks);
   115b4:	8d b7       	in	r24, 0x3d	; 61
   115b6:	9e b7       	in	r25, 0x3e	; 62
   115b8:	06 96       	adiw	r24, 0x06	; 6
   115ba:	0f b6       	in	r0, 0x3f	; 63
   115bc:	f8 94       	cli
   115be:	9e bf       	out	0x3e, r25	; 62
   115c0:	0f be       	out	0x3f, r0	; 63
   115c2:	8d bf       	out	0x3d, r24	; 61
   115c4:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
   115c8:	81 e0       	ldi	r24, 0x01	; 1
   115ca:	61 e0       	ldi	r22, 0x01	; 1
   115cc:	a8 01       	movw	r20, r16
   115ce:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2)%s"),strPrice);
   115d2:	00 d0       	rcall	.+0      	; 0x115d4 <FSettingProduct+0x1e4>
   115d4:	00 d0       	rcall	.+0      	; 0x115d6 <FSettingProduct+0x1e6>
   115d6:	00 d0       	rcall	.+0      	; 0x115d8 <FSettingProduct+0x1e8>
   115d8:	ed b7       	in	r30, 0x3d	; 61
   115da:	fe b7       	in	r31, 0x3e	; 62
   115dc:	31 96       	adiw	r30, 0x01	; 1
   115de:	ad b7       	in	r26, 0x3d	; 61
   115e0:	be b7       	in	r27, 0x3e	; 62
   115e2:	12 96       	adiw	r26, 0x02	; 2
   115e4:	1c 93       	st	X, r17
   115e6:	0e 93       	st	-X, r16
   115e8:	11 97       	sbiw	r26, 0x01	; 1
   115ea:	8e ef       	ldi	r24, 0xFE	; 254
   115ec:	91 e1       	ldi	r25, 0x11	; 17
   115ee:	93 83       	std	Z+3, r25	; 0x03
   115f0:	82 83       	std	Z+2, r24	; 0x02
   115f2:	d5 82       	std	Z+5, r13	; 0x05
   115f4:	c4 82       	std	Z+4, r12	; 0x04
   115f6:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   115fa:	8d b7       	in	r24, 0x3d	; 61
   115fc:	9e b7       	in	r25, 0x3e	; 62
   115fe:	06 96       	adiw	r24, 0x06	; 6
   11600:	0f b6       	in	r0, 0x3f	; 63
   11602:	f8 94       	cli
   11604:	9e bf       	out	0x3e, r25	; 62
   11606:	0f be       	out	0x3f, r0	; 63
   11608:	8d bf       	out	0x3d, r24	; 61
   1160a:	82 e0       	ldi	r24, 0x02	; 2
   1160c:	61 e0       	ldi	r22, 0x01	; 1
   1160e:	a8 01       	movw	r20, r16
   11610:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_printf(4,1,PSTR("*)Back       "));
   11614:	84 e0       	ldi	r24, 0x04	; 4
   11616:	61 e0       	ldi	r22, 0x01	; 1
   11618:	40 ef       	ldi	r20, 0xF0	; 240
   1161a:	51 e1       	ldi	r21, 0x11	; 17
   1161c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  stMenuProduct=mpIsEdit;
   11620:	83 e0       	ldi	r24, 0x03	; 3
   11622:	d2 c0       	rjmp	.+420    	; 0x117c8 <FSettingProduct+0x3d8>
	      break;
     case mpIsEdit:
		  KeyPressed=_key_scan(1);
   11624:	81 e0       	ldi	r24, 0x01	; 1
   11626:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   1162a:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
		  if (KeyChar=='*'){
   1162e:	8a 32       	cpi	r24, 0x2A	; 42
   11630:	09 f4       	brne	.+2      	; 0x11634 <FSettingProduct+0x244>
   11632:	a7 c0       	rjmp	.+334    	; 0x11782 <FSettingProduct+0x392>
		      stMenuProduct=mpInitProduct;
		  }else
		  if (KeyChar=='1'){
   11634:	81 33       	cpi	r24, 0x31	; 49
   11636:	09 f0       	breq	.+2      	; 0x1163a <FSettingProduct+0x24a>
   11638:	4c c0       	rjmp	.+152    	; 0x116d2 <FSettingProduct+0x2e2>
   1163a:	60 91 ee 02 	lds	r22, 0x02EE
   1163e:	8d e0       	ldi	r24, 0x0D	; 13
   11640:	68 9f       	mul	r22, r24
   11642:	b0 01       	movw	r22, r0
   11644:	11 24       	eor	r1, r1
   11646:	65 54       	subi	r22, 0x45	; 69
   11648:	7f 4f       	sbci	r23, 0xFF	; 255
   1164a:	8e 01       	movw	r16, r28
   1164c:	0f 5f       	subi	r16, 0xFF	; 255
   1164e:	1f 4f       	sbci	r17, 0xFF	; 255
   11650:	c8 01       	movw	r24, r16
   11652:	4d e0       	ldi	r20, 0x0D	; 13
   11654:	50 e0       	ldi	r21, 0x00	; 0
   11656:	28 ef       	ldi	r18, 0xF8	; 248
   11658:	32 e1       	ldi	r19, 0x12	; 18
   1165a:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
		      eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		      sprintf_P(lcdteks,PSTR("Old:%s"),strProductName);
   1165e:	00 d0       	rcall	.+0      	; 0x11660 <FSettingProduct+0x270>
   11660:	00 d0       	rcall	.+0      	; 0x11662 <FSettingProduct+0x272>
   11662:	00 d0       	rcall	.+0      	; 0x11664 <FSettingProduct+0x274>
   11664:	ed b7       	in	r30, 0x3d	; 61
   11666:	fe b7       	in	r31, 0x3e	; 62
   11668:	31 96       	adiw	r30, 0x01	; 1
   1166a:	6e e0       	ldi	r22, 0x0E	; 14
   1166c:	e6 2e       	mov	r14, r22
   1166e:	f1 2c       	mov	r15, r1
   11670:	ec 0e       	add	r14, r28
   11672:	fd 1e       	adc	r15, r29
   11674:	ad b7       	in	r26, 0x3d	; 61
   11676:	be b7       	in	r27, 0x3e	; 62
   11678:	12 96       	adiw	r26, 0x02	; 2
   1167a:	fc 92       	st	X, r15
   1167c:	ee 92       	st	-X, r14
   1167e:	11 97       	sbiw	r26, 0x01	; 1
   11680:	89 ee       	ldi	r24, 0xE9	; 233
   11682:	91 e1       	ldi	r25, 0x11	; 17
   11684:	93 83       	std	Z+3, r25	; 0x03
   11686:	82 83       	std	Z+2, r24	; 0x02
   11688:	15 83       	std	Z+5, r17	; 0x05
   1168a:	04 83       	std	Z+4, r16	; 0x04
   1168c:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			  lcd_printf(1,1,PSTR("Edit Product Name   "));
   11690:	8d b7       	in	r24, 0x3d	; 61
   11692:	9e b7       	in	r25, 0x3e	; 62
   11694:	06 96       	adiw	r24, 0x06	; 6
   11696:	0f b6       	in	r0, 0x3f	; 63
   11698:	f8 94       	cli
   1169a:	9e bf       	out	0x3e, r25	; 62
   1169c:	0f be       	out	0x3f, r0	; 63
   1169e:	8d bf       	out	0x3d, r24	; 61
   116a0:	81 e0       	ldi	r24, 0x01	; 1
   116a2:	61 e0       	ldi	r22, 0x01	; 1
   116a4:	44 ed       	ldi	r20, 0xD4	; 212
   116a6:	51 e1       	ldi	r21, 0x11	; 17
   116a8:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		       lcd_print(2,1,lcdteks);
   116ac:	82 e0       	ldi	r24, 0x02	; 2
   116ae:	61 e0       	ldi	r22, 0x01	; 1
   116b0:	a7 01       	movw	r20, r14
   116b2:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   116b6:	83 e0       	ldi	r24, 0x03	; 3
   116b8:	61 e0       	ldi	r22, 0x01	; 1
   116ba:	4e ec       	ldi	r20, 0xCE	; 206
   116bc:	51 e1       	ldi	r21, 0x11	; 17
   116be:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   116c2:	84 e0       	ldi	r24, 0x04	; 4
   116c4:	61 e0       	ldi	r22, 0x01	; 1
   116c6:	49 eb       	ldi	r20, 0xB9	; 185
   116c8:	51 e1       	ldi	r21, 0x11	; 17
   116ca:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		      stMenuProduct=mpEditProductName;
   116ce:	85 e0       	ldi	r24, 0x05	; 5
   116d0:	7b c0       	rjmp	.+246    	; 0x117c8 <FSettingProduct+0x3d8>
		  }else
		  if (KeyChar=='2'){
   116d2:	82 33       	cpi	r24, 0x32	; 50
   116d4:	09 f0       	breq	.+2      	; 0x116d8 <FSettingProduct+0x2e8>
   116d6:	82 c0       	rjmp	.+260    	; 0x117dc <FSettingProduct+0x3ec>
		      uiResult=USER_NONE;
   116d8:	10 92 ed 02 	sts	0x02ED, r1
		      sprintf_P(lcdteks,PSTR("Old:%s"),strPrice);
   116dc:	00 d0       	rcall	.+0      	; 0x116de <FSettingProduct+0x2ee>
   116de:	00 d0       	rcall	.+0      	; 0x116e0 <FSettingProduct+0x2f0>
   116e0:	00 d0       	rcall	.+0      	; 0x116e2 <FSettingProduct+0x2f2>
   116e2:	ed b7       	in	r30, 0x3d	; 61
   116e4:	fe b7       	in	r31, 0x3e	; 62
   116e6:	31 96       	adiw	r30, 0x01	; 1
   116e8:	8e 01       	movw	r16, r28
   116ea:	02 5f       	subi	r16, 0xF2	; 242
   116ec:	1f 4f       	sbci	r17, 0xFF	; 255
   116ee:	ad b7       	in	r26, 0x3d	; 61
   116f0:	be b7       	in	r27, 0x3e	; 62
   116f2:	12 96       	adiw	r26, 0x02	; 2
   116f4:	1c 93       	st	X, r17
   116f6:	0e 93       	st	-X, r16
   116f8:	11 97       	sbiw	r26, 0x01	; 1
   116fa:	82 eb       	ldi	r24, 0xB2	; 178
   116fc:	91 e1       	ldi	r25, 0x11	; 17
   116fe:	93 83       	std	Z+3, r25	; 0x03
   11700:	82 83       	std	Z+2, r24	; 0x02
   11702:	84 ee       	ldi	r24, 0xE4	; 228
   11704:	92 e0       	ldi	r25, 0x02	; 2
   11706:	95 83       	std	Z+5, r25	; 0x05
   11708:	84 83       	std	Z+4, r24	; 0x04
   1170a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		       lcd_print(2,1,lcdteks);
   1170e:	8d b7       	in	r24, 0x3d	; 61
   11710:	9e b7       	in	r25, 0x3e	; 62
   11712:	06 96       	adiw	r24, 0x06	; 6
   11714:	0f b6       	in	r0, 0x3f	; 63
   11716:	f8 94       	cli
   11718:	9e bf       	out	0x3e, r25	; 62
   1171a:	0f be       	out	0x3f, r0	; 63
   1171c:	8d bf       	out	0x3d, r24	; 61
   1171e:	82 e0       	ldi	r24, 0x02	; 2
   11720:	61 e0       	ldi	r22, 0x01	; 1
   11722:	a8 01       	movw	r20, r16
   11724:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   11728:	83 e0       	ldi	r24, 0x03	; 3
   1172a:	61 e0       	ldi	r22, 0x01	; 1
   1172c:	4c ea       	ldi	r20, 0xAC	; 172
   1172e:	51 e1       	ldi	r21, 0x11	; 17
   11730:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   11734:	84 e0       	ldi	r24, 0x04	; 4
   11736:	61 e0       	ldi	r22, 0x01	; 1
   11738:	47 e9       	ldi	r20, 0x97	; 151
   1173a:	51 e1       	ldi	r21, 0x11	; 17
   1173c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		      stMenuProduct=mpEditPrice;
   11740:	84 e0       	ldi	r24, 0x04	; 4
   11742:	42 c0       	rjmp	.+132    	; 0x117c8 <FSettingProduct+0x3d8>
		  }
	      break;
     case mpEditProductName:
	      uiResult=UserInput(UI_ALPHANUM_R,3,5,strDescription,0,10);
   11744:	83 e0       	ldi	r24, 0x03	; 3
   11746:	63 e0       	ldi	r22, 0x03	; 3
   11748:	45 e0       	ldi	r20, 0x05	; 5
   1174a:	2b ec       	ldi	r18, 0xCB	; 203
   1174c:	3b e0       	ldi	r19, 0x0B	; 11
   1174e:	00 e0       	ldi	r16, 0x00	; 0
   11750:	10 e0       	ldi	r17, 0x00	; 0
   11752:	5a e0       	ldi	r21, 0x0A	; 10
   11754:	e5 2e       	mov	r14, r21
   11756:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
   1175a:	80 93 ed 02 	sts	0x02ED, r24
		  if (uiResult==USER_OK){
   1175e:	83 30       	cpi	r24, 0x03	; 3
   11760:	b1 f5       	brne	.+108    	; 0x117ce <FSettingProduct+0x3de>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   11762:	80 91 ee 02 	lds	r24, 0x02EE
   11766:	2d e0       	ldi	r18, 0x0D	; 13
   11768:	82 9f       	mul	r24, r18
   1176a:	c0 01       	movw	r24, r0
   1176c:	11 24       	eor	r1, r1
   1176e:	85 54       	subi	r24, 0x45	; 69
   11770:	9f 4f       	sbci	r25, 0xFF	; 255
   11772:	6b ec       	ldi	r22, 0xCB	; 203
   11774:	7b e0       	ldi	r23, 0x0B	; 11
   11776:	4d e0       	ldi	r20, 0x0D	; 13
   11778:	50 e0       	ldi	r21, 0x00	; 0
   1177a:	20 e0       	ldi	r18, 0x00	; 0
   1177c:	33 e1       	ldi	r19, 0x13	; 19
   1177e:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
		      eeprom_write_block((const void*)&strDescription,(void*)&DefProductName[ProdID], 13);
		      stMenuProduct=mpInitProduct;
   11782:	10 92 ef 02 	sts	0x02EF, r1
   11786:	2a c0       	rjmp	.+84     	; 0x117dc <FSettingProduct+0x3ec>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
	      break;
     case mpEditPrice:
	      uiResult=UserInput(UI_NUMBER_R,3,5,strPrice,0,7);
   11788:	81 e0       	ldi	r24, 0x01	; 1
   1178a:	63 e0       	ldi	r22, 0x03	; 3
   1178c:	45 e0       	ldi	r20, 0x05	; 5
   1178e:	24 ee       	ldi	r18, 0xE4	; 228
   11790:	32 e0       	ldi	r19, 0x02	; 2
   11792:	00 e0       	ldi	r16, 0x00	; 0
   11794:	10 e0       	ldi	r17, 0x00	; 0
   11796:	97 e0       	ldi	r25, 0x07	; 7
   11798:	e9 2e       	mov	r14, r25
   1179a:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
   1179e:	80 93 ed 02 	sts	0x02ED, r24
		  if (uiResult==USER_OK){
   117a2:	83 30       	cpi	r24, 0x03	; 3
   117a4:	a1 f4       	brne	.+40     	; 0x117ce <FSettingProduct+0x3de>
   117a6:	80 91 ee 02 	lds	r24, 0x02EE
   117aa:	29 e0       	ldi	r18, 0x09	; 9
   117ac:	82 9f       	mul	r24, r18
   117ae:	c0 01       	movw	r24, r0
   117b0:	11 24       	eor	r1, r1
   117b2:	8b 57       	subi	r24, 0x7B	; 123
   117b4:	9f 4f       	sbci	r25, 0xFF	; 255
   117b6:	64 ee       	ldi	r22, 0xE4	; 228
   117b8:	72 e0       	ldi	r23, 0x02	; 2
   117ba:	49 e0       	ldi	r20, 0x09	; 9
   117bc:	50 e0       	ldi	r21, 0x00	; 0
   117be:	20 e0       	ldi	r18, 0x00	; 0
   117c0:	33 e1       	ldi	r19, 0x13	; 19
   117c2:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
		      eeprom_write_block((const void*)&strPrice,(void*)&DefProductPrice[ProdID], 9);
		      stMenuProduct=mpDispPrice;//stMenuProduct=mpInit;
   117c6:	82 e0       	ldi	r24, 0x02	; 2
   117c8:	80 93 ef 02 	sts	0x02EF, r24
   117cc:	07 c0       	rjmp	.+14     	; 0x117dc <FSettingProduct+0x3ec>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
   117ce:	81 30       	cpi	r24, 0x01	; 1
   117d0:	29 f4       	brne	.+10     	; 0x117dc <FSettingProduct+0x3ec>
   117d2:	f9 cf       	rjmp	.-14     	; 0x117c6 <FSettingProduct+0x3d6>
	      break;
     case mpExitMenuProduct:
	      stMenuProduct=mpInitProduct;
   117d4:	10 92 ef 02 	sts	0x02EF, r1
   117d8:	81 e0       	ldi	r24, 0x01	; 1
   117da:	01 c0       	rjmp	.+2      	; 0x117de <FSettingProduct+0x3ee>
   117dc:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   117de:	a1 96       	adiw	r28, 0x21	; 33
   117e0:	0f b6       	in	r0, 0x3f	; 63
   117e2:	f8 94       	cli
   117e4:	de bf       	out	0x3e, r29	; 62
   117e6:	0f be       	out	0x3f, r0	; 63
   117e8:	cd bf       	out	0x3d, r28	; 61
   117ea:	cf 91       	pop	r28
   117ec:	df 91       	pop	r29
   117ee:	1f 91       	pop	r17
   117f0:	0f 91       	pop	r16
   117f2:	ff 90       	pop	r15
   117f4:	ef 90       	pop	r14
   117f6:	df 90       	pop	r13
   117f8:	cf 90       	pop	r12
   117fa:	bf 90       	pop	r11
   117fc:	af 90       	pop	r10
   117fe:	9f 90       	pop	r9
   11800:	8f 90       	pop	r8
   11802:	7f 90       	pop	r7
   11804:	6f 90       	pop	r6
   11806:	08 95       	ret

00011808 <FMenuSettingFooter>:
	 }
   //_menu_header();   
   return Result;
}

char FMenuSettingFooter(){
   11808:	ef 92       	push	r14
   1180a:	0f 93       	push	r16
   1180c:	1f 93       	push	r17
   1180e:	df 93       	push	r29
   11810:	cf 93       	push	r28
   11812:	cd b7       	in	r28, 0x3d	; 61
   11814:	de b7       	in	r29, 0x3e	; 62
   11816:	c6 54       	subi	r28, 0x46	; 70
   11818:	d0 40       	sbci	r29, 0x00	; 0
   1181a:	0f b6       	in	r0, 0x3f	; 63
   1181c:	f8 94       	cli
   1181e:	de bf       	out	0x3e, r29	; 62
   11820:	0f be       	out	0x3f, r0	; 63
   11822:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[50];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   11824:	80 91 1a 03 	lds	r24, 0x031A
   11828:	84 30       	cpi	r24, 0x04	; 4
   1182a:	09 f4       	brne	.+2      	; 0x1182e <FMenuSettingFooter+0x26>
   1182c:	3f c1       	rjmp	.+638    	; 0x11aac <FMenuSettingFooter+0x2a4>
   1182e:	85 30       	cpi	r24, 0x05	; 5
   11830:	40 f4       	brcc	.+16     	; 0x11842 <FMenuSettingFooter+0x3a>
   11832:	81 30       	cpi	r24, 0x01	; 1
   11834:	79 f1       	breq	.+94     	; 0x11894 <FMenuSettingFooter+0x8c>
   11836:	81 30       	cpi	r24, 0x01	; 1
   11838:	88 f0       	brcs	.+34     	; 0x1185c <FMenuSettingFooter+0x54>
   1183a:	82 30       	cpi	r24, 0x02	; 2
   1183c:	09 f0       	breq	.+2      	; 0x11840 <FMenuSettingFooter+0x38>
   1183e:	83 c1       	rjmp	.+774    	; 0x11b46 <FMenuSettingFooter+0x33e>
   11840:	76 c0       	rjmp	.+236    	; 0x1192e <FMenuSettingFooter+0x126>
   11842:	86 30       	cpi	r24, 0x06	; 6
   11844:	09 f4       	brne	.+2      	; 0x11848 <FMenuSettingFooter+0x40>
   11846:	d7 c0       	rjmp	.+430    	; 0x119f6 <FMenuSettingFooter+0x1ee>
   11848:	86 30       	cpi	r24, 0x06	; 6
   1184a:	08 f4       	brcc	.+2      	; 0x1184e <FMenuSettingFooter+0x46>
   1184c:	bf c0       	rjmp	.+382    	; 0x119cc <FMenuSettingFooter+0x1c4>
   1184e:	87 30       	cpi	r24, 0x07	; 7
   11850:	09 f4       	brne	.+2      	; 0x11854 <FMenuSettingFooter+0x4c>
   11852:	3c c1       	rjmp	.+632    	; 0x11acc <FMenuSettingFooter+0x2c4>
   11854:	88 30       	cpi	r24, 0x08	; 8
   11856:	09 f0       	breq	.+2      	; 0x1185a <FMenuSettingFooter+0x52>
   11858:	76 c1       	rjmp	.+748    	; 0x11b46 <FMenuSettingFooter+0x33e>
   1185a:	71 c1       	rjmp	.+738    	; 0x11b3e <FMenuSettingFooter+0x336>
	 case shInitHeader:
	      lcd_clear();
   1185c:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Footer1  3)Footer3"));
   11860:	81 e0       	ldi	r24, 0x01	; 1
   11862:	61 e0       	ldi	r22, 0x01	; 1
   11864:	46 e0       	ldi	r20, 0x06	; 6
   11866:	54 e1       	ldi	r21, 0x14	; 20
   11868:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Footer2  4)Footer4"));
   1186c:	82 e0       	ldi	r24, 0x02	; 2
   1186e:	61 e0       	ldi	r22, 0x01	; 1
   11870:	41 ef       	ldi	r20, 0xF1	; 241
   11872:	53 e1       	ldi	r21, 0x13	; 19
   11874:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(3,1,PSTR("                    "));
   11878:	83 e0       	ldi	r24, 0x03	; 3
   1187a:	61 e0       	ldi	r22, 0x01	; 1
   1187c:	4c ed       	ldi	r20, 0xDC	; 220
   1187e:	53 e1       	ldi	r21, 0x13	; 19
   11880:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   11884:	84 e0       	ldi	r24, 0x04	; 4
   11886:	61 e0       	ldi	r22, 0x01	; 1
   11888:	47 ec       	ldi	r20, 0xC7	; 199
   1188a:	53 e1       	ldi	r21, 0x13	; 19
   1188c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   11890:	81 e0       	ldi	r24, 0x01	; 1
   11892:	16 c1       	rjmp	.+556    	; 0x11ac0 <FMenuSettingFooter+0x2b8>
	      break;
      case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   11894:	81 e0       	ldi	r24, 0x01	; 1
   11896:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   1189a:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   1189e:	80 93 18 03 	sts	0x0318, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   118a2:	81 53       	subi	r24, 0x31	; 49
   118a4:	86 30       	cpi	r24, 0x06	; 6
   118a6:	e0 f5       	brcc	.+120    	; 0x11920 <FMenuSettingFooter+0x118>
		       HeaderIdx=KeyChar-'1';//
   118a8:	80 93 19 03 	sts	0x0319, r24
			   lcd_clear();
   118ac:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
   118b0:	00 d0       	rcall	.+0      	; 0x118b2 <FMenuSettingFooter+0xaa>
   118b2:	00 d0       	rcall	.+0      	; 0x118b4 <FMenuSettingFooter+0xac>
   118b4:	00 d0       	rcall	.+0      	; 0x118b6 <FMenuSettingFooter+0xae>
   118b6:	ed b7       	in	r30, 0x3d	; 61
   118b8:	fe b7       	in	r31, 0x3e	; 62
   118ba:	31 96       	adiw	r30, 0x01	; 1
   118bc:	8e 01       	movw	r16, r28
   118be:	0f 5f       	subi	r16, 0xFF	; 255
   118c0:	1f 4f       	sbci	r17, 0xFF	; 255
   118c2:	ad b7       	in	r26, 0x3d	; 61
   118c4:	be b7       	in	r27, 0x3e	; 62
   118c6:	12 96       	adiw	r26, 0x02	; 2
   118c8:	1c 93       	st	X, r17
   118ca:	0e 93       	st	-X, r16
   118cc:	11 97       	sbiw	r26, 0x01	; 1
   118ce:	88 eb       	ldi	r24, 0xB8	; 184
   118d0:	93 e1       	ldi	r25, 0x13	; 19
   118d2:	93 83       	std	Z+3, r25	; 0x03
   118d4:	82 83       	std	Z+2, r24	; 0x02
   118d6:	80 91 19 03 	lds	r24, 0x0319
   118da:	90 e0       	ldi	r25, 0x00	; 0
   118dc:	01 96       	adiw	r24, 0x01	; 1
   118de:	95 83       	std	Z+5, r25	; 0x05
   118e0:	84 83       	std	Z+4, r24	; 0x04
   118e2:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			   lcd_print(1,1,lcdteks);
   118e6:	8d b7       	in	r24, 0x3d	; 61
   118e8:	9e b7       	in	r25, 0x3e	; 62
   118ea:	06 96       	adiw	r24, 0x06	; 6
   118ec:	0f b6       	in	r0, 0x3f	; 63
   118ee:	f8 94       	cli
   118f0:	9e bf       	out	0x3e, r25	; 62
   118f2:	0f be       	out	0x3f, r0	; 63
   118f4:	8d bf       	out	0x3d, r24	; 61
   118f6:	81 e0       	ldi	r24, 0x01	; 1
   118f8:	61 e0       	ldi	r22, 0x01	; 1
   118fa:	a8 01       	movw	r20, r16
   118fc:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   11900:	84 e0       	ldi	r24, 0x04	; 4
   11902:	61 e0       	ldi	r22, 0x01	; 1
   11904:	49 ea       	ldi	r20, 0xA9	; 169
   11906:	53 e1       	ldi	r21, 0x13	; 19
   11908:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   1190c:	ef ec       	ldi	r30, 0xCF	; 207
   1190e:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   11910:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11912:	97 e0       	ldi	r25, 0x07	; 7
   11914:	e0 36       	cpi	r30, 0x60	; 96
   11916:	f9 07       	cpc	r31, r25
   11918:	d9 f7       	brne	.-10     	; 0x11910 <FMenuSettingFooter+0x108>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
   1191a:	82 e0       	ldi	r24, 0x02	; 2
   1191c:	80 93 1a 03 	sts	0x031A, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   11920:	80 91 18 03 	lds	r24, 0x0318
   11924:	8a 32       	cpi	r24, 0x2A	; 42
   11926:	09 f0       	breq	.+2      	; 0x1192a <FMenuSettingFooter+0x122>
   11928:	0e c1       	rjmp	.+540    	; 0x11b46 <FMenuSettingFooter+0x33e>
   1192a:	88 e0       	ldi	r24, 0x08	; 8
   1192c:	c9 c0       	rjmp	.+402    	; 0x11ac0 <FMenuSettingFooter+0x2b8>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,AdvanZ.Message09.strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
   1192e:	83 e0       	ldi	r24, 0x03	; 3
   11930:	62 e0       	ldi	r22, 0x02	; 2
   11932:	41 e0       	ldi	r20, 0x01	; 1
   11934:	2f ec       	ldi	r18, 0xCF	; 207
   11936:	35 e0       	ldi	r19, 0x05	; 5
   11938:	00 e0       	ldi	r16, 0x00	; 0
   1193a:	10 e0       	ldi	r17, 0x00	; 0
   1193c:	98 e2       	ldi	r25, 0x28	; 40
   1193e:	e9 2e       	mov	r14, r25
   11940:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
		  if (uiResult==USER_OK){
   11944:	83 30       	cpi	r24, 0x03	; 3
   11946:	f1 f5       	brne	.+124    	; 0x119c4 <FMenuSettingFooter+0x1bc>
			  lcd_clear();
   11948:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
   1194c:	8f ec       	ldi	r24, 0xCF	; 207
   1194e:	95 e0       	ldi	r25, 0x05	; 5
   11950:	68 e2       	ldi	r22, 0x28	; 40
   11952:	0e 94 3c 2e 	call	0x5c78	; 0x5c78 <AddSpaceLag>
   11956:	20 e0       	ldi	r18, 0x00	; 0
   11958:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1195a:	f9 01       	movw	r30, r18
   1195c:	ea 51       	subi	r30, 0x1A	; 26
   1195e:	f6 4f       	sbci	r31, 0xF6	; 246
   11960:	d9 01       	movw	r26, r18
   11962:	a1 53       	subi	r26, 0x31	; 49
   11964:	ba 4f       	sbci	r27, 0xFA	; 250
   11966:	8c 91       	ld	r24, X
   11968:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1196a:	2f 5f       	subi	r18, 0xFF	; 255
   1196c:	3f 4f       	sbci	r19, 0xFF	; 255
   1196e:	24 31       	cpi	r18, 0x14	; 20
   11970:	31 05       	cpc	r19, r1
   11972:	99 f7       	brne	.-26     	; 0x1195a <FMenuSettingFooter+0x152>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11974:	10 92 fa 09 	sts	0x09FA, r1
   11978:	e3 ee       	ldi	r30, 0xE3	; 227
   1197a:	f5 e0       	ldi	r31, 0x05	; 5
   1197c:	ab ef       	ldi	r26, 0xFB	; 251
   1197e:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11980:	81 91       	ld	r24, Z+
   11982:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11984:	85 e0       	ldi	r24, 0x05	; 5
   11986:	e7 3f       	cpi	r30, 0xF7	; 247
   11988:	f8 07       	cpc	r31, r24
   1198a:	d1 f7       	brne	.-12     	; 0x11980 <FMenuSettingFooter+0x178>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   1198c:	10 92 0f 0a 	sts	0x0A0F, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,AdvanZ.Message09.strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,AdvanZ.Message09.strFreeMessageLine2,20,20);

			  lcd_print(1,1,AdvanZ.Message09.strFreeMessageLine1);			  
   11990:	81 e0       	ldi	r24, 0x01	; 1
   11992:	61 e0       	ldi	r22, 0x01	; 1
   11994:	46 ee       	ldi	r20, 0xE6	; 230
   11996:	59 e0       	ldi	r21, 0x09	; 9
   11998:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			  lcd_print(2,1,AdvanZ.Message09.strFreeMessageLine2);			  
   1199c:	82 e0       	ldi	r24, 0x02	; 2
   1199e:	61 e0       	ldi	r22, 0x01	; 1
   119a0:	4b ef       	ldi	r20, 0xFB	; 251
   119a2:	59 e0       	ldi	r21, 0x09	; 9
   119a4:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
   119a8:	83 e0       	ldi	r24, 0x03	; 3
   119aa:	61 e0       	ldi	r22, 0x01	; 1
   119ac:	4b e9       	ldi	r20, 0x9B	; 155
   119ae:	53 e1       	ldi	r21, 0x13	; 19
   119b0:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
   119b4:	84 e0       	ldi	r24, 0x04	; 4
   119b6:	61 e0       	ldi	r22, 0x01	; 1
   119b8:	4d e8       	ldi	r20, 0x8D	; 141
   119ba:	53 e1       	ldi	r21, 0x13	; 19
   119bc:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
   119c0:	85 e0       	ldi	r24, 0x05	; 5
   119c2:	7e c0       	rjmp	.+252    	; 0x11ac0 <FMenuSettingFooter+0x2b8>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   119c4:	81 30       	cpi	r24, 0x01	; 1
   119c6:	09 f0       	breq	.+2      	; 0x119ca <FMenuSettingFooter+0x1c2>
   119c8:	be c0       	rjmp	.+380    	; 0x11b46 <FMenuSettingFooter+0x33e>
   119ca:	b6 c0       	rjmp	.+364    	; 0x11b38 <FMenuSettingFooter+0x330>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
   119cc:	81 e0       	ldi	r24, 0x01	; 1
   119ce:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   119d2:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   119d6:	80 93 18 03 	sts	0x0318, r24
          if(KeyChar=='#'){
   119da:	83 32       	cpi	r24, 0x23	; 35
   119dc:	39 f4       	brne	.+14     	; 0x119ec <FMenuSettingFooter+0x1e4>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
   119de:	8f ec       	ldi	r24, 0xCF	; 207
   119e0:	95 e0       	ldi	r25, 0x05	; 5
   119e2:	68 e2       	ldi	r22, 0x28	; 40
   119e4:	70 e0       	ldi	r23, 0x00	; 0
   119e6:	0e 94 46 30 	call	0x608c	; 0x608c <StrAlignCenter>
   119ea:	03 c0       	rjmp	.+6      	; 0x119f2 <FMenuSettingFooter+0x1ea>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
   119ec:	8a 32       	cpi	r24, 0x2A	; 42
   119ee:	09 f0       	breq	.+2      	; 0x119f2 <FMenuSettingFooter+0x1ea>
   119f0:	aa c0       	rjmp	.+340    	; 0x11b46 <FMenuSettingFooter+0x33e>
   119f2:	86 e0       	ldi	r24, 0x06	; 6
   119f4:	65 c0       	rjmp	.+202    	; 0x11ac0 <FMenuSettingFooter+0x2b8>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
   119f6:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
   119fa:	20 e0       	ldi	r18, 0x00	; 0
   119fc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   119fe:	f9 01       	movw	r30, r18
   11a00:	ea 51       	subi	r30, 0x1A	; 26
   11a02:	f6 4f       	sbci	r31, 0xF6	; 246
   11a04:	d9 01       	movw	r26, r18
   11a06:	a1 53       	subi	r26, 0x31	; 49
   11a08:	ba 4f       	sbci	r27, 0xFA	; 250
   11a0a:	8c 91       	ld	r24, X
   11a0c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11a0e:	2f 5f       	subi	r18, 0xFF	; 255
   11a10:	3f 4f       	sbci	r19, 0xFF	; 255
   11a12:	24 31       	cpi	r18, 0x14	; 20
   11a14:	31 05       	cpc	r19, r1
   11a16:	99 f7       	brne	.-26     	; 0x119fe <FMenuSettingFooter+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11a18:	10 92 fa 09 	sts	0x09FA, r1
   11a1c:	e3 ee       	ldi	r30, 0xE3	; 227
   11a1e:	f5 e0       	ldi	r31, 0x05	; 5
   11a20:	ab ef       	ldi	r26, 0xFB	; 251
   11a22:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11a24:	81 91       	ld	r24, Z+
   11a26:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11a28:	95 e0       	ldi	r25, 0x05	; 5
   11a2a:	e7 3f       	cpi	r30, 0xF7	; 247
   11a2c:	f9 07       	cpc	r31, r25
   11a2e:	d1 f7       	brne	.-12     	; 0x11a24 <FMenuSettingFooter+0x21c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11a30:	10 92 0f 0a 	sts	0x0A0F, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,AdvanZ.Message09.strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,AdvanZ.Message09.strFreeMessageLine2,20,20);
          lcd_print(1,1,AdvanZ.Message09.strFreeMessageLine1);
   11a34:	81 e0       	ldi	r24, 0x01	; 1
   11a36:	61 e0       	ldi	r22, 0x01	; 1
   11a38:	46 ee       	ldi	r20, 0xE6	; 230
   11a3a:	59 e0       	ldi	r21, 0x09	; 9
   11a3c:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_print(2,1,AdvanZ.Message09.strFreeMessageLine2);
   11a40:	82 e0       	ldi	r24, 0x02	; 2
   11a42:	61 e0       	ldi	r22, 0x01	; 1
   11a44:	4b ef       	ldi	r20, 0xFB	; 251
   11a46:	59 e0       	ldi	r21, 0x09	; 9
   11a48:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Footer%d ?"),HeaderIdx+1);
   11a4c:	00 d0       	rcall	.+0      	; 0x11a4e <FMenuSettingFooter+0x246>
   11a4e:	00 d0       	rcall	.+0      	; 0x11a50 <FMenuSettingFooter+0x248>
   11a50:	00 d0       	rcall	.+0      	; 0x11a52 <FMenuSettingFooter+0x24a>
   11a52:	ed b7       	in	r30, 0x3d	; 61
   11a54:	fe b7       	in	r31, 0x3e	; 62
   11a56:	31 96       	adiw	r30, 0x01	; 1
   11a58:	8e 01       	movw	r16, r28
   11a5a:	0f 5f       	subi	r16, 0xFF	; 255
   11a5c:	1f 4f       	sbci	r17, 0xFF	; 255
   11a5e:	ad b7       	in	r26, 0x3d	; 61
   11a60:	be b7       	in	r27, 0x3e	; 62
   11a62:	12 96       	adiw	r26, 0x02	; 2
   11a64:	1c 93       	st	X, r17
   11a66:	0e 93       	st	-X, r16
   11a68:	11 97       	sbiw	r26, 0x01	; 1
   11a6a:	8d e7       	ldi	r24, 0x7D	; 125
   11a6c:	93 e1       	ldi	r25, 0x13	; 19
   11a6e:	93 83       	std	Z+3, r25	; 0x03
   11a70:	82 83       	std	Z+2, r24	; 0x02
   11a72:	80 91 19 03 	lds	r24, 0x0319
   11a76:	90 e0       	ldi	r25, 0x00	; 0
   11a78:	01 96       	adiw	r24, 0x01	; 1
   11a7a:	95 83       	std	Z+5, r25	; 0x05
   11a7c:	84 83       	std	Z+4, r24	; 0x04
   11a7e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   11a82:	8d b7       	in	r24, 0x3d	; 61
   11a84:	9e b7       	in	r25, 0x3e	; 62
   11a86:	06 96       	adiw	r24, 0x06	; 6
   11a88:	0f b6       	in	r0, 0x3f	; 63
   11a8a:	f8 94       	cli
   11a8c:	9e bf       	out	0x3e, r25	; 62
   11a8e:	0f be       	out	0x3f, r0	; 63
   11a90:	8d bf       	out	0x3d, r24	; 61
   11a92:	83 e0       	ldi	r24, 0x03	; 3
   11a94:	61 e0       	ldi	r22, 0x01	; 1
   11a96:	a8 01       	movw	r20, r16
   11a98:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
   11a9c:	84 e0       	ldi	r24, 0x04	; 4
   11a9e:	61 e0       	ldi	r22, 0x01	; 1
   11aa0:	40 e7       	ldi	r20, 0x70	; 112
   11aa2:	53 e1       	ldi	r21, 0x13	; 19
   11aa4:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
   11aa8:	84 e0       	ldi	r24, 0x04	; 4
   11aaa:	0a c0       	rjmp	.+20     	; 0x11ac0 <FMenuSettingFooter+0x2b8>
	      break;       
     case shSaveHeaderQuestions:
          KeyChar=_key_btn(_key_scan(1));
   11aac:	81 e0       	ldi	r24, 0x01	; 1
   11aae:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   11ab2:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   11ab6:	80 93 18 03 	sts	0x0318, r24
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   11aba:	83 32       	cpi	r24, 0x23	; 35
   11abc:	21 f4       	brne	.+8      	; 0x11ac6 <FMenuSettingFooter+0x2be>
   11abe:	87 e0       	ldi	r24, 0x07	; 7
   11ac0:	80 93 1a 03 	sts	0x031A, r24
   11ac4:	40 c0       	rjmp	.+128    	; 0x11b46 <FMenuSettingFooter+0x33e>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   11ac6:	8a 32       	cpi	r24, 0x2A	; 42
   11ac8:	f1 f5       	brne	.+124    	; 0x11b46 <FMenuSettingFooter+0x33e>
   11aca:	36 c0       	rjmp	.+108    	; 0x11b38 <FMenuSettingFooter+0x330>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),AdvanZ.Message09.strFreeMessageLine1,AdvanZ.Message09.strFreeMessageLine2);
   11acc:	ad b7       	in	r26, 0x3d	; 61
   11ace:	be b7       	in	r27, 0x3e	; 62
   11ad0:	18 97       	sbiw	r26, 0x08	; 8
   11ad2:	0f b6       	in	r0, 0x3f	; 63
   11ad4:	f8 94       	cli
   11ad6:	be bf       	out	0x3e, r27	; 62
   11ad8:	0f be       	out	0x3f, r0	; 63
   11ada:	ad bf       	out	0x3d, r26	; 61
   11adc:	ed b7       	in	r30, 0x3d	; 61
   11ade:	fe b7       	in	r31, 0x3e	; 62
   11ae0:	31 96       	adiw	r30, 0x01	; 1
   11ae2:	8e 01       	movw	r16, r28
   11ae4:	0b 5e       	subi	r16, 0xEB	; 235
   11ae6:	1f 4f       	sbci	r17, 0xFF	; 255
   11ae8:	12 96       	adiw	r26, 0x02	; 2
   11aea:	1c 93       	st	X, r17
   11aec:	0e 93       	st	-X, r16
   11aee:	11 97       	sbiw	r26, 0x01	; 1
   11af0:	8b e6       	ldi	r24, 0x6B	; 107
   11af2:	93 e1       	ldi	r25, 0x13	; 19
   11af4:	93 83       	std	Z+3, r25	; 0x03
   11af6:	82 83       	std	Z+2, r24	; 0x02
   11af8:	86 ee       	ldi	r24, 0xE6	; 230
   11afa:	99 e0       	ldi	r25, 0x09	; 9
   11afc:	95 83       	std	Z+5, r25	; 0x05
   11afe:	84 83       	std	Z+4, r24	; 0x04
   11b00:	45 96       	adiw	r24, 0x15	; 21
   11b02:	97 83       	std	Z+7, r25	; 0x07
   11b04:	86 83       	std	Z+6, r24	; 0x06
   11b06:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   11b0a:	8d b7       	in	r24, 0x3d	; 61
   11b0c:	9e b7       	in	r25, 0x3e	; 62
   11b0e:	08 96       	adiw	r24, 0x08	; 8
   11b10:	0f b6       	in	r0, 0x3f	; 63
   11b12:	f8 94       	cli
   11b14:	9e bf       	out	0x3e, r25	; 62
   11b16:	0f be       	out	0x3f, r0	; 63
   11b18:	8d bf       	out	0x3d, r24	; 61
   11b1a:	80 91 19 03 	lds	r24, 0x0319
   11b1e:	29 e2       	ldi	r18, 0x29	; 41
   11b20:	82 9f       	mul	r24, r18
   11b22:	c0 01       	movw	r24, r0
   11b24:	11 24       	eor	r1, r1
   11b26:	83 5e       	subi	r24, 0xE3	; 227
   11b28:	9c 4f       	sbci	r25, 0xFC	; 252
   11b2a:	b8 01       	movw	r22, r16
   11b2c:	48 e2       	ldi	r20, 0x28	; 40
   11b2e:	50 e0       	ldi	r21, 0x00	; 0
   11b30:	20 e0       	ldi	r18, 0x00	; 0
   11b32:	33 e1       	ldi	r19, 0x13	; 19
   11b34:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx+6],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx+6],40);

          stSettingHeader=shInitHeader;
   11b38:	10 92 1a 03 	sts	0x031A, r1
   11b3c:	04 c0       	rjmp	.+8      	; 0x11b46 <FMenuSettingFooter+0x33e>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   11b3e:	10 92 1a 03 	sts	0x031A, r1
   11b42:	81 e0       	ldi	r24, 0x01	; 1
   11b44:	01 c0       	rjmp	.+2      	; 0x11b48 <FMenuSettingFooter+0x340>
   11b46:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   return Result;
}
   11b48:	ca 5b       	subi	r28, 0xBA	; 186
   11b4a:	df 4f       	sbci	r29, 0xFF	; 255
   11b4c:	0f b6       	in	r0, 0x3f	; 63
   11b4e:	f8 94       	cli
   11b50:	de bf       	out	0x3e, r29	; 62
   11b52:	0f be       	out	0x3f, r0	; 63
   11b54:	cd bf       	out	0x3d, r28	; 61
   11b56:	cf 91       	pop	r28
   11b58:	df 91       	pop	r29
   11b5a:	1f 91       	pop	r17
   11b5c:	0f 91       	pop	r16
   11b5e:	ef 90       	pop	r14
   11b60:	08 95       	ret

00011b62 <FMenuSettingHeader>:
	      break;
	 }
   return Result;
}

char FMenuSettingHeader(){
   11b62:	ef 92       	push	r14
   11b64:	0f 93       	push	r16
   11b66:	1f 93       	push	r17
   11b68:	df 93       	push	r29
   11b6a:	cf 93       	push	r28
   11b6c:	cd b7       	in	r28, 0x3d	; 61
   11b6e:	de b7       	in	r29, 0x3e	; 62
   11b70:	c6 54       	subi	r28, 0x46	; 70
   11b72:	d0 40       	sbci	r29, 0x00	; 0
   11b74:	0f b6       	in	r0, 0x3f	; 63
   11b76:	f8 94       	cli
   11b78:	de bf       	out	0x3e, r29	; 62
   11b7a:	0f be       	out	0x3f, r0	; 63
   11b7c:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[50];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   11b7e:	80 91 1d 03 	lds	r24, 0x031D
   11b82:	84 30       	cpi	r24, 0x04	; 4
   11b84:	09 f4       	brne	.+2      	; 0x11b88 <FMenuSettingHeader+0x26>
   11b86:	3f c1       	rjmp	.+638    	; 0x11e06 <FMenuSettingHeader+0x2a4>
   11b88:	85 30       	cpi	r24, 0x05	; 5
   11b8a:	40 f4       	brcc	.+16     	; 0x11b9c <FMenuSettingHeader+0x3a>
   11b8c:	81 30       	cpi	r24, 0x01	; 1
   11b8e:	79 f1       	breq	.+94     	; 0x11bee <FMenuSettingHeader+0x8c>
   11b90:	81 30       	cpi	r24, 0x01	; 1
   11b92:	88 f0       	brcs	.+34     	; 0x11bb6 <FMenuSettingHeader+0x54>
   11b94:	82 30       	cpi	r24, 0x02	; 2
   11b96:	09 f0       	breq	.+2      	; 0x11b9a <FMenuSettingHeader+0x38>
   11b98:	83 c1       	rjmp	.+774    	; 0x11ea0 <FMenuSettingHeader+0x33e>
   11b9a:	76 c0       	rjmp	.+236    	; 0x11c88 <FMenuSettingHeader+0x126>
   11b9c:	86 30       	cpi	r24, 0x06	; 6
   11b9e:	09 f4       	brne	.+2      	; 0x11ba2 <FMenuSettingHeader+0x40>
   11ba0:	d7 c0       	rjmp	.+430    	; 0x11d50 <FMenuSettingHeader+0x1ee>
   11ba2:	86 30       	cpi	r24, 0x06	; 6
   11ba4:	08 f4       	brcc	.+2      	; 0x11ba8 <FMenuSettingHeader+0x46>
   11ba6:	bf c0       	rjmp	.+382    	; 0x11d26 <FMenuSettingHeader+0x1c4>
   11ba8:	87 30       	cpi	r24, 0x07	; 7
   11baa:	09 f4       	brne	.+2      	; 0x11bae <FMenuSettingHeader+0x4c>
   11bac:	3c c1       	rjmp	.+632    	; 0x11e26 <FMenuSettingHeader+0x2c4>
   11bae:	88 30       	cpi	r24, 0x08	; 8
   11bb0:	09 f0       	breq	.+2      	; 0x11bb4 <FMenuSettingHeader+0x52>
   11bb2:	76 c1       	rjmp	.+748    	; 0x11ea0 <FMenuSettingHeader+0x33e>
   11bb4:	71 c1       	rjmp	.+738    	; 0x11e98 <FMenuSettingHeader+0x336>
	 case shInitHeader:
	      lcd_clear();
   11bb6:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Header1  4)Header4"));
   11bba:	81 e0       	ldi	r24, 0x01	; 1
   11bbc:	61 e0       	ldi	r22, 0x01	; 1
   11bbe:	46 eb       	ldi	r20, 0xB6	; 182
   11bc0:	54 e1       	ldi	r21, 0x14	; 20
   11bc2:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Header2  5)Header5"));
   11bc6:	82 e0       	ldi	r24, 0x02	; 2
   11bc8:	61 e0       	ldi	r22, 0x01	; 1
   11bca:	41 ea       	ldi	r20, 0xA1	; 161
   11bcc:	54 e1       	ldi	r21, 0x14	; 20
   11bce:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(3,1,PSTR("3)Header3  6)Header6"));
   11bd2:	83 e0       	ldi	r24, 0x03	; 3
   11bd4:	61 e0       	ldi	r22, 0x01	; 1
   11bd6:	4c e8       	ldi	r20, 0x8C	; 140
   11bd8:	54 e1       	ldi	r21, 0x14	; 20
   11bda:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   11bde:	84 e0       	ldi	r24, 0x04	; 4
   11be0:	61 e0       	ldi	r22, 0x01	; 1
   11be2:	47 e7       	ldi	r20, 0x77	; 119
   11be4:	54 e1       	ldi	r21, 0x14	; 20
   11be6:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   11bea:	81 e0       	ldi	r24, 0x01	; 1
   11bec:	16 c1       	rjmp	.+556    	; 0x11e1a <FMenuSettingHeader+0x2b8>
	      break;
     case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   11bee:	81 e0       	ldi	r24, 0x01	; 1
   11bf0:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   11bf4:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   11bf8:	80 93 1b 03 	sts	0x031B, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   11bfc:	81 53       	subi	r24, 0x31	; 49
   11bfe:	86 30       	cpi	r24, 0x06	; 6
   11c00:	e0 f5       	brcc	.+120    	; 0x11c7a <FMenuSettingHeader+0x118>
		       HeaderIdx=KeyChar-'1';//
   11c02:	80 93 1c 03 	sts	0x031C, r24
			   lcd_clear();
   11c06:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
   11c0a:	00 d0       	rcall	.+0      	; 0x11c0c <FMenuSettingHeader+0xaa>
   11c0c:	00 d0       	rcall	.+0      	; 0x11c0e <FMenuSettingHeader+0xac>
   11c0e:	00 d0       	rcall	.+0      	; 0x11c10 <FMenuSettingHeader+0xae>
   11c10:	ed b7       	in	r30, 0x3d	; 61
   11c12:	fe b7       	in	r31, 0x3e	; 62
   11c14:	31 96       	adiw	r30, 0x01	; 1
   11c16:	8e 01       	movw	r16, r28
   11c18:	0f 5f       	subi	r16, 0xFF	; 255
   11c1a:	1f 4f       	sbci	r17, 0xFF	; 255
   11c1c:	ad b7       	in	r26, 0x3d	; 61
   11c1e:	be b7       	in	r27, 0x3e	; 62
   11c20:	12 96       	adiw	r26, 0x02	; 2
   11c22:	1c 93       	st	X, r17
   11c24:	0e 93       	st	-X, r16
   11c26:	11 97       	sbiw	r26, 0x01	; 1
   11c28:	88 e6       	ldi	r24, 0x68	; 104
   11c2a:	94 e1       	ldi	r25, 0x14	; 20
   11c2c:	93 83       	std	Z+3, r25	; 0x03
   11c2e:	82 83       	std	Z+2, r24	; 0x02
   11c30:	80 91 1c 03 	lds	r24, 0x031C
   11c34:	90 e0       	ldi	r25, 0x00	; 0
   11c36:	01 96       	adiw	r24, 0x01	; 1
   11c38:	95 83       	std	Z+5, r25	; 0x05
   11c3a:	84 83       	std	Z+4, r24	; 0x04
   11c3c:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			   lcd_print(1,1,lcdteks);
   11c40:	8d b7       	in	r24, 0x3d	; 61
   11c42:	9e b7       	in	r25, 0x3e	; 62
   11c44:	06 96       	adiw	r24, 0x06	; 6
   11c46:	0f b6       	in	r0, 0x3f	; 63
   11c48:	f8 94       	cli
   11c4a:	9e bf       	out	0x3e, r25	; 62
   11c4c:	0f be       	out	0x3f, r0	; 63
   11c4e:	8d bf       	out	0x3d, r24	; 61
   11c50:	81 e0       	ldi	r24, 0x01	; 1
   11c52:	61 e0       	ldi	r22, 0x01	; 1
   11c54:	a8 01       	movw	r20, r16
   11c56:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   11c5a:	84 e0       	ldi	r24, 0x04	; 4
   11c5c:	61 e0       	ldi	r22, 0x01	; 1
   11c5e:	49 e5       	ldi	r20, 0x59	; 89
   11c60:	54 e1       	ldi	r21, 0x14	; 20
   11c62:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   11c66:	ef ec       	ldi	r30, 0xCF	; 207
   11c68:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   11c6a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11c6c:	97 e0       	ldi	r25, 0x07	; 7
   11c6e:	e0 36       	cpi	r30, 0x60	; 96
   11c70:	f9 07       	cpc	r31, r25
   11c72:	d9 f7       	brne	.-10     	; 0x11c6a <FMenuSettingHeader+0x108>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
   11c74:	82 e0       	ldi	r24, 0x02	; 2
   11c76:	80 93 1d 03 	sts	0x031D, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   11c7a:	80 91 1b 03 	lds	r24, 0x031B
   11c7e:	8a 32       	cpi	r24, 0x2A	; 42
   11c80:	09 f0       	breq	.+2      	; 0x11c84 <FMenuSettingHeader+0x122>
   11c82:	0e c1       	rjmp	.+540    	; 0x11ea0 <FMenuSettingHeader+0x33e>
   11c84:	88 e0       	ldi	r24, 0x08	; 8
   11c86:	c9 c0       	rjmp	.+402    	; 0x11e1a <FMenuSettingHeader+0x2b8>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,AdvanZ.Message09.strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
   11c88:	83 e0       	ldi	r24, 0x03	; 3
   11c8a:	62 e0       	ldi	r22, 0x02	; 2
   11c8c:	41 e0       	ldi	r20, 0x01	; 1
   11c8e:	2f ec       	ldi	r18, 0xCF	; 207
   11c90:	35 e0       	ldi	r19, 0x05	; 5
   11c92:	00 e0       	ldi	r16, 0x00	; 0
   11c94:	10 e0       	ldi	r17, 0x00	; 0
   11c96:	58 e2       	ldi	r21, 0x28	; 40
   11c98:	e5 2e       	mov	r14, r21
   11c9a:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
		  if (uiResult==USER_OK){
   11c9e:	83 30       	cpi	r24, 0x03	; 3
   11ca0:	f1 f5       	brne	.+124    	; 0x11d1e <FMenuSettingHeader+0x1bc>
			  lcd_clear();
   11ca2:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
   11ca6:	8f ec       	ldi	r24, 0xCF	; 207
   11ca8:	95 e0       	ldi	r25, 0x05	; 5
   11caa:	68 e2       	ldi	r22, 0x28	; 40
   11cac:	0e 94 3c 2e 	call	0x5c78	; 0x5c78 <AddSpaceLag>
   11cb0:	20 e0       	ldi	r18, 0x00	; 0
   11cb2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11cb4:	f9 01       	movw	r30, r18
   11cb6:	ea 51       	subi	r30, 0x1A	; 26
   11cb8:	f6 4f       	sbci	r31, 0xF6	; 246
   11cba:	d9 01       	movw	r26, r18
   11cbc:	a1 53       	subi	r26, 0x31	; 49
   11cbe:	ba 4f       	sbci	r27, 0xFA	; 250
   11cc0:	8c 91       	ld	r24, X
   11cc2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11cc4:	2f 5f       	subi	r18, 0xFF	; 255
   11cc6:	3f 4f       	sbci	r19, 0xFF	; 255
   11cc8:	24 31       	cpi	r18, 0x14	; 20
   11cca:	31 05       	cpc	r19, r1
   11ccc:	99 f7       	brne	.-26     	; 0x11cb4 <FMenuSettingHeader+0x152>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11cce:	10 92 fa 09 	sts	0x09FA, r1
   11cd2:	e3 ee       	ldi	r30, 0xE3	; 227
   11cd4:	f5 e0       	ldi	r31, 0x05	; 5
   11cd6:	ab ef       	ldi	r26, 0xFB	; 251
   11cd8:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11cda:	81 91       	ld	r24, Z+
   11cdc:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11cde:	85 e0       	ldi	r24, 0x05	; 5
   11ce0:	e7 3f       	cpi	r30, 0xF7	; 247
   11ce2:	f8 07       	cpc	r31, r24
   11ce4:	d1 f7       	brne	.-12     	; 0x11cda <FMenuSettingHeader+0x178>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11ce6:	10 92 0f 0a 	sts	0x0A0F, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,AdvanZ.Message09.strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,AdvanZ.Message09.strFreeMessageLine2,20,20);

			  lcd_print(1,1,AdvanZ.Message09.strFreeMessageLine1);			  
   11cea:	81 e0       	ldi	r24, 0x01	; 1
   11cec:	61 e0       	ldi	r22, 0x01	; 1
   11cee:	46 ee       	ldi	r20, 0xE6	; 230
   11cf0:	59 e0       	ldi	r21, 0x09	; 9
   11cf2:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			  lcd_print(2,1,AdvanZ.Message09.strFreeMessageLine2);			  
   11cf6:	82 e0       	ldi	r24, 0x02	; 2
   11cf8:	61 e0       	ldi	r22, 0x01	; 1
   11cfa:	4b ef       	ldi	r20, 0xFB	; 251
   11cfc:	59 e0       	ldi	r21, 0x09	; 9
   11cfe:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
   11d02:	83 e0       	ldi	r24, 0x03	; 3
   11d04:	61 e0       	ldi	r22, 0x01	; 1
   11d06:	4b e4       	ldi	r20, 0x4B	; 75
   11d08:	54 e1       	ldi	r21, 0x14	; 20
   11d0a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
   11d0e:	84 e0       	ldi	r24, 0x04	; 4
   11d10:	61 e0       	ldi	r22, 0x01	; 1
   11d12:	4d e3       	ldi	r20, 0x3D	; 61
   11d14:	54 e1       	ldi	r21, 0x14	; 20
   11d16:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
   11d1a:	85 e0       	ldi	r24, 0x05	; 5
   11d1c:	7e c0       	rjmp	.+252    	; 0x11e1a <FMenuSettingHeader+0x2b8>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   11d1e:	81 30       	cpi	r24, 0x01	; 1
   11d20:	09 f0       	breq	.+2      	; 0x11d24 <FMenuSettingHeader+0x1c2>
   11d22:	be c0       	rjmp	.+380    	; 0x11ea0 <FMenuSettingHeader+0x33e>
   11d24:	b6 c0       	rjmp	.+364    	; 0x11e92 <FMenuSettingHeader+0x330>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
   11d26:	81 e0       	ldi	r24, 0x01	; 1
   11d28:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   11d2c:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   11d30:	80 93 1b 03 	sts	0x031B, r24
          if(KeyChar=='#'){
   11d34:	83 32       	cpi	r24, 0x23	; 35
   11d36:	39 f4       	brne	.+14     	; 0x11d46 <FMenuSettingHeader+0x1e4>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
   11d38:	8f ec       	ldi	r24, 0xCF	; 207
   11d3a:	95 e0       	ldi	r25, 0x05	; 5
   11d3c:	68 e2       	ldi	r22, 0x28	; 40
   11d3e:	70 e0       	ldi	r23, 0x00	; 0
   11d40:	0e 94 46 30 	call	0x608c	; 0x608c <StrAlignCenter>
   11d44:	03 c0       	rjmp	.+6      	; 0x11d4c <FMenuSettingHeader+0x1ea>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
   11d46:	8a 32       	cpi	r24, 0x2A	; 42
   11d48:	09 f0       	breq	.+2      	; 0x11d4c <FMenuSettingHeader+0x1ea>
   11d4a:	aa c0       	rjmp	.+340    	; 0x11ea0 <FMenuSettingHeader+0x33e>
   11d4c:	86 e0       	ldi	r24, 0x06	; 6
   11d4e:	65 c0       	rjmp	.+202    	; 0x11e1a <FMenuSettingHeader+0x2b8>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
   11d50:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
   11d54:	20 e0       	ldi	r18, 0x00	; 0
   11d56:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11d58:	f9 01       	movw	r30, r18
   11d5a:	ea 51       	subi	r30, 0x1A	; 26
   11d5c:	f6 4f       	sbci	r31, 0xF6	; 246
   11d5e:	d9 01       	movw	r26, r18
   11d60:	a1 53       	subi	r26, 0x31	; 49
   11d62:	ba 4f       	sbci	r27, 0xFA	; 250
   11d64:	8c 91       	ld	r24, X
   11d66:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11d68:	2f 5f       	subi	r18, 0xFF	; 255
   11d6a:	3f 4f       	sbci	r19, 0xFF	; 255
   11d6c:	24 31       	cpi	r18, 0x14	; 20
   11d6e:	31 05       	cpc	r19, r1
   11d70:	99 f7       	brne	.-26     	; 0x11d58 <FMenuSettingHeader+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11d72:	10 92 fa 09 	sts	0x09FA, r1
   11d76:	e3 ee       	ldi	r30, 0xE3	; 227
   11d78:	f5 e0       	ldi	r31, 0x05	; 5
   11d7a:	ab ef       	ldi	r26, 0xFB	; 251
   11d7c:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11d7e:	81 91       	ld	r24, Z+
   11d80:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11d82:	95 e0       	ldi	r25, 0x05	; 5
   11d84:	e7 3f       	cpi	r30, 0xF7	; 247
   11d86:	f9 07       	cpc	r31, r25
   11d88:	d1 f7       	brne	.-12     	; 0x11d7e <FMenuSettingHeader+0x21c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11d8a:	10 92 0f 0a 	sts	0x0A0F, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,AdvanZ.Message09.strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,AdvanZ.Message09.strFreeMessageLine2,20,20);
          lcd_print(1,1,AdvanZ.Message09.strFreeMessageLine1);
   11d8e:	81 e0       	ldi	r24, 0x01	; 1
   11d90:	61 e0       	ldi	r22, 0x01	; 1
   11d92:	46 ee       	ldi	r20, 0xE6	; 230
   11d94:	59 e0       	ldi	r21, 0x09	; 9
   11d96:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_print(2,1,AdvanZ.Message09.strFreeMessageLine2);
   11d9a:	82 e0       	ldi	r24, 0x02	; 2
   11d9c:	61 e0       	ldi	r22, 0x01	; 1
   11d9e:	4b ef       	ldi	r20, 0xFB	; 251
   11da0:	59 e0       	ldi	r21, 0x09	; 9
   11da2:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Header%d ?"),HeaderIdx+1);
   11da6:	00 d0       	rcall	.+0      	; 0x11da8 <FMenuSettingHeader+0x246>
   11da8:	00 d0       	rcall	.+0      	; 0x11daa <FMenuSettingHeader+0x248>
   11daa:	00 d0       	rcall	.+0      	; 0x11dac <FMenuSettingHeader+0x24a>
   11dac:	ed b7       	in	r30, 0x3d	; 61
   11dae:	fe b7       	in	r31, 0x3e	; 62
   11db0:	31 96       	adiw	r30, 0x01	; 1
   11db2:	8e 01       	movw	r16, r28
   11db4:	0f 5f       	subi	r16, 0xFF	; 255
   11db6:	1f 4f       	sbci	r17, 0xFF	; 255
   11db8:	ad b7       	in	r26, 0x3d	; 61
   11dba:	be b7       	in	r27, 0x3e	; 62
   11dbc:	12 96       	adiw	r26, 0x02	; 2
   11dbe:	1c 93       	st	X, r17
   11dc0:	0e 93       	st	-X, r16
   11dc2:	11 97       	sbiw	r26, 0x01	; 1
   11dc4:	8d e2       	ldi	r24, 0x2D	; 45
   11dc6:	94 e1       	ldi	r25, 0x14	; 20
   11dc8:	93 83       	std	Z+3, r25	; 0x03
   11dca:	82 83       	std	Z+2, r24	; 0x02
   11dcc:	80 91 1c 03 	lds	r24, 0x031C
   11dd0:	90 e0       	ldi	r25, 0x00	; 0
   11dd2:	01 96       	adiw	r24, 0x01	; 1
   11dd4:	95 83       	std	Z+5, r25	; 0x05
   11dd6:	84 83       	std	Z+4, r24	; 0x04
   11dd8:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   11ddc:	8d b7       	in	r24, 0x3d	; 61
   11dde:	9e b7       	in	r25, 0x3e	; 62
   11de0:	06 96       	adiw	r24, 0x06	; 6
   11de2:	0f b6       	in	r0, 0x3f	; 63
   11de4:	f8 94       	cli
   11de6:	9e bf       	out	0x3e, r25	; 62
   11de8:	0f be       	out	0x3f, r0	; 63
   11dea:	8d bf       	out	0x3d, r24	; 61
   11dec:	83 e0       	ldi	r24, 0x03	; 3
   11dee:	61 e0       	ldi	r22, 0x01	; 1
   11df0:	a8 01       	movw	r20, r16
   11df2:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
   11df6:	84 e0       	ldi	r24, 0x04	; 4
   11df8:	61 e0       	ldi	r22, 0x01	; 1
   11dfa:	40 e2       	ldi	r20, 0x20	; 32
   11dfc:	54 e1       	ldi	r21, 0x14	; 20
   11dfe:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
   11e02:	84 e0       	ldi	r24, 0x04	; 4
   11e04:	0a c0       	rjmp	.+20     	; 0x11e1a <FMenuSettingHeader+0x2b8>
	      break;    
     case shSaveHeaderQuestions:
	      KeyChar=_key_btn(_key_scan(1));
   11e06:	81 e0       	ldi	r24, 0x01	; 1
   11e08:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   11e0c:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   11e10:	80 93 1b 03 	sts	0x031B, r24
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   11e14:	83 32       	cpi	r24, 0x23	; 35
   11e16:	21 f4       	brne	.+8      	; 0x11e20 <FMenuSettingHeader+0x2be>
   11e18:	87 e0       	ldi	r24, 0x07	; 7
   11e1a:	80 93 1d 03 	sts	0x031D, r24
   11e1e:	40 c0       	rjmp	.+128    	; 0x11ea0 <FMenuSettingHeader+0x33e>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   11e20:	8a 32       	cpi	r24, 0x2A	; 42
   11e22:	f1 f5       	brne	.+124    	; 0x11ea0 <FMenuSettingHeader+0x33e>
   11e24:	36 c0       	rjmp	.+108    	; 0x11e92 <FMenuSettingHeader+0x330>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),AdvanZ.Message09.strFreeMessageLine1,AdvanZ.Message09.strFreeMessageLine2);
   11e26:	ad b7       	in	r26, 0x3d	; 61
   11e28:	be b7       	in	r27, 0x3e	; 62
   11e2a:	18 97       	sbiw	r26, 0x08	; 8
   11e2c:	0f b6       	in	r0, 0x3f	; 63
   11e2e:	f8 94       	cli
   11e30:	be bf       	out	0x3e, r27	; 62
   11e32:	0f be       	out	0x3f, r0	; 63
   11e34:	ad bf       	out	0x3d, r26	; 61
   11e36:	ed b7       	in	r30, 0x3d	; 61
   11e38:	fe b7       	in	r31, 0x3e	; 62
   11e3a:	31 96       	adiw	r30, 0x01	; 1
   11e3c:	8e 01       	movw	r16, r28
   11e3e:	0b 5e       	subi	r16, 0xEB	; 235
   11e40:	1f 4f       	sbci	r17, 0xFF	; 255
   11e42:	12 96       	adiw	r26, 0x02	; 2
   11e44:	1c 93       	st	X, r17
   11e46:	0e 93       	st	-X, r16
   11e48:	11 97       	sbiw	r26, 0x01	; 1
   11e4a:	8b e1       	ldi	r24, 0x1B	; 27
   11e4c:	94 e1       	ldi	r25, 0x14	; 20
   11e4e:	93 83       	std	Z+3, r25	; 0x03
   11e50:	82 83       	std	Z+2, r24	; 0x02
   11e52:	86 ee       	ldi	r24, 0xE6	; 230
   11e54:	99 e0       	ldi	r25, 0x09	; 9
   11e56:	95 83       	std	Z+5, r25	; 0x05
   11e58:	84 83       	std	Z+4, r24	; 0x04
   11e5a:	45 96       	adiw	r24, 0x15	; 21
   11e5c:	97 83       	std	Z+7, r25	; 0x07
   11e5e:	86 83       	std	Z+6, r24	; 0x06
   11e60:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   11e64:	8d b7       	in	r24, 0x3d	; 61
   11e66:	9e b7       	in	r25, 0x3e	; 62
   11e68:	08 96       	adiw	r24, 0x08	; 8
   11e6a:	0f b6       	in	r0, 0x3f	; 63
   11e6c:	f8 94       	cli
   11e6e:	9e bf       	out	0x3e, r25	; 62
   11e70:	0f be       	out	0x3f, r0	; 63
   11e72:	8d bf       	out	0x3d, r24	; 61
   11e74:	80 91 1c 03 	lds	r24, 0x031C
   11e78:	29 e2       	ldi	r18, 0x29	; 41
   11e7a:	82 9f       	mul	r24, r18
   11e7c:	c0 01       	movw	r24, r0
   11e7e:	11 24       	eor	r1, r1
   11e80:	89 5d       	subi	r24, 0xD9	; 217
   11e82:	9d 4f       	sbci	r25, 0xFD	; 253
   11e84:	b8 01       	movw	r22, r16
   11e86:	48 e2       	ldi	r20, 0x28	; 40
   11e88:	50 e0       	ldi	r21, 0x00	; 0
   11e8a:	20 e0       	ldi	r18, 0x00	; 0
   11e8c:	33 e1       	ldi	r19, 0x13	; 19
   11e8e:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx],40);
          stSettingHeader=shInitHeader;
   11e92:	10 92 1d 03 	sts	0x031D, r1
   11e96:	04 c0       	rjmp	.+8      	; 0x11ea0 <FMenuSettingHeader+0x33e>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   11e98:	10 92 1d 03 	sts	0x031D, r1
   11e9c:	81 e0       	ldi	r24, 0x01	; 1
   11e9e:	01 c0       	rjmp	.+2      	; 0x11ea2 <FMenuSettingHeader+0x340>
   11ea0:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   //_menu_header();   
   return Result;
}
   11ea2:	ca 5b       	subi	r28, 0xBA	; 186
   11ea4:	df 4f       	sbci	r29, 0xFF	; 255
   11ea6:	0f b6       	in	r0, 0x3f	; 63
   11ea8:	f8 94       	cli
   11eaa:	de bf       	out	0x3e, r29	; 62
   11eac:	0f be       	out	0x3f, r0	; 63
   11eae:	cd bf       	out	0x3d, r28	; 61
   11eb0:	cf 91       	pop	r28
   11eb2:	df 91       	pop	r29
   11eb4:	1f 91       	pop	r17
   11eb6:	0f 91       	pop	r16
   11eb8:	ef 90       	pop	r14
   11eba:	08 95       	ret

00011ebc <FMenuAdminSettings>:

char FMenuAdminSettings(){
     static char stAdminSettings=asInitMenu;
	 char SubMenu,Result,KeyChar;
	 Result=MENU_NONE;
	 switch(stAdminSettings){
   11ebc:	80 91 1e 03 	lds	r24, 0x031E
   11ec0:	83 30       	cpi	r24, 0x03	; 3
   11ec2:	09 f4       	brne	.+2      	; 0x11ec6 <FMenuAdminSettings+0xa>
   11ec4:	6e c0       	rjmp	.+220    	; 0x11fa2 <FMenuAdminSettings+0xe6>
   11ec6:	84 30       	cpi	r24, 0x04	; 4
   11ec8:	30 f4       	brcc	.+12     	; 0x11ed6 <FMenuAdminSettings+0x1a>
   11eca:	81 30       	cpi	r24, 0x01	; 1
   11ecc:	e9 f1       	breq	.+122    	; 0x11f48 <FMenuAdminSettings+0x8c>
   11ece:	82 30       	cpi	r24, 0x02	; 2
   11ed0:	08 f0       	brcs	.+2      	; 0x11ed4 <FMenuAdminSettings+0x18>
   11ed2:	64 c0       	rjmp	.+200    	; 0x11f9c <FMenuAdminSettings+0xe0>
   11ed4:	0d c0       	rjmp	.+26     	; 0x11ef0 <FMenuAdminSettings+0x34>
   11ed6:	85 30       	cpi	r24, 0x05	; 5
   11ed8:	09 f4       	brne	.+2      	; 0x11edc <FMenuAdminSettings+0x20>
   11eda:	66 c0       	rjmp	.+204    	; 0x11fa8 <FMenuAdminSettings+0xec>
   11edc:	85 30       	cpi	r24, 0x05	; 5
   11ede:	08 f4       	brcc	.+2      	; 0x11ee2 <FMenuAdminSettings+0x26>
   11ee0:	6a c0       	rjmp	.+212    	; 0x11fb6 <FMenuAdminSettings+0xfa>
   11ee2:	86 30       	cpi	r24, 0x06	; 6
   11ee4:	09 f4       	brne	.+2      	; 0x11ee8 <FMenuAdminSettings+0x2c>
   11ee6:	63 c0       	rjmp	.+198    	; 0x11fae <FMenuAdminSettings+0xf2>
   11ee8:	87 30       	cpi	r24, 0x07	; 7
   11eea:	09 f0       	breq	.+2      	; 0x11eee <FMenuAdminSettings+0x32>
   11eec:	6c c0       	rjmp	.+216    	; 0x11fc6 <FMenuAdminSettings+0x10a>
   11eee:	67 c0       	rjmp	.+206    	; 0x11fbe <FMenuAdminSettings+0x102>
	 case asInitMenu:
          lcd_clear();
   11ef0:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  if (IFType==IT_SLAVE){
   11ef4:	80 91 10 01 	lds	r24, 0x0110
   11ef8:	81 30       	cpi	r24, 0x01	; 1
   11efa:	51 f4       	brne	.+20     	; 0x11f10 <FMenuAdminSettings+0x54>
		      lcd_printf(1,1, PSTR("1)Header    4)Client"));
   11efc:	61 e0       	ldi	r22, 0x01	; 1
   11efe:	46 e2       	ldi	r20, 0x26	; 38
   11f00:	55 e1       	ldi	r21, 0x15	; 21
   11f02:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer    5)Server"));
   11f06:	82 e0       	ldi	r24, 0x02	; 2
   11f08:	61 e0       	ldi	r22, 0x01	; 1
   11f0a:	41 e1       	ldi	r20, 0x11	; 17
   11f0c:	55 e1       	ldi	r21, 0x15	; 21
   11f0e:	0c c0       	rjmp	.+24     	; 0x11f28 <FMenuAdminSettings+0x6c>
		  }else
		  if (IFType==IT_STANDALONE){
   11f10:	82 30       	cpi	r24, 0x02	; 2
   11f12:	61 f4       	brne	.+24     	; 0x11f2c <FMenuAdminSettings+0x70>
		      lcd_printf(1,1, PSTR("1)Header            "));
   11f14:	81 e0       	ldi	r24, 0x01	; 1
   11f16:	61 e0       	ldi	r22, 0x01	; 1
   11f18:	4c ef       	ldi	r20, 0xFC	; 252
   11f1a:	54 e1       	ldi	r21, 0x14	; 20
   11f1c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer            "));
   11f20:	82 e0       	ldi	r24, 0x02	; 2
   11f22:	61 e0       	ldi	r22, 0x01	; 1
   11f24:	47 ee       	ldi	r20, 0xE7	; 231
   11f26:	54 e1       	ldi	r21, 0x14	; 20
   11f28:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  }
		  lcd_printf(3,1, PSTR("3)Password          "));
   11f2c:	83 e0       	ldi	r24, 0x03	; 3
   11f2e:	61 e0       	ldi	r22, 0x01	; 1
   11f30:	42 ed       	ldi	r20, 0xD2	; 210
   11f32:	54 e1       	ldi	r21, 0x14	; 20
   11f34:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4,1, PSTR("*)Exit"));
   11f38:	84 e0       	ldi	r24, 0x04	; 4
   11f3a:	61 e0       	ldi	r22, 0x01	; 1
   11f3c:	4b ec       	ldi	r20, 0xCB	; 203
   11f3e:	54 e1       	ldi	r21, 0x14	; 20
   11f40:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  stAdminSettings=asAdminSettingsOption;
   11f44:	81 e0       	ldi	r24, 0x01	; 1
   11f46:	27 c0       	rjmp	.+78     	; 0x11f96 <FMenuAdminSettings+0xda>
		  break;
     case asAdminSettingsOption:
	      KeyChar=_key_btn(_key_scan(1));
   11f48:	81 e0       	ldi	r24, 0x01	; 1
   11f4a:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   11f4e:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   11f52:	98 2f       	mov	r25, r24
		  switch(KeyChar){
   11f54:	82 33       	cpi	r24, 0x32	; 50
   11f56:	61 f0       	breq	.+24     	; 0x11f70 <FMenuAdminSettings+0xb4>
   11f58:	83 33       	cpi	r24, 0x33	; 51
   11f5a:	28 f4       	brcc	.+10     	; 0x11f66 <FMenuAdminSettings+0xaa>
   11f5c:	8a 32       	cpi	r24, 0x2A	; 42
   11f5e:	61 f0       	breq	.+24     	; 0x11f78 <FMenuAdminSettings+0xbc>
   11f60:	81 33       	cpi	r24, 0x31	; 49
   11f62:	69 f4       	brne	.+26     	; 0x11f7e <FMenuAdminSettings+0xc2>
   11f64:	03 c0       	rjmp	.+6      	; 0x11f6c <FMenuAdminSettings+0xb0>
   11f66:	83 33       	cpi	r24, 0x33	; 51
   11f68:	51 f4       	brne	.+20     	; 0x11f7e <FMenuAdminSettings+0xc2>
   11f6a:	04 c0       	rjmp	.+8      	; 0x11f74 <FMenuAdminSettings+0xb8>
		  case '1':stAdminSettings=asAdminSettingHeader;
   11f6c:	82 e0       	ldi	r24, 0x02	; 2
   11f6e:	05 c0       	rjmp	.+10     	; 0x11f7a <FMenuAdminSettings+0xbe>
		       break;
		  case '2':stAdminSettings=asAdminSettingFooter;
   11f70:	83 e0       	ldi	r24, 0x03	; 3
   11f72:	03 c0       	rjmp	.+6      	; 0x11f7a <FMenuAdminSettings+0xbe>
		       break;
		  case '3':stAdminSettings=asAdminSettingPassword;
   11f74:	84 e0       	ldi	r24, 0x04	; 4
   11f76:	01 c0       	rjmp	.+2      	; 0x11f7a <FMenuAdminSettings+0xbe>
		       break;
		  case '*':stAdminSettings=asExitAdminSetting;
   11f78:	87 e0       	ldi	r24, 0x07	; 7
   11f7a:	80 93 1e 03 	sts	0x031E, r24
		       break;			   
		  }
		  if (IFType==IT_SLAVE){
   11f7e:	80 91 10 01 	lds	r24, 0x0110
   11f82:	81 30       	cpi	r24, 0x01	; 1
   11f84:	01 f5       	brne	.+64     	; 0x11fc6 <FMenuAdminSettings+0x10a>
			  switch(KeyChar){
   11f86:	94 33       	cpi	r25, 0x34	; 52
   11f88:	19 f0       	breq	.+6      	; 0x11f90 <FMenuAdminSettings+0xd4>
   11f8a:	95 33       	cpi	r25, 0x35	; 53
   11f8c:	e1 f4       	brne	.+56     	; 0x11fc6 <FMenuAdminSettings+0x10a>
   11f8e:	02 c0       	rjmp	.+4      	; 0x11f94 <FMenuAdminSettings+0xd8>
			  case '4':stAdminSettings=asAdminSettingClientIP;
   11f90:	85 e0       	ldi	r24, 0x05	; 5
   11f92:	01 c0       	rjmp	.+2      	; 0x11f96 <FMenuAdminSettings+0xda>
				   break;
			  case '5':stAdminSettings=asAdminSettingServerIP;
   11f94:	86 e0       	ldi	r24, 0x06	; 6
   11f96:	80 93 1e 03 	sts	0x031E, r24
   11f9a:	0f c0       	rjmp	.+30     	; 0x11fba <FMenuAdminSettings+0xfe>
				   break;
			  }
		  }
	      break;
	 case asAdminSettingHeader:
	      SubMenu=FMenuSettingHeader();
   11f9c:	0e 94 b1 8d 	call	0x11b62	; 0x11b62 <FMenuSettingHeader>
   11fa0:	08 c0       	rjmp	.+16     	; 0x11fb2 <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;
	      break;
	 case asAdminSettingFooter:
	      SubMenu=FMenuSettingFooter();
   11fa2:	0e 94 04 8c 	call	0x11808	; 0x11808 <FMenuSettingFooter>
   11fa6:	05 c0       	rjmp	.+10     	; 0x11fb2 <FMenuAdminSettings+0xf6>
	 case asAdminSettingPassword:
	      SubMenu=FMenuSettingPassword();
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
     case asAdminSettingClientIP:
	      SubMenu=FMenuSettingClientIP();
   11fa8:	0e 94 be 6c 	call	0xd97c	; 0xd97c <FMenuSettingClientIP>
   11fac:	02 c0       	rjmp	.+4      	; 0x11fb2 <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
	 case asAdminSettingServerIP:
	      SubMenu=FMenuSettingServerIP();
   11fae:	0e 94 34 6a 	call	0xd468	; 0xd468 <FMenuSettingServerIP>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
   11fb2:	81 30       	cpi	r24, 0x01	; 1
   11fb4:	41 f4       	brne	.+16     	; 0x11fc6 <FMenuAdminSettings+0x10a>
   11fb6:	10 92 1e 03 	sts	0x031E, r1
   11fba:	80 e0       	ldi	r24, 0x00	; 0
   11fbc:	08 95       	ret
	      break;
     case asExitAdminSetting:
	      stAdminSettings=asInitMenu;
   11fbe:	10 92 1e 03 	sts	0x031E, r1
   11fc2:	81 e0       	ldi	r24, 0x01	; 1
   11fc4:	08 95       	ret
   11fc6:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   11fc8:	08 95       	ret

00011fca <FMenuMaster>:
     else Result=RC_INVALID;

   return Result;
}

char FMenuMaster(){ 
   11fca:	ef 92       	push	r14
   11fcc:	ff 92       	push	r15
   11fce:	0f 93       	push	r16
   11fd0:	1f 93       	push	r17
   11fd2:	df 93       	push	r29
   11fd4:	cf 93       	push	r28
   11fd6:	cd b7       	in	r28, 0x3d	; 61
   11fd8:	de b7       	in	r29, 0x3e	; 62
   11fda:	e2 97       	sbiw	r28, 0x32	; 50
   11fdc:	0f b6       	in	r0, 0x3f	; 63
   11fde:	f8 94       	cli
   11fe0:	de bf       	out	0x3e, r29	; 62
   11fe2:	0f be       	out	0x3f, r0	; 63
   11fe4:	cd bf       	out	0x3d, r28	; 61
static char stMenuMaster=mmInitMaster;
     char KeyPressed,KeyChar,Result=MENU_NONE;
	 char uiResult,lcdteks[20],PTime[10],PDate[10],strNewPassword[10];
	 char strSend[20];

	 switch(stMenuMaster){
   11fe6:	80 91 23 03 	lds	r24, 0x0323
   11fea:	e8 2f       	mov	r30, r24
   11fec:	f0 e0       	ldi	r31, 0x00	; 0
   11fee:	e1 31       	cpi	r30, 0x11	; 17
   11ff0:	f1 05       	cpc	r31, r1
   11ff2:	08 f0       	brcs	.+2      	; 0x11ff6 <FMenuMaster+0x2c>
   11ff4:	f3 c1       	rjmp	.+998    	; 0x123dc <FMenuMaster+0x412>
   11ff6:	ed 54       	subi	r30, 0x4D	; 77
   11ff8:	ff 4f       	sbci	r31, 0xFF	; 255
   11ffa:	ee 0f       	add	r30, r30
   11ffc:	ff 1f       	adc	r31, r31
   11ffe:	05 90       	lpm	r0, Z+
   12000:	f4 91       	lpm	r31, Z+
   12002:	e0 2d       	mov	r30, r0
   12004:	09 94       	ijmp
	 case mmInitMaster:
	      lcd_clear();
   12006:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("-System Admin Level-"));
   1200a:	81 e0       	ldi	r24, 0x01	; 1
   1200c:	61 e0       	ldi	r22, 0x01	; 1
   1200e:	4c e9       	ldi	r20, 0x9C	; 156
   12010:	57 e1       	ldi	r21, 0x17	; 23
   12012:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Restore Password  "));
   12016:	82 e0       	ldi	r24, 0x02	; 2
   12018:	61 e0       	ldi	r22, 0x01	; 1
   1201a:	47 e8       	ldi	r20, 0x87	; 135
   1201c:	57 e1       	ldi	r21, 0x17	; 23
   1201e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Change Password   "));
   12022:	83 e0       	ldi	r24, 0x03	; 3
   12024:	61 e0       	ldi	r22, 0x01	; 1
   12026:	42 e7       	ldi	r20, 0x72	; 114
   12028:	57 e1       	ldi	r21, 0x17	; 23
   1202a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Exit             "));
   1202e:	84 e0       	ldi	r24, 0x04	; 4
   12030:	61 e0       	ldi	r22, 0x01	; 1
   12032:	4d e5       	ldi	r20, 0x5D	; 93
   12034:	57 e1       	ldi	r21, 0x17	; 23
   12036:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>

		  //_uart_printf(1,1,PSTR("-System Admin Level-"));

		  stMenuMaster=mmMasterSelect;
   1203a:	81 e0       	ldi	r24, 0x01	; 1
   1203c:	f6 c0       	rjmp	.+492    	; 0x1222a <FMenuMaster+0x260>
	      break;
     case mmMasterSelect:
	 	  KeyPressed=_key_scan(1);
   1203e:	81 e0       	ldi	r24, 0x01	; 1
   12040:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   12044:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
          switch(KeyChar){
   12048:	81 33       	cpi	r24, 0x31	; 49
   1204a:	09 f4       	brne	.+2      	; 0x1204e <FMenuMaster+0x84>
   1204c:	ed c0       	rjmp	.+474    	; 0x12228 <FMenuMaster+0x25e>
   1204e:	82 33       	cpi	r24, 0x32	; 50
   12050:	21 f0       	breq	.+8      	; 0x1205a <FMenuMaster+0x90>
   12052:	8a 32       	cpi	r24, 0x2A	; 42
   12054:	09 f0       	breq	.+2      	; 0x12058 <FMenuMaster+0x8e>
   12056:	c2 c1       	rjmp	.+900    	; 0x123dc <FMenuMaster+0x412>
   12058:	bb c1       	rjmp	.+886    	; 0x123d0 <FMenuMaster+0x406>
		  case '1':
               stMenuMaster=mmRestorePasswordMenu;
		       break;
		  case '2':
		       stMenuMaster=mmChangePassword;
   1205a:	8e e0       	ldi	r24, 0x0E	; 14
   1205c:	e6 c0       	rjmp	.+460    	; 0x1222a <FMenuMaster+0x260>
		       stMenuMaster=mmExitMaster;
		       break;
		  }
	      break;
     case mmChangePassword:
	      stMenuMaster=mmInitMaster;
   1205e:	10 92 23 03 	sts	0x0323, r1
   12062:	bc c1       	rjmp	.+888    	; 0x123dc <FMenuMaster+0x412>
	      break;
     case mmRestorePasswordMenu:	      
	      lcd_clear();
   12064:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("Enter GeNiUs Code   "));
   12068:	81 e0       	ldi	r24, 0x01	; 1
   1206a:	61 e0       	ldi	r22, 0x01	; 1
   1206c:	48 e4       	ldi	r20, 0x48	; 72
   1206e:	57 e1       	ldi	r21, 0x17	; 23
   12070:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2,1,PSTR("_                   "));
   12074:	82 e0       	ldi	r24, 0x02	; 2
   12076:	61 e0       	ldi	r22, 0x01	; 1
   12078:	43 e3       	ldi	r20, 0x33	; 51
   1207a:	57 e1       	ldi	r21, 0x17	; 23
   1207c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4,4,PSTR("[*]Cancel   [#]Enter"));
   12080:	84 e0       	ldi	r24, 0x04	; 4
   12082:	64 e0       	ldi	r22, 0x04	; 4
   12084:	4e e1       	ldi	r20, 0x1E	; 30
   12086:	57 e1       	ldi	r21, 0x17	; 23
   12088:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  sprintf_P(strGeniusCode,PSTR(""));
   1208c:	00 d0       	rcall	.+0      	; 0x1208e <FMenuMaster+0xc4>
   1208e:	00 d0       	rcall	.+0      	; 0x12090 <FMenuMaster+0xc6>
   12090:	85 e7       	ldi	r24, 0x75	; 117
   12092:	97 e0       	ldi	r25, 0x07	; 7
   12094:	ad b7       	in	r26, 0x3d	; 61
   12096:	be b7       	in	r27, 0x3e	; 62
   12098:	12 96       	adiw	r26, 0x02	; 2
   1209a:	9c 93       	st	X, r25
   1209c:	8e 93       	st	-X, r24
   1209e:	11 97       	sbiw	r26, 0x01	; 1
   120a0:	8d e1       	ldi	r24, 0x1D	; 29
   120a2:	97 e1       	ldi	r25, 0x17	; 23
   120a4:	14 96       	adiw	r26, 0x04	; 4
   120a6:	9c 93       	st	X, r25
   120a8:	8e 93       	st	-X, r24
   120aa:	13 97       	sbiw	r26, 0x03	; 3
   120ac:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
          stMenuMaster=mmGeniusCodeEntry;
   120b0:	83 e0       	ldi	r24, 0x03	; 3
   120b2:	80 93 23 03 	sts	0x0323, r24
   120b6:	80 e0       	ldi	r24, 0x00	; 0
   120b8:	0f 90       	pop	r0
   120ba:	0f 90       	pop	r0
   120bc:	0f 90       	pop	r0
   120be:	0f 90       	pop	r0
   120c0:	8e c1       	rjmp	.+796    	; 0x123de <FMenuMaster+0x414>
	      break;
     case mmGeniusCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,2,1,strGeniusCode,0,10);
   120c2:	81 e0       	ldi	r24, 0x01	; 1
   120c4:	62 e0       	ldi	r22, 0x02	; 2
   120c6:	41 e0       	ldi	r20, 0x01	; 1
   120c8:	25 e7       	ldi	r18, 0x75	; 117
   120ca:	37 e0       	ldi	r19, 0x07	; 7
   120cc:	00 e0       	ldi	r16, 0x00	; 0
   120ce:	10 e0       	ldi	r17, 0x00	; 0
   120d0:	fa e0       	ldi	r31, 0x0A	; 10
   120d2:	ef 2e       	mov	r14, r31
   120d4:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
		  switch(uiResult){
   120d8:	83 30       	cpi	r24, 0x03	; 3
   120da:	49 f0       	breq	.+18     	; 0x120ee <FMenuMaster+0x124>
   120dc:	84 30       	cpi	r24, 0x04	; 4
   120de:	08 f4       	brcc	.+2      	; 0x120e2 <FMenuMaster+0x118>
   120e0:	f2 c0       	rjmp	.+484    	; 0x122c6 <FMenuMaster+0x2fc>
   120e2:	84 30       	cpi	r24, 0x04	; 4
   120e4:	69 f0       	breq	.+26     	; 0x12100 <FMenuMaster+0x136>
   120e6:	85 30       	cpi	r24, 0x05	; 5
   120e8:	09 f0       	breq	.+2      	; 0x120ec <FMenuMaster+0x122>
   120ea:	78 c1       	rjmp	.+752    	; 0x123dc <FMenuMaster+0x412>
   120ec:	0e c0       	rjmp	.+28     	; 0x1210a <FMenuMaster+0x140>
		  case USER_OK:
               
			   //_uart_printf(1,0,PSTR("GeniusCode: "));
			   //_uart_print(1,1,strGeniusCode);

		       _datetime(0, strSystemDate, strSystemTime);
   120ee:	80 e0       	ldi	r24, 0x00	; 0
   120f0:	6a e9       	ldi	r22, 0x9A	; 154
   120f2:	75 e0       	ldi	r23, 0x05	; 5
   120f4:	4d e1       	ldi	r20, 0x1D	; 29
   120f6:	5c e0       	ldi	r21, 0x0C	; 12
   120f8:	0e 94 c9 b2 	call	0x16592	; 0x16592 <_datetime>
               stMenuMaster=mmIsValidGeniusCode;
   120fc:	84 e0       	ldi	r24, 0x04	; 4
   120fe:	95 c0       	rjmp	.+298    	; 0x1222a <FMenuMaster+0x260>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12100:	84 e0       	ldi	r24, 0x04	; 4
   12102:	61 e0       	ldi	r22, 0x01	; 1
   12104:	48 e0       	ldi	r20, 0x08	; 8
   12106:	57 e1       	ldi	r21, 0x17	; 23
   12108:	f3 c0       	rjmp	.+486    	; 0x122f0 <FMenuMaster+0x326>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1210a:	84 e0       	ldi	r24, 0x04	; 4
   1210c:	61 e0       	ldi	r22, 0x01	; 1
   1210e:	43 ef       	ldi	r20, 0xF3	; 243
   12110:	56 e1       	ldi	r21, 0x16	; 22
   12112:	ee c0       	rjmp	.+476    	; 0x122f0 <FMenuMaster+0x326>
		       break;
		  }
	      break;
     case mmIsValidGeniusCode:
	      //GetDate
		      sprintf_P(PDate,PSTR("%s"),strSystemDate);
   12114:	00 d0       	rcall	.+0      	; 0x12116 <FMenuMaster+0x14c>
   12116:	00 d0       	rcall	.+0      	; 0x12118 <FMenuMaster+0x14e>
   12118:	00 d0       	rcall	.+0      	; 0x1211a <FMenuMaster+0x150>
   1211a:	ed b7       	in	r30, 0x3d	; 61
   1211c:	fe b7       	in	r31, 0x3e	; 62
   1211e:	31 96       	adiw	r30, 0x01	; 1
   12120:	8e 01       	movw	r16, r28
   12122:	05 5f       	subi	r16, 0xF5	; 245
   12124:	1f 4f       	sbci	r17, 0xFF	; 255
   12126:	ad b7       	in	r26, 0x3d	; 61
   12128:	be b7       	in	r27, 0x3e	; 62
   1212a:	12 96       	adiw	r26, 0x02	; 2
   1212c:	1c 93       	st	X, r17
   1212e:	0e 93       	st	-X, r16
   12130:	11 97       	sbiw	r26, 0x01	; 1
   12132:	80 ef       	ldi	r24, 0xF0	; 240
   12134:	96 e1       	ldi	r25, 0x16	; 22
   12136:	93 83       	std	Z+3, r25	; 0x03
   12138:	82 83       	std	Z+2, r24	; 0x02
   1213a:	8a e9       	ldi	r24, 0x9A	; 154
   1213c:	95 e0       	ldi	r25, 0x05	; 5
   1213e:	95 83       	std	Z+5, r25	; 0x05
   12140:	84 83       	std	Z+4, r24	; 0x04
   12142:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			  RemoveChar(PDate,'/');
   12146:	ed b7       	in	r30, 0x3d	; 61
   12148:	fe b7       	in	r31, 0x3e	; 62
   1214a:	36 96       	adiw	r30, 0x06	; 6
   1214c:	0f b6       	in	r0, 0x3f	; 63
   1214e:	f8 94       	cli
   12150:	fe bf       	out	0x3e, r31	; 62
   12152:	0f be       	out	0x3f, r0	; 63
   12154:	ed bf       	out	0x3d, r30	; 61
   12156:	c8 01       	movw	r24, r16
   12158:	6f e2       	ldi	r22, 0x2F	; 47
   1215a:	0e 94 1e 31 	call	0x623c	; 0x623c <RemoveChar>
		  if (ValidateGeniusCode(PDate,strGeniusCode)==GC_VALID){
   1215e:	c8 01       	movw	r24, r16
   12160:	65 e7       	ldi	r22, 0x75	; 117
   12162:	77 e0       	ldi	r23, 0x07	; 7
   12164:	0e 94 fd 69 	call	0xd3fa	; 0xd3fa <ValidateGeniusCode>
   12168:	81 30       	cpi	r24, 0x01	; 1
   1216a:	09 f0       	breq	.+2      	; 0x1216e <FMenuMaster+0x1a4>
   1216c:	44 c0       	rjmp	.+136    	; 0x121f6 <FMenuMaster+0x22c>

		  	  sprintf_P(PTime,PSTR("%s"),strSystemTime);
   1216e:	00 d0       	rcall	.+0      	; 0x12170 <FMenuMaster+0x1a6>
   12170:	00 d0       	rcall	.+0      	; 0x12172 <FMenuMaster+0x1a8>
   12172:	00 d0       	rcall	.+0      	; 0x12174 <FMenuMaster+0x1aa>
   12174:	ed b7       	in	r30, 0x3d	; 61
   12176:	fe b7       	in	r31, 0x3e	; 62
   12178:	31 96       	adiw	r30, 0x01	; 1
   1217a:	8e 01       	movw	r16, r28
   1217c:	0f 5f       	subi	r16, 0xFF	; 255
   1217e:	1f 4f       	sbci	r17, 0xFF	; 255
   12180:	ad b7       	in	r26, 0x3d	; 61
   12182:	be b7       	in	r27, 0x3e	; 62
   12184:	12 96       	adiw	r26, 0x02	; 2
   12186:	1c 93       	st	X, r17
   12188:	0e 93       	st	-X, r16
   1218a:	11 97       	sbiw	r26, 0x01	; 1
   1218c:	8d ee       	ldi	r24, 0xED	; 237
   1218e:	96 e1       	ldi	r25, 0x16	; 22
   12190:	93 83       	std	Z+3, r25	; 0x03
   12192:	82 83       	std	Z+2, r24	; 0x02
   12194:	8d e1       	ldi	r24, 0x1D	; 29
   12196:	9c e0       	ldi	r25, 0x0C	; 12
   12198:	95 83       	std	Z+5, r25	; 0x05
   1219a:	84 83       	std	Z+4, r24	; 0x04
   1219c:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			  RemoveChar(PTime,':');sprintf_P(strKeyStamp,PSTR(""));
   121a0:	ed b7       	in	r30, 0x3d	; 61
   121a2:	fe b7       	in	r31, 0x3e	; 62
   121a4:	36 96       	adiw	r30, 0x06	; 6
   121a6:	0f b6       	in	r0, 0x3f	; 63
   121a8:	f8 94       	cli
   121aa:	fe bf       	out	0x3e, r31	; 62
   121ac:	0f be       	out	0x3f, r0	; 63
   121ae:	ed bf       	out	0x3d, r30	; 61
   121b0:	c8 01       	movw	r24, r16
   121b2:	6a e3       	ldi	r22, 0x3A	; 58
   121b4:	0e 94 1e 31 	call	0x623c	; 0x623c <RemoveChar>
   121b8:	00 d0       	rcall	.+0      	; 0x121ba <FMenuMaster+0x1f0>
   121ba:	00 d0       	rcall	.+0      	; 0x121bc <FMenuMaster+0x1f2>
   121bc:	ed e9       	ldi	r30, 0x9D	; 157
   121be:	ee 2e       	mov	r14, r30
   121c0:	e9 e0       	ldi	r30, 0x09	; 9
   121c2:	fe 2e       	mov	r15, r30
   121c4:	ad b7       	in	r26, 0x3d	; 61
   121c6:	be b7       	in	r27, 0x3e	; 62
   121c8:	12 96       	adiw	r26, 0x02	; 2
   121ca:	fc 92       	st	X, r15
   121cc:	ee 92       	st	-X, r14
   121ce:	11 97       	sbiw	r26, 0x01	; 1
   121d0:	8c ee       	ldi	r24, 0xEC	; 236
   121d2:	96 e1       	ldi	r25, 0x16	; 22
   121d4:	14 96       	adiw	r26, 0x04	; 4
   121d6:	9c 93       	st	X, r25
   121d8:	8e 93       	st	-X, r24
   121da:	13 97       	sbiw	r26, 0x03	; 3
   121dc:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>

              //sprintf_P(strSend,PSTR("Time:%s"),PTime);
			  // _uart_print(1,1,strSend);

		      GenerateKeyStamp(PTime,strGeniusCode,strKeyStamp);			  
   121e0:	0f 90       	pop	r0
   121e2:	0f 90       	pop	r0
   121e4:	0f 90       	pop	r0
   121e6:	0f 90       	pop	r0
   121e8:	c8 01       	movw	r24, r16
   121ea:	65 e7       	ldi	r22, 0x75	; 117
   121ec:	77 e0       	ldi	r23, 0x07	; 7
   121ee:	a7 01       	movw	r20, r14
   121f0:	0e 94 df 31 	call	0x63be	; 0x63be <GenerateKeyStamp>
   121f4:	d5 c0       	rjmp	.+426    	; 0x123a0 <FMenuMaster+0x3d6>
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
   121f6:	85 e0       	ldi	r24, 0x05	; 5
   121f8:	18 c0       	rjmp	.+48     	; 0x1222a <FMenuMaster+0x260>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   121fa:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   121fc:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   121fe:	81 e0       	ldi	r24, 0x01	; 1
   12200:	90 e0       	ldi	r25, 0x00	; 0
   12202:	90 93 d7 01 	sts	0x01D7, r25
   12206:	80 93 d6 01 	sts	0x01D6, r24
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
	      break;
     case mmDisplayInvalidCode:
	      system_beep(1);
          lcd_printf(3,1,PSTR("Invalid Code        "));
   1220a:	83 e0       	ldi	r24, 0x03	; 3
   1220c:	61 e0       	ldi	r22, 0x01	; 1
   1220e:	47 ed       	ldi	r20, 0xD7	; 215
   12210:	56 e1       	ldi	r21, 0x16	; 22
   12212:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          TimDisplay=0; 
   12216:	10 92 a7 01 	sts	0x01A7, r1
		  stMenuMaster=mmDelayDisplayInvalidCode;
   1221a:	86 e0       	ldi	r24, 0x06	; 6
   1221c:	06 c0       	rjmp	.+12     	; 0x1222a <FMenuMaster+0x260>
	      break;
     case mmDelayDisplayInvalidCode:
	      if (TimDisplay>5)stMenuMaster=mmRestorePasswordMenu;
   1221e:	80 91 a7 01 	lds	r24, 0x01A7
   12222:	86 30       	cpi	r24, 0x06	; 6
   12224:	08 f4       	brcc	.+2      	; 0x12228 <FMenuMaster+0x25e>
   12226:	da c0       	rjmp	.+436    	; 0x123dc <FMenuMaster+0x412>
   12228:	82 e0       	ldi	r24, 0x02	; 2
   1222a:	80 93 23 03 	sts	0x0323, r24
   1222e:	d6 c0       	rjmp	.+428    	; 0x123dc <FMenuMaster+0x412>
	      break;
     case mmDisplayKeyStamp:
	      lcd_clear();
   12230:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("Key Stamp:%s "),strKeyStamp);
   12234:	00 d0       	rcall	.+0      	; 0x12236 <FMenuMaster+0x26c>
   12236:	00 d0       	rcall	.+0      	; 0x12238 <FMenuMaster+0x26e>
   12238:	00 d0       	rcall	.+0      	; 0x1223a <FMenuMaster+0x270>
   1223a:	ed b7       	in	r30, 0x3d	; 61
   1223c:	fe b7       	in	r31, 0x3e	; 62
   1223e:	31 96       	adiw	r30, 0x01	; 1
   12240:	8e 01       	movw	r16, r28
   12242:	01 5e       	subi	r16, 0xE1	; 225
   12244:	1f 4f       	sbci	r17, 0xFF	; 255
   12246:	ad b7       	in	r26, 0x3d	; 61
   12248:	be b7       	in	r27, 0x3e	; 62
   1224a:	12 96       	adiw	r26, 0x02	; 2
   1224c:	1c 93       	st	X, r17
   1224e:	0e 93       	st	-X, r16
   12250:	11 97       	sbiw	r26, 0x01	; 1
   12252:	89 ec       	ldi	r24, 0xC9	; 201
   12254:	96 e1       	ldi	r25, 0x16	; 22
   12256:	93 83       	std	Z+3, r25	; 0x03
   12258:	82 83       	std	Z+2, r24	; 0x02
   1225a:	8d e9       	ldi	r24, 0x9D	; 157
   1225c:	99 e0       	ldi	r25, 0x09	; 9
   1225e:	95 83       	std	Z+5, r25	; 0x05
   12260:	84 83       	std	Z+4, r24	; 0x04
   12262:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   12266:	ed b7       	in	r30, 0x3d	; 61
   12268:	fe b7       	in	r31, 0x3e	; 62
   1226a:	36 96       	adiw	r30, 0x06	; 6
   1226c:	0f b6       	in	r0, 0x3f	; 63
   1226e:	f8 94       	cli
   12270:	fe bf       	out	0x3e, r31	; 62
   12272:	0f be       	out	0x3f, r0	; 63
   12274:	ed bf       	out	0x3d, r30	; 61
   12276:	81 e0       	ldi	r24, 0x01	; 1
   12278:	61 e0       	ldi	r22, 0x01	; 1
   1227a:	a8 01       	movw	r20, r16
   1227c:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_printf(2,1,PSTR("Enter Restore Code  "));
   12280:	82 e0       	ldi	r24, 0x02	; 2
   12282:	61 e0       	ldi	r22, 0x01	; 1
   12284:	44 eb       	ldi	r20, 0xB4	; 180
   12286:	56 e1       	ldi	r21, 0x16	; 22
   12288:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(3,1,PSTR("_                   "));
   1228c:	83 e0       	ldi	r24, 0x03	; 3
   1228e:	61 e0       	ldi	r22, 0x01	; 1
   12290:	4f e9       	ldi	r20, 0x9F	; 159
   12292:	56 e1       	ldi	r21, 0x16	; 22
   12294:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12298:	84 e0       	ldi	r24, 0x04	; 4
   1229a:	61 e0       	ldi	r22, 0x01	; 1
   1229c:	4a e8       	ldi	r20, 0x8A	; 138
   1229e:	56 e1       	ldi	r21, 0x16	; 22
   122a0:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          stMenuMaster=mmRestoreCodeEntry;
   122a4:	88 e0       	ldi	r24, 0x08	; 8
   122a6:	c1 cf       	rjmp	.-126    	; 0x1222a <FMenuMaster+0x260>
	      break;
     case mmRestoreCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,3,1,strRestoreCode,0,10);
   122a8:	81 e0       	ldi	r24, 0x01	; 1
   122aa:	63 e0       	ldi	r22, 0x03	; 3
   122ac:	41 e0       	ldi	r20, 0x01	; 1
   122ae:	2e ea       	ldi	r18, 0xAE	; 174
   122b0:	3f e0       	ldi	r19, 0x0F	; 15
   122b2:	00 e0       	ldi	r16, 0x00	; 0
   122b4:	10 e0       	ldi	r17, 0x00	; 0
   122b6:	7a e0       	ldi	r23, 0x0A	; 10
   122b8:	e7 2e       	mov	r14, r23
   122ba:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
		  switch(uiResult){
   122be:	83 30       	cpi	r24, 0x03	; 3
   122c0:	61 f0       	breq	.+24     	; 0x122da <FMenuMaster+0x310>
   122c2:	84 30       	cpi	r24, 0x04	; 4
   122c4:	20 f4       	brcc	.+8      	; 0x122ce <FMenuMaster+0x304>
   122c6:	81 30       	cpi	r24, 0x01	; 1
   122c8:	09 f0       	breq	.+2      	; 0x122cc <FMenuMaster+0x302>
   122ca:	88 c0       	rjmp	.+272    	; 0x123dc <FMenuMaster+0x412>
   122cc:	81 c0       	rjmp	.+258    	; 0x123d0 <FMenuMaster+0x406>
   122ce:	84 30       	cpi	r24, 0x04	; 4
   122d0:	31 f0       	breq	.+12     	; 0x122de <FMenuMaster+0x314>
   122d2:	85 30       	cpi	r24, 0x05	; 5
   122d4:	09 f0       	breq	.+2      	; 0x122d8 <FMenuMaster+0x30e>
   122d6:	82 c0       	rjmp	.+260    	; 0x123dc <FMenuMaster+0x412>
   122d8:	07 c0       	rjmp	.+14     	; 0x122e8 <FMenuMaster+0x31e>
		  case USER_OK:
               stMenuMaster=mmIsValidRestoreCode;
   122da:	89 e0       	ldi	r24, 0x09	; 9
   122dc:	a6 cf       	rjmp	.-180    	; 0x1222a <FMenuMaster+0x260>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   122de:	84 e0       	ldi	r24, 0x04	; 4
   122e0:	61 e0       	ldi	r22, 0x01	; 1
   122e2:	45 e7       	ldi	r20, 0x75	; 117
   122e4:	56 e1       	ldi	r21, 0x16	; 22
   122e6:	04 c0       	rjmp	.+8      	; 0x122f0 <FMenuMaster+0x326>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   122e8:	84 e0       	ldi	r24, 0x04	; 4
   122ea:	61 e0       	ldi	r22, 0x01	; 1
   122ec:	40 e6       	ldi	r20, 0x60	; 96
   122ee:	56 e1       	ldi	r21, 0x16	; 22
   122f0:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   122f4:	73 c0       	rjmp	.+230    	; 0x123dc <FMenuMaster+0x412>
		       break;
		  }
	      break;
     case mmIsValidRestoreCode:
	      if (ValidateRestoreCode(strKeyStamp,strRestoreCode)==RC_VALID){
   122f6:	8d e9       	ldi	r24, 0x9D	; 157
   122f8:	99 e0       	ldi	r25, 0x09	; 9
   122fa:	6e ea       	ldi	r22, 0xAE	; 174
   122fc:	7f e0       	ldi	r23, 0x0F	; 15
   122fe:	0e 94 db 69 	call	0xd3b6	; 0xd3b6 <ValidateRestoreCode>
   12302:	81 30       	cpi	r24, 0x01	; 1
   12304:	11 f4       	brne	.+4      	; 0x1230a <FMenuMaster+0x340>
		      stMenuMaster=mmRestorePassword;
   12306:	8c e0       	ldi	r24, 0x0C	; 12
   12308:	90 cf       	rjmp	.-224    	; 0x1222a <FMenuMaster+0x260>
		  }else stMenuMaster=mmDisplayInvalidRestoreCode;
   1230a:	8a e0       	ldi	r24, 0x0A	; 10
   1230c:	8e cf       	rjmp	.-228    	; 0x1222a <FMenuMaster+0x260>
	      break;
     case mmRestorePassword:
	      sprintf_P(strNewPassword,PSTR(SPV_DEFAULT_PASS));
   1230e:	00 d0       	rcall	.+0      	; 0x12310 <FMenuMaster+0x346>
   12310:	00 d0       	rcall	.+0      	; 0x12312 <FMenuMaster+0x348>
   12312:	8e 01       	movw	r16, r28
   12314:	0b 5e       	subi	r16, 0xEB	; 235
   12316:	1f 4f       	sbci	r17, 0xFF	; 255
   12318:	ad b7       	in	r26, 0x3d	; 61
   1231a:	be b7       	in	r27, 0x3e	; 62
   1231c:	12 96       	adiw	r26, 0x02	; 2
   1231e:	1c 93       	st	X, r17
   12320:	0e 93       	st	-X, r16
   12322:	11 97       	sbiw	r26, 0x01	; 1
   12324:	8a e5       	ldi	r24, 0x5A	; 90
   12326:	96 e1       	ldi	r25, 0x16	; 22
   12328:	14 96       	adiw	r26, 0x04	; 4
   1232a:	9c 93       	st	X, r25
   1232c:	8e 93       	st	-X, r24
   1232e:	13 97       	sbiw	r26, 0x03	; 3
   12330:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   12334:	0f 90       	pop	r0
   12336:	0f 90       	pop	r0
   12338:	0f 90       	pop	r0
   1233a:	0f 90       	pop	r0
   1233c:	81 e0       	ldi	r24, 0x01	; 1
   1233e:	90 e0       	ldi	r25, 0x00	; 0
   12340:	b8 01       	movw	r22, r16
   12342:	4a e0       	ldi	r20, 0x0A	; 10
   12344:	50 e0       	ldi	r21, 0x00	; 0
   12346:	20 e0       	ldi	r18, 0x00	; 0
   12348:	33 e1       	ldi	r19, 0x13	; 19
   1234a:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSpvPassword,sizeof(DefSpvPassword));
		  sprintf_P(strNewPassword,PSTR(SYS_DEFAULT_PASS));
   1234e:	00 d0       	rcall	.+0      	; 0x12350 <FMenuMaster+0x386>
   12350:	00 d0       	rcall	.+0      	; 0x12352 <FMenuMaster+0x388>
   12352:	ed b7       	in	r30, 0x3d	; 61
   12354:	fe b7       	in	r31, 0x3e	; 62
   12356:	12 83       	std	Z+2, r17	; 0x02
   12358:	01 83       	std	Z+1, r16	; 0x01
   1235a:	84 e5       	ldi	r24, 0x54	; 84
   1235c:	96 e1       	ldi	r25, 0x16	; 22
   1235e:	94 83       	std	Z+4, r25	; 0x04
   12360:	83 83       	std	Z+3, r24	; 0x03
   12362:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   12366:	0f 90       	pop	r0
   12368:	0f 90       	pop	r0
   1236a:	0f 90       	pop	r0
   1236c:	0f 90       	pop	r0
   1236e:	8b e0       	ldi	r24, 0x0B	; 11
   12370:	90 e0       	ldi	r25, 0x00	; 0
   12372:	b8 01       	movw	r22, r16
   12374:	4a e0       	ldi	r20, 0x0A	; 10
   12376:	50 e0       	ldi	r21, 0x00	; 0
   12378:	20 e0       	ldi	r18, 0x00	; 0
   1237a:	33 e1       	ldi	r19, 0x13	; 19
   1237c:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSysPassword,sizeof(DefSysPassword));	      		  
	      stMenuMaster=mmDisplaySuccess;
   12380:	8d e0       	ldi	r24, 0x0D	; 13
   12382:	53 cf       	rjmp	.-346    	; 0x1222a <FMenuMaster+0x260>
	      break;
     case mmDisplayInvalidRestoreCode:
	      lcd_printf(3,1,PSTR("Invalid Restore  "));
   12384:	83 e0       	ldi	r24, 0x03	; 3
   12386:	61 e0       	ldi	r22, 0x01	; 1
   12388:	42 e4       	ldi	r20, 0x42	; 66
   1238a:	56 e1       	ldi	r21, 0x16	; 22
   1238c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  TimDisplay=0;
   12390:	10 92 a7 01 	sts	0x01A7, r1
          stMenuMaster=mmDelayInvalidRestoreCode;
   12394:	8b e0       	ldi	r24, 0x0B	; 11
   12396:	49 cf       	rjmp	.-366    	; 0x1222a <FMenuMaster+0x260>
	      break;
     case mmDelayInvalidRestoreCode:
	      if (TimDisplay>5)stMenuMaster=mmDisplayKeyStamp;
   12398:	80 91 a7 01 	lds	r24, 0x01A7
   1239c:	86 30       	cpi	r24, 0x06	; 6
   1239e:	f0 f0       	brcs	.+60     	; 0x123dc <FMenuMaster+0x412>
   123a0:	87 e0       	ldi	r24, 0x07	; 7
   123a2:	43 cf       	rjmp	.-378    	; 0x1222a <FMenuMaster+0x260>
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
   123a4:	83 e0       	ldi	r24, 0x03	; 3
   123a6:	61 e0       	ldi	r22, 0x01	; 1
   123a8:	40 e3       	ldi	r20, 0x30	; 48
   123aa:	56 e1       	ldi	r21, 0x16	; 22
   123ac:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   123b0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   123b2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   123b4:	81 e0       	ldi	r24, 0x01	; 1
   123b6:	90 e0       	ldi	r25, 0x00	; 0
   123b8:	90 93 d7 01 	sts	0x01D7, r25
   123bc:	80 93 d6 01 	sts	0x01D6, r24
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
		  system_beep(1);
		  TimDisplay=0;
   123c0:	10 92 a7 01 	sts	0x01A7, r1
          stMenuMaster=mmDelayExit;
   123c4:	8f e0       	ldi	r24, 0x0F	; 15
   123c6:	31 cf       	rjmp	.-414    	; 0x1222a <FMenuMaster+0x260>
	      break;
     case mmDelayExit:
	      if (TimDisplay>=5)stMenuMaster=mmExitMaster;
   123c8:	80 91 a7 01 	lds	r24, 0x01A7
   123cc:	85 30       	cpi	r24, 0x05	; 5
   123ce:	30 f0       	brcs	.+12     	; 0x123dc <FMenuMaster+0x412>
   123d0:	80 e1       	ldi	r24, 0x10	; 16
   123d2:	2b cf       	rjmp	.-426    	; 0x1222a <FMenuMaster+0x260>
	      break;
     case mmExitMaster:
	      stMenuMaster=mmInitMaster;
   123d4:	10 92 23 03 	sts	0x0323, r1
   123d8:	81 e0       	ldi	r24, 0x01	; 1
   123da:	01 c0       	rjmp	.+2      	; 0x123de <FMenuMaster+0x414>
   123dc:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;

}
   123de:	e2 96       	adiw	r28, 0x32	; 50
   123e0:	0f b6       	in	r0, 0x3f	; 63
   123e2:	f8 94       	cli
   123e4:	de bf       	out	0x3e, r29	; 62
   123e6:	0f be       	out	0x3f, r0	; 63
   123e8:	cd bf       	out	0x3d, r28	; 61
   123ea:	cf 91       	pop	r28
   123ec:	df 91       	pop	r29
   123ee:	1f 91       	pop	r17
   123f0:	0f 91       	pop	r16
   123f2:	ff 90       	pop	r15
   123f4:	ef 90       	pop	r14
   123f6:	08 95       	ret

000123f8 <FMenuPassword>:
   return Result;	 
}



char FMenuPassword(){
   123f8:	af 92       	push	r10
   123fa:	bf 92       	push	r11
   123fc:	cf 92       	push	r12
   123fe:	df 92       	push	r13
   12400:	ef 92       	push	r14
   12402:	0f 93       	push	r16
   12404:	1f 93       	push	r17
   12406:	df 93       	push	r29
   12408:	cf 93       	push	r28
   1240a:	cd b7       	in	r28, 0x3d	; 61
   1240c:	de b7       	in	r29, 0x3e	; 62
   1240e:	6e 97       	sbiw	r28, 0x1e	; 30
   12410:	0f b6       	in	r0, 0x3f	; 63
   12412:	f8 94       	cli
   12414:	de bf       	out	0x3e, r29	; 62
   12416:	0f be       	out	0x3f, r0	; 63
   12418:	cd bf       	out	0x3d, r28	; 61
static char stMenuPasword=mpInitPassword,uiResult,strPassword[10],PassStatus=MP_NONE;;
char Result=MP_NONE,strMasterPass[10],strSystemPass[10],strAdminPass[10];

     Result=MP_NONE;
     switch(stMenuPasword){
   1241a:	e0 90 30 03 	lds	r14, 0x0330
   1241e:	81 e0       	ldi	r24, 0x01	; 1
   12420:	e8 16       	cp	r14, r24
   12422:	09 f1       	breq	.+66     	; 0x12466 <FMenuPassword+0x6e>
   12424:	e8 16       	cp	r14, r24
   12426:	48 f0       	brcs	.+18     	; 0x1243a <FMenuPassword+0x42>
   12428:	e2 e0       	ldi	r30, 0x02	; 2
   1242a:	ee 16       	cp	r14, r30
   1242c:	09 f4       	brne	.+2      	; 0x12430 <FMenuPassword+0x38>
   1242e:	3f c0       	rjmp	.+126    	; 0x124ae <FMenuPassword+0xb6>
   12430:	f3 e0       	ldi	r31, 0x03	; 3
   12432:	ef 16       	cp	r14, r31
   12434:	09 f0       	breq	.+2      	; 0x12438 <FMenuPassword+0x40>
   12436:	92 c0       	rjmp	.+292    	; 0x1255c <FMenuPassword+0x164>
   12438:	8c c0       	rjmp	.+280    	; 0x12552 <FMenuPassword+0x15a>
	 case mpInitPassword:
	      lcd_clear();
   1243a:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("PASSWORD:"));
   1243e:	81 e0       	ldi	r24, 0x01	; 1
   12440:	61 e0       	ldi	r22, 0x01	; 1
   12442:	4d e0       	ldi	r20, 0x0D	; 13
   12444:	58 e1       	ldi	r21, 0x18	; 24
   12446:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   1244a:	82 e0       	ldi	r24, 0x02	; 2
   1244c:	61 e0       	ldi	r22, 0x01	; 1
   1244e:	4b e0       	ldi	r20, 0x0B	; 11
   12450:	58 e1       	ldi	r21, 0x18	; 24
   12452:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12456:	84 e0       	ldi	r24, 0x04	; 4
   12458:	61 e0       	ldi	r22, 0x01	; 1
   1245a:	46 ef       	ldi	r20, 0xF6	; 246
   1245c:	57 e1       	ldi	r21, 0x17	; 23
   1245e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  FillChar(strPassword,0,sizeof(strPassword));
		  stMenuPasword=mpInputPasword;
   12462:	81 e0       	ldi	r24, 0x01	; 1
   12464:	73 c0       	rjmp	.+230    	; 0x1254c <FMenuPassword+0x154>
	      break;
     case mpInputPasword:
	 	      uiResult=UserInput(UI_NUM_PASSWORD,2,1,strPassword,0,8);
   12466:	84 e0       	ldi	r24, 0x04	; 4
   12468:	62 e0       	ldi	r22, 0x02	; 2
   1246a:	41 e0       	ldi	r20, 0x01	; 1
   1246c:	25 e2       	ldi	r18, 0x25	; 37
   1246e:	33 e0       	ldi	r19, 0x03	; 3
   12470:	00 e0       	ldi	r16, 0x00	; 0
   12472:	10 e0       	ldi	r17, 0x00	; 0
   12474:	98 e0       	ldi	r25, 0x08	; 8
   12476:	e9 2e       	mov	r14, r25
   12478:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
   1247c:	80 93 2f 03 	sts	0x032F, r24
		  if (uiResult==USER_OK){
   12480:	83 30       	cpi	r24, 0x03	; 3
   12482:	11 f4       	brne	.+4      	; 0x12488 <FMenuPassword+0x90>
		      stMenuPasword=mpProcessPassword;
   12484:	82 e0       	ldi	r24, 0x02	; 2
   12486:	62 c0       	rjmp	.+196    	; 0x1254c <FMenuPassword+0x154>
			  }
		  else
		  if (uiResult==USER_CANCEL){
   12488:	81 30       	cpi	r24, 0x01	; 1
   1248a:	09 f4       	brne	.+2      	; 0x1248e <FMenuPassword+0x96>
   1248c:	50 c0       	rjmp	.+160    	; 0x1252e <FMenuPassword+0x136>
		      PassStatus=MP_CANCEL;
		      stMenuPasword=mpExit;
			  }
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   1248e:	84 30       	cpi	r24, 0x04	; 4
   12490:	21 f4       	brne	.+8      	; 0x1249a <FMenuPassword+0xa2>
   12492:	61 e0       	ldi	r22, 0x01	; 1
   12494:	41 ee       	ldi	r20, 0xE1	; 225
   12496:	57 e1       	ldi	r21, 0x17	; 23
   12498:	07 c0       	rjmp	.+14     	; 0x124a8 <FMenuPassword+0xb0>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1249a:	85 30       	cpi	r24, 0x05	; 5
   1249c:	09 f0       	breq	.+2      	; 0x124a0 <FMenuPassword+0xa8>
   1249e:	5e c0       	rjmp	.+188    	; 0x1255c <FMenuPassword+0x164>
   124a0:	84 e0       	ldi	r24, 0x04	; 4
   124a2:	61 e0       	ldi	r22, 0x01	; 1
   124a4:	4c ec       	ldi	r20, 0xCC	; 204
   124a6:	57 e1       	ldi	r21, 0x17	; 23
   124a8:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   124ac:	57 c0       	rjmp	.+174    	; 0x1255c <FMenuPassword+0x164>
          break;	 
	 case mpProcessPassword:
		      
	      sprintf_P(strMasterPass,PSTR(MASTER_PASSWORD)); 
   124ae:	00 d0       	rcall	.+0      	; 0x124b0 <FMenuPassword+0xb8>
   124b0:	00 d0       	rcall	.+0      	; 0x124b2 <FMenuPassword+0xba>
   124b2:	8e 01       	movw	r16, r28
   124b4:	0f 5f       	subi	r16, 0xFF	; 255
   124b6:	1f 4f       	sbci	r17, 0xFF	; 255
   124b8:	ed b7       	in	r30, 0x3d	; 61
   124ba:	fe b7       	in	r31, 0x3e	; 62
   124bc:	12 83       	std	Z+2, r17	; 0x02
   124be:	01 83       	std	Z+1, r16	; 0x01
   124c0:	84 ec       	ldi	r24, 0xC4	; 196
   124c2:	97 e1       	ldi	r25, 0x17	; 23
   124c4:	94 83       	std	Z+4, r25	; 0x04
   124c6:	83 83       	std	Z+3, r24	; 0x03
   124c8:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   124cc:	0f 90       	pop	r0
   124ce:	0f 90       	pop	r0
   124d0:	0f 90       	pop	r0
   124d2:	0f 90       	pop	r0
   124d4:	b5 e1       	ldi	r27, 0x15	; 21
   124d6:	cb 2e       	mov	r12, r27
   124d8:	d1 2c       	mov	r13, r1
   124da:	cc 0e       	add	r12, r28
   124dc:	dd 1e       	adc	r13, r29
   124de:	c6 01       	movw	r24, r12
   124e0:	61 e0       	ldi	r22, 0x01	; 1
   124e2:	70 e0       	ldi	r23, 0x00	; 0
   124e4:	4a e0       	ldi	r20, 0x0A	; 10
   124e6:	50 e0       	ldi	r21, 0x00	; 0
   124e8:	28 ef       	ldi	r18, 0xF8	; 248
   124ea:	32 e1       	ldi	r19, 0x12	; 18
   124ec:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
	      eeprom_read_block((void*) &strAdminPass, (const void*) &DefSpvPassword, 10);
	      eeprom_read_block((void*) &strSystemPass, (const void*) &DefSysPassword, 10);
		  
		  if (strcmp(strMasterPass,strPassword)==0)
   124f0:	ab e0       	ldi	r26, 0x0B	; 11
   124f2:	aa 2e       	mov	r10, r26
   124f4:	b1 2c       	mov	r11, r1
   124f6:	ac 0e       	add	r10, r28
   124f8:	bd 1e       	adc	r11, r29
   124fa:	c5 01       	movw	r24, r10
   124fc:	6b e0       	ldi	r22, 0x0B	; 11
   124fe:	70 e0       	ldi	r23, 0x00	; 0
   12500:	4a e0       	ldi	r20, 0x0A	; 10
   12502:	50 e0       	ldi	r21, 0x00	; 0
   12504:	28 ef       	ldi	r18, 0xF8	; 248
   12506:	32 e1       	ldi	r19, 0x12	; 18
   12508:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
   1250c:	c8 01       	movw	r24, r16
   1250e:	65 e2       	ldi	r22, 0x25	; 37
   12510:	73 e0       	ldi	r23, 0x03	; 3
   12512:	0e 94 62 b5 	call	0x16ac4	; 0x16ac4 <strcmp>
   12516:	00 97       	sbiw	r24, 0x00	; 0
   12518:	11 f4       	brne	.+4      	; 0x1251e <FMenuPassword+0x126>
		       PassStatus=MP_VALID_MASTER;
   1251a:	83 e0       	ldi	r24, 0x03	; 3
   1251c:	08 c0       	rjmp	.+16     	; 0x1252e <FMenuPassword+0x136>
		  else
	      if (strcmp(strAdminPass,strPassword)==0){
   1251e:	c6 01       	movw	r24, r12
   12520:	65 e2       	ldi	r22, 0x25	; 37
   12522:	73 e0       	ldi	r23, 0x03	; 3
   12524:	0e 94 62 b5 	call	0x16ac4	; 0x16ac4 <strcmp>
   12528:	00 97       	sbiw	r24, 0x00	; 0
   1252a:	21 f4       	brne	.+8      	; 0x12534 <FMenuPassword+0x13c>
		       PassStatus=MP_VALID_ADMIN;
   1252c:	84 e0       	ldi	r24, 0x04	; 4
   1252e:	80 93 24 03 	sts	0x0324, r24
   12532:	0b c0       	rjmp	.+22     	; 0x1254a <FMenuPassword+0x152>
               //lcd_printf(3,1,PSTR("Admin"));
               //_delay_ms(5000);
			   }
		  else if (strcmp(strSystemPass,strPassword)==0){
   12534:	c5 01       	movw	r24, r10
   12536:	65 e2       	ldi	r22, 0x25	; 37
   12538:	73 e0       	ldi	r23, 0x03	; 3
   1253a:	0e 94 62 b5 	call	0x16ac4	; 0x16ac4 <strcmp>
   1253e:	00 97       	sbiw	r24, 0x00	; 0
   12540:	11 f4       	brne	.+4      	; 0x12546 <FMenuPassword+0x14e>
		       PassStatus=MP_VALID_SYSTEM;
   12542:	85 e0       	ldi	r24, 0x05	; 5
   12544:	f4 cf       	rjmp	.-24     	; 0x1252e <FMenuPassword+0x136>
			   //lcd_printf(3,1,PSTR("System"));
               //_delay_ms(5000);
			   }
		  else PassStatus=MP_INVALID;
   12546:	e0 92 24 03 	sts	0x0324, r14
		  stMenuPasword=mpExit;
   1254a:	83 e0       	ldi	r24, 0x03	; 3
   1254c:	80 93 30 03 	sts	0x0330, r24
   12550:	05 c0       	rjmp	.+10     	; 0x1255c <FMenuPassword+0x164>
	      break;
	 case mpExit:
	      //lcd_print(3,1,strPassword);
		  //_delay_ms(5000);
	      stMenuPasword=mpInitPassword;
   12552:	10 92 30 03 	sts	0x0330, r1
	      Result=PassStatus;
   12556:	80 91 24 03 	lds	r24, 0x0324
   1255a:	01 c0       	rjmp	.+2      	; 0x1255e <FMenuPassword+0x166>
   1255c:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
   1255e:	6e 96       	adiw	r28, 0x1e	; 30
   12560:	0f b6       	in	r0, 0x3f	; 63
   12562:	f8 94       	cli
   12564:	de bf       	out	0x3e, r29	; 62
   12566:	0f be       	out	0x3f, r0	; 63
   12568:	cd bf       	out	0x3d, r28	; 61
   1256a:	cf 91       	pop	r28
   1256c:	df 91       	pop	r29
   1256e:	1f 91       	pop	r17
   12570:	0f 91       	pop	r16
   12572:	ef 90       	pop	r14
   12574:	df 90       	pop	r13
   12576:	cf 90       	pop	r12
   12578:	bf 90       	pop	r11
   1257a:	af 90       	pop	r10
   1257c:	08 95       	ret

0001257e <FMenuReprint>:
	       break;
	 }
return Result;
}

char FMenuReprint(){
   1257e:	0f 93       	push	r16
   12580:	1f 93       	push	r17
   12582:	df 93       	push	r29
   12584:	cf 93       	push	r28
   12586:	cd b7       	in	r28, 0x3d	; 61
   12588:	de b7       	in	r29, 0x3e	; 62
   1258a:	64 97       	sbiw	r28, 0x14	; 20
   1258c:	0f b6       	in	r0, 0x3f	; 63
   1258e:	f8 94       	cli
   12590:	de bf       	out	0x3e, r29	; 62
   12592:	0f be       	out	0x3f, r0	; 63
   12594:	cd bf       	out	0x3d, r28	; 61
static char KeyPressed=0,FIP_Used=0;
       char lcdteks[20],FIPResult,KeyChar;//,FIP_USED;
	   char PassResult,Result=MENU_NONE,ReprintResult;

     Result=MENU_NONE;
	 switch(stReprint){
   12596:	80 91 52 03 	lds	r24, 0x0352
   1259a:	87 30       	cpi	r24, 0x07	; 7
   1259c:	09 f4       	brne	.+2      	; 0x125a0 <FMenuReprint+0x22>
   1259e:	8e c0       	rjmp	.+284    	; 0x126bc <FMenuReprint+0x13e>
   125a0:	88 30       	cpi	r24, 0x08	; 8
   125a2:	90 f4       	brcc	.+36     	; 0x125c8 <FMenuReprint+0x4a>
   125a4:	83 30       	cpi	r24, 0x03	; 3
   125a6:	09 f4       	brne	.+2      	; 0x125aa <FMenuReprint+0x2c>
   125a8:	43 c0       	rjmp	.+134    	; 0x12630 <FMenuReprint+0xb2>
   125aa:	84 30       	cpi	r24, 0x04	; 4
   125ac:	30 f4       	brcc	.+12     	; 0x125ba <FMenuReprint+0x3c>
   125ae:	81 30       	cpi	r24, 0x01	; 1
   125b0:	09 f4       	brne	.+2      	; 0x125b4 <FMenuReprint+0x36>
   125b2:	55 c0       	rjmp	.+170    	; 0x1265e <FMenuReprint+0xe0>
   125b4:	82 30       	cpi	r24, 0x02	; 2
   125b6:	48 f5       	brcc	.+82     	; 0x1260a <FMenuReprint+0x8c>
   125b8:	1d c0       	rjmp	.+58     	; 0x125f4 <FMenuReprint+0x76>
   125ba:	85 30       	cpi	r24, 0x05	; 5
   125bc:	09 f4       	brne	.+2      	; 0x125c0 <FMenuReprint+0x42>
   125be:	6c c0       	rjmp	.+216    	; 0x12698 <FMenuReprint+0x11a>
   125c0:	86 30       	cpi	r24, 0x06	; 6
   125c2:	08 f0       	brcs	.+2      	; 0x125c6 <FMenuReprint+0x48>
   125c4:	50 c0       	rjmp	.+160    	; 0x12666 <FMenuReprint+0xe8>
   125c6:	45 c0       	rjmp	.+138    	; 0x12652 <FMenuReprint+0xd4>
   125c8:	8b 30       	cpi	r24, 0x0B	; 11
   125ca:	09 f4       	brne	.+2      	; 0x125ce <FMenuReprint+0x50>
   125cc:	da c0       	rjmp	.+436    	; 0x12782 <FMenuReprint+0x204>
   125ce:	8c 30       	cpi	r24, 0x0C	; 12
   125d0:	38 f4       	brcc	.+14     	; 0x125e0 <FMenuReprint+0x62>
   125d2:	89 30       	cpi	r24, 0x09	; 9
   125d4:	09 f4       	brne	.+2      	; 0x125d8 <FMenuReprint+0x5a>
   125d6:	b8 c0       	rjmp	.+368    	; 0x12748 <FMenuReprint+0x1ca>
   125d8:	8a 30       	cpi	r24, 0x0A	; 10
   125da:	08 f0       	brcs	.+2      	; 0x125de <FMenuReprint+0x60>
   125dc:	ca c0       	rjmp	.+404    	; 0x12772 <FMenuReprint+0x1f4>
   125de:	7c c0       	rjmp	.+248    	; 0x126d8 <FMenuReprint+0x15a>
   125e0:	8d 30       	cpi	r24, 0x0D	; 13
   125e2:	09 f4       	brne	.+2      	; 0x125e6 <FMenuReprint+0x68>
   125e4:	ed c0       	rjmp	.+474    	; 0x127c0 <FMenuReprint+0x242>
   125e6:	8d 30       	cpi	r24, 0x0D	; 13
   125e8:	08 f4       	brcc	.+2      	; 0x125ec <FMenuReprint+0x6e>
   125ea:	d7 c0       	rjmp	.+430    	; 0x1279a <FMenuReprint+0x21c>
   125ec:	8e 30       	cpi	r24, 0x0E	; 14
   125ee:	09 f0       	breq	.+2      	; 0x125f2 <FMenuReprint+0x74>
   125f0:	f0 c0       	rjmp	.+480    	; 0x127d2 <FMenuReprint+0x254>
   125f2:	eb c0       	rjmp	.+470    	; 0x127ca <FMenuReprint+0x24c>
	 case rtInit:
	      lcd_clear();
   125f4:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
          if (IFType==IT_SLAVE)stReprint=rtFIP;
   125f8:	80 91 10 01 	lds	r24, 0x0110
   125fc:	81 30       	cpi	r24, 0x01	; 1
   125fe:	09 f4       	brne	.+2      	; 0x12602 <FMenuReprint+0x84>
   12600:	b3 c0       	rjmp	.+358    	; 0x12768 <FMenuReprint+0x1ea>
		  else
		  if (IFType==IT_STANDALONE)stReprint=rtStandaloneFIP;//rtValidPassword;//rtStandaloneFIP;
   12602:	82 30       	cpi	r24, 0x02	; 2
   12604:	09 f0       	breq	.+2      	; 0x12608 <FMenuReprint+0x8a>
   12606:	e5 c0       	rjmp	.+458    	; 0x127d2 <FMenuReprint+0x254>
   12608:	04 c0       	rjmp	.+8      	; 0x12612 <FMenuReprint+0x94>
	      break;
     case rtValidPassword:
	      PassResult=FMenuPassword();
   1260a:	0e 94 fc 91 	call	0x123f8	; 0x123f8 <FMenuPassword>
	      if (PassResult==MP_VALID_ADMIN)stReprint=rtStandaloneFIP;
   1260e:	84 30       	cpi	r24, 0x04	; 4
   12610:	11 f4       	brne	.+4      	; 0x12616 <FMenuReprint+0x98>
   12612:	81 e0       	ldi	r24, 0x01	; 1
   12614:	0a c0       	rjmp	.+20     	; 0x1262a <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_VALID_SYSTEM)stReprint=rtInvalidPassword;
   12616:	85 30       	cpi	r24, 0x05	; 5
   12618:	11 f0       	breq	.+4      	; 0x1261e <FMenuReprint+0xa0>
          else
	      if (PassResult==MP_INVALID)stReprint=rtInvalidPassword;
   1261a:	82 30       	cpi	r24, 0x02	; 2
   1261c:	11 f4       	brne	.+4      	; 0x12622 <FMenuReprint+0xa4>
   1261e:	83 e0       	ldi	r24, 0x03	; 3
   12620:	04 c0       	rjmp	.+8      	; 0x1262a <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
   12622:	81 30       	cpi	r24, 0x01	; 1
   12624:	09 f0       	breq	.+2      	; 0x12628 <FMenuReprint+0xaa>
   12626:	d5 c0       	rjmp	.+426    	; 0x127d2 <FMenuReprint+0x254>
   12628:	8e e0       	ldi	r24, 0x0E	; 14
   1262a:	80 93 52 03 	sts	0x0352, r24
   1262e:	d1 c0       	rjmp	.+418    	; 0x127d2 <FMenuReprint+0x254>
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
   12630:	10 92 a7 01 	sts	0x01A7, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   12634:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   12636:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   12638:	81 e0       	ldi	r24, 0x01	; 1
   1263a:	90 e0       	ldi	r25, 0x00	; 0
   1263c:	90 93 d7 01 	sts	0x01D7, r25
   12640:	80 93 d6 01 	sts	0x01D6, r24
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   12644:	83 e0       	ldi	r24, 0x03	; 3
   12646:	61 e0       	ldi	r22, 0x01	; 1
   12648:	48 e7       	ldi	r20, 0x78	; 120
   1264a:	5b e1       	ldi	r21, 0x1B	; 27
   1264c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   12650:	33 c0       	rjmp	.+102    	; 0x126b8 <FMenuReprint+0x13a>
          stReprint=rtTimDisplayInvalid;
	      break;
     case rtTimDisplayInvalid:
	      if (TimDisplay>2)stReprint=rtExitReprint;
   12652:	80 91 a7 01 	lds	r24, 0x01A7
   12656:	83 30       	cpi	r24, 0x03	; 3
   12658:	08 f4       	brcc	.+2      	; 0x1265c <FMenuReprint+0xde>
   1265a:	bb c0       	rjmp	.+374    	; 0x127d2 <FMenuReprint+0x254>
   1265c:	e5 cf       	rjmp	.-54     	; 0x12628 <FMenuReprint+0xaa>
	      break;
     case rtStandaloneFIP:
	      _scr_pump();
   1265e:	0e 94 4f 46 	call	0x8c9e	; 0x8c9e <_scr_pump>
		  stReprint=rtStandaloneInputFIP;
   12662:	86 e0       	ldi	r24, 0x06	; 6
   12664:	e2 cf       	rjmp	.-60     	; 0x1262a <FMenuReprint+0xac>
	      break;
     case rtStandaloneInputFIP:
		  KeyChar=_key_btn(_key_scan(1));
   12666:	81 e0       	ldi	r24, 0x01	; 1
   12668:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   1266c:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   12670:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='8')){
   12672:	81 53       	subi	r24, 0x31	; 49
   12674:	88 30       	cpi	r24, 0x08	; 8
   12676:	60 f4       	brcc	.+24     	; 0x12690 <FMenuReprint+0x112>
		       ReprintResult=PrintStandalone(KeyChar-'0',True);
   12678:	8f 5f       	subi	r24, 0xFF	; 255
   1267a:	61 e0       	ldi	r22, 0x01	; 1
   1267c:	0e 94 93 21 	call	0x4326	; 0x4326 <PrintStandalone>
			   if (ReprintResult==PS_NO_DATA)stReprint=rtDisplayNoTransaction;
   12680:	82 31       	cpi	r24, 0x12	; 18
   12682:	11 f4       	brne	.+4      	; 0x12688 <FMenuReprint+0x10a>
   12684:	85 e0       	ldi	r24, 0x05	; 5
   12686:	d1 cf       	rjmp	.-94     	; 0x1262a <FMenuReprint+0xac>
			   else if (ReprintResult==PS_PRINTED)stReprint=rtExitReprint;
   12688:	81 31       	cpi	r24, 0x11	; 17
   1268a:	09 f0       	breq	.+2      	; 0x1268e <FMenuReprint+0x110>
   1268c:	a2 c0       	rjmp	.+324    	; 0x127d2 <FMenuReprint+0x254>
   1268e:	cc cf       	rjmp	.-104    	; 0x12628 <FMenuReprint+0xaa>

		  }else if (KeyChar=='*')stReprint=rtExitReprint;
   12690:	9a 32       	cpi	r25, 0x2A	; 42
   12692:	09 f0       	breq	.+2      	; 0x12696 <FMenuReprint+0x118>
   12694:	9e c0       	rjmp	.+316    	; 0x127d2 <FMenuReprint+0x254>
   12696:	c8 cf       	rjmp	.-112    	; 0x12628 <FMenuReprint+0xaa>

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   12698:	83 e0       	ldi	r24, 0x03	; 3
   1269a:	61 e0       	ldi	r22, 0x01	; 1
   1269c:	43 e6       	ldi	r20, 0x63	; 99
   1269e:	5b e1       	ldi	r21, 0x1B	; 27
   126a0:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   126a4:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   126a6:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   126a8:	81 e0       	ldi	r24, 0x01	; 1
   126aa:	90 e0       	ldi	r25, 0x00	; 0
   126ac:	90 93 d7 01 	sts	0x01D7, r25
   126b0:	80 93 d6 01 	sts	0x01D6, r24

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
		  system_beep(1);
          TimDisplay=0;
   126b4:	10 92 a7 01 	sts	0x01A7, r1
		  stReprint=rtTimDisplayInvalid;
   126b8:	84 e0       	ldi	r24, 0x04	; 4
   126ba:	b7 cf       	rjmp	.-146    	; 0x1262a <FMenuReprint+0xac>
	      break;
	 case rtFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   126bc:	80 e5       	ldi	r24, 0x50	; 80
   126be:	93 e0       	ldi	r25, 0x03	; 3
   126c0:	66 e8       	ldi	r22, 0x86	; 134
   126c2:	79 e0       	ldi	r23, 0x09	; 9
   126c4:	0e 94 ed 64 	call	0xc9da	; 0xc9da <menu_FIP>
		  if (FIPResult==FIP_DONE){
   126c8:	88 23       	and	r24, r24
   126ca:	11 f4       	brne	.+4      	; 0x126d0 <FMenuReprint+0x152>
		      stReprint=rtRFID;
   126cc:	88 e0       	ldi	r24, 0x08	; 8
   126ce:	ad cf       	rjmp	.-166    	; 0x1262a <FMenuReprint+0xac>
			  }
		  else
		  if (FIPResult==FIP_CANCEL)stReprint=rtExitReprint;
   126d0:	82 30       	cpi	r24, 0x02	; 2
   126d2:	09 f0       	breq	.+2      	; 0x126d6 <FMenuReprint+0x158>
   126d4:	7e c0       	rjmp	.+252    	; 0x127d2 <FMenuReprint+0x254>
   126d6:	a8 cf       	rjmp	.-176    	; 0x12628 <FMenuReprint+0xaa>
	      break;
	 case rtRFID:
	      lcd_clear();
   126d8:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("RePrint FIP:%s "),strFIP_ID);lcd_print(1,1,lcdteks);
   126dc:	00 d0       	rcall	.+0      	; 0x126de <FMenuReprint+0x160>
   126de:	00 d0       	rcall	.+0      	; 0x126e0 <FMenuReprint+0x162>
   126e0:	00 d0       	rcall	.+0      	; 0x126e2 <FMenuReprint+0x164>
   126e2:	ed b7       	in	r30, 0x3d	; 61
   126e4:	fe b7       	in	r31, 0x3e	; 62
   126e6:	31 96       	adiw	r30, 0x01	; 1
   126e8:	8e 01       	movw	r16, r28
   126ea:	0f 5f       	subi	r16, 0xFF	; 255
   126ec:	1f 4f       	sbci	r17, 0xFF	; 255
   126ee:	ad b7       	in	r26, 0x3d	; 61
   126f0:	be b7       	in	r27, 0x3e	; 62
   126f2:	12 96       	adiw	r26, 0x02	; 2
   126f4:	1c 93       	st	X, r17
   126f6:	0e 93       	st	-X, r16
   126f8:	11 97       	sbiw	r26, 0x01	; 1
   126fa:	83 e5       	ldi	r24, 0x53	; 83
   126fc:	9b e1       	ldi	r25, 0x1B	; 27
   126fe:	93 83       	std	Z+3, r25	; 0x03
   12700:	82 83       	std	Z+2, r24	; 0x02
   12702:	86 e8       	ldi	r24, 0x86	; 134
   12704:	99 e0       	ldi	r25, 0x09	; 9
   12706:	95 83       	std	Z+5, r25	; 0x05
   12708:	84 83       	std	Z+4, r24	; 0x04
   1270a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   1270e:	8d b7       	in	r24, 0x3d	; 61
   12710:	9e b7       	in	r25, 0x3e	; 62
   12712:	06 96       	adiw	r24, 0x06	; 6
   12714:	0f b6       	in	r0, 0x3f	; 63
   12716:	f8 94       	cli
   12718:	9e bf       	out	0x3e, r25	; 62
   1271a:	0f be       	out	0x3f, r0	; 63
   1271c:	8d bf       	out	0x3d, r24	; 61
   1271e:	81 e0       	ldi	r24, 0x01	; 1
   12720:	61 e0       	ldi	r22, 0x01	; 1
   12722:	a8 01       	movw	r20, r16
   12724:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_printf(2,1,PSTR(  "Tap Supervisor Card"));
   12728:	82 e0       	ldi	r24, 0x02	; 2
   1272a:	61 e0       	ldi	r22, 0x01	; 1
   1272c:	4f e3       	ldi	r20, 0x3F	; 63
   1272e:	5b e1       	ldi	r21, 0x1B	; 27
   12730:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          lcd_printf(4,1,PSTR(  "[*]Back    [#]Exit"));
   12734:	84 e0       	ldi	r24, 0x04	; 4
   12736:	61 e0       	ldi	r22, 0x01	; 1
   12738:	4c e2       	ldi	r20, 0x2C	; 44
   1273a:	5b e1       	ldi	r21, 0x1B	; 27
   1273c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  IsRFIDDetected=False;
   12740:	10 92 af 01 	sts	0x01AF, r1
		  stReprint=rtInputRFID;
   12744:	89 e0       	ldi	r24, 0x09	; 9
   12746:	71 cf       	rjmp	.-286    	; 0x1262a <FMenuReprint+0xac>
	      break;
	 case rtInputRFID:
	      if (IsRFIDDetected==True){
   12748:	80 91 af 01 	lds	r24, 0x01AF
   1274c:	81 30       	cpi	r24, 0x01	; 1
   1274e:	29 f4       	brne	.+10     	; 0x1275a <FMenuReprint+0x1dc>
		      IsRFIDDetected=False;
   12750:	10 92 af 01 	sts	0x01AF, r1
		      stReprint=rtSendMessage28;
   12754:	8a e0       	ldi	r24, 0x0A	; 10
   12756:	80 93 52 03 	sts	0x0352, r24
		  }
	 	  KeyPressed=_key_scan(1);
   1275a:	81 e0       	ldi	r24, 0x01	; 1
   1275c:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   12760:	80 93 51 03 	sts	0x0351, r24
		  if (KeyPressed==_KEY_CANCEL){
   12764:	87 3e       	cpi	r24, 0xE7	; 231
   12766:	11 f4       	brne	.+4      	; 0x1276c <FMenuReprint+0x1ee>
		      stReprint=rtFIP;
   12768:	87 e0       	ldi	r24, 0x07	; 7
   1276a:	5f cf       	rjmp	.-322    	; 0x1262a <FMenuReprint+0xac>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stReprint=rtExitReprint;
   1276c:	87 3b       	cpi	r24, 0xB7	; 183
   1276e:	89 f5       	brne	.+98     	; 0x127d2 <FMenuReprint+0x254>
   12770:	5b cf       	rjmp	.-330    	; 0x12628 <FMenuReprint+0xaa>
	      break;
     case rtSendMessage28:
		  sendMessage28();
   12772:	0e 94 3c 52 	call	0xa478	; 0xa478 <sendMessage28>
		  TimSend=0;
   12776:	10 92 a9 01 	sts	0x01A9, r1
   1277a:	10 92 a8 01 	sts	0x01A8, r1
		  stReprint=rtWaitReply;
   1277e:	8b e0       	ldi	r24, 0x0B	; 11
   12780:	54 cf       	rjmp	.-344    	; 0x1262a <FMenuReprint+0xac>
		  break;
     case rtWaitReply:
	      if (TimSend>TIM_SEND*3)stReprint=rtNoConnection;
   12782:	80 91 a8 01 	lds	r24, 0x01A8
   12786:	90 91 a9 01 	lds	r25, 0x01A9
   1278a:	4f 97       	sbiw	r24, 0x1f	; 31
   1278c:	18 f0       	brcs	.+6      	; 0x12794 <FMenuReprint+0x216>
   1278e:	8c e0       	ldi	r24, 0x0C	; 12
   12790:	80 93 52 03 	sts	0x0352, r24
	      if (IsMessage99==True){
   12794:	80 91 b6 01 	lds	r24, 0x01B6
   12798:	44 cf       	rjmp	.-376    	; 0x12622 <FMenuReprint+0xa4>
		      stReprint=rtExitReprint;
		  }
	      break;
     case rtNoConnection:
	      lcd_clear();
   1279a:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
   1279e:	82 e0       	ldi	r24, 0x02	; 2
   127a0:	61 e0       	ldi	r22, 0x01	; 1
   127a2:	4e e1       	ldi	r20, 0x1E	; 30
   127a4:	5b e1       	ldi	r21, 0x1B	; 27
   127a6:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
   127aa:	83 e0       	ldi	r24, 0x03	; 3
   127ac:	61 e0       	ldi	r22, 0x01	; 1
   127ae:	40 e1       	ldi	r20, 0x10	; 16
   127b0:	5b e1       	ldi	r21, 0x1B	; 27
   127b2:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  TimDisplay=5;
   127b6:	85 e0       	ldi	r24, 0x05	; 5
   127b8:	80 93 a7 01 	sts	0x01A7, r24
		  stReprint=rtDelayExitReprint;
   127bc:	8d e0       	ldi	r24, 0x0D	; 13
   127be:	35 cf       	rjmp	.-406    	; 0x1262a <FMenuReprint+0xac>
	      break;
     case rtDelayExitReprint:
	      if(TimDisplay>=10)stReprint=rtExitReprint;
   127c0:	80 91 a7 01 	lds	r24, 0x01A7
   127c4:	8a 30       	cpi	r24, 0x0A	; 10
   127c6:	28 f0       	brcs	.+10     	; 0x127d2 <FMenuReprint+0x254>
   127c8:	2f cf       	rjmp	.-418    	; 0x12628 <FMenuReprint+0xaa>
	      break;
	 case rtExitReprint:
	      stReprint=rtInit;
   127ca:	10 92 52 03 	sts	0x0352, r1
   127ce:	81 e0       	ldi	r24, 0x01	; 1
   127d0:	01 c0       	rjmp	.+2      	; 0x127d4 <FMenuReprint+0x256>
   127d2:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   127d4:	64 96       	adiw	r28, 0x14	; 20
   127d6:	0f b6       	in	r0, 0x3f	; 63
   127d8:	f8 94       	cli
   127da:	de bf       	out	0x3e, r29	; 62
   127dc:	0f be       	out	0x3f, r0	; 63
   127de:	cd bf       	out	0x3d, r28	; 61
   127e0:	cf 91       	pop	r28
   127e2:	df 91       	pop	r29
   127e4:	1f 91       	pop	r17
   127e6:	0f 91       	pop	r16
   127e8:	08 95       	ret

000127ea <FMenuAdmin>:

char FMenuAdmin(){
static char stMenuAdmin=maInitAdmin;
	 char SubMenu,KeyPressed,KeyChar,Result=MENU_NONE;
     
	 switch(stMenuAdmin){
   127ea:	80 91 22 03 	lds	r24, 0x0322
   127ee:	83 30       	cpi	r24, 0x03	; 3
   127f0:	09 f4       	brne	.+2      	; 0x127f4 <FMenuAdmin+0xa>
   127f2:	66 c0       	rjmp	.+204    	; 0x128c0 <FMenuAdmin+0xd6>
   127f4:	84 30       	cpi	r24, 0x04	; 4
   127f6:	30 f4       	brcc	.+12     	; 0x12804 <FMenuAdmin+0x1a>
   127f8:	81 30       	cpi	r24, 0x01	; 1
   127fa:	69 f1       	breq	.+90     	; 0x12856 <FMenuAdmin+0x6c>
   127fc:	82 30       	cpi	r24, 0x02	; 2
   127fe:	08 f0       	brcs	.+2      	; 0x12802 <FMenuAdmin+0x18>
   12800:	4d c0       	rjmp	.+154    	; 0x1289c <FMenuAdmin+0xb2>
   12802:	0d c0       	rjmp	.+26     	; 0x1281e <FMenuAdmin+0x34>
   12804:	85 30       	cpi	r24, 0x05	; 5
   12806:	09 f4       	brne	.+2      	; 0x1280a <FMenuAdmin+0x20>
   12808:	4e c0       	rjmp	.+156    	; 0x128a6 <FMenuAdmin+0xbc>
   1280a:	85 30       	cpi	r24, 0x05	; 5
   1280c:	08 f4       	brcc	.+2      	; 0x12810 <FMenuAdmin+0x26>
   1280e:	49 c0       	rjmp	.+146    	; 0x128a2 <FMenuAdmin+0xb8>
   12810:	86 30       	cpi	r24, 0x06	; 6
   12812:	09 f4       	brne	.+2      	; 0x12816 <FMenuAdmin+0x2c>
   12814:	51 c0       	rjmp	.+162    	; 0x128b8 <FMenuAdmin+0xce>
   12816:	87 30       	cpi	r24, 0x07	; 7
   12818:	09 f0       	breq	.+2      	; 0x1281c <FMenuAdmin+0x32>
   1281a:	5a c0       	rjmp	.+180    	; 0x128d0 <FMenuAdmin+0xe6>
   1281c:	55 c0       	rjmp	.+170    	; 0x128c8 <FMenuAdmin+0xde>
	 case maInitAdmin:
		  lcd_clear();
   1281e:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)RePrint           "));
   12822:	81 e0       	ldi	r24, 0x01	; 1
   12824:	61 e0       	ldi	r22, 0x01	; 1
   12826:	4b e1       	ldi	r20, 0x1B	; 27
   12828:	56 e1       	ldi	r21, 0x16	; 22
   1282a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)CloseShift        "));
   1282e:	82 e0       	ldi	r24, 0x02	; 2
   12830:	61 e0       	ldi	r22, 0x01	; 1
   12832:	46 e0       	ldi	r20, 0x06	; 6
   12834:	56 e1       	ldi	r21, 0x16	; 22
   12836:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(3,1,PSTR("3)CloseDay          "));		  
   1283a:	83 e0       	ldi	r24, 0x03	; 3
   1283c:	61 e0       	ldi	r22, 0x01	; 1
   1283e:	41 ef       	ldi	r20, 0xF1	; 241
   12840:	55 e1       	ldi	r21, 0x15	; 21
   12842:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4,1,PSTR("4)Settings   *)Exit "));
   12846:	84 e0       	ldi	r24, 0x04	; 4
   12848:	61 e0       	ldi	r22, 0x01	; 1
   1284a:	4c ed       	ldi	r20, 0xDC	; 220
   1284c:	55 e1       	ldi	r21, 0x15	; 21
   1284e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	      stMenuAdmin=maSelectOptions;
   12852:	81 e0       	ldi	r24, 0x01	; 1
   12854:	2e c0       	rjmp	.+92     	; 0x128b2 <FMenuAdmin+0xc8>
	      break;
	 case maSelectOptions:
          KeyPressed=_key_scan(1);
   12856:	81 e0       	ldi	r24, 0x01	; 1
   12858:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   1285c:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
		  switch (KeyChar){
   12860:	82 33       	cpi	r24, 0x32	; 50
   12862:	71 f0       	breq	.+28     	; 0x12880 <FMenuAdmin+0x96>
   12864:	83 33       	cpi	r24, 0x33	; 51
   12866:	28 f4       	brcc	.+10     	; 0x12872 <FMenuAdmin+0x88>
   12868:	8a 32       	cpi	r24, 0x2A	; 42
   1286a:	11 f1       	breq	.+68     	; 0x128b0 <FMenuAdmin+0xc6>
   1286c:	81 33       	cpi	r24, 0x31	; 49
   1286e:	81 f5       	brne	.+96     	; 0x128d0 <FMenuAdmin+0xe6>
   12870:	05 c0       	rjmp	.+10     	; 0x1287c <FMenuAdmin+0x92>
   12872:	83 33       	cpi	r24, 0x33	; 51
   12874:	59 f0       	breq	.+22     	; 0x1288c <FMenuAdmin+0xa2>
   12876:	84 33       	cpi	r24, 0x34	; 52
   12878:	59 f5       	brne	.+86     	; 0x128d0 <FMenuAdmin+0xe6>
   1287a:	0e c0       	rjmp	.+28     	; 0x12898 <FMenuAdmin+0xae>
		  case '1':
		       stMenuAdmin=maMenuReprint;//maMenuAdminConfig;
   1287c:	82 e0       	ldi	r24, 0x02	; 2
   1287e:	19 c0       	rjmp	.+50     	; 0x128b2 <FMenuAdmin+0xc8>
		       break;  
		  case '2':
		       if (IFType==IT_STANDALONE)
   12880:	80 91 10 01 	lds	r24, 0x0110
   12884:	82 30       	cpi	r24, 0x02	; 2
   12886:	e1 f4       	brne	.+56     	; 0x128c0 <FMenuAdmin+0xd6>
			       stMenuAdmin=maMenuCloseShift;
   12888:	84 e0       	ldi	r24, 0x04	; 4
   1288a:	13 c0       	rjmp	.+38     	; 0x128b2 <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '3':
		       if (IFType==IT_STANDALONE)stMenuAdmin=maMenuCloseDay;
   1288c:	80 91 10 01 	lds	r24, 0x0110
   12890:	82 30       	cpi	r24, 0x02	; 2
   12892:	b1 f4       	brne	.+44     	; 0x128c0 <FMenuAdmin+0xd6>
   12894:	85 e0       	ldi	r24, 0x05	; 5
   12896:	0d c0       	rjmp	.+26     	; 0x128b2 <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '4':
		  	   stMenuAdmin=maMenuAdminSettings;
   12898:	86 e0       	ldi	r24, 0x06	; 6
   1289a:	0b c0       	rjmp	.+22     	; 0x128b2 <FMenuAdmin+0xc8>
    		   stMenuAdmin=maExitMenuAdmin;
		       break;  		  
		  }		  
	      break;
     case maMenuReprint:
	      SubMenu=FMenuReprint();
   1289c:	0e 94 bf 92 	call	0x1257e	; 0x1257e <FMenuReprint>
   128a0:	05 c0       	rjmp	.+10     	; 0x128ac <FMenuAdmin+0xc2>
	 case maMenuAdminConfig://ChangePassword[],RePrint,PumpTest
	      SubMenu=FSubMenuAdmin();
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;
          break;	 
	 case maMenuCloseShift:
	 	  SubMenu=FCloseShift(CONTINUE_SHIFT);
   128a2:	82 e0       	ldi	r24, 0x02	; 2
   128a4:	01 c0       	rjmp	.+2      	; 0x128a8 <FMenuAdmin+0xbe>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
	      break;
     case maMenuCloseDay://maMenuCloseShift,maMenuCloseDay
	 	  SubMenu=FCloseShift(NEW_SHIFT);
   128a6:	81 e0       	ldi	r24, 0x01	; 1
   128a8:	0e 94 49 60 	call	0xc092	; 0xc092 <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
   128ac:	81 30       	cpi	r24, 0x01	; 1
   128ae:	81 f4       	brne	.+32     	; 0x128d0 <FMenuAdmin+0xe6>
   128b0:	87 e0       	ldi	r24, 0x07	; 7
   128b2:	80 93 22 03 	sts	0x0322, r24
   128b6:	06 c0       	rjmp	.+12     	; 0x128c4 <FMenuAdmin+0xda>
	      break;
     case maMenuAdminSettings:
	      SubMenu=FMenuAdminSettings();
   128b8:	0e 94 5e 8f 	call	0x11ebc	; 0x11ebc <FMenuAdminSettings>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;	      
   128bc:	81 30       	cpi	r24, 0x01	; 1
   128be:	41 f4       	brne	.+16     	; 0x128d0 <FMenuAdmin+0xe6>
   128c0:	10 92 22 03 	sts	0x0322, r1
   128c4:	80 e0       	ldi	r24, 0x00	; 0
   128c6:	08 95       	ret
	      break;
     case maExitMenuAdmin:
	      stMenuAdmin=maInitAdmin;	      
   128c8:	10 92 22 03 	sts	0x0322, r1
   128cc:	81 e0       	ldi	r24, 0x01	; 1
   128ce:	08 95       	ret
   128d0:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
          break;	 
	 }
   return Result;
}
   128d2:	08 95       	ret

000128d4 <FMenuChangeMOP>:
	      break;
	 }
   return Result;
}

char FMenuChangeMOP(){
   128d4:	af 92       	push	r10
   128d6:	bf 92       	push	r11
   128d8:	cf 92       	push	r12
   128da:	df 92       	push	r13
   128dc:	ef 92       	push	r14
   128de:	ff 92       	push	r15
   128e0:	0f 93       	push	r16
   128e2:	1f 93       	push	r17
   128e4:	df 93       	push	r29
   128e6:	cf 93       	push	r28
   128e8:	cd b7       	in	r28, 0x3d	; 61
   128ea:	de b7       	in	r29, 0x3e	; 62
   128ec:	a3 97       	sbiw	r28, 0x23	; 35
   128ee:	0f b6       	in	r0, 0x3f	; 63
   128f0:	f8 94       	cli
   128f2:	de bf       	out	0x3e, r29	; 62
   128f4:	0f be       	out	0x3f, r0	; 63
   128f6:	cd bf       	out	0x3d, r28	; 61
	   char strBankName[11],strSurcharge[4],Result;
static char BankIdx=0,uiResult;//,Surcharge=0;
     
Result=MENU_NONE; 

	 switch(stChangeMOP){
   128f8:	80 91 47 03 	lds	r24, 0x0347
   128fc:	e8 2f       	mov	r30, r24
   128fe:	f0 e0       	ldi	r31, 0x00	; 0
   12900:	ee 31       	cpi	r30, 0x1E	; 30
   12902:	f1 05       	cpc	r31, r1
   12904:	08 f0       	brcs	.+2      	; 0x12908 <FMenuChangeMOP+0x34>
   12906:	24 c4       	rjmp	.+2120   	; 0x13150 <FMenuChangeMOP+0x87c>
   12908:	ec 53       	subi	r30, 0x3C	; 60
   1290a:	ff 4f       	sbci	r31, 0xFF	; 255
   1290c:	ee 0f       	add	r30, r30
   1290e:	ff 1f       	adc	r31, r31
   12910:	05 90       	lpm	r0, Z+
   12912:	f4 91       	lpm	r31, Z+
   12914:	e0 2d       	mov	r30, r0
   12916:	09 94       	ijmp
	 case cmInit:
	      MOPType=PAY_NONE;
   12918:	85 e0       	ldi	r24, 0x05	; 5
   1291a:	80 93 cf 01 	sts	0x01CF, r24
   1291e:	4e c1       	rjmp	.+668    	; 0x12bbc <FMenuChangeMOP+0x2e8>
		  stChangeMOP=cmDisplayMOPOption;
	      break;
	 case cmDisplayMOPOption: //12345678901234567890
	      lcd_clear();
   12920:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
	      lcd_printf(1,1,PSTR("   Select Payment   "));
   12924:	81 e0       	ldi	r24, 0x01	; 1
   12926:	61 e0       	ldi	r22, 0x01	; 1
   12928:	42 eb       	ldi	r20, 0xB2	; 178
   1292a:	59 e1       	ldi	r21, 0x19	; 25
   1292c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	      lcd_printf(2,1,PSTR("1.Account 3.Voucher "));
   12930:	82 e0       	ldi	r24, 0x02	; 2
   12932:	61 e0       	ldi	r22, 0x01	; 1
   12934:	4d e9       	ldi	r20, 0x9D	; 157
   12936:	59 e1       	ldi	r21, 0x19	; 25
   12938:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	      lcd_printf(3,1,PSTR("2.Bank    4.PumpTest"));
   1293c:	83 e0       	ldi	r24, 0x03	; 3
   1293e:	61 e0       	ldi	r22, 0x01	; 1
   12940:	48 e8       	ldi	r20, 0x88	; 136
   12942:	59 e1       	ldi	r21, 0x19	; 25
   12944:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
   12948:	84 e0       	ldi	r24, 0x04	; 4
   1294a:	61 e0       	ldi	r22, 0x01	; 1
   1294c:	43 e7       	ldi	r20, 0x73	; 115
   1294e:	59 e1       	ldi	r21, 0x19	; 25
   12950:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          stChangeMOP=cmInputMOP;		 
   12954:	82 e0       	ldi	r24, 0x02	; 2
   12956:	b5 c1       	rjmp	.+874    	; 0x12cc2 <FMenuChangeMOP+0x3ee>
		  break;
	 case cmInputMOP:
	      KeyPressed=_key_scan(1);
   12958:	81 e0       	ldi	r24, 0x01	; 1
   1295a:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   1295e:	80 93 42 03 	sts	0x0342, r24
		  KeyChar=_key_btn(KeyPressed);
   12962:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   12966:	98 2f       	mov	r25, r24
   12968:	80 93 43 03 	sts	0x0343, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   1296c:	81 53       	subi	r24, 0x31	; 49
   1296e:	84 30       	cpi	r24, 0x04	; 4
   12970:	f0 f4       	brcc	.+60     	; 0x129ae <FMenuChangeMOP+0xda>
              switch(KeyChar){
   12972:	92 33       	cpi	r25, 0x32	; 50
   12974:	61 f0       	breq	.+24     	; 0x1298e <FMenuChangeMOP+0xba>
   12976:	93 33       	cpi	r25, 0x33	; 51
   12978:	18 f4       	brcc	.+6      	; 0x12980 <FMenuChangeMOP+0xac>
   1297a:	91 33       	cpi	r25, 0x31	; 49
   1297c:	c1 f4       	brne	.+48     	; 0x129ae <FMenuChangeMOP+0xda>
   1297e:	05 c0       	rjmp	.+10     	; 0x1298a <FMenuChangeMOP+0xb6>
   12980:	93 33       	cpi	r25, 0x33	; 51
   12982:	51 f0       	breq	.+20     	; 0x12998 <FMenuChangeMOP+0xc4>
   12984:	94 33       	cpi	r25, 0x34	; 52
   12986:	99 f4       	brne	.+38     	; 0x129ae <FMenuChangeMOP+0xda>
   12988:	0c c0       	rjmp	.+24     	; 0x129a2 <FMenuChangeMOP+0xce>
		        case '1':MOPType=PAY_ACCOUNT; stChangeMOP=cmSelectFIP;         break;
   1298a:	81 e0       	ldi	r24, 0x01	; 1
   1298c:	0b c0       	rjmp	.+22     	; 0x129a4 <FMenuChangeMOP+0xd0>
		        case '2':MOPType=PAY_BANK;    stChangeMOP=cmSelectBankName;    break;
   1298e:	82 e0       	ldi	r24, 0x02	; 2
   12990:	80 93 cf 01 	sts	0x01CF, r24
   12994:	8b e0       	ldi	r24, 0x0B	; 11
   12996:	09 c0       	rjmp	.+18     	; 0x129aa <FMenuChangeMOP+0xd6>
		        case '3':MOPType=PAY_VOUCHER; stChangeMOP=cmDispInputVoucher;  break;
   12998:	83 e0       	ldi	r24, 0x03	; 3
   1299a:	80 93 cf 01 	sts	0x01CF, r24
   1299e:	8f e0       	ldi	r24, 0x0F	; 15
   129a0:	04 c0       	rjmp	.+8      	; 0x129aa <FMenuChangeMOP+0xd6>
		        case '4':MOPType=PAY_PUMPTEST;stChangeMOP=cmSelectFIP;         break;
   129a2:	84 e0       	ldi	r24, 0x04	; 4
   129a4:	80 93 cf 01 	sts	0x01CF, r24
   129a8:	89 e0       	ldi	r24, 0x09	; 9
   129aa:	80 93 47 03 	sts	0x0347, r24
		     }
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmExitChangeMOP;
   129ae:	80 91 42 03 	lds	r24, 0x0342
   129b2:	87 3e       	cpi	r24, 0xE7	; 231
   129b4:	09 f0       	breq	.+2      	; 0x129b8 <FMenuChangeMOP+0xe4>
   129b6:	cc c3       	rjmp	.+1944   	; 0x13150 <FMenuChangeMOP+0x87c>
   129b8:	c3 c3       	rjmp	.+1926   	; 0x13140 <FMenuChangeMOP+0x86c>
	      break;
	 case cmDispInputVoucher://Enter Voucher number
          lcd_clear();
   129ba:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("Kode Voucher"));
   129be:	81 e0       	ldi	r24, 0x01	; 1
   129c0:	61 e0       	ldi	r22, 0x01	; 1
   129c2:	46 e6       	ldi	r20, 0x66	; 102
   129c4:	59 e1       	ldi	r21, 0x19	; 25
   129c6:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   129ca:	82 e0       	ldi	r24, 0x02	; 2
   129cc:	61 e0       	ldi	r22, 0x01	; 1
   129ce:	44 e6       	ldi	r20, 0x64	; 100
   129d0:	59 e1       	ldi	r21, 0x19	; 25
   129d2:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   129d6:	84 e0       	ldi	r24, 0x04	; 4
   129d8:	61 e0       	ldi	r22, 0x01	; 1
   129da:	4f e4       	ldi	r20, 0x4F	; 79
   129dc:	59 e1       	ldi	r21, 0x19	; 25
   129de:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   129e2:	ef e8       	ldi	r30, 0x8F	; 143
   129e4:	ff e0       	ldi	r31, 0x0F	; 15
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   129e6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   129e8:	8f e0       	ldi	r24, 0x0F	; 15
   129ea:	e4 3a       	cpi	r30, 0xA4	; 164
   129ec:	f8 07       	cpc	r31, r24
   129ee:	d9 f7       	brne	.-10     	; 0x129e6 <FMenuChangeMOP+0x112>
          lcd_clear();
		  lcd_printf(1,1,PSTR("Kode Voucher"));
		  lcd_printf(2,1,PSTR("_"));
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
		  FillChar(strVoucherNum,sizeof(strVoucherNum),0);
          stChangeMOP=cmInputVoucher;
   129f0:	87 e0       	ldi	r24, 0x07	; 7
   129f2:	80 93 47 03 	sts	0x0347, r24
		  uiResult=USER_NONE;
   129f6:	10 92 33 03 	sts	0x0333, r1
   129fa:	aa c3       	rjmp	.+1876   	; 0x13150 <FMenuChangeMOP+0x87c>
	      break;
     case cmInputVoucher:
          uiResult=UserInput(UI_NUMBER_R,2,1,strVoucherNum,0,13);
   129fc:	81 e0       	ldi	r24, 0x01	; 1
   129fe:	62 e0       	ldi	r22, 0x02	; 2
   12a00:	41 e0       	ldi	r20, 0x01	; 1
   12a02:	2f e8       	ldi	r18, 0x8F	; 143
   12a04:	3f e0       	ldi	r19, 0x0F	; 15
   12a06:	00 e0       	ldi	r16, 0x00	; 0
   12a08:	10 e0       	ldi	r17, 0x00	; 0
   12a0a:	5d e0       	ldi	r21, 0x0D	; 13
   12a0c:	e5 2e       	mov	r14, r21
   12a0e:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
   12a12:	80 93 33 03 	sts	0x0333, r24
	      if (uiResult==USER_OK){
   12a16:	83 30       	cpi	r24, 0x03	; 3
   12a18:	11 f4       	brne	.+4      	; 0x12a1e <FMenuChangeMOP+0x14a>
		     stChangeMOP=cmSelectFIP;
   12a1a:	89 e0       	ldi	r24, 0x09	; 9
   12a1c:	52 c1       	rjmp	.+676    	; 0x12cc2 <FMenuChangeMOP+0x3ee>
			 }
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmDisplayMOPOption;
   12a1e:	81 30       	cpi	r24, 0x01	; 1
   12a20:	09 f4       	brne	.+2      	; 0x12a24 <FMenuChangeMOP+0x150>
   12a22:	4f c1       	rjmp	.+670    	; 0x12cc2 <FMenuChangeMOP+0x3ee>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12a24:	84 30       	cpi	r24, 0x04	; 4
   12a26:	21 f4       	brne	.+8      	; 0x12a30 <FMenuChangeMOP+0x15c>
   12a28:	61 e0       	ldi	r22, 0x01	; 1
   12a2a:	4a e3       	ldi	r20, 0x3A	; 58
   12a2c:	59 e1       	ldi	r21, 0x19	; 25
   12a2e:	31 c1       	rjmp	.+610    	; 0x12c92 <FMenuChangeMOP+0x3be>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12a30:	85 30       	cpi	r24, 0x05	; 5
   12a32:	09 f0       	breq	.+2      	; 0x12a36 <FMenuChangeMOP+0x162>
   12a34:	8d c3       	rjmp	.+1818   	; 0x13150 <FMenuChangeMOP+0x87c>
   12a36:	84 e0       	ldi	r24, 0x04	; 4
   12a38:	61 e0       	ldi	r22, 0x01	; 1
   12a3a:	45 e2       	ldi	r20, 0x25	; 37
   12a3c:	59 e1       	ldi	r21, 0x19	; 25
   12a3e:	29 c1       	rjmp	.+594    	; 0x12c92 <FMenuChangeMOP+0x3be>
	      break;
	 case cmSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   12a40:	81 e4       	ldi	r24, 0x41	; 65
   12a42:	93 e0       	ldi	r25, 0x03	; 3
   12a44:	66 e8       	ldi	r22, 0x86	; 134
   12a46:	79 e0       	ldi	r23, 0x09	; 9
   12a48:	0e 94 ed 64 	call	0xc9da	; 0xc9da <menu_FIP>
   12a4c:	80 93 46 03 	sts	0x0346, r24
		  if (FIPResult==FIP_DONE){
   12a50:	88 23       	and	r24, r24
   12a52:	11 f4       	brne	.+4      	; 0x12a58 <FMenuChangeMOP+0x184>
		      //sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
		      stChangeMOP=cmFlowFIP;
   12a54:	8e e0       	ldi	r24, 0x0E	; 14
   12a56:	35 c1       	rjmp	.+618    	; 0x12cc2 <FMenuChangeMOP+0x3ee>
		  }
		  else
		  if (FIPResult==FIP_CANCEL){
   12a58:	82 30       	cpi	r24, 0x02	; 2
   12a5a:	09 f0       	breq	.+2      	; 0x12a5e <FMenuChangeMOP+0x18a>
   12a5c:	79 c3       	rjmp	.+1778   	; 0x13150 <FMenuChangeMOP+0x87c>
		      if (MOPType==PAY_ACCOUNT)stChangeMOP=cmDisplayMOPOption;
   12a5e:	80 91 cf 01 	lds	r24, 0x01CF
   12a62:	81 30       	cpi	r24, 0x01	; 1
   12a64:	09 f4       	brne	.+2      	; 0x12a68 <FMenuChangeMOP+0x194>
   12a66:	2d c1       	rjmp	.+602    	; 0x12cc2 <FMenuChangeMOP+0x3ee>
		      if (MOPType==PAY_BANK)stChangeMOP=cmSelectBankName;
   12a68:	82 30       	cpi	r24, 0x02	; 2
   12a6a:	09 f4       	brne	.+2      	; 0x12a6e <FMenuChangeMOP+0x19a>
   12a6c:	03 c1       	rjmp	.+518    	; 0x12c74 <FMenuChangeMOP+0x3a0>
		      if (MOPType==PAY_VOUCHER)stChangeMOP=cmDispInputVoucher;
   12a6e:	83 30       	cpi	r24, 0x03	; 3
   12a70:	11 f4       	brne	.+4      	; 0x12a76 <FMenuChangeMOP+0x1a2>
   12a72:	8f e0       	ldi	r24, 0x0F	; 15
   12a74:	26 c1       	rjmp	.+588    	; 0x12cc2 <FMenuChangeMOP+0x3ee>
		      if (MOPType==PAY_PUMPTEST)stChangeMOP=cmDisplayMOPOption;		  
   12a76:	84 30       	cpi	r24, 0x04	; 4
   12a78:	09 f4       	brne	.+2      	; 0x12a7c <FMenuChangeMOP+0x1a8>
   12a7a:	a0 c0       	rjmp	.+320    	; 0x12bbc <FMenuChangeMOP+0x2e8>
   12a7c:	69 c3       	rjmp	.+1746   	; 0x13150 <FMenuChangeMOP+0x87c>
     case cmSelectFIPInput:
		
	      break;
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
   12a7e:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Bank"));
   12a82:	81 e0       	ldi	r24, 0x01	; 1
   12a84:	61 e0       	ldi	r22, 0x01	; 1
   12a86:	49 e1       	ldi	r20, 0x19	; 25
   12a88:	59 e1       	ldi	r21, 0x19	; 25
   12a8a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   12a8e:	10 92 36 03 	sts	0x0336, r1
   12a92:	10 92 35 03 	sts	0x0335, r1
   12a96:	8e 01       	movw	r16, r28
   12a98:	0b 5f       	subi	r16, 0xFB	; 251
   12a9a:	1f 4f       	sbci	r17, 0xFF	; 255
   12a9c:	9b e0       	ldi	r25, 0x0B	; 11
   12a9e:	a9 2e       	mov	r10, r25
   12aa0:	b1 2c       	mov	r11, r1
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   12aa2:	80 e1       	ldi	r24, 0x10	; 16
   12aa4:	e8 2e       	mov	r14, r24
   12aa6:	f1 2c       	mov	r15, r1
   12aa8:	ec 0e       	add	r14, r28
   12aaa:	fd 1e       	adc	r15, r29
   12aac:	b3 e1       	ldi	r27, 0x13	; 19
   12aae:	cb 2e       	mov	r12, r27
   12ab0:	b9 e1       	ldi	r27, 0x19	; 25
   12ab2:	db 2e       	mov	r13, r27
   12ab4:	5d c0       	rjmp	.+186    	; 0x12b70 <FMenuChangeMOP+0x29c>
   12ab6:	8a 9d       	mul	r24, r10
   12ab8:	b0 01       	movw	r22, r0
   12aba:	8b 9d       	mul	r24, r11
   12abc:	70 0d       	add	r23, r0
   12abe:	9a 9d       	mul	r25, r10
   12ac0:	70 0d       	add	r23, r0
   12ac2:	11 24       	eor	r1, r1
   12ac4:	67 5f       	subi	r22, 0xF7	; 247
   12ac6:	7e 4f       	sbci	r23, 0xFE	; 254
   12ac8:	c8 01       	movw	r24, r16
   12aca:	4b e0       	ldi	r20, 0x0B	; 11
   12acc:	50 e0       	ldi	r21, 0x00	; 0
   12ace:	28 ef       	ldi	r18, 0xF8	; 248
   12ad0:	32 e1       	ldi	r19, 0x12	; 18
   12ad2:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
   12ad6:	e0 e0       	ldi	r30, 0x00	; 0
   12ad8:	f0 e0       	ldi	r31, 0x00	; 0
   12ada:	0b 30       	cpi	r16, 0x0B	; 11
   12adc:	11 05       	cpc	r17, r1
   12ade:	10 f4       	brcc	.+4      	; 0x12ae4 <FMenuChangeMOP+0x210>
   12ae0:	e1 e0       	ldi	r30, 0x01	; 1
   12ae2:	f0 e0       	ldi	r31, 0x00	; 0
   12ae4:	80 81       	ld	r24, Z
   12ae6:	88 23       	and	r24, r24
   12ae8:	d1 f1       	breq	.+116    	; 0x12b5e <FMenuChangeMOP+0x28a>
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   12aea:	ad b7       	in	r26, 0x3d	; 61
   12aec:	be b7       	in	r27, 0x3e	; 62
   12aee:	18 97       	sbiw	r26, 0x08	; 8
   12af0:	0f b6       	in	r0, 0x3f	; 63
   12af2:	f8 94       	cli
   12af4:	be bf       	out	0x3e, r27	; 62
   12af6:	0f be       	out	0x3f, r0	; 63
   12af8:	ad bf       	out	0x3d, r26	; 61
   12afa:	ed b7       	in	r30, 0x3d	; 61
   12afc:	fe b7       	in	r31, 0x3e	; 62
   12afe:	31 96       	adiw	r30, 0x01	; 1
   12b00:	12 96       	adiw	r26, 0x02	; 2
   12b02:	fc 92       	st	X, r15
   12b04:	ee 92       	st	-X, r14
   12b06:	11 97       	sbiw	r26, 0x01	; 1
   12b08:	d3 82       	std	Z+3, r13	; 0x03
   12b0a:	c2 82       	std	Z+2, r12	; 0x02
   12b0c:	80 91 35 03 	lds	r24, 0x0335
   12b10:	90 91 36 03 	lds	r25, 0x0336
   12b14:	01 96       	adiw	r24, 0x01	; 1
   12b16:	95 83       	std	Z+5, r25	; 0x05
   12b18:	84 83       	std	Z+4, r24	; 0x04
   12b1a:	17 83       	std	Z+7, r17	; 0x07
   12b1c:	06 83       	std	Z+6, r16	; 0x06
   12b1e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
   12b22:	20 91 35 03 	lds	r18, 0x0335
   12b26:	30 91 36 03 	lds	r19, 0x0336
   12b2a:	ed b7       	in	r30, 0x3d	; 61
   12b2c:	fe b7       	in	r31, 0x3e	; 62
   12b2e:	38 96       	adiw	r30, 0x08	; 8
   12b30:	0f b6       	in	r0, 0x3f	; 63
   12b32:	f8 94       	cli
   12b34:	fe bf       	out	0x3e, r31	; 62
   12b36:	0f be       	out	0x3f, r0	; 63
   12b38:	ed bf       	out	0x3d, r30	; 61
   12b3a:	82 2f       	mov	r24, r18
   12b3c:	81 70       	andi	r24, 0x01	; 1
   12b3e:	36 95       	lsr	r19
   12b40:	27 95       	ror	r18
   12b42:	b9 01       	movw	r22, r18
   12b44:	66 0f       	add	r22, r22
   12b46:	77 1f       	adc	r23, r23
   12b48:	62 0f       	add	r22, r18
   12b4a:	73 1f       	adc	r23, r19
   12b4c:	66 0f       	add	r22, r22
   12b4e:	77 1f       	adc	r23, r23
   12b50:	66 0f       	add	r22, r22
   12b52:	77 1f       	adc	r23, r23
   12b54:	6f 5f       	subi	r22, 0xFF	; 255
   12b56:	8e 5f       	subi	r24, 0xFE	; 254
   12b58:	a7 01       	movw	r20, r14
   12b5a:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   12b5e:	80 91 35 03 	lds	r24, 0x0335
   12b62:	90 91 36 03 	lds	r25, 0x0336
   12b66:	01 96       	adiw	r24, 0x01	; 1
   12b68:	90 93 36 03 	sts	0x0336, r25
   12b6c:	80 93 35 03 	sts	0x0335, r24
   12b70:	80 91 35 03 	lds	r24, 0x0335
   12b74:	90 91 36 03 	lds	r25, 0x0336
   12b78:	84 30       	cpi	r24, 0x04	; 4
   12b7a:	91 05       	cpc	r25, r1
   12b7c:	08 f4       	brcc	.+2      	; 0x12b80 <FMenuChangeMOP+0x2ac>
   12b7e:	9b cf       	rjmp	.-202    	; 0x12ab6 <FMenuChangeMOP+0x1e2>
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
				 }
		  }
	      lcd_printf(4,1,PSTR("[*]Back"));
   12b80:	84 e0       	ldi	r24, 0x04	; 4
   12b82:	61 e0       	ldi	r22, 0x01	; 1
   12b84:	4b e0       	ldi	r20, 0x0B	; 11
   12b86:	59 e1       	ldi	r21, 0x19	; 25
   12b88:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  stChangeMOP=cmSelectBankNameInput;
   12b8c:	8c e0       	ldi	r24, 0x0C	; 12
   12b8e:	99 c0       	rjmp	.+306    	; 0x12cc2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmSelectBankNameInput:
		  KeyPressed=_key_scan(1);
   12b90:	81 e0       	ldi	r24, 0x01	; 1
   12b92:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   12b96:	80 93 42 03 	sts	0x0342, r24
		  KeyChar=_key_btn(KeyPressed);
   12b9a:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   12b9e:	80 93 43 03 	sts	0x0343, r24
          if ((KeyChar>='1')&&(KeyChar<='4')){
   12ba2:	81 53       	subi	r24, 0x31	; 49
   12ba4:	84 30       	cpi	r24, 0x04	; 4
   12ba6:	28 f4       	brcc	.+10     	; 0x12bb2 <FMenuChangeMOP+0x2de>
		      BankIdx=KeyChar-'1';
   12ba8:	80 93 34 03 	sts	0x0334, r24
			  stChangeMOP=cmSelectFIP;
   12bac:	89 e0       	ldi	r24, 0x09	; 9
   12bae:	80 93 47 03 	sts	0x0347, r24
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmDisplayMOPOption;
   12bb2:	80 91 42 03 	lds	r24, 0x0342
   12bb6:	87 3e       	cpi	r24, 0xE7	; 231
   12bb8:	09 f0       	breq	.+2      	; 0x12bbc <FMenuChangeMOP+0x2e8>
   12bba:	ca c2       	rjmp	.+1428   	; 0x13150 <FMenuChangeMOP+0x87c>
   12bbc:	81 e0       	ldi	r24, 0x01	; 1
   12bbe:	81 c0       	rjmp	.+258    	; 0x12cc2 <FMenuChangeMOP+0x3ee>

	      break;
     case cmDispBankSurcharge:
	      lcd_clear();
   12bc0:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
   12bc4:	65 e0       	ldi	r22, 0x05	; 5
   12bc6:	e6 2e       	mov	r14, r22
   12bc8:	f1 2c       	mov	r15, r1
   12bca:	ec 0e       	add	r14, r28
   12bcc:	fd 1e       	adc	r15, r29
   12bce:	60 91 34 03 	lds	r22, 0x0334
   12bd2:	8b e0       	ldi	r24, 0x0B	; 11
   12bd4:	68 9f       	mul	r22, r24
   12bd6:	b0 01       	movw	r22, r0
   12bd8:	11 24       	eor	r1, r1
   12bda:	67 5f       	subi	r22, 0xF7	; 247
   12bdc:	7e 4f       	sbci	r23, 0xFE	; 254
   12bde:	c7 01       	movw	r24, r14
   12be0:	4b e0       	ldi	r20, 0x0B	; 11
   12be2:	50 e0       	ldi	r21, 0x00	; 0
   12be4:	28 ef       	ldi	r18, 0xF8	; 248
   12be6:	32 e1       	ldi	r19, 0x12	; 18
   12be8:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
		  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		  sprintf_P(lcdteks,PSTR("%s"),strBankName);
   12bec:	00 d0       	rcall	.+0      	; 0x12bee <FMenuChangeMOP+0x31a>
   12bee:	00 d0       	rcall	.+0      	; 0x12bf0 <FMenuChangeMOP+0x31c>
   12bf0:	00 d0       	rcall	.+0      	; 0x12bf2 <FMenuChangeMOP+0x31e>
   12bf2:	ed b7       	in	r30, 0x3d	; 61
   12bf4:	fe b7       	in	r31, 0x3e	; 62
   12bf6:	31 96       	adiw	r30, 0x01	; 1
   12bf8:	8e 01       	movw	r16, r28
   12bfa:	00 5f       	subi	r16, 0xF0	; 240
   12bfc:	1f 4f       	sbci	r17, 0xFF	; 255
   12bfe:	ad b7       	in	r26, 0x3d	; 61
   12c00:	be b7       	in	r27, 0x3e	; 62
   12c02:	12 96       	adiw	r26, 0x02	; 2
   12c04:	1c 93       	st	X, r17
   12c06:	0e 93       	st	-X, r16
   12c08:	11 97       	sbiw	r26, 0x01	; 1
   12c0a:	88 e0       	ldi	r24, 0x08	; 8
   12c0c:	99 e1       	ldi	r25, 0x19	; 25
   12c0e:	93 83       	std	Z+3, r25	; 0x03
   12c10:	82 83       	std	Z+2, r24	; 0x02
   12c12:	f5 82       	std	Z+5, r15	; 0x05
   12c14:	e4 82       	std	Z+4, r14	; 0x04
   12c16:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   12c1a:	ed b7       	in	r30, 0x3d	; 61
   12c1c:	fe b7       	in	r31, 0x3e	; 62
   12c1e:	36 96       	adiw	r30, 0x06	; 6
   12c20:	0f b6       	in	r0, 0x3f	; 63
   12c22:	f8 94       	cli
   12c24:	fe bf       	out	0x3e, r31	; 62
   12c26:	0f be       	out	0x3f, r0	; 63
   12c28:	ed bf       	out	0x3d, r30	; 61
   12c2a:	81 e0       	ldi	r24, 0x01	; 1
   12c2c:	61 e0       	ldi	r22, 0x01	; 1
   12c2e:	a8 01       	movw	r20, r16
   12c30:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_printf(2,1,PSTR("Surcharge:   _%"));
   12c34:	82 e0       	ldi	r24, 0x02	; 2
   12c36:	61 e0       	ldi	r22, 0x01	; 1
   12c38:	48 ef       	ldi	r20, 0xF8	; 248
   12c3a:	58 e1       	ldi	r21, 0x18	; 24
   12c3c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12c40:	84 e0       	ldi	r24, 0x04	; 4
   12c42:	61 e0       	ldi	r22, 0x01	; 1
   12c44:	43 ee       	ldi	r20, 0xE3	; 227
   12c46:	58 e1       	ldi	r21, 0x18	; 24
   12c48:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          stChangeMOP=cmInputBankSurcharge;
   12c4c:	8d e0       	ldi	r24, 0x0D	; 13
   12c4e:	39 c0       	rjmp	.+114    	; 0x12cc2 <FMenuChangeMOP+0x3ee>
	      break;
	 case cmInputBankSurcharge:
	      uiResult=UserInput(UI_NUMBER_L,2,14,ValueChar,100,3);
   12c50:	82 e0       	ldi	r24, 0x02	; 2
   12c52:	62 e0       	ldi	r22, 0x02	; 2
   12c54:	4e e0       	ldi	r20, 0x0E	; 14
   12c56:	27 e3       	ldi	r18, 0x37	; 55
   12c58:	33 e0       	ldi	r19, 0x03	; 3
   12c5a:	04 e6       	ldi	r16, 0x64	; 100
   12c5c:	10 e0       	ldi	r17, 0x00	; 0
   12c5e:	53 e0       	ldi	r21, 0x03	; 3
   12c60:	e5 2e       	mov	r14, r21
   12c62:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
   12c66:	80 93 33 03 	sts	0x0333, r24
	      if (uiResult==USER_OK)stChangeMOP=cmGenerateData;
   12c6a:	83 30       	cpi	r24, 0x03	; 3
   12c6c:	09 f4       	brne	.+2      	; 0x12c70 <FMenuChangeMOP+0x39c>
   12c6e:	cb c0       	rjmp	.+406    	; 0x12e06 <FMenuChangeMOP+0x532>
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmSelectBankName;
   12c70:	81 30       	cpi	r24, 0x01	; 1
   12c72:	11 f4       	brne	.+4      	; 0x12c78 <FMenuChangeMOP+0x3a4>
   12c74:	8b e0       	ldi	r24, 0x0B	; 11
   12c76:	25 c0       	rjmp	.+74     	; 0x12cc2 <FMenuChangeMOP+0x3ee>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12c78:	84 30       	cpi	r24, 0x04	; 4
   12c7a:	21 f4       	brne	.+8      	; 0x12c84 <FMenuChangeMOP+0x3b0>
   12c7c:	61 e0       	ldi	r22, 0x01	; 1
   12c7e:	4e ec       	ldi	r20, 0xCE	; 206
   12c80:	58 e1       	ldi	r21, 0x18	; 24
   12c82:	07 c0       	rjmp	.+14     	; 0x12c92 <FMenuChangeMOP+0x3be>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12c84:	85 30       	cpi	r24, 0x05	; 5
   12c86:	09 f0       	breq	.+2      	; 0x12c8a <FMenuChangeMOP+0x3b6>
   12c88:	63 c2       	rjmp	.+1222   	; 0x13150 <FMenuChangeMOP+0x87c>
   12c8a:	84 e0       	ldi	r24, 0x04	; 4
   12c8c:	61 e0       	ldi	r22, 0x01	; 1
   12c8e:	49 eb       	ldi	r20, 0xB9	; 185
   12c90:	58 e1       	ldi	r21, 0x18	; 24
   12c92:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   12c96:	5c c2       	rjmp	.+1208   	; 0x13150 <FMenuChangeMOP+0x87c>
	      break;
     case cmFlowFIP:
          switch(MOPType){
   12c98:	80 91 cf 01 	lds	r24, 0x01CF
   12c9c:	82 30       	cpi	r24, 0x02	; 2
   12c9e:	61 f0       	breq	.+24     	; 0x12cb8 <FMenuChangeMOP+0x3e4>
   12ca0:	83 30       	cpi	r24, 0x03	; 3
   12ca2:	20 f4       	brcc	.+8      	; 0x12cac <FMenuChangeMOP+0x3d8>
   12ca4:	81 30       	cpi	r24, 0x01	; 1
   12ca6:	09 f0       	breq	.+2      	; 0x12caa <FMenuChangeMOP+0x3d6>
   12ca8:	53 c2       	rjmp	.+1190   	; 0x13150 <FMenuChangeMOP+0x87c>
   12caa:	0a c0       	rjmp	.+20     	; 0x12cc0 <FMenuChangeMOP+0x3ec>
   12cac:	83 30       	cpi	r24, 0x03	; 3
   12cae:	31 f0       	breq	.+12     	; 0x12cbc <FMenuChangeMOP+0x3e8>
   12cb0:	84 30       	cpi	r24, 0x04	; 4
   12cb2:	09 f0       	breq	.+2      	; 0x12cb6 <FMenuChangeMOP+0x3e2>
   12cb4:	4d c2       	rjmp	.+1178   	; 0x13150 <FMenuChangeMOP+0x87c>
   12cb6:	04 c0       	rjmp	.+8      	; 0x12cc0 <FMenuChangeMOP+0x3ec>
		  case PAY_ACCOUNT: stChangeMOP=cmDispCardTap;       break;
		  case PAY_BANK:    stChangeMOP=cmDispBankSurcharge; break;
   12cb8:	81 e1       	ldi	r24, 0x11	; 17
   12cba:	03 c0       	rjmp	.+6      	; 0x12cc2 <FMenuChangeMOP+0x3ee>
		  case PAY_VOUCHER: stChangeMOP=cmProsesVoucher;      break;
   12cbc:	85 e1       	ldi	r24, 0x15	; 21
   12cbe:	01 c0       	rjmp	.+2      	; 0x12cc2 <FMenuChangeMOP+0x3ee>
		  case PAY_PUMPTEST:stChangeMOP=cmDispCardTap;       break;
   12cc0:	82 e1       	ldi	r24, 0x12	; 18
   12cc2:	80 93 47 03 	sts	0x0347, r24
   12cc6:	44 c2       	rjmp	.+1160   	; 0x13150 <FMenuChangeMOP+0x87c>
		  }
	      break;
     case cmDispCardTap:
	      lcd_clear();
   12cc8:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
	      lcd_printf(1,1,PSTR("Tap Kartu RFID"));
   12ccc:	81 e0       	ldi	r24, 0x01	; 1
   12cce:	61 e0       	ldi	r22, 0x01	; 1
   12cd0:	4a ea       	ldi	r20, 0xAA	; 170
   12cd2:	58 e1       	ldi	r21, 0x18	; 24
   12cd4:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  sprintf_P(lcdteks,PSTR("FIP%s"),strFIP_ID);
   12cd8:	00 d0       	rcall	.+0      	; 0x12cda <FMenuChangeMOP+0x406>
   12cda:	00 d0       	rcall	.+0      	; 0x12cdc <FMenuChangeMOP+0x408>
   12cdc:	00 d0       	rcall	.+0      	; 0x12cde <FMenuChangeMOP+0x40a>
   12cde:	ed b7       	in	r30, 0x3d	; 61
   12ce0:	fe b7       	in	r31, 0x3e	; 62
   12ce2:	31 96       	adiw	r30, 0x01	; 1
   12ce4:	8e 01       	movw	r16, r28
   12ce6:	00 5f       	subi	r16, 0xF0	; 240
   12ce8:	1f 4f       	sbci	r17, 0xFF	; 255
   12cea:	ad b7       	in	r26, 0x3d	; 61
   12cec:	be b7       	in	r27, 0x3e	; 62
   12cee:	12 96       	adiw	r26, 0x02	; 2
   12cf0:	1c 93       	st	X, r17
   12cf2:	0e 93       	st	-X, r16
   12cf4:	11 97       	sbiw	r26, 0x01	; 1
   12cf6:	84 ea       	ldi	r24, 0xA4	; 164
   12cf8:	98 e1       	ldi	r25, 0x18	; 24
   12cfa:	93 83       	std	Z+3, r25	; 0x03
   12cfc:	82 83       	std	Z+2, r24	; 0x02
   12cfe:	86 e8       	ldi	r24, 0x86	; 134
   12d00:	99 e0       	ldi	r25, 0x09	; 9
   12d02:	95 83       	std	Z+5, r25	; 0x05
   12d04:	84 83       	std	Z+4, r24	; 0x04
   12d06:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   12d0a:	ed b7       	in	r30, 0x3d	; 61
   12d0c:	fe b7       	in	r31, 0x3e	; 62
   12d0e:	36 96       	adiw	r30, 0x06	; 6
   12d10:	0f b6       	in	r0, 0x3f	; 63
   12d12:	f8 94       	cli
   12d14:	fe bf       	out	0x3e, r31	; 62
   12d16:	0f be       	out	0x3f, r0	; 63
   12d18:	ed bf       	out	0x3d, r30	; 61
   12d1a:	82 e0       	ldi	r24, 0x02	; 2
   12d1c:	61 e0       	ldi	r22, 0x01	; 1
   12d1e:	a8 01       	movw	r20, r16
   12d20:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
   12d24:	84 e0       	ldi	r24, 0x04	; 4
   12d26:	61 e0       	ldi	r22, 0x01	; 1
   12d28:	41 e9       	ldi	r20, 0x91	; 145
   12d2a:	58 e1       	ldi	r21, 0x18	; 24
   12d2c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  IsRFIDDetected=False;
   12d30:	10 92 af 01 	sts	0x01AF, r1
          stChangeMOP=cmRFIDCardInput;
   12d34:	83 e1       	ldi	r24, 0x13	; 19
   12d36:	c5 cf       	rjmp	.-118    	; 0x12cc2 <FMenuChangeMOP+0x3ee>
	      break;
	 case cmRFIDCardInput:
		  KeyPressed=_key_scan(1);
   12d38:	81 e0       	ldi	r24, 0x01	; 1
   12d3a:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   12d3e:	80 93 42 03 	sts	0x0342, r24
		  KeyChar=_key_btn(KeyPressed);
   12d42:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   12d46:	80 93 43 03 	sts	0x0343, r24
		  if (KeyPressed==_KEY_ENTER){
   12d4a:	80 91 42 03 	lds	r24, 0x0342
   12d4e:	87 3b       	cpi	r24, 0xB7	; 183
   12d50:	11 f4       	brne	.+4      	; 0x12d56 <FMenuChangeMOP+0x482>
		      stChangeMOP=cmExitChangeMOP;
   12d52:	8c e1       	ldi	r24, 0x1C	; 28
   12d54:	03 c0       	rjmp	.+6      	; 0x12d5c <FMenuChangeMOP+0x488>
		  }
		  else
		  if (KeyPressed==_KEY_CANCEL){
   12d56:	87 3e       	cpi	r24, 0xE7	; 231
   12d58:	19 f4       	brne	.+6      	; 0x12d60 <FMenuChangeMOP+0x48c>
   		      stChangeMOP=cmSelectFIP;
   12d5a:	89 e0       	ldi	r24, 0x09	; 9
   12d5c:	80 93 47 03 	sts	0x0347, r24
			 }
          if (IsRFIDDetected==True){
   12d60:	80 91 af 01 	lds	r24, 0x01AF
   12d64:	81 30       	cpi	r24, 0x01	; 1
   12d66:	09 f0       	breq	.+2      	; 0x12d6a <FMenuChangeMOP+0x496>
   12d68:	f3 c1       	rjmp	.+998    	; 0x13150 <FMenuChangeMOP+0x87c>
		      IsRFIDDetected=False;
   12d6a:	10 92 af 01 	sts	0x01AF, r1
			   stChangeMOP=cmProsesRFID;
   12d6e:	84 e1       	ldi	r24, 0x14	; 20
   12d70:	a8 cf       	rjmp	.-176    	; 0x12cc2 <FMenuChangeMOP+0x3ee>
   12d72:	20 e0       	ldi	r18, 0x00	; 0
   12d74:	30 e0       	ldi	r19, 0x00	; 0
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   12d76:	f9 01       	movw	r30, r18
   12d78:	e1 51       	subi	r30, 0x11	; 17
   12d7a:	f1 4f       	sbci	r31, 0xF1	; 241
   12d7c:	d9 01       	movw	r26, r18
   12d7e:	ac 55       	subi	r26, 0x5C	; 92
   12d80:	b0 4f       	sbci	r27, 0xF0	; 240
   12d82:	8c 91       	ld	r24, X
   12d84:	80 83       	st	Z, r24
   12d86:	2f 5f       	subi	r18, 0xFF	; 255
   12d88:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   12d8a:	28 30       	cpi	r18, 0x08	; 8
   12d8c:	31 05       	cpc	r19, r1
   12d8e:	99 f7       	brne	.-26     	; 0x12d76 <FMenuChangeMOP+0x4a2>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   12d90:	10 92 f7 0e 	sts	0x0EF7, r1
			   stChangeMOP=cmProsesRFID;
			 }
	      break;
     case cmProsesRFID:
	      ViewCardID();
          sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   12d94:	00 d0       	rcall	.+0      	; 0x12d96 <FMenuChangeMOP+0x4c2>
   12d96:	00 d0       	rcall	.+0      	; 0x12d98 <FMenuChangeMOP+0x4c4>
   12d98:	00 d0       	rcall	.+0      	; 0x12d9a <FMenuChangeMOP+0x4c6>
   12d9a:	ed b7       	in	r30, 0x3d	; 61
   12d9c:	fe b7       	in	r31, 0x3e	; 62
   12d9e:	31 96       	adiw	r30, 0x01	; 1
   12da0:	8e 01       	movw	r16, r28
   12da2:	00 5f       	subi	r16, 0xF0	; 240
   12da4:	1f 4f       	sbci	r17, 0xFF	; 255
   12da6:	ad b7       	in	r26, 0x3d	; 61
   12da8:	be b7       	in	r27, 0x3e	; 62
   12daa:	12 96       	adiw	r26, 0x02	; 2
   12dac:	1c 93       	st	X, r17
   12dae:	0e 93       	st	-X, r16
   12db0:	11 97       	sbiw	r26, 0x01	; 1
   12db2:	8b e8       	ldi	r24, 0x8B	; 139
   12db4:	98 e1       	ldi	r25, 0x18	; 24
   12db6:	93 83       	std	Z+3, r25	; 0x03
   12db8:	82 83       	std	Z+2, r24	; 0x02
   12dba:	8f ee       	ldi	r24, 0xEF	; 239
   12dbc:	9e e0       	ldi	r25, 0x0E	; 14
   12dbe:	95 83       	std	Z+5, r25	; 0x05
   12dc0:	84 83       	std	Z+4, r24	; 0x04
   12dc2:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   12dc6:	ed b7       	in	r30, 0x3d	; 61
   12dc8:	fe b7       	in	r31, 0x3e	; 62
   12dca:	36 96       	adiw	r30, 0x06	; 6
   12dcc:	0f b6       	in	r0, 0x3f	; 63
   12dce:	f8 94       	cli
   12dd0:	fe bf       	out	0x3e, r31	; 62
   12dd2:	0f be       	out	0x3f, r0	; 63
   12dd4:	ed bf       	out	0x3d, r30	; 61
   12dd6:	82 e0       	ldi	r24, 0x02	; 2
   12dd8:	61 e0       	ldi	r22, 0x01	; 1
   12dda:	a8 01       	movw	r20, r16
   12ddc:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
          lcd_printf(3,1,PSTR("Proses"));
   12de0:	83 e0       	ldi	r24, 0x03	; 3
   12de2:	61 e0       	ldi	r22, 0x01	; 1
   12de4:	44 e8       	ldi	r20, 0x84	; 132
   12de6:	58 e1       	ldi	r21, 0x18	; 24
   12de8:	0c c0       	rjmp	.+24     	; 0x12e02 <FMenuChangeMOP+0x52e>
		  stChangeMOP=cmGenerateData;
	      break;
     case cmProsesVoucher:
          lcd_clear();
   12dea:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
          lcd_printf(1,1,PSTR("-MOP Voucher-")); 
   12dee:	81 e0       	ldi	r24, 0x01	; 1
   12df0:	61 e0       	ldi	r22, 0x01	; 1
   12df2:	46 e7       	ldi	r20, 0x76	; 118
   12df4:	58 e1       	ldi	r21, 0x18	; 24
   12df6:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
          lcd_printf(3,1,PSTR("Proses"));
   12dfa:	83 e0       	ldi	r24, 0x03	; 3
   12dfc:	61 e0       	ldi	r22, 0x01	; 1
   12dfe:	4f e6       	ldi	r20, 0x6F	; 111
   12e00:	58 e1       	ldi	r21, 0x18	; 24
   12e02:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  stChangeMOP=cmGenerateData;
   12e06:	86 e1       	ldi	r24, 0x16	; 22
   12e08:	5c cf       	rjmp	.-328    	; 0x12cc2 <FMenuChangeMOP+0x3ee>
	      break;
   12e0a:	e0 ee       	ldi	r30, 0xE0	; 224
   12e0c:	ff e0       	ldi	r31, 0x0F	; 15
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   12e0e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12e10:	8f e0       	ldi	r24, 0x0F	; 15
   12e12:	e5 3f       	cpi	r30, 0xF5	; 245
   12e14:	f8 07       	cpc	r31, r24
   12e16:	d9 f7       	brne	.-10     	; 0x12e0e <FMenuChangeMOP+0x53a>
   12e18:	e4 e0       	ldi	r30, 0x04	; 4
   12e1a:	ff e0       	ldi	r31, 0x0F	; 15
	     strMemory[i]=data;
   12e1c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12e1e:	9f e0       	ldi	r25, 0x0F	; 15
   12e20:	e9 31       	cpi	r30, 0x19	; 25
   12e22:	f9 07       	cpc	r31, r25
   12e24:	d9 f7       	brne	.-10     	; 0x12e1c <FMenuChangeMOP+0x548>
   12e26:	e6 e2       	ldi	r30, 0x26	; 38
   12e28:	fc e0       	ldi	r31, 0x0C	; 12
	     strMemory[i]=data;
   12e2a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12e2c:	ac e0       	ldi	r26, 0x0C	; 12
   12e2e:	eb 33       	cpi	r30, 0x3B	; 59
   12e30:	fa 07       	cpc	r31, r26
   12e32:	d9 f7       	brne	.-10     	; 0x12e2a <FMenuChangeMOP+0x556>
   12e34:	25 e8       	ldi	r18, 0x85	; 133
   12e36:	e2 2e       	mov	r14, r18
   12e38:	25 e0       	ldi	r18, 0x05	; 5
   12e3a:	f2 2e       	mov	r15, r18
	     strMemory[i]=data;
   12e3c:	f7 01       	movw	r30, r14
   12e3e:	11 92       	st	Z+, r1
   12e40:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12e42:	fa e9       	ldi	r31, 0x9A	; 154
   12e44:	ef 16       	cp	r14, r31
   12e46:	f5 e0       	ldi	r31, 0x05	; 5
   12e48:	ff 06       	cpc	r15, r31
   12e4a:	c1 f7       	brne	.-16     	; 0x12e3c <FMenuChangeMOP+0x568>
     case cmGenerateData:
	      FillChar(strRef1,sizeof(strRef1),0);
	      FillChar(strRef2,sizeof(strRef2),0);
	      FillChar(strRef3,sizeof(strRef3),0);
	      FillChar(strRef4,sizeof(strRef4),0);
          switch(MOPType){
   12e4c:	80 91 cf 01 	lds	r24, 0x01CF
   12e50:	82 30       	cpi	r24, 0x02	; 2
   12e52:	f1 f0       	breq	.+60     	; 0x12e90 <FMenuChangeMOP+0x5bc>
   12e54:	83 30       	cpi	r24, 0x03	; 3
   12e56:	20 f4       	brcc	.+8      	; 0x12e60 <FMenuChangeMOP+0x58c>
   12e58:	81 30       	cpi	r24, 0x01	; 1
   12e5a:	09 f0       	breq	.+2      	; 0x12e5e <FMenuChangeMOP+0x58a>
   12e5c:	ad c0       	rjmp	.+346    	; 0x12fb8 <FMenuChangeMOP+0x6e4>
   12e5e:	07 c0       	rjmp	.+14     	; 0x12e6e <FMenuChangeMOP+0x59a>
   12e60:	83 30       	cpi	r24, 0x03	; 3
   12e62:	09 f4       	brne	.+2      	; 0x12e66 <FMenuChangeMOP+0x592>
   12e64:	64 c0       	rjmp	.+200    	; 0x12f2e <FMenuChangeMOP+0x65a>
   12e66:	84 30       	cpi	r24, 0x04	; 4
   12e68:	09 f0       	breq	.+2      	; 0x12e6c <FMenuChangeMOP+0x598>
   12e6a:	a6 c0       	rjmp	.+332    	; 0x12fb8 <FMenuChangeMOP+0x6e4>
   12e6c:	75 c0       	rjmp	.+234    	; 0x12f58 <FMenuChangeMOP+0x684>
		  case PAY_ACCOUNT:
		       sprintf_P(strRef1,PSTR("%s"),strCardID); 
   12e6e:	00 d0       	rcall	.+0      	; 0x12e70 <FMenuChangeMOP+0x59c>
   12e70:	00 d0       	rcall	.+0      	; 0x12e72 <FMenuChangeMOP+0x59e>
   12e72:	00 d0       	rcall	.+0      	; 0x12e74 <FMenuChangeMOP+0x5a0>
   12e74:	ed b7       	in	r30, 0x3d	; 61
   12e76:	fe b7       	in	r31, 0x3e	; 62
   12e78:	31 96       	adiw	r30, 0x01	; 1
   12e7a:	80 ee       	ldi	r24, 0xE0	; 224
   12e7c:	9f e0       	ldi	r25, 0x0F	; 15
   12e7e:	ad b7       	in	r26, 0x3d	; 61
   12e80:	be b7       	in	r27, 0x3e	; 62
   12e82:	12 96       	adiw	r26, 0x02	; 2
   12e84:	9c 93       	st	X, r25
   12e86:	8e 93       	st	-X, r24
   12e88:	11 97       	sbiw	r26, 0x01	; 1
   12e8a:	8c e6       	ldi	r24, 0x6C	; 108
   12e8c:	98 e1       	ldi	r25, 0x18	; 24
   12e8e:	84 c0       	rjmp	.+264    	; 0x12f98 <FMenuChangeMOP+0x6c4>
   12e90:	8e 01       	movw	r16, r28
   12e92:	0b 5f       	subi	r16, 0xFB	; 251
   12e94:	1f 4f       	sbci	r17, 0xFF	; 255
   12e96:	60 91 34 03 	lds	r22, 0x0334
   12e9a:	8b e0       	ldi	r24, 0x0B	; 11
   12e9c:	68 9f       	mul	r22, r24
   12e9e:	b0 01       	movw	r22, r0
   12ea0:	11 24       	eor	r1, r1
   12ea2:	67 5f       	subi	r22, 0xF7	; 247
   12ea4:	7e 4f       	sbci	r23, 0xFE	; 254
   12ea6:	c8 01       	movw	r24, r16
   12ea8:	4b e0       	ldi	r20, 0x0B	; 11
   12eaa:	50 e0       	ldi	r21, 0x00	; 0
   12eac:	28 ef       	ldi	r18, 0xF8	; 248
   12eae:	32 e1       	ldi	r19, 0x12	; 18
   12eb0:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
		       break;
		  case PAY_BANK:
		  	   eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		       sprintf_P(lcdteks,PSTR("%s"),strBankName);
   12eb4:	00 d0       	rcall	.+0      	; 0x12eb6 <FMenuChangeMOP+0x5e2>
   12eb6:	00 d0       	rcall	.+0      	; 0x12eb8 <FMenuChangeMOP+0x5e4>
   12eb8:	00 d0       	rcall	.+0      	; 0x12eba <FMenuChangeMOP+0x5e6>
   12eba:	ed b7       	in	r30, 0x3d	; 61
   12ebc:	fe b7       	in	r31, 0x3e	; 62
   12ebe:	31 96       	adiw	r30, 0x01	; 1
   12ec0:	ce 01       	movw	r24, r28
   12ec2:	40 96       	adiw	r24, 0x10	; 16
   12ec4:	ad b7       	in	r26, 0x3d	; 61
   12ec6:	be b7       	in	r27, 0x3e	; 62
   12ec8:	12 96       	adiw	r26, 0x02	; 2
   12eca:	9c 93       	st	X, r25
   12ecc:	8e 93       	st	-X, r24
   12ece:	11 97       	sbiw	r26, 0x01	; 1
   12ed0:	89 e6       	ldi	r24, 0x69	; 105
   12ed2:	98 e1       	ldi	r25, 0x18	; 24
   12ed4:	93 83       	std	Z+3, r25	; 0x03
   12ed6:	82 83       	std	Z+2, r24	; 0x02
   12ed8:	15 83       	std	Z+5, r17	; 0x05
   12eda:	04 83       	std	Z+4, r16	; 0x04
   12edc:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		       sprintf_P(strRef1,PSTR("%s"),strBankName); 
   12ee0:	ed b7       	in	r30, 0x3d	; 61
   12ee2:	fe b7       	in	r31, 0x3e	; 62
   12ee4:	31 96       	adiw	r30, 0x01	; 1
   12ee6:	80 ee       	ldi	r24, 0xE0	; 224
   12ee8:	9f e0       	ldi	r25, 0x0F	; 15
   12eea:	ad b7       	in	r26, 0x3d	; 61
   12eec:	be b7       	in	r27, 0x3e	; 62
   12eee:	12 96       	adiw	r26, 0x02	; 2
   12ef0:	9c 93       	st	X, r25
   12ef2:	8e 93       	st	-X, r24
   12ef4:	11 97       	sbiw	r26, 0x01	; 1
   12ef6:	86 e6       	ldi	r24, 0x66	; 102
   12ef8:	98 e1       	ldi	r25, 0x18	; 24
   12efa:	93 83       	std	Z+3, r25	; 0x03
   12efc:	82 83       	std	Z+2, r24	; 0x02
   12efe:	15 83       	std	Z+5, r17	; 0x05
   12f00:	04 83       	std	Z+4, r16	; 0x04
   12f02:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		       sprintf_P(strRef4,PSTR("%s"),strSurcharge); 
   12f06:	ed b7       	in	r30, 0x3d	; 61
   12f08:	fe b7       	in	r31, 0x3e	; 62
   12f0a:	31 96       	adiw	r30, 0x01	; 1
   12f0c:	8b ee       	ldi	r24, 0xEB	; 235
   12f0e:	9f ef       	ldi	r25, 0xFF	; 255
   12f10:	e8 0e       	add	r14, r24
   12f12:	f9 1e       	adc	r15, r25
   12f14:	ad b7       	in	r26, 0x3d	; 61
   12f16:	be b7       	in	r27, 0x3e	; 62
   12f18:	12 96       	adiw	r26, 0x02	; 2
   12f1a:	fc 92       	st	X, r15
   12f1c:	ee 92       	st	-X, r14
   12f1e:	11 97       	sbiw	r26, 0x01	; 1
   12f20:	83 e6       	ldi	r24, 0x63	; 99
   12f22:	98 e1       	ldi	r25, 0x18	; 24
   12f24:	93 83       	std	Z+3, r25	; 0x03
   12f26:	82 83       	std	Z+2, r24	; 0x02
   12f28:	ce 01       	movw	r24, r28
   12f2a:	01 96       	adiw	r24, 0x01	; 1
   12f2c:	39 c0       	rjmp	.+114    	; 0x12fa0 <FMenuChangeMOP+0x6cc>
		       break;
		  case PAY_VOUCHER://Load data Ref1=Voucher on cmVoucherInput
		  	   sprintf_P(strRef1,PSTR("%s"),strVoucherNum); 
   12f2e:	00 d0       	rcall	.+0      	; 0x12f30 <FMenuChangeMOP+0x65c>
   12f30:	00 d0       	rcall	.+0      	; 0x12f32 <FMenuChangeMOP+0x65e>
   12f32:	00 d0       	rcall	.+0      	; 0x12f34 <FMenuChangeMOP+0x660>
   12f34:	ed b7       	in	r30, 0x3d	; 61
   12f36:	fe b7       	in	r31, 0x3e	; 62
   12f38:	31 96       	adiw	r30, 0x01	; 1
   12f3a:	80 ee       	ldi	r24, 0xE0	; 224
   12f3c:	9f e0       	ldi	r25, 0x0F	; 15
   12f3e:	ad b7       	in	r26, 0x3d	; 61
   12f40:	be b7       	in	r27, 0x3e	; 62
   12f42:	12 96       	adiw	r26, 0x02	; 2
   12f44:	9c 93       	st	X, r25
   12f46:	8e 93       	st	-X, r24
   12f48:	11 97       	sbiw	r26, 0x01	; 1
   12f4a:	80 e6       	ldi	r24, 0x60	; 96
   12f4c:	98 e1       	ldi	r25, 0x18	; 24
   12f4e:	93 83       	std	Z+3, r25	; 0x03
   12f50:	82 83       	std	Z+2, r24	; 0x02
   12f52:	8f e8       	ldi	r24, 0x8F	; 143
   12f54:	9f e0       	ldi	r25, 0x0F	; 15
   12f56:	24 c0       	rjmp	.+72     	; 0x12fa0 <FMenuChangeMOP+0x6cc>
		       break;
		  case PAY_PUMPTEST:
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
   12f58:	00 d0       	rcall	.+0      	; 0x12f5a <FMenuChangeMOP+0x686>
   12f5a:	00 d0       	rcall	.+0      	; 0x12f5c <FMenuChangeMOP+0x688>
   12f5c:	80 ee       	ldi	r24, 0xE0	; 224
   12f5e:	9f e0       	ldi	r25, 0x0F	; 15
   12f60:	ad b7       	in	r26, 0x3d	; 61
   12f62:	be b7       	in	r27, 0x3e	; 62
   12f64:	12 96       	adiw	r26, 0x02	; 2
   12f66:	9c 93       	st	X, r25
   12f68:	8e 93       	st	-X, r24
   12f6a:	11 97       	sbiw	r26, 0x01	; 1
   12f6c:	86 e5       	ldi	r24, 0x56	; 86
   12f6e:	98 e1       	ldi	r25, 0x18	; 24
   12f70:	14 96       	adiw	r26, 0x04	; 4
   12f72:	9c 93       	st	X, r25
   12f74:	8e 93       	st	-X, r24
   12f76:	13 97       	sbiw	r26, 0x03	; 3
   12f78:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
   12f7c:	00 d0       	rcall	.+0      	; 0x12f7e <FMenuChangeMOP+0x6aa>
   12f7e:	ed b7       	in	r30, 0x3d	; 61
   12f80:	fe b7       	in	r31, 0x3e	; 62
   12f82:	31 96       	adiw	r30, 0x01	; 1
   12f84:	84 e0       	ldi	r24, 0x04	; 4
   12f86:	9f e0       	ldi	r25, 0x0F	; 15
   12f88:	ad b7       	in	r26, 0x3d	; 61
   12f8a:	be b7       	in	r27, 0x3e	; 62
   12f8c:	12 96       	adiw	r26, 0x02	; 2
   12f8e:	9c 93       	st	X, r25
   12f90:	8e 93       	st	-X, r24
   12f92:	11 97       	sbiw	r26, 0x01	; 1
   12f94:	83 e5       	ldi	r24, 0x53	; 83
   12f96:	98 e1       	ldi	r25, 0x18	; 24
   12f98:	93 83       	std	Z+3, r25	; 0x03
   12f9a:	82 83       	std	Z+2, r24	; 0x02
   12f9c:	8f ee       	ldi	r24, 0xEF	; 239
   12f9e:	9e e0       	ldi	r25, 0x0E	; 14
   12fa0:	95 83       	std	Z+5, r25	; 0x05
   12fa2:	84 83       	std	Z+4, r24	; 0x04
   12fa4:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   12fa8:	ed b7       	in	r30, 0x3d	; 61
   12faa:	fe b7       	in	r31, 0x3e	; 62
   12fac:	36 96       	adiw	r30, 0x06	; 6
   12fae:	0f b6       	in	r0, 0x3f	; 63
   12fb0:	f8 94       	cli
   12fb2:	fe bf       	out	0x3e, r31	; 62
   12fb4:	0f be       	out	0x3f, r0	; 63
   12fb6:	ed bf       	out	0x3d, r30	; 61
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
   12fb8:	00 d0       	rcall	.+0      	; 0x12fba <FMenuChangeMOP+0x6e6>
   12fba:	00 d0       	rcall	.+0      	; 0x12fbc <FMenuChangeMOP+0x6e8>
   12fbc:	00 d0       	rcall	.+0      	; 0x12fbe <FMenuChangeMOP+0x6ea>
   12fbe:	ed b7       	in	r30, 0x3d	; 61
   12fc0:	fe b7       	in	r31, 0x3e	; 62
   12fc2:	31 96       	adiw	r30, 0x01	; 1
   12fc4:	83 e3       	ldi	r24, 0x33	; 51
   12fc6:	99 e0       	ldi	r25, 0x09	; 9
   12fc8:	ad b7       	in	r26, 0x3d	; 61
   12fca:	be b7       	in	r27, 0x3e	; 62
   12fcc:	12 96       	adiw	r26, 0x02	; 2
   12fce:	9c 93       	st	X, r25
   12fd0:	8e 93       	st	-X, r24
   12fd2:	11 97       	sbiw	r26, 0x01	; 1
   12fd4:	8d e5       	ldi	r24, 0x5D	; 93
   12fd6:	9d e0       	ldi	r25, 0x0D	; 13
   12fd8:	93 83       	std	Z+3, r25	; 0x03
   12fda:	82 83       	std	Z+2, r24	; 0x02
   12fdc:	80 91 cf 01 	lds	r24, 0x01CF
   12fe0:	84 83       	std	Z+4, r24	; 0x04
   12fe2:	15 82       	std	Z+5, r1	; 0x05
   12fe4:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
		       break;
		  }
		  leadingZero(MOPType,strPaymentType);
		  AddSpaceLead(strRef1,20);
   12fe8:	ed b7       	in	r30, 0x3d	; 61
   12fea:	fe b7       	in	r31, 0x3e	; 62
   12fec:	36 96       	adiw	r30, 0x06	; 6
   12fee:	0f b6       	in	r0, 0x3f	; 63
   12ff0:	f8 94       	cli
   12ff2:	fe bf       	out	0x3e, r31	; 62
   12ff4:	0f be       	out	0x3f, r0	; 63
   12ff6:	ed bf       	out	0x3d, r30	; 61
   12ff8:	80 ee       	ldi	r24, 0xE0	; 224
   12ffa:	9f e0       	ldi	r25, 0x0F	; 15
   12ffc:	64 e1       	ldi	r22, 0x14	; 20
   12ffe:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <AddSpaceLead>
		  AddSpaceLead(strRef2,20);
   13002:	84 e0       	ldi	r24, 0x04	; 4
   13004:	9f e0       	ldi	r25, 0x0F	; 15
   13006:	64 e1       	ldi	r22, 0x14	; 20
   13008:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <AddSpaceLead>
		  AddSpaceLead(strRef3,20);
   1300c:	86 e2       	ldi	r24, 0x26	; 38
   1300e:	9c e0       	ldi	r25, 0x0C	; 12
   13010:	64 e1       	ldi	r22, 0x14	; 20
   13012:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <AddSpaceLead>
		  AddSpaceLead(strRef4,20);
   13016:	85 e8       	ldi	r24, 0x85	; 133
   13018:	95 e0       	ldi	r25, 0x05	; 5
   1301a:	64 e1       	ldi	r22, 0x14	; 20
   1301c:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <AddSpaceLead>
		  iWait=0;
   13020:	10 92 44 03 	sts	0x0344, r1
		  IsMessage09=False;
   13024:	10 92 ba 01 	sts	0x01BA, r1
		  stChangeMOP=cmSendMessage32;	      
   13028:	87 e1       	ldi	r24, 0x17	; 23
   1302a:	4b ce       	rjmp	.-874    	; 0x12cc2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmSendMessage32://SendMessage32
	      sendMessage32();
   1302c:	0e 94 61 51 	call	0xa2c2	; 0xa2c2 <sendMessage32>
		  iLoop=0;
   13030:	10 92 36 03 	sts	0x0336, r1
   13034:	10 92 35 03 	sts	0x0335, r1
		  iPos=0;
   13038:	10 92 45 03 	sts	0x0345, r1
		  lcd_printf(3,1,PSTR("Please Wait"));
   1303c:	83 e0       	ldi	r24, 0x03	; 3
   1303e:	61 e0       	ldi	r22, 0x01	; 1
   13040:	47 e4       	ldi	r20, 0x47	; 71
   13042:	58 e1       	ldi	r21, 0x18	; 24
   13044:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  stChangeMOP=cmWaitReplyMessage;	      
   13048:	88 e1       	ldi	r24, 0x18	; 24
   1304a:	3b ce       	rjmp	.-906    	; 0x12cc2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmWaitReplyMessage:
          iLoop++;
   1304c:	80 91 35 03 	lds	r24, 0x0335
   13050:	90 91 36 03 	lds	r25, 0x0336
   13054:	01 96       	adiw	r24, 0x01	; 1
   13056:	90 93 36 03 	sts	0x0336, r25
   1305a:	80 93 35 03 	sts	0x0335, r24
		  if ((iLoop%MSG_WAIT_TIMOUT)==0){
   1305e:	68 e9       	ldi	r22, 0x98	; 152
   13060:	7a e3       	ldi	r23, 0x3A	; 58
   13062:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
   13066:	89 2b       	or	r24, r25
   13068:	19 f5       	brne	.+70     	; 0x130b0 <FMenuChangeMOP+0x7dc>
			 if (iPos<5){
   1306a:	60 91 45 03 	lds	r22, 0x0345
   1306e:	65 30       	cpi	r22, 0x05	; 5
   13070:	68 f4       	brcc	.+26     	; 0x1308c <FMenuChangeMOP+0x7b8>
				 lcd_xy(3,(13+iPos));_lcd('.');
   13072:	63 5f       	subi	r22, 0xF3	; 243
   13074:	83 e0       	ldi	r24, 0x03	; 3
   13076:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
   1307a:	8e e2       	ldi	r24, 0x2E	; 46
   1307c:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
				 iPos++;
   13080:	80 91 45 03 	lds	r24, 0x0345
   13084:	8f 5f       	subi	r24, 0xFF	; 255
   13086:	80 93 45 03 	sts	0x0345, r24
   1308a:	12 c0       	rjmp	.+36     	; 0x130b0 <FMenuChangeMOP+0x7dc>
				}
			 else{
				 iPos=0;
   1308c:	10 92 45 03 	sts	0x0345, r1
				 lcd_printf(3,(13+iPos),PSTR("       "));
   13090:	83 e0       	ldi	r24, 0x03	; 3
   13092:	6d e0       	ldi	r22, 0x0D	; 13
   13094:	4f e3       	ldi	r20, 0x3F	; 63
   13096:	58 e1       	ldi	r21, 0x18	; 24
   13098:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				 //Resend Message32
				 if (iWait<5)stChangeMOP=cmSendMessage32;
   1309c:	90 91 44 03 	lds	r25, 0x0344
   130a0:	95 30       	cpi	r25, 0x05	; 5
   130a2:	18 f4       	brcc	.+6      	; 0x130aa <FMenuChangeMOP+0x7d6>
   130a4:	87 e1       	ldi	r24, 0x17	; 23
   130a6:	80 93 47 03 	sts	0x0347, r24
				iWait++;
   130aa:	9f 5f       	subi	r25, 0xFF	; 255
   130ac:	90 93 44 03 	sts	0x0344, r25
				}
		  }
		  if (iWait>5)stChangeMOP=cmNoReply;
   130b0:	80 91 44 03 	lds	r24, 0x0344
   130b4:	86 30       	cpi	r24, 0x06	; 6
   130b6:	18 f0       	brcs	.+6      	; 0x130be <FMenuChangeMOP+0x7ea>
   130b8:	8a e1       	ldi	r24, 0x1A	; 26
   130ba:	80 93 47 03 	sts	0x0347, r24
		  if (IsMessage09==True)stChangeMOP=cmDisplayFreeMessage;
   130be:	80 91 ba 01 	lds	r24, 0x01BA
   130c2:	81 30       	cpi	r24, 0x01	; 1
   130c4:	19 f4       	brne	.+6      	; 0x130cc <FMenuChangeMOP+0x7f8>
   130c6:	89 e1       	ldi	r24, 0x19	; 25
   130c8:	80 93 47 03 	sts	0x0347, r24
		  if (IsMessage99==True)stChangeMOP=cmFinishChangeMOP;
   130cc:	80 91 b6 01 	lds	r24, 0x01B6
   130d0:	81 30       	cpi	r24, 0x01	; 1
   130d2:	f1 f5       	brne	.+124    	; 0x13150 <FMenuChangeMOP+0x87c>
   130d4:	37 c0       	rjmp	.+110    	; 0x13144 <FMenuChangeMOP+0x870>
		  break;
     case cmDisplayFreeMessage:
	      IsMessage09=False;
   130d6:	10 92 ba 01 	sts	0x01BA, r1
	      msgResult=procMessage09();
   130da:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <procMessage09>
		  lcd_clear();
   130de:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_print(1,1,AdvanZ.Message09.strFreeMessageLine1);
   130e2:	81 e0       	ldi	r24, 0x01	; 1
   130e4:	61 e0       	ldi	r22, 0x01	; 1
   130e6:	46 ee       	ldi	r20, 0xE6	; 230
   130e8:	59 e0       	ldi	r21, 0x09	; 9
   130ea:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_print(2,1,AdvanZ.Message09.strFreeMessageLine2);
   130ee:	82 e0       	ldi	r24, 0x02	; 2
   130f0:	61 e0       	ldi	r22, 0x01	; 1
   130f2:	4b ef       	ldi	r20, 0xFB	; 251
   130f4:	59 e0       	ldi	r21, 0x09	; 9
   130f6:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_print(3,1,AdvanZ.Message09.strFreeMessageLine3);
   130fa:	83 e0       	ldi	r24, 0x03	; 3
   130fc:	61 e0       	ldi	r22, 0x01	; 1
   130fe:	40 e1       	ldi	r20, 0x10	; 16
   13100:	5a e0       	ldi	r21, 0x0A	; 10
   13102:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_print(4,1,AdvanZ.Message09.strFreeMessageLine4);
   13106:	84 e0       	ldi	r24, 0x04	; 4
   13108:	61 e0       	ldi	r22, 0x01	; 1
   1310a:	45 e2       	ldi	r20, 0x25	; 37
   1310c:	5a e0       	ldi	r21, 0x0A	; 10
   1310e:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
   13112:	0e c0       	rjmp	.+28     	; 0x13130 <FMenuChangeMOP+0x85c>
		  TimDisplay=0;
          stChangeMOP=cmDelayMOP;
	      break;
     case cmNoReply:
	      lcd_clear();
   13114:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(2,1,PSTR("No Reply    "));
   13118:	82 e0       	ldi	r24, 0x02	; 2
   1311a:	61 e0       	ldi	r22, 0x01	; 1
   1311c:	42 e3       	ldi	r20, 0x32	; 50
   1311e:	58 e1       	ldi	r21, 0x18	; 24
   13120:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	      lcd_printf(3,1,PSTR("TCP/IP Error"));
   13124:	83 e0       	ldi	r24, 0x03	; 3
   13126:	61 e0       	ldi	r22, 0x01	; 1
   13128:	45 e2       	ldi	r20, 0x25	; 37
   1312a:	58 e1       	ldi	r21, 0x18	; 24
   1312c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  TimDisplay=0;
   13130:	10 92 a7 01 	sts	0x01A7, r1
          stChangeMOP=cmDelayMOP;
   13134:	8b e1       	ldi	r24, 0x1B	; 27
   13136:	c5 cd       	rjmp	.-1142   	; 0x12cc2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmDelayMOP:
	      if (TimDisplay>9)stChangeMOP=cmExitChangeMOP;
   13138:	80 91 a7 01 	lds	r24, 0x01A7
   1313c:	8a 30       	cpi	r24, 0x0A	; 10
   1313e:	40 f0       	brcs	.+16     	; 0x13150 <FMenuChangeMOP+0x87c>
   13140:	8c e1       	ldi	r24, 0x1C	; 28
   13142:	bf cd       	rjmp	.-1154   	; 0x12cc2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmExitChangeMOP:
	      stChangeMOP=cmFinishChangeMOP;
   13144:	8d e1       	ldi	r24, 0x1D	; 29
   13146:	bd cd       	rjmp	.-1158   	; 0x12cc2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmFinishChangeMOP:
	      stChangeMOP=cmInit;
   13148:	10 92 47 03 	sts	0x0347, r1
   1314c:	81 e0       	ldi	r24, 0x01	; 1
   1314e:	01 c0       	rjmp	.+2      	; 0x13152 <FMenuChangeMOP+0x87e>
   13150:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   13152:	a3 96       	adiw	r28, 0x23	; 35
   13154:	0f b6       	in	r0, 0x3f	; 63
   13156:	f8 94       	cli
   13158:	de bf       	out	0x3e, r29	; 62
   1315a:	0f be       	out	0x3f, r0	; 63
   1315c:	cd bf       	out	0x3d, r28	; 61
   1315e:	cf 91       	pop	r28
   13160:	df 91       	pop	r29
   13162:	1f 91       	pop	r17
   13164:	0f 91       	pop	r16
   13166:	ff 90       	pop	r15
   13168:	ef 90       	pop	r14
   1316a:	df 90       	pop	r13
   1316c:	cf 90       	pop	r12
   1316e:	bf 90       	pop	r11
   13170:	af 90       	pop	r10
   13172:	08 95       	ret

00013174 <SetBaudRate>:
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
	 IsFreePrinting=True;
}

void SetBaudRate(char ComAddr,char brMap){//Com1..Com4
   13174:	28 2f       	mov	r18, r24
   13176:	96 2f       	mov	r25, r22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
   13178:	81 50       	subi	r24, 0x01	; 1
   1317a:	82 30       	cpi	r24, 0x02	; 2
   1317c:	b8 f4       	brcc	.+46     	; 0x131ac <SetBaudRate+0x38>
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   1317e:	62 30       	cpi	r22, 0x02	; 2
   13180:	59 f0       	breq	.+22     	; 0x13198 <SetBaudRate+0x24>
   13182:	62 30       	cpi	r22, 0x02	; 2
   13184:	18 f0       	brcs	.+6      	; 0x1318c <SetBaudRate+0x18>
   13186:	63 30       	cpi	r22, 0x03	; 3
   13188:	21 f4       	brne	.+8      	; 0x13192 <SetBaudRate+0x1e>
   1318a:	09 c0       	rjmp	.+18     	; 0x1319e <SetBaudRate+0x2a>
   1318c:	40 e8       	ldi	r20, 0x80	; 128
   1318e:	55 e2       	ldi	r21, 0x25	; 37
   13190:	08 c0       	rjmp	.+16     	; 0x131a2 <SetBaudRate+0x2e>
   13192:	40 e0       	ldi	r20, 0x00	; 0
   13194:	50 e0       	ldi	r21, 0x00	; 0
   13196:	05 c0       	rjmp	.+10     	; 0x131a2 <SetBaudRate+0x2e>
   13198:	40 e0       	ldi	r20, 0x00	; 0
   1319a:	5b e4       	ldi	r21, 0x4B	; 75
   1319c:	02 c0       	rjmp	.+4      	; 0x131a2 <SetBaudRate+0x2e>
   1319e:	4b e9       	ldi	r20, 0x9B	; 155
   131a0:	56 e1       	ldi	r21, 0x16	; 22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
	     brValue=GetBaudrate(brMap);
	      _uart_init((ComAddr-1),brValue);
   131a2:	60 e0       	ldi	r22, 0x00	; 0
   131a4:	70 e0       	ldi	r23, 0x00	; 0
   131a6:	0e 94 ba b3 	call	0x16774	; 0x16774 <_uart_init>
   131aa:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
   131ac:	82 2f       	mov	r24, r18
   131ae:	83 50       	subi	r24, 0x03	; 3
   131b0:	82 30       	cpi	r24, 0x02	; 2
   131b2:	a8 f4       	brcc	.+42     	; 0x131de <SetBaudRate+0x6a>
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
   131b4:	9f 70       	andi	r25, 0x0F	; 15
   131b6:	62 2f       	mov	r22, r18
   131b8:	62 95       	swap	r22
   131ba:	60 7f       	andi	r22, 0xF0	; 240
   131bc:	69 2b       	or	r22, r25
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
   131be:	80 91 93 01 	lds	r24, 0x0193
   131c2:	88 23       	and	r24, r24
   131c4:	49 f0       	breq	.+18     	; 0x131d8 <SetBaudRate+0x64>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
   131c6:	86 e0       	ldi	r24, 0x06	; 6
   131c8:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
   131cc:	60 93 3c 0f 	sts	0x0F3C, r22
     IsControlPooling=True;
   131d0:	81 e0       	ldi	r24, 0x01	; 1
   131d2:	80 93 97 01 	sts	0x0197, r24
   131d6:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
		 else SendSlaveCommand(SC_BAUDRATE,brMessage);
   131d8:	86 e0       	ldi	r24, 0x06	; 6
   131da:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
   131de:	08 95       	ret

000131e0 <FSettingSystem>:
	      break;
	 }
     return Result;
}

char FSettingSystem(){
   131e0:	af 92       	push	r10
   131e2:	bf 92       	push	r11
   131e4:	cf 92       	push	r12
   131e6:	df 92       	push	r13
   131e8:	ef 92       	push	r14
   131ea:	ff 92       	push	r15
   131ec:	0f 93       	push	r16
   131ee:	1f 93       	push	r17
   131f0:	df 93       	push	r29
   131f2:	cf 93       	push	r28
   131f4:	cd b7       	in	r28, 0x3d	; 61
   131f6:	de b7       	in	r29, 0x3e	; 62
   131f8:	64 97       	sbiw	r28, 0x14	; 20
   131fa:	0f b6       	in	r0, 0x3f	; 63
   131fc:	f8 94       	cli
   131fe:	de bf       	out	0x3e, r29	; 62
   13200:	0f be       	out	0x3f, r0	; 63
   13202:	cd bf       	out	0x3d, r28	; 61
       char SubMenu,Result=MENU_NONE;
	   char HGMode;
       char lcdteks[20];
	   int bValue;

     switch(stSettingSytem){
   13204:	80 91 e0 02 	lds	r24, 0x02E0
   13208:	82 30       	cpi	r24, 0x02	; 2
   1320a:	09 f4       	brne	.+2      	; 0x1320e <FSettingSystem+0x2e>
   1320c:	cf c0       	rjmp	.+414    	; 0x133ac <FSettingSystem+0x1cc>
   1320e:	83 30       	cpi	r24, 0x03	; 3
   13210:	30 f4       	brcc	.+12     	; 0x1321e <FSettingSystem+0x3e>
   13212:	88 23       	and	r24, r24
   13214:	71 f0       	breq	.+28     	; 0x13232 <FSettingSystem+0x52>
   13216:	81 30       	cpi	r24, 0x01	; 1
   13218:	09 f0       	breq	.+2      	; 0x1321c <FSettingSystem+0x3c>
   1321a:	6f c1       	rjmp	.+734    	; 0x134fa <FSettingSystem+0x31a>
   1321c:	7f c0       	rjmp	.+254    	; 0x1331c <FSettingSystem+0x13c>
   1321e:	84 30       	cpi	r24, 0x04	; 4
   13220:	09 f4       	brne	.+2      	; 0x13224 <FSettingSystem+0x44>
   13222:	60 c1       	rjmp	.+704    	; 0x134e4 <FSettingSystem+0x304>
   13224:	84 30       	cpi	r24, 0x04	; 4
   13226:	08 f4       	brcc	.+2      	; 0x1322a <FSettingSystem+0x4a>
   13228:	2b c1       	rjmp	.+598    	; 0x13480 <FSettingSystem+0x2a0>
   1322a:	85 30       	cpi	r24, 0x05	; 5
   1322c:	09 f0       	breq	.+2      	; 0x13230 <FSettingSystem+0x50>
   1322e:	65 c1       	rjmp	.+714    	; 0x134fa <FSettingSystem+0x31a>
   13230:	60 c1       	rjmp	.+704    	; 0x134f2 <FSettingSystem+0x312>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13232:	e1 99       	sbic	0x1c, 1	; 28
   13234:	fe cf       	rjmp	.-4      	; 0x13232 <FSettingSystem+0x52>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13236:	86 e3       	ldi	r24, 0x36	; 54
   13238:	91 e0       	ldi	r25, 0x01	; 1
   1323a:	9f bb       	out	0x1f, r25	; 31
   1323c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1323e:	e0 9a       	sbi	0x1c, 0	; 28
   13240:	2d b3       	in	r18, 0x1d	; 29
	 case ssInitSettingSystem:
	      IFType=eeprom_read_byte(&DefInitIFT);
   13242:	20 93 10 01 	sts	0x0110, r18
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13246:	e1 99       	sbic	0x1c, 1	; 28
   13248:	fe cf       	rjmp	.-4      	; 0x13246 <FSettingSystem+0x66>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1324a:	82 ec       	ldi	r24, 0xC2	; 194
   1324c:	93 e0       	ldi	r25, 0x03	; 3
   1324e:	9f bb       	out	0x1f, r25	; 31
   13250:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13252:	e0 9a       	sbi	0x1c, 0	; 28
   13254:	1d b3       	in	r17, 0x1d	; 29
		  HGMode=eeprom_read_byte(&DefHGMode);

	      if (IFType==IT_NONE)sprintf_P(lcdteks,PSTR("1.Mode:None"));
   13256:	22 23       	and	r18, r18
   13258:	69 f4       	brne	.+26     	; 0x13274 <FSettingSystem+0x94>
   1325a:	00 d0       	rcall	.+0      	; 0x1325c <FSettingSystem+0x7c>
   1325c:	00 d0       	rcall	.+0      	; 0x1325e <FSettingSystem+0x7e>
   1325e:	ce 01       	movw	r24, r28
   13260:	01 96       	adiw	r24, 0x01	; 1
   13262:	ad b7       	in	r26, 0x3d	; 61
   13264:	be b7       	in	r27, 0x3e	; 62
   13266:	12 96       	adiw	r26, 0x02	; 2
   13268:	9c 93       	st	X, r25
   1326a:	8e 93       	st	-X, r24
   1326c:	11 97       	sbiw	r26, 0x01	; 1
   1326e:	84 e3       	ldi	r24, 0x34	; 52
   13270:	9e e0       	ldi	r25, 0x0E	; 14
   13272:	1d c0       	rjmp	.+58     	; 0x132ae <FSettingSystem+0xce>
		  else
	      if (IFType==IT_SLAVE)sprintf_P(lcdteks,PSTR("1.Mode:Slave"));
   13274:	21 30       	cpi	r18, 0x01	; 1
   13276:	69 f4       	brne	.+26     	; 0x13292 <FSettingSystem+0xb2>
   13278:	00 d0       	rcall	.+0      	; 0x1327a <FSettingSystem+0x9a>
   1327a:	00 d0       	rcall	.+0      	; 0x1327c <FSettingSystem+0x9c>
   1327c:	ce 01       	movw	r24, r28
   1327e:	01 96       	adiw	r24, 0x01	; 1
   13280:	ed b7       	in	r30, 0x3d	; 61
   13282:	fe b7       	in	r31, 0x3e	; 62
   13284:	92 83       	std	Z+2, r25	; 0x02
   13286:	81 83       	std	Z+1, r24	; 0x01
   13288:	87 e2       	ldi	r24, 0x27	; 39
   1328a:	9e e0       	ldi	r25, 0x0E	; 14
   1328c:	94 83       	std	Z+4, r25	; 0x04
   1328e:	83 83       	std	Z+3, r24	; 0x03
   13290:	12 c0       	rjmp	.+36     	; 0x132b6 <FSettingSystem+0xd6>
		  else
	      if (IFType==IT_STANDALONE)sprintf_P(lcdteks,PSTR("1.Mode:Standalone"));
   13292:	22 30       	cpi	r18, 0x02	; 2
   13294:	b1 f4       	brne	.+44     	; 0x132c2 <FSettingSystem+0xe2>
   13296:	00 d0       	rcall	.+0      	; 0x13298 <FSettingSystem+0xb8>
   13298:	00 d0       	rcall	.+0      	; 0x1329a <FSettingSystem+0xba>
   1329a:	ce 01       	movw	r24, r28
   1329c:	01 96       	adiw	r24, 0x01	; 1
   1329e:	ad b7       	in	r26, 0x3d	; 61
   132a0:	be b7       	in	r27, 0x3e	; 62
   132a2:	12 96       	adiw	r26, 0x02	; 2
   132a4:	9c 93       	st	X, r25
   132a6:	8e 93       	st	-X, r24
   132a8:	11 97       	sbiw	r26, 0x01	; 1
   132aa:	85 e1       	ldi	r24, 0x15	; 21
   132ac:	9e e0       	ldi	r25, 0x0E	; 14
   132ae:	14 96       	adiw	r26, 0x04	; 4
   132b0:	9c 93       	st	X, r25
   132b2:	8e 93       	st	-X, r24
   132b4:	13 97       	sbiw	r26, 0x03	; 3
   132b6:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   132ba:	0f 90       	pop	r0
   132bc:	0f 90       	pop	r0
   132be:	0f 90       	pop	r0
   132c0:	0f 90       	pop	r0

	      lcd_clear();
   132c2:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_print(1,1,lcdteks);
   132c6:	81 e0       	ldi	r24, 0x01	; 1
   132c8:	61 e0       	ldi	r22, 0x01	; 1
   132ca:	ae 01       	movw	r20, r28
   132cc:	4f 5f       	subi	r20, 0xFF	; 255
   132ce:	5f 4f       	sbci	r21, 0xFF	; 255
   132d0:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  lcd_printf(2,1,PSTR("2.Baudrate"));
   132d4:	82 e0       	ldi	r24, 0x02	; 2
   132d6:	61 e0       	ldi	r22, 0x01	; 1
   132d8:	4a e0       	ldi	r20, 0x0A	; 10
   132da:	5e e0       	ldi	r21, 0x0E	; 14
   132dc:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>

		  if (HGMode==HM_TTL)lcd_printf(3,1,PSTR("3.COM3:TTL"));
   132e0:	11 23       	and	r17, r17
   132e2:	29 f4       	brne	.+10     	; 0x132ee <FSettingSystem+0x10e>
   132e4:	83 e0       	ldi	r24, 0x03	; 3
   132e6:	61 e0       	ldi	r22, 0x01	; 1
   132e8:	4f ef       	ldi	r20, 0xFF	; 255
   132ea:	5d e0       	ldi	r21, 0x0D	; 13
   132ec:	0d c0       	rjmp	.+26     	; 0x13308 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_232)lcd_printf(3,1,PSTR("3.COM3:232"));
   132ee:	11 30       	cpi	r17, 0x01	; 1
   132f0:	29 f4       	brne	.+10     	; 0x132fc <FSettingSystem+0x11c>
   132f2:	83 e0       	ldi	r24, 0x03	; 3
   132f4:	61 e0       	ldi	r22, 0x01	; 1
   132f6:	44 ef       	ldi	r20, 0xF4	; 244
   132f8:	5d e0       	ldi	r21, 0x0D	; 13
   132fa:	06 c0       	rjmp	.+12     	; 0x13308 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_485)lcd_printf(3,1,PSTR("3.COM3:485"));		  
   132fc:	12 30       	cpi	r17, 0x02	; 2
   132fe:	31 f4       	brne	.+12     	; 0x1330c <FSettingSystem+0x12c>
   13300:	83 e0       	ldi	r24, 0x03	; 3
   13302:	61 e0       	ldi	r22, 0x01	; 1
   13304:	49 ee       	ldi	r20, 0xE9	; 233
   13306:	5d e0       	ldi	r21, 0x0D	; 13
   13308:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back      "));
   1330c:	84 e0       	ldi	r24, 0x04	; 4
   1330e:	61 e0       	ldi	r22, 0x01	; 1
   13310:	4b ed       	ldi	r20, 0xDB	; 219
   13312:	5d e0       	ldi	r21, 0x0D	; 13
   13314:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  stSettingSytem=ssMenuSelect;
   13318:	81 e0       	ldi	r24, 0x01	; 1
   1331a:	e1 c0       	rjmp	.+450    	; 0x134de <FSettingSystem+0x2fe>
	      break;
     case ssMenuSelect:
          KeyPressed=_key_scan(1);
   1331c:	81 e0       	ldi	r24, 0x01	; 1
   1331e:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   13322:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
		  if (KeyChar=='1'){
   13326:	81 33       	cpi	r24, 0x31	; 49
   13328:	c1 f4       	brne	.+48     	; 0x1335a <FSettingSystem+0x17a>
		      IFType=((IFType+1)%3);
   1332a:	80 91 10 01 	lds	r24, 0x0110
   1332e:	90 e0       	ldi	r25, 0x00	; 0
   13330:	01 96       	adiw	r24, 0x01	; 1
   13332:	63 e0       	ldi	r22, 0x03	; 3
   13334:	70 e0       	ldi	r23, 0x00	; 0
   13336:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
   1333a:	80 93 10 01 	sts	0x0110, r24
			  SendSlaveCommand(IFType,DispenserBrand);
   1333e:	60 91 61 01 	lds	r22, 0x0161
   13342:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
			  eeprom_write_byte(&DefInitIFT,IFType);
   13346:	20 91 10 01 	lds	r18, 0x0110
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1334a:	e1 99       	sbic	0x1c, 1	; 28
   1334c:	fe cf       	rjmp	.-4      	; 0x1334a <FSettingSystem+0x16a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1334e:	86 e3       	ldi	r24, 0x36	; 54
   13350:	91 e0       	ldi	r25, 0x01	; 1
   13352:	9f bb       	out	0x1f, r25	; 31
   13354:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   13356:	2d bb       	out	0x1d, r18	; 29
   13358:	1f c0       	rjmp	.+62     	; 0x13398 <FSettingSystem+0x1b8>
			  stSettingSytem=ssInitSettingSystem;
		  }
		  else
		  if (KeyChar=='2'){
   1335a:	82 33       	cpi	r24, 0x32	; 50
   1335c:	09 f4       	brne	.+2      	; 0x13360 <FSettingSystem+0x180>
   1335e:	ba c0       	rjmp	.+372    	; 0x134d4 <FSettingSystem+0x2f4>
		      stSettingSytem=ssComSettings;
		  }
		  else
		  if (KeyChar=='3'){
   13360:	83 33       	cpi	r24, 0x33	; 51
   13362:	01 f5       	brne	.+64     	; 0x133a4 <FSettingSystem+0x1c4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13364:	e1 99       	sbic	0x1c, 1	; 28
   13366:	fe cf       	rjmp	.-4      	; 0x13364 <FSettingSystem+0x184>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13368:	e2 ec       	ldi	r30, 0xC2	; 194
   1336a:	ee 2e       	mov	r14, r30
   1336c:	e3 e0       	ldi	r30, 0x03	; 3
   1336e:	fe 2e       	mov	r15, r30
   13370:	ff ba       	out	0x1f, r15	; 31
   13372:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13374:	e0 9a       	sbi	0x1c, 0	; 28
   13376:	8d b3       	in	r24, 0x1d	; 29
		      HGMode=eeprom_read_byte(&DefHGMode);
		      HGMode=((HGMode+1)%3);
   13378:	90 e0       	ldi	r25, 0x00	; 0
   1337a:	01 96       	adiw	r24, 0x01	; 1
   1337c:	63 e0       	ldi	r22, 0x03	; 3
   1337e:	70 e0       	ldi	r23, 0x00	; 0
   13380:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
   13384:	18 2f       	mov	r17, r24
			  SendSlaveCommand(SC_HGM_MODE,HGMode);
   13386:	81 e2       	ldi	r24, 0x21	; 33
   13388:	61 2f       	mov	r22, r17
   1338a:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1338e:	e1 99       	sbic	0x1c, 1	; 28
   13390:	fe cf       	rjmp	.-4      	; 0x1338e <FSettingSystem+0x1ae>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13392:	ff ba       	out	0x1f, r15	; 31
   13394:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   13396:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
   13398:	0f b6       	in	r0, 0x3f	; 63
   1339a:	f8 94       	cli
   1339c:	e2 9a       	sbi	0x1c, 2	; 28
   1339e:	e1 9a       	sbi	0x1c, 1	; 28
   133a0:	0f be       	out	0x3f, r0	; 63
   133a2:	a4 c0       	rjmp	.+328    	; 0x134ec <FSettingSystem+0x30c>
			  eeprom_write_byte(&DefHGMode,HGMode);
			  stSettingSytem=ssInitSettingSystem;
		  }
		  //else
		  if (KeyChar=='*'){
   133a4:	8a 32       	cpi	r24, 0x2A	; 42
   133a6:	09 f4       	brne	.+2      	; 0x133aa <FSettingSystem+0x1ca>
   133a8:	99 c0       	rjmp	.+306    	; 0x134dc <FSettingSystem+0x2fc>
   133aa:	a7 c0       	rjmp	.+334    	; 0x134fa <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
   133ac:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   133b0:	81 e0       	ldi	r24, 0x01	; 1
   133b2:	61 e0       	ldi	r22, 0x01	; 1
   133b4:	46 ec       	ldi	r20, 0xC6	; 198
   133b6:	5d e0       	ldi	r21, 0x0D	; 13
   133b8:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   133bc:	01 e0       	ldi	r16, 0x01	; 1
   133be:	10 e0       	ldi	r17, 0x00	; 0

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   133c0:	6e 01       	movw	r12, r28
   133c2:	08 94       	sec
   133c4:	c1 1c       	adc	r12, r1
   133c6:	d1 1c       	adc	r13, r1
   133c8:	7d eb       	ldi	r23, 0xBD	; 189
   133ca:	a7 2e       	mov	r10, r23
   133cc:	7d e0       	ldi	r23, 0x0D	; 13
   133ce:	b7 2e       	mov	r11, r23
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   133d0:	6b e0       	ldi	r22, 0x0B	; 11
   133d2:	e6 2e       	mov	r14, r22
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   133d4:	f0 2e       	mov	r15, r16
   133d6:	fa 94       	dec	r15
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   133d8:	e1 99       	sbic	0x1c, 1	; 28
   133da:	fe cf       	rjmp	.-4      	; 0x133d8 <FSettingSystem+0x1f8>
   133dc:	c8 01       	movw	r24, r16
   133de:	81 5c       	subi	r24, 0xC1	; 193
   133e0:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   133e2:	9f bb       	out	0x1f, r25	; 31
   133e4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   133e6:	e0 9a       	sbi	0x1c, 0	; 28
   133e8:	8d b3       	in	r24, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   133ea:	82 30       	cpi	r24, 0x02	; 2
   133ec:	69 f0       	breq	.+26     	; 0x13408 <FSettingSystem+0x228>
   133ee:	82 30       	cpi	r24, 0x02	; 2
   133f0:	28 f0       	brcs	.+10     	; 0x133fc <FSettingSystem+0x21c>
   133f2:	83 30       	cpi	r24, 0x03	; 3
   133f4:	31 f4       	brne	.+12     	; 0x13402 <FSettingSystem+0x222>
   133f6:	85 eb       	ldi	r24, 0xB5	; 181
   133f8:	9f e2       	ldi	r25, 0x2F	; 47
   133fa:	08 c0       	rjmp	.+16     	; 0x1340c <FSettingSystem+0x22c>
   133fc:	80 e8       	ldi	r24, 0x80	; 128
   133fe:	95 e2       	ldi	r25, 0x25	; 37
   13400:	05 c0       	rjmp	.+10     	; 0x1340c <FSettingSystem+0x22c>
   13402:	80 e0       	ldi	r24, 0x00	; 0
   13404:	90 e0       	ldi	r25, 0x00	; 0
   13406:	02 c0       	rjmp	.+4      	; 0x1340c <FSettingSystem+0x22c>
   13408:	80 e0       	ldi	r24, 0x00	; 0
   1340a:	9b e4       	ldi	r25, 0x4B	; 75
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   1340c:	ed b7       	in	r30, 0x3d	; 61
   1340e:	fe b7       	in	r31, 0x3e	; 62
   13410:	38 97       	sbiw	r30, 0x08	; 8
   13412:	0f b6       	in	r0, 0x3f	; 63
   13414:	f8 94       	cli
   13416:	fe bf       	out	0x3e, r31	; 62
   13418:	0f be       	out	0x3f, r0	; 63
   1341a:	ed bf       	out	0x3d, r30	; 61
   1341c:	31 96       	adiw	r30, 0x01	; 1
   1341e:	ad b7       	in	r26, 0x3d	; 61
   13420:	be b7       	in	r27, 0x3e	; 62
   13422:	12 96       	adiw	r26, 0x02	; 2
   13424:	dc 92       	st	X, r13
   13426:	ce 92       	st	-X, r12
   13428:	11 97       	sbiw	r26, 0x01	; 1
   1342a:	b3 82       	std	Z+3, r11	; 0x03
   1342c:	a2 82       	std	Z+2, r10	; 0x02
   1342e:	15 83       	std	Z+5, r17	; 0x05
   13430:	04 83       	std	Z+4, r16	; 0x04
   13432:	97 83       	std	Z+7, r25	; 0x07
   13434:	86 83       	std	Z+6, r24	; 0x06
   13436:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   1343a:	ed b7       	in	r30, 0x3d	; 61
   1343c:	fe b7       	in	r31, 0x3e	; 62
   1343e:	38 96       	adiw	r30, 0x08	; 8
   13440:	0f b6       	in	r0, 0x3f	; 63
   13442:	f8 94       	cli
   13444:	fe bf       	out	0x3e, r31	; 62
   13446:	0f be       	out	0x3f, r0	; 63
   13448:	ed bf       	out	0x3d, r30	; 61
   1344a:	6f 2d       	mov	r22, r15
   1344c:	66 95       	lsr	r22
   1344e:	6e 9d       	mul	r22, r14
   13450:	b0 01       	movw	r22, r0
   13452:	11 24       	eor	r1, r1
   13454:	6f 5f       	subi	r22, 0xFF	; 255
   13456:	f1 e0       	ldi	r31, 0x01	; 1
   13458:	ff 22       	and	r15, r31
   1345a:	8f 2d       	mov	r24, r15
   1345c:	8e 5f       	subi	r24, 0xFE	; 254
   1345e:	a6 01       	movw	r20, r12
   13460:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
   13464:	0f 5f       	subi	r16, 0xFF	; 255
   13466:	1f 4f       	sbci	r17, 0xFF	; 255
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
   13468:	05 30       	cpi	r16, 0x05	; 5
   1346a:	11 05       	cpc	r17, r1
   1346c:	09 f0       	breq	.+2      	; 0x13470 <FSettingSystem+0x290>
   1346e:	b2 cf       	rjmp	.-156    	; 0x133d4 <FSettingSystem+0x1f4>
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
		  }
		  lcd_printf(4,1,PSTR("[*]Back     "));
   13470:	84 e0       	ldi	r24, 0x04	; 4
   13472:	61 e0       	ldi	r22, 0x01	; 1
   13474:	40 eb       	ldi	r20, 0xB0	; 176
   13476:	5d e0       	ldi	r21, 0x0D	; 13
   13478:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  stSettingSytem=ssBaudrateInput;
   1347c:	83 e0       	ldi	r24, 0x03	; 3
   1347e:	2f c0       	rjmp	.+94     	; 0x134de <FSettingSystem+0x2fe>
	      break;
     case ssBaudrateInput:
	      KeyPressed=_key_scan(1);
   13480:	81 e0       	ldi	r24, 0x01	; 1
   13482:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   13486:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   1348a:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   1348c:	81 53       	subi	r24, 0x31	; 49
   1348e:	84 30       	cpi	r24, 0x04	; 4
   13490:	18 f5       	brcc	.+70     	; 0x134d8 <FSettingSystem+0x2f8>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13492:	e1 99       	sbic	0x1c, 1	; 28
   13494:	fe cf       	rjmp	.-4      	; 0x13492 <FSettingSystem+0x2b2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13496:	02 2f       	mov	r16, r18
   13498:	10 e0       	ldi	r17, 0x00	; 0
   1349a:	01 5f       	subi	r16, 0xF1	; 241
   1349c:	1e 4f       	sbci	r17, 0xFE	; 254
   1349e:	1f bb       	out	0x1f, r17	; 31
   134a0:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   134a2:	e0 9a       	sbi	0x1c, 0	; 28
   134a4:	8d b3       	in	r24, 0x1d	; 29
		       brVal=eeprom_read_byte(&DefBaudrate[KeyChar-'1']);
			   brVal=((brVal+1)%3)+1;
   134a6:	90 e0       	ldi	r25, 0x00	; 0
   134a8:	01 96       	adiw	r24, 0x01	; 1
   134aa:	63 e0       	ldi	r22, 0x03	; 3
   134ac:	70 e0       	ldi	r23, 0x00	; 0
   134ae:	0e 94 9f b8 	call	0x1713e	; 0x1713e <__divmodhi4>
   134b2:	f8 2e       	mov	r15, r24
   134b4:	f3 94       	inc	r15
			   SetBaudRate(KeyChar-'0',brVal);
   134b6:	82 2f       	mov	r24, r18
   134b8:	80 53       	subi	r24, 0x30	; 48
   134ba:	6f 2d       	mov	r22, r15
   134bc:	0e 94 ba 98 	call	0x13174	; 0x13174 <SetBaudRate>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   134c0:	e1 99       	sbic	0x1c, 1	; 28
   134c2:	fe cf       	rjmp	.-4      	; 0x134c0 <FSettingSystem+0x2e0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   134c4:	1f bb       	out	0x1f, r17	; 31
   134c6:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   134c8:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
   134ca:	0f b6       	in	r0, 0x3f	; 63
   134cc:	f8 94       	cli
   134ce:	e2 9a       	sbi	0x1c, 2	; 28
   134d0:	e1 9a       	sbi	0x1c, 1	; 28
   134d2:	0f be       	out	0x3f, r0	; 63
			   eeprom_write_byte(&DefBaudrate[KeyChar-'1'],brVal);
               stSettingSytem=ssComSettings;
   134d4:	82 e0       	ldi	r24, 0x02	; 2
   134d6:	03 c0       	rjmp	.+6      	; 0x134de <FSettingSystem+0x2fe>
		  }else if (KeyChar=='*')
   134d8:	2a 32       	cpi	r18, 0x2A	; 42
   134da:	79 f4       	brne	.+30     	; 0x134fa <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;		  	
   134dc:	85 e0       	ldi	r24, 0x05	; 5
   134de:	80 93 e0 02 	sts	0x02E0, r24
   134e2:	0b c0       	rjmp	.+22     	; 0x134fa <FSettingSystem+0x31a>
	      break;
	 case ssPumpPoolingSettings:
          SubMenu=FSettingPumpPooling();
   134e4:	0e 94 7e 6f 	call	0xdefc	; 0xdefc <FSettingPumpPooling>
		  if (SubMenu==MENU_DONE)stSettingSytem=ssInitSettingSystem;
   134e8:	81 30       	cpi	r24, 0x01	; 1
   134ea:	39 f4       	brne	.+14     	; 0x134fa <FSettingSystem+0x31a>
   134ec:	10 92 e0 02 	sts	0x02E0, r1
   134f0:	04 c0       	rjmp	.+8      	; 0x134fa <FSettingSystem+0x31a>
	      break;
     case ssExitSystemSettings:
	      stSettingSytem=ssInitSettingSystem;
   134f2:	10 92 e0 02 	sts	0x02E0, r1
   134f6:	81 e0       	ldi	r24, 0x01	; 1
   134f8:	01 c0       	rjmp	.+2      	; 0x134fc <FSettingSystem+0x31c>
   134fa:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
   134fc:	64 96       	adiw	r28, 0x14	; 20
   134fe:	0f b6       	in	r0, 0x3f	; 63
   13500:	f8 94       	cli
   13502:	de bf       	out	0x3e, r29	; 62
   13504:	0f be       	out	0x3f, r0	; 63
   13506:	cd bf       	out	0x3d, r28	; 61
   13508:	cf 91       	pop	r28
   1350a:	df 91       	pop	r29
   1350c:	1f 91       	pop	r17
   1350e:	0f 91       	pop	r16
   13510:	ff 90       	pop	r15
   13512:	ef 90       	pop	r14
   13514:	df 90       	pop	r13
   13516:	cf 90       	pop	r12
   13518:	bf 90       	pop	r11
   1351a:	af 90       	pop	r10
   1351c:	08 95       	ret

0001351e <FMenuSettings>:


char FMenuSettings(){
char Result=MENU_NONE;
static char stMenuSettings=msInit,PageSetting=1,KeyPressed,KeyChar,SubMenu;
     switch(stMenuSettings){
   1351e:	80 91 f3 02 	lds	r24, 0x02F3
   13522:	e8 2f       	mov	r30, r24
   13524:	f0 e0       	ldi	r31, 0x00	; 0
   13526:	e3 31       	cpi	r30, 0x13	; 19
   13528:	f1 05       	cpc	r31, r1
   1352a:	08 f0       	brcs	.+2      	; 0x1352e <FMenuSettings+0x10>
   1352c:	cd c0       	rjmp	.+410    	; 0x136c8 <FMenuSettings+0x1aa>
   1352e:	ee 51       	subi	r30, 0x1E	; 30
   13530:	ff 4f       	sbci	r31, 0xFF	; 255
   13532:	ee 0f       	add	r30, r30
   13534:	ff 1f       	adc	r31, r31
   13536:	05 90       	lpm	r0, Z+
   13538:	f4 91       	lpm	r31, Z+
   1353a:	e0 2d       	mov	r30, r0
   1353c:	09 94       	ijmp
	 case msInit:
		  lcd_clear();
   1353e:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		  PageSetting=1;
   13542:	81 e0       	ldi	r24, 0x01	; 1
   13544:	80 93 57 01 	sts	0x0157, r24
   13548:	b7 c0       	rjmp	.+366    	; 0x136b8 <FMenuSettings+0x19a>
		  stMenuSettings=msDisplayPage;
		  break;
	 case msDisplayPage:
	      stMenuSettings=msDisplayPage+PageSetting;
   1354a:	80 91 57 01 	lds	r24, 0x0157
   1354e:	8f 5f       	subi	r24, 0xFF	; 255
   13550:	b3 c0       	rjmp	.+358    	; 0x136b8 <FMenuSettings+0x19a>
          break; 	 
	 case msDisplayPage1:
		  lcd_printf(1, 1, PSTR("1)Product  5)Printer"));
   13552:	81 e0       	ldi	r24, 0x01	; 1
   13554:	61 e0       	ldi	r22, 0x01	; 1
   13556:	48 ea       	ldi	r20, 0xA8	; 168
   13558:	52 e1       	ldi	r21, 0x12	; 18
   1355a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)Pump     6)Host   "));
   1355e:	82 e0       	ldi	r24, 0x02	; 2
   13560:	61 e0       	ldi	r22, 0x01	; 1
   13562:	43 e9       	ldi	r20, 0x93	; 147
   13564:	52 e1       	ldi	r21, 0x12	; 18
   13566:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)Decimal  7)Next   "));
   1356a:	83 e0       	ldi	r24, 0x03	; 3
   1356c:	61 e0       	ldi	r22, 0x01	; 1
   1356e:	4e e7       	ldi	r20, 0x7E	; 126
   13570:	52 e1       	ldi	r21, 0x12	; 18
   13572:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4, 1, PSTR("4)Datetime *)Exit   "));
   13576:	84 e0       	ldi	r24, 0x04	; 4
   13578:	61 e0       	ldi	r22, 0x01	; 1
   1357a:	49 e6       	ldi	r20, 0x69	; 105
   1357c:	52 e1       	ldi	r21, 0x12	; 18
   1357e:	16 c0       	rjmp	.+44     	; 0x135ac <FMenuSettings+0x8e>
		  stMenuSettings=msSelection;
	      break;
	 case msDisplayPage2:
		  lcd_printf(1, 1, PSTR("1)Operator          "));
   13580:	81 e0       	ldi	r24, 0x01	; 1
   13582:	61 e0       	ldi	r22, 0x01	; 1
   13584:	44 e5       	ldi	r20, 0x54	; 84
   13586:	52 e1       	ldi	r21, 0x12	; 18
   13588:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)System            "));
   1358c:	82 e0       	ldi	r24, 0x02	; 2
   1358e:	61 e0       	ldi	r22, 0x01	; 1
   13590:	4f e3       	ldi	r20, 0x3F	; 63
   13592:	52 e1       	ldi	r21, 0x12	; 18
   13594:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)PumpPooling       "));
   13598:	83 e0       	ldi	r24, 0x03	; 3
   1359a:	61 e0       	ldi	r22, 0x01	; 1
   1359c:	4a e2       	ldi	r20, 0x2A	; 42
   1359e:	52 e1       	ldi	r21, 0x12	; 18
   135a0:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  lcd_printf(4, 1, PSTR("*)Back              "));
   135a4:	84 e0       	ldi	r24, 0x04	; 4
   135a6:	61 e0       	ldi	r22, 0x01	; 1
   135a8:	45 e1       	ldi	r20, 0x15	; 21
   135aa:	52 e1       	ldi	r21, 0x12	; 18
   135ac:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  stMenuSettings=msSelection;
   135b0:	84 e0       	ldi	r24, 0x04	; 4
   135b2:	82 c0       	rjmp	.+260    	; 0x136b8 <FMenuSettings+0x19a>
	      break;
	 case msSelection:
	      stMenuSettings=msSelection+PageSetting;
   135b4:	80 91 57 01 	lds	r24, 0x0157
   135b8:	8c 5f       	subi	r24, 0xFC	; 252
   135ba:	7e c0       	rjmp	.+252    	; 0x136b8 <FMenuSettings+0x19a>
          break;	 
	 case msSelectionPage1:
		  KeyPressed=_key_scan(1);
   135bc:	81 e0       	ldi	r24, 0x01	; 1
   135be:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   135c2:	80 93 f2 02 	sts	0x02F2, r24
		  KeyChar=_key_btn(KeyPressed);
   135c6:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   135ca:	80 93 f1 02 	sts	0x02F1, r24
		  switch(KeyChar){
   135ce:	84 33       	cpi	r24, 0x34	; 52
   135d0:	d1 f0       	breq	.+52     	; 0x13606 <FMenuSettings+0xe8>
   135d2:	85 33       	cpi	r24, 0x35	; 53
   135d4:	50 f4       	brcc	.+20     	; 0x135ea <FMenuSettings+0xcc>
   135d6:	82 33       	cpi	r24, 0x32	; 50
   135d8:	91 f0       	breq	.+36     	; 0x135fe <FMenuSettings+0xe0>
   135da:	83 33       	cpi	r24, 0x33	; 51
   135dc:	90 f4       	brcc	.+36     	; 0x13602 <FMenuSettings+0xe4>
   135de:	8a 32       	cpi	r24, 0x2A	; 42
   135e0:	d1 f0       	breq	.+52     	; 0x13616 <FMenuSettings+0xf8>
   135e2:	81 33       	cpi	r24, 0x31	; 49
   135e4:	09 f0       	breq	.+2      	; 0x135e8 <FMenuSettings+0xca>
   135e6:	70 c0       	rjmp	.+224    	; 0x136c8 <FMenuSettings+0x1aa>
   135e8:	08 c0       	rjmp	.+16     	; 0x135fa <FMenuSettings+0xdc>
   135ea:	86 33       	cpi	r24, 0x36	; 54
   135ec:	81 f0       	breq	.+32     	; 0x1360e <FMenuSettings+0xf0>
   135ee:	86 33       	cpi	r24, 0x36	; 54
   135f0:	60 f0       	brcs	.+24     	; 0x1360a <FMenuSettings+0xec>
   135f2:	87 33       	cpi	r24, 0x37	; 55
   135f4:	09 f0       	breq	.+2      	; 0x135f8 <FMenuSettings+0xda>
   135f6:	68 c0       	rjmp	.+208    	; 0x136c8 <FMenuSettings+0x1aa>
   135f8:	0c c0       	rjmp	.+24     	; 0x13612 <FMenuSettings+0xf4>
		  case '1':
		       stMenuSettings=msMenuSettingProduct;
   135fa:	89 e0       	ldi	r24, 0x09	; 9
   135fc:	5d c0       	rjmp	.+186    	; 0x136b8 <FMenuSettings+0x19a>
		       break;
		  case '2': 
		       stMenuSettings=msMenuSettingPump;
   135fe:	8a e0       	ldi	r24, 0x0A	; 10
   13600:	5b c0       	rjmp	.+182    	; 0x136b8 <FMenuSettings+0x19a>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingDec;
   13602:	8b e0       	ldi	r24, 0x0B	; 11
   13604:	59 c0       	rjmp	.+178    	; 0x136b8 <FMenuSettings+0x19a>
		       break;
		  case '4':
		       stMenuSettings=msMenuSettingDatetime;
   13606:	8c e0       	ldi	r24, 0x0C	; 12
   13608:	57 c0       	rjmp	.+174    	; 0x136b8 <FMenuSettings+0x19a>
		       break;
		  case '5':
		       stMenuSettings=msMenuSettingPrinter;
   1360a:	8d e0       	ldi	r24, 0x0D	; 13
   1360c:	55 c0       	rjmp	.+170    	; 0x136b8 <FMenuSettings+0x19a>
		       break;
		  case '6':
		       stMenuSettings=msMenuSettingHost;
   1360e:	8e e0       	ldi	r24, 0x0E	; 14
   13610:	53 c0       	rjmp	.+166    	; 0x136b8 <FMenuSettings+0x19a>
		       break;
		  case '7':
		       stMenuSettings=msMenuSettingNextPage;
   13612:	87 e0       	ldi	r24, 0x07	; 7
   13614:	51 c0       	rjmp	.+162    	; 0x136b8 <FMenuSettings+0x19a>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingExit;
   13616:	82 e1       	ldi	r24, 0x12	; 18
   13618:	4f c0       	rjmp	.+158    	; 0x136b8 <FMenuSettings+0x19a>
		       break;			   
		  }
	      break;
	 case msSelectionPage2:
	 	  KeyPressed=_key_scan(1);
   1361a:	81 e0       	ldi	r24, 0x01	; 1
   1361c:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   13620:	80 93 f2 02 	sts	0x02F2, r24
		  KeyChar=_key_btn(KeyPressed);
   13624:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   13628:	80 93 f1 02 	sts	0x02F1, r24
		  switch(KeyChar){
   1362c:	82 33       	cpi	r24, 0x32	; 50
   1362e:	71 f0       	breq	.+28     	; 0x1364c <FMenuSettings+0x12e>
   13630:	83 33       	cpi	r24, 0x33	; 51
   13632:	30 f4       	brcc	.+12     	; 0x13640 <FMenuSettings+0x122>
   13634:	8a 32       	cpi	r24, 0x2A	; 42
   13636:	71 f0       	breq	.+28     	; 0x13654 <FMenuSettings+0x136>
   13638:	81 33       	cpi	r24, 0x31	; 49
   1363a:	09 f0       	breq	.+2      	; 0x1363e <FMenuSettings+0x120>
   1363c:	45 c0       	rjmp	.+138    	; 0x136c8 <FMenuSettings+0x1aa>
   1363e:	04 c0       	rjmp	.+8      	; 0x13648 <FMenuSettings+0x12a>
   13640:	83 33       	cpi	r24, 0x33	; 51
   13642:	09 f0       	breq	.+2      	; 0x13646 <FMenuSettings+0x128>
   13644:	41 c0       	rjmp	.+130    	; 0x136c8 <FMenuSettings+0x1aa>
   13646:	04 c0       	rjmp	.+8      	; 0x13650 <FMenuSettings+0x132>
		  case '1':
		       stMenuSettings=msMenuSettingOperator;
   13648:	8f e0       	ldi	r24, 0x0F	; 15
   1364a:	36 c0       	rjmp	.+108    	; 0x136b8 <FMenuSettings+0x19a>
		       break;
		  case '2':
		       stMenuSettings=msMenuSettingSystem;
   1364c:	80 e1       	ldi	r24, 0x10	; 16
   1364e:	34 c0       	rjmp	.+104    	; 0x136b8 <FMenuSettings+0x19a>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingPumpPooling;
   13650:	81 e1       	ldi	r24, 0x11	; 17
   13652:	32 c0       	rjmp	.+100    	; 0x136b8 <FMenuSettings+0x19a>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingBackPage;
   13654:	88 e0       	ldi	r24, 0x08	; 8
   13656:	30 c0       	rjmp	.+96     	; 0x136b8 <FMenuSettings+0x19a>
		       break;		  
		  }
	      break;
		  
	 case msMenuSettingNextPage:
	      if (PageSetting<2)PageSetting++;
   13658:	80 91 57 01 	lds	r24, 0x0157
   1365c:	82 30       	cpi	r24, 0x02	; 2
   1365e:	48 f4       	brcc	.+18     	; 0x13672 <FMenuSettings+0x154>
   13660:	8f 5f       	subi	r24, 0xFF	; 255
   13662:	05 c0       	rjmp	.+10     	; 0x1366e <FMenuSettings+0x150>
		  stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingBackPage:
	      if (PageSetting>1)PageSetting--;
   13664:	80 91 57 01 	lds	r24, 0x0157
   13668:	82 30       	cpi	r24, 0x02	; 2
   1366a:	18 f0       	brcs	.+6      	; 0x13672 <FMenuSettings+0x154>
   1366c:	81 50       	subi	r24, 0x01	; 1
   1366e:	80 93 57 01 	sts	0x0157, r24
		  stMenuSettings=msDisplayPage;
   13672:	81 e0       	ldi	r24, 0x01	; 1
   13674:	21 c0       	rjmp	.+66     	; 0x136b8 <FMenuSettings+0x19a>
	      break;
//---Sub Menu Operations--------------------------------------------		  
     case msMenuSettingProduct:
	      SubMenu=FSettingProduct();
   13676:	0e 94 f8 89 	call	0x113f0	; 0x113f0 <FSettingProduct>
   1367a:	1a c0       	rjmp	.+52     	; 0x136b0 <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingPump:
	      SubMenu=FSettingPump();
   1367c:	0e 94 91 77 	call	0xef22	; 0xef22 <FSettingPump>
   13680:	17 c0       	rjmp	.+46     	; 0x136b0 <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingDec:
	      SubMenu=FSettingDec();
   13682:	0e 94 a8 82 	call	0x10550	; 0x10550 <FSettingDec>
   13686:	14 c0       	rjmp	.+40     	; 0x136b0 <FMenuSettings+0x192>
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
   13688:	0e 94 4e 63 	call	0xc69c	; 0xc69c <_menu_datetime>
   1368c:	05 c0       	rjmp	.+10     	; 0x13698 <FMenuSettings+0x17a>
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
   1368e:	0e 94 a2 4b 	call	0x9744	; 0x9744 <_menu_printer>
   13692:	02 c0       	rjmp	.+4      	; 0x13698 <FMenuSettings+0x17a>
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
   13694:	0e 94 d9 46 	call	0x8db2	; 0x8db2 <_menu_host>
	 case msMenuSettingPrinter: 
	      SubMenu=FSettingPrinter();
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingHost:
	      SubMenu=FSettingHost();
   13698:	81 e0       	ldi	r24, 0x01	; 1
   1369a:	80 93 f0 02 	sts	0x02F0, r24
   1369e:	0c c0       	rjmp	.+24     	; 0x136b8 <FMenuSettings+0x19a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
     case msMenuSettingOperator:
          SubMenu=FSettingOperator();
   136a0:	0e 94 05 87 	call	0x10e0a	; 0x10e0a <FSettingOperator>
   136a4:	05 c0       	rjmp	.+10     	; 0x136b0 <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingSystem:
	      SubMenu=FSettingSystem();
   136a6:	0e 94 f0 98 	call	0x131e0	; 0x131e0 <FSettingSystem>
   136aa:	02 c0       	rjmp	.+4      	; 0x136b0 <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;	 
     case msMenuSettingPumpPooling:
	      SubMenu=FSettingPumpPooling();
   136ac:	0e 94 7e 6f 	call	0xdefc	; 0xdefc <FSettingPumpPooling>
   136b0:	80 93 f0 02 	sts	0x02F0, r24
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
   136b4:	81 30       	cpi	r24, 0x01	; 1
   136b6:	41 f4       	brne	.+16     	; 0x136c8 <FMenuSettings+0x1aa>
   136b8:	80 93 f3 02 	sts	0x02F3, r24
   136bc:	80 e0       	ldi	r24, 0x00	; 0
   136be:	08 95       	ret
	      break;
//------------------------------------------------------------------
     case msMenuSettingExit:
	      stMenuSettings=msInit;
   136c0:	10 92 f3 02 	sts	0x02F3, r1
   136c4:	81 e0       	ldi	r24, 0x01	; 1
   136c6:	08 95       	ret
   136c8:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   136ca:	08 95       	ret

000136cc <FMenuAuthorization>:


char FMenuAuthorization(){
char Result=MENU_NONE,PassResult=MP_NONE,SubMenu=MENU_NONE;
static char stMenuAuthorization=maInit,PassTry=0;
     switch(stMenuAuthorization){
   136cc:	80 91 32 03 	lds	r24, 0x0332
   136d0:	83 30       	cpi	r24, 0x03	; 3
   136d2:	69 f1       	breq	.+90     	; 0x1372e <FMenuAuthorization+0x62>
   136d4:	84 30       	cpi	r24, 0x04	; 4
   136d6:	28 f4       	brcc	.+10     	; 0x136e2 <FMenuAuthorization+0x16>
   136d8:	81 30       	cpi	r24, 0x01	; 1
   136da:	89 f0       	breq	.+34     	; 0x136fe <FMenuAuthorization+0x32>
   136dc:	82 30       	cpi	r24, 0x02	; 2
   136de:	50 f5       	brcc	.+84     	; 0x13734 <FMenuAuthorization+0x68>
   136e0:	0b c0       	rjmp	.+22     	; 0x136f8 <FMenuAuthorization+0x2c>
   136e2:	85 30       	cpi	r24, 0x05	; 5
   136e4:	79 f1       	breq	.+94     	; 0x13744 <FMenuAuthorization+0x78>
   136e6:	85 30       	cpi	r24, 0x05	; 5
   136e8:	40 f1       	brcs	.+80     	; 0x1373a <FMenuAuthorization+0x6e>
   136ea:	86 30       	cpi	r24, 0x06	; 6
   136ec:	09 f4       	brne	.+2      	; 0x136f0 <FMenuAuthorization+0x24>
   136ee:	41 c0       	rjmp	.+130    	; 0x13772 <FMenuAuthorization+0xa6>
   136f0:	87 30       	cpi	r24, 0x07	; 7
   136f2:	09 f0       	breq	.+2      	; 0x136f6 <FMenuAuthorization+0x2a>
   136f4:	51 c0       	rjmp	.+162    	; 0x13798 <FMenuAuthorization+0xcc>
   136f6:	4c c0       	rjmp	.+152    	; 0x13790 <FMenuAuthorization+0xc4>
	 case maInit:
	      PassTry=0;
   136f8:	10 92 31 03 	sts	0x0331, r1
   136fc:	42 c0       	rjmp	.+132    	; 0x13782 <FMenuAuthorization+0xb6>
		  stMenuAuthorization=maInputPassword;
	      break;
	 case maInputPassword:
	      PassResult=FMenuPassword();
   136fe:	0e 94 fc 91 	call	0x123f8	; 0x123f8 <FMenuPassword>
		  switch(PassResult){
   13702:	83 30       	cpi	r24, 0x03	; 3
   13704:	09 f4       	brne	.+2      	; 0x13708 <FMenuAuthorization+0x3c>
   13706:	40 c0       	rjmp	.+128    	; 0x13788 <FMenuAuthorization+0xbc>
   13708:	84 30       	cpi	r24, 0x04	; 4
   1370a:	30 f4       	brcc	.+12     	; 0x13718 <FMenuAuthorization+0x4c>
   1370c:	81 30       	cpi	r24, 0x01	; 1
   1370e:	d9 f1       	breq	.+118    	; 0x13786 <FMenuAuthorization+0xba>
   13710:	82 30       	cpi	r24, 0x02	; 2
   13712:	09 f0       	breq	.+2      	; 0x13716 <FMenuAuthorization+0x4a>
   13714:	41 c0       	rjmp	.+130    	; 0x13798 <FMenuAuthorization+0xcc>
   13716:	09 c0       	rjmp	.+18     	; 0x1372a <FMenuAuthorization+0x5e>
   13718:	84 30       	cpi	r24, 0x04	; 4
   1371a:	19 f0       	breq	.+6      	; 0x13722 <FMenuAuthorization+0x56>
   1371c:	85 30       	cpi	r24, 0x05	; 5
   1371e:	e1 f5       	brne	.+120    	; 0x13798 <FMenuAuthorization+0xcc>
   13720:	02 c0       	rjmp	.+4      	; 0x13726 <FMenuAuthorization+0x5a>
		  case MP_VALID_ADMIN:
		       stMenuAuthorization=maMenuAdmin;
   13722:	82 e0       	ldi	r24, 0x02	; 2
   13724:	31 c0       	rjmp	.+98     	; 0x13788 <FMenuAuthorization+0xbc>
		       break;
		  case MP_VALID_SYSTEM:
		       stMenuAuthorization=maMenuSettings;
   13726:	84 e0       	ldi	r24, 0x04	; 4
   13728:	2f c0       	rjmp	.+94     	; 0x13788 <FMenuAuthorization+0xbc>
		       break;
		  case MP_INVALID:
		       stMenuAuthorization=maInvalidAuthorization;
   1372a:	85 e0       	ldi	r24, 0x05	; 5
   1372c:	2d c0       	rjmp	.+90     	; 0x13788 <FMenuAuthorization+0xbc>
		  else
	      if (PassResult==MP_CANCEL)stMenuAuthorization=maExitAuthorization;
		  */
	      break;
	 case maMenuMaster:
	      SubMenu=FMenuMaster();
   1372e:	0e 94 e5 8f 	call	0x11fca	; 0x11fca <FMenuMaster>
   13732:	05 c0       	rjmp	.+10     	; 0x1373e <FMenuAuthorization+0x72>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
	      break;
	 case maMenuAdmin:
          SubMenu=FMenuAdmin();
   13734:	0e 94 f5 93 	call	0x127ea	; 0x127ea <FMenuAdmin>
   13738:	02 c0       	rjmp	.+4      	; 0x1373e <FMenuAuthorization+0x72>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;          
		  break;
	 case maMenuSettings:
	      SubMenu=FMenuSettings();
   1373a:	0e 94 8f 9a 	call	0x1351e	; 0x1351e <FMenuSettings>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
   1373e:	81 30       	cpi	r24, 0x01	; 1
   13740:	59 f5       	brne	.+86     	; 0x13798 <FMenuAuthorization+0xcc>
   13742:	21 c0       	rjmp	.+66     	; 0x13786 <FMenuAuthorization+0xba>
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
   13744:	80 91 31 03 	lds	r24, 0x0331
   13748:	8f 5f       	subi	r24, 0xFF	; 255
   1374a:	80 93 31 03 	sts	0x0331, r24
	      TimDisplay=0;
   1374e:	10 92 a7 01 	sts	0x01A7, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   13752:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   13754:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   13756:	81 e0       	ldi	r24, 0x01	; 1
   13758:	90 e0       	ldi	r25, 0x00	; 0
   1375a:	90 93 d7 01 	sts	0x01D7, r25
   1375e:	80 93 d6 01 	sts	0x01D6, r24
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
	      TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   13762:	83 e0       	ldi	r24, 0x03	; 3
   13764:	61 e0       	ldi	r22, 0x01	; 1
   13766:	47 e1       	ldi	r20, 0x17	; 23
   13768:	58 e1       	ldi	r21, 0x18	; 24
   1376a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		  stMenuAuthorization=maDelayExitAuthorization;
   1376e:	86 e0       	ldi	r24, 0x06	; 6
   13770:	0b c0       	rjmp	.+22     	; 0x13788 <FMenuAuthorization+0xbc>
          break;	 
	 case maDelayExitAuthorization:
	      if (TimDisplay>2){
   13772:	80 91 a7 01 	lds	r24, 0x01A7
   13776:	83 30       	cpi	r24, 0x03	; 3
   13778:	78 f0       	brcs	.+30     	; 0x13798 <FMenuAuthorization+0xcc>
		      if (PassTry<3)stMenuAuthorization=maInputPassword;
   1377a:	80 91 31 03 	lds	r24, 0x0331
   1377e:	83 30       	cpi	r24, 0x03	; 3
   13780:	10 f4       	brcc	.+4      	; 0x13786 <FMenuAuthorization+0xba>
   13782:	81 e0       	ldi	r24, 0x01	; 1
   13784:	01 c0       	rjmp	.+2      	; 0x13788 <FMenuAuthorization+0xbc>
			  else stMenuAuthorization=maExitAuthorization;
   13786:	87 e0       	ldi	r24, 0x07	; 7
   13788:	80 93 32 03 	sts	0x0332, r24
   1378c:	80 e0       	ldi	r24, 0x00	; 0
   1378e:	08 95       	ret
		  }
	      break;
	 case maExitAuthorization:
	      stMenuAuthorization=maInit;
   13790:	10 92 32 03 	sts	0x0332, r1
   13794:	81 e0       	ldi	r24, 0x01	; 1
   13796:	08 95       	ret
   13798:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;	 
}
   1379a:	08 95       	ret

0001379c <InitComport>:
     	  break;	 
	 }
   return Result;
}

void InitComport(){
   1379c:	af 92       	push	r10
   1379e:	bf 92       	push	r11
   137a0:	cf 92       	push	r12
   137a2:	df 92       	push	r13
   137a4:	ff 92       	push	r15
   137a6:	0f 93       	push	r16
   137a8:	1f 93       	push	r17
   137aa:	df 93       	push	r29
   137ac:	cf 93       	push	r28
   137ae:	cd b7       	in	r28, 0x3d	; 61
   137b0:	de b7       	in	r29, 0x3e	; 62
   137b2:	64 97       	sbiw	r28, 0x14	; 20
   137b4:	0f b6       	in	r0, 0x3f	; 63
   137b6:	f8 94       	cli
   137b8:	de bf       	out	0x3e, r29	; 62
   137ba:	0f be       	out	0x3f, r0	; 63
   137bc:	cd bf       	out	0x3d, r28	; 61
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
   137be:	83 e0       	ldi	r24, 0x03	; 3
   137c0:	61 e0       	ldi	r22, 0x01	; 1
   137c2:	4b ea       	ldi	r20, 0xAB	; 171
   137c4:	5c e1       	ldi	r21, 0x1C	; 28
   137c6:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   137ca:	01 e0       	ldi	r16, 0x01	; 1
   137cc:	10 e0       	ldi	r17, 0x00	; 0
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   137ce:	6e 01       	movw	r12, r28
   137d0:	08 94       	sec
   137d2:	c1 1c       	adc	r12, r1
   137d4:	d1 1c       	adc	r13, r1
   137d6:	f7 e9       	ldi	r31, 0x97	; 151
   137d8:	af 2e       	mov	r10, r31
   137da:	fc e1       	ldi	r31, 0x1C	; 28
   137dc:	bf 2e       	mov	r11, r31
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   137de:	e1 99       	sbic	0x1c, 1	; 28
   137e0:	fe cf       	rjmp	.-4      	; 0x137de <InitComport+0x42>
   137e2:	c8 01       	movw	r24, r16
   137e4:	81 5c       	subi	r24, 0xC1	; 193
   137e6:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   137e8:	9f bb       	out	0x1f, r25	; 31
   137ea:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   137ec:	e0 9a       	sbi	0x1c, 0	; 28
   137ee:	fd b2       	in	r15, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   137f0:	22 e0       	ldi	r18, 0x02	; 2
   137f2:	f2 16       	cp	r15, r18
   137f4:	71 f0       	breq	.+28     	; 0x13812 <InitComport+0x76>
   137f6:	f2 16       	cp	r15, r18
   137f8:	30 f0       	brcs	.+12     	; 0x13806 <InitComport+0x6a>
   137fa:	33 e0       	ldi	r19, 0x03	; 3
   137fc:	f3 16       	cp	r15, r19
   137fe:	31 f4       	brne	.+12     	; 0x1380c <InitComport+0x70>
   13800:	85 eb       	ldi	r24, 0xB5	; 181
   13802:	9f e2       	ldi	r25, 0x2F	; 47
   13804:	08 c0       	rjmp	.+16     	; 0x13816 <InitComport+0x7a>
   13806:	80 e8       	ldi	r24, 0x80	; 128
   13808:	95 e2       	ldi	r25, 0x25	; 37
   1380a:	05 c0       	rjmp	.+10     	; 0x13816 <InitComport+0x7a>
   1380c:	80 e0       	ldi	r24, 0x00	; 0
   1380e:	90 e0       	ldi	r25, 0x00	; 0
   13810:	02 c0       	rjmp	.+4      	; 0x13816 <InitComport+0x7a>
   13812:	80 e0       	ldi	r24, 0x00	; 0
   13814:	9b e4       	ldi	r25, 0x4B	; 75
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   13816:	ad b7       	in	r26, 0x3d	; 61
   13818:	be b7       	in	r27, 0x3e	; 62
   1381a:	18 97       	sbiw	r26, 0x08	; 8
   1381c:	0f b6       	in	r0, 0x3f	; 63
   1381e:	f8 94       	cli
   13820:	be bf       	out	0x3e, r27	; 62
   13822:	0f be       	out	0x3f, r0	; 63
   13824:	ad bf       	out	0x3d, r26	; 61
   13826:	ed b7       	in	r30, 0x3d	; 61
   13828:	fe b7       	in	r31, 0x3e	; 62
   1382a:	31 96       	adiw	r30, 0x01	; 1
   1382c:	12 96       	adiw	r26, 0x02	; 2
   1382e:	dc 92       	st	X, r13
   13830:	ce 92       	st	-X, r12
   13832:	11 97       	sbiw	r26, 0x01	; 1
   13834:	b3 82       	std	Z+3, r11	; 0x03
   13836:	a2 82       	std	Z+2, r10	; 0x02
   13838:	15 83       	std	Z+5, r17	; 0x05
   1383a:	04 83       	std	Z+4, r16	; 0x04
   1383c:	97 83       	std	Z+7, r25	; 0x07
   1383e:	86 83       	std	Z+6, r24	; 0x06
   13840:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		 lcd_print(4,1,lcdteks);
   13844:	2d b7       	in	r18, 0x3d	; 61
   13846:	3e b7       	in	r19, 0x3e	; 62
   13848:	28 5f       	subi	r18, 0xF8	; 248
   1384a:	3f 4f       	sbci	r19, 0xFF	; 255
   1384c:	0f b6       	in	r0, 0x3f	; 63
   1384e:	f8 94       	cli
   13850:	3e bf       	out	0x3e, r19	; 62
   13852:	0f be       	out	0x3f, r0	; 63
   13854:	2d bf       	out	0x3d, r18	; 61
   13856:	84 e0       	ldi	r24, 0x04	; 4
   13858:	61 e0       	ldi	r22, 0x01	; 1
   1385a:	a6 01       	movw	r20, r12
   1385c:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		 SetBaudRate(i+1,brMap);
   13860:	80 2f       	mov	r24, r16
   13862:	6f 2d       	mov	r22, r15
   13864:	0e 94 ba 98 	call	0x13174	; 0x13174 <SetBaudRate>
 	     TimDisplay=0;
   13868:	10 92 a7 01 	sts	0x01A7, r1
   1386c:	04 c0       	rjmp	.+8      	; 0x13876 <InitComport+0xda>
	     while(TimDisplay<2){
		     if (TimDisplay>2)break;
   1386e:	80 91 a7 01 	lds	r24, 0x01A7
   13872:	83 30       	cpi	r24, 0x03	; 3
   13874:	20 f4       	brcc	.+8      	; 0x1387e <InitComport+0xe2>
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
		 lcd_print(4,1,lcdteks);
		 SetBaudRate(i+1,brMap);
 	     TimDisplay=0;
	     while(TimDisplay<2){
   13876:	80 91 a7 01 	lds	r24, 0x01A7
   1387a:	82 30       	cpi	r24, 0x02	; 2
   1387c:	c0 f3       	brcs	.-16     	; 0x1386e <InitComport+0xd2>
   1387e:	0f 5f       	subi	r16, 0xFF	; 255
   13880:	1f 4f       	sbci	r17, 0xFF	; 255

void InitComport(){
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
   13882:	05 30       	cpi	r16, 0x05	; 5
   13884:	11 05       	cpc	r17, r1
   13886:	09 f0       	breq	.+2      	; 0x1388a <InitComport+0xee>
   13888:	aa cf       	rjmp	.-172    	; 0x137de <InitComport+0x42>
	     while(TimDisplay<2){
		     if (TimDisplay>2)break;
		 };

	 }
}
   1388a:	64 96       	adiw	r28, 0x14	; 20
   1388c:	0f b6       	in	r0, 0x3f	; 63
   1388e:	f8 94       	cli
   13890:	de bf       	out	0x3e, r29	; 62
   13892:	0f be       	out	0x3f, r0	; 63
   13894:	cd bf       	out	0x3d, r28	; 61
   13896:	cf 91       	pop	r28
   13898:	df 91       	pop	r29
   1389a:	1f 91       	pop	r17
   1389c:	0f 91       	pop	r16
   1389e:	ff 90       	pop	r15
   138a0:	df 90       	pop	r13
   138a2:	cf 90       	pop	r12
   138a4:	bf 90       	pop	r11
   138a6:	af 90       	pop	r10
   138a8:	08 95       	ret

000138aa <sendMessage56>:
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);

}

void sendMessage56(){
   138aa:	0f 93       	push	r16
   138ac:	1f 93       	push	r17
   138ae:	df 93       	push	r29
   138b0:	cf 93       	push	r28
   138b2:	cd b7       	in	r28, 0x3d	; 61
   138b4:	de b7       	in	r29, 0x3e	; 62
   138b6:	ec 97       	sbiw	r28, 0x3c	; 60
   138b8:	0f b6       	in	r0, 0x3f	; 63
   138ba:	f8 94       	cli
   138bc:	de bf       	out	0x3e, r29	; 62
   138be:	0f be       	out	0x3f, r0	; 63
   138c0:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
   138c2:	81 e0       	ldi	r24, 0x01	; 1
   138c4:	61 e0       	ldi	r22, 0x01	; 1
   138c6:	41 e0       	ldi	r20, 0x01	; 1
   138c8:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
   138cc:	0e 94 0d 1c 	call	0x381a	; 0x381a <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
   138d0:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
   138d4:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
   138d8:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <UpdateServerIP>
	UpdateCardID();  //ReadCardID
   138dc:	0e 94 51 40 	call	0x80a2	; 0x80a2 <UpdateCardID>

	sprintf_P(strSend,PSTR("%s%s%s"),strIFT_ID,strSeqNum,strClientIP);
   138e0:	8d b7       	in	r24, 0x3d	; 61
   138e2:	9e b7       	in	r25, 0x3e	; 62
   138e4:	0a 97       	sbiw	r24, 0x0a	; 10
   138e6:	0f b6       	in	r0, 0x3f	; 63
   138e8:	f8 94       	cli
   138ea:	9e bf       	out	0x3e, r25	; 62
   138ec:	0f be       	out	0x3f, r0	; 63
   138ee:	8d bf       	out	0x3d, r24	; 61
   138f0:	ed b7       	in	r30, 0x3d	; 61
   138f2:	fe b7       	in	r31, 0x3e	; 62
   138f4:	31 96       	adiw	r30, 0x01	; 1
   138f6:	8e 01       	movw	r16, r28
   138f8:	0f 5f       	subi	r16, 0xFF	; 255
   138fa:	1f 4f       	sbci	r17, 0xFF	; 255
   138fc:	ad b7       	in	r26, 0x3d	; 61
   138fe:	be b7       	in	r27, 0x3e	; 62
   13900:	12 96       	adiw	r26, 0x02	; 2
   13902:	1c 93       	st	X, r17
   13904:	0e 93       	st	-X, r16
   13906:	11 97       	sbiw	r26, 0x01	; 1
   13908:	8b e6       	ldi	r24, 0x6B	; 107
   1390a:	91 e2       	ldi	r25, 0x21	; 33
   1390c:	93 83       	std	Z+3, r25	; 0x03
   1390e:	82 83       	std	Z+2, r24	; 0x02
   13910:	8c ec       	ldi	r24, 0xCC	; 204
   13912:	95 e0       	ldi	r25, 0x05	; 5
   13914:	95 83       	std	Z+5, r25	; 0x05
   13916:	84 83       	std	Z+4, r24	; 0x04
   13918:	89 e3       	ldi	r24, 0x39	; 57
   1391a:	9f e0       	ldi	r25, 0x0F	; 15
   1391c:	97 83       	std	Z+7, r25	; 0x07
   1391e:	86 83       	std	Z+6, r24	; 0x06
   13920:	88 ea       	ldi	r24, 0xA8	; 168
   13922:	99 e0       	ldi	r25, 0x09	; 9
   13924:	91 87       	std	Z+9, r25	; 0x09
   13926:	80 87       	std	Z+8, r24	; 0x08
   13928:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
   1392c:	8d b7       	in	r24, 0x3d	; 61
   1392e:	9e b7       	in	r25, 0x3e	; 62
   13930:	0a 96       	adiw	r24, 0x0a	; 10
   13932:	0f b6       	in	r0, 0x3f	; 63
   13934:	f8 94       	cli
   13936:	9e bf       	out	0x3e, r25	; 62
   13938:	0f be       	out	0x3f, r0	; 63
   1393a:	8d bf       	out	0x3d, r24	; 61
   1393c:	81 e0       	ldi	r24, 0x01	; 1
   1393e:	60 e0       	ldi	r22, 0x00	; 0
   13940:	a8 01       	movw	r20, r16
   13942:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
	sprintf_P(strSend,PSTR("%s56"),strServerIP);
   13946:	00 d0       	rcall	.+0      	; 0x13948 <sendMessage56+0x9e>
   13948:	00 d0       	rcall	.+0      	; 0x1394a <sendMessage56+0xa0>
   1394a:	00 d0       	rcall	.+0      	; 0x1394c <sendMessage56+0xa2>
   1394c:	ed b7       	in	r30, 0x3d	; 61
   1394e:	fe b7       	in	r31, 0x3e	; 62
   13950:	31 96       	adiw	r30, 0x01	; 1
   13952:	ad b7       	in	r26, 0x3d	; 61
   13954:	be b7       	in	r27, 0x3e	; 62
   13956:	12 96       	adiw	r26, 0x02	; 2
   13958:	1c 93       	st	X, r17
   1395a:	0e 93       	st	-X, r16
   1395c:	11 97       	sbiw	r26, 0x01	; 1
   1395e:	86 e6       	ldi	r24, 0x66	; 102
   13960:	91 e2       	ldi	r25, 0x21	; 33
   13962:	93 83       	std	Z+3, r25	; 0x03
   13964:	82 83       	std	Z+2, r24	; 0x02
   13966:	85 ed       	ldi	r24, 0xD5	; 213
   13968:	99 e0       	ldi	r25, 0x09	; 9
   1396a:	95 83       	std	Z+5, r25	; 0x05
   1396c:	84 83       	std	Z+4, r24	; 0x04
   1396e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);
   13972:	8d b7       	in	r24, 0x3d	; 61
   13974:	9e b7       	in	r25, 0x3e	; 62
   13976:	06 96       	adiw	r24, 0x06	; 6
   13978:	0f b6       	in	r0, 0x3f	; 63
   1397a:	f8 94       	cli
   1397c:	9e bf       	out	0x3e, r25	; 62
   1397e:	0f be       	out	0x3f, r0	; 63
   13980:	8d bf       	out	0x3d, r24	; 61
   13982:	81 e0       	ldi	r24, 0x01	; 1
   13984:	60 e0       	ldi	r22, 0x00	; 0
   13986:	a8 01       	movw	r20, r16
   13988:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
    sprintf_P(strSend,PSTR("%s"),strCardID);
   1398c:	00 d0       	rcall	.+0      	; 0x1398e <sendMessage56+0xe4>
   1398e:	00 d0       	rcall	.+0      	; 0x13990 <sendMessage56+0xe6>
   13990:	00 d0       	rcall	.+0      	; 0x13992 <sendMessage56+0xe8>
   13992:	ed b7       	in	r30, 0x3d	; 61
   13994:	fe b7       	in	r31, 0x3e	; 62
   13996:	31 96       	adiw	r30, 0x01	; 1
   13998:	ad b7       	in	r26, 0x3d	; 61
   1399a:	be b7       	in	r27, 0x3e	; 62
   1399c:	12 96       	adiw	r26, 0x02	; 2
   1399e:	1c 93       	st	X, r17
   139a0:	0e 93       	st	-X, r16
   139a2:	11 97       	sbiw	r26, 0x01	; 1
   139a4:	83 e6       	ldi	r24, 0x63	; 99
   139a6:	91 e2       	ldi	r25, 0x21	; 33
   139a8:	93 83       	std	Z+3, r25	; 0x03
   139aa:	82 83       	std	Z+2, r24	; 0x02
   139ac:	8f ee       	ldi	r24, 0xEF	; 239
   139ae:	9e e0       	ldi	r25, 0x0E	; 14
   139b0:	95 83       	std	Z+5, r25	; 0x05
   139b2:	84 83       	std	Z+4, r24	; 0x04
   139b4:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
    _uart_print(1, 0,strSend);	
   139b8:	8d b7       	in	r24, 0x3d	; 61
   139ba:	9e b7       	in	r25, 0x3e	; 62
   139bc:	06 96       	adiw	r24, 0x06	; 6
   139be:	0f b6       	in	r0, 0x3f	; 63
   139c0:	f8 94       	cli
   139c2:	9e bf       	out	0x3e, r25	; 62
   139c4:	0f be       	out	0x3f, r0	; 63
   139c6:	8d bf       	out	0x3d, r24	; 61
   139c8:	81 e0       	ldi	r24, 0x01	; 1
   139ca:	60 e0       	ldi	r22, 0x00	; 0
   139cc:	a8 01       	movw	r20, r16
   139ce:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>

	_uart_printf(1,0,PSTR("AF968CFFB"));
   139d2:	81 e0       	ldi	r24, 0x01	; 1
   139d4:	60 e0       	ldi	r22, 0x00	; 0
   139d6:	49 e5       	ldi	r20, 0x59	; 89
   139d8:	51 e2       	ldi	r21, 0x21	; 33
   139da:	0e 94 12 b4 	call	0x16824	; 0x16824 <_uart_printf>
	_uart(1, 1,0x02);
   139de:	81 e0       	ldi	r24, 0x01	; 1
   139e0:	61 e0       	ldi	r22, 0x01	; 1
   139e2:	42 e0       	ldi	r20, 0x02	; 2
   139e4:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
}
   139e8:	ec 96       	adiw	r28, 0x3c	; 60
   139ea:	0f b6       	in	r0, 0x3f	; 63
   139ec:	f8 94       	cli
   139ee:	de bf       	out	0x3e, r29	; 62
   139f0:	0f be       	out	0x3f, r0	; 63
   139f2:	cd bf       	out	0x3d, r28	; 61
   139f4:	cf 91       	pop	r28
   139f6:	df 91       	pop	r29
   139f8:	1f 91       	pop	r17
   139fa:	0f 91       	pop	r16
   139fc:	08 95       	ret

000139fe <FMenuLocalAccount>:
		 }
	 else PORTG=PORTG|0x02;
}


char FMenuLocalAccount(){
   139fe:	af 92       	push	r10
   13a00:	bf 92       	push	r11
   13a02:	cf 92       	push	r12
   13a04:	df 92       	push	r13
   13a06:	ef 92       	push	r14
   13a08:	ff 92       	push	r15
   13a0a:	0f 93       	push	r16
   13a0c:	1f 93       	push	r17
   13a0e:	df 93       	push	r29
   13a10:	cf 93       	push	r28
   13a12:	cd b7       	in	r28, 0x3d	; 61
   13a14:	de b7       	in	r29, 0x3e	; 62
   13a16:	a9 97       	sbiw	r28, 0x29	; 41
   13a18:	0f b6       	in	r0, 0x3f	; 63
   13a1a:	f8 94       	cli
   13a1c:	de bf       	out	0x3e, r29	; 62
   13a1e:	0f be       	out	0x3f, r0	; 63
   13a20:	cd bf       	out	0x3d, r28	; 61
       char strName[21];//,strPumpL[3],strPumpR[3];
       char Result;

	   Result=MENU_NONE;
	                                 //|   Local Account   |          
	       switch(stLocalAccount){   //|ID: ACD12345       |
   13a22:	80 91 5c 01 	lds	r24, 0x015C
   13a26:	90 e0       	ldi	r25, 0x00	; 0
   13a28:	fc 01       	movw	r30, r24
   13a2a:	31 97       	sbiw	r30, 0x01	; 1
   13a2c:	ef 31       	cpi	r30, 0x1F	; 31
   13a2e:	f1 05       	cpc	r31, r1
   13a30:	10 f0       	brcs	.+4      	; 0x13a36 <FMenuLocalAccount+0x38>
   13a32:	0c 94 2b a7 	jmp	0x14e56	; 0x14e56 <FMenuLocalAccount+0x1458>
   13a36:	eb 50       	subi	r30, 0x0B	; 11
   13a38:	ff 4f       	sbci	r31, 0xFF	; 255
   13a3a:	ee 0f       	add	r30, r30
   13a3c:	ff 1f       	adc	r31, r31
   13a3e:	05 90       	lpm	r0, Z+
   13a40:	f4 91       	lpm	r31, Z+
   13a42:	e0 2d       	mov	r30, r0
   13a44:	09 94       	ijmp
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
   13a46:	81 e0       	ldi	r24, 0x01	; 1
   13a48:	80 93 bf 03 	sts	0x03BF, r24
   13a4c:	10 92 c0 03 	sts	0x03C0, r1
   13a50:	80 91 65 00 	lds	r24, 0x0065
   13a54:	8d 7f       	andi	r24, 0xFD	; 253
   13a56:	80 93 65 00 	sts	0x0065, r24
   13a5a:	20 e0       	ldi	r18, 0x00	; 0
   13a5c:	30 e0       	ldi	r19, 0x00	; 0
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   13a5e:	f9 01       	movw	r30, r18
   13a60:	e1 51       	subi	r30, 0x11	; 17
   13a62:	f1 4f       	sbci	r31, 0xF1	; 241
   13a64:	d9 01       	movw	r26, r18
   13a66:	ac 55       	subi	r26, 0x5C	; 92
   13a68:	b0 4f       	sbci	r27, 0xF0	; 240
   13a6a:	8c 91       	ld	r24, X
   13a6c:	80 83       	st	Z, r24
   13a6e:	2f 5f       	subi	r18, 0xFF	; 255
   13a70:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   13a72:	28 30       	cpi	r18, 0x08	; 8
   13a74:	31 05       	cpc	r19, r1
   13a76:	99 f7       	brne	.-26     	; 0x13a5e <FMenuLocalAccount+0x60>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   13a78:	10 92 f7 0e 	sts	0x0EF7, r1
	       switch(stLocalAccount){   //|ID: ACD12345       |
	       case laInit:              //|Process ...        |
		        //Process RFID Data  //|                   |
				//UpdateCardID();
                BackLightTrig();ViewCardID();
	            lcd_clear();
   13a7c:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
	            lcd_printf(1,1,PSTR("   Local Account   "));
   13a80:	81 e0       	ldi	r24, 0x01	; 1
   13a82:	61 e0       	ldi	r22, 0x01	; 1
   13a84:	43 eb       	ldi	r20, 0xB3	; 179
   13a86:	50 e2       	ldi	r21, 0x20	; 32
   13a88:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	            sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   13a8c:	00 d0       	rcall	.+0      	; 0x13a8e <FMenuLocalAccount+0x90>
   13a8e:	00 d0       	rcall	.+0      	; 0x13a90 <FMenuLocalAccount+0x92>
   13a90:	00 d0       	rcall	.+0      	; 0x13a92 <FMenuLocalAccount+0x94>
   13a92:	ed b7       	in	r30, 0x3d	; 61
   13a94:	fe b7       	in	r31, 0x3e	; 62
   13a96:	31 96       	adiw	r30, 0x01	; 1
   13a98:	8e 01       	movw	r16, r28
   13a9a:	0f 5f       	subi	r16, 0xFF	; 255
   13a9c:	1f 4f       	sbci	r17, 0xFF	; 255
   13a9e:	ad b7       	in	r26, 0x3d	; 61
   13aa0:	be b7       	in	r27, 0x3e	; 62
   13aa2:	12 96       	adiw	r26, 0x02	; 2
   13aa4:	1c 93       	st	X, r17
   13aa6:	0e 93       	st	-X, r16
   13aa8:	11 97       	sbiw	r26, 0x01	; 1
   13aaa:	8d ea       	ldi	r24, 0xAD	; 173
   13aac:	90 e2       	ldi	r25, 0x20	; 32
   13aae:	93 83       	std	Z+3, r25	; 0x03
   13ab0:	82 83       	std	Z+2, r24	; 0x02
   13ab2:	8f ee       	ldi	r24, 0xEF	; 239
   13ab4:	9e e0       	ldi	r25, 0x0E	; 14
   13ab6:	95 83       	std	Z+5, r25	; 0x05
   13ab8:	84 83       	std	Z+4, r24	; 0x04
   13aba:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   13abe:	ed b7       	in	r30, 0x3d	; 61
   13ac0:	fe b7       	in	r31, 0x3e	; 62
   13ac2:	36 96       	adiw	r30, 0x06	; 6
   13ac4:	0f b6       	in	r0, 0x3f	; 63
   13ac6:	f8 94       	cli
   13ac8:	fe bf       	out	0x3e, r31	; 62
   13aca:	0f be       	out	0x3f, r0	; 63
   13acc:	ed bf       	out	0x3d, r30	; 61
   13ace:	82 e0       	ldi	r24, 0x02	; 2
   13ad0:	61 e0       	ldi	r22, 0x01	; 1
   13ad2:	a8 01       	movw	r20, r16
   13ad4:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
                lcd_printf(3,1,PSTR("Proses"));
   13ad8:	83 e0       	ldi	r24, 0x03	; 3
   13ada:	61 e0       	ldi	r22, 0x01	; 1
   13adc:	46 ea       	ldi	r20, 0xA6	; 166
   13ade:	50 e2       	ldi	r21, 0x20	; 32
   13ae0:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				iPos=0;iLoop=0;
   13ae4:	10 92 a3 03 	sts	0x03A3, r1
   13ae8:	10 92 73 03 	sts	0x0373, r1
   13aec:	10 92 72 03 	sts	0x0372, r1
				IsFullAuthorized=False;
   13af0:	10 92 74 03 	sts	0x0374, r1
		        stLocalAccount=laSendID;
   13af4:	82 e0       	ldi	r24, 0x02	; 2
   13af6:	dc c6       	rjmp	.+3512   	; 0x148b0 <FMenuLocalAccount+0xeb2>
				break;         
           case laSendID://sendMessage56 
				IsMessage57=False;
   13af8:	10 92 bc 01 	sts	0x01BC, r1
                sendMessage56();
   13afc:	0e 94 55 9c 	call	0x138aa	; 0x138aa <sendMessage56>
				iWait=0;iLoop=0;iPos=0;
   13b00:	10 92 a2 03 	sts	0x03A2, r1
   13b04:	10 92 73 03 	sts	0x0373, r1
   13b08:	10 92 72 03 	sts	0x0372, r1
   13b0c:	10 92 a3 03 	sts	0x03A3, r1
				stLocalAccount=laWaitMessage57;
   13b10:	83 e0       	ldi	r24, 0x03	; 3
   13b12:	ce c6       	rjmp	.+3484   	; 0x148b0 <FMenuLocalAccount+0xeb2>
		        break;
           case laWaitMessage57:
		        iLoop++;
   13b14:	80 91 72 03 	lds	r24, 0x0372
   13b18:	90 91 73 03 	lds	r25, 0x0373
   13b1c:	01 96       	adiw	r24, 0x01	; 1
   13b1e:	90 93 73 03 	sts	0x0373, r25
   13b22:	80 93 72 03 	sts	0x0372, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   13b26:	68 e9       	ldi	r22, 0x98	; 152
   13b28:	7a e3       	ldi	r23, 0x3A	; 58
   13b2a:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
   13b2e:	89 2b       	or	r24, r25
   13b30:	e1 f4       	brne	.+56     	; 0x13b6a <FMenuLocalAccount+0x16c>
				   if (iPos<5){
   13b32:	60 91 a3 03 	lds	r22, 0x03A3
   13b36:	65 30       	cpi	r22, 0x05	; 5
   13b38:	58 f4       	brcc	.+22     	; 0x13b50 <FMenuLocalAccount+0x152>
					   lcd_put(3,(8+iPos),'.');
   13b3a:	68 5f       	subi	r22, 0xF8	; 248
   13b3c:	83 e0       	ldi	r24, 0x03	; 3
   13b3e:	4e e2       	ldi	r20, 0x2E	; 46
   13b40:	0e 94 d2 ae 	call	0x15da4	; 0x15da4 <lcd_put>
				       iPos++;
   13b44:	80 91 a3 03 	lds	r24, 0x03A3
   13b48:	8f 5f       	subi	r24, 0xFF	; 255
   13b4a:	80 93 a3 03 	sts	0x03A3, r24
   13b4e:	0d c0       	rjmp	.+26     	; 0x13b6a <FMenuLocalAccount+0x16c>
					   }
				   else{
				       iPos=0;
   13b50:	10 92 a3 03 	sts	0x03A3, r1
					   lcd_printf(3,(9+iPos),PSTR("       "));
   13b54:	83 e0       	ldi	r24, 0x03	; 3
   13b56:	69 e0       	ldi	r22, 0x09	; 9
   13b58:	4e e9       	ldi	r20, 0x9E	; 158
   13b5a:	50 e2       	ldi	r21, 0x20	; 32
   13b5c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
					   iWait++;
   13b60:	80 91 a2 03 	lds	r24, 0x03A2
   13b64:	8f 5f       	subi	r24, 0xFF	; 255
   13b66:	80 93 a2 03 	sts	0x03A2, r24
					   }
				}
				if (iWait>3){
   13b6a:	80 91 a2 03 	lds	r24, 0x03A2
   13b6e:	84 30       	cpi	r24, 0x04	; 4
   13b70:	78 f0       	brcs	.+30     	; 0x13b90 <FMenuLocalAccount+0x192>
				    stLocalAccount=laConTimout;
   13b72:	84 e0       	ldi	r24, 0x04	; 4
   13b74:	80 93 5c 01 	sts	0x015C, r24
					TimLocAcc=0;
   13b78:	10 92 d3 01 	sts	0x01D3, r1
   13b7c:	10 92 d2 01 	sts	0x01D2, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   13b80:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   13b82:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   13b84:	82 e0       	ldi	r24, 0x02	; 2
   13b86:	90 e0       	ldi	r25, 0x00	; 0
   13b88:	90 93 d7 01 	sts	0x01D7, r25
   13b8c:	80 93 d6 01 	sts	0x01D6, r24
				if (iWait>3){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage57==True){
   13b90:	80 91 bc 01 	lds	r24, 0x01BC
   13b94:	81 30       	cpi	r24, 0x01	; 1
   13b96:	11 f0       	breq	.+4      	; 0x13b9c <FMenuLocalAccount+0x19e>
   13b98:	0c 94 2b a7 	jmp	0x14e56	; 0x14e56 <FMenuLocalAccount+0x1458>
				    IsMessage57=False;
   13b9c:	10 92 bc 01 	sts	0x01BC, r1
				    stLocalAccount=laProcMessage57;
   13ba0:	85 e0       	ldi	r24, 0x05	; 5
   13ba2:	86 c6       	rjmp	.+3340   	; 0x148b0 <FMenuLocalAccount+0xeb2>
					}
		        break;
           case laConTimout:
		        //IsErrorTCPIP=True;
				lcd_printf(3,1,PSTR("Sending Failed      "));
   13ba4:	83 e0       	ldi	r24, 0x03	; 3
   13ba6:	61 e0       	ldi	r22, 0x01	; 1
   13ba8:	49 e8       	ldi	r20, 0x89	; 137
   13baa:	50 e2       	ldi	r21, 0x20	; 32
   13bac:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
   13bb0:	84 e0       	ldi	r24, 0x04	; 4
   13bb2:	61 e0       	ldi	r22, 0x01	; 1
   13bb4:	44 e7       	ldi	r20, 0x74	; 116
   13bb6:	50 e2       	ldi	r21, 0x20	; 32
   13bb8:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
   13bbc:	80 91 d2 01 	lds	r24, 0x01D2
   13bc0:	90 91 d3 01 	lds	r25, 0x01D3
   13bc4:	03 97       	sbiw	r24, 0x03	; 3
   13bc6:	10 f4       	brcc	.+4      	; 0x13bcc <FMenuLocalAccount+0x1ce>
   13bc8:	0c 94 2b a7 	jmp	0x14e56	; 0x14e56 <FMenuLocalAccount+0x1458>
   13bcc:	0c 94 22 a7 	jmp	0x14e44	; 0x14e44 <FMenuLocalAccount+0x1446>
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
   13bd0:	83 e0       	ldi	r24, 0x03	; 3
   13bd2:	61 e0       	ldi	r22, 0x01	; 1
   13bd4:	4f e5       	ldi	r20, 0x5F	; 95
   13bd6:	50 e2       	ldi	r21, 0x20	; 32
   13bd8:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				LocAccStatus=GetLocAccStatus(procMessage57());
   13bdc:	0e 94 92 26 	call	0x4d24	; 0x4d24 <procMessage57>


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
   13be0:	81 30       	cpi	r24, 0x01	; 1
   13be2:	29 f0       	breq	.+10     	; 0x13bee <FMenuLocalAccount+0x1f0>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
   13be4:	82 30       	cpi	r24, 0x02	; 2
   13be6:	19 f0       	breq	.+6      	; 0x13bee <FMenuLocalAccount+0x1f0>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
   13be8:	83 30       	cpi	r24, 0x03	; 3
   13bea:	09 f0       	breq	.+2      	; 0x13bee <FMenuLocalAccount+0x1f0>
   13bec:	80 e0       	ldi	r24, 0x00	; 0
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
				LocAccStatus=GetLocAccStatus(procMessage57());
   13bee:	80 93 a4 03 	sts	0x03A4, r24
				TimLocAcc=0;
   13bf2:	10 92 d3 01 	sts	0x01D3, r1
   13bf6:	10 92 d2 01 	sts	0x01D2, r1
				stLocalAccount=laDispStatus;
   13bfa:	86 e0       	ldi	r24, 0x06	; 6
   13bfc:	59 c6       	rjmp	.+3250   	; 0x148b0 <FMenuLocalAccount+0xeb2>
		        break;
           case laDispStatus://Display Status
		        if (LocAccStatus==LA_INVALID){
   13bfe:	80 91 a4 03 	lds	r24, 0x03A4
   13c02:	81 30       	cpi	r24, 0x01	; 1
   13c04:	29 f4       	brne	.+10     	; 0x13c10 <FMenuLocalAccount+0x212>
					lcd_printf(3,1,PSTR("Tidak Terdaftar     "));    
   13c06:	83 e0       	ldi	r24, 0x03	; 3
   13c08:	61 e0       	ldi	r22, 0x01	; 1
   13c0a:	4a e4       	ldi	r20, 0x4A	; 74
   13c0c:	50 e2       	ldi	r21, 0x20	; 32
   13c0e:	0d c0       	rjmp	.+26     	; 0x13c2a <FMenuLocalAccount+0x22c>
					TimLocAcc=0;
				    stLocalAccount=laDelayExit;
				}
				else
                if (LocAccStatus==LA_VALID) {
   13c10:	82 30       	cpi	r24, 0x02	; 2
   13c12:	31 f4       	brne	.+12     	; 0x13c20 <FMenuLocalAccount+0x222>
				    stLocalAccount=laDispValid; 
   13c14:	87 e0       	ldi	r24, 0x07	; 7
   13c16:	80 93 5c 01 	sts	0x015C, r24
					lcd_clear();
   13c1a:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
   13c1e:	0e c0       	rjmp	.+28     	; 0x13c3c <FMenuLocalAccount+0x23e>
					}
				else
                if (LocAccStatus==LA_LIMITED){
   13c20:	83 30       	cpi	r24, 0x03	; 3
   13c22:	61 f4       	brne	.+24     	; 0x13c3c <FMenuLocalAccount+0x23e>
					lcd_printf(3,1,PSTR("Kartu Terbatas      "));    
   13c24:	61 e0       	ldi	r22, 0x01	; 1
   13c26:	45 e3       	ldi	r20, 0x35	; 53
   13c28:	50 e2       	ldi	r21, 0x20	; 32
   13c2a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
					TimLocAcc=0;
   13c2e:	10 92 d3 01 	sts	0x01D3, r1
   13c32:	10 92 d2 01 	sts	0x01D2, r1
				    stLocalAccount=laDelayExit;
   13c36:	8e e1       	ldi	r24, 0x1E	; 30
   13c38:	80 93 5c 01 	sts	0x015C, r24
				}
                if (TimLocAcc>5)stLocalAccount=laExitLocAcc;
   13c3c:	80 91 d2 01 	lds	r24, 0x01D2
   13c40:	90 91 d3 01 	lds	r25, 0x01D3
   13c44:	06 97       	sbiw	r24, 0x06	; 6
   13c46:	10 f4       	brcc	.+4      	; 0x13c4c <FMenuLocalAccount+0x24e>
   13c48:	0c 94 2b a7 	jmp	0x14e56	; 0x14e56 <FMenuLocalAccount+0x1458>
   13c4c:	0c 94 22 a7 	jmp	0x14e44	; 0x14e44 <FMenuLocalAccount+0x1446>
		        break;
           case laDispValid://Display VALID ID
		        lcd_clear();
   13c50:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
   13c54:	00 d0       	rcall	.+0      	; 0x13c56 <FMenuLocalAccount+0x258>
   13c56:	00 d0       	rcall	.+0      	; 0x13c58 <FMenuLocalAccount+0x25a>
   13c58:	00 d0       	rcall	.+0      	; 0x13c5a <FMenuLocalAccount+0x25c>
   13c5a:	ed b7       	in	r30, 0x3d	; 61
   13c5c:	fe b7       	in	r31, 0x3e	; 62
   13c5e:	31 96       	adiw	r30, 0x01	; 1
   13c60:	82 e7       	ldi	r24, 0x72	; 114
   13c62:	9f e0       	ldi	r25, 0x0F	; 15
   13c64:	ad b7       	in	r26, 0x3d	; 61
   13c66:	be b7       	in	r27, 0x3e	; 62
   13c68:	12 96       	adiw	r26, 0x02	; 2
   13c6a:	9c 93       	st	X, r25
   13c6c:	8e 93       	st	-X, r24
   13c6e:	11 97       	sbiw	r26, 0x01	; 1
   13c70:	82 e3       	ldi	r24, 0x32	; 50
   13c72:	90 e2       	ldi	r25, 0x20	; 32
   13c74:	93 83       	std	Z+3, r25	; 0x03
   13c76:	82 83       	std	Z+2, r24	; 0x02
   13c78:	0b e4       	ldi	r16, 0x4B	; 75
   13c7a:	1f e0       	ldi	r17, 0x0F	; 15
   13c7c:	15 83       	std	Z+5, r17	; 0x05
   13c7e:	04 83       	std	Z+4, r16	; 0x04
   13c80:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
				FormatCurrency(strBalance);
   13c84:	ed b7       	in	r30, 0x3d	; 61
   13c86:	fe b7       	in	r31, 0x3e	; 62
   13c88:	36 96       	adiw	r30, 0x06	; 6
   13c8a:	0f b6       	in	r0, 0x3f	; 63
   13c8c:	f8 94       	cli
   13c8e:	fe bf       	out	0x3e, r31	; 62
   13c90:	0f be       	out	0x3f, r0	; 63
   13c92:	ed bf       	out	0x3d, r30	; 61
   13c94:	c8 01       	movw	r24, r16
   13c96:	0e 94 ad 33 	call	0x675a	; 0x675a <FormatCurrency>
   13c9a:	20 e0       	ldi	r18, 0x00	; 0
   13c9c:	30 e0       	ldi	r19, 0x00	; 0


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
   13c9e:	65 e1       	ldi	r22, 0x15	; 21
   13ca0:	e6 2e       	mov	r14, r22
   13ca2:	f1 2c       	mov	r15, r1
   13ca4:	ec 0e       	add	r14, r28
   13ca6:	fd 1e       	adc	r15, r29
   13ca8:	f7 01       	movw	r30, r14
   13caa:	e2 0f       	add	r30, r18
   13cac:	f3 1f       	adc	r31, r19
   13cae:	d9 01       	movw	r26, r18
   13cb0:	ac 5f       	subi	r26, 0xFC	; 252
   13cb2:	ba 4f       	sbci	r27, 0xFA	; 250
   13cb4:	8c 91       	ld	r24, X
   13cb6:	80 83       	st	Z, r24
   13cb8:	2f 5f       	subi	r18, 0xFF	; 255
   13cba:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
   13cbc:	24 31       	cpi	r18, 0x14	; 20
   13cbe:	31 05       	cpc	r19, r1
   13cc0:	99 f7       	brne	.-26     	; 0x13ca8 <FMenuLocalAccount+0x2aa>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
   13cc2:	19 a6       	std	Y+41, r1	; 0x29
		        lcd_clear();
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
				FormatCurrency(strBalance);

		        StringCopy(strCardHolder,strName,20);  				                                                        
		        sprintf_P(lcdteks,PSTR("%s"),strCompName);               lcd_print(1,1,lcdteks);   //[CompName]
   13cc4:	00 d0       	rcall	.+0      	; 0x13cc6 <FMenuLocalAccount+0x2c8>
   13cc6:	00 d0       	rcall	.+0      	; 0x13cc8 <FMenuLocalAccount+0x2ca>
   13cc8:	00 d0       	rcall	.+0      	; 0x13cca <FMenuLocalAccount+0x2cc>
   13cca:	ed b7       	in	r30, 0x3d	; 61
   13ccc:	fe b7       	in	r31, 0x3e	; 62
   13cce:	31 96       	adiw	r30, 0x01	; 1
   13cd0:	8e 01       	movw	r16, r28
   13cd2:	0f 5f       	subi	r16, 0xFF	; 255
   13cd4:	1f 4f       	sbci	r17, 0xFF	; 255
   13cd6:	ad b7       	in	r26, 0x3d	; 61
   13cd8:	be b7       	in	r27, 0x3e	; 62
   13cda:	12 96       	adiw	r26, 0x02	; 2
   13cdc:	1c 93       	st	X, r17
   13cde:	0e 93       	st	-X, r16
   13ce0:	11 97       	sbiw	r26, 0x01	; 1
   13ce2:	8f e2       	ldi	r24, 0x2F	; 47
   13ce4:	90 e2       	ldi	r25, 0x20	; 32
   13ce6:	93 83       	std	Z+3, r25	; 0x03
   13ce8:	82 83       	std	Z+2, r24	; 0x02
   13cea:	8c e5       	ldi	r24, 0x5C	; 92
   13cec:	99 e0       	ldi	r25, 0x09	; 9
   13cee:	95 83       	std	Z+5, r25	; 0x05
   13cf0:	84 83       	std	Z+4, r24	; 0x04
   13cf2:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   13cf6:	ed b7       	in	r30, 0x3d	; 61
   13cf8:	fe b7       	in	r31, 0x3e	; 62
   13cfa:	36 96       	adiw	r30, 0x06	; 6
   13cfc:	0f b6       	in	r0, 0x3f	; 63
   13cfe:	f8 94       	cli
   13d00:	fe bf       	out	0x3e, r31	; 62
   13d02:	0f be       	out	0x3f, r0	; 63
   13d04:	ed bf       	out	0x3d, r30	; 61
   13d06:	81 e0       	ldi	r24, 0x01	; 1
   13d08:	61 e0       	ldi	r22, 0x01	; 1
   13d0a:	a8 01       	movw	r20, r16
   13d0c:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
                //sprintf(lcdteks,"%s %s",strCardID,strName);    lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
				sprintf_P(lcdteks,PSTR("%s"),strName);                   lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
   13d10:	00 d0       	rcall	.+0      	; 0x13d12 <FMenuLocalAccount+0x314>
   13d12:	00 d0       	rcall	.+0      	; 0x13d14 <FMenuLocalAccount+0x316>
   13d14:	00 d0       	rcall	.+0      	; 0x13d16 <FMenuLocalAccount+0x318>
   13d16:	ed b7       	in	r30, 0x3d	; 61
   13d18:	fe b7       	in	r31, 0x3e	; 62
   13d1a:	31 96       	adiw	r30, 0x01	; 1
   13d1c:	ad b7       	in	r26, 0x3d	; 61
   13d1e:	be b7       	in	r27, 0x3e	; 62
   13d20:	12 96       	adiw	r26, 0x02	; 2
   13d22:	1c 93       	st	X, r17
   13d24:	0e 93       	st	-X, r16
   13d26:	11 97       	sbiw	r26, 0x01	; 1
   13d28:	8c e2       	ldi	r24, 0x2C	; 44
   13d2a:	90 e2       	ldi	r25, 0x20	; 32
   13d2c:	93 83       	std	Z+3, r25	; 0x03
   13d2e:	82 83       	std	Z+2, r24	; 0x02
   13d30:	f5 82       	std	Z+5, r15	; 0x05
   13d32:	e4 82       	std	Z+4, r14	; 0x04
   13d34:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   13d38:	ed b7       	in	r30, 0x3d	; 61
   13d3a:	fe b7       	in	r31, 0x3e	; 62
   13d3c:	36 96       	adiw	r30, 0x06	; 6
   13d3e:	0f b6       	in	r0, 0x3f	; 63
   13d40:	f8 94       	cli
   13d42:	fe bf       	out	0x3e, r31	; 62
   13d44:	0f be       	out	0x3f, r0	; 63
   13d46:	ed bf       	out	0x3d, r30	; 61
   13d48:	82 e0       	ldi	r24, 0x02	; 2
   13d4a:	61 e0       	ldi	r22, 0x01	; 1
   13d4c:	a8 01       	movw	r20, r16
   13d4e:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
				sprintf_P(lcdteks,PSTR("%s %s"),strLicPlate,strBalance); lcd_print(3,1,lcdteks);   //[LicPlate][Balance] 
   13d52:	2d b7       	in	r18, 0x3d	; 61
   13d54:	3e b7       	in	r19, 0x3e	; 62
   13d56:	28 50       	subi	r18, 0x08	; 8
   13d58:	30 40       	sbci	r19, 0x00	; 0
   13d5a:	0f b6       	in	r0, 0x3f	; 63
   13d5c:	f8 94       	cli
   13d5e:	3e bf       	out	0x3e, r19	; 62
   13d60:	0f be       	out	0x3f, r0	; 63
   13d62:	2d bf       	out	0x3d, r18	; 61
   13d64:	ed b7       	in	r30, 0x3d	; 61
   13d66:	fe b7       	in	r31, 0x3e	; 62
   13d68:	31 96       	adiw	r30, 0x01	; 1
   13d6a:	ad b7       	in	r26, 0x3d	; 61
   13d6c:	be b7       	in	r27, 0x3e	; 62
   13d6e:	12 96       	adiw	r26, 0x02	; 2
   13d70:	1c 93       	st	X, r17
   13d72:	0e 93       	st	-X, r16
   13d74:	11 97       	sbiw	r26, 0x01	; 1
   13d76:	86 e2       	ldi	r24, 0x26	; 38
   13d78:	90 e2       	ldi	r25, 0x20	; 32
   13d7a:	93 83       	std	Z+3, r25	; 0x03
   13d7c:	82 83       	std	Z+2, r24	; 0x02
   13d7e:	80 e6       	ldi	r24, 0x60	; 96
   13d80:	9c e0       	ldi	r25, 0x0C	; 12
   13d82:	95 83       	std	Z+5, r25	; 0x05
   13d84:	84 83       	std	Z+4, r24	; 0x04
   13d86:	8b e4       	ldi	r24, 0x4B	; 75
   13d88:	9f e0       	ldi	r25, 0x0F	; 15
   13d8a:	97 83       	std	Z+7, r25	; 0x07
   13d8c:	86 83       	std	Z+6, r24	; 0x06
   13d8e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   13d92:	ed b7       	in	r30, 0x3d	; 61
   13d94:	fe b7       	in	r31, 0x3e	; 62
   13d96:	38 96       	adiw	r30, 0x08	; 8
   13d98:	0f b6       	in	r0, 0x3f	; 63
   13d9a:	f8 94       	cli
   13d9c:	fe bf       	out	0x3e, r31	; 62
   13d9e:	0f be       	out	0x3f, r0	; 63
   13da0:	ed bf       	out	0x3d, r30	; 61
   13da2:	83 e0       	ldi	r24, 0x03	; 3
   13da4:	61 e0       	ldi	r22, 0x01	; 1
   13da6:	a8 01       	movw	r20, r16
   13da8:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
	            lcd_printf(4,1,PSTR("[*]Batal       [#]OK"));   //[*]Batal       [#]OK
   13dac:	84 e0       	ldi	r24, 0x04	; 4
   13dae:	61 e0       	ldi	r22, 0x01	; 1
   13db0:	41 e1       	ldi	r20, 0x11	; 17
   13db2:	50 e2       	ldi	r21, 0x20	; 32
   13db4:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				stLocalAccount=laDispValidInput;
   13db8:	88 e0       	ldi	r24, 0x08	; 8
   13dba:	7a c5       	rjmp	.+2804   	; 0x148b0 <FMenuLocalAccount+0xeb2>
		        break;
           case laDispValidInput:
                KeyPressed=_key_scan(1);
   13dbc:	81 e0       	ldi	r24, 0x01	; 1
   13dbe:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   13dc2:	80 93 9c 03 	sts	0x039C, r24
				if (KeyPressed==_KEY_ENTER) stLocalAccount=laSelectFIP;
   13dc6:	87 3b       	cpi	r24, 0xB7	; 183
   13dc8:	09 f4       	brne	.+2      	; 0x13dcc <FMenuLocalAccount+0x3ce>
   13dca:	84 c2       	rjmp	.+1288   	; 0x142d4 <FMenuLocalAccount+0x8d6>
				else
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laExitLocAcc;
   13dcc:	87 3e       	cpi	r24, 0xE7	; 231
   13dce:	11 f0       	breq	.+4      	; 0x13dd4 <FMenuLocalAccount+0x3d6>
   13dd0:	0c 94 2b a7 	jmp	0x14e56	; 0x14e56 <FMenuLocalAccount+0x1458>
   13dd4:	0c 94 22 a7 	jmp	0x14e44	; 0x14e44 <FMenuLocalAccount+0x1446>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   13dd8:	82 e8       	ldi	r24, 0x82	; 130
   13dda:	93 e0       	ldi	r25, 0x03	; 3
   13ddc:	65 e4       	ldi	r22, 0x45	; 69
   13dde:	70 e0       	ldi	r23, 0x00	; 0
   13de0:	48 e0       	ldi	r20, 0x08	; 8
   13de2:	50 e0       	ldi	r21, 0x00	; 0
   13de4:	28 ef       	ldi	r18, 0xF8	; 248
   13de6:	32 e1       	ldi	r19, 0x12	; 18
   13de8:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
		        break;
           case laSelectFIP:       
		  		eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				lcd_clear(); 
   13dec:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
				//for (iLoop=0;iLoop<8;iLoop++){
				//     if (FIP[iLoop]>16) FIP[iLoop]=0;
				//	 }
				for (iLoop=0;iLoop<4;iLoop++){
   13df0:	10 92 73 03 	sts	0x0373, r1
   13df4:	10 92 72 03 	sts	0x0372, r1
                     //leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                     //sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
					 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
   13df8:	8e 01       	movw	r16, r28
   13dfa:	0f 5f       	subi	r16, 0xFF	; 255
   13dfc:	1f 4f       	sbci	r17, 0xFF	; 255
   13dfe:	5d ef       	ldi	r21, 0xFD	; 253
   13e00:	e5 2e       	mov	r14, r21
   13e02:	5f e1       	ldi	r21, 0x1F	; 31
   13e04:	f5 2e       	mov	r15, r21
   13e06:	41 c0       	rjmp	.+130    	; 0x13e8a <FMenuLocalAccount+0x48c>
   13e08:	8d b7       	in	r24, 0x3d	; 61
   13e0a:	9e b7       	in	r25, 0x3e	; 62
   13e0c:	0c 97       	sbiw	r24, 0x0c	; 12
   13e0e:	0f b6       	in	r0, 0x3f	; 63
   13e10:	f8 94       	cli
   13e12:	9e bf       	out	0x3e, r25	; 62
   13e14:	0f be       	out	0x3f, r0	; 63
   13e16:	8d bf       	out	0x3d, r24	; 61
   13e18:	ed b7       	in	r30, 0x3d	; 61
   13e1a:	fe b7       	in	r31, 0x3e	; 62
   13e1c:	31 96       	adiw	r30, 0x01	; 1
   13e1e:	ad b7       	in	r26, 0x3d	; 61
   13e20:	be b7       	in	r27, 0x3e	; 62
   13e22:	12 96       	adiw	r26, 0x02	; 2
   13e24:	1c 93       	st	X, r17
   13e26:	0e 93       	st	-X, r16
   13e28:	11 97       	sbiw	r26, 0x01	; 1
   13e2a:	f3 82       	std	Z+3, r15	; 0x03
   13e2c:	e2 82       	std	Z+2, r14	; 0x02
   13e2e:	2f 5f       	subi	r18, 0xFF	; 255
   13e30:	3f 4f       	sbci	r19, 0xFF	; 255
   13e32:	35 83       	std	Z+5, r19	; 0x05
   13e34:	24 83       	std	Z+4, r18	; 0x04
   13e36:	21 50       	subi	r18, 0x01	; 1
   13e38:	30 40       	sbci	r19, 0x00	; 0
   13e3a:	d9 01       	movw	r26, r18
   13e3c:	ae 57       	subi	r26, 0x7E	; 126
   13e3e:	bc 4f       	sbci	r27, 0xFC	; 252
   13e40:	8c 91       	ld	r24, X
   13e42:	86 83       	std	Z+6, r24	; 0x06
   13e44:	17 82       	std	Z+7, r1	; 0x07
   13e46:	2b 5f       	subi	r18, 0xFB	; 251
   13e48:	3f 4f       	sbci	r19, 0xFF	; 255
   13e4a:	31 87       	std	Z+9, r19	; 0x09
   13e4c:	20 87       	std	Z+8, r18	; 0x08
   13e4e:	14 96       	adiw	r26, 0x04	; 4
   13e50:	8c 91       	ld	r24, X
   13e52:	82 87       	std	Z+10, r24	; 0x0a
   13e54:	13 86       	std	Z+11, r1	; 0x0b
   13e56:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
					 lcd_print((iLoop+1),1,lcdteks);
   13e5a:	ed b7       	in	r30, 0x3d	; 61
   13e5c:	fe b7       	in	r31, 0x3e	; 62
   13e5e:	3c 96       	adiw	r30, 0x0c	; 12
   13e60:	0f b6       	in	r0, 0x3f	; 63
   13e62:	f8 94       	cli
   13e64:	fe bf       	out	0x3e, r31	; 62
   13e66:	0f be       	out	0x3f, r0	; 63
   13e68:	ed bf       	out	0x3d, r30	; 61
   13e6a:	80 91 72 03 	lds	r24, 0x0372
   13e6e:	8f 5f       	subi	r24, 0xFF	; 255
   13e70:	61 e0       	ldi	r22, 0x01	; 1
   13e72:	a8 01       	movw	r20, r16
   13e74:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		  		eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				lcd_clear(); 
				//for (iLoop=0;iLoop<8;iLoop++){
				//     if (FIP[iLoop]>16) FIP[iLoop]=0;
				//	 }
				for (iLoop=0;iLoop<4;iLoop++){
   13e78:	80 91 72 03 	lds	r24, 0x0372
   13e7c:	90 91 73 03 	lds	r25, 0x0373
   13e80:	01 96       	adiw	r24, 0x01	; 1
   13e82:	90 93 73 03 	sts	0x0373, r25
   13e86:	80 93 72 03 	sts	0x0372, r24
   13e8a:	20 91 72 03 	lds	r18, 0x0372
   13e8e:	30 91 73 03 	lds	r19, 0x0373
   13e92:	24 30       	cpi	r18, 0x04	; 4
   13e94:	31 05       	cpc	r19, r1
   13e96:	08 f4       	brcc	.+2      	; 0x13e9a <FMenuLocalAccount+0x49c>
   13e98:	b7 cf       	rjmp	.-146    	; 0x13e08 <FMenuLocalAccount+0x40a>
                     //leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                     //sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
					 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
					 lcd_print((iLoop+1),1,lcdteks);
					 }
		        lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
   13e9a:	81 e0       	ldi	r24, 0x01	; 1
   13e9c:	6f e0       	ldi	r22, 0x0F	; 15
   13e9e:	47 ef       	ldi	r20, 0xF7	; 247
   13ea0:	5f e1       	ldi	r21, 0x1F	; 31
   13ea2:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
   13ea6:	82 e0       	ldi	r24, 0x02	; 2
   13ea8:	6f e0       	ldi	r22, 0x0F	; 15
   13eaa:	41 ef       	ldi	r20, 0xF1	; 241
   13eac:	5f e1       	ldi	r21, 0x1F	; 31
   13eae:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
   13eb2:	83 e0       	ldi	r24, 0x03	; 3
   13eb4:	6f e0       	ldi	r22, 0x0F	; 15
   13eb6:	4b ee       	ldi	r20, 0xEB	; 235
   13eb8:	5f e1       	ldi	r21, 0x1F	; 31
   13eba:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	            lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
   13ebe:	84 e0       	ldi	r24, 0x04	; 4
   13ec0:	6f e0       	ldi	r22, 0x0F	; 15
   13ec2:	44 ee       	ldi	r20, 0xE4	; 228
   13ec4:	5f e1       	ldi	r21, 0x1F	; 31
   13ec6:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				//eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				iLoop=0;
   13eca:	10 92 73 03 	sts	0x0373, r1
   13ece:	10 92 72 03 	sts	0x0372, r1
				stLocalAccount=laSelectFIPInput;
   13ed2:	8a e0       	ldi	r24, 0x0A	; 10
   13ed4:	ed c4       	rjmp	.+2522   	; 0x148b0 <FMenuLocalAccount+0xeb2>
		        break; 
           case laSelectFIPInput:
			    //Blinking 50% _ 
			    iLoop++;
   13ed6:	80 91 72 03 	lds	r24, 0x0372
   13eda:	90 91 73 03 	lds	r25, 0x0373
   13ede:	01 96       	adiw	r24, 0x01	; 1
   13ee0:	90 93 73 03 	sts	0x0373, r25
   13ee4:	80 93 72 03 	sts	0x0372, r24
			    //GetKeyPressed
			    KeyPressed=_key_scan(1);
   13ee8:	81 e0       	ldi	r24, 0x01	; 1
   13eea:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   13eee:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   13ef2:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   13ef6:	98 2f       	mov	r25, r24
   13ef8:	80 93 a1 03 	sts	0x03A1, r24
				if ((KeyChar>='1')&&(KeyChar<='8')){
   13efc:	81 53       	subi	r24, 0x31	; 49
   13efe:	88 30       	cpi	r24, 0x08	; 8
   13f00:	60 f4       	brcc	.+24     	; 0x13f1a <FMenuLocalAccount+0x51c>
				    if (KeyCharLast!=KeyChar){
   13f02:	80 91 5b 01 	lds	r24, 0x015B
   13f06:	89 17       	cp	r24, r25
   13f08:	41 f0       	breq	.+16     	; 0x13f1a <FMenuLocalAccount+0x51c>
					    KeyCharLast=KeyChar;
   13f0a:	90 93 5b 01 	sts	0x015B, r25
						iLoop=1000;
   13f0e:	88 ee       	ldi	r24, 0xE8	; 232
   13f10:	93 e0       	ldi	r25, 0x03	; 3
   13f12:	90 93 73 03 	sts	0x0373, r25
   13f16:	80 93 72 03 	sts	0x0372, r24
                    }
				}

			    if ((iLoop%2000)==0){
   13f1a:	80 91 72 03 	lds	r24, 0x0372
   13f1e:	90 91 73 03 	lds	r25, 0x0373
   13f22:	60 ed       	ldi	r22, 0xD0	; 208
   13f24:	77 e0       	ldi	r23, 0x07	; 7
   13f26:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
   13f2a:	89 2b       	or	r24, r25
   13f2c:	39 f4       	brne	.+14     	; 0x13f3c <FMenuLocalAccount+0x53e>
			       lcd_xy(1,19);_lcd('_'); 
   13f2e:	81 e0       	ldi	r24, 0x01	; 1
   13f30:	63 e1       	ldi	r22, 0x13	; 19
   13f32:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
   13f36:	8f e5       	ldi	r24, 0x5F	; 95
   13f38:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
			    }
			    if ((iLoop%2000)==1000){
   13f3c:	80 91 72 03 	lds	r24, 0x0372
   13f40:	90 91 73 03 	lds	r25, 0x0373
   13f44:	60 ed       	ldi	r22, 0xD0	; 208
   13f46:	77 e0       	ldi	r23, 0x07	; 7
   13f48:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
   13f4c:	88 5e       	subi	r24, 0xE8	; 232
   13f4e:	93 40       	sbci	r25, 0x03	; 3
   13f50:	41 f4       	brne	.+16     	; 0x13f62 <FMenuLocalAccount+0x564>
			       lcd_xy(1,19);_lcd(KeyCharLast); 
   13f52:	81 e0       	ldi	r24, 0x01	; 1
   13f54:	63 e1       	ldi	r22, 0x13	; 19
   13f56:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
   13f5a:	80 91 5b 01 	lds	r24, 0x015B
   13f5e:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
			    }
				if (((KeyChar>='1')&&(KeyChar<='8'))||
   13f62:	80 91 a1 03 	lds	r24, 0x03A1
   13f66:	81 53       	subi	r24, 0x31	; 49
   13f68:	88 30       	cpi	r24, 0x08	; 8
   13f6a:	50 f0       	brcs	.+20     	; 0x13f80 <FMenuLocalAccount+0x582>
   13f6c:	80 91 9c 03 	lds	r24, 0x039C
   13f70:	87 3b       	cpi	r24, 0xB7	; 183
   13f72:	09 f0       	breq	.+2      	; 0x13f76 <FMenuLocalAccount+0x578>
   13f74:	57 c0       	rjmp	.+174    	; 0x14024 <FMenuLocalAccount+0x626>
   13f76:	80 91 5b 01 	lds	r24, 0x015B
   13f7a:	80 32       	cpi	r24, 0x20	; 32
   13f7c:	09 f4       	brne	.+2      	; 0x13f80 <FMenuLocalAccount+0x582>
   13f7e:	6b c7       	rjmp	.+3798   	; 0x14e56 <FMenuLocalAccount+0x1458>
				    (KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')
					){
				    stLocalAccount=laSelectProduct;
   13f80:	8b e0       	ldi	r24, 0x0B	; 11
   13f82:	80 93 5c 01 	sts	0x015C, r24
					FIP_Used=FIP[KeyCharLast-'1'];
   13f86:	e0 91 5b 01 	lds	r30, 0x015B
   13f8a:	f0 e0       	ldi	r31, 0x00	; 0
   13f8c:	ef 5a       	subi	r30, 0xAF	; 175
   13f8e:	fc 4f       	sbci	r31, 0xFC	; 252
   13f90:	20 81       	ld	r18, Z
   13f92:	20 93 76 03 	sts	0x0376, r18
					if (FIP_Used<=99){
   13f96:	24 36       	cpi	r18, 0x64	; 100
   13f98:	08 f0       	brcs	.+2      	; 0x13f9c <FMenuLocalAccount+0x59e>
   13f9a:	5d c7       	rjmp	.+3770   	; 0x14e56 <FMenuLocalAccount+0x1458>
					    //leadingZero(FIP_Used,strFIP);
						//leadingZero(FIP_Used,strFIP_ID);
						sprintf_P(strFIP,PSTR("%.2d"),FIP_Used);
   13f9c:	00 d0       	rcall	.+0      	; 0x13f9e <FMenuLocalAccount+0x5a0>
   13f9e:	00 d0       	rcall	.+0      	; 0x13fa0 <FMenuLocalAccount+0x5a2>
   13fa0:	00 d0       	rcall	.+0      	; 0x13fa2 <FMenuLocalAccount+0x5a4>
   13fa2:	ed b7       	in	r30, 0x3d	; 61
   13fa4:	fe b7       	in	r31, 0x3e	; 62
   13fa6:	31 96       	adiw	r30, 0x01	; 1
   13fa8:	8d e9       	ldi	r24, 0x9D	; 157
   13faa:	93 e0       	ldi	r25, 0x03	; 3
   13fac:	ad b7       	in	r26, 0x3d	; 61
   13fae:	be b7       	in	r27, 0x3e	; 62
   13fb0:	12 96       	adiw	r26, 0x02	; 2
   13fb2:	9c 93       	st	X, r25
   13fb4:	8e 93       	st	-X, r24
   13fb6:	11 97       	sbiw	r26, 0x01	; 1
   13fb8:	8f ed       	ldi	r24, 0xDF	; 223
   13fba:	9f e1       	ldi	r25, 0x1F	; 31
   13fbc:	93 83       	std	Z+3, r25	; 0x03
   13fbe:	82 83       	std	Z+2, r24	; 0x02
   13fc0:	24 83       	std	Z+4, r18	; 0x04
   13fc2:	15 82       	std	Z+5, r1	; 0x05
   13fc4:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
						sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
   13fc8:	ed b7       	in	r30, 0x3d	; 61
   13fca:	fe b7       	in	r31, 0x3e	; 62
   13fcc:	31 96       	adiw	r30, 0x01	; 1
   13fce:	86 e8       	ldi	r24, 0x86	; 134
   13fd0:	99 e0       	ldi	r25, 0x09	; 9
   13fd2:	ad b7       	in	r26, 0x3d	; 61
   13fd4:	be b7       	in	r27, 0x3e	; 62
   13fd6:	12 96       	adiw	r26, 0x02	; 2
   13fd8:	9c 93       	st	X, r25
   13fda:	8e 93       	st	-X, r24
   13fdc:	11 97       	sbiw	r26, 0x01	; 1
   13fde:	8a ed       	ldi	r24, 0xDA	; 218
   13fe0:	9f e1       	ldi	r25, 0x1F	; 31
   13fe2:	93 83       	std	Z+3, r25	; 0x03
   13fe4:	82 83       	std	Z+2, r24	; 0x02
   13fe6:	80 91 76 03 	lds	r24, 0x0376
   13fea:	84 83       	std	Z+4, r24	; 0x04
   13fec:	15 82       	std	Z+5, r1	; 0x05
   13fee:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   13ff2:	ed b7       	in	r30, 0x3d	; 61
   13ff4:	fe b7       	in	r31, 0x3e	; 62
   13ff6:	36 96       	adiw	r30, 0x06	; 6
   13ff8:	0f b6       	in	r0, 0x3f	; 63
   13ffa:	f8 94       	cli
   13ffc:	fe bf       	out	0x3e, r31	; 62
   13ffe:	0f be       	out	0x3f, r0	; 63
   14000:	ed bf       	out	0x3d, r30	; 61
   14002:	60 91 5b 01 	lds	r22, 0x015B
   14006:	86 e0       	ldi	r24, 0x06	; 6
   14008:	68 9f       	mul	r22, r24
   1400a:	b0 01       	movw	r22, r0
   1400c:	11 24       	eor	r1, r1
   1400e:	61 5d       	subi	r22, 0xD1	; 209
   14010:	70 40       	sbci	r23, 0x00	; 0
   14012:	8a e8       	ldi	r24, 0x8A	; 138
   14014:	93 e0       	ldi	r25, 0x03	; 3
   14016:	46 e0       	ldi	r20, 0x06	; 6
   14018:	50 e0       	ldi	r21, 0x00	; 0
   1401a:	28 ef       	ldi	r18, 0xF8	; 248
   1401c:	32 e1       	ldi	r19, 0x12	; 18
   1401e:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
   14022:	19 c7       	rjmp	.+3634   	; 0x14e56 <FMenuLocalAccount+0x1458>

						eeprom_read_block((void*) &ProductID, (const void*) &DefNozzleMap[(KeyCharLast-'1')], 6);
						}
					}
				else
				if (KeyPressed==_KEY_CANCEL){
   14024:	87 3e       	cpi	r24, 0xE7	; 231
   14026:	09 f0       	breq	.+2      	; 0x1402a <FMenuLocalAccount+0x62c>
   14028:	16 c7       	rjmp	.+3628   	; 0x14e56 <FMenuLocalAccount+0x1458>
				    stLocalAccount=laDispValid;
   1402a:	87 e0       	ldi	r24, 0x07	; 7
   1402c:	41 c4       	rjmp	.+2178   	; 0x148b0 <FMenuLocalAccount+0xeb2>
					}
		        break;
           case laSelectProduct://NozzleID
				lcd_clear();
   1402e:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		        sprintf_P(lcdteks,PSTR("Pompa-%s"),strFIP);lcd_print(1,1,lcdteks);
   14032:	00 d0       	rcall	.+0      	; 0x14034 <FMenuLocalAccount+0x636>
   14034:	00 d0       	rcall	.+0      	; 0x14036 <FMenuLocalAccount+0x638>
   14036:	00 d0       	rcall	.+0      	; 0x14038 <FMenuLocalAccount+0x63a>
   14038:	ed b7       	in	r30, 0x3d	; 61
   1403a:	fe b7       	in	r31, 0x3e	; 62
   1403c:	31 96       	adiw	r30, 0x01	; 1
   1403e:	8e 01       	movw	r16, r28
   14040:	0f 5f       	subi	r16, 0xFF	; 255
   14042:	1f 4f       	sbci	r17, 0xFF	; 255
   14044:	ad b7       	in	r26, 0x3d	; 61
   14046:	be b7       	in	r27, 0x3e	; 62
   14048:	12 96       	adiw	r26, 0x02	; 2
   1404a:	1c 93       	st	X, r17
   1404c:	0e 93       	st	-X, r16
   1404e:	11 97       	sbiw	r26, 0x01	; 1
   14050:	81 ed       	ldi	r24, 0xD1	; 209
   14052:	9f e1       	ldi	r25, 0x1F	; 31
   14054:	93 83       	std	Z+3, r25	; 0x03
   14056:	82 83       	std	Z+2, r24	; 0x02
   14058:	8d e9       	ldi	r24, 0x9D	; 157
   1405a:	93 e0       	ldi	r25, 0x03	; 3
   1405c:	95 83       	std	Z+5, r25	; 0x05
   1405e:	84 83       	std	Z+4, r24	; 0x04
   14060:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   14064:	ed b7       	in	r30, 0x3d	; 61
   14066:	fe b7       	in	r31, 0x3e	; 62
   14068:	36 96       	adiw	r30, 0x06	; 6
   1406a:	0f b6       	in	r0, 0x3f	; 63
   1406c:	f8 94       	cli
   1406e:	fe bf       	out	0x3e, r31	; 62
   14070:	0f be       	out	0x3f, r0	; 63
   14072:	ed bf       	out	0x3d, r30	; 61
   14074:	81 e0       	ldi	r24, 0x01	; 1
   14076:	61 e0       	ldi	r22, 0x01	; 1
   14078:	a8 01       	movw	r20, r16
   1407a:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
				//Not MPD->Single Product
				if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&
   1407e:	90 91 8a 03 	lds	r25, 0x038A
   14082:	89 2f       	mov	r24, r25
   14084:	81 50       	subi	r24, 0x01	; 1
   14086:	86 30       	cpi	r24, 0x06	; 6
   14088:	08 f0       	brcs	.+2      	; 0x1408c <FMenuLocalAccount+0x68e>
   1408a:	4b c0       	rjmp	.+150    	; 0x14122 <FMenuLocalAccount+0x724>
   1408c:	80 91 8b 03 	lds	r24, 0x038B
   14090:	88 23       	and	r24, r24
   14092:	09 f0       	breq	.+2      	; 0x14096 <FMenuLocalAccount+0x698>
   14094:	46 c0       	rjmp	.+140    	; 0x14122 <FMenuLocalAccount+0x724>
   14096:	80 91 8c 03 	lds	r24, 0x038C
   1409a:	88 23       	and	r24, r24
   1409c:	09 f0       	breq	.+2      	; 0x140a0 <FMenuLocalAccount+0x6a2>
   1409e:	41 c0       	rjmp	.+130    	; 0x14122 <FMenuLocalAccount+0x724>
   140a0:	80 91 8d 03 	lds	r24, 0x038D
   140a4:	88 23       	and	r24, r24
   140a6:	e9 f5       	brne	.+122    	; 0x14122 <FMenuLocalAccount+0x724>
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
   140a8:	90 93 75 03 	sts	0x0375, r25
   140ac:	6d e0       	ldi	r22, 0x0D	; 13
   140ae:	96 9f       	mul	r25, r22
   140b0:	b0 01       	movw	r22, r0
   140b2:	11 24       	eor	r1, r1
   140b4:	62 55       	subi	r22, 0x52	; 82
   140b6:	7f 4f       	sbci	r23, 0xFF	; 255
   140b8:	87 e7       	ldi	r24, 0x77	; 119
   140ba:	93 e0       	ldi	r25, 0x03	; 3
   140bc:	4a e0       	ldi	r20, 0x0A	; 10
   140be:	50 e0       	ldi	r21, 0x00	; 0
   140c0:	28 ef       	ldi	r18, 0xF8	; 248
   140c2:	32 e1       	ldi	r19, 0x12	; 18
   140c4:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
   140c8:	a7 e7       	ldi	r26, 0x77	; 119
   140ca:	b3 e0       	ldi	r27, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   140cc:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   140ce:	f3 e0       	ldi	r31, 0x03	; 3
   140d0:	af 37       	cpi	r26, 0x7F	; 127
   140d2:	bf 07       	cpc	r27, r31
   140d4:	d9 f7       	brne	.-10     	; 0x140cc <FMenuLocalAccount+0x6ce>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   140d6:	1c 92       	st	X, r1
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
					 eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
					 StrPosCopy(ProductName,ProductName,0,8);
					 sprintf_P(strProduct,PSTR("%s"),ProductName);
   140d8:	00 d0       	rcall	.+0      	; 0x140da <FMenuLocalAccount+0x6dc>
   140da:	00 d0       	rcall	.+0      	; 0x140dc <FMenuLocalAccount+0x6de>
   140dc:	00 d0       	rcall	.+0      	; 0x140de <FMenuLocalAccount+0x6e0>
   140de:	2d b7       	in	r18, 0x3d	; 61
   140e0:	3e b7       	in	r19, 0x3e	; 62
   140e2:	2f 5f       	subi	r18, 0xFF	; 255
   140e4:	3f 4f       	sbci	r19, 0xFF	; 255
   140e6:	81 e4       	ldi	r24, 0x41	; 65
   140e8:	99 e0       	ldi	r25, 0x09	; 9
   140ea:	ed b7       	in	r30, 0x3d	; 61
   140ec:	fe b7       	in	r31, 0x3e	; 62
   140ee:	92 83       	std	Z+2, r25	; 0x02
   140f0:	81 83       	std	Z+1, r24	; 0x01
   140f2:	8e ec       	ldi	r24, 0xCE	; 206
   140f4:	9f e1       	ldi	r25, 0x1F	; 31
   140f6:	f9 01       	movw	r30, r18
   140f8:	93 83       	std	Z+3, r25	; 0x03
   140fa:	82 83       	std	Z+2, r24	; 0x02
   140fc:	18 97       	sbiw	r26, 0x08	; 8
   140fe:	b5 83       	std	Z+5, r27	; 0x05
   14100:	a4 83       	std	Z+4, r26	; 0x04
   14102:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
                     stLocalAccount=laSelectBalanceType;
   14106:	8d e0       	ldi	r24, 0x0D	; 13
   14108:	80 93 5c 01 	sts	0x015C, r24
   1410c:	80 e0       	ldi	r24, 0x00	; 0
   1410e:	2d b7       	in	r18, 0x3d	; 61
   14110:	3e b7       	in	r19, 0x3e	; 62
   14112:	2a 5f       	subi	r18, 0xFA	; 250
   14114:	3f 4f       	sbci	r19, 0xFF	; 255
   14116:	0f b6       	in	r0, 0x3f	; 63
   14118:	f8 94       	cli
   1411a:	3e bf       	out	0x3e, r19	; 62
   1411c:	0f be       	out	0x3f, r0	; 63
   1411e:	2d bf       	out	0x3d, r18	; 61
   14120:	9b c6       	rjmp	.+3382   	; 0x14e58 <FMenuLocalAccount+0x145a>
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   14122:	10 92 9a 03 	sts	0x039A, r1
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   14126:	8e 01       	movw	r16, r28
   14128:	0f 5f       	subi	r16, 0xFF	; 255
   1412a:	1f 4f       	sbci	r17, 0xFF	; 255
   1412c:	42 ec       	ldi	r20, 0xC2	; 194
   1412e:	c4 2e       	mov	r12, r20
   14130:	4f e1       	ldi	r20, 0x1F	; 31
   14132:	d4 2e       	mov	r13, r20
   14134:	3d e0       	ldi	r19, 0x0D	; 13
   14136:	a3 2e       	mov	r10, r19
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   14138:	28 ec       	ldi	r18, 0xC8	; 200
   1413a:	e2 2e       	mov	r14, r18
   1413c:	2f e1       	ldi	r18, 0x1F	; 31
   1413e:	f2 2e       	mov	r15, r18
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   14140:	9b e0       	ldi	r25, 0x0B	; 11
   14142:	b9 2e       	mov	r11, r25
   14144:	6b c0       	rjmp	.+214    	; 0x1421c <FMenuLocalAccount+0x81e>
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
   14146:	f0 e0       	ldi	r31, 0x00	; 0
   14148:	e6 57       	subi	r30, 0x76	; 118
   1414a:	fc 4f       	sbci	r31, 0xFC	; 252
   1414c:	e0 81       	ld	r30, Z
   1414e:	e0 93 75 03 	sts	0x0375, r30
					if ((ProdId>=1)&&(ProdId<=6)){
   14152:	8e 2f       	mov	r24, r30
   14154:	81 50       	subi	r24, 0x01	; 1
   14156:	86 30       	cpi	r24, 0x06	; 6
   14158:	e8 f5       	brcc	.+122    	; 0x141d4 <FMenuLocalAccount+0x7d6>
   1415a:	ea 9d       	mul	r30, r10
   1415c:	b0 01       	movw	r22, r0
   1415e:	11 24       	eor	r1, r1
   14160:	62 55       	subi	r22, 0x52	; 82
   14162:	7f 4f       	sbci	r23, 0xFF	; 255
   14164:	87 e7       	ldi	r24, 0x77	; 119
   14166:	93 e0       	ldi	r25, 0x03	; 3
   14168:	4a e0       	ldi	r20, 0x0A	; 10
   1416a:	50 e0       	ldi	r21, 0x00	; 0
   1416c:	28 ef       	ldi	r18, 0xF8	; 248
   1416e:	32 e1       	ldi	r19, 0x12	; 18
   14170:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
   14174:	a7 e7       	ldi	r26, 0x77	; 119
   14176:	b3 e0       	ldi	r27, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14178:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1417a:	33 e0       	ldi	r19, 0x03	; 3
   1417c:	af 37       	cpi	r26, 0x7F	; 127
   1417e:	b3 07       	cpc	r27, r19
   14180:	d9 f7       	brne	.-10     	; 0x14178 <FMenuLocalAccount+0x77a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   14182:	1c 92       	st	X, r1
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   14184:	8d b7       	in	r24, 0x3d	; 61
   14186:	9e b7       	in	r25, 0x3e	; 62
   14188:	08 97       	sbiw	r24, 0x08	; 8
   1418a:	0f b6       	in	r0, 0x3f	; 63
   1418c:	f8 94       	cli
   1418e:	9e bf       	out	0x3e, r25	; 62
   14190:	0f be       	out	0x3f, r0	; 63
   14192:	8d bf       	out	0x3d, r24	; 61
   14194:	2d b7       	in	r18, 0x3d	; 61
   14196:	3e b7       	in	r19, 0x3e	; 62
   14198:	2f 5f       	subi	r18, 0xFF	; 255
   1419a:	3f 4f       	sbci	r19, 0xFF	; 255
   1419c:	ed b7       	in	r30, 0x3d	; 61
   1419e:	fe b7       	in	r31, 0x3e	; 62
   141a0:	12 83       	std	Z+2, r17	; 0x02
   141a2:	01 83       	std	Z+1, r16	; 0x01
   141a4:	f9 01       	movw	r30, r18
   141a6:	f3 82       	std	Z+3, r15	; 0x03
   141a8:	e2 82       	std	Z+2, r14	; 0x02
   141aa:	80 91 9a 03 	lds	r24, 0x039A
   141ae:	90 e0       	ldi	r25, 0x00	; 0
   141b0:	01 96       	adiw	r24, 0x01	; 1
   141b2:	95 83       	std	Z+5, r25	; 0x05
   141b4:	84 83       	std	Z+4, r24	; 0x04
   141b6:	18 97       	sbiw	r26, 0x08	; 8
   141b8:	b7 83       	std	Z+7, r27	; 0x07
   141ba:	a6 83       	std	Z+6, r26	; 0x06
   141bc:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   141c0:	2d b7       	in	r18, 0x3d	; 61
   141c2:	3e b7       	in	r19, 0x3e	; 62
   141c4:	28 5f       	subi	r18, 0xF8	; 248
   141c6:	3f 4f       	sbci	r19, 0xFF	; 255
   141c8:	0f b6       	in	r0, 0x3f	; 63
   141ca:	f8 94       	cli
   141cc:	3e bf       	out	0x3e, r19	; 62
   141ce:	0f be       	out	0x3f, r0	; 63
   141d0:	2d bf       	out	0x3d, r18	; 61
   141d2:	12 c0       	rjmp	.+36     	; 0x141f8 <FMenuLocalAccount+0x7fa>
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   141d4:	00 d0       	rcall	.+0      	; 0x141d6 <FMenuLocalAccount+0x7d8>
   141d6:	00 d0       	rcall	.+0      	; 0x141d8 <FMenuLocalAccount+0x7da>
   141d8:	ad b7       	in	r26, 0x3d	; 61
   141da:	be b7       	in	r27, 0x3e	; 62
   141dc:	12 96       	adiw	r26, 0x02	; 2
   141de:	1c 93       	st	X, r17
   141e0:	0e 93       	st	-X, r16
   141e2:	11 97       	sbiw	r26, 0x01	; 1
   141e4:	14 96       	adiw	r26, 0x04	; 4
   141e6:	dc 92       	st	X, r13
   141e8:	ce 92       	st	-X, r12
   141ea:	13 97       	sbiw	r26, 0x03	; 3
   141ec:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   141f0:	0f 90       	pop	r0
   141f2:	0f 90       	pop	r0
   141f4:	0f 90       	pop	r0
   141f6:	0f 90       	pop	r0
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   141f8:	80 91 9a 03 	lds	r24, 0x039A
   141fc:	68 2f       	mov	r22, r24
   141fe:	66 95       	lsr	r22
   14200:	6b 9d       	mul	r22, r11
   14202:	b0 01       	movw	r22, r0
   14204:	11 24       	eor	r1, r1
   14206:	6f 5f       	subi	r22, 0xFF	; 255
   14208:	81 70       	andi	r24, 0x01	; 1
   1420a:	8e 5f       	subi	r24, 0xFE	; 254
   1420c:	a8 01       	movw	r20, r16
   1420e:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
                     stLocalAccount=laSelectBalanceType;
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   14212:	80 91 9a 03 	lds	r24, 0x039A
   14216:	8f 5f       	subi	r24, 0xFF	; 255
   14218:	80 93 9a 03 	sts	0x039A, r24
   1421c:	e0 91 9a 03 	lds	r30, 0x039A
   14220:	e4 30       	cpi	r30, 0x04	; 4
   14222:	08 f4       	brcc	.+2      	; 0x14226 <FMenuLocalAccount+0x828>
   14224:	90 cf       	rjmp	.-224    	; 0x14146 <FMenuLocalAccount+0x748>
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
				}
	            lcd_printf(4,1,PSTR("[*]Back             "));   //"[*]Back             "				
   14226:	84 e0       	ldi	r24, 0x04	; 4
   14228:	61 e0       	ldi	r22, 0x01	; 1
   1422a:	4d ea       	ldi	r20, 0xAD	; 173
   1422c:	5f e1       	ldi	r21, 0x1F	; 31
   1422e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				stLocalAccount=laSelectProductInput;
   14232:	8c e0       	ldi	r24, 0x0C	; 12
   14234:	3d c3       	rjmp	.+1658   	; 0x148b0 <FMenuLocalAccount+0xeb2>
				}
		        break; 
           case laSelectProductInput:
				KeyPressed=_key_scan(1);
   14236:	81 e0       	ldi	r24, 0x01	; 1
   14238:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   1423c:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   14240:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   14244:	80 93 a1 03 	sts	0x03A1, r24
				if ((KeyChar>='1')&&(KeyChar<='4')){
   14248:	81 53       	subi	r24, 0x31	; 49
   1424a:	84 30       	cpi	r24, 0x04	; 4
   1424c:	f0 f5       	brcc	.+124    	; 0x142ca <FMenuLocalAccount+0x8cc>
				    iNozzle=KeyChar-'1';
   1424e:	80 93 9a 03 	sts	0x039A, r24
   14252:	07 e7       	ldi	r16, 0x77	; 119
   14254:	13 e0       	ldi	r17, 0x03	; 3
   14256:	e8 2f       	mov	r30, r24
   14258:	f0 e0       	ldi	r31, 0x00	; 0
   1425a:	e6 57       	subi	r30, 0x76	; 118
   1425c:	fc 4f       	sbci	r31, 0xFC	; 252
   1425e:	60 81       	ld	r22, Z
   14260:	8d e0       	ldi	r24, 0x0D	; 13
   14262:	f8 2e       	mov	r15, r24
   14264:	6f 9d       	mul	r22, r15
   14266:	b0 01       	movw	r22, r0
   14268:	11 24       	eor	r1, r1
   1426a:	62 55       	subi	r22, 0x52	; 82
   1426c:	7f 4f       	sbci	r23, 0xFF	; 255
   1426e:	c8 01       	movw	r24, r16
   14270:	4a e0       	ldi	r20, 0x0A	; 10
   14272:	50 e0       	ldi	r21, 0x00	; 0
   14274:	28 ef       	ldi	r18, 0xF8	; 248
   14276:	32 e1       	ldi	r19, 0x12	; 18
   14278:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
				    eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProductID[iNozzle]-1],10);
					sprintf_P(strProduct,PSTR("%s"),ProductName);
   1427c:	00 d0       	rcall	.+0      	; 0x1427e <FMenuLocalAccount+0x880>
   1427e:	00 d0       	rcall	.+0      	; 0x14280 <FMenuLocalAccount+0x882>
   14280:	00 d0       	rcall	.+0      	; 0x14282 <FMenuLocalAccount+0x884>
   14282:	ed b7       	in	r30, 0x3d	; 61
   14284:	fe b7       	in	r31, 0x3e	; 62
   14286:	31 96       	adiw	r30, 0x01	; 1
   14288:	81 e4       	ldi	r24, 0x41	; 65
   1428a:	99 e0       	ldi	r25, 0x09	; 9
   1428c:	ad b7       	in	r26, 0x3d	; 61
   1428e:	be b7       	in	r27, 0x3e	; 62
   14290:	12 96       	adiw	r26, 0x02	; 2
   14292:	9c 93       	st	X, r25
   14294:	8e 93       	st	-X, r24
   14296:	11 97       	sbiw	r26, 0x01	; 1
   14298:	8a ea       	ldi	r24, 0xAA	; 170
   1429a:	9f e1       	ldi	r25, 0x1F	; 31
   1429c:	93 83       	std	Z+3, r25	; 0x03
   1429e:	82 83       	std	Z+2, r24	; 0x02
   142a0:	15 83       	std	Z+5, r17	; 0x05
   142a2:	04 83       	std	Z+4, r16	; 0x04
   142a4:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
					NozzleID=iNozzle+1;
   142a8:	80 91 9a 03 	lds	r24, 0x039A
   142ac:	8f 5f       	subi	r24, 0xFF	; 255
   142ae:	80 93 50 09 	sts	0x0950, r24
                    stLocalAccount=laSelectBalanceType;
   142b2:	f0 92 5c 01 	sts	0x015C, r15
					lcd_clear();
   142b6:	ed b7       	in	r30, 0x3d	; 61
   142b8:	fe b7       	in	r31, 0x3e	; 62
   142ba:	36 96       	adiw	r30, 0x06	; 6
   142bc:	0f b6       	in	r0, 0x3f	; 63
   142be:	f8 94       	cli
   142c0:	fe bf       	out	0x3e, r31	; 62
   142c2:	0f be       	out	0x3f, r0	; 63
   142c4:	ed bf       	out	0x3d, r30	; 61
   142c6:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
					}                
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laSelectFIP;//Back To Pump Selection
   142ca:	80 91 9c 03 	lds	r24, 0x039C
   142ce:	87 3e       	cpi	r24, 0xE7	; 231
   142d0:	09 f0       	breq	.+2      	; 0x142d4 <FMenuLocalAccount+0x8d6>
   142d2:	c1 c5       	rjmp	.+2946   	; 0x14e56 <FMenuLocalAccount+0x1458>
   142d4:	89 e0       	ldi	r24, 0x09	; 9
   142d6:	ec c2       	rjmp	.+1496   	; 0x148b0 <FMenuLocalAccount+0xeb2>
		        break;
           case laSelectBalanceType:
		        lcd_clear();
   142d8:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		        sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   142dc:	2d b7       	in	r18, 0x3d	; 61
   142de:	3e b7       	in	r19, 0x3e	; 62
   142e0:	28 50       	subi	r18, 0x08	; 8
   142e2:	30 40       	sbci	r19, 0x00	; 0
   142e4:	0f b6       	in	r0, 0x3f	; 63
   142e6:	f8 94       	cli
   142e8:	3e bf       	out	0x3e, r19	; 62
   142ea:	0f be       	out	0x3f, r0	; 63
   142ec:	2d bf       	out	0x3d, r18	; 61
   142ee:	ed b7       	in	r30, 0x3d	; 61
   142f0:	fe b7       	in	r31, 0x3e	; 62
   142f2:	31 96       	adiw	r30, 0x01	; 1
   142f4:	8e 01       	movw	r16, r28
   142f6:	0f 5f       	subi	r16, 0xFF	; 255
   142f8:	1f 4f       	sbci	r17, 0xFF	; 255
   142fa:	ad b7       	in	r26, 0x3d	; 61
   142fc:	be b7       	in	r27, 0x3e	; 62
   142fe:	12 96       	adiw	r26, 0x02	; 2
   14300:	1c 93       	st	X, r17
   14302:	0e 93       	st	-X, r16
   14304:	11 97       	sbiw	r26, 0x01	; 1
   14306:	82 ea       	ldi	r24, 0xA2	; 162
   14308:	9f e1       	ldi	r25, 0x1F	; 31
   1430a:	93 83       	std	Z+3, r25	; 0x03
   1430c:	82 83       	std	Z+2, r24	; 0x02
   1430e:	8d e9       	ldi	r24, 0x9D	; 157
   14310:	93 e0       	ldi	r25, 0x03	; 3
   14312:	95 83       	std	Z+5, r25	; 0x05
   14314:	84 83       	std	Z+4, r24	; 0x04
   14316:	81 e4       	ldi	r24, 0x41	; 65
   14318:	99 e0       	ldi	r25, 0x09	; 9
   1431a:	97 83       	std	Z+7, r25	; 0x07
   1431c:	86 83       	std	Z+6, r24	; 0x06
   1431e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
				 lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   14322:	ed b7       	in	r30, 0x3d	; 61
   14324:	fe b7       	in	r31, 0x3e	; 62
   14326:	38 96       	adiw	r30, 0x08	; 8
   14328:	0f b6       	in	r0, 0x3f	; 63
   1432a:	f8 94       	cli
   1432c:	fe bf       	out	0x3e, r31	; 62
   1432e:	0f be       	out	0x3f, r0	; 63
   14330:	ed bf       	out	0x3d, r30	; 61
   14332:	81 e0       	ldi	r24, 0x01	; 1
   14334:	61 e0       	ldi	r22, 0x01	; 1
   14336:	a8 01       	movw	r20, r16
   14338:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		        lcd_printf(2,1,PSTR("[1]Volume           "));   //"[1]Premium          "                                                                      
   1433c:	82 e0       	ldi	r24, 0x02	; 2
   1433e:	61 e0       	ldi	r22, 0x01	; 1
   14340:	4d e8       	ldi	r20, 0x8D	; 141
   14342:	5f e1       	ldi	r21, 0x1F	; 31
   14344:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				lcd_printf(3,1,PSTR("[2]Amount           "));   //"[2]Pertamax         "
   14348:	83 e0       	ldi	r24, 0x03	; 3
   1434a:	61 e0       	ldi	r22, 0x01	; 1
   1434c:	48 e7       	ldi	r20, 0x78	; 120
   1434e:	5f e1       	ldi	r21, 0x1F	; 31
   14350:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
   14354:	84 e0       	ldi	r24, 0x04	; 4
   14356:	61 e0       	ldi	r22, 0x01	; 1
   14358:	43 e6       	ldi	r20, 0x63	; 99
   1435a:	5f e1       	ldi	r21, 0x1F	; 31
   1435c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	            //lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
                stLocalAccount=laSelectBalanceTypeInput;   
   14360:	8e e0       	ldi	r24, 0x0E	; 14
   14362:	a6 c2       	rjmp	.+1356   	; 0x148b0 <FMenuLocalAccount+0xeb2>
		        break;
           case laSelectBalanceTypeInput:
				KeyPressed=_key_scan(1);
   14364:	81 e0       	ldi	r24, 0x01	; 1
   14366:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   1436a:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   1436e:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   14372:	98 2f       	mov	r25, r24
   14374:	80 93 a1 03 	sts	0x03A1, r24
				if ((KeyChar>='1')&&(KeyChar<='2')){
   14378:	81 53       	subi	r24, 0x31	; 49
   1437a:	82 30       	cpi	r24, 0x02	; 2
   1437c:	80 f5       	brcc	.+96     	; 0x143de <FMenuLocalAccount+0x9e0>
                    if(KeyChar=='1'){
   1437e:	91 33       	cpi	r25, 0x31	; 49
   14380:	a1 f4       	brne	.+40     	; 0x143aa <FMenuLocalAccount+0x9ac>
					   BalanceType=1;
   14382:	81 e0       	ldi	r24, 0x01	; 1
   14384:	80 93 a0 03 	sts	0x03A0, r24
					   sprintf_P(strBalanceType,PSTR("V"));
   14388:	00 d0       	rcall	.+0      	; 0x1438a <FMenuLocalAccount+0x98c>
   1438a:	00 d0       	rcall	.+0      	; 0x1438c <FMenuLocalAccount+0x98e>
   1438c:	83 e8       	ldi	r24, 0x83	; 131
   1438e:	95 e0       	ldi	r25, 0x05	; 5
   14390:	ad b7       	in	r26, 0x3d	; 61
   14392:	be b7       	in	r27, 0x3e	; 62
   14394:	12 96       	adiw	r26, 0x02	; 2
   14396:	9c 93       	st	X, r25
   14398:	8e 93       	st	-X, r24
   1439a:	11 97       	sbiw	r26, 0x01	; 1
   1439c:	81 e6       	ldi	r24, 0x61	; 97
   1439e:	9f e1       	ldi	r25, 0x1F	; 31
   143a0:	14 96       	adiw	r26, 0x04	; 4
   143a2:	9c 93       	st	X, r25
   143a4:	8e 93       	st	-X, r24
   143a6:	13 97       	sbiw	r26, 0x03	; 3
   143a8:	11 c0       	rjmp	.+34     	; 0x143cc <FMenuLocalAccount+0x9ce>
					   }
					else
                    if(KeyChar=='2'){
   143aa:	92 33       	cpi	r25, 0x32	; 50
   143ac:	a9 f4       	brne	.+42     	; 0x143d8 <FMenuLocalAccount+0x9da>
					   BalanceType=2;
   143ae:	82 e0       	ldi	r24, 0x02	; 2
   143b0:	80 93 a0 03 	sts	0x03A0, r24
                       sprintf_P(strBalanceType,PSTR("A"));
   143b4:	00 d0       	rcall	.+0      	; 0x143b6 <FMenuLocalAccount+0x9b8>
   143b6:	00 d0       	rcall	.+0      	; 0x143b8 <FMenuLocalAccount+0x9ba>
   143b8:	83 e8       	ldi	r24, 0x83	; 131
   143ba:	95 e0       	ldi	r25, 0x05	; 5
   143bc:	ed b7       	in	r30, 0x3d	; 61
   143be:	fe b7       	in	r31, 0x3e	; 62
   143c0:	92 83       	std	Z+2, r25	; 0x02
   143c2:	81 83       	std	Z+1, r24	; 0x01
   143c4:	8f e5       	ldi	r24, 0x5F	; 95
   143c6:	9f e1       	ldi	r25, 0x1F	; 31
   143c8:	94 83       	std	Z+4, r25	; 0x04
   143ca:	83 83       	std	Z+3, r24	; 0x03
   143cc:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   143d0:	0f 90       	pop	r0
   143d2:	0f 90       	pop	r0
   143d4:	0f 90       	pop	r0
   143d6:	0f 90       	pop	r0
					   }
				    stLocalAccount=laBalanceValue;  
   143d8:	8f e0       	ldi	r24, 0x0F	; 15
   143da:	80 93 5c 01 	sts	0x015C, r24
					}              
				if (KeyPressed==_KEY_CANCEL){
   143de:	80 91 9c 03 	lds	r24, 0x039C
   143e2:	87 3e       	cpi	r24, 0xE7	; 231
   143e4:	c9 f4       	brne	.+50     	; 0x14418 <FMenuLocalAccount+0xa1a>
				    if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&(ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0))
   143e6:	80 91 8a 03 	lds	r24, 0x038A
   143ea:	81 50       	subi	r24, 0x01	; 1
   143ec:	86 30       	cpi	r24, 0x06	; 6
   143ee:	70 f4       	brcc	.+28     	; 0x1440c <FMenuLocalAccount+0xa0e>
   143f0:	80 91 8b 03 	lds	r24, 0x038B
   143f4:	88 23       	and	r24, r24
   143f6:	51 f4       	brne	.+20     	; 0x1440c <FMenuLocalAccount+0xa0e>
   143f8:	80 91 8c 03 	lds	r24, 0x038C
   143fc:	88 23       	and	r24, r24
   143fe:	31 f4       	brne	.+12     	; 0x1440c <FMenuLocalAccount+0xa0e>
   14400:	80 91 8d 03 	lds	r24, 0x038D
   14404:	88 23       	and	r24, r24
   14406:	11 f4       	brne	.+4      	; 0x1440c <FMenuLocalAccount+0xa0e>
					     stLocalAccount=laSelectFIP;//Back To FIP Select Non MPD
   14408:	89 e0       	ldi	r24, 0x09	; 9
   1440a:	01 c0       	rjmp	.+2      	; 0x1440e <FMenuLocalAccount+0xa10>
                    else stLocalAccount=laSelectProduct;//Back To Product Selection MPD
   1440c:	8b e0       	ldi	r24, 0x0B	; 11
   1440e:	80 93 5c 01 	sts	0x015C, r24
					lcd_clear();
   14412:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
   14416:	1f c5       	rjmp	.+2622   	; 0x14e56 <FMenuLocalAccount+0x1458>
					}
                else
				if (KeyPressed==_KEY_ENTER){
   14418:	87 3b       	cpi	r24, 0xB7	; 183
   1441a:	09 f0       	breq	.+2      	; 0x1441e <FMenuLocalAccount+0xa20>
   1441c:	1c c5       	rjmp	.+2616   	; 0x14e56 <FMenuLocalAccount+0x1458>
				    BalanceType=1;
   1441e:	11 e0       	ldi	r17, 0x01	; 1
   14420:	10 93 a0 03 	sts	0x03A0, r17
					sprintf_P(strBalanceType,PSTR("A"));
   14424:	00 d0       	rcall	.+0      	; 0x14426 <FMenuLocalAccount+0xa28>
   14426:	00 d0       	rcall	.+0      	; 0x14428 <FMenuLocalAccount+0xa2a>
   14428:	83 e8       	ldi	r24, 0x83	; 131
   1442a:	95 e0       	ldi	r25, 0x05	; 5
   1442c:	ad b7       	in	r26, 0x3d	; 61
   1442e:	be b7       	in	r27, 0x3e	; 62
   14430:	12 96       	adiw	r26, 0x02	; 2
   14432:	9c 93       	st	X, r25
   14434:	8e 93       	st	-X, r24
   14436:	11 97       	sbiw	r26, 0x01	; 1
   14438:	8d e5       	ldi	r24, 0x5D	; 93
   1443a:	9f e1       	ldi	r25, 0x1F	; 31
   1443c:	14 96       	adiw	r26, 0x04	; 4
   1443e:	9c 93       	st	X, r25
   14440:	8e 93       	st	-X, r24
   14442:	13 97       	sbiw	r26, 0x03	; 3
   14444:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
					//sprintf_P(strBalanceValue,PSTR("999"));
					IsFullAuthorized=True;
   14448:	10 93 74 03 	sts	0x0374, r17
                    stLocalAccount=laOdometer;//FullAuthorized
   1444c:	81 e1       	ldi	r24, 0x11	; 17
   1444e:	80 93 5c 01 	sts	0x015C, r24
   14452:	80 e0       	ldi	r24, 0x00	; 0
   14454:	0f 90       	pop	r0
   14456:	0f 90       	pop	r0
   14458:	0f 90       	pop	r0
   1445a:	0f 90       	pop	r0
   1445c:	fd c4       	rjmp	.+2554   	; 0x14e58 <FMenuLocalAccount+0x145a>
					}

		        break;
           case laBalanceValue:
		        lcd_clear();
   1445e:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		        if(BalanceType==1){
   14462:	80 91 a0 03 	lds	r24, 0x03A0
   14466:	81 30       	cpi	r24, 0x01	; 1
   14468:	f1 f5       	brne	.+124    	; 0x144e6 <FMenuLocalAccount+0xae8>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   1446a:	ed b7       	in	r30, 0x3d	; 61
   1446c:	fe b7       	in	r31, 0x3e	; 62
   1446e:	38 97       	sbiw	r30, 0x08	; 8
   14470:	0f b6       	in	r0, 0x3f	; 63
   14472:	f8 94       	cli
   14474:	fe bf       	out	0x3e, r31	; 62
   14476:	0f be       	out	0x3f, r0	; 63
   14478:	ed bf       	out	0x3d, r30	; 61
   1447a:	31 96       	adiw	r30, 0x01	; 1
   1447c:	8e 01       	movw	r16, r28
   1447e:	0f 5f       	subi	r16, 0xFF	; 255
   14480:	1f 4f       	sbci	r17, 0xFF	; 255
   14482:	ad b7       	in	r26, 0x3d	; 61
   14484:	be b7       	in	r27, 0x3e	; 62
   14486:	12 96       	adiw	r26, 0x02	; 2
   14488:	1c 93       	st	X, r17
   1448a:	0e 93       	st	-X, r16
   1448c:	11 97       	sbiw	r26, 0x01	; 1
   1448e:	85 e5       	ldi	r24, 0x55	; 85
   14490:	9f e1       	ldi	r25, 0x1F	; 31
   14492:	93 83       	std	Z+3, r25	; 0x03
   14494:	82 83       	std	Z+2, r24	; 0x02
   14496:	8d e9       	ldi	r24, 0x9D	; 157
   14498:	93 e0       	ldi	r25, 0x03	; 3
   1449a:	95 83       	std	Z+5, r25	; 0x05
   1449c:	84 83       	std	Z+4, r24	; 0x04
   1449e:	81 e4       	ldi	r24, 0x41	; 65
   144a0:	99 e0       	ldi	r25, 0x09	; 9
   144a2:	97 83       	std	Z+7, r25	; 0x07
   144a4:	86 83       	std	Z+6, r24	; 0x06
   144a6:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
				    lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   144aa:	ed b7       	in	r30, 0x3d	; 61
   144ac:	fe b7       	in	r31, 0x3e	; 62
   144ae:	38 96       	adiw	r30, 0x08	; 8
   144b0:	0f b6       	in	r0, 0x3f	; 63
   144b2:	f8 94       	cli
   144b4:	fe bf       	out	0x3e, r31	; 62
   144b6:	0f be       	out	0x3f, r0	; 63
   144b8:	ed bf       	out	0x3d, r30	; 61
   144ba:	81 e0       	ldi	r24, 0x01	; 1
   144bc:	61 e0       	ldi	r22, 0x01	; 1
   144be:	a8 01       	movw	r20, r16
   144c0:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		           lcd_printf(2,1,PSTR("[1]Volume:_         "));   //"[1]Volume:_         "                                                                      
   144c4:	82 e0       	ldi	r24, 0x02	; 2
   144c6:	61 e0       	ldi	r22, 0x01	; 1
   144c8:	40 e4       	ldi	r20, 0x40	; 64
   144ca:	5f e1       	ldi	r21, 0x1F	; 31
   144cc:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				   lcd_printf(3,1,PSTR("                    "));   //"                    "
   144d0:	83 e0       	ldi	r24, 0x03	; 3
   144d2:	61 e0       	ldi	r22, 0x01	; 1
   144d4:	4b e2       	ldi	r20, 0x2B	; 43
   144d6:	5f e1       	ldi	r21, 0x1F	; 31
   144d8:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK     "						        
   144dc:	84 e0       	ldi	r24, 0x04	; 4
   144de:	61 e0       	ldi	r22, 0x01	; 1
   144e0:	46 e1       	ldi	r20, 0x16	; 22
   144e2:	5f e1       	ldi	r21, 0x1F	; 31
   144e4:	43 c0       	rjmp	.+134    	; 0x1456c <FMenuLocalAccount+0xb6e>
				   }
                else
		        if(BalanceType==2){
   144e6:	82 30       	cpi	r24, 0x02	; 2
   144e8:	09 f0       	breq	.+2      	; 0x144ec <FMenuLocalAccount+0xaee>
   144ea:	42 c0       	rjmp	.+132    	; 0x14570 <FMenuLocalAccount+0xb72>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   144ec:	2d b7       	in	r18, 0x3d	; 61
   144ee:	3e b7       	in	r19, 0x3e	; 62
   144f0:	28 50       	subi	r18, 0x08	; 8
   144f2:	30 40       	sbci	r19, 0x00	; 0
   144f4:	0f b6       	in	r0, 0x3f	; 63
   144f6:	f8 94       	cli
   144f8:	3e bf       	out	0x3e, r19	; 62
   144fa:	0f be       	out	0x3f, r0	; 63
   144fc:	2d bf       	out	0x3d, r18	; 61
   144fe:	ed b7       	in	r30, 0x3d	; 61
   14500:	fe b7       	in	r31, 0x3e	; 62
   14502:	31 96       	adiw	r30, 0x01	; 1
   14504:	8e 01       	movw	r16, r28
   14506:	0f 5f       	subi	r16, 0xFF	; 255
   14508:	1f 4f       	sbci	r17, 0xFF	; 255
   1450a:	ad b7       	in	r26, 0x3d	; 61
   1450c:	be b7       	in	r27, 0x3e	; 62
   1450e:	12 96       	adiw	r26, 0x02	; 2
   14510:	1c 93       	st	X, r17
   14512:	0e 93       	st	-X, r16
   14514:	11 97       	sbiw	r26, 0x01	; 1
   14516:	8e e0       	ldi	r24, 0x0E	; 14
   14518:	9f e1       	ldi	r25, 0x1F	; 31
   1451a:	93 83       	std	Z+3, r25	; 0x03
   1451c:	82 83       	std	Z+2, r24	; 0x02
   1451e:	8d e9       	ldi	r24, 0x9D	; 157
   14520:	93 e0       	ldi	r25, 0x03	; 3
   14522:	95 83       	std	Z+5, r25	; 0x05
   14524:	84 83       	std	Z+4, r24	; 0x04
   14526:	81 e4       	ldi	r24, 0x41	; 65
   14528:	99 e0       	ldi	r25, 0x09	; 9
   1452a:	97 83       	std	Z+7, r25	; 0x07
   1452c:	86 83       	std	Z+6, r24	; 0x06
   1452e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
				   lcd_print(1,1,lcdteks);                         //"P01-Pertamax        "                                                                      
   14532:	ed b7       	in	r30, 0x3d	; 61
   14534:	fe b7       	in	r31, 0x3e	; 62
   14536:	38 96       	adiw	r30, 0x08	; 8
   14538:	0f b6       	in	r0, 0x3f	; 63
   1453a:	f8 94       	cli
   1453c:	fe bf       	out	0x3e, r31	; 62
   1453e:	0f be       	out	0x3f, r0	; 63
   14540:	ed bf       	out	0x3d, r30	; 61
   14542:	81 e0       	ldi	r24, 0x01	; 1
   14544:	61 e0       	ldi	r22, 0x01	; 1
   14546:	a8 01       	movw	r20, r16
   14548:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		           lcd_printf(2,1,PSTR("                    "));   //"                    "                                                                      
   1454c:	82 e0       	ldi	r24, 0x02	; 2
   1454e:	61 e0       	ldi	r22, 0x01	; 1
   14550:	49 ef       	ldi	r20, 0xF9	; 249
   14552:	5e e1       	ldi	r21, 0x1E	; 30
   14554:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				   lcd_printf(3,1,PSTR("[2]Amount:_         "));   //"[2]Amount:_         "
   14558:	83 e0       	ldi	r24, 0x03	; 3
   1455a:	61 e0       	ldi	r22, 0x01	; 1
   1455c:	44 ee       	ldi	r20, 0xE4	; 228
   1455e:	5e e1       	ldi	r21, 0x1E	; 30
   14560:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK      "			        
   14564:	84 e0       	ldi	r24, 0x04	; 4
   14566:	61 e0       	ldi	r22, 0x01	; 1
   14568:	4f ec       	ldi	r20, 0xCF	; 207
   1456a:	5e e1       	ldi	r21, 0x1E	; 30
   1456c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				   }
                iLoop=0;
   14570:	10 92 73 03 	sts	0x0373, r1
   14574:	10 92 72 03 	sts	0x0372, r1
				iValuePos=0;
   14578:	10 92 9b 03 	sts	0x039B, r1
				ValueChar[iValuePos]=' ';
   1457c:	80 e2       	ldi	r24, 0x20	; 32
   1457e:	80 93 90 03 	sts	0x0390, r24
		        stLocalAccount=laBalanceValueInput;  
   14582:	80 e1       	ldi	r24, 0x10	; 16
   14584:	95 c1       	rjmp	.+810    	; 0x148b0 <FMenuLocalAccount+0xeb2>
		        break; 
           case laBalanceValueInput:
			    //Blinking 50% _      BalanceValue Volume=999  Amount=65536
			    iLoop++;
   14586:	80 91 72 03 	lds	r24, 0x0372
   1458a:	90 91 73 03 	lds	r25, 0x0373
   1458e:	01 96       	adiw	r24, 0x01	; 1
   14590:	90 93 73 03 	sts	0x0373, r25
   14594:	80 93 72 03 	sts	0x0372, r24
			    //GetKeyPressed
			    KeyPressed=_key_scan(1);
   14598:	81 e0       	ldi	r24, 0x01	; 1
   1459a:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   1459e:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   145a2:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   145a6:	98 2f       	mov	r25, r24
   145a8:	80 93 a1 03 	sts	0x03A1, r24
				if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<6)&&(BalanceType==2))||//Max Rp.999999
   145ac:	80 53       	subi	r24, 0x30	; 48
   145ae:	8a 30       	cpi	r24, 0x0A	; 10
   145b0:	38 f5       	brcc	.+78     	; 0x14600 <FMenuLocalAccount+0xc02>
   145b2:	e0 91 9b 03 	lds	r30, 0x039B
   145b6:	e6 30       	cpi	r30, 0x06	; 6
   145b8:	18 f5       	brcc	.+70     	; 0x14600 <FMenuLocalAccount+0xc02>
   145ba:	80 91 a0 03 	lds	r24, 0x03A0
   145be:	82 30       	cpi	r24, 0x02	; 2
   145c0:	21 f0       	breq	.+8      	; 0x145ca <FMenuLocalAccount+0xbcc>
   145c2:	e3 30       	cpi	r30, 0x03	; 3
   145c4:	e8 f4       	brcc	.+58     	; 0x14600 <FMenuLocalAccount+0xc02>
   145c6:	81 30       	cpi	r24, 0x01	; 1
   145c8:	d9 f4       	brne	.+54     	; 0x14600 <FMenuLocalAccount+0xc02>
				   ((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<3)&&(BalanceType==1))){ //Max       999L
				    ValueChar[iValuePos]=KeyChar;
   145ca:	f0 e0       	ldi	r31, 0x00	; 0
   145cc:	e0 57       	subi	r30, 0x70	; 112
   145ce:	fc 4f       	sbci	r31, 0xFC	; 252
   145d0:	90 83       	st	Z, r25
					iValuePos++;
   145d2:	60 91 9b 03 	lds	r22, 0x039B
   145d6:	6f 5f       	subi	r22, 0xFF	; 255
   145d8:	60 93 9b 03 	sts	0x039B, r22
					lcd_xy(1+BalanceType,(10+iValuePos));_lcd(ValueChar[iValuePos-1]); 
   145dc:	80 91 a0 03 	lds	r24, 0x03A0
   145e0:	66 5f       	subi	r22, 0xF6	; 246
   145e2:	8f 5f       	subi	r24, 0xFF	; 255
   145e4:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
   145e8:	e0 91 9b 03 	lds	r30, 0x039B
   145ec:	f0 e0       	ldi	r31, 0x00	; 0
   145ee:	e1 57       	subi	r30, 0x71	; 113
   145f0:	fc 4f       	sbci	r31, 0xFC	; 252
   145f2:	80 81       	ld	r24, Z
   145f4:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
   145f8:	80 e5       	ldi	r24, 0x50	; 80
   145fa:	93 ec       	ldi	r25, 0xC3	; 195
   145fc:	01 97       	sbiw	r24, 0x01	; 1
   145fe:	f1 f7       	brne	.-4      	; 0x145fc <FMenuLocalAccount+0xbfe>
					_delay_ms(200);
					}
			    if ((iLoop%2000)==0){
   14600:	80 91 72 03 	lds	r24, 0x0372
   14604:	90 91 73 03 	lds	r25, 0x0373
   14608:	60 ed       	ldi	r22, 0xD0	; 208
   1460a:	77 e0       	ldi	r23, 0x07	; 7
   1460c:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
   14610:	89 2b       	or	r24, r25
   14612:	59 f4       	brne	.+22     	; 0x1462a <FMenuLocalAccount+0xc2c>
				     lcd_xy((1+BalanceType),(11+iValuePos));_lcd('_'); 
   14614:	80 91 a0 03 	lds	r24, 0x03A0
   14618:	60 91 9b 03 	lds	r22, 0x039B
   1461c:	65 5f       	subi	r22, 0xF5	; 245
   1461e:	8f 5f       	subi	r24, 0xFF	; 255
   14620:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
   14624:	8f e5       	ldi	r24, 0x5F	; 95
   14626:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
			    }
			    if ((iLoop%2000)==1000){
   1462a:	80 91 72 03 	lds	r24, 0x0372
   1462e:	90 91 73 03 	lds	r25, 0x0373
   14632:	60 ed       	ldi	r22, 0xD0	; 208
   14634:	77 e0       	ldi	r23, 0x07	; 7
   14636:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
   1463a:	88 5e       	subi	r24, 0xE8	; 232
   1463c:	93 40       	sbci	r25, 0x03	; 3
   1463e:	59 f4       	brne	.+22     	; 0x14656 <FMenuLocalAccount+0xc58>
				     lcd_xy((1+BalanceType),(11+iValuePos));_lcd(' '); 
   14640:	80 91 a0 03 	lds	r24, 0x03A0
   14644:	60 91 9b 03 	lds	r22, 0x039B
   14648:	65 5f       	subi	r22, 0xF5	; 245
   1464a:	8f 5f       	subi	r24, 0xFF	; 255
   1464c:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
   14650:	80 e2       	ldi	r24, 0x20	; 32
   14652:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
			    }
				if (KeyPressed==_KEY_CANCEL){
   14656:	80 91 9c 03 	lds	r24, 0x039C
   1465a:	87 3e       	cpi	r24, 0xE7	; 231
   1465c:	39 f4       	brne	.+14     	; 0x1466c <FMenuLocalAccount+0xc6e>
				    lcd_clear();
   1465e:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
   14662:	88 ea       	ldi	r24, 0xA8	; 168
   14664:	91 e6       	ldi	r25, 0x61	; 97
   14666:	01 97       	sbiw	r24, 0x01	; 1
   14668:	f1 f7       	brne	.-4      	; 0x14666 <FMenuLocalAccount+0xc68>
   1466a:	1f c1       	rjmp	.+574    	; 0x148aa <FMenuLocalAccount+0xeac>
					_delay_ms(100);		        
				    stLocalAccount=laSelectBalanceType;		        
					}
				else
				if (KeyPressed==_KEY_ENTER){				    
   1466c:	87 3b       	cpi	r24, 0xB7	; 183
   1466e:	09 f0       	breq	.+2      	; 0x14672 <FMenuLocalAccount+0xc74>
   14670:	f2 c3       	rjmp	.+2020   	; 0x14e56 <FMenuLocalAccount+0x1458>
                    ValueChar[iValuePos]=0;
   14672:	e0 91 9b 03 	lds	r30, 0x039B
   14676:	f0 e0       	ldi	r31, 0x00	; 0
   14678:	e0 57       	subi	r30, 0x70	; 112
   1467a:	fc 4f       	sbci	r31, 0xFC	; 252
   1467c:	10 82       	st	Z, r1
					sprintf_P(strBalanceValue,PSTR("%s"),ValueChar);
   1467e:	00 d0       	rcall	.+0      	; 0x14680 <FMenuLocalAccount+0xc82>
   14680:	00 d0       	rcall	.+0      	; 0x14682 <FMenuLocalAccount+0xc84>
   14682:	00 d0       	rcall	.+0      	; 0x14684 <FMenuLocalAccount+0xc86>
   14684:	ed b7       	in	r30, 0x3d	; 61
   14686:	fe b7       	in	r31, 0x3e	; 62
   14688:	31 96       	adiw	r30, 0x01	; 1
   1468a:	82 e7       	ldi	r24, 0x72	; 114
   1468c:	9f e0       	ldi	r25, 0x0F	; 15
   1468e:	ad b7       	in	r26, 0x3d	; 61
   14690:	be b7       	in	r27, 0x3e	; 62
   14692:	12 96       	adiw	r26, 0x02	; 2
   14694:	9c 93       	st	X, r25
   14696:	8e 93       	st	-X, r24
   14698:	11 97       	sbiw	r26, 0x01	; 1
   1469a:	8c ec       	ldi	r24, 0xCC	; 204
   1469c:	9e e1       	ldi	r25, 0x1E	; 30
   1469e:	93 83       	std	Z+3, r25	; 0x03
   146a0:	82 83       	std	Z+2, r24	; 0x02
   146a2:	80 e9       	ldi	r24, 0x90	; 144
   146a4:	93 e0       	ldi	r25, 0x03	; 3
   146a6:	95 83       	std	Z+5, r25	; 0x05
   146a8:	84 83       	std	Z+4, r24	; 0x04
   146aa:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
				    stLocalAccount=laOdometer;
   146ae:	81 e1       	ldi	r24, 0x11	; 17
   146b0:	80 93 5c 01 	sts	0x015C, r24
					lcd_clear();
   146b4:	ed b7       	in	r30, 0x3d	; 61
   146b6:	fe b7       	in	r31, 0x3e	; 62
   146b8:	36 96       	adiw	r30, 0x06	; 6
   146ba:	0f b6       	in	r0, 0x3f	; 63
   146bc:	f8 94       	cli
   146be:	fe bf       	out	0x3e, r31	; 62
   146c0:	0f be       	out	0x3f, r0	; 63
   146c2:	ed bf       	out	0x3d, r30	; 61
   146c4:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
   146c8:	88 ea       	ldi	r24, 0xA8	; 168
   146ca:	91 e6       	ldi	r25, 0x61	; 97
   146cc:	01 97       	sbiw	r24, 0x01	; 1
   146ce:	f1 f7       	brne	.-4      	; 0x146cc <FMenuLocalAccount+0xcce>
   146d0:	c2 c3       	rjmp	.+1924   	; 0x14e56 <FMenuLocalAccount+0x1458>
					_delay_ms(100);		        
					}
		        break;
           case laOdometer://GetOdometer			
		        lcd_clear();
   146d2:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
				if (IsFullAuthorized==True){
   146d6:	80 91 74 03 	lds	r24, 0x0374
   146da:	81 30       	cpi	r24, 0x01	; 1
   146dc:	09 f0       	breq	.+2      	; 0x146e0 <FMenuLocalAccount+0xce2>
   146de:	4a c0       	rjmp	.+148    	; 0x14774 <FMenuLocalAccount+0xd76>
				    lcd_printf(1,1,PSTR("Pump Product   Full"));
   146e0:	61 e0       	ldi	r22, 0x01	; 1
   146e2:	48 eb       	ldi	r20, 0xB8	; 184
   146e4:	5e e1       	ldi	r21, 0x1E	; 30
   146e6:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   146ea:	2d b7       	in	r18, 0x3d	; 61
   146ec:	3e b7       	in	r19, 0x3e	; 62
   146ee:	28 50       	subi	r18, 0x08	; 8
   146f0:	30 40       	sbci	r19, 0x00	; 0
   146f2:	0f b6       	in	r0, 0x3f	; 63
   146f4:	f8 94       	cli
   146f6:	3e bf       	out	0x3e, r19	; 62
   146f8:	0f be       	out	0x3f, r0	; 63
   146fa:	2d bf       	out	0x3d, r18	; 61
   146fc:	ed b7       	in	r30, 0x3d	; 61
   146fe:	fe b7       	in	r31, 0x3e	; 62
   14700:	31 96       	adiw	r30, 0x01	; 1
   14702:	8e 01       	movw	r16, r28
   14704:	0f 5f       	subi	r16, 0xFF	; 255
   14706:	1f 4f       	sbci	r17, 0xFF	; 255
   14708:	ad b7       	in	r26, 0x3d	; 61
   1470a:	be b7       	in	r27, 0x3e	; 62
   1470c:	12 96       	adiw	r26, 0x02	; 2
   1470e:	1c 93       	st	X, r17
   14710:	0e 93       	st	-X, r16
   14712:	11 97       	sbiw	r26, 0x01	; 1
   14714:	8f ea       	ldi	r24, 0xAF	; 175
   14716:	9e e1       	ldi	r25, 0x1E	; 30
   14718:	93 83       	std	Z+3, r25	; 0x03
   1471a:	82 83       	std	Z+2, r24	; 0x02
   1471c:	8d e9       	ldi	r24, 0x9D	; 157
   1471e:	93 e0       	ldi	r25, 0x03	; 3
   14720:	95 83       	std	Z+5, r25	; 0x05
   14722:	84 83       	std	Z+4, r24	; 0x04
   14724:	81 e4       	ldi	r24, 0x41	; 65
   14726:	99 e0       	ldi	r25, 0x09	; 9
   14728:	97 83       	std	Z+7, r25	; 0x07
   1472a:	86 83       	std	Z+6, r24	; 0x06
   1472c:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   14730:	ed b7       	in	r30, 0x3d	; 61
   14732:	fe b7       	in	r31, 0x3e	; 62
   14734:	38 96       	adiw	r30, 0x08	; 8
   14736:	0f b6       	in	r0, 0x3f	; 63
   14738:	f8 94       	cli
   1473a:	fe bf       	out	0x3e, r31	; 62
   1473c:	0f be       	out	0x3f, r0	; 63
   1473e:	ed bf       	out	0x3d, r30	; 61
   14740:	82 e0       	ldi	r24, 0x02	; 2
   14742:	61 e0       	ldi	r22, 0x01	; 1
   14744:	a8 01       	movw	r20, r16
   14746:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		            sprintf_P(lcdteks,PSTR("  Tank"));            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   1474a:	00 d0       	rcall	.+0      	; 0x1474c <FMenuLocalAccount+0xd4e>
   1474c:	00 d0       	rcall	.+0      	; 0x1474e <FMenuLocalAccount+0xd50>
   1474e:	ad b7       	in	r26, 0x3d	; 61
   14750:	be b7       	in	r27, 0x3e	; 62
   14752:	12 96       	adiw	r26, 0x02	; 2
   14754:	1c 93       	st	X, r17
   14756:	0e 93       	st	-X, r16
   14758:	11 97       	sbiw	r26, 0x01	; 1
   1475a:	88 ea       	ldi	r24, 0xA8	; 168
   1475c:	9e e1       	ldi	r25, 0x1E	; 30
   1475e:	14 96       	adiw	r26, 0x04	; 4
   14760:	9c 93       	st	X, r25
   14762:	8e 93       	st	-X, r24
   14764:	13 97       	sbiw	r26, 0x03	; 3
   14766:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   1476a:	0f 90       	pop	r0
   1476c:	0f 90       	pop	r0
   1476e:	0f 90       	pop	r0
   14770:	0f 90       	pop	r0
   14772:	5e c0       	rjmp	.+188    	; 0x14830 <FMenuLocalAccount+0xe32>
				}
                else{
		            if (BalanceType==1) lcd_printf(1,1,PSTR("Pump Product Volume"));
   14774:	80 91 a0 03 	lds	r24, 0x03A0
   14778:	81 30       	cpi	r24, 0x01	; 1
   1477a:	29 f4       	brne	.+10     	; 0x14786 <FMenuLocalAccount+0xd88>
   1477c:	61 e0       	ldi	r22, 0x01	; 1
   1477e:	44 e9       	ldi	r20, 0x94	; 148
   14780:	5e e1       	ldi	r21, 0x1E	; 30
   14782:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
                    if (BalanceType==2) lcd_printf(1,1,PSTR("Pump Product Amount"));//"Pump Product  Amount" 
   14786:	80 91 a0 03 	lds	r24, 0x03A0
   1478a:	82 30       	cpi	r24, 0x02	; 2
   1478c:	31 f4       	brne	.+12     	; 0x1479a <FMenuLocalAccount+0xd9c>
   1478e:	81 e0       	ldi	r24, 0x01	; 1
   14790:	61 e0       	ldi	r22, 0x01	; 1
   14792:	40 e8       	ldi	r20, 0x80	; 128
   14794:	5e e1       	ldi	r21, 0x1E	; 30
   14796:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   1479a:	ed b7       	in	r30, 0x3d	; 61
   1479c:	fe b7       	in	r31, 0x3e	; 62
   1479e:	38 97       	sbiw	r30, 0x08	; 8
   147a0:	0f b6       	in	r0, 0x3f	; 63
   147a2:	f8 94       	cli
   147a4:	fe bf       	out	0x3e, r31	; 62
   147a6:	0f be       	out	0x3f, r0	; 63
   147a8:	ed bf       	out	0x3d, r30	; 61
   147aa:	31 96       	adiw	r30, 0x01	; 1
   147ac:	8e 01       	movw	r16, r28
   147ae:	0f 5f       	subi	r16, 0xFF	; 255
   147b0:	1f 4f       	sbci	r17, 0xFF	; 255
   147b2:	ad b7       	in	r26, 0x3d	; 61
   147b4:	be b7       	in	r27, 0x3e	; 62
   147b6:	12 96       	adiw	r26, 0x02	; 2
   147b8:	1c 93       	st	X, r17
   147ba:	0e 93       	st	-X, r16
   147bc:	11 97       	sbiw	r26, 0x01	; 1
   147be:	87 e7       	ldi	r24, 0x77	; 119
   147c0:	9e e1       	ldi	r25, 0x1E	; 30
   147c2:	93 83       	std	Z+3, r25	; 0x03
   147c4:	82 83       	std	Z+2, r24	; 0x02
   147c6:	8d e9       	ldi	r24, 0x9D	; 157
   147c8:	93 e0       	ldi	r25, 0x03	; 3
   147ca:	95 83       	std	Z+5, r25	; 0x05
   147cc:	84 83       	std	Z+4, r24	; 0x04
   147ce:	81 e4       	ldi	r24, 0x41	; 65
   147d0:	99 e0       	ldi	r25, 0x09	; 9
   147d2:	97 83       	std	Z+7, r25	; 0x07
   147d4:	86 83       	std	Z+6, r24	; 0x06
   147d6:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   147da:	ed b7       	in	r30, 0x3d	; 61
   147dc:	fe b7       	in	r31, 0x3e	; 62
   147de:	38 96       	adiw	r30, 0x08	; 8
   147e0:	0f b6       	in	r0, 0x3f	; 63
   147e2:	f8 94       	cli
   147e4:	fe bf       	out	0x3e, r31	; 62
   147e6:	0f be       	out	0x3f, r0	; 63
   147e8:	ed bf       	out	0x3d, r30	; 61
   147ea:	82 e0       	ldi	r24, 0x02	; 2
   147ec:	61 e0       	ldi	r22, 0x01	; 1
   147ee:	a8 01       	movw	r20, r16
   147f0:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		            sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   147f4:	00 d0       	rcall	.+0      	; 0x147f6 <FMenuLocalAccount+0xdf8>
   147f6:	00 d0       	rcall	.+0      	; 0x147f8 <FMenuLocalAccount+0xdfa>
   147f8:	00 d0       	rcall	.+0      	; 0x147fa <FMenuLocalAccount+0xdfc>
   147fa:	ed b7       	in	r30, 0x3d	; 61
   147fc:	fe b7       	in	r31, 0x3e	; 62
   147fe:	31 96       	adiw	r30, 0x01	; 1
   14800:	ad b7       	in	r26, 0x3d	; 61
   14802:	be b7       	in	r27, 0x3e	; 62
   14804:	12 96       	adiw	r26, 0x02	; 2
   14806:	1c 93       	st	X, r17
   14808:	0e 93       	st	-X, r16
   1480a:	11 97       	sbiw	r26, 0x01	; 1
   1480c:	83 e7       	ldi	r24, 0x73	; 115
   1480e:	9e e1       	ldi	r25, 0x1E	; 30
   14810:	93 83       	std	Z+3, r25	; 0x03
   14812:	82 83       	std	Z+2, r24	; 0x02
   14814:	82 e7       	ldi	r24, 0x72	; 114
   14816:	9f e0       	ldi	r25, 0x0F	; 15
   14818:	95 83       	std	Z+5, r25	; 0x05
   1481a:	84 83       	std	Z+4, r24	; 0x04
   1481c:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   14820:	ed b7       	in	r30, 0x3d	; 61
   14822:	fe b7       	in	r31, 0x3e	; 62
   14824:	36 96       	adiw	r30, 0x06	; 6
   14826:	0f b6       	in	r0, 0x3f	; 63
   14828:	f8 94       	cli
   1482a:	fe bf       	out	0x3e, r31	; 62
   1482c:	0f be       	out	0x3f, r0	; 63
   1482e:	ed bf       	out	0x3d, r30	; 61
   14830:	82 e0       	ldi	r24, 0x02	; 2
   14832:	6e e0       	ldi	r22, 0x0E	; 14
   14834:	a8 01       	movw	r20, r16
   14836:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>

				}
				lcd_printf(3,1,PSTR("Odometer:_       "));                                //"Odometer:_          "
   1483a:	83 e0       	ldi	r24, 0x03	; 3
   1483c:	61 e0       	ldi	r22, 0x01	; 1
   1483e:	41 e6       	ldi	r20, 0x61	; 97
   14840:	5e e1       	ldi	r21, 0x1E	; 30
   14842:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	            lcd_printf(4,1,PSTR("[*]Back  [#]OK   "));                                //"[*]Back  [#]OK      "						        
   14846:	84 e0       	ldi	r24, 0x04	; 4
   14848:	61 e0       	ldi	r22, 0x01	; 1
   1484a:	4f e4       	ldi	r20, 0x4F	; 79
   1484c:	5e e1       	ldi	r21, 0x1E	; 30
   1484e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
                //iLoop=0;
				//iValuePos=0;
				//ValueChar[iValuePos]=' ';        
				ClearMem(strOdometer);
   14852:	83 ea       	ldi	r24, 0xA3	; 163
   14854:	95 e0       	ldi	r25, 0x05	; 5
   14856:	0e 94 f9 ae 	call	0x15df2	; 0x15df2 <ClearMem>
		        stLocalAccount=laOdometerInput;
   1485a:	82 e1       	ldi	r24, 0x12	; 18
   1485c:	29 c0       	rjmp	.+82     	; 0x148b0 <FMenuLocalAccount+0xeb2>
		        break;
           case laOdometerInput:
		        //Blinking 50% _      BalanceValue Volume=999  Amount=65536
			    //iLoop++;
				uiResult=UserInput(UI_NUMBER_R,3,10,strOdometer,0,10);
   1485e:	13 ea       	ldi	r17, 0xA3	; 163
   14860:	c1 2e       	mov	r12, r17
   14862:	15 e0       	ldi	r17, 0x05	; 5
   14864:	d1 2e       	mov	r13, r17
   14866:	81 e0       	ldi	r24, 0x01	; 1
   14868:	63 e0       	ldi	r22, 0x03	; 3
   1486a:	4a e0       	ldi	r20, 0x0A	; 10
   1486c:	96 01       	movw	r18, r12
   1486e:	00 e0       	ldi	r16, 0x00	; 0
   14870:	10 e0       	ldi	r17, 0x00	; 0
   14872:	ba e0       	ldi	r27, 0x0A	; 10
   14874:	eb 2e       	mov	r14, r27
   14876:	0e 94 47 7d 	call	0xfa8e	; 0xfa8e <UserInput>
				if (uiResult==USER_OK){
   1487a:	83 30       	cpi	r24, 0x03	; 3
   1487c:	79 f4       	brne	.+30     	; 0x1489c <FMenuLocalAccount+0xe9e>
				    if ((strlen(strOdometer)==1)&&(strOdometer[0]=='0'))
   1487e:	f6 01       	movw	r30, r12
   14880:	01 90       	ld	r0, Z+
   14882:	00 20       	and	r0, r0
   14884:	e9 f7       	brne	.-6      	; 0x14880 <FMenuLocalAccount+0xe82>
   14886:	e5 5a       	subi	r30, 0xA5	; 165
   14888:	f5 40       	sbci	r31, 0x05	; 5
   1488a:	31 f4       	brne	.+12     	; 0x14898 <FMenuLocalAccount+0xe9a>
   1488c:	80 91 a3 05 	lds	r24, 0x05A3
   14890:	80 33       	cpi	r24, 0x30	; 48
   14892:	11 f4       	brne	.+4      	; 0x14898 <FMenuLocalAccount+0xe9a>
					    strOdometer[0]=0;
   14894:	10 92 a3 05 	sts	0x05A3, r1

				    stLocalAccount=laDataConfirm;
   14898:	83 e1       	ldi	r24, 0x13	; 19
   1489a:	0a c0       	rjmp	.+20     	; 0x148b0 <FMenuLocalAccount+0xeb2>
					}
			    else
			    if (uiResult==USER_CANCEL){
   1489c:	81 30       	cpi	r24, 0x01	; 1
   1489e:	09 f0       	breq	.+2      	; 0x148a2 <FMenuLocalAccount+0xea4>
   148a0:	da c2       	rjmp	.+1460   	; 0x14e56 <FMenuLocalAccount+0x1458>
				    if (IsFullAuthorized==True)
   148a2:	80 91 74 03 	lds	r24, 0x0374
   148a6:	81 30       	cpi	r24, 0x01	; 1
   148a8:	11 f4       	brne	.+4      	; 0x148ae <FMenuLocalAccount+0xeb0>
					     stLocalAccount=laSelectBalanceType;
   148aa:	8d e0       	ldi	r24, 0x0D	; 13
   148ac:	01 c0       	rjmp	.+2      	; 0x148b0 <FMenuLocalAccount+0xeb2>
					else stLocalAccount=laBalanceValue;		        
   148ae:	8f e0       	ldi	r24, 0x0F	; 15
   148b0:	80 93 5c 01 	sts	0x015C, r24
   148b4:	d0 c2       	rjmp	.+1440   	; 0x14e56 <FMenuLocalAccount+0x1458>
					}
                */

		        break;
           case laDataConfirm: 
		        lcd_clear();
   148b6:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
   148ba:	ed e0       	ldi	r30, 0x0D	; 13
   148bc:	f5 e0       	ldi	r31, 0x05	; 5
   148be:	de 01       	movw	r26, r28
   148c0:	55 96       	adiw	r26, 0x15	; 21
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
   148c2:	81 91       	ld	r24, Z+
   148c4:	8d 93       	st	X+, r24
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
   148c6:	35 e0       	ldi	r19, 0x05	; 5
   148c8:	e7 31       	cpi	r30, 0x17	; 23
   148ca:	f3 07       	cpc	r31, r19
   148cc:	d1 f7       	brne	.-12     	; 0x148c2 <FMenuLocalAccount+0xec4>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
   148ce:	1f 8e       	std	Y+31, r1	; 0x1f

		        break;
           case laDataConfirm: 
		        lcd_clear();
		        StringCopyPos(strCardHolder,strName,9,10);                                          //Data Confirmation   
                sprintf_P(lcdteks,PSTR("%s "),strName);                  lcd_print(1,1,lcdteks);    //"Iyan The Man        "
   148d0:	00 d0       	rcall	.+0      	; 0x148d2 <FMenuLocalAccount+0xed4>
   148d2:	00 d0       	rcall	.+0      	; 0x148d4 <FMenuLocalAccount+0xed6>
   148d4:	00 d0       	rcall	.+0      	; 0x148d6 <FMenuLocalAccount+0xed8>
   148d6:	ed b7       	in	r30, 0x3d	; 61
   148d8:	fe b7       	in	r31, 0x3e	; 62
   148da:	31 96       	adiw	r30, 0x01	; 1
   148dc:	8e 01       	movw	r16, r28
   148de:	0f 5f       	subi	r16, 0xFF	; 255
   148e0:	1f 4f       	sbci	r17, 0xFF	; 255
   148e2:	ad b7       	in	r26, 0x3d	; 61
   148e4:	be b7       	in	r27, 0x3e	; 62
   148e6:	12 96       	adiw	r26, 0x02	; 2
   148e8:	1c 93       	st	X, r17
   148ea:	0e 93       	st	-X, r16
   148ec:	11 97       	sbiw	r26, 0x01	; 1
   148ee:	8b e4       	ldi	r24, 0x4B	; 75
   148f0:	9e e1       	ldi	r25, 0x1E	; 30
   148f2:	93 83       	std	Z+3, r25	; 0x03
   148f4:	82 83       	std	Z+2, r24	; 0x02
   148f6:	ce 01       	movw	r24, r28
   148f8:	45 96       	adiw	r24, 0x15	; 21
   148fa:	95 83       	std	Z+5, r25	; 0x05
   148fc:	84 83       	std	Z+4, r24	; 0x04
   148fe:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   14902:	ed b7       	in	r30, 0x3d	; 61
   14904:	fe b7       	in	r31, 0x3e	; 62
   14906:	36 96       	adiw	r30, 0x06	; 6
   14908:	0f b6       	in	r0, 0x3f	; 63
   1490a:	f8 94       	cli
   1490c:	fe bf       	out	0x3e, r31	; 62
   1490e:	0f be       	out	0x3f, r0	; 63
   14910:	ed bf       	out	0x3d, r30	; 61
   14912:	81 e0       	ldi	r24, 0x01	; 1
   14914:	61 e0       	ldi	r22, 0x01	; 1
   14916:	a8 01       	movw	r20, r16
   14918:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		        sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);             lcd_print(2,1,lcdteks);    //"ID1CCDA565 OD:123456"
   1491c:	00 d0       	rcall	.+0      	; 0x1491e <FMenuLocalAccount+0xf20>
   1491e:	00 d0       	rcall	.+0      	; 0x14920 <FMenuLocalAccount+0xf22>
   14920:	00 d0       	rcall	.+0      	; 0x14922 <FMenuLocalAccount+0xf24>
   14922:	ed b7       	in	r30, 0x3d	; 61
   14924:	fe b7       	in	r31, 0x3e	; 62
   14926:	31 96       	adiw	r30, 0x01	; 1
   14928:	ad b7       	in	r26, 0x3d	; 61
   1492a:	be b7       	in	r27, 0x3e	; 62
   1492c:	12 96       	adiw	r26, 0x02	; 2
   1492e:	1c 93       	st	X, r17
   14930:	0e 93       	st	-X, r16
   14932:	11 97       	sbiw	r26, 0x01	; 1
   14934:	84 e4       	ldi	r24, 0x44	; 68
   14936:	9e e1       	ldi	r25, 0x1E	; 30
   14938:	93 83       	std	Z+3, r25	; 0x03
   1493a:	82 83       	std	Z+2, r24	; 0x02
   1493c:	8f ee       	ldi	r24, 0xEF	; 239
   1493e:	9e e0       	ldi	r25, 0x0E	; 14
   14940:	95 83       	std	Z+5, r25	; 0x05
   14942:	84 83       	std	Z+4, r24	; 0x04
   14944:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   14948:	ed b7       	in	r30, 0x3d	; 61
   1494a:	fe b7       	in	r31, 0x3e	; 62
   1494c:	36 96       	adiw	r30, 0x06	; 6
   1494e:	0f b6       	in	r0, 0x3f	; 63
   14950:	f8 94       	cli
   14952:	fe bf       	out	0x3e, r31	; 62
   14954:	0f be       	out	0x3f, r0	; 63
   14956:	ed bf       	out	0x3d, r30	; 61
   14958:	82 e0       	ldi	r24, 0x02	; 2
   1495a:	61 e0       	ldi	r22, 0x01	; 1
   1495c:	a8 01       	movw	r20, r16
   1495e:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
				sprintf_P(lcdteks,PSTR("%s  %s "),strFIP,strProduct);    lcd_print(3,1,lcdteks);    //"P01  Pertamax 500000"
   14962:	2d b7       	in	r18, 0x3d	; 61
   14964:	3e b7       	in	r19, 0x3e	; 62
   14966:	28 50       	subi	r18, 0x08	; 8
   14968:	30 40       	sbci	r19, 0x00	; 0
   1496a:	0f b6       	in	r0, 0x3f	; 63
   1496c:	f8 94       	cli
   1496e:	3e bf       	out	0x3e, r19	; 62
   14970:	0f be       	out	0x3f, r0	; 63
   14972:	2d bf       	out	0x3d, r18	; 61
   14974:	ed b7       	in	r30, 0x3d	; 61
   14976:	fe b7       	in	r31, 0x3e	; 62
   14978:	31 96       	adiw	r30, 0x01	; 1
   1497a:	ad b7       	in	r26, 0x3d	; 61
   1497c:	be b7       	in	r27, 0x3e	; 62
   1497e:	12 96       	adiw	r26, 0x02	; 2
   14980:	1c 93       	st	X, r17
   14982:	0e 93       	st	-X, r16
   14984:	11 97       	sbiw	r26, 0x01	; 1
   14986:	8c e3       	ldi	r24, 0x3C	; 60
   14988:	9e e1       	ldi	r25, 0x1E	; 30
   1498a:	93 83       	std	Z+3, r25	; 0x03
   1498c:	82 83       	std	Z+2, r24	; 0x02
   1498e:	8d e9       	ldi	r24, 0x9D	; 157
   14990:	93 e0       	ldi	r25, 0x03	; 3
   14992:	95 83       	std	Z+5, r25	; 0x05
   14994:	84 83       	std	Z+4, r24	; 0x04
   14996:	81 e4       	ldi	r24, 0x41	; 65
   14998:	99 e0       	ldi	r25, 0x09	; 9
   1499a:	97 83       	std	Z+7, r25	; 0x07
   1499c:	86 83       	std	Z+6, r24	; 0x06
   1499e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   149a2:	ed b7       	in	r30, 0x3d	; 61
   149a4:	fe b7       	in	r31, 0x3e	; 62
   149a6:	38 96       	adiw	r30, 0x08	; 8
   149a8:	0f b6       	in	r0, 0x3f	; 63
   149aa:	f8 94       	cli
   149ac:	fe bf       	out	0x3e, r31	; 62
   149ae:	0f be       	out	0x3f, r0	; 63
   149b0:	ed bf       	out	0x3d, r30	; 61
   149b2:	83 e0       	ldi	r24, 0x03	; 3
   149b4:	61 e0       	ldi	r22, 0x01	; 1
   149b6:	a8 01       	movw	r20, r16
   149b8:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		        if (IsFullAuthorized==True){
   149bc:	80 91 74 03 	lds	r24, 0x0374
   149c0:	81 30       	cpi	r24, 0x01	; 1
   149c2:	39 f4       	brne	.+14     	; 0x149d2 <FMenuLocalAccount+0xfd4>
                    lcd_printf(3,15,PSTR(" Full"));
   149c4:	83 e0       	ldi	r24, 0x03	; 3
   149c6:	6f e0       	ldi	r22, 0x0F	; 15
   149c8:	46 e3       	ldi	r20, 0x36	; 54
   149ca:	5e e1       	ldi	r21, 0x1E	; 30
   149cc:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   149d0:	23 c0       	rjmp	.+70     	; 0x14a18 <FMenuLocalAccount+0x101a>
				}
				else {
				    sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);          lcd_print(3,15,lcdteks);   //"[*]Back [0]ESC [#]OK " 
   149d2:	00 d0       	rcall	.+0      	; 0x149d4 <FMenuLocalAccount+0xfd6>
   149d4:	00 d0       	rcall	.+0      	; 0x149d6 <FMenuLocalAccount+0xfd8>
   149d6:	00 d0       	rcall	.+0      	; 0x149d8 <FMenuLocalAccount+0xfda>
   149d8:	ed b7       	in	r30, 0x3d	; 61
   149da:	fe b7       	in	r31, 0x3e	; 62
   149dc:	31 96       	adiw	r30, 0x01	; 1
   149de:	ad b7       	in	r26, 0x3d	; 61
   149e0:	be b7       	in	r27, 0x3e	; 62
   149e2:	12 96       	adiw	r26, 0x02	; 2
   149e4:	1c 93       	st	X, r17
   149e6:	0e 93       	st	-X, r16
   149e8:	11 97       	sbiw	r26, 0x01	; 1
   149ea:	82 e3       	ldi	r24, 0x32	; 50
   149ec:	9e e1       	ldi	r25, 0x1E	; 30
   149ee:	93 83       	std	Z+3, r25	; 0x03
   149f0:	82 83       	std	Z+2, r24	; 0x02
   149f2:	82 e7       	ldi	r24, 0x72	; 114
   149f4:	9f e0       	ldi	r25, 0x0F	; 15
   149f6:	95 83       	std	Z+5, r25	; 0x05
   149f8:	84 83       	std	Z+4, r24	; 0x04
   149fa:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   149fe:	ed b7       	in	r30, 0x3d	; 61
   14a00:	fe b7       	in	r31, 0x3e	; 62
   14a02:	36 96       	adiw	r30, 0x06	; 6
   14a04:	0f b6       	in	r0, 0x3f	; 63
   14a06:	f8 94       	cli
   14a08:	fe bf       	out	0x3e, r31	; 62
   14a0a:	0f be       	out	0x3f, r0	; 63
   14a0c:	ed bf       	out	0x3d, r30	; 61
   14a0e:	83 e0       	ldi	r24, 0x03	; 3
   14a10:	6f e0       	ldi	r22, 0x0F	; 15
   14a12:	a8 01       	movw	r20, r16
   14a14:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
					}
	            lcd_printf(4,1,PSTR("[*]Back [0]ESC [#]OK"));    
   14a18:	84 e0       	ldi	r24, 0x04	; 4
   14a1a:	61 e0       	ldi	r22, 0x01	; 1
   14a1c:	4d e1       	ldi	r20, 0x1D	; 29
   14a1e:	5e e1       	ldi	r21, 0x1E	; 30
   14a20:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
                stLocalAccount=laDataConfirmInput;
   14a24:	84 e1       	ldi	r24, 0x14	; 20
   14a26:	44 cf       	rjmp	.-376    	; 0x148b0 <FMenuLocalAccount+0xeb2>
                //while(1){};   
		        break;
           case laDataConfirmInput:
                KeyPressed=_key_scan(1);
   14a28:	81 e0       	ldi	r24, 0x01	; 1
   14a2a:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   14a2e:	80 93 9c 03 	sts	0x039C, r24
                if (KeyPressed==_KEY_CANCEL)stLocalAccount=laOdometer;		        
   14a32:	87 3e       	cpi	r24, 0xE7	; 231
   14a34:	11 f4       	brne	.+4      	; 0x14a3a <FMenuLocalAccount+0x103c>
   14a36:	81 e1       	ldi	r24, 0x11	; 17
   14a38:	3b cf       	rjmp	.-394    	; 0x148b0 <FMenuLocalAccount+0xeb2>
				else
				if (KeyPressed==_KEY_ENTER)stLocalAccount=laProceedTransaction;
   14a3a:	87 3b       	cpi	r24, 0xB7	; 183
   14a3c:	11 f4       	brne	.+4      	; 0x14a42 <FMenuLocalAccount+0x1044>
   14a3e:	85 e1       	ldi	r24, 0x15	; 21
   14a40:	37 cf       	rjmp	.-402    	; 0x148b0 <FMenuLocalAccount+0xeb2>
				else
				if (KeyPressed==_KEY_0){
   14a42:	87 3d       	cpi	r24, 0xD7	; 215
   14a44:	09 f0       	breq	.+2      	; 0x14a48 <FMenuLocalAccount+0x104a>
   14a46:	07 c2       	rjmp	.+1038   	; 0x14e56 <FMenuLocalAccount+0x1458>
				   //ShowCancel
				   TimLocAcc=0;
   14a48:	10 92 d3 01 	sts	0x01D3, r1
   14a4c:	10 92 d2 01 	sts	0x01D2, r1
                   lcd_clear();
   14a50:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
				   lcd_printf(1,1,PSTR("Cancel Transaction  "));    //"Cancel Transaction"
   14a54:	81 e0       	ldi	r24, 0x01	; 1
   14a56:	61 e0       	ldi	r22, 0x01	; 1
   14a58:	48 e0       	ldi	r20, 0x08	; 8
   14a5a:	5e e1       	ldi	r21, 0x1E	; 30
   14a5c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
   14a60:	e9 c1       	rjmp	.+978    	; 0x14e34 <FMenuLocalAccount+0x1436>
				   stLocalAccount=laDelayExit;
				   }
		        break;
           case laProceedTransaction:
		        sendMessage58();
   14a62:	0e 94 89 50 	call	0xa112	; 0xa112 <sendMessage58>
                RemZeroLead(strCardID);
   14a66:	8f ee       	ldi	r24, 0xEF	; 239
   14a68:	9e e0       	ldi	r25, 0x0E	; 14
   14a6a:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
                RemZeroLead(strBalanceValue);
   14a6e:	a2 e7       	ldi	r26, 0x72	; 114
   14a70:	ea 2e       	mov	r14, r26
   14a72:	af e0       	ldi	r26, 0x0F	; 15
   14a74:	fa 2e       	mov	r15, r26
   14a76:	c7 01       	movw	r24, r14
   14a78:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
				sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct);       lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   14a7c:	2d b7       	in	r18, 0x3d	; 61
   14a7e:	3e b7       	in	r19, 0x3e	; 62
   14a80:	28 50       	subi	r18, 0x08	; 8
   14a82:	30 40       	sbci	r19, 0x00	; 0
   14a84:	0f b6       	in	r0, 0x3f	; 63
   14a86:	f8 94       	cli
   14a88:	3e bf       	out	0x3e, r19	; 62
   14a8a:	0f be       	out	0x3f, r0	; 63
   14a8c:	2d bf       	out	0x3d, r18	; 61
   14a8e:	ed b7       	in	r30, 0x3d	; 61
   14a90:	fe b7       	in	r31, 0x3e	; 62
   14a92:	31 96       	adiw	r30, 0x01	; 1
   14a94:	8e 01       	movw	r16, r28
   14a96:	0f 5f       	subi	r16, 0xFF	; 255
   14a98:	1f 4f       	sbci	r17, 0xFF	; 255
   14a9a:	ad b7       	in	r26, 0x3d	; 61
   14a9c:	be b7       	in	r27, 0x3e	; 62
   14a9e:	12 96       	adiw	r26, 0x02	; 2
   14aa0:	1c 93       	st	X, r17
   14aa2:	0e 93       	st	-X, r16
   14aa4:	11 97       	sbiw	r26, 0x01	; 1
   14aa6:	80 e0       	ldi	r24, 0x00	; 0
   14aa8:	9e e1       	ldi	r25, 0x1E	; 30
   14aaa:	93 83       	std	Z+3, r25	; 0x03
   14aac:	82 83       	std	Z+2, r24	; 0x02
   14aae:	8d e9       	ldi	r24, 0x9D	; 157
   14ab0:	93 e0       	ldi	r25, 0x03	; 3
   14ab2:	95 83       	std	Z+5, r25	; 0x05
   14ab4:	84 83       	std	Z+4, r24	; 0x04
   14ab6:	81 e4       	ldi	r24, 0x41	; 65
   14ab8:	99 e0       	ldi	r25, 0x09	; 9
   14aba:	97 83       	std	Z+7, r25	; 0x07
   14abc:	86 83       	std	Z+6, r24	; 0x06
   14abe:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   14ac2:	ed b7       	in	r30, 0x3d	; 61
   14ac4:	fe b7       	in	r31, 0x3e	; 62
   14ac6:	38 96       	adiw	r30, 0x08	; 8
   14ac8:	0f b6       	in	r0, 0x3f	; 63
   14aca:	f8 94       	cli
   14acc:	fe bf       	out	0x3e, r31	; 62
   14ace:	0f be       	out	0x3f, r0	; 63
   14ad0:	ed bf       	out	0x3d, r30	; 61
   14ad2:	81 e0       	ldi	r24, 0x01	; 1
   14ad4:	61 e0       	ldi	r22, 0x01	; 1
   14ad6:	a8 01       	movw	r20, r16
   14ad8:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);              lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   14adc:	00 d0       	rcall	.+0      	; 0x14ade <FMenuLocalAccount+0x10e0>
   14ade:	00 d0       	rcall	.+0      	; 0x14ae0 <FMenuLocalAccount+0x10e2>
   14ae0:	00 d0       	rcall	.+0      	; 0x14ae2 <FMenuLocalAccount+0x10e4>
   14ae2:	ed b7       	in	r30, 0x3d	; 61
   14ae4:	fe b7       	in	r31, 0x3e	; 62
   14ae6:	31 96       	adiw	r30, 0x01	; 1
   14ae8:	ad b7       	in	r26, 0x3d	; 61
   14aea:	be b7       	in	r27, 0x3e	; 62
   14aec:	12 96       	adiw	r26, 0x02	; 2
   14aee:	1c 93       	st	X, r17
   14af0:	0e 93       	st	-X, r16
   14af2:	11 97       	sbiw	r26, 0x01	; 1
   14af4:	8d ef       	ldi	r24, 0xFD	; 253
   14af6:	9d e1       	ldi	r25, 0x1D	; 29
   14af8:	93 83       	std	Z+3, r25	; 0x03
   14afa:	82 83       	std	Z+2, r24	; 0x02
   14afc:	f5 82       	std	Z+5, r15	; 0x05
   14afe:	e4 82       	std	Z+4, r14	; 0x04
   14b00:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   14b04:	ed b7       	in	r30, 0x3d	; 61
   14b06:	fe b7       	in	r31, 0x3e	; 62
   14b08:	36 96       	adiw	r30, 0x06	; 6
   14b0a:	0f b6       	in	r0, 0x3f	; 63
   14b0c:	f8 94       	cli
   14b0e:	fe bf       	out	0x3e, r31	; 62
   14b10:	0f be       	out	0x3f, r0	; 63
   14b12:	ed bf       	out	0x3d, r30	; 61
   14b14:	81 e0       	ldi	r24, 0x01	; 1
   14b16:	6f e0       	ldi	r22, 0x0F	; 15
   14b18:	a8 01       	movw	r20, r16
   14b1a:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
                lcd_printf(3,1,PSTR("Mohon Tunggu        "));                                         //"Mohon Tunggu ...    "
   14b1e:	83 e0       	ldi	r24, 0x03	; 3
   14b20:	61 e0       	ldi	r22, 0x01	; 1
   14b22:	48 ee       	ldi	r20, 0xE8	; 232
   14b24:	5d e1       	ldi	r21, 0x1D	; 29
   14b26:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		        lcd_printf(4,1,PSTR("                    "));                                  //"                    "
   14b2a:	84 e0       	ldi	r24, 0x04	; 4
   14b2c:	61 e0       	ldi	r22, 0x01	; 1
   14b2e:	43 ed       	ldi	r20, 0xD3	; 211
   14b30:	5d e1       	ldi	r21, 0x1D	; 29
   14b32:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				IsMessage00=False;
   14b36:	10 92 b5 01 	sts	0x01B5, r1
				TimLocAcc=0;
   14b3a:	10 92 d3 01 	sts	0x01D3, r1
   14b3e:	10 92 d2 01 	sts	0x01D2, r1
				iLoop=0;iPos=0;iWait=0;
   14b42:	10 92 73 03 	sts	0x0373, r1
   14b46:	10 92 72 03 	sts	0x0372, r1
   14b4a:	10 92 a3 03 	sts	0x03A3, r1
   14b4e:	10 92 a2 03 	sts	0x03A2, r1
				stLocalAccount=laWaitMessage00;
   14b52:	87 e1       	ldi	r24, 0x17	; 23
   14b54:	ad ce       	rjmp	.-678    	; 0x148b0 <FMenuLocalAccount+0xeb2>
		        break;
           case laWaitMessage00:
                iLoop++;
   14b56:	80 91 72 03 	lds	r24, 0x0372
   14b5a:	90 91 73 03 	lds	r25, 0x0373
   14b5e:	01 96       	adiw	r24, 0x01	; 1
   14b60:	90 93 73 03 	sts	0x0373, r25
   14b64:	80 93 72 03 	sts	0x0372, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   14b68:	68 e9       	ldi	r22, 0x98	; 152
   14b6a:	7a e3       	ldi	r23, 0x3A	; 58
   14b6c:	0e 94 8b b8 	call	0x17116	; 0x17116 <__udivmodhi4>
   14b70:	89 2b       	or	r24, r25
   14b72:	e1 f4       	brne	.+56     	; 0x14bac <FMenuLocalAccount+0x11ae>
				   if (iPos<5){
   14b74:	60 91 a3 03 	lds	r22, 0x03A3
   14b78:	65 30       	cpi	r22, 0x05	; 5
   14b7a:	58 f4       	brcc	.+22     	; 0x14b92 <FMenuLocalAccount+0x1194>
				       iPos++;
   14b7c:	6f 5f       	subi	r22, 0xFF	; 255
   14b7e:	60 93 a3 03 	sts	0x03A3, r22
					   lcd_xy(3,(14+iPos));_lcd('.');
   14b82:	62 5f       	subi	r22, 0xF2	; 242
   14b84:	83 e0       	ldi	r24, 0x03	; 3
   14b86:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
   14b8a:	8e e2       	ldi	r24, 0x2E	; 46
   14b8c:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
   14b90:	0d c0       	rjmp	.+26     	; 0x14bac <FMenuLocalAccount+0x11ae>
					   }
				   else{
				       iPos=0;
   14b92:	10 92 a3 03 	sts	0x03A3, r1
					   lcd_printf(3,(14+iPos),PSTR("       "));
   14b96:	83 e0       	ldi	r24, 0x03	; 3
   14b98:	6e e0       	ldi	r22, 0x0E	; 14
   14b9a:	4b ec       	ldi	r20, 0xCB	; 203
   14b9c:	5d e1       	ldi	r21, 0x1D	; 29
   14b9e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
					   iWait++;
   14ba2:	80 91 a2 03 	lds	r24, 0x03A2
   14ba6:	8f 5f       	subi	r24, 0xFF	; 255
   14ba8:	80 93 a2 03 	sts	0x03A2, r24
					   }
				}
				if (iWait>5){
   14bac:	80 91 a2 03 	lds	r24, 0x03A2
   14bb0:	86 30       	cpi	r24, 0x06	; 6
   14bb2:	78 f0       	brcs	.+30     	; 0x14bd2 <FMenuLocalAccount+0x11d4>
				    stLocalAccount=laConTimout;
   14bb4:	84 e0       	ldi	r24, 0x04	; 4
   14bb6:	80 93 5c 01 	sts	0x015C, r24
					TimLocAcc=0;
   14bba:	10 92 d3 01 	sts	0x01D3, r1
   14bbe:	10 92 d2 01 	sts	0x01D2, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14bc2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14bc4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14bc6:	82 e0       	ldi	r24, 0x02	; 2
   14bc8:	90 e0       	ldi	r25, 0x00	; 0
   14bca:	90 93 d7 01 	sts	0x01D7, r25
   14bce:	80 93 d6 01 	sts	0x01D6, r24
				if (iWait>5){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage00==True){
   14bd2:	80 91 b5 01 	lds	r24, 0x01B5
   14bd6:	81 30       	cpi	r24, 0x01	; 1
   14bd8:	09 f0       	breq	.+2      	; 0x14bdc <FMenuLocalAccount+0x11de>
   14bda:	3d c1       	rjmp	.+634    	; 0x14e56 <FMenuLocalAccount+0x1458>
                    IsMessage00=False;
   14bdc:	10 92 b5 01 	sts	0x01B5, r1
				    stLocalAccount=laProcMessage00;
   14be0:	88 e1       	ldi	r24, 0x18	; 24
   14be2:	66 ce       	rjmp	.-820    	; 0x148b0 <FMenuLocalAccount+0xeb2>
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   14be4:	80 91 83 0c 	lds	r24, 0x0C83
   14be8:	81 30       	cpi	r24, 0x01	; 1
   14bea:	51 f4       	brne	.+20     	; 0x14c00 <FMenuLocalAccount+0x1202>
   14bec:	80 91 9e 01 	lds	r24, 0x019E
   14bf0:	90 91 9f 01 	lds	r25, 0x019F
   14bf4:	8f 97       	sbiw	r24, 0x2f	; 47
   14bf6:	21 f4       	brne	.+8      	; 0x14c00 <FMenuLocalAccount+0x1202>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
   14bf8:	80 91 a8 0c 	lds	r24, 0x0CA8
   14bfc:	80 53       	subi	r24, 0x30	; 48
   14bfe:	01 c0       	rjmp	.+2      	; 0x14c02 <FMenuLocalAccount+0x1204>
   14c00:	80 e0       	ldi	r24, 0x00	; 0
                    IsMessage00=False;
				    stLocalAccount=laProcMessage00;
					}
		        break;
           case laProcMessage00:
		        LocAccStatus=procMessage00();
   14c02:	80 93 a4 03 	sts	0x03A4, r24
                lcd_clear();
   14c06:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
		        switch(LocAccStatus){
   14c0a:	10 91 a4 03 	lds	r17, 0x03A4
   14c0e:	11 30       	cpi	r17, 0x01	; 1
   14c10:	51 f0       	breq	.+20     	; 0x14c26 <FMenuLocalAccount+0x1228>
   14c12:	11 30       	cpi	r17, 0x01	; 1
   14c14:	18 f0       	brcs	.+6      	; 0x14c1c <FMenuLocalAccount+0x121e>
   14c16:	13 30       	cpi	r17, 0x03	; 3
   14c18:	69 f5       	brne	.+90     	; 0x14c74 <FMenuLocalAccount+0x1276>
   14c1a:	1b c0       	rjmp	.+54     	; 0x14c52 <FMenuLocalAccount+0x1254>
				case MSG00_NACK:
                     lcd_printf(2,1,PSTR("Authorisasi Gagal   "));
   14c1c:	82 e0       	ldi	r24, 0x02	; 2
   14c1e:	61 e0       	ldi	r22, 0x01	; 1
   14c20:	46 eb       	ldi	r20, 0xB6	; 182
   14c22:	5d e1       	ldi	r21, 0x1D	; 29
   14c24:	1a c0       	rjmp	.+52     	; 0x14c5a <FMenuLocalAccount+0x125c>
					 system_beep(2); 
					 stLocalAccount=laDelayExit;
				     break;
                case MSG00_ACK:
				     lcd_printf(2,1,PSTR("Authorisasi Berhasil"));
   14c26:	82 e0       	ldi	r24, 0x02	; 2
   14c28:	61 e0       	ldi	r22, 0x01	; 1
   14c2a:	41 ea       	ldi	r20, 0xA1	; 161
   14c2c:	5d e1       	ldi	r21, 0x1D	; 29
   14c2e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				     LocalAccountFIP[nLocalAccount]=FIP_Used;
   14c32:	90 91 a4 01 	lds	r25, 0x01A4
   14c36:	e9 2f       	mov	r30, r25
   14c38:	f0 e0       	ldi	r31, 0x00	; 0
   14c3a:	ea 5c       	subi	r30, 0xCA	; 202
   14c3c:	fa 4f       	sbci	r31, 0xFA	; 250
   14c3e:	80 91 76 03 	lds	r24, 0x0376
   14c42:	80 83       	st	Z, r24
					 nLocalAccount++;
   14c44:	9f 5f       	subi	r25, 0xFF	; 255
   14c46:	90 93 a4 01 	sts	0x01A4, r25
					 IsViewFillingFIP=True;
   14c4a:	10 93 ad 01 	sts	0x01AD, r17
					 stLocalAccount=laViewStatus;
   14c4e:	86 e1       	ldi	r24, 0x16	; 22
   14c50:	0f c0       	rjmp	.+30     	; 0x14c70 <FMenuLocalAccount+0x1272>
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
   14c52:	82 e0       	ldi	r24, 0x02	; 2
   14c54:	61 e0       	ldi	r22, 0x01	; 1
   14c56:	4e e8       	ldi	r20, 0x8E	; 142
   14c58:	5d e1       	ldi	r21, 0x1D	; 29
   14c5a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14c5e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14c60:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14c62:	82 e0       	ldi	r24, 0x02	; 2
   14c64:	90 e0       	ldi	r25, 0x00	; 0
   14c66:	90 93 d7 01 	sts	0x01D7, r25
   14c6a:	80 93 d6 01 	sts	0x01D6, r24
					 stLocalAccount=laViewStatus;
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
					 system_beep(2);
					 stLocalAccount=laDelayExit;
   14c6e:	8e e1       	ldi	r24, 0x1E	; 30
   14c70:	80 93 5c 01 	sts	0x015C, r24
				     break;
				}
				TimLocAcc=0;
   14c74:	10 92 d3 01 	sts	0x01D3, r1
   14c78:	10 92 d2 01 	sts	0x01D2, r1
				ClearMem(strOdometer);
   14c7c:	83 ea       	ldi	r24, 0xA3	; 163
   14c7e:	95 e0       	ldi	r25, 0x05	; 5
   14c80:	0e 94 f9 ae 	call	0x15df2	; 0x15df2 <ClearMem>
	            ClearMem(strLicPlate);
   14c84:	80 e6       	ldi	r24, 0x60	; 96
   14c86:	9c e0       	ldi	r25, 0x0C	; 12
   14c88:	0e 94 f9 ae 	call	0x15df2	; 0x15df2 <ClearMem>
   14c8c:	e4 c0       	rjmp	.+456    	; 0x14e56 <FMenuLocalAccount+0x1458>
		        break;
           case laViewStatus:
                if (TimLocAcc>20)stLocalAccount=laExitLocAcc;//laDisplayTransaction;
   14c8e:	80 91 d2 01 	lds	r24, 0x01D2
   14c92:	90 91 d3 01 	lds	r25, 0x01D3
   14c96:	45 97       	sbiw	r24, 0x15	; 21
   14c98:	08 f4       	brcc	.+2      	; 0x14c9c <FMenuLocalAccount+0x129e>
   14c9a:	dd c0       	rjmp	.+442    	; 0x14e56 <FMenuLocalAccount+0x1458>
   14c9c:	d3 c0       	rjmp	.+422    	; 0x14e44 <FMenuLocalAccount+0x1446>
		        break; 
           case laDisplayTransaction:
		        lcd_clear();
   14c9e:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
                sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct); lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   14ca2:	2d b7       	in	r18, 0x3d	; 61
   14ca4:	3e b7       	in	r19, 0x3e	; 62
   14ca6:	28 50       	subi	r18, 0x08	; 8
   14ca8:	30 40       	sbci	r19, 0x00	; 0
   14caa:	0f b6       	in	r0, 0x3f	; 63
   14cac:	f8 94       	cli
   14cae:	3e bf       	out	0x3e, r19	; 62
   14cb0:	0f be       	out	0x3f, r0	; 63
   14cb2:	2d bf       	out	0x3d, r18	; 61
   14cb4:	ed b7       	in	r30, 0x3d	; 61
   14cb6:	fe b7       	in	r31, 0x3e	; 62
   14cb8:	31 96       	adiw	r30, 0x01	; 1
   14cba:	7e 01       	movw	r14, r28
   14cbc:	08 94       	sec
   14cbe:	e1 1c       	adc	r14, r1
   14cc0:	f1 1c       	adc	r15, r1
   14cc2:	ad b7       	in	r26, 0x3d	; 61
   14cc4:	be b7       	in	r27, 0x3e	; 62
   14cc6:	12 96       	adiw	r26, 0x02	; 2
   14cc8:	fc 92       	st	X, r15
   14cca:	ee 92       	st	-X, r14
   14ccc:	11 97       	sbiw	r26, 0x01	; 1
   14cce:	86 e8       	ldi	r24, 0x86	; 134
   14cd0:	9d e1       	ldi	r25, 0x1D	; 29
   14cd2:	93 83       	std	Z+3, r25	; 0x03
   14cd4:	82 83       	std	Z+2, r24	; 0x02
   14cd6:	8d e9       	ldi	r24, 0x9D	; 157
   14cd8:	93 e0       	ldi	r25, 0x03	; 3
   14cda:	95 83       	std	Z+5, r25	; 0x05
   14cdc:	84 83       	std	Z+4, r24	; 0x04
   14cde:	81 e4       	ldi	r24, 0x41	; 65
   14ce0:	99 e0       	ldi	r25, 0x09	; 9
   14ce2:	97 83       	std	Z+7, r25	; 0x07
   14ce4:	86 83       	std	Z+6, r24	; 0x06
   14ce6:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   14cea:	ed b7       	in	r30, 0x3d	; 61
   14cec:	fe b7       	in	r31, 0x3e	; 62
   14cee:	38 96       	adiw	r30, 0x08	; 8
   14cf0:	0f b6       	in	r0, 0x3f	; 63
   14cf2:	f8 94       	cli
   14cf4:	fe bf       	out	0x3e, r31	; 62
   14cf6:	0f be       	out	0x3f, r0	; 63
   14cf8:	ed bf       	out	0x3d, r30	; 61
   14cfa:	81 e0       	ldi	r24, 0x01	; 1
   14cfc:	61 e0       	ldi	r22, 0x01	; 1
   14cfe:	a7 01       	movw	r20, r14
   14d00:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);        lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   14d04:	00 d0       	rcall	.+0      	; 0x14d06 <FMenuLocalAccount+0x1308>
   14d06:	00 d0       	rcall	.+0      	; 0x14d08 <FMenuLocalAccount+0x130a>
   14d08:	00 d0       	rcall	.+0      	; 0x14d0a <FMenuLocalAccount+0x130c>
   14d0a:	ed b7       	in	r30, 0x3d	; 61
   14d0c:	fe b7       	in	r31, 0x3e	; 62
   14d0e:	31 96       	adiw	r30, 0x01	; 1
   14d10:	ad b7       	in	r26, 0x3d	; 61
   14d12:	be b7       	in	r27, 0x3e	; 62
   14d14:	12 96       	adiw	r26, 0x02	; 2
   14d16:	fc 92       	st	X, r15
   14d18:	ee 92       	st	-X, r14
   14d1a:	11 97       	sbiw	r26, 0x01	; 1
   14d1c:	83 e8       	ldi	r24, 0x83	; 131
   14d1e:	9d e1       	ldi	r25, 0x1D	; 29
   14d20:	93 83       	std	Z+3, r25	; 0x03
   14d22:	82 83       	std	Z+2, r24	; 0x02
   14d24:	82 e7       	ldi	r24, 0x72	; 114
   14d26:	9f e0       	ldi	r25, 0x0F	; 15
   14d28:	95 83       	std	Z+5, r25	; 0x05
   14d2a:	84 83       	std	Z+4, r24	; 0x04
   14d2c:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   14d30:	ed b7       	in	r30, 0x3d	; 61
   14d32:	fe b7       	in	r31, 0x3e	; 62
   14d34:	36 96       	adiw	r30, 0x06	; 6
   14d36:	0f b6       	in	r0, 0x3f	; 63
   14d38:	f8 94       	cli
   14d3a:	fe bf       	out	0x3e, r31	; 62
   14d3c:	0f be       	out	0x3f, r0	; 63
   14d3e:	ed bf       	out	0x3d, r30	; 61
   14d40:	81 e0       	ldi	r24, 0x01	; 1
   14d42:	6f e0       	ldi	r22, 0x0F	; 15
   14d44:	a7 01       	movw	r20, r14
   14d46:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
                RemSpaceLead(strCardID);
   14d4a:	0f ee       	ldi	r16, 0xEF	; 239
   14d4c:	1e e0       	ldi	r17, 0x0E	; 14
   14d4e:	c8 01       	movw	r24, r16
   14d50:	0e 94 fd 25 	call	0x4bfa	; 0x4bfa <RemSpaceLead>
				sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);          lcd_print(2,1,lcdteks);
   14d54:	00 d0       	rcall	.+0      	; 0x14d56 <FMenuLocalAccount+0x1358>
   14d56:	00 d0       	rcall	.+0      	; 0x14d58 <FMenuLocalAccount+0x135a>
   14d58:	00 d0       	rcall	.+0      	; 0x14d5a <FMenuLocalAccount+0x135c>
   14d5a:	ed b7       	in	r30, 0x3d	; 61
   14d5c:	fe b7       	in	r31, 0x3e	; 62
   14d5e:	31 96       	adiw	r30, 0x01	; 1
   14d60:	ad b7       	in	r26, 0x3d	; 61
   14d62:	be b7       	in	r27, 0x3e	; 62
   14d64:	12 96       	adiw	r26, 0x02	; 2
   14d66:	fc 92       	st	X, r15
   14d68:	ee 92       	st	-X, r14
   14d6a:	11 97       	sbiw	r26, 0x01	; 1
   14d6c:	8c e7       	ldi	r24, 0x7C	; 124
   14d6e:	9d e1       	ldi	r25, 0x1D	; 29
   14d70:	93 83       	std	Z+3, r25	; 0x03
   14d72:	82 83       	std	Z+2, r24	; 0x02
   14d74:	15 83       	std	Z+5, r17	; 0x05
   14d76:	04 83       	std	Z+4, r16	; 0x04
   14d78:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   14d7c:	ed b7       	in	r30, 0x3d	; 61
   14d7e:	fe b7       	in	r31, 0x3e	; 62
   14d80:	36 96       	adiw	r30, 0x06	; 6
   14d82:	0f b6       	in	r0, 0x3f	; 63
   14d84:	f8 94       	cli
   14d86:	fe bf       	out	0x3e, r31	; 62
   14d88:	0f be       	out	0x3f, r0	; 63
   14d8a:	ed bf       	out	0x3d, r30	; 61
   14d8c:	82 e0       	ldi	r24, 0x02	; 2
   14d8e:	61 e0       	ldi	r22, 0x01	; 1
   14d90:	a7 01       	movw	r20, r14
   14d92:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>
				TimLocAcc=0;
   14d96:	10 92 d3 01 	sts	0x01D3, r1
   14d9a:	10 92 d2 01 	sts	0x01D2, r1
		        IsCompleteFilling=False;
   14d9e:	10 92 c0 01 	sts	0x01C0, r1
				stLocalAccount=laWaitFilling;
   14da2:	8d e1       	ldi	r24, 0x1D	; 29
   14da4:	85 cd       	rjmp	.-1270   	; 0x148b0 <FMenuLocalAccount+0xeb2>
		        break; 
           case laWaitFilling:
				if ((IsCompleteFilling==True)||(TimLocAcc>FILLING_TIMOUT)){
   14da6:	80 91 c0 01 	lds	r24, 0x01C0
   14daa:	81 30       	cpi	r24, 0x01	; 1
   14dac:	39 f0       	breq	.+14     	; 0x14dbc <FMenuLocalAccount+0x13be>
   14dae:	80 91 d2 01 	lds	r24, 0x01D2
   14db2:	90 91 d3 01 	lds	r25, 0x01D3
   14db6:	0b 97       	sbiw	r24, 0x0b	; 11
   14db8:	08 f4       	brcc	.+2      	; 0x14dbc <FMenuLocalAccount+0x13be>
   14dba:	4d c0       	rjmp	.+154    	; 0x14e56 <FMenuLocalAccount+0x1458>
				    IsCompleteFilling=False;
   14dbc:	10 92 c0 01 	sts	0x01C0, r1
				    stLocalAccount=laSuccessTransaction;
   14dc0:	89 e1       	ldi	r24, 0x19	; 25
   14dc2:	80 93 5c 01 	sts	0x015C, r24
					TimLocAcc=0;
   14dc6:	10 92 d3 01 	sts	0x01D3, r1
   14dca:	10 92 d2 01 	sts	0x01D2, r1
   14dce:	43 c0       	rjmp	.+134    	; 0x14e56 <FMenuLocalAccount+0x1458>
					}
		        break;
           case laSuccessTransaction:
				lcd_clear();lcd_printf(2,1,PSTR("Transaksi Selesai"));
   14dd0:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
   14dd4:	82 e0       	ldi	r24, 0x02	; 2
   14dd6:	61 e0       	ldi	r22, 0x01	; 1
   14dd8:	4a e6       	ldi	r20, 0x6A	; 106
   14dda:	5d e1       	ldi	r21, 0x1D	; 29
   14ddc:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
				//Show Status FIP
				sprintf_P(lcdteks,PSTR("Fueling @FIP:#%d"),FIP_Used);
   14de0:	00 d0       	rcall	.+0      	; 0x14de2 <FMenuLocalAccount+0x13e4>
   14de2:	00 d0       	rcall	.+0      	; 0x14de4 <FMenuLocalAccount+0x13e6>
   14de4:	00 d0       	rcall	.+0      	; 0x14de6 <FMenuLocalAccount+0x13e8>
   14de6:	ed b7       	in	r30, 0x3d	; 61
   14de8:	fe b7       	in	r31, 0x3e	; 62
   14dea:	31 96       	adiw	r30, 0x01	; 1
   14dec:	8e 01       	movw	r16, r28
   14dee:	0f 5f       	subi	r16, 0xFF	; 255
   14df0:	1f 4f       	sbci	r17, 0xFF	; 255
   14df2:	ad b7       	in	r26, 0x3d	; 61
   14df4:	be b7       	in	r27, 0x3e	; 62
   14df6:	12 96       	adiw	r26, 0x02	; 2
   14df8:	1c 93       	st	X, r17
   14dfa:	0e 93       	st	-X, r16
   14dfc:	11 97       	sbiw	r26, 0x01	; 1
   14dfe:	89 e5       	ldi	r24, 0x59	; 89
   14e00:	9d e1       	ldi	r25, 0x1D	; 29
   14e02:	93 83       	std	Z+3, r25	; 0x03
   14e04:	82 83       	std	Z+2, r24	; 0x02
   14e06:	80 91 76 03 	lds	r24, 0x0376
   14e0a:	84 83       	std	Z+4, r24	; 0x04
   14e0c:	15 82       	std	Z+5, r1	; 0x05
   14e0e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
				lcd_print(3,1,lcdteks);
   14e12:	ed b7       	in	r30, 0x3d	; 61
   14e14:	fe b7       	in	r31, 0x3e	; 62
   14e16:	36 96       	adiw	r30, 0x06	; 6
   14e18:	0f b6       	in	r0, 0x3f	; 63
   14e1a:	f8 94       	cli
   14e1c:	fe bf       	out	0x3e, r31	; 62
   14e1e:	0f be       	out	0x3f, r0	; 63
   14e20:	ed bf       	out	0x3d, r30	; 61
   14e22:	83 e0       	ldi	r24, 0x03	; 3
   14e24:	61 e0       	ldi	r22, 0x01	; 1
   14e26:	a8 01       	movw	r20, r16
   14e28:	0e 94 60 ae 	call	0x15cc0	; 0x15cc0 <lcd_print>

				TimLocAcc=0;
				stLocalAccount=laDelayExit;
		        break;
           case laFailedTransaction:
		        TimLocAcc=0;
   14e2c:	10 92 d3 01 	sts	0x01D3, r1
   14e30:	10 92 d2 01 	sts	0x01D2, r1
		        //Show Failed Report
				stLocalAccount=laDelayExit;
   14e34:	8e e1       	ldi	r24, 0x1E	; 30
   14e36:	3c cd       	rjmp	.-1416   	; 0x148b0 <FMenuLocalAccount+0xeb2>
		        break;
           case laDelayExit:
		        if (TimLocAcc>15)stLocalAccount=laExitLocAcc;
   14e38:	80 91 d2 01 	lds	r24, 0x01D2
   14e3c:	90 91 d3 01 	lds	r25, 0x01D3
   14e40:	40 97       	sbiw	r24, 0x10	; 16
   14e42:	48 f0       	brcs	.+18     	; 0x14e56 <FMenuLocalAccount+0x1458>
   14e44:	8f e1       	ldi	r24, 0x1F	; 31
   14e46:	34 cd       	rjmp	.-1432   	; 0x148b0 <FMenuLocalAccount+0xeb2>
		        break;
           case laExitLocAcc:
		        Result=MENU_DONE;
				stLocalAccount=laInit;
   14e48:	81 e0       	ldi	r24, 0x01	; 1
   14e4a:	80 93 5c 01 	sts	0x015C, r24
				lcd_clear();
   14e4e:	0e 94 b9 ae 	call	0x15d72	; 0x15d72 <lcd_clear>
   14e52:	81 e0       	ldi	r24, 0x01	; 1
   14e54:	01 c0       	rjmp	.+2      	; 0x14e58 <FMenuLocalAccount+0x145a>
   14e56:	80 e0       	ldi	r24, 0x00	; 0
		        break;
	       }//EndSwitch
return Result;
}
   14e58:	a9 96       	adiw	r28, 0x29	; 41
   14e5a:	0f b6       	in	r0, 0x3f	; 63
   14e5c:	f8 94       	cli
   14e5e:	de bf       	out	0x3e, r29	; 62
   14e60:	0f be       	out	0x3f, r0	; 63
   14e62:	cd bf       	out	0x3d, r28	; 61
   14e64:	cf 91       	pop	r28
   14e66:	df 91       	pop	r29
   14e68:	1f 91       	pop	r17
   14e6a:	0f 91       	pop	r16
   14e6c:	ff 90       	pop	r15
   14e6e:	ef 90       	pop	r14
   14e70:	df 90       	pop	r13
   14e72:	cf 90       	pop	r12
   14e74:	bf 90       	pop	r11
   14e76:	af 90       	pop	r10
   14e78:	08 95       	ret

00014e7a <SendConfigParamater>:
          stConfigProtocol=cpWaitSend;
	      break;
	 }
}

void SendConfigParamater(){
   14e7a:	8f 92       	push	r8
   14e7c:	9f 92       	push	r9
   14e7e:	af 92       	push	r10
   14e80:	bf 92       	push	r11
   14e82:	cf 92       	push	r12
   14e84:	df 92       	push	r13
   14e86:	ef 92       	push	r14
   14e88:	ff 92       	push	r15
   14e8a:	0f 93       	push	r16
   14e8c:	1f 93       	push	r17
   14e8e:	df 93       	push	r29
   14e90:	cf 93       	push	r28
   14e92:	cd b7       	in	r28, 0x3d	; 61
   14e94:	de b7       	in	r29, 0x3e	; 62
   14e96:	c5 56       	subi	r28, 0x65	; 101
   14e98:	d0 40       	sbci	r29, 0x00	; 0
   14e9a:	0f b6       	in	r0, 0x3f	; 63
   14e9c:	f8 94       	cli
   14e9e:	de bf       	out	0x3e, r29	; 62
   14ea0:	0f be       	out	0x3f, r0	; 63
   14ea2:	cd bf       	out	0x3d, r28	; 61
char i,j,strSend[60];
char strEEPROM[41],xEEPROM;

     //Start
	 _uart_printf(1,0,PSTR("<"));
   14ea4:	81 e0       	ldi	r24, 0x01	; 1
   14ea6:	60 e0       	ldi	r22, 0x00	; 0
   14ea8:	4c e7       	ldi	r20, 0x7C	; 124
   14eaa:	52 e2       	ldi	r21, 0x22	; 34
   14eac:	0e 94 12 b4 	call	0x16824	; 0x16824 <_uart_printf>
   14eb0:	07 e2       	ldi	r16, 0x27	; 39
   14eb2:	12 e0       	ldi	r17, 0x02	; 2
   14eb4:	6e 01       	movw	r12, r28
   14eb6:	08 94       	sec
   14eb8:	c1 1c       	adc	r12, r1
   14eba:	d1 1c       	adc	r13, r1
     //Header Footer 400
	 for (i=0;i<10;i++){
	      eeprom_read_block((void*) &strEEPROM, (const void*) &DefHeaderFooter[i],sizeof(DefHeaderFooter[i]));
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14ebc:	7a e2       	ldi	r23, 0x2A	; 42
   14ebe:	e7 2e       	mov	r14, r23
   14ec0:	f1 2c       	mov	r15, r1
   14ec2:	ec 0e       	add	r14, r28
   14ec4:	fd 1e       	adc	r15, r29
   14ec6:	69 e7       	ldi	r22, 0x79	; 121
   14ec8:	a6 2e       	mov	r10, r22
   14eca:	62 e2       	ldi	r22, 0x22	; 34
   14ecc:	b6 2e       	mov	r11, r22
   14ece:	c6 01       	movw	r24, r12
   14ed0:	b8 01       	movw	r22, r16
   14ed2:	49 e2       	ldi	r20, 0x29	; 41
   14ed4:	50 e0       	ldi	r21, 0x00	; 0
   14ed6:	28 ef       	ldi	r18, 0xF8	; 248
   14ed8:	32 e1       	ldi	r19, 0x12	; 18
   14eda:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
   14ede:	00 d0       	rcall	.+0      	; 0x14ee0 <SendConfigParamater+0x66>
   14ee0:	00 d0       	rcall	.+0      	; 0x14ee2 <SendConfigParamater+0x68>
   14ee2:	00 d0       	rcall	.+0      	; 0x14ee4 <SendConfigParamater+0x6a>
   14ee4:	ed b7       	in	r30, 0x3d	; 61
   14ee6:	fe b7       	in	r31, 0x3e	; 62
   14ee8:	31 96       	adiw	r30, 0x01	; 1
   14eea:	ad b7       	in	r26, 0x3d	; 61
   14eec:	be b7       	in	r27, 0x3e	; 62
   14eee:	12 96       	adiw	r26, 0x02	; 2
   14ef0:	fc 92       	st	X, r15
   14ef2:	ee 92       	st	-X, r14
   14ef4:	11 97       	sbiw	r26, 0x01	; 1
   14ef6:	b3 82       	std	Z+3, r11	; 0x03
   14ef8:	a2 82       	std	Z+2, r10	; 0x02
   14efa:	d5 82       	std	Z+5, r13	; 0x05
   14efc:	c4 82       	std	Z+4, r12	; 0x04
   14efe:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  AddSpaceLag(strSend,40);
   14f02:	ed b7       	in	r30, 0x3d	; 61
   14f04:	fe b7       	in	r31, 0x3e	; 62
   14f06:	36 96       	adiw	r30, 0x06	; 6
   14f08:	0f b6       	in	r0, 0x3f	; 63
   14f0a:	f8 94       	cli
   14f0c:	fe bf       	out	0x3e, r31	; 62
   14f0e:	0f be       	out	0x3f, r0	; 63
   14f10:	ed bf       	out	0x3d, r30	; 61
   14f12:	c7 01       	movw	r24, r14
   14f14:	68 e2       	ldi	r22, 0x28	; 40
   14f16:	0e 94 3c 2e 	call	0x5c78	; 0x5c78 <AddSpaceLag>
		  _uart_print(1,0,strSend);
   14f1a:	81 e0       	ldi	r24, 0x01	; 1
   14f1c:	60 e0       	ldi	r22, 0x00	; 0
   14f1e:	a7 01       	movw	r20, r14
   14f20:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
   14f24:	07 5d       	subi	r16, 0xD7	; 215
   14f26:	1f 4f       	sbci	r17, 0xFF	; 255
char strEEPROM[41],xEEPROM;

     //Start
	 _uart_printf(1,0,PSTR("<"));
     //Header Footer 400
	 for (i=0;i<10;i++){
   14f28:	f3 e0       	ldi	r31, 0x03	; 3
   14f2a:	01 3c       	cpi	r16, 0xC1	; 193
   14f2c:	1f 07       	cpc	r17, r31
   14f2e:	79 f6       	brne	.-98     	; 0x14ece <SendConfigParamater+0x54>
   14f30:	0b eb       	ldi	r16, 0xBB	; 187
   14f32:	10 e0       	ldi	r17, 0x00	; 0
   14f34:	6e 01       	movw	r12, r28
   14f36:	08 94       	sec
   14f38:	c1 1c       	adc	r12, r1
   14f3a:	d1 1c       	adc	r13, r1
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductName[i],sizeof(DefProductName[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14f3c:	5a e2       	ldi	r21, 0x2A	; 42
   14f3e:	e5 2e       	mov	r14, r21
   14f40:	f1 2c       	mov	r15, r1
   14f42:	ec 0e       	add	r14, r28
   14f44:	fd 1e       	adc	r15, r29
   14f46:	46 e7       	ldi	r20, 0x76	; 118
   14f48:	a4 2e       	mov	r10, r20
   14f4a:	42 e2       	ldi	r20, 0x22	; 34
   14f4c:	b4 2e       	mov	r11, r20
   14f4e:	c6 01       	movw	r24, r12
   14f50:	b8 01       	movw	r22, r16
   14f52:	4d e0       	ldi	r20, 0x0D	; 13
   14f54:	50 e0       	ldi	r21, 0x00	; 0
   14f56:	28 ef       	ldi	r18, 0xF8	; 248
   14f58:	32 e1       	ldi	r19, 0x12	; 18
   14f5a:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
   14f5e:	00 d0       	rcall	.+0      	; 0x14f60 <SendConfigParamater+0xe6>
   14f60:	00 d0       	rcall	.+0      	; 0x14f62 <SendConfigParamater+0xe8>
   14f62:	00 d0       	rcall	.+0      	; 0x14f64 <SendConfigParamater+0xea>
   14f64:	ed b7       	in	r30, 0x3d	; 61
   14f66:	fe b7       	in	r31, 0x3e	; 62
   14f68:	31 96       	adiw	r30, 0x01	; 1
   14f6a:	ad b7       	in	r26, 0x3d	; 61
   14f6c:	be b7       	in	r27, 0x3e	; 62
   14f6e:	12 96       	adiw	r26, 0x02	; 2
   14f70:	fc 92       	st	X, r15
   14f72:	ee 92       	st	-X, r14
   14f74:	11 97       	sbiw	r26, 0x01	; 1
   14f76:	b3 82       	std	Z+3, r11	; 0x03
   14f78:	a2 82       	std	Z+2, r10	; 0x02
   14f7a:	d5 82       	std	Z+5, r13	; 0x05
   14f7c:	c4 82       	std	Z+4, r12	; 0x04
   14f7e:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		 AddSpaceLag(strSend,12);
   14f82:	ed b7       	in	r30, 0x3d	; 61
   14f84:	fe b7       	in	r31, 0x3e	; 62
   14f86:	36 96       	adiw	r30, 0x06	; 6
   14f88:	0f b6       	in	r0, 0x3f	; 63
   14f8a:	f8 94       	cli
   14f8c:	fe bf       	out	0x3e, r31	; 62
   14f8e:	0f be       	out	0x3f, r0	; 63
   14f90:	ed bf       	out	0x3d, r30	; 61
   14f92:	c7 01       	movw	r24, r14
   14f94:	6c e0       	ldi	r22, 0x0C	; 12
   14f96:	0e 94 3c 2e 	call	0x5c78	; 0x5c78 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14f9a:	81 e0       	ldi	r24, 0x01	; 1
   14f9c:	60 e0       	ldi	r22, 0x00	; 0
   14f9e:	a7 01       	movw	r20, r14
   14fa0:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
   14fa4:	03 5f       	subi	r16, 0xF3	; 243
   14fa6:	1f 4f       	sbci	r17, 0xFF	; 255
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
		  AddSpaceLag(strSend,40);
		  _uart_print(1,0,strSend);
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
   14fa8:	f1 e0       	ldi	r31, 0x01	; 1
   14faa:	09 30       	cpi	r16, 0x09	; 9
   14fac:	1f 07       	cpc	r17, r31
   14fae:	79 f6       	brne	.-98     	; 0x14f4e <SendConfigParamater+0xd4>
   14fb0:	05 e8       	ldi	r16, 0x85	; 133
   14fb2:	10 e0       	ldi	r17, 0x00	; 0
   14fb4:	6e 01       	movw	r12, r28
   14fb6:	08 94       	sec
   14fb8:	c1 1c       	adc	r12, r1
   14fba:	d1 1c       	adc	r13, r1
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductPrice[i],sizeof(DefProductPrice[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14fbc:	3a e2       	ldi	r19, 0x2A	; 42
   14fbe:	e3 2e       	mov	r14, r19
   14fc0:	f1 2c       	mov	r15, r1
   14fc2:	ec 0e       	add	r14, r28
   14fc4:	fd 1e       	adc	r15, r29
   14fc6:	23 e7       	ldi	r18, 0x73	; 115
   14fc8:	a2 2e       	mov	r10, r18
   14fca:	22 e2       	ldi	r18, 0x22	; 34
   14fcc:	b2 2e       	mov	r11, r18
   14fce:	c6 01       	movw	r24, r12
   14fd0:	b8 01       	movw	r22, r16
   14fd2:	49 e0       	ldi	r20, 0x09	; 9
   14fd4:	50 e0       	ldi	r21, 0x00	; 0
   14fd6:	28 ef       	ldi	r18, 0xF8	; 248
   14fd8:	32 e1       	ldi	r19, 0x12	; 18
   14fda:	0e 94 72 b5 	call	0x16ae4	; 0x16ae4 <__eerd_block>
   14fde:	00 d0       	rcall	.+0      	; 0x14fe0 <SendConfigParamater+0x166>
   14fe0:	00 d0       	rcall	.+0      	; 0x14fe2 <SendConfigParamater+0x168>
   14fe2:	00 d0       	rcall	.+0      	; 0x14fe4 <SendConfigParamater+0x16a>
   14fe4:	ed b7       	in	r30, 0x3d	; 61
   14fe6:	fe b7       	in	r31, 0x3e	; 62
   14fe8:	31 96       	adiw	r30, 0x01	; 1
   14fea:	ad b7       	in	r26, 0x3d	; 61
   14fec:	be b7       	in	r27, 0x3e	; 62
   14fee:	12 96       	adiw	r26, 0x02	; 2
   14ff0:	fc 92       	st	X, r15
   14ff2:	ee 92       	st	-X, r14
   14ff4:	11 97       	sbiw	r26, 0x01	; 1
   14ff6:	b3 82       	std	Z+3, r11	; 0x03
   14ff8:	a2 82       	std	Z+2, r10	; 0x02
   14ffa:	d5 82       	std	Z+5, r13	; 0x05
   14ffc:	c4 82       	std	Z+4, r12	; 0x04
   14ffe:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		 AddSpaceLag(strSend,5);
   15002:	ed b7       	in	r30, 0x3d	; 61
   15004:	fe b7       	in	r31, 0x3e	; 62
   15006:	36 96       	adiw	r30, 0x06	; 6
   15008:	0f b6       	in	r0, 0x3f	; 63
   1500a:	f8 94       	cli
   1500c:	fe bf       	out	0x3e, r31	; 62
   1500e:	0f be       	out	0x3f, r0	; 63
   15010:	ed bf       	out	0x3d, r30	; 61
   15012:	c7 01       	movw	r24, r14
   15014:	65 e0       	ldi	r22, 0x05	; 5
   15016:	0e 94 3c 2e 	call	0x5c78	; 0x5c78 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   1501a:	81 e0       	ldi	r24, 0x01	; 1
   1501c:	60 e0       	ldi	r22, 0x00	; 0
   1501e:	a7 01       	movw	r20, r14
   15020:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
   15024:	07 5f       	subi	r16, 0xF7	; 247
   15026:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,12);
		 _uart_print(1,0,strSend);
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
   15028:	f0 e0       	ldi	r31, 0x00	; 0
   1502a:	0b 3b       	cpi	r16, 0xBB	; 187
   1502c:	1f 07       	cpc	r17, r31
   1502e:	79 f6       	brne	.-98     	; 0x14fce <SendConfigParamater+0x154>
   15030:	05 e4       	ldi	r16, 0x45	; 69
   15032:	10 e0       	ldi	r17, 0x00	; 0
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   15034:	9a e2       	ldi	r25, 0x2A	; 42
   15036:	e9 2e       	mov	r14, r25
   15038:	f1 2c       	mov	r15, r1
   1503a:	ec 0e       	add	r14, r28
   1503c:	fd 1e       	adc	r15, r29
   1503e:	8e e6       	ldi	r24, 0x6E	; 110
   15040:	c8 2e       	mov	r12, r24
   15042:	82 e2       	ldi	r24, 0x22	; 34
   15044:	d8 2e       	mov	r13, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   15046:	e1 99       	sbic	0x1c, 1	; 28
   15048:	fe cf       	rjmp	.-4      	; 0x15046 <SendConfigParamater+0x1cc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1504a:	1f bb       	out	0x1f, r17	; 31
   1504c:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1504e:	e0 9a       	sbi	0x1c, 0	; 28
   15050:	8d b3       	in	r24, 0x1d	; 29
		 _uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   15052:	84 36       	cpi	r24, 0x64	; 100
   15054:	08 f0       	brcs	.+2      	; 0x15058 <SendConfigParamater+0x1de>
   15056:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   15058:	00 d0       	rcall	.+0      	; 0x1505a <SendConfigParamater+0x1e0>
   1505a:	00 d0       	rcall	.+0      	; 0x1505c <SendConfigParamater+0x1e2>
   1505c:	00 d0       	rcall	.+0      	; 0x1505e <SendConfigParamater+0x1e4>
   1505e:	ed b7       	in	r30, 0x3d	; 61
   15060:	fe b7       	in	r31, 0x3e	; 62
   15062:	31 96       	adiw	r30, 0x01	; 1
   15064:	ad b7       	in	r26, 0x3d	; 61
   15066:	be b7       	in	r27, 0x3e	; 62
   15068:	12 96       	adiw	r26, 0x02	; 2
   1506a:	fc 92       	st	X, r15
   1506c:	ee 92       	st	-X, r14
   1506e:	11 97       	sbiw	r26, 0x01	; 1
   15070:	d3 82       	std	Z+3, r13	; 0x03
   15072:	c2 82       	std	Z+2, r12	; 0x02
   15074:	84 83       	std	Z+4, r24	; 0x04
   15076:	15 82       	std	Z+5, r1	; 0x05
   15078:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  AddSpaceLag(strSend,2);
   1507c:	ed b7       	in	r30, 0x3d	; 61
   1507e:	fe b7       	in	r31, 0x3e	; 62
   15080:	36 96       	adiw	r30, 0x06	; 6
   15082:	0f b6       	in	r0, 0x3f	; 63
   15084:	f8 94       	cli
   15086:	fe bf       	out	0x3e, r31	; 62
   15088:	0f be       	out	0x3f, r0	; 63
   1508a:	ed bf       	out	0x3d, r30	; 61
   1508c:	c7 01       	movw	r24, r14
   1508e:	62 e0       	ldi	r22, 0x02	; 2
   15090:	0e 94 3c 2e 	call	0x5c78	; 0x5c78 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   15094:	81 e0       	ldi	r24, 0x01	; 1
   15096:	60 e0       	ldi	r22, 0x00	; 0
   15098:	a7 01       	movw	r20, r14
   1509a:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
   1509e:	0f 5f       	subi	r16, 0xFF	; 255
   150a0:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,5);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
   150a2:	f0 e0       	ldi	r31, 0x00	; 0
   150a4:	0d 34       	cpi	r16, 0x4D	; 77
   150a6:	1f 07       	cpc	r17, r31
   150a8:	71 f6       	brne	.-100    	; 0x15046 <SendConfigParamater+0x1cc>
   150aa:	b5 e5       	ldi	r27, 0x55	; 85
   150ac:	eb 2e       	mov	r14, r27
   150ae:	b0 e0       	ldi	r27, 0x00	; 0
   150b0:	fb 2e       	mov	r15, r27
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   150b2:	aa e2       	ldi	r26, 0x2A	; 42
   150b4:	aa 2e       	mov	r10, r26
   150b6:	b1 2c       	mov	r11, r1
   150b8:	ac 0e       	add	r10, r28
   150ba:	bd 1e       	adc	r11, r29
   150bc:	fb e6       	ldi	r31, 0x6B	; 107
   150be:	8f 2e       	mov	r8, r31
   150c0:	f2 e2       	ldi	r31, 0x22	; 34
   150c2:	9f 2e       	mov	r9, r31
   150c4:	37 c0       	rjmp	.+110    	; 0x15134 <SendConfigParamater+0x2ba>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   150c6:	e1 99       	sbic	0x1c, 1	; 28
   150c8:	fe cf       	rjmp	.-4      	; 0x150c6 <SendConfigParamater+0x24c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   150ca:	1f bb       	out	0x1f, r17	; 31
   150cc:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   150ce:	e0 9a       	sbi	0x1c, 0	; 28
   150d0:	8d b3       	in	r24, 0x1d	; 29
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
   150d2:	8a 30       	cpi	r24, 0x0A	; 10
   150d4:	08 f0       	brcs	.+2      	; 0x150d8 <SendConfigParamater+0x25e>
   150d6:	80 e0       	ldi	r24, 0x00	; 0
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   150d8:	00 d0       	rcall	.+0      	; 0x150da <SendConfigParamater+0x260>
   150da:	00 d0       	rcall	.+0      	; 0x150dc <SendConfigParamater+0x262>
   150dc:	00 d0       	rcall	.+0      	; 0x150de <SendConfigParamater+0x264>
   150de:	ed b7       	in	r30, 0x3d	; 61
   150e0:	fe b7       	in	r31, 0x3e	; 62
   150e2:	31 96       	adiw	r30, 0x01	; 1
   150e4:	ad b7       	in	r26, 0x3d	; 61
   150e6:	be b7       	in	r27, 0x3e	; 62
   150e8:	12 96       	adiw	r26, 0x02	; 2
   150ea:	bc 92       	st	X, r11
   150ec:	ae 92       	st	-X, r10
   150ee:	11 97       	sbiw	r26, 0x01	; 1
   150f0:	93 82       	std	Z+3, r9	; 0x03
   150f2:	82 82       	std	Z+2, r8	; 0x02
   150f4:	84 83       	std	Z+4, r24	; 0x04
   150f6:	15 82       	std	Z+5, r1	; 0x05
   150f8:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
			   _uart_print(1,0,strSend);
   150fc:	ed b7       	in	r30, 0x3d	; 61
   150fe:	fe b7       	in	r31, 0x3e	; 62
   15100:	36 96       	adiw	r30, 0x06	; 6
   15102:	0f b6       	in	r0, 0x3f	; 63
   15104:	f8 94       	cli
   15106:	fe bf       	out	0x3e, r31	; 62
   15108:	0f be       	out	0x3f, r0	; 63
   1510a:	ed bf       	out	0x3d, r30	; 61
   1510c:	81 e0       	ldi	r24, 0x01	; 1
   1510e:	60 e0       	ldi	r22, 0x00	; 0
   15110:	a5 01       	movw	r20, r10
   15112:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
   15116:	d3 94       	inc	r13
   15118:	0f 5f       	subi	r16, 0xFF	; 255
   1511a:	1f 4f       	sbci	r17, 0xFF	; 255
   1511c:	f6 e0       	ldi	r31, 0x06	; 6
   1511e:	df 16       	cp	r13, r31
   15120:	91 f6       	brne	.-92     	; 0x150c6 <SendConfigParamater+0x24c>
   15122:	86 e0       	ldi	r24, 0x06	; 6
   15124:	90 e0       	ldi	r25, 0x00	; 0
   15126:	e8 0e       	add	r14, r24
   15128:	f9 1e       	adc	r15, r25
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
   1512a:	95 e8       	ldi	r25, 0x85	; 133
   1512c:	e9 16       	cp	r14, r25
   1512e:	90 e0       	ldi	r25, 0x00	; 0
   15130:	f9 06       	cpc	r15, r25
   15132:	19 f0       	breq	.+6      	; 0x1513a <SendConfigParamater+0x2c0>
   15134:	87 01       	movw	r16, r14
   15136:	dd 24       	eor	r13, r13
   15138:	c6 cf       	rjmp	.-116    	; 0x150c6 <SendConfigParamater+0x24c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1513a:	e1 99       	sbic	0x1c, 1	; 28
   1513c:	fe cf       	rjmp	.-4      	; 0x1513a <SendConfigParamater+0x2c0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1513e:	81 ec       	ldi	r24, 0xC1	; 193
   15140:	93 e0       	ldi	r25, 0x03	; 3
   15142:	9f bb       	out	0x1f, r25	; 31
   15144:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   15146:	e0 9a       	sbi	0x1c, 0	; 28
   15148:	8d b3       	in	r24, 0x1d	; 29
   1514a:	9e 01       	movw	r18, r28
   1514c:	26 5d       	subi	r18, 0xD6	; 214
   1514e:	3f 4f       	sbci	r19, 0xFF	; 255
			   _uart_print(1,0,strSend);
		  }
	 }
	 //PrintNoMoney
	 xEEPROM=eeprom_read_byte(&DefPrintMoney);
	 if (xEEPROM==True){
   15150:	81 30       	cpi	r24, 0x01	; 1
   15152:	79 f4       	brne	.+30     	; 0x15172 <SendConfigParamater+0x2f8>
		 sprintf_P(strSend,PSTR("1"));
   15154:	00 d0       	rcall	.+0      	; 0x15156 <SendConfigParamater+0x2dc>
   15156:	00 d0       	rcall	.+0      	; 0x15158 <SendConfigParamater+0x2de>
   15158:	ad b7       	in	r26, 0x3d	; 61
   1515a:	be b7       	in	r27, 0x3e	; 62
   1515c:	12 96       	adiw	r26, 0x02	; 2
   1515e:	3c 93       	st	X, r19
   15160:	2e 93       	st	-X, r18
   15162:	11 97       	sbiw	r26, 0x01	; 1
   15164:	89 e6       	ldi	r24, 0x69	; 105
   15166:	92 e2       	ldi	r25, 0x22	; 34
   15168:	14 96       	adiw	r26, 0x04	; 4
   1516a:	9c 93       	st	X, r25
   1516c:	8e 93       	st	-X, r24
   1516e:	13 97       	sbiw	r26, 0x03	; 3
   15170:	0a c0       	rjmp	.+20     	; 0x15186 <SendConfigParamater+0x30c>
	 }else{
	     sprintf_P(strSend,PSTR("0"));
   15172:	00 d0       	rcall	.+0      	; 0x15174 <SendConfigParamater+0x2fa>
   15174:	00 d0       	rcall	.+0      	; 0x15176 <SendConfigParamater+0x2fc>
   15176:	ed b7       	in	r30, 0x3d	; 61
   15178:	fe b7       	in	r31, 0x3e	; 62
   1517a:	32 83       	std	Z+2, r19	; 0x02
   1517c:	21 83       	std	Z+1, r18	; 0x01
   1517e:	87 e6       	ldi	r24, 0x67	; 103
   15180:	92 e2       	ldi	r25, 0x22	; 34
   15182:	94 83       	std	Z+4, r25	; 0x04
   15184:	83 83       	std	Z+3, r24	; 0x03
   15186:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   1518a:	0f 90       	pop	r0
   1518c:	0f 90       	pop	r0
   1518e:	0f 90       	pop	r0
   15190:	0f 90       	pop	r0
	 }_uart_print(1,0,strSend);
   15192:	81 e0       	ldi	r24, 0x01	; 1
   15194:	60 e0       	ldi	r22, 0x00	; 0
   15196:	ae 01       	movw	r20, r28
   15198:	46 5d       	subi	r20, 0xD6	; 214
   1519a:	5f 4f       	sbci	r21, 0xFF	; 255
   1519c:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   151a0:	e1 99       	sbic	0x1c, 1	; 28
   151a2:	fe cf       	rjmp	.-4      	; 0x151a0 <SendConfigParamater+0x326>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   151a4:	80 e0       	ldi	r24, 0x00	; 0
   151a6:	90 e0       	ldi	r25, 0x00	; 0
   151a8:	9f bb       	out	0x1f, r25	; 31
   151aa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   151ac:	e0 9a       	sbi	0x1c, 0	; 28
   151ae:	2d b3       	in	r18, 0x1d	; 29
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   151b0:	00 d0       	rcall	.+0      	; 0x151b2 <SendConfigParamater+0x338>
   151b2:	00 d0       	rcall	.+0      	; 0x151b4 <SendConfigParamater+0x33a>
   151b4:	00 d0       	rcall	.+0      	; 0x151b6 <SendConfigParamater+0x33c>
   151b6:	ed b7       	in	r30, 0x3d	; 61
   151b8:	fe b7       	in	r31, 0x3e	; 62
   151ba:	31 96       	adiw	r30, 0x01	; 1
   151bc:	8e 01       	movw	r16, r28
   151be:	06 5d       	subi	r16, 0xD6	; 214
   151c0:	1f 4f       	sbci	r17, 0xFF	; 255
   151c2:	ad b7       	in	r26, 0x3d	; 61
   151c4:	be b7       	in	r27, 0x3e	; 62
   151c6:	12 96       	adiw	r26, 0x02	; 2
   151c8:	1c 93       	st	X, r17
   151ca:	0e 93       	st	-X, r16
   151cc:	11 97       	sbiw	r26, 0x01	; 1
   151ce:	82 e6       	ldi	r24, 0x62	; 98
   151d0:	92 e2       	ldi	r25, 0x22	; 34
   151d2:	93 83       	std	Z+3, r25	; 0x03
   151d4:	82 83       	std	Z+2, r24	; 0x02
   151d6:	24 83       	std	Z+4, r18	; 0x04
   151d8:	15 82       	std	Z+5, r1	; 0x05
   151da:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
     _uart_print(1,0,strSend);
   151de:	ed b7       	in	r30, 0x3d	; 61
   151e0:	fe b7       	in	r31, 0x3e	; 62
   151e2:	36 96       	adiw	r30, 0x06	; 6
   151e4:	0f b6       	in	r0, 0x3f	; 63
   151e6:	f8 94       	cli
   151e8:	fe bf       	out	0x3e, r31	; 62
   151ea:	0f be       	out	0x3f, r0	; 63
   151ec:	ed bf       	out	0x3d, r30	; 61
   151ee:	81 e0       	ldi	r24, 0x01	; 1
   151f0:	60 e0       	ldi	r22, 0x00	; 0
   151f2:	a8 01       	movw	r20, r16
   151f4:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
   151f8:	ed e4       	ldi	r30, 0x4D	; 77
   151fa:	ee 2e       	mov	r14, r30
   151fc:	e0 e0       	ldi	r30, 0x00	; 0
   151fe:	fe 2e       	mov	r15, r30
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   15200:	d0 2e       	mov	r13, r16
   15202:	01 2f       	mov	r16, r17
   15204:	7d e5       	ldi	r23, 0x5D	; 93
   15206:	a7 2e       	mov	r10, r23
   15208:	72 e2       	ldi	r23, 0x22	; 34
   1520a:	b7 2e       	mov	r11, r23
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1520c:	e1 99       	sbic	0x1c, 1	; 28
   1520e:	fe cf       	rjmp	.-4      	; 0x1520c <SendConfigParamater+0x392>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15210:	ff ba       	out	0x1f, r15	; 31
   15212:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   15214:	e0 9a       	sbi	0x1c, 0	; 28
   15216:	8d b3       	in	r24, 0x1d	; 29
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     _uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   15218:	84 36       	cpi	r24, 0x64	; 100
   1521a:	08 f0       	brcs	.+2      	; 0x1521e <SendConfigParamater+0x3a4>
   1521c:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   1521e:	00 d0       	rcall	.+0      	; 0x15220 <SendConfigParamater+0x3a6>
   15220:	00 d0       	rcall	.+0      	; 0x15222 <SendConfigParamater+0x3a8>
   15222:	00 d0       	rcall	.+0      	; 0x15224 <SendConfigParamater+0x3aa>
   15224:	ed b7       	in	r30, 0x3d	; 61
   15226:	fe b7       	in	r31, 0x3e	; 62
   15228:	31 96       	adiw	r30, 0x01	; 1
   1522a:	ad b7       	in	r26, 0x3d	; 61
   1522c:	be b7       	in	r27, 0x3e	; 62
   1522e:	11 96       	adiw	r26, 0x01	; 1
   15230:	dc 92       	st	X, r13
   15232:	11 97       	sbiw	r26, 0x01	; 1
   15234:	12 96       	adiw	r26, 0x02	; 2
   15236:	0c 93       	st	X, r16
   15238:	b3 82       	std	Z+3, r11	; 0x03
   1523a:	a2 82       	std	Z+2, r10	; 0x02
   1523c:	84 83       	std	Z+4, r24	; 0x04
   1523e:	15 82       	std	Z+5, r1	; 0x05
   15240:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
		  AddSpaceLag(strSend,2);
   15244:	ed b7       	in	r30, 0x3d	; 61
   15246:	fe b7       	in	r31, 0x3e	; 62
   15248:	36 96       	adiw	r30, 0x06	; 6
   1524a:	0f b6       	in	r0, 0x3f	; 63
   1524c:	f8 94       	cli
   1524e:	fe bf       	out	0x3e, r31	; 62
   15250:	0f be       	out	0x3f, r0	; 63
   15252:	ed bf       	out	0x3d, r30	; 61
   15254:	8d 2d       	mov	r24, r13
   15256:	90 2f       	mov	r25, r16
   15258:	62 e0       	ldi	r22, 0x02	; 2
   1525a:	0e 94 3c 2e 	call	0x5c78	; 0x5c78 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   1525e:	81 e0       	ldi	r24, 0x01	; 1
   15260:	60 e0       	ldi	r22, 0x00	; 0
   15262:	4d 2d       	mov	r20, r13
   15264:	50 2f       	mov	r21, r16
   15266:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>
   1526a:	08 94       	sec
   1526c:	e1 1c       	adc	r14, r1
   1526e:	f1 1c       	adc	r15, r1
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     _uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
   15270:	f5 e5       	ldi	r31, 0x55	; 85
   15272:	ef 16       	cp	r14, r31
   15274:	f0 e0       	ldi	r31, 0x00	; 0
   15276:	ff 06       	cpc	r15, r31
   15278:	49 f6       	brne	.-110    	; 0x1520c <SendConfigParamater+0x392>
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 _uart_printf(1,1,PSTR(">"));
   1527a:	81 e0       	ldi	r24, 0x01	; 1
   1527c:	61 e0       	ldi	r22, 0x01	; 1
   1527e:	4b e5       	ldi	r20, 0x5B	; 91
   15280:	52 e2       	ldi	r21, 0x22	; 34
   15282:	0e 94 12 b4 	call	0x16824	; 0x16824 <_uart_printf>
	 //End
}
   15286:	cb 59       	subi	r28, 0x9B	; 155
   15288:	df 4f       	sbci	r29, 0xFF	; 255
   1528a:	0f b6       	in	r0, 0x3f	; 63
   1528c:	f8 94       	cli
   1528e:	de bf       	out	0x3e, r29	; 62
   15290:	0f be       	out	0x3f, r0	; 63
   15292:	cd bf       	out	0x3d, r28	; 61
   15294:	cf 91       	pop	r28
   15296:	df 91       	pop	r29
   15298:	1f 91       	pop	r17
   1529a:	0f 91       	pop	r16
   1529c:	ff 90       	pop	r15
   1529e:	ef 90       	pop	r14
   152a0:	df 90       	pop	r13
   152a2:	cf 90       	pop	r12
   152a4:	bf 90       	pop	r11
   152a6:	af 90       	pop	r10
   152a8:	9f 90       	pop	r9
   152aa:	8f 90       	pop	r8
   152ac:	08 95       	ret

000152ae <SaveConfigParameter>:
     char Result;
	 Result=False;
   return Result;
}

void SaveConfigParameter(){
   152ae:	8f 92       	push	r8
   152b0:	9f 92       	push	r9
   152b2:	af 92       	push	r10
   152b4:	bf 92       	push	r11
   152b6:	cf 92       	push	r12
   152b8:	df 92       	push	r13
   152ba:	ef 92       	push	r14
   152bc:	ff 92       	push	r15
   152be:	0f 93       	push	r16
   152c0:	1f 93       	push	r17
   152c2:	df 93       	push	r29
   152c4:	cf 93       	push	r28
   152c6:	cd b7       	in	r28, 0x3d	; 61
   152c8:	de b7       	in	r29, 0x3e	; 62
   152ca:	c6 54       	subi	r28, 0x46	; 70
   152cc:	d0 40       	sbci	r29, 0x00	; 0
   152ce:	0f b6       	in	r0, 0x3f	; 63
   152d0:	f8 94       	cli
   152d2:	de bf       	out	0x3e, r29	; 62
   152d4:	0f be       	out	0x3f, r0	; 63
   152d6:	cd bf       	out	0x3d, r28	; 61
char i,j;
char strEEPROM[50],xEEPROM;
unsigned int StrPos;
char strSend[20];
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
   152d8:	00 d0       	rcall	.+0      	; 0x152da <SaveConfigParameter+0x2c>
   152da:	00 d0       	rcall	.+0      	; 0x152dc <SaveConfigParameter+0x2e>
   152dc:	00 d0       	rcall	.+0      	; 0x152de <SaveConfigParameter+0x30>
   152de:	ed b7       	in	r30, 0x3d	; 61
   152e0:	fe b7       	in	r31, 0x3e	; 62
   152e2:	31 96       	adiw	r30, 0x01	; 1
   152e4:	8e 01       	movw	r16, r28
   152e6:	0f 5f       	subi	r16, 0xFF	; 255
   152e8:	1f 4f       	sbci	r17, 0xFF	; 255
   152ea:	ad b7       	in	r26, 0x3d	; 61
   152ec:	be b7       	in	r27, 0x3e	; 62
   152ee:	12 96       	adiw	r26, 0x02	; 2
   152f0:	1c 93       	st	X, r17
   152f2:	0e 93       	st	-X, r16
   152f4:	11 97       	sbiw	r26, 0x01	; 1
   152f6:	85 e9       	ldi	r24, 0x95	; 149
   152f8:	92 e2       	ldi	r25, 0x22	; 34
   152fa:	93 83       	std	Z+3, r25	; 0x03
   152fc:	82 83       	std	Z+2, r24	; 0x02
   152fe:	80 91 9e 01 	lds	r24, 0x019E
   15302:	90 91 9f 01 	lds	r25, 0x019F
   15306:	95 83       	std	Z+5, r25	; 0x05
   15308:	84 83       	std	Z+4, r24	; 0x04
   1530a:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	 _uart_print(1,1,strSend);
   1530e:	ed b7       	in	r30, 0x3d	; 61
   15310:	fe b7       	in	r31, 0x3e	; 62
   15312:	36 96       	adiw	r30, 0x06	; 6
   15314:	0f b6       	in	r0, 0x3f	; 63
   15316:	f8 94       	cli
   15318:	fe bf       	out	0x3e, r31	; 62
   1531a:	0f be       	out	0x3f, r0	; 63
   1531c:	ed bf       	out	0x3d, r30	; 61
   1531e:	81 e0       	ldi	r24, 0x01	; 1
   15320:	61 e0       	ldi	r22, 0x01	; 1
   15322:	a8 01       	movw	r20, r16
   15324:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <_uart_print>

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
   15328:	81 e0       	ldi	r24, 0x01	; 1
   1532a:	61 e0       	ldi	r22, 0x01	; 1
   1532c:	4c e8       	ldi	r20, 0x8C	; 140
   1532e:	52 e2       	ldi	r21, 0x22	; 34
   15330:	0e 94 12 b4 	call	0x16824	; 0x16824 <_uart_printf>
   15334:	07 e2       	ldi	r16, 0x27	; 39
   15336:	12 e0       	ldi	r17, 0x02	; 2
   15338:	a3 e8       	ldi	r26, 0x83	; 131
   1533a:	ea 2e       	mov	r14, r26
   1533c:	ac e0       	ldi	r26, 0x0C	; 12
   1533e:	fa 2e       	mov	r15, r26
   15340:	f5 e1       	ldi	r31, 0x15	; 21
   15342:	af 2e       	mov	r10, r31
   15344:	b1 2c       	mov	r11, r1
   15346:	ac 0e       	add	r10, r28
   15348:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1534a:	ed e3       	ldi	r30, 0x3D	; 61
   1534c:	ce 2e       	mov	r12, r30
   1534e:	d1 2c       	mov	r13, r1
   15350:	cc 0e       	add	r12, r28
   15352:	dd 1e       	adc	r13, r29
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
   15354:	d7 01       	movw	r26, r14
   15356:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   15358:	8d 91       	ld	r24, X+
   1535a:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1535c:	ec 15       	cp	r30, r12
   1535e:	fd 05       	cpc	r31, r13
   15360:	d9 f7       	brne	.-10     	; 0x15358 <SaveConfigParameter+0xaa>
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(40*i)),40);
		 strEEPROM[40]=0;
   15362:	1d ae       	std	Y+61, r1	; 0x3d
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   15364:	c8 01       	movw	r24, r16
   15366:	b5 01       	movw	r22, r10
   15368:	49 e2       	ldi	r20, 0x29	; 41
   1536a:	50 e0       	ldi	r21, 0x00	; 0
   1536c:	20 e0       	ldi	r18, 0x00	; 0
   1536e:	33 e1       	ldi	r19, 0x13	; 19
   15370:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
   15374:	07 5d       	subi	r16, 0xD7	; 215
   15376:	1f 4f       	sbci	r17, 0xFF	; 255
   15378:	88 e2       	ldi	r24, 0x28	; 40
   1537a:	90 e0       	ldi	r25, 0x00	; 0
   1537c:	e8 0e       	add	r14, r24
   1537e:	f9 1e       	adc	r15, r25
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   15380:	93 e0       	ldi	r25, 0x03	; 3
   15382:	01 3c       	cpi	r16, 0xC1	; 193
   15384:	19 07       	cpc	r17, r25
   15386:	31 f7       	brne	.-52     	; 0x15354 <SaveConfigParameter+0xa6>
   15388:	0b eb       	ldi	r16, 0xBB	; 187
   1538a:	10 e0       	ldi	r17, 0x00	; 0
   1538c:	73 e1       	ldi	r23, 0x13	; 19
   1538e:	e7 2e       	mov	r14, r23
   15390:	7e e0       	ldi	r23, 0x0E	; 14
   15392:	f7 2e       	mov	r15, r23
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   15394:	65 e1       	ldi	r22, 0x15	; 21
   15396:	c6 2e       	mov	r12, r22
   15398:	d1 2c       	mov	r13, r1
   1539a:	cc 0e       	add	r12, r28
   1539c:	dd 1e       	adc	r13, r29
   1539e:	51 e2       	ldi	r21, 0x21	; 33
   153a0:	85 2e       	mov	r8, r21
   153a2:	91 2c       	mov	r9, r1
   153a4:	8c 0e       	add	r8, r28
   153a6:	9d 1e       	adc	r9, r29
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   153a8:	d7 01       	movw	r26, r14
   153aa:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   153ac:	8d 91       	ld	r24, X+
   153ae:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   153b0:	e8 15       	cp	r30, r8
   153b2:	f9 05       	cpc	r31, r9
   153b4:	d9 f7       	brne	.-10     	; 0x153ac <SaveConfigParameter+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   153b6:	19 a2       	std	Y+33, r1	; 0x21
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(12*i)),12);
		 RemSpaceLag(strEEPROM);
   153b8:	c6 01       	movw	r24, r12
   153ba:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
		 strEEPROM[strlen(strEEPROM)]=0;
   153be:	f6 01       	movw	r30, r12
   153c0:	01 90       	ld	r0, Z+
   153c2:	00 20       	and	r0, r0
   153c4:	e9 f7       	brne	.-6      	; 0x153c0 <SaveConfigParameter+0x112>
   153c6:	31 97       	sbiw	r30, 0x01	; 1
   153c8:	10 82       	st	Z, r1
   153ca:	c8 01       	movw	r24, r16
   153cc:	b6 01       	movw	r22, r12
   153ce:	4d e0       	ldi	r20, 0x0D	; 13
   153d0:	50 e0       	ldi	r21, 0x00	; 0
   153d2:	20 e0       	ldi	r18, 0x00	; 0
   153d4:	33 e1       	ldi	r19, 0x13	; 19
   153d6:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
   153da:	03 5f       	subi	r16, 0xF3	; 243
   153dc:	1f 4f       	sbci	r17, 0xFF	; 255
   153de:	ac e0       	ldi	r26, 0x0C	; 12
   153e0:	b0 e0       	ldi	r27, 0x00	; 0
   153e2:	ea 0e       	add	r14, r26
   153e4:	fb 1e       	adc	r15, r27
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //_uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   153e6:	b1 e0       	ldi	r27, 0x01	; 1
   153e8:	09 30       	cpi	r16, 0x09	; 9
   153ea:	1b 07       	cpc	r17, r27
   153ec:	e9 f6       	brne	.-70     	; 0x153a8 <SaveConfigParameter+0xfa>
   153ee:	05 e8       	ldi	r16, 0x85	; 133
   153f0:	10 e0       	ldi	r17, 0x00	; 0
   153f2:	4b e5       	ldi	r20, 0x5B	; 91
   153f4:	e4 2e       	mov	r14, r20
   153f6:	4e e0       	ldi	r20, 0x0E	; 14
   153f8:	f4 2e       	mov	r15, r20
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   153fa:	35 e1       	ldi	r19, 0x15	; 21
   153fc:	c3 2e       	mov	r12, r19
   153fe:	d1 2c       	mov	r13, r1
   15400:	cc 0e       	add	r12, r28
   15402:	dd 1e       	adc	r13, r29
   15404:	2a e1       	ldi	r18, 0x1A	; 26
   15406:	82 2e       	mov	r8, r18
   15408:	91 2c       	mov	r9, r1
   1540a:	8c 0e       	add	r8, r28
   1540c:	9d 1e       	adc	r9, r29
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //_uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   1540e:	d7 01       	movw	r26, r14
   15410:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   15412:	8d 91       	ld	r24, X+
   15414:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   15416:	e8 15       	cp	r30, r8
   15418:	f9 05       	cpc	r31, r9
   1541a:	d9 f7       	brne	.-10     	; 0x15412 <SaveConfigParameter+0x164>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   1541c:	1a 8e       	std	Y+26, r1	; 0x1a
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(5*i)),5);
		 RemSpaceLag(strEEPROM);
   1541e:	c6 01       	movw	r24, r12
   15420:	0e 94 48 26 	call	0x4c90	; 0x4c90 <RemSpaceLag>
   15424:	c8 01       	movw	r24, r16
   15426:	b6 01       	movw	r22, r12
   15428:	49 e0       	ldi	r20, 0x09	; 9
   1542a:	50 e0       	ldi	r21, 0x00	; 0
   1542c:	20 e0       	ldi	r18, 0x00	; 0
   1542e:	33 e1       	ldi	r19, 0x13	; 19
   15430:	0e 94 8e b5 	call	0x16b1c	; 0x16b1c <__eewr_block>
   15434:	07 5f       	subi	r16, 0xF7	; 247
   15436:	1f 4f       	sbci	r17, 0xFF	; 255
   15438:	e5 e0       	ldi	r30, 0x05	; 5
   1543a:	f0 e0       	ldi	r31, 0x00	; 0
   1543c:	ee 0e       	add	r14, r30
   1543e:	ff 1e       	adc	r15, r31
		// _uart_print(1,1,strEEPROM);

	 }    
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
   15440:	f0 e0       	ldi	r31, 0x00	; 0
   15442:	0b 3b       	cpi	r16, 0xBB	; 187
   15444:	1f 07       	cpc	r17, r31
   15446:	19 f7       	brne	.-58     	; 0x1540e <SaveConfigParameter+0x160>
   15448:	09 e7       	ldi	r16, 0x79	; 121
   1544a:	1e e0       	ldi	r17, 0x0E	; 14
   1544c:	95 e4       	ldi	r25, 0x45	; 69
   1544e:	e9 2e       	mov	r14, r25
   15450:	90 e0       	ldi	r25, 0x00	; 0
   15452:	f9 2e       	mov	r15, r25
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   15454:	85 e1       	ldi	r24, 0x15	; 21
   15456:	c8 2e       	mov	r12, r24
   15458:	d1 2c       	mov	r13, r1
   1545a:	cc 0e       	add	r12, r28
   1545c:	dd 1e       	adc	r13, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   1545e:	4e 01       	movw	r8, r28
   15460:	08 94       	sec
   15462:	81 1c       	adc	r8, r1
   15464:	91 1c       	adc	r9, r1
   15466:	b9 e8       	ldi	r27, 0x89	; 137
   15468:	ab 2e       	mov	r10, r27
   1546a:	b2 e2       	ldi	r27, 0x22	; 34
   1546c:	bb 2e       	mov	r11, r27
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1546e:	d8 01       	movw	r26, r16
   15470:	8c 91       	ld	r24, X
   15472:	8d 8b       	std	Y+21, r24	; 0x15
   15474:	11 96       	adiw	r26, 0x01	; 1
   15476:	8c 91       	ld	r24, X
   15478:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   1547a:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   1547c:	c6 01       	movw	r24, r12
   1547e:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   15482:	c6 01       	movw	r24, r12
   15484:	0e 94 3d b5 	call	0x16a7a	; 0x16a7a <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15488:	e1 99       	sbic	0x1c, 1	; 28
   1548a:	fe cf       	rjmp	.-4      	; 0x15488 <SaveConfigParameter+0x1da>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1548c:	ff ba       	out	0x1f, r15	; 31
   1548e:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   15490:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   15492:	0f b6       	in	r0, 0x3f	; 63
   15494:	f8 94       	cli
   15496:	e2 9a       	sbi	0x1c, 2	; 28
   15498:	e1 9a       	sbi	0x1c, 1	; 28
   1549a:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   1549c:	00 d0       	rcall	.+0      	; 0x1549e <SaveConfigParameter+0x1f0>
   1549e:	00 d0       	rcall	.+0      	; 0x154a0 <SaveConfigParameter+0x1f2>
   154a0:	00 d0       	rcall	.+0      	; 0x154a2 <SaveConfigParameter+0x1f4>
   154a2:	ed b7       	in	r30, 0x3d	; 61
   154a4:	fe b7       	in	r31, 0x3e	; 62
   154a6:	31 96       	adiw	r30, 0x01	; 1
   154a8:	ad b7       	in	r26, 0x3d	; 61
   154aa:	be b7       	in	r27, 0x3e	; 62
   154ac:	12 96       	adiw	r26, 0x02	; 2
   154ae:	9c 92       	st	X, r9
   154b0:	8e 92       	st	-X, r8
   154b2:	11 97       	sbiw	r26, 0x01	; 1
   154b4:	b3 82       	std	Z+3, r11	; 0x03
   154b6:	a2 82       	std	Z+2, r10	; 0x02
   154b8:	84 83       	std	Z+4, r24	; 0x04
   154ba:	15 82       	std	Z+5, r1	; 0x05
   154bc:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   154c0:	0e 5f       	subi	r16, 0xFE	; 254
   154c2:	1f 4f       	sbci	r17, 0xFF	; 255
   154c4:	08 94       	sec
   154c6:	e1 1c       	adc	r14, r1
   154c8:	f1 1c       	adc	r15, r1
		// _uart_print(1,1,strEEPROM);

	 }    
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
   154ca:	ed b7       	in	r30, 0x3d	; 61
   154cc:	fe b7       	in	r31, 0x3e	; 62
   154ce:	36 96       	adiw	r30, 0x06	; 6
   154d0:	0f b6       	in	r0, 0x3f	; 63
   154d2:	f8 94       	cli
   154d4:	fe bf       	out	0x3e, r31	; 62
   154d6:	0f be       	out	0x3f, r0	; 63
   154d8:	ed bf       	out	0x3d, r30	; 61
   154da:	fe e0       	ldi	r31, 0x0E	; 14
   154dc:	09 38       	cpi	r16, 0x89	; 137
   154de:	1f 07       	cpc	r17, r31
   154e0:	09 f0       	breq	.+2      	; 0x154e4 <SaveConfigParameter+0x236>
   154e2:	c5 cf       	rjmp	.-118    	; 0x1546e <SaveConfigParameter+0x1c0>
   154e4:	45 e5       	ldi	r20, 0x55	; 85
   154e6:	50 e0       	ldi	r21, 0x00	; 0
   154e8:	b8 01       	movw	r22, r16
   154ea:	1d c0       	rjmp	.+58     	; 0x15526 <SaveConfigParameter+0x278>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   154ec:	90 81       	ld	r25, Z
   154ee:	90 53       	subi	r25, 0x30	; 48
   154f0:	9a 30       	cpi	r25, 0x0A	; 10
   154f2:	08 f0       	brcs	.+2      	; 0x154f6 <SaveConfigParameter+0x248>
   154f4:	90 e0       	ldi	r25, 0x00	; 0
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   154f6:	e1 99       	sbic	0x1c, 1	; 28
   154f8:	fe cf       	rjmp	.-4      	; 0x154f6 <SaveConfigParameter+0x248>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   154fa:	3f bb       	out	0x1f, r19	; 31
   154fc:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
   154fe:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
   15500:	0f b6       	in	r0, 0x3f	; 63
   15502:	f8 94       	cli
   15504:	e2 9a       	sbi	0x1c, 2	; 28
   15506:	e1 9a       	sbi	0x1c, 1	; 28
   15508:	0f be       	out	0x3f, r0	; 63

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
	     for (j=0;j<6;j++){
   1550a:	8f 5f       	subi	r24, 0xFF	; 255
   1550c:	31 96       	adiw	r30, 0x01	; 1
   1550e:	2f 5f       	subi	r18, 0xFF	; 255
   15510:	3f 4f       	sbci	r19, 0xFF	; 255
   15512:	86 30       	cpi	r24, 0x06	; 6
   15514:	59 f7       	brne	.-42     	; 0x154ec <SaveConfigParameter+0x23e>
   15516:	4a 5f       	subi	r20, 0xFA	; 250
   15518:	5f 4f       	sbci	r21, 0xFF	; 255
   1551a:	6a 5f       	subi	r22, 0xFA	; 250
   1551c:	7f 4f       	sbci	r23, 0xFF	; 255
		// _uart_print(1,1,strSend); 

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
   1551e:	80 e0       	ldi	r24, 0x00	; 0
   15520:	45 38       	cpi	r20, 0x85	; 133
   15522:	58 07       	cpc	r21, r24
   15524:	21 f0       	breq	.+8      	; 0x1552e <SaveConfigParameter+0x280>
   15526:	fb 01       	movw	r30, r22
   15528:	9a 01       	movw	r18, r20
   1552a:	80 e0       	ldi	r24, 0x00	; 0
   1552c:	df cf       	rjmp	.-66     	; 0x154ec <SaveConfigParameter+0x23e>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   1552e:	80 91 b9 0e 	lds	r24, 0x0EB9
   15532:	80 53       	subi	r24, 0x30	; 48
   15534:	8a 30       	cpi	r24, 0x0A	; 10
   15536:	10 f0       	brcs	.+4      	; 0x1553c <SaveConfigParameter+0x28e>
   15538:	20 e0       	ldi	r18, 0x00	; 0
   1553a:	03 c0       	rjmp	.+6      	; 0x15542 <SaveConfigParameter+0x294>
   1553c:	81 11       	cpse	r24, r1
   1553e:	81 e0       	ldi	r24, 0x01	; 1
   15540:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15542:	e1 99       	sbic	0x1c, 1	; 28
   15544:	fe cf       	rjmp	.-4      	; 0x15542 <SaveConfigParameter+0x294>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15546:	81 ec       	ldi	r24, 0xC1	; 193
   15548:	93 e0       	ldi	r25, 0x03	; 3
   1554a:	9f bb       	out	0x1f, r25	; 31
   1554c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   1554e:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   15550:	0f b6       	in	r0, 0x3f	; 63
   15552:	f8 94       	cli
   15554:	e2 9a       	sbi	0x1c, 2	; 28
   15556:	e1 9a       	sbi	0x1c, 1	; 28
   15558:	0f be       	out	0x3f, r0	; 63
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1555a:	80 91 ba 0e 	lds	r24, 0x0EBA
   1555e:	8d 8b       	std	Y+21, r24	; 0x15
   15560:	80 91 bb 0e 	lds	r24, 0x0EBB
   15564:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   15566:	1f 8a       	std	Y+23, r1	; 0x17

	 //TermID
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1;
     FillChar(strEEPROM,0,sizeof(strEEPROM));   
	 StrPosCopy(rcv_trans,strEEPROM,StrPos,2);
	 RemZeroLead(strEEPROM);
   15568:	8e 01       	movw	r16, r28
   1556a:	0b 5e       	subi	r16, 0xEB	; 235
   1556c:	1f 4f       	sbci	r17, 0xFF	; 255
   1556e:	c8 01       	movw	r24, r16
   15570:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
	 xEEPROM=atoi(strEEPROM);
   15574:	c8 01       	movw	r24, r16
   15576:	0e 94 3d b5 	call	0x16a7a	; 0x16a7a <atoi>
   1557a:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1557c:	e1 99       	sbic	0x1c, 1	; 28
   1557e:	fe cf       	rjmp	.-4      	; 0x1557c <SaveConfigParameter+0x2ce>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15580:	80 e0       	ldi	r24, 0x00	; 0
   15582:	90 e0       	ldi	r25, 0x00	; 0
   15584:	9f bb       	out	0x1f, r25	; 31
   15586:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   15588:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   1558a:	0f b6       	in	r0, 0x3f	; 63
   1558c:	f8 94       	cli
   1558e:	e2 9a       	sbi	0x1c, 2	; 28
   15590:	e1 9a       	sbi	0x1c, 1	; 28
   15592:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefIFT_ID,xEEPROM);
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   15594:	00 d0       	rcall	.+0      	; 0x15596 <SaveConfigParameter+0x2e8>
   15596:	00 d0       	rcall	.+0      	; 0x15598 <SaveConfigParameter+0x2ea>
   15598:	00 d0       	rcall	.+0      	; 0x1559a <SaveConfigParameter+0x2ec>
   1559a:	ed b7       	in	r30, 0x3d	; 61
   1559c:	fe b7       	in	r31, 0x3e	; 62
   1559e:	31 96       	adiw	r30, 0x01	; 1
   155a0:	8e 01       	movw	r16, r28
   155a2:	0f 5f       	subi	r16, 0xFF	; 255
   155a4:	1f 4f       	sbci	r17, 0xFF	; 255
   155a6:	ad b7       	in	r26, 0x3d	; 61
   155a8:	be b7       	in	r27, 0x3e	; 62
   155aa:	12 96       	adiw	r26, 0x02	; 2
   155ac:	1c 93       	st	X, r17
   155ae:	0e 93       	st	-X, r16
   155b0:	11 97       	sbiw	r26, 0x01	; 1
   155b2:	86 e8       	ldi	r24, 0x86	; 134
   155b4:	92 e2       	ldi	r25, 0x22	; 34
   155b6:	93 83       	std	Z+3, r25	; 0x03
   155b8:	82 83       	std	Z+2, r24	; 0x02
   155ba:	24 83       	std	Z+4, r18	; 0x04
   155bc:	15 82       	std	Z+5, r1	; 0x05
   155be:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   155c2:	ac eb       	ldi	r26, 0xBC	; 188
   155c4:	ea 2e       	mov	r14, r26
   155c6:	ae e0       	ldi	r26, 0x0E	; 14
   155c8:	fa 2e       	mov	r15, r26
   155ca:	fd e4       	ldi	r31, 0x4D	; 77
   155cc:	cf 2e       	mov	r12, r31
   155ce:	f0 e0       	ldi	r31, 0x00	; 0
   155d0:	df 2e       	mov	r13, r31
   155d2:	ed b7       	in	r30, 0x3d	; 61
   155d4:	fe b7       	in	r31, 0x3e	; 62
   155d6:	36 96       	adiw	r30, 0x06	; 6
   155d8:	0f b6       	in	r0, 0x3f	; 63
   155da:	f8 94       	cli
   155dc:	fe bf       	out	0x3e, r31	; 62
   155de:	0f be       	out	0x3f, r0	; 63
   155e0:	ed bf       	out	0x3d, r30	; 61
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   155e2:	e5 e1       	ldi	r30, 0x15	; 21
   155e4:	ae 2e       	mov	r10, r30
   155e6:	b1 2c       	mov	r11, r1
   155e8:	ac 0e       	add	r10, r28
   155ea:	bd 1e       	adc	r11, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   155ec:	48 01       	movw	r8, r16
   155ee:	03 e8       	ldi	r16, 0x83	; 131
   155f0:	12 e2       	ldi	r17, 0x22	; 34
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   155f2:	d7 01       	movw	r26, r14
   155f4:	8c 91       	ld	r24, X
   155f6:	8d 8b       	std	Y+21, r24	; 0x15
   155f8:	11 96       	adiw	r26, 0x01	; 1
   155fa:	8c 91       	ld	r24, X
   155fc:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   155fe:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   15600:	c5 01       	movw	r24, r10
   15602:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   15606:	c5 01       	movw	r24, r10
   15608:	0e 94 3d b5 	call	0x16a7a	; 0x16a7a <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1560c:	e1 99       	sbic	0x1c, 1	; 28
   1560e:	fe cf       	rjmp	.-4      	; 0x1560c <SaveConfigParameter+0x35e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15610:	df ba       	out	0x1f, r13	; 31
   15612:	ce ba       	out	0x1e, r12	; 30
#endif
    EEDR = __value;
   15614:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   15616:	0f b6       	in	r0, 0x3f	; 63
   15618:	f8 94       	cli
   1561a:	e2 9a       	sbi	0x1c, 2	; 28
   1561c:	e1 9a       	sbi	0x1c, 1	; 28
   1561e:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   15620:	00 d0       	rcall	.+0      	; 0x15622 <SaveConfigParameter+0x374>
   15622:	00 d0       	rcall	.+0      	; 0x15624 <SaveConfigParameter+0x376>
   15624:	00 d0       	rcall	.+0      	; 0x15626 <SaveConfigParameter+0x378>
   15626:	ed b7       	in	r30, 0x3d	; 61
   15628:	fe b7       	in	r31, 0x3e	; 62
   1562a:	31 96       	adiw	r30, 0x01	; 1
   1562c:	ad b7       	in	r26, 0x3d	; 61
   1562e:	be b7       	in	r27, 0x3e	; 62
   15630:	11 96       	adiw	r26, 0x01	; 1
   15632:	8c 92       	st	X, r8
   15634:	11 97       	sbiw	r26, 0x01	; 1
   15636:	12 96       	adiw	r26, 0x02	; 2
   15638:	9c 92       	st	X, r9
   1563a:	13 83       	std	Z+3, r17	; 0x03
   1563c:	02 83       	std	Z+2, r16	; 0x02
   1563e:	84 83       	std	Z+4, r24	; 0x04
   15640:	15 82       	std	Z+5, r1	; 0x05
   15642:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
   15646:	e2 e0       	ldi	r30, 0x02	; 2
   15648:	f0 e0       	ldi	r31, 0x00	; 0
   1564a:	ee 0e       	add	r14, r30
   1564c:	ff 1e       	adc	r15, r31
   1564e:	08 94       	sec
   15650:	c1 1c       	adc	r12, r1
   15652:	d1 1c       	adc	r13, r1
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//	 _uart_print(1,1,strSend); 

	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
   15654:	8d b7       	in	r24, 0x3d	; 61
   15656:	9e b7       	in	r25, 0x3e	; 62
   15658:	06 96       	adiw	r24, 0x06	; 6
   1565a:	0f b6       	in	r0, 0x3f	; 63
   1565c:	f8 94       	cli
   1565e:	9e bf       	out	0x3e, r25	; 62
   15660:	0f be       	out	0x3f, r0	; 63
   15662:	8d bf       	out	0x3d, r24	; 61
   15664:	9c ec       	ldi	r25, 0xCC	; 204
   15666:	e9 16       	cp	r14, r25
   15668:	9e e0       	ldi	r25, 0x0E	; 14
   1566a:	f9 06       	cpc	r15, r25
   1566c:	09 f0       	breq	.+2      	; 0x15670 <SaveConfigParameter+0x3c2>
   1566e:	c1 cf       	rjmp	.-126    	; 0x155f2 <SaveConfigParameter+0x344>
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//		 _uart_print(1,1,strSend); 
	 }    
	 _uart_printf(1,1,PSTR("<OK>")); 
   15670:	81 e0       	ldi	r24, 0x01	; 1
   15672:	61 e0       	ldi	r22, 0x01	; 1
   15674:	4e e7       	ldi	r20, 0x7E	; 126
   15676:	52 e2       	ldi	r21, 0x22	; 34
   15678:	0e 94 12 b4 	call	0x16824	; 0x16824 <_uart_printf>
}
   1567c:	ca 5b       	subi	r28, 0xBA	; 186
   1567e:	df 4f       	sbci	r29, 0xFF	; 255
   15680:	0f b6       	in	r0, 0x3f	; 63
   15682:	f8 94       	cli
   15684:	de bf       	out	0x3e, r29	; 62
   15686:	0f be       	out	0x3f, r0	; 63
   15688:	cd bf       	out	0x3d, r28	; 61
   1568a:	cf 91       	pop	r28
   1568c:	df 91       	pop	r29
   1568e:	1f 91       	pop	r17
   15690:	0f 91       	pop	r16
   15692:	ff 90       	pop	r15
   15694:	ef 90       	pop	r14
   15696:	df 90       	pop	r13
   15698:	cf 90       	pop	r12
   1569a:	bf 90       	pop	r11
   1569c:	af 90       	pop	r10
   1569e:	9f 90       	pop	r9
   156a0:	8f 90       	pop	r8
   156a2:	08 95       	ret

000156a4 <systemConfigProtocol>:



void systemConfigProtocol(){
     static char stConfigProtocol=cpWaitSend;
	 switch(stConfigProtocol){
   156a4:	80 91 ad 03 	lds	r24, 0x03AD
   156a8:	81 30       	cpi	r24, 0x01	; 1
   156aa:	c1 f0       	breq	.+48     	; 0x156dc <systemConfigProtocol+0x38>
   156ac:	81 30       	cpi	r24, 0x01	; 1
   156ae:	18 f0       	brcs	.+6      	; 0x156b6 <systemConfigProtocol+0x12>
   156b0:	82 30       	cpi	r24, 0x02	; 2
   156b2:	e9 f4       	brne	.+58     	; 0x156ee <systemConfigProtocol+0x4a>
   156b4:	18 c0       	rjmp	.+48     	; 0x156e6 <systemConfigProtocol+0x42>
	 case cpWaitSend:
	      switch(ConfigCommand){
   156b6:	80 91 c6 01 	lds	r24, 0x01C6
   156ba:	81 30       	cpi	r24, 0x01	; 1
   156bc:	31 f0       	breq	.+12     	; 0x156ca <systemConfigProtocol+0x26>
   156be:	82 30       	cpi	r24, 0x02	; 2
   156c0:	51 f4       	brne	.+20     	; 0x156d6 <systemConfigProtocol+0x32>
		  case CC_SEND_CONFIG:
		       ConfigCommand=CC_NONE;
   156c2:	10 92 c6 01 	sts	0x01C6, r1
			   stConfigProtocol=cpSendingParameter;
   156c6:	81 e0       	ldi	r24, 0x01	; 1
   156c8:	03 c0       	rjmp	.+6      	; 0x156d0 <systemConfigProtocol+0x2c>
		       break;
		  case CC_SAVE_CONFIG:
		       ConfigCommand=CC_NONE;
   156ca:	10 92 c6 01 	sts	0x01C6, r1
			   stConfigProtocol=cpSavingParameter;
   156ce:	82 e0       	ldi	r24, 0x02	; 2
   156d0:	80 93 ad 03 	sts	0x03AD, r24
   156d4:	08 95       	ret
		       break;
          default:
		       ConfigCommand=CC_NONE;
   156d6:	10 92 c6 01 	sts	0x01C6, r1
   156da:	08 95       	ret
		       break;
		  }
	      break;
     case cpSendingParameter:
	      SendConfigParamater();
   156dc:	0e 94 3d a7 	call	0x14e7a	; 0x14e7a <SendConfigParamater>
          stConfigProtocol=cpWaitSend;
   156e0:	10 92 ad 03 	sts	0x03AD, r1
   156e4:	08 95       	ret
	      break;
     case cpSavingParameter:
          SaveConfigParameter();
   156e6:	0e 94 57 a9 	call	0x152ae	; 0x152ae <SaveConfigParameter>
          stConfigProtocol=cpWaitSend;
   156ea:	10 92 ad 03 	sts	0x03AD, r1
   156ee:	08 95       	ret

000156f0 <FMenuIdle>:
	     ProcTimeOut++;
	}
	TimSend++;
}

void FMenuIdle(){
   156f0:	1f 93       	push	r17
	static char stMenuIdle=miInit,KeyPressed=0,KeyChar=0,ButtonID=0,PrintStandaloneResult=PS_NONE;
    //static unsigned int iLoopIdle=0;
	char lcdteks[20];
   

	switch(stMenuIdle){
   156f2:	80 91 bc 03 	lds	r24, 0x03BC
   156f6:	e8 2f       	mov	r30, r24
   156f8:	f0 e0       	ldi	r31, 0x00	; 0
   156fa:	e9 31       	cpi	r30, 0x19	; 25
   156fc:	f1 05       	cpc	r31, r1
   156fe:	08 f0       	brcs	.+2      	; 0x15702 <FMenuIdle+0x12>
   15700:	a6 c1       	rjmp	.+844    	; 0x15a4e <FMenuIdle+0x35e>
   15702:	ec 5e       	subi	r30, 0xEC	; 236
   15704:	fe 4f       	sbci	r31, 0xFE	; 254
   15706:	ee 0f       	add	r30, r30
   15708:	ff 1f       	adc	r31, r31
   1570a:	05 90       	lpm	r0, Z+
   1570c:	f4 91       	lpm	r31, Z+
   1570e:	e0 2d       	mov	r30, r0
   15710:	09 94       	ijmp
	case miInit:
         _scr_idle();
   15712:	0e 94 e6 45 	call	0x8bcc	; 0x8bcc <_scr_idle>
   15716:	62 c1       	rjmp	.+708    	; 0x159dc <FMenuIdle+0x2ec>
		 stMenuIdle=miScan;		
	     break;
	case miScan:
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
   15718:	81 e0       	ldi	r24, 0x01	; 1
   1571a:	0e 94 fe af 	call	0x15ffc	; 0x15ffc <_key_scan>
   1571e:	80 93 bb 03 	sts	0x03BB, r24
		 KeyChar= _key_btn(KeyPressed);       
   15722:	0e 94 5f af 	call	0x15ebe	; 0x15ebe <_key_btn>
   15726:	80 93 ba 03 	sts	0x03BA, r24

		 switch(KeyPressed){
   1572a:	80 91 bb 03 	lds	r24, 0x03BB
   1572e:	8b 3b       	cpi	r24, 0xBB	; 187
   15730:	09 f4       	brne	.+2      	; 0x15734 <FMenuIdle+0x44>
   15732:	94 c0       	rjmp	.+296    	; 0x1585c <FMenuIdle+0x16c>
   15734:	8c 3b       	cpi	r24, 0xBC	; 188
   15736:	70 f4       	brcc	.+28     	; 0x15754 <FMenuIdle+0x64>
   15738:	8b 37       	cpi	r24, 0x7B	; 123
   1573a:	a1 f1       	breq	.+104    	; 0x157a4 <FMenuIdle+0xb4>
   1573c:	8c 37       	cpi	r24, 0x7C	; 124
   1573e:	20 f4       	brcc	.+8      	; 0x15748 <FMenuIdle+0x58>
   15740:	87 37       	cpi	r24, 0x77	; 119
   15742:	09 f0       	breq	.+2      	; 0x15746 <FMenuIdle+0x56>
   15744:	84 c1       	rjmp	.+776    	; 0x15a4e <FMenuIdle+0x35e>
   15746:	38 c0       	rjmp	.+112    	; 0x157b8 <FMenuIdle+0xc8>
   15748:	8d 37       	cpi	r24, 0x7D	; 125
   1574a:	01 f1       	breq	.+64     	; 0x1578c <FMenuIdle+0x9c>
   1574c:	8e 37       	cpi	r24, 0x7E	; 126
   1574e:	09 f0       	breq	.+2      	; 0x15752 <FMenuIdle+0x62>
   15750:	7e c1       	rjmp	.+764    	; 0x15a4e <FMenuIdle+0x35e>
   15752:	12 c0       	rjmp	.+36     	; 0x15778 <FMenuIdle+0x88>
   15754:	8d 3d       	cpi	r24, 0xDD	; 221
   15756:	09 f4       	brne	.+2      	; 0x1575a <FMenuIdle+0x6a>
   15758:	63 c0       	rjmp	.+198    	; 0x15820 <FMenuIdle+0x130>
   1575a:	8e 3d       	cpi	r24, 0xDE	; 222
   1575c:	38 f4       	brcc	.+14     	; 0x1576c <FMenuIdle+0x7c>
   1575e:	8d 3b       	cpi	r24, 0xBD	; 189
   15760:	09 f4       	brne	.+2      	; 0x15764 <FMenuIdle+0x74>
   15762:	6d c0       	rjmp	.+218    	; 0x1583e <FMenuIdle+0x14e>
   15764:	87 3d       	cpi	r24, 0xD7	; 215
   15766:	09 f0       	breq	.+2      	; 0x1576a <FMenuIdle+0x7a>
   15768:	72 c1       	rjmp	.+740    	; 0x15a4e <FMenuIdle+0x35e>
   1576a:	32 c0       	rjmp	.+100    	; 0x157d0 <FMenuIdle+0xe0>
   1576c:	8e 3d       	cpi	r24, 0xDE	; 222
   1576e:	d1 f1       	breq	.+116    	; 0x157e4 <FMenuIdle+0xf4>
   15770:	8d 3e       	cpi	r24, 0xED	; 237
   15772:	09 f0       	breq	.+2      	; 0x15776 <FMenuIdle+0x86>
   15774:	6c c1       	rjmp	.+728    	; 0x15a4e <FMenuIdle+0x35e>
   15776:	45 c0       	rjmp	.+138    	; 0x15802 <FMenuIdle+0x112>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15778:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1577a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1577c:	82 e0       	ldi	r24, 0x02	; 2
   1577e:	90 e0       	ldi	r25, 0x00	; 0
   15780:	90 93 d7 01 	sts	0x01D7, r25
   15784:	80 93 d6 01 	sts	0x01D6, r24
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
   15788:	81 e0       	ldi	r24, 0x01	; 1
   1578a:	1f c0       	rjmp	.+62     	; 0x157ca <FMenuIdle+0xda>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1578c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1578e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15790:	82 e0       	ldi	r24, 0x02	; 2
   15792:	90 e0       	ldi	r25, 0x00	; 0
   15794:	90 93 d7 01 	sts	0x01D7, r25
   15798:	80 93 d6 01 	sts	0x01D6, r24
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
   1579c:	82 e0       	ldi	r24, 0x02	; 2
   1579e:	80 93 b9 03 	sts	0x03B9, r24
   157a2:	53 c1       	rjmp	.+678    	; 0x15a4a <FMenuIdle+0x35a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   157a4:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   157a6:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   157a8:	82 e0       	ldi	r24, 0x02	; 2
   157aa:	90 e0       	ldi	r25, 0x00	; 0
   157ac:	90 93 d7 01 	sts	0x01D7, r25
   157b0:	80 93 d6 01 	sts	0x01D6, r24
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
   157b4:	83 e0       	ldi	r24, 0x03	; 3
   157b6:	09 c0       	rjmp	.+18     	; 0x157ca <FMenuIdle+0xda>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   157b8:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   157ba:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   157bc:	82 e0       	ldi	r24, 0x02	; 2
   157be:	90 e0       	ldi	r25, 0x00	; 0
   157c0:	90 93 d7 01 	sts	0x01D7, r25
   157c4:	80 93 d6 01 	sts	0x01D6, r24

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
   157c8:	84 e0       	ldi	r24, 0x04	; 4
   157ca:	80 93 b9 03 	sts	0x03B9, r24
   157ce:	64 c0       	rjmp	.+200    	; 0x15898 <FMenuIdle+0x1a8>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   157d0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   157d2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   157d4:	82 e0       	ldi	r24, 0x02	; 2
   157d6:	90 e0       	ldi	r25, 0x00	; 0
   157d8:	90 93 d7 01 	sts	0x01D7, r25
   157dc:	80 93 d6 01 	sts	0x01D6, r24
		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
   157e0:	8c e0       	ldi	r24, 0x0C	; 12
   157e2:	33 c1       	rjmp	.+614    	; 0x15a4a <FMenuIdle+0x35a>
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   157e4:	80 91 10 01 	lds	r24, 0x0110
   157e8:	81 30       	cpi	r24, 0x01	; 1
   157ea:	09 f0       	breq	.+2      	; 0x157ee <FMenuIdle+0xfe>
   157ec:	30 c1       	rjmp	.+608    	; 0x15a4e <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   157ee:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   157f0:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   157f2:	82 e0       	ldi	r24, 0x02	; 2
   157f4:	90 e0       	ldi	r25, 0x00	; 0
   157f6:	90 93 d7 01 	sts	0x01D7, r25
   157fa:	80 93 d6 01 	sts	0x01D6, r24
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   157fe:	80 e1       	ldi	r24, 0x10	; 16
   15800:	24 c1       	rjmp	.+584    	; 0x15a4a <FMenuIdle+0x35a>
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   15802:	80 91 10 01 	lds	r24, 0x0110
   15806:	81 30       	cpi	r24, 0x01	; 1
   15808:	09 f0       	breq	.+2      	; 0x1580c <FMenuIdle+0x11c>
   1580a:	21 c1       	rjmp	.+578    	; 0x15a4e <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1580c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1580e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15810:	82 e0       	ldi	r24, 0x02	; 2
   15812:	90 e0       	ldi	r25, 0x00	; 0
   15814:	90 93 d7 01 	sts	0x01D7, r25
   15818:	80 93 d6 01 	sts	0x01D6, r24
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   1581c:	82 e1       	ldi	r24, 0x12	; 18
   1581e:	15 c1       	rjmp	.+554    	; 0x15a4a <FMenuIdle+0x35a>
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   15820:	80 91 10 01 	lds	r24, 0x0110
   15824:	81 30       	cpi	r24, 0x01	; 1
   15826:	09 f0       	breq	.+2      	; 0x1582a <FMenuIdle+0x13a>
   15828:	12 c1       	rjmp	.+548    	; 0x15a4e <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1582a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1582c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1582e:	82 e0       	ldi	r24, 0x02	; 2
   15830:	90 e0       	ldi	r25, 0x00	; 0
   15832:	90 93 d7 01 	sts	0x01D7, r25
   15836:	80 93 d6 01 	sts	0x01D6, r24
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   1583a:	81 e1       	ldi	r24, 0x11	; 17
   1583c:	06 c1       	rjmp	.+524    	; 0x15a4a <FMenuIdle+0x35a>
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   1583e:	80 91 10 01 	lds	r24, 0x0110
   15842:	81 30       	cpi	r24, 0x01	; 1
   15844:	09 f0       	breq	.+2      	; 0x15848 <FMenuIdle+0x158>
   15846:	03 c1       	rjmp	.+518    	; 0x15a4e <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15848:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1584a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1584c:	82 e0       	ldi	r24, 0x02	; 2
   1584e:	90 e0       	ldi	r25, 0x00	; 0
   15850:	90 93 d7 01 	sts	0x01D7, r25
   15854:	80 93 d6 01 	sts	0x01D6, r24
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   15858:	8f e0       	ldi	r24, 0x0F	; 15
   1585a:	f7 c0       	rjmp	.+494    	; 0x15a4a <FMenuIdle+0x35a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1585c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1585e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15860:	82 e0       	ldi	r24, 0x02	; 2
   15862:	90 e0       	ldi	r25, 0x00	; 0
   15864:	90 93 d7 01 	sts	0x01D7, r25
   15868:	80 93 d6 01 	sts	0x01D6, r24
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
		 //case _KEY_8:    system_beep(2);           stMenuIdle=miRunTestChar;   break;
		 case _KEY_9:    system_beep(2);stMenuIdle=miRunAuth;      break;
   1586c:	8d e0       	ldi	r24, 0x0D	; 13
   1586e:	ed c0       	rjmp	.+474    	; 0x15a4a <FMenuIdle+0x35a>
		 }
	     break;
    case miTestMsg56:
	     sprintf_P(strCardID,PSTR("4356A31A"));
   15870:	00 d0       	rcall	.+0      	; 0x15872 <FMenuIdle+0x182>
   15872:	00 d0       	rcall	.+0      	; 0x15874 <FMenuIdle+0x184>
   15874:	8f ee       	ldi	r24, 0xEF	; 239
   15876:	9e e0       	ldi	r25, 0x0E	; 14
   15878:	ed b7       	in	r30, 0x3d	; 61
   1587a:	fe b7       	in	r31, 0x3e	; 62
   1587c:	92 83       	std	Z+2, r25	; 0x02
   1587e:	81 83       	std	Z+1, r24	; 0x01
   15880:	87 ea       	ldi	r24, 0xA7	; 167
   15882:	93 e2       	ldi	r25, 0x23	; 35
   15884:	94 83       	std	Z+4, r25	; 0x04
   15886:	83 83       	std	Z+3, r24	; 0x03
   15888:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <sprintf_P>
	     sendMessage56();
   1588c:	0f 90       	pop	r0
   1588e:	0f 90       	pop	r0
   15890:	0f 90       	pop	r0
   15892:	0f 90       	pop	r0
   15894:	0e 94 55 9c 	call	0x138aa	; 0x138aa <sendMessage56>
         stMenuIdle=miDisplayProses;
   15898:	82 e0       	ldi	r24, 0x02	; 2
   1589a:	d7 c0       	rjmp	.+430    	; 0x15a4a <FMenuIdle+0x35a>
	     break;
	case miDisplayProses:
	     if (IsBusyIdlePrinting==False){
   1589c:	80 91 c8 01 	lds	r24, 0x01C8
   158a0:	88 23       	and	r24, r24
   158a2:	09 f0       	breq	.+2      	; 0x158a6 <FMenuIdle+0x1b6>
   158a4:	9b c0       	rjmp	.+310    	; 0x159dc <FMenuIdle+0x2ec>
		     lcd_printf(3,1,PSTR("SedangProses"));
   158a6:	83 e0       	ldi	r24, 0x03	; 3
   158a8:	61 e0       	ldi	r22, 0x01	; 1
   158aa:	4a e9       	ldi	r20, 0x9A	; 154
   158ac:	53 e2       	ldi	r21, 0x23	; 35
   158ae:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	         TimDisplay=0;
   158b2:	10 92 a7 01 	sts	0x01A7, r1
			 stMenuIdle=miWaitProses;
   158b6:	83 e0       	ldi	r24, 0x03	; 3
   158b8:	c8 c0       	rjmp	.+400    	; 0x15a4a <FMenuIdle+0x35a>
         }else stMenuIdle=miScan;
	     break;
    case miWaitProses:
	     if (TimDisplay>1){
   158ba:	80 91 a7 01 	lds	r24, 0x01A7
   158be:	82 30       	cpi	r24, 0x02	; 2
   158c0:	08 f4       	brcc	.+2      	; 0x158c4 <FMenuIdle+0x1d4>
   158c2:	c5 c0       	rjmp	.+394    	; 0x15a4e <FMenuIdle+0x35e>
		     if (IFType==IT_SLAVE)stMenuIdle=miSendMessage98;
   158c4:	80 91 10 01 	lds	r24, 0x0110
   158c8:	81 30       	cpi	r24, 0x01	; 1
   158ca:	11 f4       	brne	.+4      	; 0x158d0 <FMenuIdle+0x1e0>
   158cc:	84 e0       	ldi	r24, 0x04	; 4
   158ce:	bd c0       	rjmp	.+378    	; 0x15a4a <FMenuIdle+0x35a>
			 else
		     if (IFType==IT_STANDALONE)stMenuIdle=miPrintStandalone;
   158d0:	82 30       	cpi	r24, 0x02	; 2
   158d2:	09 f0       	breq	.+2      	; 0x158d6 <FMenuIdle+0x1e6>
   158d4:	bc c0       	rjmp	.+376    	; 0x15a4e <FMenuIdle+0x35e>
   158d6:	87 e0       	ldi	r24, 0x07	; 7
   158d8:	b8 c0       	rjmp	.+368    	; 0x15a4a <FMenuIdle+0x35a>
		 }
	     break;
    case miPrintStandalone:
	     PrintStandaloneResult=PrintStandalone(ButtonID,False);
   158da:	80 91 b9 03 	lds	r24, 0x03B9
   158de:	60 e0       	ldi	r22, 0x00	; 0
   158e0:	0e 94 93 21 	call	0x4326	; 0x4326 <PrintStandalone>
   158e4:	80 93 5d 01 	sts	0x015D, r24
	     if (PrintStandaloneResult==PS_PRINTED)stMenuIdle=miReady;
   158e8:	81 31       	cpi	r24, 0x11	; 17
   158ea:	09 f4       	brne	.+2      	; 0x158ee <FMenuIdle+0x1fe>
   158ec:	ad c0       	rjmp	.+346    	; 0x15a48 <FMenuIdle+0x358>
		 else
		 if (PrintStandaloneResult==PS_NO_DATA)stMenuIdle=miDisplayNoTransaction;
   158ee:	82 31       	cpi	r24, 0x12	; 18
   158f0:	09 f0       	breq	.+2      	; 0x158f4 <FMenuIdle+0x204>
   158f2:	ad c0       	rjmp	.+346    	; 0x15a4e <FMenuIdle+0x35e>
   158f4:	88 e0       	ldi	r24, 0x08	; 8
   158f6:	a9 c0       	rjmp	.+338    	; 0x15a4a <FMenuIdle+0x35a>
	     break;
    case miDisplayNoTransaction:
	     lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   158f8:	83 e0       	ldi	r24, 0x03	; 3
   158fa:	61 e0       	ldi	r22, 0x01	; 1
   158fc:	45 e8       	ldi	r20, 0x85	; 133
   158fe:	53 e2       	ldi	r21, 0x23	; 35
   15900:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
         TimDisplay=0;
   15904:	10 92 a7 01 	sts	0x01A7, r1
		 stMenuIdle=miWaitDisplayNoTransaction;
   15908:	89 e0       	ldi	r24, 0x09	; 9
   1590a:	9f c0       	rjmp	.+318    	; 0x15a4a <FMenuIdle+0x35a>
	     break;
    case miWaitDisplayNoTransaction:
	     if (TimDisplay>1){
   1590c:	80 91 a7 01 	lds	r24, 0x01A7
   15910:	82 30       	cpi	r24, 0x02	; 2
   15912:	08 f4       	brcc	.+2      	; 0x15916 <FMenuIdle+0x226>
   15914:	9c c0       	rjmp	.+312    	; 0x15a4e <FMenuIdle+0x35e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   15916:	83 e0       	ldi	r24, 0x03	; 3
   15918:	61 e0       	ldi	r22, 0x01	; 1
   1591a:	40 e7       	ldi	r20, 0x70	; 112
   1591c:	53 e2       	ldi	r21, 0x23	; 35
   1591e:	36 c0       	rjmp	.+108    	; 0x1598c <FMenuIdle+0x29c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
		 }
	     break;
    case miSendMessage98:
	     lcd_printf(3,1,PSTR("Please Wait..       "));
   15920:	83 e0       	ldi	r24, 0x03	; 3
   15922:	61 e0       	ldi	r22, 0x01	; 1
   15924:	4b e5       	ldi	r20, 0x5B	; 91
   15926:	53 e2       	ldi	r21, 0x23	; 35
   15928:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	     sendMessage98(ButtonID);
   1592c:	80 91 b9 03 	lds	r24, 0x03B9
   15930:	0e 94 db 4d 	call	0x9bb6	; 0x9bb6 <sendMessage98>
		 ProcTimeOut=0;
   15934:	10 92 d9 01 	sts	0x01D9, r1
   15938:	10 92 d8 01 	sts	0x01D8, r1
		 stMenuIdle=miWaitPlease;
   1593c:	85 e0       	ldi	r24, 0x05	; 5
   1593e:	85 c0       	rjmp	.+266    	; 0x15a4a <FMenuIdle+0x35a>
	     break;
    case miWaitPlease:
         if (ProcTimeOut>TIM_NO_RESPONSE){
   15940:	80 91 d8 01 	lds	r24, 0x01D8
   15944:	90 91 d9 01 	lds	r25, 0x01D9
   15948:	0f 97       	sbiw	r24, 0x0f	; 15
   1594a:	58 f0       	brcs	.+22     	; 0x15962 <FMenuIdle+0x272>
	         lcd_printf(3,1,PSTR("No Response..       "));
   1594c:	83 e0       	ldi	r24, 0x03	; 3
   1594e:	61 e0       	ldi	r22, 0x01	; 1
   15950:	46 e4       	ldi	r20, 0x46	; 70
   15952:	53 e2       	ldi	r21, 0x23	; 35
   15954:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		     stMenuIdle=miNoResponse;
   15958:	86 e0       	ldi	r24, 0x06	; 6
   1595a:	80 93 bc 03 	sts	0x03BC, r24
			 TimDisplay=0;		 
   1595e:	10 92 a7 01 	sts	0x01A7, r1
		 }
		 if ((IsMessage99==True)||(IsMessage00==True)){
   15962:	80 91 b6 01 	lds	r24, 0x01B6
   15966:	81 30       	cpi	r24, 0x01	; 1
   15968:	29 f0       	breq	.+10     	; 0x15974 <FMenuIdle+0x284>
   1596a:	80 91 b5 01 	lds	r24, 0x01B5
   1596e:	81 30       	cpi	r24, 0x01	; 1
   15970:	09 f0       	breq	.+2      	; 0x15974 <FMenuIdle+0x284>
   15972:	6d c0       	rjmp	.+218    	; 0x15a4e <FMenuIdle+0x35e>
		     ClearMem(strOdometer);
   15974:	83 ea       	ldi	r24, 0xA3	; 163
   15976:	95 e0       	ldi	r25, 0x05	; 5
   15978:	0e 94 f9 ae 	call	0x15df2	; 0x15df2 <ClearMem>
		     ClearMem(strLicPlate);
   1597c:	80 e6       	ldi	r24, 0x60	; 96
   1597e:	9c e0       	ldi	r25, 0x0C	; 12
   15980:	0e 94 f9 ae 	call	0x15df2	; 0x15df2 <ClearMem>
	         lcd_printf(3,1,PSTR("Ready...            "));
   15984:	83 e0       	ldi	r24, 0x03	; 3
   15986:	61 e0       	ldi	r22, 0x01	; 1
   15988:	41 e3       	ldi	r20, 0x31	; 49
   1598a:	53 e2       	ldi	r21, 0x23	; 35
   1598c:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		     stMenuIdle=miWaitReady;
   15990:	8a e0       	ldi	r24, 0x0A	; 10
   15992:	80 93 bc 03 	sts	0x03BC, r24
			 TimDisplay=0;
   15996:	10 92 a7 01 	sts	0x01A7, r1
   1599a:	59 c0       	rjmp	.+178    	; 0x15a4e <FMenuIdle+0x35e>
			 }
	     break;
    case miNoResponse:
         if (TimDisplay>1){
   1599c:	80 91 a7 01 	lds	r24, 0x01A7
   159a0:	82 30       	cpi	r24, 0x02	; 2
   159a2:	08 f4       	brcc	.+2      	; 0x159a6 <FMenuIdle+0x2b6>
   159a4:	54 c0       	rjmp	.+168    	; 0x15a4e <FMenuIdle+0x35e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   159a6:	83 e0       	ldi	r24, 0x03	; 3
   159a8:	61 e0       	ldi	r22, 0x01	; 1
   159aa:	4c e1       	ldi	r20, 0x1C	; 28
   159ac:	53 e2       	ldi	r21, 0x23	; 35
   159ae:	ee cf       	rjmp	.-36     	; 0x1598c <FMenuIdle+0x29c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
			 }	     
	     break;
    case miWaitReady:
         if (TimDisplay>1){
   159b0:	80 91 a7 01 	lds	r24, 0x01A7
   159b4:	82 30       	cpi	r24, 0x02	; 2
   159b6:	08 f4       	brcc	.+2      	; 0x159ba <FMenuIdle+0x2ca>
   159b8:	4a c0       	rjmp	.+148    	; 0x15a4e <FMenuIdle+0x35e>
	         lcd_printf(3,1,PSTR("                "));
   159ba:	83 e0       	ldi	r24, 0x03	; 3
   159bc:	61 e0       	ldi	r22, 0x01	; 1
   159be:	4b e0       	ldi	r20, 0x0B	; 11
   159c0:	53 e2       	ldi	r21, 0x23	; 35
   159c2:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		     stMenuIdle=miReady;
   159c6:	8b e0       	ldi	r24, 0x0B	; 11
   159c8:	e4 cf       	rjmp	.-56     	; 0x15992 <FMenuIdle+0x2a2>
			 TimDisplay=0;
			 }	     
	     break;
    case miReady:
	     _scr_idle();
   159ca:	0e 94 e6 45 	call	0x8bcc	; 0x8bcc <_scr_idle>
		 if (IFType==IT_STANDALONE)IsNewPumpStatus=True;
   159ce:	80 91 10 01 	lds	r24, 0x0110
   159d2:	82 30       	cpi	r24, 0x02	; 2
   159d4:	19 f4       	brne	.+6      	; 0x159dc <FMenuIdle+0x2ec>
   159d6:	81 e0       	ldi	r24, 0x01	; 1
   159d8:	80 93 11 01 	sts	0x0111, r24
		 stMenuIdle=miScan;
   159dc:	81 e0       	ldi	r24, 0x01	; 1
   159de:	35 c0       	rjmp	.+106    	; 0x15a4a <FMenuIdle+0x35a>
	     break;
	case miRunTicket://Slave,Standalone
		 if (FMenuTicket()==MENU_DONE)
   159e0:	0e 94 a7 85 	call	0x10b4e	; 0x10b4e <FMenuTicket>
   159e4:	2f c0       	rjmp	.+94     	; 0x15a44 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
	case miRunAuth://Slave,Standalone
		 if (FMenuAuthorization()==MENU_DONE)
   159e6:	0e 94 66 9b 	call	0x136cc	; 0x136cc <FMenuAuthorization>
   159ea:	2c c0       	rjmp	.+88     	; 0x15a44 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
		 
    case miRunLocalAccount://Slave
		 if (FMenuLocalAccount()==MENU_DONE)
   159ec:	0e 94 ff 9c 	call	0x139fe	; 0x139fe <FMenuLocalAccount>
   159f0:	29 c0       	rjmp	.+82     	; 0x15a44 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;  
    case miRunChangeMOP://Slave
	     if (FMenuChangeMOP()==MENU_DONE)
   159f2:	0e 94 6a 94 	call	0x128d4	; 0x128d4 <FMenuChangeMOP>
   159f6:	26 c0       	rjmp	.+76     	; 0x15a44 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miRunEDC://Slave
	     if (FMenuEDCTransaction()==MENU_DONE)
   159f8:	0e 94 7e 66 	call	0xccfc	; 0xccfc <FMenuEDCTransaction>
   159fc:	23 c0       	rjmp	.+70     	; 0x15a44 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
         break;
    case miRunLoyalty://Slave
	     if (FMenuLoyalty()==MENU_DONE)
   159fe:	0e 94 72 67 	call	0xcee4	; 0xcee4 <FMenuLoyalty>
   15a02:	20 c0       	rjmp	.+64     	; 0x15a44 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miRunReprint://Slave,Standalone
	     if (FMenuReprint()==MENU_DONE)
   15a04:	0e 94 bf 92 	call	0x1257e	; 0x1257e <FMenuReprint>
   15a08:	1d c0       	rjmp	.+58     	; 0x15a44 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miRunViewFreeMessage://Slave
	     if (FViewFreeMessage()==MENU_DONE)
   15a0a:	0e 94 ac 45 	call	0x8b58	; 0x8b58 <FViewFreeMessage>
   15a0e:	1a c0       	rjmp	.+52     	; 0x15a44 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miClearTotalizer://Standalone
	     lcd_printf(3,1,PSTR("Clear Data Totalizer"));
   15a10:	83 e0       	ldi	r24, 0x03	; 3
   15a12:	61 e0       	ldi	r22, 0x01	; 1
   15a14:	46 ef       	ldi	r20, 0xF6	; 246
   15a16:	52 e2       	ldi	r21, 0x22	; 34
   15a18:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	     ResetTotalizer(TOTALIZER_LAST);
   15a1c:	80 e0       	ldi	r24, 0x00	; 0
   15a1e:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <ResetTotalizer>
         ResetTotalizer(TOTALIZER_NOW);
   15a22:	81 e0       	ldi	r24, 0x01	; 1
   15a24:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <ResetTotalizer>
   15a28:	0f c0       	rjmp	.+30     	; 0x15a48 <FMenuIdle+0x358>
         stMenuIdle=miReady;	      
	     break;
    case miRunTotalizer://Standalone
	     lcd_printf(3,1,PSTR("TotalizerAll     "));
   15a2a:	83 e0       	ldi	r24, 0x03	; 3
   15a2c:	61 e0       	ldi	r22, 0x01	; 1
   15a2e:	44 ee       	ldi	r20, 0xE4	; 228
   15a30:	52 e2       	ldi	r21, 0x22	; 34
   15a32:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
	     SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);
   15a36:	85 e0       	ldi	r24, 0x05	; 5
   15a38:	62 e1       	ldi	r22, 0x12	; 18
   15a3a:	0e 94 da 73 	call	0xe7b4	; 0xe7b4 <SendSlaveCommand>
   15a3e:	04 c0       	rjmp	.+8      	; 0x15a48 <FMenuIdle+0x358>
		 stMenuIdle=miReady;	      
	     break;
    case miRunTestChar:	     
 	     if (FTestChar()==MENU_DONE)
   15a40:	0e 94 ef 44 	call	0x89de	; 0x89de <FTestChar>
   15a44:	81 30       	cpi	r24, 0x01	; 1
   15a46:	19 f4       	brne	.+6      	; 0x15a4e <FMenuIdle+0x35e>
         stMenuIdle=miReady;
   15a48:	8b e0       	ldi	r24, 0x0B	; 11
   15a4a:	80 93 bc 03 	sts	0x03BC, r24
	     break;
	}
//----------SYSTEM_PROC--------------------------------

        //Bank InfoUpdated
        if (IsMessage21==True){
   15a4e:	80 91 b8 01 	lds	r24, 0x01B8
   15a52:	81 30       	cpi	r24, 0x01	; 1
   15a54:	21 f4       	brne	.+8      	; 0x15a5e <FMenuIdle+0x36e>
		    IsMessage21=False;
   15a56:	10 92 b8 01 	sts	0x01B8, r1
			procMessage21();
   15a5a:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <procMessage21>

        }
        //Transaction Status
        if (IsMessage00==True){
   15a5e:	80 91 b5 01 	lds	r24, 0x01B5
   15a62:	81 30       	cpi	r24, 0x01	; 1
   15a64:	91 f4       	brne	.+36     	; 0x15a8a <FMenuIdle+0x39a>
		    IsMessage00=False;
   15a66:	10 92 b5 01 	sts	0x01B5, r1
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   15a6a:	20 91 83 0c 	lds	r18, 0x0C83
   15a6e:	21 30       	cpi	r18, 0x01	; 1
   15a70:	61 f4       	brne	.+24     	; 0x15a8a <FMenuIdle+0x39a>
   15a72:	80 91 9e 01 	lds	r24, 0x019E
   15a76:	90 91 9f 01 	lds	r25, 0x019F
   15a7a:	8f 97       	sbiw	r24, 0x2f	; 47
   15a7c:	31 f4       	brne	.+12     	; 0x15a8a <FMenuIdle+0x39a>

        }
        //Transaction Status
        if (IsMessage00==True){
		    IsMessage00=False;
			if (procMessage00()==MSG00_NO_PRINT){
   15a7e:	80 91 a8 0c 	lds	r24, 0x0CA8
   15a82:	84 33       	cpi	r24, 0x34	; 52
   15a84:	11 f4       	brne	.+4      	; 0x15a8a <FMenuIdle+0x39a>
			    IsNoTransaction=True;
   15a86:	20 93 c2 01 	sts	0x01C2, r18
				}
		}
  
		//Send EDC Message Information;
		if (IsSendMessageEDC==True){
   15a8a:	80 91 ae 01 	lds	r24, 0x01AE
   15a8e:	81 30       	cpi	r24, 0x01	; 1
   15a90:	21 f4       	brne	.+8      	; 0x15a9a <FMenuIdle+0x3aa>
		    IsSendMessageEDC=False;
   15a92:	10 92 ae 01 	sts	0x01AE, r1
			SendEDCMessage();
   15a96:	0e 94 55 73 	call	0xe6aa	; 0xe6aa <SendEDCMessage>
		}
		if (IsEDCApproved==True){
   15a9a:	80 91 b0 01 	lds	r24, 0x01B0
   15a9e:	81 30       	cpi	r24, 0x01	; 1
   15aa0:	21 f4       	brne	.+8      	; 0x15aaa <FMenuIdle+0x3ba>
		    IsEDCApproved=False;
   15aa2:	10 92 b0 01 	sts	0x01B0, r1
            sendMessage92();
   15aa6:	0e 94 03 4f 	call	0x9e06	; 0x9e06 <sendMessage92>
		}
		if (IsVoidTransaction==True){
   15aaa:	80 91 b2 01 	lds	r24, 0x01B2
   15aae:	81 30       	cpi	r24, 0x01	; 1
   15ab0:	21 f4       	brne	.+8      	; 0x15aba <FMenuIdle+0x3ca>
		    IsVoidTransaction=False;
   15ab2:	10 92 b2 01 	sts	0x01B2, r1
            sendMessage94();
   15ab6:	0e 94 5c 4e 	call	0x9cb8	; 0x9cb8 <sendMessage94>
		}


        //Message99 Detection 
        if (IsMessage99==True){
   15aba:	10 91 b6 01 	lds	r17, 0x01B6
   15abe:	11 30       	cpi	r17, 0x01	; 1
   15ac0:	31 f4       	brne	.+12     	; 0x15ace <FMenuIdle+0x3de>
	        IsMessage99=False;
   15ac2:	10 92 b6 01 	sts	0x01B6, r1
		    procMessage99();
   15ac6:	0e 94 97 42 	call	0x852e	; 0x852e <procMessage99>
		    IsPrinting=True;
   15aca:	10 93 c3 01 	sts	0x01C3, r17
		}
		//No Transaction
		if (IsNoTransaction==True){
   15ace:	80 91 c2 01 	lds	r24, 0x01C2
   15ad2:	81 30       	cpi	r24, 0x01	; 1
   15ad4:	41 f4       	brne	.+16     	; 0x15ae6 <FMenuIdle+0x3f6>
			IsNoTransaction=False;
   15ad6:	10 92 c2 01 	sts	0x01C2, r1
			lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   15ada:	83 e0       	ldi	r24, 0x03	; 3
   15adc:	61 e0       	ldi	r22, 0x01	; 1
   15ade:	4f ec       	ldi	r20, 0xCF	; 207
   15ae0:	52 e2       	ldi	r21, 0x22	; 34
   15ae2:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
		}
        
		//Display Idle
		if (stMenuIdle==miScan){//||(stMenuIdle=miWaitPlease)){ 
   15ae6:	80 91 bc 03 	lds	r24, 0x03BC
   15aea:	81 30       	cpi	r24, 0x01	; 1
   15aec:	11 f4       	brne	.+4      	; 0x15af2 <FMenuIdle+0x402>
		    DisplayIdle();			
   15aee:	0e 94 e9 71 	call	0xe3d2	; 0xe3d2 <DisplayIdle>
			}        

        //Display FreeMessage
		if (stMenuIdle==miScan){ 
   15af2:	80 91 bc 03 	lds	r24, 0x03BC
   15af6:	81 30       	cpi	r24, 0x01	; 1
   15af8:	59 f4       	brne	.+22     	; 0x15b10 <FMenuIdle+0x420>
		    if (IsMessage09==True){
   15afa:	80 91 ba 01 	lds	r24, 0x01BA
   15afe:	81 30       	cpi	r24, 0x01	; 1
   15b00:	39 f4       	brne	.+14     	; 0x15b10 <FMenuIdle+0x420>
			    IsMessage09=False;
   15b02:	10 92 ba 01 	sts	0x01BA, r1
				procMessage09();
   15b06:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <procMessage09>
				stMenuIdle=miRunViewFreeMessage;
   15b0a:	83 e1       	ldi	r24, 0x13	; 19
   15b0c:	80 93 bc 03 	sts	0x03BC, r24
			   }
			}

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
   15b10:	80 91 bc 03 	lds	r24, 0x03BC
   15b14:	81 30       	cpi	r24, 0x01	; 1
   15b16:	89 f4       	brne	.+34     	; 0x15b3a <FMenuIdle+0x44a>
   15b18:	80 91 af 01 	lds	r24, 0x01AF
   15b1c:	81 30       	cpi	r24, 0x01	; 1
   15b1e:	69 f4       	brne	.+26     	; 0x15b3a <FMenuIdle+0x44a>
		    IsRFIDDetected=False;
   15b20:	10 92 af 01 	sts	0x01AF, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15b24:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15b26:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15b28:	82 e0       	ldi	r24, 0x02	; 2
   15b2a:	90 e0       	ldi	r25, 0x00	; 0
   15b2c:	90 93 d7 01 	sts	0x01D7, r25
   15b30:	80 93 d6 01 	sts	0x01D6, r24

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
		    IsRFIDDetected=False;
		    system_beep(2);           
			stMenuIdle=miRunLocalAccount;
   15b34:	8e e0       	ldi	r24, 0x0E	; 14
   15b36:	80 93 bc 03 	sts	0x03BC, r24
		}
        //Print Spooling
		if (IsMessage81==True){
   15b3a:	10 91 bd 01 	lds	r17, 0x01BD
   15b3e:	11 30       	cpi	r17, 0x01	; 1
   15b40:	41 f4       	brne	.+16     	; 0x15b52 <FMenuIdle+0x462>
		    IsMessage81=False;
   15b42:	10 92 bd 01 	sts	0x01BD, r1
			//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
			cmdPrint=procMessage81();
   15b46:	0e 94 32 18 	call	0x3064	; 0x3064 <procMessage81>
   15b4a:	80 93 cb 01 	sts	0x01CB, r24
			IsFreePrinting=True;
   15b4e:	10 93 bf 01 	sts	0x01BF, r17
         }

    //SystemService
      systemGenerateReport();
   15b52:	0e 94 1e 35 	call	0x6a3c	; 0x6a3c <systemGenerateReport>
      systemPrinting();
   15b56:	0e 94 5c 5e 	call	0xbcb8	; 0xbcb8 <systemPrinting>
	  systemEDC();
	  systemConfigProtocol();
   15b5a:	0e 94 52 ab 	call	0x156a4	; 0x156a4 <systemConfigProtocol>
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}
   15b5e:	1f 91       	pop	r17
   15b60:	08 95       	ret

00015b62 <lcd_command>:
	lcd_command(0x0c);
	lcd_command(0x06);
}

void lcd_command(unsigned char __chr){
	_LCD_PORT = __chr & 0xF0;
   15b62:	98 2f       	mov	r25, r24
   15b64:	90 7f       	andi	r25, 0xF0	; 240
   15b66:	95 bb       	out	0x15, r25	; 21
	cbi(_LCD_PORT, _LCD_RS);
   15b68:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15b6a:	a9 9a       	sbi	0x15, 1	; 21
   15b6c:	48 ee       	ldi	r20, 0xE8	; 232
   15b6e:	53 e0       	ldi	r21, 0x03	; 3
   15b70:	fa 01       	movw	r30, r20
   15b72:	31 97       	sbiw	r30, 0x01	; 1
   15b74:	f1 f7       	brne	.-4      	; 0x15b72 <lcd_command+0x10>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15b76:	a9 98       	cbi	0x15, 1	; 21
   15b78:	fa 01       	movw	r30, r20
   15b7a:	31 97       	sbiw	r30, 0x01	; 1
   15b7c:	f1 f7       	brne	.-4      	; 0x15b7a <lcd_command+0x18>
	_LCD_BUSY;

	_LCD_PORT = (__chr & 0x0F) << 4;
   15b7e:	28 2f       	mov	r18, r24
   15b80:	30 e0       	ldi	r19, 0x00	; 0
   15b82:	94 e0       	ldi	r25, 0x04	; 4
   15b84:	22 0f       	add	r18, r18
   15b86:	33 1f       	adc	r19, r19
   15b88:	9a 95       	dec	r25
   15b8a:	e1 f7       	brne	.-8      	; 0x15b84 <lcd_command+0x22>
   15b8c:	25 bb       	out	0x15, r18	; 21
	cbi(_LCD_PORT, _LCD_RS);
   15b8e:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15b90:	a9 9a       	sbi	0x15, 1	; 21
   15b92:	fa 01       	movw	r30, r20
   15b94:	31 97       	sbiw	r30, 0x01	; 1
   15b96:	f1 f7       	brne	.-4      	; 0x15b94 <lcd_command+0x32>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15b98:	a9 98       	cbi	0x15, 1	; 21
   15b9a:	fa 01       	movw	r30, r20
   15b9c:	31 97       	sbiw	r30, 0x01	; 1
   15b9e:	f1 f7       	brne	.-4      	; 0x15b9c <lcd_command+0x3a>
	_LCD_BUSY;
	_LCD_BUSY;
	if (__chr==0x01) _delay_ms(50);
   15ba0:	fa 01       	movw	r30, r20
   15ba2:	31 97       	sbiw	r30, 0x01	; 1
   15ba4:	f1 f7       	brne	.-4      	; 0x15ba2 <lcd_command+0x40>
   15ba6:	81 30       	cpi	r24, 0x01	; 1
   15ba8:	21 f4       	brne	.+8      	; 0x15bb2 <lcd_command+0x50>
   15baa:	84 ed       	ldi	r24, 0xD4	; 212
   15bac:	90 e3       	ldi	r25, 0x30	; 48
   15bae:	01 97       	sbiw	r24, 0x01	; 1
   15bb0:	f1 f7       	brne	.-4      	; 0x15bae <lcd_command+0x4c>
   15bb2:	08 95       	ret

00015bb4 <lcd_init>:
   15bb4:	86 ea       	ldi	r24, 0xA6	; 166
   15bb6:	9e e0       	ldi	r25, 0x0E	; 14
   15bb8:	01 97       	sbiw	r24, 0x01	; 1
   15bba:	f1 f7       	brne	.-4      	; 0x15bb8 <lcd_init+0x4>

#define _LCD_BUSY	_delay_ms(4);

void lcd_init(void){
	_delay_ms(15);
	_LCD_PORT = 0x00;
   15bbc:	15 ba       	out	0x15, r1	; 21
	_LCD_DDR |= (1 << _LCD_D7) | (1 << _LCD_D6) | (1 << _LCD_D5) | (1 << _LCD_D4);
   15bbe:	84 b3       	in	r24, 0x14	; 20
   15bc0:	80 6f       	ori	r24, 0xF0	; 240
   15bc2:	84 bb       	out	0x14, r24	; 20
	_LCD_DDR |= (1 << _LCD_E) | (1 << _LCD_RW) | (1 << _LCD_RS);
   15bc4:	84 b3       	in	r24, 0x14	; 20
   15bc6:	8e 60       	ori	r24, 0x0E	; 14
   15bc8:	84 bb       	out	0x14, r24	; 20

	_LCD_PORT = 0x30;
   15bca:	20 e3       	ldi	r18, 0x30	; 48
   15bcc:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15bce:	a9 9a       	sbi	0x15, 1	; 21
   15bd0:	88 ee       	ldi	r24, 0xE8	; 232
   15bd2:	93 e0       	ldi	r25, 0x03	; 3
   15bd4:	fc 01       	movw	r30, r24
   15bd6:	31 97       	sbiw	r30, 0x01	; 1
   15bd8:	f1 f7       	brne	.-4      	; 0x15bd6 <lcd_init+0x22>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15bda:	a9 98       	cbi	0x15, 1	; 21
   15bdc:	fc 01       	movw	r30, r24
   15bde:	31 97       	sbiw	r30, 0x01	; 1
   15be0:	f1 f7       	brne	.-4      	; 0x15bde <lcd_init+0x2a>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   15be2:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15be4:	a9 9a       	sbi	0x15, 1	; 21
   15be6:	fc 01       	movw	r30, r24
   15be8:	31 97       	sbiw	r30, 0x01	; 1
   15bea:	f1 f7       	brne	.-4      	; 0x15be8 <lcd_init+0x34>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15bec:	a9 98       	cbi	0x15, 1	; 21
   15bee:	fc 01       	movw	r30, r24
   15bf0:	31 97       	sbiw	r30, 0x01	; 1
   15bf2:	f1 f7       	brne	.-4      	; 0x15bf0 <lcd_init+0x3c>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   15bf4:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15bf6:	a9 9a       	sbi	0x15, 1	; 21
   15bf8:	fc 01       	movw	r30, r24
   15bfa:	31 97       	sbiw	r30, 0x01	; 1
   15bfc:	f1 f7       	brne	.-4      	; 0x15bfa <lcd_init+0x46>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15bfe:	a9 98       	cbi	0x15, 1	; 21
   15c00:	fc 01       	movw	r30, r24
   15c02:	31 97       	sbiw	r30, 0x01	; 1
   15c04:	f1 f7       	brne	.-4      	; 0x15c02 <lcd_init+0x4e>
	_LCD_BUSY;

	_LCD_PORT = 0x20;
   15c06:	20 e2       	ldi	r18, 0x20	; 32
   15c08:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15c0a:	a9 9a       	sbi	0x15, 1	; 21
   15c0c:	fc 01       	movw	r30, r24
   15c0e:	31 97       	sbiw	r30, 0x01	; 1
   15c10:	f1 f7       	brne	.-4      	; 0x15c0e <lcd_init+0x5a>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15c12:	a9 98       	cbi	0x15, 1	; 21
   15c14:	01 97       	sbiw	r24, 0x01	; 1
   15c16:	f1 f7       	brne	.-4      	; 0x15c14 <lcd_init+0x60>
	_LCD_BUSY;

	_LIGHT_PORT = 0x01;
   15c18:	81 e0       	ldi	r24, 0x01	; 1
   15c1a:	80 93 65 00 	sts	0x0065, r24
	_LIGHT_DDR |= (1 << _LIGHT_PIN);
   15c1e:	e4 e6       	ldi	r30, 0x64	; 100
   15c20:	f0 e0       	ldi	r31, 0x00	; 0
   15c22:	80 81       	ld	r24, Z
   15c24:	82 60       	ori	r24, 0x02	; 2
   15c26:	80 83       	st	Z, r24

	lcd_command(0x28);
   15c28:	88 e2       	ldi	r24, 0x28	; 40
   15c2a:	0e 94 b1 ad 	call	0x15b62	; 0x15b62 <lcd_command>
	lcd_command(0x0c);
   15c2e:	8c e0       	ldi	r24, 0x0C	; 12
   15c30:	0e 94 b1 ad 	call	0x15b62	; 0x15b62 <lcd_command>
	lcd_command(0x06);
   15c34:	86 e0       	ldi	r24, 0x06	; 6
   15c36:	0e 94 b1 ad 	call	0x15b62	; 0x15b62 <lcd_command>
}
   15c3a:	08 95       	ret

00015c3c <_lcd>:
	if (__chr==0x01) _delay_ms(50);

}

void _lcd(unsigned char __chr){
	_LCD_PORT =((__chr & 0xF0));
   15c3c:	28 2f       	mov	r18, r24
   15c3e:	20 7f       	andi	r18, 0xF0	; 240
   15c40:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_RS);
   15c42:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15c44:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   15c46:	a9 98       	cbi	0x15, 1	; 21

	_LCD_PORT = (((__chr & 0x0F) << 4));
   15c48:	90 e0       	ldi	r25, 0x00	; 0
   15c4a:	24 e0       	ldi	r18, 0x04	; 4
   15c4c:	88 0f       	add	r24, r24
   15c4e:	99 1f       	adc	r25, r25
   15c50:	2a 95       	dec	r18
   15c52:	e1 f7       	brne	.-8      	; 0x15c4c <_lcd+0x10>
   15c54:	85 bb       	out	0x15, r24	; 21
	sbi(_LCD_PORT, _LCD_RS);
   15c56:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15c58:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   15c5a:	a9 98       	cbi	0x15, 1	; 21
   15c5c:	88 ee       	ldi	r24, 0xE8	; 232
   15c5e:	93 e0       	ldi	r25, 0x03	; 3
   15c60:	01 97       	sbiw	r24, 0x01	; 1
   15c62:	f1 f7       	brne	.-4      	; 0x15c60 <_lcd+0x24>
	_LCD_BUSY;
	_delay_ms(1);
}
   15c64:	8a ef       	ldi	r24, 0xFA	; 250
   15c66:	90 e0       	ldi	r25, 0x00	; 0
   15c68:	01 97       	sbiw	r24, 0x01	; 1
   15c6a:	f1 f7       	brne	.-4      	; 0x15c68 <_lcd+0x2c>
   15c6c:	08 95       	ret

00015c6e <lcd_string>:
     lcd_printf(2,1,PSTR("                    "));
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
   15c6e:	cf 93       	push	r28
   15c70:	df 93       	push	r29
   15c72:	ec 01       	movw	r28, r24
   15c74:	03 c0       	rjmp	.+6      	; 0x15c7c <lcd_string+0xe>
	while(*__string)
		_lcd(*__string++);
   15c76:	21 96       	adiw	r28, 0x01	; 1
   15c78:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
	while(*__string)
   15c7c:	88 81       	ld	r24, Y
   15c7e:	88 23       	and	r24, r24
   15c80:	d1 f7       	brne	.-12     	; 0x15c76 <lcd_string+0x8>
		_lcd(*__string++);
}
   15c82:	df 91       	pop	r29
   15c84:	cf 91       	pop	r28
   15c86:	08 95       	ret

00015c88 <lcd_xy>:

void lcd_xy(unsigned char __x, unsigned char __y){
	switch(__x){
   15c88:	82 30       	cpi	r24, 0x02	; 2
   15c8a:	69 f0       	breq	.+26     	; 0x15ca6 <lcd_xy+0x1e>
   15c8c:	83 30       	cpi	r24, 0x03	; 3
   15c8e:	18 f4       	brcc	.+6      	; 0x15c96 <lcd_xy+0xe>
   15c90:	81 30       	cpi	r24, 0x01	; 1
   15c92:	a9 f4       	brne	.+42     	; 0x15cbe <lcd_xy+0x36>
   15c94:	05 c0       	rjmp	.+10     	; 0x15ca0 <lcd_xy+0x18>
   15c96:	83 30       	cpi	r24, 0x03	; 3
   15c98:	49 f0       	breq	.+18     	; 0x15cac <lcd_xy+0x24>
   15c9a:	84 30       	cpi	r24, 0x04	; 4
   15c9c:	81 f4       	brne	.+32     	; 0x15cbe <lcd_xy+0x36>
   15c9e:	0b c0       	rjmp	.+22     	; 0x15cb6 <lcd_xy+0x2e>
		case 1:
			lcd_command(0x80 + __y - 1);
   15ca0:	86 2f       	mov	r24, r22
   15ca2:	81 58       	subi	r24, 0x81	; 129
   15ca4:	05 c0       	rjmp	.+10     	; 0x15cb0 <lcd_xy+0x28>
			break;
		case 2:
			lcd_command(0xC0 + __y - 1);
   15ca6:	86 2f       	mov	r24, r22
   15ca8:	81 54       	subi	r24, 0x41	; 65
   15caa:	02 c0       	rjmp	.+4      	; 0x15cb0 <lcd_xy+0x28>
			break;
		case 3:
			lcd_command(0x94 + __y - 1);
   15cac:	86 2f       	mov	r24, r22
   15cae:	8d 56       	subi	r24, 0x6D	; 109
   15cb0:	0e 94 b1 ad 	call	0x15b62	; 0x15b62 <lcd_command>
   15cb4:	08 95       	ret
			break;
		case 4:
			lcd_command(0xD4 + __y - 1);
   15cb6:	86 2f       	mov	r24, r22
   15cb8:	8d 52       	subi	r24, 0x2D	; 45
   15cba:	0e 94 b1 ad 	call	0x15b62	; 0x15b62 <lcd_command>
   15cbe:	08 95       	ret

00015cc0 <lcd_print>:
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
	 }     
}

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
   15cc0:	df 92       	push	r13
   15cc2:	ef 92       	push	r14
   15cc4:	ff 92       	push	r15
   15cc6:	0f 93       	push	r16
   15cc8:	1f 93       	push	r17
   15cca:	cf 93       	push	r28
   15ccc:	df 93       	push	r29
   15cce:	06 2f       	mov	r16, r22
   15cd0:	d4 2e       	mov	r13, r20
   15cd2:	15 2f       	mov	r17, r21
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
   15cd4:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
   15cd8:	2d 2d       	mov	r18, r13
   15cda:	31 2f       	mov	r19, r17
   15cdc:	c9 01       	movw	r24, r18
   15cde:	ec 01       	movw	r28, r24
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   15ce0:	34 e1       	ldi	r19, 0x14	; 20
   15ce2:	e3 2e       	mov	r14, r19
   15ce4:	f1 2c       	mov	r15, r1
   15ce6:	e0 1a       	sub	r14, r16
   15ce8:	f1 08       	sbc	r15, r1
   15cea:	04 c0       	rjmp	.+8      	; 0x15cf4 <lcd_print+0x34>
		_lcd(*__string);__string++;
   15cec:	82 2f       	mov	r24, r18
   15cee:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
   15cf2:	21 96       	adiw	r28, 0x01	; 1
   15cf4:	9e 01       	movw	r18, r28
   15cf6:	2d 19       	sub	r18, r13
   15cf8:	82 2f       	mov	r24, r18

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   15cfa:	28 81       	ld	r18, Y
   15cfc:	22 23       	and	r18, r18
   15cfe:	21 f0       	breq	.+8      	; 0x15d08 <lcd_print+0x48>
   15d00:	90 e0       	ldi	r25, 0x00	; 0
   15d02:	e8 16       	cp	r14, r24
   15d04:	f9 06       	cpc	r15, r25
   15d06:	94 f7       	brge	.-28     	; 0x15cec <lcd_print+0x2c>
		_lcd(*__string);__string++;
		iPos++;
		}    
}
   15d08:	df 91       	pop	r29
   15d0a:	cf 91       	pop	r28
   15d0c:	1f 91       	pop	r17
   15d0e:	0f 91       	pop	r16
   15d10:	ff 90       	pop	r15
   15d12:	ef 90       	pop	r14
   15d14:	df 90       	pop	r13
   15d16:	08 95       	ret

00015d18 <lcd_printf>:

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
   15d18:	df 92       	push	r13
   15d1a:	ef 92       	push	r14
   15d1c:	ff 92       	push	r15
   15d1e:	0f 93       	push	r16
   15d20:	1f 93       	push	r17
   15d22:	cf 93       	push	r28
   15d24:	df 93       	push	r29
   15d26:	06 2f       	mov	r16, r22
   15d28:	d4 2e       	mov	r13, r20
   15d2a:	15 2f       	mov	r17, r21
    char iPos=0;
	lcd_xy(__x, __y);
   15d2c:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
   15d30:	8d 2d       	mov	r24, r13
   15d32:	91 2f       	mov	r25, r17
   15d34:	fc 01       	movw	r30, r24
   15d36:	ef 01       	movw	r28, r30
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   15d38:	44 e1       	ldi	r20, 0x14	; 20
   15d3a:	e4 2e       	mov	r14, r20
   15d3c:	f1 2c       	mov	r15, r1
   15d3e:	e0 1a       	sub	r14, r16
   15d40:	f1 08       	sbc	r15, r1
   15d42:	04 c0       	rjmp	.+8      	; 0x15d4c <lcd_printf+0x34>
		_lcd(pgm_read_byte(&(*__string)));
   15d44:	82 2f       	mov	r24, r18
   15d46:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
		__string++;
   15d4a:	21 96       	adiw	r28, 0x01	; 1
   15d4c:	9e 01       	movw	r18, r28
   15d4e:	2d 19       	sub	r18, r13
   15d50:	82 2f       	mov	r24, r18

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
    char iPos=0;
	lcd_xy(__x, __y);
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   15d52:	fe 01       	movw	r30, r28
   15d54:	24 91       	lpm	r18, Z+
   15d56:	22 23       	and	r18, r18
   15d58:	21 f0       	breq	.+8      	; 0x15d62 <lcd_printf+0x4a>
   15d5a:	90 e0       	ldi	r25, 0x00	; 0
   15d5c:	e8 16       	cp	r14, r24
   15d5e:	f9 06       	cpc	r15, r25
   15d60:	8c f7       	brge	.-30     	; 0x15d44 <lcd_printf+0x2c>
		_lcd(pgm_read_byte(&(*__string)));
		__string++;
		iPos++;
		}
}
   15d62:	df 91       	pop	r29
   15d64:	cf 91       	pop	r28
   15d66:	1f 91       	pop	r17
   15d68:	0f 91       	pop	r16
   15d6a:	ff 90       	pop	r15
   15d6c:	ef 90       	pop	r14
   15d6e:	df 90       	pop	r13
   15d70:	08 95       	ret

00015d72 <lcd_clear>:
	_LCD_BUSY;
	_delay_ms(1);
}

void lcd_clear(){
     lcd_printf(1,1,PSTR("                    "));
   15d72:	81 e0       	ldi	r24, 0x01	; 1
   15d74:	61 e0       	ldi	r22, 0x01	; 1
   15d76:	4f ee       	ldi	r20, 0xEF	; 239
   15d78:	53 e2       	ldi	r21, 0x23	; 35
   15d7a:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
     lcd_printf(2,1,PSTR("                    "));
   15d7e:	82 e0       	ldi	r24, 0x02	; 2
   15d80:	61 e0       	ldi	r22, 0x01	; 1
   15d82:	4a ed       	ldi	r20, 0xDA	; 218
   15d84:	53 e2       	ldi	r21, 0x23	; 35
   15d86:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
     lcd_printf(3,1,PSTR("                    "));
   15d8a:	83 e0       	ldi	r24, 0x03	; 3
   15d8c:	61 e0       	ldi	r22, 0x01	; 1
   15d8e:	45 ec       	ldi	r20, 0xC5	; 197
   15d90:	53 e2       	ldi	r21, 0x23	; 35
   15d92:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
     lcd_printf(4,1,PSTR("                    "));
   15d96:	84 e0       	ldi	r24, 0x04	; 4
   15d98:	61 e0       	ldi	r22, 0x01	; 1
   15d9a:	40 eb       	ldi	r20, 0xB0	; 176
   15d9c:	53 e2       	ldi	r21, 0x23	; 35
   15d9e:	0e 94 8c ae 	call	0x15d18	; 0x15d18 <lcd_printf>
}
   15da2:	08 95       	ret

00015da4 <lcd_put>:
		__string++;
		iPos++;
		}
}

void lcd_put(unsigned char __x, unsigned char __y, unsigned char __chr){
   15da4:	1f 93       	push	r17
   15da6:	14 2f       	mov	r17, r20
	lcd_xy(__x, __y);
   15da8:	0e 94 44 ae 	call	0x15c88	; 0x15c88 <lcd_xy>
	_lcd(__chr);
   15dac:	81 2f       	mov	r24, r17
   15dae:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
}
   15db2:	1f 91       	pop	r17
   15db4:	08 95       	ret

00015db6 <lcd_cgram>:

void lcd_cgram(unsigned char location, char *ptr){
   15db6:	0f 93       	push	r16
   15db8:	1f 93       	push	r17
   15dba:	cf 93       	push	r28
   15dbc:	df 93       	push	r29
   15dbe:	8b 01       	movw	r16, r22
	unsigned char i;
    if(location < 8){
   15dc0:	88 30       	cpi	r24, 0x08	; 8
   15dc2:	90 f4       	brcc	.+36     	; 0x15de8 <lcd_cgram+0x32>
		lcd_command(0x40 + (location * 8));
   15dc4:	88 0f       	add	r24, r24
   15dc6:	88 0f       	add	r24, r24
   15dc8:	88 0f       	add	r24, r24
   15dca:	80 5c       	subi	r24, 0xC0	; 192
   15dcc:	0e 94 b1 ad 	call	0x15b62	; 0x15b62 <lcd_command>
   15dd0:	c0 e0       	ldi	r28, 0x00	; 0
   15dd2:	d0 e0       	ldi	r29, 0x00	; 0
		for(i = 0; i < 8; i++)
			_lcd(ptr[i]);
   15dd4:	f8 01       	movw	r30, r16
   15dd6:	ec 0f       	add	r30, r28
   15dd8:	fd 1f       	adc	r31, r29
   15dda:	80 81       	ld	r24, Z
   15ddc:	0e 94 1e ae 	call	0x15c3c	; 0x15c3c <_lcd>
   15de0:	21 96       	adiw	r28, 0x01	; 1

void lcd_cgram(unsigned char location, char *ptr){
	unsigned char i;
    if(location < 8){
		lcd_command(0x40 + (location * 8));
		for(i = 0; i < 8; i++)
   15de2:	c8 30       	cpi	r28, 0x08	; 8
   15de4:	d1 05       	cpc	r29, r1
   15de6:	b1 f7       	brne	.-20     	; 0x15dd4 <lcd_cgram+0x1e>
			_lcd(ptr[i]);
	}
}
   15de8:	df 91       	pop	r29
   15dea:	cf 91       	pop	r28
   15dec:	1f 91       	pop	r17
   15dee:	0f 91       	pop	r16
   15df0:	08 95       	ret

00015df2 <ClearMem>:
			lcd_command(0xD4 + __y - 1);
			break;
	}
}

void ClearMem(char *string){
   15df2:	cf 93       	push	r28
   15df4:	df 93       	push	r29
   15df6:	20 e0       	ldi	r18, 0x00	; 0
   15df8:	04 c0       	rjmp	.+8      	; 0x15e02 <ClearMem+0x10>
     char i;
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
   15dfa:	c8 0f       	add	r28, r24
   15dfc:	d9 1f       	adc	r29, r25
   15dfe:	18 82       	st	Y, r1
	}
}

void ClearMem(char *string){
     char i;
	 for (i=0;i<strlen(string);i++){
   15e00:	2f 5f       	subi	r18, 0xFF	; 255
   15e02:	c2 2f       	mov	r28, r18
   15e04:	d0 e0       	ldi	r29, 0x00	; 0
   15e06:	fc 01       	movw	r30, r24
   15e08:	01 90       	ld	r0, Z+
   15e0a:	00 20       	and	r0, r0
   15e0c:	e9 f7       	brne	.-6      	; 0x15e08 <ClearMem+0x16>
   15e0e:	31 97       	sbiw	r30, 0x01	; 1
   15e10:	e8 1b       	sub	r30, r24
   15e12:	f9 0b       	sbc	r31, r25
   15e14:	ce 17       	cp	r28, r30
   15e16:	df 07       	cpc	r29, r31
   15e18:	80 f3       	brcs	.-32     	; 0x15dfa <ClearMem+0x8>
          string[i]=0;
	 }     
}
   15e1a:	df 91       	pop	r29
   15e1c:	cf 91       	pop	r28
   15e1e:	08 95       	ret

00015e20 <_key_hit>:
													 {'7', 'P', 'Q', 'R', 'S', '\0'},
											         {'8', 'T', 'U', 'V', '\0'}, 
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
   15e20:	df 93       	push	r29
   15e22:	cf 93       	push	r28
   15e24:	00 d0       	rcall	.+0      	; 0x15e26 <_key_hit+0x6>
   15e26:	00 d0       	rcall	.+0      	; 0x15e28 <_key_hit+0x8>
   15e28:	cd b7       	in	r28, 0x3d	; 61
   15e2a:	de b7       	in	r29, 0x3e	; 62
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15e2c:	8f ee       	ldi	r24, 0xEF	; 239
   15e2e:	89 83       	std	Y+1, r24	; 0x01
   15e30:	8f ed       	ldi	r24, 0xDF	; 223
   15e32:	8a 83       	std	Y+2, r24	; 0x02
   15e34:	8f eb       	ldi	r24, 0xBF	; 191
   15e36:	8b 83       	std	Y+3, r24	; 0x03
   15e38:	8f e7       	ldi	r24, 0x7F	; 127
   15e3a:	8c 83       	std	Y+4, r24	; 0x04
   15e3c:	de 01       	movw	r26, r28
   15e3e:	11 96       	adiw	r26, 0x01	; 1
   15e40:	2a ef       	ldi	r18, 0xFA	; 250
   15e42:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   15e44:	ae 01       	movw	r20, r28
   15e46:	4b 5f       	subi	r20, 0xFB	; 251
   15e48:	5f 4f       	sbci	r21, 0xFF	; 255
   15e4a:	c9 01       	movw	r24, r18
   15e4c:	01 97       	sbiw	r24, 0x01	; 1
   15e4e:	f1 f7       	brne	.-4      	; 0x15e4c <_key_hit+0x2c>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15e50:	8c 91       	ld	r24, X
   15e52:	80 93 62 00 	sts	0x0062, r24
   15e56:	f9 01       	movw	r30, r18
   15e58:	31 97       	sbiw	r30, 0x01	; 1
   15e5a:	f1 f7       	brne	.-4      	; 0x15e58 <_key_hit+0x38>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15e5c:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15e5e:	98 17       	cp	r25, r24
   15e60:	21 f4       	brne	.+8      	; 0x15e6a <_key_hit+0x4a>
		    break;
   15e62:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15e64:	a4 17       	cp	r26, r20
   15e66:	b5 07       	cpc	r27, r21
   15e68:	81 f7       	brne	.-32     	; 0x15e4a <_key_hit+0x2a>
		keyhit = _KEY_MATRIX;
		if (keyhit!=outmap[i]) 
		    break;
	}
	return keyhit;
}
   15e6a:	89 2f       	mov	r24, r25
   15e6c:	0f 90       	pop	r0
   15e6e:	0f 90       	pop	r0
   15e70:	0f 90       	pop	r0
   15e72:	0f 90       	pop	r0
   15e74:	cf 91       	pop	r28
   15e76:	df 91       	pop	r29
   15e78:	08 95       	ret

00015e7a <_key_crr>:

char _key_crr(char __key){
	if(	__key != _KEY_1 && __key != _KEY_2 &&
   15e7a:	8e 3e       	cpi	r24, 0xEE	; 238
   15e7c:	f9 f0       	breq	.+62     	; 0x15ebc <_key_crr+0x42>
   15e7e:	8e 3d       	cpi	r24, 0xDE	; 222
   15e80:	e9 f0       	breq	.+58     	; 0x15ebc <_key_crr+0x42>
   15e82:	8e 3b       	cpi	r24, 0xBE	; 190
   15e84:	d9 f0       	breq	.+54     	; 0x15ebc <_key_crr+0x42>
   15e86:	8d 3e       	cpi	r24, 0xED	; 237
   15e88:	c9 f0       	breq	.+50     	; 0x15ebc <_key_crr+0x42>
   15e8a:	8d 3d       	cpi	r24, 0xDD	; 221
   15e8c:	b9 f0       	breq	.+46     	; 0x15ebc <_key_crr+0x42>
   15e8e:	8d 3b       	cpi	r24, 0xBD	; 189
   15e90:	a9 f0       	breq	.+42     	; 0x15ebc <_key_crr+0x42>
   15e92:	8b 3e       	cpi	r24, 0xEB	; 235
   15e94:	99 f0       	breq	.+38     	; 0x15ebc <_key_crr+0x42>
   15e96:	8b 3d       	cpi	r24, 0xDB	; 219
   15e98:	89 f0       	breq	.+34     	; 0x15ebc <_key_crr+0x42>
   15e9a:	8b 3b       	cpi	r24, 0xBB	; 187
   15e9c:	79 f0       	breq	.+30     	; 0x15ebc <_key_crr+0x42>
   15e9e:	87 3d       	cpi	r24, 0xD7	; 215
   15ea0:	69 f0       	breq	.+26     	; 0x15ebc <_key_crr+0x42>
   15ea2:	87 3e       	cpi	r24, 0xE7	; 231
   15ea4:	59 f0       	breq	.+22     	; 0x15ebc <_key_crr+0x42>
   15ea6:	87 3b       	cpi	r24, 0xB7	; 183
   15ea8:	49 f0       	breq	.+18     	; 0x15ebc <_key_crr+0x42>
   15eaa:	8e 37       	cpi	r24, 0x7E	; 126
   15eac:	39 f0       	breq	.+14     	; 0x15ebc <_key_crr+0x42>
   15eae:	8d 37       	cpi	r24, 0x7D	; 125
   15eb0:	29 f0       	breq	.+10     	; 0x15ebc <_key_crr+0x42>
   15eb2:	8b 37       	cpi	r24, 0x7B	; 123
   15eb4:	19 f0       	breq	.+6      	; 0x15ebc <_key_crr+0x42>
   15eb6:	87 37       	cpi	r24, 0x77	; 119
   15eb8:	09 f0       	breq	.+2      	; 0x15ebc <_key_crr+0x42>
   15eba:	80 e0       	ldi	r24, 0x00	; 0
		__key != _KEY_CANCEL && __key != _KEY_ENTER &&
		__key != _KEY_TIKET && __key != _KEY_MENU &&
		__key != _KEY_SHIFT && __key != _KEY_CLEAR)
		return _KEY_NULL;
	return __key;
}
   15ebc:	08 95       	ret

00015ebe <_key_btn>:

char _key_btn(char __key){
	char __keychar = 0;
	
	switch (__key){
   15ebe:	8e 3b       	cpi	r24, 0xBE	; 190
   15ec0:	91 f1       	breq	.+100    	; 0x15f26 <_key_btn+0x68>
   15ec2:	8f 3b       	cpi	r24, 0xBF	; 191
   15ec4:	a8 f4       	brcc	.+42     	; 0x15ef0 <_key_btn+0x32>
   15ec6:	8e 37       	cpi	r24, 0x7E	; 126
   15ec8:	09 f4       	brne	.+2      	; 0x15ecc <_key_btn+0xe>
   15eca:	41 c0       	rjmp	.+130    	; 0x15f4e <_key_btn+0x90>
   15ecc:	8f 37       	cpi	r24, 0x7F	; 127
   15ece:	48 f4       	brcc	.+18     	; 0x15ee2 <_key_btn+0x24>
   15ed0:	8b 37       	cpi	r24, 0x7B	; 123
   15ed2:	09 f4       	brne	.+2      	; 0x15ed6 <_key_btn+0x18>
   15ed4:	40 c0       	rjmp	.+128    	; 0x15f56 <_key_btn+0x98>
   15ed6:	8d 37       	cpi	r24, 0x7D	; 125
   15ed8:	e1 f1       	breq	.+120    	; 0x15f52 <_key_btn+0x94>
   15eda:	87 37       	cpi	r24, 0x77	; 119
   15edc:	09 f0       	breq	.+2      	; 0x15ee0 <_key_btn+0x22>
   15ede:	3f c0       	rjmp	.+126    	; 0x15f5e <_key_btn+0xa0>
   15ee0:	3c c0       	rjmp	.+120    	; 0x15f5a <_key_btn+0x9c>
   15ee2:	8b 3b       	cpi	r24, 0xBB	; 187
   15ee4:	61 f1       	breq	.+88     	; 0x15f3e <_key_btn+0x80>
   15ee6:	8d 3b       	cpi	r24, 0xBD	; 189
   15ee8:	21 f1       	breq	.+72     	; 0x15f32 <_key_btn+0x74>
   15eea:	87 3b       	cpi	r24, 0xB7	; 183
   15eec:	c1 f5       	brne	.+112    	; 0x15f5e <_key_btn+0xa0>
   15eee:	2d c0       	rjmp	.+90     	; 0x15f4a <_key_btn+0x8c>
   15ef0:	8e 3d       	cpi	r24, 0xDE	; 222
   15ef2:	a9 f0       	breq	.+42     	; 0x15f1e <_key_btn+0x60>
   15ef4:	8f 3d       	cpi	r24, 0xDF	; 223
   15ef6:	38 f4       	brcc	.+14     	; 0x15f06 <_key_btn+0x48>
   15ef8:	8b 3d       	cpi	r24, 0xDB	; 219
   15efa:	f9 f0       	breq	.+62     	; 0x15f3a <_key_btn+0x7c>
   15efc:	8d 3d       	cpi	r24, 0xDD	; 221
   15efe:	b9 f0       	breq	.+46     	; 0x15f2e <_key_btn+0x70>
   15f00:	87 3d       	cpi	r24, 0xD7	; 215
   15f02:	69 f5       	brne	.+90     	; 0x15f5e <_key_btn+0xa0>
   15f04:	1e c0       	rjmp	.+60     	; 0x15f42 <_key_btn+0x84>
   15f06:	8b 3e       	cpi	r24, 0xEB	; 235
   15f08:	b1 f0       	breq	.+44     	; 0x15f36 <_key_btn+0x78>
   15f0a:	8c 3e       	cpi	r24, 0xEC	; 236
   15f0c:	18 f4       	brcc	.+6      	; 0x15f14 <_key_btn+0x56>
   15f0e:	87 3e       	cpi	r24, 0xE7	; 231
   15f10:	31 f5       	brne	.+76     	; 0x15f5e <_key_btn+0xa0>
   15f12:	19 c0       	rjmp	.+50     	; 0x15f46 <_key_btn+0x88>
   15f14:	8d 3e       	cpi	r24, 0xED	; 237
   15f16:	49 f0       	breq	.+18     	; 0x15f2a <_key_btn+0x6c>
   15f18:	8e 3e       	cpi	r24, 0xEE	; 238
   15f1a:	09 f5       	brne	.+66     	; 0x15f5e <_key_btn+0xa0>
   15f1c:	02 c0       	rjmp	.+4      	; 0x15f22 <_key_btn+0x64>
   15f1e:	82 e3       	ldi	r24, 0x32	; 50
   15f20:	08 95       	ret
   15f22:	81 e3       	ldi	r24, 0x31	; 49
   15f24:	08 95       	ret
   15f26:	83 e3       	ldi	r24, 0x33	; 51
   15f28:	08 95       	ret
		case 0xDE:
			__keychar = 0x32; //2
			break;
		case 0xBE:
			__keychar = 0x33; //3
			break;
   15f2a:	84 e3       	ldi	r24, 0x34	; 52
   15f2c:	08 95       	ret
		case 0xED:
			__keychar = 0x34; //4
			break;
   15f2e:	85 e3       	ldi	r24, 0x35	; 53
   15f30:	08 95       	ret
		case 0xDD:
			__keychar = 0x35; //5
			break;
   15f32:	86 e3       	ldi	r24, 0x36	; 54
   15f34:	08 95       	ret
		case 0xBD:
			__keychar = 0x36; //6
			break;
   15f36:	87 e3       	ldi	r24, 0x37	; 55
   15f38:	08 95       	ret
		case 0xEB:
			__keychar = 0x37; //7
			break;
   15f3a:	88 e3       	ldi	r24, 0x38	; 56
   15f3c:	08 95       	ret
		case 0xDB:
			__keychar = 0x38; //8
			break;
   15f3e:	89 e3       	ldi	r24, 0x39	; 57
   15f40:	08 95       	ret
		case 0xBB:
			__keychar = 0x39; //9
			break;
   15f42:	80 e3       	ldi	r24, 0x30	; 48
   15f44:	08 95       	ret
		case 0xD7:
			__keychar = 0x30; //0
			break;
   15f46:	8a e2       	ldi	r24, 0x2A	; 42
   15f48:	08 95       	ret
		case 0xE7:
			__keychar = 0x2a; //*
			break;
   15f4a:	83 e2       	ldi	r24, 0x23	; 35
   15f4c:	08 95       	ret
		case 0xB7:
			__keychar = 0x23; //#
			break;
   15f4e:	81 ef       	ldi	r24, 0xF1	; 241
   15f50:	08 95       	ret
		case 0x7E:
			__keychar = 0xF1; //Menu 1
			break;
   15f52:	82 ef       	ldi	r24, 0xF2	; 242
   15f54:	08 95       	ret
		case 0x7D:
			__keychar = 0xF2; //Menu 2
			break;
   15f56:	83 ef       	ldi	r24, 0xF3	; 243
   15f58:	08 95       	ret
		case 0x7B:
			__keychar = 0xF3; //Menu 3
			break;
   15f5a:	84 ef       	ldi	r24, 0xF4	; 244
   15f5c:	08 95       	ret
		case 0x77:
			__keychar = 0xF4; //Menu 4
			break;
   15f5e:	80 e0       	ldi	r24, 0x00	; 0
			__keychar = 0x00;
			break;

	}
	return __keychar;
}
   15f60:	08 95       	ret

00015f62 <_table_alphanum>:
	}
	_PAD_1st;
	return __key;
}

char _table_alphanum(char __caps, char __key, char __hit){
   15f62:	98 2f       	mov	r25, r24
unsigned char __retchar = 0;

	switch(__key){
   15f64:	6d 3d       	cpi	r22, 0xDD	; 221
   15f66:	11 f1       	breq	.+68     	; 0x15fac <_table_alphanum+0x4a>
   15f68:	6e 3d       	cpi	r22, 0xDE	; 222
   15f6a:	60 f4       	brcc	.+24     	; 0x15f84 <_table_alphanum+0x22>
   15f6c:	6d 3b       	cpi	r22, 0xBD	; 189
   15f6e:	01 f1       	breq	.+64     	; 0x15fb0 <_table_alphanum+0x4e>
   15f70:	6e 3b       	cpi	r22, 0xBE	; 190
   15f72:	18 f4       	brcc	.+6      	; 0x15f7a <_table_alphanum+0x18>
   15f74:	6b 3b       	cpi	r22, 0xBB	; 187
   15f76:	21 f5       	brne	.+72     	; 0x15fc0 <_table_alphanum+0x5e>
   15f78:	21 c0       	rjmp	.+66     	; 0x15fbc <_table_alphanum+0x5a>
   15f7a:	6e 3b       	cpi	r22, 0xBE	; 190
   15f7c:	99 f0       	breq	.+38     	; 0x15fa4 <_table_alphanum+0x42>
   15f7e:	6b 3d       	cpi	r22, 0xDB	; 219
   15f80:	f9 f4       	brne	.+62     	; 0x15fc0 <_table_alphanum+0x5e>
   15f82:	1a c0       	rjmp	.+52     	; 0x15fb8 <_table_alphanum+0x56>
   15f84:	6b 3e       	cpi	r22, 0xEB	; 235
   15f86:	b1 f0       	breq	.+44     	; 0x15fb4 <_table_alphanum+0x52>
   15f88:	6c 3e       	cpi	r22, 0xEC	; 236
   15f8a:	18 f4       	brcc	.+6      	; 0x15f92 <_table_alphanum+0x30>
   15f8c:	6e 3d       	cpi	r22, 0xDE	; 222
   15f8e:	c1 f4       	brne	.+48     	; 0x15fc0 <_table_alphanum+0x5e>
   15f90:	05 c0       	rjmp	.+10     	; 0x15f9c <_table_alphanum+0x3a>
   15f92:	6d 3e       	cpi	r22, 0xED	; 237
   15f94:	49 f0       	breq	.+18     	; 0x15fa8 <_table_alphanum+0x46>
   15f96:	6e 3e       	cpi	r22, 0xEE	; 238
   15f98:	99 f4       	brne	.+38     	; 0x15fc0 <_table_alphanum+0x5e>
   15f9a:	02 c0       	rjmp	.+4      	; 0x15fa0 <_table_alphanum+0x3e>
   15f9c:	82 e0       	ldi	r24, 0x02	; 2
   15f9e:	11 c0       	rjmp	.+34     	; 0x15fc2 <_table_alphanum+0x60>
   15fa0:	81 e0       	ldi	r24, 0x01	; 1
   15fa2:	0f c0       	rjmp	.+30     	; 0x15fc2 <_table_alphanum+0x60>
   15fa4:	83 e0       	ldi	r24, 0x03	; 3
   15fa6:	0d c0       	rjmp	.+26     	; 0x15fc2 <_table_alphanum+0x60>
		case 0xDE:
			__key = 2; //2
			break;
		case 0xBE:
			__key = 3; //3
			break;
   15fa8:	84 e0       	ldi	r24, 0x04	; 4
   15faa:	0b c0       	rjmp	.+22     	; 0x15fc2 <_table_alphanum+0x60>
		case 0xED:
			__key = 4; //4
			break;
   15fac:	85 e0       	ldi	r24, 0x05	; 5
   15fae:	09 c0       	rjmp	.+18     	; 0x15fc2 <_table_alphanum+0x60>
		case 0xDD:
			__key = 5; //5
			break;
   15fb0:	86 e0       	ldi	r24, 0x06	; 6
   15fb2:	07 c0       	rjmp	.+14     	; 0x15fc2 <_table_alphanum+0x60>
		case 0xBD:
			__key = 6; //6
			break;
   15fb4:	87 e0       	ldi	r24, 0x07	; 7
   15fb6:	05 c0       	rjmp	.+10     	; 0x15fc2 <_table_alphanum+0x60>
		case 0xEB:
			__key = 7; //7
			break;
   15fb8:	88 e0       	ldi	r24, 0x08	; 8
   15fba:	03 c0       	rjmp	.+6      	; 0x15fc2 <_table_alphanum+0x60>
		case 0xDB:
			__key = 8; //8
			break;
   15fbc:	89 e0       	ldi	r24, 0x09	; 9
   15fbe:	01 c0       	rjmp	.+2      	; 0x15fc2 <_table_alphanum+0x60>
		case 0xBB:
			__key = 9; //9
			break;
   15fc0:	80 e0       	ldi	r24, 0x00	; 0
		default:
			__key = 0;
			break;	
	}

	if(__hit <= pgm_read_byte(&__maxchar[__key]))
   15fc2:	28 2f       	mov	r18, r24
   15fc4:	30 e0       	ldi	r19, 0x00	; 0
   15fc6:	f9 01       	movw	r30, r18
   15fc8:	e4 58       	subi	r30, 0x84	; 132
   15fca:	fb 4d       	sbci	r31, 0xDB	; 219
   15fcc:	e4 91       	lpm	r30, Z+
   15fce:	e4 17       	cp	r30, r20
   15fd0:	10 f4       	brcc	.+4      	; 0x15fd6 <_table_alphanum+0x74>
   15fd2:	80 e0       	ldi	r24, 0x00	; 0
   15fd4:	08 95       	ret
		__retchar = pgm_read_byte(&__alphanum[__caps][__key][__hit]);
   15fd6:	ec e3       	ldi	r30, 0x3C	; 60
   15fd8:	9e 9f       	mul	r25, r30
   15fda:	f0 01       	movw	r30, r0
   15fdc:	11 24       	eor	r1, r1
   15fde:	e4 0f       	add	r30, r20
   15fe0:	f1 1d       	adc	r31, r1
   15fe2:	c9 01       	movw	r24, r18
   15fe4:	88 0f       	add	r24, r24
   15fe6:	99 1f       	adc	r25, r25
   15fe8:	82 0f       	add	r24, r18
   15fea:	93 1f       	adc	r25, r19
   15fec:	88 0f       	add	r24, r24
   15fee:	99 1f       	adc	r25, r25
   15ff0:	e8 0f       	add	r30, r24
   15ff2:	f9 1f       	adc	r31, r25
   15ff4:	ec 5f       	subi	r30, 0xFC	; 252
   15ff6:	fb 4d       	sbci	r31, 0xDB	; 219
   15ff8:	84 91       	lpm	r24, Z+
	else __retchar = '\0';

	return __retchar;
}
   15ffa:	08 95       	ret

00015ffc <_key_scan>:





char _key_scan(char __select){
   15ffc:	8f 92       	push	r8
   15ffe:	9f 92       	push	r9
   16000:	af 92       	push	r10
   16002:	bf 92       	push	r11
   16004:	cf 92       	push	r12
   16006:	df 92       	push	r13
   16008:	ef 92       	push	r14
   1600a:	ff 92       	push	r15
   1600c:	0f 93       	push	r16
   1600e:	1f 93       	push	r17
   16010:	df 93       	push	r29
   16012:	cf 93       	push	r28
   16014:	00 d0       	rcall	.+0      	; 0x16016 <_key_scan+0x1a>
   16016:	00 d0       	rcall	.+0      	; 0x16018 <_key_scan+0x1c>
   16018:	cd b7       	in	r28, 0x3d	; 61
   1601a:	de b7       	in	r29, 0x3e	; 62
   1601c:	18 2f       	mov	r17, r24
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
   1601e:	81 50       	subi	r24, 0x01	; 1
   16020:	82 30       	cpi	r24, 0x02	; 2
   16022:	08 f0       	brcs	.+2      	; 0x16026 <_key_scan+0x2a>
   16024:	aa c0       	rjmp	.+340    	; 0x1617a <_key_scan+0x17e>
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   16026:	8f ee       	ldi	r24, 0xEF	; 239
   16028:	89 83       	std	Y+1, r24	; 0x01
   1602a:	8f ed       	ldi	r24, 0xDF	; 223
   1602c:	8a 83       	std	Y+2, r24	; 0x02
   1602e:	8f eb       	ldi	r24, 0xBF	; 191
   16030:	8b 83       	std	Y+3, r24	; 0x03
   16032:	8f e7       	ldi	r24, 0x7F	; 127
   16034:	8c 83       	std	Y+4, r24	; 0x04
   16036:	de 01       	movw	r26, r28
   16038:	11 96       	adiw	r26, 0x01	; 1
   1603a:	2a ef       	ldi	r18, 0xFA	; 250
   1603c:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   1603e:	ae 01       	movw	r20, r28
   16040:	4b 5f       	subi	r20, 0xFB	; 251
   16042:	5f 4f       	sbci	r21, 0xFF	; 255
   16044:	c9 01       	movw	r24, r18
   16046:	01 97       	sbiw	r24, 0x01	; 1
   16048:	f1 f7       	brne	.-4      	; 0x16046 <_key_scan+0x4a>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   1604a:	8c 91       	ld	r24, X
   1604c:	80 93 62 00 	sts	0x0062, r24
   16050:	f9 01       	movw	r30, r18
   16052:	31 97       	sbiw	r30, 0x01	; 1
   16054:	f1 f7       	brne	.-4      	; 0x16052 <_key_scan+0x56>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   16056:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   16058:	98 17       	cp	r25, r24
   1605a:	21 f4       	brne	.+8      	; 0x16064 <_key_scan+0x68>
   1605c:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   1605e:	a4 17       	cp	r26, r20
   16060:	b5 07       	cpc	r27, r21
   16062:	81 f7       	brne	.-32     	; 0x16044 <_key_scan+0x48>
char _key_scan(char __select){
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
		__key = _key_hit();
		__key = _key_crr(__key);
   16064:	89 2f       	mov	r24, r25
   16066:	0e 94 3d af 	call	0x15e7a	; 0x15e7a <_key_crr>
   1606a:	28 2f       	mov	r18, r24

		if(__key!=_KEY_NULL){
   1606c:	88 23       	and	r24, r24
   1606e:	09 f4       	brne	.+2      	; 0x16072 <_key_scan+0x76>
   16070:	85 c0       	rjmp	.+266    	; 0x1617c <_key_scan+0x180>
			_LIGHT_SET;
   16072:	91 e0       	ldi	r25, 0x01	; 1
   16074:	90 93 bf 03 	sts	0x03BF, r25
   16078:	10 92 c0 03 	sts	0x03C0, r1
   1607c:	80 91 65 00 	lds	r24, 0x0065
   16080:	8d 7f       	andi	r24, 0xFD	; 253
   16082:	80 93 65 00 	sts	0x0065, r24
			if(__sec_par)
   16086:	80 91 99 04 	lds	r24, 0x0499
   1608a:	88 23       	and	r24, r24
   1608c:	31 f0       	breq	.+12     	; 0x1609a <_key_scan+0x9e>
				_SEC_ON;
   1608e:	90 93 c7 03 	sts	0x03C7, r25
   16092:	10 92 ff 03 	sts	0x03FF, r1
   16096:	10 92 c8 03 	sts	0x03C8, r1

			if(_IS1st){
   1609a:	80 91 c1 03 	lds	r24, 0x03C1
   1609e:	88 23       	and	r24, r24
   160a0:	71 f4       	brne	.+28     	; 0x160be <_key_scan+0xc2>
				if(	__key == _KEY_CANCEL || __key == _KEY_ENTER)
   160a2:	27 3e       	cpi	r18, 0xE7	; 231
   160a4:	11 f0       	breq	.+4      	; 0x160aa <_key_scan+0xae>
   160a6:	27 3b       	cpi	r18, 0xB7	; 183
   160a8:	31 f4       	brne	.+12     	; 0x160b6 <_key_scan+0xba>
					if(__lock_num)
   160aa:	80 91 be 03 	lds	r24, 0x03BE
   160ae:	88 23       	and	r24, r24
   160b0:	11 f0       	breq	.+4      	; 0x160b6 <_key_scan+0xba>
						__lock_num = 0;
   160b2:	10 92 be 03 	sts	0x03BE, r1
				_PAD_2nd;
   160b6:	81 e0       	ldi	r24, 0x01	; 1
   160b8:	80 93 c1 03 	sts	0x03C1, r24
   160bc:	59 c0       	rjmp	.+178    	; 0x16170 <_key_scan+0x174>
				//_spi_tx(0x24, _SPI_SLAVE, "~");
				_delay_ms(5);
				return __key;
			}
			if(_IS2nd){
   160be:	81 30       	cpi	r24, 0x01	; 1
   160c0:	09 f0       	breq	.+2      	; 0x160c4 <_key_scan+0xc8>
   160c2:	5c c0       	rjmp	.+184    	; 0x1617c <_key_scan+0x180>
				if(__select==_PAD_MULTI){
   160c4:	12 30       	cpi	r17, 0x02	; 2
   160c6:	21 f5       	brne	.+72     	; 0x16110 <_key_scan+0x114>
					if(	__key==_KEY_0 || __key==_KEY_1 || __key==_KEY_2 || __key==_KEY_3||
   160c8:	27 3d       	cpi	r18, 0xD7	; 215
   160ca:	91 f0       	breq	.+36     	; 0x160f0 <_key_scan+0xf4>
   160cc:	2e 3e       	cpi	r18, 0xEE	; 238
   160ce:	81 f0       	breq	.+32     	; 0x160f0 <_key_scan+0xf4>
   160d0:	2e 3d       	cpi	r18, 0xDE	; 222
   160d2:	71 f0       	breq	.+28     	; 0x160f0 <_key_scan+0xf4>
   160d4:	2e 3b       	cpi	r18, 0xBE	; 190
   160d6:	61 f0       	breq	.+24     	; 0x160f0 <_key_scan+0xf4>
   160d8:	2d 3e       	cpi	r18, 0xED	; 237
   160da:	51 f0       	breq	.+20     	; 0x160f0 <_key_scan+0xf4>
   160dc:	2d 3d       	cpi	r18, 0xDD	; 221
   160de:	41 f0       	breq	.+16     	; 0x160f0 <_key_scan+0xf4>
   160e0:	2d 3b       	cpi	r18, 0xBD	; 189
   160e2:	31 f0       	breq	.+12     	; 0x160f0 <_key_scan+0xf4>
   160e4:	2b 3e       	cpi	r18, 0xEB	; 235
   160e6:	21 f0       	breq	.+8      	; 0x160f0 <_key_scan+0xf4>
   160e8:	2b 3d       	cpi	r18, 0xDB	; 219
   160ea:	11 f0       	breq	.+4      	; 0x160f0 <_key_scan+0xf4>
   160ec:	2b 3b       	cpi	r18, 0xBB	; 187
   160ee:	81 f4       	brne	.+32     	; 0x16110 <_key_scan+0x114>
						__key==_KEY_4 || __key==_KEY_5 || __key==_KEY_6 ||
						__key==_KEY_7 || __key==_KEY_8 || __key==_KEY_9){
						if(__lock_num){
   160f0:	80 91 be 03 	lds	r24, 0x03BE
   160f4:	88 23       	and	r24, r24
   160f6:	49 f0       	breq	.+18     	; 0x1610a <_key_scan+0x10e>
							_SHIFT_SET;
   160f8:	81 e0       	ldi	r24, 0x01	; 1
   160fa:	80 93 c2 03 	sts	0x03C2, r24
   160fe:	10 92 c3 03 	sts	0x03C3, r1
							CURSOR_HIDE;
   16102:	8c e0       	ldi	r24, 0x0C	; 12
   16104:	0e 94 b1 ad 	call	0x15b62	; 0x15b62 <lcd_command>
   16108:	03 c0       	rjmp	.+6      	; 0x16110 <_key_scan+0x114>
						}
						else
							__lock_num = 1;
   1610a:	81 e0       	ldi	r24, 0x01	; 1
   1610c:	80 93 be 03 	sts	0x03BE, r24
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   16110:	ff ee       	ldi	r31, 0xEF	; 239
   16112:	8f 2e       	mov	r8, r31
   16114:	ef ed       	ldi	r30, 0xDF	; 223
   16116:	9e 2e       	mov	r9, r30
   16118:	7f eb       	ldi	r23, 0xBF	; 191
   1611a:	a7 2e       	mov	r10, r23
   1611c:	6f e7       	ldi	r22, 0x7F	; 127
   1611e:	b6 2e       	mov	r11, r22
   16120:	6e 01       	movw	r12, r28
   16122:	08 94       	sec
   16124:	c1 1c       	adc	r12, r1
   16126:	d1 1c       	adc	r13, r1
   16128:	0a ef       	ldi	r16, 0xFA	; 250
   1612a:	10 e0       	ldi	r17, 0x00	; 0

	for(i=0; i<4; i++){
   1612c:	55 e0       	ldi	r21, 0x05	; 5
   1612e:	e5 2e       	mov	r14, r21
   16130:	f1 2c       	mov	r15, r1
   16132:	ec 0e       	add	r14, r28
   16134:	fd 1e       	adc	r15, r29
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   16136:	89 82       	std	Y+1, r8	; 0x01
   16138:	9a 82       	std	Y+2, r9	; 0x02
   1613a:	ab 82       	std	Y+3, r10	; 0x03
   1613c:	bc 82       	std	Y+4, r11	; 0x04
   1613e:	d6 01       	movw	r26, r12
   16140:	c8 01       	movw	r24, r16
   16142:	01 97       	sbiw	r24, 0x01	; 1
   16144:	f1 f7       	brne	.-4      	; 0x16142 <_key_scan+0x146>

	for(i=0; i<4; i++){
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   16146:	8c 91       	ld	r24, X
   16148:	80 93 62 00 	sts	0x0062, r24
   1614c:	f8 01       	movw	r30, r16
   1614e:	31 97       	sbiw	r30, 0x01	; 1
   16150:	f1 f7       	brne	.-4      	; 0x1614e <_key_scan+0x152>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   16152:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   16154:	98 17       	cp	r25, r24
   16156:	21 f4       	brne	.+8      	; 0x16160 <_key_scan+0x164>
   16158:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   1615a:	ae 15       	cp	r26, r14
   1615c:	bf 05       	cpc	r27, r15
   1615e:	81 f7       	brne	.-32     	; 0x16140 <_key_scan+0x144>
							__lock_num = 1;
					}
				}
				do{
					__key = _key_hit();
					__key = _key_crr(__key);
   16160:	89 2f       	mov	r24, r25
   16162:	0e 94 3d af 	call	0x15e7a	; 0x15e7a <_key_crr>
   16166:	28 2f       	mov	r18, r24
				}while(__key!=_KEY_NULL);
   16168:	88 23       	and	r24, r24
   1616a:	29 f7       	brne	.-54     	; 0x16136 <_key_scan+0x13a>
				_PAD_1st;
   1616c:	10 92 c1 03 	sts	0x03C1, r1
   16170:	82 ee       	ldi	r24, 0xE2	; 226
   16172:	94 e0       	ldi	r25, 0x04	; 4
   16174:	01 97       	sbiw	r24, 0x01	; 1
   16176:	f1 f7       	brne	.-4      	; 0x16174 <_key_scan+0x178>
   16178:	03 c0       	rjmp	.+6      	; 0x16180 <_key_scan+0x184>
				_delay_ms(5);
				return _KEY_NULL;
   1617a:	20 e0       	ldi	r18, 0x00	; 0
			}
		}
	}
	_PAD_1st;
   1617c:	10 92 c1 03 	sts	0x03C1, r1
	return __key;
}
   16180:	82 2f       	mov	r24, r18
   16182:	0f 90       	pop	r0
   16184:	0f 90       	pop	r0
   16186:	0f 90       	pop	r0
   16188:	0f 90       	pop	r0
   1618a:	cf 91       	pop	r28
   1618c:	df 91       	pop	r29
   1618e:	1f 91       	pop	r17
   16190:	0f 91       	pop	r16
   16192:	ff 90       	pop	r15
   16194:	ef 90       	pop	r14
   16196:	df 90       	pop	r13
   16198:	cf 90       	pop	r12
   1619a:	bf 90       	pop	r11
   1619c:	af 90       	pop	r10
   1619e:	9f 90       	pop	r9
   161a0:	8f 90       	pop	r8
   161a2:	08 95       	ret

000161a4 <_spi_init>:
unsigned char	__spi_i;
unsigned char	__spi_isstart = 0;
unsigned char	__spi_ismessage = 0;

void _spi_init(unsigned char __mode, unsigned char __interrupt){
	if(__mode){
   161a4:	88 23       	and	r24, r24
   161a6:	41 f0       	breq	.+16     	; 0x161b8 <_spi_init+0x14>
		_SPI_DDR = (1 << _SPI_MOSI) | (1 << _SPI_SCK);
   161a8:	86 e0       	ldi	r24, 0x06	; 6
   161aa:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   161ac:	66 23       	and	r22, r22
   161ae:	11 f0       	breq	.+4      	; 0x161b4 <_spi_init+0x10>
			SPCR = (1 << SPIE) | (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   161b0:	82 ed       	ldi	r24, 0xD2	; 210
   161b2:	09 c0       	rjmp	.+18     	; 0x161c6 <_spi_init+0x22>
		else
			SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   161b4:	82 e5       	ldi	r24, 0x52	; 82
   161b6:	07 c0       	rjmp	.+14     	; 0x161c6 <_spi_init+0x22>
	}
	else{
		_SPI_DDR = (1 << _SPI_MISO);
   161b8:	88 e0       	ldi	r24, 0x08	; 8
   161ba:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   161bc:	66 23       	and	r22, r22
   161be:	11 f0       	breq	.+4      	; 0x161c4 <_spi_init+0x20>
			SPCR = (1 << SPIE) | (1 << SPE);
   161c0:	80 ec       	ldi	r24, 0xC0	; 192
   161c2:	01 c0       	rjmp	.+2      	; 0x161c6 <_spi_init+0x22>
		else
			SPCR = (1 << SPE);
   161c4:	80 e4       	ldi	r24, 0x40	; 64
   161c6:	8d b9       	out	0x0d, r24	; 13
   161c8:	08 95       	ret

000161ca <_spi_enable>:
	}
}

void _spi_enable(unsigned char __select){
	if(__select == 0){
   161ca:	88 23       	and	r24, r24
   161cc:	19 f4       	brne	.+6      	; 0x161d4 <_spi_enable+0xa>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   161ce:	db 9a       	sbi	0x1b, 3	; 27
		sbi(_MMC_PORT, _MMC_PIN);
   161d0:	1b 9a       	sbi	0x03, 3	; 3
   161d2:	08 95       	ret
	}
	if(__select == 1){
   161d4:	81 30       	cpi	r24, 0x01	; 1
   161d6:	39 f4       	brne	.+14     	; 0x161e6 <_spi_enable+0x1c>
		sbi(_MMC_PORT, _MMC_PIN);
   161d8:	1b 9a       	sbi	0x03, 3	; 3
   161da:	82 ee       	ldi	r24, 0xE2	; 226
   161dc:	94 e0       	ldi	r25, 0x04	; 4
   161de:	01 97       	sbiw	r24, 0x01	; 1
   161e0:	f1 f7       	brne	.-4      	; 0x161de <_spi_enable+0x14>
		_delay_ms(5);
		cbi(_SLAVE_PORT, _SLAVE_PIN);
   161e2:	db 98       	cbi	0x1b, 3	; 27
   161e4:	08 95       	ret
	}
	if(__select == 2){
   161e6:	82 30       	cpi	r24, 0x02	; 2
   161e8:	31 f4       	brne	.+12     	; 0x161f6 <_spi_enable+0x2c>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   161ea:	db 9a       	sbi	0x1b, 3	; 27
   161ec:	82 ee       	ldi	r24, 0xE2	; 226
   161ee:	94 e0       	ldi	r25, 0x04	; 4
   161f0:	01 97       	sbiw	r24, 0x01	; 1
   161f2:	f1 f7       	brne	.-4      	; 0x161f0 <_spi_enable+0x26>
		_delay_ms(5);
		cbi(_MMC_PORT, _MMC_PIN);
   161f4:	1b 98       	cbi	0x03, 3	; 3
   161f6:	08 95       	ret

000161f8 <_spi>:
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   161f8:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   161fa:	77 9b       	sbis	0x0e, 7	; 14
   161fc:	fe cf       	rjmp	.-4      	; 0x161fa <_spi+0x2>
	return SPDR;
   161fe:	8f b1       	in	r24, 0x0f	; 15
}
   16200:	08 95       	ret

00016202 <_spi_rx>:


unsigned char _spi_rx(unsigned char __select){
	unsigned char __i = 0;

	_spi_enable(__select);
   16202:	0e 94 e5 b0 	call	0x161ca	; 0x161ca <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16206:	81 e4       	ldi	r24, 0x41	; 65
   16208:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1620a:	77 9b       	sbis	0x0e, 7	; 14
   1620c:	fe cf       	rjmp	.-4      	; 0x1620a <_spi_rx+0x8>
	return SPDR;
   1620e:	8f b1       	in	r24, 0x0f	; 15
unsigned char _spi_rx(unsigned char __select){
	unsigned char __i = 0;

	_spi_enable(__select);

		__spi_char = _spi(0x41);
   16210:	80 93 06 10 	sts	0x1006, r24
		if(__spi_char==0xff) return 0;
   16214:	8f 3f       	cpi	r24, 0xFF	; 255
   16216:	11 f4       	brne	.+4      	; 0x1621c <_spi_rx+0x1a>
   16218:	80 e0       	ldi	r24, 0x00	; 0
   1621a:	08 95       	ret
		if(__spi_char==0x55) return 1;
   1621c:	85 35       	cpi	r24, 0x55	; 85
   1621e:	11 f4       	brne	.+4      	; 0x16224 <_spi_rx+0x22>
   16220:	81 e0       	ldi	r24, 0x01	; 1
   16222:	08 95       	ret
		if(__spi_char==0x02) return 2;
   16224:	82 30       	cpi	r24, 0x02	; 2
   16226:	21 f0       	breq	.+8      	; 0x16230 <_spi_rx+0x2e>
	_spi_enable(_SPI_NONE);
   16228:	80 e0       	ldi	r24, 0x00	; 0
   1622a:	0e 94 e5 b0 	call	0x161ca	; 0x161ca <_spi_enable>
   1622e:	85 e1       	ldi	r24, 0x15	; 21
	return 21;
}
   16230:	08 95       	ret

00016232 <_spi_tx>:

unsigned char _spi_tx(unsigned char __command, unsigned char __select, char* __message){
   16232:	1f 93       	push	r17
   16234:	cf 93       	push	r28
   16236:	df 93       	push	r29
   16238:	18 2f       	mov	r17, r24
   1623a:	86 2f       	mov	r24, r22
   1623c:	ea 01       	movw	r28, r20
	_spi_enable(__select);
   1623e:	0e 94 e5 b0 	call	0x161ca	; 0x161ca <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16242:	8b e7       	ldi	r24, 0x7B	; 123
   16244:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16246:	77 9b       	sbis	0x0e, 7	; 14
   16248:	fe cf       	rjmp	.-4      	; 0x16246 <_spi_tx+0x14>
	return SPDR;
   1624a:	8f b1       	in	r24, 0x0f	; 15
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   1624c:	1f b9       	out	0x0f, r17	; 15
	while(!(SPSR & (1 << SPIF)));
   1624e:	77 9b       	sbis	0x0e, 7	; 14
   16250:	fe cf       	rjmp	.-4      	; 0x1624e <_spi_tx+0x1c>
	return SPDR;
   16252:	8f b1       	in	r24, 0x0f	; 15
unsigned char _spi_tx(unsigned char __command, unsigned char __select, char* __message){
	_spi_enable(__select);
	_spi(0x7B);
	_spi(__command);

	if(strlen(__message) > 0){
   16254:	88 81       	ld	r24, Y
   16256:	88 23       	and	r24, r24
   16258:	91 f0       	breq	.+36     	; 0x1627e <_spi_tx+0x4c>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   1625a:	88 e2       	ldi	r24, 0x28	; 40
   1625c:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1625e:	77 9b       	sbis	0x0e, 7	; 14
   16260:	fe cf       	rjmp	.-4      	; 0x1625e <_spi_tx+0x2c>
   16262:	04 c0       	rjmp	.+8      	; 0x1626c <_spi_tx+0x3a>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16264:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16266:	77 9b       	sbis	0x0e, 7	; 14
   16268:	fe cf       	rjmp	.-4      	; 0x16266 <_spi_tx+0x34>
	_spi(__command);

	if(strlen(__message) > 0){
		_spi(0x28);
		while(*__message)
			_spi(*__message++);
   1626a:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
	while(!(SPSR & (1 << SPIF)));
	return SPDR;
   1626c:	8f b1       	in	r24, 0x0f	; 15
	_spi(0x7B);
	_spi(__command);

	if(strlen(__message) > 0){
		_spi(0x28);
		while(*__message)
   1626e:	88 81       	ld	r24, Y
   16270:	88 23       	and	r24, r24
   16272:	c1 f7       	brne	.-16     	; 0x16264 <_spi_tx+0x32>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16274:	89 e2       	ldi	r24, 0x29	; 41
   16276:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16278:	77 9b       	sbis	0x0e, 7	; 14
   1627a:	fe cf       	rjmp	.-4      	; 0x16278 <_spi_tx+0x46>
	return SPDR;
   1627c:	8f b1       	in	r24, 0x0f	; 15
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   1627e:	8d e7       	ldi	r24, 0x7D	; 125
   16280:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16282:	77 9b       	sbis	0x0e, 7	; 14
   16284:	fe cf       	rjmp	.-4      	; 0x16282 <_spi_tx+0x50>
	return SPDR;
   16286:	8f b1       	in	r24, 0x0f	; 15
			_spi(*__message++);
		_spi(0x29);
	}

	_spi(0x7D);
	_spi_enable(_SPI_NONE);
   16288:	80 e0       	ldi	r24, 0x00	; 0
   1628a:	0e 94 e5 b0 	call	0x161ca	; 0x161ca <_spi_enable>
	return 0;
}
   1628e:	80 e0       	ldi	r24, 0x00	; 0
   16290:	df 91       	pop	r29
   16292:	cf 91       	pop	r28
   16294:	1f 91       	pop	r17
   16296:	08 95       	ret

00016298 <_spi_txnum>:

unsigned char _spi_txnum(unsigned char __command, unsigned char __select, char* __message, unsigned char __num){
   16298:	ff 92       	push	r15
   1629a:	0f 93       	push	r16
   1629c:	1f 93       	push	r17
   1629e:	86 2f       	mov	r24, r22
   162a0:	14 2f       	mov	r17, r20
   162a2:	05 2f       	mov	r16, r21
   162a4:	f2 2e       	mov	r15, r18
	unsigned char	__i;

	_spi_enable(__select);
   162a6:	0e 94 e5 b0 	call	0x161ca	; 0x161ca <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   162aa:	82 e0       	ldi	r24, 0x02	; 2
   162ac:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   162ae:	77 9b       	sbis	0x0e, 7	; 14
   162b0:	fe cf       	rjmp	.-4      	; 0x162ae <_spi_txnum+0x16>
	return SPDR;
   162b2:	8f b1       	in	r24, 0x0f	; 15
	unsigned char	__i;

	_spi_enable(__select);
	_spi(0x02);

	if(__num > 0){
   162b4:	ff 20       	and	r15, r15
   162b6:	79 f0       	breq	.+30     	; 0x162d6 <_spi_txnum+0x3e>
   162b8:	81 2f       	mov	r24, r17
   162ba:	90 2f       	mov	r25, r16
   162bc:	9c 01       	movw	r18, r24
   162be:	f9 01       	movw	r30, r18
   162c0:	90 e0       	ldi	r25, 0x00	; 0
   162c2:	07 c0       	rjmp	.+14     	; 0x162d2 <_spi_txnum+0x3a>
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
   162c4:	80 81       	ld	r24, Z
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   162c6:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   162c8:	77 9b       	sbis	0x0e, 7	; 14
   162ca:	fe cf       	rjmp	.-4      	; 0x162c8 <_spi_txnum+0x30>
	return SPDR;
   162cc:	8f b1       	in	r24, 0x0f	; 15

	_spi_enable(__select);
	_spi(0x02);

	if(__num > 0){
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
   162ce:	9f 5f       	subi	r25, 0xFF	; 255
   162d0:	31 96       	adiw	r30, 0x01	; 1
   162d2:	9f 15       	cp	r25, r15
   162d4:	b8 f3       	brcs	.-18     	; 0x162c4 <_spi_txnum+0x2c>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   162d6:	83 e0       	ldi	r24, 0x03	; 3
   162d8:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   162da:	77 9b       	sbis	0x0e, 7	; 14
   162dc:	fe cf       	rjmp	.-4      	; 0x162da <_spi_txnum+0x42>
	return SPDR;
   162de:	8f b1       	in	r24, 0x0f	; 15
	if(__num > 0){
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
				}// for

	_spi(0x03);
	_spi_enable(_SPI_NONE);
   162e0:	80 e0       	ldi	r24, 0x00	; 0
   162e2:	0e 94 e5 b0 	call	0x161ca	; 0x161ca <_spi_enable>
	return 0;
}
   162e6:	80 e0       	ldi	r24, 0x00	; 0
   162e8:	1f 91       	pop	r17
   162ea:	0f 91       	pop	r16
   162ec:	ff 90       	pop	r15
   162ee:	08 95       	ret

000162f0 <_spi_interrupt>:

unsigned char _spi_interrupt(void){
	__spi_char = SPDR;
   162f0:	9f b1       	in	r25, 0x0f	; 15
   162f2:	90 93 06 10 	sts	0x1006, r25

	if(__spi_char == 0xFF){
   162f6:	9f 3f       	cpi	r25, 0xFF	; 255
   162f8:	e9 f4       	brne	.+58     	; 0x16334 <_spi_interrupt+0x44>
		if(__spi_istransmit){
   162fa:	80 91 fb 03 	lds	r24, 0x03FB
   162fe:	88 23       	and	r24, r24
   16300:	b9 f0       	breq	.+46     	; 0x16330 <_spi_interrupt+0x40>
			SPDR = __command[__spi_i];
   16302:	90 91 05 10 	lds	r25, 0x1005
   16306:	e9 2f       	mov	r30, r25
   16308:	f0 e0       	ldi	r31, 0x00	; 0
   1630a:	e7 53       	subi	r30, 0x37	; 55
   1630c:	fc 4f       	sbci	r31, 0xFC	; 252
   1630e:	80 81       	ld	r24, Z
   16310:	8f b9       	out	0x0f, r24	; 15
			if(__command[__spi_i] == 0x7D){
   16312:	8d 37       	cpi	r24, 0x7D	; 125
   16314:	19 f4       	brne	.+6      	; 0x1631c <_spi_interrupt+0x2c>
				__spi_i = 0;
   16316:	10 92 05 10 	sts	0x1005, r1
   1631a:	07 c0       	rjmp	.+14     	; 0x1632a <_spi_interrupt+0x3a>
				__spi_istransmit = 0;
			}
			else{
				__spi_i++;
   1631c:	89 2f       	mov	r24, r25
   1631e:	8f 5f       	subi	r24, 0xFF	; 255
   16320:	80 93 05 10 	sts	0x1005, r24
				if(__spi_i == _MAX_COMMAND)
   16324:	82 33       	cpi	r24, 0x32	; 50
   16326:	09 f0       	breq	.+2      	; 0x1632a <_spi_interrupt+0x3a>
   16328:	3f c0       	rjmp	.+126    	; 0x163a8 <_spi_interrupt+0xb8>
					__spi_istransmit = 0;
   1632a:	10 92 fb 03 	sts	0x03FB, r1
   1632e:	3c c0       	rjmp	.+120    	; 0x163a8 <_spi_interrupt+0xb8>
			}
		}
		else
			SPDR = 0xFF;
   16330:	9f b9       	out	0x0f, r25	; 15
   16332:	3a c0       	rjmp	.+116    	; 0x163a8 <_spi_interrupt+0xb8>
	}
	else{
		if(__spi_char == 0x7D && __spi_isstart){
   16334:	9d 37       	cpi	r25, 0x7D	; 125
   16336:	69 f4       	brne	.+26     	; 0x16352 <_spi_interrupt+0x62>
   16338:	80 91 c4 03 	lds	r24, 0x03C4
   1633c:	88 23       	and	r24, r24
   1633e:	49 f0       	breq	.+18     	; 0x16352 <_spi_interrupt+0x62>
			__spi_isstart = 0;
   16340:	10 92 c4 03 	sts	0x03C4, r1
			__spi_ismessage = 0;
   16344:	10 92 c5 03 	sts	0x03C5, r1
			__spi_i = 0;
   16348:	10 92 05 10 	sts	0x1005, r1
			__command_flag = 1;
   1634c:	81 e0       	ldi	r24, 0x01	; 1
   1634e:	80 93 fe 03 	sts	0x03FE, r24
		}
		if(__spi_isstart && __spi_ismessage){
   16352:	20 91 c4 03 	lds	r18, 0x03C4
   16356:	22 23       	and	r18, r18
   16358:	f1 f0       	breq	.+60     	; 0x16396 <_spi_interrupt+0xa6>
   1635a:	80 91 c5 03 	lds	r24, 0x03C5
   1635e:	88 23       	and	r24, r24
   16360:	29 f1       	breq	.+74     	; 0x163ac <_spi_interrupt+0xbc>
			if(__spi_char != 0x29){
   16362:	99 32       	cpi	r25, 0x29	; 41
   16364:	c1 f0       	breq	.+48     	; 0x16396 <_spi_interrupt+0xa6>
				__package[__spi_i] = __spi_char;
   16366:	80 91 05 10 	lds	r24, 0x1005
   1636a:	e8 2f       	mov	r30, r24
   1636c:	f0 e0       	ldi	r31, 0x00	; 0
   1636e:	ed 5f       	subi	r30, 0xFD	; 253
   16370:	fb 4f       	sbci	r31, 0xFB	; 251
   16372:	90 83       	st	Z, r25
				__package[__spi_i + 1] = '\0';
   16374:	11 82       	std	Z+1, r1	; 0x01
				__spi_i++;
   16376:	8f 5f       	subi	r24, 0xFF	; 255
   16378:	80 93 05 10 	sts	0x1005, r24
				if(__spi_i == _MAX_PACKAGE)
   1637c:	82 38       	cpi	r24, 0x82	; 130
   1637e:	59 f4       	brne	.+22     	; 0x16396 <_spi_interrupt+0xa6>
					__spi_i = 0;
   16380:	10 92 05 10 	sts	0x1005, r1
   16384:	08 c0       	rjmp	.+16     	; 0x16396 <_spi_interrupt+0xa6>
			}
		}
		if(__spi_isstart && !__spi_ismessage){
			if(__spi_char == 0x28){
				__spi_ismessage = 1;
   16386:	81 e0       	ldi	r24, 0x01	; 1
   16388:	80 93 c5 03 	sts	0x03C5, r24
				__spi_i = 0;
   1638c:	10 92 05 10 	sts	0x1005, r1
   16390:	0b c0       	rjmp	.+22     	; 0x163a8 <_spi_interrupt+0xb8>
			}
			else
				__command_set = __spi_char;
   16392:	90 93 00 04 	sts	0x0400, r25
		}
		if(__spi_char == 0x7B && !__spi_isstart){
   16396:	9b 37       	cpi	r25, 0x7B	; 123
   16398:	39 f4       	brne	.+14     	; 0x163a8 <_spi_interrupt+0xb8>
   1639a:	22 23       	and	r18, r18
   1639c:	29 f4       	brne	.+10     	; 0x163a8 <_spi_interrupt+0xb8>
			__spi_isstart = 1;
   1639e:	81 e0       	ldi	r24, 0x01	; 1
   163a0:	80 93 c4 03 	sts	0x03C4, r24
			__spi_ismessage = 0;
   163a4:	10 92 c5 03 	sts	0x03C5, r1
		}
	}

	return 0;
}
   163a8:	80 e0       	ldi	r24, 0x00	; 0
   163aa:	08 95       	ret
				if(__spi_i == _MAX_PACKAGE)
					__spi_i = 0;
			}
		}
		if(__spi_isstart && !__spi_ismessage){
			if(__spi_char == 0x28){
   163ac:	98 32       	cpi	r25, 0x28	; 40
   163ae:	89 f7       	brne	.-30     	; 0x16392 <_spi_interrupt+0xa2>
   163b0:	ea cf       	rjmp	.-44     	; 0x16386 <_spi_interrupt+0x96>

000163b2 <_spi_command>:
	}

	return 0;
}

void _spi_command(unsigned char __cmd, char* __cell){
   163b2:	fb 01       	movw	r30, r22
	unsigned char __i = 0;

	__command[__i++] = 0x7B;
   163b4:	9b e7       	ldi	r25, 0x7B	; 123
   163b6:	90 93 c9 03 	sts	0x03C9, r25
	__command[__i++] = __cmd;
   163ba:	80 93 ca 03 	sts	0x03CA, r24

	if(strlen(__cell) > 0){
   163be:	80 81       	ld	r24, Z
   163c0:	88 23       	and	r24, r24
   163c2:	11 f4       	brne	.+4      	; 0x163c8 <_spi_command+0x16>
   163c4:	92 e0       	ldi	r25, 0x02	; 2
   163c6:	16 c0       	rjmp	.+44     	; 0x163f4 <_spi_command+0x42>
		__command[__i++] = 0x28;
   163c8:	88 e2       	ldi	r24, 0x28	; 40
   163ca:	80 93 cb 03 	sts	0x03CB, r24
   163ce:	83 e0       	ldi	r24, 0x03	; 3
   163d0:	05 c0       	rjmp	.+10     	; 0x163dc <_spi_command+0x2a>

		while(*__cell)
			__command[__i++] = *__cell++;
   163d2:	a7 53       	subi	r26, 0x37	; 55
   163d4:	bc 4f       	sbci	r27, 0xFC	; 252
   163d6:	9c 93       	st	X, r25
   163d8:	82 2f       	mov	r24, r18
   163da:	31 96       	adiw	r30, 0x01	; 1
	__command[__i++] = __cmd;

	if(strlen(__cell) > 0){
		__command[__i++] = 0x28;

		while(*__cell)
   163dc:	90 81       	ld	r25, Z
   163de:	a8 2f       	mov	r26, r24
   163e0:	b0 e0       	ldi	r27, 0x00	; 0
   163e2:	28 2f       	mov	r18, r24
   163e4:	2f 5f       	subi	r18, 0xFF	; 255
   163e6:	99 23       	and	r25, r25
   163e8:	a1 f7       	brne	.-24     	; 0x163d2 <_spi_command+0x20>
			__command[__i++] = *__cell++;

		__command[__i++] = 0x29;
   163ea:	a7 53       	subi	r26, 0x37	; 55
   163ec:	bc 4f       	sbci	r27, 0xFC	; 252
   163ee:	89 e2       	ldi	r24, 0x29	; 41
   163f0:	8c 93       	st	X, r24
   163f2:	92 2f       	mov	r25, r18
	}

	__command[__i++] = 0x7D;
   163f4:	e9 2f       	mov	r30, r25
   163f6:	f0 e0       	ldi	r31, 0x00	; 0
   163f8:	e7 53       	subi	r30, 0x37	; 55
   163fa:	fc 4f       	sbci	r31, 0xFC	; 252
   163fc:	8d e7       	ldi	r24, 0x7D	; 125
   163fe:	80 83       	st	Z, r24
	__command[__i++] = '\0';
   16400:	9f 5f       	subi	r25, 0xFF	; 255
   16402:	e9 2f       	mov	r30, r25
   16404:	f0 e0       	ldi	r31, 0x00	; 0
   16406:	e7 53       	subi	r30, 0x37	; 55
   16408:	fc 4f       	sbci	r31, 0xFC	; 252
   1640a:	10 82       	st	Z, r1
}
   1640c:	08 95       	ret

0001640e <_rtc>:

#include <compat/twi.h>

#include "RTC.h"

unsigned char _rtc(int __addr, int __len, char* __datetime, unsigned char __dir){
   1640e:	98 2f       	mov	r25, r24
	int				__twcr;
	unsigned char	__i = 0;
	
	if(__dir){
   16410:	22 23       	and	r18, r18
   16412:	09 f4       	brne	.+2      	; 0x16416 <_rtc+0x8>
   16414:	49 c0       	rjmp	.+146    	; 0x164a8 <_rtc+0x9a>
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   16416:	84 ea       	ldi	r24, 0xA4	; 164
   16418:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1641c:	80 91 74 00 	lds	r24, 0x0074
   16420:	87 ff       	sbrs	r24, 7
   16422:	fc cf       	rjmp	.-8      	; 0x1641c <_rtc+0xe>
		if(TW_STATUS != TW_START)
   16424:	80 91 71 00 	lds	r24, 0x0071
   16428:	88 7f       	andi	r24, 0xF8	; 248
   1642a:	88 30       	cpi	r24, 0x08	; 8
   1642c:	09 f0       	breq	.+2      	; 0x16430 <_rtc+0x22>
   1642e:	af c0       	rjmp	.+350    	; 0x1658e <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   16430:	80 ed       	ldi	r24, 0xD0	; 208
   16432:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   16436:	84 e8       	ldi	r24, 0x84	; 132
   16438:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1643c:	80 91 74 00 	lds	r24, 0x0074
   16440:	87 ff       	sbrs	r24, 7
   16442:	fc cf       	rjmp	.-8      	; 0x1643c <_rtc+0x2e>
		if(TW_STATUS != TW_MT_SLA_ACK)
   16444:	80 91 71 00 	lds	r24, 0x0071
   16448:	88 7f       	andi	r24, 0xF8	; 248
   1644a:	88 31       	cpi	r24, 0x18	; 24
   1644c:	09 f0       	breq	.+2      	; 0x16450 <_rtc+0x42>
   1644e:	9f c0       	rjmp	.+318    	; 0x1658e <_rtc+0x180>
			return 1;

		TWDR = __addr;
   16450:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   16454:	84 e8       	ldi	r24, 0x84	; 132
   16456:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1645a:	80 91 74 00 	lds	r24, 0x0074
   1645e:	87 ff       	sbrs	r24, 7
   16460:	fc cf       	rjmp	.-8      	; 0x1645a <_rtc+0x4c>
		if(TW_STATUS != TW_MT_DATA_ACK)
   16462:	80 91 71 00 	lds	r24, 0x0071
   16466:	88 7f       	andi	r24, 0xF8	; 248
   16468:	88 32       	cpi	r24, 0x28	; 40
   1646a:	09 f0       	breq	.+2      	; 0x1646e <_rtc+0x60>
   1646c:	90 c0       	rjmp	.+288    	; 0x1658e <_rtc+0x180>
   1646e:	9b 01       	movw	r18, r22
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
			TWCR = _BV(TWINT) | _BV(TWEN);
   16470:	94 e8       	ldi	r25, 0x84	; 132
   16472:	14 c0       	rjmp	.+40     	; 0x1649c <_rtc+0x8e>
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
   16474:	fa 01       	movw	r30, r20
   16476:	e8 0f       	add	r30, r24
   16478:	f1 1d       	adc	r31, r1
   1647a:	80 81       	ld	r24, Z
   1647c:	80 93 73 00 	sts	0x0073, r24
			TWCR = _BV(TWINT) | _BV(TWEN);
   16480:	90 93 74 00 	sts	0x0074, r25
			_rtc_response;
   16484:	80 91 74 00 	lds	r24, 0x0074
   16488:	87 ff       	sbrs	r24, 7
   1648a:	fc cf       	rjmp	.-8      	; 0x16484 <_rtc+0x76>
			if(TW_STATUS == TW_MT_DATA_NACK)
   1648c:	80 91 71 00 	lds	r24, 0x0071
   16490:	88 7f       	andi	r24, 0xF8	; 248
   16492:	80 33       	cpi	r24, 0x30	; 48
   16494:	09 f4       	brne	.+2      	; 0x16498 <_rtc+0x8a>
   16496:	7b c0       	rjmp	.+246    	; 0x1658e <_rtc+0x180>
		TWCR = _BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
   16498:	21 50       	subi	r18, 0x01	; 1
   1649a:	30 40       	sbci	r19, 0x00	; 0
   1649c:	86 2f       	mov	r24, r22
   1649e:	82 1b       	sub	r24, r18
   164a0:	12 16       	cp	r1, r18
   164a2:	13 06       	cpc	r1, r19
   164a4:	3c f3       	brlt	.-50     	; 0x16474 <_rtc+0x66>
   164a6:	6e c0       	rjmp	.+220    	; 0x16584 <_rtc+0x176>
		}

		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
	}
	else{
		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   164a8:	84 ea       	ldi	r24, 0xA4	; 164
   164aa:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   164ae:	80 91 74 00 	lds	r24, 0x0074
   164b2:	87 ff       	sbrs	r24, 7
   164b4:	fc cf       	rjmp	.-8      	; 0x164ae <_rtc+0xa0>
		if(TW_STATUS != TW_START)
   164b6:	80 91 71 00 	lds	r24, 0x0071
   164ba:	88 7f       	andi	r24, 0xF8	; 248
   164bc:	88 30       	cpi	r24, 0x08	; 8
   164be:	09 f0       	breq	.+2      	; 0x164c2 <_rtc+0xb4>
   164c0:	66 c0       	rjmp	.+204    	; 0x1658e <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   164c2:	80 ed       	ldi	r24, 0xD0	; 208
   164c4:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   164c8:	84 e8       	ldi	r24, 0x84	; 132
   164ca:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   164ce:	80 91 74 00 	lds	r24, 0x0074
   164d2:	87 ff       	sbrs	r24, 7
   164d4:	fc cf       	rjmp	.-8      	; 0x164ce <_rtc+0xc0>
		if(TW_STATUS != TW_MT_SLA_ACK)
   164d6:	80 91 71 00 	lds	r24, 0x0071
   164da:	88 7f       	andi	r24, 0xF8	; 248
   164dc:	88 31       	cpi	r24, 0x18	; 24
   164de:	09 f0       	breq	.+2      	; 0x164e2 <_rtc+0xd4>
   164e0:	56 c0       	rjmp	.+172    	; 0x1658e <_rtc+0x180>
			return 1;

		TWDR = __addr;
   164e2:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   164e6:	84 e8       	ldi	r24, 0x84	; 132
   164e8:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   164ec:	80 91 74 00 	lds	r24, 0x0074
   164f0:	87 ff       	sbrs	r24, 7
   164f2:	fc cf       	rjmp	.-8      	; 0x164ec <_rtc+0xde>
		if(TW_STATUS != TW_MT_DATA_ACK)
   164f4:	80 91 71 00 	lds	r24, 0x0071
   164f8:	88 7f       	andi	r24, 0xF8	; 248
   164fa:	88 32       	cpi	r24, 0x28	; 40
   164fc:	09 f0       	breq	.+2      	; 0x16500 <_rtc+0xf2>
   164fe:	47 c0       	rjmp	.+142    	; 0x1658e <_rtc+0x180>
			return 1;

		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   16500:	84 ea       	ldi	r24, 0xA4	; 164
   16502:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16506:	80 91 74 00 	lds	r24, 0x0074
   1650a:	87 ff       	sbrs	r24, 7
   1650c:	fc cf       	rjmp	.-8      	; 0x16506 <_rtc+0xf8>
		if(TW_STATUS != TW_REP_START)
   1650e:	80 91 71 00 	lds	r24, 0x0071
   16512:	88 7f       	andi	r24, 0xF8	; 248
   16514:	80 31       	cpi	r24, 0x10	; 16
   16516:	d9 f5       	brne	.+118    	; 0x1658e <_rtc+0x180>
			return 1;

		TWDR = _DS1307R;
   16518:	81 ed       	ldi	r24, 0xD1	; 209
   1651a:	80 93 73 00 	sts	0x0073, r24
		TWCR =_BV(TWINT) | _BV(TWEN);
   1651e:	84 e8       	ldi	r24, 0x84	; 132
   16520:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16524:	80 91 74 00 	lds	r24, 0x0074
   16528:	87 ff       	sbrs	r24, 7
   1652a:	fc cf       	rjmp	.-8      	; 0x16524 <_rtc+0x116>
		if(TW_STATUS != TW_MR_SLA_ACK)
   1652c:	80 91 71 00 	lds	r24, 0x0071
   16530:	88 7f       	andi	r24, 0xF8	; 248
   16532:	80 34       	cpi	r24, 0x40	; 64
   16534:	61 f5       	brne	.+88     	; 0x1658e <_rtc+0x180>
   16536:	24 ec       	ldi	r18, 0xC4	; 196
   16538:	30 e0       	ldi	r19, 0x00	; 0
   1653a:	90 e0       	ldi	r25, 0x00	; 0
   1653c:	20 c0       	rjmp	.+64     	; 0x1657e <_rtc+0x170>
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
			if(__len == 1)
   1653e:	61 30       	cpi	r22, 0x01	; 1
   16540:	71 05       	cpc	r23, r1
   16542:	11 f4       	brne	.+4      	; 0x16548 <_rtc+0x13a>
   16544:	24 e8       	ldi	r18, 0x84	; 132
   16546:	30 e0       	ldi	r19, 0x00	; 0
				__twcr = _BV(TWINT) | _BV(TWEN);
			TWCR = __twcr;
   16548:	20 93 74 00 	sts	0x0074, r18
			_rtc_response;
   1654c:	80 91 74 00 	lds	r24, 0x0074
   16550:	87 ff       	sbrs	r24, 7
   16552:	fc cf       	rjmp	.-8      	; 0x1654c <_rtc+0x13e>
			if(TW_STATUS == TW_MR_DATA_NACK)
   16554:	80 91 71 00 	lds	r24, 0x0071
   16558:	88 7f       	andi	r24, 0xF8	; 248
   1655a:	88 35       	cpi	r24, 0x58	; 88
   1655c:	11 f4       	brne	.+4      	; 0x16562 <_rtc+0x154>
   1655e:	60 e0       	ldi	r22, 0x00	; 0
   16560:	70 e0       	ldi	r23, 0x00	; 0
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
   16562:	80 91 71 00 	lds	r24, 0x0071
   16566:	88 7f       	andi	r24, 0xF8	; 248
   16568:	80 35       	cpi	r24, 0x50	; 80
   1656a:	39 f4       	brne	.+14     	; 0x1657a <_rtc+0x16c>
				__datetime[__i++] = TWDR;
   1656c:	80 91 73 00 	lds	r24, 0x0073
   16570:	fa 01       	movw	r30, r20
   16572:	e9 0f       	add	r30, r25
   16574:	f1 1d       	adc	r31, r1
   16576:	80 83       	st	Z, r24
   16578:	9f 5f       	subi	r25, 0xFF	; 255
		TWCR =_BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MR_SLA_ACK)
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
   1657a:	61 50       	subi	r22, 0x01	; 1
   1657c:	70 40       	sbci	r23, 0x00	; 0
   1657e:	16 16       	cp	r1, r22
   16580:	17 06       	cpc	r1, r23
   16582:	ec f2       	brlt	.-70     	; 0x1653e <_rtc+0x130>
			if(TW_STATUS == TW_MR_DATA_NACK)
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
				__datetime[__i++] = TWDR;
		}
		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
   16584:	84 e9       	ldi	r24, 0x94	; 148
   16586:	80 93 74 00 	sts	0x0074, r24
   1658a:	80 e0       	ldi	r24, 0x00	; 0
   1658c:	08 95       	ret
   1658e:	81 e0       	ldi	r24, 0x01	; 1
	}

    return 0;
}
   16590:	08 95       	ret

00016592 <_datetime>:

void _datetime(unsigned char __mode, char* __date, char* __time){
   16592:	ef 92       	push	r14
   16594:	ff 92       	push	r15
   16596:	0f 93       	push	r16
   16598:	1f 93       	push	r17
   1659a:	df 93       	push	r29
   1659c:	cf 93       	push	r28
   1659e:	cd b7       	in	r28, 0x3d	; 61
   165a0:	de b7       	in	r29, 0x3e	; 62
   165a2:	64 97       	sbiw	r28, 0x14	; 20
   165a4:	0f b6       	in	r0, 0x3f	; 63
   165a6:	f8 94       	cli
   165a8:	de bf       	out	0x3e, r29	; 62
   165aa:	0f be       	out	0x3f, r0	; 63
   165ac:	cd bf       	out	0x3d, r28	; 61
   165ae:	28 2f       	mov	r18, r24
   165b0:	8b 01       	movw	r16, r22
   165b2:	7a 01       	movw	r14, r20
   165b4:	ae 01       	movw	r20, r28
   165b6:	4f 5f       	subi	r20, 0xFF	; 255
   165b8:	5f 4f       	sbci	r21, 0xFF	; 255
	char	__datetime[20];

	if(__mode){
   165ba:	88 23       	and	r24, r24
   165bc:	99 f1       	breq	.+102    	; 0x16624 <_datetime+0x92>
		__datetime[4] = (((__date[0] - 0x30) & 0x0F) << 4) + ((__date[1] - 0x30) & 0x0F);
   165be:	fb 01       	movw	r30, r22
   165c0:	90 81       	ld	r25, Z
   165c2:	92 95       	swap	r25
   165c4:	90 7f       	andi	r25, 0xF0	; 240
   165c6:	81 81       	ldd	r24, Z+1	; 0x01
   165c8:	8f 70       	andi	r24, 0x0F	; 15
   165ca:	98 0f       	add	r25, r24
   165cc:	9d 83       	std	Y+5, r25	; 0x05
		__datetime[5] = (((__date[3] - 0x30) & 0x0F) << 4) + ((__date[4] - 0x30) & 0x0F);
   165ce:	93 81       	ldd	r25, Z+3	; 0x03
   165d0:	92 95       	swap	r25
   165d2:	90 7f       	andi	r25, 0xF0	; 240
   165d4:	84 81       	ldd	r24, Z+4	; 0x04
   165d6:	8f 70       	andi	r24, 0x0F	; 15
   165d8:	98 0f       	add	r25, r24
   165da:	9e 83       	std	Y+6, r25	; 0x06
		__datetime[6] = (((__date[6] - 0x30) & 0x0F) << 4) + ((__date[7] - 0x30) & 0x0F);
   165dc:	96 81       	ldd	r25, Z+6	; 0x06
   165de:	92 95       	swap	r25
   165e0:	90 7f       	andi	r25, 0xF0	; 240
   165e2:	87 81       	ldd	r24, Z+7	; 0x07
   165e4:	8f 70       	andi	r24, 0x0F	; 15
   165e6:	98 0f       	add	r25, r24
   165e8:	9f 83       	std	Y+7, r25	; 0x07

		__datetime[2] = (((__time[0] - 0x30) & 0x0F) << 4) + ((__time[1] - 0x30) & 0x0F);
   165ea:	f7 01       	movw	r30, r14
   165ec:	90 81       	ld	r25, Z
   165ee:	92 95       	swap	r25
   165f0:	90 7f       	andi	r25, 0xF0	; 240
   165f2:	81 81       	ldd	r24, Z+1	; 0x01
   165f4:	8f 70       	andi	r24, 0x0F	; 15
   165f6:	98 0f       	add	r25, r24
   165f8:	9b 83       	std	Y+3, r25	; 0x03
		__datetime[1] = (((__time[3] - 0x30) & 0x0F) << 4) + ((__time[4] - 0x30) & 0x0F);
   165fa:	93 81       	ldd	r25, Z+3	; 0x03
   165fc:	92 95       	swap	r25
   165fe:	90 7f       	andi	r25, 0xF0	; 240
   16600:	84 81       	ldd	r24, Z+4	; 0x04
   16602:	8f 70       	andi	r24, 0x0F	; 15
   16604:	98 0f       	add	r25, r24
   16606:	9a 83       	std	Y+2, r25	; 0x02
		__datetime[0] = (((__time[6] - 0x30) & 0x0F) << 4) + ((__time[7] - 0x30) & 0x0F);
   16608:	96 81       	ldd	r25, Z+6	; 0x06
   1660a:	92 95       	swap	r25
   1660c:	90 7f       	andi	r25, 0xF0	; 240
   1660e:	87 81       	ldd	r24, Z+7	; 0x07
   16610:	8f 70       	andi	r24, 0x0F	; 15
   16612:	98 0f       	add	r25, r24
   16614:	99 83       	std	Y+1, r25	; 0x01
		_rtc(0, 8, __datetime, __mode);
   16616:	80 e0       	ldi	r24, 0x00	; 0
   16618:	90 e0       	ldi	r25, 0x00	; 0
   1661a:	68 e0       	ldi	r22, 0x08	; 8
   1661c:	70 e0       	ldi	r23, 0x00	; 0
   1661e:	0e 94 07 b2 	call	0x1640e	; 0x1640e <_rtc>
   16622:	4a c0       	rjmp	.+148    	; 0x166b8 <_datetime+0x126>
	}
	else
		if(_rtc(0, 8, __datetime, __mode) != 1){
   16624:	80 e0       	ldi	r24, 0x00	; 0
   16626:	90 e0       	ldi	r25, 0x00	; 0
   16628:	68 e0       	ldi	r22, 0x08	; 8
   1662a:	70 e0       	ldi	r23, 0x00	; 0
   1662c:	20 e0       	ldi	r18, 0x00	; 0
   1662e:	0e 94 07 b2 	call	0x1640e	; 0x1640e <_rtc>
   16632:	81 30       	cpi	r24, 0x01	; 1
   16634:	09 f4       	brne	.+2      	; 0x16638 <_datetime+0xa6>
   16636:	40 c0       	rjmp	.+128    	; 0x166b8 <_datetime+0x126>
			__date[0] = (__datetime[4] >> 4) + 0x30;
   16638:	9d 81       	ldd	r25, Y+5	; 0x05
   1663a:	89 2f       	mov	r24, r25
   1663c:	82 95       	swap	r24
   1663e:	8f 70       	andi	r24, 0x0F	; 15
   16640:	80 5d       	subi	r24, 0xD0	; 208
   16642:	f8 01       	movw	r30, r16
   16644:	80 83       	st	Z, r24
			__date[1] = (__datetime[4] & 0x0F) + 0x30;
   16646:	9f 70       	andi	r25, 0x0F	; 15
   16648:	90 5d       	subi	r25, 0xD0	; 208
   1664a:	91 83       	std	Z+1, r25	; 0x01
			__date[2] = '/';
   1664c:	2f e2       	ldi	r18, 0x2F	; 47
   1664e:	22 83       	std	Z+2, r18	; 0x02
			__date[3] = (__datetime[5] >> 4) + 0x30;
   16650:	9e 81       	ldd	r25, Y+6	; 0x06
   16652:	89 2f       	mov	r24, r25
   16654:	82 95       	swap	r24
   16656:	8f 70       	andi	r24, 0x0F	; 15
   16658:	80 5d       	subi	r24, 0xD0	; 208
   1665a:	83 83       	std	Z+3, r24	; 0x03
			__date[4] = (__datetime[5] & 0x0F) + 0x30;
   1665c:	9f 70       	andi	r25, 0x0F	; 15
   1665e:	90 5d       	subi	r25, 0xD0	; 208
   16660:	94 83       	std	Z+4, r25	; 0x04
			__date[5] = '/';
   16662:	25 83       	std	Z+5, r18	; 0x05
			__date[6] = (__datetime[6] >> 4) + 0x30;
   16664:	9f 81       	ldd	r25, Y+7	; 0x07
   16666:	89 2f       	mov	r24, r25
   16668:	82 95       	swap	r24
   1666a:	8f 70       	andi	r24, 0x0F	; 15
   1666c:	80 5d       	subi	r24, 0xD0	; 208
   1666e:	86 83       	std	Z+6, r24	; 0x06
			__date[7] = (__datetime[6] & 0x0F) + 0x30;
   16670:	9f 70       	andi	r25, 0x0F	; 15
   16672:	90 5d       	subi	r25, 0xD0	; 208
   16674:	97 83       	std	Z+7, r25	; 0x07
			__date[8] = '\0';
   16676:	10 86       	std	Z+8, r1	; 0x08

			__time[0] = (__datetime[2] >> 4) + 0x30;
   16678:	9b 81       	ldd	r25, Y+3	; 0x03
   1667a:	89 2f       	mov	r24, r25
   1667c:	82 95       	swap	r24
   1667e:	8f 70       	andi	r24, 0x0F	; 15
   16680:	80 5d       	subi	r24, 0xD0	; 208
   16682:	f7 01       	movw	r30, r14
   16684:	80 83       	st	Z, r24
			__time[1] = (__datetime[2] & 0x0F) + 0x30;
   16686:	9f 70       	andi	r25, 0x0F	; 15
   16688:	90 5d       	subi	r25, 0xD0	; 208
   1668a:	91 83       	std	Z+1, r25	; 0x01
			__time[2] = ':';
   1668c:	2a e3       	ldi	r18, 0x3A	; 58
   1668e:	22 83       	std	Z+2, r18	; 0x02
			__time[3] = (__datetime[1] >> 4) + 0x30;
   16690:	9a 81       	ldd	r25, Y+2	; 0x02
   16692:	89 2f       	mov	r24, r25
   16694:	82 95       	swap	r24
   16696:	8f 70       	andi	r24, 0x0F	; 15
   16698:	80 5d       	subi	r24, 0xD0	; 208
   1669a:	83 83       	std	Z+3, r24	; 0x03
			__time[4] = (__datetime[1] & 0x0F) + 0x30;
   1669c:	9f 70       	andi	r25, 0x0F	; 15
   1669e:	90 5d       	subi	r25, 0xD0	; 208
   166a0:	94 83       	std	Z+4, r25	; 0x04
			__time[5] = ':';
   166a2:	25 83       	std	Z+5, r18	; 0x05
			__time[6] = (__datetime[0] >> 4) + 0x30;
   166a4:	99 81       	ldd	r25, Y+1	; 0x01
   166a6:	89 2f       	mov	r24, r25
   166a8:	82 95       	swap	r24
   166aa:	8f 70       	andi	r24, 0x0F	; 15
   166ac:	80 5d       	subi	r24, 0xD0	; 208
   166ae:	86 83       	std	Z+6, r24	; 0x06
			__time[7] = (__datetime[0] & 0x0F) + 0x30;
   166b0:	9f 70       	andi	r25, 0x0F	; 15
   166b2:	90 5d       	subi	r25, 0xD0	; 208
   166b4:	97 83       	std	Z+7, r25	; 0x07
			__time[8] = '\0';
   166b6:	10 86       	std	Z+8, r1	; 0x08
		}
}
   166b8:	64 96       	adiw	r28, 0x14	; 20
   166ba:	0f b6       	in	r0, 0x3f	; 63
   166bc:	f8 94       	cli
   166be:	de bf       	out	0x3e, r29	; 62
   166c0:	0f be       	out	0x3f, r0	; 63
   166c2:	cd bf       	out	0x3d, r28	; 61
   166c4:	cf 91       	pop	r28
   166c6:	df 91       	pop	r29
   166c8:	1f 91       	pop	r17
   166ca:	0f 91       	pop	r16
   166cc:	ff 90       	pop	r15
   166ce:	ef 90       	pop	r14
   166d0:	08 95       	ret

000166d2 <_day>:

unsigned char _day(void){
   166d2:	df 93       	push	r29
   166d4:	cf 93       	push	r28
   166d6:	cd b7       	in	r28, 0x3d	; 61
   166d8:	de b7       	in	r29, 0x3e	; 62
   166da:	64 97       	sbiw	r28, 0x14	; 20
   166dc:	0f b6       	in	r0, 0x3f	; 63
   166de:	f8 94       	cli
   166e0:	de bf       	out	0x3e, r29	; 62
   166e2:	0f be       	out	0x3f, r0	; 63
   166e4:	cd bf       	out	0x3d, r28	; 61
	char	__datetime[20];

	if(_rtc(0, 8, __datetime, 0) != 1)
   166e6:	80 e0       	ldi	r24, 0x00	; 0
   166e8:	90 e0       	ldi	r25, 0x00	; 0
   166ea:	68 e0       	ldi	r22, 0x08	; 8
   166ec:	70 e0       	ldi	r23, 0x00	; 0
   166ee:	ae 01       	movw	r20, r28
   166f0:	4f 5f       	subi	r20, 0xFF	; 255
   166f2:	5f 4f       	sbci	r21, 0xFF	; 255
   166f4:	20 e0       	ldi	r18, 0x00	; 0
   166f6:	0e 94 07 b2 	call	0x1640e	; 0x1640e <_rtc>
   166fa:	81 30       	cpi	r24, 0x01	; 1
   166fc:	11 f4       	brne	.+4      	; 0x16702 <_day+0x30>
   166fe:	80 e0       	ldi	r24, 0x00	; 0
   16700:	02 c0       	rjmp	.+4      	; 0x16706 <_day+0x34>
		return __datetime[3] & 0x0F;
   16702:	8c 81       	ldd	r24, Y+4	; 0x04
   16704:	8f 70       	andi	r24, 0x0F	; 15
	return 0;
   16706:	64 96       	adiw	r28, 0x14	; 20
   16708:	0f b6       	in	r0, 0x3f	; 63
   1670a:	f8 94       	cli
   1670c:	de bf       	out	0x3e, r29	; 62
   1670e:	0f be       	out	0x3f, r0	; 63
   16710:	cd bf       	out	0x3d, r28	; 61
   16712:	cf 91       	pop	r28
   16714:	df 91       	pop	r29
   16716:	08 95       	ret

00016718 <_uart_baudrate>:
	}

	_uart_baudrate(__com, __baudrate);
}

void _uart_baudrate(unsigned char __com, unsigned long __baudrate){
   16718:	1f 93       	push	r17
   1671a:	18 2f       	mov	r17, r24
   1671c:	9a 01       	movw	r18, r20
   1671e:	ab 01       	movw	r20, r22
	unsigned long __br;

	__br = (unsigned long)((_CPU_DEFAULT + (__baudrate * 8)) / (__baudrate * 16) - 1);
   16720:	ca 01       	movw	r24, r20
   16722:	b9 01       	movw	r22, r18
   16724:	60 50       	subi	r22, 0x00	; 0
   16726:	70 4e       	sbci	r23, 0xE0	; 224
   16728:	83 4e       	sbci	r24, 0xE3	; 227
   1672a:	9f 4f       	sbci	r25, 0xFF	; 255
   1672c:	f3 e0       	ldi	r31, 0x03	; 3
   1672e:	66 0f       	add	r22, r22
   16730:	77 1f       	adc	r23, r23
   16732:	88 1f       	adc	r24, r24
   16734:	99 1f       	adc	r25, r25
   16736:	fa 95       	dec	r31
   16738:	d1 f7       	brne	.-12     	; 0x1672e <_uart_baudrate+0x16>
   1673a:	e4 e0       	ldi	r30, 0x04	; 4
   1673c:	22 0f       	add	r18, r18
   1673e:	33 1f       	adc	r19, r19
   16740:	44 1f       	adc	r20, r20
   16742:	55 1f       	adc	r21, r21
   16744:	ea 95       	dec	r30
   16746:	d1 f7       	brne	.-12     	; 0x1673c <_uart_baudrate+0x24>
   16748:	0e 94 b2 b8 	call	0x17164	; 0x17164 <__udivmodsi4>
   1674c:	21 50       	subi	r18, 0x01	; 1
   1674e:	30 40       	sbci	r19, 0x00	; 0
   16750:	40 40       	sbci	r20, 0x00	; 0
   16752:	50 40       	sbci	r21, 0x00	; 0
   16754:	bb 27       	eor	r27, r27
   16756:	a5 2f       	mov	r26, r21
   16758:	94 2f       	mov	r25, r20
   1675a:	83 2f       	mov	r24, r19

	if(__com){
   1675c:	11 23       	and	r17, r17
   1675e:	29 f0       	breq	.+10     	; 0x1676a <_uart_baudrate+0x52>
		UBRR1L = __br;
   16760:	20 93 99 00 	sts	0x0099, r18
		UBRR1H = __br >> 8;
   16764:	80 93 98 00 	sts	0x0098, r24
   16768:	03 c0       	rjmp	.+6      	; 0x16770 <_uart_baudrate+0x58>
	}
	else{
		UBRR0L = __br;
   1676a:	29 b9       	out	0x09, r18	; 9
		UBRR0H = __br >> 8;
   1676c:	80 93 90 00 	sts	0x0090, r24
	}
}
   16770:	1f 91       	pop	r17
   16772:	08 95       	ret

00016774 <_uart_init>:
#include <util/delay.h>
#include <string.h>

#include "UART.h"

void _uart_init(unsigned char __com, unsigned long __baudrate){
   16774:	98 2f       	mov	r25, r24
	if(__com){
   16776:	88 23       	and	r24, r24
   16778:	39 f0       	breq	.+14     	; 0x16788 <_uart_init+0x14>
		UCSR1B = _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1);
   1677a:	88 e9       	ldi	r24, 0x98	; 152
   1677c:	80 93 9a 00 	sts	0x009A, r24
		UCSR1C = _BV(UCSZ11) | _BV(UCSZ10);
   16780:	86 e0       	ldi	r24, 0x06	; 6
   16782:	80 93 9d 00 	sts	0x009D, r24
   16786:	05 c0       	rjmp	.+10     	; 0x16792 <_uart_init+0x1e>
	}
	else{
		UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
   16788:	88 e9       	ldi	r24, 0x98	; 152
   1678a:	8a b9       	out	0x0a, r24	; 10
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
   1678c:	86 e0       	ldi	r24, 0x06	; 6
   1678e:	80 93 95 00 	sts	0x0095, r24
	}

	_uart_baudrate(__com, __baudrate);
   16792:	89 2f       	mov	r24, r25
   16794:	0e 94 8c b3 	call	0x16718	; 0x16718 <_uart_baudrate>
}
   16798:	08 95       	ret

0001679a <_uart>:
		UBRR0H = __br >> 8;
	}
}

unsigned char _uart(unsigned char __com, unsigned char __dir, unsigned char __chr){
	if(__com){
   1679a:	88 23       	and	r24, r24
   1679c:	81 f0       	breq	.+32     	; 0x167be <_uart+0x24>
		if(__dir){
   1679e:	66 23       	and	r22, r22
   167a0:	39 f0       	breq	.+14     	; 0x167b0 <_uart+0x16>
			loop_until_bit_is_set(UCSR1A, UDRE1);
   167a2:	80 91 9b 00 	lds	r24, 0x009B
   167a6:	85 ff       	sbrs	r24, 5
   167a8:	fc cf       	rjmp	.-8      	; 0x167a2 <_uart+0x8>
			UDR1 = __chr;
   167aa:	40 93 9c 00 	sts	0x009C, r20
   167ae:	0c c0       	rjmp	.+24     	; 0x167c8 <_uart+0x2e>
		}
		else{
			loop_until_bit_is_set(UCSR1A, RXC);
   167b0:	80 91 9b 00 	lds	r24, 0x009B
   167b4:	87 ff       	sbrs	r24, 7
   167b6:	fc cf       	rjmp	.-8      	; 0x167b0 <_uart+0x16>
			return UDR1;
   167b8:	80 91 9c 00 	lds	r24, 0x009C
   167bc:	08 95       	ret
		}
	}
	else{
		if(__dir){
   167be:	66 23       	and	r22, r22
   167c0:	29 f0       	breq	.+10     	; 0x167cc <_uart+0x32>
			loop_until_bit_is_set(UCSR0A, UDRE0);
   167c2:	5d 9b       	sbis	0x0b, 5	; 11
   167c4:	fe cf       	rjmp	.-4      	; 0x167c2 <_uart+0x28>
			UDR0 = __chr;
   167c6:	4c b9       	out	0x0c, r20	; 12
   167c8:	81 e0       	ldi	r24, 0x01	; 1
   167ca:	08 95       	ret
		}
		else{
			loop_until_bit_is_set(UCSR0A,  RXC);
   167cc:	5f 9b       	sbis	0x0b, 7	; 11
   167ce:	fe cf       	rjmp	.-4      	; 0x167cc <_uart+0x32>
			return UDR0;
   167d0:	8c b1       	in	r24, 0x0c	; 12
		}

	}

	return 1;
}
   167d2:	08 95       	ret

000167d4 <_uart_print>:

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
   167d4:	0f 93       	push	r16
   167d6:	1f 93       	push	r17
   167d8:	cf 93       	push	r28
   167da:	df 93       	push	r29
   167dc:	18 2f       	mov	r17, r24
   167de:	06 2f       	mov	r16, r22
   167e0:	ea 01       	movw	r28, r20
	if(strlen(__str)>0)
   167e2:	88 81       	ld	r24, Y
   167e4:	88 23       	and	r24, r24
   167e6:	31 f4       	brne	.+12     	; 0x167f4 <_uart_print+0x20>
   167e8:	08 c0       	rjmp	.+16     	; 0x167fa <_uart_print+0x26>
		while(*__str)
		     _uart(__com, 1, *__str++);
   167ea:	21 96       	adiw	r28, 0x01	; 1
   167ec:	81 2f       	mov	r24, r17
   167ee:	61 e0       	ldi	r22, 0x01	; 1
   167f0:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
	return 1;
}

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
	if(strlen(__str)>0)
		while(*__str)
   167f4:	48 81       	ld	r20, Y
   167f6:	44 23       	and	r20, r20
   167f8:	c1 f7       	brne	.-16     	; 0x167ea <_uart_print+0x16>
		     _uart(__com, 1, *__str++);

	if(__ret){
   167fa:	00 23       	and	r16, r16
   167fc:	51 f0       	breq	.+20     	; 0x16812 <_uart_print+0x3e>
		_uart(__com, 1, 0x0D);
   167fe:	81 2f       	mov	r24, r17
   16800:	61 e0       	ldi	r22, 0x01	; 1
   16802:	4d e0       	ldi	r20, 0x0D	; 13
   16804:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
		_uart(__com, 1, 0x0A);
   16808:	81 2f       	mov	r24, r17
   1680a:	61 e0       	ldi	r22, 0x01	; 1
   1680c:	4a e0       	ldi	r20, 0x0A	; 10
   1680e:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
   16812:	82 ee       	ldi	r24, 0xE2	; 226
   16814:	94 e0       	ldi	r25, 0x04	; 4
   16816:	01 97       	sbiw	r24, 0x01	; 1
   16818:	f1 f7       	brne	.-4      	; 0x16816 <_uart_print+0x42>
	}
	_delay_ms(5);
}
   1681a:	df 91       	pop	r29
   1681c:	cf 91       	pop	r28
   1681e:	1f 91       	pop	r17
   16820:	0f 91       	pop	r16
   16822:	08 95       	ret

00016824 <_uart_printf>:

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
   16824:	0f 93       	push	r16
   16826:	1f 93       	push	r17
   16828:	cf 93       	push	r28
   1682a:	df 93       	push	r29
   1682c:	18 2f       	mov	r17, r24
   1682e:	06 2f       	mov	r16, r22
   16830:	ea 01       	movw	r28, r20
   16832:	07 c0       	rjmp	.+14     	; 0x16842 <_uart_printf+0x1e>
	while(pgm_read_byte(&(*__str)))
		_uart(__com, 1, pgm_read_byte(&(*__str++)));
   16834:	21 96       	adiw	r28, 0x01	; 1
   16836:	f9 01       	movw	r30, r18
   16838:	44 91       	lpm	r20, Z+
   1683a:	81 2f       	mov	r24, r17
   1683c:	61 e0       	ldi	r22, 0x01	; 1
   1683e:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
   16842:	9e 01       	movw	r18, r28
	}
	_delay_ms(5);
}

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
	while(pgm_read_byte(&(*__str)))
   16844:	fe 01       	movw	r30, r28
   16846:	84 91       	lpm	r24, Z+
   16848:	88 23       	and	r24, r24
   1684a:	a1 f7       	brne	.-24     	; 0x16834 <_uart_printf+0x10>
		_uart(__com, 1, pgm_read_byte(&(*__str++)));

	if(__ret){
   1684c:	00 23       	and	r16, r16
   1684e:	51 f0       	breq	.+20     	; 0x16864 <_uart_printf+0x40>
		_uart(__com, 1, 0x0D);
   16850:	81 2f       	mov	r24, r17
   16852:	61 e0       	ldi	r22, 0x01	; 1
   16854:	4d e0       	ldi	r20, 0x0D	; 13
   16856:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
		_uart(__com, 1, 0x0A);
   1685a:	81 2f       	mov	r24, r17
   1685c:	61 e0       	ldi	r22, 0x01	; 1
   1685e:	4a e0       	ldi	r20, 0x0A	; 10
   16860:	0e 94 cd b3 	call	0x1679a	; 0x1679a <_uart>
   16864:	86 ea       	ldi	r24, 0xA6	; 166
   16866:	9e e0       	ldi	r25, 0x0E	; 14
   16868:	01 97       	sbiw	r24, 0x01	; 1
   1686a:	f1 f7       	brne	.-4      	; 0x16868 <_uart_printf+0x44>
	}
	_delay_ms(15);
}
   1686c:	df 91       	pop	r29
   1686e:	cf 91       	pop	r28
   16870:	1f 91       	pop	r17
   16872:	0f 91       	pop	r16
   16874:	08 95       	ret

00016876 <Int2Str>:

void Int2Str(char* __string, unsigned long __value){
   16876:	6f 92       	push	r6
   16878:	7f 92       	push	r7
   1687a:	8f 92       	push	r8
   1687c:	9f 92       	push	r9
   1687e:	af 92       	push	r10
   16880:	bf 92       	push	r11
   16882:	cf 92       	push	r12
   16884:	df 92       	push	r13
   16886:	ef 92       	push	r14
   16888:	ff 92       	push	r15
   1688a:	0f 93       	push	r16
   1688c:	1f 93       	push	r17
   1688e:	cf 93       	push	r28
   16890:	df 93       	push	r29
   16892:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
   16894:	41 15       	cp	r20, r1
   16896:	51 05       	cpc	r21, r1
   16898:	61 05       	cpc	r22, r1
   1689a:	71 05       	cpc	r23, r1
   1689c:	21 f4       	brne	.+8      	; 0x168a6 <Int2Str+0x30>
		__string[0] = '0';
   1689e:	80 e3       	ldi	r24, 0x30	; 48
   168a0:	88 83       	st	Y, r24
		__string[1] = '\0';
   168a2:	19 82       	std	Y+1, r1	; 0x01
   168a4:	48 c0       	rjmp	.+144    	; 0x16936 <Int2Str+0xc0>
		return;
   168a6:	4a 01       	movw	r8, r20
   168a8:	5b 01       	movw	r10, r22
   168aa:	10 e0       	ldi	r17, 0x00	; 0
   168ac:	00 e0       	ldi	r16, 0x00	; 0
   168ae:	77 24       	eor	r7, r7
   168b0:	c1 2c       	mov	r12, r1
   168b2:	ba ec       	ldi	r27, 0xCA	; 202
   168b4:	db 2e       	mov	r13, r27
   168b6:	ba e9       	ldi	r27, 0x9A	; 154
   168b8:	eb 2e       	mov	r14, r27
   168ba:	bb e3       	ldi	r27, 0x3B	; 59
   168bc:	fb 2e       	mov	r15, r27
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
   168be:	a0 e3       	ldi	r26, 0x30	; 48
   168c0:	6a 2e       	mov	r6, r26
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
   168c2:	8c 14       	cp	r8, r12
   168c4:	9d 04       	cpc	r9, r13
   168c6:	ae 04       	cpc	r10, r14
   168c8:	bf 04       	cpc	r11, r15
   168ca:	d0 f0       	brcs	.+52     	; 0x16900 <Int2Str+0x8a>
			__tmp = (int)(__num / __devider);
   168cc:	c5 01       	movw	r24, r10
   168ce:	b4 01       	movw	r22, r8
   168d0:	a7 01       	movw	r20, r14
   168d2:	96 01       	movw	r18, r12
   168d4:	0e 94 b2 b8 	call	0x17164	; 0x17164 <__udivmodsi4>
   168d8:	12 2f       	mov	r17, r18
			__num = __num % __devider;
   168da:	c5 01       	movw	r24, r10
   168dc:	b4 01       	movw	r22, r8
   168de:	a7 01       	movw	r20, r14
   168e0:	96 01       	movw	r18, r12
   168e2:	0e 94 b2 b8 	call	0x17164	; 0x17164 <__udivmodsi4>
   168e6:	ac 01       	movw	r20, r24
   168e8:	cb 01       	movw	r24, r22
   168ea:	da 01       	movw	r26, r20
   168ec:	4c 01       	movw	r8, r24
   168ee:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
   168f0:	fe 01       	movw	r30, r28
   168f2:	e0 0f       	add	r30, r16
   168f4:	f1 1d       	adc	r31, r1
   168f6:	10 5d       	subi	r17, 0xD0	; 208
   168f8:	10 83       	st	Z, r17
   168fa:	0f 5f       	subi	r16, 0xFF	; 255
   168fc:	11 e0       	ldi	r17, 0x01	; 1
   168fe:	07 c0       	rjmp	.+14     	; 0x1690e <Int2Str+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
   16900:	11 23       	and	r17, r17
   16902:	29 f0       	breq	.+10     	; 0x1690e <Int2Str+0x98>
				__string[__i++] = 0x30;
   16904:	fe 01       	movw	r30, r28
   16906:	e0 0f       	add	r30, r16
   16908:	f1 1d       	adc	r31, r1
   1690a:	60 82       	st	Z, r6
   1690c:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
   1690e:	73 94       	inc	r7
   16910:	8a e0       	ldi	r24, 0x0A	; 10
   16912:	78 16       	cp	r7, r24
   16914:	69 f0       	breq	.+26     	; 0x16930 <Int2Str+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
   16916:	c7 01       	movw	r24, r14
   16918:	b6 01       	movw	r22, r12
   1691a:	2a e0       	ldi	r18, 0x0A	; 10
   1691c:	30 e0       	ldi	r19, 0x00	; 0
   1691e:	40 e0       	ldi	r20, 0x00	; 0
   16920:	50 e0       	ldi	r21, 0x00	; 0
   16922:	0e 94 b2 b8 	call	0x17164	; 0x17164 <__udivmodsi4>
   16926:	c9 01       	movw	r24, r18
   16928:	da 01       	movw	r26, r20
   1692a:	6c 01       	movw	r12, r24
   1692c:	7d 01       	movw	r14, r26
   1692e:	c9 cf       	rjmp	.-110    	; 0x168c2 <Int2Str+0x4c>
	}
	__string[__i] = '\0';
   16930:	c0 0f       	add	r28, r16
   16932:	d1 1d       	adc	r29, r1
   16934:	18 82       	st	Y, r1
}
   16936:	df 91       	pop	r29
   16938:	cf 91       	pop	r28
   1693a:	1f 91       	pop	r17
   1693c:	0f 91       	pop	r16
   1693e:	ff 90       	pop	r15
   16940:	ef 90       	pop	r14
   16942:	df 90       	pop	r13
   16944:	cf 90       	pop	r12
   16946:	bf 90       	pop	r11
   16948:	af 90       	pop	r10
   1694a:	9f 90       	pop	r9
   1694c:	8f 90       	pop	r8
   1694e:	7f 90       	pop	r7
   16950:	6f 90       	pop	r6
   16952:	08 95       	ret

00016954 <Str2Int>:

unsigned long Str2Int(char* __string){
   16954:	6f 92       	push	r6
   16956:	7f 92       	push	r7
   16958:	8f 92       	push	r8
   1695a:	9f 92       	push	r9
   1695c:	af 92       	push	r10
   1695e:	bf 92       	push	r11
   16960:	cf 92       	push	r12
   16962:	df 92       	push	r13
   16964:	ef 92       	push	r14
   16966:	ff 92       	push	r15
   16968:	0f 93       	push	r16
   1696a:	1f 93       	push	r17
   1696c:	cf 93       	push	r28
   1696e:	df 93       	push	r29
   16970:	ec 01       	movw	r28, r24
	unsigned char	__i, __len;
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);
   16972:	dc 01       	movw	r26, r24
   16974:	0d 90       	ld	r0, X+
   16976:	00 20       	and	r0, r0
   16978:	e9 f7       	brne	.-6      	; 0x16974 <Str2Int+0x20>
   1697a:	11 97       	sbiw	r26, 0x01	; 1
   1697c:	7a 2e       	mov	r7, r26
   1697e:	78 1a       	sub	r7, r24

	if(__len > 0 && __len < 11){
   16980:	87 2d       	mov	r24, r7
   16982:	81 50       	subi	r24, 0x01	; 1
   16984:	8a 30       	cpi	r24, 0x0A	; 10
   16986:	08 f0       	brcs	.+2      	; 0x1698a <Str2Int+0x36>
   16988:	64 c0       	rjmp	.+200    	; 0x16a52 <Str2Int+0xfe>
   1698a:	4e 01       	movw	r8, r28
   1698c:	fe 01       	movw	r30, r28
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}

unsigned long Str2Int(char* __string){
   1698e:	6c 2e       	mov	r6, r28
   16990:	05 c0       	rjmp	.+10     	; 0x1699c <Str2Int+0x48>

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
   16992:	81 91       	ld	r24, Z+
   16994:	80 53       	subi	r24, 0x30	; 48
   16996:	8a 30       	cpi	r24, 0x0A	; 10
   16998:	08 f0       	brcs	.+2      	; 0x1699c <Str2Int+0x48>
   1699a:	5b c0       	rjmp	.+182    	; 0x16a52 <Str2Int+0xfe>
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
   1699c:	8e 2f       	mov	r24, r30
   1699e:	86 19       	sub	r24, r6
   169a0:	87 15       	cp	r24, r7
   169a2:	b8 f3       	brcs	.-18     	; 0x16992 <Str2Int+0x3e>
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
				return 0;
		if(__len == 10){
   169a4:	8a e0       	ldi	r24, 0x0A	; 10
   169a6:	78 16       	cp	r7, r24
   169a8:	f9 f4       	brne	.+62     	; 0x169e8 <Str2Int+0x94>
			if(__string[0] < 0x30 || __string[0] > 0x32)
   169aa:	98 81       	ld	r25, Y
   169ac:	89 2f       	mov	r24, r25
   169ae:	80 53       	subi	r24, 0x30	; 48
   169b0:	83 30       	cpi	r24, 0x03	; 3
   169b2:	08 f0       	brcs	.+2      	; 0x169b6 <Str2Int+0x62>
   169b4:	4e c0       	rjmp	.+156    	; 0x16a52 <Str2Int+0xfe>
				return 0;
			if(__string[0] == 0x32){
   169b6:	92 33       	cpi	r25, 0x32	; 50
   169b8:	b9 f4       	brne	.+46     	; 0x169e8 <Str2Int+0x94>
   169ba:	fe 01       	movw	r30, r28
   169bc:	91 e0       	ldi	r25, 0x01	; 1
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
   169be:	81 81       	ldd	r24, Z+1	; 0x01
   169c0:	80 33       	cpi	r24, 0x30	; 48
   169c2:	09 f0       	breq	.+2      	; 0x169c6 <Str2Int+0x72>
   169c4:	46 c0       	rjmp	.+140    	; 0x16a52 <Str2Int+0xfe>
				return 0;
		if(__len == 10){
			if(__string[0] < 0x30 || __string[0] > 0x32)
				return 0;
			if(__string[0] == 0x32){
				for(__i = 1; __i < __len; __i++)
   169c6:	9f 5f       	subi	r25, 0xFF	; 255
   169c8:	31 96       	adiw	r30, 0x01	; 1
   169ca:	9a 30       	cpi	r25, 0x0A	; 10
   169cc:	c1 f7       	brne	.-16     	; 0x169be <Str2Int+0x6a>
   169ce:	0c c0       	rjmp	.+24     	; 0x169e8 <Str2Int+0x94>
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
   169d0:	c6 01       	movw	r24, r12
   169d2:	b5 01       	movw	r22, r10
   169d4:	2a e0       	ldi	r18, 0x0A	; 10
   169d6:	30 e0       	ldi	r19, 0x00	; 0
   169d8:	40 e0       	ldi	r20, 0x00	; 0
   169da:	50 e0       	ldi	r21, 0x00	; 0
   169dc:	0e 94 53 b8 	call	0x170a6	; 0x170a6 <__mulsi3>
   169e0:	5b 01       	movw	r10, r22
   169e2:	6c 01       	movw	r12, r24
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
   169e4:	1f 5f       	subi	r17, 0xFF	; 255
   169e6:	09 c0       	rjmp	.+18     	; 0x169fa <Str2Int+0xa6>
   169e8:	10 e0       	ldi	r17, 0x00	; 0
   169ea:	01 e0       	ldi	r16, 0x01	; 1
   169ec:	a0 2e       	mov	r10, r16
   169ee:	b1 2c       	mov	r11, r1
   169f0:	c1 2c       	mov	r12, r1
   169f2:	d1 2c       	mov	r13, r1
   169f4:	c7 2d       	mov	r28, r7
   169f6:	d0 e0       	ldi	r29, 0x00	; 0
   169f8:	21 97       	sbiw	r28, 0x01	; 1
   169fa:	81 2f       	mov	r24, r17
   169fc:	90 e0       	ldi	r25, 0x00	; 0
   169fe:	8c 17       	cp	r24, r28
   16a00:	9d 07       	cpc	r25, r29
   16a02:	34 f3       	brlt	.-52     	; 0x169d0 <Str2Int+0x7c>
   16a04:	ee 24       	eor	r14, r14
   16a06:	ff 24       	eor	r15, r15
   16a08:	87 01       	movw	r16, r14
   16a0a:	1e c0       	rjmp	.+60     	; 0x16a48 <Str2Int+0xf4>
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
   16a0c:	f4 01       	movw	r30, r8
   16a0e:	21 91       	ld	r18, Z+
   16a10:	4f 01       	movw	r8, r30
   16a12:	30 e0       	ldi	r19, 0x00	; 0
   16a14:	20 53       	subi	r18, 0x30	; 48
   16a16:	30 40       	sbci	r19, 0x00	; 0
   16a18:	44 27       	eor	r20, r20
   16a1a:	37 fd       	sbrc	r19, 7
   16a1c:	40 95       	com	r20
   16a1e:	54 2f       	mov	r21, r20
   16a20:	c6 01       	movw	r24, r12
   16a22:	b5 01       	movw	r22, r10
   16a24:	0e 94 53 b8 	call	0x170a6	; 0x170a6 <__mulsi3>
   16a28:	e6 0e       	add	r14, r22
   16a2a:	f7 1e       	adc	r15, r23
   16a2c:	08 1f       	adc	r16, r24
   16a2e:	19 1f       	adc	r17, r25
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
   16a30:	c6 01       	movw	r24, r12
   16a32:	b5 01       	movw	r22, r10
   16a34:	2a e0       	ldi	r18, 0x0A	; 10
   16a36:	30 e0       	ldi	r19, 0x00	; 0
   16a38:	40 e0       	ldi	r20, 0x00	; 0
   16a3a:	50 e0       	ldi	r21, 0x00	; 0
   16a3c:	0e 94 b2 b8 	call	0x17164	; 0x17164 <__udivmodsi4>
   16a40:	c9 01       	movw	r24, r18
   16a42:	da 01       	movw	r26, r20
   16a44:	5c 01       	movw	r10, r24
   16a46:	6d 01       	movw	r12, r26
   16a48:	88 2d       	mov	r24, r8
   16a4a:	86 19       	sub	r24, r6
   16a4c:	87 15       	cp	r24, r7
   16a4e:	f0 f2       	brcs	.-68     	; 0x16a0c <Str2Int+0xb8>
   16a50:	03 c0       	rjmp	.+6      	; 0x16a58 <Str2Int+0x104>
   16a52:	ee 24       	eor	r14, r14
   16a54:	ff 24       	eor	r15, r15
   16a56:	87 01       	movw	r16, r14
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
	}
	return __retval;
}
   16a58:	b7 01       	movw	r22, r14
   16a5a:	c8 01       	movw	r24, r16
   16a5c:	df 91       	pop	r29
   16a5e:	cf 91       	pop	r28
   16a60:	1f 91       	pop	r17
   16a62:	0f 91       	pop	r16
   16a64:	ff 90       	pop	r15
   16a66:	ef 90       	pop	r14
   16a68:	df 90       	pop	r13
   16a6a:	cf 90       	pop	r12
   16a6c:	bf 90       	pop	r11
   16a6e:	af 90       	pop	r10
   16a70:	9f 90       	pop	r9
   16a72:	8f 90       	pop	r8
   16a74:	7f 90       	pop	r7
   16a76:	6f 90       	pop	r6
   16a78:	08 95       	ret

00016a7a <atoi>:
   16a7a:	fc 01       	movw	r30, r24
   16a7c:	88 27       	eor	r24, r24
   16a7e:	99 27       	eor	r25, r25
   16a80:	e8 94       	clt
   16a82:	21 91       	ld	r18, Z+
   16a84:	20 32       	cpi	r18, 0x20	; 32
   16a86:	e9 f3       	breq	.-6      	; 0x16a82 <atoi+0x8>
   16a88:	29 30       	cpi	r18, 0x09	; 9
   16a8a:	10 f0       	brcs	.+4      	; 0x16a90 <atoi+0x16>
   16a8c:	2e 30       	cpi	r18, 0x0E	; 14
   16a8e:	c8 f3       	brcs	.-14     	; 0x16a82 <atoi+0x8>
   16a90:	2b 32       	cpi	r18, 0x2B	; 43
   16a92:	41 f0       	breq	.+16     	; 0x16aa4 <atoi+0x2a>
   16a94:	2d 32       	cpi	r18, 0x2D	; 45
   16a96:	39 f4       	brne	.+14     	; 0x16aa6 <atoi+0x2c>
   16a98:	68 94       	set
   16a9a:	04 c0       	rjmp	.+8      	; 0x16aa4 <atoi+0x2a>
   16a9c:	0e 94 aa b5 	call	0x16b54	; 0x16b54 <__mulhi_const_10>
   16aa0:	82 0f       	add	r24, r18
   16aa2:	91 1d       	adc	r25, r1
   16aa4:	21 91       	ld	r18, Z+
   16aa6:	20 53       	subi	r18, 0x30	; 48
   16aa8:	2a 30       	cpi	r18, 0x0A	; 10
   16aaa:	c0 f3       	brcs	.-16     	; 0x16a9c <atoi+0x22>
   16aac:	1e f4       	brtc	.+6      	; 0x16ab4 <atoi+0x3a>
   16aae:	90 95       	com	r25
   16ab0:	81 95       	neg	r24
   16ab2:	9f 4f       	sbci	r25, 0xFF	; 255
   16ab4:	08 95       	ret

00016ab6 <strcpy_P>:
   16ab6:	fb 01       	movw	r30, r22
   16ab8:	dc 01       	movw	r26, r24
   16aba:	05 90       	lpm	r0, Z+
   16abc:	0d 92       	st	X+, r0
   16abe:	00 20       	and	r0, r0
   16ac0:	e1 f7       	brne	.-8      	; 0x16aba <strcpy_P+0x4>
   16ac2:	08 95       	ret

00016ac4 <strcmp>:
   16ac4:	fb 01       	movw	r30, r22
   16ac6:	dc 01       	movw	r26, r24
   16ac8:	8d 91       	ld	r24, X+
   16aca:	01 90       	ld	r0, Z+
   16acc:	80 19       	sub	r24, r0
   16ace:	01 10       	cpse	r0, r1
   16ad0:	d9 f3       	breq	.-10     	; 0x16ac8 <strcmp+0x4>
   16ad2:	99 0b       	sbc	r25, r25
   16ad4:	08 95       	ret

00016ad6 <strcpy>:
   16ad6:	fb 01       	movw	r30, r22
   16ad8:	dc 01       	movw	r26, r24
   16ada:	01 90       	ld	r0, Z+
   16adc:	0d 92       	st	X+, r0
   16ade:	00 20       	and	r0, r0
   16ae0:	e1 f7       	brne	.-8      	; 0x16ada <strcpy+0x4>
   16ae2:	08 95       	ret

00016ae4 <__eerd_block>:
   16ae4:	a0 e0       	ldi	r26, 0x00	; 0
   16ae6:	b0 e0       	ldi	r27, 0x00	; 0
   16ae8:	e8 e7       	ldi	r30, 0x78	; 120
   16aea:	f5 eb       	ldi	r31, 0xB5	; 181
   16aec:	0c 94 de b8 	jmp	0x171bc	; 0x171bc <__prologue_saves__+0x14>
   16af0:	7c 01       	movw	r14, r24
   16af2:	eb 01       	movw	r28, r22
   16af4:	8a 01       	movw	r16, r20
   16af6:	69 01       	movw	r12, r18
   16af8:	09 c0       	rjmp	.+18     	; 0x16b0c <__eerd_block+0x28>
   16afa:	ce 01       	movw	r24, r28
   16afc:	21 96       	adiw	r28, 0x01	; 1
   16afe:	f6 01       	movw	r30, r12
   16b00:	09 95       	icall
   16b02:	f7 01       	movw	r30, r14
   16b04:	81 93       	st	Z+, r24
   16b06:	7f 01       	movw	r14, r30
   16b08:	01 50       	subi	r16, 0x01	; 1
   16b0a:	10 40       	sbci	r17, 0x00	; 0
   16b0c:	01 15       	cp	r16, r1
   16b0e:	11 05       	cpc	r17, r1
   16b10:	a1 f7       	brne	.-24     	; 0x16afa <__eerd_block+0x16>
   16b12:	cd b7       	in	r28, 0x3d	; 61
   16b14:	de b7       	in	r29, 0x3e	; 62
   16b16:	e8 e0       	ldi	r30, 0x08	; 8
   16b18:	0c 94 fa b8 	jmp	0x171f4	; 0x171f4 <__epilogue_restores__+0x14>

00016b1c <__eewr_block>:
   16b1c:	a0 e0       	ldi	r26, 0x00	; 0
   16b1e:	b0 e0       	ldi	r27, 0x00	; 0
   16b20:	e4 e9       	ldi	r30, 0x94	; 148
   16b22:	f5 eb       	ldi	r31, 0xB5	; 181
   16b24:	0c 94 de b8 	jmp	0x171bc	; 0x171bc <__prologue_saves__+0x14>
   16b28:	ec 01       	movw	r28, r24
   16b2a:	7b 01       	movw	r14, r22
   16b2c:	8a 01       	movw	r16, r20
   16b2e:	69 01       	movw	r12, r18
   16b30:	09 c0       	rjmp	.+18     	; 0x16b44 <__eewr_block+0x28>
   16b32:	ce 01       	movw	r24, r28
   16b34:	21 96       	adiw	r28, 0x01	; 1
   16b36:	f7 01       	movw	r30, r14
   16b38:	61 91       	ld	r22, Z+
   16b3a:	7f 01       	movw	r14, r30
   16b3c:	f6 01       	movw	r30, r12
   16b3e:	09 95       	icall
   16b40:	01 50       	subi	r16, 0x01	; 1
   16b42:	10 40       	sbci	r17, 0x00	; 0
   16b44:	01 15       	cp	r16, r1
   16b46:	11 05       	cpc	r17, r1
   16b48:	a1 f7       	brne	.-24     	; 0x16b32 <__eewr_block+0x16>
   16b4a:	cd b7       	in	r28, 0x3d	; 61
   16b4c:	de b7       	in	r29, 0x3e	; 62
   16b4e:	e8 e0       	ldi	r30, 0x08	; 8
   16b50:	0c 94 fa b8 	jmp	0x171f4	; 0x171f4 <__epilogue_restores__+0x14>

00016b54 <__mulhi_const_10>:
   16b54:	7a e0       	ldi	r23, 0x0A	; 10
   16b56:	97 9f       	mul	r25, r23
   16b58:	90 2d       	mov	r25, r0
   16b5a:	87 9f       	mul	r24, r23
   16b5c:	80 2d       	mov	r24, r0
   16b5e:	91 0d       	add	r25, r1
   16b60:	11 24       	eor	r1, r1
   16b62:	08 95       	ret

00016b64 <sprintf_P>:
   16b64:	ae e0       	ldi	r26, 0x0E	; 14
   16b66:	b0 e0       	ldi	r27, 0x00	; 0
   16b68:	e8 eb       	ldi	r30, 0xB8	; 184
   16b6a:	f5 eb       	ldi	r31, 0xB5	; 181
   16b6c:	0c 94 e2 b8 	jmp	0x171c4	; 0x171c4 <__prologue_saves__+0x1c>
   16b70:	0d 89       	ldd	r16, Y+21	; 0x15
   16b72:	1e 89       	ldd	r17, Y+22	; 0x16
   16b74:	8e e0       	ldi	r24, 0x0E	; 14
   16b76:	8c 83       	std	Y+4, r24	; 0x04
   16b78:	1a 83       	std	Y+2, r17	; 0x02
   16b7a:	09 83       	std	Y+1, r16	; 0x01
   16b7c:	8f ef       	ldi	r24, 0xFF	; 255
   16b7e:	9f e7       	ldi	r25, 0x7F	; 127
   16b80:	9e 83       	std	Y+6, r25	; 0x06
   16b82:	8d 83       	std	Y+5, r24	; 0x05
   16b84:	9e 01       	movw	r18, r28
   16b86:	27 5e       	subi	r18, 0xE7	; 231
   16b88:	3f 4f       	sbci	r19, 0xFF	; 255
   16b8a:	ce 01       	movw	r24, r28
   16b8c:	01 96       	adiw	r24, 0x01	; 1
   16b8e:	6f 89       	ldd	r22, Y+23	; 0x17
   16b90:	78 8d       	ldd	r23, Y+24	; 0x18
   16b92:	a9 01       	movw	r20, r18
   16b94:	0e 94 d6 b5 	call	0x16bac	; 0x16bac <vfprintf>
   16b98:	2f 81       	ldd	r18, Y+7	; 0x07
   16b9a:	38 85       	ldd	r19, Y+8	; 0x08
   16b9c:	02 0f       	add	r16, r18
   16b9e:	13 1f       	adc	r17, r19
   16ba0:	f8 01       	movw	r30, r16
   16ba2:	10 82       	st	Z, r1
   16ba4:	2e 96       	adiw	r28, 0x0e	; 14
   16ba6:	e4 e0       	ldi	r30, 0x04	; 4
   16ba8:	0c 94 fe b8 	jmp	0x171fc	; 0x171fc <__epilogue_restores__+0x1c>

00016bac <vfprintf>:
   16bac:	ab e0       	ldi	r26, 0x0B	; 11
   16bae:	b0 e0       	ldi	r27, 0x00	; 0
   16bb0:	ec ed       	ldi	r30, 0xDC	; 220
   16bb2:	f5 eb       	ldi	r31, 0xB5	; 181
   16bb4:	0c 94 d4 b8 	jmp	0x171a8	; 0x171a8 <__prologue_saves__>
   16bb8:	3c 01       	movw	r6, r24
   16bba:	2b 01       	movw	r4, r22
   16bbc:	5a 01       	movw	r10, r20
   16bbe:	fc 01       	movw	r30, r24
   16bc0:	17 82       	std	Z+7, r1	; 0x07
   16bc2:	16 82       	std	Z+6, r1	; 0x06
   16bc4:	83 81       	ldd	r24, Z+3	; 0x03
   16bc6:	81 fd       	sbrc	r24, 1
   16bc8:	03 c0       	rjmp	.+6      	; 0x16bd0 <vfprintf+0x24>
   16bca:	6f ef       	ldi	r22, 0xFF	; 255
   16bcc:	7f ef       	ldi	r23, 0xFF	; 255
   16bce:	c6 c1       	rjmp	.+908    	; 0x16f5c <vfprintf+0x3b0>
   16bd0:	9a e0       	ldi	r25, 0x0A	; 10
   16bd2:	89 2e       	mov	r8, r25
   16bd4:	1e 01       	movw	r2, r28
   16bd6:	08 94       	sec
   16bd8:	21 1c       	adc	r2, r1
   16bda:	31 1c       	adc	r3, r1
   16bdc:	f3 01       	movw	r30, r6
   16bde:	23 81       	ldd	r18, Z+3	; 0x03
   16be0:	f2 01       	movw	r30, r4
   16be2:	23 fd       	sbrc	r18, 3
   16be4:	85 91       	lpm	r24, Z+
   16be6:	23 ff       	sbrs	r18, 3
   16be8:	81 91       	ld	r24, Z+
   16bea:	2f 01       	movw	r4, r30
   16bec:	88 23       	and	r24, r24
   16bee:	09 f4       	brne	.+2      	; 0x16bf2 <vfprintf+0x46>
   16bf0:	b2 c1       	rjmp	.+868    	; 0x16f56 <vfprintf+0x3aa>
   16bf2:	85 32       	cpi	r24, 0x25	; 37
   16bf4:	39 f4       	brne	.+14     	; 0x16c04 <vfprintf+0x58>
   16bf6:	23 fd       	sbrc	r18, 3
   16bf8:	85 91       	lpm	r24, Z+
   16bfa:	23 ff       	sbrs	r18, 3
   16bfc:	81 91       	ld	r24, Z+
   16bfe:	2f 01       	movw	r4, r30
   16c00:	85 32       	cpi	r24, 0x25	; 37
   16c02:	29 f4       	brne	.+10     	; 0x16c0e <vfprintf+0x62>
   16c04:	90 e0       	ldi	r25, 0x00	; 0
   16c06:	b3 01       	movw	r22, r6
   16c08:	0e 94 c9 b7 	call	0x16f92	; 0x16f92 <fputc>
   16c0c:	e7 cf       	rjmp	.-50     	; 0x16bdc <vfprintf+0x30>
   16c0e:	98 2f       	mov	r25, r24
   16c10:	ff 24       	eor	r15, r15
   16c12:	ee 24       	eor	r14, r14
   16c14:	99 24       	eor	r9, r9
   16c16:	ff e1       	ldi	r31, 0x1F	; 31
   16c18:	ff 15       	cp	r31, r15
   16c1a:	d0 f0       	brcs	.+52     	; 0x16c50 <vfprintf+0xa4>
   16c1c:	9b 32       	cpi	r25, 0x2B	; 43
   16c1e:	69 f0       	breq	.+26     	; 0x16c3a <vfprintf+0x8e>
   16c20:	9c 32       	cpi	r25, 0x2C	; 44
   16c22:	28 f4       	brcc	.+10     	; 0x16c2e <vfprintf+0x82>
   16c24:	90 32       	cpi	r25, 0x20	; 32
   16c26:	59 f0       	breq	.+22     	; 0x16c3e <vfprintf+0x92>
   16c28:	93 32       	cpi	r25, 0x23	; 35
   16c2a:	91 f4       	brne	.+36     	; 0x16c50 <vfprintf+0xa4>
   16c2c:	0e c0       	rjmp	.+28     	; 0x16c4a <vfprintf+0x9e>
   16c2e:	9d 32       	cpi	r25, 0x2D	; 45
   16c30:	49 f0       	breq	.+18     	; 0x16c44 <vfprintf+0x98>
   16c32:	90 33       	cpi	r25, 0x30	; 48
   16c34:	69 f4       	brne	.+26     	; 0x16c50 <vfprintf+0xa4>
   16c36:	41 e0       	ldi	r20, 0x01	; 1
   16c38:	24 c0       	rjmp	.+72     	; 0x16c82 <vfprintf+0xd6>
   16c3a:	52 e0       	ldi	r21, 0x02	; 2
   16c3c:	f5 2a       	or	r15, r21
   16c3e:	84 e0       	ldi	r24, 0x04	; 4
   16c40:	f8 2a       	or	r15, r24
   16c42:	28 c0       	rjmp	.+80     	; 0x16c94 <vfprintf+0xe8>
   16c44:	98 e0       	ldi	r25, 0x08	; 8
   16c46:	f9 2a       	or	r15, r25
   16c48:	25 c0       	rjmp	.+74     	; 0x16c94 <vfprintf+0xe8>
   16c4a:	e0 e1       	ldi	r30, 0x10	; 16
   16c4c:	fe 2a       	or	r15, r30
   16c4e:	22 c0       	rjmp	.+68     	; 0x16c94 <vfprintf+0xe8>
   16c50:	f7 fc       	sbrc	r15, 7
   16c52:	29 c0       	rjmp	.+82     	; 0x16ca6 <vfprintf+0xfa>
   16c54:	89 2f       	mov	r24, r25
   16c56:	80 53       	subi	r24, 0x30	; 48
   16c58:	8a 30       	cpi	r24, 0x0A	; 10
   16c5a:	70 f4       	brcc	.+28     	; 0x16c78 <vfprintf+0xcc>
   16c5c:	f6 fe       	sbrs	r15, 6
   16c5e:	05 c0       	rjmp	.+10     	; 0x16c6a <vfprintf+0xbe>
   16c60:	98 9c       	mul	r9, r8
   16c62:	90 2c       	mov	r9, r0
   16c64:	11 24       	eor	r1, r1
   16c66:	98 0e       	add	r9, r24
   16c68:	15 c0       	rjmp	.+42     	; 0x16c94 <vfprintf+0xe8>
   16c6a:	e8 9c       	mul	r14, r8
   16c6c:	e0 2c       	mov	r14, r0
   16c6e:	11 24       	eor	r1, r1
   16c70:	e8 0e       	add	r14, r24
   16c72:	f0 e2       	ldi	r31, 0x20	; 32
   16c74:	ff 2a       	or	r15, r31
   16c76:	0e c0       	rjmp	.+28     	; 0x16c94 <vfprintf+0xe8>
   16c78:	9e 32       	cpi	r25, 0x2E	; 46
   16c7a:	29 f4       	brne	.+10     	; 0x16c86 <vfprintf+0xda>
   16c7c:	f6 fc       	sbrc	r15, 6
   16c7e:	6b c1       	rjmp	.+726    	; 0x16f56 <vfprintf+0x3aa>
   16c80:	40 e4       	ldi	r20, 0x40	; 64
   16c82:	f4 2a       	or	r15, r20
   16c84:	07 c0       	rjmp	.+14     	; 0x16c94 <vfprintf+0xe8>
   16c86:	9c 36       	cpi	r25, 0x6C	; 108
   16c88:	19 f4       	brne	.+6      	; 0x16c90 <vfprintf+0xe4>
   16c8a:	50 e8       	ldi	r21, 0x80	; 128
   16c8c:	f5 2a       	or	r15, r21
   16c8e:	02 c0       	rjmp	.+4      	; 0x16c94 <vfprintf+0xe8>
   16c90:	98 36       	cpi	r25, 0x68	; 104
   16c92:	49 f4       	brne	.+18     	; 0x16ca6 <vfprintf+0xfa>
   16c94:	f2 01       	movw	r30, r4
   16c96:	23 fd       	sbrc	r18, 3
   16c98:	95 91       	lpm	r25, Z+
   16c9a:	23 ff       	sbrs	r18, 3
   16c9c:	91 91       	ld	r25, Z+
   16c9e:	2f 01       	movw	r4, r30
   16ca0:	99 23       	and	r25, r25
   16ca2:	09 f0       	breq	.+2      	; 0x16ca6 <vfprintf+0xfa>
   16ca4:	b8 cf       	rjmp	.-144    	; 0x16c16 <vfprintf+0x6a>
   16ca6:	89 2f       	mov	r24, r25
   16ca8:	85 54       	subi	r24, 0x45	; 69
   16caa:	83 30       	cpi	r24, 0x03	; 3
   16cac:	18 f0       	brcs	.+6      	; 0x16cb4 <vfprintf+0x108>
   16cae:	80 52       	subi	r24, 0x20	; 32
   16cb0:	83 30       	cpi	r24, 0x03	; 3
   16cb2:	38 f4       	brcc	.+14     	; 0x16cc2 <vfprintf+0x116>
   16cb4:	44 e0       	ldi	r20, 0x04	; 4
   16cb6:	50 e0       	ldi	r21, 0x00	; 0
   16cb8:	a4 0e       	add	r10, r20
   16cba:	b5 1e       	adc	r11, r21
   16cbc:	5f e3       	ldi	r21, 0x3F	; 63
   16cbe:	59 83       	std	Y+1, r21	; 0x01
   16cc0:	0f c0       	rjmp	.+30     	; 0x16ce0 <vfprintf+0x134>
   16cc2:	93 36       	cpi	r25, 0x63	; 99
   16cc4:	31 f0       	breq	.+12     	; 0x16cd2 <vfprintf+0x126>
   16cc6:	93 37       	cpi	r25, 0x73	; 115
   16cc8:	79 f0       	breq	.+30     	; 0x16ce8 <vfprintf+0x13c>
   16cca:	93 35       	cpi	r25, 0x53	; 83
   16ccc:	09 f0       	breq	.+2      	; 0x16cd0 <vfprintf+0x124>
   16cce:	56 c0       	rjmp	.+172    	; 0x16d7c <vfprintf+0x1d0>
   16cd0:	20 c0       	rjmp	.+64     	; 0x16d12 <vfprintf+0x166>
   16cd2:	f5 01       	movw	r30, r10
   16cd4:	80 81       	ld	r24, Z
   16cd6:	89 83       	std	Y+1, r24	; 0x01
   16cd8:	42 e0       	ldi	r20, 0x02	; 2
   16cda:	50 e0       	ldi	r21, 0x00	; 0
   16cdc:	a4 0e       	add	r10, r20
   16cde:	b5 1e       	adc	r11, r21
   16ce0:	61 01       	movw	r12, r2
   16ce2:	01 e0       	ldi	r16, 0x01	; 1
   16ce4:	10 e0       	ldi	r17, 0x00	; 0
   16ce6:	12 c0       	rjmp	.+36     	; 0x16d0c <vfprintf+0x160>
   16ce8:	f5 01       	movw	r30, r10
   16cea:	c0 80       	ld	r12, Z
   16cec:	d1 80       	ldd	r13, Z+1	; 0x01
   16cee:	f6 fc       	sbrc	r15, 6
   16cf0:	03 c0       	rjmp	.+6      	; 0x16cf8 <vfprintf+0x14c>
   16cf2:	6f ef       	ldi	r22, 0xFF	; 255
   16cf4:	7f ef       	ldi	r23, 0xFF	; 255
   16cf6:	02 c0       	rjmp	.+4      	; 0x16cfc <vfprintf+0x150>
   16cf8:	69 2d       	mov	r22, r9
   16cfa:	70 e0       	ldi	r23, 0x00	; 0
   16cfc:	42 e0       	ldi	r20, 0x02	; 2
   16cfe:	50 e0       	ldi	r21, 0x00	; 0
   16d00:	a4 0e       	add	r10, r20
   16d02:	b5 1e       	adc	r11, r21
   16d04:	c6 01       	movw	r24, r12
   16d06:	0e 94 be b7 	call	0x16f7c	; 0x16f7c <strnlen>
   16d0a:	8c 01       	movw	r16, r24
   16d0c:	5f e7       	ldi	r21, 0x7F	; 127
   16d0e:	f5 22       	and	r15, r21
   16d10:	14 c0       	rjmp	.+40     	; 0x16d3a <vfprintf+0x18e>
   16d12:	f5 01       	movw	r30, r10
   16d14:	c0 80       	ld	r12, Z
   16d16:	d1 80       	ldd	r13, Z+1	; 0x01
   16d18:	f6 fc       	sbrc	r15, 6
   16d1a:	03 c0       	rjmp	.+6      	; 0x16d22 <vfprintf+0x176>
   16d1c:	6f ef       	ldi	r22, 0xFF	; 255
   16d1e:	7f ef       	ldi	r23, 0xFF	; 255
   16d20:	02 c0       	rjmp	.+4      	; 0x16d26 <vfprintf+0x17a>
   16d22:	69 2d       	mov	r22, r9
   16d24:	70 e0       	ldi	r23, 0x00	; 0
   16d26:	42 e0       	ldi	r20, 0x02	; 2
   16d28:	50 e0       	ldi	r21, 0x00	; 0
   16d2a:	a4 0e       	add	r10, r20
   16d2c:	b5 1e       	adc	r11, r21
   16d2e:	c6 01       	movw	r24, r12
   16d30:	0e 94 b3 b7 	call	0x16f66	; 0x16f66 <strnlen_P>
   16d34:	8c 01       	movw	r16, r24
   16d36:	50 e8       	ldi	r21, 0x80	; 128
   16d38:	f5 2a       	or	r15, r21
   16d3a:	f3 fe       	sbrs	r15, 3
   16d3c:	07 c0       	rjmp	.+14     	; 0x16d4c <vfprintf+0x1a0>
   16d3e:	1a c0       	rjmp	.+52     	; 0x16d74 <vfprintf+0x1c8>
   16d40:	80 e2       	ldi	r24, 0x20	; 32
   16d42:	90 e0       	ldi	r25, 0x00	; 0
   16d44:	b3 01       	movw	r22, r6
   16d46:	0e 94 c9 b7 	call	0x16f92	; 0x16f92 <fputc>
   16d4a:	ea 94       	dec	r14
   16d4c:	8e 2d       	mov	r24, r14
   16d4e:	90 e0       	ldi	r25, 0x00	; 0
   16d50:	08 17       	cp	r16, r24
   16d52:	19 07       	cpc	r17, r25
   16d54:	a8 f3       	brcs	.-22     	; 0x16d40 <vfprintf+0x194>
   16d56:	0e c0       	rjmp	.+28     	; 0x16d74 <vfprintf+0x1c8>
   16d58:	f6 01       	movw	r30, r12
   16d5a:	f7 fc       	sbrc	r15, 7
   16d5c:	85 91       	lpm	r24, Z+
   16d5e:	f7 fe       	sbrs	r15, 7
   16d60:	81 91       	ld	r24, Z+
   16d62:	6f 01       	movw	r12, r30
   16d64:	90 e0       	ldi	r25, 0x00	; 0
   16d66:	b3 01       	movw	r22, r6
   16d68:	0e 94 c9 b7 	call	0x16f92	; 0x16f92 <fputc>
   16d6c:	e1 10       	cpse	r14, r1
   16d6e:	ea 94       	dec	r14
   16d70:	01 50       	subi	r16, 0x01	; 1
   16d72:	10 40       	sbci	r17, 0x00	; 0
   16d74:	01 15       	cp	r16, r1
   16d76:	11 05       	cpc	r17, r1
   16d78:	79 f7       	brne	.-34     	; 0x16d58 <vfprintf+0x1ac>
   16d7a:	ea c0       	rjmp	.+468    	; 0x16f50 <vfprintf+0x3a4>
   16d7c:	94 36       	cpi	r25, 0x64	; 100
   16d7e:	11 f0       	breq	.+4      	; 0x16d84 <vfprintf+0x1d8>
   16d80:	99 36       	cpi	r25, 0x69	; 105
   16d82:	69 f5       	brne	.+90     	; 0x16dde <vfprintf+0x232>
   16d84:	f7 fe       	sbrs	r15, 7
   16d86:	08 c0       	rjmp	.+16     	; 0x16d98 <vfprintf+0x1ec>
   16d88:	f5 01       	movw	r30, r10
   16d8a:	20 81       	ld	r18, Z
   16d8c:	31 81       	ldd	r19, Z+1	; 0x01
   16d8e:	42 81       	ldd	r20, Z+2	; 0x02
   16d90:	53 81       	ldd	r21, Z+3	; 0x03
   16d92:	84 e0       	ldi	r24, 0x04	; 4
   16d94:	90 e0       	ldi	r25, 0x00	; 0
   16d96:	0a c0       	rjmp	.+20     	; 0x16dac <vfprintf+0x200>
   16d98:	f5 01       	movw	r30, r10
   16d9a:	80 81       	ld	r24, Z
   16d9c:	91 81       	ldd	r25, Z+1	; 0x01
   16d9e:	9c 01       	movw	r18, r24
   16da0:	44 27       	eor	r20, r20
   16da2:	37 fd       	sbrc	r19, 7
   16da4:	40 95       	com	r20
   16da6:	54 2f       	mov	r21, r20
   16da8:	82 e0       	ldi	r24, 0x02	; 2
   16daa:	90 e0       	ldi	r25, 0x00	; 0
   16dac:	a8 0e       	add	r10, r24
   16dae:	b9 1e       	adc	r11, r25
   16db0:	9f e6       	ldi	r25, 0x6F	; 111
   16db2:	f9 22       	and	r15, r25
   16db4:	57 ff       	sbrs	r21, 7
   16db6:	09 c0       	rjmp	.+18     	; 0x16dca <vfprintf+0x21e>
   16db8:	50 95       	com	r21
   16dba:	40 95       	com	r20
   16dbc:	30 95       	com	r19
   16dbe:	21 95       	neg	r18
   16dc0:	3f 4f       	sbci	r19, 0xFF	; 255
   16dc2:	4f 4f       	sbci	r20, 0xFF	; 255
   16dc4:	5f 4f       	sbci	r21, 0xFF	; 255
   16dc6:	e0 e8       	ldi	r30, 0x80	; 128
   16dc8:	fe 2a       	or	r15, r30
   16dca:	ca 01       	movw	r24, r20
   16dcc:	b9 01       	movw	r22, r18
   16dce:	a1 01       	movw	r20, r2
   16dd0:	2a e0       	ldi	r18, 0x0A	; 10
   16dd2:	30 e0       	ldi	r19, 0x00	; 0
   16dd4:	0e 94 f5 b7 	call	0x16fea	; 0x16fea <__ultoa_invert>
   16dd8:	d8 2e       	mov	r13, r24
   16dda:	d2 18       	sub	r13, r2
   16ddc:	40 c0       	rjmp	.+128    	; 0x16e5e <vfprintf+0x2b2>
   16dde:	95 37       	cpi	r25, 0x75	; 117
   16de0:	29 f4       	brne	.+10     	; 0x16dec <vfprintf+0x240>
   16de2:	1f 2d       	mov	r17, r15
   16de4:	1f 7e       	andi	r17, 0xEF	; 239
   16de6:	2a e0       	ldi	r18, 0x0A	; 10
   16de8:	30 e0       	ldi	r19, 0x00	; 0
   16dea:	1d c0       	rjmp	.+58     	; 0x16e26 <vfprintf+0x27a>
   16dec:	1f 2d       	mov	r17, r15
   16dee:	19 7f       	andi	r17, 0xF9	; 249
   16df0:	9f 36       	cpi	r25, 0x6F	; 111
   16df2:	61 f0       	breq	.+24     	; 0x16e0c <vfprintf+0x260>
   16df4:	90 37       	cpi	r25, 0x70	; 112
   16df6:	20 f4       	brcc	.+8      	; 0x16e00 <vfprintf+0x254>
   16df8:	98 35       	cpi	r25, 0x58	; 88
   16dfa:	09 f0       	breq	.+2      	; 0x16dfe <vfprintf+0x252>
   16dfc:	ac c0       	rjmp	.+344    	; 0x16f56 <vfprintf+0x3aa>
   16dfe:	0f c0       	rjmp	.+30     	; 0x16e1e <vfprintf+0x272>
   16e00:	90 37       	cpi	r25, 0x70	; 112
   16e02:	39 f0       	breq	.+14     	; 0x16e12 <vfprintf+0x266>
   16e04:	98 37       	cpi	r25, 0x78	; 120
   16e06:	09 f0       	breq	.+2      	; 0x16e0a <vfprintf+0x25e>
   16e08:	a6 c0       	rjmp	.+332    	; 0x16f56 <vfprintf+0x3aa>
   16e0a:	04 c0       	rjmp	.+8      	; 0x16e14 <vfprintf+0x268>
   16e0c:	28 e0       	ldi	r18, 0x08	; 8
   16e0e:	30 e0       	ldi	r19, 0x00	; 0
   16e10:	0a c0       	rjmp	.+20     	; 0x16e26 <vfprintf+0x27a>
   16e12:	10 61       	ori	r17, 0x10	; 16
   16e14:	14 fd       	sbrc	r17, 4
   16e16:	14 60       	ori	r17, 0x04	; 4
   16e18:	20 e1       	ldi	r18, 0x10	; 16
   16e1a:	30 e0       	ldi	r19, 0x00	; 0
   16e1c:	04 c0       	rjmp	.+8      	; 0x16e26 <vfprintf+0x27a>
   16e1e:	14 fd       	sbrc	r17, 4
   16e20:	16 60       	ori	r17, 0x06	; 6
   16e22:	20 e1       	ldi	r18, 0x10	; 16
   16e24:	32 e0       	ldi	r19, 0x02	; 2
   16e26:	17 ff       	sbrs	r17, 7
   16e28:	08 c0       	rjmp	.+16     	; 0x16e3a <vfprintf+0x28e>
   16e2a:	f5 01       	movw	r30, r10
   16e2c:	60 81       	ld	r22, Z
   16e2e:	71 81       	ldd	r23, Z+1	; 0x01
   16e30:	82 81       	ldd	r24, Z+2	; 0x02
   16e32:	93 81       	ldd	r25, Z+3	; 0x03
   16e34:	44 e0       	ldi	r20, 0x04	; 4
   16e36:	50 e0       	ldi	r21, 0x00	; 0
   16e38:	08 c0       	rjmp	.+16     	; 0x16e4a <vfprintf+0x29e>
   16e3a:	f5 01       	movw	r30, r10
   16e3c:	80 81       	ld	r24, Z
   16e3e:	91 81       	ldd	r25, Z+1	; 0x01
   16e40:	bc 01       	movw	r22, r24
   16e42:	80 e0       	ldi	r24, 0x00	; 0
   16e44:	90 e0       	ldi	r25, 0x00	; 0
   16e46:	42 e0       	ldi	r20, 0x02	; 2
   16e48:	50 e0       	ldi	r21, 0x00	; 0
   16e4a:	a4 0e       	add	r10, r20
   16e4c:	b5 1e       	adc	r11, r21
   16e4e:	a1 01       	movw	r20, r2
   16e50:	0e 94 f5 b7 	call	0x16fea	; 0x16fea <__ultoa_invert>
   16e54:	d8 2e       	mov	r13, r24
   16e56:	d2 18       	sub	r13, r2
   16e58:	8f e7       	ldi	r24, 0x7F	; 127
   16e5a:	f8 2e       	mov	r15, r24
   16e5c:	f1 22       	and	r15, r17
   16e5e:	f6 fe       	sbrs	r15, 6
   16e60:	0b c0       	rjmp	.+22     	; 0x16e78 <vfprintf+0x2cc>
   16e62:	5e ef       	ldi	r21, 0xFE	; 254
   16e64:	f5 22       	and	r15, r21
   16e66:	d9 14       	cp	r13, r9
   16e68:	38 f4       	brcc	.+14     	; 0x16e78 <vfprintf+0x2cc>
   16e6a:	f4 fe       	sbrs	r15, 4
   16e6c:	07 c0       	rjmp	.+14     	; 0x16e7c <vfprintf+0x2d0>
   16e6e:	f2 fc       	sbrc	r15, 2
   16e70:	05 c0       	rjmp	.+10     	; 0x16e7c <vfprintf+0x2d0>
   16e72:	8f ee       	ldi	r24, 0xEF	; 239
   16e74:	f8 22       	and	r15, r24
   16e76:	02 c0       	rjmp	.+4      	; 0x16e7c <vfprintf+0x2d0>
   16e78:	1d 2d       	mov	r17, r13
   16e7a:	01 c0       	rjmp	.+2      	; 0x16e7e <vfprintf+0x2d2>
   16e7c:	19 2d       	mov	r17, r9
   16e7e:	f4 fe       	sbrs	r15, 4
   16e80:	0d c0       	rjmp	.+26     	; 0x16e9c <vfprintf+0x2f0>
   16e82:	fe 01       	movw	r30, r28
   16e84:	ed 0d       	add	r30, r13
   16e86:	f1 1d       	adc	r31, r1
   16e88:	80 81       	ld	r24, Z
   16e8a:	80 33       	cpi	r24, 0x30	; 48
   16e8c:	19 f4       	brne	.+6      	; 0x16e94 <vfprintf+0x2e8>
   16e8e:	99 ee       	ldi	r25, 0xE9	; 233
   16e90:	f9 22       	and	r15, r25
   16e92:	08 c0       	rjmp	.+16     	; 0x16ea4 <vfprintf+0x2f8>
   16e94:	1f 5f       	subi	r17, 0xFF	; 255
   16e96:	f2 fe       	sbrs	r15, 2
   16e98:	05 c0       	rjmp	.+10     	; 0x16ea4 <vfprintf+0x2f8>
   16e9a:	03 c0       	rjmp	.+6      	; 0x16ea2 <vfprintf+0x2f6>
   16e9c:	8f 2d       	mov	r24, r15
   16e9e:	86 78       	andi	r24, 0x86	; 134
   16ea0:	09 f0       	breq	.+2      	; 0x16ea4 <vfprintf+0x2f8>
   16ea2:	1f 5f       	subi	r17, 0xFF	; 255
   16ea4:	0f 2d       	mov	r16, r15
   16ea6:	f3 fc       	sbrc	r15, 3
   16ea8:	14 c0       	rjmp	.+40     	; 0x16ed2 <vfprintf+0x326>
   16eaa:	f0 fe       	sbrs	r15, 0
   16eac:	0f c0       	rjmp	.+30     	; 0x16ecc <vfprintf+0x320>
   16eae:	1e 15       	cp	r17, r14
   16eb0:	10 f0       	brcs	.+4      	; 0x16eb6 <vfprintf+0x30a>
   16eb2:	9d 2c       	mov	r9, r13
   16eb4:	0b c0       	rjmp	.+22     	; 0x16ecc <vfprintf+0x320>
   16eb6:	9d 2c       	mov	r9, r13
   16eb8:	9e 0c       	add	r9, r14
   16eba:	91 1a       	sub	r9, r17
   16ebc:	1e 2d       	mov	r17, r14
   16ebe:	06 c0       	rjmp	.+12     	; 0x16ecc <vfprintf+0x320>
   16ec0:	80 e2       	ldi	r24, 0x20	; 32
   16ec2:	90 e0       	ldi	r25, 0x00	; 0
   16ec4:	b3 01       	movw	r22, r6
   16ec6:	0e 94 c9 b7 	call	0x16f92	; 0x16f92 <fputc>
   16eca:	1f 5f       	subi	r17, 0xFF	; 255
   16ecc:	1e 15       	cp	r17, r14
   16ece:	c0 f3       	brcs	.-16     	; 0x16ec0 <vfprintf+0x314>
   16ed0:	04 c0       	rjmp	.+8      	; 0x16eda <vfprintf+0x32e>
   16ed2:	1e 15       	cp	r17, r14
   16ed4:	10 f4       	brcc	.+4      	; 0x16eda <vfprintf+0x32e>
   16ed6:	e1 1a       	sub	r14, r17
   16ed8:	01 c0       	rjmp	.+2      	; 0x16edc <vfprintf+0x330>
   16eda:	ee 24       	eor	r14, r14
   16edc:	04 ff       	sbrs	r16, 4
   16ede:	0f c0       	rjmp	.+30     	; 0x16efe <vfprintf+0x352>
   16ee0:	80 e3       	ldi	r24, 0x30	; 48
   16ee2:	90 e0       	ldi	r25, 0x00	; 0
   16ee4:	b3 01       	movw	r22, r6
   16ee6:	0e 94 c9 b7 	call	0x16f92	; 0x16f92 <fputc>
   16eea:	02 ff       	sbrs	r16, 2
   16eec:	1d c0       	rjmp	.+58     	; 0x16f28 <vfprintf+0x37c>
   16eee:	01 fd       	sbrc	r16, 1
   16ef0:	03 c0       	rjmp	.+6      	; 0x16ef8 <vfprintf+0x34c>
   16ef2:	88 e7       	ldi	r24, 0x78	; 120
   16ef4:	90 e0       	ldi	r25, 0x00	; 0
   16ef6:	0e c0       	rjmp	.+28     	; 0x16f14 <vfprintf+0x368>
   16ef8:	88 e5       	ldi	r24, 0x58	; 88
   16efa:	90 e0       	ldi	r25, 0x00	; 0
   16efc:	0b c0       	rjmp	.+22     	; 0x16f14 <vfprintf+0x368>
   16efe:	80 2f       	mov	r24, r16
   16f00:	86 78       	andi	r24, 0x86	; 134
   16f02:	91 f0       	breq	.+36     	; 0x16f28 <vfprintf+0x37c>
   16f04:	01 ff       	sbrs	r16, 1
   16f06:	02 c0       	rjmp	.+4      	; 0x16f0c <vfprintf+0x360>
   16f08:	8b e2       	ldi	r24, 0x2B	; 43
   16f0a:	01 c0       	rjmp	.+2      	; 0x16f0e <vfprintf+0x362>
   16f0c:	80 e2       	ldi	r24, 0x20	; 32
   16f0e:	f7 fc       	sbrc	r15, 7
   16f10:	8d e2       	ldi	r24, 0x2D	; 45
   16f12:	90 e0       	ldi	r25, 0x00	; 0
   16f14:	b3 01       	movw	r22, r6
   16f16:	0e 94 c9 b7 	call	0x16f92	; 0x16f92 <fputc>
   16f1a:	06 c0       	rjmp	.+12     	; 0x16f28 <vfprintf+0x37c>
   16f1c:	80 e3       	ldi	r24, 0x30	; 48
   16f1e:	90 e0       	ldi	r25, 0x00	; 0
   16f20:	b3 01       	movw	r22, r6
   16f22:	0e 94 c9 b7 	call	0x16f92	; 0x16f92 <fputc>
   16f26:	9a 94       	dec	r9
   16f28:	d9 14       	cp	r13, r9
   16f2a:	c0 f3       	brcs	.-16     	; 0x16f1c <vfprintf+0x370>
   16f2c:	da 94       	dec	r13
   16f2e:	f1 01       	movw	r30, r2
   16f30:	ed 0d       	add	r30, r13
   16f32:	f1 1d       	adc	r31, r1
   16f34:	80 81       	ld	r24, Z
   16f36:	90 e0       	ldi	r25, 0x00	; 0
   16f38:	b3 01       	movw	r22, r6
   16f3a:	0e 94 c9 b7 	call	0x16f92	; 0x16f92 <fputc>
   16f3e:	dd 20       	and	r13, r13
   16f40:	a9 f7       	brne	.-22     	; 0x16f2c <vfprintf+0x380>
   16f42:	06 c0       	rjmp	.+12     	; 0x16f50 <vfprintf+0x3a4>
   16f44:	80 e2       	ldi	r24, 0x20	; 32
   16f46:	90 e0       	ldi	r25, 0x00	; 0
   16f48:	b3 01       	movw	r22, r6
   16f4a:	0e 94 c9 b7 	call	0x16f92	; 0x16f92 <fputc>
   16f4e:	ea 94       	dec	r14
   16f50:	ee 20       	and	r14, r14
   16f52:	c1 f7       	brne	.-16     	; 0x16f44 <vfprintf+0x398>
   16f54:	43 ce       	rjmp	.-890    	; 0x16bdc <vfprintf+0x30>
   16f56:	f3 01       	movw	r30, r6
   16f58:	66 81       	ldd	r22, Z+6	; 0x06
   16f5a:	77 81       	ldd	r23, Z+7	; 0x07
   16f5c:	cb 01       	movw	r24, r22
   16f5e:	2b 96       	adiw	r28, 0x0b	; 11
   16f60:	e2 e1       	ldi	r30, 0x12	; 18
   16f62:	0c 94 f0 b8 	jmp	0x171e0	; 0x171e0 <__epilogue_restores__>

00016f66 <strnlen_P>:
   16f66:	fc 01       	movw	r30, r24
   16f68:	05 90       	lpm	r0, Z+
   16f6a:	61 50       	subi	r22, 0x01	; 1
   16f6c:	70 40       	sbci	r23, 0x00	; 0
   16f6e:	01 10       	cpse	r0, r1
   16f70:	d8 f7       	brcc	.-10     	; 0x16f68 <strnlen_P+0x2>
   16f72:	80 95       	com	r24
   16f74:	90 95       	com	r25
   16f76:	8e 0f       	add	r24, r30
   16f78:	9f 1f       	adc	r25, r31
   16f7a:	08 95       	ret

00016f7c <strnlen>:
   16f7c:	fc 01       	movw	r30, r24
   16f7e:	61 50       	subi	r22, 0x01	; 1
   16f80:	70 40       	sbci	r23, 0x00	; 0
   16f82:	01 90       	ld	r0, Z+
   16f84:	01 10       	cpse	r0, r1
   16f86:	d8 f7       	brcc	.-10     	; 0x16f7e <strnlen+0x2>
   16f88:	80 95       	com	r24
   16f8a:	90 95       	com	r25
   16f8c:	8e 0f       	add	r24, r30
   16f8e:	9f 1f       	adc	r25, r31
   16f90:	08 95       	ret

00016f92 <fputc>:
   16f92:	0f 93       	push	r16
   16f94:	1f 93       	push	r17
   16f96:	cf 93       	push	r28
   16f98:	df 93       	push	r29
   16f9a:	8c 01       	movw	r16, r24
   16f9c:	eb 01       	movw	r28, r22
   16f9e:	8b 81       	ldd	r24, Y+3	; 0x03
   16fa0:	81 ff       	sbrs	r24, 1
   16fa2:	1b c0       	rjmp	.+54     	; 0x16fda <fputc+0x48>
   16fa4:	82 ff       	sbrs	r24, 2
   16fa6:	0d c0       	rjmp	.+26     	; 0x16fc2 <fputc+0x30>
   16fa8:	2e 81       	ldd	r18, Y+6	; 0x06
   16faa:	3f 81       	ldd	r19, Y+7	; 0x07
   16fac:	8c 81       	ldd	r24, Y+4	; 0x04
   16fae:	9d 81       	ldd	r25, Y+5	; 0x05
   16fb0:	28 17       	cp	r18, r24
   16fb2:	39 07       	cpc	r19, r25
   16fb4:	64 f4       	brge	.+24     	; 0x16fce <fputc+0x3c>
   16fb6:	e8 81       	ld	r30, Y
   16fb8:	f9 81       	ldd	r31, Y+1	; 0x01
   16fba:	01 93       	st	Z+, r16
   16fbc:	f9 83       	std	Y+1, r31	; 0x01
   16fbe:	e8 83       	st	Y, r30
   16fc0:	06 c0       	rjmp	.+12     	; 0x16fce <fputc+0x3c>
   16fc2:	e8 85       	ldd	r30, Y+8	; 0x08
   16fc4:	f9 85       	ldd	r31, Y+9	; 0x09
   16fc6:	80 2f       	mov	r24, r16
   16fc8:	09 95       	icall
   16fca:	89 2b       	or	r24, r25
   16fcc:	31 f4       	brne	.+12     	; 0x16fda <fputc+0x48>
   16fce:	8e 81       	ldd	r24, Y+6	; 0x06
   16fd0:	9f 81       	ldd	r25, Y+7	; 0x07
   16fd2:	01 96       	adiw	r24, 0x01	; 1
   16fd4:	9f 83       	std	Y+7, r25	; 0x07
   16fd6:	8e 83       	std	Y+6, r24	; 0x06
   16fd8:	02 c0       	rjmp	.+4      	; 0x16fde <fputc+0x4c>
   16fda:	0f ef       	ldi	r16, 0xFF	; 255
   16fdc:	1f ef       	ldi	r17, 0xFF	; 255
   16fde:	c8 01       	movw	r24, r16
   16fe0:	df 91       	pop	r29
   16fe2:	cf 91       	pop	r28
   16fe4:	1f 91       	pop	r17
   16fe6:	0f 91       	pop	r16
   16fe8:	08 95       	ret

00016fea <__ultoa_invert>:
   16fea:	fa 01       	movw	r30, r20
   16fec:	aa 27       	eor	r26, r26
   16fee:	28 30       	cpi	r18, 0x08	; 8
   16ff0:	51 f1       	breq	.+84     	; 0x17046 <__ultoa_invert+0x5c>
   16ff2:	20 31       	cpi	r18, 0x10	; 16
   16ff4:	81 f1       	breq	.+96     	; 0x17056 <__ultoa_invert+0x6c>
   16ff6:	e8 94       	clt
   16ff8:	6f 93       	push	r22
   16ffa:	6e 7f       	andi	r22, 0xFE	; 254
   16ffc:	6e 5f       	subi	r22, 0xFE	; 254
   16ffe:	7f 4f       	sbci	r23, 0xFF	; 255
   17000:	8f 4f       	sbci	r24, 0xFF	; 255
   17002:	9f 4f       	sbci	r25, 0xFF	; 255
   17004:	af 4f       	sbci	r26, 0xFF	; 255
   17006:	b1 e0       	ldi	r27, 0x01	; 1
   17008:	3e d0       	rcall	.+124    	; 0x17086 <__ultoa_invert+0x9c>
   1700a:	b4 e0       	ldi	r27, 0x04	; 4
   1700c:	3c d0       	rcall	.+120    	; 0x17086 <__ultoa_invert+0x9c>
   1700e:	67 0f       	add	r22, r23
   17010:	78 1f       	adc	r23, r24
   17012:	89 1f       	adc	r24, r25
   17014:	9a 1f       	adc	r25, r26
   17016:	a1 1d       	adc	r26, r1
   17018:	68 0f       	add	r22, r24
   1701a:	79 1f       	adc	r23, r25
   1701c:	8a 1f       	adc	r24, r26
   1701e:	91 1d       	adc	r25, r1
   17020:	a1 1d       	adc	r26, r1
   17022:	6a 0f       	add	r22, r26
   17024:	71 1d       	adc	r23, r1
   17026:	81 1d       	adc	r24, r1
   17028:	91 1d       	adc	r25, r1
   1702a:	a1 1d       	adc	r26, r1
   1702c:	20 d0       	rcall	.+64     	; 0x1706e <__ultoa_invert+0x84>
   1702e:	09 f4       	brne	.+2      	; 0x17032 <__ultoa_invert+0x48>
   17030:	68 94       	set
   17032:	3f 91       	pop	r19
   17034:	2a e0       	ldi	r18, 0x0A	; 10
   17036:	26 9f       	mul	r18, r22
   17038:	11 24       	eor	r1, r1
   1703a:	30 19       	sub	r19, r0
   1703c:	30 5d       	subi	r19, 0xD0	; 208
   1703e:	31 93       	st	Z+, r19
   17040:	de f6       	brtc	.-74     	; 0x16ff8 <__ultoa_invert+0xe>
   17042:	cf 01       	movw	r24, r30
   17044:	08 95       	ret
   17046:	46 2f       	mov	r20, r22
   17048:	47 70       	andi	r20, 0x07	; 7
   1704a:	40 5d       	subi	r20, 0xD0	; 208
   1704c:	41 93       	st	Z+, r20
   1704e:	b3 e0       	ldi	r27, 0x03	; 3
   17050:	0f d0       	rcall	.+30     	; 0x17070 <__ultoa_invert+0x86>
   17052:	c9 f7       	brne	.-14     	; 0x17046 <__ultoa_invert+0x5c>
   17054:	f6 cf       	rjmp	.-20     	; 0x17042 <__ultoa_invert+0x58>
   17056:	46 2f       	mov	r20, r22
   17058:	4f 70       	andi	r20, 0x0F	; 15
   1705a:	40 5d       	subi	r20, 0xD0	; 208
   1705c:	4a 33       	cpi	r20, 0x3A	; 58
   1705e:	18 f0       	brcs	.+6      	; 0x17066 <__ultoa_invert+0x7c>
   17060:	49 5d       	subi	r20, 0xD9	; 217
   17062:	31 fd       	sbrc	r19, 1
   17064:	40 52       	subi	r20, 0x20	; 32
   17066:	41 93       	st	Z+, r20
   17068:	02 d0       	rcall	.+4      	; 0x1706e <__ultoa_invert+0x84>
   1706a:	a9 f7       	brne	.-22     	; 0x17056 <__ultoa_invert+0x6c>
   1706c:	ea cf       	rjmp	.-44     	; 0x17042 <__ultoa_invert+0x58>
   1706e:	b4 e0       	ldi	r27, 0x04	; 4
   17070:	a6 95       	lsr	r26
   17072:	97 95       	ror	r25
   17074:	87 95       	ror	r24
   17076:	77 95       	ror	r23
   17078:	67 95       	ror	r22
   1707a:	ba 95       	dec	r27
   1707c:	c9 f7       	brne	.-14     	; 0x17070 <__ultoa_invert+0x86>
   1707e:	00 97       	sbiw	r24, 0x00	; 0
   17080:	61 05       	cpc	r22, r1
   17082:	71 05       	cpc	r23, r1
   17084:	08 95       	ret
   17086:	9b 01       	movw	r18, r22
   17088:	ac 01       	movw	r20, r24
   1708a:	0a 2e       	mov	r0, r26
   1708c:	06 94       	lsr	r0
   1708e:	57 95       	ror	r21
   17090:	47 95       	ror	r20
   17092:	37 95       	ror	r19
   17094:	27 95       	ror	r18
   17096:	ba 95       	dec	r27
   17098:	c9 f7       	brne	.-14     	; 0x1708c <__ultoa_invert+0xa2>
   1709a:	62 0f       	add	r22, r18
   1709c:	73 1f       	adc	r23, r19
   1709e:	84 1f       	adc	r24, r20
   170a0:	95 1f       	adc	r25, r21
   170a2:	a0 1d       	adc	r26, r0
   170a4:	08 95       	ret

000170a6 <__mulsi3>:
   170a6:	62 9f       	mul	r22, r18
   170a8:	d0 01       	movw	r26, r0
   170aa:	73 9f       	mul	r23, r19
   170ac:	f0 01       	movw	r30, r0
   170ae:	82 9f       	mul	r24, r18
   170b0:	e0 0d       	add	r30, r0
   170b2:	f1 1d       	adc	r31, r1
   170b4:	64 9f       	mul	r22, r20
   170b6:	e0 0d       	add	r30, r0
   170b8:	f1 1d       	adc	r31, r1
   170ba:	92 9f       	mul	r25, r18
   170bc:	f0 0d       	add	r31, r0
   170be:	83 9f       	mul	r24, r19
   170c0:	f0 0d       	add	r31, r0
   170c2:	74 9f       	mul	r23, r20
   170c4:	f0 0d       	add	r31, r0
   170c6:	65 9f       	mul	r22, r21
   170c8:	f0 0d       	add	r31, r0
   170ca:	99 27       	eor	r25, r25
   170cc:	72 9f       	mul	r23, r18
   170ce:	b0 0d       	add	r27, r0
   170d0:	e1 1d       	adc	r30, r1
   170d2:	f9 1f       	adc	r31, r25
   170d4:	63 9f       	mul	r22, r19
   170d6:	b0 0d       	add	r27, r0
   170d8:	e1 1d       	adc	r30, r1
   170da:	f9 1f       	adc	r31, r25
   170dc:	bd 01       	movw	r22, r26
   170de:	cf 01       	movw	r24, r30
   170e0:	11 24       	eor	r1, r1
   170e2:	08 95       	ret

000170e4 <__udivmodqi4>:
   170e4:	99 1b       	sub	r25, r25
   170e6:	79 e0       	ldi	r23, 0x09	; 9
   170e8:	04 c0       	rjmp	.+8      	; 0x170f2 <__udivmodqi4_ep>

000170ea <__udivmodqi4_loop>:
   170ea:	99 1f       	adc	r25, r25
   170ec:	96 17       	cp	r25, r22
   170ee:	08 f0       	brcs	.+2      	; 0x170f2 <__udivmodqi4_ep>
   170f0:	96 1b       	sub	r25, r22

000170f2 <__udivmodqi4_ep>:
   170f2:	88 1f       	adc	r24, r24
   170f4:	7a 95       	dec	r23
   170f6:	c9 f7       	brne	.-14     	; 0x170ea <__udivmodqi4_loop>
   170f8:	80 95       	com	r24
   170fa:	08 95       	ret

000170fc <__divmodqi4>:
   170fc:	87 fb       	bst	r24, 7
   170fe:	08 2e       	mov	r0, r24
   17100:	06 26       	eor	r0, r22
   17102:	87 fd       	sbrc	r24, 7
   17104:	81 95       	neg	r24
   17106:	67 fd       	sbrc	r22, 7
   17108:	61 95       	neg	r22
   1710a:	ec df       	rcall	.-40     	; 0x170e4 <__udivmodqi4>
   1710c:	0e f4       	brtc	.+2      	; 0x17110 <__divmodqi4_1>
   1710e:	91 95       	neg	r25

00017110 <__divmodqi4_1>:
   17110:	07 fc       	sbrc	r0, 7
   17112:	81 95       	neg	r24

00017114 <__divmodqi4_exit>:
   17114:	08 95       	ret

00017116 <__udivmodhi4>:
   17116:	aa 1b       	sub	r26, r26
   17118:	bb 1b       	sub	r27, r27
   1711a:	51 e1       	ldi	r21, 0x11	; 17
   1711c:	07 c0       	rjmp	.+14     	; 0x1712c <__udivmodhi4_ep>

0001711e <__udivmodhi4_loop>:
   1711e:	aa 1f       	adc	r26, r26
   17120:	bb 1f       	adc	r27, r27
   17122:	a6 17       	cp	r26, r22
   17124:	b7 07       	cpc	r27, r23
   17126:	10 f0       	brcs	.+4      	; 0x1712c <__udivmodhi4_ep>
   17128:	a6 1b       	sub	r26, r22
   1712a:	b7 0b       	sbc	r27, r23

0001712c <__udivmodhi4_ep>:
   1712c:	88 1f       	adc	r24, r24
   1712e:	99 1f       	adc	r25, r25
   17130:	5a 95       	dec	r21
   17132:	a9 f7       	brne	.-22     	; 0x1711e <__udivmodhi4_loop>
   17134:	80 95       	com	r24
   17136:	90 95       	com	r25
   17138:	bc 01       	movw	r22, r24
   1713a:	cd 01       	movw	r24, r26
   1713c:	08 95       	ret

0001713e <__divmodhi4>:
   1713e:	97 fb       	bst	r25, 7
   17140:	09 2e       	mov	r0, r25
   17142:	07 26       	eor	r0, r23
   17144:	0a d0       	rcall	.+20     	; 0x1715a <__divmodhi4_neg1>
   17146:	77 fd       	sbrc	r23, 7
   17148:	04 d0       	rcall	.+8      	; 0x17152 <__divmodhi4_neg2>
   1714a:	e5 df       	rcall	.-54     	; 0x17116 <__udivmodhi4>
   1714c:	06 d0       	rcall	.+12     	; 0x1715a <__divmodhi4_neg1>
   1714e:	00 20       	and	r0, r0
   17150:	1a f4       	brpl	.+6      	; 0x17158 <__divmodhi4_exit>

00017152 <__divmodhi4_neg2>:
   17152:	70 95       	com	r23
   17154:	61 95       	neg	r22
   17156:	7f 4f       	sbci	r23, 0xFF	; 255

00017158 <__divmodhi4_exit>:
   17158:	08 95       	ret

0001715a <__divmodhi4_neg1>:
   1715a:	f6 f7       	brtc	.-4      	; 0x17158 <__divmodhi4_exit>
   1715c:	90 95       	com	r25
   1715e:	81 95       	neg	r24
   17160:	9f 4f       	sbci	r25, 0xFF	; 255
   17162:	08 95       	ret

00017164 <__udivmodsi4>:
   17164:	a1 e2       	ldi	r26, 0x21	; 33
   17166:	1a 2e       	mov	r1, r26
   17168:	aa 1b       	sub	r26, r26
   1716a:	bb 1b       	sub	r27, r27
   1716c:	fd 01       	movw	r30, r26
   1716e:	0d c0       	rjmp	.+26     	; 0x1718a <__udivmodsi4_ep>

00017170 <__udivmodsi4_loop>:
   17170:	aa 1f       	adc	r26, r26
   17172:	bb 1f       	adc	r27, r27
   17174:	ee 1f       	adc	r30, r30
   17176:	ff 1f       	adc	r31, r31
   17178:	a2 17       	cp	r26, r18
   1717a:	b3 07       	cpc	r27, r19
   1717c:	e4 07       	cpc	r30, r20
   1717e:	f5 07       	cpc	r31, r21
   17180:	20 f0       	brcs	.+8      	; 0x1718a <__udivmodsi4_ep>
   17182:	a2 1b       	sub	r26, r18
   17184:	b3 0b       	sbc	r27, r19
   17186:	e4 0b       	sbc	r30, r20
   17188:	f5 0b       	sbc	r31, r21

0001718a <__udivmodsi4_ep>:
   1718a:	66 1f       	adc	r22, r22
   1718c:	77 1f       	adc	r23, r23
   1718e:	88 1f       	adc	r24, r24
   17190:	99 1f       	adc	r25, r25
   17192:	1a 94       	dec	r1
   17194:	69 f7       	brne	.-38     	; 0x17170 <__udivmodsi4_loop>
   17196:	60 95       	com	r22
   17198:	70 95       	com	r23
   1719a:	80 95       	com	r24
   1719c:	90 95       	com	r25
   1719e:	9b 01       	movw	r18, r22
   171a0:	ac 01       	movw	r20, r24
   171a2:	bd 01       	movw	r22, r26
   171a4:	cf 01       	movw	r24, r30
   171a6:	08 95       	ret

000171a8 <__prologue_saves__>:
   171a8:	2f 92       	push	r2
   171aa:	3f 92       	push	r3
   171ac:	4f 92       	push	r4
   171ae:	5f 92       	push	r5
   171b0:	6f 92       	push	r6
   171b2:	7f 92       	push	r7
   171b4:	8f 92       	push	r8
   171b6:	9f 92       	push	r9
   171b8:	af 92       	push	r10
   171ba:	bf 92       	push	r11
   171bc:	cf 92       	push	r12
   171be:	df 92       	push	r13
   171c0:	ef 92       	push	r14
   171c2:	ff 92       	push	r15
   171c4:	0f 93       	push	r16
   171c6:	1f 93       	push	r17
   171c8:	cf 93       	push	r28
   171ca:	df 93       	push	r29
   171cc:	cd b7       	in	r28, 0x3d	; 61
   171ce:	de b7       	in	r29, 0x3e	; 62
   171d0:	ca 1b       	sub	r28, r26
   171d2:	db 0b       	sbc	r29, r27
   171d4:	0f b6       	in	r0, 0x3f	; 63
   171d6:	f8 94       	cli
   171d8:	de bf       	out	0x3e, r29	; 62
   171da:	0f be       	out	0x3f, r0	; 63
   171dc:	cd bf       	out	0x3d, r28	; 61
   171de:	09 94       	ijmp

000171e0 <__epilogue_restores__>:
   171e0:	2a 88       	ldd	r2, Y+18	; 0x12
   171e2:	39 88       	ldd	r3, Y+17	; 0x11
   171e4:	48 88       	ldd	r4, Y+16	; 0x10
   171e6:	5f 84       	ldd	r5, Y+15	; 0x0f
   171e8:	6e 84       	ldd	r6, Y+14	; 0x0e
   171ea:	7d 84       	ldd	r7, Y+13	; 0x0d
   171ec:	8c 84       	ldd	r8, Y+12	; 0x0c
   171ee:	9b 84       	ldd	r9, Y+11	; 0x0b
   171f0:	aa 84       	ldd	r10, Y+10	; 0x0a
   171f2:	b9 84       	ldd	r11, Y+9	; 0x09
   171f4:	c8 84       	ldd	r12, Y+8	; 0x08
   171f6:	df 80       	ldd	r13, Y+7	; 0x07
   171f8:	ee 80       	ldd	r14, Y+6	; 0x06
   171fa:	fd 80       	ldd	r15, Y+5	; 0x05
   171fc:	0c 81       	ldd	r16, Y+4	; 0x04
   171fe:	1b 81       	ldd	r17, Y+3	; 0x03
   17200:	aa 81       	ldd	r26, Y+2	; 0x02
   17202:	b9 81       	ldd	r27, Y+1	; 0x01
   17204:	ce 0f       	add	r28, r30
   17206:	d1 1d       	adc	r29, r1
   17208:	0f b6       	in	r0, 0x3f	; 63
   1720a:	f8 94       	cli
   1720c:	de bf       	out	0x3e, r29	; 62
   1720e:	0f be       	out	0x3f, r0	; 63
   17210:	cd bf       	out	0x3d, r28	; 61
   17212:	ed 01       	movw	r28, r26
   17214:	08 95       	ret

00017216 <_exit>:
   17216:	f8 94       	cli

00017218 <__stop_program>:
   17218:	ff cf       	rjmp	.-2      	; 0x17218 <__stop_program>
