
master4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000074  00800100  0001707c  00017130  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0001707c  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000d60  00800174  00800174  000171a4  2**0
                  ALLOC
  3 .eeprom       00000886  00810000  00810000  000171a4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000000e0  00000000  00000000  00017a2a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000296d  00000000  00000000  00017b0a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000132e6  00000000  00000000  0001a477  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c60  00000000  00000000  0002d75d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000e026  00000000  00000000  0002e3bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000012d0  00000000  00000000  0003c3e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005318  00000000  00000000  0003d6b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000077ef  00000000  00000000  000429cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000798  00000000  00000000  0004a1bb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 02 12 	jmp	0x2404	; 0x2404 <__ctors_end>
       4:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
       8:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
       c:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      10:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      14:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      18:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      1c:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      20:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      24:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      28:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      2c:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      30:	0c 94 36 aa 	jmp	0x1546c	; 0x1546c <__vector_12>
      34:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      38:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      3c:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      40:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      44:	0c 94 42 7d 	jmp	0xfa84	; 0xfa84 <__vector_17>
      48:	0c 94 f0 13 	jmp	0x27e0	; 0x27e0 <__vector_18>
      4c:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      50:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      54:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      58:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      5c:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      60:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      64:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      68:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      6c:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      70:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      74:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      78:	0c 94 9f a9 	jmp	0x1533e	; 0x1533e <__vector_30>
      7c:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      80:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      84:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      88:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__bad_interrupt>
      8c:	d1 12       	cpse	r13, r17
      8e:	cf 12       	cpse	r12, r31
      90:	d3 12       	cpse	r13, r19
      92:	d5 12       	cpse	r13, r21
      94:	d7 12       	cpse	r13, r23
      96:	d9 12       	cpse	r13, r25
      98:	db 12       	cpse	r13, r27
      9a:	dd 12       	cpse	r13, r29
      9c:	df 12       	cpse	r13, r31
      9e:	e1 12       	cpse	r14, r17
      a0:	f3 12       	cpse	r15, r19
      a2:	e3 12       	cpse	r14, r19
      a4:	e5 12       	cpse	r14, r21
      a6:	f1 12       	cpse	r15, r17
      a8:	e7 12       	cpse	r14, r23
      aa:	f1 12       	cpse	r15, r17
      ac:	f3 12       	cpse	r15, r19
      ae:	e9 12       	cpse	r14, r25
      b0:	f1 12       	cpse	r15, r17
      b2:	eb 12       	cpse	r14, r27
      b4:	ed 12       	cpse	r14, r29
      b6:	ef 12       	cpse	r14, r31
      b8:	f1 12       	cpse	r15, r17
      ba:	f1 12       	cpse	r15, r17
      bc:	e7 12       	cpse	r14, r23
      be:	db 12       	cpse	r13, r27
      c0:	f1 12       	cpse	r15, r17
      c2:	dd 12       	cpse	r13, r29
      c4:	e1 12       	cpse	r14, r17
      c6:	e3 12       	cpse	r14, r19
      c8:	a6 52       	subi	r26, 0x26	; 38
      ca:	be 52       	subi	r27, 0x2E	; 46
      cc:	d0 52       	subi	r29, 0x20	; 32
      ce:	05 53       	subi	r16, 0x35	; 53
      d0:	36 53       	subi	r19, 0x36	; 54
      d2:	4c 53       	subi	r20, 0x3C	; 60
      d4:	81 53       	subi	r24, 0x31	; 49
      d6:	bb 53       	subi	r27, 0x3B	; 59
      d8:	ff 53       	subi	r31, 0x3F	; 63
      da:	07 54       	subi	r16, 0x47	; 71
      dc:	1f 54       	subi	r17, 0x4F	; 79
      de:	2b 54       	subi	r18, 0x4B	; 75
      e0:	5d 54       	subi	r21, 0x4D	; 77
      e2:	9e 54       	subi	r25, 0x4E	; 78
      e4:	bb 54       	subi	r27, 0x4B	; 75
      e6:	d5 54       	subi	r29, 0x45	; 69
      e8:	15 55       	subi	r17, 0x55	; 85
      ea:	1c 53       	subi	r17, 0x3C	; 60
      ec:	d7 53       	subi	r29, 0x37	; 55
      ee:	78 54       	subi	r23, 0x48	; 72
      f0:	a1 53       	subi	r26, 0x31	; 49
      f2:	3b 55       	subi	r19, 0x5B	; 91
      f4:	51 55       	subi	r21, 0x51	; 81
      f6:	56 55       	subi	r21, 0x56	; 86
      f8:	8f 55       	subi	r24, 0x5F	; 95
      fa:	c0 55       	subi	r28, 0x50	; 80
      fc:	05 56       	subi	r16, 0x65	; 101
      fe:	25 56       	subi	r18, 0x65	; 101
     100:	3f 56       	subi	r19, 0x6F	; 111
     102:	79 56       	subi	r23, 0x69	; 105
     104:	d8 56       	subi	r29, 0x68	; 104
     106:	1c 5b       	subi	r17, 0xBC	; 188
     108:	a6 55       	subi	r26, 0x56	; 86
     10a:	44 5b       	subi	r20, 0xB4	; 180
     10c:	a4 5b       	subi	r26, 0xB4	; 180
     10e:	5e 5b       	subi	r21, 0xBE	; 190
     110:	89 5b       	subi	r24, 0xB9	; 185
     112:	de 5b       	subi	r29, 0xBE	; 190
     114:	be 5b       	subi	r27, 0xBE	; 190
     116:	f7 5b       	subi	r31, 0xB7	; 183
     118:	12 5c       	subi	r17, 0xC2	; 194
     11a:	24 5c       	subi	r18, 0xC4	; 196
     11c:	e8 56       	subi	r30, 0x68	; 104
     11e:	08 57       	subi	r16, 0x78	; 120
     120:	2f 57       	subi	r18, 0x7F	; 127
     122:	3e 57       	subi	r19, 0x7E	; 126
     124:	5c 57       	subi	r21, 0x7C	; 124
     126:	73 57       	subi	r23, 0x73	; 115
     128:	9f 57       	subi	r25, 0x7F	; 127
     12a:	b6 57       	subi	r27, 0x76	; 118
     12c:	e2 57       	subi	r30, 0x72	; 114
     12e:	02 58       	subi	r16, 0x82	; 130
     130:	33 58       	subi	r19, 0x83	; 131
     132:	42 58       	subi	r20, 0x82	; 130
     134:	9b 58       	subi	r25, 0x8B	; 139
     136:	12 59       	subi	r17, 0x92	; 146
     138:	26 59       	subi	r18, 0x96	; 150
     13a:	01 5a       	subi	r16, 0xA1	; 161
     13c:	01 5a       	subi	r16, 0xA1	; 161
     13e:	3a 59       	subi	r19, 0x9A	; 154
     140:	4e 59       	subi	r20, 0x9E	; 158
     142:	56 59       	subi	r21, 0x96	; 150
     144:	72 59       	subi	r23, 0x92	; 146
     146:	86 59       	subi	r24, 0x96	; 150
     148:	93 59       	subi	r25, 0x93	; 147
     14a:	aa 59       	subi	r26, 0x9A	; 154
     14c:	c1 59       	subi	r28, 0x91	; 145
     14e:	df 59       	subi	r29, 0x9F	; 159
     150:	04 5a       	subi	r16, 0xA4	; 164
     152:	1b 5a       	subi	r17, 0xAB	; 171
     154:	32 5a       	subi	r19, 0xA2	; 162
     156:	49 5a       	subi	r20, 0xA9	; 169
     158:	60 5a       	subi	r22, 0xA0	; 160
     15a:	77 5a       	subi	r23, 0xA7	; 167
     15c:	8e 5a       	subi	r24, 0xAE	; 174
     15e:	a5 5a       	subi	r26, 0xA5	; 165
     160:	b4 5a       	subi	r27, 0xA4	; 164
     162:	cb 5a       	subi	r28, 0xAB	; 171
     164:	ee 5a       	subi	r30, 0xAE	; 174
     166:	e0 8c       	ldd	r14, Z+24	; 0x18
     168:	fc 8c       	ldd	r15, Y+28	; 0x1c
     16a:	0f 8d       	ldd	r16, Y+31	; 0x1f
     16c:	3e 8d       	ldd	r19, Y+30	; 0x1e
     16e:	67 8d       	ldd	r22, Z+31	; 0x1f
     170:	da 8d       	ldd	r29, Y+26	; 0x1a
     172:	ec 8d       	ldd	r30, Y+28	; 0x1c
     174:	f5 8d       	ldd	r31, Z+29	; 0x1d
     176:	31 8e       	std	Z+25, r3	; 0x19
     178:	58 8e       	std	Y+24, r5	; 0x18
     17a:	9f 8e       	std	Y+31, r9	; 0x1f
     17c:	a9 8e       	std	Y+25, r10	; 0x19
     17e:	64 8e       	std	Z+28, r6	; 0x1c
     180:	af 8e       	std	Y+31, r10	; 0x1f
     182:	0c 8d       	ldd	r16, Y+28	; 0x1c
     184:	c1 8e       	std	Z+25, r12	; 0x19
     186:	c7 8e       	std	Z+31, r12	; 0x1f
     188:	69 91       	ld	r22, Y+
     18a:	6d 91       	ld	r22, X+
     18c:	89 91       	ld	r24, Y+
     18e:	6c 95 6c 95 	jmp	0x592ad8	; 0x592ad8 <__data_load_end+0x57b9e8>
     192:	6c 95 6c 95 	jmp	0x592ad8	; 0x592ad8 <__data_load_end+0x57b9e8>
     196:	db 91       	.word	0x91db	; ????
     198:	6c 95 fd 91 	jmp	0x5923fa	; 0x5923fa <__data_load_end+0x57b30a>
     19c:	6c 95 1c 92 	jmp	0x592438	; 0x592438 <__data_load_end+0x57b348>
     1a0:	a5 92       	.word	0x92a5	; ????
     1a2:	05 93       	.word	0x9305	; ????
     1a4:	29 93       	st	Y+, r18
     1a6:	ba 91       	ld	r27, -Y
     1a8:	6c 95 bd 92 	jmp	0x59257a	; 0x59257a <__data_load_end+0x57b48a>
     1ac:	41 93       	st	Z+, r20
     1ae:	79 93       	st	Y+, r23
     1b0:	96 93       	.word	0x9396	; ????
     1b2:	d2 93       	st	-Z, r29
     1b4:	e2 93       	st	-Z, r30	; undefined
     1b6:	da 94       	dec	r13
     1b8:	ea 94       	dec	r14
     1ba:	2f 95 4e 95 	call	0x4b2a9c	; 0x4b2a9c <__data_load_end+0x49b9ac>
     1be:	60 95       	com	r22
     1c0:	66 95       	lsr	r22
     1c2:	68 95       	.word	0x9568	; ????
     1c4:	a2 95       	swap	r26
     1c6:	fb 95       	.word	0x95fb	; ????
     1c8:	09 96       	adiw	r24, 0x09	; 9
     1ca:	51 96       	adiw	r26, 0x11	; 17
     1cc:	6a 96       	adiw	r28, 0x1a	; 26
     1ce:	81 96       	adiw	r24, 0x21	; 33
     1d0:	aa 96       	adiw	r28, 0x2a	; 42
     1d2:	60 97       	sbiw	r28, 0x10	; 16
     1d4:	6e 97       	sbiw	r28, 0x1e	; 30
     1d6:	ed 97       	sbiw	r28, 0x3d	; 61
     1d8:	99 98       	cbi	0x13, 1	; 19
     1da:	9b 99       	sbic	0x13, 3	; 19
     1dc:	ec 99       	sbic	0x1d, 4	; 29
     1de:	32 9a       	sbi	0x06, 2	; 6
     1e0:	af 9a       	sbi	0x15, 7	; 21
     1e2:	43 9b       	sbis	0x08, 3	; 8
     1e4:	e9 9b       	sbis	0x1d, 1	; 29
     1e6:	af 9c       	mul	r10, r15
     1e8:	db 9c       	mul	r13, r11
     1ea:	94 9d       	mul	r25, r4
     1ec:	b1 9d       	mul	r27, r1
     1ee:	c7 9e       	mul	r12, r23
     1f0:	2b 9e       	mul	r2, r27
     1f2:	72 9e       	mul	r7, r18
     1f4:	68 9f       	mul	r22, r24
     1f6:	96 9f       	mul	r25, r22
     1f8:	ab 9f       	mul	r26, r27
     1fa:	cf 9e       	mul	r12, r31
     1fc:	53 9f       	mul	r21, r19
     1fe:	9c 9f       	mul	r25, r28
     200:	a4 9f       	mul	r26, r20
     202:	67 a1       	ldd	r22, Z+39	; 0x27
     204:	6d a1       	ldd	r22, Y+37	; 0x25
     206:	71 a1       	ldd	r23, Z+33	; 0x21
     208:	88 a1       	ldd	r24, Y+32	; 0x20
     20a:	a2 a1       	ldd	r26, Z+34	; 0x22
     20c:	a6 a1       	ldd	r26, Z+38	; 0x26
     20e:	d5 a1       	ldd	r29, Z+37	; 0x25
     210:	f4 a1       	ldd	r31, Z+36	; 0x24
     212:	fa a1       	ldd	r31, Y+34	; 0x22
     214:	06 a2       	std	Z+38, r0	; 0x26
     216:	09 a2       	std	Y+33, r0	; 0x21
     218:	0c a2       	std	Y+36, r0	; 0x24
     21a:	0f a2       	std	Y+39, r0	; 0x27
     21c:	12 a2       	std	Z+34, r1	; 0x22
     21e:	15 a2       	std	Z+37, r1	; 0x25
     220:	18 a2       	std	Y+32, r1	; 0x20
     222:	1e a2       	std	Y+38, r1	; 0x26
     224:	21 a2       	std	Z+33, r2	; 0x21
     226:	28 a2       	std	Y+32, r2	; 0x20
     228:	a7 a2       	std	Z+39, r10	; 0x27
     22a:	aa a2       	std	Y+34, r10	; 0x22
     22c:	58 a3       	std	Y+32, r21	; 0x20
     22e:	67 a3       	std	Z+39, r22	; 0x27
     230:	9a a3       	std	Y+34, r25	; 0x22
     232:	aa a3       	std	Y+34, r26	; 0x22
     234:	d8 a3       	std	Y+32, r29	; 0x20
     236:	77 a3       	std	Z+39, r23	; 0x27
     238:	86 a3       	std	Z+38, r24	; 0x26
     23a:	90 a3       	std	Z+32, r25	; 0x20
     23c:	e2 a3       	std	Z+34, r30	; 0x22
     23e:	ef a3       	std	Y+39, r30	; 0x27
     240:	03 a4       	ldd	r0, Z+43	; 0x2b
     242:	06 a4       	ldd	r0, Z+46	; 0x2e
     244:	09 a4       	ldd	r0, Y+41	; 0x29
     246:	0c a4       	ldd	r0, Y+44	; 0x2c
     248:	0f a4       	ldd	r0, Y+47	; 0x2f
     24a:	12 a4       	ldd	r1, Z+42	; 0x2a
     24c:	15 a4       	ldd	r1, Z+45	; 0x2d
     24e:	18 a4       	ldd	r1, Y+40	; 0x28
     250:	42 a4       	ldd	r4, Z+42	; 0x2a
     252:	28 a4       	ldd	r2, Y+40	; 0x28
     254:	1b a4       	ldd	r1, Y+43	; 0x2b
     256:	33 a4       	ldd	r3, Z+43	; 0x2b
     258:	44 a3       	std	Z+36, r20	; 0x24
     25a:	39 a4       	ldd	r3, Y+41	; 0x29

0000025c <__logo>:
     25c:	00 00 00 01 01 01 05 09 00 00 00 11 11 11 15 15     ................
     26c:	11 00 00 00 00 10 10 10 14 12 00 0f 07 03 01 01     ................
     27c:	01 01 00 00 11 11 11 11 11 11 00 00 00 1e 1c 18     ................
     28c:	10 10 10 10 00 00 1f 1b 15 17 17 15 1b 1f 00 14     ................
     29c:	14 08 08 07 04 06 04 00                             ........

000002a4 <__c.3004>:
     2a4:	49 6e 69 74 69 61 6c 69 7a 65 2e 2e 2e 20 00        Initialize... .

000002b3 <__c.2988>:
     2b3:	57 61 74 63 68 44 6f 67 00                          WatchDog.

000002bc <__c.2986>:
     2bc:	42 72 6f 77 6e 4f 75 74 00                          BrownOut.

000002c5 <__c.2984>:
     2c5:	45 78 74 65 72 6e 61 6c 00                          External.

000002ce <__c.2982>:
     2ce:	50 6f 77 65 72 4f 6e 00                             PowerOn.

000002d6 <__reprintloc>:
     2d6:	01 06 02 06 03 06 04 06 01 0d 02 0d 03 0d 04 0d     ................

000002e6 <__idleloc>:
     2e6:	04 05 06 07 08 09 0a 0b                             ........

000002ee <__pumploc>:
     2ee:	01 05 02 05 03 05 04 05 01 0c 02 0c 03 0c 04 0c     ................

000002fe <__prodloc>:
     2fe:	01 06 02 06 01 0d 02 0d 01 14 02 14                 ............

0000030a <__decloc>:
     30a:	01 09 02 09 03 09 04 09 01 14                       ..........

00000314 <__prntloc>:
     314:	01 08 02 08 03 08 04 08 01 13 02 13                 ............

00000320 <__prntlmt>:
     320:	02 03 04 02 0f 0f                                   ......

00000326 <__prntstr>:
     326:	01 01 00 00 00 00                                   ......

0000032c <__hostloc>:
     32c:	01 0a 02 0a 03 0a                                   ......

00000332 <__txttitle>:
     332:	48 65 61 64 65 72 31 20 3a 00 48 65 61 64 65 72     Header1 :.Header
     342:	32 20 3a 00 48 65 61 64 65 72 33 20 3a 00 48 65     2 :.Header3 :.He
     352:	61 64 65 72 34 20 3a 00 46 6f 6f 74 65 72 31 20     ader4 :.Footer1 
     362:	3a 00 46 6f 6f 74 65 72 32 20 3a 00 46 6f 6f 74     :.Footer2 :.Foot
     372:	65 72 33 20 3a 00 46 6f 6f 74 65 72 34 20 3a 00     er3 :.Footer4 :.

00000382 <MaxKeyHit>:
     382:	02 04 03 03 03 03 03 04 03 04                       ..........

0000038c <strDispenserName1>:
     38c:	4e 2f 41 00                                         N/A.

00000390 <strDispenserName2>:
     390:	47 69 6c 62 61 72 63 6f 00                          Gilbarco.

00000399 <strDispenserName3>:
     399:	57 61 79 6e 65 20 44 41 52 54 00                    Wayne DART.

000003a4 <strDispenserName4>:
     3a4:	54 61 74 73 75 6e 6f 00                             Tatsuno.

000003ac <strDispenserName5>:
     3ac:	4c 47 00                                            LG.

000003af <DefListDispenserName>:
     3af:	8c 03 90 03 99 03 a4 03 ac 03                       ..........

000003b9 <__c.9998>:
     3b9:	25 64 00                                            %d.

000003bc <__c.9996>:
     3bc:	54 25 2e 32 64 25 2e 32 64 25 73 25 73 25 73 25     T%.2d%.2d%s%s%s%
     3cc:	73 25 73 25 73 3a 00                                s%s%s:.

000003d3 <__c.9947>:
     3d3:	32 30 25 73 2f 25 73 2f 25 73 20 25 73 3a 25 73     20%s/%s/%s %s:%s
     3e3:	3a 25 73 00                                         :%s.

000003e7 <__c.9919>:
     3e7:	25 73 00                                            %s.

000003ea <__c.9910>:
     3ea:	25 73 00                                            %s.

000003ed <__c.9859>:
     3ed:	25 63 25 2e 32 64 3a 00                             %c%.2d:.

000003f5 <__c.9837>:
     3f5:	43 54 53 52 50 00                                   CTSRP.

000003fb <__c.9813>:
     3fb:	3a 00                                               :.

000003fd <__c.9757>:
     3fd:	46 6d 74 54 4d 6f 6e 65 79 3a 25 73 00              FmtTMoney:%s.

0000040a <__c.9755>:
     40a:	46 6d 74 4d 6f 6e 65 79 3a 25 73 00                 FmtMoney:%s.

00000416 <__c.9753>:
     416:	54 4d 6f 6e 65 79 3a 25 73 00                       TMoney:%s.

00000420 <__c.9751>:
     420:	54 56 6f 6c 75 6d 65 3a 25 73 00                    TVolume:%s.

0000042b <__c.9749>:
     42b:	4d 6f 6e 65 79 3a 25 73 00                          Money:%s.

00000434 <__c.9747>:
     434:	56 6f 6c 75 6d 65 3a 25 73 00                       Volume:%s.

0000043e <__c.9745>:
     43e:	52 65 6d 6f 76 65 64 3a 25 73 00                    Removed:%s.

00000449 <__c.9743>:
     449:	4d 69 6e 75 73 3a 25 73 00                          Minus:%s.

00000452 <__c.9741>:
     452:	52 61 77 3a 25 73 00                                Raw:%s.

00000459 <__c.9739>:
     459:	46 6f 72 6d 61 74 65 64 3a 25 73 00                 Formated:%s.

00000465 <__c.9737>:
     465:	25 73 00                                            %s.

00000468 <__c.9735>:
     468:	25 73 00                                            %s.

0000046b <__c.9733>:
     46b:	25 73 00                                            %s.

0000046e <__c.9731>:
     46e:	25 73 00                                            %s.

00000471 <__c.9729>:
     471:	44 61 74 61 3a 25 73 00                             Data:%s.

00000479 <__c.9617>:
     479:	4e 2f 41 00                                         N/A.

0000047d <__c.9597>:
     47d:	25 73 00                                            %s.

00000480 <__c.9592>:
	...

00000481 <__c.9468>:
     481:	25 64 2e 25 73 25 73 25 73 00                       %d.%s%s%s.

0000048b <__c.9466>:
     48b:	25 64 2e 25 73 25 73 25 73 25 73 25 73 00           %d.%s%s%s%s%s.

00000499 <__c.9458>:
     499:	54 4f 54 41 4c 20 25 73 25 73 00                    TOTAL %s%s.

000004a4 <__c.9456>:
     4a4:	54 4f 54 41 4c 20 25 73 25 73 25 73 25 73 00        TOTAL %s%s%s%s.

000004b3 <__c.9452>:
     4b3:	25 73 25 73 00                                      %s%s.

000004b8 <__c.9450>:
     4b8:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

000004c1 <__c.9448>:
     4c1:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     4d1:	20 20 20 20 20 20 20 20 20 20 20 20 20 00                        .

000004df <__c.9446>:
     4df:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     4ef:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00           -------------.

000004fd <__c.9444>:
     4fd:	41 77 61 6c 20 3a 25 73 25 73 00                    Awal :%s%s.

00000508 <__c.9442>:
     508:	41 77 61 6c 20 3a 25 73 25 73 25 73 25 73 00        Awal :%s%s%s%s.

00000517 <__c.9440>:
     517:	41 6b 68 69 72 3a 25 73 25 73 00                    Akhir:%s%s.

00000522 <__c.9438>:
     522:	41 6b 68 69 72 3a 25 73 25 73 25 73 25 73 00        Akhir:%s%s%s%s.

00000531 <__c.9436>:
     531:	50 25 64 2e 25 64 20 2d 20 25 73 20 00              P%d.%d - %s .

0000053e <__c.9434>:
     53e:	50 25 64 2e 25 64 20 2d 20 25 73 20 25 73 20 25     P%d.%d - %s %s %
     54e:	73 00                                               s.

00000550 <__c.9432>:
     550:	48 61 72 67 61 3a 20 52 70 2e 25 73 00              Harga: Rp.%s.

0000055d <__c.9428>:
     55d:	4e 2f 41 00                                         N/A.

00000561 <__c.9424>:
     561:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     571:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 20 20 20 20     OLUME(L)        
     581:	20 20 20 20 20 20 00                                      .

00000588 <__c.9422>:
     588:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     598:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 52 55 50 49     OLUME(L)    RUPI
     5a8:	41 48 28 52 50 29 00                                AH(RP).

000005af <__c.9418>:
     5af:	41 6b 68 69 72 20 53 68 69 66 74 20 3a 20 25 73     Akhir Shift : %s
     5bf:	20 00                                                .

000005c1 <__c.9416>:
     5c1:	41 77 61 6c 20 20 53 68 69 66 74 20 3a 20 25 73     Awal  Shift : %s
     5d1:	20 00                                                .

000005d3 <__c.9414>:
     5d3:	54 65 72 6d 69 6e 61 6c 20 49 44 20 3a 20 25 2e     Terminal ID : %.
     5e3:	32 64 20 20 20 20 20 20 20 20 20 20 20 20 20 20     2d              
     5f3:	20 20 20 20 20 00                                        .

000005f9 <__c.9412>:
     5f9:	20 20 20 20 20 20 20 20 4c 61 70 6f 72 61 6e 20             Laporan 
     609:	54 75 74 75 70 20 53 68 69 66 74 3a 20 25 73 20     Tutup Shift: %s 
     619:	20 20 20 20 20 00                                        .

0000061f <__c.9409>:
     61f:	25 64 00                                            %d.

00000622 <__c.9350>:
     622:	25 73 00                                            %s.

00000625 <__c.9345>:
     625:	30 00                                               0.

00000627 <__c.9343>:
     627:	30 00                                               0.

00000629 <__c.9178>:
     629:	25 73 00                                            %s.

0000062c <__c.9176>:
     62c:	25 73 00                                            %s.

0000062f <__c.9174>:
     62f:	25 73 00                                            %s.

00000632 <__c.9172>:
     632:	25 73 00                                            %s.

00000635 <__c.9170>:
     635:	25 73 00                                            %s.

00000638 <__c.9080>:
     638:	41 2b 42 3a 25 73 00                                A+B:%s.

0000063f <__c.9078>:
     63f:	49 6e 42 3a 25 73 00                                InB:%s.

00000646 <__c.9074>:
     646:	49 6e 42 3a 5f 00                                   InB:_.

0000064c <__c.9072>:
     64c:	49 6e 41 3a 25 73 00                                InA:%s.

00000653 <__c.9067>:
     653:	49 6e 41 3a 5f 00                                   InA:_.

00000659 <__c.9065>:
     659:	4f 70 65 72 61 74 69 6f 6e 20 4d 75 6c 74 69 70     Operation Multip
     669:	6c 79 00                                            ly.

0000066c <__c.8934>:
     66c:	25 73 00                                            %s.

0000066f <__c.8846>:
     66f:	30 30 30 30 30 30 30 30 00                          00000000.

00000678 <__c.8688>:
     678:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     688:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     698:	20 20 20 00                                            .

0000069c <__c.8686>:
     69c:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     6ac:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     6bc:	20 20 20 00                                            .

000006c0 <__c.8543>:
     6c0:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     6d0:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     6e0:	2d 2d 00                                            --.

000006e3 <__c.8540>:
     6e3:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 41          Surcharge A
     6f3:	6d 74 3a 20 25 73 00                                mt: %s.

000006fa <__c.8537>:
     6fa:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 44          Surcharge D
     70a:	73 63 3a 20 25 73 00                                sc: %s.

00000711 <__c.8534>:
     711:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     721:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     731:	2d 2d 00                                            --.

00000734 <__c.8531>:
     734:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     744:	41 20 3a 20 52 70 2e 25 73 00                       A : Rp.%s.

0000074e <__c.8528>:
     74e:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     75e:	56 20 3a 20 25 73 20 4c 00                          V : %s L.

00000767 <__c.8525>:
     767:	20 20 20 20 20 54 6f 74 61 6c 20 52 65 64 65 65          Total Redee
     777:	6d 20 3a 20 25 73 00                                m : %s.

0000077e <__c.8522>:
     77e:	20 20 20 20 20 45 78 70 69 72 79 20 20 20 20 20          Expiry     
     78e:	20 20 3a 20 25 73 00                                  : %s.

00000795 <__c.8519>:
     795:	20 20 20 20 20 43 75 72 72 20 50 6f 69 6e 74 73          Curr Points
     7a5:	20 20 3a 20 25 73 00                                  : %s.

000007ac <__c.8516>:
     7ac:	20 20 20 20 20 50 72 65 76 20 50 6f 69 6e 74 73          Prev Points
     7bc:	20 20 3a 20 25 73 00                                  : %s.

000007c3 <__c.8513>:
     7c3:	20 20 20 20 20 47 61 69 6e 20 50 6f 69 6e 74 73          Gain Points
     7d3:	20 20 3a 20 25 73 00                                  : %s.

000007da <__c.8510>:
     7da:	20 20 20 20 20 43 6f 72 70 20 4e 61 6d 65 20 20          Corp Name  
     7ea:	20 20 3a 20 25 73 00                                  : %s.

000007f1 <__c.8507>:
     7f1:	20 20 20 20 20 43 6f 72 70 20 49 44 20 20 20 20          Corp ID    
     801:	20 20 3a 20 25 73 00                                  : %s.

00000808 <__c.8504>:
     808:	20 20 20 20 20 43 61 72 64 20 48 6f 6c 64 65 72          Card Holder
     818:	20 20 3a 20 25 73 20 00                               : %s .

00000820 <__c.8501>:
     820:	20 20 20 20 20 43 61 72 64 20 49 44 20 20 20 20          Card ID    
     830:	20 20 3a 20 25 73 00                                  : %s.

00000837 <__c.8498>:
     837:	20 20 20 20 20 20 20 20 20 4c 4f 59 41 4c 54 59              LOYALTY
     847:	20 49 4e 46 4f 52 4d 41 54 49 4f 4e 20 20 20 20      INFORMATION    
     857:	20 20 00                                              .

0000085a <__c.8495>:
     85a:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     86a:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     87a:	2d 2d 00                                            --.

0000087d <__c.8492>:
     87d:	20 20 20 20 2e 25 73 00                                 .%s.

00000885 <__c.8488>:
     885:	20 20 20 20 54 61 6e 64 61 20 54 61 6e 67 61 6e         Tanda Tangan
     895:	20 20 28 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f       (_____________
     8a5:	5f 29 00                                            _).

000008a8 <__c.8483>:
     8a8:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     8b8:	20 20 20 20 20 20 00                                      .

000008bf <__c.8480>:
     8bf:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     8cf:	20 20 20 20 20 20 00                                      .

000008d6 <__c.8477>:
     8d6:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     8e6:	20 00                                                .

000008e8 <__c.8475>:
     8e8:	20 20 00                                              .

000008eb <__c.8473>:
     8eb:	20 20 20 20 41 70 70 72 20 43 6f 64 65 3a 20 25         Appr Code: %
     8fb:	73 00                                               s.

000008fd <__c.8471>:
     8fd:	25 73 20 20 00                                      %s  .

00000902 <__c.8469>:
     902:	20 20 20 20 4e 61 6d 61 20 20 20 20 20 3a 20 25         Nama     : %
     912:	73 00                                               s.

00000914 <__c.8466>:
     914:	20 20 20 20 20 20 20 20 20 20 2a 2a 2a 20 50 55               *** PU
     924:	4d 50 20 54 45 53 54 20 2a 2a 2a 20 20 20 20 20     MP TEST ***     
     934:	20 20 00                                              .

00000937 <__c.8464>:
     937:	20 20 20 20 56 6f 75 63 68 65 72 20 4e 6f 3a 20         Voucher No: 
     947:	25 73 00                                            %s.

0000094a <__c.8462>:
     94a:	20 20 20 20 4b 61 72 74 75 20 49 44 20 3a 20 25         Kartu ID : %
     95a:	73 00                                               s.

0000095c <__c.8459>:
     95c:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     96c:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     97c:	2d 2d 00                                            --.

0000097f <__c.8456>:
     97f:	20 20 20 20 20 20 4f 64 6f 6d 65 74 65 72 20 20           Odometer  
     98f:	20 20 3a 20 25 73 00                                  : %s.

00000996 <__c.8453>:
     996:	20 20 20 20 20 20 4e 6f 2e 50 6f 6c 69 73 69 20           No.Polisi 
     9a6:	20 20 3a 20 25 73 00                                  : %s.

000009ad <__c.8450>:
	...

000009ae <__c.8448>:
     9ae:	20 20 20 20 20 20 4a 6d 6c 20 52 75 70 69 61 68           Jml Rupiah
     9be:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

000009c8 <__c.8445>:
     9c8:	20 20 20 20 20 20 4a 6d 6c 20 4c 69 74 65 72 20           Jml Liter 
     9d8:	20 20 3a 20 25 73 20 4c 00                            : %s L.

000009e1 <__c.8442>:
	...

000009e2 <__c.8440>:
     9e2:	20 20 20 20 20 20 48 61 72 67 61 2f 4c 20 20 20           Harga/L   
     9f2:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

000009fc <__c.8437>:
     9fc:	20 20 20 20 20 20 50 72 6f 64 75 6b 20 20 20 20           Produk    
     a0c:	20 20 3a 20 25 73 00                                  : %s.

00000a13 <__c.8434>:
     a13:	20 20 20 20 20 20 50 75 6c 61 75 2f 50 6f 6d 70           Pulau/Pomp
     a23:	61 20 3a 20 5b 25 73 5d 2d 25 73 00                 a : [%s]-%s.

00000a2f <__c.8431>:
     a2f:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     a3f:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     a4f:	2d 2d 00                                            --.

00000a52 <__c.8428>:
     a52:	20 20 20 20 20 20 57 61 6b 74 75 3a 20 25 73 20           Waktu: %s 
     a62:	25 73 20 00                                         %s .

00000a66 <__c.8424>:
     a66:	20 20 20 20 20 20 53 68 69 66 74 3a 20 25 73 20           Shift: %s 
     a76:	20 4e 6f 2e 54 72 61 6e 73 3a 20 25 73 20 00         No.Trans: %s .

00000a85 <__c.8407>:
     a85:	20 00                                                .

00000a87 <__c.8405>:
     a87:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     a97:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     aa7:	20 20 20 00                                            .

00000aab <__c.8110>:
     aab:	30 00                                               0.

00000aad <__c.8108>:
     aad:	30 30 00                                            00.

00000ab0 <__c.8106>:
     ab0:	30 30 30 30 00                                      0000.

00000ab5 <__c.8104>:
     ab5:	30 31 32 33 30 30 00                                012300.

00000abc <__c.8102>:
     abc:	30 30 2e 30 31 32 33 30 30 00                       00.012300.

00000ac6 <__c.8100>:
     ac6:	30 30 2c 30 31 32 33 30 30 00                       00,012300.

00000ad0 <__c.8098>:
     ad0:	30 30 30 31 32 33 30 30 00                          00012300.

00000ad9 <__c.8001>:
     ad9:	45 72 72 6f 72 20 4e 6f 20 43 6f 6e 6e 65 63 74     Error No Connect
     ae9:	69 6f 6e 00                                         ion.

00000aed <__c.7995>:
     aed:	50 72 6f 73 65 73 00                                Proses.

00000af4 <__c.7993>:
     af4:	53 65 6e 64 20 52 65 71 75 65 73 74 00              Send Request.

00000b01 <__c.7988>:
     b01:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     b11:	6e 74 65 72 00                                      nter.

00000b16 <__c.7986>:
     b16:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     b26:	6e 74 65 72 00                                      nter.

00000b2b <__c.7983>:
     b2b:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     b3b:	74 65 72 20 00                                      ter .

00000b40 <__c.7981>:
     b40:	4f 64 6f 6d 65 74 65 72 3a 5f 20 00                 Odometer:_ .

00000b4c <__c.7979>:
     b4c:	50 6c 61 74 20 4e 6f 3a 20 25 73 20 00              Plat No: %s .

00000b59 <__c.7976>:
     b59:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     b69:	6e 74 65 72 00                                      nter.

00000b6e <__c.7974>:
     b6e:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     b7e:	6e 74 65 72 00                                      nter.

00000b83 <__c.7971>:
     b83:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     b93:	74 65 72 20 00                                      ter .

00000b98 <__c.7969>:
     b98:	5f 00                                               _.

00000b9a <__c.7967>:
     b9a:	49 6e 70 75 74 20 50 6c 61 74 20 4e 6f 3a 20 00     Input Plat No: .

00000baa <__c.7921>:
     baa:	2a 29 43 61 6e 63 65 6c 20 20 20 20 20 20 23 29     *)Cancel      #)
     bba:	53 61 76 65 00                                      Save.

00000bbf <__c.7919>:
     bbf:	4f 50 45 52 41 54 4f 52 20 3a 00                    OPERATOR :.

00000bca <__c.7913>:
     bca:	2a 29 45 78 69 74 00                                *)Exit.

00000bd1 <__c.7911>:
     bd1:	33 29 55 73 65 72 28 00                             3)User(.

00000bd9 <__c.7909>:
     bd9:	32 29 52 65 2d 50 72 69 6e 74 00                    2)Re-Print.

00000be4 <__c.7907>:
     be4:	31 29 43 6c 6f 73 65 20 53 68 69 66 74 00           1)Close Shift.

00000bf2 <__c.7896>:
     bf2:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 23 29     *)Exit        #)
     c02:	53 61 76 65 00                                      Save.

00000c07 <__c.7894>:
     c07:	50 41 53 53 57 4f 52 44 20 28 4d 41 58 20 20 20     PASSWORD (MAX   
     c17:	29 3a 00                                            ):.

00000c1a <__c.7883>:
     c1a:	2a 29 45 78 69 74 00                                *)Exit.

00000c21 <__c.7881>:
     c21:	32 29 4c 32 3a 00                                   2)L2:.

00000c27 <__c.7879>:
     c27:	31 29 4c 31 3a 00                                   1)L1:.

00000c2d <__c.7837>:
     c2d:	23 29 53 61 76 65 00                                #)Save.

00000c34 <__c.7835>:
     c34:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000c41 <__c.7817>:
     c41:	23 29 53 61 76 65 00                                #)Save.

00000c48 <__c.7815>:
     c48:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000c55 <__c.7813>:
     c55:	33 29 4e 6f 74 69 66 20 3a 20 20 20 20 20 2a 29     3)Notif :     *)
     c65:	45 78 69 74 00                                      Exit.

00000c6a <__c.7811>:
     c6a:	32 29 44 2f 54 20 20 20 3a 00                       2)D/T   :.

00000c74 <__c.7809>:
     c74:	31 29 4d 6f 6e 65 79 20 3a 00                       1)Money :.

00000c7e <__c.7735>:
     c7e:	34 29 43 75 74 20 3a 20 20 2a 29 45 78 69 74 00     4)Cut :  *)Exit.

00000c8e <__c.7733>:
     c8e:	33 29 4c 6f 67 6f 3a 20 20 23 29 53 61 76 65 00     3)Logo:  #)Save.

00000c9e <__c.7731>:
     c9e:	32 29 53 69 7a 65 3a 20 20 36 29 53 70 61 63 65     2)Size:  6)Space
     cae:	20 3a 00                                             :.

00000cb1 <__c.7729>:
     cb1:	31 29 54 79 70 65 3a 20 20 35 29 53 63 72 6f 6c     1)Type:  5)Scrol
     cc1:	6c 3a 00                                            l:.

00000cc4 <__c.7665>:
     cc4:	2a 29 43 61 6e 63 65 6c 20 20 20 20 20 20 23 29     *)Cancel      #)
     cd4:	53 61 76 65 00                                      Save.

00000cd9 <__c.7663>:
     cd9:	54 49 4d 45 20 3a 20 00                             TIME : .

00000ce1 <__c.7661>:
     ce1:	44 41 54 45 20 3a 20 00                             DATE : .

00000ce9 <__c.7596>:
     ce9:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 23 29     *)Exit        #)
     cf9:	53 61 76 65 00                                      Save.

00000cfe <__c.7594>:
     cfe:	32 29 4e 32 3a 20 20 34 29 4e 34 3a 20 20 36 29     2)N2:  4)N4:  6)
     d0e:	4e 36 3a 00                                         N6:.

00000d12 <__c.7592>:
     d12:	31 29 4e 31 3a 20 20 33 29 4e 33 3a 20 20 35 29     1)N1:  3)N3:  5)
     d22:	4e 35 3a 00                                         N5:.

00000d26 <__c.7590>:
     d26:	50 72 6f 64 75 63 74 20 46 49 50 25 2e 32 64 00     Product FIP%.2d.

00000d36 <__c.7505>:
     d36:	43 6f 6d 70 6c 65 74 65 64 00                       Completed.

00000d40 <__c.7503>:
     d40:	43 61 6e 63 65 6c 20 20 20 20 20 00                 Cancel     .

00000d4c <__c.7500>:
     d4c:	49 64 5b 25 64 5d 3d 25 2e 32 64 20 20 00           Id[%d]=%.2d  .

00000d5a <__c.7497>:
     d5a:	53 61 76 69 6e 67 2e 2e 00                          Saving...

00000d63 <__c.7495>:
     d63:	2d 50 75 6d 70 49 44 2d 00                          -PumpID-.

00000d6c <__c.7491>:
     d6c:	20 20 20 20 4e 6f 74 20 41 6c 6c 6f 77 65 64 20         Not Allowed 
     d7c:	20 20 20 20 00                                          .

00000d81 <__c.7489>:
     d81:	20 20 44 75 70 6c 69 63 61 74 65 20 50 75 6d 70       Duplicate Pump
     d91:	49 44 20 20 00                                      ID  .

00000d96 <__c.7487>:
     d96:	20 20 20 20 20 20 57 61 72 6e 69 6e 67 21 20 20           Warning!  
     da6:	20 20 20 20 00                                          .

00000dab <__c.7475>:
     dab:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     dbb:	2e 32 64 00                                         .2d.

00000dbf <__c.7469>:
     dbf:	23 29 53 61 76 65 00                                #)Save.

00000dc6 <__c.7467>:
     dc6:	2a 29 42 61 63 6b 00                                *)Back.

00000dcd <__c.7462>:
     dcd:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     ddd:	2e 32 64 00                                         .2d.

00000de1 <__c.7413>:
     de1:	25 2e 32 64 00                                      %.2d.

00000de6 <__c.7407>:
     de6:	25 2e 32 64 00                                      %.2d.

00000deb <__c.7405>:
     deb:	34 29 34 3a 20 20 20 38 29 38 3a 20 20 20 2a 29     4)4:   8)8:   *)
     dfb:	45 78 69 74 00                                      Exit.

00000e00 <__c.7403>:
     e00:	33 29 33 3a 20 20 20 37 29 37 3a 20 20 20 23 29     3)3:   7)7:   #)
     e10:	53 61 76 65 00                                      Save.

00000e15 <__c.7401>:
     e15:	32 29 32 3a 20 20 20 36 29 36 3a 00                 2)2:   6)6:.

00000e21 <__c.7399>:
     e21:	31 29 31 3a 20 20 20 35 29 35 3a 00                 1)1:   5)5:.

00000e2d <__c.7365>:
     e2d:	5b 2a 5d 45 78 69 74 20 20 5b 23 5d 43 68 61 6e     [*]Exit  [#]Chan
     e3d:	67 65 20 00                                         ge .

00000e41 <__c.7363>:
     e41:	25 64 2e 25 73 00                                   %d.%s.

00000e47 <__c.7358>:
     e47:	2d 44 69 73 70 65 6e 73 65 72 20 42 72 61 6e 64     -Dispenser Brand
     e57:	2d 00                                               -.

00000e59 <__c.7342>:
     e59:	2a 29 45 78 69 74 00                                *)Exit.

00000e60 <__c.7340>:
     e60:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

00000e6a <__c.7338>:
     e6a:	31 29 49 44 00                                      1)ID.

00000e6f <__c.7329>:
     e6f:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     e7f:	20 20 20 20 00                                          .

00000e84 <__c.7327>:
     e84:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 20 5b 23 5d     [*]Cancel    [#]
     e94:	53 61 76 65 00                                      Save.

00000e99 <__c.7312>:
     e99:	2a 29 45 78 69 74 00                                *)Exit.

00000ea0 <__c.7307>:
     ea0:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     eb0:	2e 32 64 20 00                                      .2d .

00000eb5 <__c.7296>:
     eb5:	25 2e 32 64 00                                      %.2d.

00000eba <__c.7095>:
     eba:	5b 2a 5d 45 78 69 74 00                             [*]Exit.

00000ec2 <__c.7093>:
     ec2:	36 2e 41 63 74 3a 25 64 00                          6.Act:%d.

00000ecb <__c.7091>:
     ecb:	35 2e 44 6c 79 3a 25 64 00                          5.Dly:%d.

00000ed4 <__c.7089>:
     ed4:	34 2e 54 69 6d 50 6f 6f 6c 3a 25 64 00              4.TimPool:%d.

00000ee1 <__c.7087>:
     ee1:	33 2e 54 72 79 53 65 6e 64 3a 25 64 00              3.TrySend:%d.

00000eee <__c.7085>:
     eee:	32 2e 6e 4e 6f 50 75 6d 70 3a 25 64 00              2.nNoPump:%d.

00000efb <__c.7083>:
     efb:	31 2e 4d 61 78 50 75 6d 70 3a 25 64 00              1.MaxPump:%d.

00000f08 <__c.7027>:
     f08:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00000f15 <__c.7022>:
     f15:	43 4f 4d 25 64 3a 25 64 00                          COM%d:%d.

00000f1e <__c.7020>:
     f1e:	20 20 20 20 20 2d 42 61 75 64 72 61 74 65 2d 20          -Baudrate- 
     f2e:	20 20 20 20 00                                          .

00000f33 <__c.7015>:
     f33:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 00           [*]Back      .

00000f41 <__c.7013>:
     f41:	32 2e 42 61 75 64 72 61 74 65 00                    2.Baudrate.

00000f4c <__c.7011>:
     f4c:	31 2e 4d 6f 64 65 3a 53 74 61 6e 64 61 6c 6f 6e     1.Mode:Standalon
     f5c:	65 00                                               e.

00000f5e <__c.7009>:
     f5e:	31 2e 4d 6f 64 65 3a 53 6c 61 76 65 00              1.Mode:Slave.

00000f6b <__c.7007>:
     f6b:	31 2e 4d 6f 64 65 3a 4e 6f 6e 65 00                 1.Mode:None.

00000f77 <__c.6921>:
     f77:	2a 29 42 61 63 6b 00                                *)Back.

00000f7e <__c.6919>:
     f7e:	34 2e 53 70 61 72 61 74 6f 72 3a 25 63 20 00        4.Sparator:%c .

00000f8d <__c.6917>:
     f8d:	33 2e 44 65 63 69 6d 61 6c 20 3a 25 63 20 00        3.Decimal :%c .

00000f9c <__c.6915>:
     f9c:	32 2e 54 2e 4d 6f 6e 65 79 20 3a 25 64 20 00        2.T.Money :%d .

00000fab <__c.6913>:
     fab:	31 2e 54 2e 56 6f 6c 75 6d 65 3a 25 64 20 20 35     1.T.Volume:%d  5
     fbb:	2e 54 65 73 74 00                                   .Test.

00000fc1 <__c.6908>:
     fc1:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4e 65 78 74     [*]Back  [#]Next
	...

00000fd2 <__c.6906>:
     fd2:	33 2e 4d 6f 6e 65 79 20 3a 25 64 00                 3.Money :%d.

00000fde <__c.6904>:
     fde:	32 2e 56 6f 6c 75 6d 65 3a 25 64 00                 2.Volume:%d.

00000fea <__c.6902>:
     fea:	31 2e 50 72 69 63 65 20 3a 25 64 00                 1.Price :%d.

00000ff6 <__c.6885>:
     ff6:	34 29 42 72 61 6e 64 20 20 2a 29 45 78 69 74 00     4)Brand  *)Exit.

00001006 <__c.6883>:
    1006:	33 29 4c 61 62 65 6c 20 20 00                       3)Label  .

00001010 <__c.6881>:
    1010:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

0000101a <__c.6879>:
    101a:	31 29 49 44 20 20 20 20 20 00                       1)ID     .

00001024 <__c.6838>:
    1024:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    1034:	20 20 20 20 00                                          .

00001039 <__c.6836>:
    1039:	4e 65 77 3a 5f 00                                   New:_.

0000103f <__c.6834>:
    103f:	4f 6c 64 3a 25 73 00                                Old:%s.

00001046 <__c.6832>:
    1046:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    1056:	20 20 20 20 00                                          .

0000105b <__c.6830>:
    105b:	4e 65 77 3a 5f 00                                   New:_.

00001061 <__c.6828>:
    1061:	45 64 69 74 20 50 72 6f 64 75 63 74 20 4e 61 6d     Edit Product Nam
    1071:	65 20 20 20 00                                      e   .

00001076 <__c.6826>:
    1076:	4f 6c 64 3a 25 73 00                                Old:%s.

0000107d <__c.6823>:
    107d:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 00           *)Back       .

0000108b <__c.6821>:
    108b:	32 29 25 73 00                                      2)%s.

00001090 <__c.6819>:
    1090:	31 29 25 73 00                                      1)%s.

00001095 <__c.6814>:
    1095:	2a 29 42 61 63 6b 00                                *)Back.

0000109c <__c.6809>:
    109c:	25 64 29 25 73 00                                   %d)%s.

000010a2 <__c.6733>:
    10a2:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 20 20 20     *)Back          
    10b2:	20 20 20 20 00                                          .

000010b7 <__c.6731>:
    10b7:	33 29 50 75 6d 70 50 6f 6f 6c 69 6e 67 20 20 20     3)PumpPooling   
    10c7:	20 20 20 20 00                                          .

000010cc <__c.6729>:
    10cc:	32 29 53 79 73 74 65 6d 20 20 20 20 20 20 20 20     2)System        
    10dc:	20 20 20 20 00                                          .

000010e1 <__c.6727>:
    10e1:	31 29 4f 70 65 72 61 74 6f 72 20 20 20 20 20 20     1)Operator      
    10f1:	20 20 20 20 00                                          .

000010f6 <__c.6724>:
    10f6:	34 29 44 61 74 65 74 69 6d 65 20 2a 29 45 78 69     4)Datetime *)Exi
    1106:	74 20 20 20 00                                      t   .

0000110b <__c.6722>:
    110b:	33 29 44 65 63 69 6d 61 6c 20 20 37 29 4e 65 78     3)Decimal  7)Nex
    111b:	74 20 20 20 00                                      t   .

00001120 <__c.6720>:
    1120:	32 29 50 75 6d 70 20 20 20 20 20 36 29 48 6f 73     2)Pump     6)Hos
    1130:	74 20 20 20 00                                      t   .

00001135 <__c.6718>:
    1135:	31 29 50 72 6f 64 75 63 74 20 20 35 29 50 72 69     1)Product  5)Pri
    1145:	6e 74 65 72 00                                      nter.

0000114a <__c.6631>:
    114a:	2e 00                                               ..

0000114c <__c.6629>:
    114c:	25 64 00                                            %d.

0000114f <__c.6627>:
    114f:	20 20 20 00                                            .

00001153 <__c.6625>:
    1153:	2e 00                                               ..

00001155 <__c.6623>:
    1155:	25 64 00                                            %d.

00001158 <__c.6621>:
    1158:	20 20 20 00                                            .

0000115c <__c.6614>:
    115c:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    116c:	78 74 20 20 00                                      xt  .

00001171 <__c.6612>:
    1171:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    1181:	2e 20 20 20 00                                      .   .

00001186 <__c.6610>:
    1186:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

00001197 <__c.6608>:
    1197:	53 65 72 76 65 72 20 49 50 00                       Server IP.

000011a1 <__c.6517>:
    11a1:	2e 00                                               ..

000011a3 <__c.6515>:
    11a3:	25 64 00                                            %d.

000011a6 <__c.6513>:
    11a6:	20 20 20 00                                            .

000011aa <__c.6511>:
    11aa:	2e 00                                               ..

000011ac <__c.6509>:
    11ac:	25 64 00                                            %d.

000011af <__c.6507>:
    11af:	20 20 20 00                                            .

000011b3 <__c.6500>:
    11b3:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    11c3:	78 74 20 20 00                                      xt  .

000011c8 <__c.6498>:
    11c8:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    11d8:	2e 20 20 20 00                                      .   .

000011dd <__c.6496>:
    11dd:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

000011ee <__c.6494>:
    11ee:	43 6c 69 65 6e 74 20 49 50 00                       Client IP.

000011f8 <__c.6466>:
    11f8:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 23 29     *)Exit        #)
    1208:	53 61 76 65 00                                      Save.

0000120d <__c.6448>:
    120d:	2a 29 45 78 69 74 00                                *)Exit.

00001214 <__c.6446>:
    1214:	32 29 46 6f 6f 74 65 72 32 20 20 34 29 46 6f 6f     2)Footer2  4)Foo
    1224:	74 65 72 34 00                                      ter4.

00001229 <__c.6444>:
    1229:	31 29 46 6f 6f 74 65 72 31 20 20 33 29 46 6f 6f     1)Footer1  3)Foo
    1239:	74 65 72 33 00                                      ter3.

0000123e <__c.6434>:
    123e:	2a 29 45 78 69 74 00                                *)Exit.

00001245 <__c.6432>:
    1245:	32 29 48 65 61 64 65 72 32 20 20 34 29 48 65 61     2)Header2  4)Hea
    1255:	64 65 72 34 00                                      der4.

0000125a <__c.6430>:
    125a:	31 29 48 65 61 64 65 72 31 20 20 33 29 48 65 61     1)Header1  3)Hea
    126a:	64 65 72 33 00                                      der3.

0000126f <__c.6400>:
    126f:	25 73 25 73 00                                      %s%s.

00001274 <__c.6396>:
    1274:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

00001283 <__c.6394>:
    1283:	45 64 69 74 20 46 6f 6f 74 65 72 25 64 20 4c 69     Edit Footer%d Li
    1293:	6e 65 31 00                                         ne1.

00001297 <__c.6392>:
    1297:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

000012a4 <__c.6390>:
    12a4:	53 61 76 65 20 46 6f 6f 74 65 72 25 64 20 3f 00     Save Footer%d ?.

000012b4 <__c.6387>:
    12b4:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

000012c3 <__c.6385>:
    12c3:	45 64 69 74 20 46 6f 6f 74 65 72 25 64 20 4c 69     Edit Footer%d Li
    12d3:	6e 65 32 00                                         ne2.

000012d7 <__c.6382>:
    12d7:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

000012e6 <__c.6380>:
    12e6:	45 64 69 74 20 46 6f 6f 74 65 72 25 64 20 4c 69     Edit Footer%d Li
    12f6:	6e 65 31 00                                         ne1.

000012fa <__c.6376>:
    12fa:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    130a:	20 20 20 20 00                                          .

0000130f <__c.6374>:
    130f:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    131f:	20 20 20 20 00                                          .

00001324 <__c.6372>:
    1324:	32 29 46 6f 6f 74 65 72 32 20 20 34 29 46 6f 6f     2)Footer2  4)Foo
    1334:	74 65 72 34 00                                      ter4.

00001339 <__c.6370>:
    1339:	31 29 46 6f 6f 74 65 72 31 20 20 33 29 46 6f 6f     1)Footer1  3)Foo
    1349:	74 65 72 33 00                                      ter3.

0000134e <__c.6339>:
    134e:	25 73 25 73 00                                      %s%s.

00001353 <__c.6335>:
    1353:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

00001362 <__c.6333>:
    1362:	45 64 69 74 20 48 65 61 64 65 72 25 64 20 4c 69     Edit Header%d Li
    1372:	6e 65 31 00                                         ne1.

00001376 <__c.6331>:
    1376:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

00001383 <__c.6329>:
    1383:	53 61 76 65 20 48 65 61 64 65 72 25 64 20 3f 00     Save Header%d ?.

00001393 <__c.6326>:
    1393:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

000013a2 <__c.6324>:
    13a2:	45 64 69 74 20 48 65 61 64 65 72 25 64 20 4c 69     Edit Header%d Li
    13b2:	6e 65 32 00                                         ne2.

000013b6 <__c.6321>:
    13b6:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

000013c5 <__c.6319>:
    13c5:	45 64 69 74 20 48 65 61 64 65 72 25 64 20 4c 69     Edit Header%d Li
    13d5:	6e 65 31 00                                         ne1.

000013d9 <__c.6315>:
    13d9:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    13e9:	20 20 20 20 00                                          .

000013ee <__c.6313>:
    13ee:	33 29 48 65 61 64 65 72 33 20 20 36 29 48 65 61     3)Header3  6)Hea
    13fe:	64 65 72 36 00                                      der6.

00001403 <__c.6311>:
    1403:	32 29 48 65 61 64 65 72 32 20 20 35 29 48 65 61     2)Header2  5)Hea
    1413:	64 65 72 35 00                                      der5.

00001418 <__c.6309>:
    1418:	31 29 48 65 61 64 65 72 31 20 20 34 29 48 65 61     1)Header1  4)Hea
    1428:	64 65 72 34 00                                      der4.

0000142d <__c.6266>:
    142d:	2a 29 45 78 69 74 00                                *)Exit.

00001434 <__c.6264>:
    1434:	33 29 50 61 73 73 77 6f 72 64 20 20 20 20 20 20     3)Password      
    1444:	20 20 20 20 00                                          .

00001449 <__c.6262>:
    1449:	32 29 46 6f 6f 74 65 72 20 20 20 20 20 20 20 20     2)Footer        
    1459:	20 20 20 20 00                                          .

0000145e <__c.6260>:
    145e:	31 29 48 65 61 64 65 72 20 20 20 20 20 20 20 20     1)Header        
    146e:	20 20 20 20 00                                          .

00001473 <__c.6258>:
    1473:	32 29 46 6f 6f 74 65 72 20 20 20 20 35 29 53 65     2)Footer    5)Se
    1483:	72 76 65 72 00                                      rver.

00001488 <__c.6256>:
    1488:	31 29 48 65 61 64 65 72 20 20 20 20 34 29 43 6c     1)Header    4)Cl
    1498:	69 65 6e 74 00                                      ient.

0000149d <__c.6202>:
    149d:	53 61 76 69 6e 67 20 53 68 69 66 74 44 61 74 61     Saving ShiftData
    14ad:	2e 2e 20 00                                         .. .

000014b1 <__c.6197>:
    14b1:	25 73 20 25 73 00                                   %s %s.

000014b7 <__c.6195>:
    14b7:	50 72 69 6e 74 69 6e 67 20 54 6f 74 61 6c 69 7a     Printing Totaliz
    14c7:	65 72 00                                            er.

000014ca <__c.6191>:
    14ca:	43 61 6e 63 65 6c 00                                Cancel.

000014d1 <__c.6186>:
    14d1:	45 72 72 6f 72 20 2d 20 4e 6f 20 50 75 6d 70 3a     Error - No Pump:
    14e1:	25 64 20 00                                         %d .

000014e5 <__c.6181>:
    14e5:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

000014f3 <__c.6177>:
    14f3:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

00001501 <__c.6175>:
    1501:	54 6f 74 61 6c 69 7a 65 72 2e 2e 00                 Totalizer...

0000150d <__c.6103>:
    150d:	2a 29 45 78 69 74 00                                *)Exit.

00001514 <__c.6101>:
    1514:	33 2e 4c 6f 63 6b 20 50 75 6d 70 20 20 00           3.Lock Pump  .

00001522 <__c.6099>:
    1522:	32 2e 43 6c 6f 73 65 20 44 61 79 20 20 00           2.Close Day  .

00001530 <__c.6097>:
    1530:	31 2e 43 6c 6f 73 65 20 53 68 69 66 74 00           1.Close Shift.

0000153e <__c.6055>:
    153e:	34 29 53 65 74 74 69 6e 67 73 20 20 20 2a 29 45     4)Settings   *)E
    154e:	78 69 74 20 00                                      xit .

00001553 <__c.6053>:
    1553:	33 29 43 6c 6f 73 65 44 61 79 20 20 20 20 20 20     3)CloseDay      
    1563:	20 20 20 20 00                                          .

00001568 <__c.6051>:
    1568:	32 29 43 6c 6f 73 65 53 68 69 66 74 20 20 20 20     2)CloseShift    
    1578:	20 20 20 20 00                                          .

0000157d <__c.6049>:
    157d:	31 29 52 65 50 72 69 6e 74 20 20 20 20 20 20 20     1)RePrint       
    158d:	20 20 20 20 00                                          .

00001592 <__c.6019>:
    1592:	50 61 73 73 77 6f 72 64 20 52 65 73 74 6f 72 65     Password Restore
    15a2:	64 00                                               d.

000015a4 <__c.6015>:
    15a4:	49 6e 76 61 6c 69 64 20 52 65 73 74 6f 72 65 20     Invalid Restore 
    15b4:	20 00                                                .

000015b6 <__c.6012>:
    15b6:	30 30 30 30 30 00                                   00000.

000015bc <__c.6010>:
    15bc:	31 31 31 31 31 00                                   11111.

000015c2 <__c.6006>:
    15c2:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    15d2:	6e 74 65 72 00                                      nter.

000015d7 <__c.6003>:
    15d7:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    15e7:	6e 74 65 72 00                                      nter.

000015ec <__c.5996>:
    15ec:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    15fc:	6e 74 65 72 00                                      nter.

00001601 <__c.5994>:
    1601:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    1611:	20 20 20 20 00                                          .

00001616 <__c.5992>:
    1616:	45 6e 74 65 72 20 52 65 73 74 6f 72 65 20 43 6f     Enter Restore Co
    1626:	64 65 20 20 00                                      de  .

0000162b <__c.5990>:
    162b:	4b 65 79 20 53 74 61 6d 70 3a 25 73 20 00           Key Stamp:%s .

00001639 <__c.5986>:
    1639:	49 6e 76 61 6c 69 64 20 43 6f 64 65 20 20 20 20     Invalid Code    
    1649:	20 20 20 20 00                                          .

0000164e <__c.5983>:
	...

0000164f <__c.5981>:
    164f:	25 73 00                                            %s.

00001652 <__c.5979>:
    1652:	25 73 00                                            %s.

00001655 <__c.5976>:
    1655:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1665:	6e 74 65 72 00                                      nter.

0000166a <__c.5973>:
    166a:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    167a:	6e 74 65 72 00                                      nter.

0000167f <__c.5966>:
	...

00001680 <__c.5964>:
    1680:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1690:	6e 74 65 72 00                                      nter.

00001695 <__c.5962>:
    1695:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    16a5:	20 20 20 20 00                                          .

000016aa <__c.5960>:
    16aa:	45 6e 74 65 72 20 47 65 4e 69 55 73 20 43 6f 64     Enter GeNiUs Cod
    16ba:	65 20 20 20 00                                      e   .

000016bf <__c.5950>:
    16bf:	5b 2a 5d 45 78 69 74 20 20 20 20 20 20 20 20 20     [*]Exit         
    16cf:	20 20 20 20 00                                          .

000016d4 <__c.5948>:
    16d4:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    16e4:	64 20 20 20 00                                      d   .

000016e9 <__c.5946>:
    16e9:	31 2e 52 65 73 74 6f 72 65 20 50 61 73 73 77 6f     1.Restore Passwo
    16f9:	72 64 20 20 00                                      rd  .

000016fe <__c.5944>:
    16fe:	2d 53 79 73 74 65 6d 20 41 64 6d 69 6e 20 4c 65     -System Admin Le
    170e:	76 65 6c 2d 00                                      vel-.

00001713 <__c.5885>:
    1713:	25 73 25 73 00                                      %s%s.

00001718 <__c.5857>:
    1718:	25 73 00                                            %s.

0000171b <__c.5824>:
    171b:	25 63 00                                            %c.

0000171e <__c.5822>:
    171e:	32 30 25 73 00                                      20%s.

00001723 <__c.5800>:
    1723:	25 73 00                                            %s.

00001726 <__c.5751>:
    1726:	34 32 36 34 36 33 36 00                             4264636.

0000172e <__c.5748>:
    172e:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    173e:	6e 74 65 72 00                                      nter.

00001743 <__c.5746>:
    1743:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1753:	6e 74 65 72 00                                      nter.

00001758 <__c.5742>:
    1758:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1768:	6e 74 65 72 00                                      nter.

0000176d <__c.5740>:
    176d:	5f 00                                               _.

0000176f <__c.5738>:
    176f:	50 41 53 53 57 4f 52 44 3a 00                       PASSWORD:.

00001779 <__c.5710>:
    1779:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001787 <__c.5682>:
    1787:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1797:	6e 74 65 72 00                                      nter.

0000179c <__c.5680>:
    179c:	50 41 53 53 57 4f 52 44 3a 00                       PASSWORD:.

000017a6 <__c.5616>:
    17a6:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

000017b3 <__c.5614>:
    17b3:	4e 6f 20 52 65 70 6c 79 20 20 20 20 00              No Reply    .

000017c0 <__c.5610>:
    17c0:	20 20 20 20 20 20 20 00                                    .

000017c8 <__c.5607>:
    17c8:	50 6c 65 61 73 65 20 57 61 69 74 00                 Please Wait.

000017d4 <__c.5604>:
    17d4:	25 73 00                                            %s.

000017d7 <__c.5602>:
    17d7:	50 55 4d 50 20 54 45 53 54 00                       PUMP TEST.

000017e1 <__c.5599>:
    17e1:	25 73 00                                            %s.

000017e4 <__c.5596>:
    17e4:	25 73 00                                            %s.

000017e7 <__c.5594>:
    17e7:	25 73 00                                            %s.

000017ea <__c.5592>:
    17ea:	25 73 00                                            %s.

000017ed <__c.5588>:
    17ed:	25 73 00                                            %s.

000017f0 <__c.5584>:
    17f0:	50 72 6f 73 65 73 00                                Proses.

000017f7 <__c.5582>:
    17f7:	2d 4d 4f 50 20 56 6f 75 63 68 65 72 2d 00           -MOP Voucher-.

00001805 <__c.5579>:
    1805:	50 72 6f 73 65 73 00                                Proses.

0000180c <__c.5577>:
    180c:	49 44 3a 25 73 00                                   ID:%s.

00001812 <__c.5573>:
    1812:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1822:	69 74 00                                            it.

00001825 <__c.5571>:
    1825:	46 49 50 25 73 00                                   FIP%s.

0000182b <__c.5569>:
    182b:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

0000183a <__c.5560>:
    183a:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    184a:	6e 74 65 72 00                                      nter.

0000184f <__c.5558>:
    184f:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    185f:	6e 74 65 72 00                                      nter.

00001864 <__c.5555>:
    1864:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1874:	6e 74 65 72 00                                      nter.

00001879 <__c.5553>:
    1879:	53 75 72 63 68 61 72 67 65 3a 20 20 20 5f 25 00     Surcharge:   _%.

00001889 <__c.5551>:
    1889:	25 73 00                                            %s.

0000188c <__c.5547>:
    188c:	5b 2a 5d 42 61 63 6b 00                             [*]Back.

00001894 <__c.5542>:
    1894:	25 64 2e 25 73 00                                   %d.%s.

0000189a <__c.5540>:
    189a:	53 65 6c 65 63 74 20 42 61 6e 6b 00                 Select Bank.

000018a6 <__c.5535>:
    18a6:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18b6:	6e 74 65 72 00                                      nter.

000018bb <__c.5533>:
    18bb:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    18cb:	6e 74 65 72 00                                      nter.

000018d0 <__c.5530>:
    18d0:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18e0:	6e 74 65 72 00                                      nter.

000018e5 <__c.5528>:
    18e5:	5f 00                                               _.

000018e7 <__c.5526>:
    18e7:	4b 6f 64 65 20 56 6f 75 63 68 65 72 00              Kode Voucher.

000018f4 <__c.5517>:
    18f4:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1904:	20 20 20 20 00                                          .

00001909 <__c.5515>:
    1909:	32 2e 42 61 6e 6b 20 20 20 20 34 2e 50 75 6d 70     2.Bank    4.Pump
    1919:	54 65 73 74 00                                      Test.

0000191e <__c.5513>:
    191e:	31 2e 41 63 63 6f 75 6e 74 20 33 2e 56 6f 75 63     1.Account 3.Vouc
    192e:	68 65 72 20 00                                      her .

00001933 <__c.5511>:
    1933:	20 20 20 53 65 6c 65 63 74 20 50 61 79 6d 65 6e        Select Paymen
    1943:	74 20 20 20 00                                      t   .

00001948 <__c.5452>:
    1948:	43 52 45 44 49 54 43 41 52 44 00                    CREDITCARD.

00001953 <__c.5446>:
    1953:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1963:	20 20 20 20 00                                          .

00001968 <__c.5444>:
    1968:	32 2e 43 72 65 64 69 74 20 43 61 72 64 20 20 20     2.Credit Card   
    1978:	20 20 20 20 00                                          .

0000197d <__c.5442>:
    197d:	31 2e 44 65 62 69 74 2f 46 6c 61 73 68 20 43 61     1.Debit/Flash Ca
    198d:	72 64 20 20 00                                      rd  .

00001992 <__c.5440>:
    1992:	53 65 6c 65 63 74 20 43 61 72 64 20 54 79 70 65     Select Card Type
	...

000019a3 <__c.5408>:
    19a3:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

000019b1 <__c.5406>:
    19b1:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

000019bf <__c.5403>:
    19bf:	43 6d 20 56 6f 6c 3a 25 73 00                       Cm Vol:%s.

000019c9 <__c.5401>:
    19c9:	43 4d 20 41 6d 74 3a 25 73 00                       CM Amt:%s.

000019d3 <__c.5399>:
    19d3:	50 6f 69 6e 74 73 3a 25 73 00                       Points:%s.

000019dd <__c.5397>:
    19dd:	25 73 3a 25 73 00                                   %s:%s.

000019e3 <__c.5390>:
    19e3:	50 72 6f 73 65 73 00                                Proses.

000019ea <__c.5388>:
    19ea:	49 44 3a 25 73 00                                   ID:%s.

000019f0 <__c.5384>:
    19f0:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1a00:	69 74 00                                            it.

00001a03 <__c.5382>:
    1a03:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001a12 <__c.5379>:
    1a12:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1a22:	69 74 00                                            it.

00001a25 <__c.5377>:
    1a25:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001a34 <__c.5375>:
    1a34:	46 49 50 3a 25 73 00                                FIP:%s.

00001a3b <__c.5369>:
    1a3b:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1a4b:	20 00                                                .

00001a4d <__c.5367>:
    1a4d:	32 2e 4c 6f 79 61 6c 74 79 20 55 70 64 61 74 65     2.Loyalty Update
    1a5d:	20 00                                                .

00001a5f <__c.5365>:
    1a5f:	31 2e 45 6e 71 75 69 72 79 20 20 20 20 20 20 20     1.Enquiry       
    1a6f:	20 00                                                .

00001a71 <__c.5363>:
    1a71:	20 20 4d 65 6e 75 20 4c 6f 79 61 6c 74 79 20 20       Menu Loyalty  
    1a81:	20 00                                                .

00001a83 <__c.5329>:
    1a83:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001a91 <__c.5327>:
    1a91:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001a9f <__c.5321>:
    1a9f:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1aaf:	69 74 00                                            it.

00001ab2 <__c.5319>:
    1ab2:	54 61 70 20 53 75 70 65 72 76 69 73 6f 72 20 43     Tap Supervisor C
    1ac2:	61 72 64 00                                         ard.

00001ac6 <__c.5317>:
    1ac6:	52 65 50 72 69 6e 74 20 46 49 50 3a 25 73 20 00     RePrint FIP:%s .

00001ad6 <__c.5313>:
    1ad6:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    1ae6:	6b 73 69 20 00                                      ksi .

00001aeb <__c.5307>:
    1aeb:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001af9 <__c.5257>:
    1af9:	2a 29 45 78 69 74 00                                *)Exit.

00001b00 <__c.5255>:
    1b00:	23 29 4f 4b 20 00                                   #)OK .

00001b06 <__c.5253>:
    1b06:	20 20 20 20 20 00                                        .

00001b0c <__c.5251>:
    1b0c:	46 49 50 3a 5f 00                                   FIP:_.

00001b12 <__c.5246>:
    1b12:	25 64 2e 50 25 73 20 7c 20 25 64 2e 50 25 73 00     %d.P%s | %d.P%s.

00001b22 <__c.5197>:
    1b22:	30 32 25 73 25 73 25 73 25 73 25 73 25 73 25 73     02%s%s%s%s%s%s%s
	...

00001b33 <__c.5070>:
    1b33:	30 00                                               0.

00001b35 <__c.4998>:
    1b35:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1b45:	20 20 20 20 00                                          .

00001b4a <__c.4993>:
    1b4a:	23 25 73 00                                         #%s.

00001b4e <__c.4991>:
    1b4e:	25 2e 32 64 00                                      %.2d.

00001b53 <__c.4989>:
    1b53:	40 46 49 50 3a 00                                   @FIP:.

00001b59 <__c.4987>:
    1b59:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1b69:	20 20 20 20 00                                          .

00001b6e <__c.4983>:
    1b6e:	50 72 69 6e 74 69 6e 67 20 46 49 50 25 73 20 00     Printing FIP%s .

00001b7e <__c.4957>:
    1b7e:	44 3a 25 64 20 43 3a 25 63 20 20 00                 D:%d C:%c  .

00001b8a <__c.4917>:
    1b8a:	25 73 20 25 73 00                                   %s %s.

00001b90 <__c.4873>:
    1b90:	4e 6f 20 50 75 6d 70 20 46 6f 75 6e 64 00           No Pump Found.

00001b9e <__c.4871>:
    1b9e:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

00001bab <__c.4869>:
    1bab:	50 75 6d 70 46 6f 75 6e 64 00                       PumpFound.

00001bb5 <__c.4867>:
    1bb5:	43 6f 6e 6e 65 63 74 65 64 00                       Connected.

00001bbf <__c.4862>:
    1bbf:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1bcf:	20 20 20 00                                            .

00001bd3 <__c.4860>:
    1bd3:	25 73 00                                            %s.

00001bd6 <__c.4855>:
    1bd6:	53 63 61 6e 20 50 75 6d 70 00                       Scan Pump.

00001be0 <__c.4850>:
    1be0:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001bf1 <__c.4848>:
    1bf1:	43 6f 6e 6e 65 63 74 00                             Connect.

00001bf9 <__c.4846>:
    1bf9:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001c0a <__c.4819>:
    1c0a:	43 4f 4d 25 64 3a 25 69 20 20 20 20 20 20 20 20     COM%d:%i        
    1c1a:	20 20 20 00                                            .

00001c1e <__c.4817>:
    1c1e:	49 6e 69 74 69 61 6c 69 7a 65 20 43 4f 4d 20 2e     Initialize COM .
    1c2e:	2e 2e 00                                            ...

00001c31 <__c.4778>:
    1c31:	0a 47 65 4e 69 55 73 20 54 69 63 6b 65 74 20 50     .GeNiUs Ticket P
    1c41:	72 69 6e 74 65 72 20 0a 20 56 65 72 73 69 6f 6e     rinter . Version
    1c51:	3a 25 73 0a 20 4c 61 73 74 20 55 70 64 61 74 65     :%s. Last Update
    1c61:	20 25 73 20 0a 20 48 61 6e 69 6e 64 6f 20 41 75      %s . Hanindo Au
    1c71:	74 6f 6d 61 74 69 6f 6e 20 53 6f 6c 75 74 69 6f     tomation Solutio
    1c81:	6e 73 20 0a 20 77 77 77 2e 68 61 6e 69 6e 64 6f     ns . www.hanindo
    1c91:	67 72 6f 75 70 2e 63 6f 6d 0a 0a 0a 0a 0a 0a 0a     group.com.......
    1ca1:	0a 00                                               ..

00001ca3 <__c.4776>:
    1ca3:	30 37 2f 30 31 2f 32 30 31 31 00                    07/01/2011.

00001cae <__c.4774>:
    1cae:	32 2e 33 30 00                                      2.30.

00001cb3 <__c.4765>:
    1cb3:	25 73 25 73 25 73 25 73 39 38 25 2e 32 64 46 39     %s%s%s%s98%.2dF9
    1cc3:	36 38 43 46 46 42 00                                68CFFB.

00001cca <__c.4639>:
    1cca:	46 75 65 6c 69 6e 67 20 40 46 49 50 3a 23 25 64     Fueling @FIP:#%d
	...

00001cdb <__c.4637>:
    1cdb:	54 72 61 6e 73 61 6b 73 69 20 53 65 6c 65 73 61     Transaksi Selesa
    1ceb:	69 00                                               i.

00001ced <__c.4633>:
    1ced:	49 44 3a 20 25 73 00                                ID: %s.

00001cf4 <__c.4631>:
    1cf4:	25 73 00                                            %s.

00001cf7 <__c.4629>:
    1cf7:	50 25 73 20 25 73 20 00                             P%s %s .

00001cff <__c.4625>:
    1cff:	46 49 50 20 54 69 64 61 6b 20 53 69 61 70 20 20     FIP Tidak Siap  
    1d0f:	20 20 00                                              .

00001d12 <__c.4622>:
    1d12:	41 75 74 68 6f 72 69 73 61 73 69 20 42 65 72 68     Authorisasi Berh
    1d22:	61 73 69 6c 00                                      asil.

00001d27 <__c.4618>:
    1d27:	41 75 74 68 6f 72 69 73 61 73 69 20 47 61 67 61     Authorisasi Gaga
    1d37:	6c 20 20 20 00                                      l   .

00001d3c <__c.4614>:
    1d3c:	20 20 20 20 20 20 20 00                                    .

00001d44 <__c.4611>:
    1d44:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1d54:	20 20 20 20 00                                          .

00001d59 <__c.4609>:
    1d59:	4d 6f 68 6f 6e 20 54 75 6e 67 67 75 20 20 20 20     Mohon Tunggu    
    1d69:	20 20 20 20 00                                          .

00001d6e <__c.4607>:
    1d6e:	25 73 00                                            %s.

00001d71 <__c.4605>:
    1d71:	50 25 73 20 25 73 20 00                             P%s %s .

00001d79 <__c.4602>:
    1d79:	43 61 6e 63 65 6c 20 54 72 61 6e 73 61 63 74 69     Cancel Transacti
    1d89:	6f 6e 20 20 00                                      on  .

00001d8e <__c.4599>:
    1d8e:	5b 2a 5d 42 61 63 6b 20 5b 30 5d 45 53 43 20 5b     [*]Back [0]ESC [
    1d9e:	23 5d 4f 4b 00                                      #]OK.

00001da3 <__c.4597>:
    1da3:	25 73 20 00                                         %s .

00001da7 <__c.4595>:
    1da7:	20 46 75 6c 6c 00                                    Full.

00001dad <__c.4593>:
    1dad:	25 73 20 20 25 73 20 00                             %s  %s .

00001db5 <__c.4591>:
    1db5:	49 44 3a 20 25 73 00                                ID: %s.

00001dbc <__c.4589>:
    1dbc:	25 73 20 00                                         %s .

00001dc0 <__c.4585>:
    1dc0:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1dd0:	20 00                                                .

00001dd2 <__c.4583>:
    1dd2:	4f 64 6f 6d 65 74 65 72 3a 5f 20 20 20 20 20 20     Odometer:_      
    1de2:	20 00                                                .

00001de4 <__c.4581>:
    1de4:	25 73 20 00                                         %s .

00001de8 <__c.4579>:
    1de8:	20 20 25 73 20 25 73 20 00                            %s %s .

00001df1 <__c.4577>:
    1df1:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 41 6d 6f     Pump Product Amo
    1e01:	75 6e 74 00                                         unt.

00001e05 <__c.4575>:
    1e05:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 56 6f 6c     Pump Product Vol
    1e15:	75 6d 65 00                                         ume.

00001e19 <__c.4573>:
    1e19:	20 20 54 61 6e 6b 00                                  Tank.

00001e20 <__c.4571>:
    1e20:	20 20 25 73 20 25 73 20 00                            %s %s .

00001e29 <__c.4569>:
    1e29:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 20 20 46     Pump Product   F
    1e39:	75 6c 6c 00                                         ull.

00001e3d <__c.4566>:
    1e3d:	25 73 00                                            %s.

00001e40 <__c.4563>:
    1e40:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1e50:	20 20 20 20 00                                          .

00001e55 <__c.4561>:
    1e55:	5b 32 5d 41 6d 6f 75 6e 74 3a 5f 20 20 20 20 20     [2]Amount:_     
    1e65:	20 20 20 20 00                                          .

00001e6a <__c.4559>:
    1e6a:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1e7a:	20 20 20 20 00                                          .

00001e7f <__c.4557>:
    1e7f:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001e87 <__c.4555>:
    1e87:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1e97:	20 20 20 20 00                                          .

00001e9c <__c.4553>:
    1e9c:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1eac:	20 20 20 20 00                                          .

00001eb1 <__c.4551>:
    1eb1:	5b 31 5d 56 6f 6c 75 6d 65 3a 5f 20 20 20 20 20     [1]Volume:_     
    1ec1:	20 20 20 20 00                                          .

00001ec6 <__c.4549>:
    1ec6:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001ece <__c.4546>:
    1ece:	41 00                                               A.

00001ed0 <__c.4544>:
    1ed0:	41 00                                               A.

00001ed2 <__c.4542>:
    1ed2:	56 00                                               V.

00001ed4 <__c.4539>:
    1ed4:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 4e 65     [*]Back    [#]Ne
    1ee4:	78 74 20 20 00                                      xt  .

00001ee9 <__c.4537>:
    1ee9:	5b 32 5d 41 6d 6f 75 6e 74 20 20 20 20 20 20 20     [2]Amount       
    1ef9:	20 20 20 20 00                                          .

00001efe <__c.4535>:
    1efe:	5b 31 5d 56 6f 6c 75 6d 65 20 20 20 20 20 20 20     [1]Volume       
    1f0e:	20 20 20 20 00                                          .

00001f13 <__c.4533>:
    1f13:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001f1b <__c.4530>:
    1f1b:	25 73 00                                            %s.

00001f1e <__c.4527>:
    1f1e:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1f2e:	20 20 20 20 00                                          .

00001f33 <__c.4522>:
    1f33:	20 20 20 20 20 00                                        .

00001f39 <__c.4520>:
    1f39:	25 64 2e 25 73 00                                   %d.%s.

00001f3f <__c.4518>:
    1f3f:	25 73 00                                            %s.

00001f42 <__c.4516>:
    1f42:	50 6f 6d 70 61 2d 25 73 00                          Pompa-%s.

00001f4b <__c.4513>:
    1f4b:	25 2e 32 64 00                                      %.2d.

00001f50 <__c.4511>:
    1f50:	25 2e 32 64 00                                      %.2d.

00001f55 <__c.4508>:
    1f55:	2a 29 45 78 69 74 00                                *)Exit.

00001f5c <__c.4506>:
    1f5c:	23 29 4f 4b 20 00                                   #)OK .

00001f62 <__c.4504>:
    1f62:	20 20 20 20 20 00                                        .

00001f68 <__c.4502>:
    1f68:	46 49 50 3a 5f 00                                   FIP:_.

00001f6e <__c.4497>:
    1f6e:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
    1f7e:	2e 32 64 00                                         .2d.

00001f82 <__c.4493>:
    1f82:	5b 2a 5d 42 61 74 61 6c 20 20 20 20 20 20 20 5b     [*]Batal       [
    1f92:	23 5d 4f 4b 00                                      #]OK.

00001f97 <__c.4491>:
    1f97:	25 73 20 25 73 00                                   %s %s.

00001f9d <__c.4489>:
    1f9d:	25 73 00                                            %s.

00001fa0 <__c.4487>:
    1fa0:	25 73 00                                            %s.

00001fa3 <__c.4485>:
    1fa3:	25 73 00                                            %s.

00001fa6 <__c.4482>:
    1fa6:	4b 61 72 74 75 20 54 65 72 62 61 74 61 73 20 20     Kartu Terbatas  
    1fb6:	20 20 20 20 00                                          .

00001fbb <__c.4480>:
    1fbb:	54 69 64 61 6b 20 54 65 72 64 61 66 74 61 72 20     Tidak Terdaftar 
    1fcb:	20 20 20 20 00                                          .

00001fd0 <__c.4477>:
    1fd0:	44 61 74 61 20 52 65 63 65 69 76 65 64 20 20 20     Data Received   
    1fe0:	20 20 20 20 00                                          .

00001fe5 <__c.4474>:
    1fe5:	54 43 50 2f 49 50 20 45 72 72 6f 72 20 20 20 20     TCP/IP Error    
    1ff5:	20 20 20 20 00                                          .

00001ffa <__c.4472>:
    1ffa:	53 65 6e 64 69 6e 67 20 46 61 69 6c 65 64 20 20     Sending Failed  
    200a:	20 20 20 20 00                                          .

0000200f <__c.4469>:
    200f:	20 20 20 20 20 20 20 00                                    .

00002017 <__c.4464>:
    2017:	50 72 6f 73 65 73 00                                Proses.

0000201e <__c.4462>:
    201e:	49 44 3a 25 73 00                                   ID:%s.

00002024 <__c.4460>:
    2024:	20 20 20 4c 6f 63 61 6c 20 41 63 63 6f 75 6e 74        Local Account
    2034:	20 20 20 00                                            .

00002038 <__c.4260>:
    2038:	45 39 34 34 35 35 31 32 00                          E9445512.

00002041 <__c.4258>:
    2041:	25 73 25 73 00                                      %s%s.

00002046 <__c.4256>:
    2046:	25 73 25 73 25 73 25 73 39 34 00                    %s%s%s%s94.

00002051 <__c.4251>:
    2051:	45 39 34 34 35 35 31 32 00                          E9445512.

0000205a <__c.4249>:
    205a:	25 73 25 73 25 73 00                                %s%s%s.

00002061 <__c.4247>:
    2061:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

0000206a <__c.4245>:
    206a:	25 73 25 73 25 73 25 73 39 32 00                    %s%s%s%s92.

00002075 <__c.4240>:
    2075:	45 39 34 34 35 35 31 32 00                          E9445512.

0000207e <__c.4238>:
    207e:	25 73 25 73 00                                      %s%s.

00002083 <__c.4236>:
    2083:	25 73 25 73 25 73 25 73 39 30 00                    %s%s%s%s90.

0000208e <__c.4227>:
    208e:	25 64 46 30 30 30 30 30 30 30 45 31 32 33 34 35     %dF0000000E12345
    209e:	36 46 46 46 46 46 25 73 45 39 34 34 35 35 31 32     6FFFFF%sE9445512
	...

000020af <__c.4225>:
    20af:	25 73 25 73 25 64 25 73 25 73 00                    %s%s%d%s%s.

000020ba <__c.4223>:
    20ba:	25 73 25 73 25 73 25 73 35 38 00                    %s%s%s%s58.

000020c5 <__c.4218>:
    20c5:	25 73 25 73 25 73 25 73 35 36 25 73 41 46 39 36     %s%s%s%s56%sAF96
    20d5:	38 43 46 46 42 00                                   8CFFB.

000020db <__c.4213>:
    20db:	46 39 36 38 43 46 46 42 00                          F968CFFB.

000020e4 <__c.4211>:
    20e4:	25 73 25 73 00                                      %s%s.

000020e9 <__c.4209>:
    20e9:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

000020f2 <__c.4207>:
    20f2:	25 73 25 73 25 73 25 73 33 32 00                    %s%s%s%s32.

000020fd <__c.4202>:
    20fd:	25 73 25 73 46 39 36 38 43 46 46 42 00              %s%sF968CFFB.

0000210a <__c.4200>:
    210a:	25 73 25 73 25 73 25 73 32 38 00                    %s%s%s%s28.

00002115 <__c.4195>:
    2115:	25 73 25 73 46 39 36 38 43 46 46 42 00              %s%sF968CFFB.

00002122 <__c.4193>:
    2122:	25 73 25 73 25 73 25 73 32 34 00                    %s%s%s%s24.

0000212d <__c.4188>:
    212d:	25 73 46 39 36 38 43 46 46 42 00                    %sF968CFFB.

00002138 <__c.4186>:
    2138:	25 73 25 73 25 73 25 73 32 32 00                    %s%s%s%s22.

00002143 <__c.4181>:
    2143:	25 73 25 73 25 73 25 73 31 30 46 39 36 38 43 46     %s%s%s%s10F968CF
    2153:	46 42 00                                            FB.

00002156 <__c.4176>:
    2156:	25 73 25 73 25 73 25 73 30 34 25 73 31 46 39 36     %s%s%s%s04%s1F96
    2166:	38 43 46 46 42 00                                   8CFFB.

0000216c <__c.4162>:
    216c:	25 73 2e 25 73 2e 25 73 2e 25 73 00                 %s.%s.%s.%s.

00002178 <__c.4143>:
    2178:	25 73 2e 25 73 2e 25 73 2e 25 73 00                 %s.%s.%s.%s.

00002184 <__c.4076>:
    2184:	25 73 20 25 73 00                                   %s %s.

0000218a <__c.4074>:
    218a:	32 2e 33 30 00                                      2.30.

0000218f <__c.4072>:
    218f:	47 65 4e 69 55 73 00                                GeNiUs.

00002196 <__c.4064>:
    2196:	28 50 29 2b 28 43 29 32 30 30 39 2c 20 48 41 53     (P)+(C)2009, HAS
	...

000021a7 <__c.4062>:
    21a7:	49 46 54 76 35 2e 31 33 00                          IFTv5.13.

000021b0 <__c.4051>:
    21b0:	50 72 65 73 73 20 61 6e 79 20 6b 65 79 2e 2e 20     Press any key.. 
    21c0:	20 20 20 20 00                                          .

000021c5 <__c.4039>:
    21c5:	5b 31 5d 53 6c 61 76 65 20 5b 32 5d 53 74 61 6e     [1]Slave [2]Stan
    21d5:	64 61 6c 6f 6e 65 00                                dalone.

000021dc <__c.3959>:
    21dc:	3e 00                                               >.

000021de <__c.3954>:
    21de:	25 2e 32 64 00                                      %.2d.

000021e3 <__c.3952>:
    21e3:	25 2e 32 64 00                                      %.2d.

000021e8 <__c.3950>:
    21e8:	30 00                                               0.

000021ea <__c.3948>:
    21ea:	31 00                                               1.

000021ec <__c.3940>:
    21ec:	25 64 00                                            %d.

000021ef <__c.3935>:
    21ef:	25 2e 32 64 00                                      %.2d.

000021f4 <__c.3930>:
    21f4:	25 73 00                                            %s.

000021f7 <__c.3925>:
    21f7:	25 73 00                                            %s.

000021fa <__c.3920>:
    21fa:	25 73 00                                            %s.

000021fd <__c.3918>:
    21fd:	3c 00                                               <.

000021ff <__c.3867>:
    21ff:	3c 4f 4b 3e 00                                      <OK>.

00002204 <__c.3862>:
    2204:	25 64 00                                            %d.

00002207 <__c.3860>:
    2207:	25 64 00                                            %d.

0000220a <__c.3849>:
    220a:	25 64 00                                            %d.

0000220d <__c.3838>:
    220d:	3c 53 61 76 69 6e 67 3e 00                          <Saving>.

00002216 <__c.3649>:
    2216:	25 73 00                                            %s.

00002219 <__c.3591>:
    2219:	25 73 00                                            %s.

0000221c <__c.3589>:
    221c:	25 73 00                                            %s.

0000221f <__c.3587>:
    221f:	25 73 00                                            %s.

00002222 <__c.3585>:
    2222:	25 73 00                                            %s.

00002225 <__c.3583>:
    2225:	25 2e 32 64 00                                      %.2d.

0000222a <__c.3581>:
    222a:	25 64 00                                            %d.

0000222d <__c.3579>:
    222d:	25 73 00                                            %s.

00002230 <__c.3577>:
    2230:	25 73 00                                            %s.

00002233 <__c.3575>:
    2233:	25 73 00                                            %s.

00002236 <__c.3573>:
    2236:	25 64 00                                            %d.

00002239 <__c.3571>:
    2239:	4e 2f 41 00                                         N/A.

0000223d <__c.3467>:
    223d:	25 64 00                                            %d.

00002240 <__c.3465>:
    2240:	25 73 00                                            %s.

00002243 <__c.3463>:
    2243:	25 73 00                                            %s.

00002246 <__c.3372>:
    2246:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    2256:	6b 73 69 20 00                                      ksi .

0000225b <__c.3368>:
    225b:	54 6f 74 61 6c 69 7a 65 72 41 6c 6c 20 20 20 20     TotalizerAll    
    226b:	20 00                                                .

0000226d <__c.3365>:
    226d:	43 6c 65 61 72 20 44 61 74 61 20 54 6f 74 61 6c     Clear Data Total
    227d:	69 7a 65 72 00                                      izer.

00002282 <__c.3354>:
    2282:	41 75 74 6f 00                                      Auto.

00002287 <__c.3351>:
    2287:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00002298 <__c.3348>:
    2298:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    22a8:	20 20 20 20 00                                          .

000022ad <__c.3345>:
    22ad:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    22bd:	20 20 20 20 00                                          .

000022c2 <__c.3343>:
    22c2:	4e 6f 20 52 65 73 70 6f 6e 73 65 2e 2e 20 20 20     No Response..   
    22d2:	20 20 20 20 00                                          .

000022d7 <__c.3340>:
    22d7:	50 6c 65 61 73 65 20 57 61 69 74 2e 2e 20 20 20     Please Wait..   
    22e7:	20 20 20 20 00                                          .

000022ec <__c.3337>:
    22ec:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    22fc:	20 20 20 20 00                                          .

00002301 <__c.3334>:
    2301:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    2311:	6b 73 69 20 00                                      ksi .

00002316 <__c.3329>:
    2316:	53 65 64 61 6e 67 50 72 6f 73 65 73 00              SedangProses.

00002323 <__c.3326>:
    2323:	20 20 20 20 00                                          .

00002328 <__c.3324>:
    2328:	41 75 74 6f 00                                      Auto.

0000232d <__c.1750>:
    232d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    233d:	20 20 20 20 00                                          .

00002342 <__c.1748>:
    2342:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2352:	20 20 20 20 00                                          .

00002357 <__c.1746>:
    2357:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2367:	20 20 20 20 00                                          .

0000236c <__c.1744>:
    236c:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    237c:	20 20 20 20 00                                          .

00002381 <__alphanum>:
    2381:	30 20 2e 00 00 00 31 2e 2c 3f 21 00 32 61 62 63     0 ....1.,?!.2abc
    2391:	00 00 33 64 65 66 00 00 34 67 68 69 00 00 35 6a     ..3def..4ghi..5j
    23a1:	6b 6c 00 00 36 6d 6e 6f 00 00 37 70 71 72 73 00     kl..6mno..7pqrs.
    23b1:	38 74 75 76 00 00 39 77 78 79 7a 00 30 20 2e 00     8tuv..9wxyz.0 ..
    23c1:	00 00 31 26 40 2b 2d 00 32 41 42 43 00 00 33 44     ..1&@+-.2ABC..3D
    23d1:	45 46 00 00 34 47 48 49 00 00 35 4a 4b 4c 00 00     EF..4GHI..5JKL..
    23e1:	36 4d 4e 4f 00 00 37 50 51 52 53 00 38 54 55 56     6MNO..7PQRS.8TUV
    23f1:	00 00 39 57 58 59 5a 00                             ..9WXYZ.

000023f9 <__maxchar>:
    23f9:	02 04 03 03 03 03 03 04 03 04 00                    ...........

00002404 <__ctors_end>:
    2404:	11 24       	eor	r1, r1
    2406:	1f be       	out	0x3f, r1	; 63
    2408:	cf ef       	ldi	r28, 0xFF	; 255
    240a:	d0 e1       	ldi	r29, 0x10	; 16
    240c:	de bf       	out	0x3e, r29	; 62
    240e:	cd bf       	out	0x3d, r28	; 61

00002410 <__do_copy_data>:
    2410:	11 e0       	ldi	r17, 0x01	; 1
    2412:	a0 e0       	ldi	r26, 0x00	; 0
    2414:	b1 e0       	ldi	r27, 0x01	; 1
    2416:	ec e7       	ldi	r30, 0x7C	; 124
    2418:	f0 e7       	ldi	r31, 0x70	; 112
    241a:	01 e0       	ldi	r16, 0x01	; 1
    241c:	0b bf       	out	0x3b, r16	; 59
    241e:	02 c0       	rjmp	.+4      	; 0x2424 <__do_copy_data+0x14>
    2420:	07 90       	elpm	r0, Z+
    2422:	0d 92       	st	X+, r0
    2424:	a4 37       	cpi	r26, 0x74	; 116
    2426:	b1 07       	cpc	r27, r17
    2428:	d9 f7       	brne	.-10     	; 0x2420 <__do_copy_data+0x10>

0000242a <__do_clear_bss>:
    242a:	1e e0       	ldi	r17, 0x0E	; 14
    242c:	a4 e7       	ldi	r26, 0x74	; 116
    242e:	b1 e0       	ldi	r27, 0x01	; 1
    2430:	01 c0       	rjmp	.+2      	; 0x2434 <.do_clear_bss_start>

00002432 <.do_clear_bss_loop>:
    2432:	1d 92       	st	X+, r1

00002434 <.do_clear_bss_start>:
    2434:	a4 3d       	cpi	r26, 0xD4	; 212
    2436:	b1 07       	cpc	r27, r17
    2438:	e1 f7       	brne	.-8      	; 0x2432 <.do_clear_bss_loop>
    243a:	0e 94 a7 12 	call	0x254e	; 0x254e <main>
    243e:	0c 94 3c b8 	jmp	0x17078	; 0x17078 <_exit>

00002442 <__bad_interrupt>:
    2442:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00002446 <systemOnReset>:
	};
}


void systemOnReset(){
     if (MCUCSR & 1){   // Power-on Reset
    2446:	04 b6       	in	r0, 0x34	; 52
    2448:	00 fe       	sbrs	r0, 0
    244a:	06 c0       	rjmp	.+12     	; 0x2458 <systemOnReset+0x12>
         MCUCSR=0;lcd_printf(1,1,PSTR("PowerOn"));
    244c:	14 be       	out	0x34, r1	; 52
    244e:	81 e0       	ldi	r24, 0x01	; 1
    2450:	61 e0       	ldi	r22, 0x01	; 1
    2452:	4e ec       	ldi	r20, 0xCE	; 206
    2454:	52 e0       	ldi	r21, 0x02	; 2
    2456:	16 c0       	rjmp	.+44     	; 0x2484 <systemOnReset+0x3e>
         }
     else 
     if (MCUCSR & 2){   // External Reset
    2458:	04 b6       	in	r0, 0x34	; 52
    245a:	01 fe       	sbrs	r0, 1
    245c:	06 c0       	rjmp	.+12     	; 0x246a <systemOnReset+0x24>
         MCUCSR=0;lcd_printf(1,1,PSTR("External"));
    245e:	14 be       	out	0x34, r1	; 52
    2460:	81 e0       	ldi	r24, 0x01	; 1
    2462:	61 e0       	ldi	r22, 0x01	; 1
    2464:	45 ec       	ldi	r20, 0xC5	; 197
    2466:	52 e0       	ldi	r21, 0x02	; 2
    2468:	0d c0       	rjmp	.+26     	; 0x2484 <systemOnReset+0x3e>
        }
     else 
     if (MCUCSR & 4){   // Brown-Out Reset
    246a:	04 b6       	in	r0, 0x34	; 52
    246c:	02 fe       	sbrs	r0, 2
    246e:	06 c0       	rjmp	.+12     	; 0x247c <systemOnReset+0x36>
         MCUCSR=0;lcd_printf(1,1,PSTR("BrownOut"));
    2470:	14 be       	out	0x34, r1	; 52
    2472:	81 e0       	ldi	r24, 0x01	; 1
    2474:	61 e0       	ldi	r22, 0x01	; 1
    2476:	4c eb       	ldi	r20, 0xBC	; 188
    2478:	52 e0       	ldi	r21, 0x02	; 2
    247a:	04 c0       	rjmp	.+8      	; 0x2484 <systemOnReset+0x3e>
         }
     else		  // Watchdog Reset
        {
         lcd_printf(1,1,PSTR("WatchDog"));
    247c:	81 e0       	ldi	r24, 0x01	; 1
    247e:	61 e0       	ldi	r22, 0x01	; 1
    2480:	43 eb       	ldi	r20, 0xB3	; 179
    2482:	52 e0       	ldi	r21, 0x02	; 2
    2484:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
        };
     MCUCSR=0;		  
    2488:	14 be       	out	0x34, r1	; 52
    248a:	80 ee       	ldi	r24, 0xE0	; 224
    248c:	9e e2       	ldi	r25, 0x2E	; 46
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    248e:	20 e7       	ldi	r18, 0x70	; 112
    2490:	31 e0       	ldi	r19, 0x01	; 1
    2492:	f9 01       	movw	r30, r18
    2494:	31 97       	sbiw	r30, 0x01	; 1
    2496:	f1 f7       	brne	.-4      	; 0x2494 <systemOnReset+0x4e>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2498:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    249a:	d9 f7       	brne	.-10     	; 0x2492 <systemOnReset+0x4c>
	 _delay_ms(1200);
}
    249c:	08 95       	ret

0000249e <SystemInit>:


void SystemInit(){
	unsigned int __delay =300;
	lcd_init();
    249e:	0e 94 0c ab 	call	0x15618	; 0x15618 <lcd_init>
	lcd_clear();
    24a2:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
	BackLightTrig();
    24a6:	0e 94 c6 14 	call	0x298c	; 0x298c <BackLightTrig>
	systemOnReset();
    24aa:	0e 94 23 12 	call	0x2446	; 0x2446 <systemOnReset>

	lcd_printf(4, 1, PSTR("Initialize... "));
    24ae:	84 e0       	ldi	r24, 0x04	; 4
    24b0:	61 e0       	ldi	r22, 0x01	; 1
    24b2:	44 ea       	ldi	r20, 0xA4	; 164
    24b4:	52 e0       	ldi	r21, 0x02	; 2
    24b6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
    24ba:	88 eb       	ldi	r24, 0xB8	; 184
    24bc:	9b e0       	ldi	r25, 0x0B	; 11
    24be:	20 e7       	ldi	r18, 0x70	; 112
    24c0:	31 e0       	ldi	r19, 0x01	; 1
    24c2:	f9 01       	movw	r30, r18
    24c4:	31 97       	sbiw	r30, 0x01	; 1
    24c6:	f1 f7       	brne	.-4      	; 0x24c4 <SystemInit+0x26>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    24c8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    24ca:	d9 f7       	brne	.-10     	; 0x24c2 <SystemInit+0x24>
	_delay_ms(__delay);
	PORTA = 0XFF;		// Buffer for PORTA
    24cc:	9f ef       	ldi	r25, 0xFF	; 255
    24ce:	9b bb       	out	0x1b, r25	; 27
	DDRA = 0xFF;		// Pin 3 out (SS _SPI_SLAVE)
    24d0:	9a bb       	out	0x1a, r25	; 26
	sbi(PORTA, 3);		// Disable SS _SPI_SLAVE
    24d2:	db 9a       	sbi	0x1b, 3	; 27

	//Buzzer PORTB.5
	PORTB = 0xFF;DDRB = 0xFF;
    24d4:	98 bb       	out	0x18, r25	; 24
    24d6:	97 bb       	out	0x17, r25	; 23
	PORTD = 0b00001101;
    24d8:	8d e0       	ldi	r24, 0x0D	; 13
    24da:	82 bb       	out	0x12, r24	; 18
    DDRD =  0b00001001;
    24dc:	89 e0       	ldi	r24, 0x09	; 9
    24de:	81 bb       	out	0x11, r24	; 17

	TWBR = 0xFF;
    24e0:	90 93 70 00 	sts	0x0070, r25
    //MMC
	PORTE = 0x0E;		// Buffer for PORTE
    24e4:	8e e0       	ldi	r24, 0x0E	; 14
    24e6:	83 b9       	out	0x03, r24	; 3
	DDRE = 0x0E;		// Pin 3 out (SS _SPI_MMC), pin 2 out (HB)
    24e8:	82 b9       	out	0x02, r24	; 2
	sbi(PORTE, 3);		// Disable SS _SPI_MMC
    24ea:	1b 9a       	sbi	0x03, 3	; 3
	cbi(PORTE, 2);		// HB on
    24ec:	1a 98       	cbi	0x03, 2	; 3

	//Keypad
	PORTF = 0xFF;		// Buffer for PORTF
    24ee:	90 93 62 00 	sts	0x0062, r25
	DDRF = 0xF0;		// 4 bit row, 4 bit column
    24f2:	80 ef       	ldi	r24, 0xF0	; 240
    24f4:	80 93 61 00 	sts	0x0061, r24

  	_spi_init(0,1);//Slave
    24f8:	80 e0       	ldi	r24, 0x00	; 0
    24fa:	61 e0       	ldi	r22, 0x01	; 1
    24fc:	0e 94 03 b0 	call	0x16006	; 0x16006 <_spi_init>
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    2500:	bb 9a       	sbi	0x17, 3	; 23
    2502:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    2504:	ba 98       	cbi	0x17, 2	; 23
    2506:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    2508:	b9 98       	cbi	0x17, 1	; 23
    250a:	c1 9a       	sbi	0x18, 1	; 24

	TCCR1B |= (1 << WGM12);
    250c:	8e b5       	in	r24, 0x2e	; 46
    250e:	88 60       	ori	r24, 0x08	; 8
    2510:	8e bd       	out	0x2e, r24	; 46
	TIMSK |= (1 << OCIE1A);
    2512:	87 b7       	in	r24, 0x37	; 55
    2514:	80 61       	ori	r24, 0x10	; 16
    2516:	87 bf       	out	0x37, r24	; 55
	sei();          //1/14745600=0,06781684028uS *1400 = 100uS 65535-1400+1=64136
    2518:	78 94       	sei
	OCR1A   = 15624;//49911 -->0,33847384982639 ms
    251a:	88 e0       	ldi	r24, 0x08	; 8
    251c:	9d e3       	ldi	r25, 0x3D	; 61
    251e:	9b bd       	out	0x2b, r25	; 43
    2520:	8a bd       	out	0x2a, r24	; 42
	TCCR1B |= ((1 << CS10) | (1 << CS11));
    2522:	8e b5       	in	r24, 0x2e	; 46
    2524:	83 60       	ori	r24, 0x03	; 3
    2526:	8e bd       	out	0x2e, r24	; 46
	systemSlave();
	_delay_ms(100);
	systemMaster();
*/
	
	InitComport();
    2528:	0e 94 c6 a4 	call	0x1498c	; 0x1498c <InitComport>
	_LIGHT_SET;
    252c:	81 e0       	ldi	r24, 0x01	; 1
    252e:	80 93 e2 03 	sts	0x03E2, r24
    2532:	10 92 e3 03 	sts	0x03E3, r1
    2536:	80 91 65 00 	lds	r24, 0x0065
    253a:	8d 7f       	andi	r24, 0xFD	; 253
    253c:	80 93 65 00 	sts	0x0065, r24
	InitPrinter();
    2540:	0e 94 a6 4a 	call	0x954c	; 0x954c <InitPrinter>
    InitializeConnection();
    2544:	0e 94 0f 78 	call	0xf01e	; 0xf01e <InitializeConnection>
	lcd_clear(); 
    2548:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
}
    254c:	08 95       	ret

0000254e <main>:
void SystemInit();
//void TestUserInput();

//Program Utama
int main(){
	SystemInit();
    254e:	0e 94 4f 12 	call	0x249e	; 0x249e <SystemInit>
	while(1){
	//FTestChar();
	//TestUserInput();
    FMenuIdle();
    2552:	0e 94 96 a2 	call	0x1452c	; 0x1452c <FMenuIdle>
    2556:	fd cf       	rjmp	.-6      	; 0x2552 <main+0x4>

00002558 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    2558:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    255a:	e1 99       	sbic	0x1c, 1	; 28
    255c:	fe cf       	rjmp	.-4      	; 0x255a <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    255e:	3f bb       	out	0x1f, r19	; 31
    2560:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2562:	e0 9a       	sbi	0x1c, 0	; 28
    2564:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    2566:	08 95       	ret

00002568 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    2568:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    256a:	e1 99       	sbic	0x1c, 1	; 28
    256c:	fe cf       	rjmp	.-4      	; 0x256a <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    256e:	3f bb       	out	0x1f, r19	; 31
    2570:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    2572:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    2574:	0f b6       	in	r0, 0x3f	; 63
    2576:	f8 94       	cli
    2578:	e2 9a       	sbi	0x1c, 2	; 28
    257a:	e1 9a       	sbi	0x1c, 1	; 28
    257c:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    257e:	08 95       	ret

00002580 <RePrintStandalone>:

char RePrintStandalone(char FIPAddr){
     char Result=PS_NONE;

   return Result;
}
    2580:	86 e1       	ldi	r24, 0x16	; 22
    2582:	08 95       	ret

00002584 <GetPumpStatusLabel>:


char GetPumpStatusLabel(char xPumpStatus){
     char Result;

	 switch(xPumpStatus){
    2584:	e8 2f       	mov	r30, r24
    2586:	f0 e0       	ldi	r31, 0x00	; 0
    2588:	ee 31       	cpi	r30, 0x1E	; 30
    258a:	f1 05       	cpc	r31, r1
    258c:	50 f5       	brcc	.+84     	; 0x25e2 <GetPumpStatusLabel+0x5e>
    258e:	ea 5b       	subi	r30, 0xBA	; 186
    2590:	ff 4f       	sbci	r31, 0xFF	; 255
    2592:	ee 0f       	add	r30, r30
    2594:	ff 1f       	adc	r31, r31
    2596:	05 90       	lpm	r0, Z+
    2598:	f4 91       	lpm	r31, Z+
    259a:	e0 2d       	mov	r30, r0
    259c:	09 94       	ijmp
    259e:	81 e3       	ldi	r24, 0x31	; 49
    25a0:	08 95       	ret
    25a2:	85 e4       	ldi	r24, 0x45	; 69
    25a4:	08 95       	ret
    25a6:	82 e3       	ldi	r24, 0x32	; 50
    25a8:	08 95       	ret
	 case PUMP_ST1: 
	      Result='1';
		  break;
	 case PUMP_ST2: 
	 	  Result='2';
		  break;
    25aa:	83 e3       	ldi	r24, 0x33	; 51
    25ac:	08 95       	ret
     case PUMP_ST3:
	 	  Result='3';
		  break;	
    25ae:	84 e3       	ldi	r24, 0x34	; 52
    25b0:	08 95       	ret
	 case PUMP_ST4: 
          Result='4';
		  break;
    25b2:	85 e3       	ldi	r24, 0x35	; 53
    25b4:	08 95       	ret
	 case PUMP_ST5: 
	 	  Result='5';
		  break;
    25b6:	89 e6       	ldi	r24, 0x69	; 105
    25b8:	08 95       	ret
	 case PUMP_OFF: 
	 case PW_ONLINE:
	 	  Result='i';
		  break;
    25ba:	8e e6       	ldi	r24, 0x6E	; 110
    25bc:	08 95       	ret
     case PW_CALL:
	 case PUMP_CALL: 
	 	  Result='n';
		  break;     
    25be:	81 e6       	ldi	r24, 0x61	; 97
    25c0:	08 95       	ret
	 case PUMP_AUTH: 
	 	  Result='a';
		  break;
    25c2:	84 e6       	ldi	r24, 0x64	; 100
    25c4:	08 95       	ret
     case PW_AUTHORIZED:
	 case PUMP_BUSY: 
	 	  Result='d';
		  break;
    25c6:	86 e4       	ldi	r24, 0x46	; 70
    25c8:	08 95       	ret
	 	  Result='P';
		  break;
     case PW_END_DELIVERY:
	 case PUMP_FEOT: 
	 	  Result='F';
		  break;
    25ca:	83 e5       	ldi	r24, 0x53	; 83
    25cc:	08 95       	ret
	 case PUMP_STOP: 
	 	  Result='S';
		  break;
    25ce:	8d e2       	ldi	r24, 0x2D	; 45
    25d0:	08 95       	ret
	 case PUMP_NONE:
	 case PW_DISCONNECT:
	 	  Result='-';
		  break;
    25d2:	89 e4       	ldi	r24, 0x49	; 73
    25d4:	08 95       	ret
     case PS_PRINT_READY:
	      Result='P';
 	      break;
     case PS_PRINTED:
	      Result='I';
 	      break;
    25d6:	86 e5       	ldi	r24, 0x56	; 86
    25d8:	08 95       	ret
     case PS_VOID:
	      Result='V';
	      break;
    25da:	84 e5       	ldi	r24, 0x54	; 84
    25dc:	08 95       	ret
     case PS_TOTALIZER:
	      Result='T';
	      break;
    25de:	84 e7       	ldi	r24, 0x74	; 116
    25e0:	08 95       	ret
     case PS_FINISH_TOTALIZER:
	      Result='t';
	      break;
    25e2:	88 e7       	ldi	r24, 0x78	; 120
    25e4:	08 95       	ret
    25e6:	80 e5       	ldi	r24, 0x50	; 80
	 default:
          Result='x';
		  break;         	 
	 }
  return Result;	 
}
    25e8:	08 95       	ret

000025ea <SendPoolingCommand>:
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    25ea:	80 93 b6 07 	sts	0x07B6, r24
	 PoolMsg=plMsg;
    25ee:	60 93 de 0d 	sts	0x0DDE, r22
     IsControlPooling=True;
    25f2:	81 e0       	ldi	r24, 0x01	; 1
    25f4:	80 93 ad 01 	sts	0x01AD, r24
}
    25f8:	08 95       	ret

000025fa <ScanEDCFlow>:
	 RemZeroLead(strMsgID);
	 Result=atoi(strMsgID);
  return Result;
}

void ScanEDCFlow(char data){
    25fa:	28 2f       	mov	r18, r24
static char IsEDCFlow=False,EDCMsgCode=0;
static unsigned int nFlow=0;
     char i;
     //EDC-MSG
     if (data==0x02){
    25fc:	82 30       	cpi	r24, 0x02	; 2
    25fe:	39 f4       	brne	.+14     	; 0x260e <ScanEDCFlow+0x14>
	     IsEDCFlow=True;
    2600:	81 e0       	ldi	r24, 0x01	; 1
    2602:	80 93 cc 03 	sts	0x03CC, r24
		 nFlow=0;
    2606:	10 92 ca 03 	sts	0x03CA, r1
    260a:	10 92 c9 03 	sts	0x03C9, r1
	 }//FillMessage
     if (IsEDCFlow==True){
    260e:	80 91 cc 03 	lds	r24, 0x03CC
    2612:	81 30       	cpi	r24, 0x01	; 1
    2614:	69 f4       	brne	.+26     	; 0x2630 <ScanEDCFlow+0x36>
	     rcv_trans[nFlow]=data;
    2616:	80 91 c9 03 	lds	r24, 0x03C9
    261a:	90 91 ca 03 	lds	r25, 0x03CA
    261e:	fc 01       	movw	r30, r24
    2620:	eb 5d       	subi	r30, 0xDB	; 219
    2622:	f4 4f       	sbci	r31, 0xF4	; 244
    2624:	20 83       	st	Z, r18
		 nFlow++;
    2626:	01 96       	adiw	r24, 0x01	; 1
    2628:	90 93 ca 03 	sts	0x03CA, r25
    262c:	80 93 c9 03 	sts	0x03C9, r24
	 }//CloseMessage
	 if ((data==0x03)||(nFlow>=MSG03_LENGTH)){
    2630:	23 30       	cpi	r18, 0x03	; 3
    2632:	41 f0       	breq	.+16     	; 0x2644 <ScanEDCFlow+0x4a>
    2634:	80 91 c9 03 	lds	r24, 0x03C9
    2638:	90 91 ca 03 	lds	r25, 0x03CA
    263c:	8d 34       	cpi	r24, 0x4D	; 77
    263e:	91 05       	cpc	r25, r1
    2640:	08 f4       	brcc	.+2      	; 0x2644 <ScanEDCFlow+0x4a>
    2642:	9b c0       	rjmp	.+310    	; 0x277a <ScanEDCFlow+0x180>
	     //for(i=0;i<nFlow;i++){_uart(0,1,rcv_trans[i]);}
	     IsEDCFlow=False;
    2644:	10 92 cc 03 	sts	0x03CC, r1
		 EDCMsgCode=((rcv_trans[1]-'0')*10)+(rcv_trans[2]-'0');
    2648:	30 91 27 0b 	lds	r19, 0x0B27
    264c:	30 51       	subi	r19, 0x10	; 16
    264e:	80 91 26 0b 	lds	r24, 0x0B26
    2652:	2a e0       	ldi	r18, 0x0A	; 10
    2654:	82 9f       	mul	r24, r18
    2656:	c0 01       	movw	r24, r0
    2658:	11 24       	eor	r1, r1
    265a:	38 0f       	add	r19, r24
    265c:	30 93 cb 03 	sts	0x03CB, r19

		 if (EDCMsgCode==0x03){
    2660:	33 30       	cpi	r19, 0x03	; 3
    2662:	09 f0       	breq	.+2      	; 0x2666 <ScanEDCFlow+0x6c>
    2664:	65 c0       	rjmp	.+202    	; 0x2730 <ScanEDCFlow+0x136>
    2666:	e8 e2       	ldi	r30, 0x28	; 40
    2668:	fb e0       	ldi	r31, 0x0B	; 11
    266a:	a2 e9       	ldi	r26, 0x92	; 146
    266c:	be e0       	ldi	r27, 0x0E	; 14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    266e:	81 91       	ld	r24, Z+
    2670:	8d 93       	st	X+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2672:	8b e0       	ldi	r24, 0x0B	; 11
    2674:	ee 32       	cpi	r30, 0x2E	; 46
    2676:	f8 07       	cpc	r31, r24
    2678:	d1 f7       	brne	.-12     	; 0x266e <ScanEDCFlow+0x74>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    267a:	10 92 98 0e 	sts	0x0E98, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    267e:	80 81       	ld	r24, Z
    2680:	80 93 c8 09 	sts	0x09C8, r24
    2684:	81 81       	ldd	r24, Z+1	; 0x01
    2686:	80 93 c9 09 	sts	0x09C9, r24
	 }Dest[Length]=0;
    268a:	10 92 ca 09 	sts	0x09CA, r1
    268e:	32 96       	adiw	r30, 0x02	; 2
    2690:	ae ea       	ldi	r26, 0xAE	; 174
    2692:	be e0       	ldi	r27, 0x0E	; 14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2694:	81 91       	ld	r24, Z+
    2696:	8d 93       	st	X+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2698:	8b e0       	ldi	r24, 0x0B	; 11
    269a:	ef 33       	cpi	r30, 0x3F	; 63
    269c:	f8 07       	cpc	r31, r24
    269e:	d1 f7       	brne	.-12     	; 0x2694 <ScanEDCFlow+0x9a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    26a0:	10 92 bd 0e 	sts	0x0EBD, r1
    26a4:	a1 e9       	ldi	r26, 0x91	; 145
    26a6:	bd e0       	ldi	r27, 0x0D	; 13
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    26a8:	81 91       	ld	r24, Z+
    26aa:	8d 93       	st	X+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    26ac:	8b e0       	ldi	r24, 0x0B	; 11
    26ae:	e2 35       	cpi	r30, 0x52	; 82
    26b0:	f8 07       	cpc	r31, r24
    26b2:	d1 f7       	brne	.-12     	; 0x26a8 <ScanEDCFlow+0xae>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    26b4:	10 92 a4 0d 	sts	0x0DA4, r1
    26b8:	20 e0       	ldi	r18, 0x00	; 0
    26ba:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    26bc:	f9 01       	movw	r30, r18
    26be:	e0 5f       	subi	r30, 0xF0	; 240
    26c0:	f5 4f       	sbci	r31, 0xF5	; 245
    26c2:	d9 01       	movw	r26, r18
    26c4:	ab 5d       	subi	r26, 0xDB	; 219
    26c6:	b4 4f       	sbci	r27, 0xF4	; 244
    26c8:	9d 96       	adiw	r26, 0x2d	; 45
    26ca:	8c 91       	ld	r24, X
    26cc:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    26ce:	2f 5f       	subi	r18, 0xFF	; 255
    26d0:	3f 4f       	sbci	r19, 0xFF	; 255
    26d2:	26 30       	cpi	r18, 0x06	; 6
    26d4:	31 05       	cpc	r19, r1
    26d6:	91 f7       	brne	.-28     	; 0x26bc <ScanEDCFlow+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    26d8:	10 92 16 0a 	sts	0x0A16, r1
    26dc:	20 e0       	ldi	r18, 0x00	; 0
    26de:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    26e0:	f9 01       	movw	r30, r18
    26e2:	ee 59       	subi	r30, 0x9E	; 158
    26e4:	f6 4f       	sbci	r31, 0xF6	; 246
    26e6:	d9 01       	movw	r26, r18
    26e8:	ab 5d       	subi	r26, 0xDB	; 219
    26ea:	b4 4f       	sbci	r27, 0xF4	; 244
    26ec:	d3 96       	adiw	r26, 0x33	; 51
    26ee:	8c 91       	ld	r24, X
    26f0:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    26f2:	2f 5f       	subi	r18, 0xFF	; 255
    26f4:	3f 4f       	sbci	r19, 0xFF	; 255
    26f6:	2a 30       	cpi	r18, 0x0A	; 10
    26f8:	31 05       	cpc	r19, r1
    26fa:	91 f7       	brne	.-28     	; 0x26e0 <ScanEDCFlow+0xe6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    26fc:	10 92 6c 09 	sts	0x096C, r1
    2700:	20 e0       	ldi	r18, 0x00	; 0
    2702:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2704:	f9 01       	movw	r30, r18
    2706:	e9 53       	subi	r30, 0x39	; 57
    2708:	f2 4f       	sbci	r31, 0xF2	; 242
    270a:	d9 01       	movw	r26, r18
    270c:	ab 5d       	subi	r26, 0xDB	; 219
    270e:	b4 4f       	sbci	r27, 0xF4	; 244
    2710:	dd 96       	adiw	r26, 0x3d	; 61
    2712:	8c 91       	ld	r24, X
    2714:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2716:	2f 5f       	subi	r18, 0xFF	; 255
    2718:	3f 4f       	sbci	r19, 0xFF	; 255
    271a:	2e 30       	cpi	r18, 0x0E	; 14
    271c:	31 05       	cpc	r19, r1
    271e:	91 f7       	brne	.-28     	; 0x2704 <ScanEDCFlow+0x10a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2720:	10 92 d5 0d 	sts	0x0DD5, r1
             StrPosCopy(rcv_trans,strCardType,11,15);
             StrPosCopy(rcv_trans,strCardID,26,19);
             StrPosCopy(rcv_trans,strApprovalCode,45,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,51,10);
             StrPosCopy(rcv_trans,strDateTime,61,14);
		     IsEDCApproved=True;//Sending Message 92
    2724:	81 e0       	ldi	r24, 0x01	; 1
    2726:	80 93 c5 01 	sts	0x01C5, r24
			 IsPrintApprovalCode=True;
    272a:	80 93 c6 01 	sts	0x01C6, r24
    272e:	08 95       	ret
	    }else
		 if (EDCMsgCode==0x04){
    2730:	34 30       	cpi	r19, 0x04	; 4
    2732:	19 f5       	brne	.+70     	; 0x277a <ScanEDCFlow+0x180>
    2734:	e8 e2       	ldi	r30, 0x28	; 40
    2736:	fb e0       	ldi	r31, 0x0B	; 11
    2738:	a0 e1       	ldi	r26, 0x10	; 16
    273a:	ba e0       	ldi	r27, 0x0A	; 10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    273c:	81 91       	ld	r24, Z+
    273e:	8d 93       	st	X+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2740:	8b e0       	ldi	r24, 0x0B	; 11
    2742:	ee 32       	cpi	r30, 0x2E	; 46
    2744:	f8 07       	cpc	r31, r24
    2746:	d1 f7       	brne	.-12     	; 0x273c <ScanEDCFlow+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2748:	10 92 16 0a 	sts	0x0A16, r1
    274c:	a2 e6       	ldi	r26, 0x62	; 98
    274e:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2750:	81 91       	ld	r24, Z+
    2752:	8d 93       	st	X+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2754:	8b e0       	ldi	r24, 0x0B	; 11
    2756:	e8 33       	cpi	r30, 0x38	; 56
    2758:	f8 07       	cpc	r31, r24
    275a:	d1 f7       	brne	.-12     	; 0x2750 <ScanEDCFlow+0x156>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    275c:	10 92 6c 09 	sts	0x096C, r1
    2760:	a7 ec       	ldi	r26, 0xC7	; 199
    2762:	bd e0       	ldi	r27, 0x0D	; 13
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2764:	81 91       	ld	r24, Z+
    2766:	8d 93       	st	X+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2768:	8b e0       	ldi	r24, 0x0B	; 11
    276a:	e6 34       	cpi	r30, 0x46	; 70
    276c:	f8 07       	cpc	r31, r24
    276e:	d1 f7       	brne	.-12     	; 0x2764 <ScanEDCFlow+0x16a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2770:	10 92 d5 0d 	sts	0x0DD5, r1
	    }else
		 if (EDCMsgCode==0x04){
             StrPosCopy(rcv_trans,strApprovalCode,3,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,9,10);
             StrPosCopy(rcv_trans,strDateTime,19,14);
			 IsVoidTransaction=True;
    2774:	81 e0       	ldi	r24, 0x01	; 1
    2776:	80 93 c7 01 	sts	0x01C7, r24
    277a:	08 95       	ret

0000277c <ScanHiddenKeyFlow>:
	    }
    }//MSGDetection
}

void ScanHiddenKeyFlow(char KeyIn){
}
    277c:	08 95       	ret

0000277e <ScanRFIDFlow>:


void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
    277e:	98 2f       	mov	r25, r24
    2780:	e4 ea       	ldi	r30, 0xA4	; 164
    2782:	fa e0       	ldi	r31, 0x0A	; 10
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
        strSerialFlow[19-i]=strSerialFlow[18-i];   
    2784:	80 81       	ld	r24, Z
    2786:	81 83       	std	Z+1, r24	; 0x01
    2788:	31 97       	sbiw	r30, 0x01	; 1

void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
    278a:	8a e0       	ldi	r24, 0x0A	; 10
    278c:	e1 39       	cpi	r30, 0x91	; 145
    278e:	f8 07       	cpc	r31, r24
    2790:	c9 f7       	brne	.-14     	; 0x2784 <ScanRFIDFlow+0x6>
        strSerialFlow[19-i]=strSerialFlow[18-i];   
	 }  strSerialFlow[0]=data;
    2792:	9f 01       	movw	r18, r30
    2794:	2f 5f       	subi	r18, 0xFF	; 255
    2796:	3f 4f       	sbci	r19, 0xFF	; 255
    2798:	91 83       	std	Z+1, r25	; 0x01
	 //Detection
	 if ((strSerialFlow[11]==0x02)&&(strSerialFlow[1]==0x0A)&&(strSerialFlow[0]==0x03)){
    279a:	84 85       	ldd	r24, Z+12	; 0x0c
    279c:	82 30       	cpi	r24, 0x02	; 2
    279e:	f9 f4       	brne	.+62     	; 0x27de <ScanRFIDFlow+0x60>
    27a0:	80 91 93 0a 	lds	r24, 0x0A93
    27a4:	8a 30       	cpi	r24, 0x0A	; 10
    27a6:	d9 f4       	brne	.+54     	; 0x27de <ScanRFIDFlow+0x60>
    27a8:	93 30       	cpi	r25, 0x03	; 3
    27aa:	c9 f4       	brne	.+50     	; 0x27de <ScanRFIDFlow+0x60>
    27ac:	f9 01       	movw	r30, r18
    27ae:	3a 96       	adiw	r30, 0x0a	; 10
    27b0:	ac e5       	ldi	r26, 0x5C	; 92
    27b2:	be e0       	ldi	r27, 0x0E	; 14
		for(i=0;i<8;i++) strRFID[i]=strSerialFlow[10-i];
    27b4:	80 81       	ld	r24, Z
    27b6:	8d 93       	st	X+, r24
    27b8:	31 97       	sbiw	r30, 0x01	; 1
    27ba:	8a e0       	ldi	r24, 0x0A	; 10
    27bc:	e4 39       	cpi	r30, 0x94	; 148
    27be:	f8 07       	cpc	r31, r24
    27c0:	c9 f7       	brne	.-14     	; 0x27b4 <ScanRFIDFlow+0x36>
        strRFID[8]=0;
    27c2:	10 92 64 0e 	sts	0x0E64, r1
	    IsRFIDDetected=True;
    27c6:	81 e0       	ldi	r24, 0x01	; 1
    27c8:	80 93 c4 01 	sts	0x01C4, r24
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    27cc:	80 93 e2 03 	sts	0x03E2, r24
    27d0:	10 92 e3 03 	sts	0x03E3, r1
    27d4:	80 91 65 00 	lds	r24, 0x0065
    27d8:	8d 7f       	andi	r24, 0xFD	; 253
    27da:	80 93 65 00 	sts	0x0065, r24
    27de:	08 95       	ret

000027e0 <__vector_18>:
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
}

ISR(USART0_RX_vect){
    27e0:	1f 92       	push	r1
    27e2:	0f 92       	push	r0
    27e4:	0f b6       	in	r0, 0x3f	; 63
    27e6:	0f 92       	push	r0
    27e8:	11 24       	eor	r1, r1
    27ea:	8f 93       	push	r24
    27ec:	9f 93       	push	r25
	char dataRX0,IsSPI=False;
	dataRX0= UDR0;
    27ee:	9c b1       	in	r25, 0x0c	; 12
	//PrintBusyDetection
	if ((IsBusyIdlePrinting==True)||(IsBusyFreePrinting==True)){
    27f0:	80 91 df 01 	lds	r24, 0x01DF
    27f4:	81 30       	cpi	r24, 0x01	; 1
    27f6:	21 f0       	breq	.+8      	; 0x2800 <__vector_18+0x20>
    27f8:	80 91 de 01 	lds	r24, 0x01DE
    27fc:	81 30       	cpi	r24, 0x01	; 1
    27fe:	51 f4       	brne	.+20     	; 0x2814 <__vector_18+0x34>
	    if (dataRX0==19)IsBusyPrint=True;
    2800:	93 31       	cpi	r25, 0x13	; 19
    2802:	21 f4       	brne	.+8      	; 0x280c <__vector_18+0x2c>
    2804:	81 e0       	ldi	r24, 0x01	; 1
    2806:	80 93 dd 01 	sts	0x01DD, r24
    280a:	04 c0       	rjmp	.+8      	; 0x2814 <__vector_18+0x34>
		else 
	    if (dataRX0==17)IsBusyPrint=False;	
    280c:	91 31       	cpi	r25, 0x11	; 17
    280e:	11 f4       	brne	.+4      	; 0x2814 <__vector_18+0x34>
    2810:	10 92 dd 01 	sts	0x01DD, r1
	}
}
    2814:	9f 91       	pop	r25
    2816:	8f 91       	pop	r24
    2818:	0f 90       	pop	r0
    281a:	0f be       	out	0x3f, r0	; 63
    281c:	0f 90       	pop	r0
    281e:	1f 90       	pop	r1
    2820:	18 95       	reti

00002822 <ScanCommand>:

char ScanCommand(char *strFlow,char *fCommand){
     char Result;
	 Result=False;
   return Result;
}
    2822:	80 e0       	ldi	r24, 0x00	; 0
    2824:	08 95       	ret

00002826 <system_beep>:
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    2826:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    2828:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    282a:	90 93 ec 01 	sts	0x01EC, r25
    282e:	80 93 eb 01 	sts	0x01EB, r24
}
    2832:	08 95       	ret

00002834 <systemRestart>:
	 iRestart=0;
	 while(iRestart<100){
	       strRestart[iRestart]=iRestart;
	       iRestart++;	 
	 }
}
    2834:	08 95       	ret

00002836 <Low>:

char Low(char X){
     char Result;
	 Result=(0x0F&X);
	 return Result;
}
    2836:	8f 70       	andi	r24, 0x0F	; 15
    2838:	08 95       	ret

0000283a <High>:
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
	 return Result;
}
    283a:	82 95       	swap	r24
    283c:	8f 70       	andi	r24, 0x0F	; 15
    283e:	08 95       	ret

00002840 <Str>:
char Str(char H){
    2840:	98 2f       	mov	r25, r24
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2842:	8a 30       	cpi	r24, 0x0A	; 10
    2844:	10 f4       	brcc	.+4      	; 0x284a <Str+0xa>
    2846:	80 5d       	subi	r24, 0xD0	; 208
    2848:	08 95       	ret
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    284a:	8a 50       	subi	r24, 0x0A	; 10
    284c:	86 30       	cpi	r24, 0x06	; 6
    284e:	10 f0       	brcs	.+4      	; 0x2854 <Str+0x14>
    2850:	80 e0       	ldi	r24, 0x00	; 0
    2852:	08 95       	ret
    2854:	89 2f       	mov	r24, r25
    2856:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}
    2858:	08 95       	ret

0000285a <charToHex>:

void charToHex(char X, char *Result){
    285a:	28 2f       	mov	r18, r24
    285c:	fb 01       	movw	r30, r22
	 Result=(0x0F&X);
	 return Result;
}
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
    285e:	98 2f       	mov	r25, r24
    2860:	92 95       	swap	r25
    2862:	9f 70       	andi	r25, 0x0F	; 15
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2864:	9a 30       	cpi	r25, 0x0A	; 10
    2866:	18 f4       	brcc	.+6      	; 0x286e <charToHex+0x14>
    2868:	89 2f       	mov	r24, r25
    286a:	80 5d       	subi	r24, 0xD0	; 208
    286c:	08 c0       	rjmp	.+16     	; 0x287e <charToHex+0x24>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    286e:	89 2f       	mov	r24, r25
    2870:	8a 50       	subi	r24, 0x0A	; 10
    2872:	86 30       	cpi	r24, 0x06	; 6
    2874:	10 f0       	brcs	.+4      	; 0x287a <charToHex+0x20>
    2876:	80 e0       	ldi	r24, 0x00	; 0
    2878:	02 c0       	rjmp	.+4      	; 0x287e <charToHex+0x24>
    287a:	89 2f       	mov	r24, r25
    287c:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
    287e:	80 83       	st	Z, r24



char Low(char X){
     char Result;
	 Result=(0x0F&X);
    2880:	92 2f       	mov	r25, r18
    2882:	9f 70       	andi	r25, 0x0F	; 15
	 Result=((X>>4)&(0x0F));
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2884:	9a 30       	cpi	r25, 0x0A	; 10
    2886:	18 f4       	brcc	.+6      	; 0x288e <charToHex+0x34>
    2888:	89 2f       	mov	r24, r25
    288a:	80 5d       	subi	r24, 0xD0	; 208
    288c:	08 c0       	rjmp	.+16     	; 0x289e <charToHex+0x44>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    288e:	89 2f       	mov	r24, r25
    2890:	8a 50       	subi	r24, 0x0A	; 10
    2892:	86 30       	cpi	r24, 0x06	; 6
    2894:	10 f0       	brcs	.+4      	; 0x289a <charToHex+0x40>
    2896:	80 e0       	ldi	r24, 0x00	; 0
    2898:	02 c0       	rjmp	.+4      	; 0x289e <charToHex+0x44>
    289a:	89 2f       	mov	r24, r25
    289c:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
	 Result[1]=Str(Low(X));
    289e:	81 83       	std	Z+1, r24	; 0x01
	 Result[2]=0;
    28a0:	12 82       	std	Z+2, r1	; 0x02
	 
}
    28a2:	08 95       	ret

000028a4 <strToInt>:

char strToInt(char *str){
    28a4:	fc 01       	movw	r30, r24
     char Result;
     Result=(((str[0]-'0')*10) +(str[0]-'0'));
    28a6:	80 81       	ld	r24, Z
    28a8:	2a e0       	ldi	r18, 0x0A	; 10
    28aa:	82 9f       	mul	r24, r18
    28ac:	90 01       	movw	r18, r0
    28ae:	11 24       	eor	r1, r1
    28b0:	80 51       	subi	r24, 0x10	; 16
	 return Result;
}
    28b2:	82 0f       	add	r24, r18
    28b4:	08 95       	ret

000028b6 <intToStr>:

void intToStr(char X, char *str){
    28b6:	58 2f       	mov	r21, r24
    28b8:	fb 01       	movw	r30, r22
     char R,P,S;
	 R=X/100;
    28ba:	64 e6       	ldi	r22, 0x64	; 100
    28bc:	0e 94 a3 b7 	call	0x16f46	; 0x16f46 <__udivmodqi4>
    28c0:	a8 2f       	mov	r26, r24
	 P=(X%100)/10;
    28c2:	85 2f       	mov	r24, r21
    28c4:	0e 94 a3 b7 	call	0x16f46	; 0x16f46 <__udivmodqi4>
    28c8:	89 2f       	mov	r24, r25
    28ca:	6a e0       	ldi	r22, 0x0A	; 10
    28cc:	0e 94 a3 b7 	call	0x16f46	; 0x16f46 <__udivmodqi4>
    28d0:	48 2f       	mov	r20, r24
	 S=X-(R*100)-(P*10);
    28d2:	8c e9       	ldi	r24, 0x9C	; 156
    28d4:	9f ef       	ldi	r25, 0xFF	; 255
    28d6:	a8 9f       	mul	r26, r24
    28d8:	80 2d       	mov	r24, r0
    28da:	11 24       	eor	r1, r1
    28dc:	85 0f       	add	r24, r21
    28de:	26 ef       	ldi	r18, 0xF6	; 246
    28e0:	3f ef       	ldi	r19, 0xFF	; 255
    28e2:	42 9f       	mul	r20, r18
    28e4:	90 2d       	mov	r25, r0
    28e6:	11 24       	eor	r1, r1
    28e8:	98 0f       	add	r25, r24
	 if (X>=100){
    28ea:	54 36       	cpi	r21, 0x64	; 100
    28ec:	40 f0       	brcs	.+16     	; 0x28fe <intToStr+0x48>
	     str[0]=('0'+R);
    28ee:	a0 5d       	subi	r26, 0xD0	; 208
    28f0:	a0 83       	st	Z, r26
	     str[1]=('0'+P);
    28f2:	40 5d       	subi	r20, 0xD0	; 208
    28f4:	41 83       	std	Z+1, r20	; 0x01
	     str[2]=('0'+S);
    28f6:	90 5d       	subi	r25, 0xD0	; 208
    28f8:	92 83       	std	Z+2, r25	; 0x02
	     str[3]=0;
    28fa:	13 82       	std	Z+3, r1	; 0x03
    28fc:	08 95       	ret
	 if ((X>=10)&&(X>100)){
	     str[0]=('0'+P);
	     str[1]=('0'+S);
	     str[2]=0;
	 }else 
	 if (X<=10){
    28fe:	5b 30       	cpi	r21, 0x0B	; 11
    2900:	18 f4       	brcc	.+6      	; 0x2908 <intToStr+0x52>
	     str[0]=('0'+S);
    2902:	90 5d       	subi	r25, 0xD0	; 208
    2904:	90 83       	st	Z, r25
	     str[1]=0;
    2906:	11 82       	std	Z+1, r1	; 0x01
    2908:	08 95       	ret

0000290a <ViewCardID>:
	    if (i<(20-LengthID))strCardID[i]=' ';
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;     
}

void ViewCardID(){//+12345678 -->12345678
    290a:	20 e0       	ldi	r18, 0x00	; 0
    290c:	30 e0       	ldi	r19, 0x00	; 0
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
    290e:	f9 01       	movw	r30, r18
    2910:	ef 56       	subi	r30, 0x6F	; 111
    2912:	f2 4f       	sbci	r31, 0xF2	; 242
    2914:	d9 01       	movw	r26, r18
    2916:	a4 5a       	subi	r26, 0xA4	; 164
    2918:	b1 4f       	sbci	r27, 0xF1	; 241
    291a:	8c 91       	ld	r24, X
    291c:	80 83       	st	Z, r24
    291e:	2f 5f       	subi	r18, 0xFF	; 255
    2920:	3f 4f       	sbci	r19, 0xFF	; 255
	 }strCardID[20]=0;     
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
    2922:	28 30       	cpi	r18, 0x08	; 8
    2924:	31 05       	cpc	r19, r1
    2926:	99 f7       	brne	.-26     	; 0x290e <ViewCardID+0x4>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
    2928:	10 92 99 0d 	sts	0x0D99, r1
}
    292c:	08 95       	ret

0000292e <StringCopy>:
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
    292e:	cf 93       	push	r28
    2930:	df 93       	push	r29
    2932:	db 01       	movw	r26, r22
    2934:	ec 01       	movw	r28, r24
    2936:	20 e0       	ldi	r18, 0x00	; 0
    2938:	30 e0       	ldi	r19, 0x00	; 0
    293a:	07 c0       	rjmp	.+14     	; 0x294a <StringCopy+0x1c>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
    293c:	fd 01       	movw	r30, r26
    293e:	e2 0f       	add	r30, r18
    2940:	f3 1f       	adc	r31, r19
    2942:	89 91       	ld	r24, Y+
    2944:	80 83       	st	Z, r24
    2946:	2f 5f       	subi	r18, 0xFF	; 255
    2948:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
    294a:	24 17       	cp	r18, r20
    294c:	b8 f3       	brcs	.-18     	; 0x293c <StringCopy+0xe>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
    294e:	a4 0f       	add	r26, r20
    2950:	b1 1d       	adc	r27, r1
    2952:	1c 92       	st	X, r1
}
    2954:	df 91       	pop	r29
    2956:	cf 91       	pop	r28
    2958:	08 95       	ret

0000295a <StringCopyPos>:
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
    295a:	cf 93       	push	r28
    295c:	df 93       	push	r29
    295e:	db 01       	movw	r26, r22
    2960:	ec 01       	movw	r28, r24
    2962:	c4 0f       	add	r28, r20
    2964:	d1 1d       	adc	r29, r1
    2966:	40 e0       	ldi	r20, 0x00	; 0
    2968:	50 e0       	ldi	r21, 0x00	; 0
    296a:	07 c0       	rjmp	.+14     	; 0x297a <StringCopyPos+0x20>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
    296c:	fd 01       	movw	r30, r26
    296e:	e4 0f       	add	r30, r20
    2970:	f5 1f       	adc	r31, r21
    2972:	89 91       	ld	r24, Y+
    2974:	80 83       	st	Z, r24
    2976:	4f 5f       	subi	r20, 0xFF	; 255
    2978:	5f 4f       	sbci	r21, 0xFF	; 255
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
    297a:	42 17       	cp	r20, r18
    297c:	b8 f3       	brcs	.-18     	; 0x296c <StringCopyPos+0x12>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
    297e:	a2 0f       	add	r26, r18
    2980:	b1 1d       	adc	r27, r1
    2982:	1c 92       	st	X, r1
}
    2984:	df 91       	pop	r29
    2986:	cf 91       	pop	r28
    2988:	08 95       	ret

0000298a <TestLocalAccount>:

void TestLocalAccount(){

}
    298a:	08 95       	ret

0000298c <BackLightTrig>:
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    298c:	81 e0       	ldi	r24, 0x01	; 1
    298e:	80 93 e2 03 	sts	0x03E2, r24
    2992:	10 92 e3 03 	sts	0x03E3, r1
    2996:	e5 e6       	ldi	r30, 0x65	; 101
    2998:	f0 e0       	ldi	r31, 0x00	; 0
    299a:	80 81       	ld	r24, Z
    299c:	8d 7f       	andi	r24, 0xFD	; 253
    299e:	80 83       	st	Z, r24
}
    29a0:	08 95       	ret

000029a2 <FBackLight>:

void FBackLight(){
     if (TimBackLight>0){
    29a2:	20 91 b7 01 	lds	r18, 0x01B7
    29a6:	30 91 b8 01 	lds	r19, 0x01B8
    29aa:	21 15       	cp	r18, r1
    29ac:	31 05       	cpc	r19, r1
    29ae:	61 f0       	breq	.+24     	; 0x29c8 <FBackLight+0x26>
	     PORTG=PORTG&0xFD;
    29b0:	80 91 65 00 	lds	r24, 0x0065
    29b4:	8d 7f       	andi	r24, 0xFD	; 253
    29b6:	80 93 65 00 	sts	0x0065, r24
	     TimBackLight--;
    29ba:	21 50       	subi	r18, 0x01	; 1
    29bc:	30 40       	sbci	r19, 0x00	; 0
    29be:	30 93 b8 01 	sts	0x01B8, r19
    29c2:	20 93 b7 01 	sts	0x01B7, r18
    29c6:	08 95       	ret
		 }
	 else PORTG=PORTG|0x02;
    29c8:	80 91 65 00 	lds	r24, 0x0065
    29cc:	82 60       	ori	r24, 0x02	; 2
    29ce:	80 93 65 00 	sts	0x0065, r24
    29d2:	08 95       	ret

000029d4 <GetBaudrate>:
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    29d4:	82 30       	cpi	r24, 0x02	; 2
    29d6:	59 f0       	breq	.+22     	; 0x29ee <GetBaudrate+0x1a>
    29d8:	82 30       	cpi	r24, 0x02	; 2
    29da:	18 f0       	brcs	.+6      	; 0x29e2 <GetBaudrate+0xe>
    29dc:	83 30       	cpi	r24, 0x03	; 3
    29de:	21 f4       	brne	.+8      	; 0x29e8 <GetBaudrate+0x14>
    29e0:	09 c0       	rjmp	.+18     	; 0x29f4 <GetBaudrate+0x20>
    29e2:	20 e8       	ldi	r18, 0x80	; 128
    29e4:	35 e2       	ldi	r19, 0x25	; 37
    29e6:	08 c0       	rjmp	.+16     	; 0x29f8 <GetBaudrate+0x24>
    29e8:	20 e0       	ldi	r18, 0x00	; 0
    29ea:	30 e0       	ldi	r19, 0x00	; 0
    29ec:	05 c0       	rjmp	.+10     	; 0x29f8 <GetBaudrate+0x24>
    29ee:	20 e0       	ldi	r18, 0x00	; 0
    29f0:	3b e4       	ldi	r19, 0x4B	; 75
    29f2:	02 c0       	rjmp	.+4      	; 0x29f8 <GetBaudrate+0x24>
	 case br9600: 
	      Result=9600;
	      break;
	 case br19200:
	      Result=19200;
	      break;
    29f4:	2b e9       	ldi	r18, 0x9B	; 155
    29f6:	36 e1       	ldi	r19, 0x16	; 22
	 case br5787:
	      Result=5787;
     	  break;	 
	 }
   return Result;
}
    29f8:	c9 01       	movw	r24, r18
    29fa:	08 95       	ret

000029fc <InitMemory>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    29fc:	e1 99       	sbic	0x1c, 1	; 28
    29fe:	fe cf       	rjmp	.-4      	; 0x29fc <InitMemory>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2a00:	84 e7       	ldi	r24, 0x74	; 116
    2a02:	91 e0       	ldi	r25, 0x01	; 1
    2a04:	9f bb       	out	0x1f, r25	; 31
    2a06:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2a08:	e0 9a       	sbi	0x1c, 0	; 28
    2a0a:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    2a0c:	80 93 75 01 	sts	0x0175, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2a10:	e1 99       	sbic	0x1c, 1	; 28
    2a12:	fe cf       	rjmp	.-4      	; 0x2a10 <InitMemory+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2a14:	89 e7       	ldi	r24, 0x79	; 121
    2a16:	91 e0       	ldi	r25, 0x01	; 1
    2a18:	9f bb       	out	0x1f, r25	; 31
    2a1a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2a1c:	e0 9a       	sbi	0x1c, 0	; 28
    2a1e:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    2a20:	80 93 76 01 	sts	0x0176, r24
}
    2a24:	08 95       	ret

00002a26 <DisplayQueueFIP>:
}


void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}
    2a26:	08 95       	ret

00002a28 <ShowMessage>:
	 }
}

void ShowMessage(char *Message){//Display Message on Line3
     char i;
}
    2a28:	08 95       	ret

00002a2a <CalcLRC>:

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}
    2a2a:	86 27       	eor	r24, r22
    2a2c:	08 95       	ret

00002a2e <systemEDC>:
}

void systemEDC(){//EDC Handler
     

}
    2a2e:	08 95       	ret

00002a30 <GeniusCalc>:
}


char GeniusCalc(char cOption, char valA, char valB){
     char valC_H,valC_L,xValA,xValB,Result;
     switch(cOption){
    2a30:	88 23       	and	r24, r24
    2a32:	19 f0       	breq	.+6      	; 0x2a3a <GeniusCalc+0xa>
    2a34:	81 30       	cpi	r24, 0x01	; 1
    2a36:	49 f5       	brne	.+82     	; 0x2a8a <GeniusCalc+0x5a>
    2a38:	11 c0       	rjmp	.+34     	; 0x2a5c <GeniusCalc+0x2c>
	 case G_PLUS:                  // 5 + 8 = 1 + 3 = 4
	      valC_H=(valA+valB)/10;   //  
    2a3a:	26 2f       	mov	r18, r22
    2a3c:	30 e0       	ldi	r19, 0x00	; 0
    2a3e:	24 0f       	add	r18, r20
    2a40:	31 1d       	adc	r19, r1
		  valC_L=(valA+valB)%10;   //
	      Result=valC_H+valC_L;
    2a42:	c9 01       	movw	r24, r18
    2a44:	6a e0       	ldi	r22, 0x0A	; 10
    2a46:	70 e0       	ldi	r23, 0x00	; 0
    2a48:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    2a4c:	48 2f       	mov	r20, r24
    2a4e:	c9 01       	movw	r24, r18
    2a50:	6a e0       	ldi	r22, 0x0A	; 10
    2a52:	70 e0       	ldi	r23, 0x00	; 0
    2a54:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    2a58:	46 0f       	add	r20, r22
    2a5a:	17 c0       	rjmp	.+46     	; 0x2a8a <GeniusCalc+0x5a>
	      break;
	 case G_MULTY:                 
	      if (valA>0)xValA=valA;
    2a5c:	66 23       	and	r22, r22
    2a5e:	09 f4       	brne	.+2      	; 0x2a62 <GeniusCalc+0x32>
    2a60:	61 e0       	ldi	r22, 0x01	; 1
		  else xValA=1;
	      if (valB>0)xValB=valB;
    2a62:	44 23       	and	r20, r20
    2a64:	09 f4       	brne	.+2      	; 0x2a68 <GeniusCalc+0x38>
    2a66:	41 e0       	ldi	r20, 0x01	; 1
		  else xValB=1;
	      valC_H=(xValA*xValB)/10;   //  
    2a68:	46 9f       	mul	r20, r22
    2a6a:	90 01       	movw	r18, r0
    2a6c:	11 24       	eor	r1, r1
    2a6e:	c9 01       	movw	r24, r18
    2a70:	6a e0       	ldi	r22, 0x0A	; 10
    2a72:	70 e0       	ldi	r23, 0x00	; 0
    2a74:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    2a78:	46 2f       	mov	r20, r22
		  valC_L=(xValA*xValB)%10;   //
    2a7a:	c9 01       	movw	r24, r18
    2a7c:	6a e0       	ldi	r22, 0x0A	; 10
    2a7e:	70 e0       	ldi	r23, 0x00	; 0
    2a80:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    2a84:	64 2f       	mov	r22, r20
    2a86:	48 2f       	mov	r20, r24
    2a88:	d8 cf       	rjmp	.-80     	; 0x2a3a <GeniusCalc+0xa>
	 case G_MINUS:
	      
	      break;
	 }
   return Result;
}
    2a8a:	84 2f       	mov	r24, r20
    2a8c:	08 95       	ret

00002a8e <FSubMenuAdmin>:

char FSubMenuAdmin(){
     char Result;
	 Result=MENU_DONE;
   return Result;
}
    2a8e:	81 e0       	ldi	r24, 0x01	; 1
    2a90:	08 95       	ret

00002a92 <CountNoPumpSatus>:
	      break;	 
	 } 
   return Result;
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
    2a92:	ff 92       	push	r15
    2a94:	0f 93       	push	r16
    2a96:	1f 93       	push	r17
    2a98:	cf 93       	push	r28
    2a9a:	df 93       	push	r29
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2a9c:	f0 90 75 01 	lds	r15, 0x0175
    2aa0:	ec 01       	movw	r28, r24
    2aa2:	00 e0       	ldi	r16, 0x00	; 0
    2aa4:	10 e0       	ldi	r17, 0x00	; 0
    2aa6:	09 c0       	rjmp	.+18     	; 0x2aba <CountNoPumpSatus+0x28>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
    2aa8:	8e e0       	ldi	r24, 0x0E	; 14
    2aaa:	0e 94 c2 12 	call	0x2584	; 0x2584 <GetPumpStatusLabel>
    2aae:	98 81       	ld	r25, Y
    2ab0:	98 17       	cp	r25, r24
    2ab2:	09 f4       	brne	.+2      	; 0x2ab6 <CountNoPumpSatus+0x24>
		      Result++;		  
    2ab4:	1f 5f       	subi	r17, 0xFF	; 255
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2ab6:	0f 5f       	subi	r16, 0xFF	; 255
    2ab8:	21 96       	adiw	r28, 0x01	; 1
    2aba:	0f 15       	cp	r16, r15
    2abc:	a8 f3       	brcs	.-22     	; 0x2aa8 <CountNoPumpSatus+0x16>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    2abe:	81 2f       	mov	r24, r17
    2ac0:	df 91       	pop	r29
    2ac2:	cf 91       	pop	r28
    2ac4:	1f 91       	pop	r17
    2ac6:	0f 91       	pop	r16
    2ac8:	ff 90       	pop	r15
    2aca:	08 95       	ret

00002acc <FCloseDay>:
   return Result;
}

char FCloseDay(){

}
    2acc:	08 95       	ret

00002ace <FLockPump>:
char FLockPump(){

}
    2ace:	08 95       	ret

00002ad0 <menu_product>:
   return Result;
}

void menu_product(){

}
    2ad0:	08 95       	ret

00002ad2 <IncValue>:
            lcd_print(xPos,yPos,strLabel);
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
    2ad2:	fc 01       	movw	r30, r24
     if ((*Value)<MaxValue){
    2ad4:	80 81       	ld	r24, Z
    2ad6:	84 17       	cp	r24, r20
    2ad8:	18 f4       	brcc	.+6      	; 0x2ae0 <IncValue+0xe>
	     (*Value)++;
    2ada:	8f 5f       	subi	r24, 0xFF	; 255
    2adc:	80 83       	st	Z, r24
    2ade:	08 95       	ret
	 }else *Value=MinValue;
    2ae0:	60 83       	st	Z, r22
    2ae2:	08 95       	ret

00002ae4 <DecValue>:
}

void DecValue(char *Value,char MinValue,char MaxValue){
    2ae4:	fc 01       	movw	r30, r24
     if ((*Value)>MinValue){
    2ae6:	80 81       	ld	r24, Z
    2ae8:	68 17       	cp	r22, r24
    2aea:	18 f4       	brcc	.+6      	; 0x2af2 <DecValue+0xe>
	     (*Value)--;
    2aec:	81 50       	subi	r24, 0x01	; 1
    2aee:	80 83       	st	Z, r24
    2af0:	08 95       	ret
	 }else *Value=MaxValue;
    2af2:	40 83       	st	Z, r20
    2af4:	08 95       	ret

00002af6 <zeroIP>:
	if(__result==0)
		eeprom_write_block((const void*) &__buf_string, (void*) &__opp_name, _MAX_OPP + 1);
}


void zeroIP(unsigned char Val,char *StrResult){
    2af6:	58 2f       	mov	r21, r24
    2af8:	fb 01       	movw	r30, r22
     unsigned char R,P,S;
	 if (Val>=100){
    2afa:	84 36       	cpi	r24, 0x64	; 100
    2afc:	00 f1       	brcs	.+64     	; 0x2b3e <zeroIP+0x48>
	    R=(Val/100);
    2afe:	64 e6       	ldi	r22, 0x64	; 100
    2b00:	0e 94 a3 b7 	call	0x16f46	; 0x16f46 <__udivmodqi4>
    2b04:	48 2f       	mov	r20, r24
        P=((Val%100)/10);
    2b06:	85 2f       	mov	r24, r21
    2b08:	0e 94 a3 b7 	call	0x16f46	; 0x16f46 <__udivmodqi4>
    2b0c:	89 2f       	mov	r24, r25
    2b0e:	6a e0       	ldi	r22, 0x0A	; 10
    2b10:	0e 94 a3 b7 	call	0x16f46	; 0x16f46 <__udivmodqi4>
		S=Val-((R*100)+(P*10)); 
        StrResult[0]='0'+R;//+(Val/100);
    2b14:	40 5d       	subi	r20, 0xD0	; 208
    2b16:	40 83       	st	Z, r20
    2b18:	40 53       	subi	r20, 0x30	; 48
	    StrResult[1]='0'+P;//+((Val%100)/10);
    2b1a:	80 5d       	subi	r24, 0xD0	; 208
    2b1c:	81 83       	std	Z+1, r24	; 0x01
    2b1e:	80 53       	subi	r24, 0x30	; 48
		StrResult[2]='0'+S;//+(Val-((Val/100)*100)-((Val%100)/10));
    2b20:	50 5d       	subi	r21, 0xD0	; 208
    2b22:	2c e9       	ldi	r18, 0x9C	; 156
    2b24:	3f ef       	ldi	r19, 0xFF	; 255
    2b26:	42 9f       	mul	r20, r18
    2b28:	40 2d       	mov	r20, r0
    2b2a:	11 24       	eor	r1, r1
    2b2c:	45 0f       	add	r20, r21
    2b2e:	26 ef       	ldi	r18, 0xF6	; 246
    2b30:	3f ef       	ldi	r19, 0xFF	; 255
    2b32:	82 9f       	mul	r24, r18
    2b34:	80 2d       	mov	r24, r0
    2b36:	11 24       	eor	r1, r1
    2b38:	84 0f       	add	r24, r20
    2b3a:	82 83       	std	Z+2, r24	; 0x02
    2b3c:	10 c0       	rjmp	.+32     	; 0x2b5e <zeroIP+0x68>
		StrResult[3]=0;
		}else     
	 if ((Val>=10)&&(Val<100)){
    2b3e:	8a 50       	subi	r24, 0x0A	; 10
    2b40:	8a 35       	cpi	r24, 0x5A	; 90
    2b42:	78 f4       	brcc	.+30     	; 0x2b62 <zeroIP+0x6c>
        StrResult[0]='0';
    2b44:	80 e3       	ldi	r24, 0x30	; 48
    2b46:	80 83       	st	Z, r24
	    StrResult[1]=('0'+(Val/10));
    2b48:	85 2f       	mov	r24, r21
    2b4a:	6a e0       	ldi	r22, 0x0A	; 10
    2b4c:	0e 94 a3 b7 	call	0x16f46	; 0x16f46 <__udivmodqi4>
    2b50:	80 5d       	subi	r24, 0xD0	; 208
    2b52:	81 83       	std	Z+1, r24	; 0x01
		StrResult[2]=('0'+(Val%10));
    2b54:	85 2f       	mov	r24, r21
    2b56:	0e 94 a3 b7 	call	0x16f46	; 0x16f46 <__udivmodqi4>
    2b5a:	90 5d       	subi	r25, 0xD0	; 208
    2b5c:	92 83       	std	Z+2, r25	; 0x02
		StrResult[3]=0;
    2b5e:	13 82       	std	Z+3, r1	; 0x03
    2b60:	08 95       	ret
		}
     else
	 if (Val<10){
    2b62:	5a 30       	cpi	r21, 0x0A	; 10
    2b64:	30 f4       	brcc	.+12     	; 0x2b72 <zeroIP+0x7c>
	    StrResult[0]='0';
    2b66:	80 e3       	ldi	r24, 0x30	; 48
    2b68:	80 83       	st	Z, r24
		StrResult[1]='0';
    2b6a:	81 83       	std	Z+1, r24	; 0x01
	    StrResult[2]='0'+Val;
    2b6c:	50 5d       	subi	r21, 0xD0	; 208
    2b6e:	52 83       	std	Z+2, r21	; 0x02
	    StrResult[3]=0;
    2b70:	13 82       	std	Z+3, r1	; 0x03
    2b72:	08 95       	ret

00002b74 <GetLocAccStatus>:


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
    2b74:	81 30       	cpi	r24, 0x01	; 1
    2b76:	29 f0       	breq	.+10     	; 0x2b82 <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
    2b78:	82 30       	cpi	r24, 0x02	; 2
    2b7a:	19 f0       	breq	.+6      	; 0x2b82 <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
    2b7c:	83 30       	cpi	r24, 0x03	; 3
    2b7e:	09 f0       	breq	.+2      	; 0x2b82 <GetLocAccStatus+0xe>
    2b80:	80 e0       	ldi	r24, 0x00	; 0
	 return Result;
}
    2b82:	08 95       	ret

00002b84 <StrPosCopy>:
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2b84:	cf 93       	push	r28
    2b86:	df 93       	push	r29
    2b88:	eb 01       	movw	r28, r22
    2b8a:	da 01       	movw	r26, r20
    2b8c:	a8 0f       	add	r26, r24
    2b8e:	b9 1f       	adc	r27, r25
    2b90:	40 e0       	ldi	r20, 0x00	; 0
    2b92:	50 e0       	ldi	r21, 0x00	; 0
    2b94:	07 c0       	rjmp	.+14     	; 0x2ba4 <StrPosCopy+0x20>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2b96:	fe 01       	movw	r30, r28
    2b98:	e4 0f       	add	r30, r20
    2b9a:	f5 1f       	adc	r31, r21
    2b9c:	8d 91       	ld	r24, X+
    2b9e:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ba0:	4f 5f       	subi	r20, 0xFF	; 255
    2ba2:	5f 4f       	sbci	r21, 0xFF	; 255
    2ba4:	42 17       	cp	r20, r18
    2ba6:	53 07       	cpc	r21, r19
    2ba8:	b0 f3       	brcs	.-20     	; 0x2b96 <StrPosCopy+0x12>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2baa:	c2 0f       	add	r28, r18
    2bac:	d3 1f       	adc	r29, r19
    2bae:	18 82       	st	Y, r1
}
    2bb0:	df 91       	pop	r29
    2bb2:	cf 91       	pop	r28
    2bb4:	08 95       	ret

00002bb6 <StrPosPaste>:
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2bb6:	0f 93       	push	r16
    2bb8:	1f 93       	push	r17
    2bba:	cf 93       	push	r28
    2bbc:	df 93       	push	r29
    2bbe:	8c 01       	movw	r16, r24
    2bc0:	db 01       	movw	r26, r22
    2bc2:	eb 01       	movw	r28, r22
    2bc4:	c4 0f       	add	r28, r20
    2bc6:	d5 1f       	adc	r29, r21
    2bc8:	60 e0       	ldi	r22, 0x00	; 0
    2bca:	70 e0       	ldi	r23, 0x00	; 0
    2bcc:	07 c0       	rjmp	.+14     	; 0x2bdc <StrPosPaste+0x26>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    2bce:	f8 01       	movw	r30, r16
    2bd0:	e6 0f       	add	r30, r22
    2bd2:	f7 1f       	adc	r31, r23
    2bd4:	80 81       	ld	r24, Z
    2bd6:	89 93       	st	Y+, r24
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2bd8:	6f 5f       	subi	r22, 0xFF	; 255
    2bda:	7f 4f       	sbci	r23, 0xFF	; 255
    2bdc:	62 17       	cp	r22, r18
    2bde:	73 07       	cpc	r23, r19
    2be0:	b0 f3       	brcs	.-20     	; 0x2bce <StrPosPaste+0x18>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    2be2:	a4 0f       	add	r26, r20
    2be4:	b5 1f       	adc	r27, r21
    2be6:	a2 0f       	add	r26, r18
    2be8:	b3 1f       	adc	r27, r19
    2bea:	1c 92       	st	X, r1
}
    2bec:	df 91       	pop	r29
    2bee:	cf 91       	pop	r28
    2bf0:	1f 91       	pop	r17
    2bf2:	0f 91       	pop	r16
    2bf4:	08 95       	ret

00002bf6 <CharPosCopy>:
char CharPosCopy(char *Source, unsigned int IdxSource){
    2bf6:	fb 01       	movw	r30, r22
    2bf8:	e8 0f       	add	r30, r24
    2bfa:	f9 1f       	adc	r31, r25
     char Result;
     Result=Source[IdxSource];
	 return Result;
}
    2bfc:	80 81       	ld	r24, Z
    2bfe:	08 95       	ret

00002c00 <procMessage00>:
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
    2c00:	80 91 25 0b 	lds	r24, 0x0B25
    2c04:	81 30       	cpi	r24, 0x01	; 1
    2c06:	51 f4       	brne	.+20     	; 0x2c1c <procMessage00+0x1c>
    2c08:	80 91 b3 01 	lds	r24, 0x01B3
    2c0c:	90 91 b4 01 	lds	r25, 0x01B4
    2c10:	8f 97       	sbiw	r24, 0x2f	; 47
    2c12:	21 f4       	brne	.+8      	; 0x2c1c <procMessage00+0x1c>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
    2c14:	80 91 4a 0b 	lds	r24, 0x0B4A
    2c18:	80 53       	subi	r24, 0x30	; 48
    2c1a:	08 95       	ret
    2c1c:	80 e0       	ldi	r24, 0x00	; 0
		 //sprintf(strSend,"R=%d",Result);
		 //_uart_print(0,1,strSend);
		 //*/
		 }
     return Result;
}
    2c1e:	08 95       	ret

00002c20 <procMessage09>:
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    2c20:	90 91 4c 0b 	lds	r25, 0x0B4C
    2c24:	20 e0       	ldi	r18, 0x00	; 0
    2c26:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2c28:	f9 01       	movw	r30, r18
    2c2a:	e9 53       	subi	r30, 0x39	; 57
    2c2c:	f5 4f       	sbci	r31, 0xF5	; 245
    2c2e:	d9 01       	movw	r26, r18
    2c30:	ab 5d       	subi	r26, 0xDB	; 219
    2c32:	b4 4f       	sbci	r27, 0xF4	; 244
    2c34:	97 96       	adiw	r26, 0x27	; 39
    2c36:	8c 91       	ld	r24, X
    2c38:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2c3a:	2f 5f       	subi	r18, 0xFF	; 255
    2c3c:	3f 4f       	sbci	r19, 0xFF	; 255
    2c3e:	24 31       	cpi	r18, 0x14	; 20
    2c40:	31 05       	cpc	r19, r1
    2c42:	91 f7       	brne	.-28     	; 0x2c28 <procMessage09+0x8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2c44:	10 92 db 0a 	sts	0x0ADB, r1
    2c48:	20 e0       	ldi	r18, 0x00	; 0
    2c4a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2c4c:	f9 01       	movw	r30, r18
    2c4e:	ee 54       	subi	r30, 0x4E	; 78
    2c50:	f6 4f       	sbci	r31, 0xF6	; 246
    2c52:	d9 01       	movw	r26, r18
    2c54:	ab 5d       	subi	r26, 0xDB	; 219
    2c56:	b4 4f       	sbci	r27, 0xF4	; 244
    2c58:	db 96       	adiw	r26, 0x3b	; 59
    2c5a:	8c 91       	ld	r24, X
    2c5c:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2c5e:	2f 5f       	subi	r18, 0xFF	; 255
    2c60:	3f 4f       	sbci	r19, 0xFF	; 255
    2c62:	24 31       	cpi	r18, 0x14	; 20
    2c64:	31 05       	cpc	r19, r1
    2c66:	91 f7       	brne	.-28     	; 0x2c4c <procMessage09+0x2c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2c68:	10 92 c6 09 	sts	0x09C6, r1
    2c6c:	20 e0       	ldi	r18, 0x00	; 0
    2c6e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2c70:	f9 01       	movw	r30, r18
    2c72:	e3 5b       	subi	r30, 0xB3	; 179
    2c74:	f5 4f       	sbci	r31, 0xF5	; 245
    2c76:	d9 01       	movw	r26, r18
    2c78:	ac 58       	subi	r26, 0x8C	; 140
    2c7a:	b4 4f       	sbci	r27, 0xF4	; 244
    2c7c:	8c 91       	ld	r24, X
    2c7e:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2c80:	2f 5f       	subi	r18, 0xFF	; 255
    2c82:	3f 4f       	sbci	r19, 0xFF	; 255
    2c84:	24 31       	cpi	r18, 0x14	; 20
    2c86:	31 05       	cpc	r19, r1
    2c88:	99 f7       	brne	.-26     	; 0x2c70 <procMessage09+0x50>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2c8a:	10 92 61 0a 	sts	0x0A61, r1
    2c8e:	20 e0       	ldi	r18, 0x00	; 0
    2c90:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2c92:	f9 01       	movw	r30, r18
    2c94:	ef 51       	subi	r30, 0x1F	; 31
    2c96:	f2 4f       	sbci	r31, 0xF2	; 242
    2c98:	d9 01       	movw	r26, r18
    2c9a:	a8 57       	subi	r26, 0x78	; 120
    2c9c:	b4 4f       	sbci	r27, 0xF4	; 244
    2c9e:	8c 91       	ld	r24, X
    2ca0:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ca2:	2f 5f       	subi	r18, 0xFF	; 255
    2ca4:	3f 4f       	sbci	r19, 0xFF	; 255
    2ca6:	24 31       	cpi	r18, 0x14	; 20
    2ca8:	31 05       	cpc	r19, r1
    2caa:	99 f7       	brne	.-26     	; 0x2c92 <procMessage09+0x72>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2cac:	10 92 f5 0d 	sts	0x0DF5, r1
       StrPosCopy(rcv_trans,strFreeMessageLine1,39,20);
       StrPosCopy(rcv_trans,strFreeMessageLine2,59,20);
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}
    2cb0:	89 2f       	mov	r24, r25
    2cb2:	80 53       	subi	r24, 0x30	; 48
    2cb4:	08 95       	ret

00002cb6 <procMessage23>:
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}

char procMessage23(){
    2cb6:	20 e0       	ldi	r18, 0x00	; 0
    2cb8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2cba:	f9 01       	movw	r30, r18
    2cbc:	ef 56       	subi	r30, 0x6F	; 111
    2cbe:	f2 4f       	sbci	r31, 0xF2	; 242
    2cc0:	d9 01       	movw	r26, r18
    2cc2:	ab 5d       	subi	r26, 0xDB	; 219
    2cc4:	b4 4f       	sbci	r27, 0xF4	; 244
    2cc6:	95 96       	adiw	r26, 0x25	; 37
    2cc8:	8c 91       	ld	r24, X
    2cca:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ccc:	2f 5f       	subi	r18, 0xFF	; 255
    2cce:	3f 4f       	sbci	r19, 0xFF	; 255
    2cd0:	24 31       	cpi	r18, 0x14	; 20
    2cd2:	31 05       	cpc	r19, r1
    2cd4:	91 f7       	brne	.-28     	; 0x2cba <procMessage23+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2cd6:	10 92 a5 0d 	sts	0x0DA5, r1
    2cda:	20 e0       	ldi	r18, 0x00	; 0
    2cdc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2cde:	f9 01       	movw	r30, r18
    2ce0:	e6 5d       	subi	r30, 0xD6	; 214
    2ce2:	fa 4f       	sbci	r31, 0xFA	; 250
    2ce4:	d9 01       	movw	r26, r18
    2ce6:	ab 5d       	subi	r26, 0xDB	; 219
    2ce8:	b4 4f       	sbci	r27, 0xF4	; 244
    2cea:	d9 96       	adiw	r26, 0x39	; 57
    2cec:	8c 91       	ld	r24, X
    2cee:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2cf0:	2f 5f       	subi	r18, 0xFF	; 255
    2cf2:	3f 4f       	sbci	r19, 0xFF	; 255
    2cf4:	2e 31       	cpi	r18, 0x1E	; 30
    2cf6:	31 05       	cpc	r19, r1
    2cf8:	91 f7       	brne	.-28     	; 0x2cde <procMessage23+0x28>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2cfa:	10 92 48 05 	sts	0x0548, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2cfe:	80 91 7c 0b 	lds	r24, 0x0B7C
    2d02:	80 93 90 05 	sts	0x0590, r24
	 }Dest[Length]=0;
    2d06:	10 92 91 05 	sts	0x0591, r1
    2d0a:	20 e0       	ldi	r18, 0x00	; 0
    2d0c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2d0e:	f9 01       	movw	r30, r18
    2d10:	ea 59       	subi	r30, 0x9A	; 154
    2d12:	f5 4f       	sbci	r31, 0xF5	; 245
    2d14:	d9 01       	movw	r26, r18
    2d16:	a3 58       	subi	r26, 0x83	; 131
    2d18:	b4 4f       	sbci	r27, 0xF4	; 244
    2d1a:	8c 91       	ld	r24, X
    2d1c:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2d1e:	2f 5f       	subi	r18, 0xFF	; 255
    2d20:	3f 4f       	sbci	r19, 0xFF	; 255
    2d22:	28 30       	cpi	r18, 0x08	; 8
    2d24:	31 05       	cpc	r19, r1
    2d26:	99 f7       	brne	.-26     	; 0x2d0e <procMessage23+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2d28:	10 92 6e 0a 	sts	0x0A6E, r1
    2d2c:	20 e0       	ldi	r18, 0x00	; 0
    2d2e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2d30:	f9 01       	movw	r30, r18
    2d32:	ec 57       	subi	r30, 0x7C	; 124
    2d34:	fa 4f       	sbci	r31, 0xFA	; 250
    2d36:	d9 01       	movw	r26, r18
    2d38:	ab 57       	subi	r26, 0x7B	; 123
    2d3a:	b4 4f       	sbci	r27, 0xF4	; 244
    2d3c:	8c 91       	ld	r24, X
    2d3e:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2d40:	2f 5f       	subi	r18, 0xFF	; 255
    2d42:	3f 4f       	sbci	r19, 0xFF	; 255
    2d44:	2a 30       	cpi	r18, 0x0A	; 10
    2d46:	31 05       	cpc	r19, r1
    2d48:	99 f7       	brne	.-26     	; 0x2d30 <procMessage23+0x7a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2d4a:	10 92 8e 05 	sts	0x058E, r1
    2d4e:	20 e0       	ldi	r18, 0x00	; 0
    2d50:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2d52:	f9 01       	movw	r30, r18
    2d54:	e8 50       	subi	r30, 0x08	; 8
    2d56:	f2 4f       	sbci	r31, 0xF2	; 242
    2d58:	d9 01       	movw	r26, r18
    2d5a:	a1 57       	subi	r26, 0x71	; 113
    2d5c:	b4 4f       	sbci	r27, 0xF4	; 244
    2d5e:	8c 91       	ld	r24, X
    2d60:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2d62:	2f 5f       	subi	r18, 0xFF	; 255
    2d64:	3f 4f       	sbci	r19, 0xFF	; 255
    2d66:	2a 30       	cpi	r18, 0x0A	; 10
    2d68:	31 05       	cpc	r19, r1
    2d6a:	99 f7       	brne	.-26     	; 0x2d52 <procMessage23+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2d6c:	10 92 02 0e 	sts	0x0E02, r1
    2d70:	20 e0       	ldi	r18, 0x00	; 0
    2d72:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2d74:	f9 01       	movw	r30, r18
    2d76:	e9 53       	subi	r30, 0x39	; 57
    2d78:	f2 4f       	sbci	r31, 0xF2	; 242
    2d7a:	d9 01       	movw	r26, r18
    2d7c:	a7 56       	subi	r26, 0x67	; 103
    2d7e:	b4 4f       	sbci	r27, 0xF4	; 244
    2d80:	8c 91       	ld	r24, X
    2d82:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2d84:	2f 5f       	subi	r18, 0xFF	; 255
    2d86:	3f 4f       	sbci	r19, 0xFF	; 255
    2d88:	23 31       	cpi	r18, 0x13	; 19
    2d8a:	31 05       	cpc	r19, r1
    2d8c:	99 f7       	brne	.-26     	; 0x2d74 <procMessage23+0xbe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2d8e:	10 92 da 0d 	sts	0x0DDA, r1
    2d92:	20 e0       	ldi	r18, 0x00	; 0
    2d94:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2d96:	f9 01       	movw	r30, r18
    2d98:	e5 54       	subi	r30, 0x45	; 69
    2d9a:	f2 4f       	sbci	r31, 0xF2	; 242
    2d9c:	d9 01       	movw	r26, r18
    2d9e:	a4 55       	subi	r26, 0x54	; 84
    2da0:	b4 4f       	sbci	r27, 0xF4	; 244
    2da2:	8c 91       	ld	r24, X
    2da4:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2da6:	2f 5f       	subi	r18, 0xFF	; 255
    2da8:	3f 4f       	sbci	r19, 0xFF	; 255
    2daa:	27 30       	cpi	r18, 0x07	; 7
    2dac:	31 05       	cpc	r19, r1
    2dae:	99 f7       	brne	.-26     	; 0x2d96 <procMessage23+0xe0>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2db0:	10 92 c2 0d 	sts	0x0DC2, r1
    2db4:	20 e0       	ldi	r18, 0x00	; 0
    2db6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2db8:	f9 01       	movw	r30, r18
    2dba:	ef 53       	subi	r30, 0x3F	; 63
    2dbc:	fb 4f       	sbci	r31, 0xFB	; 251
    2dbe:	d9 01       	movw	r26, r18
    2dc0:	ad 54       	subi	r26, 0x4D	; 77
    2dc2:	b4 4f       	sbci	r27, 0xF4	; 244
    2dc4:	8c 91       	ld	r24, X
    2dc6:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2dc8:	2f 5f       	subi	r18, 0xFF	; 255
    2dca:	3f 4f       	sbci	r19, 0xFF	; 255
    2dcc:	24 30       	cpi	r18, 0x04	; 4
    2dce:	31 05       	cpc	r19, r1
    2dd0:	99 f7       	brne	.-26     	; 0x2db8 <procMessage23+0x102>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2dd2:	10 92 c5 04 	sts	0x04C5, r1
     StrPosCopy(rcv_trans,strLoyCurrMonConsumeV,106,10);
     StrPosCopy(rcv_trans,strDateTime,116,19);
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}
    2dd6:	80 e0       	ldi	r24, 0x00	; 0
    2dd8:	08 95       	ret

00002dda <procMessage81>:
_uart_print(0,1,strCardID);
*/	
     return Result;
}

char procMessage81(){// Result: HFCS0000
    2dda:	cf 93       	push	r28
    2ddc:	df 93       	push	r29
     char Result=0,PrintCopy=0;//
	 char lcdteks[20];
	 //PrintHeader
     if ((CharPosCopy(rcv_trans,37))=='Y') Result=(Result|(1<<7));
    2dde:	80 91 4a 0b 	lds	r24, 0x0B4A
    2de2:	89 35       	cpi	r24, 0x59	; 89
    2de4:	11 f4       	brne	.+4      	; 0x2dea <procMessage81+0x10>
    2de6:	90 e8       	ldi	r25, 0x80	; 128
    2de8:	01 c0       	rjmp	.+2      	; 0x2dec <procMessage81+0x12>
    2dea:	90 e0       	ldi	r25, 0x00	; 0
     //PrintFooter
	 if ((CharPosCopy(rcv_trans,38))=='Y') Result=(Result|(1<<6));
    2dec:	80 91 4b 0b 	lds	r24, 0x0B4B
    2df0:	89 35       	cpi	r24, 0x59	; 89
    2df2:	09 f4       	brne	.+2      	; 0x2df6 <procMessage81+0x1c>
    2df4:	90 64       	ori	r25, 0x40	; 64
	 //PaperCut
     if ((CharPosCopy(rcv_trans,39))=='Y') Result=(Result|(1<<5));
    2df6:	80 91 4c 0b 	lds	r24, 0x0B4C
    2dfa:	89 35       	cpi	r24, 0x59	; 89
    2dfc:	09 f4       	brne	.+2      	; 0x2e00 <procMessage81+0x26>
    2dfe:	90 62       	ori	r25, 0x20	; 32
	 //Scrool
	 Result=(Result|(1<<4));
    2e00:	90 61       	ori	r25, 0x10	; 16

	 //Copies
	 PrintCopy=(CharPosCopy(rcv_trans,40)-'0');
    2e02:	80 91 4d 0b 	lds	r24, 0x0B4D
    2e06:	80 53       	subi	r24, 0x30	; 48
     if (PrintCopy<=16) Result=Result|PrintCopy;
    2e08:	81 31       	cpi	r24, 0x11	; 17
    2e0a:	08 f4       	brcc	.+2      	; 0x2e0e <procMessage81+0x34>
    2e0c:	98 2b       	or	r25, r24
	 //Spooling
     StrPosCopy(rcv_trans,PrintBuffer,44,LengthMessage81);
    2e0e:	c0 91 b5 01 	lds	r28, 0x01B5
    2e12:	d0 91 b6 01 	lds	r29, 0x01B6
    2e16:	20 e0       	ldi	r18, 0x00	; 0
    2e18:	30 e0       	ldi	r19, 0x00	; 0
    2e1a:	0b c0       	rjmp	.+22     	; 0x2e32 <procMessage81+0x58>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e1c:	f9 01       	movw	r30, r18
    2e1e:	e9 50       	subi	r30, 0x09	; 9
    2e20:	fa 4f       	sbci	r31, 0xFA	; 250
    2e22:	d9 01       	movw	r26, r18
    2e24:	ab 5d       	subi	r26, 0xDB	; 219
    2e26:	b4 4f       	sbci	r27, 0xF4	; 244
    2e28:	9c 96       	adiw	r26, 0x2c	; 44
    2e2a:	8c 91       	ld	r24, X
    2e2c:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e2e:	2f 5f       	subi	r18, 0xFF	; 255
    2e30:	3f 4f       	sbci	r19, 0xFF	; 255
    2e32:	2c 17       	cp	r18, r28
    2e34:	3d 07       	cpc	r19, r29
    2e36:	90 f3       	brcs	.-28     	; 0x2e1c <procMessage81+0x42>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e38:	c9 50       	subi	r28, 0x09	; 9
    2e3a:	da 4f       	sbci	r29, 0xFA	; 250
    2e3c:	18 82       	st	Y, r1
	 //sprintf(lcdteks,"cmdPrint:%d ",Result);
     //_uart_print(0,1,lcdteks);

	 //while(1){};
	 return Result;
}
    2e3e:	89 2f       	mov	r24, r25
    2e40:	df 91       	pop	r29
    2e42:	cf 91       	pop	r28
    2e44:	08 95       	ret

00002e46 <FillChar>:
	 if(CutType== 1) { _uart(_COM_PRINTER, 1, 0x6D);}
	 if(CutType== 2) {_uart(_COM_PRINTER, 1, 0x69);}

}

void FillChar(char *strMemory, unsigned int Length,char data){
    2e46:	20 e0       	ldi	r18, 0x00	; 0
    2e48:	30 e0       	ldi	r19, 0x00	; 0
    2e4a:	06 c0       	rjmp	.+12     	; 0x2e58 <FillChar+0x12>
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    2e4c:	fc 01       	movw	r30, r24
    2e4e:	e2 0f       	add	r30, r18
    2e50:	f3 1f       	adc	r31, r19
    2e52:	40 83       	st	Z, r20

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    2e54:	2f 5f       	subi	r18, 0xFF	; 255
    2e56:	3f 4f       	sbci	r19, 0xFF	; 255
    2e58:	26 17       	cp	r18, r22
    2e5a:	37 07       	cpc	r19, r23
    2e5c:	b8 f3       	brcs	.-18     	; 0x2e4c <FillChar+0x6>
	     strMemory[i]=data;
	 }
}
    2e5e:	08 95       	ret

00002e60 <ProcMessage91>:

void ProcMessage91(){
    2e60:	20 e0       	ldi	r18, 0x00	; 0
    2e62:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e64:	f9 01       	movw	r30, r18
    2e66:	ee 56       	subi	r30, 0x6E	; 110
    2e68:	f1 4f       	sbci	r31, 0xF1	; 241
    2e6a:	d9 01       	movw	r26, r18
    2e6c:	ab 5d       	subi	r26, 0xDB	; 219
    2e6e:	b4 4f       	sbci	r27, 0xF4	; 244
    2e70:	95 96       	adiw	r26, 0x25	; 37
    2e72:	8c 91       	ld	r24, X
    2e74:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e76:	2f 5f       	subi	r18, 0xFF	; 255
    2e78:	3f 4f       	sbci	r19, 0xFF	; 255
    2e7a:	26 30       	cpi	r18, 0x06	; 6
    2e7c:	31 05       	cpc	r19, r1
    2e7e:	91 f7       	brne	.-28     	; 0x2e64 <ProcMessage91+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e80:	10 92 98 0e 	sts	0x0E98, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e84:	80 91 50 0b 	lds	r24, 0x0B50
    2e88:	80 93 c8 09 	sts	0x09C8, r24
    2e8c:	80 91 51 0b 	lds	r24, 0x0B51
    2e90:	80 93 c9 09 	sts	0x09C9, r24
	 }Dest[Length]=0;
    2e94:	10 92 ca 09 	sts	0x09CA, r1
    2e98:	20 e0       	ldi	r18, 0x00	; 0
    2e9a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e9c:	f9 01       	movw	r30, r18
    2e9e:	e3 5c       	subi	r30, 0xC3	; 195
    2ea0:	f5 4f       	sbci	r31, 0xF5	; 245
    2ea2:	d9 01       	movw	r26, r18
    2ea4:	ab 5d       	subi	r26, 0xDB	; 219
    2ea6:	b4 4f       	sbci	r27, 0xF4	; 244
    2ea8:	9d 96       	adiw	r26, 0x2d	; 45
    2eaa:	8c 91       	ld	r24, X
    2eac:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2eae:	2f 5f       	subi	r18, 0xFF	; 255
    2eb0:	3f 4f       	sbci	r19, 0xFF	; 255
    2eb2:	2f 30       	cpi	r18, 0x0F	; 15
    2eb4:	31 05       	cpc	r19, r1
    2eb6:	91 f7       	brne	.-28     	; 0x2e9c <ProcMessage91+0x3c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2eb8:	10 92 4c 0a 	sts	0x0A4C, r1
    2ebc:	20 e0       	ldi	r18, 0x00	; 0
    2ebe:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ec0:	f9 01       	movw	r30, r18
    2ec2:	e3 55       	subi	r30, 0x53	; 83
    2ec4:	f8 4f       	sbci	r31, 0xF8	; 248
    2ec6:	d9 01       	movw	r26, r18
    2ec8:	ab 5d       	subi	r26, 0xDB	; 219
    2eca:	b4 4f       	sbci	r27, 0xF4	; 244
    2ecc:	dc 96       	adiw	r26, 0x3c	; 60
    2ece:	8c 91       	ld	r24, X
    2ed0:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ed2:	2f 5f       	subi	r18, 0xFF	; 255
    2ed4:	3f 4f       	sbci	r19, 0xFF	; 255
    2ed6:	26 30       	cpi	r18, 0x06	; 6
    2ed8:	31 05       	cpc	r19, r1
    2eda:	91 f7       	brne	.-28     	; 0x2ec0 <ProcMessage91+0x60>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2edc:	10 92 b3 07 	sts	0x07B3, r1
    2ee0:	20 e0       	ldi	r18, 0x00	; 0
    2ee2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ee4:	f9 01       	movw	r30, r18
    2ee6:	e5 58       	subi	r30, 0x85	; 133
    2ee8:	fa 4f       	sbci	r31, 0xFA	; 250
    2eea:	d9 01       	movw	r26, r18
    2eec:	a9 59       	subi	r26, 0x99	; 153
    2eee:	b4 4f       	sbci	r27, 0xF4	; 244
    2ef0:	8c 91       	ld	r24, X
    2ef2:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ef4:	2f 5f       	subi	r18, 0xFF	; 255
    2ef6:	3f 4f       	sbci	r19, 0xFF	; 255
    2ef8:	28 30       	cpi	r18, 0x08	; 8
    2efa:	31 05       	cpc	r19, r1
    2efc:	99 f7       	brne	.-26     	; 0x2ee4 <ProcMessage91+0x84>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2efe:	10 92 83 05 	sts	0x0583, r1
    2f02:	20 e0       	ldi	r18, 0x00	; 0
    2f04:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f06:	f9 01       	movw	r30, r18
    2f08:	e5 54       	subi	r30, 0x45	; 69
    2f0a:	f2 4f       	sbci	r31, 0xF2	; 242
    2f0c:	d9 01       	movw	r26, r18
    2f0e:	a1 59       	subi	r26, 0x91	; 145
    2f10:	b4 4f       	sbci	r27, 0xF4	; 244
    2f12:	8c 91       	ld	r24, X
    2f14:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f16:	2f 5f       	subi	r18, 0xFF	; 255
    2f18:	3f 4f       	sbci	r19, 0xFF	; 255
    2f1a:	28 30       	cpi	r18, 0x08	; 8
    2f1c:	31 05       	cpc	r19, r1
    2f1e:	99 f7       	brne	.-26     	; 0x2f06 <ProcMessage91+0xa6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f20:	10 92 c3 0d 	sts	0x0DC3, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f24:	80 91 77 0b 	lds	r24, 0x0B77
    2f28:	80 93 90 05 	sts	0x0590, r24
	 }Dest[Length]=0;
    2f2c:	10 92 91 05 	sts	0x0591, r1
    2f30:	20 e0       	ldi	r18, 0x00	; 0
    2f32:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f34:	f9 01       	movw	r30, r18
    2f36:	ee 5f       	subi	r30, 0xFE	; 254
    2f38:	fa 4f       	sbci	r31, 0xFA	; 250
    2f3a:	d9 01       	movw	r26, r18
    2f3c:	a8 58       	subi	r26, 0x88	; 136
    2f3e:	b4 4f       	sbci	r27, 0xF4	; 244
    2f40:	8c 91       	ld	r24, X
    2f42:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f44:	2f 5f       	subi	r18, 0xFF	; 255
    2f46:	3f 4f       	sbci	r19, 0xFF	; 255
    2f48:	29 30       	cpi	r18, 0x09	; 9
    2f4a:	31 05       	cpc	r19, r1
    2f4c:	99 f7       	brne	.-26     	; 0x2f34 <ProcMessage91+0xd4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f4e:	10 92 0b 05 	sts	0x050B, r1
     StrPosCopy(rcv_trans,strPrice,60,6);
     StrPosCopy(rcv_trans,strVolume,66,8);
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}
    2f52:	08 95       	ret

00002f54 <IdentifyMessage>:
        //sprintf_P(strSerial,PSTR("RFID:%s"),strRFID);
        //_uart_print(0,1,strSerial);
	 }
}

void IdentifyMessage(char STX,unsigned int Length){
    2f54:	1f 93       	push	r17
   if (STX==0x01){
    2f56:	81 30       	cpi	r24, 0x01	; 1
    2f58:	09 f0       	breq	.+2      	; 0x2f5c <IdentifyMessage+0x8>
    2f5a:	5f c0       	rjmp	.+190    	; 0x301a <IdentifyMessage+0xc6>
	    if ((Length==MSG00_LENGTH)||(MsgCode==0)) IsMessage00=True;//47
    2f5c:	6f 32       	cpi	r22, 0x2F	; 47
    2f5e:	71 05       	cpc	r23, r1
    2f60:	21 f0       	breq	.+8      	; 0x2f6a <IdentifyMessage+0x16>
    2f62:	80 91 39 01 	lds	r24, 0x0139
    2f66:	88 23       	and	r24, r24
    2f68:	21 f4       	brne	.+8      	; 0x2f72 <IdentifyMessage+0x1e>
    2f6a:	81 e0       	ldi	r24, 0x01	; 1
    2f6c:	80 93 cb 01 	sts	0x01CB, r24
    2f70:	4a c0       	rjmp	.+148    	; 0x3006 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG09_LENGTH)||(MsgCode==9)) IsMessage09=True;//615
    2f72:	6c 36       	cpi	r22, 0x6C	; 108
    2f74:	71 05       	cpc	r23, r1
    2f76:	11 f0       	breq	.+4      	; 0x2f7c <IdentifyMessage+0x28>
    2f78:	89 30       	cpi	r24, 0x09	; 9
    2f7a:	21 f4       	brne	.+8      	; 0x2f84 <IdentifyMessage+0x30>
    2f7c:	81 e0       	ldi	r24, 0x01	; 1
    2f7e:	80 93 d0 01 	sts	0x01D0, r24
    2f82:	41 c0       	rjmp	.+130    	; 0x3006 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG11_LENGTH)||(MsgCode==11)) IsMessage11=True;//615
    2f84:	92 e0       	ldi	r25, 0x02	; 2
    2f86:	67 36       	cpi	r22, 0x67	; 103
    2f88:	79 07       	cpc	r23, r25
    2f8a:	11 f0       	breq	.+4      	; 0x2f90 <IdentifyMessage+0x3c>
    2f8c:	8b 30       	cpi	r24, 0x0B	; 11
    2f8e:	21 f4       	brne	.+8      	; 0x2f98 <IdentifyMessage+0x44>
    2f90:	81 e0       	ldi	r24, 0x01	; 1
    2f92:	80 93 cd 01 	sts	0x01CD, r24
    2f96:	37 c0       	rjmp	.+110    	; 0x3006 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG23_LENGTH)||(MsgCode==23)) IsMessage23=True;//145
    2f98:	61 39       	cpi	r22, 0x91	; 145
    2f9a:	71 05       	cpc	r23, r1
    2f9c:	11 f0       	breq	.+4      	; 0x2fa2 <IdentifyMessage+0x4e>
    2f9e:	87 31       	cpi	r24, 0x17	; 23
    2fa0:	21 f4       	brne	.+8      	; 0x2faa <IdentifyMessage+0x56>
    2fa2:	81 e0       	ldi	r24, 0x01	; 1
    2fa4:	80 93 cf 01 	sts	0x01CF, r24
    2fa8:	2e c0       	rjmp	.+92     	; 0x3006 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG57_LENGTH)||(MsgCode==57)) IsMessage57=True;//230
    2faa:	66 3e       	cpi	r22, 0xE6	; 230
    2fac:	71 05       	cpc	r23, r1
    2fae:	11 f0       	breq	.+4      	; 0x2fb4 <IdentifyMessage+0x60>
    2fb0:	89 33       	cpi	r24, 0x39	; 57
    2fb2:	21 f4       	brne	.+8      	; 0x2fbc <IdentifyMessage+0x68>
    2fb4:	81 e0       	ldi	r24, 0x01	; 1
    2fb6:	80 93 d2 01 	sts	0x01D2, r24
    2fba:	25 c0       	rjmp	.+74     	; 0x3006 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG99_LENGTH)||(MsgCode==99)) IsMessage99=True;//378
    2fbc:	91 e0       	ldi	r25, 0x01	; 1
    2fbe:	68 39       	cpi	r22, 0x98	; 152
    2fc0:	79 07       	cpc	r23, r25
    2fc2:	11 f0       	breq	.+4      	; 0x2fc8 <IdentifyMessage+0x74>
    2fc4:	83 36       	cpi	r24, 0x63	; 99
    2fc6:	21 f4       	brne	.+8      	; 0x2fd0 <IdentifyMessage+0x7c>
    2fc8:	81 e0       	ldi	r24, 0x01	; 1
    2fca:	80 93 cc 01 	sts	0x01CC, r24
    2fce:	1b c0       	rjmp	.+54     	; 0x3006 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG81_LENGTH)||(MsgCode==81)) IsMessage81=True;//426
    2fd0:	91 e0       	ldi	r25, 0x01	; 1
    2fd2:	66 3b       	cpi	r22, 0xB6	; 182
    2fd4:	79 07       	cpc	r23, r25
    2fd6:	11 f0       	breq	.+4      	; 0x2fdc <IdentifyMessage+0x88>
    2fd8:	81 35       	cpi	r24, 0x51	; 81
    2fda:	21 f4       	brne	.+8      	; 0x2fe4 <IdentifyMessage+0x90>
    2fdc:	81 e0       	ldi	r24, 0x01	; 1
    2fde:	80 93 d3 01 	sts	0x01D3, r24
    2fe2:	11 c0       	rjmp	.+34     	; 0x3006 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG91_LENGTH)||(MsgCode==91)) IsMessage91=True;//426
    2fe4:	6c 35       	cpi	r22, 0x5C	; 92
    2fe6:	71 05       	cpc	r23, r1
    2fe8:	11 f0       	breq	.+4      	; 0x2fee <IdentifyMessage+0x9a>
    2fea:	8b 35       	cpi	r24, 0x5B	; 91
    2fec:	21 f4       	brne	.+8      	; 0x2ff6 <IdentifyMessage+0xa2>
    2fee:	81 e0       	ldi	r24, 0x01	; 1
    2ff0:	80 93 d4 01 	sts	0x01D4, r24
    2ff4:	08 c0       	rjmp	.+16     	; 0x3006 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG21_LENGTH)||(MsgCode==21)) IsMessage21=True;//426
    2ff6:	66 35       	cpi	r22, 0x56	; 86
    2ff8:	71 05       	cpc	r23, r1
    2ffa:	11 f0       	breq	.+4      	; 0x3000 <IdentifyMessage+0xac>
    2ffc:	85 31       	cpi	r24, 0x15	; 21
    2ffe:	19 f4       	brne	.+6      	; 0x3006 <IdentifyMessage+0xb2>
    3000:	81 e0       	ldi	r24, 0x01	; 1
    3002:	80 93 ce 01 	sts	0x01CE, r24

        //EDC AdvanZ Respond
		if (IsMessage91==True){
    3006:	10 91 d4 01 	lds	r17, 0x01D4
    300a:	11 30       	cpi	r17, 0x01	; 1
    300c:	31 f4       	brne	.+12     	; 0x301a <IdentifyMessage+0xc6>
		    IsMessage91=False;
    300e:	10 92 d4 01 	sts	0x01D4, r1
		    ProcMessage91();
    3012:	0e 94 30 17 	call	0x2e60	; 0x2e60 <ProcMessage91>
			IsSendMessageEDC=True;
    3016:	10 93 c3 01 	sts	0x01C3, r17
		  }

//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  _uart_print(1,0,SerialSend);
	 }
}
    301a:	1f 91       	pop	r17
    301c:	08 95       	ret

0000301e <Tab>:

	  }
     return Result;     
}

void Tab(char *sTab, char nTab){
    301e:	fc 01       	movw	r30, r24
    3020:	dc 01       	movw	r26, r24
    3022:	80 e0       	ldi	r24, 0x00	; 0
     char i;
	 for(i=0;i<nTab;i++){
	     sTab[i]=' ';
    3024:	90 e2       	ldi	r25, 0x20	; 32
    3026:	02 c0       	rjmp	.+4      	; 0x302c <Tab+0xe>
    3028:	9d 93       	st	X+, r25
     return Result;     
}

void Tab(char *sTab, char nTab){
     char i;
	 for(i=0;i<nTab;i++){
    302a:	8f 5f       	subi	r24, 0xFF	; 255
    302c:	86 17       	cp	r24, r22
    302e:	e0 f3       	brcs	.-8      	; 0x3028 <Tab+0xa>
	     sTab[i]=' ';
	 }sTab[nTab]=0;
    3030:	e6 0f       	add	r30, r22
    3032:	f1 1d       	adc	r31, r1
    3034:	10 82       	st	Z, r1
}
    3036:	08 95       	ret

00003038 <_f_inttostr>:
}



//Old Function
void _f_inttostr(char* __string, unsigned long __value){
    3038:	6f 92       	push	r6
    303a:	7f 92       	push	r7
    303c:	8f 92       	push	r8
    303e:	9f 92       	push	r9
    3040:	af 92       	push	r10
    3042:	bf 92       	push	r11
    3044:	cf 92       	push	r12
    3046:	df 92       	push	r13
    3048:	ef 92       	push	r14
    304a:	ff 92       	push	r15
    304c:	0f 93       	push	r16
    304e:	1f 93       	push	r17
    3050:	cf 93       	push	r28
    3052:	df 93       	push	r29
    3054:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
    3056:	41 15       	cp	r20, r1
    3058:	51 05       	cpc	r21, r1
    305a:	61 05       	cpc	r22, r1
    305c:	71 05       	cpc	r23, r1
    305e:	21 f4       	brne	.+8      	; 0x3068 <_f_inttostr+0x30>
		__string[0] = '0';
    3060:	80 e3       	ldi	r24, 0x30	; 48
    3062:	88 83       	st	Y, r24
		__string[1] = '\0';
    3064:	19 82       	std	Y+1, r1	; 0x01
    3066:	48 c0       	rjmp	.+144    	; 0x30f8 <_f_inttostr+0xc0>
		return;
    3068:	4a 01       	movw	r8, r20
    306a:	5b 01       	movw	r10, r22
    306c:	10 e0       	ldi	r17, 0x00	; 0
    306e:	00 e0       	ldi	r16, 0x00	; 0
    3070:	77 24       	eor	r7, r7
    3072:	c1 2c       	mov	r12, r1
    3074:	9a ec       	ldi	r25, 0xCA	; 202
    3076:	d9 2e       	mov	r13, r25
    3078:	9a e9       	ldi	r25, 0x9A	; 154
    307a:	e9 2e       	mov	r14, r25
    307c:	9b e3       	ldi	r25, 0x3B	; 59
    307e:	f9 2e       	mov	r15, r25
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
    3080:	80 e3       	ldi	r24, 0x30	; 48
    3082:	68 2e       	mov	r6, r24
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
    3084:	8c 14       	cp	r8, r12
    3086:	9d 04       	cpc	r9, r13
    3088:	ae 04       	cpc	r10, r14
    308a:	bf 04       	cpc	r11, r15
    308c:	d0 f0       	brcs	.+52     	; 0x30c2 <_f_inttostr+0x8a>
			__tmp = (int)(__num / __devider);
    308e:	c5 01       	movw	r24, r10
    3090:	b4 01       	movw	r22, r8
    3092:	a7 01       	movw	r20, r14
    3094:	96 01       	movw	r18, r12
    3096:	0e 94 e3 b7 	call	0x16fc6	; 0x16fc6 <__udivmodsi4>
    309a:	12 2f       	mov	r17, r18
			__num = __num % __devider;
    309c:	c5 01       	movw	r24, r10
    309e:	b4 01       	movw	r22, r8
    30a0:	a7 01       	movw	r20, r14
    30a2:	96 01       	movw	r18, r12
    30a4:	0e 94 e3 b7 	call	0x16fc6	; 0x16fc6 <__udivmodsi4>
    30a8:	ac 01       	movw	r20, r24
    30aa:	cb 01       	movw	r24, r22
    30ac:	da 01       	movw	r26, r20
    30ae:	4c 01       	movw	r8, r24
    30b0:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
    30b2:	fe 01       	movw	r30, r28
    30b4:	e0 0f       	add	r30, r16
    30b6:	f1 1d       	adc	r31, r1
    30b8:	10 5d       	subi	r17, 0xD0	; 208
    30ba:	10 83       	st	Z, r17
    30bc:	0f 5f       	subi	r16, 0xFF	; 255
    30be:	11 e0       	ldi	r17, 0x01	; 1
    30c0:	07 c0       	rjmp	.+14     	; 0x30d0 <_f_inttostr+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
    30c2:	11 23       	and	r17, r17
    30c4:	29 f0       	breq	.+10     	; 0x30d0 <_f_inttostr+0x98>
				__string[__i++] = 0x30;
    30c6:	fe 01       	movw	r30, r28
    30c8:	e0 0f       	add	r30, r16
    30ca:	f1 1d       	adc	r31, r1
    30cc:	60 82       	st	Z, r6
    30ce:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
    30d0:	73 94       	inc	r7
    30d2:	8a e0       	ldi	r24, 0x0A	; 10
    30d4:	78 16       	cp	r7, r24
    30d6:	69 f0       	breq	.+26     	; 0x30f2 <_f_inttostr+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
    30d8:	c7 01       	movw	r24, r14
    30da:	b6 01       	movw	r22, r12
    30dc:	2a e0       	ldi	r18, 0x0A	; 10
    30de:	30 e0       	ldi	r19, 0x00	; 0
    30e0:	40 e0       	ldi	r20, 0x00	; 0
    30e2:	50 e0       	ldi	r21, 0x00	; 0
    30e4:	0e 94 e3 b7 	call	0x16fc6	; 0x16fc6 <__udivmodsi4>
    30e8:	c9 01       	movw	r24, r18
    30ea:	da 01       	movw	r26, r20
    30ec:	6c 01       	movw	r12, r24
    30ee:	7d 01       	movw	r14, r26
    30f0:	c9 cf       	rjmp	.-110    	; 0x3084 <_f_inttostr+0x4c>
	}
	__string[__i] = '\0';
    30f2:	c0 0f       	add	r28, r16
    30f4:	d1 1d       	adc	r29, r1
    30f6:	18 82       	st	Y, r1
}
    30f8:	df 91       	pop	r29
    30fa:	cf 91       	pop	r28
    30fc:	1f 91       	pop	r17
    30fe:	0f 91       	pop	r16
    3100:	ff 90       	pop	r15
    3102:	ef 90       	pop	r14
    3104:	df 90       	pop	r13
    3106:	cf 90       	pop	r12
    3108:	bf 90       	pop	r11
    310a:	af 90       	pop	r10
    310c:	9f 90       	pop	r9
    310e:	8f 90       	pop	r8
    3110:	7f 90       	pop	r7
    3112:	6f 90       	pop	r6
    3114:	08 95       	ret

00003116 <StrToRaw>:
			  }
		  }
	 }
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
    3116:	dc 01       	movw	r26, r24
    3118:	20 e0       	ldi	r18, 0x00	; 0
    311a:	30 e0       	ldi	r19, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    311c:	9c 91       	ld	r25, X
    311e:	90 53       	subi	r25, 0x30	; 48
    3120:	9a 30       	cpi	r25, 0x0A	; 10
    3122:	08 f0       	brcs	.+2      	; 0x3126 <StrToRaw+0x10>
    3124:	90 e0       	ldi	r25, 0x00	; 0
	 char xRaw=0;
	 for (i=0;i<6;i++){
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
    3126:	11 96       	adiw	r26, 0x01	; 1
    3128:	8c 91       	ld	r24, X
    312a:	11 97       	sbiw	r26, 0x01	; 1
    312c:	80 53       	subi	r24, 0x30	; 48
    312e:	8a 30       	cpi	r24, 0x0A	; 10
    3130:	08 f0       	brcs	.+2      	; 0x3134 <StrToRaw+0x1e>
    3132:	80 e0       	ldi	r24, 0x00	; 0
    3134:	fb 01       	movw	r30, r22
    3136:	e2 0f       	add	r30, r18
    3138:	f3 1f       	adc	r31, r19
    313a:	8f 70       	andi	r24, 0x0F	; 15
    313c:	92 95       	swap	r25
    313e:	90 7f       	andi	r25, 0xF0	; 240
    3140:	98 2b       	or	r25, r24
    3142:	90 83       	st	Z, r25
    3144:	2f 5f       	subi	r18, 0xFF	; 255
    3146:	3f 4f       	sbci	r19, 0xFF	; 255
    3148:	12 96       	adiw	r26, 0x02	; 2
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
     char i,xA,xB;                //Dest  :  12345678 
	 char xRaw=0;
	 for (i=0;i<6;i++){
    314a:	26 30       	cpi	r18, 0x06	; 6
    314c:	31 05       	cpc	r19, r1
    314e:	31 f7       	brne	.-52     	; 0x311c <StrToRaw+0x6>
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
	 }	      
}
    3150:	08 95       	ret

00003152 <RawToStr>:
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
    3152:	cf 93       	push	r28
    3154:	df 93       	push	r29
    3156:	eb 01       	movw	r28, r22
    3158:	db 01       	movw	r26, r22
    315a:	20 e0       	ldi	r18, 0x00	; 0
    315c:	30 e0       	ldi	r19, 0x00	; 0
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
    315e:	fc 01       	movw	r30, r24
    3160:	e2 0f       	add	r30, r18
    3162:	f3 1f       	adc	r31, r19
    3164:	e0 81       	ld	r30, Z
    3166:	4e 2f       	mov	r20, r30
    3168:	42 95       	swap	r20
    316a:	4f 70       	andi	r20, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    316c:	4a 30       	cpi	r20, 0x0A	; 10
    316e:	10 f0       	brcs	.+4      	; 0x3174 <RawToStr+0x22>
    3170:	40 e3       	ldi	r20, 0x30	; 48
    3172:	01 c0       	rjmp	.+2      	; 0x3176 <RawToStr+0x24>
	    Result='0'+X;
    3174:	40 5d       	subi	r20, 0xD0	; 208
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
    3176:	ef 70       	andi	r30, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    3178:	ea 30       	cpi	r30, 0x0A	; 10
    317a:	10 f0       	brcs	.+4      	; 0x3180 <RawToStr+0x2e>
    317c:	e0 e3       	ldi	r30, 0x30	; 48
    317e:	01 c0       	rjmp	.+2      	; 0x3182 <RawToStr+0x30>
	    Result='0'+X;
    3180:	e0 5d       	subi	r30, 0xD0	; 208
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
    3182:	4c 93       	st	X, r20
          Dest[(2*i)+1]=cB;
    3184:	11 96       	adiw	r26, 0x01	; 1
    3186:	ec 93       	st	X, r30
    3188:	11 97       	sbiw	r26, 0x01	; 1
    318a:	2f 5f       	subi	r18, 0xFF	; 255
    318c:	3f 4f       	sbci	r19, 0xFF	; 255
    318e:	12 96       	adiw	r26, 0x02	; 2
	      Dest[i]=xRaw;
	 }	      
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
    3190:	26 30       	cpi	r18, 0x06	; 6
    3192:	31 05       	cpc	r19, r1
    3194:	21 f7       	brne	.-56     	; 0x315e <RawToStr+0xc>
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
          Dest[(2*i)+1]=cB;
	 }Dest[12]=0;
    3196:	1c 86       	std	Y+12, r1	; 0x0c
}
    3198:	df 91       	pop	r29
    319a:	cf 91       	pop	r28
    319c:	08 95       	ret

0000319e <CalcMinus>:
}

char CalcMinus(char A, char B){
     signed char xA,xB,xC;
	 char Result;
	 if (A>=B) xC=((A-'0')-(B-'0'));
    319e:	86 17       	cp	r24, r22
    31a0:	08 f4       	brcc	.+2      	; 0x31a4 <CalcMinus+0x6>
	 else xC=10+((A-'0')-(B-'0'));//
    31a2:	86 5f       	subi	r24, 0xF6	; 246
    31a4:	86 1b       	sub	r24, r22
	 Result='0'+xC;
  return Result;
}
    31a6:	80 5d       	subi	r24, 0xD0	; 208
    31a8:	08 95       	ret

000031aa <CalcPlus>:

char CalcPlus(char A, char B){
    31aa:	80 56       	subi	r24, 0x60	; 96
    31ac:	86 0f       	add	r24, r22
    31ae:	6a e0       	ldi	r22, 0x0A	; 10
    31b0:	0e 94 af b7 	call	0x16f5e	; 0x16f5e <__divmodqi4>
     signed char xA,xB,xC;
	 char Result;
	 xC=((A-'0')+(B-'0'));
     Result='0'+(xC%10);  
   return Result;
}
    31b4:	89 2f       	mov	r24, r25
    31b6:	80 5d       	subi	r24, 0xD0	; 208
    31b8:	08 95       	ret

000031ba <Chr>:
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    31ba:	8a 30       	cpi	r24, 0x0A	; 10
    31bc:	10 f0       	brcs	.+4      	; 0x31c2 <Chr+0x8>
    31be:	80 e3       	ldi	r24, 0x30	; 48
    31c0:	08 95       	ret
	    Result='0'+X;
    31c2:	80 5d       	subi	r24, 0xD0	; 208
	 }
	return Result;
}
    31c4:	08 95       	ret

000031c6 <Ord>:
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    31c6:	80 53       	subi	r24, 0x30	; 48
    31c8:	8a 30       	cpi	r24, 0x0A	; 10
    31ca:	08 f0       	brcs	.+2      	; 0x31ce <Ord+0x8>
    31cc:	80 e0       	ldi	r24, 0x00	; 0
	    Result=c-'0';
	 }
	return Result;
}
    31ce:	08 95       	ret

000031d0 <GetTabSpace>:
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
    31d0:	48 2f       	mov	r20, r24
    31d2:	fb 01       	movw	r30, r22
     char i,nTab;
	 if (TabLength>0){
    31d4:	18 16       	cp	r1, r24
    31d6:	64 f4       	brge	.+24     	; 0x31f0 <GetTabSpace+0x20>
		 nTab=TabLength;//%40;
    31d8:	56 2f       	mov	r21, r22
    31da:	db 01       	movw	r26, r22
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    31dc:	90 e2       	ldi	r25, 0x20	; 32
    31de:	9d 93       	st	X+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    31e0:	8a 2f       	mov	r24, r26
    31e2:	85 1b       	sub	r24, r21
    31e4:	84 17       	cp	r24, r20
    31e6:	d8 f3       	brcs	.-10     	; 0x31de <GetTabSpace+0xe>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    31e8:	e4 0f       	add	r30, r20
    31ea:	f1 1d       	adc	r31, r1
    31ec:	10 82       	st	Z, r1
    31ee:	08 95       	ret
     }else{
	 strTab[0]=' ';
    31f0:	80 e2       	ldi	r24, 0x20	; 32
    31f2:	80 83       	st	Z, r24
	 strTab[1]=0;
    31f4:	11 82       	std	Z+1, r1	; 0x01
    31f6:	08 95       	ret

000031f8 <GetBorderValue>:

}

char GetBorderValue(char BoderType){
     char Result=0;
	 switch (BoderType){
    31f8:	86 30       	cpi	r24, 0x06	; 6
    31fa:	51 f1       	breq	.+84     	; 0x3250 <GetBorderValue+0x58>
    31fc:	87 30       	cpi	r24, 0x07	; 7
    31fe:	70 f4       	brcc	.+28     	; 0x321c <GetBorderValue+0x24>
    3200:	83 30       	cpi	r24, 0x03	; 3
    3202:	11 f1       	breq	.+68     	; 0x3248 <GetBorderValue+0x50>
    3204:	84 30       	cpi	r24, 0x04	; 4
    3206:	28 f4       	brcc	.+10     	; 0x3212 <GetBorderValue+0x1a>
    3208:	81 30       	cpi	r24, 0x01	; 1
    320a:	c1 f0       	breq	.+48     	; 0x323c <GetBorderValue+0x44>
    320c:	82 30       	cpi	r24, 0x02	; 2
    320e:	c1 f4       	brne	.+48     	; 0x3240 <GetBorderValue+0x48>
    3210:	19 c0       	rjmp	.+50     	; 0x3244 <GetBorderValue+0x4c>
    3212:	84 30       	cpi	r24, 0x04	; 4
    3214:	d9 f0       	breq	.+54     	; 0x324c <GetBorderValue+0x54>
    3216:	85 30       	cpi	r24, 0x05	; 5
    3218:	99 f4       	brne	.+38     	; 0x3240 <GetBorderValue+0x48>
    321a:	22 c0       	rjmp	.+68     	; 0x3260 <GetBorderValue+0x68>
    321c:	89 30       	cpi	r24, 0x09	; 9
    321e:	f1 f0       	breq	.+60     	; 0x325c <GetBorderValue+0x64>
    3220:	8a 30       	cpi	r24, 0x0A	; 10
    3222:	28 f4       	brcc	.+10     	; 0x322e <GetBorderValue+0x36>
    3224:	87 30       	cpi	r24, 0x07	; 7
    3226:	b1 f0       	breq	.+44     	; 0x3254 <GetBorderValue+0x5c>
    3228:	88 30       	cpi	r24, 0x08	; 8
    322a:	51 f4       	brne	.+20     	; 0x3240 <GetBorderValue+0x48>
    322c:	15 c0       	rjmp	.+42     	; 0x3258 <GetBorderValue+0x60>
    322e:	8b 30       	cpi	r24, 0x0B	; 11
    3230:	d9 f0       	breq	.+54     	; 0x3268 <GetBorderValue+0x70>
    3232:	8b 30       	cpi	r24, 0x0B	; 11
    3234:	b8 f0       	brcs	.+46     	; 0x3264 <GetBorderValue+0x6c>
    3236:	8c 30       	cpi	r24, 0x0C	; 12
    3238:	19 f4       	brne	.+6      	; 0x3240 <GetBorderValue+0x48>
    323a:	18 c0       	rjmp	.+48     	; 0x326c <GetBorderValue+0x74>
    323c:	8a ed       	ldi	r24, 0xDA	; 218
    323e:	08 95       	ret
    3240:	80 e0       	ldi	r24, 0x00	; 0
    3242:	08 95       	ret
    3244:	82 ec       	ldi	r24, 0xC2	; 194
    3246:	08 95       	ret
		case btTopLeft: 
		     Result=0xDA;
			 break;
		case btTopCenter: 
		     Result=0xC2;
			 break;
    3248:	8f eb       	ldi	r24, 0xBF	; 191
    324a:	08 95       	ret
		case btTopRight:
		     Result=0xBF;		 
			 break;
    324c:	83 ec       	ldi	r24, 0xC3	; 195
    324e:	08 95       	ret
		case btMiddleLeft: 
			 Result=0xC3;
			 break;
    3250:	84 eb       	ldi	r24, 0xB4	; 180
    3252:	08 95       	ret
		case btMiddleRight: 
			 Result=0xB4;
			 break;
    3254:	80 ec       	ldi	r24, 0xC0	; 192
    3256:	08 95       	ret
		case btBottomLeft: 
		     Result=0xC0;
			 break;
    3258:	81 ec       	ldi	r24, 0xC1	; 193
    325a:	08 95       	ret
		case btBottomCenter: 
			 Result=0xC1;
			 break;
    325c:	89 ed       	ldi	r24, 0xD9	; 217
    325e:	08 95       	ret
		case btBottomRight: 
			 Result=0xD9;
			 break;
    3260:	85 ec       	ldi	r24, 0xC5	; 197
    3262:	08 95       	ret
        case btMiddleCenter:
		     Result=0xC5;
		     break;
    3264:	83 eb       	ldi	r24, 0xB3	; 179
    3266:	08 95       	ret
		case btVertical: 
			 Result=0xB3;
			 break;
    3268:	84 ec       	ldi	r24, 0xC4	; 196
    326a:	08 95       	ret
		case btHorizontal:
			 Result=0xC4;
			 break;	 
    326c:	8d e0       	ldi	r24, 0x0D	; 13
        case btNewLine:
		     Result=0x0D;
			 break;	 
	 }
   return Result;
}
    326e:	08 95       	ret

00003270 <InserBorder>:

void InserBorder(char BorderType, char *strPrnBuffer,char nLength,unsigned int *Pos){
    3270:	bf 92       	push	r11
    3272:	cf 92       	push	r12
    3274:	df 92       	push	r13
    3276:	ef 92       	push	r14
    3278:	ff 92       	push	r15
    327a:	0f 93       	push	r16
    327c:	1f 93       	push	r17
    327e:	cf 93       	push	r28
    3280:	df 93       	push	r29
    3282:	b8 2e       	mov	r11, r24
    3284:	8b 01       	movw	r16, r22
    3286:	e4 2e       	mov	r14, r20
    3288:	69 01       	movw	r12, r18
     char i,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
    328a:	f9 01       	movw	r30, r18
    328c:	c0 81       	ld	r28, Z
    328e:	d1 81       	ldd	r29, Z+1	; 0x01
    3290:	0c 0f       	add	r16, r28
    3292:	1d 1f       	adc	r17, r29
    3294:	ff 24       	eor	r15, r15
    3296:	07 c0       	rjmp	.+14     	; 0x32a6 <InserBorder+0x36>
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
	      strPrnBuffer[iPos]=GetBorderValue(BorderType);
    3298:	8b 2d       	mov	r24, r11
    329a:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <GetBorderValue>
    329e:	f8 01       	movw	r30, r16
    32a0:	81 93       	st	Z+, r24
    32a2:	8f 01       	movw	r16, r30
     char i,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
    32a4:	f3 94       	inc	r15
    32a6:	fe 14       	cp	r15, r14
    32a8:	b8 f3       	brcs	.-18     	; 0x3298 <InserBorder+0x28>
	 //for (i=0;i<nLength;i++){
	 //     if (strPrnBuffer[i+StartPos]!=GetBorderValue(BorderType)){
//		      strPrnBuffer[i+StartPos]=GetBorderValue(BorderType);
//		  }
//	 }
     *Pos=iPos;
    32aa:	ce 0d       	add	r28, r14
    32ac:	d1 1d       	adc	r29, r1
    32ae:	f6 01       	movw	r30, r12
    32b0:	d1 83       	std	Z+1, r29	; 0x01
    32b2:	c0 83       	st	Z, r28
}
    32b4:	df 91       	pop	r29
    32b6:	cf 91       	pop	r28
    32b8:	1f 91       	pop	r17
    32ba:	0f 91       	pop	r16
    32bc:	ff 90       	pop	r15
    32be:	ef 90       	pop	r14
    32c0:	df 90       	pop	r13
    32c2:	cf 90       	pop	r12
    32c4:	bf 90       	pop	r11
    32c6:	08 95       	ret

000032c8 <GeniusSendPumpStatus>:
   return Result;
}

void GeniusSendPumpStatus(char iPumpID){
     
}
    32c8:	08 95       	ret

000032ca <GeniusSendStopPump>:
void GeniusSendStopPump(char iPumpID){
}
    32ca:	08 95       	ret

000032cc <GeniusSendResumePump>:
void GeniusSendResumePump(char iPumpID){
}
    32cc:	08 95       	ret

000032ce <GeniusSendPumpPreset>:
void GeniusSendPumpPreset(char iPumpID){
}
    32ce:	08 95       	ret

000032d0 <SetIncomingTransStatus>:
	 sprintf_P(strSend,PSTR("%d"),cSum);
	 _uart_print(1,1,strSend);	 
}


void SetIncomingTransStatus(char iPumpID,char xTransStatus){
    32d0:	e8 2f       	mov	r30, r24
char iStatus,xMaskA,xMaskB,xMaskC,xPumpID;
	 xPumpID=(iPumpID&0x0F);
    32d2:	28 2f       	mov	r18, r24
    32d4:	2f 70       	andi	r18, 0x0F	; 15
     iStatus=IncomingTransaction[xPumpID/8];
    32d6:	82 2f       	mov	r24, r18
    32d8:	86 95       	lsr	r24
    32da:	86 95       	lsr	r24
    32dc:	86 95       	lsr	r24
    32de:	a8 2f       	mov	r26, r24
    32e0:	b0 e0       	ldi	r27, 0x00	; 0
    32e2:	a1 52       	subi	r26, 0x21	; 33
    32e4:	b2 4f       	sbci	r27, 0xF2	; 242
    32e6:	4c 91       	ld	r20, X
	 if (xTransStatus==TS_NEW){
    32e8:	62 30       	cpi	r22, 0x02	; 2
    32ea:	59 f4       	brne	.+22     	; 0x3302 <SetIncomingTransStatus+0x32>
	     iStatus=(iStatus|(1<<(xPumpID%8)));	 
    32ec:	27 70       	andi	r18, 0x07	; 7
    32ee:	81 e0       	ldi	r24, 0x01	; 1
    32f0:	90 e0       	ldi	r25, 0x00	; 0
    32f2:	02 c0       	rjmp	.+4      	; 0x32f8 <SetIncomingTransStatus+0x28>
    32f4:	88 0f       	add	r24, r24
    32f6:	99 1f       	adc	r25, r25
    32f8:	2a 95       	dec	r18
    32fa:	e2 f7       	brpl	.-8      	; 0x32f4 <SetIncomingTransStatus+0x24>
    32fc:	48 2b       	or	r20, r24
		 IncomingTransaction[xPumpID/8]=iStatus;
    32fe:	4c 93       	st	X, r20
    3300:	08 95       	ret
	 }else if (xTransStatus==TS_OLD){
    3302:	63 30       	cpi	r22, 0x03	; 3
    3304:	b1 f4       	brne	.+44     	; 0x3332 <SetIncomingTransStatus+0x62>
		 xMaskA=(0xFE<<(xPumpID%8));
    3306:	27 70       	andi	r18, 0x07	; 7
    3308:	8e ef       	ldi	r24, 0xFE	; 254
    330a:	90 e0       	ldi	r25, 0x00	; 0
    330c:	01 c0       	rjmp	.+2      	; 0x3310 <SetIncomingTransStatus+0x40>
    330e:	88 0f       	add	r24, r24
    3310:	2a 95       	dec	r18
    3312:	ea f7       	brpl	.-6      	; 0x330e <SetIncomingTransStatus+0x3e>
		 xMaskB=(~xMaskA)>>1;
		 xMaskC=xMaskA|xMaskB;
		 iStatus=iStatus&xMaskC;
		 IncomingTransaction[iPumpID/8]=iStatus;
    3314:	e6 95       	lsr	r30
    3316:	e6 95       	lsr	r30
    3318:	e6 95       	lsr	r30
    331a:	f0 e0       	ldi	r31, 0x00	; 0
    331c:	e1 52       	subi	r30, 0x21	; 33
    331e:	f2 4f       	sbci	r31, 0xF2	; 242
    3320:	28 2f       	mov	r18, r24
    3322:	30 e0       	ldi	r19, 0x00	; 0
    3324:	20 95       	com	r18
    3326:	30 95       	com	r19
    3328:	35 95       	asr	r19
    332a:	27 95       	ror	r18
    332c:	82 2b       	or	r24, r18
    332e:	84 23       	and	r24, r20
    3330:	80 83       	st	Z, r24
    3332:	08 95       	ret

00003334 <GetIncomingTransStatus>:
	 }
}
char GetIncomingTransStatus(char iPumpID){
     char xPumpID,Result;
	 xPumpID=(iPumpID&0x0F);
    3334:	8f 70       	andi	r24, 0x0F	; 15
	 Result=TS_NONE;
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==1){
    3336:	e8 2f       	mov	r30, r24
    3338:	e6 95       	lsr	r30
    333a:	e6 95       	lsr	r30
    333c:	e6 95       	lsr	r30
    333e:	f0 e0       	ldi	r31, 0x00	; 0
    3340:	e1 52       	subi	r30, 0x21	; 33
    3342:	f2 4f       	sbci	r31, 0xF2	; 242
    3344:	90 81       	ld	r25, Z
    3346:	29 2f       	mov	r18, r25
    3348:	30 e0       	ldi	r19, 0x00	; 0
    334a:	87 70       	andi	r24, 0x07	; 7
    334c:	02 c0       	rjmp	.+4      	; 0x3352 <GetIncomingTransStatus+0x1e>
    334e:	35 95       	asr	r19
    3350:	27 95       	ror	r18
    3352:	8a 95       	dec	r24
    3354:	e2 f7       	brpl	.-8      	; 0x334e <GetIncomingTransStatus+0x1a>
    3356:	21 30       	cpi	r18, 0x01	; 1
    3358:	31 05       	cpc	r19, r1
    335a:	11 f4       	brne	.+4      	; 0x3360 <GetIncomingTransStatus+0x2c>
    335c:	82 e0       	ldi	r24, 0x02	; 2
    335e:	08 95       	ret
	     Result=TS_NEW;
	 }else
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==0){
    3360:	23 2b       	or	r18, r19
    3362:	11 f4       	brne	.+4      	; 0x3368 <GetIncomingTransStatus+0x34>
    3364:	83 e0       	ldi	r24, 0x03	; 3
    3366:	08 95       	ret
    3368:	80 e0       	ldi	r24, 0x00	; 0
	     Result=TS_OLD;
	 }
   return Result;
}
    336a:	08 95       	ret

0000336c <SetDispenser>:
		  }
	      break;
	 }
}

void SetDispenser(char DispType){
    336c:	df 93       	push	r29
    336e:	cf 93       	push	r28
    3370:	00 d0       	rcall	.+0      	; 0x3372 <SetDispenser+0x6>
    3372:	00 d0       	rcall	.+0      	; 0x3374 <SetDispenser+0x8>
    3374:	0f 92       	push	r0
    3376:	cd b7       	in	r28, 0x3d	; 61
    3378:	de b7       	in	r29, 0x3e	; 62
    337a:	98 2f       	mov	r25, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    337c:	e1 99       	sbic	0x1c, 1	; 28
    337e:	fe cf       	rjmp	.-4      	; 0x337c <SetDispenser+0x10>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3380:	27 e6       	ldi	r18, 0x67	; 103
    3382:	31 e0       	ldi	r19, 0x01	; 1
    3384:	3f bb       	out	0x1f, r19	; 31
    3386:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3388:	e0 9a       	sbi	0x1c, 0	; 28
    338a:	8d b3       	in	r24, 0x1d	; 29
     char CurrentDispenser;
	 char i,DecimalSetting[5];
     CurrentDispenser=eeprom_read_byte(&DefDispenserBrand);
	 if (CurrentDispenser!=DispType){
    338c:	89 17       	cp	r24, r25
    338e:	51 f0       	breq	.+20     	; 0x33a4 <SetDispenser+0x38>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3390:	e1 99       	sbic	0x1c, 1	; 28
    3392:	fe cf       	rjmp	.-4      	; 0x3390 <SetDispenser+0x24>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3394:	3f bb       	out	0x1f, r19	; 31
    3396:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    3398:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    339a:	0f b6       	in	r0, 0x3f	; 63
    339c:	f8 94       	cli
    339e:	e2 9a       	sbi	0x1c, 2	; 28
    33a0:	e1 9a       	sbi	0x1c, 1	; 28
    33a2:	0f be       	out	0x3f, r0	; 63
	     eeprom_write_byte(&DefDispenserBrand,DispType);
	 }
     //Apply Setting for Pump respectively
	 switch(DispType){
    33a4:	91 30       	cpi	r25, 0x01	; 1
    33a6:	19 f0       	breq	.+6      	; 0x33ae <SetDispenser+0x42>
    33a8:	92 30       	cpi	r25, 0x02	; 2
    33aa:	71 f4       	brne	.+28     	; 0x33c8 <SetDispenser+0x5c>
    33ac:	08 c0       	rjmp	.+16     	; 0x33be <SetDispenser+0x52>
	 case ST_GILBARCO:
          DecimalSetting[0]=0;//Price
    33ae:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=3;//Volume
    33b0:	83 e0       	ldi	r24, 0x03	; 3
    33b2:	8a 83       	std	Y+2, r24	; 0x02
		  DecimalSetting[2]=0;//Money
    33b4:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    33b6:	82 e0       	ldi	r24, 0x02	; 2
    33b8:	8c 83       	std	Y+4, r24	; 0x04
		  DecimalSetting[4]=0;//TotalMoney 
    33ba:	1d 82       	std	Y+5, r1	; 0x05
    33bc:	05 c0       	rjmp	.+10     	; 0x33c8 <SetDispenser+0x5c>
	      break;
	 case ST_WAYNE_DART:
          DecimalSetting[0]=0;//Price
    33be:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=2;//Volume
    33c0:	9a 83       	std	Y+2, r25	; 0x02
		  DecimalSetting[2]=0;//Money
    33c2:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    33c4:	9c 83       	std	Y+4, r25	; 0x04
		  DecimalSetting[4]=2;//TotalMoney 
    33c6:	9d 83       	std	Y+5, r25	; 0x05
    33c8:	29 e3       	ldi	r18, 0x39	; 57
    33ca:	30 e0       	ldi	r19, 0x00	; 0
    33cc:	fe 01       	movw	r30, r28
    33ce:	31 96       	adiw	r30, 0x01	; 1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    33d0:	e1 99       	sbic	0x1c, 1	; 28
    33d2:	fe cf       	rjmp	.-4      	; 0x33d0 <SetDispenser+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    33d4:	3f bb       	out	0x1f, r19	; 31
    33d6:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    33d8:	e0 9a       	sbi	0x1c, 0	; 28
    33da:	8d b3       	in	r24, 0x1d	; 29
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
    33dc:	90 81       	ld	r25, Z
    33de:	89 17       	cp	r24, r25
    33e0:	51 f0       	breq	.+20     	; 0x33f6 <SetDispenser+0x8a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    33e2:	e1 99       	sbic	0x1c, 1	; 28
    33e4:	fe cf       	rjmp	.-4      	; 0x33e2 <SetDispenser+0x76>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    33e6:	3f bb       	out	0x1f, r19	; 31
    33e8:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    33ea:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    33ec:	0f b6       	in	r0, 0x3f	; 63
    33ee:	f8 94       	cli
    33f0:	e2 9a       	sbi	0x1c, 2	; 28
    33f2:	e1 9a       	sbi	0x1c, 1	; 28
    33f4:	0f be       	out	0x3f, r0	; 63
    33f6:	2f 5f       	subi	r18, 0xFF	; 255
    33f8:	3f 4f       	sbci	r19, 0xFF	; 255
    33fa:	31 96       	adiw	r30, 0x01	; 1
		  DecimalSetting[3]=2;//TotalVolume
		  DecimalSetting[4]=2;//TotalMoney 
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
    33fc:	80 e0       	ldi	r24, 0x00	; 0
    33fe:	2e 33       	cpi	r18, 0x3E	; 62
    3400:	38 07       	cpc	r19, r24
    3402:	31 f7       	brne	.-52     	; 0x33d0 <SetDispenser+0x64>
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
		     eeprom_write_byte(&DefDecimalPrice+i,DecimalSetting[i]);
		 }
	 }
}
    3404:	0f 90       	pop	r0
    3406:	0f 90       	pop	r0
    3408:	0f 90       	pop	r0
    340a:	0f 90       	pop	r0
    340c:	0f 90       	pop	r0
    340e:	cf 91       	pop	r28
    3410:	df 91       	pop	r29
    3412:	08 95       	ret

00003414 <ComposeDatetime>:
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}


void ComposeDatetime(char *Result){// 2010/10/01 16:27:44
    3414:	df 93       	push	r29
    3416:	cf 93       	push	r28
    3418:	cd b7       	in	r28, 0x3d	; 61
    341a:	de b7       	in	r29, 0x3e	; 62
    341c:	62 97       	sbiw	r28, 0x12	; 18
    341e:	0f b6       	in	r0, 0x3f	; 63
    3420:	f8 94       	cli
    3422:	de bf       	out	0x3e, r29	; 62
    3424:	0f be       	out	0x3f, r0	; 63
    3426:	cd bf       	out	0x3d, r28	; 61
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3428:	20 91 c0 05 	lds	r18, 0x05C0
    342c:	2f 83       	std	Y+7, r18	; 0x07
    342e:	20 91 c1 05 	lds	r18, 0x05C1
    3432:	28 87       	std	Y+8, r18	; 0x08
	 }Dest[Length]=0;
    3434:	20 91 c3 05 	lds	r18, 0x05C3
    3438:	2c 83       	std	Y+4, r18	; 0x04
    343a:	20 91 c4 05 	lds	r18, 0x05C4
    343e:	2d 83       	std	Y+5, r18	; 0x05
    3440:	20 91 c6 05 	lds	r18, 0x05C6
    3444:	29 83       	std	Y+1, r18	; 0x01
    3446:	20 91 c7 05 	lds	r18, 0x05C7
    344a:	2a 83       	std	Y+2, r18	; 0x02
    344c:	20 91 a9 0a 	lds	r18, 0x0AA9
    3450:	2a 87       	std	Y+10, r18	; 0x0a
    3452:	20 91 aa 0a 	lds	r18, 0x0AAA
    3456:	2b 87       	std	Y+11, r18	; 0x0b
    3458:	20 91 ac 0a 	lds	r18, 0x0AAC
    345c:	2d 87       	std	Y+13, r18	; 0x0d
    345e:	20 91 ad 0a 	lds	r18, 0x0AAD
    3462:	2e 87       	std	Y+14, r18	; 0x0e
    3464:	20 91 af 0a 	lds	r18, 0x0AAF
    3468:	28 8b       	std	Y+16, r18	; 0x10
    346a:	20 91 b0 0a 	lds	r18, 0x0AB0
    346e:	29 8b       	std	Y+17, r18	; 0x11
    3470:	1a 8a       	std	Y+18, r1	; 0x12
    3472:	1f 86       	std	Y+15, r1	; 0x0f
    3474:	1c 86       	std	Y+12, r1	; 0x0c
    3476:	1b 82       	std	Y+3, r1	; 0x03
    3478:	1e 82       	std	Y+6, r1	; 0x06
    347a:	19 86       	std	Y+9, r1	; 0x09
     StrPosCopy(strSystemDate,sYear,6,2);

     StrPosCopy(strSystemTime,sHour,0,2);
     StrPosCopy(strSystemTime,sMinute,3,2);
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
    347c:	2d b7       	in	r18, 0x3d	; 61
    347e:	3e b7       	in	r19, 0x3e	; 62
    3480:	20 51       	subi	r18, 0x10	; 16
    3482:	30 40       	sbci	r19, 0x00	; 0
    3484:	0f b6       	in	r0, 0x3f	; 63
    3486:	f8 94       	cli
    3488:	3e bf       	out	0x3e, r19	; 62
    348a:	0f be       	out	0x3f, r0	; 63
    348c:	2d bf       	out	0x3d, r18	; 61
    348e:	ed b7       	in	r30, 0x3d	; 61
    3490:	fe b7       	in	r31, 0x3e	; 62
    3492:	31 96       	adiw	r30, 0x01	; 1
    3494:	ad b7       	in	r26, 0x3d	; 61
    3496:	be b7       	in	r27, 0x3e	; 62
    3498:	12 96       	adiw	r26, 0x02	; 2
    349a:	9c 93       	st	X, r25
    349c:	8e 93       	st	-X, r24
    349e:	11 97       	sbiw	r26, 0x01	; 1
    34a0:	83 ed       	ldi	r24, 0xD3	; 211
    34a2:	93 e0       	ldi	r25, 0x03	; 3
    34a4:	93 83       	std	Z+3, r25	; 0x03
    34a6:	82 83       	std	Z+2, r24	; 0x02
    34a8:	ce 01       	movw	r24, r28
    34aa:	01 96       	adiw	r24, 0x01	; 1
    34ac:	95 83       	std	Z+5, r25	; 0x05
    34ae:	84 83       	std	Z+4, r24	; 0x04
    34b0:	ce 01       	movw	r24, r28
    34b2:	04 96       	adiw	r24, 0x04	; 4
    34b4:	97 83       	std	Z+7, r25	; 0x07
    34b6:	86 83       	std	Z+6, r24	; 0x06
    34b8:	ce 01       	movw	r24, r28
    34ba:	07 96       	adiw	r24, 0x07	; 7
    34bc:	91 87       	std	Z+9, r25	; 0x09
    34be:	80 87       	std	Z+8, r24	; 0x08
    34c0:	ce 01       	movw	r24, r28
    34c2:	0a 96       	adiw	r24, 0x0a	; 10
    34c4:	93 87       	std	Z+11, r25	; 0x0b
    34c6:	82 87       	std	Z+10, r24	; 0x0a
    34c8:	ce 01       	movw	r24, r28
    34ca:	0d 96       	adiw	r24, 0x0d	; 13
    34cc:	95 87       	std	Z+13, r25	; 0x0d
    34ce:	84 87       	std	Z+12, r24	; 0x0c
    34d0:	ce 01       	movw	r24, r28
    34d2:	40 96       	adiw	r24, 0x10	; 16
    34d4:	97 87       	std	Z+15, r25	; 0x0f
    34d6:	86 87       	std	Z+14, r24	; 0x0e
    34d8:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    34dc:	2d b7       	in	r18, 0x3d	; 61
    34de:	3e b7       	in	r19, 0x3e	; 62
    34e0:	20 5f       	subi	r18, 0xF0	; 240
    34e2:	3f 4f       	sbci	r19, 0xFF	; 255
    34e4:	0f b6       	in	r0, 0x3f	; 63
    34e6:	f8 94       	cli
    34e8:	3e bf       	out	0x3e, r19	; 62
    34ea:	0f be       	out	0x3f, r0	; 63
    34ec:	2d bf       	out	0x3d, r18	; 61
}
    34ee:	62 96       	adiw	r28, 0x12	; 18
    34f0:	0f b6       	in	r0, 0x3f	; 63
    34f2:	f8 94       	cli
    34f4:	de bf       	out	0x3e, r29	; 62
    34f6:	0f be       	out	0x3f, r0	; 63
    34f8:	cd bf       	out	0x3d, r28	; 61
    34fa:	cf 91       	pop	r28
    34fc:	df 91       	pop	r29
    34fe:	08 95       	ret

00003500 <leadingZero>:
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    3500:	00 d0       	rcall	.+0      	; 0x3502 <leadingZero+0x2>
    3502:	00 d0       	rcall	.+0      	; 0x3504 <leadingZero+0x4>
    3504:	00 d0       	rcall	.+0      	; 0x3506 <leadingZero+0x6>
    3506:	ed b7       	in	r30, 0x3d	; 61
    3508:	fe b7       	in	r31, 0x3e	; 62
    350a:	31 96       	adiw	r30, 0x01	; 1
    350c:	ad b7       	in	r26, 0x3d	; 61
    350e:	be b7       	in	r27, 0x3e	; 62
    3510:	12 96       	adiw	r26, 0x02	; 2
    3512:	7c 93       	st	X, r23
    3514:	6e 93       	st	-X, r22
    3516:	11 97       	sbiw	r26, 0x01	; 1
    3518:	25 eb       	ldi	r18, 0xB5	; 181
    351a:	3e e0       	ldi	r19, 0x0E	; 14
    351c:	33 83       	std	Z+3, r19	; 0x03
    351e:	22 83       	std	Z+2, r18	; 0x02
    3520:	84 83       	std	Z+4, r24	; 0x04
    3522:	15 82       	std	Z+5, r1	; 0x05
    3524:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    3528:	8d b7       	in	r24, 0x3d	; 61
    352a:	9e b7       	in	r25, 0x3e	; 62
    352c:	06 96       	adiw	r24, 0x06	; 6
    352e:	0f b6       	in	r0, 0x3f	; 63
    3530:	f8 94       	cli
    3532:	9e bf       	out	0x3e, r25	; 62
    3534:	0f be       	out	0x3f, r0	; 63
    3536:	8d bf       	out	0x3d, r24	; 61

}
    3538:	08 95       	ret

0000353a <UpdateSeqNum>:
void UpdateIFT_ID(){
	 leadingZero(eeprom_read_byte(&DefIFT_ID),strIFT_ID);
}

void UpdateSeqNum(){
     if (SeqNum<100)SeqNum++;
    353a:	80 91 e6 01 	lds	r24, 0x01E6
    353e:	84 36       	cpi	r24, 0x64	; 100
    3540:	20 f4       	brcc	.+8      	; 0x354a <UpdateSeqNum+0x10>
    3542:	8f 5f       	subi	r24, 0xFF	; 255
    3544:	80 93 e6 01 	sts	0x01E6, r24
    3548:	02 c0       	rjmp	.+4      	; 0x354e <UpdateSeqNum+0x14>
	 else SeqNum=0;
    354a:	10 92 e6 01 	sts	0x01E6, r1
	 leadingZero(SeqNum,strSeqNum);
    354e:	80 91 e6 01 	lds	r24, 0x01E6
    3552:	90 e0       	ldi	r25, 0x00	; 0
    3554:	6b ed       	ldi	r22, 0xDB	; 219
    3556:	7d e0       	ldi	r23, 0x0D	; 13
    3558:	0e 94 80 1a 	call	0x3500	; 0x3500 <leadingZero>
} 
    355c:	08 95       	ret

0000355e <UpdateIFT_ID>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    355e:	e1 99       	sbic	0x1c, 1	; 28
    3560:	fe cf       	rjmp	.-4      	; 0x355e <UpdateIFT_ID>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3562:	80 e0       	ldi	r24, 0x00	; 0
    3564:	90 e0       	ldi	r25, 0x00	; 0
    3566:	9f bb       	out	0x1f, r25	; 31
    3568:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    356a:	e0 9a       	sbi	0x1c, 0	; 28
    356c:	8d b3       	in	r24, 0x1d	; 29
	_uart(1, 1,0x02);
}


void UpdateIFT_ID(){
	 leadingZero(eeprom_read_byte(&DefIFT_ID),strIFT_ID);
    356e:	90 e0       	ldi	r25, 0x00	; 0
    3570:	62 ef       	ldi	r22, 0xF2	; 242
    3572:	75 e0       	ldi	r23, 0x05	; 5
    3574:	0e 94 80 1a 	call	0x3500	; 0x3500 <leadingZero>
}
    3578:	08 95       	ret

0000357a <GetFIPAddr>:
	    Result=PPumpID[FIPAddr-1];
	 }
   return Result;
}

char GetFIPAddr(char iPumpID){
    357a:	ff 92       	push	r15
    357c:	0f 93       	push	r16
    357e:	1f 93       	push	r17
    3580:	df 93       	push	r29
    3582:	cf 93       	push	r28
    3584:	cd b7       	in	r28, 0x3d	; 61
    3586:	de b7       	in	r29, 0x3e	; 62
    3588:	28 97       	sbiw	r28, 0x08	; 8
    358a:	0f b6       	in	r0, 0x3f	; 63
    358c:	f8 94       	cli
    358e:	de bf       	out	0x3e, r29	; 62
    3590:	0f be       	out	0x3f, r0	; 63
    3592:	cd bf       	out	0x3d, r28	; 61
    3594:	f8 2e       	mov	r15, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3596:	8e 01       	movw	r16, r28
    3598:	0f 5f       	subi	r16, 0xFF	; 255
    359a:	1f 4f       	sbci	r17, 0xFF	; 255
    359c:	c8 01       	movw	r24, r16
    359e:	65 e4       	ldi	r22, 0x45	; 69
    35a0:	70 e0       	ldi	r23, 0x00	; 0
    35a2:	48 e0       	ldi	r20, 0x08	; 8
    35a4:	50 e0       	ldi	r21, 0x00	; 0
    35a6:	2c ea       	ldi	r18, 0xAC	; 172
    35a8:	32 e1       	ldi	r19, 0x12	; 18
    35aa:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
    35ae:	f8 01       	movw	r30, r16
char i,PPumpID[8],Result;     
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    35b0:	9e 01       	movw	r18, r28
    35b2:	27 5f       	subi	r18, 0xF7	; 247
    35b4:	3f 4f       	sbci	r19, 0xFF	; 255
    35b6:	9e 2f       	mov	r25, r30
    35b8:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==iPumpID){
    35ba:	80 81       	ld	r24, Z
    35bc:	8f 15       	cp	r24, r15
    35be:	19 f4       	brne	.+6      	; 0x35c6 <GetFIPAddr+0x4c>
		     Result=i+1;
    35c0:	89 2f       	mov	r24, r25
    35c2:	8f 5f       	subi	r24, 0xFF	; 255
    35c4:	05 c0       	rjmp	.+10     	; 0x35d0 <GetFIPAddr+0x56>
			 break;
    35c6:	31 96       	adiw	r30, 0x01	; 1

char GetFIPAddr(char iPumpID){
char i,PPumpID[8],Result;     
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    35c8:	e2 17       	cp	r30, r18
    35ca:	f3 07       	cpc	r31, r19
    35cc:	a1 f7       	brne	.-24     	; 0x35b6 <GetFIPAddr+0x3c>
    35ce:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
   return Result;
}
    35d0:	28 96       	adiw	r28, 0x08	; 8
    35d2:	0f b6       	in	r0, 0x3f	; 63
    35d4:	f8 94       	cli
    35d6:	de bf       	out	0x3e, r29	; 62
    35d8:	0f be       	out	0x3f, r0	; 63
    35da:	cd bf       	out	0x3d, r28	; 61
    35dc:	cf 91       	pop	r28
    35de:	df 91       	pop	r29
    35e0:	1f 91       	pop	r17
    35e2:	0f 91       	pop	r16
    35e4:	ff 90       	pop	r15
    35e6:	08 95       	ret

000035e8 <UpdateStandaloneStatus>:
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
         lcd_print(4,1,lcdteks);
     	 }
}

void UpdateStandaloneStatus(char xPumpID,char xPumpStatus){//xPumpID: (1-16)&0x0F
    35e8:	ff 92       	push	r15
    35ea:	0f 93       	push	r16
    35ec:	1f 93       	push	r17
    35ee:	cf 93       	push	r28
    35f0:	df 93       	push	r29
    35f2:	28 2f       	mov	r18, r24
    35f4:	f6 2e       	mov	r15, r22
char iPumpID,strSend[20]; //[xxxxxxxxxPx]
char iAddr;

	 if (xPumpID<16){
    35f6:	80 31       	cpi	r24, 0x10	; 16
    35f8:	08 f0       	brcs	.+2      	; 0x35fc <UpdateStandaloneStatus+0x14>
    35fa:	56 c0       	rjmp	.+172    	; 0x36a8 <UpdateStandaloneStatus+0xc0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    35fc:	e1 99       	sbic	0x1c, 1	; 28
    35fe:	fe cf       	rjmp	.-4      	; 0x35fc <UpdateStandaloneStatus+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3600:	87 e6       	ldi	r24, 0x67	; 103
    3602:	91 e0       	ldi	r25, 0x01	; 1
    3604:	9f bb       	out	0x1f, r25	; 31
    3606:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3608:	e0 9a       	sbi	0x1c, 0	; 28
    360a:	8d b3       	in	r24, 0x1d	; 29
	     DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    360c:	80 93 77 01 	sts	0x0177, r24
	     switch(DispenserBrand){
    3610:	81 30       	cpi	r24, 0x01	; 1
    3612:	21 f0       	breq	.+8      	; 0x361c <UpdateStandaloneStatus+0x34>
    3614:	82 30       	cpi	r24, 0x02	; 2
    3616:	41 f4       	brne	.+16     	; 0x3628 <UpdateStandaloneStatus+0x40>
    3618:	82 2f       	mov	r24, r18
    361a:	06 c0       	rjmp	.+12     	; 0x3628 <UpdateStandaloneStatus+0x40>
	     case ST_GILBARCO:	     
			  if (xPumpID>0)iPumpID=xPumpID-1;
    361c:	22 23       	and	r18, r18
    361e:	11 f4       	brne	.+4      	; 0x3624 <UpdateStandaloneStatus+0x3c>
    3620:	8f e0       	ldi	r24, 0x0F	; 15
    3622:	02 c0       	rjmp	.+4      	; 0x3628 <UpdateStandaloneStatus+0x40>
    3624:	82 2f       	mov	r24, r18
    3626:	81 50       	subi	r24, 0x01	; 1
	          break;
	     case ST_WAYNE_DART:
              iPumpID=xPumpID;
	          break;				   
	     }
		 iAddr=GetFIPAddr(iPumpID);
    3628:	0e 94 bd 1a 	call	0x357a	; 0x357a <GetFIPAddr>
		 if (iAddr>0){
    362c:	88 23       	and	r24, r24
    362e:	e1 f1       	breq	.+120    	; 0x36a8 <UpdateStandaloneStatus+0xc0>
		     iAddr=iAddr-1;
			 if (strPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY)){//iFdiiiiiiiiiiiii
    3630:	81 50       	subi	r24, 0x01	; 1
    3632:	c8 2f       	mov	r28, r24
    3634:	d0 e0       	ldi	r29, 0x00	; 0
    3636:	80 e1       	ldi	r24, 0x10	; 16
    3638:	0e 94 c2 12 	call	0x2584	; 0x2584 <GetPumpStatusLabel>
    363c:	8e 01       	movw	r16, r28
    363e:	09 5d       	subi	r16, 0xD9	; 217
    3640:	1e 4f       	sbci	r17, 0xFE	; 254
    3642:	f8 01       	movw	r30, r16
    3644:	90 81       	ld	r25, Z
    3646:	98 17       	cp	r25, r24
    3648:	b1 f0       	breq	.+44     	; 0x3676 <UpdateStandaloneStatus+0x8e>
		         if (xPumpStatus!=PS_PRINT_READY)
    364a:	f0 e1       	ldi	r31, 0x10	; 16
    364c:	ff 16       	cp	r15, r31
    364e:	21 f0       	breq	.+8      	; 0x3658 <UpdateStandaloneStatus+0x70>
				     CurrentPumpStatus[iAddr]=xPumpStatus;
    3650:	fe 01       	movw	r30, r28
    3652:	e8 58       	subi	r30, 0x88	; 136
    3654:	fe 4f       	sbci	r31, 0xFE	; 254
    3656:	f0 82       	st	Z, r15
			     strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    3658:	8f 2d       	mov	r24, r15
    365a:	0e 94 c2 12 	call	0x2584	; 0x2584 <GetPumpStatusLabel>
    365e:	8e 01       	movw	r16, r28
    3660:	09 5d       	subi	r16, 0xD9	; 217
    3662:	1e 4f       	sbci	r17, 0xFE	; 254
    3664:	f8 01       	movw	r30, r16
    3666:	80 83       	st	Z, r24
                 if (xPumpStatus==PS_FINISH_TOTALIZER)
    3668:	f5 e1       	ldi	r31, 0x15	; 21
    366a:	ff 16       	cp	r15, r31
    366c:	c1 f4       	brne	.+48     	; 0x369e <UpdateStandaloneStatus+0xb6>
				     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    366e:	c8 58       	subi	r28, 0x88	; 136
    3670:	de 4f       	sbci	r29, 0xFE	; 254
    3672:	88 81       	ld	r24, Y
    3674:	10 c0       	rjmp	.+32     	; 0x3696 <UpdateStandaloneStatus+0xae>
    3676:	fe 01       	movw	r30, r28
    3678:	e8 58       	subi	r30, 0x88	; 136
    367a:	fe 4f       	sbci	r31, 0xFE	; 254
		     }else if ((strPumpStatus[iAddr]==GetPumpStatusLabel(PS_PRINT_READY))||(xPumpStatus==PUMP_FEOT)||(xPumpStatus==PS_PRINTED)||(xPumpStatus==PS_TOTALIZER)){//P
			     if (xPumpStatus==PS_PRINTED)
    367c:	81 e1       	ldi	r24, 0x11	; 17
    367e:	f8 16       	cp	r15, r24
    3680:	11 f4       	brne	.+4      	; 0x3686 <UpdateStandaloneStatus+0x9e>
			         strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    3682:	80 81       	ld	r24, Z
    3684:	08 c0       	rjmp	.+16     	; 0x3696 <UpdateStandaloneStatus+0xae>
			     else CurrentPumpStatus[iAddr]=xPumpStatus;			 
    3686:	f0 82       	st	Z, r15
			 if (xPumpStatus==PUMP_FEOT){
    3688:	8b e0       	ldi	r24, 0x0B	; 11
    368a:	f8 16       	cp	r15, r24
    368c:	21 f0       	breq	.+8      	; 0x3696 <UpdateStandaloneStatus+0xae>
			     CurrentPumpStatus[iAddr]=xPumpStatus;
			     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
				 }
             else if (xPumpStatus==PS_TOTALIZER){
    368e:	f4 e1       	ldi	r31, 0x14	; 20
    3690:	ff 16       	cp	r15, r31
    3692:	29 f4       	brne	.+10     	; 0x369e <UpdateStandaloneStatus+0xb6>
			      strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    3694:	84 e1       	ldi	r24, 0x14	; 20
    3696:	0e 94 c2 12 	call	0x2584	; 0x2584 <GetPumpStatusLabel>
    369a:	f8 01       	movw	r30, r16
    369c:	80 83       	st	Z, r24
				 }
		 }		 	     
         strPumpStatus[16]=0;
    369e:	10 92 37 01 	sts	0x0137, r1
	     IsNewPumpStatus=True;		 
    36a2:	81 e0       	ldi	r24, 0x01	; 1
    36a4:	80 93 26 01 	sts	0x0126, r24
		 }		 
	 }
}
    36a8:	df 91       	pop	r29
    36aa:	cf 91       	pop	r28
    36ac:	1f 91       	pop	r17
    36ae:	0f 91       	pop	r16
    36b0:	ff 90       	pop	r15
    36b2:	08 95       	ret

000036b4 <GetPumpID>:
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
}


char GetPumpID(char FIPAddr){//Find Stored PumpID in PumpMap
    36b4:	1f 93       	push	r17
    36b6:	df 93       	push	r29
    36b8:	cf 93       	push	r28
    36ba:	cd b7       	in	r28, 0x3d	; 61
    36bc:	de b7       	in	r29, 0x3e	; 62
    36be:	28 97       	sbiw	r28, 0x08	; 8
    36c0:	0f b6       	in	r0, 0x3f	; 63
    36c2:	f8 94       	cli
    36c4:	de bf       	out	0x3e, r29	; 62
    36c6:	0f be       	out	0x3f, r0	; 63
    36c8:	cd bf       	out	0x3d, r28	; 61
    36ca:	18 2f       	mov	r17, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    36cc:	ce 01       	movw	r24, r28
    36ce:	01 96       	adiw	r24, 0x01	; 1
    36d0:	65 e4       	ldi	r22, 0x45	; 69
    36d2:	70 e0       	ldi	r23, 0x00	; 0
    36d4:	48 e0       	ldi	r20, 0x08	; 8
    36d6:	50 e0       	ldi	r21, 0x00	; 0
    36d8:	2c ea       	ldi	r18, 0xAC	; 172
    36da:	32 e1       	ldi	r19, 0x12	; 18
    36dc:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
     char PPumpID[8],Result;     
     eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 Result=0;
	 if ((FIPAddr>0) && (FIPAddr<8)){
    36e0:	81 2f       	mov	r24, r17
    36e2:	81 50       	subi	r24, 0x01	; 1
    36e4:	87 30       	cpi	r24, 0x07	; 7
    36e6:	10 f0       	brcs	.+4      	; 0x36ec <GetPumpID+0x38>
    36e8:	80 e0       	ldi	r24, 0x00	; 0
    36ea:	04 c0       	rjmp	.+8      	; 0x36f4 <GetPumpID+0x40>
	    Result=PPumpID[FIPAddr-1];
    36ec:	fe 01       	movw	r30, r28
    36ee:	e1 0f       	add	r30, r17
    36f0:	f1 1d       	adc	r31, r1
    36f2:	80 81       	ld	r24, Z
	 }
   return Result;
}
    36f4:	28 96       	adiw	r28, 0x08	; 8
    36f6:	0f b6       	in	r0, 0x3f	; 63
    36f8:	f8 94       	cli
    36fa:	de bf       	out	0x3e, r29	; 62
    36fc:	0f be       	out	0x3f, r0	; 63
    36fe:	cd bf       	out	0x3d, r28	; 61
    3700:	cf 91       	pop	r28
    3702:	df 91       	pop	r29
    3704:	1f 91       	pop	r17
    3706:	08 95       	ret

00003708 <GetTotalizerData>:
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
}



void GetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "0000000"
    3708:	0f 93       	push	r16
    370a:	1f 93       	push	r17
    370c:	df 93       	push	r29
    370e:	cf 93       	push	r28
    3710:	00 d0       	rcall	.+0      	; 0x3712 <GetTotalizerData+0xa>
    3712:	00 d0       	rcall	.+0      	; 0x3714 <GetTotalizerData+0xc>
    3714:	00 d0       	rcall	.+0      	; 0x3716 <GetTotalizerData+0xe>
    3716:	cd b7       	in	r28, 0x3d	; 61
    3718:	de b7       	in	r29, 0x3e	; 62
    371a:	96 2f       	mov	r25, r22
     char rawValue[6],iPumpAddr,iGrade;

	 iPumpAddr=(xPumpAddr&0x0F);
    371c:	4f 70       	andi	r20, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    371e:	21 50       	subi	r18, 0x01	; 1
    3720:	26 30       	cpi	r18, 0x06	; 6
    3722:	08 f4       	brcc	.+2      	; 0x3726 <GetTotalizerData+0x1e>
    3724:	52 2f       	mov	r21, r18
	     iGrade=xGradeAddr-1;
     
//TotalVolume[2][16][6][6];
//GetTotalizerData(TVOLUME,TOTALIZER_LAST,PumpNum,xGrade,strLastVolume);
	 if (TType==TVOLUME)eeprom_read_block((void*) &rawValue, (const void*) &(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    3726:	88 23       	and	r24, r24
    3728:	d9 f4       	brne	.+54     	; 0x3760 <GetTotalizerData+0x58>
    372a:	64 e2       	ldi	r22, 0x24	; 36
    372c:	46 9f       	mul	r20, r22
    372e:	b0 01       	movw	r22, r0
    3730:	11 24       	eor	r1, r1
    3732:	29 2f       	mov	r18, r25
    3734:	30 e0       	ldi	r19, 0x00	; 0
    3736:	80 e2       	ldi	r24, 0x20	; 32
    3738:	91 e0       	ldi	r25, 0x01	; 1
    373a:	fc 01       	movw	r30, r24
    373c:	2e 9f       	mul	r18, r30
    373e:	c0 01       	movw	r24, r0
    3740:	2f 9f       	mul	r18, r31
    3742:	90 0d       	add	r25, r0
    3744:	3e 9f       	mul	r19, r30
    3746:	90 0d       	add	r25, r0
    3748:	11 24       	eor	r1, r1
    374a:	68 0f       	add	r22, r24
    374c:	79 1f       	adc	r23, r25
    374e:	86 e0       	ldi	r24, 0x06	; 6
    3750:	58 9f       	mul	r21, r24
    3752:	c0 01       	movw	r24, r0
    3754:	11 24       	eor	r1, r1
    3756:	68 0f       	add	r22, r24
    3758:	79 1f       	adc	r23, r25
    375a:	6e 50       	subi	r22, 0x0E	; 14
    375c:	7c 4f       	sbci	r23, 0xFC	; 252
    375e:	1c c0       	rjmp	.+56     	; 0x3798 <GetTotalizerData+0x90>
	 else 
	 if (TType==TMONEY)eeprom_read_block((void*) &rawValue, (const void*) &(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    3760:	81 30       	cpi	r24, 0x01	; 1
    3762:	11 f5       	brne	.+68     	; 0x37a8 <GetTotalizerData+0xa0>
    3764:	64 e2       	ldi	r22, 0x24	; 36
    3766:	46 9f       	mul	r20, r22
    3768:	b0 01       	movw	r22, r0
    376a:	11 24       	eor	r1, r1
    376c:	29 2f       	mov	r18, r25
    376e:	30 e0       	ldi	r19, 0x00	; 0
    3770:	80 e2       	ldi	r24, 0x20	; 32
    3772:	91 e0       	ldi	r25, 0x01	; 1
    3774:	fc 01       	movw	r30, r24
    3776:	2e 9f       	mul	r18, r30
    3778:	c0 01       	movw	r24, r0
    377a:	2f 9f       	mul	r18, r31
    377c:	90 0d       	add	r25, r0
    377e:	3e 9f       	mul	r19, r30
    3780:	90 0d       	add	r25, r0
    3782:	11 24       	eor	r1, r1
    3784:	68 0f       	add	r22, r24
    3786:	79 1f       	adc	r23, r25
    3788:	86 e0       	ldi	r24, 0x06	; 6
    378a:	58 9f       	mul	r21, r24
    378c:	c0 01       	movw	r24, r0
    378e:	11 24       	eor	r1, r1
    3790:	68 0f       	add	r22, r24
    3792:	79 1f       	adc	r23, r25
    3794:	6e 5c       	subi	r22, 0xCE	; 206
    3796:	79 4f       	sbci	r23, 0xF9	; 249
    3798:	ce 01       	movw	r24, r28
    379a:	01 96       	adiw	r24, 0x01	; 1
    379c:	46 e0       	ldi	r20, 0x06	; 6
    379e:	50 e0       	ldi	r21, 0x00	; 0
    37a0:	2c ea       	ldi	r18, 0xAC	; 172
    37a2:	32 e1       	ldi	r19, 0x12	; 18
    37a4:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
	 //Convert RawData to String 
	 RawToStr(rawValue,strValue);
    37a8:	ce 01       	movw	r24, r28
    37aa:	01 96       	adiw	r24, 0x01	; 1
    37ac:	b8 01       	movw	r22, r16
    37ae:	0e 94 a9 18 	call	0x3152	; 0x3152 <RawToStr>
}
    37b2:	26 96       	adiw	r28, 0x06	; 6
    37b4:	0f b6       	in	r0, 0x3f	; 63
    37b6:	f8 94       	cli
    37b8:	de bf       	out	0x3e, r29	; 62
    37ba:	0f be       	out	0x3f, r0	; 63
    37bc:	cd bf       	out	0x3d, r28	; 61
    37be:	cf 91       	pop	r28
    37c0:	df 91       	pop	r29
    37c2:	1f 91       	pop	r17
    37c4:	0f 91       	pop	r16
    37c6:	08 95       	ret

000037c8 <SelectMark>:
	      break;
	 }
    return Result;
}

char SelectMark(char InMark){
    37c8:	df 92       	push	r13
    37ca:	ef 92       	push	r14
    37cc:	ff 92       	push	r15
    37ce:	0f 93       	push	r16
    37d0:	1f 93       	push	r17
    37d2:	df 93       	push	r29
    37d4:	cf 93       	push	r28
    37d6:	00 d0       	rcall	.+0      	; 0x37d8 <SelectMark+0x10>
    37d8:	00 d0       	rcall	.+0      	; 0x37da <SelectMark+0x12>
    37da:	0f 92       	push	r0
    37dc:	cd b7       	in	r28, 0x3d	; 61
    37de:	de b7       	in	r29, 0x3e	; 62
    37e0:	d8 2e       	mov	r13, r24
    37e2:	8e 01       	movw	r16, r28
    37e4:	0f 5f       	subi	r16, 0xFF	; 255
    37e6:	1f 4f       	sbci	r17, 0xFF	; 255
    37e8:	c8 01       	movw	r24, r16
    37ea:	60 e4       	ldi	r22, 0x40	; 64
    37ec:	70 e0       	ldi	r23, 0x00	; 0
    37ee:	45 e0       	ldi	r20, 0x05	; 5
    37f0:	50 e0       	ldi	r21, 0x00	; 0
    37f2:	2c ea       	ldi	r18, 0xAC	; 172
    37f4:	32 e1       	ldi	r19, 0x12	; 18
    37f6:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
    37fa:	ed 2d       	mov	r30, r13
    37fc:	21 e0       	ldi	r18, 0x01	; 1
    37fe:	30 e0       	ldi	r19, 0x00	; 0
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
    3800:	78 01       	movw	r14, r16
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
    3802:	d8 01       	movw	r26, r16
    3804:	8c 91       	ld	r24, X
    3806:	d8 16       	cp	r13, r24
    3808:	49 f4       	brne	.+18     	; 0x381c <SelectMark+0x54>
		     Result=PMark[(i+1)%Length];
    380a:	c9 01       	movw	r24, r18
    380c:	65 e0       	ldi	r22, 0x05	; 5
    380e:	70 e0       	ldi	r23, 0x00	; 0
    3810:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    3814:	f7 01       	movw	r30, r14
    3816:	e8 0f       	add	r30, r24
    3818:	f9 1f       	adc	r31, r25
    381a:	e0 81       	ld	r30, Z
    381c:	0f 5f       	subi	r16, 0xFF	; 255
    381e:	1f 4f       	sbci	r17, 0xFF	; 255
    3820:	2f 5f       	subi	r18, 0xFF	; 255
    3822:	3f 4f       	sbci	r19, 0xFF	; 255
char SelectMark(char InMark){
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
    3824:	26 30       	cpi	r18, 0x06	; 6
    3826:	31 05       	cpc	r19, r1
    3828:	61 f7       	brne	.-40     	; 0x3802 <SelectMark+0x3a>
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
	 }
     return Result;
}
    382a:	8e 2f       	mov	r24, r30
    382c:	0f 90       	pop	r0
    382e:	0f 90       	pop	r0
    3830:	0f 90       	pop	r0
    3832:	0f 90       	pop	r0
    3834:	0f 90       	pop	r0
    3836:	cf 91       	pop	r28
    3838:	df 91       	pop	r29
    383a:	1f 91       	pop	r17
    383c:	0f 91       	pop	r16
    383e:	ff 90       	pop	r15
    3840:	ef 90       	pop	r14
    3842:	df 90       	pop	r13
    3844:	08 95       	ret

00003846 <UpdateServerIP>:
	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
}
void UpdateServerIP(){     
    3846:	cf 92       	push	r12
    3848:	df 92       	push	r13
    384a:	ef 92       	push	r14
    384c:	ff 92       	push	r15
    384e:	0f 93       	push	r16
    3850:	1f 93       	push	r17
    3852:	df 93       	push	r29
    3854:	cf 93       	push	r28
    3856:	cd b7       	in	r28, 0x3d	; 61
    3858:	de b7       	in	r29, 0x3e	; 62
    385a:	64 97       	sbiw	r28, 0x14	; 20
    385c:	0f b6       	in	r0, 0x3f	; 63
    385e:	f8 94       	cli
    3860:	de bf       	out	0x3e, r29	; 62
    3862:	0f be       	out	0x3f, r0	; 63
    3864:	cd bf       	out	0x3d, r28	; 61
    3866:	8e 01       	movw	r16, r28
    3868:	0f 5f       	subi	r16, 0xFF	; 255
    386a:	1f 4f       	sbci	r17, 0xFF	; 255
    386c:	c8 01       	movw	r24, r16
    386e:	6c e2       	ldi	r22, 0x2C	; 44
    3870:	70 e0       	ldi	r23, 0x00	; 0
    3872:	44 e0       	ldi	r20, 0x04	; 4
    3874:	50 e0       	ldi	r21, 0x00	; 0
    3876:	2c ea       	ldi	r18, 0xAC	; 172
    3878:	32 e1       	ldi	r19, 0x12	; 18
    387a:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
    387e:	78 01       	movw	r14, r16
    3880:	8e 01       	movw	r16, r28
    3882:	0b 5f       	subi	r16, 0xFB	; 251
    3884:	1f 4f       	sbci	r17, 0xFF	; 255
	 char strIP[4][4];
	 //192.168.016.180
     eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);

	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
    3886:	68 01       	movw	r12, r16
    3888:	d7 01       	movw	r26, r14
    388a:	8d 91       	ld	r24, X+
    388c:	7d 01       	movw	r14, r26
    388e:	b8 01       	movw	r22, r16
    3890:	0e 94 7b 15 	call	0x2af6	; 0x2af6 <zeroIP>
    3894:	0c 5f       	subi	r16, 0xFC	; 252
    3896:	1f 4f       	sbci	r17, 0xFF	; 255
     char i,IP_blok[4];
	 char strIP[4][4];
	 //192.168.016.180
     eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);

	 for(i=0;i<4;i++){
    3898:	ec 14       	cp	r14, r12
    389a:	fd 04       	cpc	r15, r13
    389c:	a9 f7       	brne	.-22     	; 0x3888 <UpdateServerIP+0x42>
	     zeroIP(IP_blok[i],strIP[i]);
	 }
		 sprintf_P(strServerIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
    389e:	ed b7       	in	r30, 0x3d	; 61
    38a0:	fe b7       	in	r31, 0x3e	; 62
    38a2:	3c 97       	sbiw	r30, 0x0c	; 12
    38a4:	0f b6       	in	r0, 0x3f	; 63
    38a6:	f8 94       	cli
    38a8:	fe bf       	out	0x3e, r31	; 62
    38aa:	0f be       	out	0x3f, r0	; 63
    38ac:	ed bf       	out	0x3d, r30	; 61
    38ae:	31 96       	adiw	r30, 0x01	; 1
    38b0:	87 e1       	ldi	r24, 0x17	; 23
    38b2:	9a e0       	ldi	r25, 0x0A	; 10
    38b4:	ad b7       	in	r26, 0x3d	; 61
    38b6:	be b7       	in	r27, 0x3e	; 62
    38b8:	12 96       	adiw	r26, 0x02	; 2
    38ba:	9c 93       	st	X, r25
    38bc:	8e 93       	st	-X, r24
    38be:	11 97       	sbiw	r26, 0x01	; 1
    38c0:	8c e6       	ldi	r24, 0x6C	; 108
    38c2:	91 e2       	ldi	r25, 0x21	; 33
    38c4:	93 83       	std	Z+3, r25	; 0x03
    38c6:	82 83       	std	Z+2, r24	; 0x02
    38c8:	f5 82       	std	Z+5, r15	; 0x05
    38ca:	e4 82       	std	Z+4, r14	; 0x04
    38cc:	ce 01       	movw	r24, r28
    38ce:	09 96       	adiw	r24, 0x09	; 9
    38d0:	97 83       	std	Z+7, r25	; 0x07
    38d2:	86 83       	std	Z+6, r24	; 0x06
    38d4:	ce 01       	movw	r24, r28
    38d6:	0d 96       	adiw	r24, 0x0d	; 13
    38d8:	91 87       	std	Z+9, r25	; 0x09
    38da:	80 87       	std	Z+8, r24	; 0x08
    38dc:	ce 01       	movw	r24, r28
    38de:	41 96       	adiw	r24, 0x11	; 17
    38e0:	93 87       	std	Z+11, r25	; 0x0b
    38e2:	82 87       	std	Z+10, r24	; 0x0a
    38e4:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    38e8:	ed b7       	in	r30, 0x3d	; 61
    38ea:	fe b7       	in	r31, 0x3e	; 62
    38ec:	3c 96       	adiw	r30, 0x0c	; 12
    38ee:	0f b6       	in	r0, 0x3f	; 63
    38f0:	f8 94       	cli
    38f2:	fe bf       	out	0x3e, r31	; 62
    38f4:	0f be       	out	0x3f, r0	; 63
    38f6:	ed bf       	out	0x3d, r30	; 61
}
    38f8:	64 96       	adiw	r28, 0x14	; 20
    38fa:	0f b6       	in	r0, 0x3f	; 63
    38fc:	f8 94       	cli
    38fe:	de bf       	out	0x3e, r29	; 62
    3900:	0f be       	out	0x3f, r0	; 63
    3902:	cd bf       	out	0x3d, r28	; 61
    3904:	cf 91       	pop	r28
    3906:	df 91       	pop	r29
    3908:	1f 91       	pop	r17
    390a:	0f 91       	pop	r16
    390c:	ff 90       	pop	r15
    390e:	ef 90       	pop	r14
    3910:	df 90       	pop	r13
    3912:	cf 90       	pop	r12
    3914:	08 95       	ret

00003916 <UpdateClientIP>:
	     str[0]=('0'+S);
	     str[1]=0;
	 }
}

void UpdateClientIP(){     
    3916:	cf 92       	push	r12
    3918:	df 92       	push	r13
    391a:	ef 92       	push	r14
    391c:	ff 92       	push	r15
    391e:	0f 93       	push	r16
    3920:	1f 93       	push	r17
    3922:	df 93       	push	r29
    3924:	cf 93       	push	r28
    3926:	cd b7       	in	r28, 0x3d	; 61
    3928:	de b7       	in	r29, 0x3e	; 62
    392a:	68 97       	sbiw	r28, 0x18	; 24
    392c:	0f b6       	in	r0, 0x3f	; 63
    392e:	f8 94       	cli
    3930:	de bf       	out	0x3e, r29	; 62
    3932:	0f be       	out	0x3f, r0	; 63
    3934:	cd bf       	out	0x3d, r28	; 61
    3936:	8e 01       	movw	r16, r28
    3938:	0f 5f       	subi	r16, 0xFF	; 255
    393a:	1f 4f       	sbci	r17, 0xFF	; 255
    393c:	c8 01       	movw	r24, r16
    393e:	68 e2       	ldi	r22, 0x28	; 40
    3940:	70 e0       	ldi	r23, 0x00	; 0
    3942:	44 e0       	ldi	r20, 0x04	; 4
    3944:	50 e0       	ldi	r21, 0x00	; 0
    3946:	2c ea       	ldi	r18, 0xAC	; 172
    3948:	32 e1       	ldi	r19, 0x12	; 18
    394a:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
    394e:	78 01       	movw	r14, r16
    3950:	8e 01       	movw	r16, r28
    3952:	0b 5f       	subi	r16, 0xFB	; 251
    3954:	1f 4f       	sbci	r17, 0xFF	; 255
	 char strIP[4][5];
	 //192.168.010.002
     eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);

	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
    3956:	68 01       	movw	r12, r16
    3958:	d7 01       	movw	r26, r14
    395a:	8d 91       	ld	r24, X+
    395c:	7d 01       	movw	r14, r26
    395e:	b8 01       	movw	r22, r16
    3960:	0e 94 7b 15 	call	0x2af6	; 0x2af6 <zeroIP>
    3964:	0b 5f       	subi	r16, 0xFB	; 251
    3966:	1f 4f       	sbci	r17, 0xFF	; 255
     char i,IP_blok[4];
	 char strIP[4][5];
	 //192.168.010.002
     eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);

	 for(i=0;i<4;i++){
    3968:	ec 14       	cp	r14, r12
    396a:	fd 04       	cpc	r15, r13
    396c:	a9 f7       	brne	.-22     	; 0x3958 <UpdateClientIP+0x42>
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
    396e:	ed b7       	in	r30, 0x3d	; 61
    3970:	fe b7       	in	r31, 0x3e	; 62
    3972:	3c 97       	sbiw	r30, 0x0c	; 12
    3974:	0f b6       	in	r0, 0x3f	; 63
    3976:	f8 94       	cli
    3978:	fe bf       	out	0x3e, r31	; 62
    397a:	0f be       	out	0x3f, r0	; 63
    397c:	ed bf       	out	0x3d, r30	; 61
    397e:	31 96       	adiw	r30, 0x01	; 1
    3980:	8a ee       	ldi	r24, 0xEA	; 234
    3982:	99 e0       	ldi	r25, 0x09	; 9
    3984:	ad b7       	in	r26, 0x3d	; 61
    3986:	be b7       	in	r27, 0x3e	; 62
    3988:	12 96       	adiw	r26, 0x02	; 2
    398a:	9c 93       	st	X, r25
    398c:	8e 93       	st	-X, r24
    398e:	11 97       	sbiw	r26, 0x01	; 1
    3990:	88 e7       	ldi	r24, 0x78	; 120
    3992:	91 e2       	ldi	r25, 0x21	; 33
    3994:	93 83       	std	Z+3, r25	; 0x03
    3996:	82 83       	std	Z+2, r24	; 0x02
    3998:	f5 82       	std	Z+5, r15	; 0x05
    399a:	e4 82       	std	Z+4, r14	; 0x04
    399c:	ce 01       	movw	r24, r28
    399e:	0a 96       	adiw	r24, 0x0a	; 10
    39a0:	97 83       	std	Z+7, r25	; 0x07
    39a2:	86 83       	std	Z+6, r24	; 0x06
    39a4:	ce 01       	movw	r24, r28
    39a6:	0f 96       	adiw	r24, 0x0f	; 15
    39a8:	91 87       	std	Z+9, r25	; 0x09
    39aa:	80 87       	std	Z+8, r24	; 0x08
    39ac:	ce 01       	movw	r24, r28
    39ae:	44 96       	adiw	r24, 0x14	; 20
    39b0:	93 87       	std	Z+11, r25	; 0x0b
    39b2:	82 87       	std	Z+10, r24	; 0x0a
    39b4:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    39b8:	ed b7       	in	r30, 0x3d	; 61
    39ba:	fe b7       	in	r31, 0x3e	; 62
    39bc:	3c 96       	adiw	r30, 0x0c	; 12
    39be:	0f b6       	in	r0, 0x3f	; 63
    39c0:	f8 94       	cli
    39c2:	fe bf       	out	0x3e, r31	; 62
    39c4:	0f be       	out	0x3f, r0	; 63
    39c6:	ed bf       	out	0x3d, r30	; 61
}
    39c8:	68 96       	adiw	r28, 0x18	; 24
    39ca:	0f b6       	in	r0, 0x3f	; 63
    39cc:	f8 94       	cli
    39ce:	de bf       	out	0x3e, r29	; 62
    39d0:	0f be       	out	0x3f, r0	; 63
    39d2:	cd bf       	out	0x3d, r28	; 61
    39d4:	cf 91       	pop	r28
    39d6:	df 91       	pop	r29
    39d8:	1f 91       	pop	r17
    39da:	0f 91       	pop	r16
    39dc:	ff 90       	pop	r15
    39de:	ef 90       	pop	r14
    39e0:	df 90       	pop	r13
    39e2:	cf 90       	pop	r12
    39e4:	08 95       	ret

000039e6 <GenerateStandaloneTransData>:

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}


char GenerateStandaloneTransData(char xPumpID, char *PNozzle){//[1,2,3..16]->[1,2,3..0]
    39e6:	cf 92       	push	r12
    39e8:	df 92       	push	r13
    39ea:	ef 92       	push	r14
    39ec:	ff 92       	push	r15
    39ee:	0f 93       	push	r16
    39f0:	1f 93       	push	r17
    39f2:	df 93       	push	r29
    39f4:	cf 93       	push	r28
    39f6:	cd b7       	in	r28, 0x3d	; 61
    39f8:	de b7       	in	r29, 0x3e	; 62
    39fa:	2f 97       	sbiw	r28, 0x0f	; 15
    39fc:	0f b6       	in	r0, 0x3f	; 63
    39fe:	f8 94       	cli
    3a00:	de bf       	out	0x3e, r29	; 62
    3a02:	0f be       	out	0x3f, r0	; 63
    3a04:	cd bf       	out	0x3d, r28	; 61
    3a06:	e8 2e       	mov	r14, r24
    3a08:	8b 01       	movw	r16, r22
     char Result=GS_NONE;
	 char strSend[30];
	 char FIPAddr;

	 iPumpID=(xPumpID&0x0F);
	 FIPAddr=GetFIPAddr(iPumpID);
    3a0a:	8f 70       	andi	r24, 0x0F	; 15
    3a0c:	0e 94 bd 1a 	call	0x357a	; 0x357a <GetFIPAddr>
     if (FIPAddr>0){
    3a10:	88 23       	and	r24, r24
    3a12:	09 f4       	brne	.+2      	; 0x3a16 <GenerateStandaloneTransData+0x30>
    3a14:	2d c1       	rjmp	.+602    	; 0x3c70 <GenerateStandaloneTransData+0x28a>
	     FIPAddr=FIPAddr-1;
		 iProdID=PNozzle[RecPumpData[FIPAddr].Grade];
    3a16:	81 50       	subi	r24, 0x01	; 1
    3a18:	c8 2e       	mov	r12, r24
    3a1a:	dd 24       	eor	r13, r13
    3a1c:	85 e3       	ldi	r24, 0x35	; 53
    3a1e:	90 e0       	ldi	r25, 0x00	; 0
    3a20:	c8 9e       	mul	r12, r24
    3a22:	f0 01       	movw	r30, r0
    3a24:	c9 9e       	mul	r12, r25
    3a26:	f0 0d       	add	r31, r0
    3a28:	d8 9e       	mul	r13, r24
    3a2a:	f0 0d       	add	r31, r0
    3a2c:	11 24       	eor	r1, r1
    3a2e:	e9 54       	subi	r30, 0x49	; 73
    3a30:	f8 4f       	sbci	r31, 0xF8	; 248
    3a32:	80 81       	ld	r24, Z
    3a34:	08 0f       	add	r16, r24
    3a36:	11 1d       	adc	r17, r1
    3a38:	d8 01       	movw	r26, r16
    3a3a:	2c 91       	ld	r18, X
    3a3c:	ce 01       	movw	r24, r28
    3a3e:	01 96       	adiw	r24, 0x01	; 1

		 if (iProdID>0) eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[iProdID-1],sizeof(DefProductName[iProdID-1]));
    3a40:	22 23       	and	r18, r18
    3a42:	69 f0       	breq	.+26     	; 0x3a5e <GenerateStandaloneTransData+0x78>
    3a44:	6d e0       	ldi	r22, 0x0D	; 13
    3a46:	26 9f       	mul	r18, r22
    3a48:	b0 01       	movw	r22, r0
    3a4a:	11 24       	eor	r1, r1
    3a4c:	62 52       	subi	r22, 0x22	; 34
    3a4e:	7f 4f       	sbci	r23, 0xFF	; 255
    3a50:	4d e0       	ldi	r20, 0x0D	; 13
    3a52:	50 e0       	ldi	r21, 0x00	; 0
    3a54:	2c ea       	ldi	r18, 0xAC	; 172
    3a56:	32 e1       	ldi	r19, 0x12	; 18
    3a58:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
    3a5c:	10 c0       	rjmp	.+32     	; 0x3a7e <GenerateStandaloneTransData+0x98>
		 else sprintf_P(ProductName,PSTR("N/A"));
    3a5e:	00 d0       	rcall	.+0      	; 0x3a60 <GenerateStandaloneTransData+0x7a>
    3a60:	00 d0       	rcall	.+0      	; 0x3a62 <GenerateStandaloneTransData+0x7c>
    3a62:	ed b7       	in	r30, 0x3d	; 61
    3a64:	fe b7       	in	r31, 0x3e	; 62
    3a66:	92 83       	std	Z+2, r25	; 0x02
    3a68:	81 83       	std	Z+1, r24	; 0x01
    3a6a:	89 e3       	ldi	r24, 0x39	; 57
    3a6c:	92 e2       	ldi	r25, 0x22	; 34
    3a6e:	94 83       	std	Z+4, r25	; 0x04
    3a70:	83 83       	std	Z+3, r24	; 0x03
    3a72:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    3a76:	0f 90       	pop	r0
    3a78:	0f 90       	pop	r0
    3a7a:	0f 90       	pop	r0
    3a7c:	0f 90       	pop	r0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3a7e:	e1 99       	sbic	0x1c, 1	; 28
    3a80:	fe cf       	rjmp	.-4      	; 0x3a7e <GenerateStandaloneTransData+0x98>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a82:	80 e0       	ldi	r24, 0x00	; 0
    3a84:	90 e0       	ldi	r25, 0x00	; 0
    3a86:	9f bb       	out	0x1f, r25	; 31
    3a88:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3a8a:	e0 9a       	sbi	0x1c, 0	; 28
    3a8c:	fd b2       	in	r15, 0x1d	; 29

		 TermID=eeprom_read_byte(&DefIFT_ID);

		 //Shift,TransNum,Date,Time
		 sprintf_P(strShift,PSTR("%d"),RecPumpData[FIPAddr].Shift);
    3a8e:	00 d0       	rcall	.+0      	; 0x3a90 <GenerateStandaloneTransData+0xaa>
    3a90:	00 d0       	rcall	.+0      	; 0x3a92 <GenerateStandaloneTransData+0xac>
    3a92:	00 d0       	rcall	.+0      	; 0x3a94 <GenerateStandaloneTransData+0xae>
    3a94:	ad b7       	in	r26, 0x3d	; 61
    3a96:	be b7       	in	r27, 0x3e	; 62
    3a98:	11 96       	adiw	r26, 0x01	; 1
    3a9a:	83 e7       	ldi	r24, 0x73	; 115
    3a9c:	9e e0       	ldi	r25, 0x0E	; 14
    3a9e:	ed b7       	in	r30, 0x3d	; 61
    3aa0:	fe b7       	in	r31, 0x3e	; 62
    3aa2:	92 83       	std	Z+2, r25	; 0x02
    3aa4:	81 83       	std	Z+1, r24	; 0x01
    3aa6:	86 e3       	ldi	r24, 0x36	; 54
    3aa8:	92 e2       	ldi	r25, 0x22	; 34
    3aaa:	13 96       	adiw	r26, 0x03	; 3
    3aac:	9c 93       	st	X, r25
    3aae:	8e 93       	st	-X, r24
    3ab0:	12 97       	sbiw	r26, 0x02	; 2
    3ab2:	85 e3       	ldi	r24, 0x35	; 53
    3ab4:	90 e0       	ldi	r25, 0x00	; 0
    3ab6:	c8 9e       	mul	r12, r24
    3ab8:	80 01       	movw	r16, r0
    3aba:	c9 9e       	mul	r12, r25
    3abc:	10 0d       	add	r17, r0
    3abe:	d8 9e       	mul	r13, r24
    3ac0:	10 0d       	add	r17, r0
    3ac2:	11 24       	eor	r1, r1
    3ac4:	f8 01       	movw	r30, r16
    3ac6:	e9 54       	subi	r30, 0x49	; 73
    3ac8:	f8 4f       	sbci	r31, 0xF8	; 248
    3aca:	82 81       	ldd	r24, Z+2	; 0x02
    3acc:	14 96       	adiw	r26, 0x04	; 4
    3ace:	8c 93       	st	X, r24
    3ad0:	14 97       	sbiw	r26, 0x04	; 4
    3ad2:	15 96       	adiw	r26, 0x05	; 5
    3ad4:	1c 92       	st	X, r1
    3ad6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		 sprintf_P(strTranNo,PSTR("%s"),RecPumpData[FIPAddr].strTransNum);
    3ada:	ed b7       	in	r30, 0x3d	; 61
    3adc:	fe b7       	in	r31, 0x3e	; 62
    3ade:	31 96       	adiw	r30, 0x01	; 1
    3ae0:	82 e9       	ldi	r24, 0x92	; 146
    3ae2:	9e e0       	ldi	r25, 0x0E	; 14
    3ae4:	ad b7       	in	r26, 0x3d	; 61
    3ae6:	be b7       	in	r27, 0x3e	; 62
    3ae8:	12 96       	adiw	r26, 0x02	; 2
    3aea:	9c 93       	st	X, r25
    3aec:	8e 93       	st	-X, r24
    3aee:	11 97       	sbiw	r26, 0x01	; 1
    3af0:	83 e3       	ldi	r24, 0x33	; 51
    3af2:	92 e2       	ldi	r25, 0x22	; 34
    3af4:	93 83       	std	Z+3, r25	; 0x03
    3af6:	82 83       	std	Z+2, r24	; 0x02
    3af8:	c8 01       	movw	r24, r16
    3afa:	86 54       	subi	r24, 0x46	; 70
    3afc:	98 4f       	sbci	r25, 0xF8	; 248
    3afe:	95 83       	std	Z+5, r25	; 0x05
    3b00:	84 83       	std	Z+4, r24	; 0x04
    3b02:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	     sprintf_P(strDate,PSTR("%s"),RecPumpData[FIPAddr].strTransDate);
    3b06:	ed b7       	in	r30, 0x3d	; 61
    3b08:	fe b7       	in	r31, 0x3e	; 62
    3b0a:	31 96       	adiw	r30, 0x01	; 1
    3b0c:	8d e7       	ldi	r24, 0x7D	; 125
    3b0e:	99 e0       	ldi	r25, 0x09	; 9
    3b10:	ad b7       	in	r26, 0x3d	; 61
    3b12:	be b7       	in	r27, 0x3e	; 62
    3b14:	12 96       	adiw	r26, 0x02	; 2
    3b16:	9c 93       	st	X, r25
    3b18:	8e 93       	st	-X, r24
    3b1a:	11 97       	sbiw	r26, 0x01	; 1
    3b1c:	80 e3       	ldi	r24, 0x30	; 48
    3b1e:	92 e2       	ldi	r25, 0x22	; 34
    3b20:	93 83       	std	Z+3, r25	; 0x03
    3b22:	82 83       	std	Z+2, r24	; 0x02
    3b24:	c8 01       	movw	r24, r16
    3b26:	8f 53       	subi	r24, 0x3F	; 63
    3b28:	98 4f       	sbci	r25, 0xF8	; 248
    3b2a:	95 83       	std	Z+5, r25	; 0x05
    3b2c:	84 83       	std	Z+4, r24	; 0x04
    3b2e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		 sprintf_P(strTime,PSTR("%s"),RecPumpData[FIPAddr].strTransTime);	 
    3b32:	ed b7       	in	r30, 0x3d	; 61
    3b34:	fe b7       	in	r31, 0x3e	; 62
    3b36:	31 96       	adiw	r30, 0x01	; 1
    3b38:	83 e5       	ldi	r24, 0x53	; 83
    3b3a:	95 e0       	ldi	r25, 0x05	; 5
    3b3c:	ad b7       	in	r26, 0x3d	; 61
    3b3e:	be b7       	in	r27, 0x3e	; 62
    3b40:	12 96       	adiw	r26, 0x02	; 2
    3b42:	9c 93       	st	X, r25
    3b44:	8e 93       	st	-X, r24
    3b46:	11 97       	sbiw	r26, 0x01	; 1
    3b48:	8d e2       	ldi	r24, 0x2D	; 45
    3b4a:	92 e2       	ldi	r25, 0x22	; 34
    3b4c:	93 83       	std	Z+3, r25	; 0x03
    3b4e:	82 83       	std	Z+2, r24	; 0x02
    3b50:	c8 01       	movw	r24, r16
    3b52:	86 53       	subi	r24, 0x36	; 54
    3b54:	98 4f       	sbci	r25, 0xF8	; 248
    3b56:	95 83       	std	Z+5, r25	; 0x05
    3b58:	84 83       	std	Z+4, r24	; 0x04
    3b5a:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>

	     //TermID,FIP_ID,Product
		 sprintf_P(strIslandID,PSTR("%d"),TermID);
    3b5e:	ed b7       	in	r30, 0x3d	; 61
    3b60:	fe b7       	in	r31, 0x3e	; 62
    3b62:	31 96       	adiw	r30, 0x01	; 1
    3b64:	8f ef       	ldi	r24, 0xFF	; 255
    3b66:	9a e0       	ldi	r25, 0x0A	; 10
    3b68:	ad b7       	in	r26, 0x3d	; 61
    3b6a:	be b7       	in	r27, 0x3e	; 62
    3b6c:	12 96       	adiw	r26, 0x02	; 2
    3b6e:	9c 93       	st	X, r25
    3b70:	8e 93       	st	-X, r24
    3b72:	11 97       	sbiw	r26, 0x01	; 1
    3b74:	8a e2       	ldi	r24, 0x2A	; 42
    3b76:	92 e2       	ldi	r25, 0x22	; 34
    3b78:	93 83       	std	Z+3, r25	; 0x03
    3b7a:	82 83       	std	Z+2, r24	; 0x02
    3b7c:	f4 82       	std	Z+4, r15	; 0x04
    3b7e:	15 82       	std	Z+5, r1	; 0x05
    3b80:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		 sprintf_P(strFIP_ID,PSTR("%.2d"),xPumpID);
    3b84:	ed b7       	in	r30, 0x3d	; 61
    3b86:	fe b7       	in	r31, 0x3e	; 62
    3b88:	31 96       	adiw	r30, 0x01	; 1
    3b8a:	88 ec       	ldi	r24, 0xC8	; 200
    3b8c:	99 e0       	ldi	r25, 0x09	; 9
    3b8e:	ad b7       	in	r26, 0x3d	; 61
    3b90:	be b7       	in	r27, 0x3e	; 62
    3b92:	12 96       	adiw	r26, 0x02	; 2
    3b94:	9c 93       	st	X, r25
    3b96:	8e 93       	st	-X, r24
    3b98:	11 97       	sbiw	r26, 0x01	; 1
    3b9a:	85 e2       	ldi	r24, 0x25	; 37
    3b9c:	92 e2       	ldi	r25, 0x22	; 34
    3b9e:	93 83       	std	Z+3, r25	; 0x03
    3ba0:	82 83       	std	Z+2, r24	; 0x02
    3ba2:	e4 82       	std	Z+4, r14	; 0x04
    3ba4:	15 82       	std	Z+5, r1	; 0x05
    3ba6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	     sprintf_P(strDescription,PSTR("%s"),ProductName);
    3baa:	ed b7       	in	r30, 0x3d	; 61
    3bac:	fe b7       	in	r31, 0x3e	; 62
    3bae:	31 96       	adiw	r30, 0x01	; 1
    3bb0:	8d e3       	ldi	r24, 0x3D	; 61
    3bb2:	9a e0       	ldi	r25, 0x0A	; 10
    3bb4:	ad b7       	in	r26, 0x3d	; 61
    3bb6:	be b7       	in	r27, 0x3e	; 62
    3bb8:	12 96       	adiw	r26, 0x02	; 2
    3bba:	9c 93       	st	X, r25
    3bbc:	8e 93       	st	-X, r24
    3bbe:	11 97       	sbiw	r26, 0x01	; 1
    3bc0:	82 e2       	ldi	r24, 0x22	; 34
    3bc2:	92 e2       	ldi	r25, 0x22	; 34
    3bc4:	93 83       	std	Z+3, r25	; 0x03
    3bc6:	82 83       	std	Z+2, r24	; 0x02
    3bc8:	ce 01       	movw	r24, r28
    3bca:	01 96       	adiw	r24, 0x01	; 1
    3bcc:	95 83       	std	Z+5, r25	; 0x05
    3bce:	84 83       	std	Z+4, r24	; 0x04
    3bd0:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>

		 //Price Volume Money
		 sprintf_P(strPrice,PSTR("%s"),RecPumpData[FIPAddr].Price);
    3bd4:	ed b7       	in	r30, 0x3d	; 61
    3bd6:	fe b7       	in	r31, 0x3e	; 62
    3bd8:	31 96       	adiw	r30, 0x01	; 1
    3bda:	8d ea       	ldi	r24, 0xAD	; 173
    3bdc:	97 e0       	ldi	r25, 0x07	; 7
    3bde:	ad b7       	in	r26, 0x3d	; 61
    3be0:	be b7       	in	r27, 0x3e	; 62
    3be2:	12 96       	adiw	r26, 0x02	; 2
    3be4:	9c 93       	st	X, r25
    3be6:	8e 93       	st	-X, r24
    3be8:	11 97       	sbiw	r26, 0x01	; 1
    3bea:	8f e1       	ldi	r24, 0x1F	; 31
    3bec:	92 e2       	ldi	r25, 0x22	; 34
    3bee:	93 83       	std	Z+3, r25	; 0x03
    3bf0:	82 83       	std	Z+2, r24	; 0x02
    3bf2:	c8 01       	movw	r24, r16
    3bf4:	8d 52       	subi	r24, 0x2D	; 45
    3bf6:	98 4f       	sbci	r25, 0xF8	; 248
    3bf8:	95 83       	std	Z+5, r25	; 0x05
    3bfa:	84 83       	std	Z+4, r24	; 0x04
    3bfc:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	     sprintf_P(strVolume,PSTR("%s"),RecPumpData[FIPAddr].Volume);
    3c00:	ed b7       	in	r30, 0x3d	; 61
    3c02:	fe b7       	in	r31, 0x3e	; 62
    3c04:	31 96       	adiw	r30, 0x01	; 1
    3c06:	8b e7       	ldi	r24, 0x7B	; 123
    3c08:	95 e0       	ldi	r25, 0x05	; 5
    3c0a:	ad b7       	in	r26, 0x3d	; 61
    3c0c:	be b7       	in	r27, 0x3e	; 62
    3c0e:	12 96       	adiw	r26, 0x02	; 2
    3c10:	9c 93       	st	X, r25
    3c12:	8e 93       	st	-X, r24
    3c14:	11 97       	sbiw	r26, 0x01	; 1
    3c16:	8c e1       	ldi	r24, 0x1C	; 28
    3c18:	92 e2       	ldi	r25, 0x22	; 34
    3c1a:	93 83       	std	Z+3, r25	; 0x03
    3c1c:	82 83       	std	Z+2, r24	; 0x02
    3c1e:	c8 01       	movw	r24, r16
    3c20:	86 52       	subi	r24, 0x26	; 38
    3c22:	98 4f       	sbci	r25, 0xF8	; 248
    3c24:	95 83       	std	Z+5, r25	; 0x05
    3c26:	84 83       	std	Z+4, r24	; 0x04
    3c28:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		 sprintf_P(strAmount,PSTR("%s"),RecPumpData[FIPAddr].Money);
    3c2c:	ed b7       	in	r30, 0x3d	; 61
    3c2e:	fe b7       	in	r31, 0x3e	; 62
    3c30:	31 96       	adiw	r30, 0x01	; 1
    3c32:	8b eb       	ldi	r24, 0xBB	; 187
    3c34:	9d e0       	ldi	r25, 0x0D	; 13
    3c36:	ad b7       	in	r26, 0x3d	; 61
    3c38:	be b7       	in	r27, 0x3e	; 62
    3c3a:	12 96       	adiw	r26, 0x02	; 2
    3c3c:	9c 93       	st	X, r25
    3c3e:	8e 93       	st	-X, r24
    3c40:	11 97       	sbiw	r26, 0x01	; 1
    3c42:	89 e1       	ldi	r24, 0x19	; 25
    3c44:	92 e2       	ldi	r25, 0x22	; 34
    3c46:	93 83       	std	Z+3, r25	; 0x03
    3c48:	82 83       	std	Z+2, r24	; 0x02
    3c4a:	0d 51       	subi	r16, 0x1D	; 29
    3c4c:	18 4f       	sbci	r17, 0xF8	; 248
    3c4e:	15 83       	std	Z+5, r17	; 0x05
    3c50:	04 83       	std	Z+4, r16	; 0x04
    3c52:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>

		 MOPType=MOP_CASH;
    3c56:	10 92 e4 01 	sts	0x01E4, r1
	     IsPrinting=True;	 
    3c5a:	81 e0       	ldi	r24, 0x01	; 1
    3c5c:	80 93 d9 01 	sts	0x01D9, r24
    3c60:	ed b7       	in	r30, 0x3d	; 61
    3c62:	fe b7       	in	r31, 0x3e	; 62
    3c64:	36 96       	adiw	r30, 0x06	; 6
    3c66:	0f b6       	in	r0, 0x3f	; 63
    3c68:	f8 94       	cli
    3c6a:	fe bf       	out	0x3e, r31	; 62
    3c6c:	0f be       	out	0x3f, r0	; 63
    3c6e:	ed bf       	out	0x3d, r30	; 61
	 }
	 //ProductName	 
	 //iProdID=PNozzle[RecPumpData[iPumpID].Nozzle];
	 //BAsedOnGrade
   return Result;
}
    3c70:	2f 96       	adiw	r28, 0x0f	; 15
    3c72:	0f b6       	in	r0, 0x3f	; 63
    3c74:	f8 94       	cli
    3c76:	de bf       	out	0x3e, r29	; 62
    3c78:	0f be       	out	0x3f, r0	; 63
    3c7a:	cd bf       	out	0x3d, r28	; 61
    3c7c:	cf 91       	pop	r28
    3c7e:	df 91       	pop	r29
    3c80:	1f 91       	pop	r17
    3c82:	0f 91       	pop	r16
    3c84:	ff 90       	pop	r15
    3c86:	ef 90       	pop	r14
    3c88:	df 90       	pop	r13
    3c8a:	cf 90       	pop	r12
    3c8c:	08 95       	ret

00003c8e <PrintStandalone>:
     char Result=PS_NONE;

   return Result;
}

char PrintStandalone(char FIPAddr,char IsReprint){
    3c8e:	ef 92       	push	r14
    3c90:	ff 92       	push	r15
    3c92:	0f 93       	push	r16
    3c94:	1f 93       	push	r17
    3c96:	df 93       	push	r29
    3c98:	cf 93       	push	r28
    3c9a:	00 d0       	rcall	.+0      	; 0x3c9c <PrintStandalone+0xe>
    3c9c:	00 d0       	rcall	.+0      	; 0x3c9e <PrintStandalone+0x10>
    3c9e:	00 d0       	rcall	.+0      	; 0x3ca0 <PrintStandalone+0x12>
    3ca0:	cd b7       	in	r28, 0x3d	; 61
    3ca2:	de b7       	in	r29, 0x3e	; 62
    3ca4:	f8 2e       	mov	r15, r24
    3ca6:	06 2f       	mov	r16, r22
	 char LFIPAddr;
	      
	 Result=PS_NO_DATA;

//	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
	 iPumpID=GetPumpID(FIPAddr);//PPumpID[FIPAddr-1];
    3ca8:	0e 94 5a 1b 	call	0x36b4	; 0x36b4 <GetPumpID>
    3cac:	e8 2e       	mov	r14, r24
     LFIPAddr=GetFIPAddr(iPumpID);
    3cae:	0e 94 bd 1a 	call	0x357a	; 0x357a <GetFIPAddr>
    3cb2:	18 2f       	mov	r17, r24

     if (LFIPAddr>0){
    3cb4:	88 23       	and	r24, r24
    3cb6:	99 f1       	breq	.+102    	; 0x3d1e <PrintStandalone+0x90>
	     LFIPAddr=LFIPAddr-1;
	     if ((IsReprint==True)||(iPumpID>0)&&(strPumpStatus[LFIPAddr]==GetPumpStatusLabel(PS_PRINT_READY))){    	 
    3cb8:	01 30       	cpi	r16, 0x01	; 1
    3cba:	69 f0       	breq	.+26     	; 0x3cd6 <PrintStandalone+0x48>
    3cbc:	ee 20       	and	r14, r14
    3cbe:	79 f1       	breq	.+94     	; 0x3d1e <PrintStandalone+0x90>
    3cc0:	80 e1       	ldi	r24, 0x10	; 16
    3cc2:	0e 94 c2 12 	call	0x2584	; 0x2584 <GetPumpStatusLabel>
    3cc6:	11 50       	subi	r17, 0x01	; 1
    3cc8:	e1 2f       	mov	r30, r17
    3cca:	f0 e0       	ldi	r31, 0x00	; 0
    3ccc:	e9 5d       	subi	r30, 0xD9	; 217
    3cce:	fe 4f       	sbci	r31, 0xFE	; 254
    3cd0:	90 81       	ld	r25, Z
    3cd2:	98 17       	cp	r25, r24
    3cd4:	21 f5       	brne	.+72     	; 0x3d1e <PrintStandalone+0x90>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3cd6:	66 e0       	ldi	r22, 0x06	; 6
    3cd8:	f6 9e       	mul	r15, r22
    3cda:	b0 01       	movw	r22, r0
    3cdc:	11 24       	eor	r1, r1
    3cde:	61 5b       	subi	r22, 0xB1	; 177
    3ce0:	7f 4f       	sbci	r23, 0xFF	; 255
    3ce2:	ce 01       	movw	r24, r28
    3ce4:	01 96       	adiw	r24, 0x01	; 1
    3ce6:	46 e0       	ldi	r20, 0x06	; 6
    3ce8:	50 e0       	ldi	r21, 0x00	; 0
    3cea:	2c ea       	ldi	r18, 0xAC	; 172
    3cec:	32 e1       	ldi	r19, 0x12	; 18
    3cee:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
		     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);		 
		     if (((ReprintReady[FIPAddr-1]==True))||(IsReprint==False)){
    3cf2:	ef 2d       	mov	r30, r15
    3cf4:	f0 e0       	ldi	r31, 0x00	; 0
    3cf6:	e9 56       	subi	r30, 0x69	; 105
    3cf8:	fe 4f       	sbci	r31, 0xFE	; 254
    3cfa:	80 81       	ld	r24, Z
    3cfc:	81 30       	cpi	r24, 0x01	; 1
    3cfe:	19 f0       	breq	.+6      	; 0x3d06 <PrintStandalone+0x78>
    3d00:	00 23       	and	r16, r16
    3d02:	29 f0       	breq	.+10     	; 0x3d0e <PrintStandalone+0x80>
    3d04:	0c c0       	rjmp	.+24     	; 0x3d1e <PrintStandalone+0x90>
			       if (IsReprint==True)IsReprintTicket=True;
    3d06:	01 30       	cpi	r16, 0x01	; 1
    3d08:	11 f4       	brne	.+4      	; 0x3d0e <PrintStandalone+0x80>
    3d0a:	00 93 a8 01 	sts	0x01A8, r16
			       GenerateStandaloneTransData(iPumpID,PProductID);		 			   
    3d0e:	8e 2d       	mov	r24, r14
    3d10:	be 01       	movw	r22, r28
    3d12:	6f 5f       	subi	r22, 0xFF	; 255
    3d14:	7f 4f       	sbci	r23, 0xFF	; 255
    3d16:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <GenerateStandaloneTransData>
    3d1a:	81 e1       	ldi	r24, 0x11	; 17
    3d1c:	01 c0       	rjmp	.+2      	; 0x3d20 <PrintStandalone+0x92>
    3d1e:	82 e1       	ldi	r24, 0x12	; 18
			 }//else Result=PS_NO_DATA;
		 }
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}
    3d20:	26 96       	adiw	r28, 0x06	; 6
    3d22:	0f b6       	in	r0, 0x3f	; 63
    3d24:	f8 94       	cli
    3d26:	de bf       	out	0x3e, r29	; 62
    3d28:	0f be       	out	0x3f, r0	; 63
    3d2a:	cd bf       	out	0x3d, r28	; 61
    3d2c:	cf 91       	pop	r28
    3d2e:	df 91       	pop	r29
    3d30:	1f 91       	pop	r17
    3d32:	0f 91       	pop	r16
    3d34:	ff 90       	pop	r15
    3d36:	ef 90       	pop	r14
    3d38:	08 95       	ret

00003d3a <SumChecksum>:
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}

char SumChecksum(char *strChecked){
    3d3a:	ac 01       	movw	r20, r24
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    3d3c:	dc 01       	movw	r26, r24
    3d3e:	0d 90       	ld	r0, X+
    3d40:	00 20       	and	r0, r0
    3d42:	e9 f7       	brne	.-6      	; 0x3d3e <SumChecksum+0x4>
    3d44:	11 97       	sbiw	r26, 0x01	; 1
    3d46:	a8 1b       	sub	r26, r24
    3d48:	b9 0b       	sbc	r27, r25
    3d4a:	20 e0       	ldi	r18, 0x00	; 0
    3d4c:	30 e0       	ldi	r19, 0x00	; 0
    3d4e:	90 e0       	ldi	r25, 0x00	; 0
    3d50:	06 c0       	rjmp	.+12     	; 0x3d5e <SumChecksum+0x24>
	     SigmaSum=SigmaSum+strChecked[i];
    3d52:	e4 0f       	add	r30, r20
    3d54:	f5 1f       	adc	r31, r21
    3d56:	80 81       	ld	r24, Z
    3d58:	28 0f       	add	r18, r24
    3d5a:	31 1d       	adc	r19, r1
}

char SumChecksum(char *strChecked){
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    3d5c:	9f 5f       	subi	r25, 0xFF	; 255
    3d5e:	e9 2f       	mov	r30, r25
    3d60:	f0 e0       	ldi	r31, 0x00	; 0
    3d62:	ea 17       	cp	r30, r26
    3d64:	fb 07       	cpc	r31, r27
    3d66:	a8 f3       	brcs	.-22     	; 0x3d52 <SumChecksum+0x18>
	     SigmaSum=SigmaSum+strChecked[i];
	 }
	 Result=(SigmaSum%255);
    3d68:	c9 01       	movw	r24, r18
    3d6a:	6f ef       	ldi	r22, 0xFF	; 255
    3d6c:	70 e0       	ldi	r23, 0x00	; 0
    3d6e:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
	 if (Result==0)Result=255;
    3d72:	88 23       	and	r24, r24
    3d74:	09 f4       	brne	.+2      	; 0x3d78 <SumChecksum+0x3e>
    3d76:	8f ef       	ldi	r24, 0xFF	; 255
   return Result;
}
    3d78:	08 95       	ret

00003d7a <IsGeniusCommand>:
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 _uart_print(1,1,strSend);
*/
}

char IsGeniusCommand(char GCommand){
    3d7a:	ff 92       	push	r15
    3d7c:	0f 93       	push	r16
    3d7e:	1f 93       	push	r17
    3d80:	df 93       	push	r29
    3d82:	cf 93       	push	r28
    3d84:	cd b7       	in	r28, 0x3d	; 61
    3d86:	de b7       	in	r29, 0x3e	; 62
    3d88:	2a 97       	sbiw	r28, 0x0a	; 10
    3d8a:	0f b6       	in	r0, 0x3f	; 63
    3d8c:	f8 94       	cli
    3d8e:	de bf       	out	0x3e, r29	; 62
    3d90:	0f be       	out	0x3f, r0	; 63
    3d92:	cd bf       	out	0x3d, r28	; 61
    3d94:	f8 2e       	mov	r15, r24
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
    3d96:	00 d0       	rcall	.+0      	; 0x3d98 <IsGeniusCommand+0x1e>
    3d98:	00 d0       	rcall	.+0      	; 0x3d9a <IsGeniusCommand+0x20>
    3d9a:	8e 01       	movw	r16, r28
    3d9c:	0f 5f       	subi	r16, 0xFF	; 255
    3d9e:	1f 4f       	sbci	r17, 0xFF	; 255
    3da0:	ed b7       	in	r30, 0x3d	; 61
    3da2:	fe b7       	in	r31, 0x3e	; 62
    3da4:	12 83       	std	Z+2, r17	; 0x02
    3da6:	01 83       	std	Z+1, r16	; 0x01
    3da8:	85 ef       	ldi	r24, 0xF5	; 245
    3daa:	93 e0       	ldi	r25, 0x03	; 3
    3dac:	94 83       	std	Z+4, r25	; 0x04
    3dae:	83 83       	std	Z+3, r24	; 0x03
    3db0:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 for(i=0;i<strlen(CommandList);i++){
    3db4:	d8 01       	movw	r26, r16
    3db6:	0d 90       	ld	r0, X+
    3db8:	00 20       	and	r0, r0
    3dba:	e9 f7       	brne	.-6      	; 0x3db6 <IsGeniusCommand+0x3c>
    3dbc:	11 97       	sbiw	r26, 0x01	; 1
    3dbe:	a0 1b       	sub	r26, r16
    3dc0:	b1 0b       	sbc	r27, r17
    3dc2:	90 e0       	ldi	r25, 0x00	; 0
    3dc4:	0f 90       	pop	r0
    3dc6:	0f 90       	pop	r0
    3dc8:	0f 90       	pop	r0
    3dca:	0f 90       	pop	r0
	    if (CommandList[i]==GCommand){
    3dcc:	98 01       	movw	r18, r16
    3dce:	08 c0       	rjmp	.+16     	; 0x3de0 <IsGeniusCommand+0x66>
    3dd0:	e2 0f       	add	r30, r18
    3dd2:	f3 1f       	adc	r31, r19
    3dd4:	80 81       	ld	r24, Z
    3dd6:	8f 15       	cp	r24, r15
    3dd8:	11 f4       	brne	.+4      	; 0x3dde <IsGeniusCommand+0x64>
    3dda:	81 e0       	ldi	r24, 0x01	; 1
    3ddc:	07 c0       	rjmp	.+14     	; 0x3dec <IsGeniusCommand+0x72>

char IsGeniusCommand(char GCommand){
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
	 for(i=0;i<strlen(CommandList);i++){
    3dde:	9f 5f       	subi	r25, 0xFF	; 255
    3de0:	e9 2f       	mov	r30, r25
    3de2:	f0 e0       	ldi	r31, 0x00	; 0
    3de4:	ea 17       	cp	r30, r26
    3de6:	fb 07       	cpc	r31, r27
    3de8:	98 f3       	brcs	.-26     	; 0x3dd0 <IsGeniusCommand+0x56>
    3dea:	80 e0       	ldi	r24, 0x00	; 0
		    Result=True;
			break;
			}
	 }
   return Result;	 
}
    3dec:	2a 96       	adiw	r28, 0x0a	; 10
    3dee:	0f b6       	in	r0, 0x3f	; 63
    3df0:	f8 94       	cli
    3df2:	de bf       	out	0x3e, r29	; 62
    3df4:	0f be       	out	0x3f, r0	; 63
    3df6:	cd bf       	out	0x3d, r28	; 61
    3df8:	cf 91       	pop	r28
    3dfa:	df 91       	pop	r29
    3dfc:	1f 91       	pop	r17
    3dfe:	0f 91       	pop	r16
    3e00:	ff 90       	pop	r15
    3e02:	08 95       	ret

00003e04 <Pos>:
  return Result;
}
		

//Genius Protocol Version:1.0 AKR
int Pos(char *Substr, char *String){//1245:4645
    3e04:	0f 93       	push	r16
    3e06:	1f 93       	push	r17
    3e08:	cf 93       	push	r28
    3e0a:	df 93       	push	r29
    3e0c:	ac 01       	movw	r20, r24
    char i,j,CountMatch;
	char Length,subLen,PosFound;

	Length=strlen(String);
    3e0e:	fb 01       	movw	r30, r22
    3e10:	01 90       	ld	r0, Z+
    3e12:	00 20       	and	r0, r0
    3e14:	e9 f7       	brne	.-6      	; 0x3e10 <Pos+0xc>
    3e16:	31 97       	sbiw	r30, 0x01	; 1
    3e18:	1e 2f       	mov	r17, r30
    3e1a:	16 1b       	sub	r17, r22
	subLen=strlen(Substr);
    3e1c:	fc 01       	movw	r30, r24
    3e1e:	01 90       	ld	r0, Z+
    3e20:	00 20       	and	r0, r0
    3e22:	e9 f7       	brne	.-6      	; 0x3e1e <Pos+0x1a>
    3e24:	31 97       	sbiw	r30, 0x01	; 1
    3e26:	0e 2f       	mov	r16, r30
    3e28:	08 1b       	sub	r16, r24
    3e2a:	db 01       	movw	r26, r22
    3e2c:	60 e0       	ldi	r22, 0x00	; 0
    3e2e:	18 c0       	rjmp	.+48     	; 0x3e60 <Pos+0x5c>
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
    3e30:	9c 91       	ld	r25, X
    3e32:	fa 01       	movw	r30, r20
    3e34:	80 81       	ld	r24, Z
    3e36:	98 17       	cp	r25, r24
    3e38:	89 f4       	brne	.+34     	; 0x3e5c <Pos+0x58>
    3e3a:	ed 01       	movw	r28, r26
    3e3c:	20 e0       	ldi	r18, 0x00	; 0
    3e3e:	30 e0       	ldi	r19, 0x00	; 0
    3e40:	09 c0       	rjmp	.+18     	; 0x3e54 <Pos+0x50>
		    CountMatch=0;
			for(j=0;j<subLen;j++){
			    //notFound
			    if (Substr[j]==String[i+j]){
    3e42:	fa 01       	movw	r30, r20
    3e44:	e2 0f       	add	r30, r18
    3e46:	f3 1f       	adc	r31, r19
    3e48:	90 81       	ld	r25, Z
    3e4a:	89 91       	ld	r24, Y+
    3e4c:	2f 5f       	subi	r18, 0xFF	; 255
    3e4e:	3f 4f       	sbci	r19, 0xFF	; 255
    3e50:	98 17       	cp	r25, r24
    3e52:	21 f4       	brne	.+8      	; 0x3e5c <Pos+0x58>
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
		    CountMatch=0;
			for(j=0;j<subLen;j++){
    3e54:	20 17       	cp	r18, r16
    3e56:	a8 f3       	brcs	.-22     	; 0x3e42 <Pos+0x3e>
    3e58:	86 2f       	mov	r24, r22
    3e5a:	05 c0       	rjmp	.+10     	; 0x3e66 <Pos+0x62>
	char Length,subLen,PosFound;

	Length=strlen(String);
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
    3e5c:	6f 5f       	subi	r22, 0xFF	; 255
    3e5e:	11 96       	adiw	r26, 0x01	; 1
    3e60:	61 17       	cp	r22, r17
    3e62:	30 f3       	brcs	.-52     	; 0x3e30 <Pos+0x2c>
    3e64:	81 2f       	mov	r24, r17
			    break;  
			}
		}
	}
  return  PosFound;
}
    3e66:	90 e0       	ldi	r25, 0x00	; 0
    3e68:	df 91       	pop	r29
    3e6a:	cf 91       	pop	r28
    3e6c:	1f 91       	pop	r17
    3e6e:	0f 91       	pop	r16
    3e70:	08 95       	ret

00003e72 <CreateReport>:
//		  }
//	 }
     *Pos=iPos;
}

void CreateReport(char *strData, char *strPrnBuffer, unsigned int *Pos){
    3e72:	7f 92       	push	r7
    3e74:	8f 92       	push	r8
    3e76:	9f 92       	push	r9
    3e78:	af 92       	push	r10
    3e7a:	bf 92       	push	r11
    3e7c:	cf 92       	push	r12
    3e7e:	df 92       	push	r13
    3e80:	ef 92       	push	r14
    3e82:	ff 92       	push	r15
    3e84:	0f 93       	push	r16
    3e86:	1f 93       	push	r17
    3e88:	cf 93       	push	r28
    3e8a:	df 93       	push	r29
    3e8c:	5c 01       	movw	r10, r24
    3e8e:	6b 01       	movw	r12, r22
    3e90:	4a 01       	movw	r8, r20
     unsigned int iPos,PosResult,Length;
	 char i,strSend[20];
	 Length=strlen(strData);
    3e92:	ec 01       	movw	r28, r24
    3e94:	09 90       	ld	r0, Y+
    3e96:	00 20       	and	r0, r0
    3e98:	e9 f7       	brne	.-6      	; 0x3e94 <CreateReport+0x22>
    3e9a:	21 97       	sbiw	r28, 0x01	; 1
    3e9c:	c8 1b       	sub	r28, r24
    3e9e:	d9 0b       	sbc	r29, r25
    3ea0:	cb 32       	cpi	r28, 0x2B	; 43
    3ea2:	d1 05       	cpc	r29, r1
    3ea4:	10 f0       	brcs	.+4      	; 0x3eaa <CreateReport+0x38>
    3ea6:	ca e2       	ldi	r28, 0x2A	; 42
    3ea8:	d0 e0       	ldi	r29, 0x00	; 0
	 if (Length>BORDER_LENGTH)Length=BORDER_LENGTH;
     
	 iPos=*Pos;
    3eaa:	f4 01       	movw	r30, r8
    3eac:	00 81       	ld	r16, Z
    3eae:	11 81       	ldd	r17, Z+1	; 0x01
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    3eb0:	76 01       	movw	r14, r12
    3eb2:	e0 0e       	add	r14, r16
    3eb4:	f1 1e       	adc	r15, r17
    3eb6:	8a e0       	ldi	r24, 0x0A	; 10
    3eb8:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <GetBorderValue>
    3ebc:	78 2e       	mov	r7, r24
    3ebe:	f7 01       	movw	r30, r14
    3ec0:	80 83       	st	Z, r24
     iPos++;
    3ec2:	98 01       	movw	r18, r16
    3ec4:	2f 5f       	subi	r18, 0xFF	; 255
    3ec6:	3f 4f       	sbci	r19, 0xFF	; 255
    3ec8:	d7 01       	movw	r26, r14
    3eca:	90 e0       	ldi	r25, 0x00	; 0
    3ecc:	07 c0       	rjmp	.+14     	; 0x3edc <CreateReport+0x6a>

	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
    3ece:	ea 0d       	add	r30, r10
    3ed0:	fb 1d       	adc	r31, r11
    3ed2:	80 81       	ld	r24, Z
    3ed4:	8c 93       	st	X, r24
		  iPos++;
    3ed6:	2f 5f       	subi	r18, 0xFF	; 255
    3ed8:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 iPos=*Pos;
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
     iPos++;

	 for (i=0;i<Length;i++){	      
    3eda:	9f 5f       	subi	r25, 0xFF	; 255
    3edc:	e9 2f       	mov	r30, r25
    3ede:	f0 e0       	ldi	r31, 0x00	; 0
    3ee0:	11 96       	adiw	r26, 0x01	; 1
    3ee2:	ec 17       	cp	r30, r28
    3ee4:	fd 07       	cpc	r31, r29
    3ee6:	98 f3       	brcs	.-26     	; 0x3ece <CreateReport+0x5c>
    3ee8:	62 2f       	mov	r22, r18
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
    3eea:	ca 32       	cpi	r28, 0x2A	; 42
    3eec:	d1 05       	cpc	r29, r1
    3eee:	91 f0       	breq	.+36     	; 0x3f14 <CreateReport+0xa2>
    3ef0:	f6 01       	movw	r30, r12
    3ef2:	e2 0f       	add	r30, r18
    3ef4:	f3 1f       	adc	r31, r19
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    3ef6:	4a e2       	ldi	r20, 0x2A	; 42
    3ef8:	50 e0       	ldi	r21, 0x00	; 0
    3efa:	4c 1b       	sub	r20, r28
    3efc:	5d 0b       	sbc	r21, r29
	          strPrnBuffer[iPos]=' ';
    3efe:	70 e2       	ldi	r23, 0x20	; 32
    3f00:	03 c0       	rjmp	.+6      	; 0x3f08 <CreateReport+0x96>
    3f02:	71 93       	st	Z+, r23
		      iPos++;
    3f04:	2f 5f       	subi	r18, 0xFF	; 255
    3f06:	3f 4f       	sbci	r19, 0xFF	; 255
	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    3f08:	82 2f       	mov	r24, r18
    3f0a:	86 1b       	sub	r24, r22
    3f0c:	90 e0       	ldi	r25, 0x00	; 0
    3f0e:	84 17       	cp	r24, r20
    3f10:	95 07       	cpc	r25, r21
    3f12:	b8 f3       	brcs	.-18     	; 0x3f02 <CreateReport+0x90>
	          strPrnBuffer[iPos]=' ';
		      iPos++;
	     }	    
	 }
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    3f14:	f6 01       	movw	r30, r12
    3f16:	e2 0f       	add	r30, r18
    3f18:	f3 1f       	adc	r31, r19
    3f1a:	70 82       	st	Z, r7
     iPos++;
    3f1c:	c9 01       	movw	r24, r18
    3f1e:	01 96       	adiw	r24, 0x01	; 1
     //PosResult=*Pos+Length;
	 strPrnBuffer[iPos]=0x0D; 
    3f20:	c8 0e       	add	r12, r24
    3f22:	d9 1e       	adc	r13, r25
    3f24:	2d e0       	ldi	r18, 0x0D	; 13
    3f26:	f6 01       	movw	r30, r12
    3f28:	20 83       	st	Z, r18
	 iPos++;

   //*Pos=PosResult+1;
   *Pos=iPos;
    3f2a:	01 96       	adiw	r24, 0x01	; 1
    3f2c:	f4 01       	movw	r30, r8
    3f2e:	91 83       	std	Z+1, r25	; 0x01
    3f30:	80 83       	st	Z, r24
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//_uart_print(0,1,strSend);
}
    3f32:	df 91       	pop	r29
    3f34:	cf 91       	pop	r28
    3f36:	1f 91       	pop	r17
    3f38:	0f 91       	pop	r16
    3f3a:	ff 90       	pop	r15
    3f3c:	ef 90       	pop	r14
    3f3e:	df 90       	pop	r13
    3f40:	cf 90       	pop	r12
    3f42:	bf 90       	pop	r11
    3f44:	af 90       	pop	r10
    3f46:	9f 90       	pop	r9
    3f48:	8f 90       	pop	r8
    3f4a:	7f 90       	pop	r7
    3f4c:	08 95       	ret

00003f4e <AddList>:

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
void AddList(char GradeId, char *strList){
    3f4e:	38 2f       	mov	r19, r24
    3f50:	ab 01       	movw	r20, r22
     char i,iPos,Length,IsFound=False;	 
	 if ((GradeId>=1)&&((GradeId<=6))){
    3f52:	81 50       	subi	r24, 0x01	; 1
    3f54:	86 30       	cpi	r24, 0x06	; 6
    3f56:	68 f5       	brcc	.+90     	; 0x3fb2 <AddList+0x64>
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
    3f58:	fb 01       	movw	r30, r22
    3f5a:	01 90       	ld	r0, Z+
    3f5c:	00 20       	and	r0, r0
    3f5e:	e9 f7       	brne	.-6      	; 0x3f5a <AddList+0xc>
    3f60:	31 97       	sbiw	r30, 0x01	; 1
    3f62:	e6 1b       	sub	r30, r22
    3f64:	f7 0b       	sbc	r31, r23
    3f66:	7e 2f       	mov	r23, r30
	     if (Length>0){
    3f68:	ee 23       	and	r30, r30
    3f6a:	11 f4       	brne	.+4      	; 0x3f70 <AddList+0x22>
    3f6c:	20 e0       	ldi	r18, 0x00	; 0
    3f6e:	14 c0       	rjmp	.+40     	; 0x3f98 <AddList+0x4a>
    3f70:	80 e0       	ldi	r24, 0x00	; 0
    3f72:	90 e0       	ldi	r25, 0x00	; 0
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    3f74:	63 2f       	mov	r22, r19
    3f76:	60 5d       	subi	r22, 0xD0	; 208
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //_uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    3f78:	fa 01       	movw	r30, r20
    3f7a:	e8 0f       	add	r30, r24
    3f7c:	f9 1f       	adc	r31, r25
    3f7e:	e0 81       	ld	r30, Z
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    3f80:	3a 30       	cpi	r19, 0x0A	; 10
    3f82:	10 f0       	brcs	.+4      	; 0x3f88 <AddList+0x3a>
    3f84:	20 e3       	ldi	r18, 0x30	; 48
    3f86:	01 c0       	rjmp	.+2      	; 0x3f8a <AddList+0x3c>
	    Result='0'+X;
    3f88:	26 2f       	mov	r18, r22
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //_uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    3f8a:	e2 17       	cp	r30, r18
    3f8c:	91 f0       	breq	.+36     	; 0x3fb2 <AddList+0x64>
    3f8e:	28 2f       	mov	r18, r24
    3f90:	2f 5f       	subi	r18, 0xFF	; 255
    3f92:	01 96       	adiw	r24, 0x01	; 1
	 if ((GradeId>=1)&&((GradeId<=6))){
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
    3f94:	87 17       	cp	r24, r23
    3f96:	80 f3       	brcs	.-32     	; 0x3f78 <AddList+0x2a>
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    3f98:	62 2f       	mov	r22, r18
    3f9a:	70 e0       	ldi	r23, 0x00	; 0
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    3f9c:	3a 30       	cpi	r19, 0x0A	; 10
    3f9e:	10 f0       	brcs	.+4      	; 0x3fa4 <AddList+0x56>
    3fa0:	80 e3       	ldi	r24, 0x30	; 48
    3fa2:	02 c0       	rjmp	.+4      	; 0x3fa8 <AddList+0x5a>
	    Result='0'+X;
    3fa4:	83 2f       	mov	r24, r19
    3fa6:	80 5d       	subi	r24, 0xD0	; 208
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    3fa8:	fa 01       	movw	r30, r20
    3faa:	e6 0f       	add	r30, r22
    3fac:	f7 1f       	adc	r31, r23
    3fae:	80 83       	st	Z, r24
		     strList[iPos+1]=0;
    3fb0:	11 82       	std	Z+1, r1	; 0x01
    3fb2:	08 95       	ret

00003fb4 <ClearList>:
	 AddSpaceLag(strProductName,10);
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
    3fb4:	dc 01       	movw	r26, r24
    3fb6:	0d 90       	ld	r0, X+
    3fb8:	00 20       	and	r0, r0
    3fba:	e9 f7       	brne	.-6      	; 0x3fb6 <ClearList+0x2>
    3fbc:	11 97       	sbiw	r26, 0x01	; 1
    3fbe:	a8 1b       	sub	r26, r24
    3fc0:	b9 0b       	sbc	r27, r25
    3fc2:	20 e0       	ldi	r18, 0x00	; 0
    3fc4:	30 e0       	ldi	r19, 0x00	; 0
    3fc6:	06 c0       	rjmp	.+12     	; 0x3fd4 <ClearList+0x20>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    3fc8:	fc 01       	movw	r30, r24
    3fca:	e2 0f       	add	r30, r18
    3fcc:	f3 1f       	adc	r31, r19
    3fce:	10 82       	st	Z, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    3fd0:	2f 5f       	subi	r18, 0xFF	; 255
    3fd2:	3f 4f       	sbci	r19, 0xFF	; 255
    3fd4:	2a 17       	cp	r18, r26
    3fd6:	3b 07       	cpc	r19, r27
    3fd8:	b8 f3       	brcs	.-18     	; 0x3fc8 <ClearList+0x14>
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
    3fda:	08 95       	ret

00003fdc <CalcSegmen>:
		 */
		 CalcMultiply(strA,strB,strC);
	 }
}

void CalcSegmen(char *strMain, char cNum, char *strResult){
    3fdc:	6f 92       	push	r6
    3fde:	7f 92       	push	r7
    3fe0:	8f 92       	push	r8
    3fe2:	9f 92       	push	r9
    3fe4:	bf 92       	push	r11
    3fe6:	cf 92       	push	r12
    3fe8:	df 92       	push	r13
    3fea:	ef 92       	push	r14
    3fec:	ff 92       	push	r15
    3fee:	0f 93       	push	r16
    3ff0:	1f 93       	push	r17
    3ff2:	df 93       	push	r29
    3ff4:	cf 93       	push	r28
    3ff6:	cd b7       	in	r28, 0x3d	; 61
    3ff8:	de b7       	in	r29, 0x3e	; 62
    3ffa:	64 97       	sbiw	r28, 0x14	; 20
    3ffc:	0f b6       	in	r0, 0x3f	; 63
    3ffe:	f8 94       	cli
    4000:	de bf       	out	0x3e, r29	; 62
    4002:	0f be       	out	0x3f, r0	; 63
    4004:	cd bf       	out	0x3d, r28	; 61
    4006:	7c 01       	movw	r14, r24
    4008:	6a 01       	movw	r12, r20
    400a:	bb 24       	eor	r11, r11
    400c:	30 e0       	ldi	r19, 0x00	; 0

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    400e:	06 2f       	mov	r16, r22
    4010:	10 e0       	ldi	r17, 0x00	; 0
    4012:	00 53       	subi	r16, 0x30	; 48
    4014:	10 40       	sbci	r17, 0x00	; 0
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
    4016:	3e 01       	movw	r6, r28
    4018:	08 94       	sec
    401a:	61 1c       	adc	r6, r1
    401c:	71 1c       	adc	r7, r1
		 tmpResult[i+1]=0;
    401e:	62 e0       	ldi	r22, 0x02	; 2
    4020:	86 2e       	mov	r8, r22
    4022:	91 2c       	mov	r9, r1
    4024:	8c 0e       	add	r8, r28
    4026:	9d 1e       	adc	r9, r29
    4028:	24 c0       	rjmp	.+72     	; 0x4072 <CalcSegmen+0x96>

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    402a:	11 97       	sbiw	r26, 0x01	; 1
    402c:	a4 1b       	sub	r26, r20
    402e:	b5 0b       	sbc	r27, r21
    4030:	ae 0d       	add	r26, r14
    4032:	bf 1d       	adc	r27, r15
    4034:	8c 91       	ld	r24, X
    4036:	90 e0       	ldi	r25, 0x00	; 0
    4038:	c0 97       	sbiw	r24, 0x30	; 48
    403a:	bc 01       	movw	r22, r24
    403c:	60 9f       	mul	r22, r16
    403e:	c0 01       	movw	r24, r0
    4040:	61 9f       	mul	r22, r17
    4042:	90 0d       	add	r25, r0
    4044:	70 9f       	mul	r23, r16
    4046:	90 0d       	add	r25, r0
    4048:	11 24       	eor	r1, r1
    404a:	23 2f       	mov	r18, r19
    404c:	28 0f       	add	r18, r24
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
    404e:	82 2f       	mov	r24, r18
    4050:	6a e0       	ldi	r22, 0x0A	; 10
    4052:	0e 94 a3 b7 	call	0x16f46	; 0x16f46 <__udivmodqi4>
    4056:	38 2f       	mov	r19, r24
	     tmpResult[i]='0'+xRes;	 
    4058:	f3 01       	movw	r30, r6
    405a:	e4 0f       	add	r30, r20
    405c:	f5 1f       	adc	r31, r21
    405e:	82 2f       	mov	r24, r18
    4060:	0e 94 a3 b7 	call	0x16f46	; 0x16f46 <__udivmodqi4>
    4064:	90 5d       	subi	r25, 0xD0	; 208
    4066:	90 83       	st	Z, r25
		 tmpResult[i+1]=0;
    4068:	48 0d       	add	r20, r8
    406a:	59 1d       	adc	r21, r9
    406c:	fa 01       	movw	r30, r20
    406e:	10 82       	st	Z, r1
	 char i,lenR,xCalc,xRes,xResNext,tmpResult[20];

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
    4070:	b3 94       	inc	r11
    4072:	4b 2d       	mov	r20, r11
    4074:	50 e0       	ldi	r21, 0x00	; 0
    4076:	d7 01       	movw	r26, r14
    4078:	0d 90       	ld	r0, X+
    407a:	00 20       	and	r0, r0
    407c:	e9 f7       	brne	.-6      	; 0x4078 <CalcSegmen+0x9c>
    407e:	11 97       	sbiw	r26, 0x01	; 1
    4080:	ae 19       	sub	r26, r14
    4082:	bf 09       	sbc	r27, r15
    4084:	4a 17       	cp	r20, r26
    4086:	5b 07       	cpc	r21, r27
    4088:	80 f2       	brcs	.-96     	; 0x402a <CalcSegmen+0x4e>
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
		 tmpResult[i+1]=0;
	 }
	 if (xResNext>0){
    408a:	33 23       	and	r19, r19
    408c:	89 f0       	breq	.+34     	; 0x40b0 <CalcSegmen+0xd4>
	     lenR=strlen(tmpResult);
    408e:	fe 01       	movw	r30, r28
    4090:	31 96       	adiw	r30, 0x01	; 1
    4092:	df 01       	movw	r26, r30
    4094:	0d 90       	ld	r0, X+
    4096:	00 20       	and	r0, r0
    4098:	e9 f7       	brne	.-6      	; 0x4094 <CalcSegmen+0xb8>
    409a:	11 97       	sbiw	r26, 0x01	; 1
	     tmpResult[lenR]='0'+xResNext;
    409c:	ae 1b       	sub	r26, r30
    409e:	b0 e0       	ldi	r27, 0x00	; 0
    40a0:	ea 0f       	add	r30, r26
    40a2:	fb 1f       	adc	r31, r27
    40a4:	30 5d       	subi	r19, 0xD0	; 208
    40a6:	30 83       	st	Z, r19
		 tmpResult[lenR+1]=0;	 
    40a8:	ac 0f       	add	r26, r28
    40aa:	bd 1f       	adc	r27, r29
    40ac:	12 96       	adiw	r26, 0x02	; 2
    40ae:	1c 92       	st	X, r1
	 }
	 lenR=strlen(tmpResult);
    40b0:	de 01       	movw	r26, r28
    40b2:	11 96       	adiw	r26, 0x01	; 1
    40b4:	fd 01       	movw	r30, r26
    40b6:	01 90       	ld	r0, Z+
    40b8:	00 20       	and	r0, r0
    40ba:	e9 f7       	brne	.-6      	; 0x40b6 <CalcSegmen+0xda>
    40bc:	31 97       	sbiw	r30, 0x01	; 1
    40be:	9e 2f       	mov	r25, r30
    40c0:	9a 1b       	sub	r25, r26
    40c2:	a9 0f       	add	r26, r25
    40c4:	b1 1d       	adc	r27, r1
    40c6:	f6 01       	movw	r30, r12
    40c8:	02 c0       	rjmp	.+4      	; 0x40ce <CalcSegmen+0xf2>
	 for (i=0;i<lenR;i++){
	     strResult[i]=tmpResult[lenR-1-i];
    40ca:	8c 91       	ld	r24, X
    40cc:	81 93       	st	Z+, r24
    40ce:	11 97       	sbiw	r26, 0x01	; 1
	     lenR=strlen(tmpResult);
	     tmpResult[lenR]='0'+xResNext;
		 tmpResult[lenR+1]=0;	 
	 }
	 lenR=strlen(tmpResult);
	 for (i=0;i<lenR;i++){
    40d0:	ac 17       	cp	r26, r28
    40d2:	bd 07       	cpc	r27, r29
    40d4:	d1 f7       	brne	.-12     	; 0x40ca <CalcSegmen+0xee>
	     strResult[i]=tmpResult[lenR-1-i];
	 }
	 strResult[lenR]=0;
    40d6:	c9 0e       	add	r12, r25
    40d8:	d1 1c       	adc	r13, r1
    40da:	f6 01       	movw	r30, r12
    40dc:	10 82       	st	Z, r1
}
    40de:	64 96       	adiw	r28, 0x14	; 20
    40e0:	0f b6       	in	r0, 0x3f	; 63
    40e2:	f8 94       	cli
    40e4:	de bf       	out	0x3e, r29	; 62
    40e6:	0f be       	out	0x3f, r0	; 63
    40e8:	cd bf       	out	0x3d, r28	; 61
    40ea:	cf 91       	pop	r28
    40ec:	df 91       	pop	r29
    40ee:	1f 91       	pop	r17
    40f0:	0f 91       	pop	r16
    40f2:	ff 90       	pop	r15
    40f4:	ef 90       	pop	r14
    40f6:	df 90       	pop	r13
    40f8:	cf 90       	pop	r12
    40fa:	bf 90       	pop	r11
    40fc:	9f 90       	pop	r9
    40fe:	8f 90       	pop	r8
    4100:	7f 90       	pop	r7
    4102:	6f 90       	pop	r6
    4104:	08 95       	ret

00004106 <GetMinusPos>:
		  if (KeyChar=='*')stTestCalc=tcInitData;
	      break;	 
	 }
}

char GetMinusPos(char *strNumber){
    4106:	ac 01       	movw	r20, r24
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    4108:	dc 01       	movw	r26, r24
    410a:	0d 90       	ld	r0, X+
    410c:	00 20       	and	r0, r0
    410e:	e9 f7       	brne	.-6      	; 0x410a <GetMinusPos+0x4>
    4110:	11 97       	sbiw	r26, 0x01	; 1
    4112:	a8 1b       	sub	r26, r24
    4114:	b9 0b       	sbc	r27, r25
    4116:	20 e0       	ldi	r18, 0x00	; 0
    4118:	0a c0       	rjmp	.+20     	; 0x412e <GetMinusPos+0x28>
	     if (strNumber[i]=='-'){
    411a:	e4 0f       	add	r30, r20
    411c:	f5 1f       	adc	r31, r21
    411e:	80 81       	ld	r24, Z
    4120:	92 2f       	mov	r25, r18
    4122:	9f 5f       	subi	r25, 0xFF	; 255
    4124:	8d 32       	cpi	r24, 0x2D	; 45
    4126:	11 f4       	brne	.+4      	; 0x412c <GetMinusPos+0x26>
		     Result=i+1;
    4128:	89 2f       	mov	r24, r25
    412a:	08 95       	ret
}

char GetMinusPos(char *strNumber){
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    412c:	29 2f       	mov	r18, r25
    412e:	e2 2f       	mov	r30, r18
    4130:	f0 e0       	ldi	r31, 0x00	; 0
    4132:	ea 17       	cp	r30, r26
    4134:	fb 07       	cpc	r31, r27
    4136:	88 f3       	brcs	.-30     	; 0x411a <GetMinusPos+0x14>
    4138:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
  return Result;     
}
    413a:	08 95       	ret

0000413c <IsMinus>:

char IsMinus(char *strNumber){
char i,Result=False;
     Result=False;
	 if (GetMinusPos(strNumber)>0){
    413c:	0e 94 83 20 	call	0x4106	; 0x4106 <GetMinusPos>
    4140:	81 11       	cpse	r24, r1
    4142:	81 e0       	ldi	r24, 0x01	; 1
	     Result=True;
	 }     
  return Result;
}
    4144:	08 95       	ret

00004146 <RemoveMinus>:

void RemoveMinus(char *strNumber){
    4146:	cf 93       	push	r28
    4148:	df 93       	push	r29
    414a:	ec 01       	movw	r28, r24
     char MinPos,Length;

     if (IsMinus(strNumber)==True){
    414c:	0e 94 9e 20 	call	0x413c	; 0x413c <IsMinus>
    4150:	81 30       	cpi	r24, 0x01	; 1
    4152:	19 f5       	brne	.+70     	; 0x419a <RemoveMinus+0x54>
	     MinPos=GetMinusPos(strNumber);
    4154:	ce 01       	movw	r24, r28
    4156:	0e 94 83 20 	call	0x4106	; 0x4106 <GetMinusPos>
		 Length=strlen(strNumber);
    415a:	de 01       	movw	r26, r28
    415c:	0d 90       	ld	r0, X+
    415e:	00 20       	and	r0, r0
    4160:	e9 f7       	brne	.-6      	; 0x415c <RemoveMinus+0x16>
    4162:	11 97       	sbiw	r26, 0x01	; 1
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
    4164:	ac 1b       	sub	r26, r28
    4166:	b0 e0       	ldi	r27, 0x00	; 0
    4168:	90 e0       	ldi	r25, 0x00	; 0
    416a:	a8 1b       	sub	r26, r24
    416c:	b9 0b       	sbc	r27, r25
    416e:	ae 01       	movw	r20, r28
    4170:	48 0f       	add	r20, r24
    4172:	59 1f       	adc	r21, r25
    4174:	20 e0       	ldi	r18, 0x00	; 0
    4176:	30 e0       	ldi	r19, 0x00	; 0
    4178:	0a c0       	rjmp	.+20     	; 0x418e <RemoveMinus+0x48>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    417a:	be 01       	movw	r22, r28
    417c:	62 0f       	add	r22, r18
    417e:	73 1f       	adc	r23, r19
    4180:	fa 01       	movw	r30, r20
    4182:	81 91       	ld	r24, Z+
    4184:	af 01       	movw	r20, r30
    4186:	fb 01       	movw	r30, r22
    4188:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    418a:	2f 5f       	subi	r18, 0xFF	; 255
    418c:	3f 4f       	sbci	r19, 0xFF	; 255
    418e:	2a 17       	cp	r18, r26
    4190:	3b 07       	cpc	r19, r27
    4192:	98 f3       	brcs	.-26     	; 0x417a <RemoveMinus+0x34>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4194:	ac 0f       	add	r26, r28
    4196:	bd 1f       	adc	r27, r29
    4198:	1c 92       	st	X, r1
     if (IsMinus(strNumber)==True){
	     MinPos=GetMinusPos(strNumber);
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}
    419a:	df 91       	pop	r29
    419c:	cf 91       	pop	r28
    419e:	08 95       	ret

000041a0 <IsMoreThan>:
	    Result=c-'0';
	 }
	return Result;
}

char IsMoreThan(char *strA, char *strB){
    41a0:	ac 01       	movw	r20, r24
    41a2:	27 2f       	mov	r18, r23
     char i,LengthA,LengthB,Result=False;
	 char strSend[20];	 
     //Check Length
	 LengthA=strlen(strA);
    41a4:	fc 01       	movw	r30, r24
    41a6:	01 90       	ld	r0, Z+
    41a8:	00 20       	and	r0, r0
    41aa:	e9 f7       	brne	.-6      	; 0x41a6 <IsMoreThan+0x6>
    41ac:	31 97       	sbiw	r30, 0x01	; 1
    41ae:	7e 2f       	mov	r23, r30
    41b0:	78 1b       	sub	r23, r24
	 LengthB=strlen(strB);
    41b2:	a6 2f       	mov	r26, r22
    41b4:	b2 2f       	mov	r27, r18
    41b6:	fd 01       	movw	r30, r26
    41b8:	01 90       	ld	r0, Z+
    41ba:	00 20       	and	r0, r0
    41bc:	e9 f7       	brne	.-6      	; 0x41b8 <IsMoreThan+0x18>
    41be:	31 97       	sbiw	r30, 0x01	; 1
    41c0:	e6 1b       	sub	r30, r22
	 Result=False;
	 if (LengthA>LengthB)Result=True;
    41c2:	e7 17       	cp	r30, r23
    41c4:	48 f1       	brcs	.+82     	; 0x4218 <IsMoreThan+0x78>
	 else 
	 if (LengthA==LengthB){          //456755 
    41c6:	7e 17       	cp	r23, r30
    41c8:	49 f5       	brne	.+82     	; 0x421c <IsMoreThan+0x7c>
    41ca:	86 2f       	mov	r24, r22
    41cc:	92 2f       	mov	r25, r18
    41ce:	9c 01       	movw	r18, r24
    41d0:	d9 01       	movw	r26, r18
    41d2:	20 e0       	ldi	r18, 0x00	; 0
    41d4:	30 e0       	ldi	r19, 0x00	; 0
    41d6:	1d c0       	rjmp	.+58     	; 0x4212 <IsMoreThan+0x72>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    41d8:	fa 01       	movw	r30, r20
    41da:	e2 0f       	add	r30, r18
    41dc:	f3 1f       	adc	r31, r19
    41de:	e0 81       	ld	r30, Z
    41e0:	e0 53       	subi	r30, 0x30	; 48
    41e2:	ea 30       	cpi	r30, 0x0A	; 10
    41e4:	10 f0       	brcs	.+4      	; 0x41ea <IsMoreThan+0x4a>
    41e6:	60 e0       	ldi	r22, 0x00	; 0
    41e8:	01 c0       	rjmp	.+2      	; 0x41ec <IsMoreThan+0x4c>
    41ea:	6e 2f       	mov	r22, r30
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
    41ec:	8c 91       	ld	r24, X
    41ee:	80 53       	subi	r24, 0x30	; 48
    41f0:	8a 30       	cpi	r24, 0x0A	; 10
    41f2:	10 f0       	brcs	.+4      	; 0x41f8 <IsMoreThan+0x58>
    41f4:	90 e0       	ldi	r25, 0x00	; 0
    41f6:	01 c0       	rjmp	.+2      	; 0x41fa <IsMoreThan+0x5a>
    41f8:	98 2f       	mov	r25, r24
    41fa:	96 17       	cp	r25, r22
    41fc:	68 f0       	brcs	.+26     	; 0x4218 <IsMoreThan+0x78>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    41fe:	ea 30       	cpi	r30, 0x0A	; 10
    4200:	08 f0       	brcs	.+2      	; 0x4204 <IsMoreThan+0x64>
    4202:	e0 e0       	ldi	r30, 0x00	; 0
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
			     Result=True;
				 break;
			 }else if (Ord(strA[i])<Ord(strB[i])){
    4204:	8a 30       	cpi	r24, 0x0A	; 10
    4206:	10 f4       	brcc	.+4      	; 0x420c <IsMoreThan+0x6c>
    4208:	e8 17       	cp	r30, r24
    420a:	40 f0       	brcs	.+16     	; 0x421c <IsMoreThan+0x7c>
    420c:	2f 5f       	subi	r18, 0xFF	; 255
    420e:	3f 4f       	sbci	r19, 0xFF	; 255
    4210:	11 96       	adiw	r26, 0x01	; 1
	 LengthB=strlen(strB);
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
    4212:	27 17       	cp	r18, r23
    4214:	08 f3       	brcs	.-62     	; 0x41d8 <IsMoreThan+0x38>
    4216:	02 c0       	rjmp	.+4      	; 0x421c <IsMoreThan+0x7c>
    4218:	81 e0       	ldi	r24, 0x01	; 1
    421a:	08 95       	ret
    421c:	80 e0       	ldi	r24, 0x00	; 0
				 break;
			 }			 		 
		 }
	 }
  return Result;
}
    421e:	08 95       	ret

00004220 <IsZerroAll>:
   return Result;
}

char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
    4220:	fc 01       	movw	r30, r24
    4222:	01 90       	ld	r0, Z+
    4224:	00 20       	and	r0, r0
    4226:	e9 f7       	brne	.-6      	; 0x4222 <IsZerroAll+0x2>
    4228:	31 97       	sbiw	r30, 0x01	; 1
    422a:	e8 1b       	sub	r30, r24
    422c:	dc 01       	movw	r26, r24
    422e:	ae 0f       	add	r26, r30
    4230:	b1 1d       	adc	r27, r1
    4232:	90 e0       	ldi	r25, 0x00	; 0
    4234:	20 e0       	ldi	r18, 0x00	; 0
    4236:	06 c0       	rjmp	.+12     	; 0x4244 <IsZerroAll+0x24>
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
	     if (strZerro[Length-i]=='0')nZerro++;
    4238:	8c 91       	ld	r24, X
    423a:	80 33       	cpi	r24, 0x30	; 48
    423c:	09 f4       	brne	.+2      	; 0x4240 <IsZerroAll+0x20>
    423e:	2f 5f       	subi	r18, 0xFF	; 255
char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
    4240:	9f 5f       	subi	r25, 0xFF	; 255
    4242:	11 97       	sbiw	r26, 0x01	; 1
    4244:	9e 17       	cp	r25, r30
    4246:	c0 f3       	brcs	.-16     	; 0x4238 <IsZerroAll+0x18>
    4248:	80 e0       	ldi	r24, 0x00	; 0
    424a:	2e 17       	cp	r18, r30
    424c:	09 f4       	brne	.+2      	; 0x4250 <IsZerroAll+0x30>
    424e:	81 e0       	ldi	r24, 0x01	; 1
	     if (strZerro[Length-i]=='0')nZerro++;
	 }if (nZerro==Length) Result=True;
  return Result;
}
    4250:	08 95       	ret

00004252 <PstrCopy>:
     _uart(_COM_PRINTER, 1, 0x0D);     
     _uart(_COM_PRINTER, 1, 0x0A);

}

void PstrCopy(char *Dest,char *Source){
    4252:	cf 93       	push	r28
    4254:	df 93       	push	r29
    4256:	20 e0       	ldi	r18, 0x00	; 0
    4258:	08 c0       	rjmp	.+16     	; 0x426a <PstrCopy+0x18>
     char i=0;
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
    425a:	fb 01       	movw	r30, r22
    425c:	ec 0f       	add	r30, r28
    425e:	fd 1f       	adc	r31, r29
    4260:	e4 91       	lpm	r30, Z+
    4262:	c8 0f       	add	r28, r24
    4264:	d9 1f       	adc	r29, r25
    4266:	e8 83       	st	Y, r30

}

void PstrCopy(char *Dest,char *Source){
     char i=0;
	 for(i=0;i<strlen(Source);i++){
    4268:	2f 5f       	subi	r18, 0xFF	; 255
    426a:	c2 2f       	mov	r28, r18
    426c:	d0 e0       	ldi	r29, 0x00	; 0
    426e:	fb 01       	movw	r30, r22
    4270:	01 90       	ld	r0, Z+
    4272:	00 20       	and	r0, r0
    4274:	e9 f7       	brne	.-6      	; 0x4270 <PstrCopy+0x1e>
    4276:	31 97       	sbiw	r30, 0x01	; 1
    4278:	e6 1b       	sub	r30, r22
    427a:	f7 0b       	sbc	r31, r23
    427c:	ce 17       	cp	r28, r30
    427e:	df 07       	cpc	r29, r31
    4280:	60 f3       	brcs	.-40     	; 0x425a <PstrCopy+0x8>
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}
    4282:	df 91       	pop	r29
    4284:	cf 91       	pop	r28
    4286:	08 95       	ret

00004288 <SpaceOnly>:
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}

char SpaceOnly(char *string){
    4288:	ac 01       	movw	r20, r24
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    428a:	dc 01       	movw	r26, r24
    428c:	0d 90       	ld	r0, X+
    428e:	00 20       	and	r0, r0
    4290:	e9 f7       	brne	.-6      	; 0x428c <SpaceOnly+0x4>
    4292:	11 97       	sbiw	r26, 0x01	; 1
    4294:	a8 1b       	sub	r26, r24
    4296:	b9 0b       	sbc	r27, r25
    4298:	90 e0       	ldi	r25, 0x00	; 0
    429a:	20 e0       	ldi	r18, 0x00	; 0
    429c:	30 e0       	ldi	r19, 0x00	; 0
    429e:	09 c0       	rjmp	.+18     	; 0x42b2 <SpaceOnly+0x2a>
	    if(string[i]!=' ') nChar++;
    42a0:	fa 01       	movw	r30, r20
    42a2:	e2 0f       	add	r30, r18
    42a4:	f3 1f       	adc	r31, r19
    42a6:	80 81       	ld	r24, Z
    42a8:	80 32       	cpi	r24, 0x20	; 32
    42aa:	09 f0       	breq	.+2      	; 0x42ae <SpaceOnly+0x26>
    42ac:	9f 5f       	subi	r25, 0xFF	; 255
char SpaceOnly(char *string){
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    42ae:	2f 5f       	subi	r18, 0xFF	; 255
    42b0:	3f 4f       	sbci	r19, 0xFF	; 255
    42b2:	2a 17       	cp	r18, r26
    42b4:	3b 07       	cpc	r19, r27
    42b6:	a0 f3       	brcs	.-24     	; 0x42a0 <SpaceOnly+0x18>
    42b8:	80 e0       	ldi	r24, 0x00	; 0
    42ba:	99 23       	and	r25, r25
    42bc:	09 f4       	brne	.+2      	; 0x42c0 <SpaceOnly+0x38>
    42be:	81 e0       	ldi	r24, 0x01	; 1
	 }
	 if (nChar>0) Result=False;
	 else Result=True;

	 return Result;
}
    42c0:	08 95       	ret

000042c2 <RemDecimal>:
	 }
}



void RemDecimal(char *strDecimal){//4500.00-->4500
    42c2:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    42c4:	e1 99       	sbic	0x1c, 1	; 28
    42c6:	fe cf       	rjmp	.-4      	; 0x42c4 <RemDecimal+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    42c8:	8e e3       	ldi	r24, 0x3E	; 62
    42ca:	90 e0       	ldi	r25, 0x00	; 0
    42cc:	9f bb       	out	0x1f, r25	; 31
    42ce:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    42d0:	e0 9a       	sbi	0x1c, 0	; 28
    42d2:	5d b3       	in	r21, 0x1d	; 29
    42d4:	40 e0       	ldi	r20, 0x00	; 0
    42d6:	08 c0       	rjmp	.+16     	; 0x42e8 <RemDecimal+0x26>
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
	     if (strDecimal[i]==DecPointMark)
    42d8:	f9 01       	movw	r30, r18
    42da:	e8 0f       	add	r30, r24
    42dc:	f9 1f       	adc	r31, r25
    42de:	80 81       	ld	r24, Z
    42e0:	85 17       	cp	r24, r21
    42e2:	09 f4       	brne	.+2      	; 0x42e6 <RemDecimal+0x24>
		     strDecimal[i]=0;
    42e4:	10 82       	st	Z, r1

void RemDecimal(char *strDecimal){//4500.00-->4500
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
    42e6:	4f 5f       	subi	r20, 0xFF	; 255
    42e8:	84 2f       	mov	r24, r20
    42ea:	90 e0       	ldi	r25, 0x00	; 0
    42ec:	f9 01       	movw	r30, r18
    42ee:	01 90       	ld	r0, Z+
    42f0:	00 20       	and	r0, r0
    42f2:	e9 f7       	brne	.-6      	; 0x42ee <RemDecimal+0x2c>
    42f4:	31 97       	sbiw	r30, 0x01	; 1
    42f6:	e2 1b       	sub	r30, r18
    42f8:	f3 0b       	sbc	r31, r19
    42fa:	8e 17       	cp	r24, r30
    42fc:	9f 07       	cpc	r25, r31
    42fe:	60 f3       	brcs	.-40     	; 0x42d8 <RemDecimal+0x16>
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}
    4300:	08 95       	ret

00004302 <GetProductPrice>:
          stGenerateReport=grScanAction;
	      break;
	 }
}
//SaveTotalProduct(xGrade,strDeltaVolume,strDeltaMoney);
void GetProductPrice(char *sPrice,char xPumpID,char xNozzle){
    4302:	cf 92       	push	r12
    4304:	df 92       	push	r13
    4306:	ef 92       	push	r14
    4308:	ff 92       	push	r15
    430a:	0f 93       	push	r16
    430c:	1f 93       	push	r17
    430e:	df 93       	push	r29
    4310:	cf 93       	push	r28
    4312:	cd b7       	in	r28, 0x3d	; 61
    4314:	de b7       	in	r29, 0x3e	; 62
    4316:	67 97       	sbiw	r28, 0x17	; 23
    4318:	0f b6       	in	r0, 0x3f	; 63
    431a:	f8 94       	cli
    431c:	de bf       	out	0x3e, r29	; 62
    431e:	0f be       	out	0x3f, r0	; 63
    4320:	cd bf       	out	0x3d, r28	; 61
    4322:	7c 01       	movw	r14, r24
    4324:	d6 2e       	mov	r13, r22
    4326:	c4 2e       	mov	r12, r20
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
    4328:	00 d0       	rcall	.+0      	; 0x432a <GetProductPrice+0x28>
    432a:	00 d0       	rcall	.+0      	; 0x432c <GetProductPrice+0x2a>
    432c:	ad b7       	in	r26, 0x3d	; 61
    432e:	be b7       	in	r27, 0x3e	; 62
    4330:	12 96       	adiw	r26, 0x02	; 2
    4332:	9c 93       	st	X, r25
    4334:	8e 93       	st	-X, r24
    4336:	11 97       	sbiw	r26, 0x01	; 1
    4338:	80 e8       	ldi	r24, 0x80	; 128
    433a:	94 e0       	ldi	r25, 0x04	; 4
    433c:	14 96       	adiw	r26, 0x04	; 4
    433e:	9c 93       	st	X, r25
    4340:	8e 93       	st	-X, r24
    4342:	13 97       	sbiw	r26, 0x03	; 3
    4344:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    4348:	0f 90       	pop	r0
    434a:	0f 90       	pop	r0
    434c:	0f 90       	pop	r0
    434e:	0f 90       	pop	r0
    4350:	8e 01       	movw	r16, r28
    4352:	09 5f       	subi	r16, 0xF9	; 249
    4354:	1f 4f       	sbci	r17, 0xFF	; 255
    4356:	c8 01       	movw	r24, r16
    4358:	65 e4       	ldi	r22, 0x45	; 69
    435a:	70 e0       	ldi	r23, 0x00	; 0
    435c:	48 e0       	ldi	r20, 0x08	; 8
    435e:	50 e0       	ldi	r21, 0x00	; 0
    4360:	2c ea       	ldi	r18, 0xAC	; 172
    4362:	32 e1       	ldi	r19, 0x12	; 18
    4364:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
    4368:	f8 01       	movw	r30, r16
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    436a:	9e 01       	movw	r18, r28
    436c:	21 5f       	subi	r18, 0xF1	; 241
    436e:	3f 4f       	sbci	r19, 0xFF	; 255
    4370:	9e 2f       	mov	r25, r30
    4372:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==xPumpID){
    4374:	80 81       	ld	r24, Z
    4376:	8d 15       	cp	r24, r13
    4378:	11 f4       	brne	.+4      	; 0x437e <GetProductPrice+0x7c>
    437a:	89 2f       	mov	r24, r25
    437c:	05 c0       	rjmp	.+10     	; 0x4388 <GetProductPrice+0x86>
    437e:	31 96       	adiw	r30, 0x01	; 1
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4380:	e2 17       	cp	r30, r18
    4382:	f3 07       	cpc	r31, r19
    4384:	a9 f7       	brne	.-22     	; 0x4370 <GetProductPrice+0x6e>
    4386:	80 e0       	ldi	r24, 0x00	; 0
	     if (PPumpID[i]==xPumpID){
		     iPumpID=i;
			 break;
		 }	 
	 }
	 if ((iPumpID>=0)&&(xNozzle<6)){
    4388:	b5 e0       	ldi	r27, 0x05	; 5
    438a:	bc 15       	cp	r27, r12
    438c:	08 f4       	brcc	.+2      	; 0x4390 <GetProductPrice+0x8e>
    438e:	41 c0       	rjmp	.+130    	; 0x4412 <GetProductPrice+0x110>
    4390:	66 e0       	ldi	r22, 0x06	; 6
    4392:	86 9f       	mul	r24, r22
    4394:	b0 01       	movw	r22, r0
    4396:	11 24       	eor	r1, r1
    4398:	6b 5a       	subi	r22, 0xAB	; 171
    439a:	7f 4f       	sbci	r23, 0xFF	; 255
    439c:	ce 01       	movw	r24, r28
    439e:	01 96       	adiw	r24, 0x01	; 1
    43a0:	46 e0       	ldi	r20, 0x06	; 6
    43a2:	50 e0       	ldi	r21, 0x00	; 0
    43a4:	2c ea       	ldi	r18, 0xAC	; 172
    43a6:	32 e1       	ldi	r19, 0x12	; 18
    43a8:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
         eeprom_read_block((void*) &PProdID,(const void*) &DefNozzleMap[iPumpID],6);
         xProductID=PProdID[xNozzle-1];
		 //Price
		 eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[xProductID-1], 9);
		 RemDecimal(strPrice);
    43ac:	8e 01       	movw	r16, r28
    43ae:	01 5f       	subi	r16, 0xF1	; 241
    43b0:	1f 4f       	sbci	r17, 0xFF	; 255
    43b2:	fe 01       	movw	r30, r28
    43b4:	ec 0d       	add	r30, r12
    43b6:	f1 1d       	adc	r31, r1
    43b8:	60 81       	ld	r22, Z
    43ba:	89 e0       	ldi	r24, 0x09	; 9
    43bc:	68 9f       	mul	r22, r24
    43be:	b0 01       	movw	r22, r0
    43c0:	11 24       	eor	r1, r1
    43c2:	64 55       	subi	r22, 0x54	; 84
    43c4:	7f 4f       	sbci	r23, 0xFF	; 255
    43c6:	c8 01       	movw	r24, r16
    43c8:	49 e0       	ldi	r20, 0x09	; 9
    43ca:	50 e0       	ldi	r21, 0x00	; 0
    43cc:	2c ea       	ldi	r18, 0xAC	; 172
    43ce:	32 e1       	ldi	r19, 0x12	; 18
    43d0:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
    43d4:	c8 01       	movw	r24, r16
    43d6:	0e 94 61 21 	call	0x42c2	; 0x42c2 <RemDecimal>
		 sprintf_P(sPrice,PSTR("%s"),strPrice);
    43da:	00 d0       	rcall	.+0      	; 0x43dc <GetProductPrice+0xda>
    43dc:	00 d0       	rcall	.+0      	; 0x43de <GetProductPrice+0xdc>
    43de:	00 d0       	rcall	.+0      	; 0x43e0 <GetProductPrice+0xde>
    43e0:	ed b7       	in	r30, 0x3d	; 61
    43e2:	fe b7       	in	r31, 0x3e	; 62
    43e4:	31 96       	adiw	r30, 0x01	; 1
    43e6:	ad b7       	in	r26, 0x3d	; 61
    43e8:	be b7       	in	r27, 0x3e	; 62
    43ea:	12 96       	adiw	r26, 0x02	; 2
    43ec:	fc 92       	st	X, r15
    43ee:	ee 92       	st	-X, r14
    43f0:	11 97       	sbiw	r26, 0x01	; 1
    43f2:	8d e7       	ldi	r24, 0x7D	; 125
    43f4:	94 e0       	ldi	r25, 0x04	; 4
    43f6:	93 83       	std	Z+3, r25	; 0x03
    43f8:	82 83       	std	Z+2, r24	; 0x02
    43fa:	15 83       	std	Z+5, r17	; 0x05
    43fc:	04 83       	std	Z+4, r16	; 0x04
    43fe:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    4402:	ed b7       	in	r30, 0x3d	; 61
    4404:	fe b7       	in	r31, 0x3e	; 62
    4406:	36 96       	adiw	r30, 0x06	; 6
    4408:	0f b6       	in	r0, 0x3f	; 63
    440a:	f8 94       	cli
    440c:	fe bf       	out	0x3e, r31	; 62
    440e:	0f be       	out	0x3f, r0	; 63
    4410:	ed bf       	out	0x3d, r30	; 61
	 }    
	 //Clear Decimal

}
    4412:	67 96       	adiw	r28, 0x17	; 23
    4414:	0f b6       	in	r0, 0x3f	; 63
    4416:	f8 94       	cli
    4418:	de bf       	out	0x3e, r29	; 62
    441a:	0f be       	out	0x3f, r0	; 63
    441c:	cd bf       	out	0x3d, r28	; 61
    441e:	cf 91       	pop	r28
    4420:	df 91       	pop	r29
    4422:	1f 91       	pop	r17
    4424:	0f 91       	pop	r16
    4426:	ff 90       	pop	r15
    4428:	ef 90       	pop	r14
    442a:	df 90       	pop	r13
    442c:	cf 90       	pop	r12
    442e:	08 95       	ret

00004430 <FormatDate>:
	 }     
   }
}

              //Fmt:DATE_LONG_YEAR,DATE_SHORT_YEAR //0123456789    0123456789 
void FormatDate(char FmtYear, char *Date){         //2010/06/16 -> 16/06/2010
    4430:	df 93       	push	r29
    4432:	cf 93       	push	r28
    4434:	cd b7       	in	r28, 0x3d	; 61
    4436:	de b7       	in	r29, 0x3e	; 62
    4438:	2b 97       	sbiw	r28, 0x0b	; 11
    443a:	0f b6       	in	r0, 0x3f	; 63
    443c:	f8 94       	cli
    443e:	de bf       	out	0x3e, r29	; 62
    4440:	0f be       	out	0x3f, r0	; 63
    4442:	cd bf       	out	0x3d, r28	; 61
    4444:	98 2f       	mov	r25, r24
    4446:	9b 01       	movw	r18, r22
     char i,sDate[11];

     sDate[0]=Date[8];
    4448:	fb 01       	movw	r30, r22
    444a:	80 85       	ldd	r24, Z+8	; 0x08
    444c:	89 83       	std	Y+1, r24	; 0x01
	 sDate[1]=Date[9];
    444e:	81 85       	ldd	r24, Z+9	; 0x09
    4450:	8a 83       	std	Y+2, r24	; 0x02
     sDate[2]=Date[7];
    4452:	87 81       	ldd	r24, Z+7	; 0x07
    4454:	8b 83       	std	Y+3, r24	; 0x03
	 sDate[3]=Date[5];
    4456:	85 81       	ldd	r24, Z+5	; 0x05
    4458:	8c 83       	std	Y+4, r24	; 0x04
     sDate[4]=Date[6];
    445a:	86 81       	ldd	r24, Z+6	; 0x06
    445c:	8d 83       	std	Y+5, r24	; 0x05
	 sDate[5]=Date[4];
    445e:	84 81       	ldd	r24, Z+4	; 0x04
    4460:	8e 83       	std	Y+6, r24	; 0x06
	 switch(FmtYear){
    4462:	99 23       	and	r25, r25
    4464:	19 f0       	breq	.+6      	; 0x446c <FormatDate+0x3c>
    4466:	91 30       	cpi	r25, 0x01	; 1
    4468:	59 f4       	brne	.+22     	; 0x4480 <FormatDate+0x50>
    446a:	0f c0       	rjmp	.+30     	; 0x448a <FormatDate+0x5a>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
    446c:	fb 01       	movw	r30, r22
    446e:	80 81       	ld	r24, Z
    4470:	8f 83       	std	Y+7, r24	; 0x07
    4472:	81 81       	ldd	r24, Z+1	; 0x01
    4474:	88 87       	std	Y+8, r24	; 0x08
    4476:	82 81       	ldd	r24, Z+2	; 0x02
    4478:	89 87       	std	Y+9, r24	; 0x09
    447a:	83 81       	ldd	r24, Z+3	; 0x03
    447c:	8a 87       	std	Y+10, r24	; 0x0a
          sDate[10]=0;
    447e:	1b 86       	std	Y+11, r1	; 0x0b
    4480:	90 e0       	ldi	r25, 0x00	; 0
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
          sDate[8]=0;
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    4482:	ae 01       	movw	r20, r28
    4484:	4f 5f       	subi	r20, 0xFF	; 255
    4486:	5f 4f       	sbci	r21, 0xFF	; 255
    4488:	0f c0       	rjmp	.+30     	; 0x44a8 <FormatDate+0x78>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
          sDate[10]=0;
	      break;
	 case DATE_SHORT_YEAR:
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
    448a:	fb 01       	movw	r30, r22
    448c:	82 81       	ldd	r24, Z+2	; 0x02
    448e:	8f 83       	std	Y+7, r24	; 0x07
    4490:	83 81       	ldd	r24, Z+3	; 0x03
    4492:	88 87       	std	Y+8, r24	; 0x08
          sDate[8]=0;
    4494:	19 86       	std	Y+9, r1	; 0x09
    4496:	f4 cf       	rjmp	.-24     	; 0x4480 <FormatDate+0x50>
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    4498:	f9 01       	movw	r30, r18
    449a:	ea 0f       	add	r30, r26
    449c:	fb 1f       	adc	r31, r27
    449e:	a4 0f       	add	r26, r20
    44a0:	b5 1f       	adc	r27, r21
    44a2:	8c 91       	ld	r24, X
    44a4:	80 83       	st	Z, r24
    44a6:	9f 5f       	subi	r25, 0xFF	; 255
    44a8:	a9 2f       	mov	r26, r25
    44aa:	b0 e0       	ldi	r27, 0x00	; 0
    44ac:	fa 01       	movw	r30, r20
    44ae:	01 90       	ld	r0, Z+
    44b0:	00 20       	and	r0, r0
    44b2:	e9 f7       	brne	.-6      	; 0x44ae <FormatDate+0x7e>
    44b4:	31 97       	sbiw	r30, 0x01	; 1
    44b6:	e4 1b       	sub	r30, r20
    44b8:	f5 0b       	sbc	r31, r21
    44ba:	ae 17       	cp	r26, r30
    44bc:	bf 07       	cpc	r27, r31
    44be:	60 f3       	brcs	.-40     	; 0x4498 <FormatDate+0x68>
}
    44c0:	2b 96       	adiw	r28, 0x0b	; 11
    44c2:	0f b6       	in	r0, 0x3f	; 63
    44c4:	f8 94       	cli
    44c6:	de bf       	out	0x3e, r29	; 62
    44c8:	0f be       	out	0x3f, r0	; 63
    44ca:	cd bf       	out	0x3d, r28	; 61
    44cc:	cf 91       	pop	r28
    44ce:	df 91       	pop	r29
    44d0:	08 95       	ret

000044d2 <RemZeroLead>:
	 _uart_print(0,1,strTest);

while (1){};
}

void RemZeroLead(char *Zeroed){//Remove Zero Character 00001004 000050000 0 
    44d2:	cf 93       	push	r28
    44d4:	df 93       	push	r29
    44d6:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
    44d8:	fc 01       	movw	r30, r24
    44da:	01 90       	ld	r0, Z+
    44dc:	00 20       	and	r0, r0
    44de:	e9 f7       	brne	.-6      	; 0x44da <RemZeroLead+0x8>
    44e0:	31 97       	sbiw	r30, 0x01	; 1
    44e2:	e8 1b       	sub	r30, r24
  if ((Length>1)&&(Zeroed[0]=='0')){
    44e4:	e2 30       	cpi	r30, 0x02	; 2
    44e6:	d0 f1       	brcs	.+116    	; 0x455c <RemZeroLead+0x8a>
    44e8:	88 81       	ld	r24, Y
    44ea:	80 33       	cpi	r24, 0x30	; 48
    44ec:	b9 f5       	brne	.+110    	; 0x455c <RemZeroLead+0x8a>
    44ee:	4c 2f       	mov	r20, r28
    44f0:	de 01       	movw	r26, r28
    44f2:	90 e0       	ldi	r25, 0x00	; 0
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
	         if ((Zeroed[i]=='0')&&(Zeroed[i+1]=='0')&&(IsFound==False)) ZeroPos++;
    44f4:	8c 91       	ld	r24, X
    44f6:	80 33       	cpi	r24, 0x30	; 48
    44f8:	69 f4       	brne	.+26     	; 0x4514 <RemZeroLead+0x42>
    44fa:	11 96       	adiw	r26, 0x01	; 1
    44fc:	8c 91       	ld	r24, X
    44fe:	11 97       	sbiw	r26, 0x01	; 1
    4500:	80 33       	cpi	r24, 0x30	; 48
    4502:	11 f4       	brne	.+4      	; 0x4508 <RemZeroLead+0x36>
    4504:	9f 5f       	subi	r25, 0xFF	; 255
    4506:	06 c0       	rjmp	.+12     	; 0x4514 <RemZeroLead+0x42>
             if ((Zeroed[i]=='0')&&(Zeroed[i+1]!='0')){
			     if ((Zeroed[i+1]=='.')||(Zeroed[i+1]==','))ZeroPos--;
    4508:	8e 32       	cpi	r24, 0x2E	; 46
    450a:	11 f0       	breq	.+4      	; 0x4510 <RemZeroLead+0x3e>
    450c:	8c 32       	cpi	r24, 0x2C	; 44
    450e:	41 f4       	brne	.+16     	; 0x4520 <RemZeroLead+0x4e>
    4510:	91 50       	subi	r25, 0x01	; 1
    4512:	06 c0       	rjmp	.+12     	; 0x4520 <RemZeroLead+0x4e>
    4514:	11 96       	adiw	r26, 0x01	; 1
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
  if ((Length>1)&&(Zeroed[0]=='0')){
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
    4516:	8a 2f       	mov	r24, r26
    4518:	84 1b       	sub	r24, r20
    451a:	8e 17       	cp	r24, r30
    451c:	58 f3       	brcs	.-42     	; 0x44f4 <RemZeroLead+0x22>
    451e:	01 c0       	rjmp	.+2      	; 0x4522 <RemZeroLead+0x50>
		         IsFound=True;
			     break;			  
			     }
	      }

		  if (IsFound==True)ZeroPos++;
    4520:	9f 5f       	subi	r25, 0xFF	; 255
		  if (ZeroPos>=Length)ZeroPos=Length-1;
    4522:	9e 17       	cp	r25, r30
    4524:	10 f0       	brcs	.+4      	; 0x452a <RemZeroLead+0x58>
    4526:	9e 2f       	mov	r25, r30
    4528:	91 50       	subi	r25, 0x01	; 1
    452a:	40 e0       	ldi	r20, 0x00	; 0
          for(i=0;i<(Length-ZeroPos);i++){
    452c:	89 2f       	mov	r24, r25
    452e:	90 e0       	ldi	r25, 0x00	; 0
    4530:	2e 2f       	mov	r18, r30
    4532:	30 e0       	ldi	r19, 0x00	; 0
    4534:	28 1b       	sub	r18, r24
    4536:	39 0b       	sbc	r19, r25
	          Zeroed[i]=Zeroed[i+ZeroPos];
    4538:	be 01       	movw	r22, r28
    453a:	68 0f       	add	r22, r24
    453c:	79 1f       	adc	r23, r25
    453e:	09 c0       	rjmp	.+18     	; 0x4552 <RemZeroLead+0x80>
    4540:	fe 01       	movw	r30, r28
    4542:	ea 0f       	add	r30, r26
    4544:	fb 1f       	adc	r31, r27
    4546:	a6 0f       	add	r26, r22
    4548:	b7 1f       	adc	r27, r23
    454a:	8c 91       	ld	r24, X
    454c:	80 83       	st	Z, r24
		      Zeroed[i+1]=0;
    454e:	11 82       	std	Z+1, r1	; 0x01
			     }
	      }

		  if (IsFound==True)ZeroPos++;
		  if (ZeroPos>=Length)ZeroPos=Length-1;
          for(i=0;i<(Length-ZeroPos);i++){
    4550:	4f 5f       	subi	r20, 0xFF	; 255
    4552:	a4 2f       	mov	r26, r20
    4554:	b0 e0       	ldi	r27, 0x00	; 0
    4556:	a2 17       	cp	r26, r18
    4558:	b3 07       	cpc	r27, r19
    455a:	94 f3       	brlt	.-28     	; 0x4540 <RemZeroLead+0x6e>
	          Zeroed[i]=Zeroed[i+ZeroPos];
		      Zeroed[i+1]=0;
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}
    455c:	df 91       	pop	r29
    455e:	cf 91       	pop	r28
    4560:	08 95       	ret

00004562 <FTestRemZero>:
	 for(i=(Length-ZeroPos);i<Length;i++){
	     Zeroed[i]=0;
	 }
}

void FTestRemZero(){
    4562:	0f 93       	push	r16
    4564:	1f 93       	push	r17
    4566:	df 93       	push	r29
    4568:	cf 93       	push	r28
    456a:	cd b7       	in	r28, 0x3d	; 61
    456c:	de b7       	in	r29, 0x3e	; 62
    456e:	64 97       	sbiw	r28, 0x14	; 20
    4570:	0f b6       	in	r0, 0x3f	; 63
    4572:	f8 94       	cli
    4574:	de bf       	out	0x3e, r29	; 62
    4576:	0f be       	out	0x3f, r0	; 63
    4578:	cd bf       	out	0x3d, r28	; 61
char strSend[50],strTest[20];

     sprintf_P(strTest,PSTR("00012300"));
    457a:	00 d0       	rcall	.+0      	; 0x457c <FTestRemZero+0x1a>
    457c:	00 d0       	rcall	.+0      	; 0x457e <FTestRemZero+0x1c>
    457e:	8e 01       	movw	r16, r28
    4580:	0f 5f       	subi	r16, 0xFF	; 255
    4582:	1f 4f       	sbci	r17, 0xFF	; 255
    4584:	ed b7       	in	r30, 0x3d	; 61
    4586:	fe b7       	in	r31, 0x3e	; 62
    4588:	12 83       	std	Z+2, r17	; 0x02
    458a:	01 83       	std	Z+1, r16	; 0x01
    458c:	80 ed       	ldi	r24, 0xD0	; 208
    458e:	9a e0       	ldi	r25, 0x0A	; 10
    4590:	94 83       	std	Z+4, r25	; 0x04
    4592:	83 83       	std	Z+3, r24	; 0x03
    4594:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 _uart_print(0,1,strTest);
    4598:	0f 90       	pop	r0
    459a:	0f 90       	pop	r0
    459c:	0f 90       	pop	r0
    459e:	0f 90       	pop	r0
    45a0:	80 e0       	ldi	r24, 0x00	; 0
    45a2:	61 e0       	ldi	r22, 0x01	; 1
    45a4:	a8 01       	movw	r20, r16
    45a6:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
     RemZeroLead(strTest);  
    45aa:	c8 01       	movw	r24, r16
    45ac:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
	 _uart_print(0,1,strTest);
    45b0:	80 e0       	ldi	r24, 0x00	; 0
    45b2:	61 e0       	ldi	r22, 0x01	; 1
    45b4:	a8 01       	movw	r20, r16
    45b6:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>

     sprintf_P(strTest,PSTR("00,012300"));
    45ba:	00 d0       	rcall	.+0      	; 0x45bc <FTestRemZero+0x5a>
    45bc:	00 d0       	rcall	.+0      	; 0x45be <FTestRemZero+0x5c>
    45be:	ed b7       	in	r30, 0x3d	; 61
    45c0:	fe b7       	in	r31, 0x3e	; 62
    45c2:	12 83       	std	Z+2, r17	; 0x02
    45c4:	01 83       	std	Z+1, r16	; 0x01
    45c6:	86 ec       	ldi	r24, 0xC6	; 198
    45c8:	9a e0       	ldi	r25, 0x0A	; 10
    45ca:	94 83       	std	Z+4, r25	; 0x04
    45cc:	83 83       	std	Z+3, r24	; 0x03
    45ce:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 _uart_print(0,1,strTest);
    45d2:	0f 90       	pop	r0
    45d4:	0f 90       	pop	r0
    45d6:	0f 90       	pop	r0
    45d8:	0f 90       	pop	r0
    45da:	80 e0       	ldi	r24, 0x00	; 0
    45dc:	61 e0       	ldi	r22, 0x01	; 1
    45de:	a8 01       	movw	r20, r16
    45e0:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
     RemZeroLead(strTest);  
    45e4:	c8 01       	movw	r24, r16
    45e6:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
	 _uart_print(0,1,strTest);
    45ea:	80 e0       	ldi	r24, 0x00	; 0
    45ec:	61 e0       	ldi	r22, 0x01	; 1
    45ee:	a8 01       	movw	r20, r16
    45f0:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>

     sprintf_P(strTest,PSTR("00.012300"));
    45f4:	00 d0       	rcall	.+0      	; 0x45f6 <FTestRemZero+0x94>
    45f6:	00 d0       	rcall	.+0      	; 0x45f8 <FTestRemZero+0x96>
    45f8:	ed b7       	in	r30, 0x3d	; 61
    45fa:	fe b7       	in	r31, 0x3e	; 62
    45fc:	12 83       	std	Z+2, r17	; 0x02
    45fe:	01 83       	std	Z+1, r16	; 0x01
    4600:	8c eb       	ldi	r24, 0xBC	; 188
    4602:	9a e0       	ldi	r25, 0x0A	; 10
    4604:	94 83       	std	Z+4, r25	; 0x04
    4606:	83 83       	std	Z+3, r24	; 0x03
    4608:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 _uart_print(0,1,strTest);
    460c:	0f 90       	pop	r0
    460e:	0f 90       	pop	r0
    4610:	0f 90       	pop	r0
    4612:	0f 90       	pop	r0
    4614:	80 e0       	ldi	r24, 0x00	; 0
    4616:	61 e0       	ldi	r22, 0x01	; 1
    4618:	a8 01       	movw	r20, r16
    461a:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
     RemZeroLead(strTest);  
    461e:	c8 01       	movw	r24, r16
    4620:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
	 _uart_print(0,1,strTest);
    4624:	80 e0       	ldi	r24, 0x00	; 0
    4626:	61 e0       	ldi	r22, 0x01	; 1
    4628:	a8 01       	movw	r20, r16
    462a:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>


     sprintf_P(strTest,PSTR("012300"));
    462e:	00 d0       	rcall	.+0      	; 0x4630 <FTestRemZero+0xce>
    4630:	00 d0       	rcall	.+0      	; 0x4632 <FTestRemZero+0xd0>
    4632:	ed b7       	in	r30, 0x3d	; 61
    4634:	fe b7       	in	r31, 0x3e	; 62
    4636:	12 83       	std	Z+2, r17	; 0x02
    4638:	01 83       	std	Z+1, r16	; 0x01
    463a:	85 eb       	ldi	r24, 0xB5	; 181
    463c:	9a e0       	ldi	r25, 0x0A	; 10
    463e:	94 83       	std	Z+4, r25	; 0x04
    4640:	83 83       	std	Z+3, r24	; 0x03
    4642:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 _uart_print(0,1,strTest);
    4646:	0f 90       	pop	r0
    4648:	0f 90       	pop	r0
    464a:	0f 90       	pop	r0
    464c:	0f 90       	pop	r0
    464e:	80 e0       	ldi	r24, 0x00	; 0
    4650:	61 e0       	ldi	r22, 0x01	; 1
    4652:	a8 01       	movw	r20, r16
    4654:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
     RemZeroLead(strTest);  
    4658:	c8 01       	movw	r24, r16
    465a:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
	 _uart_print(0,1,strTest);
    465e:	80 e0       	ldi	r24, 0x00	; 0
    4660:	61 e0       	ldi	r22, 0x01	; 1
    4662:	a8 01       	movw	r20, r16
    4664:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>


     sprintf_P(strTest,PSTR("0000"));
    4668:	00 d0       	rcall	.+0      	; 0x466a <FTestRemZero+0x108>
    466a:	00 d0       	rcall	.+0      	; 0x466c <FTestRemZero+0x10a>
    466c:	ed b7       	in	r30, 0x3d	; 61
    466e:	fe b7       	in	r31, 0x3e	; 62
    4670:	12 83       	std	Z+2, r17	; 0x02
    4672:	01 83       	std	Z+1, r16	; 0x01
    4674:	80 eb       	ldi	r24, 0xB0	; 176
    4676:	9a e0       	ldi	r25, 0x0A	; 10
    4678:	94 83       	std	Z+4, r25	; 0x04
    467a:	83 83       	std	Z+3, r24	; 0x03
    467c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 _uart_print(0,1,strTest);
    4680:	0f 90       	pop	r0
    4682:	0f 90       	pop	r0
    4684:	0f 90       	pop	r0
    4686:	0f 90       	pop	r0
    4688:	80 e0       	ldi	r24, 0x00	; 0
    468a:	61 e0       	ldi	r22, 0x01	; 1
    468c:	a8 01       	movw	r20, r16
    468e:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
     RemZeroLead(strTest);  
    4692:	c8 01       	movw	r24, r16
    4694:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
	 _uart_print(0,1,strTest);
    4698:	80 e0       	ldi	r24, 0x00	; 0
    469a:	61 e0       	ldi	r22, 0x01	; 1
    469c:	a8 01       	movw	r20, r16
    469e:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>


     sprintf_P(strTest,PSTR("00"));
    46a2:	00 d0       	rcall	.+0      	; 0x46a4 <FTestRemZero+0x142>
    46a4:	00 d0       	rcall	.+0      	; 0x46a6 <FTestRemZero+0x144>
    46a6:	ed b7       	in	r30, 0x3d	; 61
    46a8:	fe b7       	in	r31, 0x3e	; 62
    46aa:	12 83       	std	Z+2, r17	; 0x02
    46ac:	01 83       	std	Z+1, r16	; 0x01
    46ae:	8d ea       	ldi	r24, 0xAD	; 173
    46b0:	9a e0       	ldi	r25, 0x0A	; 10
    46b2:	94 83       	std	Z+4, r25	; 0x04
    46b4:	83 83       	std	Z+3, r24	; 0x03
    46b6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 _uart_print(0,1,strTest);
    46ba:	0f 90       	pop	r0
    46bc:	0f 90       	pop	r0
    46be:	0f 90       	pop	r0
    46c0:	0f 90       	pop	r0
    46c2:	80 e0       	ldi	r24, 0x00	; 0
    46c4:	61 e0       	ldi	r22, 0x01	; 1
    46c6:	a8 01       	movw	r20, r16
    46c8:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
     RemZeroLead(strTest);  
    46cc:	c8 01       	movw	r24, r16
    46ce:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
	 _uart_print(0,1,strTest);
    46d2:	80 e0       	ldi	r24, 0x00	; 0
    46d4:	61 e0       	ldi	r22, 0x01	; 1
    46d6:	a8 01       	movw	r20, r16
    46d8:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>

     sprintf_P(strTest,PSTR("0"));
    46dc:	00 d0       	rcall	.+0      	; 0x46de <FTestRemZero+0x17c>
    46de:	00 d0       	rcall	.+0      	; 0x46e0 <FTestRemZero+0x17e>
    46e0:	ed b7       	in	r30, 0x3d	; 61
    46e2:	fe b7       	in	r31, 0x3e	; 62
    46e4:	12 83       	std	Z+2, r17	; 0x02
    46e6:	01 83       	std	Z+1, r16	; 0x01
    46e8:	8b ea       	ldi	r24, 0xAB	; 171
    46ea:	9a e0       	ldi	r25, 0x0A	; 10
    46ec:	94 83       	std	Z+4, r25	; 0x04
    46ee:	83 83       	std	Z+3, r24	; 0x03
    46f0:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 _uart_print(0,1,strTest);
    46f4:	0f 90       	pop	r0
    46f6:	0f 90       	pop	r0
    46f8:	0f 90       	pop	r0
    46fa:	0f 90       	pop	r0
    46fc:	80 e0       	ldi	r24, 0x00	; 0
    46fe:	61 e0       	ldi	r22, 0x01	; 1
    4700:	a8 01       	movw	r20, r16
    4702:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
     RemZeroLead(strTest);  
    4706:	c8 01       	movw	r24, r16
    4708:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
	 _uart_print(0,1,strTest);
    470c:	80 e0       	ldi	r24, 0x00	; 0
    470e:	61 e0       	ldi	r22, 0x01	; 1
    4710:	a8 01       	movw	r20, r16
    4712:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
    4716:	ff cf       	rjmp	.-2      	; 0x4716 <FTestRemZero+0x1b4>

00004718 <RemSpaceLead>:
	 }
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}
void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
    4718:	1f 93       	push	r17
    471a:	9c 01       	movw	r18, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
    471c:	fc 01       	movw	r30, r24
    471e:	01 90       	ld	r0, Z+
    4720:	00 20       	and	r0, r0
    4722:	e9 f7       	brne	.-6      	; 0x471e <RemSpaceLead+0x6>
    4724:	31 97       	sbiw	r30, 0x01	; 1
    4726:	1e 2f       	mov	r17, r30
    4728:	18 1b       	sub	r17, r24
    472a:	fc 01       	movw	r30, r24
    472c:	40 e0       	ldi	r20, 0x00	; 0
    472e:	90 e0       	ldi	r25, 0x00	; 0
    4730:	50 e0       	ldi	r21, 0x00	; 0
    4732:	0d c0       	rjmp	.+26     	; 0x474e <RemSpaceLead+0x36>
     for(i=0;i<Length;i++){
	     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
    4734:	80 81       	ld	r24, Z
    4736:	80 32       	cpi	r24, 0x20	; 32
    4738:	41 f4       	brne	.+16     	; 0x474a <RemSpaceLead+0x32>
    473a:	81 81       	ldd	r24, Z+1	; 0x01
    473c:	80 32       	cpi	r24, 0x20	; 32
    473e:	21 f4       	brne	.+8      	; 0x4748 <RemSpaceLead+0x30>
    4740:	55 23       	and	r21, r21
    4742:	19 f4       	brne	.+6      	; 0x474a <RemSpaceLead+0x32>
    4744:	9f 5f       	subi	r25, 0xFF	; 255
    4746:	01 c0       	rjmp	.+2      	; 0x474a <RemSpaceLead+0x32>
    4748:	51 e0       	ldi	r21, 0x01	; 1
	 Spaced[strlen(Spaced)]=0;
}
void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
     for(i=0;i<Length;i++){
    474a:	4f 5f       	subi	r20, 0xFF	; 255
    474c:	31 96       	adiw	r30, 0x01	; 1
    474e:	41 17       	cp	r20, r17
    4750:	88 f3       	brcs	.-30     	; 0x4734 <RemSpaceLead+0x1c>
	     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
	 }ZeroPos++;
    4752:	59 2f       	mov	r21, r25
    4754:	5f 5f       	subi	r21, 0xFF	; 255
    4756:	40 e0       	ldi	r20, 0x00	; 0
     for(i=0;i<strlen(Zeroed);i++){
	     Zeroed[i]=Zeroed[i+ZeroPos];
    4758:	65 2f       	mov	r22, r21
    475a:	70 e0       	ldi	r23, 0x00	; 0
    475c:	09 c0       	rjmp	.+18     	; 0x4770 <RemSpaceLead+0x58>
    475e:	f9 01       	movw	r30, r18
    4760:	e8 0f       	add	r30, r24
    4762:	f9 1f       	adc	r31, r25
    4764:	df 01       	movw	r26, r30
    4766:	a6 0f       	add	r26, r22
    4768:	b7 1f       	adc	r27, r23
    476a:	8c 91       	ld	r24, X
    476c:	80 83       	st	Z, r24
     ZeroPos=0;Length=strlen(Zeroed);
     for(i=0;i<Length;i++){
	     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
	 }ZeroPos++;
     for(i=0;i<strlen(Zeroed);i++){
    476e:	4f 5f       	subi	r20, 0xFF	; 255
    4770:	84 2f       	mov	r24, r20
    4772:	90 e0       	ldi	r25, 0x00	; 0
    4774:	f9 01       	movw	r30, r18
    4776:	01 90       	ld	r0, Z+
    4778:	00 20       	and	r0, r0
    477a:	e9 f7       	brne	.-6      	; 0x4776 <RemSpaceLead+0x5e>
    477c:	31 97       	sbiw	r30, 0x01	; 1
    477e:	e2 1b       	sub	r30, r18
    4780:	f3 0b       	sbc	r31, r19
    4782:	8e 17       	cp	r24, r30
    4784:	9f 07       	cpc	r25, r31
    4786:	58 f3       	brcs	.-42     	; 0x475e <RemSpaceLead+0x46>
	     Zeroed[i]=Zeroed[i+ZeroPos];
	 }
	 //Clearence
	 for(i=(Length-ZeroPos);i<Length;i++){
    4788:	81 2f       	mov	r24, r17
    478a:	85 1b       	sub	r24, r21
    478c:	05 c0       	rjmp	.+10     	; 0x4798 <RemSpaceLead+0x80>
	     Zeroed[i]=0;
    478e:	f9 01       	movw	r30, r18
    4790:	e8 0f       	add	r30, r24
    4792:	f1 1d       	adc	r31, r1
    4794:	10 82       	st	Z, r1
	 }ZeroPos++;
     for(i=0;i<strlen(Zeroed);i++){
	     Zeroed[i]=Zeroed[i+ZeroPos];
	 }
	 //Clearence
	 for(i=(Length-ZeroPos);i<Length;i++){
    4796:	8f 5f       	subi	r24, 0xFF	; 255
    4798:	81 17       	cp	r24, r17
    479a:	c8 f3       	brcs	.-14     	; 0x478e <RemSpaceLead+0x76>
	     Zeroed[i]=0;
	 }
}
    479c:	1f 91       	pop	r17
    479e:	08 95       	ret

000047a0 <RemSpaceLag>:
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
	 return Result;
}

void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS
    47a0:	cf 93       	push	r28
    47a2:	df 93       	push	r29
    47a4:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
    47a6:	fc 01       	movw	r30, r24
    47a8:	01 90       	ld	r0, Z+
    47aa:	00 20       	and	r0, r0
    47ac:	e9 f7       	brne	.-6      	; 0x47a8 <RemSpaceLag+0x8>
    47ae:	31 97       	sbiw	r30, 0x01	; 1
    47b0:	e8 1b       	sub	r30, r24
    47b2:	ae 2f       	mov	r26, r30
    47b4:	b0 e0       	ldi	r27, 0x00	; 0
    47b6:	11 97       	sbiw	r26, 0x01	; 1
    47b8:	a8 0f       	add	r26, r24
    47ba:	b9 1f       	adc	r27, r25
    47bc:	90 e0       	ldi	r25, 0x00	; 0
    47be:	20 e0       	ldi	r18, 0x00	; 0
    47c0:	30 e0       	ldi	r19, 0x00	; 0
    47c2:	0e c0       	rjmp	.+28     	; 0x47e0 <RemSpaceLag+0x40>
     for(i=0;i<Length;i++){
	     if ((Spaced[Length-i-1]==' ')&&(Spaced[Length-i]==' ')){
    47c4:	8c 91       	ld	r24, X
    47c6:	80 32       	cpi	r24, 0x20	; 32
    47c8:	69 f4       	brne	.+26     	; 0x47e4 <RemSpaceLag+0x44>
    47ca:	2f 5f       	subi	r18, 0xFF	; 255
    47cc:	3f 4f       	sbci	r19, 0xFF	; 255
    47ce:	11 96       	adiw	r26, 0x01	; 1
    47d0:	8c 91       	ld	r24, X
    47d2:	11 97       	sbiw	r26, 0x01	; 1
    47d4:	80 32       	cpi	r24, 0x20	; 32
    47d6:	31 f4       	brne	.+12     	; 0x47e4 <RemSpaceLag+0x44>
		      Spaced[Length-i-1]=0;
    47d8:	1c 92       	st	X, r1
    47da:	9e 2f       	mov	r25, r30
    47dc:	92 1b       	sub	r25, r18
    47de:	11 97       	sbiw	r26, 0x01	; 1
}

void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<Length;i++){
    47e0:	2e 17       	cp	r18, r30
    47e2:	80 f3       	brcs	.-32     	; 0x47c4 <RemSpaceLag+0x24>
		      Spaced[Length-i-1]=0;
			  PosSpaced=Length-i-1;
			  }
         else break;
	 }
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
    47e4:	fe 01       	movw	r30, r28
    47e6:	e9 0f       	add	r30, r25
    47e8:	f1 1d       	adc	r31, r1
    47ea:	80 81       	ld	r24, Z
    47ec:	80 32       	cpi	r24, 0x20	; 32
    47ee:	09 f4       	brne	.+2      	; 0x47f2 <RemSpaceLag+0x52>
    47f0:	10 82       	st	Z, r1
	 if (Spaced[0]==' ')Spaced[0]=0;
    47f2:	88 81       	ld	r24, Y
    47f4:	80 32       	cpi	r24, 0x20	; 32
    47f6:	09 f4       	brne	.+2      	; 0x47fa <RemSpaceLag+0x5a>
    47f8:	18 82       	st	Y, r1
	 Spaced[strlen(Spaced)]=0;
    47fa:	fe 01       	movw	r30, r28
    47fc:	01 90       	ld	r0, Z+
    47fe:	00 20       	and	r0, r0
    4800:	e9 f7       	brne	.-6      	; 0x47fc <RemSpaceLag+0x5c>
    4802:	31 97       	sbiw	r30, 0x01	; 1
    4804:	ec 1b       	sub	r30, r28
    4806:	fd 0b       	sbc	r31, r29
    4808:	ec 0f       	add	r30, r28
    480a:	fd 1f       	adc	r31, r29
    480c:	10 82       	st	Z, r1
}
    480e:	df 91       	pop	r29
    4810:	cf 91       	pop	r28
    4812:	08 95       	ret

00004814 <procMessage57>:
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}

char procMessage57(){
    4814:	1f 93       	push	r17
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    4816:	10 91 5e 0b 	lds	r17, 0x0B5E
    481a:	20 e0       	ldi	r18, 0x00	; 0
    481c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    481e:	f9 01       	movw	r30, r18
    4820:	eb 5d       	subi	r30, 0xDB	; 219
    4822:	f4 4f       	sbci	r31, 0xF4	; 244
    4824:	d9 01       	movw	r26, r18
    4826:	af 56       	subi	r26, 0x6F	; 111
    4828:	b2 4f       	sbci	r27, 0xF2	; 242
    482a:	95 96       	adiw	r26, 0x25	; 37
    482c:	8c 91       	ld	r24, X
    482e:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4830:	2f 5f       	subi	r18, 0xFF	; 255
    4832:	3f 4f       	sbci	r19, 0xFF	; 255
    4834:	24 31       	cpi	r18, 0x14	; 20
    4836:	31 05       	cpc	r19, r1
    4838:	91 f7       	brne	.-28     	; 0x481e <procMessage57+0xa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    483a:	10 92 39 0b 	sts	0x0B39, r1
	 
	     //Card Status
		 Result=(CharPosCopy(rcv_trans,57)-'0')+1;
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
    483e:	81 e9       	ldi	r24, 0x91	; 145
    4840:	9d e0       	ldi	r25, 0x0D	; 13
    4842:	0e 94 8c 23 	call	0x4718	; 0x4718 <RemSpaceLead>
    4846:	20 e0       	ldi	r18, 0x00	; 0
    4848:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    484a:	f9 01       	movw	r30, r18
    484c:	e6 5d       	subi	r30, 0xD6	; 214
    484e:	fa 4f       	sbci	r31, 0xFA	; 250
    4850:	d9 01       	movw	r26, r18
    4852:	ab 5d       	subi	r26, 0xDB	; 219
    4854:	b4 4f       	sbci	r27, 0xF4	; 244
    4856:	dc 96       	adiw	r26, 0x3c	; 60
    4858:	8c 91       	ld	r24, X
    485a:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    485c:	2f 5f       	subi	r18, 0xFF	; 255
    485e:	3f 4f       	sbci	r19, 0xFF	; 255
    4860:	28 32       	cpi	r18, 0x28	; 40
    4862:	31 05       	cpc	r19, r1
    4864:	91 f7       	brne	.-28     	; 0x484a <procMessage57+0x36>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4866:	10 92 52 05 	sts	0x0552, r1
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
    486a:	8a e2       	ldi	r24, 0x2A	; 42
    486c:	95 e0       	ldi	r25, 0x05	; 5
    486e:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
    4872:	20 e0       	ldi	r18, 0x00	; 0
    4874:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4876:	f9 01       	movw	r30, r18
    4878:	ef 59       	subi	r30, 0x9F	; 159
    487a:	fa 4f       	sbci	r31, 0xFA	; 250
    487c:	d9 01       	movw	r26, r18
    487e:	a3 54       	subi	r26, 0x43	; 67
    4880:	b4 4f       	sbci	r27, 0xF4	; 244
    4882:	8c 91       	ld	r24, X
    4884:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4886:	2f 5f       	subi	r18, 0xFF	; 255
    4888:	3f 4f       	sbci	r19, 0xFF	; 255
    488a:	29 31       	cpi	r18, 0x19	; 25
    488c:	31 05       	cpc	r19, r1
    488e:	99 f7       	brne	.-26     	; 0x4876 <procMessage57+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4890:	10 92 7a 05 	sts	0x057A, r1
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
		 //BalanceTypePrint
		 StrPosCopy(rcv_trans,strBalanceTypePrint,154-2,25);
		 RemSpaceLag(strBalanceTypePrint);
    4894:	81 e6       	ldi	r24, 0x61	; 97
    4896:	95 e0       	ldi	r25, 0x05	; 5
    4898:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    489c:	80 91 d6 0b 	lds	r24, 0x0BD6
    48a0:	80 93 eb 04 	sts	0x04EB, r24
	 }Dest[Length]=0;
    48a4:	10 92 ec 04 	sts	0x04EC, r1
    48a8:	20 e0       	ldi	r18, 0x00	; 0
    48aa:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    48ac:	f9 01       	movw	r30, r18
    48ae:	ed 5f       	subi	r30, 0xFD	; 253
    48b0:	f1 4f       	sbci	r31, 0xF1	; 241
    48b2:	d9 01       	movw	r26, r18
    48b4:	a9 52       	subi	r26, 0x29	; 41
    48b6:	b4 4f       	sbci	r27, 0xF4	; 244
    48b8:	8c 91       	ld	r24, X
    48ba:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    48bc:	2f 5f       	subi	r18, 0xFF	; 255
    48be:	3f 4f       	sbci	r19, 0xFF	; 255
    48c0:	2d 30       	cpi	r18, 0x0D	; 13
    48c2:	31 05       	cpc	r19, r1
    48c4:	99 f7       	brne	.-26     	; 0x48ac <procMessage57+0x98>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    48c6:	10 92 10 0e 	sts	0x0E10, r1
		 RemSpaceLag(strBalanceTypePrint);
         //BalanceTypeCode
		 StrPosCopy(rcv_trans,strBalanceCode,177,1);
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
    48ca:	83 e0       	ldi	r24, 0x03	; 3
    48cc:	9e e0       	ldi	r25, 0x0E	; 14
    48ce:	0e 94 8c 23 	call	0x4718	; 0x4718 <RemSpaceLead>
    48d2:	20 e0       	ldi	r18, 0x00	; 0
    48d4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    48d6:	f9 01       	movw	r30, r18
    48d8:	ee 5f       	subi	r30, 0xFE	; 254
    48da:	f4 4f       	sbci	r31, 0xF4	; 244
    48dc:	d9 01       	movw	r26, r18
    48de:	ac 51       	subi	r26, 0x1C	; 28
    48e0:	b4 4f       	sbci	r27, 0xF4	; 244
    48e2:	8c 91       	ld	r24, X
    48e4:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    48e6:	2f 5f       	subi	r18, 0xFF	; 255
    48e8:	3f 4f       	sbci	r19, 0xFF	; 255
    48ea:	2a 30       	cpi	r18, 0x0A	; 10
    48ec:	31 05       	cpc	r19, r1
    48ee:	99 f7       	brne	.-26     	; 0x48d6 <procMessage57+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    48f0:	10 92 0c 0b 	sts	0x0B0C, r1
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
    48f4:	82 e0       	ldi	r24, 0x02	; 2
    48f6:	9b e0       	ldi	r25, 0x0B	; 11
    48f8:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
    48fc:	20 e0       	ldi	r18, 0x00	; 0
    48fe:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4900:	f9 01       	movw	r30, r18
    4902:	e8 57       	subi	r30, 0x78	; 120
    4904:	f6 4f       	sbci	r31, 0xF6	; 246
    4906:	d9 01       	movw	r26, r18
    4908:	a2 51       	subi	r26, 0x12	; 18
    490a:	b4 4f       	sbci	r27, 0xF4	; 244
    490c:	8c 91       	ld	r24, X
    490e:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4910:	2f 5f       	subi	r18, 0xFF	; 255
    4912:	3f 4f       	sbci	r19, 0xFF	; 255
    4914:	24 31       	cpi	r18, 0x14	; 20
    4916:	31 05       	cpc	r19, r1
    4918:	99 f7       	brne	.-26     	; 0x4900 <procMessage57+0xec>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    491a:	10 92 9c 09 	sts	0x099C, r1
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
		 //CompName
		 StrPosCopy(rcv_trans,strCompName,203-2,20);
		 RemSpaceLag(strCompName);
    491e:	88 e8       	ldi	r24, 0x88	; 136
    4920:	99 e0       	ldi	r25, 0x09	; 9
    4922:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		 _uart_print(0,1,strCompName);
		 
_uart_print(0,1,strCardID);
*/	
     return Result;
}
    4926:	81 2f       	mov	r24, r17
    4928:	8f 52       	subi	r24, 0x2F	; 47
    492a:	1f 91       	pop	r17
    492c:	08 95       	ret

0000492e <clearString>:
	     break;
	}
  return Result;
}

void clearString(char *str){
    492e:	20 e0       	ldi	r18, 0x00	; 0
    4930:	30 e0       	ldi	r19, 0x00	; 0
    4932:	06 c0       	rjmp	.+12     	; 0x4940 <clearString+0x12>
     int i;
	 for(i=0;i<strlen(str);i++){
	    str[i]=0;
    4934:	fc 01       	movw	r30, r24
    4936:	e2 0f       	add	r30, r18
    4938:	f3 1f       	adc	r31, r19
    493a:	10 82       	st	Z, r1
  return Result;
}

void clearString(char *str){
     int i;
	 for(i=0;i<strlen(str);i++){
    493c:	2f 5f       	subi	r18, 0xFF	; 255
    493e:	3f 4f       	sbci	r19, 0xFF	; 255
    4940:	fc 01       	movw	r30, r24
    4942:	01 90       	ld	r0, Z+
    4944:	00 20       	and	r0, r0
    4946:	e9 f7       	brne	.-6      	; 0x4942 <clearString+0x14>
    4948:	31 97       	sbiw	r30, 0x01	; 1
    494a:	e8 1b       	sub	r30, r24
    494c:	f9 0b       	sbc	r31, r25
    494e:	2e 17       	cp	r18, r30
    4950:	3f 07       	cpc	r19, r31
    4952:	80 f3       	brcs	.-32     	; 0x4934 <clearString+0x6>
	    str[i]=0;
	 }
}
    4954:	08 95       	ret

00004956 <AddZeroLead>:
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    4956:	bf 92       	push	r11
    4958:	cf 92       	push	r12
    495a:	df 92       	push	r13
    495c:	ef 92       	push	r14
    495e:	ff 92       	push	r15
    4960:	0f 93       	push	r16
    4962:	1f 93       	push	r17
    4964:	df 93       	push	r29
    4966:	cf 93       	push	r28
    4968:	cd b7       	in	r28, 0x3d	; 61
    496a:	de b7       	in	r29, 0x3e	; 62
    496c:	6e 97       	sbiw	r28, 0x1e	; 30
    496e:	0f b6       	in	r0, 0x3f	; 63
    4970:	f8 94       	cli
    4972:	de bf       	out	0x3e, r29	; 62
    4974:	0f be       	out	0x3f, r0	; 63
    4976:	cd bf       	out	0x3d, r28	; 61
    4978:	8c 01       	movw	r16, r24
     char i,Length,strAdded[30];
     Length=strlen(String);
    497a:	fc 01       	movw	r30, r24
    497c:	01 90       	ld	r0, Z+
    497e:	00 20       	and	r0, r0
    4980:	e9 f7       	brne	.-6      	; 0x497c <AddZeroLead+0x26>
    4982:	31 97       	sbiw	r30, 0x01	; 1
    4984:	2e 2f       	mov	r18, r30
    4986:	28 1b       	sub	r18, r24

	 if (Size>Length){
    4988:	26 17       	cp	r18, r22
    498a:	e0 f5       	brcc	.+120    	; 0x4a04 <AddZeroLead+0xae>
    498c:	7e 01       	movw	r14, r28
    498e:	08 94       	sec
    4990:	e1 1c       	adc	r14, r1
    4992:	f1 1c       	adc	r15, r1
    4994:	f7 01       	movw	r30, r14
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    4996:	be 2c       	mov	r11, r14
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
    4998:	90 e3       	ldi	r25, 0x30	; 48
    499a:	01 c0       	rjmp	.+2      	; 0x499e <AddZeroLead+0x48>
    499c:	91 93       	st	Z+, r25
void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    499e:	8e 2f       	mov	r24, r30
    49a0:	8b 19       	sub	r24, r11
    49a2:	86 17       	cp	r24, r22
    49a4:	d8 f3       	brcs	.-10     	; 0x499c <AddZeroLead+0x46>
	         strAdded[i]='0';
	     }strAdded[Size]=0;
    49a6:	46 2f       	mov	r20, r22
    49a8:	50 e0       	ldi	r21, 0x00	; 0
    49aa:	ce 01       	movw	r24, r28
    49ac:	01 96       	adiw	r24, 0x01	; 1
    49ae:	fc 01       	movw	r30, r24
    49b0:	e4 0f       	add	r30, r20
    49b2:	f5 1f       	adc	r31, r21
    49b4:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    49b6:	76 2f       	mov	r23, r22
    49b8:	72 1b       	sub	r23, r18
    49ba:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    49bc:	30 e0       	ldi	r19, 0x00	; 0
    49be:	24 1b       	sub	r18, r20
    49c0:	35 0b       	sbc	r19, r21
    49c2:	0c c0       	rjmp	.+24     	; 0x49dc <AddZeroLead+0x86>
    49c4:	e7 2f       	mov	r30, r23
    49c6:	f0 e0       	ldi	r31, 0x00	; 0
    49c8:	d6 01       	movw	r26, r12
    49ca:	ae 0f       	add	r26, r30
    49cc:	bf 1f       	adc	r27, r31
    49ce:	e0 0f       	add	r30, r16
    49d0:	f1 1f       	adc	r31, r17
    49d2:	e2 0f       	add	r30, r18
    49d4:	f3 1f       	adc	r31, r19
    49d6:	80 81       	ld	r24, Z
    49d8:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    49da:	7f 5f       	subi	r23, 0xFF	; 255
    49dc:	76 17       	cp	r23, r22
    49de:	90 f3       	brcs	.-28     	; 0x49c4 <AddZeroLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    49e0:	4c 0d       	add	r20, r12
    49e2:	5d 1d       	adc	r21, r13
    49e4:	da 01       	movw	r26, r20
    49e6:	1c 92       	st	X, r1
    49e8:	f8 01       	movw	r30, r16
    49ea:	04 c0       	rjmp	.+8      	; 0x49f4 <AddZeroLead+0x9e>
	     //Zeroed
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    49ec:	d7 01       	movw	r26, r14
    49ee:	8d 91       	ld	r24, X+
    49f0:	7d 01       	movw	r14, r26
    49f2:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Zeroed
         for(i=0;i<Size;i++){
    49f4:	8e 2d       	mov	r24, r14
    49f6:	8b 19       	sub	r24, r11
    49f8:	86 17       	cp	r24, r22
    49fa:	c0 f3       	brcs	.-16     	; 0x49ec <AddZeroLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    49fc:	06 0f       	add	r16, r22
    49fe:	11 1d       	adc	r17, r1
    4a00:	f8 01       	movw	r30, r16
    4a02:	10 82       	st	Z, r1
	 }
}
    4a04:	6e 96       	adiw	r28, 0x1e	; 30
    4a06:	0f b6       	in	r0, 0x3f	; 63
    4a08:	f8 94       	cli
    4a0a:	de bf       	out	0x3e, r29	; 62
    4a0c:	0f be       	out	0x3f, r0	; 63
    4a0e:	cd bf       	out	0x3d, r28	; 61
    4a10:	cf 91       	pop	r28
    4a12:	df 91       	pop	r29
    4a14:	1f 91       	pop	r17
    4a16:	0f 91       	pop	r16
    4a18:	ff 90       	pop	r15
    4a1a:	ef 90       	pop	r14
    4a1c:	df 90       	pop	r13
    4a1e:	cf 90       	pop	r12
    4a20:	bf 90       	pop	r11
    4a22:	08 95       	ret

00004a24 <GetTotalizerMoney>:
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
void GetTotalizerMoney(char iPumpID,char iGrade, char *Result){
    4a24:	0f 93       	push	r16
    4a26:	1f 93       	push	r17
    4a28:	cf 93       	push	r28
    4a2a:	df 93       	push	r29
    4a2c:	18 2f       	mov	r17, r24
    4a2e:	06 2f       	mov	r16, r22
    4a30:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,13); 
    4a32:	ca 01       	movw	r24, r20
    4a34:	6d e0       	ldi	r22, 0x0D	; 13
    4a36:	0e 94 ab 24 	call	0x4956	; 0x4956 <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4a3a:	81 2f       	mov	r24, r17
    4a3c:	0e 94 bd 1a 	call	0x357a	; 0x357a <GetFIPAddr>
    4a40:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4a42:	88 23       	and	r24, r24
    4a44:	39 f0       	breq	.+14     	; 0x4a54 <GetTotalizerMoney+0x30>
	    FIPAddr=FIPAddr-1;
	    GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4a46:	41 50       	subi	r20, 0x01	; 1
    4a48:	81 e0       	ldi	r24, 0x01	; 1
    4a4a:	61 e0       	ldi	r22, 0x01	; 1
    4a4c:	20 2f       	mov	r18, r16
    4a4e:	8e 01       	movw	r16, r28
    4a50:	0e 94 84 1b 	call	0x3708	; 0x3708 <GetTotalizerData>
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}
    4a54:	df 91       	pop	r29
    4a56:	cf 91       	pop	r28
    4a58:	1f 91       	pop	r17
    4a5a:	0f 91       	pop	r16
    4a5c:	08 95       	ret

00004a5e <GetTotalizerVolume>:
     AddZeroLead(Result,10);
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}

void GetTotalizerVolume(char iPumpID,char iGrade,char *Result){
    4a5e:	0f 93       	push	r16
    4a60:	1f 93       	push	r17
    4a62:	cf 93       	push	r28
    4a64:	df 93       	push	r29
    4a66:	18 2f       	mov	r17, r24
    4a68:	06 2f       	mov	r16, r22
    4a6a:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,11);
    4a6c:	ca 01       	movw	r24, r20
    4a6e:	6b e0       	ldi	r22, 0x0B	; 11
    4a70:	0e 94 ab 24 	call	0x4956	; 0x4956 <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4a74:	81 2f       	mov	r24, r17
    4a76:	0e 94 bd 1a 	call	0x357a	; 0x357a <GetFIPAddr>
    4a7a:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4a7c:	88 23       	and	r24, r24
    4a7e:	39 f0       	breq	.+14     	; 0x4a8e <GetTotalizerVolume+0x30>
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4a80:	41 50       	subi	r20, 0x01	; 1
    4a82:	80 e0       	ldi	r24, 0x00	; 0
    4a84:	61 e0       	ldi	r22, 0x01	; 1
    4a86:	20 2f       	mov	r18, r16
    4a88:	8e 01       	movw	r16, r28
    4a8a:	0e 94 84 1b 	call	0x3708	; 0x3708 <GetTotalizerData>
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
    4a8e:	df 91       	pop	r29
    4a90:	cf 91       	pop	r28
    4a92:	1f 91       	pop	r17
    4a94:	0f 91       	pop	r16
    4a96:	08 95       	ret

00004a98 <GetTransactionMoney>:
void GetTransactionVolume(char iPumpID,char *Result){
     AddZeroLead(Result,10);
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
void GetTransactionMoney(char iPumpID,char *Result){
    4a98:	ef 92       	push	r14
    4a9a:	ff 92       	push	r15
    4a9c:	0f 93       	push	r16
    4a9e:	1f 93       	push	r17
    4aa0:	08 2f       	mov	r16, r24
    4aa2:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    4aa4:	cb 01       	movw	r24, r22
    4aa6:	6a e0       	ldi	r22, 0x0A	; 10
    4aa8:	0e 94 ab 24 	call	0x4956	; 0x4956 <AddZeroLead>
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
    4aac:	00 d0       	rcall	.+0      	; 0x4aae <GetTransactionMoney+0x16>
    4aae:	00 d0       	rcall	.+0      	; 0x4ab0 <GetTransactionMoney+0x18>
    4ab0:	00 d0       	rcall	.+0      	; 0x4ab2 <GetTransactionMoney+0x1a>
    4ab2:	ed b7       	in	r30, 0x3d	; 61
    4ab4:	fe b7       	in	r31, 0x3e	; 62
    4ab6:	31 96       	adiw	r30, 0x01	; 1
    4ab8:	ad b7       	in	r26, 0x3d	; 61
    4aba:	be b7       	in	r27, 0x3e	; 62
    4abc:	12 96       	adiw	r26, 0x02	; 2
    4abe:	fc 92       	st	X, r15
    4ac0:	ee 92       	st	-X, r14
    4ac2:	11 97       	sbiw	r26, 0x01	; 1
    4ac4:	87 ee       	ldi	r24, 0xE7	; 231
    4ac6:	93 e0       	ldi	r25, 0x03	; 3
    4ac8:	93 83       	std	Z+3, r25	; 0x03
    4aca:	82 83       	std	Z+2, r24	; 0x02
    4acc:	10 e0       	ldi	r17, 0x00	; 0
    4ace:	0f 70       	andi	r16, 0x0F	; 15
    4ad0:	10 70       	andi	r17, 0x00	; 0
    4ad2:	85 e3       	ldi	r24, 0x35	; 53
    4ad4:	90 e0       	ldi	r25, 0x00	; 0
    4ad6:	9c 01       	movw	r18, r24
    4ad8:	02 9f       	mul	r16, r18
    4ada:	c0 01       	movw	r24, r0
    4adc:	03 9f       	mul	r16, r19
    4ade:	90 0d       	add	r25, r0
    4ae0:	12 9f       	mul	r17, r18
    4ae2:	90 0d       	add	r25, r0
    4ae4:	11 24       	eor	r1, r1
    4ae6:	8d 51       	subi	r24, 0x1D	; 29
    4ae8:	98 4f       	sbci	r25, 0xF8	; 248
    4aea:	95 83       	std	Z+5, r25	; 0x05
    4aec:	84 83       	std	Z+4, r24	; 0x04
    4aee:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    4af2:	8d b7       	in	r24, 0x3d	; 61
    4af4:	9e b7       	in	r25, 0x3e	; 62
    4af6:	06 96       	adiw	r24, 0x06	; 6
    4af8:	0f b6       	in	r0, 0x3f	; 63
    4afa:	f8 94       	cli
    4afc:	9e bf       	out	0x3e, r25	; 62
    4afe:	0f be       	out	0x3f, r0	; 63
    4b00:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}
    4b02:	1f 91       	pop	r17
    4b04:	0f 91       	pop	r16
    4b06:	ff 90       	pop	r15
    4b08:	ef 90       	pop	r14
    4b0a:	08 95       	ret

00004b0c <GetTransactionVolume>:
     }
*/
     FormatDecimal(Result,CurrentDecimal);
}

void GetTransactionVolume(char iPumpID,char *Result){
    4b0c:	ef 92       	push	r14
    4b0e:	ff 92       	push	r15
    4b10:	0f 93       	push	r16
    4b12:	1f 93       	push	r17
    4b14:	08 2f       	mov	r16, r24
    4b16:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    4b18:	cb 01       	movw	r24, r22
    4b1a:	6a e0       	ldi	r22, 0x0A	; 10
    4b1c:	0e 94 ab 24 	call	0x4956	; 0x4956 <AddZeroLead>
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
    4b20:	00 d0       	rcall	.+0      	; 0x4b22 <GetTransactionVolume+0x16>
    4b22:	00 d0       	rcall	.+0      	; 0x4b24 <GetTransactionVolume+0x18>
    4b24:	00 d0       	rcall	.+0      	; 0x4b26 <GetTransactionVolume+0x1a>
    4b26:	ed b7       	in	r30, 0x3d	; 61
    4b28:	fe b7       	in	r31, 0x3e	; 62
    4b2a:	31 96       	adiw	r30, 0x01	; 1
    4b2c:	ad b7       	in	r26, 0x3d	; 61
    4b2e:	be b7       	in	r27, 0x3e	; 62
    4b30:	12 96       	adiw	r26, 0x02	; 2
    4b32:	fc 92       	st	X, r15
    4b34:	ee 92       	st	-X, r14
    4b36:	11 97       	sbiw	r26, 0x01	; 1
    4b38:	8a ee       	ldi	r24, 0xEA	; 234
    4b3a:	93 e0       	ldi	r25, 0x03	; 3
    4b3c:	93 83       	std	Z+3, r25	; 0x03
    4b3e:	82 83       	std	Z+2, r24	; 0x02
    4b40:	10 e0       	ldi	r17, 0x00	; 0
    4b42:	0f 70       	andi	r16, 0x0F	; 15
    4b44:	10 70       	andi	r17, 0x00	; 0
    4b46:	85 e3       	ldi	r24, 0x35	; 53
    4b48:	90 e0       	ldi	r25, 0x00	; 0
    4b4a:	9c 01       	movw	r18, r24
    4b4c:	02 9f       	mul	r16, r18
    4b4e:	c0 01       	movw	r24, r0
    4b50:	03 9f       	mul	r16, r19
    4b52:	90 0d       	add	r25, r0
    4b54:	12 9f       	mul	r17, r18
    4b56:	90 0d       	add	r25, r0
    4b58:	11 24       	eor	r1, r1
    4b5a:	86 52       	subi	r24, 0x26	; 38
    4b5c:	98 4f       	sbci	r25, 0xF8	; 248
    4b5e:	95 83       	std	Z+5, r25	; 0x05
    4b60:	84 83       	std	Z+4, r24	; 0x04
    4b62:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    4b66:	8d b7       	in	r24, 0x3d	; 61
    4b68:	9e b7       	in	r25, 0x3e	; 62
    4b6a:	06 96       	adiw	r24, 0x06	; 6
    4b6c:	0f b6       	in	r0, 0x3f	; 63
    4b6e:	f8 94       	cli
    4b70:	9e bf       	out	0x3e, r25	; 62
    4b72:	0f be       	out	0x3f, r0	; 63
    4b74:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
    4b76:	1f 91       	pop	r17
    4b78:	0f 91       	pop	r16
    4b7a:	ff 90       	pop	r15
    4b7c:	ef 90       	pop	r14
    4b7e:	08 95       	ret

00004b80 <AddZeroLag>:
	         String[i]=strAdded[i];
	     }String[Size]=0;
	 }
}

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
    4b80:	cf 93       	push	r28
    4b82:	df 93       	push	r29
    4b84:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    4b86:	dc 01       	movw	r26, r24
    4b88:	0d 90       	ld	r0, X+
    4b8a:	00 20       	and	r0, r0
    4b8c:	e9 f7       	brne	.-6      	; 0x4b88 <AddZeroLag+0x8>
    4b8e:	11 97       	sbiw	r26, 0x01	; 1
    4b90:	a8 1b       	sub	r26, r24
    4b92:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    4b94:	a6 17       	cp	r26, r22
    4b96:	60 f4       	brcc	.+24     	; 0x4bb0 <AddZeroLag+0x30>
    4b98:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]='0';
    4b9a:	90 e3       	ldi	r25, 0x30	; 48
    4b9c:	fe 01       	movw	r30, r28
    4b9e:	e8 0f       	add	r30, r24
    4ba0:	f1 1d       	adc	r31, r1
    4ba2:	90 83       	st	Z, r25

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    4ba4:	8f 5f       	subi	r24, 0xFF	; 255
    4ba6:	86 17       	cp	r24, r22
    4ba8:	c8 f3       	brcs	.-14     	; 0x4b9c <AddZeroLag+0x1c>
	    String[i]='0';
	 }String[Size]=0;
    4baa:	c6 0f       	add	r28, r22
    4bac:	d1 1d       	adc	r29, r1
    4bae:	18 82       	st	Y, r1
  }
}
    4bb0:	df 91       	pop	r29
    4bb2:	cf 91       	pop	r28
    4bb4:	08 95       	ret

00004bb6 <StrCalc>:
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    4bb6:	2f 92       	push	r2
    4bb8:	3f 92       	push	r3
    4bba:	4f 92       	push	r4
    4bbc:	5f 92       	push	r5
    4bbe:	6f 92       	push	r6
    4bc0:	7f 92       	push	r7
    4bc2:	8f 92       	push	r8
    4bc4:	9f 92       	push	r9
    4bc6:	af 92       	push	r10
    4bc8:	bf 92       	push	r11
    4bca:	cf 92       	push	r12
    4bcc:	df 92       	push	r13
    4bce:	ef 92       	push	r14
    4bd0:	ff 92       	push	r15
    4bd2:	0f 93       	push	r16
    4bd4:	1f 93       	push	r17
    4bd6:	df 93       	push	r29
    4bd8:	cf 93       	push	r28
    4bda:	cd b7       	in	r28, 0x3d	; 61
    4bdc:	de b7       	in	r29, 0x3e	; 62
    4bde:	c6 55       	subi	r28, 0x56	; 86
    4be0:	d0 40       	sbci	r29, 0x00	; 0
    4be2:	0f b6       	in	r0, 0x3f	; 63
    4be4:	f8 94       	cli
    4be6:	de bf       	out	0x3e, r29	; 62
    4be8:	0f be       	out	0x3f, r0	; 63
    4bea:	cd bf       	out	0x3d, r28	; 61
    4bec:	68 2e       	mov	r6, r24
    4bee:	1b 01       	movw	r2, r22
    4bf0:	67 96       	adiw	r28, 0x17	; 23
    4bf2:	5f af       	std	Y+63, r21	; 0x3f
    4bf4:	4e af       	std	Y+62, r20	; 0x3e
    4bf6:	67 97       	sbiw	r28, 0x17	; 23
    4bf8:	59 01       	movw	r10, r18
    4bfa:	fe 01       	movw	r30, r28
    4bfc:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4bfe:	ce 01       	movw	r24, r28
    4c00:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    4c02:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4c04:	e8 17       	cp	r30, r24
    4c06:	f9 07       	cpc	r31, r25
    4c08:	e1 f7       	brne	.-8      	; 0x4c02 <StrCalc+0x4c>
	     strMemory[i]=data;
    4c0a:	ce 01       	movw	r24, r28
    4c0c:	89 96       	adiw	r24, 0x29	; 41
    4c0e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4c10:	e8 17       	cp	r30, r24
    4c12:	f9 07       	cpc	r31, r25
    4c14:	e1 f7       	brne	.-8      	; 0x4c0e <StrCalc+0x58>
    4c16:	fe 01       	movw	r30, r28
    4c18:	fd 96       	adiw	r30, 0x3d	; 61
	     strMemory[i]=data;
    4c1a:	cf 01       	movw	r24, r30
    4c1c:	44 96       	adiw	r24, 0x14	; 20
    4c1e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4c20:	e8 17       	cp	r30, r24
    4c22:	f9 07       	cpc	r31, r25
    4c24:	e1 f7       	brne	.-8      	; 0x4c1e <StrCalc+0x68>
	 FillChar(tmpB,sizeof(tmpB),0);
	 FillChar(Result,sizeof(Result),0);
                                            // -5    -5     5    5
	                                        // -6 -   6 -  -6 -  6 -
                                            // -5+6   
	 sprintf_P(tmpA,PSTR("%s"),strA);       // 
    4c26:	00 d0       	rcall	.+0      	; 0x4c28 <StrCalc+0x72>
    4c28:	00 d0       	rcall	.+0      	; 0x4c2a <StrCalc+0x74>
    4c2a:	00 d0       	rcall	.+0      	; 0x4c2c <StrCalc+0x76>
    4c2c:	ed b7       	in	r30, 0x3d	; 61
    4c2e:	fe b7       	in	r31, 0x3e	; 62
    4c30:	31 96       	adiw	r30, 0x01	; 1
    4c32:	8e 01       	movw	r16, r28
    4c34:	0f 5f       	subi	r16, 0xFF	; 255
    4c36:	1f 4f       	sbci	r17, 0xFF	; 255
    4c38:	ad b7       	in	r26, 0x3d	; 61
    4c3a:	be b7       	in	r27, 0x3e	; 62
    4c3c:	12 96       	adiw	r26, 0x02	; 2
    4c3e:	1c 93       	st	X, r17
    4c40:	0e 93       	st	-X, r16
    4c42:	11 97       	sbiw	r26, 0x01	; 1
    4c44:	85 e3       	ldi	r24, 0x35	; 53
    4c46:	96 e0       	ldi	r25, 0x06	; 6
    4c48:	93 83       	std	Z+3, r25	; 0x03
    4c4a:	82 83       	std	Z+2, r24	; 0x02
    4c4c:	35 82       	std	Z+5, r3	; 0x05
    4c4e:	24 82       	std	Z+4, r2	; 0x04
    4c50:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 sprintf_P(tmpB,PSTR("%s"),strB);  
    4c54:	ed b7       	in	r30, 0x3d	; 61
    4c56:	fe b7       	in	r31, 0x3e	; 62
    4c58:	31 96       	adiw	r30, 0x01	; 1
    4c5a:	ce 01       	movw	r24, r28
    4c5c:	45 96       	adiw	r24, 0x15	; 21
    4c5e:	ad b7       	in	r26, 0x3d	; 61
    4c60:	be b7       	in	r27, 0x3e	; 62
    4c62:	12 96       	adiw	r26, 0x02	; 2
    4c64:	9c 93       	st	X, r25
    4c66:	8e 93       	st	-X, r24
    4c68:	11 97       	sbiw	r26, 0x01	; 1
    4c6a:	82 e3       	ldi	r24, 0x32	; 50
    4c6c:	96 e0       	ldi	r25, 0x06	; 6
    4c6e:	93 83       	std	Z+3, r25	; 0x03
    4c70:	82 83       	std	Z+2, r24	; 0x02
    4c72:	67 96       	adiw	r28, 0x17	; 23
    4c74:	2e ad       	ldd	r18, Y+62	; 0x3e
    4c76:	3f ad       	ldd	r19, Y+63	; 0x3f
    4c78:	67 97       	sbiw	r28, 0x17	; 23
    4c7a:	35 83       	std	Z+5, r19	; 0x05
    4c7c:	24 83       	std	Z+4, r18	; 0x04
    4c7e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>

     if (IsMinus(tmpA)==True){
    4c82:	8d b7       	in	r24, 0x3d	; 61
    4c84:	9e b7       	in	r25, 0x3e	; 62
    4c86:	06 96       	adiw	r24, 0x06	; 6
    4c88:	0f b6       	in	r0, 0x3f	; 63
    4c8a:	f8 94       	cli
    4c8c:	9e bf       	out	0x3e, r25	; 62
    4c8e:	0f be       	out	0x3f, r0	; 63
    4c90:	8d bf       	out	0x3d, r24	; 61
    4c92:	c8 01       	movw	r24, r16
    4c94:	0e 94 9e 20 	call	0x413c	; 0x413c <IsMinus>
    4c98:	81 30       	cpi	r24, 0x01	; 1
    4c9a:	21 f0       	breq	.+8      	; 0x4ca4 <StrCalc+0xee>
    4c9c:	65 96       	adiw	r28, 0x15	; 21
    4c9e:	1f ae       	std	Y+63, r1	; 0x3f
    4ca0:	65 97       	sbiw	r28, 0x15	; 21
    4ca2:	07 c0       	rjmp	.+14     	; 0x4cb2 <StrCalc+0xfc>
	     RemoveMinus(tmpA);
    4ca4:	c8 01       	movw	r24, r16
    4ca6:	0e 94 a3 20 	call	0x4146	; 0x4146 <RemoveMinus>
    4caa:	91 e0       	ldi	r25, 0x01	; 1
    4cac:	65 96       	adiw	r28, 0x15	; 21
    4cae:	9f af       	std	Y+63, r25	; 0x3f
    4cb0:	65 97       	sbiw	r28, 0x15	; 21
		 IsMinA=True;
	 }
     if (IsMinus(tmpB)==True){
    4cb2:	8e 01       	movw	r16, r28
    4cb4:	0b 5e       	subi	r16, 0xEB	; 235
    4cb6:	1f 4f       	sbci	r17, 0xFF	; 255
    4cb8:	c8 01       	movw	r24, r16
    4cba:	0e 94 9e 20 	call	0x413c	; 0x413c <IsMinus>
    4cbe:	81 30       	cpi	r24, 0x01	; 1
    4cc0:	21 f0       	breq	.+8      	; 0x4cca <StrCalc+0x114>
    4cc2:	64 96       	adiw	r28, 0x14	; 20
    4cc4:	1f ae       	std	Y+63, r1	; 0x3f
    4cc6:	64 97       	sbiw	r28, 0x14	; 20
    4cc8:	07 c0       	rjmp	.+14     	; 0x4cd8 <StrCalc+0x122>
	     RemoveMinus(tmpB);
    4cca:	c8 01       	movw	r24, r16
    4ccc:	0e 94 a3 20 	call	0x4146	; 0x4146 <RemoveMinus>
    4cd0:	a1 e0       	ldi	r26, 0x01	; 1
    4cd2:	64 96       	adiw	r28, 0x14	; 20
    4cd4:	af af       	std	Y+63, r26	; 0x3f
    4cd6:	64 97       	sbiw	r28, 0x14	; 20
		 IsMinB=True;
	 }    	

     lenA=strlen(tmpA);
    4cd8:	fe 01       	movw	r30, r28
    4cda:	31 96       	adiw	r30, 0x01	; 1
    4cdc:	df 01       	movw	r26, r30
    4cde:	0d 90       	ld	r0, X+
    4ce0:	00 20       	and	r0, r0
    4ce2:	e9 f7       	brne	.-6      	; 0x4cde <StrCalc+0x128>
    4ce4:	cd 01       	movw	r24, r26
    4ce6:	01 97       	sbiw	r24, 0x01	; 1
    4ce8:	8e 1b       	sub	r24, r30
    4cea:	9f 0b       	sbc	r25, r31
     lenB=strlen(tmpB);
    4cec:	de 01       	movw	r26, r28
    4cee:	55 96       	adiw	r26, 0x15	; 21
    4cf0:	fd 01       	movw	r30, r26
    4cf2:	01 90       	ld	r0, Z+
    4cf4:	00 20       	and	r0, r0
    4cf6:	e9 f7       	brne	.-6      	; 0x4cf2 <StrCalc+0x13c>
    4cf8:	31 97       	sbiw	r30, 0x01	; 1
     /*
	 sprintf_P(strSend,PSTR("A:%s"),strA);	 _uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);	 _uart_print(0,1,strSend);
     */

     AddZeroLead(tmpA,FixLen+1);
    4cfa:	1e 2f       	mov	r17, r30
    4cfc:	1a 1b       	sub	r17, r26
    4cfe:	18 17       	cp	r17, r24
    4d00:	08 f4       	brcc	.+2      	; 0x4d04 <StrCalc+0x14e>
    4d02:	18 2f       	mov	r17, r24
    4d04:	1f 5f       	subi	r17, 0xFF	; 255
    4d06:	7e 01       	movw	r14, r28
    4d08:	08 94       	sec
    4d0a:	e1 1c       	adc	r14, r1
    4d0c:	f1 1c       	adc	r15, r1
    4d0e:	c7 01       	movw	r24, r14
    4d10:	61 2f       	mov	r22, r17
    4d12:	0e 94 ab 24 	call	0x4956	; 0x4956 <AddZeroLead>
     AddZeroLead(tmpB,FixLen+1);
    4d16:	f5 e1       	ldi	r31, 0x15	; 21
    4d18:	cf 2e       	mov	r12, r31
    4d1a:	d1 2c       	mov	r13, r1
    4d1c:	cc 0e       	add	r12, r28
    4d1e:	dd 1e       	adc	r13, r29
    4d20:	c6 01       	movw	r24, r12
    4d22:	61 2f       	mov	r22, r17
    4d24:	0e 94 ab 24 	call	0x4956	; 0x4956 <AddZeroLead>
	 _uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);
	 _uart_print(0,1,strSend);
	 */

     lenA=strlen(tmpA);
    4d28:	f7 01       	movw	r30, r14
    4d2a:	01 90       	ld	r0, Z+
    4d2c:	00 20       	and	r0, r0
    4d2e:	e9 f7       	brne	.-6      	; 0x4d2a <StrCalc+0x174>
    4d30:	31 97       	sbiw	r30, 0x01	; 1
    4d32:	7e 2e       	mov	r7, r30
    4d34:	7e 18       	sub	r7, r14
     lenB=strlen(tmpB);
    4d36:	f6 01       	movw	r30, r12
    4d38:	01 90       	ld	r0, Z+
    4d3a:	00 20       	and	r0, r0
    4d3c:	e9 f7       	brne	.-6      	; 0x4d38 <StrCalc+0x182>
    4d3e:	31 97       	sbiw	r30, 0x01	; 1
    4d40:	9e 2e       	mov	r9, r30
    4d42:	9c 18       	sub	r9, r12
     IsNegative=False;
	 
	 IsNegative=False;
	 IsSwap=False;

	 if (IsMoreThan(tmpB,tmpA)==True){
    4d44:	c6 01       	movw	r24, r12
    4d46:	b7 01       	movw	r22, r14
    4d48:	0e 94 d0 20 	call	0x41a0	; 0x41a0 <IsMoreThan>
    4d4c:	81 30       	cpi	r24, 0x01	; 1
    4d4e:	11 f0       	breq	.+4      	; 0x4d54 <StrCalc+0x19e>
    4d50:	80 e0       	ldi	r24, 0x00	; 0
    4d52:	42 c0       	rjmp	.+132    	; 0x4dd8 <StrCalc+0x222>
	     IsSwap=True;
         sprintf_P(tmpC,PSTR("%s"),tmpA);
    4d54:	00 d0       	rcall	.+0      	; 0x4d56 <StrCalc+0x1a0>
    4d56:	00 d0       	rcall	.+0      	; 0x4d58 <StrCalc+0x1a2>
    4d58:	00 d0       	rcall	.+0      	; 0x4d5a <StrCalc+0x1a4>
    4d5a:	ed b7       	in	r30, 0x3d	; 61
    4d5c:	fe b7       	in	r31, 0x3e	; 62
    4d5e:	31 96       	adiw	r30, 0x01	; 1
    4d60:	8e 01       	movw	r16, r28
    4d62:	07 5d       	subi	r16, 0xD7	; 215
    4d64:	1f 4f       	sbci	r17, 0xFF	; 255
    4d66:	ad b7       	in	r26, 0x3d	; 61
    4d68:	be b7       	in	r27, 0x3e	; 62
    4d6a:	12 96       	adiw	r26, 0x02	; 2
    4d6c:	1c 93       	st	X, r17
    4d6e:	0e 93       	st	-X, r16
    4d70:	11 97       	sbiw	r26, 0x01	; 1
    4d72:	8f e2       	ldi	r24, 0x2F	; 47
    4d74:	96 e0       	ldi	r25, 0x06	; 6
    4d76:	93 83       	std	Z+3, r25	; 0x03
    4d78:	82 83       	std	Z+2, r24	; 0x02
    4d7a:	f5 82       	std	Z+5, r15	; 0x05
    4d7c:	e4 82       	std	Z+4, r14	; 0x04
    4d7e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		 sprintf_P(tmpA,PSTR("%s"),tmpB);
    4d82:	ed b7       	in	r30, 0x3d	; 61
    4d84:	fe b7       	in	r31, 0x3e	; 62
    4d86:	31 96       	adiw	r30, 0x01	; 1
    4d88:	ad b7       	in	r26, 0x3d	; 61
    4d8a:	be b7       	in	r27, 0x3e	; 62
    4d8c:	12 96       	adiw	r26, 0x02	; 2
    4d8e:	fc 92       	st	X, r15
    4d90:	ee 92       	st	-X, r14
    4d92:	11 97       	sbiw	r26, 0x01	; 1
    4d94:	8c e2       	ldi	r24, 0x2C	; 44
    4d96:	96 e0       	ldi	r25, 0x06	; 6
    4d98:	93 83       	std	Z+3, r25	; 0x03
    4d9a:	82 83       	std	Z+2, r24	; 0x02
    4d9c:	d5 82       	std	Z+5, r13	; 0x05
    4d9e:	c4 82       	std	Z+4, r12	; 0x04
    4da0:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		 sprintf_P(tmpB,PSTR("%s"),tmpC);
    4da4:	ed b7       	in	r30, 0x3d	; 61
    4da6:	fe b7       	in	r31, 0x3e	; 62
    4da8:	31 96       	adiw	r30, 0x01	; 1
    4daa:	ad b7       	in	r26, 0x3d	; 61
    4dac:	be b7       	in	r27, 0x3e	; 62
    4dae:	12 96       	adiw	r26, 0x02	; 2
    4db0:	dc 92       	st	X, r13
    4db2:	ce 92       	st	-X, r12
    4db4:	11 97       	sbiw	r26, 0x01	; 1
    4db6:	89 e2       	ldi	r24, 0x29	; 41
    4db8:	96 e0       	ldi	r25, 0x06	; 6
    4dba:	93 83       	std	Z+3, r25	; 0x03
    4dbc:	82 83       	std	Z+2, r24	; 0x02
    4dbe:	15 83       	std	Z+5, r17	; 0x05
    4dc0:	04 83       	std	Z+4, r16	; 0x04
    4dc2:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    4dc6:	81 e0       	ldi	r24, 0x01	; 1
    4dc8:	ed b7       	in	r30, 0x3d	; 61
    4dca:	fe b7       	in	r31, 0x3e	; 62
    4dcc:	36 96       	adiw	r30, 0x06	; 6
    4dce:	0f b6       	in	r0, 0x3f	; 63
    4dd0:	f8 94       	cli
    4dd2:	fe bf       	out	0x3e, r31	; 62
    4dd4:	0f be       	out	0x3f, r0	; 63
    4dd6:	ed bf       	out	0x3d, r30	; 61
	 }
    
	if (TOperation==TMINUS){
    4dd8:	66 20       	and	r6, r6
    4dda:	39 f5       	brne	.+78     	; 0x4e2a <StrCalc+0x274>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    4ddc:	81 30       	cpi	r24, 0x01	; 1
    4dde:	99 f4       	brne	.+38     	; 0x4e06 <StrCalc+0x250>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    4de0:	65 96       	adiw	r28, 0x15	; 21
    4de2:	ff ad       	ldd	r31, Y+63	; 0x3f
    4de4:	65 97       	sbiw	r28, 0x15	; 21
    4de6:	f1 30       	cpi	r31, 0x01	; 1
    4de8:	39 f4       	brne	.+14     	; 0x4df8 <StrCalc+0x242>
    4dea:	64 96       	adiw	r28, 0x14	; 20
    4dec:	2f ad       	ldd	r18, Y+63	; 0x3f
    4dee:	64 97       	sbiw	r28, 0x14	; 20
    4df0:	21 30       	cpi	r18, 0x01	; 1
    4df2:	09 f0       	breq	.+2      	; 0x4df6 <StrCalc+0x240>
    4df4:	90 c1       	rjmp	.+800    	; 0x5116 <StrCalc+0x560>
    4df6:	42 c0       	rjmp	.+132    	; 0x4e7c <StrCalc+0x2c6>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    4df8:	64 96       	adiw	r28, 0x14	; 20
    4dfa:	3f ad       	ldd	r19, Y+63	; 0x3f
    4dfc:	64 97       	sbiw	r28, 0x14	; 20
    4dfe:	31 30       	cpi	r19, 0x01	; 1
    4e00:	09 f0       	breq	.+2      	; 0x4e04 <StrCalc+0x24e>
    4e02:	80 c1       	rjmp	.+768    	; 0x5104 <StrCalc+0x54e>
    4e04:	84 c1       	rjmp	.+776    	; 0x510e <StrCalc+0x558>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    4e06:	65 96       	adiw	r28, 0x15	; 21
    4e08:	8f ad       	ldd	r24, Y+63	; 0x3f
    4e0a:	65 97       	sbiw	r28, 0x15	; 21
    4e0c:	81 30       	cpi	r24, 0x01	; 1
    4e0e:	39 f4       	brne	.+14     	; 0x4e1e <StrCalc+0x268>
    4e10:	64 96       	adiw	r28, 0x14	; 20
    4e12:	9f ad       	ldd	r25, Y+63	; 0x3f
    4e14:	64 97       	sbiw	r28, 0x14	; 20
    4e16:	91 30       	cpi	r25, 0x01	; 1
    4e18:	09 f0       	breq	.+2      	; 0x4e1c <StrCalc+0x266>
    4e1a:	7d c1       	rjmp	.+762    	; 0x5116 <StrCalc+0x560>
    4e1c:	73 c1       	rjmp	.+742    	; 0x5104 <StrCalc+0x54e>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    4e1e:	64 96       	adiw	r28, 0x14	; 20
    4e20:	af ad       	ldd	r26, Y+63	; 0x3f
    4e22:	64 97       	sbiw	r28, 0x14	; 20
    4e24:	a1 30       	cpi	r26, 0x01	; 1
    4e26:	51 f5       	brne	.+84     	; 0x4e7c <StrCalc+0x2c6>
    4e28:	72 c1       	rjmp	.+740    	; 0x510e <StrCalc+0x558>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
		}
	 }else
	if (TOperation==TPLUS){
    4e2a:	b1 e0       	ldi	r27, 0x01	; 1
    4e2c:	6b 16       	cp	r6, r27
    4e2e:	31 f5       	brne	.+76     	; 0x4e7c <StrCalc+0x2c6>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    4e30:	81 30       	cpi	r24, 0x01	; 1
    4e32:	91 f4       	brne	.+36     	; 0x4e58 <StrCalc+0x2a2>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    4e34:	65 96       	adiw	r28, 0x15	; 21
    4e36:	ef ad       	ldd	r30, Y+63	; 0x3f
    4e38:	65 97       	sbiw	r28, 0x15	; 21
    4e3a:	e1 30       	cpi	r30, 0x01	; 1
    4e3c:	31 f4       	brne	.+12     	; 0x4e4a <StrCalc+0x294>
    4e3e:	64 96       	adiw	r28, 0x14	; 20
    4e40:	ff ad       	ldd	r31, Y+63	; 0x3f
    4e42:	64 97       	sbiw	r28, 0x14	; 20
    4e44:	f1 30       	cpi	r31, 0x01	; 1
    4e46:	d1 f4       	brne	.+52     	; 0x4e7c <StrCalc+0x2c6>
    4e48:	66 c1       	rjmp	.+716    	; 0x5116 <StrCalc+0x560>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    4e4a:	64 96       	adiw	r28, 0x14	; 20
    4e4c:	2f ad       	ldd	r18, Y+63	; 0x3f
    4e4e:	64 97       	sbiw	r28, 0x14	; 20
    4e50:	21 30       	cpi	r18, 0x01	; 1
    4e52:	09 f0       	breq	.+2      	; 0x4e56 <StrCalc+0x2a0>
    4e54:	5c c1       	rjmp	.+696    	; 0x510e <StrCalc+0x558>
    4e56:	56 c1       	rjmp	.+684    	; 0x5104 <StrCalc+0x54e>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TPLUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    4e58:	65 96       	adiw	r28, 0x15	; 21
    4e5a:	3f ad       	ldd	r19, Y+63	; 0x3f
    4e5c:	65 97       	sbiw	r28, 0x15	; 21
    4e5e:	31 30       	cpi	r19, 0x01	; 1
    4e60:	39 f4       	brne	.+14     	; 0x4e70 <StrCalc+0x2ba>
    4e62:	64 96       	adiw	r28, 0x14	; 20
    4e64:	8f ad       	ldd	r24, Y+63	; 0x3f
    4e66:	64 97       	sbiw	r28, 0x14	; 20
    4e68:	81 30       	cpi	r24, 0x01	; 1
    4e6a:	09 f0       	breq	.+2      	; 0x4e6e <StrCalc+0x2b8>
    4e6c:	4b c1       	rjmp	.+662    	; 0x5104 <StrCalc+0x54e>
    4e6e:	53 c1       	rjmp	.+678    	; 0x5116 <StrCalc+0x560>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    4e70:	64 96       	adiw	r28, 0x14	; 20
    4e72:	9f ad       	ldd	r25, Y+63	; 0x3f
    4e74:	64 97       	sbiw	r28, 0x14	; 20
    4e76:	91 30       	cpi	r25, 0x01	; 1
    4e78:	09 f0       	breq	.+2      	; 0x4e7c <StrCalc+0x2c6>
    4e7a:	49 c1       	rjmp	.+658    	; 0x510e <StrCalc+0x558>
   // A: 100000
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
    4e7c:	62 96       	adiw	r28, 0x12	; 18
    4e7e:	1f ae       	std	Y+63, r1	; 0x3f
    4e80:	62 97       	sbiw	r28, 0x12	; 18
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    4e82:	e7 2c       	mov	r14, r7
    4e84:	ff 24       	eor	r15, r15
    4e86:	67 01       	movw	r12, r14
    4e88:	08 94       	sec
    4e8a:	c1 08       	sbc	r12, r1
    4e8c:	d1 08       	sbc	r13, r1
    4e8e:	ae 01       	movw	r20, r28
    4e90:	43 5c       	subi	r20, 0xC3	; 195
    4e92:	5f 4f       	sbci	r21, 0xFF	; 255
    4e94:	4c 0d       	add	r20, r12
    4e96:	5d 1d       	adc	r21, r13
    4e98:	ce 01       	movw	r24, r28
    4e9a:	01 96       	adiw	r24, 0x01	; 1
    4e9c:	8c 01       	movw	r16, r24
    4e9e:	0c 0d       	add	r16, r12
    4ea0:	1d 1d       	adc	r17, r13
    4ea2:	be 01       	movw	r22, r28
    4ea4:	69 0d       	add	r22, r9
    4ea6:	71 1d       	adc	r23, r1
    4ea8:	6c 5e       	subi	r22, 0xEC	; 236
    4eaa:	7f 4f       	sbci	r23, 0xFF	; 255
    4eac:	99 24       	eor	r9, r9
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    4eae:	2c 01       	movw	r4, r24
    4eb0:	e9 e3       	ldi	r30, 0x39	; 57
    4eb2:	8e 2e       	mov	r8, r30
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    4eb4:	9a e0       	ldi	r25, 0x0A	; 10
    4eb6:	52 c0       	rjmp	.+164    	; 0x4f5c <StrCalc+0x3a6>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4eb8:	d8 01       	movw	r26, r16
    4eba:	8c 91       	ld	r24, X
    4ebc:	80 53       	subi	r24, 0x30	; 48
    4ebe:	8a 30       	cpi	r24, 0x0A	; 10
    4ec0:	10 f0       	brcs	.+4      	; 0x4ec6 <StrCalc+0x310>
    4ec2:	20 e0       	ldi	r18, 0x00	; 0
    4ec4:	01 c0       	rjmp	.+2      	; 0x4ec8 <StrCalc+0x312>
    4ec6:	28 2f       	mov	r18, r24
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
    4ec8:	fb 01       	movw	r30, r22
    4eca:	30 81       	ld	r19, Z
    4ecc:	30 53       	subi	r19, 0x30	; 48
    4ece:	3a 30       	cpi	r19, 0x0A	; 10
    4ed0:	10 f4       	brcc	.+4      	; 0x4ed6 <StrCalc+0x320>
    4ed2:	23 17       	cp	r18, r19
    4ed4:	40 f0       	brcs	.+16     	; 0x4ee6 <StrCalc+0x330>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4ed6:	8a 30       	cpi	r24, 0x0A	; 10
    4ed8:	08 f0       	brcs	.+2      	; 0x4edc <StrCalc+0x326>
    4eda:	80 e0       	ldi	r24, 0x00	; 0

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    4edc:	3a 30       	cpi	r19, 0x0A	; 10
    4ede:	08 f0       	brcs	.+2      	; 0x4ee2 <StrCalc+0x32c>
    4ee0:	30 e0       	ldi	r19, 0x00	; 0
    4ee2:	83 1b       	sub	r24, r19
    4ee4:	2d c0       	rjmp	.+90     	; 0x4f40 <StrCalc+0x38a>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4ee6:	8a 30       	cpi	r24, 0x0A	; 10
    4ee8:	10 f4       	brcc	.+4      	; 0x4eee <StrCalc+0x338>
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
    4eea:	83 17       	cp	r24, r19
    4eec:	80 f5       	brcc	.+96     	; 0x4f4e <StrCalc+0x398>
    4eee:	29 2d       	mov	r18, r9
    4ef0:	0a c0       	rjmp	.+20     	; 0x4f06 <StrCalc+0x350>
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    4ef2:	f6 01       	movw	r30, r12
    4ef4:	e2 1b       	sub	r30, r18
    4ef6:	f1 09       	sbc	r31, r1
    4ef8:	d2 01       	movw	r26, r4
    4efa:	ae 0f       	add	r26, r30
    4efc:	bf 1f       	adc	r27, r31
    4efe:	8c 91       	ld	r24, X
    4f00:	80 33       	cpi	r24, 0x30	; 48
    4f02:	29 f4       	brne	.+10     	; 0x4f0e <StrCalc+0x358>
    4f04:	8c 92       	st	X, r8
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
    4f06:	2f 5f       	subi	r18, 0xFF	; 255
    4f08:	27 15       	cp	r18, r7
    4f0a:	98 f3       	brcs	.-26     	; 0x4ef2 <StrCalc+0x33c>
    4f0c:	10 c0       	rjmp	.+32     	; 0x4f2e <StrCalc+0x378>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4f0e:	28 2f       	mov	r18, r24
    4f10:	20 53       	subi	r18, 0x30	; 48
    4f12:	2a 30       	cpi	r18, 0x0A	; 10
    4f14:	08 f0       	brcs	.+2      	; 0x4f18 <StrCalc+0x362>
    4f16:	20 e0       	ldi	r18, 0x00	; 0
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    4f18:	82 2f       	mov	r24, r18
    4f1a:	81 50       	subi	r24, 0x01	; 1
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4f1c:	8a 30       	cpi	r24, 0x0A	; 10
    4f1e:	10 f0       	brcs	.+4      	; 0x4f24 <StrCalc+0x36e>
    4f20:	80 e3       	ldi	r24, 0x30	; 48
    4f22:	02 c0       	rjmp	.+4      	; 0x4f28 <StrCalc+0x372>
	    Result='0'+X;
    4f24:	82 2f       	mov	r24, r18
    4f26:	81 5d       	subi	r24, 0xD1	; 209
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    4f28:	e4 0d       	add	r30, r4
    4f2a:	f5 1d       	adc	r31, r5
    4f2c:	80 83       	st	Z, r24
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4f2e:	f8 01       	movw	r30, r16
    4f30:	20 81       	ld	r18, Z
    4f32:	20 53       	subi	r18, 0x30	; 48
    4f34:	2a 30       	cpi	r18, 0x0A	; 10
    4f36:	08 f0       	brcs	.+2      	; 0x4f3a <StrCalc+0x384>
    4f38:	20 e0       	ldi	r18, 0x00	; 0
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    4f3a:	89 2f       	mov	r24, r25
    4f3c:	83 1b       	sub	r24, r19
    4f3e:	82 0f       	add	r24, r18
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4f40:	8a 30       	cpi	r24, 0x0A	; 10
    4f42:	10 f0       	brcs	.+4      	; 0x4f48 <StrCalc+0x392>
    4f44:	80 e3       	ldi	r24, 0x30	; 48
    4f46:	01 c0       	rjmp	.+2      	; 0x4f4a <StrCalc+0x394>
	    Result='0'+X;
    4f48:	80 5d       	subi	r24, 0xD0	; 208
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    4f4a:	da 01       	movw	r26, r20
    4f4c:	8c 93       	st	X, r24
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
    4f4e:	93 94       	inc	r9
    4f50:	41 50       	subi	r20, 0x01	; 1
    4f52:	50 40       	sbci	r21, 0x00	; 0
    4f54:	01 50       	subi	r16, 0x01	; 1
    4f56:	10 40       	sbci	r17, 0x00	; 0
    4f58:	61 50       	subi	r22, 0x01	; 1
    4f5a:	70 40       	sbci	r23, 0x00	; 0
    4f5c:	97 14       	cp	r9, r7
    4f5e:	08 f4       	brcc	.+2      	; 0x4f62 <StrCalc+0x3ac>
    4f60:	ab cf       	rjmp	.-170    	; 0x4eb8 <StrCalc+0x302>
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }
		 }Result[lenA]=0;		    
    4f62:	8e 01       	movw	r16, r28
    4f64:	03 5c       	subi	r16, 0xC3	; 195
    4f66:	1f 4f       	sbci	r17, 0xFF	; 255
    4f68:	e0 0e       	add	r14, r16
    4f6a:	f1 1e       	adc	r15, r17
    4f6c:	f7 01       	movw	r30, r14
    4f6e:	10 82       	st	Z, r1
       RemZeroLead(Result);
    4f70:	c8 01       	movw	r24, r16
    4f72:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
    4f76:	f8 01       	movw	r30, r16
    4f78:	01 90       	ld	r0, Z+
    4f7a:	00 20       	and	r0, r0
    4f7c:	e9 f7       	brne	.-6      	; 0x4f78 <StrCalc+0x3c2>
    4f7e:	31 97       	sbiw	r30, 0x01	; 1
    4f80:	3e 2f       	mov	r19, r30
    4f82:	30 1b       	sub	r19, r16
    4f84:	d8 01       	movw	r26, r16
    4f86:	20 e0       	ldi	r18, 0x00	; 0
    4f88:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    4f8a:	4d e2       	ldi	r20, 0x2D	; 45
    4f8c:	13 c0       	rjmp	.+38     	; 0x4fb4 <StrCalc+0x3fe>
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    4f8e:	22 23       	and	r18, r18
    4f90:	51 f4       	brne	.+20     	; 0x4fa6 <StrCalc+0x3f0>
    4f92:	62 96       	adiw	r28, 0x12	; 18
    4f94:	ff ad       	ldd	r31, Y+63	; 0x3f
    4f96:	62 97       	sbiw	r28, 0x12	; 18
    4f98:	f1 30       	cpi	r31, 0x01	; 1
    4f9a:	29 f4       	brne	.+10     	; 0x4fa6 <StrCalc+0x3f0>
			     strC[iPos]='-';
    4f9c:	f5 01       	movw	r30, r10
    4f9e:	e9 0f       	add	r30, r25
    4fa0:	f1 1d       	adc	r31, r1
    4fa2:	40 83       	st	Z, r20
				 iPos++;
    4fa4:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[i];
    4fa6:	f5 01       	movw	r30, r10
    4fa8:	e9 0f       	add	r30, r25
    4faa:	f1 1d       	adc	r31, r1
    4fac:	8d 91       	ld	r24, X+
    4fae:	80 83       	st	Z, r24
			 iPos++;
    4fb0:	9f 5f       	subi	r25, 0xFF	; 255
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    4fb2:	2f 5f       	subi	r18, 0xFF	; 255
    4fb4:	23 17       	cp	r18, r19
    4fb6:	58 f3       	brcs	.-42     	; 0x4f8e <StrCalc+0x3d8>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[i];
			 iPos++;
		 }strC[iPos]=0;
    4fb8:	f5 01       	movw	r30, r10
    4fba:	e9 0f       	add	r30, r25
    4fbc:	f1 1d       	adc	r31, r1
    4fbe:	10 82       	st	Z, r1
    4fc0:	95 c0       	rjmp	.+298    	; 0x50ec <StrCalc+0x536>
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
    4fc2:	8e 01       	movw	r16, r28
    4fc4:	03 5c       	subi	r16, 0xC3	; 195
    4fc6:	1f 4f       	sbci	r17, 0xFF	; 255
    4fc8:	9e 01       	movw	r18, r28
    4fca:	29 0d       	add	r18, r9
    4fcc:	31 1d       	adc	r19, r1
    4fce:	2c 5e       	subi	r18, 0xEC	; 236
    4fd0:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    4fd2:	47 2d       	mov	r20, r7
    4fd4:	50 e0       	ldi	r21, 0x00	; 0
    4fd6:	4a 01       	movw	r8, r20
    4fd8:	08 94       	sec
    4fda:	81 08       	sbc	r8, r1
    4fdc:	91 08       	sbc	r9, r1
    4fde:	ce 01       	movw	r24, r28
    4fe0:	01 96       	adiw	r24, 0x01	; 1
    4fe2:	7c 01       	movw	r14, r24
    4fe4:	e8 0c       	add	r14, r8
    4fe6:	f9 1c       	adc	r15, r9
    4fe8:	dd 24       	eor	r13, r13
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4fea:	2c 01       	movw	r4, r24
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    4fec:	70 e3       	ldi	r23, 0x30	; 48
    4fee:	c7 2e       	mov	r12, r23
    4ff0:	43 c0       	rjmp	.+134    	; 0x5078 <StrCalc+0x4c2>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4ff2:	d7 01       	movw	r26, r14
    4ff4:	9c 91       	ld	r25, X
    4ff6:	90 53       	subi	r25, 0x30	; 48
    4ff8:	9a 30       	cpi	r25, 0x0A	; 10
    4ffa:	08 f0       	brcs	.+2      	; 0x4ffe <StrCalc+0x448>
    4ffc:	90 e0       	ldi	r25, 0x00	; 0
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
		     newC=(Ord(tmpA[lenA-i-1])+Ord(tmpB[lenB-i-1]));			 
    4ffe:	f9 01       	movw	r30, r18
    5000:	80 81       	ld	r24, Z
    5002:	80 53       	subi	r24, 0x30	; 48
    5004:	8a 30       	cpi	r24, 0x0A	; 10
    5006:	08 f0       	brcs	.+2      	; 0x500a <StrCalc+0x454>
    5008:	80 e0       	ldi	r24, 0x00	; 0
    500a:	89 0f       	add	r24, r25
			 if (newC<10){
    500c:	8a 30       	cpi	r24, 0x0A	; 10
    500e:	18 f4       	brcc	.+6      	; 0x5016 <StrCalc+0x460>
			     Result[i]=Chr(newC);
    5010:	80 5d       	subi	r24, 0xD0	; 208
    5012:	d8 01       	movw	r26, r16
    5014:	28 c0       	rjmp	.+80     	; 0x5066 <StrCalc+0x4b0>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5016:	6a e0       	ldi	r22, 0x0A	; 10
    5018:	0e 94 a3 b7 	call	0x16f46	; 0x16f46 <__udivmodqi4>
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    501c:	9a 30       	cpi	r25, 0x0A	; 10
    501e:	10 f0       	brcs	.+4      	; 0x5024 <StrCalc+0x46e>
    5020:	90 e3       	ldi	r25, 0x30	; 48
    5022:	01 c0       	rjmp	.+2      	; 0x5026 <StrCalc+0x470>
	    Result='0'+X;
    5024:	90 5d       	subi	r25, 0xD0	; 208
			 if (newC<10){
			     Result[i]=Chr(newC);
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5026:	f8 01       	movw	r30, r16
    5028:	90 83       	st	Z, r25
    502a:	8d 2d       	mov	r24, r13
    502c:	0e c0       	rjmp	.+28     	; 0x504a <StrCalc+0x494>
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    502e:	d4 01       	movw	r26, r8
    5030:	a8 1b       	sub	r26, r24
    5032:	b1 09       	sbc	r27, r1
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5034:	f2 01       	movw	r30, r4
    5036:	ea 0f       	add	r30, r26
    5038:	fb 1f       	adc	r31, r27
    503a:	90 81       	ld	r25, Z
    503c:	90 53       	subi	r25, 0x30	; 48
    503e:	9a 30       	cpi	r25, 0x0A	; 10
    5040:	08 f0       	brcs	.+2      	; 0x5044 <StrCalc+0x48e>
    5042:	6e c0       	rjmp	.+220    	; 0x5120 <StrCalc+0x56a>
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    5044:	99 30       	cpi	r25, 0x09	; 9
    5046:	29 f4       	brne	.+10     	; 0x5052 <StrCalc+0x49c>
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    5048:	c0 82       	st	Z, r12
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    504a:	8f 5f       	subi	r24, 0xFF	; 255
    504c:	87 15       	cp	r24, r7
    504e:	78 f3       	brcs	.-34     	; 0x502e <StrCalc+0x478>
    5050:	0b c0       	rjmp	.+22     	; 0x5068 <StrCalc+0x4b2>
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    5052:	89 2f       	mov	r24, r25
    5054:	8f 5f       	subi	r24, 0xFF	; 255
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5056:	8a 30       	cpi	r24, 0x0A	; 10
    5058:	10 f0       	brcs	.+4      	; 0x505e <StrCalc+0x4a8>
    505a:	80 e3       	ldi	r24, 0x30	; 48
    505c:	02 c0       	rjmp	.+4      	; 0x5062 <StrCalc+0x4ac>
	    Result='0'+X;
    505e:	89 2f       	mov	r24, r25
    5060:	8f 5c       	subi	r24, 0xCF	; 207
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    5062:	a4 0d       	add	r26, r4
    5064:	b5 1d       	adc	r27, r5
    5066:	8c 93       	st	X, r24
		 }strC[iPos]=0;
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
    5068:	d3 94       	inc	r13
    506a:	0f 5f       	subi	r16, 0xFF	; 255
    506c:	1f 4f       	sbci	r17, 0xFF	; 255
    506e:	21 50       	subi	r18, 0x01	; 1
    5070:	30 40       	sbci	r19, 0x00	; 0
    5072:	08 94       	sec
    5074:	e1 08       	sbc	r14, r1
    5076:	f1 08       	sbc	r15, r1
    5078:	d7 14       	cp	r13, r7
    507a:	08 f4       	brcc	.+2      	; 0x507e <StrCalc+0x4c8>
    507c:	ba cf       	rjmp	.-140    	; 0x4ff2 <StrCalc+0x43c>
					 }					 
				 }//EndFor j                
			   }//End else
			 }//EndFor
		  Result[lenA]==Chr(zMin);
		  Result[lenA+1]=0;
    507e:	4c 0f       	add	r20, r28
    5080:	5d 1f       	adc	r21, r29
    5082:	da 01       	movw	r26, r20
    5084:	de 96       	adiw	r26, 0x3e	; 62
    5086:	1c 92       	st	X, r1
		 FixLen=strlen(Result);
		 for(i=0;i<FixLen;i++){
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
    5088:	de 01       	movw	r26, r28
    508a:	dd 96       	adiw	r26, 0x3d	; 61
    508c:	fd 01       	movw	r30, r26
    508e:	01 90       	ld	r0, Z+
    5090:	00 20       	and	r0, r0
    5092:	e9 f7       	brne	.-6      	; 0x508e <StrCalc+0x4d8>
    5094:	31 97       	sbiw	r30, 0x01	; 1
    5096:	5e 2f       	mov	r21, r30
    5098:	5a 1b       	sub	r21, r26
    509a:	25 2f       	mov	r18, r21
    509c:	30 e0       	ldi	r19, 0x00	; 0
    509e:	21 50       	subi	r18, 0x01	; 1
    50a0:	30 40       	sbci	r19, 0x00	; 0
    50a2:	2a 0f       	add	r18, r26
    50a4:	3b 1f       	adc	r19, r27
    50a6:	40 e0       	ldi	r20, 0x00	; 0
    50a8:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    50aa:	6d e2       	ldi	r22, 0x2D	; 45
    50ac:	16 c0       	rjmp	.+44     	; 0x50da <StrCalc+0x524>
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    50ae:	44 23       	and	r20, r20
    50b0:	51 f4       	brne	.+20     	; 0x50c6 <StrCalc+0x510>
    50b2:	63 96       	adiw	r28, 0x13	; 19
    50b4:	bf ad       	ldd	r27, Y+63	; 0x3f
    50b6:	63 97       	sbiw	r28, 0x13	; 19
    50b8:	b1 30       	cpi	r27, 0x01	; 1
    50ba:	29 f4       	brne	.+10     	; 0x50c6 <StrCalc+0x510>
			     strC[iPos]='-';
    50bc:	f5 01       	movw	r30, r10
    50be:	e9 0f       	add	r30, r25
    50c0:	f1 1d       	adc	r31, r1
    50c2:	60 83       	st	Z, r22
				 iPos++;
    50c4:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[FixLen-i-1];
    50c6:	f5 01       	movw	r30, r10
    50c8:	e9 0f       	add	r30, r25
    50ca:	f1 1d       	adc	r31, r1
    50cc:	d9 01       	movw	r26, r18
    50ce:	8c 91       	ld	r24, X
    50d0:	80 83       	st	Z, r24
			 iPos++;
    50d2:	9f 5f       	subi	r25, 0xFF	; 255
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    50d4:	4f 5f       	subi	r20, 0xFF	; 255
    50d6:	21 50       	subi	r18, 0x01	; 1
    50d8:	30 40       	sbci	r19, 0x00	; 0
    50da:	45 17       	cp	r20, r21
    50dc:	40 f3       	brcs	.-48     	; 0x50ae <StrCalc+0x4f8>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[FixLen-i-1];
			 iPos++;
		 }strC[iPos]=0;
    50de:	f5 01       	movw	r30, r10
    50e0:	e9 0f       	add	r30, r25
    50e2:	f1 1d       	adc	r31, r1
    50e4:	10 82       	st	Z, r1

       RemZeroLead(strC);
    50e6:	c5 01       	movw	r24, r10
    50e8:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
  //    sprintf_P(strSend,PSTR("C':%s"),strC);
//	 _uart_print(0,1,strSend);

	 }//EndIf 

	 if (TOperation==TMULTIPLY){
    50ec:	b2 e0       	ldi	r27, 0x02	; 2
    50ee:	6b 16       	cp	r6, r27
    50f0:	c9 f4       	brne	.+50     	; 0x5124 <StrCalc+0x56e>
		 valA=atol(strA);
		 valB=atol(strB);
		 valC=valA*valB;		 
         ltoa(valC,strC,10);
		 */
		 CalcMultiply(strA,strB,strC);
    50f2:	c1 01       	movw	r24, r2
    50f4:	67 96       	adiw	r28, 0x17	; 23
    50f6:	6e ad       	ldd	r22, Y+62	; 0x3e
    50f8:	7f ad       	ldd	r23, Y+63	; 0x3f
    50fa:	67 97       	sbiw	r28, 0x17	; 23
    50fc:	a5 01       	movw	r20, r10
    50fe:	0e 94 ac 28 	call	0x5158	; 0x5158 <CalcMultiply>
    5102:	10 c0       	rjmp	.+32     	; 0x5124 <StrCalc+0x56e>
	 }
}
    5104:	e1 e0       	ldi	r30, 0x01	; 1
    5106:	62 96       	adiw	r28, 0x12	; 18
    5108:	ef af       	std	Y+63, r30	; 0x3f
    510a:	62 97       	sbiw	r28, 0x12	; 18
    510c:	ba ce       	rjmp	.-652    	; 0x4e82 <StrCalc+0x2cc>
    510e:	63 96       	adiw	r28, 0x13	; 19
    5110:	1f ae       	std	Y+63, r1	; 0x3f
    5112:	63 97       	sbiw	r28, 0x13	; 19
    5114:	56 cf       	rjmp	.-340    	; 0x4fc2 <StrCalc+0x40c>
    5116:	f1 e0       	ldi	r31, 0x01	; 1
    5118:	63 96       	adiw	r28, 0x13	; 19
    511a:	ff af       	std	Y+63, r31	; 0x3f
    511c:	63 97       	sbiw	r28, 0x13	; 19
    511e:	51 cf       	rjmp	.-350    	; 0x4fc2 <StrCalc+0x40c>
    5120:	90 e0       	ldi	r25, 0x00	; 0
    5122:	97 cf       	rjmp	.-210    	; 0x5052 <StrCalc+0x49c>
    5124:	ca 5a       	subi	r28, 0xAA	; 170
    5126:	df 4f       	sbci	r29, 0xFF	; 255
    5128:	0f b6       	in	r0, 0x3f	; 63
    512a:	f8 94       	cli
    512c:	de bf       	out	0x3e, r29	; 62
    512e:	0f be       	out	0x3f, r0	; 63
    5130:	cd bf       	out	0x3d, r28	; 61
    5132:	cf 91       	pop	r28
    5134:	df 91       	pop	r29
    5136:	1f 91       	pop	r17
    5138:	0f 91       	pop	r16
    513a:	ff 90       	pop	r15
    513c:	ef 90       	pop	r14
    513e:	df 90       	pop	r13
    5140:	cf 90       	pop	r12
    5142:	bf 90       	pop	r11
    5144:	af 90       	pop	r10
    5146:	9f 90       	pop	r9
    5148:	8f 90       	pop	r8
    514a:	7f 90       	pop	r7
    514c:	6f 90       	pop	r6
    514e:	5f 90       	pop	r5
    5150:	4f 90       	pop	r4
    5152:	3f 90       	pop	r3
    5154:	2f 90       	pop	r2
    5156:	08 95       	ret

00005158 <CalcMultiply>:
	 }
	 strResult[lenR]=0;
}


void CalcMultiply(char *strA,char *strB,char *strC){
    5158:	4f 92       	push	r4
    515a:	5f 92       	push	r5
    515c:	6f 92       	push	r6
    515e:	7f 92       	push	r7
    5160:	8f 92       	push	r8
    5162:	9f 92       	push	r9
    5164:	af 92       	push	r10
    5166:	bf 92       	push	r11
    5168:	cf 92       	push	r12
    516a:	df 92       	push	r13
    516c:	ef 92       	push	r14
    516e:	ff 92       	push	r15
    5170:	0f 93       	push	r16
    5172:	1f 93       	push	r17
    5174:	df 93       	push	r29
    5176:	cf 93       	push	r28
    5178:	cd b7       	in	r28, 0x3d	; 61
    517a:	de b7       	in	r29, 0x3e	; 62
    517c:	a8 97       	sbiw	r28, 0x28	; 40
    517e:	0f b6       	in	r0, 0x3f	; 63
    5180:	f8 94       	cli
    5182:	de bf       	out	0x3e, r29	; 62
    5184:	0f be       	out	0x3f, r0	; 63
    5186:	cd bf       	out	0x3d, r28	; 61
    5188:	3c 01       	movw	r6, r24
    518a:	6b 01       	movw	r12, r22
    518c:	2a 01       	movw	r4, r20
	 
	 */
	 char i,lenB;
	 char prevSeg[20],currSeg[20];

     RemZeroLead(strA);
    518e:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
     RemZeroLead(strB);
    5192:	c6 01       	movw	r24, r12
    5194:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
	 lenB=strlen(strB);
    5198:	d6 01       	movw	r26, r12
    519a:	0d 90       	ld	r0, X+
    519c:	00 20       	and	r0, r0
    519e:	e9 f7       	brne	.-6      	; 0x519a <CalcMultiply+0x42>
    51a0:	11 97       	sbiw	r26, 0x01	; 1
    51a2:	8a 2e       	mov	r8, r26
    51a4:	8c 18       	sub	r8, r12
	 sprintf_P(prevSeg,PSTR("0"));
    51a6:	00 d0       	rcall	.+0      	; 0x51a8 <CalcMultiply+0x50>
    51a8:	00 d0       	rcall	.+0      	; 0x51aa <CalcMultiply+0x52>
    51aa:	8e 01       	movw	r16, r28
    51ac:	0f 5f       	subi	r16, 0xFF	; 255
    51ae:	1f 4f       	sbci	r17, 0xFF	; 255
    51b0:	ad b7       	in	r26, 0x3d	; 61
    51b2:	be b7       	in	r27, 0x3e	; 62
    51b4:	12 96       	adiw	r26, 0x02	; 2
    51b6:	1c 93       	st	X, r17
    51b8:	0e 93       	st	-X, r16
    51ba:	11 97       	sbiw	r26, 0x01	; 1
    51bc:	87 e2       	ldi	r24, 0x27	; 39
    51be:	96 e0       	ldi	r25, 0x06	; 6
    51c0:	14 96       	adiw	r26, 0x04	; 4
    51c2:	9c 93       	st	X, r25
    51c4:	8e 93       	st	-X, r24
    51c6:	13 97       	sbiw	r26, 0x03	; 3
    51c8:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 sprintf_P(currSeg,PSTR("0"));
    51cc:	a5 e1       	ldi	r26, 0x15	; 21
    51ce:	ea 2e       	mov	r14, r26
    51d0:	f1 2c       	mov	r15, r1
    51d2:	ec 0e       	add	r14, r28
    51d4:	fd 1e       	adc	r15, r29
    51d6:	ed b7       	in	r30, 0x3d	; 61
    51d8:	fe b7       	in	r31, 0x3e	; 62
    51da:	f2 82       	std	Z+2, r15	; 0x02
    51dc:	e1 82       	std	Z+1, r14	; 0x01
    51de:	85 e2       	ldi	r24, 0x25	; 37
    51e0:	96 e0       	ldi	r25, 0x06	; 6
    51e2:	94 83       	std	Z+4, r25	; 0x04
    51e4:	83 83       	std	Z+3, r24	; 0x03
    51e6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    51ea:	bb 24       	eor	r11, r11
    51ec:	0f 90       	pop	r0
    51ee:	0f 90       	pop	r0
    51f0:	0f 90       	pop	r0
    51f2:	0f 90       	pop	r0
    51f4:	a0 2e       	mov	r10, r16
    51f6:	91 2e       	mov	r9, r17

	 for(i=0;i<strlen(strB);i++){
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
    51f8:	08 2d       	mov	r16, r8
    51fa:	10 e0       	ldi	r17, 0x00	; 0
    51fc:	01 50       	subi	r16, 0x01	; 1
    51fe:	10 40       	sbci	r17, 0x00	; 0
    5200:	1f c0       	rjmp	.+62     	; 0x5240 <CalcMultiply+0xe8>
    5202:	f8 01       	movw	r30, r16
    5204:	e8 1b       	sub	r30, r24
    5206:	f9 0b       	sbc	r31, r25
    5208:	ec 0d       	add	r30, r12
    520a:	fd 1d       	adc	r31, r13
    520c:	c3 01       	movw	r24, r6
    520e:	60 81       	ld	r22, Z
    5210:	a7 01       	movw	r20, r14
    5212:	0e 94 ee 1f 	call	0x3fdc	; 0x3fdc <CalcSegmen>
         AddZeroLag(currSeg,strlen(currSeg)+i);
    5216:	f7 01       	movw	r30, r14
    5218:	01 90       	ld	r0, Z+
    521a:	00 20       	and	r0, r0
    521c:	e9 f7       	brne	.-6      	; 0x5218 <CalcMultiply+0xc0>
    521e:	31 97       	sbiw	r30, 0x01	; 1
    5220:	ee 19       	sub	r30, r14
    5222:	ff 09       	sbc	r31, r15
    5224:	6b 2d       	mov	r22, r11
    5226:	6e 0f       	add	r22, r30
    5228:	c7 01       	movw	r24, r14
    522a:	0e 94 c0 25 	call	0x4b80	; 0x4b80 <AddZeroLag>
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
    522e:	81 e0       	ldi	r24, 0x01	; 1
    5230:	6a 2d       	mov	r22, r10
    5232:	79 2d       	mov	r23, r9
    5234:	a7 01       	movw	r20, r14
    5236:	2a 2d       	mov	r18, r10
    5238:	39 2d       	mov	r19, r9
    523a:	0e 94 db 25 	call	0x4bb6	; 0x4bb6 <StrCalc>
     RemZeroLead(strB);
	 lenB=strlen(strB);
	 sprintf_P(prevSeg,PSTR("0"));
	 sprintf_P(currSeg,PSTR("0"));

	 for(i=0;i<strlen(strB);i++){
    523e:	b3 94       	inc	r11
    5240:	f6 01       	movw	r30, r12
    5242:	01 90       	ld	r0, Z+
    5244:	00 20       	and	r0, r0
    5246:	e9 f7       	brne	.-6      	; 0x5242 <CalcMultiply+0xea>
    5248:	31 97       	sbiw	r30, 0x01	; 1
    524a:	ec 19       	sub	r30, r12
    524c:	fd 09       	sbc	r31, r13
    524e:	8b 2d       	mov	r24, r11
    5250:	90 e0       	ldi	r25, 0x00	; 0
    5252:	8e 17       	cp	r24, r30
    5254:	9f 07       	cpc	r25, r31
    5256:	a8 f2       	brcs	.-86     	; 0x5202 <CalcMultiply+0xaa>
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
         AddZeroLag(currSeg,strlen(currSeg)+i);
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
    5258:	00 d0       	rcall	.+0      	; 0x525a <CalcMultiply+0x102>
    525a:	00 d0       	rcall	.+0      	; 0x525c <CalcMultiply+0x104>
    525c:	00 d0       	rcall	.+0      	; 0x525e <CalcMultiply+0x106>
    525e:	ed b7       	in	r30, 0x3d	; 61
    5260:	fe b7       	in	r31, 0x3e	; 62
    5262:	31 96       	adiw	r30, 0x01	; 1
    5264:	ad b7       	in	r26, 0x3d	; 61
    5266:	be b7       	in	r27, 0x3e	; 62
    5268:	12 96       	adiw	r26, 0x02	; 2
    526a:	5c 92       	st	X, r5
    526c:	4e 92       	st	-X, r4
    526e:	11 97       	sbiw	r26, 0x01	; 1
    5270:	82 e2       	ldi	r24, 0x22	; 34
    5272:	96 e0       	ldi	r25, 0x06	; 6
    5274:	93 83       	std	Z+3, r25	; 0x03
    5276:	82 83       	std	Z+2, r24	; 0x02
    5278:	a4 82       	std	Z+4, r10	; 0x04
    527a:	95 82       	std	Z+5, r9	; 0x05
    527c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    5280:	ed b7       	in	r30, 0x3d	; 61
    5282:	fe b7       	in	r31, 0x3e	; 62
    5284:	36 96       	adiw	r30, 0x06	; 6
    5286:	0f b6       	in	r0, 0x3f	; 63
    5288:	f8 94       	cli
    528a:	fe bf       	out	0x3e, r31	; 62
    528c:	0f be       	out	0x3f, r0	; 63
    528e:	ed bf       	out	0x3d, r30	; 61
}
    5290:	a8 96       	adiw	r28, 0x28	; 40
    5292:	0f b6       	in	r0, 0x3f	; 63
    5294:	f8 94       	cli
    5296:	de bf       	out	0x3e, r29	; 62
    5298:	0f be       	out	0x3f, r0	; 63
    529a:	cd bf       	out	0x3d, r28	; 61
    529c:	cf 91       	pop	r28
    529e:	df 91       	pop	r29
    52a0:	1f 91       	pop	r17
    52a2:	0f 91       	pop	r16
    52a4:	ff 90       	pop	r15
    52a6:	ef 90       	pop	r14
    52a8:	df 90       	pop	r13
    52aa:	cf 90       	pop	r12
    52ac:	bf 90       	pop	r11
    52ae:	af 90       	pop	r10
    52b0:	9f 90       	pop	r9
    52b2:	8f 90       	pop	r8
    52b4:	7f 90       	pop	r7
    52b6:	6f 90       	pop	r6
    52b8:	5f 90       	pop	r5
    52ba:	4f 90       	pop	r4
    52bc:	08 95       	ret

000052be <NormalizeOverflow>:
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}

void NormalizeOverflow(char *strOverflowed){
    52be:	cf 92       	push	r12
    52c0:	df 92       	push	r13
    52c2:	ef 92       	push	r14
    52c4:	ff 92       	push	r15
    52c6:	0f 93       	push	r16
    52c8:	1f 93       	push	r17
    52ca:	df 93       	push	r29
    52cc:	cf 93       	push	r28
    52ce:	cd b7       	in	r28, 0x3d	; 61
    52d0:	de b7       	in	r29, 0x3e	; 62
    52d2:	64 97       	sbiw	r28, 0x14	; 20
    52d4:	0f b6       	in	r0, 0x3f	; 63
    52d6:	f8 94       	cli
    52d8:	de bf       	out	0x3e, r29	; 62
    52da:	0f be       	out	0x3f, r0	; 63
    52dc:	cd bf       	out	0x3d, r28	; 61
    52de:	d8 2e       	mov	r13, r24
    52e0:	c9 2e       	mov	r12, r25
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
    52e2:	a8 2f       	mov	r26, r24
    52e4:	b9 2f       	mov	r27, r25
    52e6:	fd 01       	movw	r30, r26
    52e8:	01 90       	ld	r0, Z+
    52ea:	00 20       	and	r0, r0
    52ec:	e9 f7       	brne	.-6      	; 0x52e8 <NormalizeOverflow+0x2a>
    52ee:	31 97       	sbiw	r30, 0x01	; 1
    52f0:	4e 2f       	mov	r20, r30
    52f2:	48 1b       	sub	r20, r24
    52f4:	20 e0       	ldi	r18, 0x00	; 0
    52f6:	30 e0       	ldi	r19, 0x00	; 0
    52f8:	7e 01       	movw	r14, r28
    52fa:	08 94       	sec
    52fc:	e1 1c       	adc	r14, r1
    52fe:	f1 1c       	adc	r15, r1
    5300:	04 2f       	mov	r16, r20
    5302:	10 e0       	ldi	r17, 0x00	; 0
    5304:	0e c0       	rjmp	.+28     	; 0x5322 <NormalizeOverflow+0x64>
     for(i=0;i<Length;i++){//123456
	     strMaxValue[i]='0'+((Length-i)/Length);
    5306:	f7 01       	movw	r30, r14
    5308:	e2 0f       	add	r30, r18
    530a:	f3 1f       	adc	r31, r19
    530c:	c8 01       	movw	r24, r16
    530e:	82 1b       	sub	r24, r18
    5310:	93 0b       	sbc	r25, r19
    5312:	64 2f       	mov	r22, r20
    5314:	70 e0       	ldi	r23, 0x00	; 0
    5316:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    531a:	60 5d       	subi	r22, 0xD0	; 208
    531c:	60 83       	st	Z, r22
    531e:	2f 5f       	subi	r18, 0xFF	; 255
    5320:	3f 4f       	sbci	r19, 0xFF	; 255

void NormalizeOverflow(char *strOverflowed){
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
     for(i=0;i<Length;i++){//123456
    5322:	24 17       	cp	r18, r20
    5324:	80 f3       	brcs	.-32     	; 0x5306 <NormalizeOverflow+0x48>
	     strMaxValue[i]='0'+((Length-i)/Length);
	 }strMaxValue[Length]=0;
    5326:	0e 0d       	add	r16, r14
    5328:	1f 1d       	adc	r17, r15
    532a:	f8 01       	movw	r30, r16
    532c:	10 82       	st	Z, r1
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
    532e:	81 e0       	ldi	r24, 0x01	; 1
    5330:	b7 01       	movw	r22, r14
    5332:	4d 2d       	mov	r20, r13
    5334:	5c 2d       	mov	r21, r12
    5336:	2d 2d       	mov	r18, r13
    5338:	3c 2d       	mov	r19, r12
    533a:	0e 94 db 25 	call	0x4bb6	; 0x4bb6 <StrCalc>
}
    533e:	64 96       	adiw	r28, 0x14	; 20
    5340:	0f b6       	in	r0, 0x3f	; 63
    5342:	f8 94       	cli
    5344:	de bf       	out	0x3e, r29	; 62
    5346:	0f be       	out	0x3f, r0	; 63
    5348:	cd bf       	out	0x3d, r28	; 61
    534a:	cf 91       	pop	r28
    534c:	df 91       	pop	r29
    534e:	1f 91       	pop	r17
    5350:	0f 91       	pop	r16
    5352:	ff 90       	pop	r15
    5354:	ef 90       	pop	r14
    5356:	df 90       	pop	r13
    5358:	cf 90       	pop	r12
    535a:	08 95       	ret

0000535c <AddSpaceLead>:
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    535c:	bf 92       	push	r11
    535e:	cf 92       	push	r12
    5360:	df 92       	push	r13
    5362:	ef 92       	push	r14
    5364:	ff 92       	push	r15
    5366:	0f 93       	push	r16
    5368:	1f 93       	push	r17
    536a:	df 93       	push	r29
    536c:	cf 93       	push	r28
    536e:	cd b7       	in	r28, 0x3d	; 61
    5370:	de b7       	in	r29, 0x3e	; 62
    5372:	6e 97       	sbiw	r28, 0x1e	; 30
    5374:	0f b6       	in	r0, 0x3f	; 63
    5376:	f8 94       	cli
    5378:	de bf       	out	0x3e, r29	; 62
    537a:	0f be       	out	0x3f, r0	; 63
    537c:	cd bf       	out	0x3d, r28	; 61
    537e:	8c 01       	movw	r16, r24
     char i,Length,strAdded[30];
     Length=strlen(String);
    5380:	fc 01       	movw	r30, r24
    5382:	01 90       	ld	r0, Z+
    5384:	00 20       	and	r0, r0
    5386:	e9 f7       	brne	.-6      	; 0x5382 <AddSpaceLead+0x26>
    5388:	31 97       	sbiw	r30, 0x01	; 1
    538a:	2e 2f       	mov	r18, r30
    538c:	28 1b       	sub	r18, r24

	 if (Size>Length){
    538e:	26 17       	cp	r18, r22
    5390:	e0 f5       	brcc	.+120    	; 0x540a <AddSpaceLead+0xae>
    5392:	7e 01       	movw	r14, r28
    5394:	08 94       	sec
    5396:	e1 1c       	adc	r14, r1
    5398:	f1 1c       	adc	r15, r1
    539a:	f7 01       	movw	r30, r14
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    539c:	be 2c       	mov	r11, r14
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
    539e:	90 e2       	ldi	r25, 0x20	; 32
    53a0:	01 c0       	rjmp	.+2      	; 0x53a4 <AddSpaceLead+0x48>
    53a2:	91 93       	st	Z+, r25
void AddSpaceLead(char *String,unsigned char Size){//
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    53a4:	8e 2f       	mov	r24, r30
    53a6:	8b 19       	sub	r24, r11
    53a8:	86 17       	cp	r24, r22
    53aa:	d8 f3       	brcs	.-10     	; 0x53a2 <AddSpaceLead+0x46>
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
    53ac:	46 2f       	mov	r20, r22
    53ae:	50 e0       	ldi	r21, 0x00	; 0
    53b0:	ce 01       	movw	r24, r28
    53b2:	01 96       	adiw	r24, 0x01	; 1
    53b4:	fc 01       	movw	r30, r24
    53b6:	e4 0f       	add	r30, r20
    53b8:	f5 1f       	adc	r31, r21
    53ba:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    53bc:	76 2f       	mov	r23, r22
    53be:	72 1b       	sub	r23, r18
    53c0:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    53c2:	30 e0       	ldi	r19, 0x00	; 0
    53c4:	24 1b       	sub	r18, r20
    53c6:	35 0b       	sbc	r19, r21
    53c8:	0c c0       	rjmp	.+24     	; 0x53e2 <AddSpaceLead+0x86>
    53ca:	e7 2f       	mov	r30, r23
    53cc:	f0 e0       	ldi	r31, 0x00	; 0
    53ce:	d6 01       	movw	r26, r12
    53d0:	ae 0f       	add	r26, r30
    53d2:	bf 1f       	adc	r27, r31
    53d4:	e0 0f       	add	r30, r16
    53d6:	f1 1f       	adc	r31, r17
    53d8:	e2 0f       	add	r30, r18
    53da:	f3 1f       	adc	r31, r19
    53dc:	80 81       	ld	r24, Z
    53de:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    53e0:	7f 5f       	subi	r23, 0xFF	; 255
    53e2:	76 17       	cp	r23, r22
    53e4:	90 f3       	brcs	.-28     	; 0x53ca <AddSpaceLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    53e6:	4c 0d       	add	r20, r12
    53e8:	5d 1d       	adc	r21, r13
    53ea:	da 01       	movw	r26, r20
    53ec:	1c 92       	st	X, r1
    53ee:	f8 01       	movw	r30, r16
    53f0:	04 c0       	rjmp	.+8      	; 0x53fa <AddSpaceLead+0x9e>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    53f2:	d7 01       	movw	r26, r14
    53f4:	8d 91       	ld	r24, X+
    53f6:	7d 01       	movw	r14, r26
    53f8:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    53fa:	8e 2d       	mov	r24, r14
    53fc:	8b 19       	sub	r24, r11
    53fe:	86 17       	cp	r24, r22
    5400:	c0 f3       	brcs	.-16     	; 0x53f2 <AddSpaceLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    5402:	06 0f       	add	r16, r22
    5404:	11 1d       	adc	r17, r1
    5406:	f8 01       	movw	r30, r16
    5408:	10 82       	st	Z, r1
	 }
}
    540a:	6e 96       	adiw	r28, 0x1e	; 30
    540c:	0f b6       	in	r0, 0x3f	; 63
    540e:	f8 94       	cli
    5410:	de bf       	out	0x3e, r29	; 62
    5412:	0f be       	out	0x3f, r0	; 63
    5414:	cd bf       	out	0x3d, r28	; 61
    5416:	cf 91       	pop	r28
    5418:	df 91       	pop	r29
    541a:	1f 91       	pop	r17
    541c:	0f 91       	pop	r16
    541e:	ff 90       	pop	r15
    5420:	ef 90       	pop	r14
    5422:	df 90       	pop	r13
    5424:	cf 90       	pop	r12
    5426:	bf 90       	pop	r11
    5428:	08 95       	ret

0000542a <AddSpaceLag>:
	 }
}



void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
    542a:	cf 93       	push	r28
    542c:	df 93       	push	r29
    542e:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    5430:	dc 01       	movw	r26, r24
    5432:	0d 90       	ld	r0, X+
    5434:	00 20       	and	r0, r0
    5436:	e9 f7       	brne	.-6      	; 0x5432 <AddSpaceLag+0x8>
    5438:	11 97       	sbiw	r26, 0x01	; 1
    543a:	a8 1b       	sub	r26, r24
    543c:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    543e:	a6 17       	cp	r26, r22
    5440:	60 f4       	brcc	.+24     	; 0x545a <AddSpaceLag+0x30>
    5442:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=' ';
    5444:	90 e2       	ldi	r25, 0x20	; 32
    5446:	fe 01       	movw	r30, r28
    5448:	e8 0f       	add	r30, r24
    544a:	f1 1d       	adc	r31, r1
    544c:	90 83       	st	Z, r25

void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    544e:	8f 5f       	subi	r24, 0xFF	; 255
    5450:	86 17       	cp	r24, r22
    5452:	c8 f3       	brcs	.-14     	; 0x5446 <AddSpaceLag+0x1c>
	    String[i]=' ';
	 }String[Size]=0;
    5454:	c6 0f       	add	r28, r22
    5456:	d1 1d       	adc	r29, r1
    5458:	18 82       	st	Y, r1
  }
}
    545a:	df 91       	pop	r29
    545c:	cf 91       	pop	r28
    545e:	08 95       	ret

00005460 <GetProductName>:
	 }    
	 //Clear Decimal

}

void GetProductName(char GradeId,char *strProductName){
    5460:	0f 93       	push	r16
    5462:	1f 93       	push	r17
    5464:	df 93       	push	r29
    5466:	cf 93       	push	r28
    5468:	cd b7       	in	r28, 0x3d	; 61
    546a:	de b7       	in	r29, 0x3e	; 62
    546c:	2c 97       	sbiw	r28, 0x0c	; 12
    546e:	0f b6       	in	r0, 0x3f	; 63
    5470:	f8 94       	cli
    5472:	de bf       	out	0x3e, r29	; 62
    5474:	0f be       	out	0x3f, r0	; 63
    5476:	cd bf       	out	0x3d, r28	; 61
    5478:	48 2f       	mov	r20, r24
    547a:	8b 01       	movw	r16, r22
    547c:	fe 01       	movw	r30, r28
    547e:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5480:	9e 01       	movw	r18, r28
    5482:	23 5f       	subi	r18, 0xF3	; 243
    5484:	3f 4f       	sbci	r19, 0xFF	; 255
	     strMemory[i]=data;
    5486:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5488:	e2 17       	cp	r30, r18
    548a:	f3 07       	cpc	r31, r19
    548c:	e1 f7       	brne	.-8      	; 0x5486 <GetProductName+0x26>
    548e:	ce 01       	movw	r24, r28
    5490:	01 96       	adiw	r24, 0x01	; 1

void GetProductName(char GradeId,char *strProductName){
char SProductName[12],i,Length;
     FillChar(SProductName,sizeof(SProductName),0); 
	 //eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
	 if (GradeId>0) eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
    5492:	44 23       	and	r20, r20
    5494:	69 f0       	breq	.+26     	; 0x54b0 <GetProductName+0x50>
    5496:	6d e0       	ldi	r22, 0x0D	; 13
    5498:	46 9f       	mul	r20, r22
    549a:	b0 01       	movw	r22, r0
    549c:	11 24       	eor	r1, r1
    549e:	62 52       	subi	r22, 0x22	; 34
    54a0:	7f 4f       	sbci	r23, 0xFF	; 255
    54a2:	4a e0       	ldi	r20, 0x0A	; 10
    54a4:	50 e0       	ldi	r21, 0x00	; 0
    54a6:	2c ea       	ldi	r18, 0xAC	; 172
    54a8:	32 e1       	ldi	r19, 0x12	; 18
    54aa:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
    54ae:	14 c0       	rjmp	.+40     	; 0x54d8 <GetProductName+0x78>
	 else sprintf_P(SProductName,PSTR("N/A"));
    54b0:	00 d0       	rcall	.+0      	; 0x54b2 <GetProductName+0x52>
    54b2:	00 d0       	rcall	.+0      	; 0x54b4 <GetProductName+0x54>
    54b4:	ad b7       	in	r26, 0x3d	; 61
    54b6:	be b7       	in	r27, 0x3e	; 62
    54b8:	12 96       	adiw	r26, 0x02	; 2
    54ba:	9c 93       	st	X, r25
    54bc:	8e 93       	st	-X, r24
    54be:	11 97       	sbiw	r26, 0x01	; 1
    54c0:	89 e7       	ldi	r24, 0x79	; 121
    54c2:	94 e0       	ldi	r25, 0x04	; 4
    54c4:	14 96       	adiw	r26, 0x04	; 4
    54c6:	9c 93       	st	X, r25
    54c8:	8e 93       	st	-X, r24
    54ca:	13 97       	sbiw	r26, 0x03	; 3
    54cc:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    54d0:	0f 90       	pop	r0
    54d2:	0f 90       	pop	r0
    54d4:	0f 90       	pop	r0
    54d6:	0f 90       	pop	r0

     Length=strlen(SProductName);
    54d8:	de 01       	movw	r26, r28
    54da:	11 96       	adiw	r26, 0x01	; 1
    54dc:	fd 01       	movw	r30, r26
    54de:	01 90       	ld	r0, Z+
    54e0:	00 20       	and	r0, r0
    54e2:	e9 f7       	brne	.-6      	; 0x54de <GetProductName+0x7e>
    54e4:	31 97       	sbiw	r30, 0x01	; 1
    54e6:	ea 1b       	sub	r30, r26
    54e8:	eb 30       	cpi	r30, 0x0B	; 11
    54ea:	08 f0       	brcs	.+2      	; 0x54ee <GetProductName+0x8e>
    54ec:	ea e0       	ldi	r30, 0x0A	; 10
    54ee:	ae 01       	movw	r20, r28
    54f0:	4f 5f       	subi	r20, 0xFF	; 255
    54f2:	5f 4f       	sbci	r21, 0xFF	; 255
    54f4:	98 01       	movw	r18, r16
    54f6:	ba 01       	movw	r22, r20
    54f8:	06 c0       	rjmp	.+12     	; 0x5506 <GetProductName+0xa6>
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
	     strProductName[i]=SProductName[i];
    54fa:	db 01       	movw	r26, r22
    54fc:	8d 91       	ld	r24, X+
    54fe:	bd 01       	movw	r22, r26
    5500:	d9 01       	movw	r26, r18
    5502:	8d 93       	st	X+, r24
    5504:	9d 01       	movw	r18, r26
	 else sprintf_P(SProductName,PSTR("N/A"));

     Length=strlen(SProductName);
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
    5506:	86 2f       	mov	r24, r22
    5508:	84 1b       	sub	r24, r20
    550a:	8e 17       	cp	r24, r30
    550c:	b0 f3       	brcs	.-20     	; 0x54fa <GetProductName+0x9a>
	     strProductName[i]=SProductName[i];
	 }strProductName[Length]=0;
    550e:	c8 01       	movw	r24, r16
    5510:	8e 0f       	add	r24, r30
    5512:	91 1d       	adc	r25, r1
    5514:	fc 01       	movw	r30, r24
    5516:	10 82       	st	Z, r1

	 AddSpaceLag(strProductName,10);
    5518:	c8 01       	movw	r24, r16
    551a:	6a e0       	ldi	r22, 0x0A	; 10
    551c:	0e 94 15 2a 	call	0x542a	; 0x542a <AddSpaceLag>
}
    5520:	2c 96       	adiw	r28, 0x0c	; 12
    5522:	0f b6       	in	r0, 0x3f	; 63
    5524:	f8 94       	cli
    5526:	de bf       	out	0x3e, r29	; 62
    5528:	0f be       	out	0x3f, r0	; 63
    552a:	cd bf       	out	0x3d, r28	; 61
    552c:	cf 91       	pop	r28
    552e:	df 91       	pop	r29
    5530:	1f 91       	pop	r17
    5532:	0f 91       	pop	r16
    5534:	08 95       	ret

00005536 <GeniusSendLastTransaction>:
}
void GeniusSendPumpPreset(char iPumpID){
}


void GeniusSendLastTransaction(char iPumpID){
    5536:	2f 92       	push	r2
    5538:	3f 92       	push	r3
    553a:	4f 92       	push	r4
    553c:	5f 92       	push	r5
    553e:	6f 92       	push	r6
    5540:	7f 92       	push	r7
    5542:	8f 92       	push	r8
    5544:	9f 92       	push	r9
    5546:	af 92       	push	r10
    5548:	bf 92       	push	r11
    554a:	cf 92       	push	r12
    554c:	df 92       	push	r13
    554e:	ef 92       	push	r14
    5550:	ff 92       	push	r15
    5552:	0f 93       	push	r16
    5554:	1f 93       	push	r17
    5556:	df 93       	push	r29
    5558:	cf 93       	push	r28
    555a:	cd b7       	in	r28, 0x3d	; 61
    555c:	de b7       	in	r29, 0x3e	; 62
    555e:	c0 5b       	subi	r28, 0xB0	; 176
    5560:	d0 40       	sbci	r29, 0x00	; 0
    5562:	0f b6       	in	r0, 0x3f	; 63
    5564:	f8 94       	cli
    5566:	de bf       	out	0x3e, r29	; 62
    5568:	0f be       	out	0x3f, r0	; 63
    556a:	cd bf       	out	0x3d, r28	; 61
    556c:	e8 2e       	mov	r14, r24
    556e:	fe 01       	movw	r30, r28
    5570:	37 96       	adiw	r30, 0x07	; 7

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5572:	ce 01       	movw	r24, r28
    5574:	46 96       	adiw	r24, 0x16	; 22
	     strMemory[i]=data;
    5576:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5578:	e8 17       	cp	r30, r24
    557a:	f9 07       	cpc	r31, r25
    557c:	e1 f7       	brne	.-8      	; 0x5576 <GeniusSendLastTransaction+0x40>
	     strMemory[i]=data;
    557e:	ce 01       	movw	r24, r28
    5580:	85 96       	adiw	r24, 0x25	; 37
    5582:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5584:	e8 17       	cp	r30, r24
    5586:	f9 07       	cpc	r31, r25
    5588:	e1 f7       	brne	.-8      	; 0x5582 <GeniusSendLastTransaction+0x4c>
	     strMemory[i]=data;
    558a:	ce 01       	movw	r24, r28
    558c:	c4 96       	adiw	r24, 0x34	; 52
    558e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5590:	e8 17       	cp	r30, r24
    5592:	f9 07       	cpc	r31, r25
    5594:	e1 f7       	brne	.-8      	; 0x558e <GeniusSendLastTransaction+0x58>
	     strMemory[i]=data;
    5596:	cf 01       	movw	r24, r30
    5598:	3f 01       	movw	r6, r30
    559a:	0f 96       	adiw	r24, 0x0f	; 15
    559c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    559e:	e8 17       	cp	r30, r24
    55a0:	f9 07       	cpc	r31, r25
    55a2:	e1 f7       	brne	.-8      	; 0x559c <GeniusSendLastTransaction+0x66>
	 FillChar(STotalVolume,sizeof(STotalVolume),0);
	 FillChar(STotalMoney,sizeof(STotalMoney),0);
	      

	 //Generate
	 FIPAddr=GetFIPAddr(iPumpID);
    55a4:	8e 2d       	mov	r24, r14
    55a6:	0e 94 bd 1a 	call	0x357a	; 0x357a <GetFIPAddr>
    55aa:	96 e0       	ldi	r25, 0x06	; 6
    55ac:	89 9f       	mul	r24, r25
    55ae:	b0 01       	movw	r22, r0
    55b0:	11 24       	eor	r1, r1
    55b2:	61 5b       	subi	r22, 0xB1	; 177
    55b4:	7f 4f       	sbci	r23, 0xFF	; 255
    55b6:	8e 01       	movw	r16, r28
    55b8:	0f 5f       	subi	r16, 0xFF	; 255
    55ba:	1f 4f       	sbci	r17, 0xFF	; 255
    55bc:	c8 01       	movw	r24, r16
    55be:	46 e0       	ldi	r20, 0x06	; 6
    55c0:	50 e0       	ldi	r21, 0x00	; 0
    55c2:	2c ea       	ldi	r18, 0xAC	; 172
    55c4:	32 e1       	ldi	r19, 0x12	; 18
    55c6:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);
	 iNozzle=RecPumpData[iPumpID&0x0F].Grade;
    55ca:	2e 2c       	mov	r2, r14
    55cc:	33 24       	eor	r3, r3
    55ce:	91 01       	movw	r18, r2
    55d0:	2f 70       	andi	r18, 0x0F	; 15
    55d2:	30 70       	andi	r19, 0x00	; 0
    55d4:	85 e3       	ldi	r24, 0x35	; 53
    55d6:	90 e0       	ldi	r25, 0x00	; 0
    55d8:	28 9f       	mul	r18, r24
    55da:	f0 01       	movw	r30, r0
    55dc:	29 9f       	mul	r18, r25
    55de:	f0 0d       	add	r31, r0
    55e0:	38 9f       	mul	r19, r24
    55e2:	f0 0d       	add	r31, r0
    55e4:	11 24       	eor	r1, r1
    55e6:	e9 54       	subi	r30, 0x49	; 73
    55e8:	f8 4f       	sbci	r31, 0xF8	; 248
    55ea:	f0 80       	ld	r15, Z
	 iProdID=PProductID[iNozzle];
    55ec:	4f 2c       	mov	r4, r15
    55ee:	55 24       	eor	r5, r5

	 GetProductName(iProdID,strProduct);
    55f0:	04 0d       	add	r16, r4
    55f2:	15 1d       	adc	r17, r5
    55f4:	d8 01       	movw	r26, r16
    55f6:	8c 91       	ld	r24, X
    55f8:	6d e6       	ldi	r22, 0x6D	; 109
    55fa:	79 e0       	ldi	r23, 0x09	; 9
    55fc:	0e 94 30 2a 	call	0x5460	; 0x5460 <GetProductName>
	 GetTransactionVolume(iPumpID,SVolume);
    5600:	87 e0       	ldi	r24, 0x07	; 7
    5602:	88 2e       	mov	r8, r24
    5604:	91 2c       	mov	r9, r1
    5606:	8c 0e       	add	r8, r28
    5608:	9d 1e       	adc	r9, r29
    560a:	8e 2d       	mov	r24, r14
    560c:	b4 01       	movw	r22, r8
    560e:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <GetTransactionVolume>
	 GetTransactionMoney(iPumpID,SMoney);
    5612:	06 e1       	ldi	r16, 0x16	; 22
    5614:	a0 2e       	mov	r10, r16
    5616:	b1 2c       	mov	r11, r1
    5618:	ac 0e       	add	r10, r28
    561a:	bd 1e       	adc	r11, r29
    561c:	8e 2d       	mov	r24, r14
    561e:	b5 01       	movw	r22, r10
    5620:	0e 94 4c 25 	call	0x4a98	; 0x4a98 <GetTransactionMoney>
	 GetTotalizerVolume(iPumpID,iNozzle,STotalVolume);
    5624:	15 e2       	ldi	r17, 0x25	; 37
    5626:	c1 2e       	mov	r12, r17
    5628:	d1 2c       	mov	r13, r1
    562a:	cc 0e       	add	r12, r28
    562c:	dd 1e       	adc	r13, r29
    562e:	8e 2d       	mov	r24, r14
    5630:	6f 2d       	mov	r22, r15
    5632:	a6 01       	movw	r20, r12
    5634:	0e 94 2f 25 	call	0x4a5e	; 0x4a5e <GetTotalizerVolume>
	 GetTotalizerMoney(iPumpID,iNozzle,STotalMoney);
    5638:	8e 2d       	mov	r24, r14
    563a:	6f 2d       	mov	r22, r15
    563c:	a3 01       	movw	r20, r6
    563e:	0e 94 12 25 	call	0x4a24	; 0x4a24 <GetTotalizerMoney>
	 
     ComposeDatetime(SDatetime);
    5642:	b3 e4       	ldi	r27, 0x43	; 67
    5644:	eb 2e       	mov	r14, r27
    5646:	f1 2c       	mov	r15, r1
    5648:	ec 0e       	add	r14, r28
    564a:	fd 1e       	adc	r15, r29
    564c:	c7 01       	movw	r24, r14
    564e:	0e 94 0a 1a 	call	0x3414	; 0x3414 <ComposeDatetime>

	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
    5652:	ed b7       	in	r30, 0x3d	; 61
    5654:	fe b7       	in	r31, 0x3e	; 62
    5656:	74 97       	sbiw	r30, 0x14	; 20
    5658:	0f b6       	in	r0, 0x3f	; 63
    565a:	f8 94       	cli
    565c:	fe bf       	out	0x3e, r31	; 62
    565e:	0f be       	out	0x3f, r0	; 63
    5660:	ed bf       	out	0x3d, r30	; 61
    5662:	31 96       	adiw	r30, 0x01	; 1
    5664:	8e 01       	movw	r16, r28
    5666:	09 5a       	subi	r16, 0xA9	; 169
    5668:	1f 4f       	sbci	r17, 0xFF	; 255
    566a:	ad b7       	in	r26, 0x3d	; 61
    566c:	be b7       	in	r27, 0x3e	; 62
    566e:	12 96       	adiw	r26, 0x02	; 2
    5670:	1c 93       	st	X, r17
    5672:	0e 93       	st	-X, r16
    5674:	11 97       	sbiw	r26, 0x01	; 1
    5676:	8c eb       	ldi	r24, 0xBC	; 188
    5678:	93 e0       	ldi	r25, 0x03	; 3
    567a:	93 83       	std	Z+3, r25	; 0x03
    567c:	82 83       	std	Z+2, r24	; 0x02
    567e:	35 82       	std	Z+5, r3	; 0x05
    5680:	24 82       	std	Z+4, r2	; 0x04
    5682:	57 82       	std	Z+7, r5	; 0x07
    5684:	46 82       	std	Z+6, r4	; 0x06
    5686:	8d e6       	ldi	r24, 0x6D	; 109
    5688:	99 e0       	ldi	r25, 0x09	; 9
    568a:	91 87       	std	Z+9, r25	; 0x09
    568c:	80 87       	std	Z+8, r24	; 0x08
    568e:	f3 86       	std	Z+11, r15	; 0x0b
    5690:	e2 86       	std	Z+10, r14	; 0x0a
    5692:	95 86       	std	Z+13, r9	; 0x0d
    5694:	84 86       	std	Z+12, r8	; 0x0c
    5696:	b7 86       	std	Z+15, r11	; 0x0f
    5698:	a6 86       	std	Z+14, r10	; 0x0e
    569a:	d1 8a       	std	Z+17, r13	; 0x11
    569c:	c0 8a       	std	Z+16, r12	; 0x10
    569e:	62 8a       	std	Z+18, r6	; 0x12
    56a0:	73 8a       	std	Z+19, r7	; 0x13
    56a2:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 cSum=SumChecksum(strSend);
    56a6:	ad b7       	in	r26, 0x3d	; 61
    56a8:	be b7       	in	r27, 0x3e	; 62
    56aa:	54 96       	adiw	r26, 0x14	; 20
    56ac:	0f b6       	in	r0, 0x3f	; 63
    56ae:	f8 94       	cli
    56b0:	be bf       	out	0x3e, r27	; 62
    56b2:	0f be       	out	0x3f, r0	; 63
    56b4:	ad bf       	out	0x3d, r26	; 61
    56b6:	c8 01       	movw	r24, r16
    56b8:	0e 94 9d 1e 	call	0x3d3a	; 0x3d3a <SumChecksum>
    56bc:	e8 2e       	mov	r14, r24
	 _uart_print(1,0,strSend);
    56be:	81 e0       	ldi	r24, 0x01	; 1
    56c0:	60 e0       	ldi	r22, 0x00	; 0
    56c2:	a8 01       	movw	r20, r16
    56c4:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
    56c8:	f8 01       	movw	r30, r16

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    56ca:	c8 01       	movw	r24, r16
    56cc:	f9 2e       	mov	r15, r25
    56ce:	ce 01       	movw	r24, r28
    56d0:	8f 54       	subi	r24, 0x4F	; 79
    56d2:	9f 4f       	sbci	r25, 0xFF	; 255
	     strMemory[i]=data;
    56d4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    56d6:	e8 17       	cp	r30, r24
    56d8:	f9 07       	cpc	r31, r25
    56da:	e1 f7       	brne	.-8      	; 0x56d4 <GeniusSendLastTransaction+0x19e>
	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
	 cSum=SumChecksum(strSend);
	 _uart_print(1,0,strSend);
	 FillChar(strSend,sizeof(strSend),0);      
	 sprintf_P(strSend,PSTR("%d"),cSum);
    56dc:	00 d0       	rcall	.+0      	; 0x56de <GeniusSendLastTransaction+0x1a8>
    56de:	00 d0       	rcall	.+0      	; 0x56e0 <GeniusSendLastTransaction+0x1aa>
    56e0:	00 d0       	rcall	.+0      	; 0x56e2 <GeniusSendLastTransaction+0x1ac>
    56e2:	ed b7       	in	r30, 0x3d	; 61
    56e4:	fe b7       	in	r31, 0x3e	; 62
    56e6:	31 96       	adiw	r30, 0x01	; 1
    56e8:	ad b7       	in	r26, 0x3d	; 61
    56ea:	be b7       	in	r27, 0x3e	; 62
    56ec:	11 96       	adiw	r26, 0x01	; 1
    56ee:	0c 93       	st	X, r16
    56f0:	11 97       	sbiw	r26, 0x01	; 1
    56f2:	12 96       	adiw	r26, 0x02	; 2
    56f4:	fc 92       	st	X, r15
    56f6:	89 eb       	ldi	r24, 0xB9	; 185
    56f8:	93 e0       	ldi	r25, 0x03	; 3
    56fa:	93 83       	std	Z+3, r25	; 0x03
    56fc:	82 83       	std	Z+2, r24	; 0x02
    56fe:	e4 82       	std	Z+4, r14	; 0x04
    5700:	15 82       	std	Z+5, r1	; 0x05
    5702:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 _uart_print(1,1,strSend);	 
    5706:	ed b7       	in	r30, 0x3d	; 61
    5708:	fe b7       	in	r31, 0x3e	; 62
    570a:	36 96       	adiw	r30, 0x06	; 6
    570c:	0f b6       	in	r0, 0x3f	; 63
    570e:	f8 94       	cli
    5710:	fe bf       	out	0x3e, r31	; 62
    5712:	0f be       	out	0x3f, r0	; 63
    5714:	ed bf       	out	0x3d, r30	; 61
    5716:	81 e0       	ldi	r24, 0x01	; 1
    5718:	61 e0       	ldi	r22, 0x01	; 1
    571a:	40 2f       	mov	r20, r16
    571c:	5f 2d       	mov	r21, r15
    571e:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
}
    5722:	c0 55       	subi	r28, 0x50	; 80
    5724:	df 4f       	sbci	r29, 0xFF	; 255
    5726:	0f b6       	in	r0, 0x3f	; 63
    5728:	f8 94       	cli
    572a:	de bf       	out	0x3e, r29	; 62
    572c:	0f be       	out	0x3f, r0	; 63
    572e:	cd bf       	out	0x3d, r28	; 61
    5730:	cf 91       	pop	r28
    5732:	df 91       	pop	r29
    5734:	1f 91       	pop	r17
    5736:	0f 91       	pop	r16
    5738:	ff 90       	pop	r15
    573a:	ef 90       	pop	r14
    573c:	df 90       	pop	r13
    573e:	cf 90       	pop	r12
    5740:	bf 90       	pop	r11
    5742:	af 90       	pop	r10
    5744:	9f 90       	pop	r9
    5746:	8f 90       	pop	r8
    5748:	7f 90       	pop	r7
    574a:	6f 90       	pop	r6
    574c:	5f 90       	pop	r5
    574e:	4f 90       	pop	r4
    5750:	3f 90       	pop	r3
    5752:	2f 90       	pop	r2
    5754:	08 95       	ret

00005756 <systemGeniusProtocol>:

void systemGeniusProtocol(){
static char stGeniusProtocol=gpInitScan;
static char iPumpID;
	 
	 switch(stGeniusProtocol){
    5756:	80 91 f9 01 	lds	r24, 0x01F9
    575a:	83 30       	cpi	r24, 0x03	; 3
    575c:	71 f1       	breq	.+92     	; 0x57ba <systemGeniusProtocol+0x64>
    575e:	84 30       	cpi	r24, 0x04	; 4
    5760:	28 f4       	brcc	.+10     	; 0x576c <systemGeniusProtocol+0x16>
    5762:	81 30       	cpi	r24, 0x01	; 1
    5764:	81 f0       	breq	.+32     	; 0x5786 <systemGeniusProtocol+0x30>
    5766:	82 30       	cpi	r24, 0x02	; 2
    5768:	c0 f4       	brcc	.+48     	; 0x579a <systemGeniusProtocol+0x44>
    576a:	09 c0       	rjmp	.+18     	; 0x577e <systemGeniusProtocol+0x28>
    576c:	85 30       	cpi	r24, 0x05	; 5
    576e:	09 f4       	brne	.+2      	; 0x5772 <systemGeniusProtocol+0x1c>
    5770:	49 c0       	rjmp	.+146    	; 0x5804 <systemGeniusProtocol+0xae>
    5772:	85 30       	cpi	r24, 0x05	; 5
    5774:	c0 f1       	brcs	.+112    	; 0x57e6 <systemGeniusProtocol+0x90>
    5776:	86 30       	cpi	r24, 0x06	; 6
    5778:	09 f0       	breq	.+2      	; 0x577c <systemGeniusProtocol+0x26>
    577a:	60 c0       	rjmp	.+192    	; 0x583c <systemGeniusProtocol+0xe6>
    577c:	4d c0       	rjmp	.+154    	; 0x5818 <systemGeniusProtocol+0xc2>
	 case gpInitScan:
	      iPumpID=1;
    577e:	81 e0       	ldi	r24, 0x01	; 1
    5780:	80 93 f8 01 	sts	0x01F8, r24
    5784:	46 c0       	rjmp	.+140    	; 0x5812 <systemGeniusProtocol+0xbc>
          stGeniusProtocol=gpScanNewTransaction;
	      break;
	 case gpScanNewTransaction:
	      if (GetIncomingTransStatus(PumpID)==TS_NEW){
    5786:	80 91 f3 01 	lds	r24, 0x01F3
    578a:	0e 94 9a 19 	call	0x3334	; 0x3334 <GetIncomingTransStatus>
    578e:	82 30       	cpi	r24, 0x02	; 2
    5790:	09 f0       	breq	.+2      	; 0x5794 <systemGeniusProtocol+0x3e>
    5792:	54 c0       	rjmp	.+168    	; 0x583c <systemGeniusProtocol+0xe6>
		      IsTotalizerReceived=False;
    5794:	10 92 db 01 	sts	0x01DB, r1
    5798:	3c c0       	rjmp	.+120    	; 0x5812 <systemGeniusProtocol+0xbc>
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
    579a:	90 91 f8 01 	lds	r25, 0x01F8
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    579e:	85 e0       	ldi	r24, 0x05	; 5
    57a0:	80 93 b6 07 	sts	0x07B6, r24
	 PoolMsg=plMsg;
    57a4:	90 93 de 0d 	sts	0x0DDE, r25
     IsControlPooling=True;
    57a8:	81 e0       	ldi	r24, 0x01	; 1
    57aa:	80 93 ad 01 	sts	0x01AD, r24
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
		  TimSend=0;
    57ae:	10 92 be 01 	sts	0x01BE, r1
    57b2:	10 92 bd 01 	sts	0x01BD, r1
		  stGeniusProtocol=gpWaitRequestedTotalizer;
    57b6:	83 e0       	ldi	r24, 0x03	; 3
    57b8:	2c c0       	rjmp	.+88     	; 0x5812 <systemGeniusProtocol+0xbc>
	      break;
     case gpWaitRequestedTotalizer:
	      if ((IsTotalizerReceived==True)&&(AcknoledgePump==iPumpID)){
    57ba:	80 91 db 01 	lds	r24, 0x01DB
    57be:	81 30       	cpi	r24, 0x01	; 1
    57c0:	59 f4       	brne	.+22     	; 0x57d8 <systemGeniusProtocol+0x82>
    57c2:	90 91 f7 0d 	lds	r25, 0x0DF7
    57c6:	80 91 f8 01 	lds	r24, 0x01F8
    57ca:	98 17       	cp	r25, r24
    57cc:	29 f4       	brne	.+10     	; 0x57d8 <systemGeniusProtocol+0x82>
		      IsTotalizerReceived=False;
    57ce:	10 92 db 01 	sts	0x01DB, r1
			  stGeniusProtocol=gpSendTransactionData;
    57d2:	84 e0       	ldi	r24, 0x04	; 4
    57d4:	80 93 f9 01 	sts	0x01F9, r24
		  }
	      if (TimSend>TIM_SEND)stGeniusProtocol=gpNextPumpScan;
    57d8:	80 91 bd 01 	lds	r24, 0x01BD
    57dc:	90 91 be 01 	lds	r25, 0x01BE
    57e0:	0b 97       	sbiw	r24, 0x0b	; 11
    57e2:	60 f1       	brcs	.+88     	; 0x583c <systemGeniusProtocol+0xe6>
    57e4:	15 c0       	rjmp	.+42     	; 0x5810 <systemGeniusProtocol+0xba>
	      break;
     case gpSendTransactionData:
          GeniusSendLastTransaction(iPumpID);
    57e6:	80 91 f8 01 	lds	r24, 0x01F8
    57ea:	0e 94 9b 2a 	call	0x5536	; 0x5536 <GeniusSendLastTransaction>
		  SetIncomingTransStatus(iPumpID,TS_OLD);
    57ee:	80 91 f8 01 	lds	r24, 0x01F8
    57f2:	63 e0       	ldi	r22, 0x03	; 3
    57f4:	0e 94 68 19 	call	0x32d0	; 0x32d0 <SetIncomingTransStatus>
		  
		  TimSend=0;
    57f8:	10 92 be 01 	sts	0x01BE, r1
    57fc:	10 92 bd 01 	sts	0x01BD, r1
          stGeniusProtocol=gpDelayNextPumpScan;
    5800:	85 e0       	ldi	r24, 0x05	; 5
    5802:	07 c0       	rjmp	.+14     	; 0x5812 <systemGeniusProtocol+0xbc>
	      break;
     case gpDelayNextPumpScan:
          if (TimSend>1)stGeniusProtocol=gpNextPumpScan;
    5804:	80 91 bd 01 	lds	r24, 0x01BD
    5808:	90 91 be 01 	lds	r25, 0x01BE
    580c:	02 97       	sbiw	r24, 0x02	; 2
    580e:	b0 f0       	brcs	.+44     	; 0x583c <systemGeniusProtocol+0xe6>
    5810:	86 e0       	ldi	r24, 0x06	; 6
    5812:	80 93 f9 01 	sts	0x01F9, r24
    5816:	08 95       	ret
	      break;
     case gpNextPumpScan:
          if (iPumpID<=eeprom_read_byte(&DefPoolingPumpMax)){
    5818:	20 91 f8 01 	lds	r18, 0x01F8
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    581c:	e1 99       	sbic	0x1c, 1	; 28
    581e:	fe cf       	rjmp	.-4      	; 0x581c <systemGeniusProtocol+0xc6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    5820:	84 e7       	ldi	r24, 0x74	; 116
    5822:	91 e0       	ldi	r25, 0x01	; 1
    5824:	9f bb       	out	0x1f, r25	; 31
    5826:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    5828:	e0 9a       	sbi	0x1c, 0	; 28
    582a:	8d b3       	in	r24, 0x1d	; 29
    582c:	82 17       	cp	r24, r18
    582e:	30 f0       	brcs	.+12     	; 0x583c <systemGeniusProtocol+0xe6>
		      iPumpID++;
    5830:	2f 5f       	subi	r18, 0xFF	; 255
    5832:	20 93 f8 01 	sts	0x01F8, r18
              stGeniusProtocol=gpScanNewTransaction;
    5836:	81 e0       	ldi	r24, 0x01	; 1
    5838:	80 93 f9 01 	sts	0x01F9, r24
    583c:	08 95       	ret

0000583e <AddCharLead>:
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    583e:	bf 92       	push	r11
    5840:	cf 92       	push	r12
    5842:	df 92       	push	r13
    5844:	ef 92       	push	r14
    5846:	ff 92       	push	r15
    5848:	0f 93       	push	r16
    584a:	1f 93       	push	r17
    584c:	df 93       	push	r29
    584e:	cf 93       	push	r28
    5850:	cd b7       	in	r28, 0x3d	; 61
    5852:	de b7       	in	r29, 0x3e	; 62
    5854:	6e 97       	sbiw	r28, 0x1e	; 30
    5856:	0f b6       	in	r0, 0x3f	; 63
    5858:	f8 94       	cli
    585a:	de bf       	out	0x3e, r29	; 62
    585c:	0f be       	out	0x3f, r0	; 63
    585e:	cd bf       	out	0x3d, r28	; 61
    5860:	8c 01       	movw	r16, r24
    5862:	e4 2e       	mov	r14, r20
     char i,Length,strAdded[30];
     Length=strlen(String);
    5864:	fc 01       	movw	r30, r24
    5866:	01 90       	ld	r0, Z+
    5868:	00 20       	and	r0, r0
    586a:	e9 f7       	brne	.-6      	; 0x5866 <AddCharLead+0x28>
    586c:	31 97       	sbiw	r30, 0x01	; 1
    586e:	2e 2f       	mov	r18, r30
    5870:	28 1b       	sub	r18, r24

	 if (Size>Length){
    5872:	24 17       	cp	r18, r20
    5874:	d0 f5       	brcc	.+116    	; 0x58ea <AddCharLead+0xac>
    5876:	ae 01       	movw	r20, r28
    5878:	4f 5f       	subi	r20, 0xFF	; 255
    587a:	5f 4f       	sbci	r21, 0xFF	; 255
    587c:	fa 01       	movw	r30, r20
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    587e:	b4 2e       	mov	r11, r20
    5880:	01 c0       	rjmp	.+2      	; 0x5884 <AddCharLead+0x46>
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
    5882:	61 93       	st	Z+, r22
void AddCharLead(char *String,char CharAdded,unsigned char Size){//
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    5884:	8e 2f       	mov	r24, r30
    5886:	8b 19       	sub	r24, r11
    5888:	8e 15       	cp	r24, r14
    588a:	d8 f3       	brcs	.-10     	; 0x5882 <AddCharLead+0x44>
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
    588c:	6e 2d       	mov	r22, r14
    588e:	70 e0       	ldi	r23, 0x00	; 0
    5890:	ce 01       	movw	r24, r28
    5892:	01 96       	adiw	r24, 0x01	; 1
    5894:	fc 01       	movw	r30, r24
    5896:	e6 0f       	add	r30, r22
    5898:	f7 1f       	adc	r31, r23
    589a:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    589c:	fe 2c       	mov	r15, r14
    589e:	f2 1a       	sub	r15, r18
    58a0:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    58a2:	30 e0       	ldi	r19, 0x00	; 0
    58a4:	26 1b       	sub	r18, r22
    58a6:	37 0b       	sbc	r19, r23
    58a8:	0c c0       	rjmp	.+24     	; 0x58c2 <AddCharLead+0x84>
    58aa:	ef 2d       	mov	r30, r15
    58ac:	f0 e0       	ldi	r31, 0x00	; 0
    58ae:	d6 01       	movw	r26, r12
    58b0:	ae 0f       	add	r26, r30
    58b2:	bf 1f       	adc	r27, r31
    58b4:	e0 0f       	add	r30, r16
    58b6:	f1 1f       	adc	r31, r17
    58b8:	e2 0f       	add	r30, r18
    58ba:	f3 1f       	adc	r31, r19
    58bc:	80 81       	ld	r24, Z
    58be:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    58c0:	f3 94       	inc	r15
    58c2:	fe 14       	cp	r15, r14
    58c4:	90 f3       	brcs	.-28     	; 0x58aa <AddCharLead+0x6c>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    58c6:	6c 0d       	add	r22, r12
    58c8:	7d 1d       	adc	r23, r13
    58ca:	db 01       	movw	r26, r22
    58cc:	1c 92       	st	X, r1
    58ce:	f8 01       	movw	r30, r16
    58d0:	04 c0       	rjmp	.+8      	; 0x58da <AddCharLead+0x9c>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    58d2:	da 01       	movw	r26, r20
    58d4:	8d 91       	ld	r24, X+
    58d6:	ad 01       	movw	r20, r26
    58d8:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    58da:	84 2f       	mov	r24, r20
    58dc:	8b 19       	sub	r24, r11
    58de:	8e 15       	cp	r24, r14
    58e0:	c0 f3       	brcs	.-16     	; 0x58d2 <AddCharLead+0x94>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    58e2:	0e 0d       	add	r16, r14
    58e4:	11 1d       	adc	r17, r1
    58e6:	f8 01       	movw	r30, r16
    58e8:	10 82       	st	Z, r1
	 }
}
    58ea:	6e 96       	adiw	r28, 0x1e	; 30
    58ec:	0f b6       	in	r0, 0x3f	; 63
    58ee:	f8 94       	cli
    58f0:	de bf       	out	0x3e, r29	; 62
    58f2:	0f be       	out	0x3f, r0	; 63
    58f4:	cd bf       	out	0x3d, r28	; 61
    58f6:	cf 91       	pop	r28
    58f8:	df 91       	pop	r29
    58fa:	1f 91       	pop	r17
    58fc:	0f 91       	pop	r16
    58fe:	ff 90       	pop	r15
    5900:	ef 90       	pop	r14
    5902:	df 90       	pop	r13
    5904:	cf 90       	pop	r12
    5906:	bf 90       	pop	r11
    5908:	08 95       	ret

0000590a <AddCharLag>:
    }
return Result;
}

//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
    590a:	cf 93       	push	r28
    590c:	df 93       	push	r29
    590e:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    5910:	dc 01       	movw	r26, r24
    5912:	0d 90       	ld	r0, X+
    5914:	00 20       	and	r0, r0
    5916:	e9 f7       	brne	.-6      	; 0x5912 <AddCharLag+0x8>
    5918:	11 97       	sbiw	r26, 0x01	; 1
    591a:	a8 1b       	sub	r26, r24
    591c:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    591e:	a4 17       	cp	r26, r20
    5920:	58 f4       	brcc	.+22     	; 0x5938 <AddCharLag+0x2e>
    5922:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=CharAdded;
    5924:	fe 01       	movw	r30, r28
    5926:	e8 0f       	add	r30, r24
    5928:	f1 1d       	adc	r31, r1
    592a:	60 83       	st	Z, r22
//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    592c:	8f 5f       	subi	r24, 0xFF	; 255
    592e:	84 17       	cp	r24, r20
    5930:	c8 f3       	brcs	.-14     	; 0x5924 <AddCharLag+0x1a>
	    String[i]=CharAdded;
	 }String[Size]=0;
    5932:	c4 0f       	add	r28, r20
    5934:	d1 1d       	adc	r29, r1
    5936:	18 82       	st	Y, r1
  }

}
    5938:	df 91       	pop	r29
    593a:	cf 91       	pop	r28
    593c:	08 95       	ret

0000593e <CountTotalizerSatus>:
		      Result++;		  
		  }	 
	 }
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
    593e:	cf 92       	push	r12
    5940:	df 92       	push	r13
    5942:	ef 92       	push	r14
    5944:	ff 92       	push	r15
    5946:	0f 93       	push	r16
    5948:	1f 93       	push	r17
    594a:	cf 93       	push	r28
    594c:	df 93       	push	r29
    594e:	7c 01       	movw	r14, r24
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    5950:	dc 01       	movw	r26, r24
    5952:	0d 90       	ld	r0, X+
    5954:	00 20       	and	r0, r0
    5956:	e9 f7       	brne	.-6      	; 0x5952 <CountTotalizerSatus+0x14>
    5958:	8d 01       	movw	r16, r26
    595a:	01 50       	subi	r16, 0x01	; 1
    595c:	10 40       	sbci	r17, 0x00	; 0
    595e:	08 1b       	sub	r16, r24
    5960:	19 0b       	sbc	r17, r25
    5962:	cc 24       	eor	r12, r12
    5964:	dd 24       	eor	r13, r13
    5966:	0a c0       	rjmp	.+20     	; 0x597c <CountTotalizerSatus+0x3e>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
    5968:	84 e1       	ldi	r24, 0x14	; 20
    596a:	0e 94 c2 12 	call	0x2584	; 0x2584 <GetPumpStatusLabel>
    596e:	ce 0d       	add	r28, r14
    5970:	df 1d       	adc	r29, r15
    5972:	98 81       	ld	r25, Y
    5974:	98 17       	cp	r25, r24
    5976:	09 f4       	brne	.+2      	; 0x597a <CountTotalizerSatus+0x3c>
		      Result++;		  
    5978:	d3 94       	inc	r13
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    597a:	c3 94       	inc	r12
    597c:	cc 2d       	mov	r28, r12
    597e:	d0 e0       	ldi	r29, 0x00	; 0
    5980:	c0 17       	cp	r28, r16
    5982:	d1 07       	cpc	r29, r17
    5984:	88 f3       	brcs	.-30     	; 0x5968 <CountTotalizerSatus+0x2a>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    5986:	8d 2d       	mov	r24, r13
    5988:	df 91       	pop	r29
    598a:	cf 91       	pop	r28
    598c:	1f 91       	pop	r17
    598e:	0f 91       	pop	r16
    5990:	ff 90       	pop	r15
    5992:	ef 90       	pop	r14
    5994:	df 90       	pop	r13
    5996:	cf 90       	pop	r12
    5998:	08 95       	ret

0000599a <RemoveChar>:

	 //sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	 //_uart_print(1,1,strSend);     
}

void RemoveChar(char *strSource, char cRem){
    599a:	1f 93       	push	r17
    599c:	df 93       	push	r29
    599e:	cf 93       	push	r28
    59a0:	cd b7       	in	r28, 0x3d	; 61
    59a2:	de b7       	in	r29, 0x3e	; 62
    59a4:	64 97       	sbiw	r28, 0x14	; 20
    59a6:	0f b6       	in	r0, 0x3f	; 63
    59a8:	f8 94       	cli
    59aa:	de bf       	out	0x3e, r29	; 62
    59ac:	0f be       	out	0x3f, r0	; 63
    59ae:	cd bf       	out	0x3d, r28	; 61
    59b0:	16 2f       	mov	r17, r22
    59b2:	50 e0       	ldi	r21, 0x00	; 0
    59b4:	40 e0       	ldi	r20, 0x00	; 0
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
    59b6:	be 01       	movw	r22, r28
    59b8:	6f 5f       	subi	r22, 0xFF	; 255
    59ba:	7f 4f       	sbci	r23, 0xFF	; 255
    59bc:	0c c0       	rjmp	.+24     	; 0x59d6 <RemoveChar+0x3c>

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
    59be:	28 0f       	add	r18, r24
    59c0:	39 1f       	adc	r19, r25
    59c2:	d9 01       	movw	r26, r18
    59c4:	2c 91       	ld	r18, X
    59c6:	21 17       	cp	r18, r17
    59c8:	29 f0       	breq	.+10     	; 0x59d4 <RemoveChar+0x3a>
		     sTemp[iAdd]=strSource[i];
    59ca:	fb 01       	movw	r30, r22
    59cc:	e4 0f       	add	r30, r20
    59ce:	f1 1d       	adc	r31, r1
    59d0:	20 83       	st	Z, r18
			 iAdd++;
    59d2:	4f 5f       	subi	r20, 0xFF	; 255
}

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
    59d4:	5f 5f       	subi	r21, 0xFF	; 255
    59d6:	25 2f       	mov	r18, r21
    59d8:	30 e0       	ldi	r19, 0x00	; 0
    59da:	fc 01       	movw	r30, r24
    59dc:	01 90       	ld	r0, Z+
    59de:	00 20       	and	r0, r0
    59e0:	e9 f7       	brne	.-6      	; 0x59dc <RemoveChar+0x42>
    59e2:	31 97       	sbiw	r30, 0x01	; 1
    59e4:	e8 1b       	sub	r30, r24
    59e6:	f9 0b       	sbc	r31, r25
    59e8:	2e 17       	cp	r18, r30
    59ea:	3f 07       	cpc	r19, r31
    59ec:	40 f3       	brcs	.-48     	; 0x59be <RemoveChar+0x24>
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
			 iAdd++;
          }
	 }sTemp[iAdd]=0;
    59ee:	9e 01       	movw	r18, r28
    59f0:	2f 5f       	subi	r18, 0xFF	; 255
    59f2:	3f 4f       	sbci	r19, 0xFF	; 255
    59f4:	f9 01       	movw	r30, r18
    59f6:	e4 0f       	add	r30, r20
    59f8:	f1 1d       	adc	r31, r1
    59fa:	10 82       	st	Z, r1
	 sprintf_P(strSource,PSTR("%s"),sTemp);
    59fc:	00 d0       	rcall	.+0      	; 0x59fe <RemoveChar+0x64>
    59fe:	00 d0       	rcall	.+0      	; 0x5a00 <RemoveChar+0x66>
    5a00:	00 d0       	rcall	.+0      	; 0x5a02 <RemoveChar+0x68>
    5a02:	ed b7       	in	r30, 0x3d	; 61
    5a04:	fe b7       	in	r31, 0x3e	; 62
    5a06:	31 96       	adiw	r30, 0x01	; 1
    5a08:	ad b7       	in	r26, 0x3d	; 61
    5a0a:	be b7       	in	r27, 0x3e	; 62
    5a0c:	12 96       	adiw	r26, 0x02	; 2
    5a0e:	9c 93       	st	X, r25
    5a10:	8e 93       	st	-X, r24
    5a12:	11 97       	sbiw	r26, 0x01	; 1
    5a14:	88 e1       	ldi	r24, 0x18	; 24
    5a16:	97 e1       	ldi	r25, 0x17	; 23
    5a18:	93 83       	std	Z+3, r25	; 0x03
    5a1a:	82 83       	std	Z+2, r24	; 0x02
    5a1c:	35 83       	std	Z+5, r19	; 0x05
    5a1e:	24 83       	std	Z+4, r18	; 0x04
    5a20:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    5a24:	ed b7       	in	r30, 0x3d	; 61
    5a26:	fe b7       	in	r31, 0x3e	; 62
    5a28:	36 96       	adiw	r30, 0x06	; 6
    5a2a:	0f b6       	in	r0, 0x3f	; 63
    5a2c:	f8 94       	cli
    5a2e:	fe bf       	out	0x3e, r31	; 62
    5a30:	0f be       	out	0x3f, r0	; 63
    5a32:	ed bf       	out	0x3d, r30	; 61
}
    5a34:	64 96       	adiw	r28, 0x14	; 20
    5a36:	0f b6       	in	r0, 0x3f	; 63
    5a38:	f8 94       	cli
    5a3a:	de bf       	out	0x3e, r29	; 62
    5a3c:	0f be       	out	0x3f, r0	; 63
    5a3e:	cd bf       	out	0x3d, r28	; 61
    5a40:	cf 91       	pop	r28
    5a42:	df 91       	pop	r29
    5a44:	1f 91       	pop	r17
    5a46:	08 95       	ret

00005a48 <WrapCode>:
	      break;
	 }
   return Result;
}

void WrapCode(char *strRawCode){
    5a48:	8f 92       	push	r8
    5a4a:	9f 92       	push	r9
    5a4c:	bf 92       	push	r11
    5a4e:	cf 92       	push	r12
    5a50:	df 92       	push	r13
    5a52:	ef 92       	push	r14
    5a54:	ff 92       	push	r15
    5a56:	0f 93       	push	r16
    5a58:	1f 93       	push	r17
    5a5a:	df 93       	push	r29
    5a5c:	cf 93       	push	r28
    5a5e:	cd b7       	in	r28, 0x3d	; 61
    5a60:	de b7       	in	r29, 0x3e	; 62
    5a62:	2f 97       	sbiw	r28, 0x0f	; 15
    5a64:	0f b6       	in	r0, 0x3f	; 63
    5a66:	f8 94       	cli
    5a68:	de bf       	out	0x3e, r29	; 62
    5a6a:	0f be       	out	0x3f, r0	; 63
    5a6c:	cd bf       	out	0x3d, r28	; 61
    5a6e:	6c 01       	movw	r12, r24
    5a70:	bb 24       	eor	r11, r11
    5a72:	40 e0       	ldi	r20, 0x00	; 0
    5a74:	4e 01       	movw	r8, r28
    5a76:	08 94       	sec
    5a78:	81 1c       	adc	r8, r1
    5a7a:	91 1c       	adc	r9, r1
    5a7c:	12 c0       	rjmp	.+36     	; 0x5aa2 <WrapCode+0x5a>
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
    5a7e:	86 01       	movw	r16, r12
    5a80:	0e 0d       	add	r16, r14
    5a82:	1f 1d       	adc	r17, r15
    5a84:	d8 01       	movw	r26, r16
    5a86:	6c 91       	ld	r22, X
    5a88:	60 53       	subi	r22, 0x30	; 48
    5a8a:	80 e0       	ldi	r24, 0x00	; 0
    5a8c:	0e 94 18 15 	call	0x2a30	; 0x2a30 <GeniusCalc>
    5a90:	e8 0c       	add	r14, r8
    5a92:	f9 1c       	adc	r15, r9
    5a94:	80 5d       	subi	r24, 0xD0	; 208
    5a96:	f7 01       	movw	r30, r14
    5a98:	80 83       	st	Z, r24
		  seedKey=strRawCode[i]-'0';
    5a9a:	d8 01       	movw	r26, r16
    5a9c:	4c 91       	ld	r20, X
    5a9e:	40 53       	subi	r20, 0x30	; 48
void WrapCode(char *strRawCode){
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
    5aa0:	b3 94       	inc	r11
    5aa2:	eb 2c       	mov	r14, r11
    5aa4:	ff 24       	eor	r15, r15
    5aa6:	d6 01       	movw	r26, r12
    5aa8:	0d 90       	ld	r0, X+
    5aaa:	00 20       	and	r0, r0
    5aac:	e9 f7       	brne	.-6      	; 0x5aa8 <WrapCode+0x60>
    5aae:	11 97       	sbiw	r26, 0x01	; 1
    5ab0:	ac 19       	sub	r26, r12
    5ab2:	bd 09       	sbc	r27, r13
    5ab4:	ea 16       	cp	r14, r26
    5ab6:	fb 06       	cpc	r15, r27
    5ab8:	10 f3       	brcs	.-60     	; 0x5a7e <WrapCode+0x36>
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
    5aba:	a8 0d       	add	r26, r8
    5abc:	b9 1d       	adc	r27, r9
    5abe:	1c 92       	st	X, r1
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
    5ac0:	00 d0       	rcall	.+0      	; 0x5ac2 <WrapCode+0x7a>
    5ac2:	00 d0       	rcall	.+0      	; 0x5ac4 <WrapCode+0x7c>
    5ac4:	00 d0       	rcall	.+0      	; 0x5ac6 <WrapCode+0x7e>
    5ac6:	ed b7       	in	r30, 0x3d	; 61
    5ac8:	fe b7       	in	r31, 0x3e	; 62
    5aca:	31 96       	adiw	r30, 0x01	; 1
    5acc:	ad b7       	in	r26, 0x3d	; 61
    5ace:	be b7       	in	r27, 0x3e	; 62
    5ad0:	12 96       	adiw	r26, 0x02	; 2
    5ad2:	dc 92       	st	X, r13
    5ad4:	ce 92       	st	-X, r12
    5ad6:	11 97       	sbiw	r26, 0x01	; 1
    5ad8:	83 e2       	ldi	r24, 0x23	; 35
    5ada:	97 e1       	ldi	r25, 0x17	; 23
    5adc:	93 83       	std	Z+3, r25	; 0x03
    5ade:	82 83       	std	Z+2, r24	; 0x02
    5ae0:	95 82       	std	Z+5, r9	; 0x05
    5ae2:	84 82       	std	Z+4, r8	; 0x04
    5ae4:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    5ae8:	ed b7       	in	r30, 0x3d	; 61
    5aea:	fe b7       	in	r31, 0x3e	; 62
    5aec:	36 96       	adiw	r30, 0x06	; 6
    5aee:	0f b6       	in	r0, 0x3f	; 63
    5af0:	f8 94       	cli
    5af2:	fe bf       	out	0x3e, r31	; 62
    5af4:	0f be       	out	0x3f, r0	; 63
    5af6:	ed bf       	out	0x3d, r30	; 61
}
    5af8:	2f 96       	adiw	r28, 0x0f	; 15
    5afa:	0f b6       	in	r0, 0x3f	; 63
    5afc:	f8 94       	cli
    5afe:	de bf       	out	0x3e, r29	; 62
    5b00:	0f be       	out	0x3f, r0	; 63
    5b02:	cd bf       	out	0x3d, r28	; 61
    5b04:	cf 91       	pop	r28
    5b06:	df 91       	pop	r29
    5b08:	1f 91       	pop	r17
    5b0a:	0f 91       	pop	r16
    5b0c:	ff 90       	pop	r15
    5b0e:	ef 90       	pop	r14
    5b10:	df 90       	pop	r13
    5b12:	cf 90       	pop	r12
    5b14:	bf 90       	pop	r11
    5b16:	9f 90       	pop	r9
    5b18:	8f 90       	pop	r8
    5b1a:	08 95       	ret

00005b1c <GenerateKeyStamp>:
         else Result=GC_INVALID;
	 }
   return Result;
}

void GenerateKeyStamp(char *sTime, char *sGCode, char *strKeyStamp){//
    5b1c:	8f 92       	push	r8
    5b1e:	9f 92       	push	r9
    5b20:	af 92       	push	r10
    5b22:	bf 92       	push	r11
    5b24:	df 92       	push	r13
    5b26:	ef 92       	push	r14
    5b28:	ff 92       	push	r15
    5b2a:	0f 93       	push	r16
    5b2c:	1f 93       	push	r17
    5b2e:	df 93       	push	r29
    5b30:	cf 93       	push	r28
    5b32:	cd b7       	in	r28, 0x3d	; 61
    5b34:	de b7       	in	r29, 0x3e	; 62
    5b36:	2d 97       	sbiw	r28, 0x0d	; 13
    5b38:	0f b6       	in	r0, 0x3f	; 63
    5b3a:	f8 94       	cli
    5b3c:	de bf       	out	0x3e, r29	; 62
    5b3e:	0f be       	out	0x3f, r0	; 63
    5b40:	cd bf       	out	0x3d, r28	; 61
    5b42:	9c 01       	movw	r18, r24
    5b44:	7b 01       	movw	r14, r22
    5b46:	5a 01       	movw	r10, r20
	             65585577
	 */
     char seedIdx,sSeed[10],sAdd[3],i;
     
	 seedIdx=(sTime[5]-'0')%8; 
	 sAdd[0]=sGCode[seedIdx];
    5b48:	dc 01       	movw	r26, r24
    5b4a:	15 96       	adiw	r26, 0x05	; 5
    5b4c:	8c 91       	ld	r24, X
    5b4e:	90 e0       	ldi	r25, 0x00	; 0
    5b50:	c0 97       	sbiw	r24, 0x30	; 48
    5b52:	68 e0       	ldi	r22, 0x08	; 8
    5b54:	70 e0       	ldi	r23, 0x00	; 0
    5b56:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    5b5a:	f7 01       	movw	r30, r14
    5b5c:	e8 0f       	add	r30, r24
    5b5e:	f1 1d       	adc	r31, r1
    5b60:	80 81       	ld	r24, Z
    5b62:	89 83       	std	Y+1, r24	; 0x01
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
    5b64:	f9 01       	movw	r30, r18
    5b66:	86 81       	ldd	r24, Z+6	; 0x06
    5b68:	90 e0       	ldi	r25, 0x00	; 0
    5b6a:	c0 97       	sbiw	r24, 0x30	; 48
    5b6c:	68 e0       	ldi	r22, 0x08	; 8
    5b6e:	70 e0       	ldi	r23, 0x00	; 0
    5b70:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    5b74:	f7 01       	movw	r30, r14
    5b76:	e8 0f       	add	r30, r24
    5b78:	f1 1d       	adc	r31, r1
    5b7a:	80 81       	ld	r24, Z
    5b7c:	8a 83       	std	Y+2, r24	; 0x02
	 sAdd[2]=0;
    5b7e:	1b 82       	std	Y+3, r1	; 0x03

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
    5b80:	8d b7       	in	r24, 0x3d	; 61
    5b82:	9e b7       	in	r25, 0x3e	; 62
    5b84:	08 97       	sbiw	r24, 0x08	; 8
    5b86:	0f b6       	in	r0, 0x3f	; 63
    5b88:	f8 94       	cli
    5b8a:	9e bf       	out	0x3e, r25	; 62
    5b8c:	0f be       	out	0x3f, r0	; 63
    5b8e:	8d bf       	out	0x3d, r24	; 61
    5b90:	ed b7       	in	r30, 0x3d	; 61
    5b92:	fe b7       	in	r31, 0x3e	; 62
    5b94:	31 96       	adiw	r30, 0x01	; 1
    5b96:	8e 01       	movw	r16, r28
    5b98:	0c 5f       	subi	r16, 0xFC	; 252
    5b9a:	1f 4f       	sbci	r17, 0xFF	; 255
    5b9c:	ad b7       	in	r26, 0x3d	; 61
    5b9e:	be b7       	in	r27, 0x3e	; 62
    5ba0:	12 96       	adiw	r26, 0x02	; 2
    5ba2:	1c 93       	st	X, r17
    5ba4:	0e 93       	st	-X, r16
    5ba6:	11 97       	sbiw	r26, 0x01	; 1
    5ba8:	83 e1       	ldi	r24, 0x13	; 19
    5baa:	97 e1       	ldi	r25, 0x17	; 23
    5bac:	93 83       	std	Z+3, r25	; 0x03
    5bae:	82 83       	std	Z+2, r24	; 0x02
    5bb0:	35 83       	std	Z+5, r19	; 0x05
    5bb2:	24 83       	std	Z+4, r18	; 0x04
    5bb4:	ce 01       	movw	r24, r28
    5bb6:	01 96       	adiw	r24, 0x01	; 1
    5bb8:	97 83       	std	Z+7, r25	; 0x07
    5bba:	86 83       	std	Z+6, r24	; 0x06
    5bbc:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    5bc0:	dd 24       	eor	r13, r13
    5bc2:	ed b7       	in	r30, 0x3d	; 61
    5bc4:	fe b7       	in	r31, 0x3e	; 62
    5bc6:	38 96       	adiw	r30, 0x08	; 8
    5bc8:	0f b6       	in	r0, 0x3f	; 63
    5bca:	f8 94       	cli
    5bcc:	fe bf       	out	0x3e, r31	; 62
    5bce:	0f be       	out	0x3f, r0	; 63
    5bd0:	ed bf       	out	0x3d, r30	; 61
     for(i=0;i<strlen(sGCode);i++){
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
    5bd2:	48 01       	movw	r8, r16
    5bd4:	13 c0       	rjmp	.+38     	; 0x5bfc <GenerateKeyStamp+0xe0>
    5bd6:	f4 01       	movw	r30, r8
    5bd8:	e0 0f       	add	r30, r16
    5bda:	f1 1f       	adc	r31, r17
    5bdc:	60 81       	ld	r22, Z
    5bde:	60 53       	subi	r22, 0x30	; 48
    5be0:	f7 01       	movw	r30, r14
    5be2:	e0 0f       	add	r30, r16
    5be4:	f1 1f       	adc	r31, r17
    5be6:	40 81       	ld	r20, Z
    5be8:	40 53       	subi	r20, 0x30	; 48
    5bea:	81 e0       	ldi	r24, 0x01	; 1
    5bec:	0e 94 18 15 	call	0x2a30	; 0x2a30 <GeniusCalc>
    5bf0:	0a 0d       	add	r16, r10
    5bf2:	1b 1d       	adc	r17, r11
    5bf4:	80 5d       	subi	r24, 0xD0	; 208
    5bf6:	d8 01       	movw	r26, r16
    5bf8:	8c 93       	st	X, r24
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
	 sAdd[2]=0;

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
     for(i=0;i<strlen(sGCode);i++){
    5bfa:	d3 94       	inc	r13
    5bfc:	0d 2d       	mov	r16, r13
    5bfe:	10 e0       	ldi	r17, 0x00	; 0
    5c00:	d7 01       	movw	r26, r14
    5c02:	0d 90       	ld	r0, X+
    5c04:	00 20       	and	r0, r0
    5c06:	e9 f7       	brne	.-6      	; 0x5c02 <GenerateKeyStamp+0xe6>
    5c08:	11 97       	sbiw	r26, 0x01	; 1
    5c0a:	ae 19       	sub	r26, r14
    5c0c:	bf 09       	sbc	r27, r15
    5c0e:	0a 17       	cp	r16, r26
    5c10:	1b 07       	cpc	r17, r27
    5c12:	08 f3       	brcs	.-62     	; 0x5bd6 <GenerateKeyStamp+0xba>
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
    5c14:	aa 0d       	add	r26, r10
    5c16:	bb 1d       	adc	r27, r11
    5c18:	1c 92       	st	X, r1
     WrapCode(strKeyStamp);
    5c1a:	c5 01       	movw	r24, r10
    5c1c:	0e 94 24 2d 	call	0x5a48	; 0x5a48 <WrapCode>
}
    5c20:	2d 96       	adiw	r28, 0x0d	; 13
    5c22:	0f b6       	in	r0, 0x3f	; 63
    5c24:	f8 94       	cli
    5c26:	de bf       	out	0x3e, r29	; 62
    5c28:	0f be       	out	0x3f, r0	; 63
    5c2a:	cd bf       	out	0x3d, r28	; 61
    5c2c:	cf 91       	pop	r28
    5c2e:	df 91       	pop	r29
    5c30:	1f 91       	pop	r17
    5c32:	0f 91       	pop	r16
    5c34:	ff 90       	pop	r15
    5c36:	ef 90       	pop	r14
    5c38:	df 90       	pop	r13
    5c3a:	bf 90       	pop	r11
    5c3c:	af 90       	pop	r10
    5c3e:	9f 90       	pop	r9
    5c40:	8f 90       	pop	r8
    5c42:	08 95       	ret

00005c44 <GenerateGeniusCode>:
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
}

void GenerateGeniusCode(char *srcDate, char cSeed, char *strDestCode){
    5c44:	af 92       	push	r10
    5c46:	bf 92       	push	r11
    5c48:	cf 92       	push	r12
    5c4a:	df 92       	push	r13
    5c4c:	ef 92       	push	r14
    5c4e:	ff 92       	push	r15
    5c50:	0f 93       	push	r16
    5c52:	1f 93       	push	r17
    5c54:	df 93       	push	r29
    5c56:	cf 93       	push	r28
    5c58:	cd b7       	in	r28, 0x3d	; 61
    5c5a:	de b7       	in	r29, 0x3e	; 62
    5c5c:	28 97       	sbiw	r28, 0x08	; 8
    5c5e:	0f b6       	in	r0, 0x3f	; 63
    5c60:	f8 94       	cli
    5c62:	de bf       	out	0x3e, r29	; 62
    5c64:	0f be       	out	0x3f, r0	; 63
    5c66:	cd bf       	out	0x3d, r28	; 61
    5c68:	7c 01       	movw	r14, r24
    5c6a:	c6 2e       	mov	r12, r22
    5c6c:	5a 01       	movw	r10, r20
	     WrapC ->68846545
	 */ 
	 char i,GCalcOpt,AddYear[3],SYear[5];
	 char strSend[20];

	 StrPosCopy(srcDate,AddYear,strlen(srcDate)-3,2);
    5c6e:	fc 01       	movw	r30, r24
    5c70:	01 90       	ld	r0, Z+
    5c72:	00 20       	and	r0, r0
    5c74:	e9 f7       	brne	.-6      	; 0x5c70 <GenerateGeniusCode+0x2c>
    5c76:	e8 1b       	sub	r30, r24
    5c78:	f9 0b       	sbc	r31, r25
    5c7a:	34 97       	sbiw	r30, 0x04	; 4
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    5c7c:	e8 0f       	add	r30, r24
    5c7e:	f9 1f       	adc	r31, r25
    5c80:	80 81       	ld	r24, Z
    5c82:	89 83       	std	Y+1, r24	; 0x01
    5c84:	81 81       	ldd	r24, Z+1	; 0x01
    5c86:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    5c88:	1b 82       	std	Y+3, r1	; 0x03
	 */ 
	 char i,GCalcOpt,AddYear[3],SYear[5];
	 char strSend[20];

	 StrPosCopy(srcDate,AddYear,strlen(srcDate)-3,2);
	 sprintf_P(SYear,PSTR("20%s"),AddYear);
    5c8a:	00 d0       	rcall	.+0      	; 0x5c8c <GenerateGeniusCode+0x48>
    5c8c:	00 d0       	rcall	.+0      	; 0x5c8e <GenerateGeniusCode+0x4a>
    5c8e:	00 d0       	rcall	.+0      	; 0x5c90 <GenerateGeniusCode+0x4c>
    5c90:	ed b7       	in	r30, 0x3d	; 61
    5c92:	fe b7       	in	r31, 0x3e	; 62
    5c94:	31 96       	adiw	r30, 0x01	; 1
    5c96:	8e 01       	movw	r16, r28
    5c98:	0c 5f       	subi	r16, 0xFC	; 252
    5c9a:	1f 4f       	sbci	r17, 0xFF	; 255
    5c9c:	ad b7       	in	r26, 0x3d	; 61
    5c9e:	be b7       	in	r27, 0x3e	; 62
    5ca0:	12 96       	adiw	r26, 0x02	; 2
    5ca2:	1c 93       	st	X, r17
    5ca4:	0e 93       	st	-X, r16
    5ca6:	11 97       	sbiw	r26, 0x01	; 1
    5ca8:	8e e1       	ldi	r24, 0x1E	; 30
    5caa:	97 e1       	ldi	r25, 0x17	; 23
    5cac:	93 83       	std	Z+3, r25	; 0x03
    5cae:	82 83       	std	Z+2, r24	; 0x02
    5cb0:	ce 01       	movw	r24, r28
    5cb2:	01 96       	adiw	r24, 0x01	; 1
    5cb4:	95 83       	std	Z+5, r25	; 0x05
    5cb6:	84 83       	std	Z+4, r24	; 0x04
    5cb8:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 StrPosPaste(SYear,srcDate,strlen(srcDate)-2,strlen(SYear));
    5cbc:	d7 01       	movw	r26, r14
    5cbe:	0d 90       	ld	r0, X+
    5cc0:	00 20       	and	r0, r0
    5cc2:	e9 f7       	brne	.-6      	; 0x5cbe <GenerateGeniusCode+0x7a>
    5cc4:	9d 01       	movw	r18, r26
    5cc6:	21 50       	subi	r18, 0x01	; 1
    5cc8:	30 40       	sbci	r19, 0x00	; 0
    5cca:	2e 19       	sub	r18, r14
    5ccc:	3f 09       	sbc	r19, r15
    5cce:	d8 01       	movw	r26, r16
    5cd0:	0d 90       	ld	r0, X+
    5cd2:	00 20       	and	r0, r0
    5cd4:	e9 f7       	brne	.-6      	; 0x5cd0 <GenerateGeniusCode+0x8c>
    5cd6:	11 97       	sbiw	r26, 0x01	; 1
    5cd8:	a0 1b       	sub	r26, r16
    5cda:	b1 0b       	sbc	r27, r17
    5cdc:	22 50       	subi	r18, 0x02	; 2
    5cde:	30 40       	sbci	r19, 0x00	; 0
    5ce0:	b7 01       	movw	r22, r14
    5ce2:	62 0f       	add	r22, r18
    5ce4:	73 1f       	adc	r23, r19
    5ce6:	2e 5f       	subi	r18, 0xFE	; 254
    5ce8:	3f 4f       	sbci	r19, 0xFF	; 255
    5cea:	40 e0       	ldi	r20, 0x00	; 0
    5cec:	50 e0       	ldi	r21, 0x00	; 0
    5cee:	ed b7       	in	r30, 0x3d	; 61
    5cf0:	fe b7       	in	r31, 0x3e	; 62
    5cf2:	36 96       	adiw	r30, 0x06	; 6
    5cf4:	0f b6       	in	r0, 0x3f	; 63
    5cf6:	f8 94       	cli
    5cf8:	fe bf       	out	0x3e, r31	; 62
    5cfa:	0f be       	out	0x3f, r0	; 63
    5cfc:	ed bf       	out	0x3d, r30	; 61
    5cfe:	09 c0       	rjmp	.+18     	; 0x5d12 <GenerateGeniusCode+0xce>
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    5d00:	f8 01       	movw	r30, r16
    5d02:	e4 0f       	add	r30, r20
    5d04:	f5 1f       	adc	r31, r21
    5d06:	80 81       	ld	r24, Z
    5d08:	fb 01       	movw	r30, r22
    5d0a:	81 93       	st	Z+, r24
    5d0c:	bf 01       	movw	r22, r30
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5d0e:	4f 5f       	subi	r20, 0xFF	; 255
    5d10:	5f 4f       	sbci	r21, 0xFF	; 255
    5d12:	4a 17       	cp	r20, r26
    5d14:	5b 07       	cpc	r21, r27
    5d16:	a0 f3       	brcs	.-24     	; 0x5d00 <GenerateGeniusCode+0xbc>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    5d18:	ae 0d       	add	r26, r14
    5d1a:	bf 1d       	adc	r27, r15
    5d1c:	a2 0f       	add	r26, r18
    5d1e:	b3 1f       	adc	r27, r19
    5d20:	12 97       	sbiw	r26, 0x02	; 2
    5d22:	1c 92       	st	X, r1
	 StrPosPaste(SYear,srcDate,strlen(srcDate)-2,strlen(SYear));

	 //sprintf_P(strSend,PSTR("[%s]"),srcDate);
	 //_uart_print(1,1,strSend);

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
    5d24:	00 d0       	rcall	.+0      	; 0x5d26 <GenerateGeniusCode+0xe2>
    5d26:	00 d0       	rcall	.+0      	; 0x5d28 <GenerateGeniusCode+0xe4>
    5d28:	00 d0       	rcall	.+0      	; 0x5d2a <GenerateGeniusCode+0xe6>
    5d2a:	ed b7       	in	r30, 0x3d	; 61
    5d2c:	fe b7       	in	r31, 0x3e	; 62
    5d2e:	31 96       	adiw	r30, 0x01	; 1
    5d30:	ad b7       	in	r26, 0x3d	; 61
    5d32:	be b7       	in	r27, 0x3e	; 62
    5d34:	12 96       	adiw	r26, 0x02	; 2
    5d36:	bc 92       	st	X, r11
    5d38:	ae 92       	st	-X, r10
    5d3a:	11 97       	sbiw	r26, 0x01	; 1
    5d3c:	8b e1       	ldi	r24, 0x1B	; 27
    5d3e:	97 e1       	ldi	r25, 0x17	; 23
    5d40:	93 83       	std	Z+3, r25	; 0x03
    5d42:	82 83       	std	Z+2, r24	; 0x02
    5d44:	c4 82       	std	Z+4, r12	; 0x04
    5d46:	15 82       	std	Z+5, r1	; 0x05
    5d48:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    5d4c:	dd 24       	eor	r13, r13
    5d4e:	d3 94       	inc	r13
    5d50:	ed b7       	in	r30, 0x3d	; 61
    5d52:	fe b7       	in	r31, 0x3e	; 62
    5d54:	36 96       	adiw	r30, 0x06	; 6
    5d56:	0f b6       	in	r0, 0x3f	; 63
    5d58:	f8 94       	cli
    5d5a:	fe bf       	out	0x3e, r31	; 62
    5d5c:	0f be       	out	0x3f, r0	; 63
    5d5e:	ed bf       	out	0x3d, r30	; 61
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
    5d60:	f0 ed       	ldi	r31, 0xD0	; 208
    5d62:	cf 0e       	add	r12, r31
    5d64:	0f c0       	rjmp	.+30     	; 0x5d84 <GenerateGeniusCode+0x140>
    5d66:	f7 01       	movw	r30, r14
    5d68:	e0 0f       	add	r30, r16
    5d6a:	f1 1f       	adc	r31, r17
    5d6c:	40 81       	ld	r20, Z
    5d6e:	40 53       	subi	r20, 0x30	; 48
    5d70:	80 e0       	ldi	r24, 0x00	; 0
    5d72:	6c 2d       	mov	r22, r12
    5d74:	0e 94 18 15 	call	0x2a30	; 0x2a30 <GeniusCalc>
    5d78:	0a 0d       	add	r16, r10
    5d7a:	1b 1d       	adc	r17, r11
    5d7c:	80 5d       	subi	r24, 0xD0	; 208
    5d7e:	d8 01       	movw	r26, r16
    5d80:	8c 93       	st	X, r24
	 //sprintf_P(strSend,PSTR("[%s]"),srcDate);
	 //_uart_print(1,1,strSend);

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
    5d82:	d3 94       	inc	r13
    5d84:	0d 2d       	mov	r16, r13
    5d86:	10 e0       	ldi	r17, 0x00	; 0
    5d88:	d7 01       	movw	r26, r14
    5d8a:	0d 90       	ld	r0, X+
    5d8c:	00 20       	and	r0, r0
    5d8e:	e9 f7       	brne	.-6      	; 0x5d8a <GenerateGeniusCode+0x146>
    5d90:	11 97       	sbiw	r26, 0x01	; 1
    5d92:	ae 19       	sub	r26, r14
    5d94:	bf 09       	sbc	r27, r15
    5d96:	0a 17       	cp	r16, r26
    5d98:	1b 07       	cpc	r17, r27
    5d9a:	28 f3       	brcs	.-54     	; 0x5d66 <GenerateGeniusCode+0x122>
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
	 }strDestCode[strlen(srcDate)]=0;
    5d9c:	aa 0d       	add	r26, r10
    5d9e:	bb 1d       	adc	r27, r11
    5da0:	1c 92       	st	X, r1

     //sprintf_P(strSend,PSTR("1st:%s"),strDestCode);
	 //_uart_print(1,1,strSend);     

	 WrapCode(strDestCode);
    5da2:	c5 01       	movw	r24, r10
    5da4:	0e 94 24 2d 	call	0x5a48	; 0x5a48 <WrapCode>

	 //sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	 //_uart_print(1,1,strSend);     
}
    5da8:	28 96       	adiw	r28, 0x08	; 8
    5daa:	0f b6       	in	r0, 0x3f	; 63
    5dac:	f8 94       	cli
    5dae:	de bf       	out	0x3e, r29	; 62
    5db0:	0f be       	out	0x3f, r0	; 63
    5db2:	cd bf       	out	0x3d, r28	; 61
    5db4:	cf 91       	pop	r28
    5db6:	df 91       	pop	r29
    5db8:	1f 91       	pop	r17
    5dba:	0f 91       	pop	r16
    5dbc:	ff 90       	pop	r15
    5dbe:	ef 90       	pop	r14
    5dc0:	df 90       	pop	r13
    5dc2:	cf 90       	pop	r12
    5dc4:	bf 90       	pop	r11
    5dc6:	af 90       	pop	r10
    5dc8:	08 95       	ret

00005dca <GeneratePrintInit>:
	IsBusyMsg11=True;
}



void GeneratePrintInit(){//Create Initialize Print 
    5dca:	cf 92       	push	r12
    5dcc:	df 92       	push	r13
    5dce:	ef 92       	push	r14
    5dd0:	ff 92       	push	r15
    5dd2:	0f 93       	push	r16
    5dd4:	1f 93       	push	r17
    5dd6:	df 93       	push	r29
    5dd8:	cf 93       	push	r28
    5dda:	cd b7       	in	r28, 0x3d	; 61
    5ddc:	de b7       	in	r29, 0x3e	; 62
    5dde:	62 97       	sbiw	r28, 0x12	; 18
    5de0:	0f b6       	in	r0, 0x3f	; 63
    5de2:	f8 94       	cli
    5de4:	de bf       	out	0x3e, r29	; 62
    5de6:	0f be       	out	0x3f, r0	; 63
    5de8:	cd bf       	out	0x3d, r28	; 61
     char strVernum[6],strVerdate[12];
	 sprintf_P(strVernum,PSTR(VERSION_NUM));
    5dea:	00 d0       	rcall	.+0      	; 0x5dec <GeneratePrintInit+0x22>
    5dec:	00 d0       	rcall	.+0      	; 0x5dee <GeneratePrintInit+0x24>
    5dee:	6e 01       	movw	r12, r28
    5df0:	08 94       	sec
    5df2:	c1 1c       	adc	r12, r1
    5df4:	d1 1c       	adc	r13, r1
    5df6:	ad b7       	in	r26, 0x3d	; 61
    5df8:	be b7       	in	r27, 0x3e	; 62
    5dfa:	12 96       	adiw	r26, 0x02	; 2
    5dfc:	dc 92       	st	X, r13
    5dfe:	ce 92       	st	-X, r12
    5e00:	11 97       	sbiw	r26, 0x01	; 1
    5e02:	8e ea       	ldi	r24, 0xAE	; 174
    5e04:	9c e1       	ldi	r25, 0x1C	; 28
    5e06:	14 96       	adiw	r26, 0x04	; 4
    5e08:	9c 93       	st	X, r25
    5e0a:	8e 93       	st	-X, r24
    5e0c:	13 97       	sbiw	r26, 0x03	; 3
    5e0e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 sprintf_P(strVerdate,PSTR(VERSION_DATE));
    5e12:	97 e0       	ldi	r25, 0x07	; 7
    5e14:	e9 2e       	mov	r14, r25
    5e16:	f1 2c       	mov	r15, r1
    5e18:	ec 0e       	add	r14, r28
    5e1a:	fd 1e       	adc	r15, r29
    5e1c:	ed b7       	in	r30, 0x3d	; 61
    5e1e:	fe b7       	in	r31, 0x3e	; 62
    5e20:	f2 82       	std	Z+2, r15	; 0x02
    5e22:	e1 82       	std	Z+1, r14	; 0x01
    5e24:	83 ea       	ldi	r24, 0xA3	; 163
    5e26:	9c e1       	ldi	r25, 0x1C	; 28
    5e28:	94 83       	std	Z+4, r25	; 0x04
    5e2a:	83 83       	std	Z+3, r24	; 0x03
    5e2c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
     sprintf_P(PrintBuffer,PSTR("\nGeNiUs Ticket Printer \n Version:%s\n Last Update %s \n Hanindo Automation Solutions \n www.hanindogroup.com\n\n\n\n\n\n\n\n"),strVernum,strVerdate);
    5e30:	00 d0       	rcall	.+0      	; 0x5e32 <GeneratePrintInit+0x68>
    5e32:	00 d0       	rcall	.+0      	; 0x5e34 <GeneratePrintInit+0x6a>
    5e34:	ed b7       	in	r30, 0x3d	; 61
    5e36:	fe b7       	in	r31, 0x3e	; 62
    5e38:	31 96       	adiw	r30, 0x01	; 1
    5e3a:	07 ef       	ldi	r16, 0xF7	; 247
    5e3c:	15 e0       	ldi	r17, 0x05	; 5
    5e3e:	ad b7       	in	r26, 0x3d	; 61
    5e40:	be b7       	in	r27, 0x3e	; 62
    5e42:	12 96       	adiw	r26, 0x02	; 2
    5e44:	1c 93       	st	X, r17
    5e46:	0e 93       	st	-X, r16
    5e48:	11 97       	sbiw	r26, 0x01	; 1
    5e4a:	81 e3       	ldi	r24, 0x31	; 49
    5e4c:	9c e1       	ldi	r25, 0x1C	; 28
    5e4e:	93 83       	std	Z+3, r25	; 0x03
    5e50:	82 83       	std	Z+2, r24	; 0x02
    5e52:	d5 82       	std	Z+5, r13	; 0x05
    5e54:	c4 82       	std	Z+4, r12	; 0x04
    5e56:	f7 82       	std	Z+7, r15	; 0x07
    5e58:	e6 82       	std	Z+6, r14	; 0x06
    5e5a:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 _uart_print(0,1,PrintBuffer);
    5e5e:	ed b7       	in	r30, 0x3d	; 61
    5e60:	fe b7       	in	r31, 0x3e	; 62
    5e62:	38 96       	adiw	r30, 0x08	; 8
    5e64:	0f b6       	in	r0, 0x3f	; 63
    5e66:	f8 94       	cli
    5e68:	fe bf       	out	0x3e, r31	; 62
    5e6a:	0f be       	out	0x3f, r0	; 63
    5e6c:	ed bf       	out	0x3d, r30	; 61
    5e6e:	80 e0       	ldi	r24, 0x00	; 0
    5e70:	61 e0       	ldi	r22, 0x01	; 1
    5e72:	a8 01       	movw	r20, r16
    5e74:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	 LengthMessage81=strlen(PrintBuffer);
    5e78:	f8 01       	movw	r30, r16
    5e7a:	01 90       	ld	r0, Z+
    5e7c:	00 20       	and	r0, r0
    5e7e:	e9 f7       	brne	.-6      	; 0x5e7a <GeneratePrintInit+0xb0>
    5e80:	31 97       	sbiw	r30, 0x01	; 1
    5e82:	e0 1b       	sub	r30, r16
    5e84:	f1 0b       	sbc	r31, r17
    5e86:	f0 93 b6 01 	sts	0x01B6, r31
    5e8a:	e0 93 b5 01 	sts	0x01B5, r30
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    5e8e:	80 e3       	ldi	r24, 0x30	; 48
    5e90:	80 93 e0 01 	sts	0x01E0, r24
	 IsFreePrinting=True;
    5e94:	81 e0       	ldi	r24, 0x01	; 1
    5e96:	80 93 d5 01 	sts	0x01D5, r24
}
    5e9a:	62 96       	adiw	r28, 0x12	; 18
    5e9c:	0f b6       	in	r0, 0x3f	; 63
    5e9e:	f8 94       	cli
    5ea0:	de bf       	out	0x3e, r29	; 62
    5ea2:	0f be       	out	0x3f, r0	; 63
    5ea4:	cd bf       	out	0x3d, r28	; 61
    5ea6:	cf 91       	pop	r28
    5ea8:	df 91       	pop	r29
    5eaa:	1f 91       	pop	r17
    5eac:	0f 91       	pop	r16
    5eae:	ff 90       	pop	r15
    5eb0:	ef 90       	pop	r14
    5eb2:	df 90       	pop	r13
    5eb4:	cf 90       	pop	r12
    5eb6:	08 95       	ret

00005eb8 <FormatCurrency>:
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}


void FormatCurrency(char *strCurrency){// 5000000.00 5,000,000.00
    5eb8:	9f 92       	push	r9
    5eba:	af 92       	push	r10
    5ebc:	bf 92       	push	r11
    5ebe:	cf 92       	push	r12
    5ec0:	df 92       	push	r13
    5ec2:	ef 92       	push	r14
    5ec4:	ff 92       	push	r15
    5ec6:	0f 93       	push	r16
    5ec8:	1f 93       	push	r17
    5eca:	df 93       	push	r29
    5ecc:	cf 93       	push	r28
    5ece:	cd b7       	in	r28, 0x3d	; 61
    5ed0:	de b7       	in	r29, 0x3e	; 62
    5ed2:	64 97       	sbiw	r28, 0x14	; 20
    5ed4:	0f b6       	in	r0, 0x3f	; 63
    5ed6:	f8 94       	cli
    5ed8:	de bf       	out	0x3e, r29	; 62
    5eda:	0f be       	out	0x3f, r0	; 63
    5edc:	cd bf       	out	0x3d, r28	; 61
    5ede:	6c 01       	movw	r12, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    5ee0:	e1 99       	sbic	0x1c, 1	; 28
    5ee2:	fe cf       	rjmp	.-4      	; 0x5ee0 <FormatCurrency+0x28>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    5ee4:	8f e3       	ldi	r24, 0x3F	; 63
    5ee6:	90 e0       	ldi	r25, 0x00	; 0
    5ee8:	9f bb       	out	0x1f, r25	; 31
    5eea:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    5eec:	e0 9a       	sbi	0x1c, 0	; 28
    5eee:	9d b2       	in	r9, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    5ef0:	e1 99       	sbic	0x1c, 1	; 28
    5ef2:	fe cf       	rjmp	.-4      	; 0x5ef0 <FormatCurrency+0x38>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    5ef4:	8e e3       	ldi	r24, 0x3E	; 62
    5ef6:	90 e0       	ldi	r25, 0x00	; 0
    5ef8:	9f bb       	out	0x1f, r25	; 31
    5efa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    5efc:	e0 9a       	sbi	0x1c, 0	; 28
    5efe:	3d b3       	in	r19, 0x1d	; 29
	 char CurrencyMark,DecimalMark;

	 CurrencyMark=eeprom_read_byte(&DefCurrencyMark);
	 DecimalMark=eeprom_read_byte(&DefDecimalMark);

	 Length=strlen(strCurrency);//123,456
    5f00:	f6 01       	movw	r30, r12
    5f02:	01 90       	ld	r0, Z+
    5f04:	00 20       	and	r0, r0
    5f06:	e9 f7       	brne	.-6      	; 0x5f02 <FormatCurrency+0x4a>
    5f08:	31 97       	sbiw	r30, 0x01	; 1
    5f0a:	ee 2e       	mov	r14, r30
    5f0c:	ec 18       	sub	r14, r12
    5f0e:	fe 01       	movw	r30, r28
    5f10:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5f12:	ce 01       	movw	r24, r28
    5f14:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    5f16:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5f18:	e8 17       	cp	r30, r24
    5f1a:	f9 07       	cpc	r31, r25
    5f1c:	e1 f7       	brne	.-8      	; 0x5f16 <FormatCurrency+0x5e>
    5f1e:	f6 01       	movw	r30, r12
    5f20:	fe 2c       	mov	r15, r14
    5f22:	80 e0       	ldi	r24, 0x00	; 0
    5f24:	20 e0       	ldi	r18, 0x00	; 0
    5f26:	09 c0       	rjmp	.+18     	; 0x5f3a <FormatCurrency+0x82>
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
    5f28:	90 81       	ld	r25, Z
    5f2a:	93 17       	cp	r25, r19
    5f2c:	09 f4       	brne	.+2      	; 0x5f30 <FormatCurrency+0x78>
    5f2e:	f8 2e       	mov	r15, r24
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
    5f30:	99 15       	cp	r25, r9
    5f32:	09 f4       	brne	.+2      	; 0x5f36 <FormatCurrency+0x7e>
    5f34:	2f 5f       	subi	r18, 0xFF	; 255
	 Length=strlen(strCurrency);//123,456
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
    5f36:	8f 5f       	subi	r24, 0xFF	; 255
    5f38:	31 96       	adiw	r30, 0x01	; 1
    5f3a:	8e 15       	cp	r24, r14
    5f3c:	a8 f3       	brcs	.-22     	; 0x5f28 <FormatCurrency+0x70>
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
    5f3e:	22 23       	and	r18, r18
    5f40:	09 f0       	breq	.+2      	; 0x5f44 <FormatCurrency+0x8c>
    5f42:	5e c0       	rjmp	.+188    	; 0x6000 <FormatCurrency+0x148>
    5f44:	83 e0       	ldi	r24, 0x03	; 3
    5f46:	8f 15       	cp	r24, r15
    5f48:	08 f0       	brcs	.+2      	; 0x5f4c <FormatCurrency+0x94>
    5f4a:	5a c0       	rjmp	.+180    	; 0x6000 <FormatCurrency+0x148>
    5f4c:	40 e0       	ldi	r20, 0x00	; 0
    5f4e:	20 e0       	ldi	r18, 0x00	; 0
    5f50:	30 e0       	ldi	r19, 0x00	; 0
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    5f52:	af 2c       	mov	r10, r15
    5f54:	bb 24       	eor	r11, r11
		        fmtCurrency[iPos]=CurrencyMark;
    5f56:	8e 01       	movw	r16, r28
    5f58:	0f 5f       	subi	r16, 0xFF	; 255
    5f5a:	1f 4f       	sbci	r17, 0xFF	; 255
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    5f5c:	c5 01       	movw	r24, r10
    5f5e:	82 1b       	sub	r24, r18
    5f60:	93 0b       	sbc	r25, r19
    5f62:	63 e0       	ldi	r22, 0x03	; 3
    5f64:	70 e0       	ldi	r23, 0x00	; 0
    5f66:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    5f6a:	89 2b       	or	r24, r25
    5f6c:	49 f4       	brne	.+18     	; 0x5f80 <FormatCurrency+0xc8>
    5f6e:	2f 15       	cp	r18, r15
    5f70:	38 f4       	brcc	.+14     	; 0x5f80 <FormatCurrency+0xc8>
    5f72:	22 23       	and	r18, r18
    5f74:	29 f0       	breq	.+10     	; 0x5f80 <FormatCurrency+0xc8>
		        fmtCurrency[iPos]=CurrencyMark;
    5f76:	f8 01       	movw	r30, r16
    5f78:	e4 0f       	add	r30, r20
    5f7a:	f1 1d       	adc	r31, r1
    5f7c:	90 82       	st	Z, r9
		        iPos++;
    5f7e:	4f 5f       	subi	r20, 0xFF	; 255
		        }
		        fmtCurrency[iPos]=strCurrency[i];
    5f80:	d8 01       	movw	r26, r16
    5f82:	a4 0f       	add	r26, r20
    5f84:	b1 1d       	adc	r27, r1
    5f86:	f6 01       	movw	r30, r12
    5f88:	e2 0f       	add	r30, r18
    5f8a:	f3 1f       	adc	r31, r19
    5f8c:	80 81       	ld	r24, Z
    5f8e:	8c 93       	st	X, r24
			    iPos++;
    5f90:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    5f92:	f8 01       	movw	r30, r16
    5f94:	e4 0f       	add	r30, r20
    5f96:	f1 1d       	adc	r31, r1
    5f98:	10 82       	st	Z, r1
    5f9a:	2f 5f       	subi	r18, 0xFF	; 255
    5f9c:	3f 4f       	sbci	r19, 0xFF	; 255
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
    5f9e:	2f 15       	cp	r18, r15
    5fa0:	e8 f2       	brcs	.-70     	; 0x5f5c <FormatCurrency+0xa4>
    5fa2:	9f 2d       	mov	r25, r15
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
    5fa4:	9e 01       	movw	r18, r28
    5fa6:	2f 5f       	subi	r18, 0xFF	; 255
    5fa8:	3f 4f       	sbci	r19, 0xFF	; 255
    5faa:	0e c0       	rjmp	.+28     	; 0x5fc8 <FormatCurrency+0x110>
    5fac:	d9 01       	movw	r26, r18
    5fae:	a4 0f       	add	r26, r20
    5fb0:	b1 1d       	adc	r27, r1
    5fb2:	f6 01       	movw	r30, r12
    5fb4:	e9 0f       	add	r30, r25
    5fb6:	f1 1d       	adc	r31, r1
    5fb8:	80 81       	ld	r24, Z
    5fba:	8c 93       	st	X, r24
			    iPos++;
    5fbc:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    5fbe:	f9 01       	movw	r30, r18
    5fc0:	e4 0f       	add	r30, r20
    5fc2:	f1 1d       	adc	r31, r1
    5fc4:	10 82       	st	Z, r1
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
    5fc6:	9f 5f       	subi	r25, 0xFF	; 255
    5fc8:	9e 15       	cp	r25, r14
    5fca:	80 f3       	brcs	.-32     	; 0x5fac <FormatCurrency+0xf4>
    5fcc:	90 e0       	ldi	r25, 0x00	; 0
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    5fce:	9e 01       	movw	r18, r28
    5fd0:	2f 5f       	subi	r18, 0xFF	; 255
    5fd2:	3f 4f       	sbci	r19, 0xFF	; 255
    5fd4:	09 c0       	rjmp	.+18     	; 0x5fe8 <FormatCurrency+0x130>
	          strCurrency[i]=fmtCurrency[i];
    5fd6:	f6 01       	movw	r30, r12
    5fd8:	ea 0f       	add	r30, r26
    5fda:	fb 1f       	adc	r31, r27
    5fdc:	a2 0f       	add	r26, r18
    5fde:	b3 1f       	adc	r27, r19
    5fe0:	8c 91       	ld	r24, X
    5fe2:	80 83       	st	Z, r24
			  strCurrency[i+1]=0;
    5fe4:	11 82       	std	Z+1, r1	; 0x01
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    5fe6:	9f 5f       	subi	r25, 0xFF	; 255
    5fe8:	a9 2f       	mov	r26, r25
    5fea:	b0 e0       	ldi	r27, 0x00	; 0
    5fec:	f9 01       	movw	r30, r18
    5fee:	01 90       	ld	r0, Z+
    5ff0:	00 20       	and	r0, r0
    5ff2:	e9 f7       	brne	.-6      	; 0x5fee <FormatCurrency+0x136>
    5ff4:	31 97       	sbiw	r30, 0x01	; 1
    5ff6:	e2 1b       	sub	r30, r18
    5ff8:	f3 0b       	sbc	r31, r19
    5ffa:	ae 17       	cp	r26, r30
    5ffc:	bf 07       	cpc	r27, r31
    5ffe:	58 f3       	brcs	.-42     	; 0x5fd6 <FormatCurrency+0x11e>
	          strCurrency[i]=fmtCurrency[i];
			  strCurrency[i+1]=0;
	      }
     }      
}
    6000:	64 96       	adiw	r28, 0x14	; 20
    6002:	0f b6       	in	r0, 0x3f	; 63
    6004:	f8 94       	cli
    6006:	de bf       	out	0x3e, r29	; 62
    6008:	0f be       	out	0x3f, r0	; 63
    600a:	cd bf       	out	0x3d, r28	; 61
    600c:	cf 91       	pop	r28
    600e:	df 91       	pop	r29
    6010:	1f 91       	pop	r17
    6012:	0f 91       	pop	r16
    6014:	ff 90       	pop	r15
    6016:	ef 90       	pop	r14
    6018:	df 90       	pop	r13
    601a:	cf 90       	pop	r12
    601c:	bf 90       	pop	r11
    601e:	af 90       	pop	r10
    6020:	9f 90       	pop	r9
    6022:	08 95       	ret

00006024 <FormatDecimal>:

void TestLocalAccount(){

}

void FormatDecimal(char *strRawData, char DecimalCfg){// 9-> 0,009 0,234
    6024:	ef 92       	push	r14
    6026:	ff 92       	push	r15
    6028:	0f 93       	push	r16
    602a:	1f 93       	push	r17
    602c:	df 93       	push	r29
    602e:	cf 93       	push	r28
    6030:	cd b7       	in	r28, 0x3d	; 61
    6032:	de b7       	in	r29, 0x3e	; 62
    6034:	64 97       	sbiw	r28, 0x14	; 20
    6036:	0f b6       	in	r0, 0x3f	; 63
    6038:	f8 94       	cli
    603a:	de bf       	out	0x3e, r29	; 62
    603c:	0f be       	out	0x3f, r0	; 63
    603e:	cd bf       	out	0x3d, r28	; 61
    6040:	8c 01       	movw	r16, r24
    6042:	f6 2e       	mov	r15, r22
     char i,iPos,CommaPos,Length=0;                 //1->0,01 
	 char strDecimalFormated[20];
	 char DecPointMark;
     if (DecimalCfg>0){    
    6044:	66 23       	and	r22, r22
    6046:	09 f4       	brne	.+2      	; 0x604a <FormatDecimal+0x26>
    6048:	59 c0       	rjmp	.+178    	; 0x60fc <FormatDecimal+0xd8>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    604a:	e1 99       	sbic	0x1c, 1	; 28
    604c:	fe cf       	rjmp	.-4      	; 0x604a <FormatDecimal+0x26>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    604e:	8e e3       	ldi	r24, 0x3E	; 62
    6050:	90 e0       	ldi	r25, 0x00	; 0
    6052:	9f bb       	out	0x1f, r25	; 31
    6054:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6056:	e0 9a       	sbi	0x1c, 0	; 28
    6058:	ed b2       	in	r14, 0x1d	; 29
		 DecPointMark=eeprom_read_byte(&DefDecimalMark);	 
		 Length=strlen(strRawData);
    605a:	f8 01       	movw	r30, r16
    605c:	01 90       	ld	r0, Z+
    605e:	00 20       	and	r0, r0
    6060:	e9 f7       	brne	.-6      	; 0x605c <FormatDecimal+0x38>
    6062:	31 97       	sbiw	r30, 0x01	; 1
    6064:	3e 2f       	mov	r19, r30
    6066:	30 1b       	sub	r19, r16
		 if (Length<=DecimalCfg){ 
    6068:	f3 16       	cp	r15, r19
    606a:	88 f0       	brcs	.+34     	; 0x608e <FormatDecimal+0x6a>
			 AddZeroLead(strRawData,(DecimalCfg+1));
    606c:	6f 2d       	mov	r22, r15
    606e:	6f 5f       	subi	r22, 0xFF	; 255
    6070:	c8 01       	movw	r24, r16
    6072:	0e 94 ab 24 	call	0x4956	; 0x4956 <AddZeroLead>
			 Length=strlen(strRawData);
    6076:	f8 01       	movw	r30, r16
    6078:	01 90       	ld	r0, Z+
    607a:	00 20       	and	r0, r0
    607c:	e9 f7       	brne	.-6      	; 0x6078 <FormatDecimal+0x54>
    607e:	31 97       	sbiw	r30, 0x01	; 1
    6080:	3e 2f       	mov	r19, r30
    6082:	30 1b       	sub	r19, r16
			 }

		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
    6084:	f3 16       	cp	r15, r19
    6086:	18 f0       	brcs	.+6      	; 0x608e <FormatDecimal+0x6a>
    6088:	ff 24       	eor	r15, r15
    608a:	f3 94       	inc	r15
    608c:	03 c0       	rjmp	.+6      	; 0x6094 <FormatDecimal+0x70>
    608e:	83 2f       	mov	r24, r19
    6090:	8f 19       	sub	r24, r15
    6092:	f8 2e       	mov	r15, r24
    6094:	b8 01       	movw	r22, r16
    6096:	d8 01       	movw	r26, r16
    6098:	20 e0       	ldi	r18, 0x00	; 0
    609a:	90 e0       	ldi	r25, 0x00	; 0
		 else CommaPos=1;
		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
				 strDecimalFormated[iPos]=DecPointMark;
    609c:	ae 01       	movw	r20, r28
    609e:	4f 5f       	subi	r20, 0xFF	; 255
    60a0:	5f 4f       	sbci	r21, 0xFF	; 255
    60a2:	0e c0       	rjmp	.+28     	; 0x60c0 <FormatDecimal+0x9c>
		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
		 else CommaPos=1;
		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
    60a4:	2f 15       	cp	r18, r15
    60a6:	29 f4       	brne	.+10     	; 0x60b2 <FormatDecimal+0x8e>
				 strDecimalFormated[iPos]=DecPointMark;
    60a8:	fa 01       	movw	r30, r20
    60aa:	e9 0f       	add	r30, r25
    60ac:	f1 1d       	adc	r31, r1
    60ae:	e0 82       	st	Z, r14
				 iPos++;
    60b0:	9f 5f       	subi	r25, 0xFF	; 255
			 }
			strDecimalFormated[iPos]=strRawData[i];
    60b2:	fa 01       	movw	r30, r20
    60b4:	e9 0f       	add	r30, r25
    60b6:	f1 1d       	adc	r31, r1
    60b8:	8d 91       	ld	r24, X+
    60ba:	80 83       	st	Z, r24
			//strDecimalFormated[iPos+1]=0;
			iPos++;
    60bc:	9f 5f       	subi	r25, 0xFF	; 255

		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
		 else CommaPos=1;
		 
		 iPos=0;
		 for(i=0;i<Length;i++){
    60be:	2f 5f       	subi	r18, 0xFF	; 255
    60c0:	23 17       	cp	r18, r19
    60c2:	80 f3       	brcs	.-32     	; 0x60a4 <FormatDecimal+0x80>
				 iPos++;
			 }
			strDecimalFormated[iPos]=strRawData[i];
			//strDecimalFormated[iPos+1]=0;
			iPos++;
		 }strDecimalFormated[iPos]=0;
    60c4:	9e 01       	movw	r18, r28
    60c6:	2f 5f       	subi	r18, 0xFF	; 255
    60c8:	3f 4f       	sbci	r19, 0xFF	; 255
    60ca:	f9 01       	movw	r30, r18
    60cc:	e9 0f       	add	r30, r25
    60ce:	f1 1d       	adc	r31, r1
    60d0:	10 82       	st	Z, r1
		 
         //_uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
    60d2:	f9 01       	movw	r30, r18
    60d4:	01 90       	ld	r0, Z+
    60d6:	00 20       	and	r0, r0
    60d8:	e9 f7       	brne	.-6      	; 0x60d4 <FormatDecimal+0xb0>
    60da:	31 97       	sbiw	r30, 0x01	; 1
    60dc:	9e 2f       	mov	r25, r30
    60de:	92 1b       	sub	r25, r18
    60e0:	d9 01       	movw	r26, r18
    60e2:	04 c0       	rjmp	.+8      	; 0x60ec <FormatDecimal+0xc8>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
    60e4:	8d 91       	ld	r24, X+
    60e6:	fb 01       	movw	r30, r22
    60e8:	81 93       	st	Z+, r24
    60ea:	bf 01       	movw	r22, r30
		 }strDecimalFormated[iPos]=0;
		 
         //_uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
		 for(i=0;i<Length;i++){
    60ec:	8a 2f       	mov	r24, r26
    60ee:	82 1b       	sub	r24, r18
    60f0:	89 17       	cp	r24, r25
    60f2:	c0 f3       	brcs	.-16     	; 0x60e4 <FormatDecimal+0xc0>
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
    60f4:	09 0f       	add	r16, r25
    60f6:	11 1d       	adc	r17, r1
    60f8:	f8 01       	movw	r30, r16
    60fa:	10 82       	st	Z, r1
	 }
          //_uart_print(1,1,strRawData); 
}
    60fc:	64 96       	adiw	r28, 0x14	; 20
    60fe:	0f b6       	in	r0, 0x3f	; 63
    6100:	f8 94       	cli
    6102:	de bf       	out	0x3e, r29	; 62
    6104:	0f be       	out	0x3f, r0	; 63
    6106:	cd bf       	out	0x3d, r28	; 61
    6108:	cf 91       	pop	r28
    610a:	df 91       	pop	r29
    610c:	1f 91       	pop	r17
    610e:	0f 91       	pop	r16
    6110:	ff 90       	pop	r15
    6112:	ef 90       	pop	r14
    6114:	08 95       	ret

00006116 <NormalizeDecimal>:
	 Result=(SigmaSum%255);
	 if (Result==0)Result=255;
   return Result;
}

void NormalizeDecimal(char CurrentDecimal, char NewDecimal, char *Result){// 01234567,89
    6116:	68 2f       	mov	r22, r24
    6118:	ca 01       	movw	r24, r20
		 StrPosCopy(Result,SResult,DeltaDec,Length-DeltaDec);
		 	           
	 
     }
*/
     FormatDecimal(Result,CurrentDecimal);
    611a:	0e 94 12 30 	call	0x6024	; 0x6024 <FormatDecimal>
}
    611e:	08 95       	ret

00006120 <FormatTotalizerVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatTotalizerVolume(char *strRawVolume){//96->0,96 
    6120:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6122:	e1 99       	sbic	0x1c, 1	; 28
    6124:	fe cf       	rjmp	.-4      	; 0x6122 <FormatTotalizerVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6126:	8c e3       	ldi	r24, 0x3C	; 60
    6128:	90 e0       	ldi	r25, 0x00	; 0
    612a:	9f bb       	out	0x1f, r25	; 31
    612c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    612e:	e0 9a       	sbi	0x1c, 0	; 28
    6130:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    6132:	c9 01       	movw	r24, r18
    6134:	0e 94 12 30 	call	0x6024	; 0x6024 <FormatDecimal>
}
    6138:	08 95       	ret

0000613a <FormatTotalizerMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}

void FormatTotalizerMoney(char *strRawMoney){
    613a:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    613c:	e1 99       	sbic	0x1c, 1	; 28
    613e:	fe cf       	rjmp	.-4      	; 0x613c <FormatTotalizerMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6140:	8d e3       	ldi	r24, 0x3D	; 61
    6142:	90 e0       	ldi	r25, 0x00	; 0
    6144:	9f bb       	out	0x1f, r25	; 31
    6146:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6148:	e0 9a       	sbi	0x1c, 0	; 28
    614a:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    614c:	c9 01       	movw	r24, r18
    614e:	0e 94 12 30 	call	0x6024	; 0x6024 <FormatDecimal>
}
    6152:	08 95       	ret

00006154 <FormatVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatVolume(char *strRawVolume){//96->0,96 
    6154:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6156:	e1 99       	sbic	0x1c, 1	; 28
    6158:	fe cf       	rjmp	.-4      	; 0x6156 <FormatVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    615a:	8a e3       	ldi	r24, 0x3A	; 58
    615c:	90 e0       	ldi	r25, 0x00	; 0
    615e:	9f bb       	out	0x1f, r25	; 31
    6160:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6162:	e0 9a       	sbi	0x1c, 0	; 28
    6164:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    6166:	c9 01       	movw	r24, r18
    6168:	0e 94 12 30 	call	0x6024	; 0x6024 <FormatDecimal>
}
    616c:	08 95       	ret

0000616e <FormatMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
}

void FormatMoney(char *strRawMoney){
    616e:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6170:	e1 99       	sbic	0x1c, 1	; 28
    6172:	fe cf       	rjmp	.-4      	; 0x6170 <FormatMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6174:	8b e3       	ldi	r24, 0x3B	; 59
    6176:	90 e0       	ldi	r25, 0x00	; 0
    6178:	9f bb       	out	0x1f, r25	; 31
    617a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    617c:	e0 9a       	sbi	0x1c, 0	; 28
    617e:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    6180:	c9 01       	movw	r24, r18
    6182:	0e 94 12 30 	call	0x6024	; 0x6024 <FormatDecimal>
}
    6186:	08 95       	ret

00006188 <FormatPrice>:
		 }strRawData[Length]=0;
	 }
          //_uart_print(1,1,strRawData); 
}

void FormatPrice(char *strRawPrice){
    6188:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    618a:	e1 99       	sbic	0x1c, 1	; 28
    618c:	fe cf       	rjmp	.-4      	; 0x618a <FormatPrice+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    618e:	89 e3       	ldi	r24, 0x39	; 57
    6190:	90 e0       	ldi	r25, 0x00	; 0
    6192:	9f bb       	out	0x1f, r25	; 31
    6194:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6196:	e0 9a       	sbi	0x1c, 0	; 28
    6198:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
    619a:	c9 01       	movw	r24, r18
    619c:	0e 94 12 30 	call	0x6024	; 0x6024 <FormatDecimal>
}
    61a0:	08 95       	ret

000061a2 <systemGenerateReport>:
	 }
}

//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
//			cmdPrint=procMessage81();
void systemGenerateReport(){
    61a2:	2f 92       	push	r2
    61a4:	3f 92       	push	r3
    61a6:	4f 92       	push	r4
    61a8:	5f 92       	push	r5
    61aa:	6f 92       	push	r6
    61ac:	7f 92       	push	r7
    61ae:	8f 92       	push	r8
    61b0:	9f 92       	push	r9
    61b2:	af 92       	push	r10
    61b4:	bf 92       	push	r11
    61b6:	cf 92       	push	r12
    61b8:	df 92       	push	r13
    61ba:	ef 92       	push	r14
    61bc:	ff 92       	push	r15
    61be:	0f 93       	push	r16
    61c0:	1f 93       	push	r17
    61c2:	df 93       	push	r29
    61c4:	cf 93       	push	r28
    61c6:	cd b7       	in	r28, 0x3d	; 61
    61c8:	de b7       	in	r29, 0x3e	; 62
    61ca:	c8 5f       	subi	r28, 0xF8	; 248
    61cc:	d0 40       	sbci	r29, 0x00	; 0
    61ce:	0f b6       	in	r0, 0x3f	; 63
    61d0:	f8 94       	cli
    61d2:	de bf       	out	0x3e, r29	; 62
    61d4:	0f be       	out	0x3f, r0	; 63
    61d6:	cd bf       	out	0x3d, r28	; 61
	   char strTabSpace[20],strTabSpace2[20];
	   char PadLength,iTotal;
	   char sPrice[10],strProductPrice[20];
	   char FIPAddr;

     switch(stGenerateReport){
    61d8:	10 91 31 02 	lds	r17, 0x0231
    61dc:	16 30       	cpi	r17, 0x06	; 6
    61de:	09 f4       	brne	.+2      	; 0x61e2 <systemGenerateReport+0x40>
    61e0:	5d c2       	rjmp	.+1210   	; 0x669c <systemGenerateReport+0x4fa>
    61e2:	17 30       	cpi	r17, 0x07	; 7
    61e4:	a8 f4       	brcc	.+42     	; 0x6210 <systemGenerateReport+0x6e>
    61e6:	12 30       	cpi	r17, 0x02	; 2
    61e8:	09 f4       	brne	.+2      	; 0x61ec <systemGenerateReport+0x4a>
    61ea:	a9 c0       	rjmp	.+338    	; 0x633e <systemGenerateReport+0x19c>
    61ec:	13 30       	cpi	r17, 0x03	; 3
    61ee:	38 f4       	brcc	.+14     	; 0x61fe <systemGenerateReport+0x5c>
    61f0:	11 23       	and	r17, r17
    61f2:	41 f1       	breq	.+80     	; 0x6244 <systemGenerateReport+0xa2>
    61f4:	11 30       	cpi	r17, 0x01	; 1
    61f6:	11 f0       	breq	.+4      	; 0x61fc <systemGenerateReport+0x5a>
    61f8:	0c 94 ea 3b 	jmp	0x77d4	; 0x77d4 <systemGenerateReport+0x1632>
    61fc:	2f c0       	rjmp	.+94     	; 0x625c <systemGenerateReport+0xba>
    61fe:	14 30       	cpi	r17, 0x04	; 4
    6200:	09 f4       	brne	.+2      	; 0x6204 <systemGenerateReport+0x62>
    6202:	c8 c1       	rjmp	.+912    	; 0x6594 <systemGenerateReport+0x3f2>
    6204:	80 91 de 01 	lds	r24, 0x01DE
    6208:	15 30       	cpi	r17, 0x05	; 5
    620a:	08 f0       	brcs	.+2      	; 0x620e <systemGenerateReport+0x6c>
    620c:	4c c7       	rjmp	.+3736   	; 0x70a6 <systemGenerateReport+0xf04>
    620e:	bb c1       	rjmp	.+886    	; 0x6586 <systemGenerateReport+0x3e4>
    6210:	19 30       	cpi	r17, 0x09	; 9
    6212:	09 f4       	brne	.+2      	; 0x6216 <systemGenerateReport+0x74>
    6214:	46 c7       	rjmp	.+3724   	; 0x70a2 <systemGenerateReport+0xf00>
    6216:	1a 30       	cpi	r17, 0x0A	; 10
    6218:	40 f4       	brcc	.+16     	; 0x622a <systemGenerateReport+0x88>
    621a:	17 30       	cpi	r17, 0x07	; 7
    621c:	09 f4       	brne	.+2      	; 0x6220 <systemGenerateReport+0x7e>
    621e:	a8 c2       	rjmp	.+1360   	; 0x6770 <systemGenerateReport+0x5ce>
    6220:	18 30       	cpi	r17, 0x08	; 8
    6222:	11 f0       	breq	.+4      	; 0x6228 <systemGenerateReport+0x86>
    6224:	0c 94 ea 3b 	jmp	0x77d4	; 0x77d4 <systemGenerateReport+0x1632>
    6228:	b1 c2       	rjmp	.+1378   	; 0x678c <systemGenerateReport+0x5ea>
    622a:	1b 30       	cpi	r17, 0x0B	; 11
    622c:	11 f4       	brne	.+4      	; 0x6232 <systemGenerateReport+0x90>
    622e:	0c 94 dd 3b 	jmp	0x77ba	; 0x77ba <systemGenerateReport+0x1618>
    6232:	1b 30       	cpi	r17, 0x0B	; 11
    6234:	08 f4       	brcc	.+2      	; 0x6238 <systemGenerateReport+0x96>
    6236:	3c c7       	rjmp	.+3704   	; 0x70b0 <systemGenerateReport+0xf0e>
    6238:	1c 30       	cpi	r17, 0x0C	; 12
    623a:	11 f0       	breq	.+4      	; 0x6240 <systemGenerateReport+0x9e>
    623c:	0c 94 ea 3b 	jmp	0x77d4	; 0x77d4 <systemGenerateReport+0x1632>
    6240:	0c 94 e5 3b 	jmp	0x77ca	; 0x77ca <systemGenerateReport+0x1628>
	 case grScanAction://Wait for Complete incoming Totalizer data	      
		  if (IsGenerateReport==True){
    6244:	80 91 af 01 	lds	r24, 0x01AF
    6248:	81 30       	cpi	r24, 0x01	; 1
    624a:	11 f0       	breq	.+4      	; 0x6250 <systemGenerateReport+0xae>
    624c:	0c 94 ea 3b 	jmp	0x77d4	; 0x77d4 <systemGenerateReport+0x1632>
		      IsGenerateReport=False;
    6250:	10 92 af 01 	sts	0x01AF, r1
			  IsFinishPrintingTotalizer=False;
    6254:	10 92 b0 01 	sts	0x01B0, r1
    6258:	0c 94 e2 3b 	jmp	0x77c4	; 0x77c4 <systemGenerateReport+0x1622>
			  stGenerateReport=grInitData;
		  }
	      break;
	 case grInitData:
	      xPump=1;
    625c:	10 93 30 02 	sts	0x0230, r17
		  xNozzle=1;
    6260:	10 93 2f 02 	sts	0x022F, r17
		  RepPos=0;
    6264:	10 92 20 02 	sts	0x0220, r1
    6268:	10 92 1f 02 	sts	0x021F, r1
    626c:	e7 ef       	ldi	r30, 0xF7	; 247
    626e:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    6270:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6272:	87 e0       	ldi	r24, 0x07	; 7
    6274:	ec 38       	cpi	r30, 0x8C	; 140
    6276:	f8 07       	cpc	r31, r24
    6278:	d9 f7       	brne	.-10     	; 0x6270 <systemGenerateReport+0xce>
    627a:	fe 01       	movw	r30, r28
    627c:	eb 55       	subi	r30, 0x5B	; 91
    627e:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6280:	ce 01       	movw	r24, r28
    6282:	8b 50       	subi	r24, 0x0B	; 11
    6284:	9f 4f       	sbci	r25, 0xFF	; 255
    6286:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6288:	e8 17       	cp	r30, r24
    628a:	f9 07       	cpc	r31, r25
    628c:	e1 f7       	brne	.-8      	; 0x6286 <systemGenerateReport+0xe4>
    628e:	fe 01       	movw	r30, r28
    6290:	f7 96       	adiw	r30, 0x37	; 55
	     strMemory[i]=data;
    6292:	cf 01       	movw	r24, r30
    6294:	0f 96       	adiw	r24, 0x0f	; 15
    6296:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6298:	e8 17       	cp	r30, r24
    629a:	f9 07       	cpc	r31, r25
    629c:	e1 f7       	brne	.-8      	; 0x6296 <systemGenerateReport+0xf4>
    629e:	fe 01       	movw	r30, r28
    62a0:	ea 5b       	subi	r30, 0xBA	; 186
    62a2:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    62a4:	cf 01       	movw	r24, r30
    62a6:	0f 96       	adiw	r24, 0x0f	; 15
    62a8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    62aa:	e8 17       	cp	r30, r24
    62ac:	f9 07       	cpc	r31, r25
    62ae:	e1 f7       	brne	.-8      	; 0x62a8 <systemGenerateReport+0x106>
    62b0:	e8 e2       	ldi	r30, 0x28	; 40
    62b2:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    62b4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    62b6:	9a e0       	ldi	r25, 0x0A	; 10
    62b8:	ec 33       	cpi	r30, 0x3C	; 60
    62ba:	f9 07       	cpc	r31, r25
    62bc:	d9 f7       	brne	.-10     	; 0x62b4 <systemGenerateReport+0x112>
    62be:	ed ed       	ldi	r30, 0xDD	; 221
    62c0:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    62c2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    62c4:	aa e0       	ldi	r26, 0x0A	; 10
    62c6:	e1 3f       	cpi	r30, 0xF1	; 241
    62c8:	fa 07       	cpc	r31, r26
    62ca:	d9 f7       	brne	.-10     	; 0x62c2 <systemGenerateReport+0x120>
    62cc:	e8 e3       	ldi	r30, 0x38	; 56
    62ce:	fe e0       	ldi	r31, 0x0E	; 14
	     strMemory[i]=data;
    62d0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    62d2:	be e0       	ldi	r27, 0x0E	; 14
    62d4:	e7 34       	cpi	r30, 0x47	; 71
    62d6:	fb 07       	cpc	r31, r27
    62d8:	d9 f7       	brne	.-10     	; 0x62d0 <systemGenerateReport+0x12e>
    62da:	ed e0       	ldi	r30, 0x0D	; 13
    62dc:	fb e0       	ldi	r31, 0x0B	; 11
	     strMemory[i]=data;
    62de:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    62e0:	8b e0       	ldi	r24, 0x0B	; 11
    62e2:	ec 31       	cpi	r30, 0x1C	; 28
    62e4:	f8 07       	cpc	r31, r24
    62e6:	d9 f7       	brne	.-10     	; 0x62de <systemGenerateReport+0x13c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    62e8:	e1 99       	sbic	0x1c, 1	; 28
    62ea:	fe cf       	rjmp	.-4      	; 0x62e8 <systemGenerateReport+0x146>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    62ec:	8f e6       	ldi	r24, 0x6F	; 111
    62ee:	91 e0       	ldi	r25, 0x01	; 1
    62f0:	9f bb       	out	0x1f, r25	; 31
    62f2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    62f4:	e0 9a       	sbi	0x1c, 0	; 28
    62f6:	2d b3       	in	r18, 0x1d	; 29
		  FillChar(strTotalMoney,sizeof(strTotalMoney),0);


		  FillChar(strDeltaMoney,sizeof(strDeltaMoney),0);
		  FillChar(strDeltaVolume,sizeof(strDeltaVolume),0);
		  sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    62f8:	00 d0       	rcall	.+0      	; 0x62fa <systemGenerateReport+0x158>
    62fa:	00 d0       	rcall	.+0      	; 0x62fc <systemGenerateReport+0x15a>
    62fc:	00 d0       	rcall	.+0      	; 0x62fe <systemGenerateReport+0x15c>
    62fe:	ed b7       	in	r30, 0x3d	; 61
    6300:	fe b7       	in	r31, 0x3e	; 62
    6302:	31 96       	adiw	r30, 0x01	; 1
    6304:	83 e7       	ldi	r24, 0x73	; 115
    6306:	9e e0       	ldi	r25, 0x0E	; 14
    6308:	ad b7       	in	r26, 0x3d	; 61
    630a:	be b7       	in	r27, 0x3e	; 62
    630c:	12 96       	adiw	r26, 0x02	; 2
    630e:	9c 93       	st	X, r25
    6310:	8e 93       	st	-X, r24
    6312:	11 97       	sbiw	r26, 0x01	; 1
    6314:	8f e1       	ldi	r24, 0x1F	; 31
    6316:	96 e0       	ldi	r25, 0x06	; 6
    6318:	93 83       	std	Z+3, r25	; 0x03
    631a:	82 83       	std	Z+2, r24	; 0x02
    631c:	24 83       	std	Z+4, r18	; 0x04
    631e:	15 82       	std	Z+5, r1	; 0x05
    6320:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>

          stGenerateReport=grCreateReportHeader;
    6324:	82 e0       	ldi	r24, 0x02	; 2
    6326:	80 93 31 02 	sts	0x0231, r24
    632a:	ed b7       	in	r30, 0x3d	; 61
    632c:	fe b7       	in	r31, 0x3e	; 62
    632e:	36 96       	adiw	r30, 0x06	; 6
    6330:	0f b6       	in	r0, 0x3f	; 63
    6332:	f8 94       	cli
    6334:	fe bf       	out	0x3e, r31	; 62
    6336:	0f be       	out	0x3f, r0	; 63
    6338:	ed bf       	out	0x3d, r30	; 61
    633a:	0c 94 ea 3b 	jmp	0x77d4	; 0x77d4 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    633e:	ce 01       	movw	r24, r28
    6340:	8b 5a       	subi	r24, 0xAB	; 171
    6342:	9f 4f       	sbci	r25, 0xFF	; 255
    6344:	62 e7       	ldi	r22, 0x72	; 114
    6346:	78 e0       	ldi	r23, 0x08	; 8
    6348:	44 e1       	ldi	r20, 0x14	; 20
    634a:	50 e0       	ldi	r21, 0x00	; 0
    634c:	2c ea       	ldi	r18, 0xAC	; 172
    634e:	32 e1       	ldi	r19, 0x12	; 18
    6350:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
	      break;
	 case grCreateReportHeader://Border: btTopLeft,btTopCenter,btTopRight,btMiddleLeft,btMiddleCenter,btMiddleRight,btBottomLeft,btBottomCenter,btBottomRight,btVertical,btHorizontal
		  eeprom_read_block((void*) &LastShiftDateTime, (const void*) &DefLastShiftDateTime, sizeof(DefLastShiftDateTime));
          
		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    6354:	81 e0       	ldi	r24, 0x01	; 1
    6356:	67 ef       	ldi	r22, 0xF7	; 247
    6358:	75 e0       	ldi	r23, 0x05	; 5
    635a:	41 e0       	ldi	r20, 0x01	; 1
    635c:	2f e1       	ldi	r18, 0x1F	; 31
    635e:	32 e0       	ldi	r19, 0x02	; 2
    6360:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    6364:	8b e0       	ldi	r24, 0x0B	; 11
    6366:	67 ef       	ldi	r22, 0xF7	; 247
    6368:	75 e0       	ldi	r23, 0x05	; 5
    636a:	4a e2       	ldi	r20, 0x2A	; 42
    636c:	2f e1       	ldi	r18, 0x1F	; 31
    636e:	32 e0       	ldi	r19, 0x02	; 2
    6370:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    6374:	83 e0       	ldi	r24, 0x03	; 3
    6376:	67 ef       	ldi	r22, 0xF7	; 247
    6378:	75 e0       	ldi	r23, 0x05	; 5
    637a:	41 e0       	ldi	r20, 0x01	; 1
    637c:	2f e1       	ldi	r18, 0x1F	; 31
    637e:	32 e0       	ldi	r19, 0x02	; 2
    6380:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    6384:	8c e0       	ldi	r24, 0x0C	; 12
    6386:	67 ef       	ldi	r22, 0xF7	; 247
    6388:	75 e0       	ldi	r23, 0x05	; 5
    638a:	41 e0       	ldi	r20, 0x01	; 1
    638c:	2f e1       	ldi	r18, 0x1F	; 31
    638e:	32 e0       	ldi	r19, 0x02	; 2
    6390:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
	      sprintf_P(strReport,PSTR("        Laporan Tutup Shift: %s      "),strShift);CreateReport(strReport,PrintBuffer,&RepPos);
    6394:	00 d0       	rcall	.+0      	; 0x6396 <systemGenerateReport+0x1f4>
    6396:	00 d0       	rcall	.+0      	; 0x6398 <systemGenerateReport+0x1f6>
    6398:	00 d0       	rcall	.+0      	; 0x639a <systemGenerateReport+0x1f8>
    639a:	ed b7       	in	r30, 0x3d	; 61
    639c:	fe b7       	in	r31, 0x3e	; 62
    639e:	31 96       	adiw	r30, 0x01	; 1
    63a0:	8e 01       	movw	r16, r28
    63a2:	0b 55       	subi	r16, 0x5B	; 91
    63a4:	1f 4f       	sbci	r17, 0xFF	; 255
    63a6:	ad b7       	in	r26, 0x3d	; 61
    63a8:	be b7       	in	r27, 0x3e	; 62
    63aa:	12 96       	adiw	r26, 0x02	; 2
    63ac:	1c 93       	st	X, r17
    63ae:	0e 93       	st	-X, r16
    63b0:	11 97       	sbiw	r26, 0x01	; 1
    63b2:	89 ef       	ldi	r24, 0xF9	; 249
    63b4:	95 e0       	ldi	r25, 0x05	; 5
    63b6:	93 83       	std	Z+3, r25	; 0x03
    63b8:	82 83       	std	Z+2, r24	; 0x02
    63ba:	83 e7       	ldi	r24, 0x73	; 115
    63bc:	9e e0       	ldi	r25, 0x0E	; 14
    63be:	95 83       	std	Z+5, r25	; 0x05
    63c0:	84 83       	std	Z+4, r24	; 0x04
    63c2:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    63c6:	ed b7       	in	r30, 0x3d	; 61
    63c8:	fe b7       	in	r31, 0x3e	; 62
    63ca:	36 96       	adiw	r30, 0x06	; 6
    63cc:	0f b6       	in	r0, 0x3f	; 63
    63ce:	f8 94       	cli
    63d0:	fe bf       	out	0x3e, r31	; 62
    63d2:	0f be       	out	0x3f, r0	; 63
    63d4:	ed bf       	out	0x3d, r30	; 61
    63d6:	c8 01       	movw	r24, r16
    63d8:	67 ef       	ldi	r22, 0xF7	; 247
    63da:	75 e0       	ldi	r23, 0x05	; 5
    63dc:	4f e1       	ldi	r20, 0x1F	; 31
    63de:	52 e0       	ldi	r21, 0x02	; 2
    63e0:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <CreateReport>
		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     
    63e4:	84 e0       	ldi	r24, 0x04	; 4
    63e6:	67 ef       	ldi	r22, 0xF7	; 247
    63e8:	75 e0       	ldi	r23, 0x05	; 5
    63ea:	41 e0       	ldi	r20, 0x01	; 1
    63ec:	2f e1       	ldi	r18, 0x1F	; 31
    63ee:	32 e0       	ldi	r19, 0x02	; 2
    63f0:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    63f4:	8b e0       	ldi	r24, 0x0B	; 11
    63f6:	67 ef       	ldi	r22, 0xF7	; 247
    63f8:	75 e0       	ldi	r23, 0x05	; 5
    63fa:	4a e2       	ldi	r20, 0x2A	; 42
    63fc:	2f e1       	ldi	r18, 0x1F	; 31
    63fe:	32 e0       	ldi	r19, 0x02	; 2
    6400:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    6404:	86 e0       	ldi	r24, 0x06	; 6
    6406:	67 ef       	ldi	r22, 0xF7	; 247
    6408:	75 e0       	ldi	r23, 0x05	; 5
    640a:	41 e0       	ldi	r20, 0x01	; 1
    640c:	2f e1       	ldi	r18, 0x1F	; 31
    640e:	32 e0       	ldi	r19, 0x02	; 2
    6410:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    6414:	8c e0       	ldi	r24, 0x0C	; 12
    6416:	67 ef       	ldi	r22, 0xF7	; 247
    6418:	75 e0       	ldi	r23, 0x05	; 5
    641a:	41 e0       	ldi	r20, 0x01	; 1
    641c:	2f e1       	ldi	r18, 0x1F	; 31
    641e:	32 e0       	ldi	r19, 0x02	; 2
    6420:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6424:	e1 99       	sbic	0x1c, 1	; 28
    6426:	fe cf       	rjmp	.-4      	; 0x6424 <systemGenerateReport+0x282>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6428:	80 e0       	ldi	r24, 0x00	; 0
    642a:	90 e0       	ldi	r25, 0x00	; 0
    642c:	9f bb       	out	0x1f, r25	; 31
    642e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6430:	e0 9a       	sbi	0x1c, 0	; 28
    6432:	2d b3       	in	r18, 0x1d	; 29
	      sprintf_P(strReport,PSTR("Terminal ID : %.2d                   "),eeprom_read_byte(&DefIFT_ID));CreateReport(strReport,PrintBuffer,&RepPos);
    6434:	00 d0       	rcall	.+0      	; 0x6436 <systemGenerateReport+0x294>
    6436:	00 d0       	rcall	.+0      	; 0x6438 <systemGenerateReport+0x296>
    6438:	00 d0       	rcall	.+0      	; 0x643a <systemGenerateReport+0x298>
    643a:	ed b7       	in	r30, 0x3d	; 61
    643c:	fe b7       	in	r31, 0x3e	; 62
    643e:	31 96       	adiw	r30, 0x01	; 1
    6440:	8e 01       	movw	r16, r28
    6442:	0b 55       	subi	r16, 0x5B	; 91
    6444:	1f 4f       	sbci	r17, 0xFF	; 255
    6446:	ad b7       	in	r26, 0x3d	; 61
    6448:	be b7       	in	r27, 0x3e	; 62
    644a:	12 96       	adiw	r26, 0x02	; 2
    644c:	1c 93       	st	X, r17
    644e:	0e 93       	st	-X, r16
    6450:	11 97       	sbiw	r26, 0x01	; 1
    6452:	83 ed       	ldi	r24, 0xD3	; 211
    6454:	95 e0       	ldi	r25, 0x05	; 5
    6456:	93 83       	std	Z+3, r25	; 0x03
    6458:	82 83       	std	Z+2, r24	; 0x02
    645a:	24 83       	std	Z+4, r18	; 0x04
    645c:	15 82       	std	Z+5, r1	; 0x05
    645e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    6462:	ed b7       	in	r30, 0x3d	; 61
    6464:	fe b7       	in	r31, 0x3e	; 62
    6466:	36 96       	adiw	r30, 0x06	; 6
    6468:	0f b6       	in	r0, 0x3f	; 63
    646a:	f8 94       	cli
    646c:	fe bf       	out	0x3e, r31	; 62
    646e:	0f be       	out	0x3f, r0	; 63
    6470:	ed bf       	out	0x3d, r30	; 61
    6472:	c8 01       	movw	r24, r16
    6474:	67 ef       	ldi	r22, 0xF7	; 247
    6476:	75 e0       	ldi	r23, 0x05	; 5
    6478:	4f e1       	ldi	r20, 0x1F	; 31
    647a:	52 e0       	ldi	r21, 0x02	; 2
    647c:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <CreateReport>
	      sprintf_P(strReport,PSTR("Awal  Shift : %s "),LastShiftDateTime);             CreateReport(strReport,PrintBuffer,&RepPos);
    6480:	00 d0       	rcall	.+0      	; 0x6482 <systemGenerateReport+0x2e0>
    6482:	00 d0       	rcall	.+0      	; 0x6484 <systemGenerateReport+0x2e2>
    6484:	00 d0       	rcall	.+0      	; 0x6486 <systemGenerateReport+0x2e4>
    6486:	ed b7       	in	r30, 0x3d	; 61
    6488:	fe b7       	in	r31, 0x3e	; 62
    648a:	31 96       	adiw	r30, 0x01	; 1
    648c:	ad b7       	in	r26, 0x3d	; 61
    648e:	be b7       	in	r27, 0x3e	; 62
    6490:	12 96       	adiw	r26, 0x02	; 2
    6492:	1c 93       	st	X, r17
    6494:	0e 93       	st	-X, r16
    6496:	11 97       	sbiw	r26, 0x01	; 1
    6498:	81 ec       	ldi	r24, 0xC1	; 193
    649a:	95 e0       	ldi	r25, 0x05	; 5
    649c:	93 83       	std	Z+3, r25	; 0x03
    649e:	82 83       	std	Z+2, r24	; 0x02
    64a0:	ce 01       	movw	r24, r28
    64a2:	8b 5a       	subi	r24, 0xAB	; 171
    64a4:	9f 4f       	sbci	r25, 0xFF	; 255
    64a6:	95 83       	std	Z+5, r25	; 0x05
    64a8:	84 83       	std	Z+4, r24	; 0x04
    64aa:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    64ae:	ed b7       	in	r30, 0x3d	; 61
    64b0:	fe b7       	in	r31, 0x3e	; 62
    64b2:	36 96       	adiw	r30, 0x06	; 6
    64b4:	0f b6       	in	r0, 0x3f	; 63
    64b6:	f8 94       	cli
    64b8:	fe bf       	out	0x3e, r31	; 62
    64ba:	0f be       	out	0x3f, r0	; 63
    64bc:	ed bf       	out	0x3d, r30	; 61
    64be:	c8 01       	movw	r24, r16
    64c0:	67 ef       	ldi	r22, 0xF7	; 247
    64c2:	75 e0       	ldi	r23, 0x05	; 5
    64c4:	4f e1       	ldi	r20, 0x1F	; 31
    64c6:	52 e0       	ldi	r21, 0x02	; 2
    64c8:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <CreateReport>
	      sprintf_P(strReport,PSTR("Akhir Shift : %s "),CurrentShiftDateTime);      CreateReport(strReport,PrintBuffer,&RepPos);
    64cc:	00 d0       	rcall	.+0      	; 0x64ce <systemGenerateReport+0x32c>
    64ce:	00 d0       	rcall	.+0      	; 0x64d0 <systemGenerateReport+0x32e>
    64d0:	00 d0       	rcall	.+0      	; 0x64d2 <systemGenerateReport+0x330>
    64d2:	ed b7       	in	r30, 0x3d	; 61
    64d4:	fe b7       	in	r31, 0x3e	; 62
    64d6:	31 96       	adiw	r30, 0x01	; 1
    64d8:	ad b7       	in	r26, 0x3d	; 61
    64da:	be b7       	in	r27, 0x3e	; 62
    64dc:	12 96       	adiw	r26, 0x02	; 2
    64de:	1c 93       	st	X, r17
    64e0:	0e 93       	st	-X, r16
    64e2:	11 97       	sbiw	r26, 0x01	; 1
    64e4:	8f ea       	ldi	r24, 0xAF	; 175
    64e6:	95 e0       	ldi	r25, 0x05	; 5
    64e8:	93 83       	std	Z+3, r25	; 0x03
    64ea:	82 83       	std	Z+2, r24	; 0x02
    64ec:	8d e9       	ldi	r24, 0x9D	; 157
    64ee:	99 e0       	ldi	r25, 0x09	; 9
    64f0:	95 83       	std	Z+5, r25	; 0x05
    64f2:	84 83       	std	Z+4, r24	; 0x04
    64f4:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    64f8:	ed b7       	in	r30, 0x3d	; 61
    64fa:	fe b7       	in	r31, 0x3e	; 62
    64fc:	36 96       	adiw	r30, 0x06	; 6
    64fe:	0f b6       	in	r0, 0x3f	; 63
    6500:	f8 94       	cli
    6502:	fe bf       	out	0x3e, r31	; 62
    6504:	0f be       	out	0x3f, r0	; 63
    6506:	ed bf       	out	0x3d, r30	; 61
    6508:	c8 01       	movw	r24, r16
    650a:	67 ef       	ldi	r22, 0xF7	; 247
    650c:	75 e0       	ldi	r23, 0x05	; 5
    650e:	4f e1       	ldi	r20, 0x1F	; 31
    6510:	52 e0       	ldi	r21, 0x02	; 2
    6512:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <CreateReport>
	      //sprintf_P(strReport,PSTR("Transaksi   : %s "),DeltaTransaction);      CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    6516:	87 e0       	ldi	r24, 0x07	; 7
    6518:	67 ef       	ldi	r22, 0xF7	; 247
    651a:	75 e0       	ldi	r23, 0x05	; 5
    651c:	41 e0       	ldi	r20, 0x01	; 1
    651e:	2f e1       	ldi	r18, 0x1F	; 31
    6520:	32 e0       	ldi	r19, 0x02	; 2
    6522:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    6526:	8b e0       	ldi	r24, 0x0B	; 11
    6528:	67 ef       	ldi	r22, 0xF7	; 247
    652a:	75 e0       	ldi	r23, 0x05	; 5
    652c:	4a e2       	ldi	r20, 0x2A	; 42
    652e:	2f e1       	ldi	r18, 0x1F	; 31
    6530:	32 e0       	ldi	r19, 0x02	; 2
    6532:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    6536:	89 e0       	ldi	r24, 0x09	; 9
    6538:	67 ef       	ldi	r22, 0xF7	; 247
    653a:	75 e0       	ldi	r23, 0x05	; 5
    653c:	41 e0       	ldi	r20, 0x01	; 1
    653e:	2f e1       	ldi	r18, 0x1F	; 31
    6540:	32 e0       	ldi	r19, 0x02	; 2
    6542:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    6546:	8c e0       	ldi	r24, 0x0C	; 12
    6548:	67 ef       	ldi	r22, 0xF7	; 247
    654a:	75 e0       	ldi	r23, 0x05	; 5
    654c:	41 e0       	ldi	r20, 0x01	; 1
    654e:	2f e1       	ldi	r18, 0x1F	; 31
    6550:	32 e0       	ldi	r19, 0x02	; 2
    6552:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
		  /*
	      if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
          */
		  ClearList(GradeList);
    6556:	81 e2       	ldi	r24, 0x21	; 33
    6558:	92 e0       	ldi	r25, 0x02	; 2
    655a:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <ClearList>
		  cmdPrint=0b10000000;//PrintHeader
    655e:	80 e8       	ldi	r24, 0x80	; 128
    6560:	80 93 e0 01 	sts	0x01E0, r24
		  LengthMessage81=RepPos+1;
    6564:	80 91 1f 02 	lds	r24, 0x021F
    6568:	90 91 20 02 	lds	r25, 0x0220
    656c:	01 96       	adiw	r24, 0x01	; 1
    656e:	90 93 b6 01 	sts	0x01B6, r25
    6572:	80 93 b5 01 	sts	0x01B5, r24
		  IsFreePrinting=True;
    6576:	81 e0       	ldi	r24, 0x01	; 1
    6578:	80 93 d5 01 	sts	0x01D5, r24
          IsBusyFreePrinting=True;
    657c:	80 93 de 01 	sts	0x01DE, r24
		  		  
          stGenerateReport=grWaitPrinted1;
    6580:	83 e0       	ldi	r24, 0x03	; 3
    6582:	0c 94 e2 3b 	jmp	0x77c4	; 0x77c4 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted1:
          if (IsBusyFreePrinting==False)
    6586:	88 23       	and	r24, r24
    6588:	11 f0       	breq	.+4      	; 0x658e <systemGenerateReport+0x3ec>
    658a:	0c 94 ea 3b 	jmp	0x77d4	; 0x77d4 <systemGenerateReport+0x1632>
		      stGenerateReport=grGenerateLabel;//grGenerateReportData;//grFinishGenerateReport;
    658e:	84 e0       	ldi	r24, 0x04	; 4
    6590:	0c 94 e2 3b 	jmp	0x77c4	; 0x77c4 <systemGenerateReport+0x1622>
	      break;
     case grGenerateLabel:
          RepPos=0;
    6594:	10 92 20 02 	sts	0x0220, r1
    6598:	10 92 1f 02 	sts	0x021F, r1
          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    659c:	81 e0       	ldi	r24, 0x01	; 1
    659e:	67 ef       	ldi	r22, 0xF7	; 247
    65a0:	75 e0       	ldi	r23, 0x05	; 5
    65a2:	41 e0       	ldi	r20, 0x01	; 1
    65a4:	2f e1       	ldi	r18, 0x1F	; 31
    65a6:	32 e0       	ldi	r19, 0x02	; 2
    65a8:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    65ac:	8b e0       	ldi	r24, 0x0B	; 11
    65ae:	67 ef       	ldi	r22, 0xF7	; 247
    65b0:	75 e0       	ldi	r23, 0x05	; 5
    65b2:	4a e2       	ldi	r20, 0x2A	; 42
    65b4:	2f e1       	ldi	r18, 0x1F	; 31
    65b6:	32 e0       	ldi	r19, 0x02	; 2
    65b8:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    65bc:	83 e0       	ldi	r24, 0x03	; 3
    65be:	67 ef       	ldi	r22, 0xF7	; 247
    65c0:	75 e0       	ldi	r23, 0x05	; 5
    65c2:	41 e0       	ldi	r20, 0x01	; 1
    65c4:	2f e1       	ldi	r18, 0x1F	; 31
    65c6:	32 e0       	ldi	r19, 0x02	; 2
    65c8:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    65cc:	8c e0       	ldi	r24, 0x0C	; 12
    65ce:	67 ef       	ldi	r22, 0xF7	; 247
    65d0:	75 e0       	ldi	r23, 0x05	; 5
    65d2:	41 e0       	ldi	r20, 0x01	; 1
    65d4:	2f e1       	ldi	r18, 0x1F	; 31
    65d6:	32 e0       	ldi	r19, 0x02	; 2
    65d8:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    65dc:	e1 99       	sbic	0x1c, 1	; 28
    65de:	fe cf       	rjmp	.-4      	; 0x65dc <systemGenerateReport+0x43a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    65e0:	81 ef       	ldi	r24, 0xF1	; 241
    65e2:	93 e0       	ldi	r25, 0x03	; 3
    65e4:	9f bb       	out	0x1f, r25	; 31
    65e6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    65e8:	e0 9a       	sbi	0x1c, 0	; 28
    65ea:	8d b3       	in	r24, 0x1d	; 29
    65ec:	9e 01       	movw	r18, r28
    65ee:	2b 55       	subi	r18, 0x5B	; 91
    65f0:	3f 4f       	sbci	r19, 0xFF	; 255
	      if (eeprom_read_byte(&DefPrintMoney)==True)
    65f2:	81 30       	cpi	r24, 0x01	; 1
    65f4:	79 f4       	brne	.+30     	; 0x6614 <systemGenerateReport+0x472>
		       sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
    65f6:	00 d0       	rcall	.+0      	; 0x65f8 <systemGenerateReport+0x456>
    65f8:	00 d0       	rcall	.+0      	; 0x65fa <systemGenerateReport+0x458>
    65fa:	ad b7       	in	r26, 0x3d	; 61
    65fc:	be b7       	in	r27, 0x3e	; 62
    65fe:	12 96       	adiw	r26, 0x02	; 2
    6600:	3c 93       	st	X, r19
    6602:	2e 93       	st	-X, r18
    6604:	11 97       	sbiw	r26, 0x01	; 1
    6606:	88 e8       	ldi	r24, 0x88	; 136
    6608:	95 e0       	ldi	r25, 0x05	; 5
    660a:	14 96       	adiw	r26, 0x04	; 4
    660c:	9c 93       	st	X, r25
    660e:	8e 93       	st	-X, r24
    6610:	13 97       	sbiw	r26, 0x03	; 3
    6612:	0a c0       	rjmp	.+20     	; 0x6628 <systemGenerateReport+0x486>
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
    6614:	00 d0       	rcall	.+0      	; 0x6616 <systemGenerateReport+0x474>
    6616:	00 d0       	rcall	.+0      	; 0x6618 <systemGenerateReport+0x476>
    6618:	ed b7       	in	r30, 0x3d	; 61
    661a:	fe b7       	in	r31, 0x3e	; 62
    661c:	32 83       	std	Z+2, r19	; 0x02
    661e:	21 83       	std	Z+1, r18	; 0x01
    6620:	81 e6       	ldi	r24, 0x61	; 97
    6622:	95 e0       	ldi	r25, 0x05	; 5
    6624:	94 83       	std	Z+4, r25	; 0x04
    6626:	83 83       	std	Z+3, r24	; 0x03
    6628:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    662c:	0f 90       	pop	r0
    662e:	0f 90       	pop	r0
    6630:	0f 90       	pop	r0
    6632:	0f 90       	pop	r0
    6634:	ce 01       	movw	r24, r28
    6636:	8b 55       	subi	r24, 0x5B	; 91
    6638:	9f 4f       	sbci	r25, 0xFF	; 255
    663a:	67 ef       	ldi	r22, 0xF7	; 247
    663c:	75 e0       	ldi	r23, 0x05	; 5
    663e:	4f e1       	ldi	r20, 0x1F	; 31
    6640:	52 e0       	ldi	r21, 0x02	; 2
    6642:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <CreateReport>
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
    6646:	87 e0       	ldi	r24, 0x07	; 7
    6648:	67 ef       	ldi	r22, 0xF7	; 247
    664a:	75 e0       	ldi	r23, 0x05	; 5
    664c:	41 e0       	ldi	r20, 0x01	; 1
    664e:	2f e1       	ldi	r18, 0x1F	; 31
    6650:	32 e0       	ldi	r19, 0x02	; 2
    6652:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    6656:	8b e0       	ldi	r24, 0x0B	; 11
    6658:	67 ef       	ldi	r22, 0xF7	; 247
    665a:	75 e0       	ldi	r23, 0x05	; 5
    665c:	4a e2       	ldi	r20, 0x2A	; 42
    665e:	2f e1       	ldi	r18, 0x1F	; 31
    6660:	32 e0       	ldi	r19, 0x02	; 2
    6662:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    6666:	89 e0       	ldi	r24, 0x09	; 9
    6668:	67 ef       	ldi	r22, 0xF7	; 247
    666a:	75 e0       	ldi	r23, 0x05	; 5
    666c:	41 e0       	ldi	r20, 0x01	; 1
    666e:	2f e1       	ldi	r18, 0x1F	; 31
    6670:	32 e0       	ldi	r19, 0x02	; 2
    6672:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
          
		  cmdPrint=0b00000000;
    6676:	10 92 e0 01 	sts	0x01E0, r1
		  LengthMessage81=RepPos+1;
    667a:	80 91 1f 02 	lds	r24, 0x021F
    667e:	90 91 20 02 	lds	r25, 0x0220
    6682:	01 96       	adiw	r24, 0x01	; 1
    6684:	90 93 b6 01 	sts	0x01B6, r25
    6688:	80 93 b5 01 	sts	0x01B5, r24

		  IsFreePrinting=True;
    668c:	81 e0       	ldi	r24, 0x01	; 1
    668e:	80 93 d5 01 	sts	0x01D5, r24
	      IsBusyFreePrinting=True;
    6692:	80 93 de 01 	sts	0x01DE, r24

		  stGenerateReport=grWaitLabelPrinted;
    6696:	85 e0       	ldi	r24, 0x05	; 5
    6698:	0c 94 e2 3b 	jmp	0x77c4	; 0x77c4 <systemGenerateReport+0x1622>
          if (IsBusyFreePrinting==False)
		      stGenerateReport=grGenerateReportData;//grFinishGenerateReport;
	      break;
     case grGenerateReportData:
	      //Generate: PumpNum, Nozzle, Product
	      if ((xPump>=1)&&(xPump<=8)){
    669c:	80 91 30 02 	lds	r24, 0x0230
    66a0:	81 50       	subi	r24, 0x01	; 1
    66a2:	88 30       	cpi	r24, 0x08	; 8
    66a4:	10 f0       	brcs	.+4      	; 0x66aa <systemGenerateReport+0x508>
    66a6:	0c 94 ea 3b 	jmp	0x77d4	; 0x77d4 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    66aa:	ce 01       	movw	r24, r28
    66ac:	07 96       	adiw	r24, 0x07	; 7
    66ae:	65 e4       	ldi	r22, 0x45	; 69
    66b0:	70 e0       	ldi	r23, 0x00	; 0
    66b2:	48 e0       	ldi	r20, 0x08	; 8
    66b4:	50 e0       	ldi	r21, 0x00	; 0
    66b6:	2c ea       	ldi	r18, 0xAC	; 172
    66b8:	32 e1       	ldi	r19, 0x12	; 18
    66ba:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
		      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			  PumpNum=PPumpID[xPump-1];
    66be:	90 91 30 02 	lds	r25, 0x0230
    66c2:	fe 01       	movw	r30, r28
    66c4:	e9 0f       	add	r30, r25
    66c6:	f1 1d       	adc	r31, r1
    66c8:	86 81       	ldd	r24, Z+6	; 0x06
    66ca:	80 93 2d 02 	sts	0x022D, r24
			  if (PumpNum>0){
    66ce:	88 23       	and	r24, r24
    66d0:	09 f4       	brne	.+2      	; 0x66d4 <systemGenerateReport+0x532>
    66d2:	4b c0       	rjmp	.+150    	; 0x676a <systemGenerateReport+0x5c8>
    66d4:	91 9f       	mul	r25, r17
    66d6:	b0 01       	movw	r22, r0
    66d8:	11 24       	eor	r1, r1
    66da:	61 5b       	subi	r22, 0xB1	; 177
    66dc:	7f 4f       	sbci	r23, 0xFF	; 255
    66de:	ce 01       	movw	r24, r28
    66e0:	01 96       	adiw	r24, 0x01	; 1
    66e2:	46 e0       	ldi	r20, 0x06	; 6
    66e4:	50 e0       	ldi	r21, 0x00	; 0
    66e6:	2c ea       	ldi	r18, 0xAC	; 172
    66e8:	32 e1       	ldi	r19, 0x12	; 18
    66ea:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
				  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
				  xGrade=PProductID[xNozzle-1];
    66ee:	80 91 2f 02 	lds	r24, 0x022F
    66f2:	fe 01       	movw	r30, r28
    66f4:	e8 0f       	add	r30, r24
    66f6:	f1 1d       	adc	r31, r1
    66f8:	80 81       	ld	r24, Z
    66fa:	80 93 2e 02 	sts	0x022E, r24
    66fe:	6d e6       	ldi	r22, 0x6D	; 109
    6700:	c6 2e       	mov	r12, r22
    6702:	69 e0       	ldi	r22, 0x09	; 9
    6704:	d6 2e       	mov	r13, r22

				  if (xGrade>0){
    6706:	88 23       	and	r24, r24
    6708:	99 f0       	breq	.+38     	; 0x6730 <systemGenerateReport+0x58e>
				      GetProductName(xGrade,strProduct);
    670a:	b6 01       	movw	r22, r12
    670c:	0e 94 30 2a 	call	0x5460	; 0x5460 <GetProductName>
                      GradeUsed=xGrade;
    6710:	80 91 2e 02 	lds	r24, 0x022E
    6714:	80 93 2b 02 	sts	0x022B, r24
					  xGrade=xNozzle;//
    6718:	80 91 2f 02 	lds	r24, 0x022F
    671c:	80 93 2e 02 	sts	0x022E, r24
					  PumpNozzle=xNozzle;
    6720:	80 93 2c 02 	sts	0x022C, r24
					  xNozzle++;
    6724:	8f 5f       	subi	r24, 0xFF	; 255
    6726:	80 93 2f 02 	sts	0x022F, r24
					  stGenerateReport=grCreateReportTotalizer;
    672a:	88 e0       	ldi	r24, 0x08	; 8
    672c:	0c 94 e2 3b 	jmp	0x77c4	; 0x77c4 <systemGenerateReport+0x1622>
				  }
				  else{sprintf_P(strProduct,PSTR("N/A"));			  
    6730:	00 d0       	rcall	.+0      	; 0x6732 <systemGenerateReport+0x590>
    6732:	00 d0       	rcall	.+0      	; 0x6734 <systemGenerateReport+0x592>
    6734:	ad b7       	in	r26, 0x3d	; 61
    6736:	be b7       	in	r27, 0x3e	; 62
    6738:	12 96       	adiw	r26, 0x02	; 2
    673a:	dc 92       	st	X, r13
    673c:	ce 92       	st	-X, r12
    673e:	11 97       	sbiw	r26, 0x01	; 1
    6740:	8d e5       	ldi	r24, 0x5D	; 93
    6742:	95 e0       	ldi	r25, 0x05	; 5
    6744:	14 96       	adiw	r26, 0x04	; 4
    6746:	9c 93       	st	X, r25
    6748:	8e 93       	st	-X, r24
    674a:	13 97       	sbiw	r26, 0x03	; 3
    674c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
					   xNozzle++;
    6750:	80 91 2f 02 	lds	r24, 0x022F
    6754:	8f 5f       	subi	r24, 0xFF	; 255
    6756:	80 93 2f 02 	sts	0x022F, r24
					   if (xNozzle>6)stGenerateReport=grNextPump;
    675a:	0f 90       	pop	r0
    675c:	0f 90       	pop	r0
    675e:	0f 90       	pop	r0
    6760:	0f 90       	pop	r0
    6762:	87 30       	cpi	r24, 0x07	; 7
    6764:	10 f4       	brcc	.+4      	; 0x676a <systemGenerateReport+0x5c8>
    6766:	0c 94 ea 3b 	jmp	0x77d4	; 0x77d4 <systemGenerateReport+0x1632>
					  }
				}else stGenerateReport=grNextPump;
    676a:	87 e0       	ldi	r24, 0x07	; 7
    676c:	0c 94 e2 3b 	jmp	0x77c4	; 0x77c4 <systemGenerateReport+0x1622>
			  }
	      break;
     case grNextPump:
	      xNozzle=1;
    6770:	81 e0       	ldi	r24, 0x01	; 1
    6772:	80 93 2f 02 	sts	0x022F, r24
	      xPump++;
    6776:	80 91 30 02 	lds	r24, 0x0230
    677a:	8f 5f       	subi	r24, 0xFF	; 255
    677c:	80 93 30 02 	sts	0x0230, r24
	      if (xPump>8)stGenerateReport=grCreateReportFooter;
    6780:	89 30       	cpi	r24, 0x09	; 9
    6782:	08 f4       	brcc	.+2      	; 0x6786 <systemGenerateReport+0x5e4>
    6784:	93 c4       	rjmp	.+2342   	; 0x70ac <systemGenerateReport+0xf0a>
    6786:	8a e0       	ldi	r24, 0x0A	; 10
    6788:	0c 94 e2 3b 	jmp	0x77c4	; 0x77c4 <systemGenerateReport+0x1622>
		  else stGenerateReport=grGenerateReportData;
	      break;
     case grCreateReportTotalizer:

          RepPos=0;
    678c:	10 92 20 02 	sts	0x0220, r1
    6790:	10 92 1f 02 	sts	0x021F, r1
    6794:	e7 ef       	ldi	r30, 0xF7	; 247
    6796:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    6798:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    679a:	b7 e0       	ldi	r27, 0x07	; 7
    679c:	ec 38       	cpi	r30, 0x8C	; 140
    679e:	fb 07       	cpc	r31, r27
    67a0:	d9 f7       	brne	.-10     	; 0x6798 <systemGenerateReport+0x5f6>
    67a2:	fe 01       	movw	r30, r28
    67a4:	eb 55       	subi	r30, 0x5B	; 91
    67a6:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    67a8:	ce 01       	movw	r24, r28
    67aa:	8b 50       	subi	r24, 0x0B	; 11
    67ac:	9f 4f       	sbci	r25, 0xFF	; 255
    67ae:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67b0:	e8 17       	cp	r30, r24
    67b2:	f9 07       	cpc	r31, r25
    67b4:	e1 f7       	brne	.-8      	; 0x67ae <systemGenerateReport+0x60c>
    67b6:	e8 e3       	ldi	r30, 0x38	; 56
    67b8:	fe e0       	ldi	r31, 0x0E	; 14
	     strMemory[i]=data;
    67ba:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67bc:	8e e0       	ldi	r24, 0x0E	; 14
    67be:	e7 34       	cpi	r30, 0x47	; 71
    67c0:	f8 07       	cpc	r31, r24
    67c2:	d9 f7       	brne	.-10     	; 0x67ba <systemGenerateReport+0x618>
    67c4:	ed e0       	ldi	r30, 0x0D	; 13
    67c6:	fb e0       	ldi	r31, 0x0B	; 11
	     strMemory[i]=data;
    67c8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67ca:	9b e0       	ldi	r25, 0x0B	; 11
    67cc:	ec 31       	cpi	r30, 0x1C	; 28
    67ce:	f9 07       	cpc	r31, r25
    67d0:	d9 f7       	brne	.-10     	; 0x67c8 <systemGenerateReport+0x626>
    67d2:	fe 01       	movw	r30, r28
    67d4:	79 96       	adiw	r30, 0x19	; 25
	     strMemory[i]=data;
    67d6:	ce 01       	movw	r24, r28
    67d8:	88 96       	adiw	r24, 0x28	; 40
    67da:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67dc:	e8 17       	cp	r30, r24
    67de:	f9 07       	cpc	r31, r25
    67e0:	e1 f7       	brne	.-8      	; 0x67da <systemGenerateReport+0x638>
	     strMemory[i]=data;
    67e2:	ce 01       	movw	r24, r28
    67e4:	c7 96       	adiw	r24, 0x37	; 55
    67e6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67e8:	e8 17       	cp	r30, r24
    67ea:	f9 07       	cpc	r31, r25
    67ec:	e1 f7       	brne	.-8      	; 0x67e6 <systemGenerateReport+0x644>
	     strMemory[i]=data;
    67ee:	cf 01       	movw	r24, r30
    67f0:	0f 96       	adiw	r24, 0x0f	; 15
    67f2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67f4:	e8 17       	cp	r30, r24
    67f6:	f9 07       	cpc	r31, r25
    67f8:	e1 f7       	brne	.-8      	; 0x67f2 <systemGenerateReport+0x650>
    67fa:	fe 01       	movw	r30, r28
    67fc:	ea 5b       	subi	r30, 0xBA	; 186
    67fe:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6800:	cf 01       	movw	r24, r30
    6802:	ee 2e       	mov	r14, r30
    6804:	d9 2e       	mov	r13, r25
    6806:	0f 96       	adiw	r24, 0x0f	; 15
    6808:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    680a:	e8 17       	cp	r30, r24
    680c:	f9 07       	cpc	r31, r25
    680e:	e1 f7       	brne	.-8      	; 0x6808 <systemGenerateReport+0x666>
		  FillChar(strLastMoney,sizeof(strLastMoney),0);

		  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
		  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

          FIPAddr=GetFIPAddr(PumpNum); 
    6810:	80 91 2d 02 	lds	r24, 0x022D
    6814:	0e 94 bd 1a 	call	0x357a	; 0x357a <GetFIPAddr>
		  if (FIPAddr>0){
    6818:	88 23       	and	r24, r24
    681a:	49 f1       	breq	.+82     	; 0x686e <systemGenerateReport+0x6cc>
		      FIPAddr=FIPAddr-1;		  
    681c:	f8 2e       	mov	r15, r24
    681e:	fa 94       	dec	r15
			  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    6820:	80 e0       	ldi	r24, 0x00	; 0
    6822:	60 e0       	ldi	r22, 0x00	; 0
    6824:	4f 2d       	mov	r20, r15
    6826:	20 91 2c 02 	lds	r18, 0x022C
    682a:	8e 01       	movw	r16, r28
    682c:	07 5e       	subi	r16, 0xE7	; 231
    682e:	1f 4f       	sbci	r17, 0xFF	; 255
    6830:	0e 94 84 1b 	call	0x3708	; 0x3708 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    6834:	81 e0       	ldi	r24, 0x01	; 1
    6836:	60 e0       	ldi	r22, 0x00	; 0
    6838:	4f 2d       	mov	r20, r15
    683a:	20 91 2c 02 	lds	r18, 0x022C
    683e:	8e 01       	movw	r16, r28
    6840:	08 5d       	subi	r16, 0xD8	; 216
    6842:	1f 4f       	sbci	r17, 0xFF	; 255
    6844:	0e 94 84 1b 	call	0x3708	; 0x3708 <GetTotalizerData>

			  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    6848:	80 e0       	ldi	r24, 0x00	; 0
    684a:	61 e0       	ldi	r22, 0x01	; 1
    684c:	4f 2d       	mov	r20, r15
    684e:	20 91 2c 02 	lds	r18, 0x022C
    6852:	8e 01       	movw	r16, r28
    6854:	09 5c       	subi	r16, 0xC9	; 201
    6856:	1f 4f       	sbci	r17, 0xFF	; 255
    6858:	0e 94 84 1b 	call	0x3708	; 0x3708 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    685c:	81 e0       	ldi	r24, 0x01	; 1
    685e:	61 e0       	ldi	r22, 0x01	; 1
    6860:	4f 2d       	mov	r20, r15
    6862:	20 91 2c 02 	lds	r18, 0x022C
    6866:	0e 2d       	mov	r16, r14
    6868:	1d 2d       	mov	r17, r13
    686a:	0e 94 84 1b 	call	0x3708	; 0x3708 <GetTotalizerData>
		  }

		  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    686e:	80 e0       	ldi	r24, 0x00	; 0
    6870:	be 01       	movw	r22, r28
    6872:	69 5c       	subi	r22, 0xC9	; 201
    6874:	7f 4f       	sbci	r23, 0xFF	; 255
    6876:	ae 01       	movw	r20, r28
    6878:	47 5e       	subi	r20, 0xE7	; 231
    687a:	5f 4f       	sbci	r21, 0xFF	; 255
    687c:	2d e0       	ldi	r18, 0x0D	; 13
    687e:	3b e0       	ldi	r19, 0x0B	; 11
    6880:	0e 94 db 25 	call	0x4bb6	; 0x4bb6 <StrCalc>

		  if (IsMinus(strDeltaVolume)==True)
    6884:	8d e0       	ldi	r24, 0x0D	; 13
    6886:	9b e0       	ldi	r25, 0x0B	; 11
    6888:	0e 94 9e 20 	call	0x413c	; 0x413c <IsMinus>
    688c:	81 30       	cpi	r24, 0x01	; 1
    688e:	21 f4       	brne	.+8      	; 0x6898 <systemGenerateReport+0x6f6>
		      NormalizeOverflow(strDeltaVolume);
    6890:	8d e0       	ldi	r24, 0x0D	; 13
    6892:	9b e0       	ldi	r25, 0x0B	; 11
    6894:	0e 94 5f 29 	call	0x52be	; 0x52be <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6898:	e1 99       	sbic	0x1c, 1	; 28
    689a:	fe cf       	rjmp	.-4      	; 0x6898 <systemGenerateReport+0x6f6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    689c:	57 e6       	ldi	r21, 0x67	; 103
    689e:	85 2e       	mov	r8, r21
    68a0:	51 e0       	ldi	r21, 0x01	; 1
    68a2:	95 2e       	mov	r9, r21
    68a4:	9f ba       	out	0x1f, r9	; 31
    68a6:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    68a8:	e0 9a       	sbi	0x1c, 0	; 28
    68aa:	8d b3       	in	r24, 0x1d	; 29

		  //Calculate Wayne Estimated Total Money
		  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    68ac:	82 30       	cpi	r24, 0x02	; 2
    68ae:	79 f4       	brne	.+30     	; 0x68ce <systemGenerateReport+0x72c>
              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    68b0:	8e 01       	movw	r16, r28
    68b2:	01 5f       	subi	r16, 0xF1	; 241
    68b4:	1f 4f       	sbci	r17, 0xFF	; 255
    68b6:	c8 01       	movw	r24, r16
    68b8:	60 91 2d 02 	lds	r22, 0x022D
    68bc:	40 91 2c 02 	lds	r20, 0x022C
    68c0:	0e 94 81 21 	call	0x4302	; 0x4302 <GetProductPrice>
			  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    68c4:	82 e0       	ldi	r24, 0x02	; 2
    68c6:	b8 01       	movw	r22, r16
    68c8:	4d e0       	ldi	r20, 0x0D	; 13
    68ca:	5b e0       	ldi	r21, 0x0B	; 11
    68cc:	07 c0       	rjmp	.+14     	; 0x68dc <systemGenerateReport+0x73a>
			  
		  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    68ce:	80 e0       	ldi	r24, 0x00	; 0
    68d0:	be 01       	movw	r22, r28
    68d2:	6a 5b       	subi	r22, 0xBA	; 186
    68d4:	7f 4f       	sbci	r23, 0xFF	; 255
    68d6:	ae 01       	movw	r20, r28
    68d8:	48 5d       	subi	r20, 0xD8	; 216
    68da:	5f 4f       	sbci	r21, 0xFF	; 255
    68dc:	28 e3       	ldi	r18, 0x38	; 56
    68de:	3e e0       	ldi	r19, 0x0E	; 14
    68e0:	0e 94 db 25 	call	0x4bb6	; 0x4bb6 <StrCalc>

		  if (IsMinus(strDeltaMoney)==True)
    68e4:	88 e3       	ldi	r24, 0x38	; 56
    68e6:	9e e0       	ldi	r25, 0x0E	; 14
    68e8:	0e 94 9e 20 	call	0x413c	; 0x413c <IsMinus>
    68ec:	81 30       	cpi	r24, 0x01	; 1
    68ee:	21 f4       	brne	.+8      	; 0x68f8 <systemGenerateReport+0x756>
		      NormalizeOverflow(strDeltaMoney);
    68f0:	88 e3       	ldi	r24, 0x38	; 56
    68f2:	9e e0       	ldi	r25, 0x0E	; 14
    68f4:	0e 94 5f 29 	call	0x52be	; 0x52be <NormalizeOverflow>

		  AddList(GradeUsed,GradeList);
    68f8:	80 91 2b 02 	lds	r24, 0x022B
    68fc:	61 e2       	ldi	r22, 0x21	; 33
    68fe:	72 e0       	ldi	r23, 0x02	; 2
    6900:	0e 94 a7 1f 	call	0x3f4e	; 0x3f4e <AddList>
		  
		  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    6904:	81 e0       	ldi	r24, 0x01	; 1
    6906:	68 e2       	ldi	r22, 0x28	; 40
    6908:	7a e0       	ldi	r23, 0x0A	; 10
    690a:	4d e0       	ldi	r20, 0x0D	; 13
    690c:	5b e0       	ldi	r21, 0x0B	; 11
    690e:	9b 01       	movw	r18, r22
    6910:	0e 94 db 25 	call	0x4bb6	; 0x4bb6 <StrCalc>
		  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    6914:	81 e0       	ldi	r24, 0x01	; 1
    6916:	6d ed       	ldi	r22, 0xDD	; 221
    6918:	7a e0       	ldi	r23, 0x0A	; 10
    691a:	48 e3       	ldi	r20, 0x38	; 56
    691c:	5e e0       	ldi	r21, 0x0E	; 14
    691e:	9b 01       	movw	r18, r22
    6920:	0e 94 db 25 	call	0x4bb6	; 0x4bb6 <StrCalc>


		  RemZeroLead(strDeltaMoney);
    6924:	88 e3       	ldi	r24, 0x38	; 56
    6926:	9e e0       	ldi	r25, 0x0E	; 14
    6928:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
		  RemZeroLead(strCurrentMoney);
    692c:	46 e4       	ldi	r20, 0x46	; 70
    692e:	c4 2e       	mov	r12, r20
    6930:	d1 2c       	mov	r13, r1
    6932:	cc 0e       	add	r12, r28
    6934:	dd 1e       	adc	r13, r29
    6936:	c6 01       	movw	r24, r12
    6938:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
		  RemZeroLead(strLastMoney);
    693c:	38 e2       	ldi	r19, 0x28	; 40
    693e:	e3 2e       	mov	r14, r19
    6940:	f1 2c       	mov	r15, r1
    6942:	ec 0e       	add	r14, r28
    6944:	fd 1e       	adc	r15, r29
    6946:	c7 01       	movw	r24, r14
    6948:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>

          RemZeroLead(strDeltaVolume);
    694c:	8d e0       	ldi	r24, 0x0D	; 13
    694e:	9b e0       	ldi	r25, 0x0B	; 11
    6950:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
          RemZeroLead(strCurrentVolume);
    6954:	27 e3       	ldi	r18, 0x37	; 55
    6956:	a2 2e       	mov	r10, r18
    6958:	b1 2c       	mov	r11, r1
    695a:	ac 0e       	add	r10, r28
    695c:	bd 1e       	adc	r11, r29
    695e:	c5 01       	movw	r24, r10
    6960:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
          RemZeroLead(strLastVolume);
    6964:	8e 01       	movw	r16, r28
    6966:	07 5e       	subi	r16, 0xE7	; 231
    6968:	1f 4f       	sbci	r17, 0xFF	; 255
    696a:	c8 01       	movw	r24, r16
    696c:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>

		  FormatTotalizerMoney(strDeltaMoney);
    6970:	88 e3       	ldi	r24, 0x38	; 56
    6972:	9e e0       	ldi	r25, 0x0E	; 14
    6974:	0e 94 9d 30 	call	0x613a	; 0x613a <FormatTotalizerMoney>
		  FormatTotalizerMoney(strCurrentMoney);
    6978:	c6 01       	movw	r24, r12
    697a:	0e 94 9d 30 	call	0x613a	; 0x613a <FormatTotalizerMoney>
		  FormatTotalizerMoney(strLastMoney);
    697e:	c7 01       	movw	r24, r14
    6980:	0e 94 9d 30 	call	0x613a	; 0x613a <FormatTotalizerMoney>

		  FormatTotalizerVolume(strDeltaVolume);
    6984:	8d e0       	ldi	r24, 0x0D	; 13
    6986:	9b e0       	ldi	r25, 0x0B	; 11
    6988:	0e 94 90 30 	call	0x6120	; 0x6120 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strLastVolume);
    698c:	c8 01       	movw	r24, r16
    698e:	0e 94 90 30 	call	0x6120	; 0x6120 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strCurrentVolume); 
    6992:	c5 01       	movw	r24, r10
    6994:	0e 94 90 30 	call	0x6120	; 0x6120 <FormatTotalizerVolume>

          FormatCurrency(strDeltaMoney);
    6998:	88 e3       	ldi	r24, 0x38	; 56
    699a:	9e e0       	ldi	r25, 0x0E	; 14
    699c:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>
		  FormatCurrency(strCurrentMoney);
    69a0:	c6 01       	movw	r24, r12
    69a2:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>
		  FormatCurrency(strLastMoney);
    69a6:	c7 01       	movw	r24, r14
    69a8:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>

		  FormatCurrency(strDeltaVolume);		  
    69ac:	8d e0       	ldi	r24, 0x0D	; 13
    69ae:	9b e0       	ldi	r25, 0x0B	; 11
    69b0:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>
		  FormatCurrency(strLastVolume);
    69b4:	c8 01       	movw	r24, r16
    69b6:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>
          FormatCurrency(strCurrentVolume);
    69ba:	c5 01       	movw	r24, r10
    69bc:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>


          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    69c0:	81 e0       	ldi	r24, 0x01	; 1
    69c2:	67 ef       	ldi	r22, 0xF7	; 247
    69c4:	75 e0       	ldi	r23, 0x05	; 5
    69c6:	41 e0       	ldi	r20, 0x01	; 1
    69c8:	2f e1       	ldi	r18, 0x1F	; 31
    69ca:	32 e0       	ldi	r19, 0x02	; 2
    69cc:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    69d0:	8b e0       	ldi	r24, 0x0B	; 11
    69d2:	67 ef       	ldi	r22, 0xF7	; 247
    69d4:	75 e0       	ldi	r23, 0x05	; 5
    69d6:	4a e2       	ldi	r20, 0x2A	; 42
    69d8:	2f e1       	ldi	r18, 0x1F	; 31
    69da:	32 e0       	ldi	r19, 0x02	; 2
    69dc:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    69e0:	83 e0       	ldi	r24, 0x03	; 3
    69e2:	67 ef       	ldi	r22, 0xF7	; 247
    69e4:	75 e0       	ldi	r23, 0x05	; 5
    69e6:	41 e0       	ldi	r20, 0x01	; 1
    69e8:	2f e1       	ldi	r18, 0x1F	; 31
    69ea:	32 e0       	ldi	r19, 0x02	; 2
    69ec:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    69f0:	8c e0       	ldi	r24, 0x0C	; 12
    69f2:	67 ef       	ldi	r22, 0xF7	; 247
    69f4:	75 e0       	ldi	r23, 0x05	; 5
    69f6:	41 e0       	ldi	r20, 0x01	; 1
    69f8:	2f e1       	ldi	r18, 0x1F	; 31
    69fa:	32 e0       	ldi	r19, 0x02	; 2
    69fc:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6a00:	e1 99       	sbic	0x1c, 1	; 28
    6a02:	fe cf       	rjmp	.-4      	; 0x6a00 <systemGenerateReport+0x85e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6a04:	9f ba       	out	0x1f, r9	; 31
    6a06:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6a08:	e0 9a       	sbi	0x1c, 0	; 28
    6a0a:	8d b3       	in	r24, 0x1d	; 29
    6a0c:	9d e6       	ldi	r25, 0x6D	; 109
    6a0e:	c9 2e       	mov	r12, r25
    6a10:	99 e0       	ldi	r25, 0x09	; 9
    6a12:	d9 2e       	mov	r13, r25
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    6a14:	82 30       	cpi	r24, 0x02	; 2
    6a16:	09 f0       	breq	.+2      	; 0x6a1a <systemGenerateReport+0x878>
    6a18:	84 c0       	rjmp	.+264    	; 0x6b22 <systemGenerateReport+0x980>
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
    6a1a:	0f e0       	ldi	r16, 0x0F	; 15
    6a1c:	e0 2e       	mov	r14, r16
    6a1e:	f1 2c       	mov	r15, r1
    6a20:	ec 0e       	add	r14, r28
    6a22:	fd 1e       	adc	r15, r29
    6a24:	c7 01       	movw	r24, r14
    6a26:	60 91 2d 02 	lds	r22, 0x022D
    6a2a:	40 91 2c 02 	lds	r20, 0x022C
    6a2e:	0e 94 81 21 	call	0x4302	; 0x4302 <GetProductPrice>
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);
    6a32:	00 d0       	rcall	.+0      	; 0x6a34 <systemGenerateReport+0x892>
    6a34:	00 d0       	rcall	.+0      	; 0x6a36 <systemGenerateReport+0x894>
    6a36:	00 d0       	rcall	.+0      	; 0x6a38 <systemGenerateReport+0x896>
    6a38:	ed b7       	in	r30, 0x3d	; 61
    6a3a:	fe b7       	in	r31, 0x3e	; 62
    6a3c:	31 96       	adiw	r30, 0x01	; 1
    6a3e:	8e 01       	movw	r16, r28
    6a40:	0f 56       	subi	r16, 0x6F	; 111
    6a42:	1f 4f       	sbci	r17, 0xFF	; 255
    6a44:	ad b7       	in	r26, 0x3d	; 61
    6a46:	be b7       	in	r27, 0x3e	; 62
    6a48:	12 96       	adiw	r26, 0x02	; 2
    6a4a:	1c 93       	st	X, r17
    6a4c:	0e 93       	st	-X, r16
    6a4e:	11 97       	sbiw	r26, 0x01	; 1
    6a50:	80 e5       	ldi	r24, 0x50	; 80
    6a52:	95 e0       	ldi	r25, 0x05	; 5
    6a54:	93 83       	std	Z+3, r25	; 0x03
    6a56:	82 83       	std	Z+2, r24	; 0x02
    6a58:	f5 82       	std	Z+5, r15	; 0x05
    6a5a:	e4 82       	std	Z+4, r14	; 0x04
    6a5c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
    6a60:	d6 01       	movw	r26, r12
    6a62:	0d 90       	ld	r0, X+
    6a64:	00 20       	and	r0, r0
    6a66:	e9 f7       	brne	.-6      	; 0x6a62 <systemGenerateReport+0x8c0>
    6a68:	11 97       	sbiw	r26, 0x01	; 1
    6a6a:	ac 19       	sub	r26, r12
    6a6c:	bd 09       	sbc	r27, r13
    6a6e:	f8 01       	movw	r30, r16
    6a70:	01 90       	ld	r0, Z+
    6a72:	00 20       	and	r0, r0
    6a74:	e9 f7       	brne	.-6      	; 0x6a70 <systemGenerateReport+0x8ce>
    6a76:	31 97       	sbiw	r30, 0x01	; 1
    6a78:	0e 1b       	sub	r16, r30
    6a7a:	0a 1b       	sub	r16, r26
    6a7c:	05 5e       	subi	r16, 0xE5	; 229
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6a7e:	ed b7       	in	r30, 0x3d	; 61
    6a80:	fe b7       	in	r31, 0x3e	; 62
    6a82:	36 96       	adiw	r30, 0x06	; 6
    6a84:	0f b6       	in	r0, 0x3f	; 63
    6a86:	f8 94       	cli
    6a88:	fe bf       	out	0x3e, r31	; 62
    6a8a:	0f be       	out	0x3f, r0	; 63
    6a8c:	ed bf       	out	0x3d, r30	; 61
    6a8e:	fe 01       	movw	r30, r28
    6a90:	e3 58       	subi	r30, 0x83	; 131
    6a92:	ff 4f       	sbci	r31, 0xFF	; 255
    6a94:	10 16       	cp	r1, r16
    6a96:	74 f4       	brge	.+28     	; 0x6ab4 <systemGenerateReport+0x912>
    6a98:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6a9a:	90 e2       	ldi	r25, 0x20	; 32
    6a9c:	02 c0       	rjmp	.+4      	; 0x6aa2 <systemGenerateReport+0x900>
    6a9e:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6aa0:	8f 5f       	subi	r24, 0xFF	; 255
    6aa2:	80 17       	cp	r24, r16
    6aa4:	e0 f3       	brcs	.-8      	; 0x6a9e <systemGenerateReport+0x8fc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6aa6:	fe 01       	movw	r30, r28
    6aa8:	e3 58       	subi	r30, 0x83	; 131
    6aaa:	ff 4f       	sbci	r31, 0xFF	; 255
    6aac:	e0 0f       	add	r30, r16
    6aae:	f1 1d       	adc	r31, r1
    6ab0:	10 82       	st	Z, r1
    6ab2:	03 c0       	rjmp	.+6      	; 0x6aba <systemGenerateReport+0x918>
     }else{
	 strTab[0]=' ';
    6ab4:	80 e2       	ldi	r24, 0x20	; 32
    6ab6:	80 83       	st	Z, r24
	 strTab[1]=0;
    6ab8:	11 82       	std	Z+1, r1	; 0x01
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
		      sprintf_P(strReport,PSTR("P%d.%d - %s %s %s"),PumpNum,PumpNozzle,strProduct,strTabSpace2,strProductPrice);
    6aba:	8d b7       	in	r24, 0x3d	; 61
    6abc:	9e b7       	in	r25, 0x3e	; 62
    6abe:	0e 97       	sbiw	r24, 0x0e	; 14
    6ac0:	0f b6       	in	r0, 0x3f	; 63
    6ac2:	f8 94       	cli
    6ac4:	9e bf       	out	0x3e, r25	; 62
    6ac6:	0f be       	out	0x3f, r0	; 63
    6ac8:	8d bf       	out	0x3d, r24	; 61
    6aca:	ed b7       	in	r30, 0x3d	; 61
    6acc:	fe b7       	in	r31, 0x3e	; 62
    6ace:	31 96       	adiw	r30, 0x01	; 1
    6ad0:	ce 01       	movw	r24, r28
    6ad2:	8b 55       	subi	r24, 0x5B	; 91
    6ad4:	9f 4f       	sbci	r25, 0xFF	; 255
    6ad6:	ad b7       	in	r26, 0x3d	; 61
    6ad8:	be b7       	in	r27, 0x3e	; 62
    6ada:	12 96       	adiw	r26, 0x02	; 2
    6adc:	9c 93       	st	X, r25
    6ade:	8e 93       	st	-X, r24
    6ae0:	11 97       	sbiw	r26, 0x01	; 1
    6ae2:	8e e3       	ldi	r24, 0x3E	; 62
    6ae4:	95 e0       	ldi	r25, 0x05	; 5
    6ae6:	93 83       	std	Z+3, r25	; 0x03
    6ae8:	82 83       	std	Z+2, r24	; 0x02
    6aea:	80 91 2d 02 	lds	r24, 0x022D
    6aee:	84 83       	std	Z+4, r24	; 0x04
    6af0:	15 82       	std	Z+5, r1	; 0x05
    6af2:	80 91 2c 02 	lds	r24, 0x022C
    6af6:	86 83       	std	Z+6, r24	; 0x06
    6af8:	17 82       	std	Z+7, r1	; 0x07
    6afa:	8d e6       	ldi	r24, 0x6D	; 109
    6afc:	99 e0       	ldi	r25, 0x09	; 9
    6afe:	91 87       	std	Z+9, r25	; 0x09
    6b00:	80 87       	std	Z+8, r24	; 0x08
    6b02:	ce 01       	movw	r24, r28
    6b04:	83 58       	subi	r24, 0x83	; 131
    6b06:	9f 4f       	sbci	r25, 0xFF	; 255
    6b08:	93 87       	std	Z+11, r25	; 0x0b
    6b0a:	82 87       	std	Z+10, r24	; 0x0a
    6b0c:	ce 01       	movw	r24, r28
    6b0e:	8f 56       	subi	r24, 0x6F	; 111
    6b10:	9f 4f       	sbci	r25, 0xFF	; 255
    6b12:	95 87       	std	Z+13, r25	; 0x0d
    6b14:	84 87       	std	Z+12, r24	; 0x0c
    6b16:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    6b1a:	ed b7       	in	r30, 0x3d	; 61
    6b1c:	fe b7       	in	r31, 0x3e	; 62
    6b1e:	3e 96       	adiw	r30, 0x0e	; 14
    6b20:	27 c0       	rjmp	.+78     	; 0x6b70 <systemGenerateReport+0x9ce>
		  }
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
    6b22:	8d b7       	in	r24, 0x3d	; 61
    6b24:	9e b7       	in	r25, 0x3e	; 62
    6b26:	0a 97       	sbiw	r24, 0x0a	; 10
    6b28:	0f b6       	in	r0, 0x3f	; 63
    6b2a:	f8 94       	cli
    6b2c:	9e bf       	out	0x3e, r25	; 62
    6b2e:	0f be       	out	0x3f, r0	; 63
    6b30:	8d bf       	out	0x3d, r24	; 61
    6b32:	ed b7       	in	r30, 0x3d	; 61
    6b34:	fe b7       	in	r31, 0x3e	; 62
    6b36:	31 96       	adiw	r30, 0x01	; 1
    6b38:	ce 01       	movw	r24, r28
    6b3a:	8b 55       	subi	r24, 0x5B	; 91
    6b3c:	9f 4f       	sbci	r25, 0xFF	; 255
    6b3e:	ad b7       	in	r26, 0x3d	; 61
    6b40:	be b7       	in	r27, 0x3e	; 62
    6b42:	12 96       	adiw	r26, 0x02	; 2
    6b44:	9c 93       	st	X, r25
    6b46:	8e 93       	st	-X, r24
    6b48:	11 97       	sbiw	r26, 0x01	; 1
    6b4a:	81 e3       	ldi	r24, 0x31	; 49
    6b4c:	95 e0       	ldi	r25, 0x05	; 5
    6b4e:	93 83       	std	Z+3, r25	; 0x03
    6b50:	82 83       	std	Z+2, r24	; 0x02
    6b52:	80 91 2d 02 	lds	r24, 0x022D
    6b56:	84 83       	std	Z+4, r24	; 0x04
    6b58:	15 82       	std	Z+5, r1	; 0x05
    6b5a:	80 91 2c 02 	lds	r24, 0x022C
    6b5e:	86 83       	std	Z+6, r24	; 0x06
    6b60:	17 82       	std	Z+7, r1	; 0x07
    6b62:	d1 86       	std	Z+9, r13	; 0x09
    6b64:	c0 86       	std	Z+8, r12	; 0x08
    6b66:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    6b6a:	ed b7       	in	r30, 0x3d	; 61
    6b6c:	fe b7       	in	r31, 0x3e	; 62
    6b6e:	3a 96       	adiw	r30, 0x0a	; 10
    6b70:	0f b6       	in	r0, 0x3f	; 63
    6b72:	f8 94       	cli
    6b74:	fe bf       	out	0x3e, r31	; 62
    6b76:	0f be       	out	0x3f, r0	; 63
    6b78:	ed bf       	out	0x3d, r30	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    6b7a:	ce 01       	movw	r24, r28
    6b7c:	8b 55       	subi	r24, 0x5B	; 91
    6b7e:	9f 4f       	sbci	r25, 0xFF	; 255
    6b80:	67 ef       	ldi	r22, 0xF7	; 247
    6b82:	75 e0       	ldi	r23, 0x05	; 5
    6b84:	4f e1       	ldi	r20, 0x1F	; 31
    6b86:	52 e0       	ldi	r21, 0x02	; 2
    6b88:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <CreateReport>
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    6b8c:	84 e0       	ldi	r24, 0x04	; 4
    6b8e:	67 ef       	ldi	r22, 0xF7	; 247
    6b90:	75 e0       	ldi	r23, 0x05	; 5
    6b92:	41 e0       	ldi	r20, 0x01	; 1
    6b94:	2f e1       	ldi	r18, 0x1F	; 31
    6b96:	32 e0       	ldi	r19, 0x02	; 2
    6b98:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    6b9c:	8b e0       	ldi	r24, 0x0B	; 11
    6b9e:	67 ef       	ldi	r22, 0xF7	; 247
    6ba0:	75 e0       	ldi	r23, 0x05	; 5
    6ba2:	4a e2       	ldi	r20, 0x2A	; 42
    6ba4:	2f e1       	ldi	r18, 0x1F	; 31
    6ba6:	32 e0       	ldi	r19, 0x02	; 2
    6ba8:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    6bac:	86 e0       	ldi	r24, 0x06	; 6
    6bae:	67 ef       	ldi	r22, 0xF7	; 247
    6bb0:	75 e0       	ldi	r23, 0x05	; 5
    6bb2:	41 e0       	ldi	r20, 0x01	; 1
    6bb4:	2f e1       	ldi	r18, 0x1F	; 31
    6bb6:	32 e0       	ldi	r19, 0x02	; 2
    6bb8:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    6bbc:	8c e0       	ldi	r24, 0x0C	; 12
    6bbe:	67 ef       	ldi	r22, 0xF7	; 247
    6bc0:	75 e0       	ldi	r23, 0x05	; 5
    6bc2:	41 e0       	ldi	r20, 0x01	; 1
    6bc4:	2f e1       	ldi	r18, 0x1F	; 31
    6bc6:	32 e0       	ldi	r19, 0x02	; 2
    6bc8:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
    6bcc:	de 01       	movw	r26, r28
    6bce:	d7 96       	adiw	r26, 0x37	; 55
    6bd0:	fd 01       	movw	r30, r26
    6bd2:	01 90       	ld	r0, Z+
    6bd4:	00 20       	and	r0, r0
    6bd6:	e9 f7       	brne	.-6      	; 0x6bd2 <systemGenerateReport+0xa30>
    6bd8:	9a 2f       	mov	r25, r26
    6bda:	9e 1b       	sub	r25, r30
    6bdc:	9e 5e       	subi	r25, 0xEE	; 238
    6bde:	de 01       	movw	r26, r28
    6be0:	a7 59       	subi	r26, 0x97	; 151
    6be2:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6be4:	19 16       	cp	r1, r25
    6be6:	7c f4       	brge	.+30     	; 0x6c06 <systemGenerateReport+0xa64>
    6be8:	fd 01       	movw	r30, r26
    6bea:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6bec:	20 e2       	ldi	r18, 0x20	; 32
    6bee:	02 c0       	rjmp	.+4      	; 0x6bf4 <systemGenerateReport+0xa52>
    6bf0:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6bf2:	8f 5f       	subi	r24, 0xFF	; 255
    6bf4:	89 17       	cp	r24, r25
    6bf6:	e0 f3       	brcs	.-8      	; 0x6bf0 <systemGenerateReport+0xa4e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6bf8:	fe 01       	movw	r30, r28
    6bfa:	e7 59       	subi	r30, 0x97	; 151
    6bfc:	ff 4f       	sbci	r31, 0xFF	; 255
    6bfe:	e9 0f       	add	r30, r25
    6c00:	f1 1d       	adc	r31, r1
    6c02:	10 82       	st	Z, r1
    6c04:	04 c0       	rjmp	.+8      	; 0x6c0e <systemGenerateReport+0xa6c>
     }else{
	 strTab[0]=' ';
    6c06:	80 e2       	ldi	r24, 0x20	; 32
    6c08:	8c 93       	st	X, r24
	 strTab[1]=0;
    6c0a:	11 96       	adiw	r26, 0x01	; 1
    6c0c:	1c 92       	st	X, r1
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
		  CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
    6c0e:	de 01       	movw	r26, r28
    6c10:	aa 5b       	subi	r26, 0xBA	; 186
    6c12:	bf 4f       	sbci	r27, 0xFF	; 255
    6c14:	fd 01       	movw	r30, r26
    6c16:	01 90       	ld	r0, Z+
    6c18:	00 20       	and	r0, r0
    6c1a:	e9 f7       	brne	.-6      	; 0x6c16 <systemGenerateReport+0xa74>
    6c1c:	ae 1b       	sub	r26, r30
    6c1e:	a0 5f       	subi	r26, 0xF0	; 240
    6c20:	fe 01       	movw	r30, r28
    6c22:	e3 58       	subi	r30, 0x83	; 131
    6c24:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6c26:	1a 16       	cp	r1, r26
    6c28:	74 f4       	brge	.+28     	; 0x6c46 <systemGenerateReport+0xaa4>
    6c2a:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6c2c:	90 e2       	ldi	r25, 0x20	; 32
    6c2e:	02 c0       	rjmp	.+4      	; 0x6c34 <systemGenerateReport+0xa92>
    6c30:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6c32:	8f 5f       	subi	r24, 0xFF	; 255
    6c34:	8a 17       	cp	r24, r26
    6c36:	e0 f3       	brcs	.-8      	; 0x6c30 <systemGenerateReport+0xa8e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6c38:	fe 01       	movw	r30, r28
    6c3a:	e3 58       	subi	r30, 0x83	; 131
    6c3c:	ff 4f       	sbci	r31, 0xFF	; 255
    6c3e:	ea 0f       	add	r30, r26
    6c40:	f1 1d       	adc	r31, r1
    6c42:	10 82       	st	Z, r1
    6c44:	03 c0       	rjmp	.+6      	; 0x6c4c <systemGenerateReport+0xaaa>
     }else{
	 strTab[0]=' ';
    6c46:	80 e2       	ldi	r24, 0x20	; 32
    6c48:	80 83       	st	Z, r24
	 strTab[1]=0;
    6c4a:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6c4c:	e1 99       	sbic	0x1c, 1	; 28
    6c4e:	fe cf       	rjmp	.-4      	; 0x6c4c <systemGenerateReport+0xaaa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6c50:	11 ef       	ldi	r17, 0xF1	; 241
    6c52:	e1 2e       	mov	r14, r17
    6c54:	13 e0       	ldi	r17, 0x03	; 3
    6c56:	f1 2e       	mov	r15, r17
    6c58:	ff ba       	out	0x1f, r15	; 31
    6c5a:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6c5c:	e0 9a       	sbi	0x1c, 0	; 28
    6c5e:	8d b3       	in	r24, 0x1d	; 29
    6c60:	9e 01       	movw	r18, r28
    6c62:	2b 55       	subi	r18, 0x5B	; 91
    6c64:	3f 4f       	sbci	r19, 0xFF	; 255
    6c66:	ae 01       	movw	r20, r28
    6c68:	49 5c       	subi	r20, 0xC9	; 201
    6c6a:	5f 4f       	sbci	r21, 0xFF	; 255
    6c6c:	de 01       	movw	r26, r28
    6c6e:	a7 59       	subi	r26, 0x97	; 151
    6c70:	bf 4f       	sbci	r27, 0xFF	; 255
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    6c72:	81 30       	cpi	r24, 0x01	; 1
    6c74:	49 f5       	brne	.+82     	; 0x6cc8 <systemGenerateReport+0xb26>
    6c76:	8d b7       	in	r24, 0x3d	; 61
    6c78:	9e b7       	in	r25, 0x3e	; 62
    6c7a:	0c 97       	sbiw	r24, 0x0c	; 12
    6c7c:	0f b6       	in	r0, 0x3f	; 63
    6c7e:	f8 94       	cli
    6c80:	9e bf       	out	0x3e, r25	; 62
    6c82:	0f be       	out	0x3f, r0	; 63
    6c84:	8d bf       	out	0x3d, r24	; 61
    6c86:	6d b7       	in	r22, 0x3d	; 61
    6c88:	7e b7       	in	r23, 0x3e	; 62
    6c8a:	6f 5f       	subi	r22, 0xFF	; 255
    6c8c:	7f 4f       	sbci	r23, 0xFF	; 255
    6c8e:	ed b7       	in	r30, 0x3d	; 61
    6c90:	fe b7       	in	r31, 0x3e	; 62
    6c92:	32 83       	std	Z+2, r19	; 0x02
    6c94:	21 83       	std	Z+1, r18	; 0x01
    6c96:	82 e2       	ldi	r24, 0x22	; 34
    6c98:	95 e0       	ldi	r25, 0x05	; 5
    6c9a:	fb 01       	movw	r30, r22
    6c9c:	93 83       	std	Z+3, r25	; 0x03
    6c9e:	82 83       	std	Z+2, r24	; 0x02
    6ca0:	b5 83       	std	Z+5, r27	; 0x05
    6ca2:	a4 83       	std	Z+4, r26	; 0x04
    6ca4:	57 83       	std	Z+7, r21	; 0x07
    6ca6:	46 83       	std	Z+6, r20	; 0x06
    6ca8:	ce 01       	movw	r24, r28
    6caa:	83 58       	subi	r24, 0x83	; 131
    6cac:	9f 4f       	sbci	r25, 0xFF	; 255
    6cae:	91 87       	std	Z+9, r25	; 0x09
    6cb0:	80 87       	std	Z+8, r24	; 0x08
    6cb2:	ce 01       	movw	r24, r28
    6cb4:	8a 5b       	subi	r24, 0xBA	; 186
    6cb6:	9f 4f       	sbci	r25, 0xFF	; 255
    6cb8:	93 87       	std	Z+11, r25	; 0x0b
    6cba:	82 87       	std	Z+10, r24	; 0x0a
    6cbc:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    6cc0:	8d b7       	in	r24, 0x3d	; 61
    6cc2:	9e b7       	in	r25, 0x3e	; 62
    6cc4:	0c 96       	adiw	r24, 0x0c	; 12
    6cc6:	1c c0       	rjmp	.+56     	; 0x6d00 <systemGenerateReport+0xb5e>
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
    6cc8:	ed b7       	in	r30, 0x3d	; 61
    6cca:	fe b7       	in	r31, 0x3e	; 62
    6ccc:	38 97       	sbiw	r30, 0x08	; 8
    6cce:	0f b6       	in	r0, 0x3f	; 63
    6cd0:	f8 94       	cli
    6cd2:	fe bf       	out	0x3e, r31	; 62
    6cd4:	0f be       	out	0x3f, r0	; 63
    6cd6:	ed bf       	out	0x3d, r30	; 61
    6cd8:	6d b7       	in	r22, 0x3d	; 61
    6cda:	7e b7       	in	r23, 0x3e	; 62
    6cdc:	6f 5f       	subi	r22, 0xFF	; 255
    6cde:	7f 4f       	sbci	r23, 0xFF	; 255
    6ce0:	32 83       	std	Z+2, r19	; 0x02
    6ce2:	21 83       	std	Z+1, r18	; 0x01
    6ce4:	87 e1       	ldi	r24, 0x17	; 23
    6ce6:	95 e0       	ldi	r25, 0x05	; 5
    6ce8:	fb 01       	movw	r30, r22
    6cea:	93 83       	std	Z+3, r25	; 0x03
    6cec:	82 83       	std	Z+2, r24	; 0x02
    6cee:	b5 83       	std	Z+5, r27	; 0x05
    6cf0:	a4 83       	std	Z+4, r26	; 0x04
    6cf2:	57 83       	std	Z+7, r21	; 0x07
    6cf4:	46 83       	std	Z+6, r20	; 0x06
    6cf6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    6cfa:	8d b7       	in	r24, 0x3d	; 61
    6cfc:	9e b7       	in	r25, 0x3e	; 62
    6cfe:	08 96       	adiw	r24, 0x08	; 8
    6d00:	0f b6       	in	r0, 0x3f	; 63
    6d02:	f8 94       	cli
    6d04:	9e bf       	out	0x3e, r25	; 62
    6d06:	0f be       	out	0x3f, r0	; 63
    6d08:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    6d0a:	ce 01       	movw	r24, r28
    6d0c:	8b 55       	subi	r24, 0x5B	; 91
    6d0e:	9f 4f       	sbci	r25, 0xFF	; 255
    6d10:	67 ef       	ldi	r22, 0xF7	; 247
    6d12:	75 e0       	ldi	r23, 0x05	; 5
    6d14:	4f e1       	ldi	r20, 0x1F	; 31
    6d16:	52 e0       	ldi	r21, 0x02	; 2
    6d18:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <CreateReport>

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
    6d1c:	de 01       	movw	r26, r28
    6d1e:	59 96       	adiw	r26, 0x19	; 25
    6d20:	fd 01       	movw	r30, r26
    6d22:	01 90       	ld	r0, Z+
    6d24:	00 20       	and	r0, r0
    6d26:	e9 f7       	brne	.-6      	; 0x6d22 <systemGenerateReport+0xb80>
    6d28:	9a 2f       	mov	r25, r26
    6d2a:	9e 1b       	sub	r25, r30
    6d2c:	9e 5e       	subi	r25, 0xEE	; 238
    6d2e:	de 01       	movw	r26, r28
    6d30:	a7 59       	subi	r26, 0x97	; 151
    6d32:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6d34:	19 16       	cp	r1, r25
    6d36:	7c f4       	brge	.+30     	; 0x6d56 <systemGenerateReport+0xbb4>
    6d38:	fd 01       	movw	r30, r26
    6d3a:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6d3c:	20 e2       	ldi	r18, 0x20	; 32
    6d3e:	02 c0       	rjmp	.+4      	; 0x6d44 <systemGenerateReport+0xba2>
    6d40:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6d42:	8f 5f       	subi	r24, 0xFF	; 255
    6d44:	89 17       	cp	r24, r25
    6d46:	e0 f3       	brcs	.-8      	; 0x6d40 <systemGenerateReport+0xb9e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6d48:	fe 01       	movw	r30, r28
    6d4a:	e7 59       	subi	r30, 0x97	; 151
    6d4c:	ff 4f       	sbci	r31, 0xFF	; 255
    6d4e:	e9 0f       	add	r30, r25
    6d50:	f1 1d       	adc	r31, r1
    6d52:	10 82       	st	Z, r1
    6d54:	04 c0       	rjmp	.+8      	; 0x6d5e <systemGenerateReport+0xbbc>
     }else{
	 strTab[0]=' ';
    6d56:	80 e2       	ldi	r24, 0x20	; 32
    6d58:	8c 93       	st	X, r24
	 strTab[1]=0;
    6d5a:	11 96       	adiw	r26, 0x01	; 1
    6d5c:	1c 92       	st	X, r1
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
    6d5e:	de 01       	movw	r26, r28
    6d60:	98 96       	adiw	r26, 0x28	; 40
    6d62:	fd 01       	movw	r30, r26
    6d64:	01 90       	ld	r0, Z+
    6d66:	00 20       	and	r0, r0
    6d68:	e9 f7       	brne	.-6      	; 0x6d64 <systemGenerateReport+0xbc2>
    6d6a:	ae 1b       	sub	r26, r30
    6d6c:	a0 5f       	subi	r26, 0xF0	; 240
    6d6e:	fe 01       	movw	r30, r28
    6d70:	e3 58       	subi	r30, 0x83	; 131
    6d72:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6d74:	1a 16       	cp	r1, r26
    6d76:	74 f4       	brge	.+28     	; 0x6d94 <systemGenerateReport+0xbf2>
    6d78:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6d7a:	90 e2       	ldi	r25, 0x20	; 32
    6d7c:	02 c0       	rjmp	.+4      	; 0x6d82 <systemGenerateReport+0xbe0>
    6d7e:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6d80:	8f 5f       	subi	r24, 0xFF	; 255
    6d82:	8a 17       	cp	r24, r26
    6d84:	e0 f3       	brcs	.-8      	; 0x6d7e <systemGenerateReport+0xbdc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6d86:	fe 01       	movw	r30, r28
    6d88:	e3 58       	subi	r30, 0x83	; 131
    6d8a:	ff 4f       	sbci	r31, 0xFF	; 255
    6d8c:	ea 0f       	add	r30, r26
    6d8e:	f1 1d       	adc	r31, r1
    6d90:	10 82       	st	Z, r1
    6d92:	03 c0       	rjmp	.+6      	; 0x6d9a <systemGenerateReport+0xbf8>
     }else{
	 strTab[0]=' ';
    6d94:	80 e2       	ldi	r24, 0x20	; 32
    6d96:	80 83       	st	Z, r24
	 strTab[1]=0;
    6d98:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6d9a:	e1 99       	sbic	0x1c, 1	; 28
    6d9c:	fe cf       	rjmp	.-4      	; 0x6d9a <systemGenerateReport+0xbf8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6d9e:	ff ba       	out	0x1f, r15	; 31
    6da0:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6da2:	e0 9a       	sbi	0x1c, 0	; 28
    6da4:	8d b3       	in	r24, 0x1d	; 29
    6da6:	9e 01       	movw	r18, r28
    6da8:	2b 55       	subi	r18, 0x5B	; 91
    6daa:	3f 4f       	sbci	r19, 0xFF	; 255
    6dac:	ae 01       	movw	r20, r28
    6dae:	47 5e       	subi	r20, 0xE7	; 231
    6db0:	5f 4f       	sbci	r21, 0xFF	; 255
    6db2:	de 01       	movw	r26, r28
    6db4:	a7 59       	subi	r26, 0x97	; 151
    6db6:	bf 4f       	sbci	r27, 0xFF	; 255
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("Awal :%s%s%s%s"),strTabSpace,strLastVolume,strTabSpace2,strLastMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    6db8:	81 30       	cpi	r24, 0x01	; 1
    6dba:	31 f5       	brne	.+76     	; 0x6e08 <systemGenerateReport+0xc66>
    6dbc:	ed b7       	in	r30, 0x3d	; 61
    6dbe:	fe b7       	in	r31, 0x3e	; 62
    6dc0:	3c 97       	sbiw	r30, 0x0c	; 12
    6dc2:	0f b6       	in	r0, 0x3f	; 63
    6dc4:	f8 94       	cli
    6dc6:	fe bf       	out	0x3e, r31	; 62
    6dc8:	0f be       	out	0x3f, r0	; 63
    6dca:	ed bf       	out	0x3d, r30	; 61
    6dcc:	6d b7       	in	r22, 0x3d	; 61
    6dce:	7e b7       	in	r23, 0x3e	; 62
    6dd0:	6f 5f       	subi	r22, 0xFF	; 255
    6dd2:	7f 4f       	sbci	r23, 0xFF	; 255
    6dd4:	32 83       	std	Z+2, r19	; 0x02
    6dd6:	21 83       	std	Z+1, r18	; 0x01
    6dd8:	88 e0       	ldi	r24, 0x08	; 8
    6dda:	95 e0       	ldi	r25, 0x05	; 5
    6ddc:	fb 01       	movw	r30, r22
    6dde:	93 83       	std	Z+3, r25	; 0x03
    6de0:	82 83       	std	Z+2, r24	; 0x02
    6de2:	b5 83       	std	Z+5, r27	; 0x05
    6de4:	a4 83       	std	Z+4, r26	; 0x04
    6de6:	57 83       	std	Z+7, r21	; 0x07
    6de8:	46 83       	std	Z+6, r20	; 0x06
    6dea:	ce 01       	movw	r24, r28
    6dec:	83 58       	subi	r24, 0x83	; 131
    6dee:	9f 4f       	sbci	r25, 0xFF	; 255
    6df0:	91 87       	std	Z+9, r25	; 0x09
    6df2:	80 87       	std	Z+8, r24	; 0x08
    6df4:	ce 01       	movw	r24, r28
    6df6:	88 96       	adiw	r24, 0x28	; 40
    6df8:	93 87       	std	Z+11, r25	; 0x0b
    6dfa:	82 87       	std	Z+10, r24	; 0x0a
    6dfc:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    6e00:	8d b7       	in	r24, 0x3d	; 61
    6e02:	9e b7       	in	r25, 0x3e	; 62
    6e04:	0c 96       	adiw	r24, 0x0c	; 12
    6e06:	1c c0       	rjmp	.+56     	; 0x6e40 <systemGenerateReport+0xc9e>
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
    6e08:	ed b7       	in	r30, 0x3d	; 61
    6e0a:	fe b7       	in	r31, 0x3e	; 62
    6e0c:	38 97       	sbiw	r30, 0x08	; 8
    6e0e:	0f b6       	in	r0, 0x3f	; 63
    6e10:	f8 94       	cli
    6e12:	fe bf       	out	0x3e, r31	; 62
    6e14:	0f be       	out	0x3f, r0	; 63
    6e16:	ed bf       	out	0x3d, r30	; 61
    6e18:	6d b7       	in	r22, 0x3d	; 61
    6e1a:	7e b7       	in	r23, 0x3e	; 62
    6e1c:	6f 5f       	subi	r22, 0xFF	; 255
    6e1e:	7f 4f       	sbci	r23, 0xFF	; 255
    6e20:	32 83       	std	Z+2, r19	; 0x02
    6e22:	21 83       	std	Z+1, r18	; 0x01
    6e24:	8d ef       	ldi	r24, 0xFD	; 253
    6e26:	94 e0       	ldi	r25, 0x04	; 4
    6e28:	fb 01       	movw	r30, r22
    6e2a:	93 83       	std	Z+3, r25	; 0x03
    6e2c:	82 83       	std	Z+2, r24	; 0x02
    6e2e:	b5 83       	std	Z+5, r27	; 0x05
    6e30:	a4 83       	std	Z+4, r26	; 0x04
    6e32:	57 83       	std	Z+7, r21	; 0x07
    6e34:	46 83       	std	Z+6, r20	; 0x06
    6e36:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    6e3a:	8d b7       	in	r24, 0x3d	; 61
    6e3c:	9e b7       	in	r25, 0x3e	; 62
    6e3e:	08 96       	adiw	r24, 0x08	; 8
    6e40:	0f b6       	in	r0, 0x3f	; 63
    6e42:	f8 94       	cli
    6e44:	9e bf       	out	0x3e, r25	; 62
    6e46:	0f be       	out	0x3f, r0	; 63
    6e48:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    6e4a:	ce 01       	movw	r24, r28
    6e4c:	8b 55       	subi	r24, 0x5B	; 91
    6e4e:	9f 4f       	sbci	r25, 0xFF	; 255
    6e50:	67 ef       	ldi	r22, 0xF7	; 247
    6e52:	75 e0       	ldi	r23, 0x05	; 5
    6e54:	4f e1       	ldi	r20, 0x1F	; 31
    6e56:	52 e0       	ldi	r21, 0x02	; 2
    6e58:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <CreateReport>
    6e5c:	8e 01       	movw	r16, r28
    6e5e:	07 59       	subi	r16, 0x97	; 151
    6e60:	1f 4f       	sbci	r17, 0xFF	; 255
    6e62:	f8 01       	movw	r30, r16
void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6e64:	20 e2       	ldi	r18, 0x20	; 32

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6e66:	d8 01       	movw	r26, r16
    6e68:	c8 01       	movw	r24, r16
    6e6a:	0c 96       	adiw	r24, 0x0c	; 12
		     strTab[i]=' ';
    6e6c:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6e6e:	e8 17       	cp	r30, r24
    6e70:	f9 07       	cpc	r31, r25
    6e72:	e1 f7       	brne	.-8      	; 0x6e6c <systemGenerateReport+0xcca>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6e74:	1c 96       	adiw	r26, 0x0c	; 12
    6e76:	1c 92       	st	X, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6e78:	e1 99       	sbic	0x1c, 1	; 28
    6e7a:	fe cf       	rjmp	.-4      	; 0x6e78 <systemGenerateReport+0xcd6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6e7c:	ff ba       	out	0x1f, r15	; 31
    6e7e:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6e80:	e0 9a       	sbi	0x1c, 0	; 28
    6e82:	8d b3       	in	r24, 0x1d	; 29
    6e84:	9e 01       	movw	r18, r28
    6e86:	2b 55       	subi	r18, 0x5B	; 91
    6e88:	3f 4f       	sbci	r19, 0xFF	; 255
    6e8a:	de 01       	movw	r26, r28
    6e8c:	a7 59       	subi	r26, 0x97	; 151
    6e8e:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace(12,strTabSpace);
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
    6e90:	81 30       	cpi	r24, 0x01	; 1
    6e92:	71 f4       	brne	.+28     	; 0x6eb0 <systemGenerateReport+0xd0e>
    6e94:	00 d0       	rcall	.+0      	; 0x6e96 <systemGenerateReport+0xcf4>
    6e96:	00 d0       	rcall	.+0      	; 0x6e98 <systemGenerateReport+0xcf6>
    6e98:	00 d0       	rcall	.+0      	; 0x6e9a <systemGenerateReport+0xcf8>
    6e9a:	4d b7       	in	r20, 0x3d	; 61
    6e9c:	5e b7       	in	r21, 0x3e	; 62
    6e9e:	4f 5f       	subi	r20, 0xFF	; 255
    6ea0:	5f 4f       	sbci	r21, 0xFF	; 255
    6ea2:	ed b7       	in	r30, 0x3d	; 61
    6ea4:	fe b7       	in	r31, 0x3e	; 62
    6ea6:	32 83       	std	Z+2, r19	; 0x02
    6ea8:	21 83       	std	Z+1, r18	; 0x01
    6eaa:	8f ed       	ldi	r24, 0xDF	; 223
    6eac:	94 e0       	ldi	r25, 0x04	; 4
    6eae:	0d c0       	rjmp	.+26     	; 0x6eca <systemGenerateReport+0xd28>
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);
    6eb0:	00 d0       	rcall	.+0      	; 0x6eb2 <systemGenerateReport+0xd10>
    6eb2:	00 d0       	rcall	.+0      	; 0x6eb4 <systemGenerateReport+0xd12>
    6eb4:	00 d0       	rcall	.+0      	; 0x6eb6 <systemGenerateReport+0xd14>
    6eb6:	4d b7       	in	r20, 0x3d	; 61
    6eb8:	5e b7       	in	r21, 0x3e	; 62
    6eba:	4f 5f       	subi	r20, 0xFF	; 255
    6ebc:	5f 4f       	sbci	r21, 0xFF	; 255
    6ebe:	ed b7       	in	r30, 0x3d	; 61
    6ec0:	fe b7       	in	r31, 0x3e	; 62
    6ec2:	32 83       	std	Z+2, r19	; 0x02
    6ec4:	21 83       	std	Z+1, r18	; 0x01
    6ec6:	81 ec       	ldi	r24, 0xC1	; 193
    6ec8:	94 e0       	ldi	r25, 0x04	; 4
    6eca:	fa 01       	movw	r30, r20
    6ecc:	93 83       	std	Z+3, r25	; 0x03
    6ece:	82 83       	std	Z+2, r24	; 0x02
    6ed0:	b5 83       	std	Z+5, r27	; 0x05
    6ed2:	a4 83       	std	Z+4, r26	; 0x04
    6ed4:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    6ed8:	8d b7       	in	r24, 0x3d	; 61
    6eda:	9e b7       	in	r25, 0x3e	; 62
    6edc:	06 96       	adiw	r24, 0x06	; 6
    6ede:	0f b6       	in	r0, 0x3f	; 63
    6ee0:	f8 94       	cli
    6ee2:	9e bf       	out	0x3e, r25	; 62
    6ee4:	0f be       	out	0x3f, r0	; 63
    6ee6:	8d bf       	out	0x3d, r24	; 61
    6ee8:	ce 01       	movw	r24, r28
    6eea:	8b 55       	subi	r24, 0x5B	; 91
    6eec:	9f 4f       	sbci	r25, 0xFF	; 255
    6eee:	67 ef       	ldi	r22, 0xF7	; 247
    6ef0:	75 e0       	ldi	r23, 0x05	; 5
    6ef2:	4f e1       	ldi	r20, 0x1F	; 31
    6ef4:	52 e0       	ldi	r21, 0x02	; 2
    6ef6:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <CreateReport>

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
    6efa:	ed e0       	ldi	r30, 0x0D	; 13
    6efc:	fb e0       	ldi	r31, 0x0B	; 11
    6efe:	01 90       	ld	r0, Z+
    6f00:	00 20       	and	r0, r0
    6f02:	e9 f7       	brne	.-6      	; 0x6efe <systemGenerateReport+0xd5c>
    6f04:	31 97       	sbiw	r30, 0x01	; 1
    6f06:	ed 50       	subi	r30, 0x0D	; 13
    6f08:	fb 40       	sbci	r31, 0x0B	; 11
    6f0a:	97 e1       	ldi	r25, 0x17	; 23
    6f0c:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6f0e:	19 16       	cp	r1, r25
    6f10:	84 f4       	brge	.+32     	; 0x6f32 <systemGenerateReport+0xd90>
    6f12:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6f14:	20 e2       	ldi	r18, 0x20	; 32
    6f16:	04 c0       	rjmp	.+8      	; 0x6f20 <systemGenerateReport+0xd7e>
    6f18:	d8 01       	movw	r26, r16
    6f1a:	2d 93       	st	X+, r18
    6f1c:	8d 01       	movw	r16, r26

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6f1e:	8f 5f       	subi	r24, 0xFF	; 255
    6f20:	89 17       	cp	r24, r25
    6f22:	d0 f3       	brcs	.-12     	; 0x6f18 <systemGenerateReport+0xd76>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6f24:	fe 01       	movw	r30, r28
    6f26:	e7 59       	subi	r30, 0x97	; 151
    6f28:	ff 4f       	sbci	r31, 0xFF	; 255
    6f2a:	e9 0f       	add	r30, r25
    6f2c:	f1 1d       	adc	r31, r1
    6f2e:	10 82       	st	Z, r1
    6f30:	06 c0       	rjmp	.+12     	; 0x6f3e <systemGenerateReport+0xd9c>
     }else{
	 strTab[0]=' ';
    6f32:	fe 01       	movw	r30, r28
    6f34:	e7 59       	subi	r30, 0x97	; 151
    6f36:	ff 4f       	sbci	r31, 0xFF	; 255
    6f38:	80 e2       	ldi	r24, 0x20	; 32
    6f3a:	80 83       	st	Z, r24
	 strTab[1]=0;
    6f3c:	11 82       	std	Z+1, r1	; 0x01
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
    6f3e:	e8 e3       	ldi	r30, 0x38	; 56
    6f40:	fe e0       	ldi	r31, 0x0E	; 14
    6f42:	01 90       	ld	r0, Z+
    6f44:	00 20       	and	r0, r0
    6f46:	e9 f7       	brne	.-6      	; 0x6f42 <systemGenerateReport+0xda0>
    6f48:	31 97       	sbiw	r30, 0x01	; 1
    6f4a:	e8 53       	subi	r30, 0x38	; 56
    6f4c:	fe 40       	sbci	r31, 0x0E	; 14
    6f4e:	9f e0       	ldi	r25, 0x0F	; 15
    6f50:	9e 1b       	sub	r25, r30
    6f52:	fe 01       	movw	r30, r28
    6f54:	e3 58       	subi	r30, 0x83	; 131
    6f56:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6f58:	19 16       	cp	r1, r25
    6f5a:	74 f4       	brge	.+28     	; 0x6f78 <systemGenerateReport+0xdd6>
    6f5c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6f5e:	20 e2       	ldi	r18, 0x20	; 32
    6f60:	02 c0       	rjmp	.+4      	; 0x6f66 <systemGenerateReport+0xdc4>
    6f62:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6f64:	8f 5f       	subi	r24, 0xFF	; 255
    6f66:	89 17       	cp	r24, r25
    6f68:	e0 f3       	brcs	.-8      	; 0x6f62 <systemGenerateReport+0xdc0>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6f6a:	fe 01       	movw	r30, r28
    6f6c:	e3 58       	subi	r30, 0x83	; 131
    6f6e:	ff 4f       	sbci	r31, 0xFF	; 255
    6f70:	e9 0f       	add	r30, r25
    6f72:	f1 1d       	adc	r31, r1
    6f74:	10 82       	st	Z, r1
    6f76:	03 c0       	rjmp	.+6      	; 0x6f7e <systemGenerateReport+0xddc>
     }else{
	 strTab[0]=' ';
    6f78:	80 e2       	ldi	r24, 0x20	; 32
    6f7a:	80 83       	st	Z, r24
	 strTab[1]=0;
    6f7c:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6f7e:	e1 99       	sbic	0x1c, 1	; 28
    6f80:	fe cf       	rjmp	.-4      	; 0x6f7e <systemGenerateReport+0xddc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6f82:	ff ba       	out	0x1f, r15	; 31
    6f84:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6f86:	e0 9a       	sbi	0x1c, 0	; 28
    6f88:	8d b3       	in	r24, 0x1d	; 29
    6f8a:	9e 01       	movw	r18, r28
    6f8c:	2b 55       	subi	r18, 0x5B	; 91
    6f8e:	3f 4f       	sbci	r19, 0xFF	; 255
    6f90:	4d e0       	ldi	r20, 0x0D	; 13
    6f92:	5b e0       	ldi	r21, 0x0B	; 11
    6f94:	de 01       	movw	r26, r28
    6f96:	a7 59       	subi	r26, 0x97	; 151
    6f98:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s%s%s%s"),strTabSpace,strDeltaVolume,strTabSpace2,strDeltaMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    6f9a:	81 30       	cpi	r24, 0x01	; 1
    6f9c:	31 f5       	brne	.+76     	; 0x6fea <systemGenerateReport+0xe48>
    6f9e:	ed b7       	in	r30, 0x3d	; 61
    6fa0:	fe b7       	in	r31, 0x3e	; 62
    6fa2:	3c 97       	sbiw	r30, 0x0c	; 12
    6fa4:	0f b6       	in	r0, 0x3f	; 63
    6fa6:	f8 94       	cli
    6fa8:	fe bf       	out	0x3e, r31	; 62
    6faa:	0f be       	out	0x3f, r0	; 63
    6fac:	ed bf       	out	0x3d, r30	; 61
    6fae:	6d b7       	in	r22, 0x3d	; 61
    6fb0:	7e b7       	in	r23, 0x3e	; 62
    6fb2:	6f 5f       	subi	r22, 0xFF	; 255
    6fb4:	7f 4f       	sbci	r23, 0xFF	; 255
    6fb6:	32 83       	std	Z+2, r19	; 0x02
    6fb8:	21 83       	std	Z+1, r18	; 0x01
    6fba:	88 eb       	ldi	r24, 0xB8	; 184
    6fbc:	94 e0       	ldi	r25, 0x04	; 4
    6fbe:	fb 01       	movw	r30, r22
    6fc0:	93 83       	std	Z+3, r25	; 0x03
    6fc2:	82 83       	std	Z+2, r24	; 0x02
    6fc4:	b5 83       	std	Z+5, r27	; 0x05
    6fc6:	a4 83       	std	Z+4, r26	; 0x04
    6fc8:	57 83       	std	Z+7, r21	; 0x07
    6fca:	46 83       	std	Z+6, r20	; 0x06
    6fcc:	ce 01       	movw	r24, r28
    6fce:	83 58       	subi	r24, 0x83	; 131
    6fd0:	9f 4f       	sbci	r25, 0xFF	; 255
    6fd2:	91 87       	std	Z+9, r25	; 0x09
    6fd4:	80 87       	std	Z+8, r24	; 0x08
    6fd6:	88 e3       	ldi	r24, 0x38	; 56
    6fd8:	9e e0       	ldi	r25, 0x0E	; 14
    6fda:	93 87       	std	Z+11, r25	; 0x0b
    6fdc:	82 87       	std	Z+10, r24	; 0x0a
    6fde:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    6fe2:	8d b7       	in	r24, 0x3d	; 61
    6fe4:	9e b7       	in	r25, 0x3e	; 62
    6fe6:	0c 96       	adiw	r24, 0x0c	; 12
    6fe8:	1c c0       	rjmp	.+56     	; 0x7022 <systemGenerateReport+0xe80>
          else sprintf_P(strReport,PSTR("%s%s"),strTabSpace,strDeltaVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    6fea:	ed b7       	in	r30, 0x3d	; 61
    6fec:	fe b7       	in	r31, 0x3e	; 62
    6fee:	38 97       	sbiw	r30, 0x08	; 8
    6ff0:	0f b6       	in	r0, 0x3f	; 63
    6ff2:	f8 94       	cli
    6ff4:	fe bf       	out	0x3e, r31	; 62
    6ff6:	0f be       	out	0x3f, r0	; 63
    6ff8:	ed bf       	out	0x3d, r30	; 61
    6ffa:	6d b7       	in	r22, 0x3d	; 61
    6ffc:	7e b7       	in	r23, 0x3e	; 62
    6ffe:	6f 5f       	subi	r22, 0xFF	; 255
    7000:	7f 4f       	sbci	r23, 0xFF	; 255
    7002:	32 83       	std	Z+2, r19	; 0x02
    7004:	21 83       	std	Z+1, r18	; 0x01
    7006:	83 eb       	ldi	r24, 0xB3	; 179
    7008:	94 e0       	ldi	r25, 0x04	; 4
    700a:	fb 01       	movw	r30, r22
    700c:	93 83       	std	Z+3, r25	; 0x03
    700e:	82 83       	std	Z+2, r24	; 0x02
    7010:	b5 83       	std	Z+5, r27	; 0x05
    7012:	a4 83       	std	Z+4, r26	; 0x04
    7014:	57 83       	std	Z+7, r21	; 0x07
    7016:	46 83       	std	Z+6, r20	; 0x06
    7018:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    701c:	8d b7       	in	r24, 0x3d	; 61
    701e:	9e b7       	in	r25, 0x3e	; 62
    7020:	08 96       	adiw	r24, 0x08	; 8
    7022:	0f b6       	in	r0, 0x3f	; 63
    7024:	f8 94       	cli
    7026:	9e bf       	out	0x3e, r25	; 62
    7028:	0f be       	out	0x3f, r0	; 63
    702a:	8d bf       	out	0x3d, r24	; 61
    702c:	ce 01       	movw	r24, r28
    702e:	8b 55       	subi	r24, 0x5B	; 91
    7030:	9f 4f       	sbci	r25, 0xFF	; 255
    7032:	67 ef       	ldi	r22, 0xF7	; 247
    7034:	75 e0       	ldi	r23, 0x05	; 5
    7036:	4f e1       	ldi	r20, 0x1F	; 31
    7038:	52 e0       	ldi	r21, 0x02	; 2
    703a:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <CreateReport>

          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    703e:	87 e0       	ldi	r24, 0x07	; 7
    7040:	67 ef       	ldi	r22, 0xF7	; 247
    7042:	75 e0       	ldi	r23, 0x05	; 5
    7044:	41 e0       	ldi	r20, 0x01	; 1
    7046:	2f e1       	ldi	r18, 0x1F	; 31
    7048:	32 e0       	ldi	r19, 0x02	; 2
    704a:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    704e:	8b e0       	ldi	r24, 0x0B	; 11
    7050:	67 ef       	ldi	r22, 0xF7	; 247
    7052:	75 e0       	ldi	r23, 0x05	; 5
    7054:	4a e2       	ldi	r20, 0x2A	; 42
    7056:	2f e1       	ldi	r18, 0x1F	; 31
    7058:	32 e0       	ldi	r19, 0x02	; 2
    705a:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    705e:	89 e0       	ldi	r24, 0x09	; 9
    7060:	67 ef       	ldi	r22, 0xF7	; 247
    7062:	75 e0       	ldi	r23, 0x05	; 5
    7064:	41 e0       	ldi	r20, 0x01	; 1
    7066:	2f e1       	ldi	r18, 0x1F	; 31
    7068:	32 e0       	ldi	r19, 0x02	; 2
    706a:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    706e:	8c e0       	ldi	r24, 0x0C	; 12
    7070:	67 ef       	ldi	r22, 0xF7	; 247
    7072:	75 e0       	ldi	r23, 0x05	; 5
    7074:	41 e0       	ldi	r20, 0x01	; 1
    7076:	2f e1       	ldi	r18, 0x1F	; 31
    7078:	32 e0       	ldi	r19, 0x02	; 2
    707a:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>


          cmdPrint=0b00000000;
    707e:	10 92 e0 01 	sts	0x01E0, r1
		  LengthMessage81=RepPos+1;
    7082:	80 91 1f 02 	lds	r24, 0x021F
    7086:	90 91 20 02 	lds	r25, 0x0220
    708a:	01 96       	adiw	r24, 0x01	; 1
    708c:	90 93 b6 01 	sts	0x01B6, r25
    7090:	80 93 b5 01 	sts	0x01B5, r24

		  IsFreePrinting=True;
    7094:	81 e0       	ldi	r24, 0x01	; 1
    7096:	80 93 d5 01 	sts	0x01D5, r24
	      IsBusyFreePrinting=True;
    709a:	80 93 de 01 	sts	0x01DE, r24

	      stGenerateReport=grWaitPrinted2;
    709e:	89 e0       	ldi	r24, 0x09	; 9
    70a0:	91 c3       	rjmp	.+1826   	; 0x77c4 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted2:
	 
          if (IsBusyFreePrinting==False)stGenerateReport=grGenerateReportData;
    70a2:	80 91 de 01 	lds	r24, 0x01DE
    70a6:	88 23       	and	r24, r24
    70a8:	09 f0       	breq	.+2      	; 0x70ac <systemGenerateReport+0xf0a>
    70aa:	94 c3       	rjmp	.+1832   	; 0x77d4 <systemGenerateReport+0x1632>
    70ac:	86 e0       	ldi	r24, 0x06	; 6
    70ae:	8a c3       	rjmp	.+1812   	; 0x77c4 <systemGenerateReport+0x1622>
	      break;
     case grCreateReportFooter:
          RepPos=0;
    70b0:	10 92 20 02 	sts	0x0220, r1
    70b4:	10 92 1f 02 	sts	0x021F, r1
    70b8:	e7 ef       	ldi	r30, 0xF7	; 247
    70ba:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    70bc:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    70be:	97 e0       	ldi	r25, 0x07	; 7
    70c0:	ec 38       	cpi	r30, 0x8C	; 140
    70c2:	f9 07       	cpc	r31, r25
    70c4:	d9 f7       	brne	.-10     	; 0x70bc <systemGenerateReport+0xf1a>
    70c6:	fe 01       	movw	r30, r28
    70c8:	eb 55       	subi	r30, 0x5B	; 91
    70ca:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    70cc:	ce 01       	movw	r24, r28
    70ce:	8b 50       	subi	r24, 0x0B	; 11
    70d0:	9f 4f       	sbci	r25, 0xFF	; 255
    70d2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    70d4:	e8 17       	cp	r30, r24
    70d6:	f9 07       	cpc	r31, r25
    70d8:	e1 f7       	brne	.-8      	; 0x70d2 <systemGenerateReport+0xf30>
     case grCreateReportFooter:
          RepPos=0;
		  FillChar(PrintBuffer,sizeof(PrintBuffer),0);
		  FillChar(strReport,sizeof(strReport),0);

		  RemZeroLead(strTotalMoney);
    70da:	8d ed       	ldi	r24, 0xDD	; 221
    70dc:	9a e0       	ldi	r25, 0x0A	; 10
    70de:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
		  RemZeroLead(strTotalVolume);
    70e2:	08 e2       	ldi	r16, 0x28	; 40
    70e4:	1a e0       	ldi	r17, 0x0A	; 10
    70e6:	c8 01       	movw	r24, r16
    70e8:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>

		  FormatTotalizerMoney(strTotalMoney);
    70ec:	8d ed       	ldi	r24, 0xDD	; 221
    70ee:	9a e0       	ldi	r25, 0x0A	; 10
    70f0:	0e 94 9d 30 	call	0x613a	; 0x613a <FormatTotalizerMoney>
		  FormatCurrency(strTotalMoney);
    70f4:	8d ed       	ldi	r24, 0xDD	; 221
    70f6:	9a e0       	ldi	r25, 0x0A	; 10
    70f8:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>
		  FormatTotalizerVolume(strTotalVolume);
    70fc:	c8 01       	movw	r24, r16
    70fe:	0e 94 90 30 	call	0x6120	; 0x6120 <FormatTotalizerVolume>
		  FormatCurrency(strTotalVolume);
    7102:	c8 01       	movw	r24, r16
    7104:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>

          //Test
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    7108:	81 e0       	ldi	r24, 0x01	; 1
    710a:	67 ef       	ldi	r22, 0xF7	; 247
    710c:	75 e0       	ldi	r23, 0x05	; 5
    710e:	41 e0       	ldi	r20, 0x01	; 1
    7110:	2f e1       	ldi	r18, 0x1F	; 31
    7112:	32 e0       	ldi	r19, 0x02	; 2
    7114:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    7118:	8b e0       	ldi	r24, 0x0B	; 11
    711a:	67 ef       	ldi	r22, 0xF7	; 247
    711c:	75 e0       	ldi	r23, 0x05	; 5
    711e:	4a e2       	ldi	r20, 0x2A	; 42
    7120:	2f e1       	ldi	r18, 0x1F	; 31
    7122:	32 e0       	ldi	r19, 0x02	; 2
    7124:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    7128:	83 e0       	ldi	r24, 0x03	; 3
    712a:	67 ef       	ldi	r22, 0xF7	; 247
    712c:	75 e0       	ldi	r23, 0x05	; 5
    712e:	41 e0       	ldi	r20, 0x01	; 1
    7130:	2f e1       	ldi	r18, 0x1F	; 31
    7132:	32 e0       	ldi	r19, 0x02	; 2
    7134:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    7138:	8c e0       	ldi	r24, 0x0C	; 12
    713a:	67 ef       	ldi	r22, 0xF7	; 247
    713c:	75 e0       	ldi	r23, 0x05	; 5
    713e:	41 e0       	ldi	r20, 0x01	; 1
    7140:	2f e1       	ldi	r18, 0x1F	; 31
    7142:	32 e0       	ldi	r19, 0x02	; 2
    7144:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
    7148:	d8 01       	movw	r26, r16
    714a:	0d 90       	ld	r0, X+
    714c:	00 20       	and	r0, r0
    714e:	e9 f7       	brne	.-6      	; 0x714a <systemGenerateReport+0xfa8>
    7150:	8d 01       	movw	r16, r26
    7152:	01 50       	subi	r16, 0x01	; 1
    7154:	10 40       	sbci	r17, 0x00	; 0
    7156:	08 52       	subi	r16, 0x28	; 40
    7158:	1a 40       	sbci	r17, 0x0A	; 10
    715a:	91 e1       	ldi	r25, 0x11	; 17
    715c:	90 1b       	sub	r25, r16
    715e:	de 01       	movw	r26, r28
    7160:	a7 59       	subi	r26, 0x97	; 151
    7162:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7164:	19 16       	cp	r1, r25
    7166:	7c f4       	brge	.+30     	; 0x7186 <systemGenerateReport+0xfe4>
    7168:	fd 01       	movw	r30, r26
    716a:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    716c:	20 e2       	ldi	r18, 0x20	; 32
    716e:	02 c0       	rjmp	.+4      	; 0x7174 <systemGenerateReport+0xfd2>
    7170:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7172:	8f 5f       	subi	r24, 0xFF	; 255
    7174:	89 17       	cp	r24, r25
    7176:	e0 f3       	brcs	.-8      	; 0x7170 <systemGenerateReport+0xfce>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7178:	fe 01       	movw	r30, r28
    717a:	e7 59       	subi	r30, 0x97	; 151
    717c:	ff 4f       	sbci	r31, 0xFF	; 255
    717e:	e9 0f       	add	r30, r25
    7180:	f1 1d       	adc	r31, r1
    7182:	10 82       	st	Z, r1
    7184:	04 c0       	rjmp	.+8      	; 0x718e <systemGenerateReport+0xfec>
     }else{
	 strTab[0]=' ';
    7186:	80 e2       	ldi	r24, 0x20	; 32
    7188:	8c 93       	st	X, r24
	 strTab[1]=0;
    718a:	11 96       	adiw	r26, 0x01	; 1
    718c:	1c 92       	st	X, r1
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    718e:	ed ed       	ldi	r30, 0xDD	; 221
    7190:	fa e0       	ldi	r31, 0x0A	; 10
    7192:	01 90       	ld	r0, Z+
    7194:	00 20       	and	r0, r0
    7196:	e9 f7       	brne	.-6      	; 0x7192 <systemGenerateReport+0xff0>
    7198:	31 97       	sbiw	r30, 0x01	; 1
    719a:	ed 5d       	subi	r30, 0xDD	; 221
    719c:	fa 40       	sbci	r31, 0x0A	; 10
    719e:	9f e0       	ldi	r25, 0x0F	; 15
    71a0:	9e 1b       	sub	r25, r30
    71a2:	fe 01       	movw	r30, r28
    71a4:	e3 58       	subi	r30, 0x83	; 131
    71a6:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    71a8:	19 16       	cp	r1, r25
    71aa:	74 f4       	brge	.+28     	; 0x71c8 <systemGenerateReport+0x1026>
    71ac:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    71ae:	20 e2       	ldi	r18, 0x20	; 32
    71b0:	02 c0       	rjmp	.+4      	; 0x71b6 <systemGenerateReport+0x1014>
    71b2:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    71b4:	8f 5f       	subi	r24, 0xFF	; 255
    71b6:	89 17       	cp	r24, r25
    71b8:	e0 f3       	brcs	.-8      	; 0x71b2 <systemGenerateReport+0x1010>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    71ba:	fe 01       	movw	r30, r28
    71bc:	e3 58       	subi	r30, 0x83	; 131
    71be:	ff 4f       	sbci	r31, 0xFF	; 255
    71c0:	e9 0f       	add	r30, r25
    71c2:	f1 1d       	adc	r31, r1
    71c4:	10 82       	st	Z, r1
    71c6:	03 c0       	rjmp	.+6      	; 0x71ce <systemGenerateReport+0x102c>
     }else{
	 strTab[0]=' ';
    71c8:	80 e2       	ldi	r24, 0x20	; 32
    71ca:	80 83       	st	Z, r24
	 strTab[1]=0;
    71cc:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    71ce:	e1 99       	sbic	0x1c, 1	; 28
    71d0:	fe cf       	rjmp	.-4      	; 0x71ce <systemGenerateReport+0x102c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    71d2:	e1 ef       	ldi	r30, 0xF1	; 241
    71d4:	f3 e0       	ldi	r31, 0x03	; 3
    71d6:	ff bb       	out	0x1f, r31	; 31
    71d8:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    71da:	e0 9a       	sbi	0x1c, 0	; 28
    71dc:	8d b3       	in	r24, 0x1d	; 29
    71de:	9e 01       	movw	r18, r28
    71e0:	2b 55       	subi	r18, 0x5B	; 91
    71e2:	3f 4f       	sbci	r19, 0xFF	; 255
    71e4:	48 e2       	ldi	r20, 0x28	; 40
    71e6:	5a e0       	ldi	r21, 0x0A	; 10
    71e8:	de 01       	movw	r26, r28
    71ea:	a7 59       	subi	r26, 0x97	; 151
    71ec:	bf 4f       	sbci	r27, 0xFF	; 255

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    71ee:	81 30       	cpi	r24, 0x01	; 1
    71f0:	41 f5       	brne	.+80     	; 0x7242 <systemGenerateReport+0x10a0>
    71f2:	8d b7       	in	r24, 0x3d	; 61
    71f4:	9e b7       	in	r25, 0x3e	; 62
    71f6:	0c 97       	sbiw	r24, 0x0c	; 12
    71f8:	0f b6       	in	r0, 0x3f	; 63
    71fa:	f8 94       	cli
    71fc:	9e bf       	out	0x3e, r25	; 62
    71fe:	0f be       	out	0x3f, r0	; 63
    7200:	8d bf       	out	0x3d, r24	; 61
    7202:	6d b7       	in	r22, 0x3d	; 61
    7204:	7e b7       	in	r23, 0x3e	; 62
    7206:	6f 5f       	subi	r22, 0xFF	; 255
    7208:	7f 4f       	sbci	r23, 0xFF	; 255
    720a:	ed b7       	in	r30, 0x3d	; 61
    720c:	fe b7       	in	r31, 0x3e	; 62
    720e:	32 83       	std	Z+2, r19	; 0x02
    7210:	21 83       	std	Z+1, r18	; 0x01
    7212:	84 ea       	ldi	r24, 0xA4	; 164
    7214:	94 e0       	ldi	r25, 0x04	; 4
    7216:	fb 01       	movw	r30, r22
    7218:	93 83       	std	Z+3, r25	; 0x03
    721a:	82 83       	std	Z+2, r24	; 0x02
    721c:	b5 83       	std	Z+5, r27	; 0x05
    721e:	a4 83       	std	Z+4, r26	; 0x04
    7220:	57 83       	std	Z+7, r21	; 0x07
    7222:	46 83       	std	Z+6, r20	; 0x06
    7224:	ce 01       	movw	r24, r28
    7226:	83 58       	subi	r24, 0x83	; 131
    7228:	9f 4f       	sbci	r25, 0xFF	; 255
    722a:	91 87       	std	Z+9, r25	; 0x09
    722c:	80 87       	std	Z+8, r24	; 0x08
    722e:	8d ed       	ldi	r24, 0xDD	; 221
    7230:	9a e0       	ldi	r25, 0x0A	; 10
    7232:	93 87       	std	Z+11, r25	; 0x0b
    7234:	82 87       	std	Z+10, r24	; 0x0a
    7236:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    723a:	8d b7       	in	r24, 0x3d	; 61
    723c:	9e b7       	in	r25, 0x3e	; 62
    723e:	0c 96       	adiw	r24, 0x0c	; 12
    7240:	1c c0       	rjmp	.+56     	; 0x727a <systemGenerateReport+0x10d8>
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    7242:	ed b7       	in	r30, 0x3d	; 61
    7244:	fe b7       	in	r31, 0x3e	; 62
    7246:	38 97       	sbiw	r30, 0x08	; 8
    7248:	0f b6       	in	r0, 0x3f	; 63
    724a:	f8 94       	cli
    724c:	fe bf       	out	0x3e, r31	; 62
    724e:	0f be       	out	0x3f, r0	; 63
    7250:	ed bf       	out	0x3d, r30	; 61
    7252:	6d b7       	in	r22, 0x3d	; 61
    7254:	7e b7       	in	r23, 0x3e	; 62
    7256:	6f 5f       	subi	r22, 0xFF	; 255
    7258:	7f 4f       	sbci	r23, 0xFF	; 255
    725a:	32 83       	std	Z+2, r19	; 0x02
    725c:	21 83       	std	Z+1, r18	; 0x01
    725e:	89 e9       	ldi	r24, 0x99	; 153
    7260:	94 e0       	ldi	r25, 0x04	; 4
    7262:	fb 01       	movw	r30, r22
    7264:	93 83       	std	Z+3, r25	; 0x03
    7266:	82 83       	std	Z+2, r24	; 0x02
    7268:	b5 83       	std	Z+5, r27	; 0x05
    726a:	a4 83       	std	Z+4, r26	; 0x04
    726c:	57 83       	std	Z+7, r21	; 0x07
    726e:	46 83       	std	Z+6, r20	; 0x06
    7270:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    7274:	8d b7       	in	r24, 0x3d	; 61
    7276:	9e b7       	in	r25, 0x3e	; 62
    7278:	08 96       	adiw	r24, 0x08	; 8
    727a:	0f b6       	in	r0, 0x3f	; 63
    727c:	f8 94       	cli
    727e:	9e bf       	out	0x3e, r25	; 62
    7280:	0f be       	out	0x3f, r0	; 63
    7282:	8d bf       	out	0x3d, r24	; 61
    7284:	ce 01       	movw	r24, r28
    7286:	8b 55       	subi	r24, 0x5B	; 91
    7288:	9f 4f       	sbci	r25, 0xFF	; 255
    728a:	67 ef       	ldi	r22, 0xF7	; 247
    728c:	75 e0       	ldi	r23, 0x05	; 5
    728e:	4f e1       	ldi	r20, 0x1F	; 31
    7290:	52 e0       	ldi	r21, 0x02	; 2
    7292:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <CreateReport>

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      
    7296:	84 e0       	ldi	r24, 0x04	; 4
    7298:	67 ef       	ldi	r22, 0xF7	; 247
    729a:	75 e0       	ldi	r23, 0x05	; 5
    729c:	41 e0       	ldi	r20, 0x01	; 1
    729e:	2f e1       	ldi	r18, 0x1F	; 31
    72a0:	32 e0       	ldi	r19, 0x02	; 2
    72a2:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    72a6:	8b e0       	ldi	r24, 0x0B	; 11
    72a8:	67 ef       	ldi	r22, 0xF7	; 247
    72aa:	75 e0       	ldi	r23, 0x05	; 5
    72ac:	4a e2       	ldi	r20, 0x2A	; 42
    72ae:	2f e1       	ldi	r18, 0x1F	; 31
    72b0:	32 e0       	ldi	r19, 0x02	; 2
    72b2:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    72b6:	86 e0       	ldi	r24, 0x06	; 6
    72b8:	67 ef       	ldi	r22, 0xF7	; 247
    72ba:	75 e0       	ldi	r23, 0x05	; 5
    72bc:	41 e0       	ldi	r20, 0x01	; 1
    72be:	2f e1       	ldi	r18, 0x1F	; 31
    72c0:	32 e0       	ldi	r19, 0x02	; 2
    72c2:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    72c6:	8c e0       	ldi	r24, 0x0C	; 12
    72c8:	67 ef       	ldi	r22, 0xF7	; 247
    72ca:	75 e0       	ldi	r23, 0x05	; 5
    72cc:	41 e0       	ldi	r20, 0x01	; 1
    72ce:	2f e1       	ldi	r18, 0x1F	; 31
    72d0:	32 e0       	ldi	r19, 0x02	; 2
    72d2:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    72d6:	ee 24       	eor	r14, r14

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    72d8:	b8 e2       	ldi	r27, 0x28	; 40
    72da:	2b 2e       	mov	r2, r27
    72dc:	31 2c       	mov	r3, r1
    72de:	2c 0e       	add	r2, r28
    72e0:	3d 1e       	adc	r3, r29
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    72e2:	a7 e3       	ldi	r26, 0x37	; 55
    72e4:	6a 2e       	mov	r6, r26
    72e6:	71 2c       	mov	r7, r1
    72e8:	6c 0e       	add	r6, r28
    72ea:	7d 1e       	adc	r7, r29
    72ec:	d3 01       	movw	r26, r6
    72ee:	1f 96       	adiw	r26, 0x0f	; 15
    72f0:	cb 50       	subi	r28, 0x0B	; 11
    72f2:	df 4f       	sbci	r29, 0xFF	; 255
    72f4:	b9 83       	std	Y+1, r27	; 0x01
    72f6:	a8 83       	st	Y, r26
    72f8:	c5 5f       	subi	r28, 0xF5	; 245
    72fa:	d0 40       	sbci	r29, 0x00	; 0
    72fc:	f6 e4       	ldi	r31, 0x46	; 70
    72fe:	4f 2e       	mov	r4, r31
    7300:	51 2c       	mov	r5, r1
    7302:	4c 0e       	add	r4, r28
    7304:	5d 1e       	adc	r5, r29
    7306:	f2 01       	movw	r30, r4
    7308:	3f 96       	adiw	r30, 0x0f	; 15
    730a:	c9 50       	subi	r28, 0x09	; 9
    730c:	df 4f       	sbci	r29, 0xFF	; 255
    730e:	f9 83       	std	Y+1, r31	; 0x01
    7310:	e8 83       	st	Y, r30
    7312:	c7 5f       	subi	r28, 0xF7	; 247
    7314:	d0 40       	sbci	r29, 0x00	; 0
    7316:	ed e7       	ldi	r30, 0x7D	; 125
    7318:	8e 2e       	mov	r8, r30
    731a:	91 2c       	mov	r9, r1
    731c:	8c 0e       	add	r8, r28
    731e:	9d 1e       	adc	r9, r29
    7320:	e3 c1       	rjmp	.+966    	; 0x76e8 <systemGenerateReport+0x1546>
    7322:	f5 01       	movw	r30, r10
    7324:	ef 5d       	subi	r30, 0xDF	; 223
    7326:	fd 4f       	sbci	r31, 0xFD	; 253
    7328:	80 81       	ld	r24, Z
    732a:	80 53       	subi	r24, 0x30	; 48
    732c:	8a 30       	cpi	r24, 0x0A	; 10
    732e:	08 f0       	brcs	.+2      	; 0x7332 <systemGenerateReport+0x1190>
    7330:	80 e0       	ldi	r24, 0x00	; 0
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
		      xGrade=Ord(GradeList[iTotal]);
    7332:	80 93 2e 02 	sts	0x022E, r24
			  if (xGrade>0){
    7336:	88 23       	and	r24, r24
    7338:	09 f4       	brne	.+2      	; 0x733c <systemGenerateReport+0x119a>
    733a:	d5 c1       	rjmp	.+938    	; 0x76e6 <systemGenerateReport+0x1544>
			      GetProductName(xGrade,strProduct);
    733c:	6d e6       	ldi	r22, 0x6D	; 109
    733e:	79 e0       	ldi	r23, 0x09	; 9
    7340:	0e 94 30 2a 	call	0x5460	; 0x5460 <GetProductName>
    7344:	e8 e2       	ldi	r30, 0x28	; 40
    7346:	fa e0       	ldi	r31, 0x0A	; 10
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    7348:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    734a:	8a e0       	ldi	r24, 0x0A	; 10
    734c:	ec 33       	cpi	r30, 0x3C	; 60
    734e:	f8 07       	cpc	r31, r24
    7350:	d9 f7       	brne	.-10     	; 0x7348 <systemGenerateReport+0x11a6>
    7352:	ed ed       	ldi	r30, 0xDD	; 221
    7354:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    7356:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7358:	9a e0       	ldi	r25, 0x0A	; 10
    735a:	e1 3f       	cpi	r30, 0xF1	; 241
    735c:	f9 07       	cpc	r31, r25
    735e:	d9 f7       	brne	.-10     	; 0x7356 <systemGenerateReport+0x11b4>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    7360:	81 e0       	ldi	r24, 0x01	; 1
    7362:	80 93 30 02 	sts	0x0230, r24

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7366:	79 e1       	ldi	r23, 0x19	; 25
    7368:	c7 2e       	mov	r12, r23
    736a:	d1 2c       	mov	r13, r1
    736c:	cc 0e       	add	r12, r28
    736e:	dd 1e       	adc	r13, r29
    7370:	e6 c0       	rjmp	.+460    	; 0x753e <systemGenerateReport+0x139c>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    7372:	ce 01       	movw	r24, r28
    7374:	07 96       	adiw	r24, 0x07	; 7
    7376:	65 e4       	ldi	r22, 0x45	; 69
    7378:	70 e0       	ldi	r23, 0x00	; 0
    737a:	48 e0       	ldi	r20, 0x08	; 8
    737c:	50 e0       	ldi	r21, 0x00	; 0
    737e:	2c ea       	ldi	r18, 0xAC	; 172
    7380:	32 e1       	ldi	r19, 0x12	; 18
    7382:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
    7386:	80 91 30 02 	lds	r24, 0x0230
    738a:	fe 01       	movw	r30, r28
    738c:	e8 0f       	add	r30, r24
    738e:	f1 1d       	adc	r31, r1
    7390:	86 81       	ldd	r24, Z+6	; 0x06
    7392:	80 93 2d 02 	sts	0x022D, r24
					  if (PumpNum>0){
    7396:	88 23       	and	r24, r24
    7398:	09 f4       	brne	.+2      	; 0x739c <systemGenerateReport+0x11fa>
    739a:	cc c0       	rjmp	.+408    	; 0x7534 <systemGenerateReport+0x1392>
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    739c:	81 e0       	ldi	r24, 0x01	; 1
    739e:	c3 c0       	rjmp	.+390    	; 0x7526 <systemGenerateReport+0x1384>
    73a0:	60 91 30 02 	lds	r22, 0x0230
    73a4:	a6 e0       	ldi	r26, 0x06	; 6
    73a6:	6a 9f       	mul	r22, r26
    73a8:	b0 01       	movw	r22, r0
    73aa:	11 24       	eor	r1, r1
    73ac:	61 5b       	subi	r22, 0xB1	; 177
    73ae:	7f 4f       	sbci	r23, 0xFF	; 255
    73b0:	ce 01       	movw	r24, r28
    73b2:	01 96       	adiw	r24, 0x01	; 1
    73b4:	46 e0       	ldi	r20, 0x06	; 6
    73b6:	50 e0       	ldi	r21, 0x00	; 0
    73b8:	2c ea       	ldi	r18, 0xAC	; 172
    73ba:	32 e1       	ldi	r19, 0x12	; 18
    73bc:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
							  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
							  //Found Grade
						      if (PProductID[xNozzle-1]==xGrade){
    73c0:	80 91 2f 02 	lds	r24, 0x022F
    73c4:	fe 01       	movw	r30, r28
    73c6:	e8 0f       	add	r30, r24
    73c8:	f1 1d       	adc	r31, r1
    73ca:	90 81       	ld	r25, Z
    73cc:	80 91 2e 02 	lds	r24, 0x022E
    73d0:	98 17       	cp	r25, r24
    73d2:	09 f0       	breq	.+2      	; 0x73d6 <systemGenerateReport+0x1234>
    73d4:	a5 c0       	rjmp	.+330    	; 0x7520 <systemGenerateReport+0x137e>
    73d6:	e8 e3       	ldi	r30, 0x38	; 56
    73d8:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    73da:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    73dc:	be e0       	ldi	r27, 0x0E	; 14
    73de:	e7 34       	cpi	r30, 0x47	; 71
    73e0:	fb 07       	cpc	r31, r27
    73e2:	d9 f7       	brne	.-10     	; 0x73da <systemGenerateReport+0x1238>
    73e4:	ed e0       	ldi	r30, 0x0D	; 13
    73e6:	fb e0       	ldi	r31, 0x0B	; 11
	     strMemory[i]=data;
    73e8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    73ea:	8b e0       	ldi	r24, 0x0B	; 11
    73ec:	ec 31       	cpi	r30, 0x1C	; 28
    73ee:	f8 07       	cpc	r31, r24
    73f0:	d9 f7       	brne	.-10     	; 0x73e8 <systemGenerateReport+0x1246>
    73f2:	f6 01       	movw	r30, r12
	     strMemory[i]=data;
    73f4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    73f6:	e2 15       	cp	r30, r2
    73f8:	f3 05       	cpc	r31, r3
    73fa:	e1 f7       	brne	.-8      	; 0x73f4 <systemGenerateReport+0x1252>
    73fc:	f1 01       	movw	r30, r2
	     strMemory[i]=data;
    73fe:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7400:	e6 15       	cp	r30, r6
    7402:	f7 05       	cpc	r31, r7
    7404:	e1 f7       	brne	.-8      	; 0x73fe <systemGenerateReport+0x125c>
    7406:	f3 01       	movw	r30, r6
	     strMemory[i]=data;
    7408:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    740a:	cb 50       	subi	r28, 0x0B	; 11
    740c:	df 4f       	sbci	r29, 0xFF	; 255
    740e:	a8 81       	ld	r26, Y
    7410:	b9 81       	ldd	r27, Y+1	; 0x01
    7412:	c5 5f       	subi	r28, 0xF5	; 245
    7414:	d0 40       	sbci	r29, 0x00	; 0
    7416:	ea 17       	cp	r30, r26
    7418:	fb 07       	cpc	r31, r27
    741a:	b1 f7       	brne	.-20     	; 0x7408 <systemGenerateReport+0x1266>
    741c:	f2 01       	movw	r30, r4
	     strMemory[i]=data;
    741e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7420:	c9 50       	subi	r28, 0x09	; 9
    7422:	df 4f       	sbci	r29, 0xFF	; 255
    7424:	88 81       	ld	r24, Y
    7426:	99 81       	ldd	r25, Y+1	; 0x01
    7428:	c7 5f       	subi	r28, 0xF7	; 247
    742a:	d0 40       	sbci	r29, 0x00	; 0
    742c:	e8 17       	cp	r30, r24
    742e:	f9 07       	cpc	r31, r25
    7430:	b1 f7       	brne	.-20     	; 0x741e <systemGenerateReport+0x127c>
								  FillChar(strLastVolume,sizeof(strLastVolume),0);
								  FillChar(strLastMoney,sizeof(strLastMoney),0);
								  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
								  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

								  PumpNozzle=xNozzle;
    7432:	80 91 2f 02 	lds	r24, 0x022F
    7436:	80 93 2c 02 	sts	0x022C, r24
								  
								  FIPAddr=GetFIPAddr(PumpNum); 
    743a:	80 91 2d 02 	lds	r24, 0x022D
    743e:	0e 94 bd 1a 	call	0x357a	; 0x357a <GetFIPAddr>
								  if (FIPAddr>0){
    7442:	88 23       	and	r24, r24
    7444:	11 f1       	breq	.+68     	; 0x748a <systemGenerateReport+0x12e8>
									  FIPAddr=FIPAddr-1;							  							  							      
    7446:	f8 2e       	mov	r15, r24
    7448:	fa 94       	dec	r15
									  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    744a:	80 e0       	ldi	r24, 0x00	; 0
    744c:	60 e0       	ldi	r22, 0x00	; 0
    744e:	4f 2d       	mov	r20, r15
    7450:	20 91 2c 02 	lds	r18, 0x022C
    7454:	86 01       	movw	r16, r12
    7456:	0e 94 84 1b 	call	0x3708	; 0x3708 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    745a:	81 e0       	ldi	r24, 0x01	; 1
    745c:	60 e0       	ldi	r22, 0x00	; 0
    745e:	4f 2d       	mov	r20, r15
    7460:	20 91 2c 02 	lds	r18, 0x022C
    7464:	81 01       	movw	r16, r2
    7466:	0e 94 84 1b 	call	0x3708	; 0x3708 <GetTotalizerData>

									  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    746a:	80 e0       	ldi	r24, 0x00	; 0
    746c:	61 e0       	ldi	r22, 0x01	; 1
    746e:	4f 2d       	mov	r20, r15
    7470:	20 91 2c 02 	lds	r18, 0x022C
    7474:	83 01       	movw	r16, r6
    7476:	0e 94 84 1b 	call	0x3708	; 0x3708 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    747a:	81 e0       	ldi	r24, 0x01	; 1
    747c:	61 e0       	ldi	r22, 0x01	; 1
    747e:	4f 2d       	mov	r20, r15
    7480:	20 91 2c 02 	lds	r18, 0x022C
    7484:	82 01       	movw	r16, r4
    7486:	0e 94 84 1b 	call	0x3708	; 0x3708 <GetTotalizerData>
								  }

								  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    748a:	80 e0       	ldi	r24, 0x00	; 0
    748c:	b3 01       	movw	r22, r6
    748e:	a6 01       	movw	r20, r12
    7490:	2d e0       	ldi	r18, 0x0D	; 13
    7492:	3b e0       	ldi	r19, 0x0B	; 11
    7494:	0e 94 db 25 	call	0x4bb6	; 0x4bb6 <StrCalc>
								  if (IsMinus(strDeltaVolume)==True)
    7498:	8d e0       	ldi	r24, 0x0D	; 13
    749a:	9b e0       	ldi	r25, 0x0B	; 11
    749c:	0e 94 9e 20 	call	0x413c	; 0x413c <IsMinus>
    74a0:	81 30       	cpi	r24, 0x01	; 1
    74a2:	21 f4       	brne	.+8      	; 0x74ac <systemGenerateReport+0x130a>
								      NormalizeOverflow(strDeltaVolume);
    74a4:	8d e0       	ldi	r24, 0x0D	; 13
    74a6:	9b e0       	ldi	r25, 0x0B	; 11
    74a8:	0e 94 5f 29 	call	0x52be	; 0x52be <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    74ac:	e1 99       	sbic	0x1c, 1	; 28
    74ae:	fe cf       	rjmp	.-4      	; 0x74ac <systemGenerateReport+0x130a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    74b0:	a7 e6       	ldi	r26, 0x67	; 103
    74b2:	b1 e0       	ldi	r27, 0x01	; 1
    74b4:	bf bb       	out	0x1f, r27	; 31
    74b6:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    74b8:	e0 9a       	sbi	0x1c, 0	; 28
    74ba:	8d b3       	in	r24, 0x1d	; 29


								  //Calculate Wayne Estimated Total Money
								  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    74bc:	82 30       	cpi	r24, 0x02	; 2
    74be:	79 f4       	brne	.+30     	; 0x74de <systemGenerateReport+0x133c>
						              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    74c0:	ce 01       	movw	r24, r28
    74c2:	0f 96       	adiw	r24, 0x0f	; 15
    74c4:	60 91 2d 02 	lds	r22, 0x022D
    74c8:	40 91 2c 02 	lds	r20, 0x022C
    74cc:	0e 94 81 21 	call	0x4302	; 0x4302 <GetProductPrice>
									  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    74d0:	82 e0       	ldi	r24, 0x02	; 2
    74d2:	be 01       	movw	r22, r28
    74d4:	61 5f       	subi	r22, 0xF1	; 241
    74d6:	7f 4f       	sbci	r23, 0xFF	; 255
    74d8:	4d e0       	ldi	r20, 0x0D	; 13
    74da:	5b e0       	ldi	r21, 0x0B	; 11
    74dc:	03 c0       	rjmp	.+6      	; 0x74e4 <systemGenerateReport+0x1342>
								  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    74de:	80 e0       	ldi	r24, 0x00	; 0
    74e0:	b2 01       	movw	r22, r4
    74e2:	a1 01       	movw	r20, r2
    74e4:	28 e3       	ldi	r18, 0x38	; 56
    74e6:	3e e0       	ldi	r19, 0x0E	; 14
    74e8:	0e 94 db 25 	call	0x4bb6	; 0x4bb6 <StrCalc>
								  //StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
								  if (IsMinus(strDeltaMoney)==True)
    74ec:	88 e3       	ldi	r24, 0x38	; 56
    74ee:	9e e0       	ldi	r25, 0x0E	; 14
    74f0:	0e 94 9e 20 	call	0x413c	; 0x413c <IsMinus>
    74f4:	81 30       	cpi	r24, 0x01	; 1
    74f6:	21 f4       	brne	.+8      	; 0x7500 <systemGenerateReport+0x135e>
								      NormalizeOverflow(strDeltaMoney);
    74f8:	88 e3       	ldi	r24, 0x38	; 56
    74fa:	9e e0       	ldi	r25, 0x0E	; 14
    74fc:	0e 94 5f 29 	call	0x52be	; 0x52be <NormalizeOverflow>
		  
								  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    7500:	81 e0       	ldi	r24, 0x01	; 1
    7502:	68 e2       	ldi	r22, 0x28	; 40
    7504:	7a e0       	ldi	r23, 0x0A	; 10
    7506:	4d e0       	ldi	r20, 0x0D	; 13
    7508:	5b e0       	ldi	r21, 0x0B	; 11
    750a:	9b 01       	movw	r18, r22
    750c:	0e 94 db 25 	call	0x4bb6	; 0x4bb6 <StrCalc>
								  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    7510:	81 e0       	ldi	r24, 0x01	; 1
    7512:	6d ed       	ldi	r22, 0xDD	; 221
    7514:	7a e0       	ldi	r23, 0x0A	; 10
    7516:	48 e3       	ldi	r20, 0x38	; 56
    7518:	5e e0       	ldi	r21, 0x0E	; 14
    751a:	9b 01       	movw	r18, r22
    751c:	0e 94 db 25 	call	0x4bb6	; 0x4bb6 <StrCalc>

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
					  if (PumpNum>0){
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    7520:	80 91 2f 02 	lds	r24, 0x022F
    7524:	8f 5f       	subi	r24, 0xFF	; 255
    7526:	80 93 2f 02 	sts	0x022F, r24
    752a:	80 91 2f 02 	lds	r24, 0x022F
    752e:	87 30       	cpi	r24, 0x07	; 7
    7530:	08 f4       	brcc	.+2      	; 0x7534 <systemGenerateReport+0x1392>
    7532:	36 cf       	rjmp	.-404    	; 0x73a0 <systemGenerateReport+0x11fe>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    7534:	80 91 30 02 	lds	r24, 0x0230
    7538:	8f 5f       	subi	r24, 0xFF	; 255
    753a:	80 93 30 02 	sts	0x0230, r24
    753e:	80 91 30 02 	lds	r24, 0x0230
    7542:	89 30       	cpi	r24, 0x09	; 9
    7544:	08 f4       	brcc	.+2      	; 0x7548 <systemGenerateReport+0x13a6>
    7546:	15 cf       	rjmp	.-470    	; 0x7372 <systemGenerateReport+0x11d0>
							  }
						  }
					  }				  
				  }

				  RemZeroLead(strTotalMoney);
    7548:	8d ed       	ldi	r24, 0xDD	; 221
    754a:	9a e0       	ldi	r25, 0x0A	; 10
    754c:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
				  RemZeroLead(strTotalVolume);
    7550:	08 e2       	ldi	r16, 0x28	; 40
    7552:	1a e0       	ldi	r17, 0x0A	; 10
    7554:	c8 01       	movw	r24, r16
    7556:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>

				  FormatTotalizerMoney(strTotalMoney);
    755a:	8d ed       	ldi	r24, 0xDD	; 221
    755c:	9a e0       	ldi	r25, 0x0A	; 10
    755e:	0e 94 9d 30 	call	0x613a	; 0x613a <FormatTotalizerMoney>
				  FormatCurrency(strTotalMoney);
    7562:	8d ed       	ldi	r24, 0xDD	; 221
    7564:	9a e0       	ldi	r25, 0x0A	; 10
    7566:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>

				  FormatTotalizerVolume(strTotalVolume);
    756a:	c8 01       	movw	r24, r16
    756c:	0e 94 90 30 	call	0x6120	; 0x6120 <FormatTotalizerVolume>
				  FormatCurrency(strTotalVolume);
    7570:	c8 01       	movw	r24, r16
    7572:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>
		          //Test
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
    7576:	ed e6       	ldi	r30, 0x6D	; 109
    7578:	f9 e0       	ldi	r31, 0x09	; 9
    757a:	01 90       	ld	r0, Z+
    757c:	00 20       	and	r0, r0
    757e:	e9 f7       	brne	.-6      	; 0x757a <systemGenerateReport+0x13d8>
    7580:	31 97       	sbiw	r30, 0x01	; 1
    7582:	ed 56       	subi	r30, 0x6D	; 109
    7584:	f9 40       	sbci	r31, 0x09	; 9
    7586:	d8 01       	movw	r26, r16
    7588:	0d 90       	ld	r0, X+
    758a:	00 20       	and	r0, r0
    758c:	e9 f7       	brne	.-6      	; 0x7588 <systemGenerateReport+0x13e6>
    758e:	8d 01       	movw	r16, r26
    7590:	01 50       	subi	r16, 0x01	; 1
    7592:	10 40       	sbci	r17, 0x00	; 0
    7594:	08 52       	subi	r16, 0x28	; 40
    7596:	1a 40       	sbci	r17, 0x0A	; 10
    7598:	8e 2f       	mov	r24, r30
    759a:	81 95       	neg	r24
    759c:	80 1b       	sub	r24, r16
    759e:	8b 5e       	subi	r24, 0xEB	; 235
    75a0:	de 01       	movw	r26, r28
    75a2:	a7 59       	subi	r26, 0x97	; 151
    75a4:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    75a6:	18 16       	cp	r1, r24
    75a8:	7c f4       	brge	.+30     	; 0x75c8 <systemGenerateReport+0x1426>
    75aa:	fd 01       	movw	r30, r26
    75ac:	90 e0       	ldi	r25, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    75ae:	20 e2       	ldi	r18, 0x20	; 32
    75b0:	02 c0       	rjmp	.+4      	; 0x75b6 <systemGenerateReport+0x1414>
    75b2:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    75b4:	9f 5f       	subi	r25, 0xFF	; 255
    75b6:	98 17       	cp	r25, r24
    75b8:	e0 f3       	brcs	.-8      	; 0x75b2 <systemGenerateReport+0x1410>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    75ba:	fe 01       	movw	r30, r28
    75bc:	e7 59       	subi	r30, 0x97	; 151
    75be:	ff 4f       	sbci	r31, 0xFF	; 255
    75c0:	e8 0f       	add	r30, r24
    75c2:	f1 1d       	adc	r31, r1
    75c4:	10 82       	st	Z, r1
    75c6:	04 c0       	rjmp	.+8      	; 0x75d0 <systemGenerateReport+0x142e>
     }else{
	 strTab[0]=' ';
    75c8:	80 e2       	ldi	r24, 0x20	; 32
    75ca:	8c 93       	st	X, r24
	 strTab[1]=0;
    75cc:	11 96       	adiw	r26, 0x01	; 1
    75ce:	1c 92       	st	X, r1
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    75d0:	ed ed       	ldi	r30, 0xDD	; 221
    75d2:	fa e0       	ldi	r31, 0x0A	; 10
    75d4:	01 90       	ld	r0, Z+
    75d6:	00 20       	and	r0, r0
    75d8:	e9 f7       	brne	.-6      	; 0x75d4 <systemGenerateReport+0x1432>
    75da:	31 97       	sbiw	r30, 0x01	; 1
    75dc:	ed 5d       	subi	r30, 0xDD	; 221
    75de:	fa 40       	sbci	r31, 0x0A	; 10
    75e0:	9f e0       	ldi	r25, 0x0F	; 15
    75e2:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    75e4:	19 16       	cp	r1, r25
    75e6:	6c f4       	brge	.+26     	; 0x7602 <systemGenerateReport+0x1460>
    75e8:	f4 01       	movw	r30, r8
    75ea:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    75ec:	20 e2       	ldi	r18, 0x20	; 32
    75ee:	02 c0       	rjmp	.+4      	; 0x75f4 <systemGenerateReport+0x1452>
    75f0:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    75f2:	8f 5f       	subi	r24, 0xFF	; 255
    75f4:	89 17       	cp	r24, r25
    75f6:	e0 f3       	brcs	.-8      	; 0x75f0 <systemGenerateReport+0x144e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    75f8:	f4 01       	movw	r30, r8
    75fa:	e9 0f       	add	r30, r25
    75fc:	f1 1d       	adc	r31, r1
    75fe:	10 82       	st	Z, r1
    7600:	04 c0       	rjmp	.+8      	; 0x760a <systemGenerateReport+0x1468>
     }else{
	 strTab[0]=' ';
    7602:	80 e2       	ldi	r24, 0x20	; 32
    7604:	f4 01       	movw	r30, r8
    7606:	80 83       	st	Z, r24
	 strTab[1]=0;
    7608:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    760a:	e1 99       	sbic	0x1c, 1	; 28
    760c:	fe cf       	rjmp	.-4      	; 0x760a <systemGenerateReport+0x1468>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    760e:	81 ef       	ldi	r24, 0xF1	; 241
    7610:	93 e0       	ldi	r25, 0x03	; 3
    7612:	9f bb       	out	0x1f, r25	; 31
    7614:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7616:	e0 9a       	sbi	0x1c, 0	; 28
    7618:	8d b3       	in	r24, 0x1d	; 29
    761a:	9e 01       	movw	r18, r28
    761c:	2b 55       	subi	r18, 0x5B	; 91
    761e:	3f 4f       	sbci	r19, 0xFF	; 255
    7620:	48 e2       	ldi	r20, 0x28	; 40
    7622:	5a e0       	ldi	r21, 0x0A	; 10
    7624:	6d e6       	ldi	r22, 0x6D	; 109
    7626:	c6 2e       	mov	r12, r22
    7628:	69 e0       	ldi	r22, 0x09	; 9
    762a:	d6 2e       	mov	r13, r22
    762c:	de 01       	movw	r26, r28
    762e:	a7 59       	subi	r26, 0x97	; 151
    7630:	bf 4f       	sbci	r27, 0xFF	; 255
    7632:	b5 01       	movw	r22, r10
    7634:	6f 5f       	subi	r22, 0xFF	; 255
    7636:	7f 4f       	sbci	r23, 0xFF	; 255

			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);

				  //PrintMoney
		          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%d.%s%s%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);
    7638:	81 30       	cpi	r24, 0x01	; 1
    763a:	39 f5       	brne	.+78     	; 0x768a <systemGenerateReport+0x14e8>
    763c:	ed b7       	in	r30, 0x3d	; 61
    763e:	fe b7       	in	r31, 0x3e	; 62
    7640:	70 97       	sbiw	r30, 0x10	; 16
    7642:	0f b6       	in	r0, 0x3f	; 63
    7644:	f8 94       	cli
    7646:	fe bf       	out	0x3e, r31	; 62
    7648:	0f be       	out	0x3f, r0	; 63
    764a:	ed bf       	out	0x3d, r30	; 61
    764c:	0d b7       	in	r16, 0x3d	; 61
    764e:	1e b7       	in	r17, 0x3e	; 62
    7650:	0f 5f       	subi	r16, 0xFF	; 255
    7652:	1f 4f       	sbci	r17, 0xFF	; 255
    7654:	32 83       	std	Z+2, r19	; 0x02
    7656:	21 83       	std	Z+1, r18	; 0x01
    7658:	8b e8       	ldi	r24, 0x8B	; 139
    765a:	94 e0       	ldi	r25, 0x04	; 4
    765c:	f8 01       	movw	r30, r16
    765e:	93 83       	std	Z+3, r25	; 0x03
    7660:	82 83       	std	Z+2, r24	; 0x02
    7662:	75 83       	std	Z+5, r23	; 0x05
    7664:	64 83       	std	Z+4, r22	; 0x04
    7666:	d7 82       	std	Z+7, r13	; 0x07
    7668:	c6 82       	std	Z+6, r12	; 0x06
    766a:	b1 87       	std	Z+9, r27	; 0x09
    766c:	a0 87       	std	Z+8, r26	; 0x08
    766e:	53 87       	std	Z+11, r21	; 0x0b
    7670:	42 87       	std	Z+10, r20	; 0x0a
    7672:	95 86       	std	Z+13, r9	; 0x0d
    7674:	84 86       	std	Z+12, r8	; 0x0c
    7676:	8d ed       	ldi	r24, 0xDD	; 221
    7678:	9a e0       	ldi	r25, 0x0A	; 10
    767a:	97 87       	std	Z+15, r25	; 0x0f
    767c:	86 87       	std	Z+14, r24	; 0x0e
    767e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    7682:	8d b7       	in	r24, 0x3d	; 61
    7684:	9e b7       	in	r25, 0x3e	; 62
    7686:	40 96       	adiw	r24, 0x10	; 16
    7688:	20 c0       	rjmp	.+64     	; 0x76ca <systemGenerateReport+0x1528>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);
    768a:	ed b7       	in	r30, 0x3d	; 61
    768c:	fe b7       	in	r31, 0x3e	; 62
    768e:	3c 97       	sbiw	r30, 0x0c	; 12
    7690:	0f b6       	in	r0, 0x3f	; 63
    7692:	f8 94       	cli
    7694:	fe bf       	out	0x3e, r31	; 62
    7696:	0f be       	out	0x3f, r0	; 63
    7698:	ed bf       	out	0x3d, r30	; 61
    769a:	0d b7       	in	r16, 0x3d	; 61
    769c:	1e b7       	in	r17, 0x3e	; 62
    769e:	0f 5f       	subi	r16, 0xFF	; 255
    76a0:	1f 4f       	sbci	r17, 0xFF	; 255
    76a2:	32 83       	std	Z+2, r19	; 0x02
    76a4:	21 83       	std	Z+1, r18	; 0x01
    76a6:	81 e8       	ldi	r24, 0x81	; 129
    76a8:	94 e0       	ldi	r25, 0x04	; 4
    76aa:	f8 01       	movw	r30, r16
    76ac:	93 83       	std	Z+3, r25	; 0x03
    76ae:	82 83       	std	Z+2, r24	; 0x02
    76b0:	75 83       	std	Z+5, r23	; 0x05
    76b2:	64 83       	std	Z+4, r22	; 0x04
    76b4:	d7 82       	std	Z+7, r13	; 0x07
    76b6:	c6 82       	std	Z+6, r12	; 0x06
    76b8:	b1 87       	std	Z+9, r27	; 0x09
    76ba:	a0 87       	std	Z+8, r26	; 0x08
    76bc:	53 87       	std	Z+11, r21	; 0x0b
    76be:	42 87       	std	Z+10, r20	; 0x0a
    76c0:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    76c4:	8d b7       	in	r24, 0x3d	; 61
    76c6:	9e b7       	in	r25, 0x3e	; 62
    76c8:	0c 96       	adiw	r24, 0x0c	; 12
    76ca:	0f b6       	in	r0, 0x3f	; 63
    76cc:	f8 94       	cli
    76ce:	9e bf       	out	0x3e, r25	; 62
    76d0:	0f be       	out	0x3f, r0	; 63
    76d2:	8d bf       	out	0x3d, r24	; 61

				  CreateReport(strReport,PrintBuffer,&RepPos);
    76d4:	ce 01       	movw	r24, r28
    76d6:	8b 55       	subi	r24, 0x5B	; 91
    76d8:	9f 4f       	sbci	r25, 0xFF	; 255
    76da:	67 ef       	ldi	r22, 0xF7	; 247
    76dc:	75 e0       	ldi	r23, 0x05	; 5
    76de:	4f e1       	ldi	r20, 0x1F	; 31
    76e0:	52 e0       	ldi	r21, 0x02	; 2
    76e2:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <CreateReport>
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
    76e6:	e3 94       	inc	r14
    76e8:	e1 e2       	ldi	r30, 0x21	; 33
    76ea:	f2 e0       	ldi	r31, 0x02	; 2
    76ec:	01 90       	ld	r0, Z+
    76ee:	00 20       	and	r0, r0
    76f0:	e9 f7       	brne	.-6      	; 0x76ec <systemGenerateReport+0x154a>
    76f2:	31 97       	sbiw	r30, 0x01	; 1
    76f4:	e1 52       	subi	r30, 0x21	; 33
    76f6:	f2 40       	sbci	r31, 0x02	; 2
    76f8:	ae 2c       	mov	r10, r14
    76fa:	bb 24       	eor	r11, r11
    76fc:	ae 16       	cp	r10, r30
    76fe:	bf 06       	cpc	r11, r31
    7700:	08 f4       	brcc	.+2      	; 0x7704 <systemGenerateReport+0x1562>
    7702:	0f ce       	rjmp	.-994    	; 0x7322 <systemGenerateReport+0x1180>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);

				  CreateReport(strReport,PrintBuffer,&RepPos);
               }
		  }
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7704:	87 e0       	ldi	r24, 0x07	; 7
    7706:	67 ef       	ldi	r22, 0xF7	; 247
    7708:	75 e0       	ldi	r23, 0x05	; 5
    770a:	41 e0       	ldi	r20, 0x01	; 1
    770c:	2f e1       	ldi	r18, 0x1F	; 31
    770e:	32 e0       	ldi	r19, 0x02	; 2
    7710:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    7714:	8b e0       	ldi	r24, 0x0B	; 11
    7716:	67 ef       	ldi	r22, 0xF7	; 247
    7718:	75 e0       	ldi	r23, 0x05	; 5
    771a:	4a e2       	ldi	r20, 0x2A	; 42
    771c:	2f e1       	ldi	r18, 0x1F	; 31
    771e:	32 e0       	ldi	r19, 0x02	; 2
    7720:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    7724:	89 e0       	ldi	r24, 0x09	; 9
    7726:	67 ef       	ldi	r22, 0xF7	; 247
    7728:	75 e0       	ldi	r23, 0x05	; 5
    772a:	41 e0       	ldi	r20, 0x01	; 1
    772c:	2f e1       	ldi	r18, 0x1F	; 31
    772e:	32 e0       	ldi	r19, 0x02	; 2
    7730:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    7734:	8c e0       	ldi	r24, 0x0C	; 12
    7736:	67 ef       	ldi	r22, 0xF7	; 247
    7738:	75 e0       	ldi	r23, 0x05	; 5
    773a:	41 e0       	ldi	r20, 0x01	; 1
    773c:	2f e1       	ldi	r18, 0x1F	; 31
    773e:	32 e0       	ldi	r19, 0x02	; 2
    7740:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
		  InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7744:	8c e0       	ldi	r24, 0x0C	; 12
    7746:	67 ef       	ldi	r22, 0xF7	; 247
    7748:	75 e0       	ldi	r23, 0x05	; 5
    774a:	41 e0       	ldi	r20, 0x01	; 1
    774c:	2f e1       	ldi	r18, 0x1F	; 31
    774e:	32 e0       	ldi	r19, 0x02	; 2
    7750:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    7754:	8c e0       	ldi	r24, 0x0C	; 12
    7756:	67 ef       	ldi	r22, 0xF7	; 247
    7758:	75 e0       	ldi	r23, 0x05	; 5
    775a:	41 e0       	ldi	r20, 0x01	; 1
    775c:	2f e1       	ldi	r18, 0x1F	; 31
    775e:	32 e0       	ldi	r19, 0x02	; 2
    7760:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    7764:	8c e0       	ldi	r24, 0x0C	; 12
    7766:	67 ef       	ldi	r22, 0xF7	; 247
    7768:	75 e0       	ldi	r23, 0x05	; 5
    776a:	41 e0       	ldi	r20, 0x01	; 1
    776c:	2f e1       	ldi	r18, 0x1F	; 31
    776e:	32 e0       	ldi	r19, 0x02	; 2
    7770:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    7774:	8c e0       	ldi	r24, 0x0C	; 12
    7776:	67 ef       	ldi	r22, 0xF7	; 247
    7778:	75 e0       	ldi	r23, 0x05	; 5
    777a:	41 e0       	ldi	r20, 0x01	; 1
    777c:	2f e1       	ldi	r18, 0x1F	; 31
    777e:	32 e0       	ldi	r19, 0x02	; 2
    7780:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>
    7784:	8c e0       	ldi	r24, 0x0C	; 12
    7786:	67 ef       	ldi	r22, 0xF7	; 247
    7788:	75 e0       	ldi	r23, 0x05	; 5
    778a:	41 e0       	ldi	r20, 0x01	; 1
    778c:	2f e1       	ldi	r18, 0x1F	; 31
    778e:	32 e0       	ldi	r19, 0x02	; 2
    7790:	0e 94 38 19 	call	0x3270	; 0x3270 <InserBorder>


          cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    7794:	80 e3       	ldi	r24, 0x30	; 48
    7796:	80 93 e0 01 	sts	0x01E0, r24
		  LengthMessage81=RepPos+1;
    779a:	80 91 1f 02 	lds	r24, 0x021F
    779e:	90 91 20 02 	lds	r25, 0x0220
    77a2:	01 96       	adiw	r24, 0x01	; 1
    77a4:	90 93 b6 01 	sts	0x01B6, r25
    77a8:	80 93 b5 01 	sts	0x01B5, r24
		  IsFreePrinting=True;
    77ac:	81 e0       	ldi	r24, 0x01	; 1
    77ae:	80 93 d5 01 	sts	0x01D5, r24
	      IsBusyFreePrinting=True; 
    77b2:	80 93 de 01 	sts	0x01DE, r24
         	       
	      stGenerateReport=grWaitPrinted3;
    77b6:	8b e0       	ldi	r24, 0x0B	; 11
    77b8:	05 c0       	rjmp	.+10     	; 0x77c4 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted3:
          if (IsBusyFreePrinting==False)stGenerateReport=grFinishGenerateReport;
    77ba:	80 91 de 01 	lds	r24, 0x01DE
    77be:	88 23       	and	r24, r24
    77c0:	49 f4       	brne	.+18     	; 0x77d4 <systemGenerateReport+0x1632>
    77c2:	8c e0       	ldi	r24, 0x0C	; 12
    77c4:	80 93 31 02 	sts	0x0231, r24
    77c8:	05 c0       	rjmp	.+10     	; 0x77d4 <systemGenerateReport+0x1632>
	      break;
     case grFinishGenerateReport:
	      IsFinishPrintingTotalizer=True;
    77ca:	81 e0       	ldi	r24, 0x01	; 1
    77cc:	80 93 b0 01 	sts	0x01B0, r24
          stGenerateReport=grScanAction;
    77d0:	10 92 31 02 	sts	0x0231, r1
	      break;
	 }
}
    77d4:	c8 50       	subi	r28, 0x08	; 8
    77d6:	df 4f       	sbci	r29, 0xFF	; 255
    77d8:	0f b6       	in	r0, 0x3f	; 63
    77da:	f8 94       	cli
    77dc:	de bf       	out	0x3e, r29	; 62
    77de:	0f be       	out	0x3f, r0	; 63
    77e0:	cd bf       	out	0x3d, r28	; 61
    77e2:	cf 91       	pop	r28
    77e4:	df 91       	pop	r29
    77e6:	1f 91       	pop	r17
    77e8:	0f 91       	pop	r16
    77ea:	ff 90       	pop	r15
    77ec:	ef 90       	pop	r14
    77ee:	df 90       	pop	r13
    77f0:	cf 90       	pop	r12
    77f2:	bf 90       	pop	r11
    77f4:	af 90       	pop	r10
    77f6:	9f 90       	pop	r9
    77f8:	8f 90       	pop	r8
    77fa:	7f 90       	pop	r7
    77fc:	6f 90       	pop	r6
    77fe:	5f 90       	pop	r5
    7800:	4f 90       	pop	r4
    7802:	3f 90       	pop	r3
    7804:	2f 90       	pop	r2
    7806:	08 95       	ret

00007808 <UpdateCardID>:
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 


void UpdateCardID(){
    7808:	cf 93       	push	r28
    780a:	df 93       	push	r29
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
    780c:	ec e5       	ldi	r30, 0x5C	; 92
    780e:	fe e0       	ldi	r31, 0x0E	; 14
    7810:	01 90       	ld	r0, Z+
    7812:	00 20       	and	r0, r0
    7814:	e9 f7       	brne	.-6      	; 0x7810 <UpdateCardID+0x8>
    7816:	31 97       	sbiw	r30, 0x01	; 1
    7818:	ec 55       	subi	r30, 0x5C	; 92
    781a:	fe 40       	sbci	r31, 0x0E	; 14
    781c:	a1 e9       	ldi	r26, 0x91	; 145
    781e:	bd e0       	ldi	r27, 0x0D	; 13
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 


void UpdateCardID(){
    7820:	f0 e0       	ldi	r31, 0x00	; 0
    7822:	ef 01       	movw	r28, r30
    7824:	c8 5b       	subi	r28, 0xB8	; 184
    7826:	d1 4f       	sbci	r29, 0xF1	; 241
    7828:	20 e0       	ldi	r18, 0x00	; 0
    782a:	30 e0       	ldi	r19, 0x00	; 0
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
	    if (i<(20-LengthID))strCardID[i]=' ';
    782c:	44 e1       	ldi	r20, 0x14	; 20
    782e:	50 e0       	ldi	r21, 0x00	; 0
    7830:	4e 1b       	sub	r20, r30
    7832:	5f 0b       	sbc	r21, r31
    7834:	90 e2       	ldi	r25, 0x20	; 32
    7836:	24 17       	cp	r18, r20
    7838:	35 07       	cpc	r19, r21
    783a:	14 f4       	brge	.+4      	; 0x7840 <UpdateCardID+0x38>
    783c:	9c 93       	st	X, r25
    783e:	02 c0       	rjmp	.+4      	; 0x7844 <UpdateCardID+0x3c>
		else strCardID[i]=strRFID[i-(20-LengthID)];
    7840:	88 81       	ld	r24, Y
    7842:	8c 93       	st	X, r24
    7844:	2f 5f       	subi	r18, 0xFF	; 255
    7846:	3f 4f       	sbci	r19, 0xFF	; 255
    7848:	11 96       	adiw	r26, 0x01	; 1
    784a:	21 96       	adiw	r28, 0x01	; 1


void UpdateCardID(){
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
    784c:	24 31       	cpi	r18, 0x14	; 20
    784e:	31 05       	cpc	r19, r1
    7850:	91 f7       	brne	.-28     	; 0x7836 <UpdateCardID+0x2e>
	    if (i<(20-LengthID))strCardID[i]=' ';
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;     
    7852:	10 92 a5 0d 	sts	0x0DA5, r1
}
    7856:	df 91       	pop	r29
    7858:	cf 91       	pop	r28
    785a:	08 95       	ret

0000785c <GetParameter>:
	}
  return  PosFound;
}


void GetParameter(char *GFlow,char FLength,char *GCmd,char *GPumpID, char *GeniCSum){
    785c:	8f 92       	push	r8
    785e:	9f 92       	push	r9
    7860:	af 92       	push	r10
    7862:	bf 92       	push	r11
    7864:	cf 92       	push	r12
    7866:	df 92       	push	r13
    7868:	ef 92       	push	r14
    786a:	ff 92       	push	r15
    786c:	0f 93       	push	r16
    786e:	1f 93       	push	r17
    7870:	df 93       	push	r29
    7872:	cf 93       	push	r28
    7874:	cd b7       	in	r28, 0x3d	; 61
    7876:	de b7       	in	r29, 0x3e	; 62
    7878:	a7 97       	sbiw	r28, 0x27	; 39
    787a:	0f b6       	in	r0, 0x3f	; 63
    787c:	f8 94       	cli
    787e:	de bf       	out	0x3e, r29	; 62
    7880:	0f be       	out	0x3f, r0	; 63
    7882:	cd bf       	out	0x3d, r28	; 61
    7884:	79 01       	movw	r14, r18
    7886:	48 01       	movw	r8, r16
    7888:	e6 2f       	mov	r30, r22
    788a:	f0 e0       	ldi	r31, 0x00	; 0
    788c:	31 97       	sbiw	r30, 0x01	; 1
    788e:	e8 0f       	add	r30, r24
    7890:	f9 1f       	adc	r31, r25
    7892:	9e 01       	movw	r18, r28
    7894:	26 5f       	subi	r18, 0xF6	; 246
    7896:	3f 4f       	sbci	r19, 0xFF	; 255
    7898:	d9 01       	movw	r26, r18
    789a:	03 c0       	rjmp	.+6      	; 0x78a2 <GetParameter+0x46>
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
	     SGeniusFlow[i]=GFlow[FLength-i-1];
    789c:	80 81       	ld	r24, Z
    789e:	8d 93       	st	X+, r24
    78a0:	31 97       	sbiw	r30, 0x01	; 1
char SGeniusFlow[30];
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
    78a2:	8a 2f       	mov	r24, r26
    78a4:	82 1b       	sub	r24, r18
    78a6:	86 17       	cp	r24, r22
    78a8:	c8 f3       	brcs	.-14     	; 0x789c <GetParameter+0x40>
	     SGeniusFlow[i]=GFlow[FLength-i-1];
	 }SGeniusFlow[FLength]=0;
    78aa:	c6 2e       	mov	r12, r22
    78ac:	dd 24       	eor	r13, r13
    78ae:	ea e0       	ldi	r30, 0x0A	; 10
    78b0:	ae 2e       	mov	r10, r30
    78b2:	b1 2c       	mov	r11, r1
    78b4:	ac 0e       	add	r10, r28
    78b6:	bd 1e       	adc	r11, r29
    78b8:	f5 01       	movw	r30, r10
    78ba:	ec 0d       	add	r30, r12
    78bc:	fd 1d       	adc	r31, r13
    78be:	10 82       	st	Z, r1

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
    78c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    78c2:	fa 01       	movw	r30, r20
    78c4:	80 83       	st	Z, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    78c6:	8b 85       	ldd	r24, Y+11	; 0x0b
    78c8:	89 83       	std	Y+1, r24	; 0x01
    78ca:	8c 85       	ldd	r24, Y+12	; 0x0c
    78cc:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    78ce:	1b 82       	std	Y+3, r1	; 0x03
	 }SGeniusFlow[FLength]=0;

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
	 StrPosCopy(SGeniusFlow,sPumpID,1,2);
	 xPumpID=atoi(sPumpID);
    78d0:	ce 01       	movw	r24, r28
    78d2:	01 96       	adiw	r24, 0x01	; 1
    78d4:	0e 94 6e b4 	call	0x168dc	; 0x168dc <atoi>
	 *GPumpID=xPumpID;
    78d8:	f7 01       	movw	r30, r14
    78da:	80 83       	st	Z, r24
	 sprintf_P(strSub,PSTR(":"));
    78dc:	00 d0       	rcall	.+0      	; 0x78de <GetParameter+0x82>
    78de:	00 d0       	rcall	.+0      	; 0x78e0 <GetParameter+0x84>
    78e0:	77 e0       	ldi	r23, 0x07	; 7
    78e2:	e7 2e       	mov	r14, r23
    78e4:	f1 2c       	mov	r15, r1
    78e6:	ec 0e       	add	r14, r28
    78e8:	fd 1e       	adc	r15, r29
    78ea:	ed b7       	in	r30, 0x3d	; 61
    78ec:	fe b7       	in	r31, 0x3e	; 62
    78ee:	f2 82       	std	Z+2, r15	; 0x02
    78f0:	e1 82       	std	Z+1, r14	; 0x01
    78f2:	8b ef       	ldi	r24, 0xFB	; 251
    78f4:	93 e0       	ldi	r25, 0x03	; 3
    78f6:	94 83       	std	Z+4, r25	; 0x04
    78f8:	83 83       	std	Z+3, r24	; 0x03
    78fa:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 if (Pos(strSub,SGeniusFlow)<FLength){
    78fe:	0f 90       	pop	r0
    7900:	0f 90       	pop	r0
    7902:	0f 90       	pop	r0
    7904:	0f 90       	pop	r0
    7906:	c7 01       	movw	r24, r14
    7908:	b5 01       	movw	r22, r10
    790a:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <Pos>
    790e:	8c 15       	cp	r24, r12
    7910:	9d 05       	cpc	r25, r13
    7912:	4c f5       	brge	.+82     	; 0x7966 <GetParameter+0x10a>
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
    7914:	c7 01       	movw	r24, r14
    7916:	b5 01       	movw	r22, r10
    7918:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <Pos>
    791c:	8c 01       	movw	r16, r24
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
    791e:	c7 01       	movw	r24, r14
    7920:	b5 01       	movw	r22, r10
    7922:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <Pos>
    7926:	a6 01       	movw	r20, r12
    7928:	40 1b       	sub	r20, r16
    792a:	51 0b       	sbc	r21, r17
    792c:	d5 01       	movw	r26, r10
    792e:	a8 0f       	add	r26, r24
    7930:	b9 1f       	adc	r27, r25
    7932:	20 e0       	ldi	r18, 0x00	; 0
    7934:	30 e0       	ldi	r19, 0x00	; 0
    7936:	be 01       	movw	r22, r28
    7938:	6c 5f       	subi	r22, 0xFC	; 252
    793a:	7f 4f       	sbci	r23, 0xFF	; 255
    793c:	07 c0       	rjmp	.+14     	; 0x794c <GetParameter+0xf0>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    793e:	fb 01       	movw	r30, r22
    7940:	e2 0f       	add	r30, r18
    7942:	f3 1f       	adc	r31, r19
    7944:	8c 91       	ld	r24, X
    7946:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7948:	2f 5f       	subi	r18, 0xFF	; 255
    794a:	3f 4f       	sbci	r19, 0xFF	; 255
    794c:	11 96       	adiw	r26, 0x01	; 1
    794e:	24 17       	cp	r18, r20
    7950:	35 07       	cpc	r19, r21
    7952:	a8 f3       	brcs	.-22     	; 0x793e <GetParameter+0xe2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7954:	46 0f       	add	r20, r22
    7956:	57 1f       	adc	r21, r23
    7958:	fa 01       	movw	r30, r20
    795a:	10 82       	st	Z, r1
	 *GPumpID=xPumpID;
	 sprintf_P(strSub,PSTR(":"));
	 if (Pos(strSub,SGeniusFlow)<FLength){
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
		 xCsum=atoi(sCSum);
    795c:	cb 01       	movw	r24, r22
    795e:	0e 94 6e b4 	call	0x168dc	; 0x168dc <atoi>
	     *GeniCSum=xCsum;
    7962:	f4 01       	movw	r30, r8
    7964:	80 83       	st	Z, r24
	 sprintf_P(strSend,PSTR("%d"),xPumpID);
	 _uart_print(1,1,strSend);
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 _uart_print(1,1,strSend);
*/
}
    7966:	a7 96       	adiw	r28, 0x27	; 39
    7968:	0f b6       	in	r0, 0x3f	; 63
    796a:	f8 94       	cli
    796c:	de bf       	out	0x3e, r29	; 62
    796e:	0f be       	out	0x3f, r0	; 63
    7970:	cd bf       	out	0x3d, r28	; 61
    7972:	cf 91       	pop	r28
    7974:	df 91       	pop	r29
    7976:	1f 91       	pop	r17
    7978:	0f 91       	pop	r16
    797a:	ff 90       	pop	r15
    797c:	ef 90       	pop	r14
    797e:	df 90       	pop	r13
    7980:	cf 90       	pop	r12
    7982:	bf 90       	pop	r11
    7984:	af 90       	pop	r10
    7986:	9f 90       	pop	r9
    7988:	8f 90       	pop	r8
    798a:	08 95       	ret

0000798c <GeniusProtocol>:
   return Result;	 
}

//enum eGeniusProtocolCommand{GP_PUMP_STATUS,GP_PUMP_LAST_TRANSACTION,GP_PUMP_STOP,GP_PUMP_RESUME,GP_PUMP_PRESET};

void GeniusProtocol(char dataIn){
    798c:	ff 92       	push	r15
    798e:	0f 93       	push	r16
    7990:	1f 93       	push	r17
    7992:	df 93       	push	r29
    7994:	cf 93       	push	r28
    7996:	cd b7       	in	r28, 0x3d	; 61
    7998:	de b7       	in	r29, 0x3e	; 62
    799a:	67 97       	sbiw	r28, 0x17	; 23
    799c:	0f b6       	in	r0, 0x3f	; 63
    799e:	f8 94       	cli
    79a0:	de bf       	out	0x3e, r29	; 62
    79a2:	0f be       	out	0x3f, r0	; 63
    79a4:	cd bf       	out	0x3d, r28	; 61
    79a6:	f8 2e       	mov	r15, r24
	 char sCmd[7],i,GeniCmd,GeniPumpID,GeniCSum;
	 char strSend[20];

    //_uart(1,1,dataIn);

	if (dataIn==0x0D){	
    79a8:	8d e0       	ldi	r24, 0x0D	; 13
    79aa:	f8 16       	cp	r15, r24
    79ac:	09 f0       	breq	.+2      	; 0x79b0 <GeniusProtocol+0x24>
    79ae:	45 c0       	rjmp	.+138    	; 0x7a3a <GeniusProtocol+0xae>
	    GetParameter(Geniflow,FlowLength,&GeniCmd,&GeniPumpID,&GeniCSum);
    79b0:	8c ef       	ldi	r24, 0xFC	; 252
    79b2:	91 e0       	ldi	r25, 0x01	; 1
    79b4:	60 91 fb 01 	lds	r22, 0x01FB
    79b8:	ae 01       	movw	r20, r28
    79ba:	4f 5f       	subi	r20, 0xFF	; 255
    79bc:	5f 4f       	sbci	r21, 0xFF	; 255
    79be:	9e 01       	movw	r18, r28
    79c0:	2e 5f       	subi	r18, 0xFE	; 254
    79c2:	3f 4f       	sbci	r19, 0xFF	; 255
    79c4:	8e 01       	movw	r16, r28
    79c6:	0d 5f       	subi	r16, 0xFD	; 253
    79c8:	1f 4f       	sbci	r17, 0xFF	; 255
    79ca:	0e 94 2e 3c 	call	0x785c	; 0x785c <GetParameter>
		FlowLength=0;
    79ce:	10 92 fb 01 	sts	0x01FB, r1
		IsGeniusFlow=False;
    79d2:	10 92 fa 01 	sts	0x01FA, r1
		FillChar(strSend,0,sizeof(strSend));
		sprintf_P(strSend,PSTR("%c%.2d:"),GeniCmd,GeniPumpID);
    79d6:	ad b7       	in	r26, 0x3d	; 61
    79d8:	be b7       	in	r27, 0x3e	; 62
    79da:	18 97       	sbiw	r26, 0x08	; 8
    79dc:	0f b6       	in	r0, 0x3f	; 63
    79de:	f8 94       	cli
    79e0:	be bf       	out	0x3e, r27	; 62
    79e2:	0f be       	out	0x3f, r0	; 63
    79e4:	ad bf       	out	0x3d, r26	; 61
    79e6:	ed b7       	in	r30, 0x3d	; 61
    79e8:	fe b7       	in	r31, 0x3e	; 62
    79ea:	31 96       	adiw	r30, 0x01	; 1
    79ec:	8e 01       	movw	r16, r28
    79ee:	0c 5f       	subi	r16, 0xFC	; 252
    79f0:	1f 4f       	sbci	r17, 0xFF	; 255
    79f2:	12 96       	adiw	r26, 0x02	; 2
    79f4:	1c 93       	st	X, r17
    79f6:	0e 93       	st	-X, r16
    79f8:	11 97       	sbiw	r26, 0x01	; 1
    79fa:	8d ee       	ldi	r24, 0xED	; 237
    79fc:	93 e0       	ldi	r25, 0x03	; 3
    79fe:	93 83       	std	Z+3, r25	; 0x03
    7a00:	82 83       	std	Z+2, r24	; 0x02
    7a02:	89 81       	ldd	r24, Y+1	; 0x01
    7a04:	84 83       	std	Z+4, r24	; 0x04
    7a06:	15 82       	std	Z+5, r1	; 0x05
    7a08:	8a 81       	ldd	r24, Y+2	; 0x02
    7a0a:	86 83       	std	Z+6, r24	; 0x06
    7a0c:	17 82       	std	Z+7, r1	; 0x07
    7a0e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		//_uart_print(1,1,strSend);


		if ((SumChecksum(strSend))==GeniCSum){
    7a12:	8d b7       	in	r24, 0x3d	; 61
    7a14:	9e b7       	in	r25, 0x3e	; 62
    7a16:	08 96       	adiw	r24, 0x08	; 8
    7a18:	0f b6       	in	r0, 0x3f	; 63
    7a1a:	f8 94       	cli
    7a1c:	9e bf       	out	0x3e, r25	; 62
    7a1e:	0f be       	out	0x3f, r0	; 63
    7a20:	8d bf       	out	0x3d, r24	; 61
    7a22:	c8 01       	movw	r24, r16
    7a24:	0e 94 9d 1e 	call	0x3d3a	; 0x3d3a <SumChecksum>
    7a28:	9b 81       	ldd	r25, Y+3	; 0x03
    7a2a:	89 17       	cp	r24, r25
    7a2c:	31 f4       	brne	.+12     	; 0x7a3a <GeniusProtocol+0xae>
		     switch(GeniCmd){
    7a2e:	89 81       	ldd	r24, Y+1	; 0x01
    7a30:	84 35       	cpi	r24, 0x54	; 84
    7a32:	19 f4       	brne	.+6      	; 0x7a3a <GeniusProtocol+0xae>
			 case 'C'://PumpStatus
			      GeniusSendPumpStatus(GeniPumpID);
			      break;
             case 'T'://Transaction Request: T01:239<0D>
			      GeniusSendLastTransaction(GeniPumpID);
    7a34:	8a 81       	ldd	r24, Y+2	; 0x02
    7a36:	0e 94 9b 2a 	call	0x5536	; 0x5536 <GeniusSendLastTransaction>
    7a3a:	ee e0       	ldi	r30, 0x0E	; 14
    7a3c:	f2 e0       	ldi	r31, 0x02	; 2
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
	    Geniflow[i]=Geniflow[i-1];	
    7a3e:	80 81       	ld	r24, Z
    7a40:	81 83       	std	Z+1, r24	; 0x01
    7a42:	31 97       	sbiw	r30, 0x01	; 1
			      break;
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
    7a44:	91 e0       	ldi	r25, 0x01	; 1
    7a46:	eb 3f       	cpi	r30, 0xFB	; 251
    7a48:	f9 07       	cpc	r31, r25
    7a4a:	c9 f7       	brne	.-14     	; 0x7a3e <GeniusProtocol+0xb2>
	    Geniflow[i]=Geniflow[i-1];	
	}Geniflow[0]=dataIn;
    7a4c:	f1 82       	std	Z+1, r15	; 0x01

	if (IsGeniusCommand(dataIn)==True)IsGeniusFlow=True;
    7a4e:	8f 2d       	mov	r24, r15
    7a50:	0e 94 bd 1e 	call	0x3d7a	; 0x3d7a <IsGeniusCommand>
    7a54:	81 30       	cpi	r24, 0x01	; 1
    7a56:	11 f4       	brne	.+4      	; 0x7a5c <GeniusProtocol+0xd0>
    7a58:	80 93 fa 01 	sts	0x01FA, r24
	if (IsGeniusFlow==True)FlowLength++;
    7a5c:	80 91 fa 01 	lds	r24, 0x01FA
    7a60:	81 30       	cpi	r24, 0x01	; 1
    7a62:	29 f4       	brne	.+10     	; 0x7a6e <GeniusProtocol+0xe2>
    7a64:	80 91 fb 01 	lds	r24, 0x01FB
    7a68:	8f 5f       	subi	r24, 0xFF	; 255
    7a6a:	80 93 fb 01 	sts	0x01FB, r24
	Geniflow[3]=Geniflow[2];
	Geniflow[2]=Geniflow[1];
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}
    7a6e:	67 96       	adiw	r28, 0x17	; 23
    7a70:	0f b6       	in	r0, 0x3f	; 63
    7a72:	f8 94       	cli
    7a74:	de bf       	out	0x3e, r29	; 62
    7a76:	0f be       	out	0x3f, r0	; 63
    7a78:	cd bf       	out	0x3d, r28	; 61
    7a7a:	cf 91       	pop	r28
    7a7c:	df 91       	pop	r29
    7a7e:	1f 91       	pop	r17
    7a80:	0f 91       	pop	r16
    7a82:	ff 90       	pop	r15
    7a84:	08 95       	ret

00007a86 <procMessage99>:
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}

char procMessage99(){//<STX>[IFT IDSeq N Srce IPDest IPMsg CodeTran NoShiftDateTimeIsland IDFIP IDProduct IDDescriptionPriceVolumeAmountMOP TypeMOP NameCard IDCard HolderBalance Type Balance MeterVolume MeterAmount Current TimePrint Count Checksum ETX
    7a86:	0f 93       	push	r16
    7a88:	1f 93       	push	r17
     char Result;
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
    7a8a:	80 91 25 0b 	lds	r24, 0x0B25
    7a8e:	81 30       	cpi	r24, 0x01	; 1
    7a90:	09 f0       	breq	.+2      	; 0x7a94 <procMessage99+0xe>
    7a92:	2e c2       	rjmp	.+1116   	; 0x7ef0 <procMessage99+0x46a>
    7a94:	80 91 b3 01 	lds	r24, 0x01B3
    7a98:	90 91 b4 01 	lds	r25, 0x01B4
    7a9c:	8a 57       	subi	r24, 0x7A	; 122
    7a9e:	91 40       	sbci	r25, 0x01	; 1
    7aa0:	08 f4       	brcc	.+2      	; 0x7aa4 <procMessage99+0x1e>
    7aa2:	26 c2       	rjmp	.+1100   	; 0x7ef0 <procMessage99+0x46a>
    7aa4:	20 e0       	ldi	r18, 0x00	; 0
    7aa6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7aa8:	f9 01       	movw	r30, r18
    7aaa:	ee 56       	subi	r30, 0x6E	; 110
    7aac:	f1 4f       	sbci	r31, 0xF1	; 241
    7aae:	d9 01       	movw	r26, r18
    7ab0:	ab 5d       	subi	r26, 0xDB	; 219
    7ab2:	b4 4f       	sbci	r27, 0xF4	; 244
    7ab4:	95 96       	adiw	r26, 0x25	; 37
    7ab6:	8c 91       	ld	r24, X
    7ab8:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7aba:	2f 5f       	subi	r18, 0xFF	; 255
    7abc:	3f 4f       	sbci	r19, 0xFF	; 255
    7abe:	26 30       	cpi	r18, 0x06	; 6
    7ac0:	31 05       	cpc	r19, r1
    7ac2:	91 f7       	brne	.-28     	; 0x7aa8 <procMessage99+0x22>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7ac4:	10 92 98 0e 	sts	0x0E98, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7ac8:	80 91 50 0b 	lds	r24, 0x0B50
    7acc:	80 93 73 0e 	sts	0x0E73, r24
	 }Dest[Length]=0;
    7ad0:	10 92 74 0e 	sts	0x0E74, r1
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
       StrPosCopy(rcv_trans,strTranNo,37,6);//Transaction Number
       StrPosCopy(rcv_trans,strShift,43,1);
       Shift=(CharPosCopy(rcv_trans,43)-'0');
    7ad4:	80 53       	subi	r24, 0x30	; 48
    7ad6:	80 93 e5 01 	sts	0x01E5, r24
    7ada:	20 e0       	ldi	r18, 0x00	; 0
    7adc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7ade:	f9 01       	movw	r30, r18
    7ae0:	e3 58       	subi	r30, 0x83	; 131
    7ae2:	f6 4f       	sbci	r31, 0xF6	; 246
    7ae4:	d9 01       	movw	r26, r18
    7ae6:	ab 5d       	subi	r26, 0xDB	; 219
    7ae8:	b4 4f       	sbci	r27, 0xF4	; 244
    7aea:	9c 96       	adiw	r26, 0x2c	; 44
    7aec:	8c 91       	ld	r24, X
    7aee:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7af0:	2f 5f       	subi	r18, 0xFF	; 255
    7af2:	3f 4f       	sbci	r19, 0xFF	; 255
    7af4:	2a 30       	cpi	r18, 0x0A	; 10
    7af6:	31 05       	cpc	r19, r1
    7af8:	91 f7       	brne	.-28     	; 0x7ade <procMessage99+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7afa:	10 92 87 09 	sts	0x0987, r1
    7afe:	20 e0       	ldi	r18, 0x00	; 0
    7b00:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7b02:	f9 01       	movw	r30, r18
    7b04:	ed 5a       	subi	r30, 0xAD	; 173
    7b06:	fa 4f       	sbci	r31, 0xFA	; 250
    7b08:	d9 01       	movw	r26, r18
    7b0a:	ab 5d       	subi	r26, 0xDB	; 219
    7b0c:	b4 4f       	sbci	r27, 0xF4	; 244
    7b0e:	d6 96       	adiw	r26, 0x36	; 54
    7b10:	8c 91       	ld	r24, X
    7b12:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7b14:	2f 5f       	subi	r18, 0xFF	; 255
    7b16:	3f 4f       	sbci	r19, 0xFF	; 255
    7b18:	28 30       	cpi	r18, 0x08	; 8
    7b1a:	31 05       	cpc	r19, r1
    7b1c:	91 f7       	brne	.-28     	; 0x7b02 <procMessage99+0x7c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7b1e:	10 92 5b 05 	sts	0x055B, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7b22:	80 91 63 0b 	lds	r24, 0x0B63
    7b26:	80 93 ff 0a 	sts	0x0AFF, r24
    7b2a:	80 91 64 0b 	lds	r24, 0x0B64
    7b2e:	80 93 00 0b 	sts	0x0B00, r24
	 }Dest[Length]=0;
    7b32:	10 92 01 0b 	sts	0x0B01, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7b36:	80 91 65 0b 	lds	r24, 0x0B65
    7b3a:	80 93 c8 09 	sts	0x09C8, r24
    7b3e:	80 91 66 0b 	lds	r24, 0x0B66
    7b42:	80 93 c9 09 	sts	0x09C9, r24
	 }Dest[Length]=0;
    7b46:	10 92 ca 09 	sts	0x09CA, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7b4a:	80 91 67 0b 	lds	r24, 0x0B67
    7b4e:	80 93 a6 0a 	sts	0x0AA6, r24
    7b52:	80 91 68 0b 	lds	r24, 0x0B68
    7b56:	80 93 a7 0a 	sts	0x0AA7, r24
	 }Dest[Length]=0;
    7b5a:	10 92 a8 0a 	sts	0x0AA8, r1
    7b5e:	20 e0       	ldi	r18, 0x00	; 0
    7b60:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7b62:	f9 01       	movw	r30, r18
    7b64:	e3 5c       	subi	r30, 0xC3	; 195
    7b66:	f5 4f       	sbci	r31, 0xF5	; 245
    7b68:	d9 01       	movw	r26, r18
    7b6a:	a7 59       	subi	r26, 0x97	; 151
    7b6c:	b4 4f       	sbci	r27, 0xF4	; 244
    7b6e:	8c 91       	ld	r24, X
    7b70:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7b72:	2f 5f       	subi	r18, 0xFF	; 255
    7b74:	3f 4f       	sbci	r19, 0xFF	; 255
    7b76:	2f 30       	cpi	r18, 0x0F	; 15
    7b78:	31 05       	cpc	r19, r1
    7b7a:	99 f7       	brne	.-26     	; 0x7b62 <procMessage99+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7b7c:	10 92 4c 0a 	sts	0x0A4C, r1
    7b80:	20 e0       	ldi	r18, 0x00	; 0
    7b82:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7b84:	f9 01       	movw	r30, r18
    7b86:	e3 55       	subi	r30, 0x53	; 83
    7b88:	f8 4f       	sbci	r31, 0xF8	; 248
    7b8a:	d9 01       	movw	r26, r18
    7b8c:	a8 58       	subi	r26, 0x88	; 136
    7b8e:	b4 4f       	sbci	r27, 0xF4	; 244
    7b90:	8c 91       	ld	r24, X
    7b92:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7b94:	2f 5f       	subi	r18, 0xFF	; 255
    7b96:	3f 4f       	sbci	r19, 0xFF	; 255
    7b98:	28 30       	cpi	r18, 0x08	; 8
    7b9a:	31 05       	cpc	r19, r1
    7b9c:	99 f7       	brne	.-26     	; 0x7b84 <procMessage99+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7b9e:	10 92 b5 07 	sts	0x07B5, r1
    7ba2:	20 e0       	ldi	r18, 0x00	; 0
    7ba4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7ba6:	f9 01       	movw	r30, r18
    7ba8:	e5 58       	subi	r30, 0x85	; 133
    7baa:	fa 4f       	sbci	r31, 0xFA	; 250
    7bac:	d9 01       	movw	r26, r18
    7bae:	a0 58       	subi	r26, 0x80	; 128
    7bb0:	b4 4f       	sbci	r27, 0xF4	; 244
    7bb2:	8c 91       	ld	r24, X
    7bb4:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7bb6:	2f 5f       	subi	r18, 0xFF	; 255
    7bb8:	3f 4f       	sbci	r19, 0xFF	; 255
    7bba:	28 30       	cpi	r18, 0x08	; 8
    7bbc:	31 05       	cpc	r19, r1
    7bbe:	99 f7       	brne	.-26     	; 0x7ba6 <procMessage99+0x120>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7bc0:	10 92 83 05 	sts	0x0583, r1
    7bc4:	20 e0       	ldi	r18, 0x00	; 0
    7bc6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7bc8:	f9 01       	movw	r30, r18
    7bca:	e5 54       	subi	r30, 0x45	; 69
    7bcc:	f2 4f       	sbci	r31, 0xF2	; 242
    7bce:	d9 01       	movw	r26, r18
    7bd0:	a8 57       	subi	r26, 0x78	; 120
    7bd2:	b4 4f       	sbci	r27, 0xF4	; 244
    7bd4:	8c 91       	ld	r24, X
    7bd6:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7bd8:	2f 5f       	subi	r18, 0xFF	; 255
    7bda:	3f 4f       	sbci	r19, 0xFF	; 255
    7bdc:	2a 30       	cpi	r18, 0x0A	; 10
    7bde:	31 05       	cpc	r19, r1
    7be0:	99 f7       	brne	.-26     	; 0x7bc8 <procMessage99+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7be2:	10 92 c5 0d 	sts	0x0DC5, r1

	   //FillChar(strAmount,sizeof(strAmount),0);
       StrPosCopy(rcv_trans,strAmount,99,10);

       //StrPosCopy(rcv_trans,strMOPType,109,1);
       MOPType=(CharPosCopy(rcv_trans,109)-'0');
    7be6:	80 91 92 0b 	lds	r24, 0x0B92
    7bea:	80 53       	subi	r24, 0x30	; 48
    7bec:	80 93 e4 01 	sts	0x01E4, r24
    7bf0:	20 e0       	ldi	r18, 0x00	; 0
    7bf2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7bf4:	f9 01       	movw	r30, r18
    7bf6:	e4 57       	subi	r30, 0x74	; 116
    7bf8:	f8 4f       	sbci	r31, 0xF8	; 248
    7bfa:	d9 01       	movw	r26, r18
    7bfc:	ad 56       	subi	r26, 0x6D	; 109
    7bfe:	b4 4f       	sbci	r27, 0xF4	; 244
    7c00:	8c 91       	ld	r24, X
    7c02:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7c04:	2f 5f       	subi	r18, 0xFF	; 255
    7c06:	3f 4f       	sbci	r19, 0xFF	; 255
    7c08:	24 31       	cpi	r18, 0x14	; 20
    7c0a:	31 05       	cpc	r19, r1
    7c0c:	99 f7       	brne	.-26     	; 0x7bf4 <procMessage99+0x16e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7c0e:	10 92 a0 07 	sts	0x07A0, r1
    7c12:	20 e0       	ldi	r18, 0x00	; 0
    7c14:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7c16:	f9 01       	movw	r30, r18
    7c18:	ef 56       	subi	r30, 0x6F	; 111
    7c1a:	f2 4f       	sbci	r31, 0xF2	; 242
    7c1c:	d9 01       	movw	r26, r18
    7c1e:	a9 55       	subi	r26, 0x59	; 89
    7c20:	b4 4f       	sbci	r27, 0xF4	; 244
    7c22:	8c 91       	ld	r24, X
    7c24:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7c26:	2f 5f       	subi	r18, 0xFF	; 255
    7c28:	3f 4f       	sbci	r19, 0xFF	; 255
    7c2a:	24 31       	cpi	r18, 0x14	; 20
    7c2c:	31 05       	cpc	r19, r1
    7c2e:	99 f7       	brne	.-26     	; 0x7c16 <procMessage99+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7c30:	10 92 a5 0d 	sts	0x0DA5, r1
    7c34:	20 e0       	ldi	r18, 0x00	; 0
    7c36:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7c38:	f9 01       	movw	r30, r18
    7c3a:	e6 5d       	subi	r30, 0xD6	; 214
    7c3c:	fa 4f       	sbci	r31, 0xFA	; 250
    7c3e:	d9 01       	movw	r26, r18
    7c40:	a5 54       	subi	r26, 0x45	; 69
    7c42:	b4 4f       	sbci	r27, 0xF4	; 244
    7c44:	8c 91       	ld	r24, X
    7c46:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7c48:	2f 5f       	subi	r18, 0xFF	; 255
    7c4a:	3f 4f       	sbci	r19, 0xFF	; 255
    7c4c:	28 32       	cpi	r18, 0x28	; 40
    7c4e:	31 05       	cpc	r19, r1
    7c50:	99 f7       	brne	.-26     	; 0x7c38 <procMessage99+0x1b2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7c52:	10 92 52 05 	sts	0x0552, r1
    7c56:	20 e0       	ldi	r18, 0x00	; 0
    7c58:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7c5a:	f9 01       	movw	r30, r18
    7c5c:	ef 59       	subi	r30, 0x9F	; 159
    7c5e:	fa 4f       	sbci	r31, 0xFA	; 250
    7c60:	d9 01       	movw	r26, r18
    7c62:	ad 51       	subi	r26, 0x1D	; 29
    7c64:	b4 4f       	sbci	r27, 0xF4	; 244
    7c66:	8c 91       	ld	r24, X
    7c68:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7c6a:	2f 5f       	subi	r18, 0xFF	; 255
    7c6c:	3f 4f       	sbci	r19, 0xFF	; 255
    7c6e:	29 31       	cpi	r18, 0x19	; 25
    7c70:	31 05       	cpc	r19, r1
    7c72:	99 f7       	brne	.-26     	; 0x7c5a <procMessage99+0x1d4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7c74:	10 92 7a 05 	sts	0x057A, r1
    7c78:	20 e0       	ldi	r18, 0x00	; 0
    7c7a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7c7c:	f9 01       	movw	r30, r18
    7c7e:	ed 5f       	subi	r30, 0xFD	; 253
    7c80:	f1 4f       	sbci	r31, 0xF1	; 241
    7c82:	d9 01       	movw	r26, r18
    7c84:	a4 50       	subi	r26, 0x04	; 4
    7c86:	b4 4f       	sbci	r27, 0xF4	; 244
    7c88:	8c 91       	ld	r24, X
    7c8a:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7c8c:	2f 5f       	subi	r18, 0xFF	; 255
    7c8e:	3f 4f       	sbci	r19, 0xFF	; 255
    7c90:	2d 30       	cpi	r18, 0x0D	; 13
    7c92:	31 05       	cpc	r19, r1
    7c94:	99 f7       	brne	.-26     	; 0x7c7c <procMessage99+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7c96:	10 92 10 0e 	sts	0x0E10, r1
    7c9a:	20 e0       	ldi	r18, 0x00	; 0
    7c9c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7c9e:	f9 01       	movw	r30, r18
    7ca0:	ee 56       	subi	r30, 0x6E	; 110
    7ca2:	fa 4f       	sbci	r31, 0xFA	; 250
    7ca4:	d9 01       	movw	r26, r18
    7ca6:	a7 5f       	subi	r26, 0xF7	; 247
    7ca8:	b3 4f       	sbci	r27, 0xF3	; 243
    7caa:	8c 91       	ld	r24, X
    7cac:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7cae:	2f 5f       	subi	r18, 0xFF	; 255
    7cb0:	3f 4f       	sbci	r19, 0xFF	; 255
    7cb2:	2d 30       	cpi	r18, 0x0D	; 13
    7cb4:	31 05       	cpc	r19, r1
    7cb6:	99 f7       	brne	.-26     	; 0x7c9e <procMessage99+0x218>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7cb8:	10 92 9f 05 	sts	0x059F, r1
    7cbc:	20 e0       	ldi	r18, 0x00	; 0
    7cbe:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7cc0:	f9 01       	movw	r30, r18
    7cc2:	ef 50       	subi	r30, 0x0F	; 15
    7cc4:	f5 4f       	sbci	r31, 0xF5	; 245
    7cc6:	d9 01       	movw	r26, r18
    7cc8:	aa 5e       	subi	r26, 0xEA	; 234
    7cca:	b3 4f       	sbci	r27, 0xF3	; 243
    7ccc:	8c 91       	ld	r24, X
    7cce:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7cd0:	2f 5f       	subi	r18, 0xFF	; 255
    7cd2:	3f 4f       	sbci	r19, 0xFF	; 255
    7cd4:	2d 30       	cpi	r18, 0x0D	; 13
    7cd6:	31 05       	cpc	r19, r1
    7cd8:	99 f7       	brne	.-26     	; 0x7cc0 <procMessage99+0x23a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7cda:	10 92 fe 0a 	sts	0x0AFE, r1
    7cde:	20 e0       	ldi	r18, 0x00	; 0
    7ce0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7ce2:	f9 01       	movw	r30, r18
    7ce4:	e5 53       	subi	r30, 0x35	; 53
    7ce6:	f6 4f       	sbci	r31, 0xF6	; 246
    7ce8:	d9 01       	movw	r26, r18
    7cea:	ad 5d       	subi	r26, 0xDD	; 221
    7cec:	b3 4f       	sbci	r27, 0xF3	; 243
    7cee:	8c 91       	ld	r24, X
    7cf0:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7cf2:	2f 5f       	subi	r18, 0xFF	; 255
    7cf4:	3f 4f       	sbci	r19, 0xFF	; 255
    7cf6:	23 31       	cpi	r18, 0x13	; 19
    7cf8:	31 05       	cpc	r19, r1
    7cfa:	99 f7       	brne	.-26     	; 0x7ce2 <procMessage99+0x25c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7cfc:	10 92 de 09 	sts	0x09DE, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d00:	80 91 36 0c 	lds	r24, 0x0C36
    7d04:	80 93 8e 0e 	sts	0x0E8E, r24
    7d08:	80 91 37 0c 	lds	r24, 0x0C37
    7d0c:	80 93 8f 0e 	sts	0x0E8F, r24
	 }Dest[Length]=0;
    7d10:	10 92 90 0e 	sts	0x0E90, r1
    7d14:	20 e0       	ldi	r18, 0x00	; 0
    7d16:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d18:	f9 01       	movw	r30, r18
    7d1a:	e4 5e       	subi	r30, 0xE4	; 228
    7d1c:	f4 4f       	sbci	r31, 0xF4	; 244
    7d1e:	d9 01       	movw	r26, r18
    7d20:	a8 5c       	subi	r26, 0xC8	; 200
    7d22:	b3 4f       	sbci	r27, 0xF3	; 243
    7d24:	8c 91       	ld	r24, X
    7d26:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7d28:	2f 5f       	subi	r18, 0xFF	; 255
    7d2a:	3f 4f       	sbci	r19, 0xFF	; 255
    7d2c:	28 30       	cpi	r18, 0x08	; 8
    7d2e:	31 05       	cpc	r19, r1
    7d30:	99 f7       	brne	.-26     	; 0x7d18 <procMessage99+0x292>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7d32:	10 92 24 0b 	sts	0x0B24, r1
    7d36:	20 e0       	ldi	r18, 0x00	; 0
    7d38:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d3a:	f9 01       	movw	r30, r18
    7d3c:	ef 53       	subi	r30, 0x3F	; 63
    7d3e:	fb 4f       	sbci	r31, 0xFB	; 251
    7d40:	d9 01       	movw	r26, r18
    7d42:	a0 5c       	subi	r26, 0xC0	; 192
    7d44:	b3 4f       	sbci	r27, 0xF3	; 243
    7d46:	8c 91       	ld	r24, X
    7d48:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7d4a:	2f 5f       	subi	r18, 0xFF	; 255
    7d4c:	3f 4f       	sbci	r19, 0xFF	; 255
    7d4e:	28 30       	cpi	r18, 0x08	; 8
    7d50:	31 05       	cpc	r19, r1
    7d52:	99 f7       	brne	.-26     	; 0x7d3a <procMessage99+0x2b4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7d54:	10 92 c9 04 	sts	0x04C9, r1
    7d58:	20 e0       	ldi	r18, 0x00	; 0
    7d5a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d5c:	f9 01       	movw	r30, r18
    7d5e:	e3 51       	subi	r30, 0x13	; 19
    7d60:	fb 4f       	sbci	r31, 0xFB	; 251
    7d62:	d9 01       	movw	r26, r18
    7d64:	a8 5b       	subi	r26, 0xB8	; 184
    7d66:	b3 4f       	sbci	r27, 0xF3	; 243
    7d68:	8c 91       	ld	r24, X
    7d6a:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7d6c:	2f 5f       	subi	r18, 0xFF	; 255
    7d6e:	3f 4f       	sbci	r19, 0xFF	; 255
    7d70:	24 31       	cpi	r18, 0x14	; 20
    7d72:	31 05       	cpc	r19, r1
    7d74:	99 f7       	brne	.-26     	; 0x7d5c <procMessage99+0x2d6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7d76:	10 92 01 05 	sts	0x0501, r1
    7d7a:	20 e0       	ldi	r18, 0x00	; 0
    7d7c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7d7e:	f9 01       	movw	r30, r18
    7d80:	e6 53       	subi	r30, 0x36	; 54
    7d82:	fb 4f       	sbci	r31, 0xFB	; 251
    7d84:	d9 01       	movw	r26, r18
    7d86:	a4 5a       	subi	r26, 0xA4	; 164
    7d88:	b3 4f       	sbci	r27, 0xF3	; 243
    7d8a:	8c 91       	ld	r24, X
    7d8c:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7d8e:	2f 5f       	subi	r18, 0xFF	; 255
    7d90:	3f 4f       	sbci	r19, 0xFF	; 255
    7d92:	2e 31       	cpi	r18, 0x1E	; 30
    7d94:	31 05       	cpc	r19, r1
    7d96:	99 f7       	brne	.-26     	; 0x7d7e <procMessage99+0x2f8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7d98:	10 92 e8 04 	sts	0x04E8, r1
    7d9c:	20 e0       	ldi	r18, 0x00	; 0
    7d9e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7da0:	f9 01       	movw	r30, r18
    7da2:	ea 59       	subi	r30, 0x9A	; 154
    7da4:	f5 4f       	sbci	r31, 0xF5	; 245
    7da6:	d9 01       	movw	r26, r18
    7da8:	a6 58       	subi	r26, 0x86	; 134
    7daa:	b3 4f       	sbci	r27, 0xF3	; 243
    7dac:	8c 91       	ld	r24, X
    7dae:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7db0:	2f 5f       	subi	r18, 0xFF	; 255
    7db2:	3f 4f       	sbci	r19, 0xFF	; 255
    7db4:	28 30       	cpi	r18, 0x08	; 8
    7db6:	31 05       	cpc	r19, r1
    7db8:	99 f7       	brne	.-26     	; 0x7da0 <procMessage99+0x31a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7dba:	10 92 6e 0a 	sts	0x0A6E, r1
    7dbe:	20 e0       	ldi	r18, 0x00	; 0
    7dc0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7dc2:	f9 01       	movw	r30, r18
    7dc4:	ec 57       	subi	r30, 0x7C	; 124
    7dc6:	fa 4f       	sbci	r31, 0xFA	; 250
    7dc8:	d9 01       	movw	r26, r18
    7dca:	ae 57       	subi	r26, 0x7E	; 126
    7dcc:	b3 4f       	sbci	r27, 0xF3	; 243
    7dce:	8c 91       	ld	r24, X
    7dd0:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7dd2:	2f 5f       	subi	r18, 0xFF	; 255
    7dd4:	3f 4f       	sbci	r19, 0xFF	; 255
    7dd6:	2a 30       	cpi	r18, 0x0A	; 10
    7dd8:	31 05       	cpc	r19, r1
    7dda:	99 f7       	brne	.-26     	; 0x7dc2 <procMessage99+0x33c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7ddc:	10 92 8e 05 	sts	0x058E, r1
    7de0:	20 e0       	ldi	r18, 0x00	; 0
    7de2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7de4:	f9 01       	movw	r30, r18
    7de6:	e8 50       	subi	r30, 0x08	; 8
    7de8:	f2 4f       	sbci	r31, 0xF2	; 242
    7dea:	d9 01       	movw	r26, r18
    7dec:	a4 57       	subi	r26, 0x74	; 116
    7dee:	b3 4f       	sbci	r27, 0xF3	; 243
    7df0:	8c 91       	ld	r24, X
    7df2:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7df4:	2f 5f       	subi	r18, 0xFF	; 255
    7df6:	3f 4f       	sbci	r19, 0xFF	; 255
    7df8:	2a 30       	cpi	r18, 0x0A	; 10
    7dfa:	31 05       	cpc	r19, r1
    7dfc:	99 f7       	brne	.-26     	; 0x7de4 <procMessage99+0x35e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7dfe:	10 92 02 0e 	sts	0x0E02, r1
    7e02:	20 e0       	ldi	r18, 0x00	; 0
    7e04:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e06:	f9 01       	movw	r30, r18
    7e08:	e5 50       	subi	r30, 0x05	; 5
    7e0a:	f6 4f       	sbci	r31, 0xF6	; 246
    7e0c:	d9 01       	movw	r26, r18
    7e0e:	aa 56       	subi	r26, 0x6A	; 106
    7e10:	b3 4f       	sbci	r27, 0xF3	; 243
    7e12:	8c 91       	ld	r24, X
    7e14:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e16:	2f 5f       	subi	r18, 0xFF	; 255
    7e18:	3f 4f       	sbci	r19, 0xFF	; 255
    7e1a:	24 31       	cpi	r18, 0x14	; 20
    7e1c:	31 05       	cpc	r19, r1
    7e1e:	99 f7       	brne	.-26     	; 0x7e06 <procMessage99+0x380>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e20:	10 92 0f 0a 	sts	0x0A0F, r1
    7e24:	20 e0       	ldi	r18, 0x00	; 0
    7e26:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e28:	f9 01       	movw	r30, r18
    7e2a:	e9 57       	subi	r30, 0x79	; 121
    7e2c:	f5 4f       	sbci	r31, 0xF5	; 245
    7e2e:	d9 01       	movw	r26, r18
    7e30:	a6 55       	subi	r26, 0x56	; 86
    7e32:	b3 4f       	sbci	r27, 0xF3	; 243
    7e34:	8c 91       	ld	r24, X
    7e36:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e38:	2f 5f       	subi	r18, 0xFF	; 255
    7e3a:	3f 4f       	sbci	r19, 0xFF	; 255
    7e3c:	2a 30       	cpi	r18, 0x0A	; 10
    7e3e:	31 05       	cpc	r19, r1
    7e40:	99 f7       	brne	.-26     	; 0x7e28 <procMessage99+0x3a2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e42:	10 92 91 0a 	sts	0x0A91, r1
    7e46:	20 e0       	ldi	r18, 0x00	; 0
    7e48:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e4a:	f9 01       	movw	r30, r18
    7e4c:	e0 56       	subi	r30, 0x60	; 96
    7e4e:	fa 4f       	sbci	r31, 0xFA	; 250
    7e50:	d9 01       	movw	r26, r18
    7e52:	ac 54       	subi	r26, 0x4C	; 76
    7e54:	b3 4f       	sbci	r27, 0xF3	; 243
    7e56:	8c 91       	ld	r24, X
    7e58:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e5a:	2f 5f       	subi	r18, 0xFF	; 255
    7e5c:	3f 4f       	sbci	r19, 0xFF	; 255
    7e5e:	28 30       	cpi	r18, 0x08	; 8
    7e60:	31 05       	cpc	r19, r1
    7e62:	99 f7       	brne	.-26     	; 0x7e4a <procMessage99+0x3c4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e64:	10 92 a8 05 	sts	0x05A8, r1
    7e68:	20 e0       	ldi	r18, 0x00	; 0
    7e6a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e6c:	f9 01       	movw	r30, r18
    7e6e:	ed 57       	subi	r30, 0x7D	; 125
    7e70:	f1 4f       	sbci	r31, 0xF1	; 241
    7e72:	d9 01       	movw	r26, r18
    7e74:	a4 54       	subi	r26, 0x44	; 68
    7e76:	b3 4f       	sbci	r27, 0xF3	; 243
    7e78:	8c 91       	ld	r24, X
    7e7a:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e7c:	2f 5f       	subi	r18, 0xFF	; 255
    7e7e:	3f 4f       	sbci	r19, 0xFF	; 255
    7e80:	2a 30       	cpi	r18, 0x0A	; 10
    7e82:	31 05       	cpc	r19, r1
    7e84:	99 f7       	brne	.-26     	; 0x7e6c <procMessage99+0x3e6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e86:	10 92 8d 0e 	sts	0x0E8D, r1
    7e8a:	20 e0       	ldi	r18, 0x00	; 0
    7e8c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e8e:	f9 01       	movw	r30, r18
    7e90:	eb 5e       	subi	r30, 0xEB	; 235
    7e92:	f1 4f       	sbci	r31, 0xF1	; 241
    7e94:	d9 01       	movw	r26, r18
    7e96:	aa 53       	subi	r26, 0x3A	; 58
    7e98:	b3 4f       	sbci	r27, 0xF3	; 243
    7e9a:	8c 91       	ld	r24, X
    7e9c:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e9e:	2f 5f       	subi	r18, 0xFF	; 255
    7ea0:	3f 4f       	sbci	r19, 0xFF	; 255
    7ea2:	24 31       	cpi	r18, 0x14	; 20
    7ea4:	31 05       	cpc	r19, r1
    7ea6:	99 f7       	brne	.-26     	; 0x7e8e <procMessage99+0x408>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7ea8:	10 92 29 0e 	sts	0x0E29, r1
    7eac:	20 e0       	ldi	r18, 0x00	; 0
    7eae:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7eb0:	f9 01       	movw	r30, r18
    7eb2:	ed 52       	subi	r30, 0x2D	; 45
    7eb4:	fa 4f       	sbci	r31, 0xFA	; 250
    7eb6:	d9 01       	movw	r26, r18
    7eb8:	a6 52       	subi	r26, 0x26	; 38
    7eba:	b3 4f       	sbci	r27, 0xF3	; 243
    7ebc:	8c 91       	ld	r24, X
    7ebe:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7ec0:	2f 5f       	subi	r18, 0xFF	; 255
    7ec2:	3f 4f       	sbci	r19, 0xFF	; 255
    7ec4:	2e 31       	cpi	r18, 0x1E	; 30
    7ec6:	31 05       	cpc	r19, r1
    7ec8:	99 f7       	brne	.-26     	; 0x7eb0 <procMessage99+0x42a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7eca:	10 92 f1 05 	sts	0x05F1, r1
       StrPosCopy(rcv_trans,strLoyExpiry,407,10);
       StrPosCopy(rcv_trans,strCorporateID,417,20);
       StrPosCopy(rcv_trans,strCorporateName,437,30);

	   //FIP Detection LocalAccount Null Filling
	   if ((nLocalAccount>0)&&(LocalAccountFIP[0]==atoi(strFIP_ID))){
    7ece:	80 91 b9 01 	lds	r24, 0x01B9
    7ed2:	88 23       	and	r24, r24
    7ed4:	69 f0       	breq	.+26     	; 0x7ef0 <procMessage99+0x46a>
    7ed6:	00 91 5c 05 	lds	r16, 0x055C
    7eda:	10 e0       	ldi	r17, 0x00	; 0
    7edc:	88 ec       	ldi	r24, 0xC8	; 200
    7ede:	99 e0       	ldi	r25, 0x09	; 9
    7ee0:	0e 94 6e b4 	call	0x168dc	; 0x168dc <atoi>
    7ee4:	08 17       	cp	r16, r24
    7ee6:	19 07       	cpc	r17, r25
    7ee8:	19 f4       	brne	.+6      	; 0x7ef0 <procMessage99+0x46a>
	        IsCompleteFilling=True;
    7eea:	81 e0       	ldi	r24, 0x01	; 1
    7eec:	80 93 d6 01 	sts	0x01D6, r24
	   }

	  }
     return Result;     
}
    7ef0:	80 e0       	ldi	r24, 0x00	; 0
    7ef2:	1f 91       	pop	r17
    7ef4:	0f 91       	pop	r16
    7ef6:	08 95       	ret

00007ef8 <GetMessageID>:
		  }
       IsStandaloneAcknoledge=True;
	  }
}

char GetMessageID(char *strMessageFlow){
    7ef8:	0f 93       	push	r16
    7efa:	1f 93       	push	r17
    7efc:	df 93       	push	r29
    7efe:	cf 93       	push	r28
    7f00:	00 d0       	rcall	.+0      	; 0x7f02 <GetMessageID+0xa>
    7f02:	0f 92       	push	r0
    7f04:	cd b7       	in	r28, 0x3d	; 61
    7f06:	de b7       	in	r29, 0x3e	; 62
    7f08:	fc 01       	movw	r30, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f0a:	80 81       	ld	r24, Z
    7f0c:	89 83       	std	Y+1, r24	; 0x01
    7f0e:	81 81       	ldd	r24, Z+1	; 0x01
    7f10:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    7f12:	1b 82       	std	Y+3, r1	; 0x03
}

char GetMessageID(char *strMessageFlow){
     char Result,strMsgID[3];
	 StrPosCopy(strMessageFlow,strMsgID,0,2);
	 RemZeroLead(strMsgID);
    7f14:	8e 01       	movw	r16, r28
    7f16:	0f 5f       	subi	r16, 0xFF	; 255
    7f18:	1f 4f       	sbci	r17, 0xFF	; 255
    7f1a:	c8 01       	movw	r24, r16
    7f1c:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
	 Result=atoi(strMsgID);
    7f20:	c8 01       	movw	r24, r16
    7f22:	0e 94 6e b4 	call	0x168dc	; 0x168dc <atoi>
  return Result;
}
    7f26:	0f 90       	pop	r0
    7f28:	0f 90       	pop	r0
    7f2a:	0f 90       	pop	r0
    7f2c:	cf 91       	pop	r28
    7f2e:	df 91       	pop	r29
    7f30:	1f 91       	pop	r17
    7f32:	0f 91       	pop	r16
    7f34:	08 95       	ret

00007f36 <FTestChar>:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
	     break;
	}
}

char FTestChar(){
    7f36:	0f 93       	push	r16
    7f38:	1f 93       	push	r17
    7f3a:	df 93       	push	r29
    7f3c:	cf 93       	push	r28
    7f3e:	cd b7       	in	r28, 0x3d	; 61
    7f40:	de b7       	in	r29, 0x3e	; 62
    7f42:	64 97       	sbiw	r28, 0x14	; 20
    7f44:	0f b6       	in	r0, 0x3f	; 63
    7f46:	f8 94       	cli
    7f48:	de bf       	out	0x3e, r29	; 62
    7f4a:	0f be       	out	0x3f, r0	; 63
    7f4c:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],Result;
static char i=0;
     Result=MENU_NONE;
     sprintf_P(lcdteks,PSTR("D:%d C:%c  "),i,i);
    7f4e:	20 91 8b 03 	lds	r18, 0x038B
    7f52:	8d b7       	in	r24, 0x3d	; 61
    7f54:	9e b7       	in	r25, 0x3e	; 62
    7f56:	08 97       	sbiw	r24, 0x08	; 8
    7f58:	0f b6       	in	r0, 0x3f	; 63
    7f5a:	f8 94       	cli
    7f5c:	9e bf       	out	0x3e, r25	; 62
    7f5e:	0f be       	out	0x3f, r0	; 63
    7f60:	8d bf       	out	0x3d, r24	; 61
    7f62:	ed b7       	in	r30, 0x3d	; 61
    7f64:	fe b7       	in	r31, 0x3e	; 62
    7f66:	31 96       	adiw	r30, 0x01	; 1
    7f68:	8e 01       	movw	r16, r28
    7f6a:	0f 5f       	subi	r16, 0xFF	; 255
    7f6c:	1f 4f       	sbci	r17, 0xFF	; 255
    7f6e:	ad b7       	in	r26, 0x3d	; 61
    7f70:	be b7       	in	r27, 0x3e	; 62
    7f72:	12 96       	adiw	r26, 0x02	; 2
    7f74:	1c 93       	st	X, r17
    7f76:	0e 93       	st	-X, r16
    7f78:	11 97       	sbiw	r26, 0x01	; 1
    7f7a:	8e e7       	ldi	r24, 0x7E	; 126
    7f7c:	9b e1       	ldi	r25, 0x1B	; 27
    7f7e:	93 83       	std	Z+3, r25	; 0x03
    7f80:	82 83       	std	Z+2, r24	; 0x02
    7f82:	24 83       	std	Z+4, r18	; 0x04
    7f84:	15 82       	std	Z+5, r1	; 0x05
    7f86:	26 83       	std	Z+6, r18	; 0x06
    7f88:	17 82       	std	Z+7, r1	; 0x07
    7f8a:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
     lcd_print(1,1,lcdteks);
    7f8e:	8d b7       	in	r24, 0x3d	; 61
    7f90:	9e b7       	in	r25, 0x3e	; 62
    7f92:	08 96       	adiw	r24, 0x08	; 8
    7f94:	0f b6       	in	r0, 0x3f	; 63
    7f96:	f8 94       	cli
    7f98:	9e bf       	out	0x3e, r25	; 62
    7f9a:	0f be       	out	0x3f, r0	; 63
    7f9c:	8d bf       	out	0x3d, r24	; 61
    7f9e:	81 e0       	ldi	r24, 0x01	; 1
    7fa0:	61 e0       	ldi	r22, 0x01	; 1
    7fa2:	a8 01       	movw	r20, r16
    7fa4:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	 if (i==0xFF)Result=MENU_DONE;
    7fa8:	20 91 8b 03 	lds	r18, 0x038B
	 i++;
    7fac:	2f 5f       	subi	r18, 0xFF	; 255
    7fae:	20 93 8b 03 	sts	0x038B, r18
    7fb2:	21 50       	subi	r18, 0x01	; 1
    7fb4:	88 ee       	ldi	r24, 0xE8	; 232
    7fb6:	9d ef       	ldi	r25, 0xFD	; 253
    7fb8:	49 e1       	ldi	r20, 0x19	; 25
    7fba:	50 e0       	ldi	r21, 0x00	; 0
    7fbc:	fa 01       	movw	r30, r20
    7fbe:	31 97       	sbiw	r30, 0x01	; 1
    7fc0:	f1 f7       	brne	.-4      	; 0x7fbe <FTestChar+0x88>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7fc2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7fc4:	d9 f7       	brne	.-10     	; 0x7fbc <FTestChar+0x86>
    7fc6:	80 e0       	ldi	r24, 0x00	; 0
    7fc8:	2f 3f       	cpi	r18, 0xFF	; 255
    7fca:	09 f4       	brne	.+2      	; 0x7fce <FTestChar+0x98>
    7fcc:	81 e0       	ldi	r24, 0x01	; 1
     _delay_ms(6500);
  return Result;
}
    7fce:	64 96       	adiw	r28, 0x14	; 20
    7fd0:	0f b6       	in	r0, 0x3f	; 63
    7fd2:	f8 94       	cli
    7fd4:	de bf       	out	0x3e, r29	; 62
    7fd6:	0f be       	out	0x3f, r0	; 63
    7fd8:	cd bf       	out	0x3d, r28	; 61
    7fda:	cf 91       	pop	r28
    7fdc:	df 91       	pop	r29
    7fde:	1f 91       	pop	r17
    7fe0:	0f 91       	pop	r16
    7fe2:	08 95       	ret

00007fe4 <DisplayPumpStatus>:
		  break;         	 
	 }
  return Result;	 
}

void DisplayPumpStatus(){
    7fe4:	0f 93       	push	r16
    7fe6:	1f 93       	push	r17
    7fe8:	df 93       	push	r29
    7fea:	cf 93       	push	r28
    7fec:	cd b7       	in	r28, 0x3d	; 61
    7fee:	de b7       	in	r29, 0x3e	; 62
    7ff0:	a8 97       	sbiw	r28, 0x28	; 40
    7ff2:	0f b6       	in	r0, 0x3f	; 63
    7ff4:	f8 94       	cli
    7ff6:	de bf       	out	0x3e, r29	; 62
    7ff8:	0f be       	out	0x3f, r0	; 63
    7ffa:	cd bf       	out	0x3d, r28	; 61
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
    7ffc:	80 91 26 01 	lds	r24, 0x0126
    8000:	81 30       	cpi	r24, 0x01	; 1
    8002:	09 f0       	breq	.+2      	; 0x8006 <DisplayPumpStatus+0x22>
    8004:	4a c0       	rjmp	.+148    	; 0x809a <DisplayPumpStatus+0xb6>
	     IsNewPumpStatus=False;
    8006:	10 92 26 01 	sts	0x0126, r1
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    800a:	80 93 e2 03 	sts	0x03E2, r24
    800e:	10 92 e3 03 	sts	0x03E3, r1
    8012:	80 91 65 00 	lds	r24, 0x0065
    8016:	8d 7f       	andi	r24, 0xFD	; 253
    8018:	80 93 65 00 	sts	0x0065, r24
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
    801c:	80 91 75 01 	lds	r24, 0x0175
    8020:	48 2f       	mov	r20, r24
    8022:	50 e0       	ldi	r21, 0x00	; 0
    8024:	20 e0       	ldi	r18, 0x00	; 0
    8026:	30 e0       	ldi	r19, 0x00	; 0
    8028:	be 01       	movw	r22, r28
    802a:	6f 5f       	subi	r22, 0xFF	; 255
    802c:	7f 4f       	sbci	r23, 0xFF	; 255
    802e:	0a c0       	rjmp	.+20     	; 0x8044 <DisplayPumpStatus+0x60>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8030:	fb 01       	movw	r30, r22
    8032:	e2 0f       	add	r30, r18
    8034:	f3 1f       	adc	r31, r19
    8036:	d9 01       	movw	r26, r18
    8038:	a9 5d       	subi	r26, 0xD9	; 217
    803a:	be 4f       	sbci	r27, 0xFE	; 254
    803c:	8c 91       	ld	r24, X
    803e:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8040:	2f 5f       	subi	r18, 0xFF	; 255
    8042:	3f 4f       	sbci	r19, 0xFF	; 255
    8044:	24 17       	cp	r18, r20
    8046:	35 07       	cpc	r19, r21
    8048:	98 f3       	brcs	.-26     	; 0x8030 <DisplayPumpStatus+0x4c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    804a:	46 0f       	add	r20, r22
    804c:	57 1f       	adc	r21, r23
    804e:	da 01       	movw	r26, r20
    8050:	1c 92       	st	X, r1

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
    8052:	00 d0       	rcall	.+0      	; 0x8054 <DisplayPumpStatus+0x70>
    8054:	00 d0       	rcall	.+0      	; 0x8056 <DisplayPumpStatus+0x72>
    8056:	00 d0       	rcall	.+0      	; 0x8058 <DisplayPumpStatus+0x74>
    8058:	ed b7       	in	r30, 0x3d	; 61
    805a:	fe b7       	in	r31, 0x3e	; 62
    805c:	31 96       	adiw	r30, 0x01	; 1
    805e:	8e 01       	movw	r16, r28
    8060:	0b 5e       	subi	r16, 0xEB	; 235
    8062:	1f 4f       	sbci	r17, 0xFF	; 255
    8064:	ad b7       	in	r26, 0x3d	; 61
    8066:	be b7       	in	r27, 0x3e	; 62
    8068:	12 96       	adiw	r26, 0x02	; 2
    806a:	1c 93       	st	X, r17
    806c:	0e 93       	st	-X, r16
    806e:	11 97       	sbiw	r26, 0x01	; 1
    8070:	86 e1       	ldi	r24, 0x16	; 22
    8072:	92 e2       	ldi	r25, 0x22	; 34
    8074:	93 83       	std	Z+3, r25	; 0x03
    8076:	82 83       	std	Z+2, r24	; 0x02
    8078:	75 83       	std	Z+5, r23	; 0x05
    807a:	64 83       	std	Z+4, r22	; 0x04
    807c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
         lcd_print(4,1,lcdteks);
    8080:	ed b7       	in	r30, 0x3d	; 61
    8082:	fe b7       	in	r31, 0x3e	; 62
    8084:	36 96       	adiw	r30, 0x06	; 6
    8086:	0f b6       	in	r0, 0x3f	; 63
    8088:	f8 94       	cli
    808a:	fe bf       	out	0x3e, r31	; 62
    808c:	0f be       	out	0x3f, r0	; 63
    808e:	ed bf       	out	0x3d, r30	; 61
    8090:	84 e0       	ldi	r24, 0x04	; 4
    8092:	61 e0       	ldi	r22, 0x01	; 1
    8094:	a8 01       	movw	r20, r16
    8096:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
     	 }
}
    809a:	a8 96       	adiw	r28, 0x28	; 40
    809c:	0f b6       	in	r0, 0x3f	; 63
    809e:	f8 94       	cli
    80a0:	de bf       	out	0x3e, r29	; 62
    80a2:	0f be       	out	0x3f, r0	; 63
    80a4:	cd bf       	out	0x3d, r28	; 61
    80a6:	cf 91       	pop	r28
    80a8:	df 91       	pop	r29
    80aa:	1f 91       	pop	r17
    80ac:	0f 91       	pop	r16
    80ae:	08 95       	ret

000080b0 <FViewFreeMessage>:
char FViewFreeMessage(){
static char stFreeMessage=fmInit;
       char Result=MENU_NONE;
     
	 Result=MENU_NONE;
	 switch(stFreeMessage){
    80b0:	80 91 74 03 	lds	r24, 0x0374
    80b4:	81 30       	cpi	r24, 0x01	; 1
    80b6:	49 f0       	breq	.+18     	; 0x80ca <FViewFreeMessage+0x1a>
    80b8:	81 30       	cpi	r24, 0x01	; 1
    80ba:	28 f0       	brcs	.+10     	; 0x80c6 <FViewFreeMessage+0x16>
    80bc:	82 30       	cpi	r24, 0x02	; 2
    80be:	19 f1       	breq	.+70     	; 0x8106 <FViewFreeMessage+0x56>
    80c0:	83 30       	cpi	r24, 0x03	; 3
    80c2:	71 f5       	brne	.+92     	; 0x8120 <FViewFreeMessage+0x70>
    80c4:	29 c0       	rjmp	.+82     	; 0x8118 <FViewFreeMessage+0x68>
	 case fmInit:
	      stFreeMessage=fmDisplayFreeMessage;
    80c6:	81 e0       	ldi	r24, 0x01	; 1
    80c8:	23 c0       	rjmp	.+70     	; 0x8110 <FViewFreeMessage+0x60>
	      break;
     case fmDisplayFreeMessage:
		  lcd_clear();
    80ca:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    80ce:	81 e0       	ldi	r24, 0x01	; 1
    80d0:	61 e0       	ldi	r22, 0x01	; 1
    80d2:	47 ec       	ldi	r20, 0xC7	; 199
    80d4:	5a e0       	ldi	r21, 0x0A	; 10
    80d6:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    80da:	82 e0       	ldi	r24, 0x02	; 2
    80dc:	61 e0       	ldi	r22, 0x01	; 1
    80de:	42 eb       	ldi	r20, 0xB2	; 178
    80e0:	59 e0       	ldi	r21, 0x09	; 9
    80e2:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    80e6:	83 e0       	ldi	r24, 0x03	; 3
    80e8:	61 e0       	ldi	r22, 0x01	; 1
    80ea:	4d e4       	ldi	r20, 0x4D	; 77
    80ec:	5a e0       	ldi	r21, 0x0A	; 10
    80ee:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    80f2:	84 e0       	ldi	r24, 0x04	; 4
    80f4:	61 e0       	ldi	r22, 0x01	; 1
    80f6:	41 ee       	ldi	r20, 0xE1	; 225
    80f8:	5d e0       	ldi	r21, 0x0D	; 13
    80fa:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	      TimDisplay=0;
    80fe:	10 92 bc 01 	sts	0x01BC, r1
	      stFreeMessage=fmDelayViewMesage;
    8102:	82 e0       	ldi	r24, 0x02	; 2
    8104:	05 c0       	rjmp	.+10     	; 0x8110 <FViewFreeMessage+0x60>
	      break;
	 case fmDelayViewMesage:  
	      if (TimDisplay>TIM_FREE_MESSAGE)stFreeMessage=fmFinishFreeMessage;
    8106:	80 91 bc 01 	lds	r24, 0x01BC
    810a:	8b 30       	cpi	r24, 0x0B	; 11
    810c:	48 f0       	brcs	.+18     	; 0x8120 <FViewFreeMessage+0x70>
    810e:	83 e0       	ldi	r24, 0x03	; 3
    8110:	80 93 74 03 	sts	0x0374, r24
    8114:	80 e0       	ldi	r24, 0x00	; 0
    8116:	08 95       	ret
	      break;
     case fmFinishFreeMessage:
          stFreeMessage=fmInit;
    8118:	10 92 74 03 	sts	0x0374, r1
    811c:	81 e0       	ldi	r24, 0x01	; 1
    811e:	08 95       	ret
    8120:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;
}
    8122:	08 95       	ret

00008124 <_scr_idle>:
	lcd_printf(2, 5, PSTR("(P)+(C)2009, HAS"));
}



void _scr_idle(void){
    8124:	cf 92       	push	r12
    8126:	df 92       	push	r13
    8128:	ef 92       	push	r14
    812a:	ff 92       	push	r15
    812c:	0f 93       	push	r16
    812e:	1f 93       	push	r17
    8130:	df 93       	push	r29
    8132:	cf 93       	push	r28
    8134:	cd b7       	in	r28, 0x3d	; 61
    8136:	de b7       	in	r29, 0x3e	; 62
    8138:	a8 97       	sbiw	r28, 0x28	; 40
    813a:	0f b6       	in	r0, 0x3f	; 63
    813c:	f8 94       	cli
    813e:	de bf       	out	0x3e, r29	; 62
    8140:	0f be       	out	0x3f, r0	; 63
    8142:	cd bf       	out	0x3d, r28	; 61
char strCodeName[10],strVersion[10],lcdteks[20];
    sprintf_P(strCodeName,PSTR(CODE_NAME)); 
    8144:	00 d0       	rcall	.+0      	; 0x8146 <_scr_idle+0x22>
    8146:	00 d0       	rcall	.+0      	; 0x8148 <_scr_idle+0x24>
    8148:	6e 01       	movw	r12, r28
    814a:	08 94       	sec
    814c:	c1 1c       	adc	r12, r1
    814e:	d1 1c       	adc	r13, r1
    8150:	ad b7       	in	r26, 0x3d	; 61
    8152:	be b7       	in	r27, 0x3e	; 62
    8154:	12 96       	adiw	r26, 0x02	; 2
    8156:	dc 92       	st	X, r13
    8158:	ce 92       	st	-X, r12
    815a:	11 97       	sbiw	r26, 0x01	; 1
    815c:	8f e8       	ldi	r24, 0x8F	; 143
    815e:	91 e2       	ldi	r25, 0x21	; 33
    8160:	14 96       	adiw	r26, 0x04	; 4
    8162:	9c 93       	st	X, r25
    8164:	8e 93       	st	-X, r24
    8166:	13 97       	sbiw	r26, 0x03	; 3
    8168:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    sprintf_P(strVersion,PSTR(VERSION_NUM)); 
    816c:	fb e0       	ldi	r31, 0x0B	; 11
    816e:	ef 2e       	mov	r14, r31
    8170:	f1 2c       	mov	r15, r1
    8172:	ec 0e       	add	r14, r28
    8174:	fd 1e       	adc	r15, r29
    8176:	ed b7       	in	r30, 0x3d	; 61
    8178:	fe b7       	in	r31, 0x3e	; 62
    817a:	f2 82       	std	Z+2, r15	; 0x02
    817c:	e1 82       	std	Z+1, r14	; 0x01
    817e:	8a e8       	ldi	r24, 0x8A	; 138
    8180:	91 e2       	ldi	r25, 0x21	; 33
    8182:	94 83       	std	Z+4, r25	; 0x04
    8184:	83 83       	std	Z+3, r24	; 0x03
    8186:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    sprintf_P(lcdteks,PSTR("%s %s"),strCodeName,strVersion); 
    818a:	00 d0       	rcall	.+0      	; 0x818c <_scr_idle+0x68>
    818c:	00 d0       	rcall	.+0      	; 0x818e <_scr_idle+0x6a>
    818e:	ed b7       	in	r30, 0x3d	; 61
    8190:	fe b7       	in	r31, 0x3e	; 62
    8192:	31 96       	adiw	r30, 0x01	; 1
    8194:	8e 01       	movw	r16, r28
    8196:	0b 5e       	subi	r16, 0xEB	; 235
    8198:	1f 4f       	sbci	r17, 0xFF	; 255
    819a:	ad b7       	in	r26, 0x3d	; 61
    819c:	be b7       	in	r27, 0x3e	; 62
    819e:	12 96       	adiw	r26, 0x02	; 2
    81a0:	1c 93       	st	X, r17
    81a2:	0e 93       	st	-X, r16
    81a4:	11 97       	sbiw	r26, 0x01	; 1
    81a6:	84 e8       	ldi	r24, 0x84	; 132
    81a8:	91 e2       	ldi	r25, 0x21	; 33
    81aa:	93 83       	std	Z+3, r25	; 0x03
    81ac:	82 83       	std	Z+2, r24	; 0x02
    81ae:	d5 82       	std	Z+5, r13	; 0x05
    81b0:	c4 82       	std	Z+4, r12	; 0x04
    81b2:	f7 82       	std	Z+7, r15	; 0x07
    81b4:	e6 82       	std	Z+6, r14	; 0x06
    81b6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	lcd_clear();
    81ba:	ed b7       	in	r30, 0x3d	; 61
    81bc:	fe b7       	in	r31, 0x3e	; 62
    81be:	38 96       	adiw	r30, 0x08	; 8
    81c0:	0f b6       	in	r0, 0x3f	; 63
    81c2:	f8 94       	cli
    81c4:	fe bf       	out	0x3e, r31	; 62
    81c6:	0f be       	out	0x3f, r0	; 63
    81c8:	ed bf       	out	0x3d, r30	; 61
    81ca:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
	lcd_print(1,1,lcdteks);
    81ce:	81 e0       	ldi	r24, 0x01	; 1
    81d0:	61 e0       	ldi	r22, 0x01	; 1
    81d2:	a8 01       	movw	r20, r16
    81d4:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
}
    81d8:	a8 96       	adiw	r28, 0x28	; 40
    81da:	0f b6       	in	r0, 0x3f	; 63
    81dc:	f8 94       	cli
    81de:	de bf       	out	0x3e, r29	; 62
    81e0:	0f be       	out	0x3f, r0	; 63
    81e2:	cd bf       	out	0x3d, r28	; 61
    81e4:	cf 91       	pop	r28
    81e6:	df 91       	pop	r29
    81e8:	1f 91       	pop	r17
    81ea:	0f 91       	pop	r16
    81ec:	ff 90       	pop	r15
    81ee:	ef 90       	pop	r14
    81f0:	df 90       	pop	r13
    81f2:	cf 90       	pop	r12
    81f4:	08 95       	ret

000081f6 <_menu_admin>:
}



void _menu_admin(void){
		lcd_clear();
    81f6:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		lcd_printf(1, 1, PSTR("1)Close Shift"));
    81fa:	81 e0       	ldi	r24, 0x01	; 1
    81fc:	61 e0       	ldi	r22, 0x01	; 1
    81fe:	44 ee       	ldi	r20, 0xE4	; 228
    8200:	5b e0       	ldi	r21, 0x0B	; 11
    8202:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Re-Print"));
    8206:	82 e0       	ldi	r24, 0x02	; 2
    8208:	61 e0       	ldi	r22, 0x01	; 1
    820a:	49 ed       	ldi	r20, 0xD9	; 217
    820c:	5b e0       	ldi	r21, 0x0B	; 11
    820e:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		lcd_printf(3, 1, PSTR("3)User("));
    8212:	83 e0       	ldi	r24, 0x03	; 3
    8214:	61 e0       	ldi	r22, 0x01	; 1
    8216:	41 ed       	ldi	r20, 0xD1	; 209
    8218:	5b e0       	ldi	r21, 0x0B	; 11
    821a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    821e:	84 e0       	ldi	r24, 0x04	; 4
    8220:	61 e0       	ldi	r22, 0x01	; 1
    8222:	4a ec       	ldi	r20, 0xCA	; 202
    8224:	5b e0       	ldi	r21, 0x0B	; 11
    8226:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
}
    822a:	08 95       	ret

0000822c <_scr_pump>:
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);

}
void _scr_pump(void){
    822c:	8f 92       	push	r8
    822e:	9f 92       	push	r9
    8230:	af 92       	push	r10
    8232:	bf 92       	push	r11
    8234:	cf 92       	push	r12
    8236:	df 92       	push	r13
    8238:	ef 92       	push	r14
    823a:	ff 92       	push	r15
    823c:	0f 93       	push	r16
    823e:	1f 93       	push	r17
    8240:	df 93       	push	r29
    8242:	cf 93       	push	r28
    8244:	cd b7       	in	r28, 0x3d	; 61
    8246:	de b7       	in	r29, 0x3e	; 62
    8248:	6c 97       	sbiw	r28, 0x1c	; 28
    824a:	0f b6       	in	r0, 0x3f	; 63
    824c:	f8 94       	cli
    824e:	de bf       	out	0x3e, r29	; 62
    8250:	0f be       	out	0x3f, r0	; 63
    8252:	cd bf       	out	0x3d, r28	; 61
	 char strPumpL[3],strPumpR[3];
	 char __pump_id[8];
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
    8254:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    8258:	84 ec       	ldi	r24, 0xC4	; 196
    825a:	99 e0       	ldi	r25, 0x09	; 9
    825c:	01 97       	sbiw	r24, 0x01	; 1
    825e:	f1 f7       	brne	.-4      	; 0x825c <_scr_pump+0x30>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8260:	8e 01       	movw	r16, r28
    8262:	0f 5f       	subi	r16, 0xFF	; 255
    8264:	1f 4f       	sbci	r17, 0xFF	; 255
    8266:	c8 01       	movw	r24, r16
    8268:	65 e4       	ldi	r22, 0x45	; 69
    826a:	70 e0       	ldi	r23, 0x00	; 0
    826c:	48 e0       	ldi	r20, 0x08	; 8
    826e:	50 e0       	ldi	r21, 0x00	; 0
    8270:	2c ea       	ldi	r18, 0xAC	; 172
    8272:	32 e1       	ldi	r19, 0x12	; 18
    8274:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
    8278:	78 01       	movw	r14, r16
    827a:	01 e0       	ldi	r16, 0x01	; 1
    827c:	10 e0       	ldi	r17, 0x00	; 0
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    827e:	89 e0       	ldi	r24, 0x09	; 9
    8280:	c8 2e       	mov	r12, r24
    8282:	d1 2c       	mov	r13, r1
    8284:	cc 0e       	add	r12, r28
    8286:	dd 1e       	adc	r13, r29
    8288:	b0 ea       	ldi	r27, 0xA0	; 160
    828a:	8b 2e       	mov	r8, r27
    828c:	be e0       	ldi	r27, 0x0E	; 14
    828e:	9b 2e       	mov	r9, r27
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    8290:	a5 e0       	ldi	r26, 0x05	; 5
    8292:	aa 2e       	mov	r10, r26
    8294:	b1 2c       	mov	r11, r1
    8296:	ac 0e       	add	r10, r28
    8298:	bd 1e       	adc	r11, r29
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    829a:	8d b7       	in	r24, 0x3d	; 61
    829c:	9e b7       	in	r25, 0x3e	; 62
    829e:	0c 97       	sbiw	r24, 0x0c	; 12
    82a0:	0f b6       	in	r0, 0x3f	; 63
    82a2:	f8 94       	cli
    82a4:	9e bf       	out	0x3e, r25	; 62
    82a6:	0f be       	out	0x3f, r0	; 63
    82a8:	8d bf       	out	0x3d, r24	; 61
    82aa:	ed b7       	in	r30, 0x3d	; 61
    82ac:	fe b7       	in	r31, 0x3e	; 62
    82ae:	31 96       	adiw	r30, 0x01	; 1
    82b0:	ad b7       	in	r26, 0x3d	; 61
    82b2:	be b7       	in	r27, 0x3e	; 62
    82b4:	12 96       	adiw	r26, 0x02	; 2
    82b6:	dc 92       	st	X, r13
    82b8:	ce 92       	st	-X, r12
    82ba:	11 97       	sbiw	r26, 0x01	; 1
    82bc:	93 82       	std	Z+3, r9	; 0x03
    82be:	82 82       	std	Z+2, r8	; 0x02
    82c0:	15 83       	std	Z+5, r17	; 0x05
    82c2:	04 83       	std	Z+4, r16	; 0x04
    82c4:	d7 01       	movw	r26, r14
    82c6:	8c 91       	ld	r24, X
    82c8:	86 83       	std	Z+6, r24	; 0x06
    82ca:	17 82       	std	Z+7, r1	; 0x07
    82cc:	0c 5f       	subi	r16, 0xFC	; 252
    82ce:	1f 4f       	sbci	r17, 0xFF	; 255
    82d0:	11 87       	std	Z+9, r17	; 0x09
    82d2:	00 87       	std	Z+8, r16	; 0x08
    82d4:	04 50       	subi	r16, 0x04	; 4
    82d6:	10 40       	sbci	r17, 0x00	; 0
    82d8:	14 96       	adiw	r26, 0x04	; 4
    82da:	8c 91       	ld	r24, X
    82dc:	82 87       	std	Z+10, r24	; 0x0a
    82de:	13 86       	std	Z+11, r1	; 0x0b
    82e0:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			 lcd_print((i+1),1,lcdteks);
    82e4:	8d b7       	in	r24, 0x3d	; 61
    82e6:	9e b7       	in	r25, 0x3e	; 62
    82e8:	0c 96       	adiw	r24, 0x0c	; 12
    82ea:	0f b6       	in	r0, 0x3f	; 63
    82ec:	f8 94       	cli
    82ee:	9e bf       	out	0x3e, r25	; 62
    82f0:	0f be       	out	0x3f, r0	; 63
    82f2:	8d bf       	out	0x3d, r24	; 61
    82f4:	80 2f       	mov	r24, r16
    82f6:	61 e0       	ldi	r22, 0x01	; 1
    82f8:	a6 01       	movw	r20, r12
    82fa:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    82fe:	08 94       	sec
    8300:	e1 1c       	adc	r14, r1
    8302:	f1 1c       	adc	r15, r1
    8304:	0f 5f       	subi	r16, 0xFF	; 255
    8306:	1f 4f       	sbci	r17, 0xFF	; 255
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    8308:	ea 14       	cp	r14, r10
    830a:	fb 04       	cpc	r15, r11
    830c:	31 f6       	brne	.-116    	; 0x829a <_scr_pump+0x6e>
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
			 lcd_print((i+1),1,lcdteks);
		}
        lcd_printf(4,15,PSTR("*)Exit"));
    830e:	84 e0       	ldi	r24, 0x04	; 4
    8310:	6f e0       	ldi	r22, 0x0F	; 15
    8312:	49 e9       	ldi	r20, 0x99	; 153
    8314:	5e e0       	ldi	r21, 0x0E	; 14
    8316:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
}
    831a:	6c 96       	adiw	r28, 0x1c	; 28
    831c:	0f b6       	in	r0, 0x3f	; 63
    831e:	f8 94       	cli
    8320:	de bf       	out	0x3e, r29	; 62
    8322:	0f be       	out	0x3f, r0	; 63
    8324:	cd bf       	out	0x3d, r28	; 61
    8326:	cf 91       	pop	r28
    8328:	df 91       	pop	r29
    832a:	1f 91       	pop	r17
    832c:	0f 91       	pop	r16
    832e:	ff 90       	pop	r15
    8330:	ef 90       	pop	r14
    8332:	df 90       	pop	r13
    8334:	cf 90       	pop	r12
    8336:	bf 90       	pop	r11
    8338:	af 90       	pop	r10
    833a:	9f 90       	pop	r9
    833c:	8f 90       	pop	r8
    833e:	08 95       	ret

00008340 <_scr_splash>:
		break;
	 }
}

void _scr_splash(void){
	lcd_clear();_delay_ms(20);
    8340:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    8344:	88 e8       	ldi	r24, 0x88	; 136
    8346:	93 e1       	ldi	r25, 0x13	; 19
    8348:	01 97       	sbiw	r24, 0x01	; 1
    834a:	f1 f7       	brne	.-4      	; 0x8348 <_scr_splash+0x8>
	lcd_printf(1, 5, PSTR("IFTv5.13"));
    834c:	81 e0       	ldi	r24, 0x01	; 1
    834e:	65 e0       	ldi	r22, 0x05	; 5
    8350:	47 ea       	ldi	r20, 0xA7	; 167
    8352:	51 e2       	ldi	r21, 0x21	; 33
    8354:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_printf(2, 5, PSTR("(P)+(C)2009, HAS"));
    8358:	82 e0       	ldi	r24, 0x02	; 2
    835a:	65 e0       	ldi	r22, 0x05	; 5
    835c:	46 e9       	ldi	r20, 0x96	; 150
    835e:	51 e2       	ldi	r21, 0x21	; 33
    8360:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
}
    8364:	08 95       	ret

00008366 <_menu_host>:
			lcd_print(__x, __y, __buff);
		}
	}
}

void _menu_host(void){
    8366:	2f 92       	push	r2
    8368:	3f 92       	push	r3
    836a:	4f 92       	push	r4
    836c:	5f 92       	push	r5
    836e:	6f 92       	push	r6
    8370:	7f 92       	push	r7
    8372:	8f 92       	push	r8
    8374:	9f 92       	push	r9
    8376:	af 92       	push	r10
    8378:	bf 92       	push	r11
    837a:	cf 92       	push	r12
    837c:	df 92       	push	r13
    837e:	ef 92       	push	r14
    8380:	ff 92       	push	r15
    8382:	0f 93       	push	r16
    8384:	1f 93       	push	r17
    8386:	df 93       	push	r29
    8388:	cf 93       	push	r28
    838a:	cd b7       	in	r28, 0x3d	; 61
    838c:	de b7       	in	r29, 0x3e	; 62
    838e:	6d 97       	sbiw	r28, 0x1d	; 29
    8390:	0f b6       	in	r0, 0x3f	; 63
    8392:	f8 94       	cli
    8394:	de bf       	out	0x3e, r29	; 62
    8396:	0f be       	out	0x3f, r0	; 63
    8398:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    839a:	e1 99       	sbic	0x1c, 1	; 28
    839c:	fe cf       	rjmp	.-4      	; 0x839a <_menu_host+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    839e:	21 ef       	ldi	r18, 0xF1	; 241
    83a0:	33 e0       	ldi	r19, 0x03	; 3
    83a2:	3f bb       	out	0x1f, r19	; 31
    83a4:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    83a6:	e0 9a       	sbi	0x1c, 0	; 28
    83a8:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[4];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];
	static char TermID;

	__value[0] = eeprom_read_byte(&DefPrintMoney);
    83aa:	89 83       	std	Y+1, r24	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    83ac:	e1 99       	sbic	0x1c, 1	; 28
    83ae:	fe cf       	rjmp	.-4      	; 0x83ac <_menu_host+0x46>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    83b0:	f7 e3       	ldi	r31, 0x37	; 55
    83b2:	2f 2e       	mov	r2, r31
    83b4:	f0 e0       	ldi	r31, 0x00	; 0
    83b6:	3f 2e       	mov	r3, r31
    83b8:	3f ba       	out	0x1f, r3	; 31
    83ba:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    83bc:	e0 9a       	sbi	0x1c, 0	; 28
    83be:	8d b3       	in	r24, 0x1d	; 29
	__value[1] = eeprom_read_byte(&__date_time);
    83c0:	8a 83       	std	Y+2, r24	; 0x02
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    83c2:	e1 99       	sbic	0x1c, 1	; 28
    83c4:	fe cf       	rjmp	.-4      	; 0x83c2 <_menu_host+0x5c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    83c6:	e8 e3       	ldi	r30, 0x38	; 56
    83c8:	4e 2e       	mov	r4, r30
    83ca:	e0 e0       	ldi	r30, 0x00	; 0
    83cc:	5e 2e       	mov	r5, r30
    83ce:	5f ba       	out	0x1f, r5	; 31
    83d0:	4e ba       	out	0x1e, r4	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    83d2:	e0 9a       	sbi	0x1c, 0	; 28
    83d4:	8d b3       	in	r24, 0x1d	; 29
	__value[2] = eeprom_read_byte(&__notif_scr);
    83d6:	8b 83       	std	Y+3, r24	; 0x03
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    83d8:	e1 99       	sbic	0x1c, 1	; 28
    83da:	fe cf       	rjmp	.-4      	; 0x83d8 <_menu_host+0x72>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    83dc:	70 e0       	ldi	r23, 0x00	; 0
    83de:	67 2e       	mov	r6, r23
    83e0:	70 e0       	ldi	r23, 0x00	; 0
    83e2:	77 2e       	mov	r7, r23
    83e4:	7f ba       	out	0x1f, r7	; 31
    83e6:	6e ba       	out	0x1e, r6	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    83e8:	e0 9a       	sbi	0x1c, 0	; 28
    83ea:	8d b3       	in	r24, 0x1d	; 29
	TermID= eeprom_read_byte(&DefIFT_ID);
    83ec:	80 93 ee 02 	sts	0x02EE, r24


	lcd_clear();_delay_ms(10);
    83f0:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    83f4:	84 ec       	ldi	r24, 0xC4	; 196
    83f6:	99 e0       	ldi	r25, 0x09	; 9
    83f8:	01 97       	sbiw	r24, 0x01	; 1
    83fa:	f1 f7       	brne	.-4      	; 0x83f8 <_menu_host+0x92>
	lcd_printf(1, 1, PSTR("1)Money :"));
    83fc:	81 e0       	ldi	r24, 0x01	; 1
    83fe:	61 e0       	ldi	r22, 0x01	; 1
    8400:	44 e7       	ldi	r20, 0x74	; 116
    8402:	5c e0       	ldi	r21, 0x0C	; 12
    8404:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_printf(2, 1, PSTR("2)D/T   :"));
    8408:	82 e0       	ldi	r24, 0x02	; 2
    840a:	61 e0       	ldi	r22, 0x01	; 1
    840c:	4a e6       	ldi	r20, 0x6A	; 106
    840e:	5c e0       	ldi	r21, 0x0C	; 12
    8410:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
    8414:	83 e0       	ldi	r24, 0x03	; 3
    8416:	61 e0       	ldi	r22, 0x01	; 1
    8418:	45 e5       	ldi	r20, 0x55	; 85
    841a:	5c e0       	ldi	r21, 0x0C	; 12
    841c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    8420:	00 d0       	rcall	.+0      	; 0x8422 <_menu_host+0xbc>
    8422:	00 d0       	rcall	.+0      	; 0x8424 <_menu_host+0xbe>
    8424:	00 d0       	rcall	.+0      	; 0x8426 <_menu_host+0xc0>
    8426:	ed b7       	in	r30, 0x3d	; 61
    8428:	fe b7       	in	r31, 0x3e	; 62
    842a:	31 96       	adiw	r30, 0x01	; 1
    842c:	8e 01       	movw	r16, r28
    842e:	06 5f       	subi	r16, 0xF6	; 246
    8430:	1f 4f       	sbci	r17, 0xFF	; 255
    8432:	ad b7       	in	r26, 0x3d	; 61
    8434:	be b7       	in	r27, 0x3e	; 62
    8436:	12 96       	adiw	r26, 0x02	; 2
    8438:	1c 93       	st	X, r17
    843a:	0e 93       	st	-X, r16
    843c:	11 97       	sbiw	r26, 0x01	; 1
    843e:	88 e4       	ldi	r24, 0x48	; 72
    8440:	9c e0       	ldi	r25, 0x0C	; 12
    8442:	93 83       	std	Z+3, r25	; 0x03
    8444:	82 83       	std	Z+2, r24	; 0x02
    8446:	80 91 ee 02 	lds	r24, 0x02EE
    844a:	84 83       	std	Z+4, r24	; 0x04
    844c:	15 82       	std	Z+5, r1	; 0x05
    844e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		 lcd_print(4, 1,lcdteks);
    8452:	ed b7       	in	r30, 0x3d	; 61
    8454:	fe b7       	in	r31, 0x3e	; 62
    8456:	36 96       	adiw	r30, 0x06	; 6
    8458:	0f b6       	in	r0, 0x3f	; 63
    845a:	f8 94       	cli
    845c:	fe bf       	out	0x3e, r31	; 62
    845e:	0f be       	out	0x3f, r0	; 63
    8460:	ed bf       	out	0x3d, r30	; 61
    8462:	84 e0       	ldi	r24, 0x04	; 4
    8464:	61 e0       	ldi	r22, 0x01	; 1
    8466:	a8 01       	movw	r20, r16
    8468:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	lcd_printf(4, 15, PSTR("#)Save"));
    846c:	84 e0       	ldi	r24, 0x04	; 4
    846e:	6f e0       	ldi	r22, 0x0F	; 15
    8470:	41 e4       	ldi	r20, 0x41	; 65
    8472:	5c e0       	ldi	r21, 0x0C	; 12
    8474:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
    8478:	6c e2       	ldi	r22, 0x2C	; 44
    847a:	e6 2e       	mov	r14, r22
    847c:	63 e0       	ldi	r22, 0x03	; 3
    847e:	f6 2e       	mov	r15, r22
    8480:	6e 01       	movw	r12, r28
    8482:	08 94       	sec
    8484:	c1 1c       	adc	r12, r1
    8486:	d1 1c       	adc	r13, r1

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
		__y = pgm_read_byte(&__hostloc[__i][1]);
		_f_inttostr(__buff, __value[__i]);
    8488:	55 e0       	ldi	r21, 0x05	; 5
    848a:	a5 2e       	mov	r10, r21
    848c:	b1 2c       	mov	r11, r1
    848e:	ac 0e       	add	r10, r28
    8490:	bd 1e       	adc	r11, r29
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
		 lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
    8492:	f7 01       	movw	r30, r14
    8494:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__hostloc[__i][1]);
    8496:	08 94       	sec
    8498:	e1 1c       	adc	r14, r1
    849a:	f1 1c       	adc	r15, r1
    849c:	f7 01       	movw	r30, r14
    849e:	14 91       	lpm	r17, Z+
		_f_inttostr(__buff, __value[__i]);
    84a0:	d6 01       	movw	r26, r12
    84a2:	4d 91       	ld	r20, X+
    84a4:	6d 01       	movw	r12, r26
    84a6:	50 e0       	ldi	r21, 0x00	; 0
    84a8:	60 e0       	ldi	r22, 0x00	; 0
    84aa:	70 e0       	ldi	r23, 0x00	; 0
    84ac:	c5 01       	movw	r24, r10
    84ae:	0e 94 1c 18 	call	0x3038	; 0x3038 <_f_inttostr>
		lcd_print(__x, __y, __buff);
    84b2:	80 2f       	mov	r24, r16
    84b4:	61 2f       	mov	r22, r17
    84b6:	a5 01       	movw	r20, r10
    84b8:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    84bc:	08 94       	sec
    84be:	e1 1c       	adc	r14, r1
    84c0:	f1 1c       	adc	r15, r1
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
		 lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
    84c2:	b2 e3       	ldi	r27, 0x32	; 50
    84c4:	eb 16       	cp	r14, r27
    84c6:	b3 e0       	ldi	r27, 0x03	; 3
    84c8:	fb 06       	cpc	r15, r27
    84ca:	19 f7       	brne	.-58     	; 0x8492 <_menu_host+0x12c>
			lcd_print(__x, __y, __buff);
		}else
		if (__num=='4'){
		    if (TermID<=99)TermID++;
			else TermID=1;
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    84cc:	4a e0       	ldi	r20, 0x0A	; 10
    84ce:	a4 2e       	mov	r10, r20
    84d0:	b1 2c       	mov	r11, r1
    84d2:	ac 0e       	add	r10, r28
    84d4:	bd 1e       	adc	r11, r29
    84d6:	34 e3       	ldi	r19, 0x34	; 52
    84d8:	83 2e       	mov	r8, r19
    84da:	3c e0       	ldi	r19, 0x0C	; 12
    84dc:	93 2e       	mov	r9, r19
			eeprom_write_byte(&__notif_scr, __value[2]);
			eeprom_write_byte(&DefIFT_ID,TermID);
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
			if(__value[__num - 0x31] == 1)
    84de:	6e 01       	movw	r12, r28
    84e0:	08 94       	sec
    84e2:	c1 1c       	adc	r12, r1
    84e4:	d1 1c       	adc	r13, r1
				__value[__num - 0x31] = 0;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
			_f_inttostr(__buff, __value[__num - 0x31]);
    84e6:	25 e0       	ldi	r18, 0x05	; 5
    84e8:	e2 2e       	mov	r14, r18
    84ea:	f1 2c       	mov	r15, r1
    84ec:	ec 0e       	add	r14, r28
    84ee:	fd 1e       	adc	r15, r29
		_f_inttostr(__buff, __value[__i]);
		lcd_print(__x, __y, __buff);
	}

	while(1){
		__key = _key_scan(1);
    84f0:	81 e0       	ldi	r24, 0x01	; 1
    84f2:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    84f6:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    84f8:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
    84fc:	98 2f       	mov	r25, r24

		if(__key == _KEY_CANCEL)
    84fe:	17 3e       	cpi	r17, 0xE7	; 231
    8500:	09 f4       	brne	.+2      	; 0x8504 <_menu_host+0x19e>
    8502:	95 c0       	rjmp	.+298    	; 0x862e <_menu_host+0x2c8>
			return;
		if(__key==_KEY_ENTER){
    8504:	17 3b       	cpi	r17, 0xB7	; 183
    8506:	09 f0       	breq	.+2      	; 0x850a <_menu_host+0x1a4>
    8508:	30 c0       	rjmp	.+96     	; 0x856a <_menu_host+0x204>
			eeprom_write_byte(&DefPrintMoney, __value[0]);
    850a:	89 81       	ldd	r24, Y+1	; 0x01
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    850c:	e1 99       	sbic	0x1c, 1	; 28
    850e:	fe cf       	rjmp	.-4      	; 0x850c <_menu_host+0x1a6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8510:	e1 ef       	ldi	r30, 0xF1	; 241
    8512:	f3 e0       	ldi	r31, 0x03	; 3
    8514:	ff bb       	out	0x1f, r31	; 31
    8516:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    8518:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    851a:	0f b6       	in	r0, 0x3f	; 63
    851c:	f8 94       	cli
    851e:	e2 9a       	sbi	0x1c, 2	; 28
    8520:	e1 9a       	sbi	0x1c, 1	; 28
    8522:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&__date_time, __value[1]);
    8524:	8a 81       	ldd	r24, Y+2	; 0x02
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8526:	e1 99       	sbic	0x1c, 1	; 28
    8528:	fe cf       	rjmp	.-4      	; 0x8526 <_menu_host+0x1c0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    852a:	3f ba       	out	0x1f, r3	; 31
    852c:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    852e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8530:	0f b6       	in	r0, 0x3f	; 63
    8532:	f8 94       	cli
    8534:	e2 9a       	sbi	0x1c, 2	; 28
    8536:	e1 9a       	sbi	0x1c, 1	; 28
    8538:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&__notif_scr, __value[2]);
    853a:	8b 81       	ldd	r24, Y+3	; 0x03
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    853c:	e1 99       	sbic	0x1c, 1	; 28
    853e:	fe cf       	rjmp	.-4      	; 0x853c <_menu_host+0x1d6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8540:	5f ba       	out	0x1f, r5	; 31
    8542:	4e ba       	out	0x1e, r4	; 30
#endif
    EEDR = __value;
    8544:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8546:	0f b6       	in	r0, 0x3f	; 63
    8548:	f8 94       	cli
    854a:	e2 9a       	sbi	0x1c, 2	; 28
    854c:	e1 9a       	sbi	0x1c, 1	; 28
    854e:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefIFT_ID,TermID);
    8550:	80 91 ee 02 	lds	r24, 0x02EE
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8554:	e1 99       	sbic	0x1c, 1	; 28
    8556:	fe cf       	rjmp	.-4      	; 0x8554 <_menu_host+0x1ee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8558:	7f ba       	out	0x1f, r7	; 31
    855a:	6e ba       	out	0x1e, r6	; 30
#endif
    EEDR = __value;
    855c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    855e:	0f b6       	in	r0, 0x3f	; 63
    8560:	f8 94       	cli
    8562:	e2 9a       	sbi	0x1c, 2	; 28
    8564:	e1 9a       	sbi	0x1c, 1	; 28
    8566:	0f be       	out	0x3f, r0	; 63
    8568:	62 c0       	rjmp	.+196    	; 0x862e <_menu_host+0x2c8>
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
    856a:	81 53       	subi	r24, 0x31	; 49
    856c:	83 30       	cpi	r24, 0x03	; 3
    856e:	58 f5       	brcc	.+86     	; 0x85c6 <_menu_host+0x260>
			if(__value[__num - 0x31] == 1)
    8570:	a9 2f       	mov	r26, r25
    8572:	b0 e0       	ldi	r27, 0x00	; 0
    8574:	d1 97       	sbiw	r26, 0x31	; 49
    8576:	f6 01       	movw	r30, r12
    8578:	ea 0f       	add	r30, r26
    857a:	fb 1f       	adc	r31, r27
    857c:	80 81       	ld	r24, Z
    857e:	81 30       	cpi	r24, 0x01	; 1
    8580:	11 f4       	brne	.+4      	; 0x8586 <_menu_host+0x220>
				__value[__num - 0x31] = 0;
    8582:	10 82       	st	Z, r1
    8584:	02 c0       	rjmp	.+4      	; 0x858a <_menu_host+0x224>
			else
				__value[__num - 0x31]++;
    8586:	8f 5f       	subi	r24, 0xFF	; 255
    8588:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
    858a:	29 2f       	mov	r18, r25
    858c:	30 e0       	ldi	r19, 0x00	; 0
    858e:	21 53       	subi	r18, 0x31	; 49
    8590:	30 40       	sbci	r19, 0x00	; 0
    8592:	22 0f       	add	r18, r18
    8594:	33 1f       	adc	r19, r19
    8596:	c9 01       	movw	r24, r18
    8598:	84 5d       	subi	r24, 0xD4	; 212
    859a:	9c 4f       	sbci	r25, 0xFC	; 252
    859c:	fc 01       	movw	r30, r24
    859e:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
    85a0:	23 5d       	subi	r18, 0xD3	; 211
    85a2:	3c 4f       	sbci	r19, 0xFC	; 252
    85a4:	f9 01       	movw	r30, r18
    85a6:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __value[__num - 0x31]);
    85a8:	ac 0d       	add	r26, r12
    85aa:	bd 1d       	adc	r27, r13
    85ac:	4c 91       	ld	r20, X
    85ae:	50 e0       	ldi	r21, 0x00	; 0
    85b0:	60 e0       	ldi	r22, 0x00	; 0
    85b2:	70 e0       	ldi	r23, 0x00	; 0
    85b4:	c7 01       	movw	r24, r14
    85b6:	0e 94 1c 18 	call	0x3038	; 0x3038 <_f_inttostr>
			lcd_print(__x, __y, __buff);
    85ba:	80 2f       	mov	r24, r16
    85bc:	61 2f       	mov	r22, r17
    85be:	a7 01       	movw	r20, r14
    85c0:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    85c4:	95 cf       	rjmp	.-214    	; 0x84f0 <_menu_host+0x18a>
		}else
		if (__num=='4'){
    85c6:	94 33       	cpi	r25, 0x34	; 52
    85c8:	09 f0       	breq	.+2      	; 0x85cc <_menu_host+0x266>
    85ca:	92 cf       	rjmp	.-220    	; 0x84f0 <_menu_host+0x18a>
		    if (TermID<=99)TermID++;
    85cc:	80 91 ee 02 	lds	r24, 0x02EE
    85d0:	84 36       	cpi	r24, 0x64	; 100
    85d2:	10 f4       	brcc	.+4      	; 0x85d8 <_menu_host+0x272>
    85d4:	8f 5f       	subi	r24, 0xFF	; 255
    85d6:	01 c0       	rjmp	.+2      	; 0x85da <_menu_host+0x274>
			else TermID=1;
    85d8:	81 e0       	ldi	r24, 0x01	; 1
    85da:	80 93 ee 02 	sts	0x02EE, r24
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    85de:	00 d0       	rcall	.+0      	; 0x85e0 <_menu_host+0x27a>
    85e0:	00 d0       	rcall	.+0      	; 0x85e2 <_menu_host+0x27c>
    85e2:	00 d0       	rcall	.+0      	; 0x85e4 <_menu_host+0x27e>
    85e4:	ed b7       	in	r30, 0x3d	; 61
    85e6:	fe b7       	in	r31, 0x3e	; 62
    85e8:	31 96       	adiw	r30, 0x01	; 1
    85ea:	ad b7       	in	r26, 0x3d	; 61
    85ec:	be b7       	in	r27, 0x3e	; 62
    85ee:	12 96       	adiw	r26, 0x02	; 2
    85f0:	bc 92       	st	X, r11
    85f2:	ae 92       	st	-X, r10
    85f4:	11 97       	sbiw	r26, 0x01	; 1
    85f6:	93 82       	std	Z+3, r9	; 0x03
    85f8:	82 82       	std	Z+2, r8	; 0x02
    85fa:	80 91 ee 02 	lds	r24, 0x02EE
    85fe:	84 83       	std	Z+4, r24	; 0x04
    8600:	15 82       	std	Z+5, r1	; 0x05
    8602:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		 lcd_print(4, 1,lcdteks);lcd_printf(4, 15, PSTR("#)Save"));
    8606:	ed b7       	in	r30, 0x3d	; 61
    8608:	fe b7       	in	r31, 0x3e	; 62
    860a:	36 96       	adiw	r30, 0x06	; 6
    860c:	0f b6       	in	r0, 0x3f	; 63
    860e:	f8 94       	cli
    8610:	fe bf       	out	0x3e, r31	; 62
    8612:	0f be       	out	0x3f, r0	; 63
    8614:	ed bf       	out	0x3d, r30	; 61
    8616:	84 e0       	ldi	r24, 0x04	; 4
    8618:	61 e0       	ldi	r22, 0x01	; 1
    861a:	a5 01       	movw	r20, r10
    861c:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    8620:	84 e0       	ldi	r24, 0x04	; 4
    8622:	6f e0       	ldi	r22, 0x0F	; 15
    8624:	4d e2       	ldi	r20, 0x2D	; 45
    8626:	5c e0       	ldi	r21, 0x0C	; 12
    8628:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
    862c:	61 cf       	rjmp	.-318    	; 0x84f0 <_menu_host+0x18a>
		 
		}

	}
}
    862e:	6d 96       	adiw	r28, 0x1d	; 29
    8630:	0f b6       	in	r0, 0x3f	; 63
    8632:	f8 94       	cli
    8634:	de bf       	out	0x3e, r29	; 62
    8636:	0f be       	out	0x3f, r0	; 63
    8638:	cd bf       	out	0x3d, r28	; 61
    863a:	cf 91       	pop	r28
    863c:	df 91       	pop	r29
    863e:	1f 91       	pop	r17
    8640:	0f 91       	pop	r16
    8642:	ff 90       	pop	r15
    8644:	ef 90       	pop	r14
    8646:	df 90       	pop	r13
    8648:	cf 90       	pop	r12
    864a:	bf 90       	pop	r11
    864c:	af 90       	pop	r10
    864e:	9f 90       	pop	r9
    8650:	8f 90       	pop	r8
    8652:	7f 90       	pop	r7
    8654:	6f 90       	pop	r6
    8656:	5f 90       	pop	r5
    8658:	4f 90       	pop	r4
    865a:	3f 90       	pop	r3
    865c:	2f 90       	pop	r2
    865e:	08 95       	ret

00008660 <FSettingHost>:
char FSettingPrinter(){
     _menu_printer();
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
    8660:	0e 94 b3 41 	call	0x8366	; 0x8366 <_menu_host>
	 return MENU_DONE;
}
    8664:	81 e0       	ldi	r24, 0x01	; 1
    8666:	08 95       	ret

00008668 <system_stop>:
	return Result;
}

void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
    8668:	84 e0       	ldi	r24, 0x04	; 4
    866a:	61 e0       	ldi	r22, 0x01	; 1
    866c:	40 eb       	ldi	r20, 0xB0	; 176
    866e:	51 e2       	ldi	r21, 0x21	; 33
    8670:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    8674:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    8676:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    8678:	85 e0       	ldi	r24, 0x05	; 5
    867a:	90 e0       	ldi	r25, 0x00	; 0
    867c:	90 93 ec 01 	sts	0x01EC, r25
    8680:	80 93 eb 01 	sts	0x01EB, r24
void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
	 system_beep(5);
	 while(1){
		__key = _key_scan(1);
    8684:	81 e0       	ldi	r24, 0x01	; 1
    8686:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
		__num = _key_btn(__key);
    868a:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
    868e:	80 53       	subi	r24, 0x30	; 48
    8690:	8a 30       	cpi	r24, 0x0A	; 10
    8692:	20 f0       	brcs	.+8      	; 0x869c <system_stop+0x34>
    8694:	80 91 c8 01 	lds	r24, 0x01C8
    8698:	81 30       	cpi	r24, 0x01	; 1
    869a:	a1 f7       	brne	.-24     	; 0x8684 <system_stop+0x1c>
    869c:	08 95       	ret

0000869e <systemForceType>:
	 }
}

char systemForceType(){
     char Result,KeyChar;
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
    869e:	84 e0       	ldi	r24, 0x04	; 4
    86a0:	61 e0       	ldi	r22, 0x01	; 1
    86a2:	45 ec       	ldi	r20, 0xC5	; 197
    86a4:	51 e2       	ldi	r21, 0x21	; 33
    86a6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    86aa:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    86ac:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    86ae:	81 e0       	ldi	r24, 0x01	; 1
    86b0:	90 e0       	ldi	r25, 0x00	; 0
    86b2:	90 93 ec 01 	sts	0x01EC, r25
    86b6:	80 93 eb 01 	sts	0x01EB, r24
    86ba:	80 e5       	ldi	r24, 0x50	; 80
    86bc:	93 ec       	ldi	r25, 0xC3	; 195
    86be:	01 97       	sbiw	r24, 0x01	; 1
    86c0:	f1 f7       	brne	.-4      	; 0x86be <systemForceType+0x20>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    86c2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    86c4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    86c6:	82 e0       	ldi	r24, 0x02	; 2
    86c8:	90 e0       	ldi	r25, 0x00	; 0
    86ca:	90 93 ec 01 	sts	0x01EC, r25
    86ce:	80 93 eb 01 	sts	0x01EB, r24
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
	 system_beep(1);
	 _delay_ms(200);
	 system_beep(2);
	 while(1){
	    KeyChar=_key_btn(_key_scan(1));
    86d2:	81 e0       	ldi	r24, 0x01	; 1
    86d4:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    86d8:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
    86dc:	98 2f       	mov	r25, r24
		if ((KeyChar=='1')||(KeyChar=='2')){
    86de:	81 53       	subi	r24, 0x31	; 49
    86e0:	82 30       	cpi	r24, 0x02	; 2
    86e2:	b8 f7       	brcc	.-18     	; 0x86d2 <systemForceType+0x34>
		    Result=KeyChar;
			break;
		}
	 }
	return Result;
}
    86e4:	89 2f       	mov	r24, r25
    86e6:	08 95       	ret

000086e8 <SetTotalizerData>:
			  }
		  }
	 }
}

void SetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "00000000"
    86e8:	af 92       	push	r10
    86ea:	bf 92       	push	r11
    86ec:	cf 92       	push	r12
    86ee:	df 92       	push	r13
    86f0:	ef 92       	push	r14
    86f2:	ff 92       	push	r15
    86f4:	0f 93       	push	r16
    86f6:	1f 93       	push	r17
    86f8:	df 93       	push	r29
    86fa:	cf 93       	push	r28
    86fc:	cd b7       	in	r28, 0x3d	; 61
    86fe:	de b7       	in	r29, 0x3e	; 62
    8700:	65 97       	sbiw	r28, 0x15	; 21
    8702:	0f b6       	in	r0, 0x3f	; 63
    8704:	f8 94       	cli
    8706:	de bf       	out	0x3e, r29	; 62
    8708:	0f be       	out	0x3f, r0	; 63
    870a:	cd bf       	out	0x3d, r28	; 61
    870c:	d8 2e       	mov	r13, r24
    870e:	c6 2e       	mov	r12, r22
    8710:	b4 2e       	mov	r11, r20
    8712:	a2 2e       	mov	r10, r18
     char rawValue[6],iPumpAddr,iGrade;
	 char strPValue[15];
	 char Idx;
	 char strSend[30];
	 //Convert String to RawData
	 if (strlen(strValue)<=12){
    8714:	d8 01       	movw	r26, r16
    8716:	0d 90       	ld	r0, X+
    8718:	00 20       	and	r0, r0
    871a:	e9 f7       	brne	.-6      	; 0x8716 <SetTotalizerData+0x2e>
    871c:	11 97       	sbiw	r26, 0x01	; 1
    871e:	a0 1b       	sub	r26, r16
    8720:	b1 0b       	sbc	r27, r17
    8722:	87 e0       	ldi	r24, 0x07	; 7
    8724:	e8 2e       	mov	r14, r24
    8726:	f1 2c       	mov	r15, r1
    8728:	ec 0e       	add	r14, r28
    872a:	fd 1e       	adc	r15, r29
    872c:	ad 30       	cpi	r26, 0x0D	; 13
    872e:	b1 05       	cpc	r27, r1
    8730:	58 f5       	brcc	.+86     	; 0x8788 <SetTotalizerData+0xa0>
	     sprintf_P(strPValue,PSTR("%s"),strValue);
    8732:	00 d0       	rcall	.+0      	; 0x8734 <SetTotalizerData+0x4c>
    8734:	00 d0       	rcall	.+0      	; 0x8736 <SetTotalizerData+0x4e>
    8736:	00 d0       	rcall	.+0      	; 0x8738 <SetTotalizerData+0x50>
    8738:	ed b7       	in	r30, 0x3d	; 61
    873a:	fe b7       	in	r31, 0x3e	; 62
    873c:	31 96       	adiw	r30, 0x01	; 1
    873e:	ad b7       	in	r26, 0x3d	; 61
    8740:	be b7       	in	r27, 0x3e	; 62
    8742:	12 96       	adiw	r26, 0x02	; 2
    8744:	fc 92       	st	X, r15
    8746:	ee 92       	st	-X, r14
    8748:	11 97       	sbiw	r26, 0x01	; 1
    874a:	8c e6       	ldi	r24, 0x6C	; 108
    874c:	96 e0       	ldi	r25, 0x06	; 6
    874e:	93 83       	std	Z+3, r25	; 0x03
    8750:	82 83       	std	Z+2, r24	; 0x02
    8752:	15 83       	std	Z+5, r17	; 0x05
    8754:	04 83       	std	Z+4, r16	; 0x04
    8756:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		 if (strlen(strPValue)<12)AddZeroLead(strPValue,12);
    875a:	f7 01       	movw	r30, r14
    875c:	01 90       	ld	r0, Z+
    875e:	00 20       	and	r0, r0
    8760:	e9 f7       	brne	.-6      	; 0x875c <SetTotalizerData+0x74>
    8762:	31 97       	sbiw	r30, 0x01	; 1
    8764:	ee 19       	sub	r30, r14
    8766:	ff 09       	sbc	r31, r15
    8768:	6d b7       	in	r22, 0x3d	; 61
    876a:	7e b7       	in	r23, 0x3e	; 62
    876c:	6a 5f       	subi	r22, 0xFA	; 250
    876e:	7f 4f       	sbci	r23, 0xFF	; 255
    8770:	0f b6       	in	r0, 0x3f	; 63
    8772:	f8 94       	cli
    8774:	7e bf       	out	0x3e, r23	; 62
    8776:	0f be       	out	0x3f, r0	; 63
    8778:	6d bf       	out	0x3d, r22	; 61
    877a:	3c 97       	sbiw	r30, 0x0c	; 12
    877c:	a0 f4       	brcc	.+40     	; 0x87a6 <SetTotalizerData+0xbe>
    877e:	c7 01       	movw	r24, r14
    8780:	6c e0       	ldi	r22, 0x0C	; 12
    8782:	0e 94 ab 24 	call	0x4956	; 0x4956 <AddZeroLead>
    8786:	0f c0       	rjmp	.+30     	; 0x87a6 <SetTotalizerData+0xbe>
    8788:	8a 2f       	mov	r24, r26
    878a:	8c 50       	subi	r24, 0x0C	; 12
    878c:	f8 01       	movw	r30, r16
    878e:	e8 0f       	add	r30, r24
    8790:	f1 1d       	adc	r31, r1
    8792:	d7 01       	movw	r26, r14
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8794:	9e 01       	movw	r18, r28
    8796:	2d 5e       	subi	r18, 0xED	; 237
    8798:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    879a:	81 91       	ld	r24, Z+
    879c:	8d 93       	st	X+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    879e:	a2 17       	cp	r26, r18
    87a0:	b3 07       	cpc	r27, r19
    87a2:	d9 f7       	brne	.-10     	; 0x879a <SetTotalizerData+0xb2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    87a4:	1b 8a       	std	Y+19, r1	; 0x13
	 else {//Lebih dari 8: 0123456789
	     Idx=strlen(strValue)-12;
	     StrPosCopy(strValue,strPValue,Idx,12);
	 }

	 iPumpAddr=(xPumpAddr&0x0F);
    87a6:	0b 2d       	mov	r16, r11
    87a8:	0f 70       	andi	r16, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    87aa:	1a 2d       	mov	r17, r10
    87ac:	11 50       	subi	r17, 0x01	; 1
    87ae:	16 30       	cpi	r17, 0x06	; 6
    87b0:	08 f0       	brcs	.+2      	; 0x87b4 <SetTotalizerData+0xcc>
    87b2:	10 e0       	ldi	r17, 0x00	; 0
	     iGrade=xGradeAddr-1;
	 StrToRaw(strPValue,rawValue);
    87b4:	ce 01       	movw	r24, r28
    87b6:	07 96       	adiw	r24, 0x07	; 7
    87b8:	7e 01       	movw	r14, r28
    87ba:	08 94       	sec
    87bc:	e1 1c       	adc	r14, r1
    87be:	f1 1c       	adc	r15, r1
    87c0:	b7 01       	movw	r22, r14
    87c2:	0e 94 8b 18 	call	0x3116	; 0x3116 <StrToRaw>

	 if (TType==TVOLUME)eeprom_write_block((const void*)&rawValue,(void*)&(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    87c6:	dd 20       	and	r13, r13
    87c8:	d9 f4       	brne	.+54     	; 0x8800 <SetTotalizerData+0x118>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    87ca:	84 e2       	ldi	r24, 0x24	; 36
    87cc:	08 9f       	mul	r16, r24
    87ce:	c0 01       	movw	r24, r0
    87d0:	11 24       	eor	r1, r1
    87d2:	4c 2d       	mov	r20, r12
    87d4:	50 e0       	ldi	r21, 0x00	; 0
    87d6:	20 e2       	ldi	r18, 0x20	; 32
    87d8:	31 e0       	ldi	r19, 0x01	; 1
    87da:	d9 01       	movw	r26, r18
    87dc:	4a 9f       	mul	r20, r26
    87de:	90 01       	movw	r18, r0
    87e0:	4b 9f       	mul	r20, r27
    87e2:	30 0d       	add	r19, r0
    87e4:	5a 9f       	mul	r21, r26
    87e6:	30 0d       	add	r19, r0
    87e8:	11 24       	eor	r1, r1
    87ea:	82 0f       	add	r24, r18
    87ec:	93 1f       	adc	r25, r19
    87ee:	26 e0       	ldi	r18, 0x06	; 6
    87f0:	12 9f       	mul	r17, r18
    87f2:	90 01       	movw	r18, r0
    87f4:	11 24       	eor	r1, r1
    87f6:	82 0f       	add	r24, r18
    87f8:	93 1f       	adc	r25, r19
    87fa:	8e 50       	subi	r24, 0x0E	; 14
    87fc:	9c 4f       	sbci	r25, 0xFC	; 252
    87fe:	1d c0       	rjmp	.+58     	; 0x883a <SetTotalizerData+0x152>
	 else 
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    8800:	b1 e0       	ldi	r27, 0x01	; 1
    8802:	db 16       	cp	r13, r27
    8804:	09 f5       	brne	.+66     	; 0x8848 <SetTotalizerData+0x160>
    8806:	84 e2       	ldi	r24, 0x24	; 36
    8808:	08 9f       	mul	r16, r24
    880a:	c0 01       	movw	r24, r0
    880c:	11 24       	eor	r1, r1
    880e:	4c 2d       	mov	r20, r12
    8810:	50 e0       	ldi	r21, 0x00	; 0
    8812:	20 e2       	ldi	r18, 0x20	; 32
    8814:	31 e0       	ldi	r19, 0x01	; 1
    8816:	b9 01       	movw	r22, r18
    8818:	46 9f       	mul	r20, r22
    881a:	90 01       	movw	r18, r0
    881c:	47 9f       	mul	r20, r23
    881e:	30 0d       	add	r19, r0
    8820:	56 9f       	mul	r21, r22
    8822:	30 0d       	add	r19, r0
    8824:	11 24       	eor	r1, r1
    8826:	82 0f       	add	r24, r18
    8828:	93 1f       	adc	r25, r19
    882a:	26 e0       	ldi	r18, 0x06	; 6
    882c:	12 9f       	mul	r17, r18
    882e:	90 01       	movw	r18, r0
    8830:	11 24       	eor	r1, r1
    8832:	82 0f       	add	r24, r18
    8834:	93 1f       	adc	r25, r19
    8836:	8e 5c       	subi	r24, 0xCE	; 206
    8838:	99 4f       	sbci	r25, 0xF9	; 249
    883a:	b7 01       	movw	r22, r14
    883c:	46 e0       	ldi	r20, 0x06	; 6
    883e:	50 e0       	ldi	r21, 0x00	; 0
    8840:	24 eb       	ldi	r18, 0xB4	; 180
    8842:	32 e1       	ldi	r19, 0x12	; 18
    8844:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
}
    8848:	65 96       	adiw	r28, 0x15	; 21
    884a:	0f b6       	in	r0, 0x3f	; 63
    884c:	f8 94       	cli
    884e:	de bf       	out	0x3e, r29	; 62
    8850:	0f be       	out	0x3f, r0	; 63
    8852:	cd bf       	out	0x3d, r28	; 61
    8854:	cf 91       	pop	r28
    8856:	df 91       	pop	r29
    8858:	1f 91       	pop	r17
    885a:	0f 91       	pop	r16
    885c:	ff 90       	pop	r15
    885e:	ef 90       	pop	r14
    8860:	df 90       	pop	r13
    8862:	cf 90       	pop	r12
    8864:	bf 90       	pop	r11
    8866:	af 90       	pop	r10
    8868:	08 95       	ret

0000886a <SaveTotalizerCurrentToLast>:
	 }Dest[12]=0;
}

//SetTotalizerData(TVOLUME,TOTALIZER_NOW,1,1,strVolume)

void SaveTotalizerCurrentToLast(){
    886a:	4f 92       	push	r4
    886c:	5f 92       	push	r5
    886e:	7f 92       	push	r7
    8870:	8f 92       	push	r8
    8872:	9f 92       	push	r9
    8874:	af 92       	push	r10
    8876:	bf 92       	push	r11
    8878:	cf 92       	push	r12
    887a:	df 92       	push	r13
    887c:	ef 92       	push	r14
    887e:	ff 92       	push	r15
    8880:	0f 93       	push	r16
    8882:	1f 93       	push	r17
    8884:	df 93       	push	r29
    8886:	cf 93       	push	r28
    8888:	cd b7       	in	r28, 0x3d	; 61
    888a:	de b7       	in	r29, 0x3e	; 62
    888c:	2f 97       	sbiw	r28, 0x0f	; 15
    888e:	0f b6       	in	r0, 0x3f	; 63
    8890:	f8 94       	cli
    8892:	de bf       	out	0x3e, r29	; 62
    8894:	0f be       	out	0x3f, r0	; 63
    8896:	cd bf       	out	0x3d, r28	; 61
    8898:	77 24       	eor	r7, r7
    889a:	73 94       	inc	r7
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    889c:	4e 01       	movw	r8, r28
    889e:	08 94       	sec
    88a0:	81 1c       	adc	r8, r1
    88a2:	91 1c       	adc	r9, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    88a4:	90 e1       	ldi	r25, 0x10	; 16
    88a6:	49 2e       	mov	r4, r25
    88a8:	51 2c       	mov	r5, r1
    88aa:	4c 0e       	add	r4, r28
    88ac:	5d 1e       	adc	r5, r29
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    88ae:	87 2d       	mov	r24, r7
    88b0:	0e 94 bd 1a 	call	0x357a	; 0x357a <GetFIPAddr>
		  if (FIPAddr>0){
    88b4:	88 23       	and	r24, r24
    88b6:	91 f1       	breq	.+100    	; 0x891c <SaveTotalizerCurrentToLast+0xb2>
		      FIPAddr=FIPAddr-1;
    88b8:	a8 2e       	mov	r10, r24
    88ba:	aa 94       	dec	r10
    88bc:	bb 24       	eor	r11, r11
    88be:	b3 94       	inc	r11
    88c0:	2a c0       	rjmp	.+84     	; 0x8916 <SaveTotalizerCurrentToLast+0xac>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    88c2:	f7 01       	movw	r30, r14
    88c4:	11 92       	st	Z+, r1
    88c6:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    88c8:	e4 15       	cp	r30, r4
    88ca:	f5 05       	cpc	r31, r5
    88cc:	d1 f7       	brne	.-12     	; 0x88c2 <SaveTotalizerCurrentToLast+0x58>
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    88ce:	80 e0       	ldi	r24, 0x00	; 0
    88d0:	61 e0       	ldi	r22, 0x01	; 1
    88d2:	4a 2d       	mov	r20, r10
    88d4:	2b 2d       	mov	r18, r11
    88d6:	84 01       	movw	r16, r8
    88d8:	0e 94 84 1b 	call	0x3708	; 0x3708 <GetTotalizerData>
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    88dc:	80 e0       	ldi	r24, 0x00	; 0
    88de:	60 e0       	ldi	r22, 0x00	; 0
    88e0:	4a 2d       	mov	r20, r10
    88e2:	2b 2d       	mov	r18, r11
    88e4:	0e 94 74 43 	call	0x86e8	; 0x86e8 <SetTotalizerData>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    88e8:	f6 01       	movw	r30, r12
    88ea:	11 92       	st	Z+, r1
    88ec:	6f 01       	movw	r12, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    88ee:	ee 15       	cp	r30, r14
    88f0:	ff 05       	cpc	r31, r15
    88f2:	d1 f7       	brne	.-12     	; 0x88e8 <SaveTotalizerCurrentToLast+0x7e>
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    88f4:	81 e0       	ldi	r24, 0x01	; 1
    88f6:	61 e0       	ldi	r22, 0x01	; 1
    88f8:	4a 2d       	mov	r20, r10
    88fa:	2b 2d       	mov	r18, r11
    88fc:	84 01       	movw	r16, r8
    88fe:	0e 94 84 1b 	call	0x3708	; 0x3708 <GetTotalizerData>
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    8902:	81 e0       	ldi	r24, 0x01	; 1
    8904:	60 e0       	ldi	r22, 0x00	; 0
    8906:	4a 2d       	mov	r20, r10
    8908:	2b 2d       	mov	r18, r11
    890a:	0e 94 74 43 	call	0x86e8	; 0x86e8 <SetTotalizerData>
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    890e:	b3 94       	inc	r11
    8910:	f7 e0       	ldi	r31, 0x07	; 7
    8912:	bf 16       	cp	r11, r31
    8914:	19 f0       	breq	.+6      	; 0x891c <SaveTotalizerCurrentToLast+0xb2>
    8916:	64 01       	movw	r12, r8
    8918:	74 01       	movw	r14, r8
    891a:	d3 cf       	rjmp	.-90     	; 0x88c2 <SaveTotalizerCurrentToLast+0x58>
void SaveTotalizerCurrentToLast(){
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
    891c:	73 94       	inc	r7
    891e:	81 e1       	ldi	r24, 0x11	; 17
    8920:	78 16       	cp	r7, r24
    8922:	29 f6       	brne	.-118    	; 0x88ae <SaveTotalizerCurrentToLast+0x44>
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    8924:	2f 96       	adiw	r28, 0x0f	; 15
    8926:	0f b6       	in	r0, 0x3f	; 63
    8928:	f8 94       	cli
    892a:	de bf       	out	0x3e, r29	; 62
    892c:	0f be       	out	0x3f, r0	; 63
    892e:	cd bf       	out	0x3d, r28	; 61
    8930:	cf 91       	pop	r28
    8932:	df 91       	pop	r29
    8934:	1f 91       	pop	r17
    8936:	0f 91       	pop	r16
    8938:	ff 90       	pop	r15
    893a:	ef 90       	pop	r14
    893c:	df 90       	pop	r13
    893e:	cf 90       	pop	r12
    8940:	bf 90       	pop	r11
    8942:	af 90       	pop	r10
    8944:	9f 90       	pop	r9
    8946:	8f 90       	pop	r8
    8948:	7f 90       	pop	r7
    894a:	5f 90       	pop	r5
    894c:	4f 90       	pop	r4
    894e:	08 95       	ret

00008950 <ResetTotalizer>:
}

//-------------------Totalizer-----------------------------------------
//TAddr{TOTALIZER_LAST,TOTALIZER_NOW}
//TType:{TNONE,TVOLUME,TMONEY};
void ResetTotalizer(char TAddr){//Clear All TotalizerData;
    8950:	af 92       	push	r10
    8952:	bf 92       	push	r11
    8954:	cf 92       	push	r12
    8956:	df 92       	push	r13
    8958:	ef 92       	push	r14
    895a:	ff 92       	push	r15
    895c:	0f 93       	push	r16
    895e:	1f 93       	push	r17
    8960:	df 93       	push	r29
    8962:	cf 93       	push	r28
    8964:	cd b7       	in	r28, 0x3d	; 61
    8966:	de b7       	in	r29, 0x3e	; 62
    8968:	29 97       	sbiw	r28, 0x09	; 9
    896a:	0f b6       	in	r0, 0x3f	; 63
    896c:	f8 94       	cli
    896e:	de bf       	out	0x3e, r29	; 62
    8970:	0f be       	out	0x3f, r0	; 63
    8972:	cd bf       	out	0x3d, r28	; 61
    8974:	a8 2e       	mov	r10, r24
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
    8976:	00 d0       	rcall	.+0      	; 0x8978 <ResetTotalizer+0x28>
    8978:	00 d0       	rcall	.+0      	; 0x897a <ResetTotalizer+0x2a>
    897a:	6e 01       	movw	r12, r28
    897c:	08 94       	sec
    897e:	c1 1c       	adc	r12, r1
    8980:	d1 1c       	adc	r13, r1
    8982:	ed b7       	in	r30, 0x3d	; 61
    8984:	fe b7       	in	r31, 0x3e	; 62
    8986:	d2 82       	std	Z+2, r13	; 0x02
    8988:	c1 82       	std	Z+1, r12	; 0x01
    898a:	8f e6       	ldi	r24, 0x6F	; 111
    898c:	96 e0       	ldi	r25, 0x06	; 6
    898e:	94 83       	std	Z+4, r25	; 0x04
    8990:	83 83       	std	Z+3, r24	; 0x03
    8992:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    8996:	ee 24       	eor	r14, r14
    8998:	e3 94       	inc	r14
    899a:	0f 90       	pop	r0
    899c:	0f 90       	pop	r0
    899e:	0f 90       	pop	r0
    89a0:	0f 90       	pop	r0
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    89a2:	8e 2d       	mov	r24, r14
    89a4:	0e 94 bd 1a 	call	0x357a	; 0x357a <GetFIPAddr>
		  if (FIPAddr>0){
    89a8:	88 23       	and	r24, r24
    89aa:	a9 f0       	breq	.+42     	; 0x89d6 <ResetTotalizer+0x86>
		      FIPAddr=FIPAddr-1;
    89ac:	b8 2e       	mov	r11, r24
    89ae:	ba 94       	dec	r11
    89b0:	ff 24       	eor	r15, r15
    89b2:	f3 94       	inc	r15
			  for(iGrade=1;iGrade<=6;iGrade++){
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
    89b4:	80 e0       	ldi	r24, 0x00	; 0
    89b6:	6a 2d       	mov	r22, r10
    89b8:	4b 2d       	mov	r20, r11
    89ba:	2f 2d       	mov	r18, r15
    89bc:	86 01       	movw	r16, r12
    89be:	0e 94 74 43 	call	0x86e8	; 0x86e8 <SetTotalizerData>
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
    89c2:	81 e0       	ldi	r24, 0x01	; 1
    89c4:	6a 2d       	mov	r22, r10
    89c6:	4b 2d       	mov	r20, r11
    89c8:	2f 2d       	mov	r18, r15
    89ca:	0e 94 74 43 	call	0x86e8	; 0x86e8 <SetTotalizerData>
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    89ce:	f3 94       	inc	r15
    89d0:	f7 e0       	ldi	r31, 0x07	; 7
    89d2:	ff 16       	cp	r15, r31
    89d4:	79 f7       	brne	.-34     	; 0x89b4 <ResetTotalizer+0x64>
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
    89d6:	e3 94       	inc	r14
    89d8:	81 e1       	ldi	r24, 0x11	; 17
    89da:	e8 16       	cp	r14, r24
    89dc:	11 f7       	brne	.-60     	; 0x89a2 <ResetTotalizer+0x52>
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    89de:	29 96       	adiw	r28, 0x09	; 9
    89e0:	0f b6       	in	r0, 0x3f	; 63
    89e2:	f8 94       	cli
    89e4:	de bf       	out	0x3e, r29	; 62
    89e6:	0f be       	out	0x3f, r0	; 63
    89e8:	cd bf       	out	0x3d, r28	; 61
    89ea:	cf 91       	pop	r28
    89ec:	df 91       	pop	r29
    89ee:	1f 91       	pop	r17
    89f0:	0f 91       	pop	r16
    89f2:	ff 90       	pop	r15
    89f4:	ef 90       	pop	r14
    89f6:	df 90       	pop	r13
    89f8:	cf 90       	pop	r12
    89fa:	bf 90       	pop	r11
    89fc:	af 90       	pop	r10
    89fe:	08 95       	ret

00008a00 <procMessage21>:
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}

char procMessage21(){
    8a00:	af 92       	push	r10
    8a02:	bf 92       	push	r11
    8a04:	cf 92       	push	r12
    8a06:	df 92       	push	r13
    8a08:	ef 92       	push	r14
    8a0a:	ff 92       	push	r15
    8a0c:	0f 93       	push	r16
    8a0e:	1f 93       	push	r17
    8a10:	df 93       	push	r29
    8a12:	cf 93       	push	r28
    8a14:	cd b7       	in	r28, 0x3d	; 61
    8a16:	de b7       	in	r29, 0x3e	; 62
    8a18:	2b 97       	sbiw	r28, 0x0b	; 11
    8a1a:	0f b6       	in	r0, 0x3f	; 63
    8a1c:	f8 94       	cli
    8a1e:	de bf       	out	0x3e, r29	; 62
    8a20:	0f be       	out	0x3f, r0	; 63
    8a22:	cd bf       	out	0x3d, r28	; 61
    8a24:	09 e3       	ldi	r16, 0x39	; 57
    8a26:	11 e0       	ldi	r17, 0x01	; 1
    8a28:	3a e4       	ldi	r19, 0x4A	; 74
    8a2a:	e3 2e       	mov	r14, r19
    8a2c:	3b e0       	ldi	r19, 0x0B	; 11
    8a2e:	f3 2e       	mov	r15, r19
    8a30:	6e 01       	movw	r12, r28
    8a32:	08 94       	sec
    8a34:	c1 1c       	adc	r12, r1
    8a36:	d1 1c       	adc	r13, r1
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8a38:	2b e0       	ldi	r18, 0x0B	; 11
    8a3a:	a2 2e       	mov	r10, r18
    8a3c:	b1 2c       	mov	r11, r1
    8a3e:	ac 0e       	add	r10, r28
    8a40:	bd 1e       	adc	r11, r29
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}

char procMessage21(){
    8a42:	f6 01       	movw	r30, r12
    8a44:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8a46:	8d 91       	ld	r24, X+
    8a48:	81 93       	st	Z+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8a4a:	ea 15       	cp	r30, r10
    8a4c:	fb 05       	cpc	r31, r11
    8a4e:	d9 f7       	brne	.-10     	; 0x8a46 <procMessage21+0x46>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8a50:	1b 86       	std	Y+11, r1	; 0x0b
    8a52:	c8 01       	movw	r24, r16
    8a54:	b6 01       	movw	r22, r12
    8a56:	4b e0       	ldi	r20, 0x0B	; 11
    8a58:	50 e0       	ldi	r21, 0x00	; 0
    8a5a:	24 eb       	ldi	r18, 0xB4	; 180
    8a5c:	32 e1       	ldi	r19, 0x12	; 18
    8a5e:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    8a62:	05 5f       	subi	r16, 0xF5	; 245
    8a64:	1f 4f       	sbci	r17, 0xFF	; 255
    8a66:	8a e0       	ldi	r24, 0x0A	; 10
    8a68:	90 e0       	ldi	r25, 0x00	; 0
    8a6a:	e8 0e       	add	r14, r24
    8a6c:	f9 1e       	adc	r15, r25
}

char procMessage21(){
     char i,Result,strBankName[11];
	 Result=0;
	 for(i=0;i<4;i++){
    8a6e:	91 e0       	ldi	r25, 0x01	; 1
    8a70:	05 36       	cpi	r16, 0x65	; 101
    8a72:	19 07       	cpc	r17, r25
    8a74:	31 f7       	brne	.-52     	; 0x8a42 <procMessage21+0x42>
         StrPosCopy(rcv_trans,strBankName,(37+(i*10)),10);
		 //Result=((Result<<1)|SaveToEEPROM(strBankName,DefBankName[i],11)); 
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}
    8a76:	80 e0       	ldi	r24, 0x00	; 0
    8a78:	2b 96       	adiw	r28, 0x0b	; 11
    8a7a:	0f b6       	in	r0, 0x3f	; 63
    8a7c:	f8 94       	cli
    8a7e:	de bf       	out	0x3e, r29	; 62
    8a80:	0f be       	out	0x3f, r0	; 63
    8a82:	cd bf       	out	0x3d, r28	; 61
    8a84:	cf 91       	pop	r28
    8a86:	df 91       	pop	r29
    8a88:	1f 91       	pop	r17
    8a8a:	0f 91       	pop	r16
    8a8c:	ff 90       	pop	r15
    8a8e:	ef 90       	pop	r14
    8a90:	df 90       	pop	r13
    8a92:	cf 90       	pop	r12
    8a94:	bf 90       	pop	r11
    8a96:	af 90       	pop	r10
    8a98:	08 95       	ret

00008a9a <SaveToEEPROM>:
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}

char SaveToEEPROM(char *Src,char *Dest,unsigned int Length){
    8a9a:	ef 92       	push	r14
    8a9c:	ff 92       	push	r15
    8a9e:	0f 93       	push	r16
    8aa0:	1f 93       	push	r17
    8aa2:	df 93       	push	r29
    8aa4:	cf 93       	push	r28
    8aa6:	cd b7       	in	r28, 0x3d	; 61
    8aa8:	de b7       	in	r29, 0x3e	; 62
    8aaa:	ac 97       	sbiw	r28, 0x2c	; 44
    8aac:	0f b6       	in	r0, 0x3f	; 63
    8aae:	f8 94       	cli
    8ab0:	de bf       	out	0x3e, r29	; 62
    8ab2:	0f be       	out	0x3f, r0	; 63
    8ab4:	cd bf       	out	0x3d, r28	; 61
    8ab6:	9a a7       	std	Y+42, r25	; 0x2a
    8ab8:	89 a7       	std	Y+41, r24	; 0x29
    8aba:	7c a7       	std	Y+44, r23	; 0x2c
    8abc:	6b a7       	std	Y+43, r22	; 0x2b
    8abe:	7a 01       	movw	r14, r20
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8ac0:	8e 01       	movw	r16, r28
    8ac2:	05 5d       	subi	r16, 0xD5	; 213
    8ac4:	1f 4f       	sbci	r17, 0xFF	; 255
    8ac6:	c8 01       	movw	r24, r16
    8ac8:	be 01       	movw	r22, r28
    8aca:	6f 5f       	subi	r22, 0xFF	; 255
    8acc:	7f 4f       	sbci	r23, 0xFF	; 255
    8ace:	2c ea       	ldi	r18, 0xAC	; 172
    8ad0:	32 e1       	ldi	r19, 0x12	; 18
    8ad2:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8ad6:	c8 01       	movw	r24, r16
    8ad8:	be 01       	movw	r22, r28
    8ada:	67 5d       	subi	r22, 0xD7	; 215
    8adc:	7f 4f       	sbci	r23, 0xFF	; 255
    8ade:	a7 01       	movw	r20, r14
    8ae0:	24 eb       	ldi	r18, 0xB4	; 180
    8ae2:	32 e1       	ldi	r19, 0x12	; 18
    8ae4:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
     char strCompare[40];
	 //Read Previous Data
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}
    8ae8:	ac 96       	adiw	r28, 0x2c	; 44
    8aea:	0f b6       	in	r0, 0x3f	; 63
    8aec:	f8 94       	cli
    8aee:	de bf       	out	0x3e, r29	; 62
    8af0:	0f be       	out	0x3f, r0	; 63
    8af2:	cd bf       	out	0x3d, r28	; 61
    8af4:	cf 91       	pop	r28
    8af6:	df 91       	pop	r29
    8af8:	1f 91       	pop	r17
    8afa:	0f 91       	pop	r16
    8afc:	ff 90       	pop	r15
    8afe:	ef 90       	pop	r14
    8b00:	08 95       	ret

00008b02 <_menu_pumpprodinput>:
//**********************************************************************
// subrutin merubah produk
// parameter di simpan di __pump_prod
//**********************************************************************

void _menu_pumpprodinput(unsigned char __select){
    8b02:	8f 92       	push	r8
    8b04:	9f 92       	push	r9
    8b06:	af 92       	push	r10
    8b08:	bf 92       	push	r11
    8b0a:	cf 92       	push	r12
    8b0c:	df 92       	push	r13
    8b0e:	ef 92       	push	r14
    8b10:	ff 92       	push	r15
    8b12:	0f 93       	push	r16
    8b14:	1f 93       	push	r17
    8b16:	df 93       	push	r29
    8b18:	cf 93       	push	r28
    8b1a:	cd b7       	in	r28, 0x3d	; 61
    8b1c:	de b7       	in	r29, 0x3e	; 62
    8b1e:	a7 97       	sbiw	r28, 0x27	; 39
    8b20:	0f b6       	in	r0, 0x3f	; 63
    8b22:	f8 94       	cli
    8b24:	de bf       	out	0x3e, r29	; 62
    8b26:	0f be       	out	0x3f, r0	; 63
    8b28:	cd bf       	out	0x3d, r28	; 61
    8b2a:	b8 2e       	mov	r11, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8b2c:	8e 01       	movw	r16, r28
    8b2e:	04 5f       	subi	r16, 0xF4	; 244
    8b30:	1f 4f       	sbci	r17, 0xFF	; 255
    8b32:	c8 01       	movw	r24, r16
    8b34:	65 e4       	ldi	r22, 0x45	; 69
    8b36:	70 e0       	ldi	r23, 0x00	; 0
    8b38:	48 e0       	ldi	r20, 0x08	; 8
    8b3a:	50 e0       	ldi	r21, 0x00	; 0
    8b3c:	2c ea       	ldi	r18, 0xAC	; 172
    8b3e:	32 e1       	ldi	r19, 0x12	; 18
    8b40:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
	char 			__pump_prod[6],__pump_id[8];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];

	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	eeprom_read_block((void*) &__pump_prod, (const void*) &DefNozzleMap[__select], 6);
    8b44:	86 e0       	ldi	r24, 0x06	; 6
    8b46:	b8 9e       	mul	r11, r24
    8b48:	40 01       	movw	r8, r0
    8b4a:	11 24       	eor	r1, r1
    8b4c:	85 e5       	ldi	r24, 0x55	; 85
    8b4e:	90 e0       	ldi	r25, 0x00	; 0
    8b50:	88 0e       	add	r8, r24
    8b52:	99 1e       	adc	r9, r25
    8b54:	e6 e0       	ldi	r30, 0x06	; 6
    8b56:	ce 2e       	mov	r12, r30
    8b58:	d1 2c       	mov	r13, r1
    8b5a:	cc 0e       	add	r12, r28
    8b5c:	dd 1e       	adc	r13, r29
    8b5e:	c6 01       	movw	r24, r12
    8b60:	b4 01       	movw	r22, r8
    8b62:	46 e0       	ldi	r20, 0x06	; 6
    8b64:	50 e0       	ldi	r21, 0x00	; 0
    8b66:	2c ea       	ldi	r18, 0xAC	; 172
    8b68:	32 e1       	ldi	r19, 0x12	; 18
    8b6a:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>

	lcd_clear();_delay_ms(10);
    8b6e:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    8b72:	84 ec       	ldi	r24, 0xC4	; 196
    8b74:	99 e0       	ldi	r25, 0x09	; 9
    8b76:	01 97       	sbiw	r24, 0x01	; 1
    8b78:	f1 f7       	brne	.-4      	; 0x8b76 <_menu_pumpprodinput+0x74>
    sprintf_P(lcdteks, PSTR("Product FIP%.2d"),__pump_id[__select]);
    8b7a:	00 d0       	rcall	.+0      	; 0x8b7c <_menu_pumpprodinput+0x7a>
    8b7c:	00 d0       	rcall	.+0      	; 0x8b7e <_menu_pumpprodinput+0x7c>
    8b7e:	00 d0       	rcall	.+0      	; 0x8b80 <_menu_pumpprodinput+0x7e>
    8b80:	ed b7       	in	r30, 0x3d	; 61
    8b82:	fe b7       	in	r31, 0x3e	; 62
    8b84:	31 96       	adiw	r30, 0x01	; 1
    8b86:	74 e1       	ldi	r23, 0x14	; 20
    8b88:	e7 2e       	mov	r14, r23
    8b8a:	f1 2c       	mov	r15, r1
    8b8c:	ec 0e       	add	r14, r28
    8b8e:	fd 1e       	adc	r15, r29
    8b90:	ad b7       	in	r26, 0x3d	; 61
    8b92:	be b7       	in	r27, 0x3e	; 62
    8b94:	12 96       	adiw	r26, 0x02	; 2
    8b96:	fc 92       	st	X, r15
    8b98:	ee 92       	st	-X, r14
    8b9a:	11 97       	sbiw	r26, 0x01	; 1
    8b9c:	86 e2       	ldi	r24, 0x26	; 38
    8b9e:	9d e0       	ldi	r25, 0x0D	; 13
    8ba0:	93 83       	std	Z+3, r25	; 0x03
    8ba2:	82 83       	std	Z+2, r24	; 0x02
    8ba4:	0b 0d       	add	r16, r11
    8ba6:	11 1d       	adc	r17, r1
    8ba8:	d8 01       	movw	r26, r16
    8baa:	8c 91       	ld	r24, X
    8bac:	84 83       	std	Z+4, r24	; 0x04
    8bae:	15 82       	std	Z+5, r1	; 0x05
    8bb0:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    lcd_print(1, 1,lcdteks);
    8bb4:	ed b7       	in	r30, 0x3d	; 61
    8bb6:	fe b7       	in	r31, 0x3e	; 62
    8bb8:	36 96       	adiw	r30, 0x06	; 6
    8bba:	0f b6       	in	r0, 0x3f	; 63
    8bbc:	f8 94       	cli
    8bbe:	fe bf       	out	0x3e, r31	; 62
    8bc0:	0f be       	out	0x3f, r0	; 63
    8bc2:	ed bf       	out	0x3d, r30	; 61
    8bc4:	81 e0       	ldi	r24, 0x01	; 1
    8bc6:	61 e0       	ldi	r22, 0x01	; 1
    8bc8:	a7 01       	movw	r20, r14
    8bca:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
    8bce:	82 e0       	ldi	r24, 0x02	; 2
    8bd0:	61 e0       	ldi	r22, 0x01	; 1
    8bd2:	42 e1       	ldi	r20, 0x12	; 18
    8bd4:	5d e0       	ldi	r21, 0x0D	; 13
    8bd6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
    8bda:	83 e0       	ldi	r24, 0x03	; 3
    8bdc:	61 e0       	ldi	r22, 0x01	; 1
    8bde:	4e ef       	ldi	r20, 0xFE	; 254
    8be0:	5c e0       	ldi	r21, 0x0C	; 12
    8be2:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));
    8be6:	84 e0       	ldi	r24, 0x04	; 4
    8be8:	61 e0       	ldi	r22, 0x01	; 1
    8bea:	49 ee       	ldi	r20, 0xE9	; 233
    8bec:	5c e0       	ldi	r21, 0x0C	; 12
    8bee:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
    8bf2:	6e ef       	ldi	r22, 0xFE	; 254
    8bf4:	e6 2e       	mov	r14, r22
    8bf6:	62 e0       	ldi	r22, 0x02	; 2
    8bf8:	f6 2e       	mov	r15, r22

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prodloc[__i][0]);
		__y = pgm_read_byte(&__prodloc[__i][1]);
		_f_inttostr(__buff, __pump_prod[__i]);
    8bfa:	5e 01       	movw	r10, r28
    8bfc:	08 94       	sec
    8bfe:	a1 1c       	adc	r10, r1
    8c00:	b1 1c       	adc	r11, r1
	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prodloc[__i][0]);
    8c02:	f7 01       	movw	r30, r14
    8c04:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__prodloc[__i][1]);
    8c06:	08 94       	sec
    8c08:	e1 1c       	adc	r14, r1
    8c0a:	f1 1c       	adc	r15, r1
    8c0c:	f7 01       	movw	r30, r14
    8c0e:	14 91       	lpm	r17, Z+
		_f_inttostr(__buff, __pump_prod[__i]);
    8c10:	d6 01       	movw	r26, r12
    8c12:	4d 91       	ld	r20, X+
    8c14:	6d 01       	movw	r12, r26
    8c16:	50 e0       	ldi	r21, 0x00	; 0
    8c18:	60 e0       	ldi	r22, 0x00	; 0
    8c1a:	70 e0       	ldi	r23, 0x00	; 0
    8c1c:	c5 01       	movw	r24, r10
    8c1e:	0e 94 1c 18 	call	0x3038	; 0x3038 <_f_inttostr>
		lcd_print(__x+1, __y, __buff);
    8c22:	80 2f       	mov	r24, r16
    8c24:	8f 5f       	subi	r24, 0xFF	; 255
    8c26:	61 2f       	mov	r22, r17
    8c28:	a5 01       	movw	r20, r10
    8c2a:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    8c2e:	08 94       	sec
    8c30:	e1 1c       	adc	r14, r1
    8c32:	f1 1c       	adc	r15, r1

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(__i = 0; __i < 6; __i++){
    8c34:	ba e0       	ldi	r27, 0x0A	; 10
    8c36:	eb 16       	cp	r14, r27
    8c38:	b3 e0       	ldi	r27, 0x03	; 3
    8c3a:	fb 06       	cpc	r15, r27
    8c3c:	11 f7       	brne	.-60     	; 0x8c02 <_menu_pumpprodinput+0x100>
		if(__key == _KEY_ENTER){
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
			if(__pump_prod[__num - '1'] == 6)
    8c3e:	56 e0       	ldi	r21, 0x06	; 6
    8c40:	c5 2e       	mov	r12, r21
    8c42:	d1 2c       	mov	r13, r1
    8c44:	cc 0e       	add	r12, r28
    8c46:	dd 1e       	adc	r13, r29
			else
				__pump_prod[__num - '1']++;

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
			_f_inttostr(__buff, __pump_prod[__num - 0x31]);
    8c48:	7e 01       	movw	r14, r28
    8c4a:	08 94       	sec
    8c4c:	e1 1c       	adc	r14, r1
    8c4e:	f1 1c       	adc	r15, r1
		lcd_print(__x+1, __y, __buff);
	}

	while(1){
		
		__key = _key_scan(1);
    8c50:	81 e0       	ldi	r24, 0x01	; 1
    8c52:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    8c56:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    8c58:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
    8c5c:	98 2f       	mov	r25, r24
		if(__key == _KEY_CANCEL)
    8c5e:	17 3e       	cpi	r17, 0xE7	; 231
    8c60:	09 f4       	brne	.+2      	; 0x8c64 <_menu_pumpprodinput+0x162>
    8c62:	3c c0       	rjmp	.+120    	; 0x8cdc <_menu_pumpprodinput+0x1da>
			return;
		if(__key == _KEY_ENTER){
    8c64:	17 3b       	cpi	r17, 0xB7	; 183
    8c66:	59 f4       	brne	.+22     	; 0x8c7e <_menu_pumpprodinput+0x17c>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8c68:	c4 01       	movw	r24, r8
    8c6a:	be 01       	movw	r22, r28
    8c6c:	6a 5f       	subi	r22, 0xFA	; 250
    8c6e:	7f 4f       	sbci	r23, 0xFF	; 255
    8c70:	46 e0       	ldi	r20, 0x06	; 6
    8c72:	50 e0       	ldi	r21, 0x00	; 0
    8c74:	24 eb       	ldi	r18, 0xB4	; 180
    8c76:	32 e1       	ldi	r19, 0x12	; 18
    8c78:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    8c7c:	2f c0       	rjmp	.+94     	; 0x8cdc <_menu_pumpprodinput+0x1da>
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
    8c7e:	81 53       	subi	r24, 0x31	; 49
    8c80:	86 30       	cpi	r24, 0x06	; 6
    8c82:	30 f7       	brcc	.-52     	; 0x8c50 <_menu_pumpprodinput+0x14e>
			if(__pump_prod[__num - '1'] == 6)
    8c84:	a9 2f       	mov	r26, r25
    8c86:	b0 e0       	ldi	r27, 0x00	; 0
    8c88:	d1 97       	sbiw	r26, 0x31	; 49
    8c8a:	f6 01       	movw	r30, r12
    8c8c:	ea 0f       	add	r30, r26
    8c8e:	fb 1f       	adc	r31, r27
    8c90:	80 81       	ld	r24, Z
    8c92:	86 30       	cpi	r24, 0x06	; 6
    8c94:	11 f4       	brne	.+4      	; 0x8c9a <_menu_pumpprodinput+0x198>
				__pump_prod[__num - '1'] = 0;
    8c96:	10 82       	st	Z, r1
    8c98:	02 c0       	rjmp	.+4      	; 0x8c9e <_menu_pumpprodinput+0x19c>
			else
				__pump_prod[__num - '1']++;
    8c9a:	8f 5f       	subi	r24, 0xFF	; 255
    8c9c:	80 83       	st	Z, r24

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
    8c9e:	29 2f       	mov	r18, r25
    8ca0:	30 e0       	ldi	r19, 0x00	; 0
    8ca2:	21 53       	subi	r18, 0x31	; 49
    8ca4:	30 40       	sbci	r19, 0x00	; 0
    8ca6:	22 0f       	add	r18, r18
    8ca8:	33 1f       	adc	r19, r19
    8caa:	c9 01       	movw	r24, r18
    8cac:	82 50       	subi	r24, 0x02	; 2
    8cae:	9d 4f       	sbci	r25, 0xFD	; 253
    8cb0:	fc 01       	movw	r30, r24
    8cb2:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
    8cb4:	21 50       	subi	r18, 0x01	; 1
    8cb6:	3d 4f       	sbci	r19, 0xFD	; 253
    8cb8:	f9 01       	movw	r30, r18
    8cba:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __pump_prod[__num - 0x31]);
    8cbc:	ac 0d       	add	r26, r12
    8cbe:	bd 1d       	adc	r27, r13
    8cc0:	4c 91       	ld	r20, X
    8cc2:	50 e0       	ldi	r21, 0x00	; 0
    8cc4:	60 e0       	ldi	r22, 0x00	; 0
    8cc6:	70 e0       	ldi	r23, 0x00	; 0
    8cc8:	c7 01       	movw	r24, r14
    8cca:	0e 94 1c 18 	call	0x3038	; 0x3038 <_f_inttostr>
			lcd_print(__x+1, __y, __buff);
    8cce:	80 2f       	mov	r24, r16
    8cd0:	8f 5f       	subi	r24, 0xFF	; 255
    8cd2:	61 2f       	mov	r22, r17
    8cd4:	a7 01       	movw	r20, r14
    8cd6:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    8cda:	ba cf       	rjmp	.-140    	; 0x8c50 <_menu_pumpprodinput+0x14e>
		}
	}
}
    8cdc:	a7 96       	adiw	r28, 0x27	; 39
    8cde:	0f b6       	in	r0, 0x3f	; 63
    8ce0:	f8 94       	cli
    8ce2:	de bf       	out	0x3e, r29	; 62
    8ce4:	0f be       	out	0x3f, r0	; 63
    8ce6:	cd bf       	out	0x3d, r28	; 61
    8ce8:	cf 91       	pop	r28
    8cea:	df 91       	pop	r29
    8cec:	1f 91       	pop	r17
    8cee:	0f 91       	pop	r16
    8cf0:	ff 90       	pop	r15
    8cf2:	ef 90       	pop	r14
    8cf4:	df 90       	pop	r13
    8cf6:	cf 90       	pop	r12
    8cf8:	bf 90       	pop	r11
    8cfa:	af 90       	pop	r10
    8cfc:	9f 90       	pop	r9
    8cfe:	8f 90       	pop	r8
    8d00:	08 95       	ret

00008d02 <_menu_pumpprod>:
	       break;
	   }	   
	}
}

void _menu_pumpprod(void){
    8d02:	cf 93       	push	r28
    8d04:	df 93       	push	r29
    8d06:	c4 ec       	ldi	r28, 0xC4	; 196
    8d08:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;
	char __pump_id[8];
	while(1){
		lcd_clear();_delay_ms(10);
    8d0a:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    8d0e:	ce 01       	movw	r24, r28
    8d10:	01 97       	sbiw	r24, 0x01	; 1
    8d12:	f1 f7       	brne	.-4      	; 0x8d10 <_menu_pumpprod+0xe>
		_scr_pump();
    8d14:	0e 94 16 41 	call	0x822c	; 0x822c <_scr_pump>
		while(1){
			__key = _key_scan(1);
    8d18:	81 e0       	ldi	r24, 0x01	; 1
    8d1a:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
			if( __key == _KEY_1 || __key == _KEY_2 || __key == _KEY_3 ||
    8d1e:	8e 3e       	cpi	r24, 0xEE	; 238
    8d20:	71 f0       	breq	.+28     	; 0x8d3e <_menu_pumpprod+0x3c>
    8d22:	8e 3d       	cpi	r24, 0xDE	; 222
    8d24:	61 f0       	breq	.+24     	; 0x8d3e <_menu_pumpprod+0x3c>
    8d26:	8e 3b       	cpi	r24, 0xBE	; 190
    8d28:	51 f0       	breq	.+20     	; 0x8d3e <_menu_pumpprod+0x3c>
    8d2a:	8d 3e       	cpi	r24, 0xED	; 237
    8d2c:	41 f0       	breq	.+16     	; 0x8d3e <_menu_pumpprod+0x3c>
    8d2e:	8d 3d       	cpi	r24, 0xDD	; 221
    8d30:	31 f0       	breq	.+12     	; 0x8d3e <_menu_pumpprod+0x3c>
    8d32:	8d 3b       	cpi	r24, 0xBD	; 189
    8d34:	21 f0       	breq	.+8      	; 0x8d3e <_menu_pumpprod+0x3c>
    8d36:	8b 3e       	cpi	r24, 0xEB	; 235
    8d38:	11 f0       	breq	.+4      	; 0x8d3e <_menu_pumpprod+0x3c>
    8d3a:	8b 3d       	cpi	r24, 0xDB	; 219
    8d3c:	31 f4       	brne	.+12     	; 0x8d4a <_menu_pumpprod+0x48>
				__key == _KEY_4 || __key == _KEY_5 || __key == _KEY_6 ||
				__key == _KEY_7 || __key == _KEY_8){
				_menu_pumpprodinput(_key_btn(__key) - 0x31);
    8d3e:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
    8d42:	81 53       	subi	r24, 0x31	; 49
    8d44:	0e 94 81 45 	call	0x8b02	; 0x8b02 <_menu_pumpprodinput>
    8d48:	e0 cf       	rjmp	.-64     	; 0x8d0a <_menu_pumpprod+0x8>
				break;
			}
			if(__key == _KEY_CANCEL)
    8d4a:	87 3e       	cpi	r24, 0xE7	; 231
    8d4c:	29 f7       	brne	.-54     	; 0x8d18 <_menu_pumpprod+0x16>
				return;
		}
	}
}
    8d4e:	df 91       	pop	r29
    8d50:	cf 91       	pop	r28
    8d52:	08 95       	ret

00008d54 <FMenuPumpLabel>:
		       break;		         
	      }
	 }     
}

void FMenuPumpLabel(){
    8d54:	6f 92       	push	r6
    8d56:	7f 92       	push	r7
    8d58:	8f 92       	push	r8
    8d5a:	9f 92       	push	r9
    8d5c:	af 92       	push	r10
    8d5e:	bf 92       	push	r11
    8d60:	cf 92       	push	r12
    8d62:	df 92       	push	r13
    8d64:	ef 92       	push	r14
    8d66:	ff 92       	push	r15
    8d68:	1f 93       	push	r17
    8d6a:	df 93       	push	r29
    8d6c:	cf 93       	push	r28
    8d6e:	cd b7       	in	r28, 0x3d	; 61
    8d70:	de b7       	in	r29, 0x3e	; 62
    8d72:	2d 97       	sbiw	r28, 0x0d	; 13
    8d74:	0f b6       	in	r0, 0x3f	; 63
    8d76:	f8 94       	cli
    8d78:	de bf       	out	0x3e, r29	; 62
    8d7a:	0f be       	out	0x3f, r0	; 63
    8d7c:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8d7e:	86 e0       	ldi	r24, 0x06	; 6
    8d80:	c8 2e       	mov	r12, r24
    8d82:	d1 2c       	mov	r13, r1
    8d84:	cc 0e       	add	r12, r28
    8d86:	dd 1e       	adc	r13, r29
    8d88:	c6 01       	movw	r24, r12
    8d8a:	6d e4       	ldi	r22, 0x4D	; 77
    8d8c:	70 e0       	ldi	r23, 0x00	; 0
    8d8e:	48 e0       	ldi	r20, 0x08	; 8
    8d90:	50 e0       	ldi	r21, 0x00	; 0
    8d92:	2c ea       	ldi	r18, 0xAC	; 172
    8d94:	32 e1       	ldi	r19, 0x12	; 18
    8d96:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
	char PPumpLabel[8];
	unsigned char i, xPos,yPos,KeyPressed,KeyChar,strLabel[5];
	static char MaxCountId=16;

	eeprom_read_block((void*) &PPumpLabel, (const void*) &DefPumpLabel, 8);
	MaxCountId=99;
    8d9a:	83 e6       	ldi	r24, 0x63	; 99
    8d9c:	80 93 6b 01 	sts	0x016B, r24
	lcd_clear();_delay_ms(10);
    8da0:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    8da4:	84 ec       	ldi	r24, 0xC4	; 196
    8da6:	99 e0       	ldi	r25, 0x09	; 9
    8da8:	01 97       	sbiw	r24, 0x01	; 1
    8daa:	f1 f7       	brne	.-4      	; 0x8da8 <FMenuPumpLabel+0x54>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
    8dac:	81 e0       	ldi	r24, 0x01	; 1
    8dae:	61 e0       	ldi	r22, 0x01	; 1
    8db0:	41 e2       	ldi	r20, 0x21	; 33
    8db2:	5e e0       	ldi	r21, 0x0E	; 14
    8db4:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
    8db8:	82 e0       	ldi	r24, 0x02	; 2
    8dba:	61 e0       	ldi	r22, 0x01	; 1
    8dbc:	45 e1       	ldi	r20, 0x15	; 21
    8dbe:	5e e0       	ldi	r21, 0x0E	; 14
    8dc0:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
    8dc4:	83 e0       	ldi	r24, 0x03	; 3
    8dc6:	61 e0       	ldi	r22, 0x01	; 1
    8dc8:	40 e0       	ldi	r20, 0x00	; 0
    8dca:	5e e0       	ldi	r21, 0x0E	; 14
    8dcc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    8dd0:	84 e0       	ldi	r24, 0x04	; 4
    8dd2:	61 e0       	ldi	r22, 0x01	; 1
    8dd4:	4b ee       	ldi	r20, 0xEB	; 235
    8dd6:	5d e0       	ldi	r21, 0x0D	; 13
    8dd8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
    8ddc:	76 01       	movw	r14, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    8dde:	5e 01       	movw	r10, r28
    8de0:	08 94       	sec
    8de2:	a1 1c       	adc	r10, r1
    8de4:	b1 1c       	adc	r11, r1
    8de6:	16 ee       	ldi	r17, 0xE6	; 230
    8de8:	61 2e       	mov	r6, r17
    8dea:	1d e0       	ldi	r17, 0x0D	; 13
    8dec:	71 2e       	mov	r7, r17
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    8dee:	be e0       	ldi	r27, 0x0E	; 14
    8df0:	8b 2e       	mov	r8, r27
    8df2:	91 2c       	mov	r9, r1
    8df4:	8c 0e       	add	r8, r28
    8df6:	9d 1e       	adc	r9, r29
	MaxCountId=99;
	lcd_clear();_delay_ms(10);
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    8df8:	1e 2d       	mov	r17, r14
    8dfa:	1c 19       	sub	r17, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    8dfc:	00 d0       	rcall	.+0      	; 0x8dfe <FMenuPumpLabel+0xaa>
    8dfe:	00 d0       	rcall	.+0      	; 0x8e00 <FMenuPumpLabel+0xac>
    8e00:	00 d0       	rcall	.+0      	; 0x8e02 <FMenuPumpLabel+0xae>
    8e02:	ed b7       	in	r30, 0x3d	; 61
    8e04:	fe b7       	in	r31, 0x3e	; 62
    8e06:	31 96       	adiw	r30, 0x01	; 1
    8e08:	ad b7       	in	r26, 0x3d	; 61
    8e0a:	be b7       	in	r27, 0x3e	; 62
    8e0c:	12 96       	adiw	r26, 0x02	; 2
    8e0e:	bc 92       	st	X, r11
    8e10:	ae 92       	st	-X, r10
    8e12:	11 97       	sbiw	r26, 0x01	; 1
    8e14:	73 82       	std	Z+3, r7	; 0x03
    8e16:	62 82       	std	Z+2, r6	; 0x02
    8e18:	d7 01       	movw	r26, r14
    8e1a:	8d 91       	ld	r24, X+
    8e1c:	7d 01       	movw	r14, r26
    8e1e:	84 83       	std	Z+4, r24	; 0x04
    8e20:	15 82       	std	Z+5, r1	; 0x05
    8e22:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		xPos=1+(i%4);
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
    8e26:	ed b7       	in	r30, 0x3d	; 61
    8e28:	fe b7       	in	r31, 0x3e	; 62
    8e2a:	36 96       	adiw	r30, 0x06	; 6
    8e2c:	0f b6       	in	r0, 0x3f	; 63
    8e2e:	f8 94       	cli
    8e30:	fe bf       	out	0x3e, r31	; 62
    8e32:	0f be       	out	0x3f, r0	; 63
    8e34:	ed bf       	out	0x3d, r30	; 61
    8e36:	61 2f       	mov	r22, r17
    8e38:	66 95       	lsr	r22
    8e3a:	66 95       	lsr	r22
    8e3c:	66 0f       	add	r22, r22
    8e3e:	66 0f       	add	r22, r22
    8e40:	66 0f       	add	r22, r22
    8e42:	6b 5f       	subi	r22, 0xFB	; 251
    8e44:	13 70       	andi	r17, 0x03	; 3
    8e46:	81 2f       	mov	r24, r17
    8e48:	8f 5f       	subi	r24, 0xFF	; 255
    8e4a:	a5 01       	movw	r20, r10
    8e4c:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    8e50:	e8 14       	cp	r14, r8
    8e52:	f9 04       	cpc	r15, r9
    8e54:	89 f6       	brne	.-94     	; 0x8df8 <FMenuPumpLabel+0xa4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    8e56:	a6 e0       	ldi	r26, 0x06	; 6
    8e58:	ca 2e       	mov	r12, r26
    8e5a:	d1 2c       	mov	r13, r1
    8e5c:	cc 0e       	add	r12, r28
    8e5e:	dd 1e       	adc	r13, r29
			   PPumpLabel[i] = 0;
			else
			   PPumpLabel[i]++;
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    8e60:	7e 01       	movw	r14, r28
    8e62:	08 94       	sec
    8e64:	e1 1c       	adc	r14, r1
    8e66:	f1 1c       	adc	r15, r1
    8e68:	f1 ee       	ldi	r31, 0xE1	; 225
    8e6a:	af 2e       	mov	r10, r31
    8e6c:	fd e0       	ldi	r31, 0x0D	; 13
    8e6e:	bf 2e       	mov	r11, r31
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
	}

	while(1){
		KeyPressed = _key_scan(1);
    8e70:	81 e0       	ldi	r24, 0x01	; 1
    8e72:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    8e76:	18 2f       	mov	r17, r24
		KeyChar    = _key_btn(KeyPressed);
    8e78:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
		if(KeyPressed == _KEY_CANCEL)break;
    8e7c:	17 3e       	cpi	r17, 0xE7	; 231
    8e7e:	09 f4       	brne	.+2      	; 0x8e82 <FMenuPumpLabel+0x12e>
    8e80:	4b c0       	rjmp	.+150    	; 0x8f18 <FMenuPumpLabel+0x1c4>
		else
		if(KeyPressed == _KEY_ENTER){
    8e82:	17 3b       	cpi	r17, 0xB7	; 183
    8e84:	61 f4       	brne	.+24     	; 0x8e9e <FMenuPumpLabel+0x14a>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8e86:	8d e4       	ldi	r24, 0x4D	; 77
    8e88:	90 e0       	ldi	r25, 0x00	; 0
    8e8a:	be 01       	movw	r22, r28
    8e8c:	6a 5f       	subi	r22, 0xFA	; 250
    8e8e:	7f 4f       	sbci	r23, 0xFF	; 255
    8e90:	48 e0       	ldi	r20, 0x08	; 8
    8e92:	50 e0       	ldi	r21, 0x00	; 0
    8e94:	24 eb       	ldi	r18, 0xB4	; 180
    8e96:	32 e1       	ldi	r19, 0x12	; 18
    8e98:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    8e9c:	3d c0       	rjmp	.+122    	; 0x8f18 <FMenuPumpLabel+0x1c4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
    8e9e:	18 2f       	mov	r17, r24
    8ea0:	11 53       	subi	r17, 0x31	; 49
    8ea2:	18 30       	cpi	r17, 0x08	; 8
    8ea4:	28 f7       	brcc	.-54     	; 0x8e70 <FMenuPumpLabel+0x11c>
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    8ea6:	a1 2f       	mov	r26, r17
    8ea8:	b0 e0       	ldi	r27, 0x00	; 0
    8eaa:	f6 01       	movw	r30, r12
    8eac:	ea 0f       	add	r30, r26
    8eae:	fb 1f       	adc	r31, r27
    8eb0:	90 81       	ld	r25, Z
    8eb2:	80 91 6b 01 	lds	r24, 0x016B
    8eb6:	98 17       	cp	r25, r24
    8eb8:	11 f4       	brne	.+4      	; 0x8ebe <FMenuPumpLabel+0x16a>
			   PPumpLabel[i] = 0;
    8eba:	10 82       	st	Z, r1
    8ebc:	02 c0       	rjmp	.+4      	; 0x8ec2 <FMenuPumpLabel+0x16e>
			else
			   PPumpLabel[i]++;
    8ebe:	9f 5f       	subi	r25, 0xFF	; 255
    8ec0:	90 83       	st	Z, r25
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    8ec2:	00 d0       	rcall	.+0      	; 0x8ec4 <FMenuPumpLabel+0x170>
    8ec4:	00 d0       	rcall	.+0      	; 0x8ec6 <FMenuPumpLabel+0x172>
    8ec6:	00 d0       	rcall	.+0      	; 0x8ec8 <FMenuPumpLabel+0x174>
    8ec8:	2d b7       	in	r18, 0x3d	; 61
    8eca:	3e b7       	in	r19, 0x3e	; 62
    8ecc:	2f 5f       	subi	r18, 0xFF	; 255
    8ece:	3f 4f       	sbci	r19, 0xFF	; 255
    8ed0:	ed b7       	in	r30, 0x3d	; 61
    8ed2:	fe b7       	in	r31, 0x3e	; 62
    8ed4:	f2 82       	std	Z+2, r15	; 0x02
    8ed6:	e1 82       	std	Z+1, r14	; 0x01
    8ed8:	f9 01       	movw	r30, r18
    8eda:	b3 82       	std	Z+3, r11	; 0x03
    8edc:	a2 82       	std	Z+2, r10	; 0x02
    8ede:	ac 0d       	add	r26, r12
    8ee0:	bd 1d       	adc	r27, r13
    8ee2:	8c 91       	ld	r24, X
    8ee4:	84 83       	std	Z+4, r24	; 0x04
    8ee6:	15 82       	std	Z+5, r1	; 0x05
    8ee8:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
            lcd_print(xPos,yPos,strLabel);
    8eec:	8d b7       	in	r24, 0x3d	; 61
    8eee:	9e b7       	in	r25, 0x3e	; 62
    8ef0:	06 96       	adiw	r24, 0x06	; 6
    8ef2:	0f b6       	in	r0, 0x3f	; 63
    8ef4:	f8 94       	cli
    8ef6:	9e bf       	out	0x3e, r25	; 62
    8ef8:	0f be       	out	0x3f, r0	; 63
    8efa:	8d bf       	out	0x3d, r24	; 61
    8efc:	61 2f       	mov	r22, r17
    8efe:	66 95       	lsr	r22
    8f00:	66 95       	lsr	r22
    8f02:	66 0f       	add	r22, r22
    8f04:	66 0f       	add	r22, r22
    8f06:	66 0f       	add	r22, r22
    8f08:	6b 5f       	subi	r22, 0xFB	; 251
    8f0a:	13 70       	andi	r17, 0x03	; 3
    8f0c:	81 2f       	mov	r24, r17
    8f0e:	8f 5f       	subi	r24, 0xFF	; 255
    8f10:	a7 01       	movw	r20, r14
    8f12:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    8f16:	ac cf       	rjmp	.-168    	; 0x8e70 <FMenuPumpLabel+0x11c>
		}
	}
}
    8f18:	2d 96       	adiw	r28, 0x0d	; 13
    8f1a:	0f b6       	in	r0, 0x3f	; 63
    8f1c:	f8 94       	cli
    8f1e:	de bf       	out	0x3e, r29	; 62
    8f20:	0f be       	out	0x3f, r0	; 63
    8f22:	cd bf       	out	0x3d, r28	; 61
    8f24:	cf 91       	pop	r28
    8f26:	df 91       	pop	r29
    8f28:	1f 91       	pop	r17
    8f2a:	ff 90       	pop	r15
    8f2c:	ef 90       	pop	r14
    8f2e:	df 90       	pop	r13
    8f30:	cf 90       	pop	r12
    8f32:	bf 90       	pop	r11
    8f34:	af 90       	pop	r10
    8f36:	9f 90       	pop	r9
    8f38:	8f 90       	pop	r8
    8f3a:	7f 90       	pop	r7
    8f3c:	6f 90       	pop	r6
    8f3e:	08 95       	ret

00008f40 <GenerateTransactionNum>:
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    8f40:	cf 92       	push	r12
    8f42:	df 92       	push	r13
    8f44:	ef 92       	push	r14
    8f46:	ff 92       	push	r15
    8f48:	0f 93       	push	r16
    8f4a:	1f 93       	push	r17
    8f4c:	df 93       	push	r29
    8f4e:	cf 93       	push	r28
    8f50:	cd b7       	in	r28, 0x3d	; 61
    8f52:	de b7       	in	r29, 0x3e	; 62
    8f54:	27 97       	sbiw	r28, 0x07	; 7
    8f56:	0f b6       	in	r0, 0x3f	; 63
    8f58:	f8 94       	cli
    8f5a:	de bf       	out	0x3e, r29	; 62
    8f5c:	0f be       	out	0x3f, r0	; 63
    8f5e:	cd bf       	out	0x3d, r28	; 61
    8f60:	6c 01       	movw	r12, r24
    8f62:	fe 01       	movw	r30, r28
    8f64:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8f66:	ce 01       	movw	r24, r28
    8f68:	08 96       	adiw	r24, 0x08	; 8
	     strMemory[i]=data;
    8f6a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8f6c:	e8 17       	cp	r30, r24
    8f6e:	f9 07       	cpc	r31, r25
    8f70:	e1 f7       	brne	.-8      	; 0x8f6a <GenerateTransactionNum+0x2a>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8f72:	8e 01       	movw	r16, r28
    8f74:	0f 5f       	subi	r16, 0xFF	; 255
    8f76:	1f 4f       	sbci	r17, 0xFF	; 255
    8f78:	c8 01       	movw	r24, r16
    8f7a:	68 e6       	ldi	r22, 0x68	; 104
    8f7c:	71 e0       	ldi	r23, 0x01	; 1
    8f7e:	47 e0       	ldi	r20, 0x07	; 7
    8f80:	50 e0       	ldi	r21, 0x00	; 0
    8f82:	2c ea       	ldi	r18, 0xAC	; 172
    8f84:	32 e1       	ldi	r19, 0x12	; 18
    8f86:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
     char i,PTransNum[7],cNum,xNum=0,xAdd=0,Length=0;
	 FillChar(PTransNum,sizeof(PTransNum),0);//"999999"->"000000"
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);
    8f8a:	f8 01       	movw	r30, r16
    8f8c:	01 90       	ld	r0, Z+
    8f8e:	00 20       	and	r0, r0
    8f90:	e9 f7       	brne	.-6      	; 0x8f8c <GenerateTransactionNum+0x4c>
    8f92:	31 97       	sbiw	r30, 0x01	; 1
    8f94:	e0 1b       	sub	r30, r16
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    8f96:	f0 e0       	ldi	r31, 0x00	; 0
    8f98:	0e 0f       	add	r16, r30
    8f9a:	1f 1f       	adc	r17, r31
    8f9c:	31 97       	sbiw	r30, 0x01	; 1
    8f9e:	76 01       	movw	r14, r12
    8fa0:	ee 0e       	add	r14, r30
    8fa2:	ff 1e       	adc	r15, r31
    8fa4:	31 96       	adiw	r30, 0x01	; 1
    8fa6:	61 e0       	ldi	r22, 0x01	; 1
    8fa8:	19 c0       	rjmp	.+50     	; 0x8fdc <GenerateTransactionNum+0x9c>
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
	     xNum=PTransNum[Length-i-1]-'0';		 
		 cNum='0'+((xNum+xAdd)%10);
    8faa:	d8 01       	movw	r26, r16
    8fac:	2c 91       	ld	r18, X
    8fae:	20 53       	subi	r18, 0x30	; 48
    8fb0:	30 e0       	ldi	r19, 0x00	; 0
    8fb2:	26 0f       	add	r18, r22
    8fb4:	31 1d       	adc	r19, r1
    8fb6:	c9 01       	movw	r24, r18
    8fb8:	6a e0       	ldi	r22, 0x0A	; 10
    8fba:	70 e0       	ldi	r23, 0x00	; 0
    8fbc:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    8fc0:	48 2f       	mov	r20, r24
    8fc2:	40 5d       	subi	r20, 0xD0	; 208
		 xAdd=((xNum+xAdd)/10);
    8fc4:	c9 01       	movw	r24, r18
    8fc6:	6a e0       	ldi	r22, 0x0A	; 10
    8fc8:	70 e0       	ldi	r23, 0x00	; 0
    8fca:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
		 PTransNum[Length-i-1]=cNum;
    8fce:	d8 01       	movw	r26, r16
    8fd0:	4c 93       	st	X, r20
		 sTransNumber[Length-i-1]=cNum;
    8fd2:	d7 01       	movw	r26, r14
    8fd4:	4c 93       	st	X, r20
    8fd6:	08 94       	sec
    8fd8:	e1 08       	sbc	r14, r1
    8fda:	f1 08       	sbc	r15, r1
    8fdc:	01 50       	subi	r16, 0x01	; 1
    8fde:	10 40       	sbci	r17, 0x00	; 0
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
    8fe0:	0c 17       	cp	r16, r28
    8fe2:	1d 07       	cpc	r17, r29
    8fe4:	11 f7       	brne	.-60     	; 0x8faa <GenerateTransactionNum+0x6a>
		 cNum='0'+((xNum+xAdd)%10);
		 xAdd=((xNum+xAdd)/10);
		 PTransNum[Length-i-1]=cNum;
		 sTransNumber[Length-i-1]=cNum;
	 }
	 sTransNumber[Length]=0;
    8fe6:	ce 0e       	add	r12, r30
    8fe8:	df 1e       	adc	r13, r31
    8fea:	d6 01       	movw	r26, r12
    8fec:	1c 92       	st	X, r1
	 PTransNum[Length]=0;
    8fee:	be 01       	movw	r22, r28
    8ff0:	6f 5f       	subi	r22, 0xFF	; 255
    8ff2:	7f 4f       	sbci	r23, 0xFF	; 255
    8ff4:	e6 0f       	add	r30, r22
    8ff6:	f7 1f       	adc	r31, r23
    8ff8:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8ffa:	88 e6       	ldi	r24, 0x68	; 104
    8ffc:	91 e0       	ldi	r25, 0x01	; 1
    8ffe:	47 e0       	ldi	r20, 0x07	; 7
    9000:	50 e0       	ldi	r21, 0x00	; 0
    9002:	24 eb       	ldi	r18, 0xB4	; 180
    9004:	32 e1       	ldi	r19, 0x12	; 18
    9006:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}
    900a:	27 96       	adiw	r28, 0x07	; 7
    900c:	0f b6       	in	r0, 0x3f	; 63
    900e:	f8 94       	cli
    9010:	de bf       	out	0x3e, r29	; 62
    9012:	0f be       	out	0x3f, r0	; 63
    9014:	cd bf       	out	0x3d, r28	; 61
    9016:	cf 91       	pop	r28
    9018:	df 91       	pop	r29
    901a:	1f 91       	pop	r17
    901c:	0f 91       	pop	r16
    901e:	ff 90       	pop	r15
    9020:	ef 90       	pop	r14
    9022:	df 90       	pop	r13
    9024:	cf 90       	pop	r12
    9026:	08 95       	ret

00009028 <_c_pumpmap>:
			__string[__length] = '\0';
		}
	}
}

void _c_pumpmap(void){
    9028:	0f 93       	push	r16
    902a:	1f 93       	push	r17
    902c:	df 93       	push	r29
    902e:	cf 93       	push	r28
    9030:	cd b7       	in	r28, 0x3d	; 61
    9032:	de b7       	in	r29, 0x3e	; 62
    9034:	28 97       	sbiw	r28, 0x08	; 8
    9036:	0f b6       	in	r0, 0x3f	; 63
    9038:	f8 94       	cli
    903a:	de bf       	out	0x3e, r29	; 62
    903c:	0f be       	out	0x3f, r0	; 63
    903e:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9040:	8e 01       	movw	r16, r28
    9042:	0f 5f       	subi	r16, 0xFF	; 255
    9044:	1f 4f       	sbci	r17, 0xFF	; 255
    9046:	c8 01       	movw	r24, r16
    9048:	65 e4       	ldi	r22, 0x45	; 69
    904a:	70 e0       	ldi	r23, 0x00	; 0
    904c:	48 e0       	ldi	r20, 0x08	; 8
    904e:	50 e0       	ldi	r21, 0x00	; 0
    9050:	2c ea       	ldi	r18, 0xAC	; 172
    9052:	32 e1       	ldi	r19, 0x12	; 18
    9054:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
	unsigned char __buff[8];

	eeprom_read_block((void*) &__buff, (const void*) &DefPumpMap, 8);
	_spi_txnum(_PUMP_DEF, _SPI_SLAVE, __buff, 8);
    9058:	8a ec       	ldi	r24, 0xCA	; 202
    905a:	61 e0       	ldi	r22, 0x01	; 1
    905c:	a8 01       	movw	r20, r16
    905e:	28 e0       	ldi	r18, 0x08	; 8
    9060:	0e 94 7d b0 	call	0x160fa	; 0x160fa <_spi_txnum>
}
    9064:	28 96       	adiw	r28, 0x08	; 8
    9066:	0f b6       	in	r0, 0x3f	; 63
    9068:	f8 94       	cli
    906a:	de bf       	out	0x3e, r29	; 62
    906c:	0f be       	out	0x3f, r0	; 63
    906e:	cd bf       	out	0x3d, r28	; 61
    9070:	cf 91       	pop	r28
    9072:	df 91       	pop	r29
    9074:	1f 91       	pop	r17
    9076:	0f 91       	pop	r16
    9078:	08 95       	ret

0000907a <_f_punctuation>:
				__string[__i++] = 0x30;
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}
void _f_punctuation(char* __string, unsigned char __mode, unsigned char __length, unsigned char __decimal){
    907a:	bf 92       	push	r11
    907c:	cf 92       	push	r12
    907e:	df 92       	push	r13
    9080:	ef 92       	push	r14
    9082:	ff 92       	push	r15
    9084:	0f 93       	push	r16
    9086:	1f 93       	push	r17
    9088:	df 93       	push	r29
    908a:	cf 93       	push	r28
    908c:	cd b7       	in	r28, 0x3d	; 61
    908e:	de b7       	in	r29, 0x3e	; 62
    9090:	2f 97       	sbiw	r28, 0x0f	; 15
    9092:	0f b6       	in	r0, 0x3f	; 63
    9094:	f8 94       	cli
    9096:	de bf       	out	0x3e, r29	; 62
    9098:	0f be       	out	0x3f, r0	; 63
    909a:	cd bf       	out	0x3d, r28	; 61
    909c:	8c 01       	movw	r16, r24
    909e:	c6 2e       	mov	r12, r22
    90a0:	d4 2e       	mov	r13, r20
    90a2:	62 2f       	mov	r22, r18
	char __buff[15] = {"000000000000000"};
    90a4:	de 01       	movw	r26, r28
    90a6:	11 96       	adiw	r26, 0x01	; 1
    90a8:	e0 e0       	ldi	r30, 0x00	; 0
    90aa:	f1 e0       	ldi	r31, 0x01	; 1
    90ac:	8f e0       	ldi	r24, 0x0F	; 15
    90ae:	01 90       	ld	r0, Z+
    90b0:	0d 92       	st	X+, r0
    90b2:	81 50       	subi	r24, 0x01	; 1
    90b4:	e1 f7       	brne	.-8      	; 0x90ae <_f_punctuation+0x34>
	char  __point = 0,  __len;
	unsigned char __i, __ii,__counter = 0;

	__len = strlen(__string);
    90b6:	f8 01       	movw	r30, r16
    90b8:	01 90       	ld	r0, Z+
    90ba:	00 20       	and	r0, r0
    90bc:	e9 f7       	brne	.-6      	; 0x90b8 <_f_punctuation+0x3e>
    90be:	31 97       	sbiw	r30, 0x01	; 1
    90c0:	3e 2f       	mov	r19, r30
    90c2:	30 1b       	sub	r19, r16
	if(__mode == 0){
    90c4:	cc 20       	and	r12, r12
    90c6:	11 f5       	brne	.+68     	; 0x910c <_f_punctuation+0x92>
		__buff[__length] = '\0';
    90c8:	8d 2d       	mov	r24, r13
    90ca:	90 e0       	ldi	r25, 0x00	; 0
    90cc:	fe 01       	movw	r30, r28
    90ce:	e8 0f       	add	r30, r24
    90d0:	f9 1f       	adc	r31, r25
    90d2:	11 82       	std	Z+1, r1	; 0x01
		for(__i = __length, __ii = __len - 1; __i > (__length - __len); __i--, __ii--)
    90d4:	23 2f       	mov	r18, r19
    90d6:	21 50       	subi	r18, 0x01	; 1
    90d8:	4d 2d       	mov	r20, r13
    90da:	bc 01       	movw	r22, r24
    90dc:	63 1b       	sub	r22, r19
    90de:	71 09       	sbc	r23, r1
    90e0:	09 c0       	rjmp	.+18     	; 0x90f4 <_f_punctuation+0x7a>
			__buff[__i - 1] = __string[__ii];
    90e2:	ac 0f       	add	r26, r28
    90e4:	bd 1f       	adc	r27, r29
    90e6:	f8 01       	movw	r30, r16
    90e8:	e2 0f       	add	r30, r18
    90ea:	f1 1d       	adc	r31, r1
    90ec:	80 81       	ld	r24, Z
    90ee:	8c 93       	st	X, r24
	unsigned char __i, __ii,__counter = 0;

	__len = strlen(__string);
	if(__mode == 0){
		__buff[__length] = '\0';
		for(__i = __length, __ii = __len - 1; __i > (__length - __len); __i--, __ii--)
    90f0:	41 50       	subi	r20, 0x01	; 1
    90f2:	21 50       	subi	r18, 0x01	; 1
    90f4:	a4 2f       	mov	r26, r20
    90f6:	b0 e0       	ldi	r27, 0x00	; 0
    90f8:	6a 17       	cp	r22, r26
    90fa:	7b 07       	cpc	r23, r27
    90fc:	94 f3       	brlt	.-28     	; 0x90e2 <_f_punctuation+0x68>
			__buff[__i - 1] = __string[__ii];
		strcpy(__string, __buff);
    90fe:	c8 01       	movw	r24, r16
    9100:	be 01       	movw	r22, r28
    9102:	6f 5f       	subi	r22, 0xFF	; 255
    9104:	7f 4f       	sbci	r23, 0xFF	; 255
    9106:	0e 94 9c b4 	call	0x16938	; 0x16938 <strcpy>
    910a:	90 c0       	rjmp	.+288    	; 0x922c <_f_punctuation+0x1b2>
	}
	else{
		if(__decimal > 0){
    910c:	66 23       	and	r22, r22
    910e:	61 f1       	breq	.+88     	; 0x9168 <_f_punctuation+0xee>
    9110:	a3 2f       	mov	r26, r19
    9112:	b0 e0       	ldi	r27, 0x00	; 0
    9114:	11 97       	sbiw	r26, 0x01	; 1
    9116:	a0 0f       	add	r26, r16
    9118:	b1 1f       	adc	r27, r17
    911a:	90 e0       	ldi	r25, 0x00	; 0
    911c:	ae 01       	movw	r20, r28
    911e:	4f 5f       	subi	r20, 0xFF	; 255
    9120:	5f 4f       	sbci	r21, 0xFF	; 255
			for(__i = 0; __i < __decimal; __i++){
				if(__i < __len)
					__buff[__counter++] = __string[__len - 1 - __i];
				else
					__buff[__counter++] = '0';
    9122:	20 e3       	ldi	r18, 0x30	; 48
    9124:	0e c0       	rjmp	.+28     	; 0x9142 <_f_punctuation+0xc8>
    9126:	e9 2f       	mov	r30, r25
    9128:	f0 e0       	ldi	r31, 0x00	; 0
		strcpy(__string, __buff);
	}
	else{
		if(__decimal > 0){
			for(__i = 0; __i < __decimal; __i++){
				if(__i < __len)
    912a:	93 17       	cp	r25, r19
    912c:	28 f4       	brcc	.+10     	; 0x9138 <_f_punctuation+0xbe>
					__buff[__counter++] = __string[__len - 1 - __i];
    912e:	e4 0f       	add	r30, r20
    9130:	f5 1f       	adc	r31, r21
    9132:	8c 91       	ld	r24, X
    9134:	80 83       	st	Z, r24
    9136:	03 c0       	rjmp	.+6      	; 0x913e <_f_punctuation+0xc4>
				else
					__buff[__counter++] = '0';
    9138:	e4 0f       	add	r30, r20
    913a:	f5 1f       	adc	r31, r21
    913c:	20 83       	st	Z, r18
			__buff[__i - 1] = __string[__ii];
		strcpy(__string, __buff);
	}
	else{
		if(__decimal > 0){
			for(__i = 0; __i < __decimal; __i++){
    913e:	9f 5f       	subi	r25, 0xFF	; 255
    9140:	11 97       	sbiw	r26, 0x01	; 1
    9142:	96 17       	cp	r25, r22
    9144:	80 f3       	brcs	.-32     	; 0x9126 <_f_punctuation+0xac>
				if(__i < __len)
					__buff[__counter++] = __string[__len - 1 - __i];
				else
					__buff[__counter++] = '0';
			}
			__buff[__counter++] = ',';
    9146:	de 01       	movw	r26, r28
    9148:	11 96       	adiw	r26, 0x01	; 1
    914a:	fd 01       	movw	r30, r26
    914c:	e6 0f       	add	r30, r22
    914e:	f1 1d       	adc	r31, r1
    9150:	8c e2       	ldi	r24, 0x2C	; 44
    9152:	80 83       	st	Z, r24
    9154:	56 2f       	mov	r21, r22
    9156:	5f 5f       	subi	r21, 0xFF	; 255
		}
		if(__decimal > 0 && __len <= 2)
    9158:	33 30       	cpi	r19, 0x03	; 3
    915a:	48 f4       	brcc	.+18     	; 0x916e <_f_punctuation+0xf4>
			__buff[__counter++] = '0';
    915c:	a5 0f       	add	r26, r21
    915e:	b1 1d       	adc	r27, r1
    9160:	80 e3       	ldi	r24, 0x30	; 48
    9162:	8c 93       	st	X, r24
    9164:	5f 5f       	subi	r21, 0xFF	; 255
    9166:	32 c0       	rjmp	.+100    	; 0x91cc <_f_punctuation+0x152>
		else{
			if(__len > 1){
    9168:	32 30       	cpi	r19, 0x02	; 2
    916a:	68 f1       	brcs	.+90     	; 0x91c6 <_f_punctuation+0x14c>
    916c:	50 e0       	ldi	r21, 0x00	; 0
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
    916e:	31 50       	subi	r19, 0x01	; 1
    9170:	b3 2e       	mov	r11, r19
    9172:	b6 1a       	sub	r11, r22
    9174:	3f 5f       	subi	r19, 0xFF	; 255
    9176:	40 e0       	ldi	r20, 0x00	; 0
    9178:	70 e0       	ldi	r23, 0x00	; 0
    917a:	23 2f       	mov	r18, r19
    917c:	30 e0       	ldi	r19, 0x00	; 0
    917e:	26 1b       	sub	r18, r22
    9180:	31 09       	sbc	r19, r1
						__i++, __point++, __ii--){
					if(__point == 3){
						__point = 0;
						__buff[__counter++] = '.';
    9182:	7e 01       	movw	r14, r28
    9184:	08 94       	sec
    9186:	e1 1c       	adc	r14, r1
    9188:	f1 1c       	adc	r15, r1
    918a:	6e e2       	ldi	r22, 0x2E	; 46
    918c:	14 c0       	rjmp	.+40     	; 0x91b6 <_f_punctuation+0x13c>
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
						__i++, __point++, __ii--){
					if(__point == 3){
    918e:	73 30       	cpi	r23, 0x03	; 3
    9190:	31 f4       	brne	.+12     	; 0x919e <_f_punctuation+0x124>
						__point = 0;
						__buff[__counter++] = '.';
    9192:	f7 01       	movw	r30, r14
    9194:	e5 0f       	add	r30, r21
    9196:	f1 1d       	adc	r31, r1
    9198:	60 83       	st	Z, r22
    919a:	5f 5f       	subi	r21, 0xFF	; 255
    919c:	70 e0       	ldi	r23, 0x00	; 0
					}
					__buff[__counter++] = __string[__ii];
    919e:	f7 01       	movw	r30, r14
    91a0:	e5 0f       	add	r30, r21
    91a2:	f1 1d       	adc	r31, r1
    91a4:	c8 01       	movw	r24, r16
    91a6:	8a 0f       	add	r24, r26
    91a8:	91 1d       	adc	r25, r1
    91aa:	dc 01       	movw	r26, r24
    91ac:	8c 91       	ld	r24, X
    91ae:	80 83       	st	Z, r24
    91b0:	5f 5f       	subi	r21, 0xFF	; 255
		if(__decimal > 0 && __len <= 2)
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
						__i++, __point++, __ii--){
    91b2:	4f 5f       	subi	r20, 0xFF	; 255
    91b4:	7f 5f       	subi	r23, 0xFF	; 255
    91b6:	ab 2d       	mov	r26, r11
    91b8:	a4 1b       	sub	r26, r20
		}
		if(__decimal > 0 && __len <= 2)
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
    91ba:	84 2f       	mov	r24, r20
    91bc:	90 e0       	ldi	r25, 0x00	; 0
    91be:	82 17       	cp	r24, r18
    91c0:	93 07       	cpc	r25, r19
    91c2:	2c f3       	brlt	.-54     	; 0x918e <_f_punctuation+0x114>
    91c4:	03 c0       	rjmp	.+6      	; 0x91cc <_f_punctuation+0x152>
					}
					__buff[__counter++] = __string[__ii];
				}
			}
			else
				__buff[__counter++] = '0';
    91c6:	80 e3       	ldi	r24, 0x30	; 48
    91c8:	89 83       	std	Y+1, r24	; 0x01
    91ca:	51 e0       	ldi	r21, 0x01	; 1
		}
		if(__mode == 1){
    91cc:	91 e0       	ldi	r25, 0x01	; 1
    91ce:	c9 16       	cp	r12, r25
    91d0:	79 f4       	brne	.+30     	; 0x91f0 <_f_punctuation+0x176>
    91d2:	fe 01       	movw	r30, r28
    91d4:	31 96       	adiw	r30, 0x01	; 1
    91d6:	e5 0f       	add	r30, r21
    91d8:	f1 1d       	adc	r31, r1
    91da:	d8 01       	movw	r26, r16
    91dc:	02 c0       	rjmp	.+4      	; 0x91e2 <_f_punctuation+0x168>
			for(__i = 0; __i < __counter; __i++)
				__string[__i] = __buff[__counter - 1 - __i];
    91de:	80 81       	ld	r24, Z
    91e0:	8d 93       	st	X+, r24
    91e2:	31 97       	sbiw	r30, 0x01	; 1
			}
			else
				__buff[__counter++] = '0';
		}
		if(__mode == 1){
			for(__i = 0; __i < __counter; __i++)
    91e4:	ec 17       	cp	r30, r28
    91e6:	fd 07       	cpc	r31, r29
    91e8:	d1 f7       	brne	.-12     	; 0x91de <_f_punctuation+0x164>
				__string[__i] = __buff[__counter - 1 - __i];
			__string[__counter] = '\0';
    91ea:	05 0f       	add	r16, r21
    91ec:	11 1d       	adc	r17, r1
    91ee:	1c c0       	rjmp	.+56     	; 0x9228 <_f_punctuation+0x1ae>
		}
		if(__mode == 2){
    91f0:	f2 e0       	ldi	r31, 0x02	; 2
    91f2:	cf 16       	cp	r12, r31
    91f4:	d9 f4       	brne	.+54     	; 0x922c <_f_punctuation+0x1b2>
    91f6:	f8 01       	movw	r30, r16
    91f8:	80 e0       	ldi	r24, 0x00	; 0
			for(__i = 0; __i < __length; __i++)
				__string[__i] = 0x20;
    91fa:	90 e2       	ldi	r25, 0x20	; 32
    91fc:	02 c0       	rjmp	.+4      	; 0x9202 <_f_punctuation+0x188>
    91fe:	91 93       	st	Z+, r25
			for(__i = 0; __i < __counter; __i++)
				__string[__i] = __buff[__counter - 1 - __i];
			__string[__counter] = '\0';
		}
		if(__mode == 2){
			for(__i = 0; __i < __length; __i++)
    9200:	8f 5f       	subi	r24, 0xFF	; 255
    9202:	8d 15       	cp	r24, r13
    9204:	e0 f3       	brcs	.-8      	; 0x91fe <_f_punctuation+0x184>
				__string[__i] = 0x20;
			for(__i = 0, __ii = __length - 1; __i < __counter; __i++, __ii--)
    9206:	de 01       	movw	r26, r28
    9208:	11 96       	adiw	r26, 0x01	; 1
    920a:	9d 2d       	mov	r25, r13
    920c:	91 50       	subi	r25, 0x01	; 1
    920e:	29 2f       	mov	r18, r25
    9210:	25 1b       	sub	r18, r21
    9212:	06 c0       	rjmp	.+12     	; 0x9220 <_f_punctuation+0x1a6>
				__string[__ii] = __buff[__i];
    9214:	f8 01       	movw	r30, r16
    9216:	e9 0f       	add	r30, r25
    9218:	f1 1d       	adc	r31, r1
    921a:	8d 91       	ld	r24, X+
    921c:	80 83       	st	Z, r24
			__string[__counter] = '\0';
		}
		if(__mode == 2){
			for(__i = 0; __i < __length; __i++)
				__string[__i] = 0x20;
			for(__i = 0, __ii = __length - 1; __i < __counter; __i++, __ii--)
    921e:	91 50       	subi	r25, 0x01	; 1
    9220:	92 17       	cp	r25, r18
    9222:	c1 f7       	brne	.-16     	; 0x9214 <_f_punctuation+0x19a>
				__string[__ii] = __buff[__i];
			__string[__length] = '\0';
    9224:	0d 0d       	add	r16, r13
    9226:	11 1d       	adc	r17, r1
    9228:	f8 01       	movw	r30, r16
    922a:	10 82       	st	Z, r1
		}
	}
}
    922c:	2f 96       	adiw	r28, 0x0f	; 15
    922e:	0f b6       	in	r0, 0x3f	; 63
    9230:	f8 94       	cli
    9232:	de bf       	out	0x3e, r29	; 62
    9234:	0f be       	out	0x3f, r0	; 63
    9236:	cd bf       	out	0x3d, r28	; 61
    9238:	cf 91       	pop	r28
    923a:	df 91       	pop	r29
    923c:	1f 91       	pop	r17
    923e:	0f 91       	pop	r16
    9240:	ff 90       	pop	r15
    9242:	ef 90       	pop	r14
    9244:	df 90       	pop	r13
    9246:	cf 90       	pop	r12
    9248:	bf 90       	pop	r11
    924a:	08 95       	ret

0000924c <_menu_printer>:
}

//*************************************************************************
//  ngeset printer

void _menu_printer(void){
    924c:	2f 92       	push	r2
    924e:	3f 92       	push	r3
    9250:	4f 92       	push	r4
    9252:	5f 92       	push	r5
    9254:	6f 92       	push	r6
    9256:	7f 92       	push	r7
    9258:	8f 92       	push	r8
    925a:	9f 92       	push	r9
    925c:	af 92       	push	r10
    925e:	bf 92       	push	r11
    9260:	cf 92       	push	r12
    9262:	df 92       	push	r13
    9264:	ef 92       	push	r14
    9266:	ff 92       	push	r15
    9268:	0f 93       	push	r16
    926a:	1f 93       	push	r17
    926c:	df 93       	push	r29
    926e:	cf 93       	push	r28
    9270:	cd b7       	in	r28, 0x3d	; 61
    9272:	de b7       	in	r29, 0x3e	; 62
    9274:	2c 97       	sbiw	r28, 0x0c	; 12
    9276:	0f b6       	in	r0, 0x3f	; 63
    9278:	f8 94       	cli
    927a:	de bf       	out	0x3e, r29	; 62
    927c:	0f be       	out	0x3f, r0	; 63
    927e:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9280:	e1 99       	sbic	0x1c, 1	; 28
    9282:	fe cf       	rjmp	.-4      	; 0x9280 <_menu_printer+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9284:	80 e3       	ldi	r24, 0x30	; 48
    9286:	90 e0       	ldi	r25, 0x00	; 0
    9288:	9f bb       	out	0x1f, r25	; 31
    928a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    928c:	e0 9a       	sbi	0x1c, 0	; 28
    928e:	5d b3       	in	r21, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9290:	e1 99       	sbic	0x1c, 1	; 28
    9292:	fe cf       	rjmp	.-4      	; 0x9290 <_menu_printer+0x44>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9294:	e5 e3       	ldi	r30, 0x35	; 53
    9296:	f0 e0       	ldi	r31, 0x00	; 0
    9298:	ff bb       	out	0x1f, r31	; 31
    929a:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    929c:	e0 9a       	sbi	0x1c, 0	; 28
    929e:	4d b3       	in	r20, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    92a0:	e1 99       	sbic	0x1c, 1	; 28
    92a2:	fe cf       	rjmp	.-4      	; 0x92a0 <_menu_printer+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    92a4:	84 e3       	ldi	r24, 0x34	; 52
    92a6:	90 e0       	ldi	r25, 0x00	; 0
    92a8:	9f bb       	out	0x1f, r25	; 31
    92aa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    92ac:	e0 9a       	sbi	0x1c, 0	; 28
    92ae:	3d b3       	in	r19, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    92b0:	e1 99       	sbic	0x1c, 1	; 28
    92b2:	fe cf       	rjmp	.-4      	; 0x92b0 <_menu_printer+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    92b4:	e3 e3       	ldi	r30, 0x33	; 51
    92b6:	f0 e0       	ldi	r31, 0x00	; 0
    92b8:	ff bb       	out	0x1f, r31	; 31
    92ba:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    92bc:	e0 9a       	sbi	0x1c, 0	; 28
    92be:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    92c0:	e1 99       	sbic	0x1c, 1	; 28
    92c2:	fe cf       	rjmp	.-4      	; 0x92c0 <_menu_printer+0x74>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    92c4:	71 e3       	ldi	r23, 0x31	; 49
    92c6:	27 2e       	mov	r2, r23
    92c8:	70 e0       	ldi	r23, 0x00	; 0
    92ca:	37 2e       	mov	r3, r23
    92cc:	3f ba       	out	0x1f, r3	; 31
    92ce:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    92d0:	e0 9a       	sbi	0x1c, 0	; 28
    92d2:	9d b3       	in	r25, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    92d4:	e1 99       	sbic	0x1c, 1	; 28
    92d6:	fe cf       	rjmp	.-4      	; 0x92d4 <_menu_printer+0x88>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    92d8:	62 e3       	ldi	r22, 0x32	; 50
    92da:	46 2e       	mov	r4, r22
    92dc:	60 e0       	ldi	r22, 0x00	; 0
    92de:	56 2e       	mov	r5, r22
    92e0:	5f ba       	out	0x1f, r5	; 31
    92e2:	4e ba       	out	0x1e, r4	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    92e4:	e0 9a       	sbi	0x1c, 0	; 28
    92e6:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[6];
	char	__i, __x, __y, __lmt, __start, __key, __num, __buff[6];
//	char lcdteks[20];

	__value[0] = eeprom_read_byte(&DefPrinterType);
    92e8:	59 83       	std	Y+1, r21	; 0x01
	__value[1] = eeprom_read_byte(&__prt_papper);
    92ea:	4a 83       	std	Y+2, r20	; 0x02
	__value[2] = eeprom_read_byte(&__prt_logo);
    92ec:	3b 83       	std	Y+3, r19	; 0x03
	__value[3] = eeprom_read_byte(&__prt_autocut);
    92ee:	2c 83       	std	Y+4, r18	; 0x04
	__value[4] = eeprom_read_byte(&DefPrintScrollEnd);
    92f0:	9d 83       	std	Y+5, r25	; 0x05
	__value[5] = eeprom_read_byte(&DefPrintScrollSpace);
    92f2:	8e 83       	std	Y+6, r24	; 0x06

	lcd_clear();
    92f4:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
    92f8:	81 e0       	ldi	r24, 0x01	; 1
    92fa:	61 e0       	ldi	r22, 0x01	; 1
    92fc:	41 eb       	ldi	r20, 0xB1	; 177
    92fe:	5c e0       	ldi	r21, 0x0C	; 12
    9300:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
    9304:	82 e0       	ldi	r24, 0x02	; 2
    9306:	61 e0       	ldi	r22, 0x01	; 1
    9308:	4e e9       	ldi	r20, 0x9E	; 158
    930a:	5c e0       	ldi	r21, 0x0C	; 12
    930c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
    9310:	83 e0       	ldi	r24, 0x03	; 3
    9312:	61 e0       	ldi	r22, 0x01	; 1
    9314:	4e e8       	ldi	r20, 0x8E	; 142
    9316:	5c e0       	ldi	r21, 0x0C	; 12
    9318:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));
    931c:	84 e0       	ldi	r24, 0x04	; 4
    931e:	61 e0       	ldi	r22, 0x01	; 1
    9320:	4e e7       	ldi	r20, 0x7E	; 126
    9322:	5c e0       	ldi	r21, 0x0C	; 12
    9324:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
    9328:	04 e1       	ldi	r16, 0x14	; 20
    932a:	13 e0       	ldi	r17, 0x03	; 3
    932c:	4e 01       	movw	r8, r28
    932e:	08 94       	sec
    9330:	81 1c       	adc	r8, r1
    9332:	91 1c       	adc	r9, r1
    9334:	74 01       	movw	r14, r8

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
		__y = pgm_read_byte(&__prntloc[__i][1]);
		_f_inttostr(__buff, __value[__i]);
    9336:	37 e0       	ldi	r19, 0x07	; 7
    9338:	c3 2e       	mov	r12, r19
    933a:	d1 2c       	mov	r13, r1
    933c:	cc 0e       	add	r12, r28
    933e:	dd 1e       	adc	r13, r29
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
    9340:	f8 01       	movw	r30, r16
    9342:	a4 90       	lpm	r10, Z+
		__y = pgm_read_byte(&__prntloc[__i][1]);
    9344:	0f 5f       	subi	r16, 0xFF	; 255
    9346:	1f 4f       	sbci	r17, 0xFF	; 255
    9348:	f8 01       	movw	r30, r16
    934a:	b4 90       	lpm	r11, Z+
    934c:	01 50       	subi	r16, 0x01	; 1
    934e:	10 40       	sbci	r17, 0x00	; 0
		_f_inttostr(__buff, __value[__i]);
    9350:	f7 01       	movw	r30, r14
    9352:	40 81       	ld	r20, Z
    9354:	50 e0       	ldi	r21, 0x00	; 0
    9356:	60 e0       	ldi	r22, 0x00	; 0
    9358:	70 e0       	ldi	r23, 0x00	; 0
    935a:	c6 01       	movw	r24, r12
    935c:	0e 94 1c 18 	call	0x3038	; 0x3038 <_f_inttostr>
		if(__i == 4)_f_punctuation(__buff, 0, 2, 0);
    9360:	8e 2d       	mov	r24, r14
    9362:	88 19       	sub	r24, r8
    9364:	84 30       	cpi	r24, 0x04	; 4
    9366:	31 f4       	brne	.+12     	; 0x9374 <_menu_printer+0x128>
    9368:	c6 01       	movw	r24, r12
    936a:	60 e0       	ldi	r22, 0x00	; 0
    936c:	42 e0       	ldi	r20, 0x02	; 2
    936e:	20 e0       	ldi	r18, 0x00	; 0
    9370:	0e 94 3d 48 	call	0x907a	; 0x907a <_f_punctuation>
		lcd_print(__x, __y, __buff);
    9374:	8a 2d       	mov	r24, r10
    9376:	6b 2d       	mov	r22, r11
    9378:	a6 01       	movw	r20, r12
    937a:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    937e:	0e 5f       	subi	r16, 0xFE	; 254
    9380:	1f 4f       	sbci	r17, 0xFF	; 255
    9382:	08 94       	sec
    9384:	e1 1c       	adc	r14, r1
    9386:	f1 1c       	adc	r15, r1
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
    9388:	f3 e0       	ldi	r31, 0x03	; 3
    938a:	00 32       	cpi	r16, 0x20	; 32
    938c:	1f 07       	cpc	r17, r31
    938e:	c1 f6       	brne	.-80     	; 0x9340 <_menu_printer+0xf4>

		}
		if(__num >= 0x31 && __num <= 0x36){
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
			if(__value[__num - 0x31] == __lmt)
    9390:	3e 01       	movw	r6, r28
    9392:	08 94       	sec
    9394:	61 1c       	adc	r6, r1
    9396:	71 1c       	adc	r7, r1
				__value[__num - 0x31] = __start;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
			_f_inttostr(__buff, __value[__num - 0x31]);
    9398:	27 e0       	ldi	r18, 0x07	; 7
    939a:	c2 2e       	mov	r12, r18
    939c:	d1 2c       	mov	r13, r1
    939e:	cc 0e       	add	r12, r28
    93a0:	dd 1e       	adc	r13, r29
		__key = _key_scan(1);
		__num = _key_btn(__key);
		if(__key == _KEY_CANCEL)
			return;
		if(__key==_KEY_ENTER){
			eeprom_write_byte(&DefPrinterType, __value[0]);
    93a2:	89 80       	ldd	r8, Y+1	; 0x01
			eeprom_write_byte(&__prt_papper, __value[1]);
    93a4:	9a 80       	ldd	r9, Y+2	; 0x02
			eeprom_write_byte(&__prt_logo, __value[2]);
    93a6:	ab 80       	ldd	r10, Y+3	; 0x03
			eeprom_write_byte(&__prt_autocut, __value[3]);
    93a8:	bc 80       	ldd	r11, Y+4	; 0x04
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
    93aa:	ed 80       	ldd	r14, Y+5	; 0x05
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);
    93ac:	fe 80       	ldd	r15, Y+6	; 0x06
	}
    //sprintf_P(lcdteks,PSTR("6)Space :%.2d"),__value[5]);
	//lcd_print(2,10,lcdteks);

	while(1){	
		__key = _key_scan(1);
    93ae:	81 e0       	ldi	r24, 0x01	; 1
    93b0:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    93b4:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    93b6:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
    93ba:	08 2f       	mov	r16, r24
		if(__key == _KEY_CANCEL)
    93bc:	17 3e       	cpi	r17, 0xE7	; 231
    93be:	09 f4       	brne	.+2      	; 0x93c2 <_menu_printer+0x176>
    93c0:	85 c0       	rjmp	.+266    	; 0x94cc <_menu_printer+0x280>
			return;
		if(__key==_KEY_ENTER){
    93c2:	17 3b       	cpi	r17, 0xB7	; 183
    93c4:	09 f0       	breq	.+2      	; 0x93c8 <_menu_printer+0x17c>
    93c6:	44 c0       	rjmp	.+136    	; 0x9450 <_menu_printer+0x204>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    93c8:	e1 99       	sbic	0x1c, 1	; 28
    93ca:	fe cf       	rjmp	.-4      	; 0x93c8 <_menu_printer+0x17c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    93cc:	80 e3       	ldi	r24, 0x30	; 48
    93ce:	90 e0       	ldi	r25, 0x00	; 0
    93d0:	9f bb       	out	0x1f, r25	; 31
    93d2:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    93d4:	8d ba       	out	0x1d, r8	; 29

    __asm__ __volatile__ (
    93d6:	0f b6       	in	r0, 0x3f	; 63
    93d8:	f8 94       	cli
    93da:	e2 9a       	sbi	0x1c, 2	; 28
    93dc:	e1 9a       	sbi	0x1c, 1	; 28
    93de:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    93e0:	e1 99       	sbic	0x1c, 1	; 28
    93e2:	fe cf       	rjmp	.-4      	; 0x93e0 <_menu_printer+0x194>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    93e4:	e5 e3       	ldi	r30, 0x35	; 53
    93e6:	f0 e0       	ldi	r31, 0x00	; 0
    93e8:	ff bb       	out	0x1f, r31	; 31
    93ea:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    93ec:	9d ba       	out	0x1d, r9	; 29

    __asm__ __volatile__ (
    93ee:	0f b6       	in	r0, 0x3f	; 63
    93f0:	f8 94       	cli
    93f2:	e2 9a       	sbi	0x1c, 2	; 28
    93f4:	e1 9a       	sbi	0x1c, 1	; 28
    93f6:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    93f8:	e1 99       	sbic	0x1c, 1	; 28
    93fa:	fe cf       	rjmp	.-4      	; 0x93f8 <_menu_printer+0x1ac>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    93fc:	84 e3       	ldi	r24, 0x34	; 52
    93fe:	90 e0       	ldi	r25, 0x00	; 0
    9400:	9f bb       	out	0x1f, r25	; 31
    9402:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    9404:	ad ba       	out	0x1d, r10	; 29

    __asm__ __volatile__ (
    9406:	0f b6       	in	r0, 0x3f	; 63
    9408:	f8 94       	cli
    940a:	e2 9a       	sbi	0x1c, 2	; 28
    940c:	e1 9a       	sbi	0x1c, 1	; 28
    940e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9410:	e1 99       	sbic	0x1c, 1	; 28
    9412:	fe cf       	rjmp	.-4      	; 0x9410 <_menu_printer+0x1c4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9414:	e3 e3       	ldi	r30, 0x33	; 51
    9416:	f0 e0       	ldi	r31, 0x00	; 0
    9418:	ff bb       	out	0x1f, r31	; 31
    941a:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    941c:	bd ba       	out	0x1d, r11	; 29

    __asm__ __volatile__ (
    941e:	0f b6       	in	r0, 0x3f	; 63
    9420:	f8 94       	cli
    9422:	e2 9a       	sbi	0x1c, 2	; 28
    9424:	e1 9a       	sbi	0x1c, 1	; 28
    9426:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9428:	e1 99       	sbic	0x1c, 1	; 28
    942a:	fe cf       	rjmp	.-4      	; 0x9428 <_menu_printer+0x1dc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    942c:	3f ba       	out	0x1f, r3	; 31
    942e:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    9430:	ed ba       	out	0x1d, r14	; 29

    __asm__ __volatile__ (
    9432:	0f b6       	in	r0, 0x3f	; 63
    9434:	f8 94       	cli
    9436:	e2 9a       	sbi	0x1c, 2	; 28
    9438:	e1 9a       	sbi	0x1c, 1	; 28
    943a:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    943c:	e1 99       	sbic	0x1c, 1	; 28
    943e:	fe cf       	rjmp	.-4      	; 0x943c <_menu_printer+0x1f0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9440:	5f ba       	out	0x1f, r5	; 31
    9442:	4e ba       	out	0x1e, r4	; 30
#endif
    EEDR = __value;
    9444:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
    9446:	0f b6       	in	r0, 0x3f	; 63
    9448:	f8 94       	cli
    944a:	e2 9a       	sbi	0x1c, 2	; 28
    944c:	e1 9a       	sbi	0x1c, 1	; 28
    944e:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&__prt_autocut, __value[3]);
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);

		}
		if(__num >= 0x31 && __num <= 0x36){
    9450:	80 2f       	mov	r24, r16
    9452:	81 53       	subi	r24, 0x31	; 49
    9454:	86 30       	cpi	r24, 0x06	; 6
    9456:	08 f0       	brcs	.+2      	; 0x945a <_menu_printer+0x20e>
    9458:	aa cf       	rjmp	.-172    	; 0x93ae <_menu_printer+0x162>
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
    945a:	a0 2f       	mov	r26, r16
    945c:	b0 e0       	ldi	r27, 0x00	; 0
    945e:	d1 97       	sbiw	r26, 0x31	; 49
    9460:	fd 01       	movw	r30, r26
    9462:	e0 5e       	subi	r30, 0xE0	; 224
    9464:	fc 4f       	sbci	r31, 0xFC	; 252
    9466:	24 91       	lpm	r18, Z+
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
    9468:	fd 01       	movw	r30, r26
    946a:	ea 5d       	subi	r30, 0xDA	; 218
    946c:	fc 4f       	sbci	r31, 0xFC	; 252
    946e:	94 91       	lpm	r25, Z+
			if(__value[__num - 0x31] == __lmt)
    9470:	f3 01       	movw	r30, r6
    9472:	ea 0f       	add	r30, r26
    9474:	fb 1f       	adc	r31, r27
    9476:	80 81       	ld	r24, Z
    9478:	82 17       	cp	r24, r18
    947a:	11 f4       	brne	.+4      	; 0x9480 <_menu_printer+0x234>
				__value[__num - 0x31] = __start;
    947c:	90 83       	st	Z, r25
    947e:	02 c0       	rjmp	.+4      	; 0x9484 <_menu_printer+0x238>
			else
				__value[__num - 0x31]++;
    9480:	8f 5f       	subi	r24, 0xFF	; 255
    9482:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
    9484:	9d 01       	movw	r18, r26
    9486:	22 0f       	add	r18, r18
    9488:	33 1f       	adc	r19, r19
    948a:	c9 01       	movw	r24, r18
    948c:	8c 5e       	subi	r24, 0xEC	; 236
    948e:	9c 4f       	sbci	r25, 0xFC	; 252
    9490:	fc 01       	movw	r30, r24
    9492:	f4 90       	lpm	r15, Z+
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
    9494:	2b 5e       	subi	r18, 0xEB	; 235
    9496:	3c 4f       	sbci	r19, 0xFC	; 252
    9498:	f9 01       	movw	r30, r18
    949a:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __value[__num - 0x31]);
    949c:	a6 0d       	add	r26, r6
    949e:	b7 1d       	adc	r27, r7
    94a0:	4c 91       	ld	r20, X
    94a2:	50 e0       	ldi	r21, 0x00	; 0
    94a4:	60 e0       	ldi	r22, 0x00	; 0
    94a6:	70 e0       	ldi	r23, 0x00	; 0
    94a8:	c6 01       	movw	r24, r12
    94aa:	0e 94 1c 18 	call	0x3038	; 0x3038 <_f_inttostr>
			if((__num == 0x35)||(__num == 0x36))
    94ae:	05 53       	subi	r16, 0x35	; 53
    94b0:	02 30       	cpi	r16, 0x02	; 2
    94b2:	30 f4       	brcc	.+12     	; 0x94c0 <_menu_printer+0x274>
				_f_punctuation(__buff, 0, 2, 0);
    94b4:	c6 01       	movw	r24, r12
    94b6:	60 e0       	ldi	r22, 0x00	; 0
    94b8:	42 e0       	ldi	r20, 0x02	; 2
    94ba:	20 e0       	ldi	r18, 0x00	; 0
    94bc:	0e 94 3d 48 	call	0x907a	; 0x907a <_f_punctuation>
			lcd_print(__x, __y, __buff);
    94c0:	8f 2d       	mov	r24, r15
    94c2:	61 2f       	mov	r22, r17
    94c4:	a6 01       	movw	r20, r12
    94c6:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    94ca:	6b cf       	rjmp	.-298    	; 0x93a2 <_menu_printer+0x156>
		}
	}
}
    94cc:	2c 96       	adiw	r28, 0x0c	; 12
    94ce:	0f b6       	in	r0, 0x3f	; 63
    94d0:	f8 94       	cli
    94d2:	de bf       	out	0x3e, r29	; 62
    94d4:	0f be       	out	0x3f, r0	; 63
    94d6:	cd bf       	out	0x3d, r28	; 61
    94d8:	cf 91       	pop	r28
    94da:	df 91       	pop	r29
    94dc:	1f 91       	pop	r17
    94de:	0f 91       	pop	r16
    94e0:	ff 90       	pop	r15
    94e2:	ef 90       	pop	r14
    94e4:	df 90       	pop	r13
    94e6:	cf 90       	pop	r12
    94e8:	bf 90       	pop	r11
    94ea:	af 90       	pop	r10
    94ec:	9f 90       	pop	r9
    94ee:	8f 90       	pop	r8
    94f0:	7f 90       	pop	r7
    94f2:	6f 90       	pop	r6
    94f4:	5f 90       	pop	r5
    94f6:	4f 90       	pop	r4
    94f8:	3f 90       	pop	r3
    94fa:	2f 90       	pop	r2
    94fc:	08 95       	ret

000094fe <FSettingPrinter>:
char FSettingDatetime(){
     _menu_datetime();
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
    94fe:	0e 94 26 49 	call	0x924c	; 0x924c <_menu_printer>
	 return MENU_DONE;
}
    9502:	81 e0       	ldi	r24, 0x01	; 1
    9504:	08 95       	ret

00009506 <SendPrint>:
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}

void SendPrint(char xSend,char xSendLead){
    9506:	1f 93       	push	r17
    9508:	18 2f       	mov	r17, r24
static char zSend;     
	 if (xSend==0x19){
    950a:	89 31       	cpi	r24, 0x19	; 25
    950c:	59 f4       	brne	.+22     	; 0x9524 <SendPrint+0x1e>
	     if (zSend==xSendLead)_uart(_COM_PRINTER,1,xSendLead);
    950e:	40 91 a6 02 	lds	r20, 0x02A6
    9512:	46 17       	cp	r20, r22
    9514:	19 f4       	brne	.+6      	; 0x951c <SendPrint+0x16>
    9516:	80 e0       	ldi	r24, 0x00	; 0
    9518:	61 e0       	ldi	r22, 0x01	; 1
    951a:	07 c0       	rjmp	.+14     	; 0x952a <SendPrint+0x24>
		 else _uart(_COM_PRINTER,1,' ');	 
    951c:	80 e0       	ldi	r24, 0x00	; 0
    951e:	61 e0       	ldi	r22, 0x01	; 1
    9520:	40 e2       	ldi	r20, 0x20	; 32
    9522:	03 c0       	rjmp	.+6      	; 0x952a <SendPrint+0x24>
	 } 
	 else _uart(_COM_PRINTER,1,xSend);
    9524:	80 e0       	ldi	r24, 0x00	; 0
    9526:	61 e0       	ldi	r22, 0x01	; 1
    9528:	41 2f       	mov	r20, r17
    952a:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
	 zSend=xSend;
    952e:	10 93 a6 02 	sts	0x02A6, r17
}
    9532:	1f 91       	pop	r17
    9534:	08 95       	ret

00009536 <CarriegeReturn>:
	      break;	 
	 }
}

void CarriegeReturn(){
     _uart(_COM_PRINTER, 1, 0x0D);     
    9536:	80 e0       	ldi	r24, 0x00	; 0
    9538:	61 e0       	ldi	r22, 0x01	; 1
    953a:	4d e0       	ldi	r20, 0x0D	; 13
    953c:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
     _uart(_COM_PRINTER, 1, 0x0A);
    9540:	80 e0       	ldi	r24, 0x00	; 0
    9542:	61 e0       	ldi	r22, 0x01	; 1
    9544:	4a e0       	ldi	r20, 0x0A	; 10
    9546:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>

}
    954a:	08 95       	ret

0000954c <InitPrinter>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    954c:	e1 99       	sbic	0x1c, 1	; 28
    954e:	fe cf       	rjmp	.-4      	; 0x954c <InitPrinter>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9550:	80 e3       	ldi	r24, 0x30	; 48
    9552:	90 e0       	ldi	r25, 0x00	; 0
    9554:	9f bb       	out	0x1f, r25	; 31
    9556:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9558:	e0 9a       	sbi	0x1c, 0	; 28
    955a:	8d b3       	in	r24, 0x1d	; 29
void InitPrinter(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
    //Custom Printer TG02
	//Density Lowest: 1D 7C 00
	if (PrinterType==PT_CUSTOM_TG02){
    955c:	81 30       	cpi	r24, 0x01	; 1
    955e:	71 f5       	brne	.+92     	; 0x95bc <InitPrinter+0x70>
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x7C);_uart(_COM_PRINTER, 1, 0x00);
    9560:	80 e0       	ldi	r24, 0x00	; 0
    9562:	61 e0       	ldi	r22, 0x01	; 1
    9564:	4d e1       	ldi	r20, 0x1D	; 29
    9566:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    956a:	80 e0       	ldi	r24, 0x00	; 0
    956c:	61 e0       	ldi	r22, 0x01	; 1
    956e:	4c e7       	ldi	r20, 0x7C	; 124
    9570:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    9574:	80 e0       	ldi	r24, 0x00	; 0
    9576:	61 e0       	ldi	r22, 0x01	; 1
    9578:	40 e0       	ldi	r20, 0x00	; 0
    957a:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
		//Double Strike ON : 1B 47 01
		_uart(_COM_PRINTER, 1, 0x1B);_uart(_COM_PRINTER, 1, 0x47);_uart(_COM_PRINTER, 1, 0x01);
    957e:	80 e0       	ldi	r24, 0x00	; 0
    9580:	61 e0       	ldi	r22, 0x01	; 1
    9582:	4b e1       	ldi	r20, 0x1B	; 27
    9584:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    9588:	80 e0       	ldi	r24, 0x00	; 0
    958a:	61 e0       	ldi	r22, 0x01	; 1
    958c:	47 e4       	ldi	r20, 0x47	; 71
    958e:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    9592:	80 e0       	ldi	r24, 0x00	; 0
    9594:	61 e0       	ldi	r22, 0x01	; 1
    9596:	41 e0       	ldi	r20, 0x01	; 1
    9598:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x01);   
    959c:	80 e0       	ldi	r24, 0x00	; 0
    959e:	61 e0       	ldi	r22, 0x01	; 1
    95a0:	4d e1       	ldi	r20, 0x1D	; 29
    95a2:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    95a6:	80 e0       	ldi	r24, 0x00	; 0
    95a8:	61 e0       	ldi	r22, 0x01	; 1
    95aa:	41 e2       	ldi	r20, 0x21	; 33
    95ac:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    95b0:	80 e0       	ldi	r24, 0x00	; 0
    95b2:	61 e0       	ldi	r22, 0x01	; 1
    95b4:	41 e0       	ldi	r20, 0x01	; 1
    95b6:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    95ba:	08 95       	ret
		}
    else
	if (PrinterType==PT_CUSTOM_CUBE){
    95bc:	82 30       	cpi	r24, 0x02	; 2
    95be:	69 f5       	brne	.+90     	; 0x961a <InitPrinter+0xce>
        //Print Density 0%
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x7C);_uart(_COM_PRINTER, 1, 0x04);
    95c0:	80 e0       	ldi	r24, 0x00	; 0
    95c2:	61 e0       	ldi	r22, 0x01	; 1
    95c4:	4d e1       	ldi	r20, 0x1D	; 29
    95c6:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    95ca:	80 e0       	ldi	r24, 0x00	; 0
    95cc:	61 e0       	ldi	r22, 0x01	; 1
    95ce:	4c e7       	ldi	r20, 0x7C	; 124
    95d0:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    95d4:	80 e0       	ldi	r24, 0x00	; 0
    95d6:	61 e0       	ldi	r22, 0x01	; 1
    95d8:	44 e0       	ldi	r20, 0x04	; 4
    95da:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
		//Double Strike OFF : 1B 47 00
		_uart(_COM_PRINTER, 1, 0x1B);_uart(_COM_PRINTER, 1, 0x47);_uart(_COM_PRINTER, 1, 0x00);
    95de:	80 e0       	ldi	r24, 0x00	; 0
    95e0:	61 e0       	ldi	r22, 0x01	; 1
    95e2:	4b e1       	ldi	r20, 0x1B	; 27
    95e4:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    95e8:	80 e0       	ldi	r24, 0x00	; 0
    95ea:	61 e0       	ldi	r22, 0x01	; 1
    95ec:	47 e4       	ldi	r20, 0x47	; 71
    95ee:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    95f2:	80 e0       	ldi	r24, 0x00	; 0
    95f4:	61 e0       	ldi	r22, 0x01	; 1
    95f6:	40 e0       	ldi	r20, 0x00	; 0
    95f8:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);   
    95fc:	80 e0       	ldi	r24, 0x00	; 0
    95fe:	61 e0       	ldi	r22, 0x01	; 1
    9600:	4d e1       	ldi	r20, 0x1D	; 29
    9602:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    9606:	80 e0       	ldi	r24, 0x00	; 0
    9608:	61 e0       	ldi	r22, 0x01	; 1
    960a:	41 e2       	ldi	r20, 0x21	; 33
    960c:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    9610:	80 e0       	ldi	r24, 0x00	; 0
    9612:	61 e0       	ldi	r22, 0x01	; 1
    9614:	40 e0       	ldi	r20, 0x00	; 0
    9616:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    961a:	08 95       	ret

0000961c <PrintNormalHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    961c:	e1 99       	sbic	0x1c, 1	; 28
    961e:	fe cf       	rjmp	.-4      	; 0x961c <PrintNormalHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9620:	80 e3       	ldi	r24, 0x30	; 48
    9622:	90 e0       	ldi	r25, 0x00	; 0
    9624:	9f bb       	out	0x1f, r25	; 31
    9626:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9628:	e0 9a       	sbi	0x1c, 0	; 28
    962a:	8d b3       	in	r24, 0x1d	; 29
}

void PrintNormalHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    962c:	82 30       	cpi	r24, 0x02	; 2
    962e:	79 f4       	brne	.+30     	; 0x964e <PrintNormalHeight+0x32>
	     _uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);
    9630:	80 e0       	ldi	r24, 0x00	; 0
    9632:	61 e0       	ldi	r22, 0x01	; 1
    9634:	4d e1       	ldi	r20, 0x1D	; 29
    9636:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    963a:	80 e0       	ldi	r24, 0x00	; 0
    963c:	61 e0       	ldi	r22, 0x01	; 1
    963e:	41 e2       	ldi	r20, 0x21	; 33
    9640:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    9644:	80 e0       	ldi	r24, 0x00	; 0
    9646:	61 e0       	ldi	r22, 0x01	; 1
    9648:	40 e0       	ldi	r20, 0x00	; 0
    964a:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    964e:	08 95       	ret

00009650 <PrintDoubleHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9650:	e1 99       	sbic	0x1c, 1	; 28
    9652:	fe cf       	rjmp	.-4      	; 0x9650 <PrintDoubleHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9654:	80 e3       	ldi	r24, 0x30	; 48
    9656:	90 e0       	ldi	r25, 0x00	; 0
    9658:	9f bb       	out	0x1f, r25	; 31
    965a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    965c:	e0 9a       	sbi	0x1c, 0	; 28
    965e:	8d b3       	in	r24, 0x1d	; 29
//void SetPrinterCharacterWidth

void PrintDoubleHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    9660:	82 30       	cpi	r24, 0x02	; 2
    9662:	79 f4       	brne	.+30     	; 0x9682 <PrintDoubleHeight+0x32>
	     _uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x01);
    9664:	80 e0       	ldi	r24, 0x00	; 0
    9666:	61 e0       	ldi	r22, 0x01	; 1
    9668:	4d e1       	ldi	r20, 0x1D	; 29
    966a:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    966e:	80 e0       	ldi	r24, 0x00	; 0
    9670:	61 e0       	ldi	r22, 0x01	; 1
    9672:	41 e2       	ldi	r20, 0x21	; 33
    9674:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    9678:	80 e0       	ldi	r24, 0x00	; 0
    967a:	61 e0       	ldi	r22, 0x01	; 1
    967c:	41 e0       	ldi	r20, 0x01	; 1
    967e:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    9682:	08 95       	ret

00009684 <PaperCut>:

	 return Result;
}


void PaperCut(){
    9684:	1f 93       	push	r17
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9686:	e1 99       	sbic	0x1c, 1	; 28
    9688:	fe cf       	rjmp	.-4      	; 0x9686 <PaperCut+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    968a:	83 e3       	ldi	r24, 0x33	; 51
    968c:	90 e0       	ldi	r25, 0x00	; 0
    968e:	9f bb       	out	0x1f, r25	; 31
    9690:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9692:	e0 9a       	sbi	0x1c, 0	; 28
    9694:	1d b3       	in	r17, 0x1d	; 29
     char CutType;
     CutType= eeprom_read_byte(&__prt_autocut);
     _uart(_COM_PRINTER, 1, 0x1B);
    9696:	80 e0       	ldi	r24, 0x00	; 0
    9698:	61 e0       	ldi	r22, 0x01	; 1
    969a:	4b e1       	ldi	r20, 0x1B	; 27
    969c:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
	 if(CutType== 1) { _uart(_COM_PRINTER, 1, 0x6D);}
    96a0:	11 30       	cpi	r17, 0x01	; 1
    96a2:	21 f4       	brne	.+8      	; 0x96ac <PaperCut+0x28>
    96a4:	80 e0       	ldi	r24, 0x00	; 0
    96a6:	61 e0       	ldi	r22, 0x01	; 1
    96a8:	4d e6       	ldi	r20, 0x6D	; 109
    96aa:	05 c0       	rjmp	.+10     	; 0x96b6 <PaperCut+0x32>
	 if(CutType== 2) {_uart(_COM_PRINTER, 1, 0x69);}
    96ac:	12 30       	cpi	r17, 0x02	; 2
    96ae:	29 f4       	brne	.+10     	; 0x96ba <PaperCut+0x36>
    96b0:	80 e0       	ldi	r24, 0x00	; 0
    96b2:	61 e0       	ldi	r22, 0x01	; 1
    96b4:	49 e6       	ldi	r20, 0x69	; 105
    96b6:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>

}
    96ba:	1f 91       	pop	r17
    96bc:	08 95       	ret

000096be <sendMessage98>:
		        break;
	       }//EndSwitch
return Result;
}

void sendMessage98(char PumpID){
    96be:	ff 92       	push	r15
    96c0:	0f 93       	push	r16
    96c2:	1f 93       	push	r17
    96c4:	df 93       	push	r29
    96c6:	cf 93       	push	r28
    96c8:	cd b7       	in	r28, 0x3d	; 61
    96ca:	de b7       	in	r29, 0x3e	; 62
    96cc:	ea 97       	sbiw	r28, 0x3a	; 58
    96ce:	0f b6       	in	r0, 0x3f	; 63
    96d0:	f8 94       	cli
    96d2:	de bf       	out	0x3e, r29	; 62
    96d4:	0f be       	out	0x3f, r0	; 63
    96d6:	cd bf       	out	0x3d, r28	; 61
    96d8:	f8 2e       	mov	r15, r24
	char __pump_id[8];
	char strSend[50];
	char xFIP_ID;
	
	_uart(1, 1,0x01);
    96da:	81 e0       	ldi	r24, 0x01	; 1
    96dc:	61 e0       	ldi	r22, 0x01	; 1
    96de:	41 e0       	ldi	r20, 0x01	; 1
    96e0:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    UpdateIFT_ID(); //ReadIFT_ID
    96e4:	0e 94 af 1a 	call	0x355e	; 0x355e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    96e8:	0e 94 9d 1a 	call	0x353a	; 0x353a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    96ec:	0e 94 8b 1c 	call	0x3916	; 0x3916 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    96f0:	0e 94 23 1c 	call	0x3846	; 0x3846 <UpdateServerIP>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    96f4:	ce 01       	movw	r24, r28
    96f6:	01 96       	adiw	r24, 0x01	; 1
    96f8:	65 e4       	ldi	r22, 0x45	; 69
    96fa:	70 e0       	ldi	r23, 0x00	; 0
    96fc:	48 e0       	ldi	r20, 0x08	; 8
    96fe:	50 e0       	ldi	r21, 0x00	; 0
    9700:	2c ea       	ldi	r18, 0xAC	; 172
    9702:	32 e1       	ldi	r19, 0x12	; 18
    9704:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	xFIP_ID=__pump_id[PumpID-1];
	//if (xFIP_ID>16)xFIP_ID=16;
	sprintf_P(strSend,PSTR("%s%s%s%s98%.2dF968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,xFIP_ID);
    9708:	8d b7       	in	r24, 0x3d	; 61
    970a:	9e b7       	in	r25, 0x3e	; 62
    970c:	0e 97       	sbiw	r24, 0x0e	; 14
    970e:	0f b6       	in	r0, 0x3f	; 63
    9710:	f8 94       	cli
    9712:	9e bf       	out	0x3e, r25	; 62
    9714:	0f be       	out	0x3f, r0	; 63
    9716:	8d bf       	out	0x3d, r24	; 61
    9718:	ad b7       	in	r26, 0x3d	; 61
    971a:	be b7       	in	r27, 0x3e	; 62
    971c:	11 96       	adiw	r26, 0x01	; 1
    971e:	8e 01       	movw	r16, r28
    9720:	07 5f       	subi	r16, 0xF7	; 247
    9722:	1f 4f       	sbci	r17, 0xFF	; 255
    9724:	ed b7       	in	r30, 0x3d	; 61
    9726:	fe b7       	in	r31, 0x3e	; 62
    9728:	12 83       	std	Z+2, r17	; 0x02
    972a:	01 83       	std	Z+1, r16	; 0x01
    972c:	83 eb       	ldi	r24, 0xB3	; 179
    972e:	9c e1       	ldi	r25, 0x1C	; 28
    9730:	13 96       	adiw	r26, 0x03	; 3
    9732:	9c 93       	st	X, r25
    9734:	8e 93       	st	-X, r24
    9736:	12 97       	sbiw	r26, 0x02	; 2
    9738:	82 ef       	ldi	r24, 0xF2	; 242
    973a:	95 e0       	ldi	r25, 0x05	; 5
    973c:	15 96       	adiw	r26, 0x05	; 5
    973e:	9c 93       	st	X, r25
    9740:	8e 93       	st	-X, r24
    9742:	14 97       	sbiw	r26, 0x04	; 4
    9744:	8b ed       	ldi	r24, 0xDB	; 219
    9746:	9d e0       	ldi	r25, 0x0D	; 13
    9748:	17 96       	adiw	r26, 0x07	; 7
    974a:	9c 93       	st	X, r25
    974c:	8e 93       	st	-X, r24
    974e:	16 97       	sbiw	r26, 0x06	; 6
    9750:	8a ee       	ldi	r24, 0xEA	; 234
    9752:	99 e0       	ldi	r25, 0x09	; 9
    9754:	19 96       	adiw	r26, 0x09	; 9
    9756:	9c 93       	st	X, r25
    9758:	8e 93       	st	-X, r24
    975a:	18 97       	sbiw	r26, 0x08	; 8
    975c:	87 e1       	ldi	r24, 0x17	; 23
    975e:	9a e0       	ldi	r25, 0x0A	; 10
    9760:	1b 96       	adiw	r26, 0x0b	; 11
    9762:	9c 93       	st	X, r25
    9764:	8e 93       	st	-X, r24
    9766:	1a 97       	sbiw	r26, 0x0a	; 10
    9768:	fe 01       	movw	r30, r28
    976a:	ef 0d       	add	r30, r15
    976c:	f1 1d       	adc	r31, r1
    976e:	80 81       	ld	r24, Z
    9770:	1c 96       	adiw	r26, 0x0c	; 12
    9772:	8c 93       	st	X, r24
    9774:	1c 97       	sbiw	r26, 0x0c	; 12
    9776:	1d 96       	adiw	r26, 0x0d	; 13
    9778:	1c 92       	st	X, r1
    977a:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	_uart_print(1, 0,strSend);
    977e:	8d b7       	in	r24, 0x3d	; 61
    9780:	9e b7       	in	r25, 0x3e	; 62
    9782:	0e 96       	adiw	r24, 0x0e	; 14
    9784:	0f b6       	in	r0, 0x3f	; 63
    9786:	f8 94       	cli
    9788:	9e bf       	out	0x3e, r25	; 62
    978a:	0f be       	out	0x3f, r0	; 63
    978c:	8d bf       	out	0x3d, r24	; 61
    978e:	81 e0       	ldi	r24, 0x01	; 1
    9790:	60 e0       	ldi	r22, 0x00	; 0
    9792:	a8 01       	movw	r20, r16
    9794:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	_uart(1, 1,0x02);
    9798:	81 e0       	ldi	r24, 0x01	; 1
    979a:	61 e0       	ldi	r22, 0x01	; 1
    979c:	42 e0       	ldi	r20, 0x02	; 2
    979e:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
	IsBusyMsg11=True;
    97a2:	81 e0       	ldi	r24, 0x01	; 1
    97a4:	80 93 da 01 	sts	0x01DA, r24
}
    97a8:	ea 96       	adiw	r28, 0x3a	; 58
    97aa:	0f b6       	in	r0, 0x3f	; 63
    97ac:	f8 94       	cli
    97ae:	de bf       	out	0x3e, r29	; 62
    97b0:	0f be       	out	0x3f, r0	; 63
    97b2:	cd bf       	out	0x3d, r28	; 61
    97b4:	cf 91       	pop	r28
    97b6:	df 91       	pop	r29
    97b8:	1f 91       	pop	r17
    97ba:	0f 91       	pop	r16
    97bc:	ff 90       	pop	r15
    97be:	08 95       	ret

000097c0 <sendMessage94>:
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage94(){//Void Transaction Message
    97c0:	0f 93       	push	r16
    97c2:	1f 93       	push	r17
    97c4:	df 93       	push	r29
    97c6:	cf 93       	push	r28
    97c8:	cd b7       	in	r28, 0x3d	; 61
    97ca:	de b7       	in	r29, 0x3e	; 62
    97cc:	c0 55       	subi	r28, 0x50	; 80
    97ce:	d0 40       	sbci	r29, 0x00	; 0
    97d0:	0f b6       	in	r0, 0x3f	; 63
    97d2:	f8 94       	cli
    97d4:	de bf       	out	0x3e, r29	; 62
    97d6:	0f be       	out	0x3f, r0	; 63
    97d8:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    97da:	81 e0       	ldi	r24, 0x01	; 1
    97dc:	61 e0       	ldi	r22, 0x01	; 1
    97de:	41 e0       	ldi	r20, 0x01	; 1
    97e0:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    97e4:	0e 94 af 1a 	call	0x355e	; 0x355e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    97e8:	0e 94 9d 1a 	call	0x353a	; 0x353a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    97ec:	0e 94 8b 1c 	call	0x3916	; 0x3916 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    97f0:	0e 94 23 1c 	call	0x3846	; 0x3846 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s94"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    97f4:	8d b7       	in	r24, 0x3d	; 61
    97f6:	9e b7       	in	r25, 0x3e	; 62
    97f8:	0c 97       	sbiw	r24, 0x0c	; 12
    97fa:	0f b6       	in	r0, 0x3f	; 63
    97fc:	f8 94       	cli
    97fe:	9e bf       	out	0x3e, r25	; 62
    9800:	0f be       	out	0x3f, r0	; 63
    9802:	8d bf       	out	0x3d, r24	; 61
    9804:	ed b7       	in	r30, 0x3d	; 61
    9806:	fe b7       	in	r31, 0x3e	; 62
    9808:	31 96       	adiw	r30, 0x01	; 1
    980a:	8e 01       	movw	r16, r28
    980c:	0f 5f       	subi	r16, 0xFF	; 255
    980e:	1f 4f       	sbci	r17, 0xFF	; 255
    9810:	ad b7       	in	r26, 0x3d	; 61
    9812:	be b7       	in	r27, 0x3e	; 62
    9814:	12 96       	adiw	r26, 0x02	; 2
    9816:	1c 93       	st	X, r17
    9818:	0e 93       	st	-X, r16
    981a:	11 97       	sbiw	r26, 0x01	; 1
    981c:	86 e4       	ldi	r24, 0x46	; 70
    981e:	90 e2       	ldi	r25, 0x20	; 32
    9820:	93 83       	std	Z+3, r25	; 0x03
    9822:	82 83       	std	Z+2, r24	; 0x02
    9824:	82 ef       	ldi	r24, 0xF2	; 242
    9826:	95 e0       	ldi	r25, 0x05	; 5
    9828:	95 83       	std	Z+5, r25	; 0x05
    982a:	84 83       	std	Z+4, r24	; 0x04
    982c:	8b ed       	ldi	r24, 0xDB	; 219
    982e:	9d e0       	ldi	r25, 0x0D	; 13
    9830:	97 83       	std	Z+7, r25	; 0x07
    9832:	86 83       	std	Z+6, r24	; 0x06
    9834:	8a ee       	ldi	r24, 0xEA	; 234
    9836:	99 e0       	ldi	r25, 0x09	; 9
    9838:	91 87       	std	Z+9, r25	; 0x09
    983a:	80 87       	std	Z+8, r24	; 0x08
    983c:	87 e1       	ldi	r24, 0x17	; 23
    983e:	9a e0       	ldi	r25, 0x0A	; 10
    9840:	93 87       	std	Z+11, r25	; 0x0b
    9842:	82 87       	std	Z+10, r24	; 0x0a
    9844:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    9848:	ed b7       	in	r30, 0x3d	; 61
    984a:	fe b7       	in	r31, 0x3e	; 62
    984c:	3c 96       	adiw	r30, 0x0c	; 12
    984e:	0f b6       	in	r0, 0x3f	; 63
    9850:	f8 94       	cli
    9852:	fe bf       	out	0x3e, r31	; 62
    9854:	0f be       	out	0x3f, r0	; 63
    9856:	ed bf       	out	0x3d, r30	; 61
    9858:	81 e0       	ldi	r24, 0x01	; 1
    985a:	60 e0       	ldi	r22, 0x00	; 0
    985c:	a8 01       	movw	r20, r16
    985e:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s"),strInvoiceNumber,strDateTime);
    9862:	8d b7       	in	r24, 0x3d	; 61
    9864:	9e b7       	in	r25, 0x3e	; 62
    9866:	08 97       	sbiw	r24, 0x08	; 8
    9868:	0f b6       	in	r0, 0x3f	; 63
    986a:	f8 94       	cli
    986c:	9e bf       	out	0x3e, r25	; 62
    986e:	0f be       	out	0x3f, r0	; 63
    9870:	8d bf       	out	0x3d, r24	; 61
    9872:	ed b7       	in	r30, 0x3d	; 61
    9874:	fe b7       	in	r31, 0x3e	; 62
    9876:	31 96       	adiw	r30, 0x01	; 1
    9878:	ad b7       	in	r26, 0x3d	; 61
    987a:	be b7       	in	r27, 0x3e	; 62
    987c:	12 96       	adiw	r26, 0x02	; 2
    987e:	1c 93       	st	X, r17
    9880:	0e 93       	st	-X, r16
    9882:	11 97       	sbiw	r26, 0x01	; 1
    9884:	81 e4       	ldi	r24, 0x41	; 65
    9886:	90 e2       	ldi	r25, 0x20	; 32
    9888:	93 83       	std	Z+3, r25	; 0x03
    988a:	82 83       	std	Z+2, r24	; 0x02
    988c:	82 e6       	ldi	r24, 0x62	; 98
    988e:	99 e0       	ldi	r25, 0x09	; 9
    9890:	95 83       	std	Z+5, r25	; 0x05
    9892:	84 83       	std	Z+4, r24	; 0x04
    9894:	87 ec       	ldi	r24, 0xC7	; 199
    9896:	9d e0       	ldi	r25, 0x0D	; 13
    9898:	97 83       	std	Z+7, r25	; 0x07
    989a:	86 83       	std	Z+6, r24	; 0x06
    989c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    98a0:	ed b7       	in	r30, 0x3d	; 61
    98a2:	fe b7       	in	r31, 0x3e	; 62
    98a4:	38 96       	adiw	r30, 0x08	; 8
    98a6:	0f b6       	in	r0, 0x3f	; 63
    98a8:	f8 94       	cli
    98aa:	fe bf       	out	0x3e, r31	; 62
    98ac:	0f be       	out	0x3f, r0	; 63
    98ae:	ed bf       	out	0x3d, r30	; 61
    98b0:	81 e0       	ldi	r24, 0x01	; 1
    98b2:	60 e0       	ldi	r22, 0x00	; 0
    98b4:	a8 01       	movw	r20, r16
    98b6:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	sprintf_P(strSend,PSTR("E9445512"));
    98ba:	00 d0       	rcall	.+0      	; 0x98bc <sendMessage94+0xfc>
    98bc:	00 d0       	rcall	.+0      	; 0x98be <sendMessage94+0xfe>
    98be:	ad b7       	in	r26, 0x3d	; 61
    98c0:	be b7       	in	r27, 0x3e	; 62
    98c2:	12 96       	adiw	r26, 0x02	; 2
    98c4:	1c 93       	st	X, r17
    98c6:	0e 93       	st	-X, r16
    98c8:	11 97       	sbiw	r26, 0x01	; 1
    98ca:	88 e3       	ldi	r24, 0x38	; 56
    98cc:	90 e2       	ldi	r25, 0x20	; 32
    98ce:	14 96       	adiw	r26, 0x04	; 4
    98d0:	9c 93       	st	X, r25
    98d2:	8e 93       	st	-X, r24
    98d4:	13 97       	sbiw	r26, 0x03	; 3
    98d6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
    98da:	0f 90       	pop	r0
    98dc:	0f 90       	pop	r0
    98de:	0f 90       	pop	r0
    98e0:	0f 90       	pop	r0
    98e2:	81 e0       	ldi	r24, 0x01	; 1
    98e4:	60 e0       	ldi	r22, 0x00	; 0
    98e6:	a8 01       	movw	r20, r16
    98e8:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	_uart(1, 1,0x02);
    98ec:	81 e0       	ldi	r24, 0x01	; 1
    98ee:	61 e0       	ldi	r22, 0x01	; 1
    98f0:	42 e0       	ldi	r20, 0x02	; 2
    98f2:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
}
    98f6:	c0 5b       	subi	r28, 0xB0	; 176
    98f8:	df 4f       	sbci	r29, 0xFF	; 255
    98fa:	0f b6       	in	r0, 0x3f	; 63
    98fc:	f8 94       	cli
    98fe:	de bf       	out	0x3e, r29	; 62
    9900:	0f be       	out	0x3f, r0	; 63
    9902:	cd bf       	out	0x3d, r28	; 61
    9904:	cf 91       	pop	r28
    9906:	df 91       	pop	r29
    9908:	1f 91       	pop	r17
    990a:	0f 91       	pop	r16
    990c:	08 95       	ret

0000990e <sendMessage92>:
	sprintf_P(strSend,PSTR("E9445512"));
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage92(){
    990e:	0f 93       	push	r16
    9910:	1f 93       	push	r17
    9912:	df 93       	push	r29
    9914:	cf 93       	push	r28
    9916:	cd b7       	in	r28, 0x3d	; 61
    9918:	de b7       	in	r29, 0x3e	; 62
    991a:	c0 55       	subi	r28, 0x50	; 80
    991c:	d0 40       	sbci	r29, 0x00	; 0
    991e:	0f b6       	in	r0, 0x3f	; 63
    9920:	f8 94       	cli
    9922:	de bf       	out	0x3e, r29	; 62
    9924:	0f be       	out	0x3f, r0	; 63
    9926:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9928:	81 e0       	ldi	r24, 0x01	; 1
    992a:	61 e0       	ldi	r22, 0x01	; 1
    992c:	41 e0       	ldi	r20, 0x01	; 1
    992e:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9932:	0e 94 af 1a 	call	0x355e	; 0x355e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9936:	0e 94 9d 1a 	call	0x353a	; 0x353a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    993a:	0e 94 8b 1c 	call	0x3916	; 0x3916 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    993e:	0e 94 23 1c 	call	0x3846	; 0x3846 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s92"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9942:	8d b7       	in	r24, 0x3d	; 61
    9944:	9e b7       	in	r25, 0x3e	; 62
    9946:	0c 97       	sbiw	r24, 0x0c	; 12
    9948:	0f b6       	in	r0, 0x3f	; 63
    994a:	f8 94       	cli
    994c:	9e bf       	out	0x3e, r25	; 62
    994e:	0f be       	out	0x3f, r0	; 63
    9950:	8d bf       	out	0x3d, r24	; 61
    9952:	ed b7       	in	r30, 0x3d	; 61
    9954:	fe b7       	in	r31, 0x3e	; 62
    9956:	31 96       	adiw	r30, 0x01	; 1
    9958:	8e 01       	movw	r16, r28
    995a:	0f 5f       	subi	r16, 0xFF	; 255
    995c:	1f 4f       	sbci	r17, 0xFF	; 255
    995e:	ad b7       	in	r26, 0x3d	; 61
    9960:	be b7       	in	r27, 0x3e	; 62
    9962:	12 96       	adiw	r26, 0x02	; 2
    9964:	1c 93       	st	X, r17
    9966:	0e 93       	st	-X, r16
    9968:	11 97       	sbiw	r26, 0x01	; 1
    996a:	8a e6       	ldi	r24, 0x6A	; 106
    996c:	90 e2       	ldi	r25, 0x20	; 32
    996e:	93 83       	std	Z+3, r25	; 0x03
    9970:	82 83       	std	Z+2, r24	; 0x02
    9972:	82 ef       	ldi	r24, 0xF2	; 242
    9974:	95 e0       	ldi	r25, 0x05	; 5
    9976:	95 83       	std	Z+5, r25	; 0x05
    9978:	84 83       	std	Z+4, r24	; 0x04
    997a:	8b ed       	ldi	r24, 0xDB	; 219
    997c:	9d e0       	ldi	r25, 0x0D	; 13
    997e:	97 83       	std	Z+7, r25	; 0x07
    9980:	86 83       	std	Z+6, r24	; 0x06
    9982:	8a ee       	ldi	r24, 0xEA	; 234
    9984:	99 e0       	ldi	r25, 0x09	; 9
    9986:	91 87       	std	Z+9, r25	; 0x09
    9988:	80 87       	std	Z+8, r24	; 0x08
    998a:	87 e1       	ldi	r24, 0x17	; 23
    998c:	9a e0       	ldi	r25, 0x0A	; 10
    998e:	93 87       	std	Z+11, r25	; 0x0b
    9990:	82 87       	std	Z+10, r24	; 0x0a
    9992:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    9996:	ed b7       	in	r30, 0x3d	; 61
    9998:	fe b7       	in	r31, 0x3e	; 62
    999a:	3c 96       	adiw	r30, 0x0c	; 12
    999c:	0f b6       	in	r0, 0x3f	; 63
    999e:	f8 94       	cli
    99a0:	fe bf       	out	0x3e, r31	; 62
    99a2:	0f be       	out	0x3f, r0	; 63
    99a4:	ed bf       	out	0x3d, r30	; 61
    99a6:	81 e0       	ldi	r24, 0x01	; 1
    99a8:	60 e0       	ldi	r22, 0x00	; 0
    99aa:	a8 01       	movw	r20, r16
    99ac:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s%s%s"),strTranNo,strFIP_ID,strCardType,strCardID);
    99b0:	8d b7       	in	r24, 0x3d	; 61
    99b2:	9e b7       	in	r25, 0x3e	; 62
    99b4:	0c 97       	sbiw	r24, 0x0c	; 12
    99b6:	0f b6       	in	r0, 0x3f	; 63
    99b8:	f8 94       	cli
    99ba:	9e bf       	out	0x3e, r25	; 62
    99bc:	0f be       	out	0x3f, r0	; 63
    99be:	8d bf       	out	0x3d, r24	; 61
    99c0:	ed b7       	in	r30, 0x3d	; 61
    99c2:	fe b7       	in	r31, 0x3e	; 62
    99c4:	31 96       	adiw	r30, 0x01	; 1
    99c6:	ad b7       	in	r26, 0x3d	; 61
    99c8:	be b7       	in	r27, 0x3e	; 62
    99ca:	12 96       	adiw	r26, 0x02	; 2
    99cc:	1c 93       	st	X, r17
    99ce:	0e 93       	st	-X, r16
    99d0:	11 97       	sbiw	r26, 0x01	; 1
    99d2:	81 e6       	ldi	r24, 0x61	; 97
    99d4:	90 e2       	ldi	r25, 0x20	; 32
    99d6:	93 83       	std	Z+3, r25	; 0x03
    99d8:	82 83       	std	Z+2, r24	; 0x02
    99da:	82 e9       	ldi	r24, 0x92	; 146
    99dc:	9e e0       	ldi	r25, 0x0E	; 14
    99de:	95 83       	std	Z+5, r25	; 0x05
    99e0:	84 83       	std	Z+4, r24	; 0x04
    99e2:	88 ec       	ldi	r24, 0xC8	; 200
    99e4:	99 e0       	ldi	r25, 0x09	; 9
    99e6:	97 83       	std	Z+7, r25	; 0x07
    99e8:	86 83       	std	Z+6, r24	; 0x06
    99ea:	8e ea       	ldi	r24, 0xAE	; 174
    99ec:	9e e0       	ldi	r25, 0x0E	; 14
    99ee:	91 87       	std	Z+9, r25	; 0x09
    99f0:	80 87       	std	Z+8, r24	; 0x08
    99f2:	81 e9       	ldi	r24, 0x91	; 145
    99f4:	9d e0       	ldi	r25, 0x0D	; 13
    99f6:	93 87       	std	Z+11, r25	; 0x0b
    99f8:	82 87       	std	Z+10, r24	; 0x0a
    99fa:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    99fe:	ed b7       	in	r30, 0x3d	; 61
    9a00:	fe b7       	in	r31, 0x3e	; 62
    9a02:	3c 96       	adiw	r30, 0x0c	; 12
    9a04:	0f b6       	in	r0, 0x3f	; 63
    9a06:	f8 94       	cli
    9a08:	fe bf       	out	0x3e, r31	; 62
    9a0a:	0f be       	out	0x3f, r0	; 63
    9a0c:	ed bf       	out	0x3d, r30	; 61
    9a0e:	81 e0       	ldi	r24, 0x01	; 1
    9a10:	60 e0       	ldi	r22, 0x00	; 0
    9a12:	a8 01       	movw	r20, r16
    9a14:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s%s"),strApprovalCode,strInvoiceNumber,strDateTime);
    9a18:	8d b7       	in	r24, 0x3d	; 61
    9a1a:	9e b7       	in	r25, 0x3e	; 62
    9a1c:	0a 97       	sbiw	r24, 0x0a	; 10
    9a1e:	0f b6       	in	r0, 0x3f	; 63
    9a20:	f8 94       	cli
    9a22:	9e bf       	out	0x3e, r25	; 62
    9a24:	0f be       	out	0x3f, r0	; 63
    9a26:	8d bf       	out	0x3d, r24	; 61
    9a28:	ed b7       	in	r30, 0x3d	; 61
    9a2a:	fe b7       	in	r31, 0x3e	; 62
    9a2c:	31 96       	adiw	r30, 0x01	; 1
    9a2e:	ad b7       	in	r26, 0x3d	; 61
    9a30:	be b7       	in	r27, 0x3e	; 62
    9a32:	12 96       	adiw	r26, 0x02	; 2
    9a34:	1c 93       	st	X, r17
    9a36:	0e 93       	st	-X, r16
    9a38:	11 97       	sbiw	r26, 0x01	; 1
    9a3a:	8a e5       	ldi	r24, 0x5A	; 90
    9a3c:	90 e2       	ldi	r25, 0x20	; 32
    9a3e:	93 83       	std	Z+3, r25	; 0x03
    9a40:	82 83       	std	Z+2, r24	; 0x02
    9a42:	80 e1       	ldi	r24, 0x10	; 16
    9a44:	9a e0       	ldi	r25, 0x0A	; 10
    9a46:	95 83       	std	Z+5, r25	; 0x05
    9a48:	84 83       	std	Z+4, r24	; 0x04
    9a4a:	82 e6       	ldi	r24, 0x62	; 98
    9a4c:	99 e0       	ldi	r25, 0x09	; 9
    9a4e:	97 83       	std	Z+7, r25	; 0x07
    9a50:	86 83       	std	Z+6, r24	; 0x06
    9a52:	87 ec       	ldi	r24, 0xC7	; 199
    9a54:	9d e0       	ldi	r25, 0x0D	; 13
    9a56:	91 87       	std	Z+9, r25	; 0x09
    9a58:	80 87       	std	Z+8, r24	; 0x08
    9a5a:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    9a5e:	ed b7       	in	r30, 0x3d	; 61
    9a60:	fe b7       	in	r31, 0x3e	; 62
    9a62:	3a 96       	adiw	r30, 0x0a	; 10
    9a64:	0f b6       	in	r0, 0x3f	; 63
    9a66:	f8 94       	cli
    9a68:	fe bf       	out	0x3e, r31	; 62
    9a6a:	0f be       	out	0x3f, r0	; 63
    9a6c:	ed bf       	out	0x3d, r30	; 61
    9a6e:	81 e0       	ldi	r24, 0x01	; 1
    9a70:	60 e0       	ldi	r22, 0x00	; 0
    9a72:	a8 01       	movw	r20, r16
    9a74:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("E9445512"));
    9a78:	00 d0       	rcall	.+0      	; 0x9a7a <sendMessage92+0x16c>
    9a7a:	00 d0       	rcall	.+0      	; 0x9a7c <sendMessage92+0x16e>
    9a7c:	ad b7       	in	r26, 0x3d	; 61
    9a7e:	be b7       	in	r27, 0x3e	; 62
    9a80:	12 96       	adiw	r26, 0x02	; 2
    9a82:	1c 93       	st	X, r17
    9a84:	0e 93       	st	-X, r16
    9a86:	11 97       	sbiw	r26, 0x01	; 1
    9a88:	81 e5       	ldi	r24, 0x51	; 81
    9a8a:	90 e2       	ldi	r25, 0x20	; 32
    9a8c:	14 96       	adiw	r26, 0x04	; 4
    9a8e:	9c 93       	st	X, r25
    9a90:	8e 93       	st	-X, r24
    9a92:	13 97       	sbiw	r26, 0x03	; 3
    9a94:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
    9a98:	0f 90       	pop	r0
    9a9a:	0f 90       	pop	r0
    9a9c:	0f 90       	pop	r0
    9a9e:	0f 90       	pop	r0
    9aa0:	81 e0       	ldi	r24, 0x01	; 1
    9aa2:	60 e0       	ldi	r22, 0x00	; 0
    9aa4:	a8 01       	movw	r20, r16
    9aa6:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	_uart(1, 1,0x02);
    9aaa:	81 e0       	ldi	r24, 0x01	; 1
    9aac:	61 e0       	ldi	r22, 0x01	; 1
    9aae:	42 e0       	ldi	r20, 0x02	; 2
    9ab0:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
}
    9ab4:	c0 5b       	subi	r28, 0xB0	; 176
    9ab6:	df 4f       	sbci	r29, 0xFF	; 255
    9ab8:	0f b6       	in	r0, 0x3f	; 63
    9aba:	f8 94       	cli
    9abc:	de bf       	out	0x3e, r29	; 62
    9abe:	0f be       	out	0x3f, r0	; 63
    9ac0:	cd bf       	out	0x3d, r28	; 61
    9ac2:	cf 91       	pop	r28
    9ac4:	df 91       	pop	r29
    9ac6:	1f 91       	pop	r17
    9ac8:	0f 91       	pop	r16
    9aca:	08 95       	ret

00009acc <sendMessage90>:
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage90(){
    9acc:	0f 93       	push	r16
    9ace:	1f 93       	push	r17
    9ad0:	df 93       	push	r29
    9ad2:	cf 93       	push	r28
    9ad4:	cd b7       	in	r28, 0x3d	; 61
    9ad6:	de b7       	in	r29, 0x3e	; 62
    9ad8:	c0 55       	subi	r28, 0x50	; 80
    9ada:	d0 40       	sbci	r29, 0x00	; 0
    9adc:	0f b6       	in	r0, 0x3f	; 63
    9ade:	f8 94       	cli
    9ae0:	de bf       	out	0x3e, r29	; 62
    9ae2:	0f be       	out	0x3f, r0	; 63
    9ae4:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9ae6:	81 e0       	ldi	r24, 0x01	; 1
    9ae8:	61 e0       	ldi	r22, 0x01	; 1
    9aea:	41 e0       	ldi	r20, 0x01	; 1
    9aec:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9af0:	0e 94 af 1a 	call	0x355e	; 0x355e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9af4:	0e 94 9d 1a 	call	0x353a	; 0x353a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9af8:	0e 94 8b 1c 	call	0x3916	; 0x3916 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9afc:	0e 94 23 1c 	call	0x3846	; 0x3846 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s90"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9b00:	8d b7       	in	r24, 0x3d	; 61
    9b02:	9e b7       	in	r25, 0x3e	; 62
    9b04:	0c 97       	sbiw	r24, 0x0c	; 12
    9b06:	0f b6       	in	r0, 0x3f	; 63
    9b08:	f8 94       	cli
    9b0a:	9e bf       	out	0x3e, r25	; 62
    9b0c:	0f be       	out	0x3f, r0	; 63
    9b0e:	8d bf       	out	0x3d, r24	; 61
    9b10:	ed b7       	in	r30, 0x3d	; 61
    9b12:	fe b7       	in	r31, 0x3e	; 62
    9b14:	31 96       	adiw	r30, 0x01	; 1
    9b16:	8e 01       	movw	r16, r28
    9b18:	0f 5f       	subi	r16, 0xFF	; 255
    9b1a:	1f 4f       	sbci	r17, 0xFF	; 255
    9b1c:	ad b7       	in	r26, 0x3d	; 61
    9b1e:	be b7       	in	r27, 0x3e	; 62
    9b20:	12 96       	adiw	r26, 0x02	; 2
    9b22:	1c 93       	st	X, r17
    9b24:	0e 93       	st	-X, r16
    9b26:	11 97       	sbiw	r26, 0x01	; 1
    9b28:	83 e8       	ldi	r24, 0x83	; 131
    9b2a:	90 e2       	ldi	r25, 0x20	; 32
    9b2c:	93 83       	std	Z+3, r25	; 0x03
    9b2e:	82 83       	std	Z+2, r24	; 0x02
    9b30:	82 ef       	ldi	r24, 0xF2	; 242
    9b32:	95 e0       	ldi	r25, 0x05	; 5
    9b34:	95 83       	std	Z+5, r25	; 0x05
    9b36:	84 83       	std	Z+4, r24	; 0x04
    9b38:	8b ed       	ldi	r24, 0xDB	; 219
    9b3a:	9d e0       	ldi	r25, 0x0D	; 13
    9b3c:	97 83       	std	Z+7, r25	; 0x07
    9b3e:	86 83       	std	Z+6, r24	; 0x06
    9b40:	8a ee       	ldi	r24, 0xEA	; 234
    9b42:	99 e0       	ldi	r25, 0x09	; 9
    9b44:	91 87       	std	Z+9, r25	; 0x09
    9b46:	80 87       	std	Z+8, r24	; 0x08
    9b48:	87 e1       	ldi	r24, 0x17	; 23
    9b4a:	9a e0       	ldi	r25, 0x0A	; 10
    9b4c:	93 87       	std	Z+11, r25	; 0x0b
    9b4e:	82 87       	std	Z+10, r24	; 0x0a
    9b50:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    9b54:	ed b7       	in	r30, 0x3d	; 61
    9b56:	fe b7       	in	r31, 0x3e	; 62
    9b58:	3c 96       	adiw	r30, 0x0c	; 12
    9b5a:	0f b6       	in	r0, 0x3f	; 63
    9b5c:	f8 94       	cli
    9b5e:	fe bf       	out	0x3e, r31	; 62
    9b60:	0f be       	out	0x3f, r0	; 63
    9b62:	ed bf       	out	0x3d, r30	; 61
    9b64:	81 e0       	ldi	r24, 0x01	; 1
    9b66:	60 e0       	ldi	r22, 0x00	; 0
    9b68:	a8 01       	movw	r20, r16
    9b6a:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strRef1);
    9b6e:	8d b7       	in	r24, 0x3d	; 61
    9b70:	9e b7       	in	r25, 0x3e	; 62
    9b72:	08 97       	sbiw	r24, 0x08	; 8
    9b74:	0f b6       	in	r0, 0x3f	; 63
    9b76:	f8 94       	cli
    9b78:	9e bf       	out	0x3e, r25	; 62
    9b7a:	0f be       	out	0x3f, r0	; 63
    9b7c:	8d bf       	out	0x3d, r24	; 61
    9b7e:	ed b7       	in	r30, 0x3d	; 61
    9b80:	fe b7       	in	r31, 0x3e	; 62
    9b82:	31 96       	adiw	r30, 0x01	; 1
    9b84:	ad b7       	in	r26, 0x3d	; 61
    9b86:	be b7       	in	r27, 0x3e	; 62
    9b88:	12 96       	adiw	r26, 0x02	; 2
    9b8a:	1c 93       	st	X, r17
    9b8c:	0e 93       	st	-X, r16
    9b8e:	11 97       	sbiw	r26, 0x01	; 1
    9b90:	8e e7       	ldi	r24, 0x7E	; 126
    9b92:	90 e2       	ldi	r25, 0x20	; 32
    9b94:	93 83       	std	Z+3, r25	; 0x03
    9b96:	82 83       	std	Z+2, r24	; 0x02
    9b98:	88 ec       	ldi	r24, 0xC8	; 200
    9b9a:	99 e0       	ldi	r25, 0x09	; 9
    9b9c:	95 83       	std	Z+5, r25	; 0x05
    9b9e:	84 83       	std	Z+4, r24	; 0x04
    9ba0:	89 e9       	ldi	r24, 0x99	; 153
    9ba2:	9e e0       	ldi	r25, 0x0E	; 14
    9ba4:	97 83       	std	Z+7, r25	; 0x07
    9ba6:	86 83       	std	Z+6, r24	; 0x06
    9ba8:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    9bac:	ed b7       	in	r30, 0x3d	; 61
    9bae:	fe b7       	in	r31, 0x3e	; 62
    9bb0:	38 96       	adiw	r30, 0x08	; 8
    9bb2:	0f b6       	in	r0, 0x3f	; 63
    9bb4:	f8 94       	cli
    9bb6:	fe bf       	out	0x3e, r31	; 62
    9bb8:	0f be       	out	0x3f, r0	; 63
    9bba:	ed bf       	out	0x3d, r30	; 61
    9bbc:	81 e0       	ldi	r24, 0x01	; 1
    9bbe:	60 e0       	ldi	r22, 0x00	; 0
    9bc0:	a8 01       	movw	r20, r16
    9bc2:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	sprintf_P(strSend,PSTR("E9445512"));
    9bc6:	00 d0       	rcall	.+0      	; 0x9bc8 <sendMessage90+0xfc>
    9bc8:	00 d0       	rcall	.+0      	; 0x9bca <sendMessage90+0xfe>
    9bca:	ad b7       	in	r26, 0x3d	; 61
    9bcc:	be b7       	in	r27, 0x3e	; 62
    9bce:	12 96       	adiw	r26, 0x02	; 2
    9bd0:	1c 93       	st	X, r17
    9bd2:	0e 93       	st	-X, r16
    9bd4:	11 97       	sbiw	r26, 0x01	; 1
    9bd6:	85 e7       	ldi	r24, 0x75	; 117
    9bd8:	90 e2       	ldi	r25, 0x20	; 32
    9bda:	14 96       	adiw	r26, 0x04	; 4
    9bdc:	9c 93       	st	X, r25
    9bde:	8e 93       	st	-X, r24
    9be0:	13 97       	sbiw	r26, 0x03	; 3
    9be2:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    9be6:	0f 90       	pop	r0
    9be8:	0f 90       	pop	r0
    9bea:	0f 90       	pop	r0
    9bec:	0f 90       	pop	r0
    9bee:	81 e0       	ldi	r24, 0x01	; 1
    9bf0:	60 e0       	ldi	r22, 0x00	; 0
    9bf2:	a8 01       	movw	r20, r16
    9bf4:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	_uart(1, 1,0x02);
    9bf8:	81 e0       	ldi	r24, 0x01	; 1
    9bfa:	61 e0       	ldi	r22, 0x01	; 1
    9bfc:	42 e0       	ldi	r20, 0x02	; 2
    9bfe:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
}
    9c02:	c0 5b       	subi	r28, 0xB0	; 176
    9c04:	df 4f       	sbci	r29, 0xFF	; 255
    9c06:	0f b6       	in	r0, 0x3f	; 63
    9c08:	f8 94       	cli
    9c0a:	de bf       	out	0x3e, r29	; 62
    9c0c:	0f be       	out	0x3f, r0	; 63
    9c0e:	cd bf       	out	0x3d, r28	; 61
    9c10:	cf 91       	pop	r28
    9c12:	df 91       	pop	r29
    9c14:	1f 91       	pop	r17
    9c16:	0f 91       	pop	r16
    9c18:	08 95       	ret

00009c1a <sendMessage58>:
	sprintf_P(strSend,PSTR("%s%s%s%s56%sAF968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,strCardID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage58(){
    9c1a:	cf 92       	push	r12
    9c1c:	df 92       	push	r13
    9c1e:	ef 92       	push	r14
    9c20:	ff 92       	push	r15
    9c22:	0f 93       	push	r16
    9c24:	1f 93       	push	r17
    9c26:	df 93       	push	r29
    9c28:	cf 93       	push	r28
    9c2a:	cd b7       	in	r28, 0x3d	; 61
    9c2c:	de b7       	in	r29, 0x3e	; 62
    9c2e:	c0 55       	subi	r28, 0x50	; 80
    9c30:	d0 40       	sbci	r29, 0x00	; 0
    9c32:	0f b6       	in	r0, 0x3f	; 63
    9c34:	f8 94       	cli
    9c36:	de bf       	out	0x3e, r29	; 62
    9c38:	0f be       	out	0x3f, r0	; 63
    9c3a:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9c3c:	81 e0       	ldi	r24, 0x01	; 1
    9c3e:	61 e0       	ldi	r22, 0x01	; 1
    9c40:	41 e0       	ldi	r20, 0x01	; 1
    9c42:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9c46:	0e 94 af 1a 	call	0x355e	; 0x355e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9c4a:	0e 94 9d 1a 	call	0x353a	; 0x353a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9c4e:	0e 94 8b 1c 	call	0x3916	; 0x3916 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9c52:	0e 94 23 1c 	call	0x3846	; 0x3846 <UpdateServerIP>
	UpdateCardID();  //ReadCardID
    9c56:	0e 94 04 3c 	call	0x7808	; 0x7808 <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%s%s%s58"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9c5a:	8d b7       	in	r24, 0x3d	; 61
    9c5c:	9e b7       	in	r25, 0x3e	; 62
    9c5e:	0c 97       	sbiw	r24, 0x0c	; 12
    9c60:	0f b6       	in	r0, 0x3f	; 63
    9c62:	f8 94       	cli
    9c64:	9e bf       	out	0x3e, r25	; 62
    9c66:	0f be       	out	0x3f, r0	; 63
    9c68:	8d bf       	out	0x3d, r24	; 61
    9c6a:	ed b7       	in	r30, 0x3d	; 61
    9c6c:	fe b7       	in	r31, 0x3e	; 62
    9c6e:	31 96       	adiw	r30, 0x01	; 1
    9c70:	8e 01       	movw	r16, r28
    9c72:	0f 5f       	subi	r16, 0xFF	; 255
    9c74:	1f 4f       	sbci	r17, 0xFF	; 255
    9c76:	ad b7       	in	r26, 0x3d	; 61
    9c78:	be b7       	in	r27, 0x3e	; 62
    9c7a:	12 96       	adiw	r26, 0x02	; 2
    9c7c:	1c 93       	st	X, r17
    9c7e:	0e 93       	st	-X, r16
    9c80:	11 97       	sbiw	r26, 0x01	; 1
    9c82:	8a eb       	ldi	r24, 0xBA	; 186
    9c84:	90 e2       	ldi	r25, 0x20	; 32
    9c86:	93 83       	std	Z+3, r25	; 0x03
    9c88:	82 83       	std	Z+2, r24	; 0x02
    9c8a:	82 ef       	ldi	r24, 0xF2	; 242
    9c8c:	95 e0       	ldi	r25, 0x05	; 5
    9c8e:	95 83       	std	Z+5, r25	; 0x05
    9c90:	84 83       	std	Z+4, r24	; 0x04
    9c92:	8b ed       	ldi	r24, 0xDB	; 219
    9c94:	9d e0       	ldi	r25, 0x0D	; 13
    9c96:	97 83       	std	Z+7, r25	; 0x07
    9c98:	86 83       	std	Z+6, r24	; 0x06
    9c9a:	8a ee       	ldi	r24, 0xEA	; 234
    9c9c:	99 e0       	ldi	r25, 0x09	; 9
    9c9e:	91 87       	std	Z+9, r25	; 0x09
    9ca0:	80 87       	std	Z+8, r24	; 0x08
    9ca2:	87 e1       	ldi	r24, 0x17	; 23
    9ca4:	9a e0       	ldi	r25, 0x0A	; 10
    9ca6:	93 87       	std	Z+11, r25	; 0x0b
    9ca8:	82 87       	std	Z+10, r24	; 0x0a
    9caa:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    9cae:	8d b7       	in	r24, 0x3d	; 61
    9cb0:	9e b7       	in	r25, 0x3e	; 62
    9cb2:	0c 96       	adiw	r24, 0x0c	; 12
    9cb4:	0f b6       	in	r0, 0x3f	; 63
    9cb6:	f8 94       	cli
    9cb8:	9e bf       	out	0x3e, r25	; 62
    9cba:	0f be       	out	0x3f, r0	; 63
    9cbc:	8d bf       	out	0x3d, r24	; 61
    9cbe:	81 e0       	ldi	r24, 0x01	; 1
    9cc0:	60 e0       	ldi	r22, 0x00	; 0
    9cc2:	a8 01       	movw	r20, r16
    9cc4:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	AddSpaceLead(strBalanceValue,13);
    9cc8:	fa e2       	ldi	r31, 0x2A	; 42
    9cca:	ef 2e       	mov	r14, r31
    9ccc:	fe e0       	ldi	r31, 0x0E	; 14
    9cce:	ff 2e       	mov	r15, r31
    9cd0:	c7 01       	movw	r24, r14
    9cd2:	6d e0       	ldi	r22, 0x0D	; 13
    9cd4:	0e 94 ae 29 	call	0x535c	; 0x535c <AddSpaceLead>
	AddSpaceLead(strOdometer,10);
    9cd8:	e9 ec       	ldi	r30, 0xC9	; 201
    9cda:	ce 2e       	mov	r12, r30
    9cdc:	e5 e0       	ldi	r30, 0x05	; 5
    9cde:	de 2e       	mov	r13, r30
    9ce0:	c6 01       	movw	r24, r12
    9ce2:	6a e0       	ldi	r22, 0x0A	; 10
    9ce4:	0e 94 ae 29 	call	0x535c	; 0x535c <AddSpaceLead>
	sprintf_P(strSend,PSTR("%s%s%d%s%s"),strCardID,strFIP_ID,NozzleID,strBalanceType,strBalanceValue);
    9ce8:	ad b7       	in	r26, 0x3d	; 61
    9cea:	be b7       	in	r27, 0x3e	; 62
    9cec:	1e 97       	sbiw	r26, 0x0e	; 14
    9cee:	0f b6       	in	r0, 0x3f	; 63
    9cf0:	f8 94       	cli
    9cf2:	be bf       	out	0x3e, r27	; 62
    9cf4:	0f be       	out	0x3f, r0	; 63
    9cf6:	ad bf       	out	0x3d, r26	; 61
    9cf8:	ed b7       	in	r30, 0x3d	; 61
    9cfa:	fe b7       	in	r31, 0x3e	; 62
    9cfc:	31 96       	adiw	r30, 0x01	; 1
    9cfe:	12 96       	adiw	r26, 0x02	; 2
    9d00:	1c 93       	st	X, r17
    9d02:	0e 93       	st	-X, r16
    9d04:	11 97       	sbiw	r26, 0x01	; 1
    9d06:	8f ea       	ldi	r24, 0xAF	; 175
    9d08:	90 e2       	ldi	r25, 0x20	; 32
    9d0a:	93 83       	std	Z+3, r25	; 0x03
    9d0c:	82 83       	std	Z+2, r24	; 0x02
    9d0e:	81 e9       	ldi	r24, 0x91	; 145
    9d10:	9d e0       	ldi	r25, 0x0D	; 13
    9d12:	95 83       	std	Z+5, r25	; 0x05
    9d14:	84 83       	std	Z+4, r24	; 0x04
    9d16:	88 ec       	ldi	r24, 0xC8	; 200
    9d18:	99 e0       	ldi	r25, 0x09	; 9
    9d1a:	97 83       	std	Z+7, r25	; 0x07
    9d1c:	86 83       	std	Z+6, r24	; 0x06
    9d1e:	80 91 7c 09 	lds	r24, 0x097C
    9d22:	80 87       	std	Z+8, r24	; 0x08
    9d24:	11 86       	std	Z+9, r1	; 0x09
    9d26:	89 ea       	ldi	r24, 0xA9	; 169
    9d28:	95 e0       	ldi	r25, 0x05	; 5
    9d2a:	93 87       	std	Z+11, r25	; 0x0b
    9d2c:	82 87       	std	Z+10, r24	; 0x0a
    9d2e:	f5 86       	std	Z+13, r15	; 0x0d
    9d30:	e4 86       	std	Z+12, r14	; 0x0c
    9d32:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    9d36:	8d b7       	in	r24, 0x3d	; 61
    9d38:	9e b7       	in	r25, 0x3e	; 62
    9d3a:	0e 96       	adiw	r24, 0x0e	; 14
    9d3c:	0f b6       	in	r0, 0x3f	; 63
    9d3e:	f8 94       	cli
    9d40:	9e bf       	out	0x3e, r25	; 62
    9d42:	0f be       	out	0x3f, r0	; 63
    9d44:	8d bf       	out	0x3d, r24	; 61
    9d46:	81 e0       	ldi	r24, 0x01	; 1
    9d48:	60 e0       	ldi	r22, 0x00	; 0
    9d4a:	a8 01       	movw	r20, r16
    9d4c:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>

	CardType=0;
    9d50:	10 92 8f 05 	sts	0x058F, r1
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    9d54:	ad b7       	in	r26, 0x3d	; 61
    9d56:	be b7       	in	r27, 0x3e	; 62
    9d58:	18 97       	sbiw	r26, 0x08	; 8
    9d5a:	0f b6       	in	r0, 0x3f	; 63
    9d5c:	f8 94       	cli
    9d5e:	be bf       	out	0x3e, r27	; 62
    9d60:	0f be       	out	0x3f, r0	; 63
    9d62:	ad bf       	out	0x3d, r26	; 61
    9d64:	ed b7       	in	r30, 0x3d	; 61
    9d66:	fe b7       	in	r31, 0x3e	; 62
    9d68:	31 96       	adiw	r30, 0x01	; 1
    9d6a:	12 96       	adiw	r26, 0x02	; 2
    9d6c:	1c 93       	st	X, r17
    9d6e:	0e 93       	st	-X, r16
    9d70:	11 97       	sbiw	r26, 0x01	; 1
    9d72:	8e e8       	ldi	r24, 0x8E	; 142
    9d74:	90 e2       	ldi	r25, 0x20	; 32
    9d76:	93 83       	std	Z+3, r25	; 0x03
    9d78:	82 83       	std	Z+2, r24	; 0x02
    9d7a:	15 82       	std	Z+5, r1	; 0x05
    9d7c:	14 82       	std	Z+4, r1	; 0x04
    9d7e:	d7 82       	std	Z+7, r13	; 0x07
    9d80:	c6 82       	std	Z+6, r12	; 0x06
    9d82:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    9d86:	8d b7       	in	r24, 0x3d	; 61
    9d88:	9e b7       	in	r25, 0x3e	; 62
    9d8a:	08 96       	adiw	r24, 0x08	; 8
    9d8c:	0f b6       	in	r0, 0x3f	; 63
    9d8e:	f8 94       	cli
    9d90:	9e bf       	out	0x3e, r25	; 62
    9d92:	0f be       	out	0x3f, r0	; 63
    9d94:	8d bf       	out	0x3d, r24	; 61
    9d96:	81 e0       	ldi	r24, 0x01	; 1
    9d98:	60 e0       	ldi	r22, 0x00	; 0
    9d9a:	a8 01       	movw	r20, r16
    9d9c:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	_uart(1, 1,0x02);
    9da0:	81 e0       	ldi	r24, 0x01	; 1
    9da2:	61 e0       	ldi	r22, 0x01	; 1
    9da4:	42 e0       	ldi	r20, 0x02	; 2
    9da6:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
}
    9daa:	c0 5b       	subi	r28, 0xB0	; 176
    9dac:	df 4f       	sbci	r29, 0xFF	; 255
    9dae:	0f b6       	in	r0, 0x3f	; 63
    9db0:	f8 94       	cli
    9db2:	de bf       	out	0x3e, r29	; 62
    9db4:	0f be       	out	0x3f, r0	; 63
    9db6:	cd bf       	out	0x3d, r28	; 61
    9db8:	cf 91       	pop	r28
    9dba:	df 91       	pop	r29
    9dbc:	1f 91       	pop	r17
    9dbe:	0f 91       	pop	r16
    9dc0:	ff 90       	pop	r15
    9dc2:	ef 90       	pop	r14
    9dc4:	df 90       	pop	r13
    9dc6:	cf 90       	pop	r12
    9dc8:	08 95       	ret

00009dca <sendMessage56>:
	sprintf_P(strSend,PSTR("F968CFFB"));
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);

}
void sendMessage56(){
    9dca:	0f 93       	push	r16
    9dcc:	1f 93       	push	r17
    9dce:	df 93       	push	r29
    9dd0:	cf 93       	push	r28
    9dd2:	cd b7       	in	r28, 0x3d	; 61
    9dd4:	de b7       	in	r29, 0x3e	; 62
    9dd6:	c0 55       	subi	r28, 0x50	; 80
    9dd8:	d0 40       	sbci	r29, 0x00	; 0
    9dda:	0f b6       	in	r0, 0x3f	; 63
    9ddc:	f8 94       	cli
    9dde:	de bf       	out	0x3e, r29	; 62
    9de0:	0f be       	out	0x3f, r0	; 63
    9de2:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9de4:	81 e0       	ldi	r24, 0x01	; 1
    9de6:	61 e0       	ldi	r22, 0x01	; 1
    9de8:	41 e0       	ldi	r20, 0x01	; 1
    9dea:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9dee:	0e 94 af 1a 	call	0x355e	; 0x355e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9df2:	0e 94 9d 1a 	call	0x353a	; 0x353a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9df6:	0e 94 8b 1c 	call	0x3916	; 0x3916 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9dfa:	0e 94 23 1c 	call	0x3846	; 0x3846 <UpdateServerIP>
	UpdateCardID();  //ReadCardID
    9dfe:	0e 94 04 3c 	call	0x7808	; 0x7808 <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%s%s%s56%sAF968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,strCardID);
    9e02:	8d b7       	in	r24, 0x3d	; 61
    9e04:	9e b7       	in	r25, 0x3e	; 62
    9e06:	0e 97       	sbiw	r24, 0x0e	; 14
    9e08:	0f b6       	in	r0, 0x3f	; 63
    9e0a:	f8 94       	cli
    9e0c:	9e bf       	out	0x3e, r25	; 62
    9e0e:	0f be       	out	0x3f, r0	; 63
    9e10:	8d bf       	out	0x3d, r24	; 61
    9e12:	ed b7       	in	r30, 0x3d	; 61
    9e14:	fe b7       	in	r31, 0x3e	; 62
    9e16:	31 96       	adiw	r30, 0x01	; 1
    9e18:	8e 01       	movw	r16, r28
    9e1a:	0f 5f       	subi	r16, 0xFF	; 255
    9e1c:	1f 4f       	sbci	r17, 0xFF	; 255
    9e1e:	ad b7       	in	r26, 0x3d	; 61
    9e20:	be b7       	in	r27, 0x3e	; 62
    9e22:	12 96       	adiw	r26, 0x02	; 2
    9e24:	1c 93       	st	X, r17
    9e26:	0e 93       	st	-X, r16
    9e28:	11 97       	sbiw	r26, 0x01	; 1
    9e2a:	85 ec       	ldi	r24, 0xC5	; 197
    9e2c:	90 e2       	ldi	r25, 0x20	; 32
    9e2e:	93 83       	std	Z+3, r25	; 0x03
    9e30:	82 83       	std	Z+2, r24	; 0x02
    9e32:	82 ef       	ldi	r24, 0xF2	; 242
    9e34:	95 e0       	ldi	r25, 0x05	; 5
    9e36:	95 83       	std	Z+5, r25	; 0x05
    9e38:	84 83       	std	Z+4, r24	; 0x04
    9e3a:	8b ed       	ldi	r24, 0xDB	; 219
    9e3c:	9d e0       	ldi	r25, 0x0D	; 13
    9e3e:	97 83       	std	Z+7, r25	; 0x07
    9e40:	86 83       	std	Z+6, r24	; 0x06
    9e42:	8a ee       	ldi	r24, 0xEA	; 234
    9e44:	99 e0       	ldi	r25, 0x09	; 9
    9e46:	91 87       	std	Z+9, r25	; 0x09
    9e48:	80 87       	std	Z+8, r24	; 0x08
    9e4a:	87 e1       	ldi	r24, 0x17	; 23
    9e4c:	9a e0       	ldi	r25, 0x0A	; 10
    9e4e:	93 87       	std	Z+11, r25	; 0x0b
    9e50:	82 87       	std	Z+10, r24	; 0x0a
    9e52:	81 e9       	ldi	r24, 0x91	; 145
    9e54:	9d e0       	ldi	r25, 0x0D	; 13
    9e56:	95 87       	std	Z+13, r25	; 0x0d
    9e58:	84 87       	std	Z+12, r24	; 0x0c
    9e5a:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    9e5e:	8d b7       	in	r24, 0x3d	; 61
    9e60:	9e b7       	in	r25, 0x3e	; 62
    9e62:	0e 96       	adiw	r24, 0x0e	; 14
    9e64:	0f b6       	in	r0, 0x3f	; 63
    9e66:	f8 94       	cli
    9e68:	9e bf       	out	0x3e, r25	; 62
    9e6a:	0f be       	out	0x3f, r0	; 63
    9e6c:	8d bf       	out	0x3d, r24	; 61
    9e6e:	81 e0       	ldi	r24, 0x01	; 1
    9e70:	60 e0       	ldi	r22, 0x00	; 0
    9e72:	a8 01       	movw	r20, r16
    9e74:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	_uart(1, 1,0x02);
    9e78:	81 e0       	ldi	r24, 0x01	; 1
    9e7a:	61 e0       	ldi	r22, 0x01	; 1
    9e7c:	42 e0       	ldi	r20, 0x02	; 2
    9e7e:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
}
    9e82:	c0 5b       	subi	r28, 0xB0	; 176
    9e84:	df 4f       	sbci	r29, 0xFF	; 255
    9e86:	0f b6       	in	r0, 0x3f	; 63
    9e88:	f8 94       	cli
    9e8a:	de bf       	out	0x3e, r29	; 62
    9e8c:	0f be       	out	0x3f, r0	; 63
    9e8e:	cd bf       	out	0x3d, r28	; 61
    9e90:	cf 91       	pop	r28
    9e92:	df 91       	pop	r29
    9e94:	1f 91       	pop	r17
    9e96:	0f 91       	pop	r16
    9e98:	08 95       	ret

00009e9a <sendMessage32>:
	_uart(1, 1,0x02);
}



void sendMessage32(){//Msg32: <01>[ID][Seq][SrcIP][DestIP][MsgCode][FIP][PaymentType][Ref1][Ref2][Ref3][Ref4]<02>
    9e9a:	0f 93       	push	r16
    9e9c:	1f 93       	push	r17
    9e9e:	df 93       	push	r29
    9ea0:	cf 93       	push	r28
    9ea2:	cd b7       	in	r28, 0x3d	; 61
    9ea4:	de b7       	in	r29, 0x3e	; 62
    9ea6:	c0 55       	subi	r28, 0x50	; 80
    9ea8:	d0 40       	sbci	r29, 0x00	; 0
    9eaa:	0f b6       	in	r0, 0x3f	; 63
    9eac:	f8 94       	cli
    9eae:	de bf       	out	0x3e, r29	; 62
    9eb0:	0f be       	out	0x3f, r0	; 63
    9eb2:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	UpdateIFT_ID(); //ReadIFT_ID
    9eb4:	0e 94 af 1a 	call	0x355e	; 0x355e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9eb8:	0e 94 9d 1a 	call	0x353a	; 0x353a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9ebc:	0e 94 8b 1c 	call	0x3916	; 0x3916 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9ec0:	0e 94 23 1c 	call	0x3846	; 0x3846 <UpdateServerIP>
	_uart(1, 1,0x01);
    9ec4:	81 e0       	ldi	r24, 0x01	; 1
    9ec6:	61 e0       	ldi	r22, 0x01	; 1
    9ec8:	41 e0       	ldi	r20, 0x01	; 1
    9eca:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
	sprintf_P(strSend,PSTR("%s%s%s%s32"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9ece:	8d b7       	in	r24, 0x3d	; 61
    9ed0:	9e b7       	in	r25, 0x3e	; 62
    9ed2:	0c 97       	sbiw	r24, 0x0c	; 12
    9ed4:	0f b6       	in	r0, 0x3f	; 63
    9ed6:	f8 94       	cli
    9ed8:	9e bf       	out	0x3e, r25	; 62
    9eda:	0f be       	out	0x3f, r0	; 63
    9edc:	8d bf       	out	0x3d, r24	; 61
    9ede:	ed b7       	in	r30, 0x3d	; 61
    9ee0:	fe b7       	in	r31, 0x3e	; 62
    9ee2:	31 96       	adiw	r30, 0x01	; 1
    9ee4:	8e 01       	movw	r16, r28
    9ee6:	0f 5f       	subi	r16, 0xFF	; 255
    9ee8:	1f 4f       	sbci	r17, 0xFF	; 255
    9eea:	ad b7       	in	r26, 0x3d	; 61
    9eec:	be b7       	in	r27, 0x3e	; 62
    9eee:	12 96       	adiw	r26, 0x02	; 2
    9ef0:	1c 93       	st	X, r17
    9ef2:	0e 93       	st	-X, r16
    9ef4:	11 97       	sbiw	r26, 0x01	; 1
    9ef6:	82 ef       	ldi	r24, 0xF2	; 242
    9ef8:	90 e2       	ldi	r25, 0x20	; 32
    9efa:	93 83       	std	Z+3, r25	; 0x03
    9efc:	82 83       	std	Z+2, r24	; 0x02
    9efe:	82 ef       	ldi	r24, 0xF2	; 242
    9f00:	95 e0       	ldi	r25, 0x05	; 5
    9f02:	95 83       	std	Z+5, r25	; 0x05
    9f04:	84 83       	std	Z+4, r24	; 0x04
    9f06:	8b ed       	ldi	r24, 0xDB	; 219
    9f08:	9d e0       	ldi	r25, 0x0D	; 13
    9f0a:	97 83       	std	Z+7, r25	; 0x07
    9f0c:	86 83       	std	Z+6, r24	; 0x06
    9f0e:	8a ee       	ldi	r24, 0xEA	; 234
    9f10:	99 e0       	ldi	r25, 0x09	; 9
    9f12:	91 87       	std	Z+9, r25	; 0x09
    9f14:	80 87       	std	Z+8, r24	; 0x08
    9f16:	87 e1       	ldi	r24, 0x17	; 23
    9f18:	9a e0       	ldi	r25, 0x0A	; 10
    9f1a:	93 87       	std	Z+11, r25	; 0x0b
    9f1c:	82 87       	std	Z+10, r24	; 0x0a
    9f1e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    9f22:	ed b7       	in	r30, 0x3d	; 61
    9f24:	fe b7       	in	r31, 0x3e	; 62
    9f26:	3c 96       	adiw	r30, 0x0c	; 12
    9f28:	0f b6       	in	r0, 0x3f	; 63
    9f2a:	f8 94       	cli
    9f2c:	fe bf       	out	0x3e, r31	; 62
    9f2e:	0f be       	out	0x3f, r0	; 63
    9f30:	ed bf       	out	0x3d, r30	; 61
    9f32:	81 e0       	ldi	r24, 0x01	; 1
    9f34:	60 e0       	ldi	r22, 0x00	; 0
    9f36:	a8 01       	movw	r20, r16
    9f38:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s%s%s"),strFIP_ID,strPaymentType,strRef1,strRef2);
    9f3c:	8d b7       	in	r24, 0x3d	; 61
    9f3e:	9e b7       	in	r25, 0x3e	; 62
    9f40:	0c 97       	sbiw	r24, 0x0c	; 12
    9f42:	0f b6       	in	r0, 0x3f	; 63
    9f44:	f8 94       	cli
    9f46:	9e bf       	out	0x3e, r25	; 62
    9f48:	0f be       	out	0x3f, r0	; 63
    9f4a:	8d bf       	out	0x3d, r24	; 61
    9f4c:	ed b7       	in	r30, 0x3d	; 61
    9f4e:	fe b7       	in	r31, 0x3e	; 62
    9f50:	31 96       	adiw	r30, 0x01	; 1
    9f52:	ad b7       	in	r26, 0x3d	; 61
    9f54:	be b7       	in	r27, 0x3e	; 62
    9f56:	12 96       	adiw	r26, 0x02	; 2
    9f58:	1c 93       	st	X, r17
    9f5a:	0e 93       	st	-X, r16
    9f5c:	11 97       	sbiw	r26, 0x01	; 1
    9f5e:	89 ee       	ldi	r24, 0xE9	; 233
    9f60:	90 e2       	ldi	r25, 0x20	; 32
    9f62:	93 83       	std	Z+3, r25	; 0x03
    9f64:	82 83       	std	Z+2, r24	; 0x02
    9f66:	88 ec       	ldi	r24, 0xC8	; 200
    9f68:	99 e0       	ldi	r25, 0x09	; 9
    9f6a:	95 83       	std	Z+5, r25	; 0x05
    9f6c:	84 83       	std	Z+4, r24	; 0x04
    9f6e:	8f e5       	ldi	r24, 0x5F	; 95
    9f70:	99 e0       	ldi	r25, 0x09	; 9
    9f72:	97 83       	std	Z+7, r25	; 0x07
    9f74:	86 83       	std	Z+6, r24	; 0x06
    9f76:	89 e9       	ldi	r24, 0x99	; 153
    9f78:	9e e0       	ldi	r25, 0x0E	; 14
    9f7a:	91 87       	std	Z+9, r25	; 0x09
    9f7c:	80 87       	std	Z+8, r24	; 0x08
    9f7e:	86 ea       	ldi	r24, 0xA6	; 166
    9f80:	9d e0       	ldi	r25, 0x0D	; 13
    9f82:	93 87       	std	Z+11, r25	; 0x0b
    9f84:	82 87       	std	Z+10, r24	; 0x0a
    9f86:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    9f8a:	ed b7       	in	r30, 0x3d	; 61
    9f8c:	fe b7       	in	r31, 0x3e	; 62
    9f8e:	3c 96       	adiw	r30, 0x0c	; 12
    9f90:	0f b6       	in	r0, 0x3f	; 63
    9f92:	f8 94       	cli
    9f94:	fe bf       	out	0x3e, r31	; 62
    9f96:	0f be       	out	0x3f, r0	; 63
    9f98:	ed bf       	out	0x3d, r30	; 61
    9f9a:	81 e0       	ldi	r24, 0x01	; 1
    9f9c:	60 e0       	ldi	r22, 0x00	; 0
    9f9e:	a8 01       	movw	r20, r16
    9fa0:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s"),strRef3,strRef4);
    9fa4:	8d b7       	in	r24, 0x3d	; 61
    9fa6:	9e b7       	in	r25, 0x3e	; 62
    9fa8:	08 97       	sbiw	r24, 0x08	; 8
    9faa:	0f b6       	in	r0, 0x3f	; 63
    9fac:	f8 94       	cli
    9fae:	9e bf       	out	0x3e, r25	; 62
    9fb0:	0f be       	out	0x3f, r0	; 63
    9fb2:	8d bf       	out	0x3d, r24	; 61
    9fb4:	ed b7       	in	r30, 0x3d	; 61
    9fb6:	fe b7       	in	r31, 0x3e	; 62
    9fb8:	31 96       	adiw	r30, 0x01	; 1
    9fba:	ad b7       	in	r26, 0x3d	; 61
    9fbc:	be b7       	in	r27, 0x3e	; 62
    9fbe:	12 96       	adiw	r26, 0x02	; 2
    9fc0:	1c 93       	st	X, r17
    9fc2:	0e 93       	st	-X, r16
    9fc4:	11 97       	sbiw	r26, 0x01	; 1
    9fc6:	84 ee       	ldi	r24, 0xE4	; 228
    9fc8:	90 e2       	ldi	r25, 0x20	; 32
    9fca:	93 83       	std	Z+3, r25	; 0x03
    9fcc:	82 83       	std	Z+2, r24	; 0x02
    9fce:	82 eb       	ldi	r24, 0xB2	; 178
    9fd0:	9a e0       	ldi	r25, 0x0A	; 10
    9fd2:	95 83       	std	Z+5, r25	; 0x05
    9fd4:	84 83       	std	Z+4, r24	; 0x04
    9fd6:	8b ea       	ldi	r24, 0xAB	; 171
    9fd8:	95 e0       	ldi	r25, 0x05	; 5
    9fda:	97 83       	std	Z+7, r25	; 0x07
    9fdc:	86 83       	std	Z+6, r24	; 0x06
    9fde:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    9fe2:	ed b7       	in	r30, 0x3d	; 61
    9fe4:	fe b7       	in	r31, 0x3e	; 62
    9fe6:	38 96       	adiw	r30, 0x08	; 8
    9fe8:	0f b6       	in	r0, 0x3f	; 63
    9fea:	f8 94       	cli
    9fec:	fe bf       	out	0x3e, r31	; 62
    9fee:	0f be       	out	0x3f, r0	; 63
    9ff0:	ed bf       	out	0x3d, r30	; 61
    9ff2:	81 e0       	ldi	r24, 0x01	; 1
    9ff4:	60 e0       	ldi	r22, 0x00	; 0
    9ff6:	a8 01       	movw	r20, r16
    9ff8:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	sprintf_P(strSend,PSTR("F968CFFB"));
    9ffc:	00 d0       	rcall	.+0      	; 0x9ffe <sendMessage32+0x164>
    9ffe:	00 d0       	rcall	.+0      	; 0xa000 <sendMessage32+0x166>
    a000:	ad b7       	in	r26, 0x3d	; 61
    a002:	be b7       	in	r27, 0x3e	; 62
    a004:	12 96       	adiw	r26, 0x02	; 2
    a006:	1c 93       	st	X, r17
    a008:	0e 93       	st	-X, r16
    a00a:	11 97       	sbiw	r26, 0x01	; 1
    a00c:	8b ed       	ldi	r24, 0xDB	; 219
    a00e:	90 e2       	ldi	r25, 0x20	; 32
    a010:	14 96       	adiw	r26, 0x04	; 4
    a012:	9c 93       	st	X, r25
    a014:	8e 93       	st	-X, r24
    a016:	13 97       	sbiw	r26, 0x03	; 3
    a018:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    a01c:	0f 90       	pop	r0
    a01e:	0f 90       	pop	r0
    a020:	0f 90       	pop	r0
    a022:	0f 90       	pop	r0
    a024:	81 e0       	ldi	r24, 0x01	; 1
    a026:	60 e0       	ldi	r22, 0x00	; 0
    a028:	a8 01       	movw	r20, r16
    a02a:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	_uart(1, 1,0x02);
    a02e:	81 e0       	ldi	r24, 0x01	; 1
    a030:	61 e0       	ldi	r22, 0x01	; 1
    a032:	42 e0       	ldi	r20, 0x02	; 2
    a034:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>

}
    a038:	c0 5b       	subi	r28, 0xB0	; 176
    a03a:	df 4f       	sbci	r29, 0xFF	; 255
    a03c:	0f b6       	in	r0, 0x3f	; 63
    a03e:	f8 94       	cli
    a040:	de bf       	out	0x3e, r29	; 62
    a042:	0f be       	out	0x3f, r0	; 63
    a044:	cd bf       	out	0x3d, r28	; 61
    a046:	cf 91       	pop	r28
    a048:	df 91       	pop	r29
    a04a:	1f 91       	pop	r17
    a04c:	0f 91       	pop	r16
    a04e:	08 95       	ret

0000a050 <sendMessage28>:
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage28(){//Msg28: <01>[0103192.168.016.070192.168.016.18024[FIP][CardID]F968CFFB]<02>
    a050:	0f 93       	push	r16
    a052:	1f 93       	push	r17
    a054:	df 93       	push	r29
    a056:	cf 93       	push	r28
    a058:	cd b7       	in	r28, 0x3d	; 61
    a05a:	de b7       	in	r29, 0x3e	; 62
    a05c:	ec 97       	sbiw	r28, 0x3c	; 60
    a05e:	0f b6       	in	r0, 0x3f	; 63
    a060:	f8 94       	cli
    a062:	de bf       	out	0x3e, r29	; 62
    a064:	0f be       	out	0x3f, r0	; 63
    a066:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a068:	81 e0       	ldi	r24, 0x01	; 1
    a06a:	61 e0       	ldi	r22, 0x01	; 1
    a06c:	41 e0       	ldi	r20, 0x01	; 1
    a06e:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a072:	0e 94 af 1a 	call	0x355e	; 0x355e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a076:	0e 94 9d 1a 	call	0x353a	; 0x353a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a07a:	0e 94 8b 1c 	call	0x3916	; 0x3916 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a07e:	0e 94 23 1c 	call	0x3846	; 0x3846 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s28"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a082:	8d b7       	in	r24, 0x3d	; 61
    a084:	9e b7       	in	r25, 0x3e	; 62
    a086:	0c 97       	sbiw	r24, 0x0c	; 12
    a088:	0f b6       	in	r0, 0x3f	; 63
    a08a:	f8 94       	cli
    a08c:	9e bf       	out	0x3e, r25	; 62
    a08e:	0f be       	out	0x3f, r0	; 63
    a090:	8d bf       	out	0x3d, r24	; 61
    a092:	ed b7       	in	r30, 0x3d	; 61
    a094:	fe b7       	in	r31, 0x3e	; 62
    a096:	31 96       	adiw	r30, 0x01	; 1
    a098:	8e 01       	movw	r16, r28
    a09a:	0f 5f       	subi	r16, 0xFF	; 255
    a09c:	1f 4f       	sbci	r17, 0xFF	; 255
    a09e:	ad b7       	in	r26, 0x3d	; 61
    a0a0:	be b7       	in	r27, 0x3e	; 62
    a0a2:	12 96       	adiw	r26, 0x02	; 2
    a0a4:	1c 93       	st	X, r17
    a0a6:	0e 93       	st	-X, r16
    a0a8:	11 97       	sbiw	r26, 0x01	; 1
    a0aa:	8a e0       	ldi	r24, 0x0A	; 10
    a0ac:	91 e2       	ldi	r25, 0x21	; 33
    a0ae:	93 83       	std	Z+3, r25	; 0x03
    a0b0:	82 83       	std	Z+2, r24	; 0x02
    a0b2:	82 ef       	ldi	r24, 0xF2	; 242
    a0b4:	95 e0       	ldi	r25, 0x05	; 5
    a0b6:	95 83       	std	Z+5, r25	; 0x05
    a0b8:	84 83       	std	Z+4, r24	; 0x04
    a0ba:	8b ed       	ldi	r24, 0xDB	; 219
    a0bc:	9d e0       	ldi	r25, 0x0D	; 13
    a0be:	97 83       	std	Z+7, r25	; 0x07
    a0c0:	86 83       	std	Z+6, r24	; 0x06
    a0c2:	8a ee       	ldi	r24, 0xEA	; 234
    a0c4:	99 e0       	ldi	r25, 0x09	; 9
    a0c6:	91 87       	std	Z+9, r25	; 0x09
    a0c8:	80 87       	std	Z+8, r24	; 0x08
    a0ca:	87 e1       	ldi	r24, 0x17	; 23
    a0cc:	9a e0       	ldi	r25, 0x0A	; 10
    a0ce:	93 87       	std	Z+11, r25	; 0x0b
    a0d0:	82 87       	std	Z+10, r24	; 0x0a
    a0d2:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    a0d6:	8d b7       	in	r24, 0x3d	; 61
    a0d8:	9e b7       	in	r25, 0x3e	; 62
    a0da:	0c 96       	adiw	r24, 0x0c	; 12
    a0dc:	0f b6       	in	r0, 0x3f	; 63
    a0de:	f8 94       	cli
    a0e0:	9e bf       	out	0x3e, r25	; 62
    a0e2:	0f be       	out	0x3f, r0	; 63
    a0e4:	8d bf       	out	0x3d, r24	; 61
    a0e6:	81 e0       	ldi	r24, 0x01	; 1
    a0e8:	60 e0       	ldi	r22, 0x00	; 0
    a0ea:	a8 01       	movw	r20, r16
    a0ec:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	UpdateCardID();
    a0f0:	0e 94 04 3c 	call	0x7808	; 0x7808 <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strFIP_ID,strCardID);
    a0f4:	ad b7       	in	r26, 0x3d	; 61
    a0f6:	be b7       	in	r27, 0x3e	; 62
    a0f8:	18 97       	sbiw	r26, 0x08	; 8
    a0fa:	0f b6       	in	r0, 0x3f	; 63
    a0fc:	f8 94       	cli
    a0fe:	be bf       	out	0x3e, r27	; 62
    a100:	0f be       	out	0x3f, r0	; 63
    a102:	ad bf       	out	0x3d, r26	; 61
    a104:	ed b7       	in	r30, 0x3d	; 61
    a106:	fe b7       	in	r31, 0x3e	; 62
    a108:	31 96       	adiw	r30, 0x01	; 1
    a10a:	12 96       	adiw	r26, 0x02	; 2
    a10c:	1c 93       	st	X, r17
    a10e:	0e 93       	st	-X, r16
    a110:	11 97       	sbiw	r26, 0x01	; 1
    a112:	8d ef       	ldi	r24, 0xFD	; 253
    a114:	90 e2       	ldi	r25, 0x20	; 32
    a116:	93 83       	std	Z+3, r25	; 0x03
    a118:	82 83       	std	Z+2, r24	; 0x02
    a11a:	88 ec       	ldi	r24, 0xC8	; 200
    a11c:	99 e0       	ldi	r25, 0x09	; 9
    a11e:	95 83       	std	Z+5, r25	; 0x05
    a120:	84 83       	std	Z+4, r24	; 0x04
    a122:	81 e9       	ldi	r24, 0x91	; 145
    a124:	9d e0       	ldi	r25, 0x0D	; 13
    a126:	97 83       	std	Z+7, r25	; 0x07
    a128:	86 83       	std	Z+6, r24	; 0x06
    a12a:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    a12e:	8d b7       	in	r24, 0x3d	; 61
    a130:	9e b7       	in	r25, 0x3e	; 62
    a132:	08 96       	adiw	r24, 0x08	; 8
    a134:	0f b6       	in	r0, 0x3f	; 63
    a136:	f8 94       	cli
    a138:	9e bf       	out	0x3e, r25	; 62
    a13a:	0f be       	out	0x3f, r0	; 63
    a13c:	8d bf       	out	0x3d, r24	; 61
    a13e:	81 e0       	ldi	r24, 0x01	; 1
    a140:	60 e0       	ldi	r22, 0x00	; 0
    a142:	a8 01       	movw	r20, r16
    a144:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	_uart(1, 1,0x02);
    a148:	81 e0       	ldi	r24, 0x01	; 1
    a14a:	61 e0       	ldi	r22, 0x01	; 1
    a14c:	42 e0       	ldi	r20, 0x02	; 2
    a14e:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
}
    a152:	ec 96       	adiw	r28, 0x3c	; 60
    a154:	0f b6       	in	r0, 0x3f	; 63
    a156:	f8 94       	cli
    a158:	de bf       	out	0x3e, r29	; 62
    a15a:	0f be       	out	0x3f, r0	; 63
    a15c:	cd bf       	out	0x3d, r28	; 61
    a15e:	cf 91       	pop	r28
    a160:	df 91       	pop	r29
    a162:	1f 91       	pop	r17
    a164:	0f 91       	pop	r16
    a166:	08 95       	ret

0000a168 <sendMessage24>:
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage24(){//Msg24: <01>[0103192.168.016.070192.168.016.18022[CardID]F968CFFB]<02>
    a168:	0f 93       	push	r16
    a16a:	1f 93       	push	r17
    a16c:	df 93       	push	r29
    a16e:	cf 93       	push	r28
    a170:	cd b7       	in	r28, 0x3d	; 61
    a172:	de b7       	in	r29, 0x3e	; 62
    a174:	ec 97       	sbiw	r28, 0x3c	; 60
    a176:	0f b6       	in	r0, 0x3f	; 63
    a178:	f8 94       	cli
    a17a:	de bf       	out	0x3e, r29	; 62
    a17c:	0f be       	out	0x3f, r0	; 63
    a17e:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a180:	81 e0       	ldi	r24, 0x01	; 1
    a182:	61 e0       	ldi	r22, 0x01	; 1
    a184:	41 e0       	ldi	r20, 0x01	; 1
    a186:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a18a:	0e 94 af 1a 	call	0x355e	; 0x355e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a18e:	0e 94 9d 1a 	call	0x353a	; 0x353a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a192:	0e 94 8b 1c 	call	0x3916	; 0x3916 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a196:	0e 94 23 1c 	call	0x3846	; 0x3846 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s24"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a19a:	8d b7       	in	r24, 0x3d	; 61
    a19c:	9e b7       	in	r25, 0x3e	; 62
    a19e:	0c 97       	sbiw	r24, 0x0c	; 12
    a1a0:	0f b6       	in	r0, 0x3f	; 63
    a1a2:	f8 94       	cli
    a1a4:	9e bf       	out	0x3e, r25	; 62
    a1a6:	0f be       	out	0x3f, r0	; 63
    a1a8:	8d bf       	out	0x3d, r24	; 61
    a1aa:	ed b7       	in	r30, 0x3d	; 61
    a1ac:	fe b7       	in	r31, 0x3e	; 62
    a1ae:	31 96       	adiw	r30, 0x01	; 1
    a1b0:	8e 01       	movw	r16, r28
    a1b2:	0f 5f       	subi	r16, 0xFF	; 255
    a1b4:	1f 4f       	sbci	r17, 0xFF	; 255
    a1b6:	ad b7       	in	r26, 0x3d	; 61
    a1b8:	be b7       	in	r27, 0x3e	; 62
    a1ba:	12 96       	adiw	r26, 0x02	; 2
    a1bc:	1c 93       	st	X, r17
    a1be:	0e 93       	st	-X, r16
    a1c0:	11 97       	sbiw	r26, 0x01	; 1
    a1c2:	82 e2       	ldi	r24, 0x22	; 34
    a1c4:	91 e2       	ldi	r25, 0x21	; 33
    a1c6:	93 83       	std	Z+3, r25	; 0x03
    a1c8:	82 83       	std	Z+2, r24	; 0x02
    a1ca:	82 ef       	ldi	r24, 0xF2	; 242
    a1cc:	95 e0       	ldi	r25, 0x05	; 5
    a1ce:	95 83       	std	Z+5, r25	; 0x05
    a1d0:	84 83       	std	Z+4, r24	; 0x04
    a1d2:	8b ed       	ldi	r24, 0xDB	; 219
    a1d4:	9d e0       	ldi	r25, 0x0D	; 13
    a1d6:	97 83       	std	Z+7, r25	; 0x07
    a1d8:	86 83       	std	Z+6, r24	; 0x06
    a1da:	8a ee       	ldi	r24, 0xEA	; 234
    a1dc:	99 e0       	ldi	r25, 0x09	; 9
    a1de:	91 87       	std	Z+9, r25	; 0x09
    a1e0:	80 87       	std	Z+8, r24	; 0x08
    a1e2:	87 e1       	ldi	r24, 0x17	; 23
    a1e4:	9a e0       	ldi	r25, 0x0A	; 10
    a1e6:	93 87       	std	Z+11, r25	; 0x0b
    a1e8:	82 87       	std	Z+10, r24	; 0x0a
    a1ea:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    a1ee:	8d b7       	in	r24, 0x3d	; 61
    a1f0:	9e b7       	in	r25, 0x3e	; 62
    a1f2:	0c 96       	adiw	r24, 0x0c	; 12
    a1f4:	0f b6       	in	r0, 0x3f	; 63
    a1f6:	f8 94       	cli
    a1f8:	9e bf       	out	0x3e, r25	; 62
    a1fa:	0f be       	out	0x3f, r0	; 63
    a1fc:	8d bf       	out	0x3d, r24	; 61
    a1fe:	81 e0       	ldi	r24, 0x01	; 1
    a200:	60 e0       	ldi	r22, 0x00	; 0
    a202:	a8 01       	movw	r20, r16
    a204:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	UpdateCardID();
    a208:	0e 94 04 3c 	call	0x7808	; 0x7808 <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    a20c:	ad b7       	in	r26, 0x3d	; 61
    a20e:	be b7       	in	r27, 0x3e	; 62
    a210:	18 97       	sbiw	r26, 0x08	; 8
    a212:	0f b6       	in	r0, 0x3f	; 63
    a214:	f8 94       	cli
    a216:	be bf       	out	0x3e, r27	; 62
    a218:	0f be       	out	0x3f, r0	; 63
    a21a:	ad bf       	out	0x3d, r26	; 61
    a21c:	ed b7       	in	r30, 0x3d	; 61
    a21e:	fe b7       	in	r31, 0x3e	; 62
    a220:	31 96       	adiw	r30, 0x01	; 1
    a222:	12 96       	adiw	r26, 0x02	; 2
    a224:	1c 93       	st	X, r17
    a226:	0e 93       	st	-X, r16
    a228:	11 97       	sbiw	r26, 0x01	; 1
    a22a:	85 e1       	ldi	r24, 0x15	; 21
    a22c:	91 e2       	ldi	r25, 0x21	; 33
    a22e:	93 83       	std	Z+3, r25	; 0x03
    a230:	82 83       	std	Z+2, r24	; 0x02
    a232:	81 e9       	ldi	r24, 0x91	; 145
    a234:	9d e0       	ldi	r25, 0x0D	; 13
    a236:	95 83       	std	Z+5, r25	; 0x05
    a238:	84 83       	std	Z+4, r24	; 0x04
    a23a:	88 ec       	ldi	r24, 0xC8	; 200
    a23c:	99 e0       	ldi	r25, 0x09	; 9
    a23e:	97 83       	std	Z+7, r25	; 0x07
    a240:	86 83       	std	Z+6, r24	; 0x06
    a242:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    a246:	8d b7       	in	r24, 0x3d	; 61
    a248:	9e b7       	in	r25, 0x3e	; 62
    a24a:	08 96       	adiw	r24, 0x08	; 8
    a24c:	0f b6       	in	r0, 0x3f	; 63
    a24e:	f8 94       	cli
    a250:	9e bf       	out	0x3e, r25	; 62
    a252:	0f be       	out	0x3f, r0	; 63
    a254:	8d bf       	out	0x3d, r24	; 61
    a256:	81 e0       	ldi	r24, 0x01	; 1
    a258:	60 e0       	ldi	r22, 0x00	; 0
    a25a:	a8 01       	movw	r20, r16
    a25c:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	_uart(1, 1,0x02);
    a260:	81 e0       	ldi	r24, 0x01	; 1
    a262:	61 e0       	ldi	r22, 0x01	; 1
    a264:	42 e0       	ldi	r20, 0x02	; 2
    a266:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
}
    a26a:	ec 96       	adiw	r28, 0x3c	; 60
    a26c:	0f b6       	in	r0, 0x3f	; 63
    a26e:	f8 94       	cli
    a270:	de bf       	out	0x3e, r29	; 62
    a272:	0f be       	out	0x3f, r0	; 63
    a274:	cd bf       	out	0x3d, r28	; 61
    a276:	cf 91       	pop	r28
    a278:	df 91       	pop	r29
    a27a:	1f 91       	pop	r17
    a27c:	0f 91       	pop	r16
    a27e:	08 95       	ret

0000a280 <sendMessage22>:
	sprintf_P(strSend,PSTR("%s%s%s%s10F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage22(){//Msg22: <01>[0103192.168.016.070192.168.016.18022[CardID]F968CFFB]<02>
    a280:	0f 93       	push	r16
    a282:	1f 93       	push	r17
    a284:	df 93       	push	r29
    a286:	cf 93       	push	r28
    a288:	cd b7       	in	r28, 0x3d	; 61
    a28a:	de b7       	in	r29, 0x3e	; 62
    a28c:	ec 97       	sbiw	r28, 0x3c	; 60
    a28e:	0f b6       	in	r0, 0x3f	; 63
    a290:	f8 94       	cli
    a292:	de bf       	out	0x3e, r29	; 62
    a294:	0f be       	out	0x3f, r0	; 63
    a296:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a298:	81 e0       	ldi	r24, 0x01	; 1
    a29a:	61 e0       	ldi	r22, 0x01	; 1
    a29c:	41 e0       	ldi	r20, 0x01	; 1
    a29e:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a2a2:	0e 94 af 1a 	call	0x355e	; 0x355e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a2a6:	0e 94 9d 1a 	call	0x353a	; 0x353a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a2aa:	0e 94 8b 1c 	call	0x3916	; 0x3916 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a2ae:	0e 94 23 1c 	call	0x3846	; 0x3846 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s22"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a2b2:	8d b7       	in	r24, 0x3d	; 61
    a2b4:	9e b7       	in	r25, 0x3e	; 62
    a2b6:	0c 97       	sbiw	r24, 0x0c	; 12
    a2b8:	0f b6       	in	r0, 0x3f	; 63
    a2ba:	f8 94       	cli
    a2bc:	9e bf       	out	0x3e, r25	; 62
    a2be:	0f be       	out	0x3f, r0	; 63
    a2c0:	8d bf       	out	0x3d, r24	; 61
    a2c2:	ed b7       	in	r30, 0x3d	; 61
    a2c4:	fe b7       	in	r31, 0x3e	; 62
    a2c6:	31 96       	adiw	r30, 0x01	; 1
    a2c8:	8e 01       	movw	r16, r28
    a2ca:	0f 5f       	subi	r16, 0xFF	; 255
    a2cc:	1f 4f       	sbci	r17, 0xFF	; 255
    a2ce:	ad b7       	in	r26, 0x3d	; 61
    a2d0:	be b7       	in	r27, 0x3e	; 62
    a2d2:	12 96       	adiw	r26, 0x02	; 2
    a2d4:	1c 93       	st	X, r17
    a2d6:	0e 93       	st	-X, r16
    a2d8:	11 97       	sbiw	r26, 0x01	; 1
    a2da:	88 e3       	ldi	r24, 0x38	; 56
    a2dc:	91 e2       	ldi	r25, 0x21	; 33
    a2de:	93 83       	std	Z+3, r25	; 0x03
    a2e0:	82 83       	std	Z+2, r24	; 0x02
    a2e2:	82 ef       	ldi	r24, 0xF2	; 242
    a2e4:	95 e0       	ldi	r25, 0x05	; 5
    a2e6:	95 83       	std	Z+5, r25	; 0x05
    a2e8:	84 83       	std	Z+4, r24	; 0x04
    a2ea:	8b ed       	ldi	r24, 0xDB	; 219
    a2ec:	9d e0       	ldi	r25, 0x0D	; 13
    a2ee:	97 83       	std	Z+7, r25	; 0x07
    a2f0:	86 83       	std	Z+6, r24	; 0x06
    a2f2:	8a ee       	ldi	r24, 0xEA	; 234
    a2f4:	99 e0       	ldi	r25, 0x09	; 9
    a2f6:	91 87       	std	Z+9, r25	; 0x09
    a2f8:	80 87       	std	Z+8, r24	; 0x08
    a2fa:	87 e1       	ldi	r24, 0x17	; 23
    a2fc:	9a e0       	ldi	r25, 0x0A	; 10
    a2fe:	93 87       	std	Z+11, r25	; 0x0b
    a300:	82 87       	std	Z+10, r24	; 0x0a
    a302:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    a306:	8d b7       	in	r24, 0x3d	; 61
    a308:	9e b7       	in	r25, 0x3e	; 62
    a30a:	0c 96       	adiw	r24, 0x0c	; 12
    a30c:	0f b6       	in	r0, 0x3f	; 63
    a30e:	f8 94       	cli
    a310:	9e bf       	out	0x3e, r25	; 62
    a312:	0f be       	out	0x3f, r0	; 63
    a314:	8d bf       	out	0x3d, r24	; 61
    a316:	81 e0       	ldi	r24, 0x01	; 1
    a318:	60 e0       	ldi	r22, 0x00	; 0
    a31a:	a8 01       	movw	r20, r16
    a31c:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	UpdateCardID();
    a320:	0e 94 04 3c 	call	0x7808	; 0x7808 <UpdateCardID>
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    a324:	00 d0       	rcall	.+0      	; 0xa326 <sendMessage22+0xa6>
    a326:	00 d0       	rcall	.+0      	; 0xa328 <sendMessage22+0xa8>
    a328:	00 d0       	rcall	.+0      	; 0xa32a <sendMessage22+0xaa>
    a32a:	ed b7       	in	r30, 0x3d	; 61
    a32c:	fe b7       	in	r31, 0x3e	; 62
    a32e:	31 96       	adiw	r30, 0x01	; 1
    a330:	ad b7       	in	r26, 0x3d	; 61
    a332:	be b7       	in	r27, 0x3e	; 62
    a334:	12 96       	adiw	r26, 0x02	; 2
    a336:	1c 93       	st	X, r17
    a338:	0e 93       	st	-X, r16
    a33a:	11 97       	sbiw	r26, 0x01	; 1
    a33c:	8d e2       	ldi	r24, 0x2D	; 45
    a33e:	91 e2       	ldi	r25, 0x21	; 33
    a340:	93 83       	std	Z+3, r25	; 0x03
    a342:	82 83       	std	Z+2, r24	; 0x02
    a344:	81 e9       	ldi	r24, 0x91	; 145
    a346:	9d e0       	ldi	r25, 0x0D	; 13
    a348:	95 83       	std	Z+5, r25	; 0x05
    a34a:	84 83       	std	Z+4, r24	; 0x04
    a34c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    a350:	8d b7       	in	r24, 0x3d	; 61
    a352:	9e b7       	in	r25, 0x3e	; 62
    a354:	06 96       	adiw	r24, 0x06	; 6
    a356:	0f b6       	in	r0, 0x3f	; 63
    a358:	f8 94       	cli
    a35a:	9e bf       	out	0x3e, r25	; 62
    a35c:	0f be       	out	0x3f, r0	; 63
    a35e:	8d bf       	out	0x3d, r24	; 61
    a360:	81 e0       	ldi	r24, 0x01	; 1
    a362:	60 e0       	ldi	r22, 0x00	; 0
    a364:	a8 01       	movw	r20, r16
    a366:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	_uart(1, 1,0x02);
    a36a:	81 e0       	ldi	r24, 0x01	; 1
    a36c:	61 e0       	ldi	r22, 0x01	; 1
    a36e:	42 e0       	ldi	r20, 0x02	; 2
    a370:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
}
    a374:	ec 96       	adiw	r28, 0x3c	; 60
    a376:	0f b6       	in	r0, 0x3f	; 63
    a378:	f8 94       	cli
    a37a:	de bf       	out	0x3e, r29	; 62
    a37c:	0f be       	out	0x3f, r0	; 63
    a37e:	cd bf       	out	0x3d, r28	; 61
    a380:	cf 91       	pop	r28
    a382:	df 91       	pop	r29
    a384:	1f 91       	pop	r17
    a386:	0f 91       	pop	r16
    a388:	08 95       	ret

0000a38a <sendMessage10>:
     _uart_print(1, 0,strSend);
	 _uart(1, 1,0x02);
}

/*Subrutine Msg10*/
void sendMessage10(){//Msg10: <01>[0103192.168.016.070192.168.016.18010F968CFFB]<02>
    a38a:	0f 93       	push	r16
    a38c:	1f 93       	push	r17
    a38e:	df 93       	push	r29
    a390:	cf 93       	push	r28
    a392:	cd b7       	in	r28, 0x3d	; 61
    a394:	de b7       	in	r29, 0x3e	; 62
    a396:	ec 97       	sbiw	r28, 0x3c	; 60
    a398:	0f b6       	in	r0, 0x3f	; 63
    a39a:	f8 94       	cli
    a39c:	de bf       	out	0x3e, r29	; 62
    a39e:	0f be       	out	0x3f, r0	; 63
    a3a0:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a3a2:	81 e0       	ldi	r24, 0x01	; 1
    a3a4:	61 e0       	ldi	r22, 0x01	; 1
    a3a6:	41 e0       	ldi	r20, 0x01	; 1
    a3a8:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a3ac:	0e 94 af 1a 	call	0x355e	; 0x355e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a3b0:	0e 94 9d 1a 	call	0x353a	; 0x353a <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a3b4:	0e 94 8b 1c 	call	0x3916	; 0x3916 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a3b8:	0e 94 23 1c 	call	0x3846	; 0x3846 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s10F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a3bc:	8d b7       	in	r24, 0x3d	; 61
    a3be:	9e b7       	in	r25, 0x3e	; 62
    a3c0:	0c 97       	sbiw	r24, 0x0c	; 12
    a3c2:	0f b6       	in	r0, 0x3f	; 63
    a3c4:	f8 94       	cli
    a3c6:	9e bf       	out	0x3e, r25	; 62
    a3c8:	0f be       	out	0x3f, r0	; 63
    a3ca:	8d bf       	out	0x3d, r24	; 61
    a3cc:	ed b7       	in	r30, 0x3d	; 61
    a3ce:	fe b7       	in	r31, 0x3e	; 62
    a3d0:	31 96       	adiw	r30, 0x01	; 1
    a3d2:	8e 01       	movw	r16, r28
    a3d4:	0f 5f       	subi	r16, 0xFF	; 255
    a3d6:	1f 4f       	sbci	r17, 0xFF	; 255
    a3d8:	ad b7       	in	r26, 0x3d	; 61
    a3da:	be b7       	in	r27, 0x3e	; 62
    a3dc:	12 96       	adiw	r26, 0x02	; 2
    a3de:	1c 93       	st	X, r17
    a3e0:	0e 93       	st	-X, r16
    a3e2:	11 97       	sbiw	r26, 0x01	; 1
    a3e4:	83 e4       	ldi	r24, 0x43	; 67
    a3e6:	91 e2       	ldi	r25, 0x21	; 33
    a3e8:	93 83       	std	Z+3, r25	; 0x03
    a3ea:	82 83       	std	Z+2, r24	; 0x02
    a3ec:	82 ef       	ldi	r24, 0xF2	; 242
    a3ee:	95 e0       	ldi	r25, 0x05	; 5
    a3f0:	95 83       	std	Z+5, r25	; 0x05
    a3f2:	84 83       	std	Z+4, r24	; 0x04
    a3f4:	8b ed       	ldi	r24, 0xDB	; 219
    a3f6:	9d e0       	ldi	r25, 0x0D	; 13
    a3f8:	97 83       	std	Z+7, r25	; 0x07
    a3fa:	86 83       	std	Z+6, r24	; 0x06
    a3fc:	8a ee       	ldi	r24, 0xEA	; 234
    a3fe:	99 e0       	ldi	r25, 0x09	; 9
    a400:	91 87       	std	Z+9, r25	; 0x09
    a402:	80 87       	std	Z+8, r24	; 0x08
    a404:	87 e1       	ldi	r24, 0x17	; 23
    a406:	9a e0       	ldi	r25, 0x0A	; 10
    a408:	93 87       	std	Z+11, r25	; 0x0b
    a40a:	82 87       	std	Z+10, r24	; 0x0a
    a40c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    _uart_print(1, 0,strSend);
    a410:	8d b7       	in	r24, 0x3d	; 61
    a412:	9e b7       	in	r25, 0x3e	; 62
    a414:	0c 96       	adiw	r24, 0x0c	; 12
    a416:	0f b6       	in	r0, 0x3f	; 63
    a418:	f8 94       	cli
    a41a:	9e bf       	out	0x3e, r25	; 62
    a41c:	0f be       	out	0x3f, r0	; 63
    a41e:	8d bf       	out	0x3d, r24	; 61
    a420:	81 e0       	ldi	r24, 0x01	; 1
    a422:	60 e0       	ldi	r22, 0x00	; 0
    a424:	a8 01       	movw	r20, r16
    a426:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	_uart(1, 1,0x02);
    a42a:	81 e0       	ldi	r24, 0x01	; 1
    a42c:	61 e0       	ldi	r22, 0x01	; 1
    a42e:	42 e0       	ldi	r20, 0x02	; 2
    a430:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
}
    a434:	ec 96       	adiw	r28, 0x3c	; 60
    a436:	0f b6       	in	r0, 0x3f	; 63
    a438:	f8 94       	cli
    a43a:	de bf       	out	0x3e, r29	; 62
    a43c:	0f be       	out	0x3f, r0	; 63
    a43e:	cd bf       	out	0x3d, r28	; 61
    a440:	cf 91       	pop	r28
    a442:	df 91       	pop	r29
    a444:	1f 91       	pop	r17
    a446:	0f 91       	pop	r16
    a448:	08 95       	ret

0000a44a <sendMessage04>:
	 }
		 sprintf_P(strServerIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
}

/*Subrutine Msg04*/
void sendMessage04(){   //      <STX>[IFTID][Seq][No][SrceIP][DestIP][MsgCode][ReceiptNo][Value][Checksum][ETX]
    a44a:	0f 93       	push	r16
    a44c:	1f 93       	push	r17
    a44e:	df 93       	push	r29
    a450:	cf 93       	push	r28
    a452:	cd b7       	in	r28, 0x3d	; 61
    a454:	de b7       	in	r29, 0x3e	; 62
    a456:	ec 97       	sbiw	r28, 0x3c	; 60
    a458:	0f b6       	in	r0, 0x3f	; 63
    a45a:	f8 94       	cli
    a45c:	de bf       	out	0x3e, r29	; 62
    a45e:	0f be       	out	0x3f, r0	; 63
    a460:	cd bf       	out	0x3d, r28	; 61
                        //Msg04: <01>[01][03][192.168.000.101][192.168.000.001][04][000001]0F968CFFB]<02>
	 char strSend[60];
	 _uart(1, 1,0x01);
    a462:	81 e0       	ldi	r24, 0x01	; 1
    a464:	61 e0       	ldi	r22, 0x01	; 1
    a466:	41 e0       	ldi	r20, 0x01	; 1
    a468:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
	 UpdateIFT_ID(); //ReadIFT_ID
    a46c:	0e 94 af 1a 	call	0x355e	; 0x355e <UpdateIFT_ID>
	 UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a470:	0e 94 9d 1a 	call	0x353a	; 0x353a <UpdateSeqNum>
	 UpdateClientIP();//ReadSourceIP
    a474:	0e 94 8b 1c 	call	0x3916	; 0x3916 <UpdateClientIP>
	 UpdateServerIP();//ReadDestIP
    a478:	0e 94 23 1c 	call	0x3846	; 0x3846 <UpdateServerIP>
	 //strTranNo = strReceiptNum
	 sprintf_P(strSend,PSTR("%s%s%s%s04%s1F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,strTranNo);
    a47c:	8d b7       	in	r24, 0x3d	; 61
    a47e:	9e b7       	in	r25, 0x3e	; 62
    a480:	0e 97       	sbiw	r24, 0x0e	; 14
    a482:	0f b6       	in	r0, 0x3f	; 63
    a484:	f8 94       	cli
    a486:	9e bf       	out	0x3e, r25	; 62
    a488:	0f be       	out	0x3f, r0	; 63
    a48a:	8d bf       	out	0x3d, r24	; 61
    a48c:	ed b7       	in	r30, 0x3d	; 61
    a48e:	fe b7       	in	r31, 0x3e	; 62
    a490:	31 96       	adiw	r30, 0x01	; 1
    a492:	8e 01       	movw	r16, r28
    a494:	0f 5f       	subi	r16, 0xFF	; 255
    a496:	1f 4f       	sbci	r17, 0xFF	; 255
    a498:	ad b7       	in	r26, 0x3d	; 61
    a49a:	be b7       	in	r27, 0x3e	; 62
    a49c:	12 96       	adiw	r26, 0x02	; 2
    a49e:	1c 93       	st	X, r17
    a4a0:	0e 93       	st	-X, r16
    a4a2:	11 97       	sbiw	r26, 0x01	; 1
    a4a4:	86 e5       	ldi	r24, 0x56	; 86
    a4a6:	91 e2       	ldi	r25, 0x21	; 33
    a4a8:	93 83       	std	Z+3, r25	; 0x03
    a4aa:	82 83       	std	Z+2, r24	; 0x02
    a4ac:	82 ef       	ldi	r24, 0xF2	; 242
    a4ae:	95 e0       	ldi	r25, 0x05	; 5
    a4b0:	95 83       	std	Z+5, r25	; 0x05
    a4b2:	84 83       	std	Z+4, r24	; 0x04
    a4b4:	8b ed       	ldi	r24, 0xDB	; 219
    a4b6:	9d e0       	ldi	r25, 0x0D	; 13
    a4b8:	97 83       	std	Z+7, r25	; 0x07
    a4ba:	86 83       	std	Z+6, r24	; 0x06
    a4bc:	8a ee       	ldi	r24, 0xEA	; 234
    a4be:	99 e0       	ldi	r25, 0x09	; 9
    a4c0:	91 87       	std	Z+9, r25	; 0x09
    a4c2:	80 87       	std	Z+8, r24	; 0x08
    a4c4:	87 e1       	ldi	r24, 0x17	; 23
    a4c6:	9a e0       	ldi	r25, 0x0A	; 10
    a4c8:	93 87       	std	Z+11, r25	; 0x0b
    a4ca:	82 87       	std	Z+10, r24	; 0x0a
    a4cc:	82 e9       	ldi	r24, 0x92	; 146
    a4ce:	9e e0       	ldi	r25, 0x0E	; 14
    a4d0:	95 87       	std	Z+13, r25	; 0x0d
    a4d2:	84 87       	std	Z+12, r24	; 0x0c
    a4d4:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
     _uart_print(1, 0,strSend);
    a4d8:	8d b7       	in	r24, 0x3d	; 61
    a4da:	9e b7       	in	r25, 0x3e	; 62
    a4dc:	0e 96       	adiw	r24, 0x0e	; 14
    a4de:	0f b6       	in	r0, 0x3f	; 63
    a4e0:	f8 94       	cli
    a4e2:	9e bf       	out	0x3e, r25	; 62
    a4e4:	0f be       	out	0x3f, r0	; 63
    a4e6:	8d bf       	out	0x3d, r24	; 61
    a4e8:	81 e0       	ldi	r24, 0x01	; 1
    a4ea:	60 e0       	ldi	r22, 0x00	; 0
    a4ec:	a8 01       	movw	r20, r16
    a4ee:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	 _uart(1, 1,0x02);
    a4f2:	81 e0       	ldi	r24, 0x01	; 1
    a4f4:	61 e0       	ldi	r22, 0x01	; 1
    a4f6:	42 e0       	ldi	r20, 0x02	; 2
    a4f8:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
}
    a4fc:	ec 96       	adiw	r28, 0x3c	; 60
    a4fe:	0f b6       	in	r0, 0x3f	; 63
    a500:	f8 94       	cli
    a502:	de bf       	out	0x3e, r29	; 62
    a504:	0f be       	out	0x3f, r0	; 63
    a506:	cd bf       	out	0x3d, r28	; 61
    a508:	cf 91       	pop	r28
    a50a:	df 91       	pop	r29
    a50c:	1f 91       	pop	r17
    a50e:	0f 91       	pop	r16
    a510:	08 95       	ret

0000a512 <FreePrinting>:
	 } 
	 else _uart(_COM_PRINTER,1,xSend);
	 zSend=xSend;
}

void FreePrinting(){
    a512:	0f 93       	push	r16
    a514:	1f 93       	push	r17
static char iPrinted=0,iHeader=0,iFooter=0,PrintCopy=0,iMargin=0,iScroll=0,nScroll=0;
static char strHeader[41];
static unsigned int iSend=0,LSend=0,iLoop=0;

     //Normalize FreePrintIdleState
     if ((IsFreePrinting==True)&&(stFreePrinting!=fpInit)){
    a516:	20 91 d5 01 	lds	r18, 0x01D5
    a51a:	21 30       	cpi	r18, 0x01	; 1
    a51c:	31 f4       	brne	.+12     	; 0xa52a <FreePrinting+0x18>
    a51e:	80 91 3a 01 	lds	r24, 0x013A
    a522:	81 30       	cpi	r24, 0x01	; 1
    a524:	11 f0       	breq	.+4      	; 0xa52a <FreePrinting+0x18>
	     stFreePrinting=fpInit;
    a526:	20 93 3a 01 	sts	0x013A, r18
	 }

	 switch (stFreePrinting){
    a52a:	80 91 3a 01 	lds	r24, 0x013A
    a52e:	90 e0       	ldi	r25, 0x00	; 0
    a530:	fc 01       	movw	r30, r24
    a532:	31 97       	sbiw	r30, 0x01	; 1
    a534:	e5 31       	cpi	r30, 0x15	; 21
    a536:	f1 05       	cpc	r31, r1
    a538:	08 f0       	brcs	.+2      	; 0xa53c <FreePrinting+0x2a>
    a53a:	7e c2       	rjmp	.+1276   	; 0xaa38 <FreePrinting+0x526>
    a53c:	ec 59       	subi	r30, 0x9C	; 156
    a53e:	ff 4f       	sbci	r31, 0xFF	; 255
    a540:	ee 0f       	add	r30, r30
    a542:	ff 1f       	adc	r31, r31
    a544:	05 90       	lpm	r0, Z+
    a546:	f4 91       	lpm	r31, Z+
    a548:	e0 2d       	mov	r30, r0
    a54a:	09 94       	ijmp
     case fpInit:
	      //_uart_printf(0,1,PSTR("fpInit"));
	      if (IsFreePrinting==True){
    a54c:	21 30       	cpi	r18, 0x01	; 1
    a54e:	09 f0       	breq	.+2      	; 0xa552 <FreePrinting+0x40>
    a550:	73 c2       	rjmp	.+1254   	; 0xaa38 <FreePrinting+0x526>
		      IsFreePrinting=False;
    a552:	10 92 d5 01 	sts	0x01D5, r1
			  IsBusyFreePrinting=True;
    a556:	20 93 de 01 	sts	0x01DE, r18
			  IsBusyPrint=False;
    a55a:	10 92 dd 01 	sts	0x01DD, r1
			  iPrinted=0,iFooter=0;
    a55e:	10 92 a5 02 	sts	0x02A5, r1
    a562:	10 92 a3 02 	sts	0x02A3, r1

			  PrintCopy=(cmdPrint&0x0F);
    a566:	80 91 e0 01 	lds	r24, 0x01E0
    a56a:	8f 70       	andi	r24, 0x0F	; 15
    a56c:	80 93 a2 02 	sts	0x02A2, r24

			  //cmdPrint=cmdPrint|0b00100000;
			  //PrintCopy=2;

			  stFreePrinting=fpInitHeader;
    a570:	82 e0       	ldi	r24, 0x02	; 2
    a572:	80 93 3a 01 	sts	0x013A, r24
			  InitPrinter();
    a576:	0e 94 a6 4a 	call	0x954c	; 0x954c <InitPrinter>
    a57a:	5e c2       	rjmp	.+1212   	; 0xaa38 <FreePrinting+0x526>
			  }
	      break;
     case fpInitHeader:
	      //_uart_printf(0,1,PSTR("fpInitHeader"));
		  iHeader=0;
    a57c:	10 92 a4 02 	sts	0x02A4, r1
	      if (((cmdPrint&0b10000000)>>7)==1){
    a580:	80 91 e0 01 	lds	r24, 0x01E0
    a584:	88 1f       	adc	r24, r24
    a586:	88 27       	eor	r24, r24
    a588:	88 1f       	adc	r24, r24
    a58a:	90 e0       	ldi	r25, 0x00	; 0
    a58c:	81 30       	cpi	r24, 0x01	; 1
    a58e:	91 05       	cpc	r25, r1
    a590:	21 f1       	breq	.+72     	; 0xa5da <FreePrinting+0xc8>
		      stFreePrinting=fpLoadHeader;
			  }
		  else
	      if (((cmdPrint&0b10000000)>>7)==0) stFreePrinting=fpInitMessage;	      
    a592:	89 2b       	or	r24, r25
    a594:	09 f0       	breq	.+2      	; 0xa598 <FreePrinting+0x86>
    a596:	50 c2       	rjmp	.+1184   	; 0xaa38 <FreePrinting+0x526>
    a598:	85 e0       	ldi	r24, 0x05	; 5
    a59a:	80 93 3a 01 	sts	0x013A, r24
    a59e:	4c c2       	rjmp	.+1176   	; 0xaa38 <FreePrinting+0x526>
    a5a0:	60 91 a4 02 	lds	r22, 0x02A4
    a5a4:	89 e2       	ldi	r24, 0x29	; 41
    a5a6:	68 9f       	mul	r22, r24
    a5a8:	b0 01       	movw	r22, r0
    a5aa:	11 24       	eor	r1, r1
    a5ac:	69 5a       	subi	r22, 0xA9	; 169
    a5ae:	7d 4f       	sbci	r23, 0xFD	; 253
    a5b0:	86 e7       	ldi	r24, 0x76	; 118
    a5b2:	92 e0       	ldi	r25, 0x02	; 2
    a5b4:	48 e2       	ldi	r20, 0x28	; 40
    a5b6:	50 e0       	ldi	r21, 0x00	; 0
    a5b8:	2c ea       	ldi	r18, 0xAC	; 172
    a5ba:	32 e1       	ldi	r19, 0x12	; 18
    a5bc:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
	      break;
     case fpLoadHeader:
	      //_uart_printf(0,1,PSTR("fpLoadHeader"));
          //Header 1
	      eeprom_read_block((void*) &strHeader, (const void*) &DefHeaderFooter[iHeader], 40);
		  iHeader++;
    a5c0:	00 91 a4 02 	lds	r16, 0x02A4
    a5c4:	0f 5f       	subi	r16, 0xFF	; 255
    a5c6:	00 93 a4 02 	sts	0x02A4, r16
		  if (iHeader<6){
    a5ca:	06 30       	cpi	r16, 0x06	; 6
    a5cc:	28 f7       	brcc	.-54     	; 0xa598 <FreePrinting+0x86>
		      if (SpaceOnly(strHeader)==True){
    a5ce:	86 e7       	ldi	r24, 0x76	; 118
    a5d0:	92 e0       	ldi	r25, 0x02	; 2
    a5d2:	0e 94 44 21 	call	0x4288	; 0x4288 <SpaceOnly>
    a5d6:	81 30       	cpi	r24, 0x01	; 1
    a5d8:	11 f4       	brne	.+4      	; 0xa5de <FreePrinting+0xcc>
			      stFreePrinting=fpLoadHeader;
    a5da:	83 e0       	ldi	r24, 0x03	; 3
    a5dc:	de cf       	rjmp	.-68     	; 0xa59a <FreePrinting+0x88>
				  }	      
			  else{
			      stFreePrinting=fpPrintHeader;
    a5de:	84 e0       	ldi	r24, 0x04	; 4
    a5e0:	80 93 3a 01 	sts	0x013A, r24
			      iSend=0;
    a5e4:	10 92 75 02 	sts	0x0275, r1
    a5e8:	10 92 74 02 	sts	0x0274, r1
				  iLoop=0;
    a5ec:	10 92 71 02 	sts	0x0271, r1
    a5f0:	10 92 70 02 	sts	0x0270, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    a5f4:	01 30       	cpi	r16, 0x01	; 1
    a5f6:	19 f4       	brne	.+6      	; 0xa5fe <FreePrinting+0xec>
    a5f8:	0e 94 28 4b 	call	0x9650	; 0x9650 <PrintDoubleHeight>
    a5fc:	1d c2       	rjmp	.+1082   	; 0xaa38 <FreePrinting+0x526>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    a5fe:	02 30       	cpi	r16, 0x02	; 2
    a600:	09 f0       	breq	.+2      	; 0xa604 <FreePrinting+0xf2>
    a602:	1a c2       	rjmp	.+1076   	; 0xaa38 <FreePrinting+0x526>
    a604:	0e 94 0e 4b 	call	0x961c	; 0x961c <PrintNormalHeight>
    a608:	17 c2       	rjmp	.+1070   	; 0xaa38 <FreePrinting+0x526>
		  {stFreePrinting=fpInitMessage;
		  }
	      break;
     case fpPrintHeader:
	      //_uart_printf(0,1,PSTR("fpPrintHeader"));
		  if (iSend<40){
    a60a:	80 91 74 02 	lds	r24, 0x0274
    a60e:	90 91 75 02 	lds	r25, 0x0275
    a612:	88 97       	sbiw	r24, 0x28	; 40
    a614:	78 f4       	brcc	.+30     	; 0xa634 <FreePrinting+0x122>
		      iLoop++;
    a616:	80 91 70 02 	lds	r24, 0x0270
    a61a:	90 91 71 02 	lds	r25, 0x0271
    a61e:	01 96       	adiw	r24, 0x01	; 1
    a620:	90 93 71 02 	sts	0x0271, r25
    a624:	80 93 70 02 	sts	0x0270, r24
			  if ((iLoop%PRINT_DELAY)==0){
			     //_uart(_COM_PRINTER,1,strHeader[iSend]);
		         //iSend++;
				 TimPrintBusy=0;
    a628:	10 92 e2 01 	sts	0x01E2, r1
    a62c:	10 92 e1 01 	sts	0x01E1, r1
				 stFreePrinting=fpCheckPrintStatusHeader;
    a630:	82 e1       	ldi	r24, 0x12	; 18
    a632:	b3 cf       	rjmp	.-154    	; 0xa59a <FreePrinting+0x88>
				 }
			  }
          else{ 
		     stFreePrinting=fpLoadHeader;
    a634:	83 e0       	ldi	r24, 0x03	; 3
    a636:	57 c1       	rjmp	.+686    	; 0xa8e6 <FreePrinting+0x3d4>
			 CarriegeReturn();
		  }
	      break;

     case fpCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    a638:	80 91 dd 01 	lds	r24, 0x01DD
    a63c:	88 23       	and	r24, r24
    a63e:	09 f0       	breq	.+2      	; 0xa642 <FreePrinting+0x130>
    a640:	71 c1       	rjmp	.+738    	; 0xa924 <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    a642:	e0 91 74 02 	lds	r30, 0x0274
    a646:	f0 91 75 02 	lds	r31, 0x0275
    a64a:	ea 58       	subi	r30, 0x8A	; 138
    a64c:	fd 4f       	sbci	r31, 0xFD	; 253
    a64e:	61 e0       	ldi	r22, 0x01	; 1
    a650:	40 81       	ld	r20, Z
    a652:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
		      iSend++;
    a656:	80 91 74 02 	lds	r24, 0x0274
    a65a:	90 91 75 02 	lds	r25, 0x0275
    a65e:	01 96       	adiw	r24, 0x01	; 1
    a660:	90 93 75 02 	sts	0x0275, r25
    a664:	80 93 74 02 	sts	0x0274, r24
		      stFreePrinting=fpPrintHeader;
    a668:	84 e0       	ldi	r24, 0x04	; 4
    a66a:	5a c1       	rjmp	.+692    	; 0xa920 <FreePrinting+0x40e>
			  }
	      break;

     case fpInitMessage:
	      //_uart_printf(0,1,PSTR("fpInitMessage"));
	      iSend=0;iLoop=0;
    a66c:	10 92 75 02 	sts	0x0275, r1
    a670:	10 92 74 02 	sts	0x0274, r1
    a674:	10 92 71 02 	sts	0x0271, r1
    a678:	10 92 70 02 	sts	0x0270, r1
          stFreePrinting=fpPrintMessage; 
    a67c:	08 e0       	ldi	r16, 0x08	; 8
    a67e:	00 93 3a 01 	sts	0x013A, r16
		  CarriegeReturn();
    a682:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		  if (iPrinted>0) stFreePrinting=fpInitDuplicate;
    a686:	80 91 a5 02 	lds	r24, 0x02A5
    a68a:	88 23       	and	r24, r24
    a68c:	11 f0       	breq	.+4      	; 0xa692 <FreePrinting+0x180>
    a68e:	86 e0       	ldi	r24, 0x06	; 6
    a690:	84 cf       	rjmp	.-248    	; 0xa59a <FreePrinting+0x88>
		  else stFreePrinting=fpPrintMessage; 
    a692:	00 93 3a 01 	sts	0x013A, r16
    a696:	d0 c1       	rjmp	.+928    	; 0xaa38 <FreePrinting+0x526>
	      break;
     case fpInitDuplicate:
	      //_uart_printf(0,1,PSTR("fpInitDuplicate"));
          if (iPrinted>0)sprintf_P(strHeader,PSTR("             DUPLICATE COPY        "));
    a698:	80 91 a5 02 	lds	r24, 0x02A5
    a69c:	26 e7       	ldi	r18, 0x76	; 118
    a69e:	32 e0       	ldi	r19, 0x02	; 2
    a6a0:	88 23       	and	r24, r24
    a6a2:	49 f0       	breq	.+18     	; 0xa6b6 <FreePrinting+0x1a4>
    a6a4:	00 d0       	rcall	.+0      	; 0xa6a6 <FreePrinting+0x194>
    a6a6:	00 d0       	rcall	.+0      	; 0xa6a8 <FreePrinting+0x196>
    a6a8:	ed b7       	in	r30, 0x3d	; 61
    a6aa:	fe b7       	in	r31, 0x3e	; 62
    a6ac:	32 83       	std	Z+2, r19	; 0x02
    a6ae:	21 83       	std	Z+1, r18	; 0x01
    a6b0:	8c e9       	ldi	r24, 0x9C	; 156
    a6b2:	96 e0       	ldi	r25, 0x06	; 6
    a6b4:	08 c0       	rjmp	.+16     	; 0xa6c6 <FreePrinting+0x1b4>
          else           sprintf_P(strHeader,PSTR("                                   "));
    a6b6:	00 d0       	rcall	.+0      	; 0xa6b8 <FreePrinting+0x1a6>
    a6b8:	00 d0       	rcall	.+0      	; 0xa6ba <FreePrinting+0x1a8>
    a6ba:	ed b7       	in	r30, 0x3d	; 61
    a6bc:	fe b7       	in	r31, 0x3e	; 62
    a6be:	32 83       	std	Z+2, r19	; 0x02
    a6c0:	21 83       	std	Z+1, r18	; 0x01
    a6c2:	88 e7       	ldi	r24, 0x78	; 120
    a6c4:	96 e0       	ldi	r25, 0x06	; 6
    a6c6:	94 83       	std	Z+4, r25	; 0x04
    a6c8:	83 83       	std	Z+3, r24	; 0x03
    a6ca:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    a6ce:	0f 90       	pop	r0
    a6d0:	0f 90       	pop	r0
    a6d2:	0f 90       	pop	r0
    a6d4:	0f 90       	pop	r0
		  iSend=0;
    a6d6:	10 92 75 02 	sts	0x0275, r1
    a6da:	10 92 74 02 	sts	0x0274, r1
		  iLoop=0;
    a6de:	10 92 71 02 	sts	0x0271, r1
    a6e2:	10 92 70 02 	sts	0x0270, r1
		  LSend=strlen(strHeader);
    a6e6:	e6 e7       	ldi	r30, 0x76	; 118
    a6e8:	f2 e0       	ldi	r31, 0x02	; 2
    a6ea:	01 90       	ld	r0, Z+
    a6ec:	00 20       	and	r0, r0
    a6ee:	e9 f7       	brne	.-6      	; 0xa6ea <FreePrinting+0x1d8>
    a6f0:	31 97       	sbiw	r30, 0x01	; 1
    a6f2:	e6 57       	subi	r30, 0x76	; 118
    a6f4:	f2 40       	sbci	r31, 0x02	; 2
    a6f6:	f0 93 73 02 	sts	0x0273, r31
    a6fa:	e0 93 72 02 	sts	0x0272, r30
          stFreePrinting=fpPrintDuplicate; 
    a6fe:	87 e0       	ldi	r24, 0x07	; 7
    a700:	4c cf       	rjmp	.-360    	; 0xa59a <FreePrinting+0x88>
	      break;
     case fpPrintDuplicate:
	      //_uart_printf(0,1,PSTR("fpPrintDuplicate"));
		  if (iSend<LSend){
    a702:	20 91 74 02 	lds	r18, 0x0274
    a706:	30 91 75 02 	lds	r19, 0x0275
    a70a:	80 91 72 02 	lds	r24, 0x0272
    a70e:	90 91 73 02 	lds	r25, 0x0273
    a712:	28 17       	cp	r18, r24
    a714:	39 07       	cpc	r19, r25
    a716:	78 f4       	brcc	.+30     	; 0xa736 <FreePrinting+0x224>
		      iLoop++;
    a718:	80 91 70 02 	lds	r24, 0x0270
    a71c:	90 91 71 02 	lds	r25, 0x0271
    a720:	01 96       	adiw	r24, 0x01	; 1
    a722:	90 93 71 02 	sts	0x0271, r25
    a726:	80 93 70 02 	sts	0x0270, r24
			  if((iLoop%PRINT_DELAY)==0){
			     //_uart(_COM_PRINTER,1,strHeader[iSend]);
				 //iSend++;
				 TimPrintBusy=0;
    a72a:	10 92 e2 01 	sts	0x01E2, r1
    a72e:	10 92 e1 01 	sts	0x01E1, r1
                 stFreePrinting=fpCheckPrintStatusDuplicate;
    a732:	85 e1       	ldi	r24, 0x15	; 21
    a734:	32 cf       	rjmp	.-412    	; 0xa59a <FreePrinting+0x88>
				 }
			  }
          else {
		     iSend=0;
    a736:	10 92 75 02 	sts	0x0275, r1
    a73a:	10 92 74 02 	sts	0x0274, r1
		     stFreePrinting=fpPrintMessage;
    a73e:	88 e0       	ldi	r24, 0x08	; 8
    a740:	d2 c0       	rjmp	.+420    	; 0xa8e6 <FreePrinting+0x3d4>
			 CarriegeReturn();	      
			 }
	      break;
     case fpCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    a742:	80 91 dd 01 	lds	r24, 0x01DD
    a746:	88 23       	and	r24, r24
    a748:	09 f0       	breq	.+2      	; 0xa74c <FreePrinting+0x23a>
    a74a:	ec c0       	rjmp	.+472    	; 0xa924 <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    a74c:	e0 91 74 02 	lds	r30, 0x0274
    a750:	f0 91 75 02 	lds	r31, 0x0275
    a754:	ea 58       	subi	r30, 0x8A	; 138
    a756:	fd 4f       	sbci	r31, 0xFD	; 253
    a758:	61 e0       	ldi	r22, 0x01	; 1
    a75a:	40 81       	ld	r20, Z
    a75c:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
		      iSend++;
    a760:	80 91 74 02 	lds	r24, 0x0274
    a764:	90 91 75 02 	lds	r25, 0x0275
    a768:	01 96       	adiw	r24, 0x01	; 1
    a76a:	90 93 75 02 	sts	0x0275, r25
    a76e:	80 93 74 02 	sts	0x0274, r24
		      stFreePrinting=fpPrintDuplicate;
    a772:	87 e0       	ldi	r24, 0x07	; 7
    a774:	d5 c0       	rjmp	.+426    	; 0xa920 <FreePrinting+0x40e>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;

     case fpPrintMessage:
		  if (iSend<LengthMessage81){
    a776:	20 91 74 02 	lds	r18, 0x0274
    a77a:	30 91 75 02 	lds	r19, 0x0275
    a77e:	80 91 b5 01 	lds	r24, 0x01B5
    a782:	90 91 b6 01 	lds	r25, 0x01B6
    a786:	28 17       	cp	r18, r24
    a788:	39 07       	cpc	r19, r25
    a78a:	78 f4       	brcc	.+30     	; 0xa7aa <FreePrinting+0x298>
		      iLoop++;
    a78c:	80 91 70 02 	lds	r24, 0x0270
    a790:	90 91 71 02 	lds	r25, 0x0271
    a794:	01 96       	adiw	r24, 0x01	; 1
    a796:	90 93 71 02 	sts	0x0271, r25
    a79a:	80 93 70 02 	sts	0x0270, r24
			  if((iLoop%PRINT_DELAY)==0){
			     TimPrintBusy=0;
    a79e:	10 92 e2 01 	sts	0x01E2, r1
    a7a2:	10 92 e1 01 	sts	0x01E1, r1
				 stFreePrinting=fpCheckPrintStatusMessage;
    a7a6:	83 e1       	ldi	r24, 0x13	; 19
    a7a8:	f8 ce       	rjmp	.-528    	; 0xa59a <FreePrinting+0x88>
				 }
			  }
          else stFreePrinting=fpInitFooter;
    a7aa:	8b e0       	ldi	r24, 0x0B	; 11
    a7ac:	f6 ce       	rjmp	.-532    	; 0xa59a <FreePrinting+0x88>
	      break;
     
     case fpCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    a7ae:	80 91 dd 01 	lds	r24, 0x01DD
    a7b2:	88 23       	and	r24, r24
    a7b4:	09 f0       	breq	.+2      	; 0xa7b8 <FreePrinting+0x2a6>
    a7b6:	b6 c0       	rjmp	.+364    	; 0xa924 <FreePrinting+0x412>
              if ((PrintBuffer[iSend]!=0x0D)||(PrintBuffer[iSend]!=0x0A))
			      SendPrint(PrintBuffer[iSend],PrintBuffer[iSend+1]);
    a7b8:	e0 91 74 02 	lds	r30, 0x0274
    a7bc:	f0 91 75 02 	lds	r31, 0x0275
    a7c0:	e9 50       	subi	r30, 0x09	; 9
    a7c2:	fa 4f       	sbci	r31, 0xFA	; 250
    a7c4:	80 81       	ld	r24, Z
    a7c6:	61 81       	ldd	r22, Z+1	; 0x01
    a7c8:	0e 94 83 4a 	call	0x9506	; 0x9506 <SendPrint>
			     // _uart(_COM_PRINTER,1,PrintBuffer[iSend]);
              if ((PrintBuffer[iSend]==0x0D)||(PrintBuffer[iSend+1]==0x0A))
    a7cc:	e0 91 74 02 	lds	r30, 0x0274
    a7d0:	f0 91 75 02 	lds	r31, 0x0275
    a7d4:	e9 50       	subi	r30, 0x09	; 9
    a7d6:	fa 4f       	sbci	r31, 0xFA	; 250
    a7d8:	80 81       	ld	r24, Z
    a7da:	8d 30       	cpi	r24, 0x0D	; 13
    a7dc:	19 f0       	breq	.+6      	; 0xa7e4 <FreePrinting+0x2d2>
    a7de:	81 81       	ldd	r24, Z+1	; 0x01
    a7e0:	8a 30       	cpi	r24, 0x0A	; 10
    a7e2:	11 f4       	brne	.+4      	; 0xa7e8 <FreePrinting+0x2d6>
			     CarriegeReturn();
    a7e4:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
             iSend++;
    a7e8:	80 91 74 02 	lds	r24, 0x0274
    a7ec:	90 91 75 02 	lds	r25, 0x0275
    a7f0:	01 96       	adiw	r24, 0x01	; 1
    a7f2:	90 93 75 02 	sts	0x0275, r25
    a7f6:	80 93 74 02 	sts	0x0274, r24
		     stFreePrinting=fpPrintMessage;
    a7fa:	88 e0       	ldi	r24, 0x08	; 8
    a7fc:	91 c0       	rjmp	.+290    	; 0xa920 <FreePrinting+0x40e>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;
     //SpaceAdded
	 case fpInitSpace:
	      iLoop=0;
    a7fe:	10 92 71 02 	sts	0x0271, r1
    a802:	10 92 70 02 	sts	0x0270, r1
		  iMargin=0;
    a806:	10 92 a1 02 	sts	0x02A1, r1
		  stFreePrinting=fpPrintMargin;
    a80a:	8a e0       	ldi	r24, 0x0A	; 10
    a80c:	c6 ce       	rjmp	.-628    	; 0xa59a <FreePrinting+0x88>
	      break;
	 case fpPrintMargin:
		  if (iMargin<PRINT_MARGIN){
    a80e:	80 91 a1 02 	lds	r24, 0x02A1
    a812:	85 30       	cpi	r24, 0x05	; 5
    a814:	90 f4       	brcc	.+36     	; 0xa83a <FreePrinting+0x328>
		      iMargin++;
    a816:	8f 5f       	subi	r24, 0xFF	; 255
    a818:	80 93 a1 02 	sts	0x02A1, r24
		      iLoop++;
    a81c:	80 91 70 02 	lds	r24, 0x0270
    a820:	90 91 71 02 	lds	r25, 0x0271
    a824:	01 96       	adiw	r24, 0x01	; 1
    a826:	90 93 71 02 	sts	0x0271, r25
    a82a:	80 93 70 02 	sts	0x0270, r24
	          if ((iLoop%PRINT_DELAY)==0)_uart(_COM_PRINTER,1,' ');
    a82e:	80 e0       	ldi	r24, 0x00	; 0
    a830:	61 e0       	ldi	r22, 0x01	; 1
    a832:	40 e2       	ldi	r20, 0x20	; 32
    a834:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
    a838:	ff c0       	rjmp	.+510    	; 0xaa38 <FreePrinting+0x526>
			 }
          else stFreePrinting=fpPrintMessage;
    a83a:	88 e0       	ldi	r24, 0x08	; 8
    a83c:	ae ce       	rjmp	.-676    	; 0xa59a <FreePrinting+0x88>
	      break;
     case fpInitFooter:
	      //_uart_printf(0,1,PSTR("fpInitFooter"));
          if (((cmdPrint&0b01000000)>>6)==1){
    a83e:	80 91 e0 01 	lds	r24, 0x01E0
    a842:	86 ff       	sbrs	r24, 6
    a844:	06 c0       	rjmp	.+12     	; 0xa852 <FreePrinting+0x340>
		      stFreePrinting=fpLoadFooter;
    a846:	8c e0       	ldi	r24, 0x0C	; 12
    a848:	80 93 3a 01 	sts	0x013A, r24
			  iFooter=0;
    a84c:	10 92 a3 02 	sts	0x02A3, r1
    a850:	f3 c0       	rjmp	.+486    	; 0xaa38 <FreePrinting+0x526>
			  }
		  else
	      if (((cmdPrint&0b01000000)>>6)==0) stFreePrinting=fpPaperCut;//fpInitScroll;	                
    a852:	80 e1       	ldi	r24, 0x10	; 16
    a854:	a2 ce       	rjmp	.-700    	; 0xa59a <FreePrinting+0x88>
    a856:	60 91 a3 02 	lds	r22, 0x02A3
    a85a:	89 e2       	ldi	r24, 0x29	; 41
    a85c:	68 9f       	mul	r22, r24
    a85e:	b0 01       	movw	r22, r0
    a860:	11 24       	eor	r1, r1
    a862:	63 5b       	subi	r22, 0xB3	; 179
    a864:	7c 4f       	sbci	r23, 0xFC	; 252
    a866:	86 e7       	ldi	r24, 0x76	; 118
    a868:	92 e0       	ldi	r25, 0x02	; 2
    a86a:	48 e2       	ldi	r20, 0x28	; 40
    a86c:	50 e0       	ldi	r21, 0x00	; 0
    a86e:	2c ea       	ldi	r18, 0xAC	; 172
    a870:	32 e1       	ldi	r19, 0x12	; 18
    a872:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
	      break;
     case fpLoadFooter:
	 	  //_uart_printf(0,1,PSTR("fpLoadFooter"));
          //Footer 1
	      eeprom_read_block((void*) &strHeader, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    a876:	80 91 a3 02 	lds	r24, 0x02A3
    a87a:	8f 5f       	subi	r24, 0xFF	; 255
    a87c:	80 93 a3 02 	sts	0x02A3, r24
		  if (iFooter<4){
    a880:	84 30       	cpi	r24, 0x04	; 4
    a882:	90 f4       	brcc	.+36     	; 0xa8a8 <FreePrinting+0x396>
		      if (SpaceOnly(strHeader)==True){
    a884:	86 e7       	ldi	r24, 0x76	; 118
    a886:	92 e0       	ldi	r25, 0x02	; 2
    a888:	0e 94 44 21 	call	0x4288	; 0x4288 <SpaceOnly>
    a88c:	81 30       	cpi	r24, 0x01	; 1
    a88e:	11 f4       	brne	.+4      	; 0xa894 <FreePrinting+0x382>
			      stFreePrinting=fpLoadFooter;
    a890:	8c e0       	ldi	r24, 0x0C	; 12
    a892:	83 ce       	rjmp	.-762    	; 0xa59a <FreePrinting+0x88>
				  }
			  else{
			      iSend=0;
    a894:	10 92 75 02 	sts	0x0275, r1
    a898:	10 92 74 02 	sts	0x0274, r1
				  iLoop=0;
    a89c:	10 92 71 02 	sts	0x0271, r1
    a8a0:	10 92 70 02 	sts	0x0270, r1
				  stFreePrinting=fpPrintFooter;
    a8a4:	8d e0       	ldi	r24, 0x0D	; 13
    a8a6:	79 ce       	rjmp	.-782    	; 0xa59a <FreePrinting+0x88>
			      }
		  }else{
		    CarriegeReturn();
    a8a8:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			iPrinted++;
    a8ac:	80 91 a5 02 	lds	r24, 0x02A5
    a8b0:	8f 5f       	subi	r24, 0xFF	; 255
    a8b2:	80 93 a5 02 	sts	0x02A5, r24

			//if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_CUBE){
			    stFreePrinting=fpInitScroll;
    a8b6:	8e e0       	ldi	r24, 0x0E	; 14
    a8b8:	70 ce       	rjmp	.-800    	; 0xa59a <FreePrinting+0x88>
			//}else stFreePrinting=fpPaperCut;

			}
	      break;
     case fpPrintFooter:
		  if (iSend<40){
    a8ba:	80 91 74 02 	lds	r24, 0x0274
    a8be:	90 91 75 02 	lds	r25, 0x0275
    a8c2:	88 97       	sbiw	r24, 0x28	; 40
    a8c4:	78 f4       	brcc	.+30     	; 0xa8e4 <FreePrinting+0x3d2>
		      iLoop++;
    a8c6:	80 91 70 02 	lds	r24, 0x0270
    a8ca:	90 91 71 02 	lds	r25, 0x0271
    a8ce:	01 96       	adiw	r24, 0x01	; 1
    a8d0:	90 93 71 02 	sts	0x0271, r25
    a8d4:	80 93 70 02 	sts	0x0270, r24
			  if((iLoop%PRINT_DELAY)==0){
		        //_uart(_COM_PRINTER,1,strHeader[iSend]);
		        //iSend++;
				TimPrintBusy=0;
    a8d8:	10 92 e2 01 	sts	0x01E2, r1
    a8dc:	10 92 e1 01 	sts	0x01E1, r1
				stFreePrinting=fpCheckPrintStatusFooter;
    a8e0:	84 e1       	ldi	r24, 0x14	; 20
    a8e2:	5b ce       	rjmp	.-842    	; 0xa59a <FreePrinting+0x88>
				}
			  }
          else {
		      stFreePrinting=fpLoadFooter;
    a8e4:	8c e0       	ldi	r24, 0x0C	; 12
    a8e6:	80 93 3a 01 	sts	0x013A, r24
			  CarriegeReturn();
    a8ea:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
    a8ee:	a4 c0       	rjmp	.+328    	; 0xaa38 <FreePrinting+0x526>
			  }
	      break;
     
	 case fpCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    a8f0:	80 91 dd 01 	lds	r24, 0x01DD
    a8f4:	88 23       	and	r24, r24
    a8f6:	b1 f4       	brne	.+44     	; 0xa924 <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    a8f8:	e0 91 74 02 	lds	r30, 0x0274
    a8fc:	f0 91 75 02 	lds	r31, 0x0275
    a900:	ea 58       	subi	r30, 0x8A	; 138
    a902:	fd 4f       	sbci	r31, 0xFD	; 253
    a904:	61 e0       	ldi	r22, 0x01	; 1
    a906:	40 81       	ld	r20, Z
    a908:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
		      iSend++;
    a90c:	80 91 74 02 	lds	r24, 0x0274
    a910:	90 91 75 02 	lds	r25, 0x0275
    a914:	01 96       	adiw	r24, 0x01	; 1
    a916:	90 93 75 02 	sts	0x0275, r25
    a91a:	80 93 74 02 	sts	0x0274, r24
		      stFreePrinting=fpPrintFooter;
    a91e:	8d e0       	ldi	r24, 0x0D	; 13
    a920:	80 93 3a 01 	sts	0x013A, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    a924:	80 91 e1 01 	lds	r24, 0x01E1
    a928:	90 91 e2 01 	lds	r25, 0x01E2
    a92c:	0b 97       	sbiw	r24, 0x0b	; 11
    a92e:	0c f4       	brge	.+2      	; 0xa932 <FreePrinting+0x420>
    a930:	83 c0       	rjmp	.+262    	; 0xaa38 <FreePrinting+0x526>
		      IsPrintERROR=True;
    a932:	81 e0       	ldi	r24, 0x01	; 1
    a934:	80 93 dc 01 	sts	0x01DC, r24
		      stFreePrinting=fpFinishFreePrinting;
    a938:	81 e1       	ldi	r24, 0x11	; 17
    a93a:	2f ce       	rjmp	.-930    	; 0xa59a <FreePrinting+0x88>
			  }
	      break;

     case fpInitScroll:
	      iScroll=0;
    a93c:	10 92 a0 02 	sts	0x02A0, r1
		  iSend=0;
    a940:	10 92 75 02 	sts	0x0275, r1
    a944:	10 92 74 02 	sts	0x0274, r1
		  if (iPrinted<PrintCopy)
    a948:	90 91 a5 02 	lds	r25, 0x02A5
    a94c:	80 91 a2 02 	lds	r24, 0x02A2
    a950:	98 17       	cp	r25, r24
    a952:	28 f4       	brcc	.+10     	; 0xa95e <FreePrinting+0x44c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a954:	e1 99       	sbic	0x1c, 1	; 28
    a956:	fe cf       	rjmp	.-4      	; 0xa954 <FreePrinting+0x442>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a958:	82 e3       	ldi	r24, 0x32	; 50
    a95a:	90 e0       	ldi	r25, 0x00	; 0
    a95c:	04 c0       	rjmp	.+8      	; 0xa966 <FreePrinting+0x454>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    a95e:	e1 99       	sbic	0x1c, 1	; 28
    a960:	fe cf       	rjmp	.-4      	; 0xa95e <FreePrinting+0x44c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    a962:	81 e3       	ldi	r24, 0x31	; 49
    a964:	90 e0       	ldi	r25, 0x00	; 0
    a966:	9f bb       	out	0x1f, r25	; 31
    a968:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    a96a:	e0 9a       	sbi	0x1c, 0	; 28
    a96c:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  else if (iPrinted>=PrintCopy)
		  	  nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    a96e:	80 93 9f 02 	sts	0x029F, r24

          stFreePrinting=fpScrollPaper;
    a972:	8f e0       	ldi	r24, 0x0F	; 15
    a974:	12 ce       	rjmp	.-988    	; 0xa59a <FreePrinting+0x88>
	      break;
     case fpScrollPaper:
	      if (iScroll>nScroll)stFreePrinting=fpPaperCut;
    a976:	90 91 a0 02 	lds	r25, 0x02A0
    a97a:	80 91 9f 02 	lds	r24, 0x029F
    a97e:	89 17       	cp	r24, r25
    a980:	18 f4       	brcc	.+6      	; 0xa988 <FreePrinting+0x476>
    a982:	80 e1       	ldi	r24, 0x10	; 16
    a984:	80 93 3a 01 	sts	0x013A, r24
		  iSend++;
    a988:	80 91 74 02 	lds	r24, 0x0274
    a98c:	90 91 75 02 	lds	r25, 0x0275
    a990:	01 96       	adiw	r24, 0x01	; 1
    a992:	90 93 75 02 	sts	0x0275, r25
    a996:	80 93 74 02 	sts	0x0274, r24
		  if (iSend%PRINT_DELAY==0){
		      CarriegeReturn();
    a99a:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			  iScroll++;
    a99e:	80 91 a0 02 	lds	r24, 0x02A0
    a9a2:	8f 5f       	subi	r24, 0xFF	; 255
    a9a4:	80 93 a0 02 	sts	0x02A0, r24
    a9a8:	47 c0       	rjmp	.+142    	; 0xaa38 <FreePrinting+0x526>
			  }
	      break;
     case fpPaperCut:
		  //_uart_printf(0,1,PSTR("fpPaperCut"));
		  //iPrinted++;
          if (iPrinted<PrintCopy){
    a9aa:	90 91 a5 02 	lds	r25, 0x02A5
    a9ae:	80 91 a2 02 	lds	r24, 0x02A2
    a9b2:	98 17       	cp	r25, r24
    a9b4:	20 f4       	brcc	.+8      	; 0xa9be <FreePrinting+0x4ac>
		      CarriegeReturn();
    a9b6:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
              stFreePrinting=fpInitHeader;
    a9ba:	82 e0       	ldi	r24, 0x02	; 2
    a9bc:	07 c0       	rjmp	.+14     	; 0xa9cc <FreePrinting+0x4ba>
			  }
          else{
		      if (IFType==IT_SLAVE)sendMessage04();
    a9be:	80 91 25 01 	lds	r24, 0x0125
    a9c2:	81 30       	cpi	r24, 0x01	; 1
    a9c4:	11 f4       	brne	.+4      	; 0xa9ca <FreePrinting+0x4b8>
    a9c6:	0e 94 25 52 	call	0xa44a	; 0xa44a <sendMessage04>
		      stFreePrinting=fpFinishFreePrinting;
    a9ca:	81 e1       	ldi	r24, 0x11	; 17
    a9cc:	80 93 3a 01 	sts	0x013A, r24
			  }

		  if (((cmdPrint&0b00100000)>>5)==1){
    a9d0:	80 91 e0 01 	lds	r24, 0x01E0
    a9d4:	85 ff       	sbrs	r24, 5
    a9d6:	30 c0       	rjmp	.+96     	; 0xaa38 <FreePrinting+0x526>
		      if (iPrinted==0){
    a9d8:	80 91 a5 02 	lds	r24, 0x02A5
    a9dc:	88 23       	and	r24, r24
    a9de:	31 f4       	brne	.+12     	; 0xa9ec <FreePrinting+0x4da>
			      CarriegeReturn();_delay_ms(50);
    a9e0:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
    a9e4:	84 ed       	ldi	r24, 0xD4	; 212
    a9e6:	90 e3       	ldi	r25, 0x30	; 48
    a9e8:	01 97       	sbiw	r24, 0x01	; 1
    a9ea:	f1 f7       	brne	.-4      	; 0xa9e8 <FreePrinting+0x4d6>
				 }
              //HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
		      if ((iPrinted==PrintCopy)){
    a9ec:	90 91 a5 02 	lds	r25, 0x02A5
    a9f0:	80 91 a2 02 	lds	r24, 0x02A2
    a9f4:	98 17       	cp	r25, r24
    a9f6:	b1 f4       	brne	.+44     	; 0xaa24 <FreePrinting+0x512>
			      // if (((cmdPrint&0b00010000)>>4)==1){
				       CarriegeReturn();_delay_ms(50);
    a9f8:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
    a9fc:	04 ed       	ldi	r16, 0xD4	; 212
    a9fe:	10 e3       	ldi	r17, 0x30	; 48
    aa00:	c8 01       	movw	r24, r16
    aa02:	01 97       	sbiw	r24, 0x01	; 1
    aa04:	f1 f7       	brne	.-4      	; 0xaa02 <FreePrinting+0x4f0>
					   CarriegeReturn();_delay_ms(50);
    aa06:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
    aa0a:	c8 01       	movw	r24, r16
    aa0c:	01 97       	sbiw	r24, 0x01	; 1
    aa0e:	f1 f7       	brne	.-4      	; 0xaa0c <FreePrinting+0x4fa>
					   CarriegeReturn();_delay_ms(50);
    aa10:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
    aa14:	c8 01       	movw	r24, r16
    aa16:	01 97       	sbiw	r24, 0x01	; 1
    aa18:	f1 f7       	brne	.-4      	; 0xaa16 <FreePrinting+0x504>
					   CarriegeReturn();_delay_ms(50);
    aa1a:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
    aa1e:	c8 01       	movw	r24, r16
    aa20:	01 97       	sbiw	r24, 0x01	; 1
    aa22:	f1 f7       	brne	.-4      	; 0xaa20 <FreePrinting+0x50e>
				   //}
				 }
		      PaperCut();
    aa24:	0e 94 42 4b 	call	0x9684	; 0x9684 <PaperCut>
    aa28:	07 c0       	rjmp	.+14     	; 0xaa38 <FreePrinting+0x526>
		   }
	      break;
     case fpFinishFreePrinting:
	 	  //_uart_printf(0,1,PSTR("fpFinished"));
		  IsBusyFreePrinting=False;
    aa2a:	10 92 de 01 	sts	0x01DE, r1
	      stFreePrinting=fpInit;
    aa2e:	81 e0       	ldi	r24, 0x01	; 1
    aa30:	80 93 3a 01 	sts	0x013A, r24
		  iPrinted=0;
    aa34:	10 92 a5 02 	sts	0x02A5, r1
	      break;
	 }//EndCase
}
    aa38:	1f 91       	pop	r17
    aa3a:	0f 91       	pop	r16
    aa3c:	08 95       	ret

0000aa3e <PrintIdle>:
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);   
		}
}

void PrintIdle(){
    aa3e:	cf 93       	push	r28
    aa40:	df 93       	push	r29
		_uart_print(1,1,strSend);
	 }
	 #endif

     //Normalize PrintIdleState
     if ((IsPrinting==True)&&(stPrintIdle!=piIdle)){
    aa42:	80 91 d9 01 	lds	r24, 0x01D9
    aa46:	81 30       	cpi	r24, 0x01	; 1
    aa48:	31 f4       	brne	.+12     	; 0xaa56 <PrintIdle+0x18>
    aa4a:	80 91 e3 02 	lds	r24, 0x02E3
    aa4e:	88 23       	and	r24, r24
    aa50:	11 f0       	breq	.+4      	; 0xaa56 <PrintIdle+0x18>
	     stPrintIdle=piIdle;
    aa52:	10 92 e3 02 	sts	0x02E3, r1
	 }

     switch(stPrintIdle){
    aa56:	80 91 e3 02 	lds	r24, 0x02E3
    aa5a:	e8 2f       	mov	r30, r24
    aa5c:	f0 e0       	ldi	r31, 0x00	; 0
    aa5e:	e5 31       	cpi	r30, 0x15	; 21
    aa60:	f1 05       	cpc	r31, r1
    aa62:	08 f0       	brcs	.+2      	; 0xaa66 <PrintIdle+0x28>
    aa64:	07 c7       	rjmp	.+3598   	; 0xb874 <PrintIdle+0xe36>
    aa66:	e7 58       	subi	r30, 0x87	; 135
    aa68:	ff 4f       	sbci	r31, 0xFF	; 255
    aa6a:	ee 0f       	add	r30, r30
    aa6c:	ff 1f       	adc	r31, r31
    aa6e:	05 90       	lpm	r0, Z+
    aa70:	f4 91       	lpm	r31, Z+
    aa72:	e0 2d       	mov	r30, r0
    aa74:	09 94       	ijmp
	 case piIdle:
	      if (IsPrinting==True){
    aa76:	80 91 d9 01 	lds	r24, 0x01D9
    aa7a:	81 30       	cpi	r24, 0x01	; 1
    aa7c:	09 f0       	breq	.+2      	; 0xaa80 <PrintIdle+0x42>
    aa7e:	fa c6       	rjmp	.+3572   	; 0xb874 <PrintIdle+0xe36>
		      IsPrinting=False;
    aa80:	10 92 d9 01 	sts	0x01D9, r1
			  IsBusyIdlePrinting=True;
    aa84:	80 93 df 01 	sts	0x01DF, r24
			  IsBusyPrint=False;
    aa88:	10 92 dd 01 	sts	0x01DD, r1
			  iPrinted=0;
    aa8c:	10 92 a8 02 	sts	0x02A8, r1
			  PrintCopy=0;
    aa90:	10 92 a7 02 	sts	0x02A7, r1
		      stPrintIdle=piInit;
    aa94:	80 93 e3 02 	sts	0x02E3, r24
			  InitPrinter();
    aa98:	0e 94 a6 4a 	call	0x954c	; 0x954c <InitPrinter>
			  IsSignedField=False;
    aa9c:	10 92 af 02 	sts	0x02AF, r1
    aaa0:	e9 c6       	rjmp	.+3538   	; 0xb874 <PrintIdle+0xe36>
			  }
	      break;
	 case piInit:
	      iHeader=0;
    aaa2:	10 92 e2 02 	sts	0x02E2, r1
		  CarriegeReturn();
    aaa6:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
    aaaa:	1d c0       	rjmp	.+58     	; 0xaae6 <PrintIdle+0xa8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    aaac:	60 91 e2 02 	lds	r22, 0x02E2
    aab0:	89 e2       	ldi	r24, 0x29	; 41
    aab2:	68 9f       	mul	r22, r24
    aab4:	b0 01       	movw	r22, r0
    aab6:	11 24       	eor	r1, r1
    aab8:	69 5a       	subi	r22, 0xA9	; 169
    aaba:	7d 4f       	sbci	r23, 0xFD	; 253
    aabc:	82 eb       	ldi	r24, 0xB2	; 178
    aabe:	92 e0       	ldi	r25, 0x02	; 2
    aac0:	49 e2       	ldi	r20, 0x29	; 41
    aac2:	50 e0       	ldi	r21, 0x00	; 0
    aac4:	2c ea       	ldi	r18, 0xAC	; 172
    aac6:	32 e1       	ldi	r19, 0x12	; 18
    aac8:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
		  stPrintIdle=piLoadHeader;
	      break;
     case piLoadHeader:
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[iHeader], sizeof(DefHeaderFooter[iHeader]));
		  iHeader++;
    aacc:	80 91 e2 02 	lds	r24, 0x02E2
    aad0:	8f 5f       	subi	r24, 0xFF	; 255
    aad2:	80 93 e2 02 	sts	0x02E2, r24
		  if (iHeader<6){
    aad6:	86 30       	cpi	r24, 0x06	; 6
    aad8:	00 f5       	brcc	.+64     	; 0xab1a <PrintIdle+0xdc>
		      if (SpaceOnly(strPrint)==True){
    aada:	82 eb       	ldi	r24, 0xB2	; 178
    aadc:	92 e0       	ldi	r25, 0x02	; 2
    aade:	0e 94 44 21 	call	0x4288	; 0x4288 <SpaceOnly>
    aae2:	81 30       	cpi	r24, 0x01	; 1
    aae4:	11 f4       	brne	.+4      	; 0xaaea <PrintIdle+0xac>
			      stPrintIdle=piLoadHeader;
    aae6:	82 e0       	ldi	r24, 0x02	; 2
    aae8:	9a c6       	rjmp	.+3380   	; 0xb81e <PrintIdle+0xde0>
				  }	      
			  else{
			      stPrintIdle=piPrintHeader;
    aaea:	83 e0       	ldi	r24, 0x03	; 3
    aaec:	80 93 e3 02 	sts	0x02E3, r24
			      iSend=0;
    aaf0:	10 92 ae 02 	sts	0x02AE, r1
    aaf4:	10 92 ad 02 	sts	0x02AD, r1
				  iLoop=0;
    aaf8:	10 92 aa 02 	sts	0x02AA, r1
    aafc:	10 92 a9 02 	sts	0x02A9, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    ab00:	80 91 e2 02 	lds	r24, 0x02E2
    ab04:	81 30       	cpi	r24, 0x01	; 1
    ab06:	19 f4       	brne	.+6      	; 0xab0e <PrintIdle+0xd0>
    ab08:	0e 94 28 4b 	call	0x9650	; 0x9650 <PrintDoubleHeight>
    ab0c:	b3 c6       	rjmp	.+3430   	; 0xb874 <PrintIdle+0xe36>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    ab0e:	82 30       	cpi	r24, 0x02	; 2
    ab10:	09 f0       	breq	.+2      	; 0xab14 <PrintIdle+0xd6>
    ab12:	b0 c6       	rjmp	.+3424   	; 0xb874 <PrintIdle+0xe36>
    ab14:	0e 94 0e 4b 	call	0x961c	; 0x961c <PrintNormalHeight>
    ab18:	ad c6       	rjmp	.+3418   	; 0xb874 <PrintIdle+0xe36>
			   }
		  }else{stPrintIdle=piInitDuplicate; //stPrintIdle=piInitMessage;//
    ab1a:	84 e0       	ldi	r24, 0x04	; 4
    ab1c:	80 c6       	rjmp	.+3328   	; 0xb81e <PrintIdle+0xde0>
		        //else stPrintIdle=piInitMessage;
		  }
	      break;
	 case piPrintHeader:
		  if (iSend<40){
    ab1e:	80 91 ad 02 	lds	r24, 0x02AD
    ab22:	90 91 ae 02 	lds	r25, 0x02AE
    ab26:	88 97       	sbiw	r24, 0x28	; 40
    ab28:	78 f4       	brcc	.+30     	; 0xab48 <PrintIdle+0x10a>
		      iLoop++;
    ab2a:	80 91 a9 02 	lds	r24, 0x02A9
    ab2e:	90 91 aa 02 	lds	r25, 0x02AA
    ab32:	01 96       	adiw	r24, 0x01	; 1
    ab34:	90 93 aa 02 	sts	0x02AA, r25
    ab38:	80 93 a9 02 	sts	0x02A9, r24
			  if ((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    ab3c:	10 92 e2 01 	sts	0x01E2, r1
    ab40:	10 92 e1 01 	sts	0x01E1, r1
				 stPrintIdle=piCheckPrintStatusHeader;
    ab44:	8b e0       	ldi	r24, 0x0B	; 11
    ab46:	6b c6       	rjmp	.+3286   	; 0xb81e <PrintIdle+0xde0>
				 }
			  }
          else{ 
		     stPrintIdle=piLoadHeader;
    ab48:	82 e0       	ldi	r24, 0x02	; 2
    ab4a:	f9 c5       	rjmp	.+3058   	; 0xb73e <PrintIdle+0xd00>
			 CarriegeReturn();
		  }
	      break;
     case piCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    ab4c:	80 91 dd 01 	lds	r24, 0x01DD
    ab50:	88 23       	and	r24, r24
    ab52:	09 f0       	breq	.+2      	; 0xab56 <PrintIdle+0x118>
    ab54:	5a c6       	rjmp	.+3252   	; 0xb80a <PrintIdle+0xdcc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    ab56:	e0 91 ad 02 	lds	r30, 0x02AD
    ab5a:	f0 91 ae 02 	lds	r31, 0x02AE
    ab5e:	ee 54       	subi	r30, 0x4E	; 78
    ab60:	fd 4f       	sbci	r31, 0xFD	; 253
    ab62:	61 e0       	ldi	r22, 0x01	; 1
    ab64:	40 81       	ld	r20, Z
    ab66:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
		      iSend++;
    ab6a:	80 91 ad 02 	lds	r24, 0x02AD
    ab6e:	90 91 ae 02 	lds	r25, 0x02AE
    ab72:	01 96       	adiw	r24, 0x01	; 1
    ab74:	90 93 ae 02 	sts	0x02AE, r25
    ab78:	80 93 ad 02 	sts	0x02AD, r24
		      stPrintIdle=piPrintHeader;
    ab7c:	83 e0       	ldi	r24, 0x03	; 3
    ab7e:	43 c6       	rjmp	.+3206   	; 0xb806 <PrintIdle+0xdc8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitDuplicate:
          if ((iPrinted>0)||(IsReprintTicket==True)){
    ab80:	80 91 a8 02 	lds	r24, 0x02A8
    ab84:	88 23       	and	r24, r24
    ab86:	21 f4       	brne	.+8      	; 0xab90 <PrintIdle+0x152>
    ab88:	80 91 a8 01 	lds	r24, 0x01A8
    ab8c:	81 30       	cpi	r24, 0x01	; 1
    ab8e:	a9 f4       	brne	.+42     	; 0xabba <PrintIdle+0x17c>
		      IsReprintTicket=False;
    ab90:	10 92 a8 01 	sts	0x01A8, r1
		      CarriegeReturn(); 
    ab94:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		      sprintf_P(strPrint,PSTR("             DUPLICATE COPY        "));
    ab98:	00 d0       	rcall	.+0      	; 0xab9a <PrintIdle+0x15c>
    ab9a:	00 d0       	rcall	.+0      	; 0xab9c <PrintIdle+0x15e>
    ab9c:	82 eb       	ldi	r24, 0xB2	; 178
    ab9e:	92 e0       	ldi	r25, 0x02	; 2
    aba0:	ad b7       	in	r26, 0x3d	; 61
    aba2:	be b7       	in	r27, 0x3e	; 62
    aba4:	12 96       	adiw	r26, 0x02	; 2
    aba6:	9c 93       	st	X, r25
    aba8:	8e 93       	st	-X, r24
    abaa:	11 97       	sbiw	r26, 0x01	; 1
    abac:	87 e8       	ldi	r24, 0x87	; 135
    abae:	9a e0       	ldi	r25, 0x0A	; 10
    abb0:	14 96       	adiw	r26, 0x04	; 4
    abb2:	9c 93       	st	X, r25
    abb4:	8e 93       	st	-X, r24
    abb6:	13 97       	sbiw	r26, 0x03	; 3
    abb8:	0c c0       	rjmp	.+24     	; 0xabd2 <PrintIdle+0x194>
		      }
          else{           sprintf_P(strPrint,PSTR(" "));
    abba:	00 d0       	rcall	.+0      	; 0xabbc <PrintIdle+0x17e>
    abbc:	00 d0       	rcall	.+0      	; 0xabbe <PrintIdle+0x180>
    abbe:	82 eb       	ldi	r24, 0xB2	; 178
    abc0:	92 e0       	ldi	r25, 0x02	; 2
    abc2:	ed b7       	in	r30, 0x3d	; 61
    abc4:	fe b7       	in	r31, 0x3e	; 62
    abc6:	92 83       	std	Z+2, r25	; 0x02
    abc8:	81 83       	std	Z+1, r24	; 0x01
    abca:	85 e8       	ldi	r24, 0x85	; 133
    abcc:	9a e0       	ldi	r25, 0x0A	; 10
    abce:	94 83       	std	Z+4, r25	; 0x04
    abd0:	83 83       	std	Z+3, r24	; 0x03
    abd2:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    abd6:	0f 90       	pop	r0
    abd8:	0f 90       	pop	r0
    abda:	0f 90       	pop	r0
    abdc:	0f 90       	pop	r0
		      }
		  iSend=0;
    abde:	10 92 ae 02 	sts	0x02AE, r1
    abe2:	10 92 ad 02 	sts	0x02AD, r1
		  iLoop=0;
    abe6:	10 92 aa 02 	sts	0x02AA, r1
    abea:	10 92 a9 02 	sts	0x02A9, r1
		  LSend=strlen(strPrint);
    abee:	e2 eb       	ldi	r30, 0xB2	; 178
    abf0:	f2 e0       	ldi	r31, 0x02	; 2
    abf2:	01 90       	ld	r0, Z+
    abf4:	00 20       	and	r0, r0
    abf6:	e9 f7       	brne	.-6      	; 0xabf2 <PrintIdle+0x1b4>
    abf8:	31 97       	sbiw	r30, 0x01	; 1
    abfa:	e2 5b       	subi	r30, 0xB2	; 178
    abfc:	f2 40       	sbci	r31, 0x02	; 2
    abfe:	f0 93 ac 02 	sts	0x02AC, r31
    ac02:	e0 93 ab 02 	sts	0x02AB, r30
          stPrintIdle=piPrintDuplicate; 
    ac06:	85 e0       	ldi	r24, 0x05	; 5
    ac08:	0a c6       	rjmp	.+3092   	; 0xb81e <PrintIdle+0xde0>
	      break;
     case piPrintDuplicate:
		  if (iSend<LSend){
    ac0a:	20 91 ad 02 	lds	r18, 0x02AD
    ac0e:	30 91 ae 02 	lds	r19, 0x02AE
    ac12:	80 91 ab 02 	lds	r24, 0x02AB
    ac16:	90 91 ac 02 	lds	r25, 0x02AC
    ac1a:	28 17       	cp	r18, r24
    ac1c:	39 07       	cpc	r19, r25
    ac1e:	78 f4       	brcc	.+30     	; 0xac3e <PrintIdle+0x200>
		      iLoop++;
    ac20:	80 91 a9 02 	lds	r24, 0x02A9
    ac24:	90 91 aa 02 	lds	r25, 0x02AA
    ac28:	01 96       	adiw	r24, 0x01	; 1
    ac2a:	90 93 aa 02 	sts	0x02AA, r25
    ac2e:	80 93 a9 02 	sts	0x02A9, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    ac32:	10 92 e2 01 	sts	0x01E2, r1
    ac36:	10 92 e1 01 	sts	0x01E1, r1
                 stPrintIdle=piCheckPrintStatusDuplicate;
    ac3a:	86 e0       	ldi	r24, 0x06	; 6
    ac3c:	f0 c5       	rjmp	.+3040   	; 0xb81e <PrintIdle+0xde0>
				 }
			  }
          else {
		     iSend=0;
    ac3e:	10 92 ae 02 	sts	0x02AE, r1
    ac42:	10 92 ad 02 	sts	0x02AD, r1
		     stPrintIdle=piInitMessage;
    ac46:	87 e0       	ldi	r24, 0x07	; 7
    ac48:	ea c5       	rjmp	.+3028   	; 0xb81e <PrintIdle+0xde0>
			 }
	      break;
     case piCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    ac4a:	80 91 dd 01 	lds	r24, 0x01DD
    ac4e:	88 23       	and	r24, r24
    ac50:	09 f0       	breq	.+2      	; 0xac54 <PrintIdle+0x216>
    ac52:	db c5       	rjmp	.+2998   	; 0xb80a <PrintIdle+0xdcc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    ac54:	e0 91 ad 02 	lds	r30, 0x02AD
    ac58:	f0 91 ae 02 	lds	r31, 0x02AE
    ac5c:	ee 54       	subi	r30, 0x4E	; 78
    ac5e:	fd 4f       	sbci	r31, 0xFD	; 253
    ac60:	61 e0       	ldi	r22, 0x01	; 1
    ac62:	40 81       	ld	r20, Z
    ac64:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
		      iSend++;
    ac68:	80 91 ad 02 	lds	r24, 0x02AD
    ac6c:	90 91 ae 02 	lds	r25, 0x02AE
    ac70:	01 96       	adiw	r24, 0x01	; 1
    ac72:	90 93 ae 02 	sts	0x02AE, r25
    ac76:	80 93 ad 02 	sts	0x02AD, r24
		      stPrintIdle=piPrintDuplicate;
    ac7a:	85 e0       	ldi	r24, 0x05	; 5
    ac7c:	c4 c5       	rjmp	.+2952   	; 0xb806 <PrintIdle+0xdc8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitMessage:
	      iSend=0;iLoop=0;
    ac7e:	10 92 ae 02 	sts	0x02AE, r1
    ac82:	10 92 ad 02 	sts	0x02AD, r1
    ac86:	10 92 aa 02 	sts	0x02AA, r1
    ac8a:	10 92 a9 02 	sts	0x02A9, r1
		  iMessage=0;
    ac8e:	10 92 b1 02 	sts	0x02B1, r1
		  switch(MOPType){
    ac92:	80 91 e4 01 	lds	r24, 0x01E4
    ac96:	83 30       	cpi	r24, 0x03	; 3
    ac98:	81 f0       	breq	.+32     	; 0xacba <PrintIdle+0x27c>
    ac9a:	84 30       	cpi	r24, 0x04	; 4
    ac9c:	28 f4       	brcc	.+10     	; 0xaca8 <PrintIdle+0x26a>
    ac9e:	81 30       	cpi	r24, 0x01	; 1
    aca0:	61 f0       	breq	.+24     	; 0xacba <PrintIdle+0x27c>
    aca2:	82 30       	cpi	r24, 0x02	; 2
    aca4:	40 f4       	brcc	.+16     	; 0xacb6 <PrintIdle+0x278>
    aca6:	10 c0       	rjmp	.+32     	; 0xacc8 <PrintIdle+0x28a>
    aca8:	88 30       	cpi	r24, 0x08	; 8
    acaa:	49 f0       	breq	.+18     	; 0xacbe <PrintIdle+0x280>
    acac:	89 30       	cpi	r24, 0x09	; 9
    acae:	61 f0       	breq	.+24     	; 0xacc8 <PrintIdle+0x28a>
    acb0:	87 30       	cpi	r24, 0x07	; 7
    acb2:	51 f4       	brne	.+20     	; 0xacc8 <PrintIdle+0x28a>
    acb4:	02 c0       	rjmp	.+4      	; 0xacba <PrintIdle+0x27c>
		  case MOP_CASH:
		       MessageLine=10;
			   PrintCopy=1;
		       break;
          case MOP_CREDIT_CARD:
		       MessageLine=10;
    acb6:	8a e0       	ldi	r24, 0x0A	; 10
    acb8:	03 c0       	rjmp	.+6      	; 0xacc0 <PrintIdle+0x282>
          case MOP_LOCAL_ACCOUNT:
		       MessageLine=20;
			   PrintCopy=2;
		       break;
          case MOP_VOUCHER:
		       MessageLine=20;
    acba:	84 e1       	ldi	r24, 0x14	; 20
    acbc:	01 c0       	rjmp	.+2      	; 0xacc0 <PrintIdle+0x282>
			   PrintCopy=2;
		       break;
          case MOP_PUMP_TEST:
		       MessageLine=12;
    acbe:	8c e0       	ldi	r24, 0x0C	; 12
    acc0:	80 93 b0 02 	sts	0x02B0, r24
			   PrintCopy=2;
    acc4:	82 e0       	ldi	r24, 0x02	; 2
    acc6:	04 c0       	rjmp	.+8      	; 0xacd0 <PrintIdle+0x292>
          case MOP_VOID_CARD:
		       MessageLine=10;
			   PrintCopy=1;
		       break;          
          default:
		       MessageLine=10;
    acc8:	8a e0       	ldi	r24, 0x0A	; 10
    acca:	80 93 b0 02 	sts	0x02B0, r24
			   PrintCopy=1;
    acce:	81 e0       	ldi	r24, 0x01	; 1
    acd0:	80 93 a7 02 	sts	0x02A7, r24
		       break; 
		  }
		  //LoyaltyDetection
          if ((strlen(strLoyCardID)>0)&&(SpaceOnly(strLoyCardID)==False)){
    acd4:	80 91 ed 04 	lds	r24, 0x04ED
    acd8:	88 23       	and	r24, r24
    acda:	49 f0       	breq	.+18     	; 0xacee <PrintIdle+0x2b0>
    acdc:	8d ee       	ldi	r24, 0xED	; 237
    acde:	94 e0       	ldi	r25, 0x04	; 4
    ace0:	0e 94 44 21 	call	0x4288	; 0x4288 <SpaceOnly>
    ace4:	88 23       	and	r24, r24
    ace6:	19 f4       	brne	.+6      	; 0xacee <PrintIdle+0x2b0>
		       MessageLine=33;
    ace8:	81 e2       	ldi	r24, 0x21	; 33
    acea:	80 93 b0 02 	sts	0x02B0, r24
		  }
          //stPrintIdle=piLoadMessage;
		  stPrintIdle=piFormatingMessage;
    acee:	88 e0       	ldi	r24, 0x08	; 8
    acf0:	96 c5       	rjmp	.+2860   	; 0xb81e <PrintIdle+0xde0>
	      break;
     case piFormatingMessage:
	      if (iPrinted==0){
    acf2:	80 91 a8 02 	lds	r24, 0x02A8
    acf6:	88 23       	and	r24, r24
    acf8:	09 f0       	breq	.+2      	; 0xacfc <PrintIdle+0x2be>
    acfa:	c4 c4       	rjmp	.+2440   	; 0xb684 <PrintIdle+0xc46>

		      FormatDate(DATE_LONG_YEAR,strDate);
    acfc:	6d e7       	ldi	r22, 0x7D	; 125
    acfe:	79 e0       	ldi	r23, 0x09	; 9
    ad00:	0e 94 18 22 	call	0x4430	; 0x4430 <FormatDate>
              RemZeroLead(strIslandID);
    ad04:	8f ef       	ldi	r24, 0xFF	; 255
    ad06:	9a e0       	ldi	r25, 0x0A	; 10
    ad08:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
			  RemZeroLead(strFIP_ID);
    ad0c:	88 ec       	ldi	r24, 0xC8	; 200
    ad0e:	99 e0       	ldi	r25, 0x09	; 9
    ad10:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
		      RemZeroLead(strPrice);              
    ad14:	8d ea       	ldi	r24, 0xAD	; 173
    ad16:	97 e0       	ldi	r25, 0x07	; 7
    ad18:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
              RemZeroLead(strVolume);
    ad1c:	8b e7       	ldi	r24, 0x7B	; 123
    ad1e:	95 e0       	ldi	r25, 0x05	; 5
    ad20:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
              RemZeroLead(strAmount);
    ad24:	8b eb       	ldi	r24, 0xBB	; 187
    ad26:	9d e0       	ldi	r25, 0x0D	; 13
    ad28:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>

			  RemDecimal(strPrice);
    ad2c:	8d ea       	ldi	r24, 0xAD	; 173
    ad2e:	97 e0       	ldi	r25, 0x07	; 7
    ad30:	0e 94 61 21 	call	0x42c2	; 0x42c2 <RemDecimal>
			  RemDecimal(strAmount);
    ad34:	8b eb       	ldi	r24, 0xBB	; 187
    ad36:	9d e0       	ldi	r25, 0x0D	; 13
    ad38:	0e 94 61 21 	call	0x42c2	; 0x42c2 <RemDecimal>
	  
			  FormatCurrency(strPrice);
    ad3c:	8d ea       	ldi	r24, 0xAD	; 173
    ad3e:	97 e0       	ldi	r25, 0x07	; 7
    ad40:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>
			  FormatCurrency(strAmount);
    ad44:	8b eb       	ldi	r24, 0xBB	; 187
    ad46:	9d e0       	ldi	r25, 0x0D	; 13
    ad48:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>
              if (IFType==IT_SLAVE){
    ad4c:	80 91 25 01 	lds	r24, 0x0125
    ad50:	81 30       	cpi	r24, 0x01	; 1
    ad52:	09 f0       	breq	.+2      	; 0xad56 <PrintIdle+0x318>
    ad54:	97 c4       	rjmp	.+2350   	; 0xb684 <PrintIdle+0xc46>
		          RemSpaceLag(strCardID);
    ad56:	81 e9       	ldi	r24, 0x91	; 145
    ad58:	9d e0       	ldi	r25, 0x0D	; 13
    ad5a:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		          RemSpaceLag(strCardHolder);
    ad5e:	8a e2       	ldi	r24, 0x2A	; 42
    ad60:	95 e0       	ldi	r25, 0x05	; 5
    ad62:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		          RemSpaceLag(strMOPName);
    ad66:	8c e8       	ldi	r24, 0x8C	; 140
    ad68:	97 e0       	ldi	r25, 0x07	; 7
    ad6a:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		          RemSpaceLag(strLoyCardHolder);
    ad6e:	8a ec       	ldi	r24, 0xCA	; 202
    ad70:	94 e0       	ldi	r25, 0x04	; 4
    ad72:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		          RemSpaceLag(strCorporateID);
    ad76:	85 e1       	ldi	r24, 0x15	; 21
    ad78:	9e e0       	ldi	r25, 0x0E	; 14
    ad7a:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		          RemSpaceLag(strCorporateName);
    ad7e:	83 ed       	ldi	r24, 0xD3	; 211
    ad80:	95 e0       	ldi	r25, 0x05	; 5
    ad82:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		          RemSpaceLag(strLoyRedeemPoints);
    ad86:	80 ea       	ldi	r24, 0xA0	; 160
    ad88:	95 e0       	ldi	r25, 0x05	; 5
    ad8a:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		          RemSpaceLag(strLoyCurrMonConsumeV);
    ad8e:	88 ef       	ldi	r24, 0xF8	; 248
    ad90:	9d e0       	ldi	r25, 0x0D	; 13
    ad92:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
				  RemSpaceLag(strLoyCurrMonConsumeA);
    ad96:	84 e8       	ldi	r24, 0x84	; 132
    ad98:	95 e0       	ldi	r25, 0x05	; 5
    ad9a:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		          FormatCurrency(strLoyCurrMonConsumeV);              
    ad9e:	88 ef       	ldi	r24, 0xF8	; 248
    ada0:	9d e0       	ldi	r25, 0x0D	; 13
    ada2:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>
		          FormatCurrency(strLoyCurrMonConsumeA);
    ada6:	84 e8       	ldi	r24, 0x84	; 132
    ada8:	95 e0       	ldi	r25, 0x05	; 5
    adaa:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>
    adae:	6a c4       	rjmp	.+2260   	; 0xb684 <PrintIdle+0xc46>
			   }
		  }
          stPrintIdle=piLoadMessage;
	      break;
     case piLoadMessage:
	      switch(iMessage){
    adb0:	80 91 b1 02 	lds	r24, 0x02B1
    adb4:	e8 2f       	mov	r30, r24
    adb6:	f0 e0       	ldi	r31, 0x00	; 0
    adb8:	e5 32       	cpi	r30, 0x25	; 37
    adba:	f1 05       	cpc	r31, r1
    adbc:	08 f0       	brcs	.+2      	; 0xadc0 <PrintIdle+0x382>
    adbe:	26 c4       	rjmp	.+2124   	; 0xb60c <PrintIdle+0xbce>
    adc0:	e2 57       	subi	r30, 0x72	; 114
    adc2:	ff 4f       	sbci	r31, 0xFF	; 255
    adc4:	ee 0f       	add	r30, r30
    adc6:	ff 1f       	adc	r31, r31
    adc8:	05 90       	lpm	r0, Z+
    adca:	f4 91       	lpm	r31, Z+
    adcc:	e0 2d       	mov	r30, r0
    adce:	09 94       	ijmp
		  case 0:
		       CarriegeReturn();
    add0:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Shift: %s  No.Trans: %s "),strShift,strTranNo);
    add4:	8d b7       	in	r24, 0x3d	; 61
    add6:	9e b7       	in	r25, 0x3e	; 62
    add8:	08 97       	sbiw	r24, 0x08	; 8
    adda:	0f b6       	in	r0, 0x3f	; 63
    addc:	f8 94       	cli
    adde:	9e bf       	out	0x3e, r25	; 62
    ade0:	0f be       	out	0x3f, r0	; 63
    ade2:	8d bf       	out	0x3d, r24	; 61
    ade4:	ed b7       	in	r30, 0x3d	; 61
    ade6:	fe b7       	in	r31, 0x3e	; 62
    ade8:	31 96       	adiw	r30, 0x01	; 1
    adea:	82 eb       	ldi	r24, 0xB2	; 178
    adec:	92 e0       	ldi	r25, 0x02	; 2
    adee:	ad b7       	in	r26, 0x3d	; 61
    adf0:	be b7       	in	r27, 0x3e	; 62
    adf2:	12 96       	adiw	r26, 0x02	; 2
    adf4:	9c 93       	st	X, r25
    adf6:	8e 93       	st	-X, r24
    adf8:	11 97       	sbiw	r26, 0x01	; 1
    adfa:	86 e6       	ldi	r24, 0x66	; 102
    adfc:	9a e0       	ldi	r25, 0x0A	; 10
    adfe:	93 83       	std	Z+3, r25	; 0x03
    ae00:	82 83       	std	Z+2, r24	; 0x02
    ae02:	83 e7       	ldi	r24, 0x73	; 115
    ae04:	9e e0       	ldi	r25, 0x0E	; 14
    ae06:	95 83       	std	Z+5, r25	; 0x05
    ae08:	84 83       	std	Z+4, r24	; 0x04
    ae0a:	82 e9       	ldi	r24, 0x92	; 146
    ae0c:	9e e0       	ldi	r25, 0x0E	; 14
    ae0e:	1f c0       	rjmp	.+62     	; 0xae4e <PrintIdle+0x410>
		       break;
		  case 1:
		       //FormatDate(strDate);
			   CarriegeReturn();
    ae10:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Waktu: %s %s "),strDate,strTime);
    ae14:	8d b7       	in	r24, 0x3d	; 61
    ae16:	9e b7       	in	r25, 0x3e	; 62
    ae18:	08 97       	sbiw	r24, 0x08	; 8
    ae1a:	0f b6       	in	r0, 0x3f	; 63
    ae1c:	f8 94       	cli
    ae1e:	9e bf       	out	0x3e, r25	; 62
    ae20:	0f be       	out	0x3f, r0	; 63
    ae22:	8d bf       	out	0x3d, r24	; 61
    ae24:	ed b7       	in	r30, 0x3d	; 61
    ae26:	fe b7       	in	r31, 0x3e	; 62
    ae28:	31 96       	adiw	r30, 0x01	; 1
    ae2a:	82 eb       	ldi	r24, 0xB2	; 178
    ae2c:	92 e0       	ldi	r25, 0x02	; 2
    ae2e:	ad b7       	in	r26, 0x3d	; 61
    ae30:	be b7       	in	r27, 0x3e	; 62
    ae32:	12 96       	adiw	r26, 0x02	; 2
    ae34:	9c 93       	st	X, r25
    ae36:	8e 93       	st	-X, r24
    ae38:	11 97       	sbiw	r26, 0x01	; 1
    ae3a:	82 e5       	ldi	r24, 0x52	; 82
    ae3c:	9a e0       	ldi	r25, 0x0A	; 10
    ae3e:	93 83       	std	Z+3, r25	; 0x03
    ae40:	82 83       	std	Z+2, r24	; 0x02
    ae42:	8d e7       	ldi	r24, 0x7D	; 125
    ae44:	99 e0       	ldi	r25, 0x09	; 9
    ae46:	95 83       	std	Z+5, r25	; 0x05
    ae48:	84 83       	std	Z+4, r24	; 0x04
    ae4a:	83 e5       	ldi	r24, 0x53	; 83
    ae4c:	95 e0       	ldi	r25, 0x05	; 5
    ae4e:	97 83       	std	Z+7, r25	; 0x07
    ae50:	86 83       	std	Z+6, r24	; 0x06
    ae52:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    ae56:	ed b7       	in	r30, 0x3d	; 61
    ae58:	fe b7       	in	r31, 0x3e	; 62
    ae5a:	38 96       	adiw	r30, 0x08	; 8
    ae5c:	b9 c3       	rjmp	.+1906   	; 0xb5d0 <PrintIdle+0xb92>
		       break;
		  case 2:
		       CarriegeReturn();
    ae5e:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    ae62:	00 d0       	rcall	.+0      	; 0xae64 <PrintIdle+0x426>
    ae64:	00 d0       	rcall	.+0      	; 0xae66 <PrintIdle+0x428>
    ae66:	82 eb       	ldi	r24, 0xB2	; 178
    ae68:	92 e0       	ldi	r25, 0x02	; 2
    ae6a:	ad b7       	in	r26, 0x3d	; 61
    ae6c:	be b7       	in	r27, 0x3e	; 62
    ae6e:	12 96       	adiw	r26, 0x02	; 2
    ae70:	9c 93       	st	X, r25
    ae72:	8e 93       	st	-X, r24
    ae74:	11 97       	sbiw	r26, 0x01	; 1
    ae76:	8f e2       	ldi	r24, 0x2F	; 47
    ae78:	9a e0       	ldi	r25, 0x0A	; 10
    ae7a:	be c3       	rjmp	.+1916   	; 0xb5f8 <PrintIdle+0xbba>
		       break;
		  case 3:
		       CarriegeReturn();
    ae7c:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			   //RemZeroLead(strIslandID);
			   //RemZeroLead(strFIP_ID);
		       sprintf_P(strPrint,PSTR("      Pulau/Pompa : [%s]-%s"),strIslandID,strFIP_ID);
    ae80:	ed b7       	in	r30, 0x3d	; 61
    ae82:	fe b7       	in	r31, 0x3e	; 62
    ae84:	38 97       	sbiw	r30, 0x08	; 8
    ae86:	0f b6       	in	r0, 0x3f	; 63
    ae88:	f8 94       	cli
    ae8a:	fe bf       	out	0x3e, r31	; 62
    ae8c:	0f be       	out	0x3f, r0	; 63
    ae8e:	ed bf       	out	0x3d, r30	; 61
    ae90:	31 96       	adiw	r30, 0x01	; 1
    ae92:	82 eb       	ldi	r24, 0xB2	; 178
    ae94:	92 e0       	ldi	r25, 0x02	; 2
    ae96:	ad b7       	in	r26, 0x3d	; 61
    ae98:	be b7       	in	r27, 0x3e	; 62
    ae9a:	12 96       	adiw	r26, 0x02	; 2
    ae9c:	9c 93       	st	X, r25
    ae9e:	8e 93       	st	-X, r24
    aea0:	11 97       	sbiw	r26, 0x01	; 1
    aea2:	83 e1       	ldi	r24, 0x13	; 19
    aea4:	9a e0       	ldi	r25, 0x0A	; 10
    aea6:	93 83       	std	Z+3, r25	; 0x03
    aea8:	82 83       	std	Z+2, r24	; 0x02
    aeaa:	8f ef       	ldi	r24, 0xFF	; 255
    aeac:	9a e0       	ldi	r25, 0x0A	; 10
    aeae:	95 83       	std	Z+5, r25	; 0x05
    aeb0:	84 83       	std	Z+4, r24	; 0x04
    aeb2:	88 ec       	ldi	r24, 0xC8	; 200
    aeb4:	99 e0       	ldi	r25, 0x09	; 9
    aeb6:	cb cf       	rjmp	.-106    	; 0xae4e <PrintIdle+0x410>
		       break;
		  case 4:
		       CarriegeReturn();
    aeb8:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Produk      : %s"),strDescription);
    aebc:	00 d0       	rcall	.+0      	; 0xaebe <PrintIdle+0x480>
    aebe:	00 d0       	rcall	.+0      	; 0xaec0 <PrintIdle+0x482>
    aec0:	00 d0       	rcall	.+0      	; 0xaec2 <PrintIdle+0x484>
    aec2:	ed b7       	in	r30, 0x3d	; 61
    aec4:	fe b7       	in	r31, 0x3e	; 62
    aec6:	31 96       	adiw	r30, 0x01	; 1
    aec8:	82 eb       	ldi	r24, 0xB2	; 178
    aeca:	92 e0       	ldi	r25, 0x02	; 2
    aecc:	ad b7       	in	r26, 0x3d	; 61
    aece:	be b7       	in	r27, 0x3e	; 62
    aed0:	12 96       	adiw	r26, 0x02	; 2
    aed2:	9c 93       	st	X, r25
    aed4:	8e 93       	st	-X, r24
    aed6:	11 97       	sbiw	r26, 0x01	; 1
    aed8:	8c ef       	ldi	r24, 0xFC	; 252
    aeda:	99 e0       	ldi	r25, 0x09	; 9
    aedc:	93 83       	std	Z+3, r25	; 0x03
    aede:	82 83       	std	Z+2, r24	; 0x02
    aee0:	8d e3       	ldi	r24, 0x3D	; 61
    aee2:	9a e0       	ldi	r25, 0x0A	; 10
    aee4:	6e c3       	rjmp	.+1756   	; 0xb5c2 <PrintIdle+0xb84>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    aee6:	e1 99       	sbic	0x1c, 1	; 28
    aee8:	fe cf       	rjmp	.-4      	; 0xaee6 <PrintIdle+0x4a8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    aeea:	81 ef       	ldi	r24, 0xF1	; 241
    aeec:	93 e0       	ldi	r25, 0x03	; 3
    aeee:	9f bb       	out	0x1f, r25	; 31
    aef0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    aef2:	e0 9a       	sbi	0x1c, 0	; 28
    aef4:	8d b3       	in	r24, 0x1d	; 29
    aef6:	c2 eb       	ldi	r28, 0xB2	; 178
    aef8:	d2 e0       	ldi	r29, 0x02	; 2
		       break;
		  case 5:
		       //RemZeroLead(strPrice);
               //FormatCurrency(strPrice);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    aefa:	81 30       	cpi	r24, 0x01	; 1
    aefc:	a9 f4       	brne	.+42     	; 0xaf28 <PrintIdle+0x4ea>
			   	   CarriegeReturn();
    aefe:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Harga/L     : Rp.%s"),strPrice);
    af02:	00 d0       	rcall	.+0      	; 0xaf04 <PrintIdle+0x4c6>
    af04:	00 d0       	rcall	.+0      	; 0xaf06 <PrintIdle+0x4c8>
    af06:	00 d0       	rcall	.+0      	; 0xaf08 <PrintIdle+0x4ca>
    af08:	ed b7       	in	r30, 0x3d	; 61
    af0a:	fe b7       	in	r31, 0x3e	; 62
    af0c:	31 96       	adiw	r30, 0x01	; 1
    af0e:	ad b7       	in	r26, 0x3d	; 61
    af10:	be b7       	in	r27, 0x3e	; 62
    af12:	12 96       	adiw	r26, 0x02	; 2
    af14:	dc 93       	st	X, r29
    af16:	ce 93       	st	-X, r28
    af18:	11 97       	sbiw	r26, 0x01	; 1
    af1a:	82 ee       	ldi	r24, 0xE2	; 226
    af1c:	99 e0       	ldi	r25, 0x09	; 9
    af1e:	93 83       	std	Z+3, r25	; 0x03
    af20:	82 83       	std	Z+2, r24	; 0x02
    af22:	8d ea       	ldi	r24, 0xAD	; 173
    af24:	97 e0       	ldi	r25, 0x07	; 7
    af26:	4d c3       	rjmp	.+1690   	; 0xb5c2 <PrintIdle+0xb84>
			   }else sprintf_P(strPrint,PSTR(""));
    af28:	00 d0       	rcall	.+0      	; 0xaf2a <PrintIdle+0x4ec>
    af2a:	00 d0       	rcall	.+0      	; 0xaf2c <PrintIdle+0x4ee>
    af2c:	ad b7       	in	r26, 0x3d	; 61
    af2e:	be b7       	in	r27, 0x3e	; 62
    af30:	12 96       	adiw	r26, 0x02	; 2
    af32:	dc 93       	st	X, r29
    af34:	ce 93       	st	-X, r28
    af36:	11 97       	sbiw	r26, 0x01	; 1
    af38:	81 ee       	ldi	r24, 0xE1	; 225
    af3a:	99 e0       	ldi	r25, 0x09	; 9
    af3c:	5d c3       	rjmp	.+1722   	; 0xb5f8 <PrintIdle+0xbba>

		       break;
		  case 6:
		       //RemZeroLead(strVolume);
		       CarriegeReturn();
    af3e:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Jml Liter   : %s L"),strVolume);
    af42:	00 d0       	rcall	.+0      	; 0xaf44 <PrintIdle+0x506>
    af44:	00 d0       	rcall	.+0      	; 0xaf46 <PrintIdle+0x508>
    af46:	00 d0       	rcall	.+0      	; 0xaf48 <PrintIdle+0x50a>
    af48:	ed b7       	in	r30, 0x3d	; 61
    af4a:	fe b7       	in	r31, 0x3e	; 62
    af4c:	31 96       	adiw	r30, 0x01	; 1
    af4e:	82 eb       	ldi	r24, 0xB2	; 178
    af50:	92 e0       	ldi	r25, 0x02	; 2
    af52:	ad b7       	in	r26, 0x3d	; 61
    af54:	be b7       	in	r27, 0x3e	; 62
    af56:	12 96       	adiw	r26, 0x02	; 2
    af58:	9c 93       	st	X, r25
    af5a:	8e 93       	st	-X, r24
    af5c:	11 97       	sbiw	r26, 0x01	; 1
    af5e:	88 ec       	ldi	r24, 0xC8	; 200
    af60:	99 e0       	ldi	r25, 0x09	; 9
    af62:	93 83       	std	Z+3, r25	; 0x03
    af64:	82 83       	std	Z+2, r24	; 0x02
    af66:	8b e7       	ldi	r24, 0x7B	; 123
    af68:	95 e0       	ldi	r25, 0x05	; 5
    af6a:	2b c3       	rjmp	.+1622   	; 0xb5c2 <PrintIdle+0xb84>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    af6c:	e1 99       	sbic	0x1c, 1	; 28
    af6e:	fe cf       	rjmp	.-4      	; 0xaf6c <PrintIdle+0x52e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    af70:	81 ef       	ldi	r24, 0xF1	; 241
    af72:	93 e0       	ldi	r25, 0x03	; 3
    af74:	9f bb       	out	0x1f, r25	; 31
    af76:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    af78:	e0 9a       	sbi	0x1c, 0	; 28
    af7a:	8d b3       	in	r24, 0x1d	; 29
    af7c:	c2 eb       	ldi	r28, 0xB2	; 178
    af7e:	d2 e0       	ldi	r29, 0x02	; 2
		       break;
		  case 7:
		       //RemZeroLead(strAmount);		       
			   //FormatCurrency(strAmount);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    af80:	81 30       	cpi	r24, 0x01	; 1
    af82:	a9 f4       	brne	.+42     	; 0xafae <PrintIdle+0x570>
			   	   CarriegeReturn();
    af84:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Jml Rupiah  : Rp.%s"),strAmount);
    af88:	00 d0       	rcall	.+0      	; 0xaf8a <PrintIdle+0x54c>
    af8a:	00 d0       	rcall	.+0      	; 0xaf8c <PrintIdle+0x54e>
    af8c:	00 d0       	rcall	.+0      	; 0xaf8e <PrintIdle+0x550>
    af8e:	ed b7       	in	r30, 0x3d	; 61
    af90:	fe b7       	in	r31, 0x3e	; 62
    af92:	31 96       	adiw	r30, 0x01	; 1
    af94:	ad b7       	in	r26, 0x3d	; 61
    af96:	be b7       	in	r27, 0x3e	; 62
    af98:	12 96       	adiw	r26, 0x02	; 2
    af9a:	dc 93       	st	X, r29
    af9c:	ce 93       	st	-X, r28
    af9e:	11 97       	sbiw	r26, 0x01	; 1
    afa0:	8e ea       	ldi	r24, 0xAE	; 174
    afa2:	99 e0       	ldi	r25, 0x09	; 9
    afa4:	93 83       	std	Z+3, r25	; 0x03
    afa6:	82 83       	std	Z+2, r24	; 0x02
    afa8:	8b eb       	ldi	r24, 0xBB	; 187
    afaa:	9d e0       	ldi	r25, 0x0D	; 13
    afac:	0a c3       	rjmp	.+1556   	; 0xb5c2 <PrintIdle+0xb84>
			   }else sprintf_P(strPrint,PSTR(""));
    afae:	00 d0       	rcall	.+0      	; 0xafb0 <PrintIdle+0x572>
    afb0:	00 d0       	rcall	.+0      	; 0xafb2 <PrintIdle+0x574>
    afb2:	ad b7       	in	r26, 0x3d	; 61
    afb4:	be b7       	in	r27, 0x3e	; 62
    afb6:	12 96       	adiw	r26, 0x02	; 2
    afb8:	dc 93       	st	X, r29
    afba:	ce 93       	st	-X, r28
    afbc:	11 97       	sbiw	r26, 0x01	; 1
    afbe:	8d ea       	ldi	r24, 0xAD	; 173
    afc0:	99 e0       	ldi	r25, 0x09	; 9
    afc2:	1a c3       	rjmp	.+1588   	; 0xb5f8 <PrintIdle+0xbba>

		       break;
		  case 8:
		       if ((strlen(strLicPlate)>0)&&(SpaceOnly(strLicPlate)==False)){
    afc4:	c2 e0       	ldi	r28, 0x02	; 2
    afc6:	db e0       	ldi	r29, 0x0B	; 11
    afc8:	80 91 02 0b 	lds	r24, 0x0B02
    afcc:	88 23       	and	r24, r24
    afce:	09 f4       	brne	.+2      	; 0xafd2 <PrintIdle+0x594>
    afd0:	18 c2       	rjmp	.+1072   	; 0xb402 <PrintIdle+0x9c4>
    afd2:	ce 01       	movw	r24, r28
    afd4:	0e 94 44 21 	call	0x4288	; 0x4288 <SpaceOnly>
    afd8:	88 23       	and	r24, r24
    afda:	09 f0       	breq	.+2      	; 0xafde <PrintIdle+0x5a0>
    afdc:	12 c2       	rjmp	.+1060   	; 0xb402 <PrintIdle+0x9c4>
			       CarriegeReturn();
    afde:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      No.Polisi   : %s"),strLicPlate);
    afe2:	00 d0       	rcall	.+0      	; 0xafe4 <PrintIdle+0x5a6>
    afe4:	00 d0       	rcall	.+0      	; 0xafe6 <PrintIdle+0x5a8>
    afe6:	00 d0       	rcall	.+0      	; 0xafe8 <PrintIdle+0x5aa>
    afe8:	ed b7       	in	r30, 0x3d	; 61
    afea:	fe b7       	in	r31, 0x3e	; 62
    afec:	31 96       	adiw	r30, 0x01	; 1
    afee:	82 eb       	ldi	r24, 0xB2	; 178
    aff0:	92 e0       	ldi	r25, 0x02	; 2
    aff2:	ad b7       	in	r26, 0x3d	; 61
    aff4:	be b7       	in	r27, 0x3e	; 62
    aff6:	12 96       	adiw	r26, 0x02	; 2
    aff8:	9c 93       	st	X, r25
    affa:	8e 93       	st	-X, r24
    affc:	11 97       	sbiw	r26, 0x01	; 1
    affe:	86 e9       	ldi	r24, 0x96	; 150
    b000:	99 e0       	ldi	r25, 0x09	; 9
    b002:	1f c0       	rjmp	.+62     	; 0xb042 <PrintIdle+0x604>
                   ClearMem(strLicPlate);
				   }
               else ClearMem(strPrint);
		       break;
		  case 9:
		       if ((strlen(strOdometer)>0)&&(SpaceOnly(strOdometer)==False)){
    b004:	c9 ec       	ldi	r28, 0xC9	; 201
    b006:	d5 e0       	ldi	r29, 0x05	; 5
    b008:	80 91 c9 05 	lds	r24, 0x05C9
    b00c:	88 23       	and	r24, r24
    b00e:	09 f4       	brne	.+2      	; 0xb012 <PrintIdle+0x5d4>
    b010:	f8 c1       	rjmp	.+1008   	; 0xb402 <PrintIdle+0x9c4>
    b012:	ce 01       	movw	r24, r28
    b014:	0e 94 44 21 	call	0x4288	; 0x4288 <SpaceOnly>
    b018:	88 23       	and	r24, r24
    b01a:	09 f0       	breq	.+2      	; 0xb01e <PrintIdle+0x5e0>
    b01c:	f2 c1       	rjmp	.+996    	; 0xb402 <PrintIdle+0x9c4>
			       CarriegeReturn();
    b01e:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("      Odometer    : %s"),strOdometer);
    b022:	00 d0       	rcall	.+0      	; 0xb024 <PrintIdle+0x5e6>
    b024:	00 d0       	rcall	.+0      	; 0xb026 <PrintIdle+0x5e8>
    b026:	00 d0       	rcall	.+0      	; 0xb028 <PrintIdle+0x5ea>
    b028:	ed b7       	in	r30, 0x3d	; 61
    b02a:	fe b7       	in	r31, 0x3e	; 62
    b02c:	31 96       	adiw	r30, 0x01	; 1
    b02e:	82 eb       	ldi	r24, 0xB2	; 178
    b030:	92 e0       	ldi	r25, 0x02	; 2
    b032:	ad b7       	in	r26, 0x3d	; 61
    b034:	be b7       	in	r27, 0x3e	; 62
    b036:	12 96       	adiw	r26, 0x02	; 2
    b038:	9c 93       	st	X, r25
    b03a:	8e 93       	st	-X, r24
    b03c:	11 97       	sbiw	r26, 0x01	; 1
    b03e:	8f e7       	ldi	r24, 0x7F	; 127
    b040:	99 e0       	ldi	r25, 0x09	; 9
    b042:	93 83       	std	Z+3, r25	; 0x03
    b044:	82 83       	std	Z+2, r24	; 0x02
    b046:	d5 83       	std	Z+5, r29	; 0x05
    b048:	c4 83       	std	Z+4, r28	; 0x04
    b04a:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
				   ClearMem(strOdometer);
    b04e:	ed b7       	in	r30, 0x3d	; 61
    b050:	fe b7       	in	r31, 0x3e	; 62
    b052:	36 96       	adiw	r30, 0x06	; 6
    b054:	0f b6       	in	r0, 0x3f	; 63
    b056:	f8 94       	cli
    b058:	fe bf       	out	0x3e, r31	; 62
    b05a:	0f be       	out	0x3f, r0	; 63
    b05c:	ed bf       	out	0x3d, r30	; 61
    b05e:	ce 01       	movw	r24, r28
    b060:	0e 94 2b ac 	call	0x15856	; 0x15856 <ClearMem>
    b064:	d3 c2       	rjmp	.+1446   	; 0xb60c <PrintIdle+0xbce>
			   }else ClearMem(strPrint);
		       break;
		  case 10:
		       CarriegeReturn();
    b066:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b06a:	00 d0       	rcall	.+0      	; 0xb06c <PrintIdle+0x62e>
    b06c:	00 d0       	rcall	.+0      	; 0xb06e <PrintIdle+0x630>
    b06e:	82 eb       	ldi	r24, 0xB2	; 178
    b070:	92 e0       	ldi	r25, 0x02	; 2
    b072:	ad b7       	in	r26, 0x3d	; 61
    b074:	be b7       	in	r27, 0x3e	; 62
    b076:	12 96       	adiw	r26, 0x02	; 2
    b078:	9c 93       	st	X, r25
    b07a:	8e 93       	st	-X, r24
    b07c:	11 97       	sbiw	r26, 0x01	; 1
    b07e:	8c e5       	ldi	r24, 0x5C	; 92
    b080:	99 e0       	ldi	r25, 0x09	; 9
    b082:	ba c2       	rjmp	.+1396   	; 0xb5f8 <PrintIdle+0xbba>
		       break;
          //ChangeMOPPrint
		  case 11:
			   if ((MOPType==MOP_LOCAL_ACCOUNT)||(MOPType==MOP_DEBIT_CARD)||(MOPType==MOP_LOYALTY_LOCAL_ACCOUNT)){
    b084:	80 91 e4 01 	lds	r24, 0x01E4
    b088:	81 30       	cpi	r24, 0x01	; 1
    b08a:	21 f0       	breq	.+8      	; 0xb094 <PrintIdle+0x656>
    b08c:	83 30       	cpi	r24, 0x03	; 3
    b08e:	11 f0       	breq	.+4      	; 0xb094 <PrintIdle+0x656>
    b090:	86 30       	cpi	r24, 0x06	; 6
    b092:	b9 f4       	brne	.+46     	; 0xb0c2 <PrintIdle+0x684>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    b094:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Kartu ID : %s"),strCardID);
    b098:	00 d0       	rcall	.+0      	; 0xb09a <PrintIdle+0x65c>
    b09a:	00 d0       	rcall	.+0      	; 0xb09c <PrintIdle+0x65e>
    b09c:	00 d0       	rcall	.+0      	; 0xb09e <PrintIdle+0x660>
    b09e:	ed b7       	in	r30, 0x3d	; 61
    b0a0:	fe b7       	in	r31, 0x3e	; 62
    b0a2:	31 96       	adiw	r30, 0x01	; 1
    b0a4:	82 eb       	ldi	r24, 0xB2	; 178
    b0a6:	92 e0       	ldi	r25, 0x02	; 2
    b0a8:	ad b7       	in	r26, 0x3d	; 61
    b0aa:	be b7       	in	r27, 0x3e	; 62
    b0ac:	12 96       	adiw	r26, 0x02	; 2
    b0ae:	9c 93       	st	X, r25
    b0b0:	8e 93       	st	-X, r24
    b0b2:	11 97       	sbiw	r26, 0x01	; 1
    b0b4:	8a e4       	ldi	r24, 0x4A	; 74
    b0b6:	99 e0       	ldi	r25, 0x09	; 9
    b0b8:	93 83       	std	Z+3, r25	; 0x03
    b0ba:	82 83       	std	Z+2, r24	; 0x02
    b0bc:	81 e9       	ldi	r24, 0x91	; 145
    b0be:	9d e0       	ldi	r25, 0x0D	; 13
    b0c0:	18 c0       	rjmp	.+48     	; 0xb0f2 <PrintIdle+0x6b4>
				   IsSignedField=True;
				   }
	           else
			   if (MOPType==MOP_VOUCHER){
    b0c2:	87 30       	cpi	r24, 0x07	; 7
    b0c4:	f1 f4       	brne	.+60     	; 0xb102 <PrintIdle+0x6c4>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    b0c6:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Voucher No: %s"),strVoucherNum);
    b0ca:	00 d0       	rcall	.+0      	; 0xb0cc <PrintIdle+0x68e>
    b0cc:	00 d0       	rcall	.+0      	; 0xb0ce <PrintIdle+0x690>
    b0ce:	00 d0       	rcall	.+0      	; 0xb0d0 <PrintIdle+0x692>
    b0d0:	ed b7       	in	r30, 0x3d	; 61
    b0d2:	fe b7       	in	r31, 0x3e	; 62
    b0d4:	31 96       	adiw	r30, 0x01	; 1
    b0d6:	82 eb       	ldi	r24, 0xB2	; 178
    b0d8:	92 e0       	ldi	r25, 0x02	; 2
    b0da:	ad b7       	in	r26, 0x3d	; 61
    b0dc:	be b7       	in	r27, 0x3e	; 62
    b0de:	12 96       	adiw	r26, 0x02	; 2
    b0e0:	9c 93       	st	X, r25
    b0e2:	8e 93       	st	-X, r24
    b0e4:	11 97       	sbiw	r26, 0x01	; 1
    b0e6:	87 e3       	ldi	r24, 0x37	; 55
    b0e8:	99 e0       	ldi	r25, 0x09	; 9
    b0ea:	93 83       	std	Z+3, r25	; 0x03
    b0ec:	82 83       	std	Z+2, r24	; 0x02
    b0ee:	87 e4       	ldi	r24, 0x47	; 71
    b0f0:	9e e0       	ldi	r25, 0x0E	; 14
    b0f2:	95 83       	std	Z+5, r25	; 0x05
    b0f4:	84 83       	std	Z+4, r24	; 0x04
    b0f6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
				   IsSignedField=True;
    b0fa:	81 e0       	ldi	r24, 0x01	; 1
    b0fc:	80 93 af 02 	sts	0x02AF, r24
    b100:	64 c2       	rjmp	.+1224   	; 0xb5ca <PrintIdle+0xb8c>
    b102:	c2 eb       	ldi	r28, 0xB2	; 178
    b104:	d2 e0       	ldi	r29, 0x02	; 2
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b106:	88 30       	cpi	r24, 0x08	; 8
    b108:	09 f0       	breq	.+2      	; 0xb10c <PrintIdle+0x6ce>
    b10a:	a9 cf       	rjmp	.-174    	; 0xb05e <PrintIdle+0x620>
			       CarriegeReturn();
    b10c:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("          *** PUMP TEST ***       "));
    b110:	00 d0       	rcall	.+0      	; 0xb112 <PrintIdle+0x6d4>
    b112:	00 d0       	rcall	.+0      	; 0xb114 <PrintIdle+0x6d6>
    b114:	ad b7       	in	r26, 0x3d	; 61
    b116:	be b7       	in	r27, 0x3e	; 62
    b118:	12 96       	adiw	r26, 0x02	; 2
    b11a:	dc 93       	st	X, r29
    b11c:	ce 93       	st	-X, r28
    b11e:	11 97       	sbiw	r26, 0x01	; 1
    b120:	84 e1       	ldi	r24, 0x14	; 20
    b122:	99 e0       	ldi	r25, 0x09	; 9
    b124:	14 96       	adiw	r26, 0x04	; 4
    b126:	9c 93       	st	X, r25
    b128:	8e 93       	st	-X, r24
    b12a:	13 97       	sbiw	r26, 0x03	; 3
    b12c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
				   IsSignedField=False;
    b130:	10 92 af 02 	sts	0x02AF, r1
    b134:	67 c2       	rjmp	.+1230   	; 0xb604 <PrintIdle+0xbc6>
				   }
               else ClearMem(strPrint);
		       break;
          case 12:
			   if (MOPType==MOP_LOCAL_ACCOUNT) {
    b136:	80 91 e4 01 	lds	r24, 0x01E4
    b13a:	81 30       	cpi	r24, 0x01	; 1
    b13c:	99 f4       	brne	.+38     	; 0xb164 <PrintIdle+0x726>
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    b13e:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Nama     : %s"),strCardHolder);
    b142:	00 d0       	rcall	.+0      	; 0xb144 <PrintIdle+0x706>
    b144:	00 d0       	rcall	.+0      	; 0xb146 <PrintIdle+0x708>
    b146:	00 d0       	rcall	.+0      	; 0xb148 <PrintIdle+0x70a>
    b148:	ed b7       	in	r30, 0x3d	; 61
    b14a:	fe b7       	in	r31, 0x3e	; 62
    b14c:	31 96       	adiw	r30, 0x01	; 1
    b14e:	82 eb       	ldi	r24, 0xB2	; 178
    b150:	92 e0       	ldi	r25, 0x02	; 2
    b152:	ad b7       	in	r26, 0x3d	; 61
    b154:	be b7       	in	r27, 0x3e	; 62
    b156:	12 96       	adiw	r26, 0x02	; 2
    b158:	9c 93       	st	X, r25
    b15a:	8e 93       	st	-X, r24
    b15c:	11 97       	sbiw	r26, 0x01	; 1
    b15e:	82 e0       	ldi	r24, 0x02	; 2
    b160:	99 e0       	ldi	r25, 0x09	; 9
    b162:	3a c0       	rjmp	.+116    	; 0xb1d8 <PrintIdle+0x79a>
				   }
               else 
               if (MOPType==MOP_DEBIT_CARD) {//EDCApprovalCode
    b164:	83 30       	cpi	r24, 0x03	; 3
    b166:	e9 f5       	brne	.+122    	; 0xb1e2 <PrintIdle+0x7a4>
			       if (IsPrintApprovalCode==True){
    b168:	80 91 c6 01 	lds	r24, 0x01C6
    b16c:	81 30       	cpi	r24, 0x01	; 1
    b16e:	11 f5       	brne	.+68     	; 0xb1b4 <PrintIdle+0x776>
				       IsPrintApprovalCode=False;
    b170:	10 92 c6 01 	sts	0x01C6, r1
					   FillChar(strCardHolder,0,sizeof(strCardHolder));
					   sprintf_P(strCardHolder,PSTR("%s  "),strApprovalCode);
    b174:	00 d0       	rcall	.+0      	; 0xb176 <PrintIdle+0x738>
    b176:	00 d0       	rcall	.+0      	; 0xb178 <PrintIdle+0x73a>
    b178:	00 d0       	rcall	.+0      	; 0xb17a <PrintIdle+0x73c>
    b17a:	ed b7       	in	r30, 0x3d	; 61
    b17c:	fe b7       	in	r31, 0x3e	; 62
    b17e:	31 96       	adiw	r30, 0x01	; 1
    b180:	8a e2       	ldi	r24, 0x2A	; 42
    b182:	95 e0       	ldi	r25, 0x05	; 5
    b184:	ad b7       	in	r26, 0x3d	; 61
    b186:	be b7       	in	r27, 0x3e	; 62
    b188:	12 96       	adiw	r26, 0x02	; 2
    b18a:	9c 93       	st	X, r25
    b18c:	8e 93       	st	-X, r24
    b18e:	11 97       	sbiw	r26, 0x01	; 1
    b190:	8d ef       	ldi	r24, 0xFD	; 253
    b192:	98 e0       	ldi	r25, 0x08	; 8
    b194:	93 83       	std	Z+3, r25	; 0x03
    b196:	82 83       	std	Z+2, r24	; 0x02
    b198:	80 e1       	ldi	r24, 0x10	; 16
    b19a:	9a e0       	ldi	r25, 0x0A	; 10
    b19c:	95 83       	std	Z+5, r25	; 0x05
    b19e:	84 83       	std	Z+4, r24	; 0x04
    b1a0:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    b1a4:	ed b7       	in	r30, 0x3d	; 61
    b1a6:	fe b7       	in	r31, 0x3e	; 62
    b1a8:	36 96       	adiw	r30, 0x06	; 6
    b1aa:	0f b6       	in	r0, 0x3f	; 63
    b1ac:	f8 94       	cli
    b1ae:	fe bf       	out	0x3e, r31	; 62
    b1b0:	0f be       	out	0x3f, r0	; 63
    b1b2:	ed bf       	out	0x3d, r30	; 61
				   }
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    b1b4:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Appr Code: %s"),strCardHolder);
    b1b8:	00 d0       	rcall	.+0      	; 0xb1ba <PrintIdle+0x77c>
    b1ba:	00 d0       	rcall	.+0      	; 0xb1bc <PrintIdle+0x77e>
    b1bc:	00 d0       	rcall	.+0      	; 0xb1be <PrintIdle+0x780>
    b1be:	ed b7       	in	r30, 0x3d	; 61
    b1c0:	fe b7       	in	r31, 0x3e	; 62
    b1c2:	31 96       	adiw	r30, 0x01	; 1
    b1c4:	82 eb       	ldi	r24, 0xB2	; 178
    b1c6:	92 e0       	ldi	r25, 0x02	; 2
    b1c8:	ad b7       	in	r26, 0x3d	; 61
    b1ca:	be b7       	in	r27, 0x3e	; 62
    b1cc:	12 96       	adiw	r26, 0x02	; 2
    b1ce:	9c 93       	st	X, r25
    b1d0:	8e 93       	st	-X, r24
    b1d2:	11 97       	sbiw	r26, 0x01	; 1
    b1d4:	8b ee       	ldi	r24, 0xEB	; 235
    b1d6:	98 e0       	ldi	r25, 0x08	; 8
    b1d8:	93 83       	std	Z+3, r25	; 0x03
    b1da:	82 83       	std	Z+2, r24	; 0x02
    b1dc:	8a e2       	ldi	r24, 0x2A	; 42
    b1de:	95 e0       	ldi	r25, 0x05	; 5
    b1e0:	f0 c1       	rjmp	.+992    	; 0xb5c2 <PrintIdle+0xb84>
				   }
               else
			   if (MOPType==MOP_VOUCHER){
    b1e2:	87 30       	cpi	r24, 0x07	; 7
    b1e4:	79 f4       	brne	.+30     	; 0xb204 <PrintIdle+0x7c6>
			       CarriegeReturn();
    b1e6:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("  "));
    b1ea:	00 d0       	rcall	.+0      	; 0xb1ec <PrintIdle+0x7ae>
    b1ec:	00 d0       	rcall	.+0      	; 0xb1ee <PrintIdle+0x7b0>
    b1ee:	82 eb       	ldi	r24, 0xB2	; 178
    b1f0:	92 e0       	ldi	r25, 0x02	; 2
    b1f2:	ad b7       	in	r26, 0x3d	; 61
    b1f4:	be b7       	in	r27, 0x3e	; 62
    b1f6:	12 96       	adiw	r26, 0x02	; 2
    b1f8:	9c 93       	st	X, r25
    b1fa:	8e 93       	st	-X, r24
    b1fc:	11 97       	sbiw	r26, 0x01	; 1
    b1fe:	88 ee       	ldi	r24, 0xE8	; 232
    b200:	98 e0       	ldi	r25, 0x08	; 8
    b202:	fa c1       	rjmp	.+1012   	; 0xb5f8 <PrintIdle+0xbba>
    b204:	c2 eb       	ldi	r28, 0xB2	; 178
    b206:	d2 e0       	ldi	r29, 0x02	; 2
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b208:	88 30       	cpi	r24, 0x08	; 8
    b20a:	09 f0       	breq	.+2      	; 0xb20e <PrintIdle+0x7d0>
    b20c:	28 cf       	rjmp	.-432    	; 0xb05e <PrintIdle+0x620>
			       CarriegeReturn();
    b20e:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                 "));
    b212:	00 d0       	rcall	.+0      	; 0xb214 <PrintIdle+0x7d6>
    b214:	00 d0       	rcall	.+0      	; 0xb216 <PrintIdle+0x7d8>
    b216:	ed b7       	in	r30, 0x3d	; 61
    b218:	fe b7       	in	r31, 0x3e	; 62
    b21a:	d2 83       	std	Z+2, r29	; 0x02
    b21c:	c1 83       	std	Z+1, r28	; 0x01
    b21e:	86 ed       	ldi	r24, 0xD6	; 214
    b220:	98 e0       	ldi	r25, 0x08	; 8
    b222:	25 c0       	rjmp	.+74     	; 0xb26e <PrintIdle+0x830>
				   }
               else ClearMem(strPrint);
		       break;
          case 13:
		       if (IsSignedField==True){
    b224:	80 91 af 02 	lds	r24, 0x02AF
    b228:	c2 eb       	ldi	r28, 0xB2	; 178
    b22a:	d2 e0       	ldi	r29, 0x02	; 2
    b22c:	81 30       	cpi	r24, 0x01	; 1
    b22e:	09 f0       	breq	.+2      	; 0xb232 <PrintIdle+0x7f4>
    b230:	16 cf       	rjmp	.-468    	; 0xb05e <PrintIdle+0x620>
			       CarriegeReturn();
    b232:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b236:	00 d0       	rcall	.+0      	; 0xb238 <PrintIdle+0x7fa>
    b238:	00 d0       	rcall	.+0      	; 0xb23a <PrintIdle+0x7fc>
    b23a:	ad b7       	in	r26, 0x3d	; 61
    b23c:	be b7       	in	r27, 0x3e	; 62
    b23e:	12 96       	adiw	r26, 0x02	; 2
    b240:	dc 93       	st	X, r29
    b242:	ce 93       	st	-X, r28
    b244:	11 97       	sbiw	r26, 0x01	; 1
    b246:	8f eb       	ldi	r24, 0xBF	; 191
    b248:	98 e0       	ldi	r25, 0x08	; 8
    b24a:	d6 c1       	rjmp	.+940    	; 0xb5f8 <PrintIdle+0xbba>
               }else ClearMem(strPrint);
		       break;
          case 14:
		       if (IsSignedField==True){
    b24c:	80 91 af 02 	lds	r24, 0x02AF
    b250:	c2 eb       	ldi	r28, 0xB2	; 178
    b252:	d2 e0       	ldi	r29, 0x02	; 2
    b254:	81 30       	cpi	r24, 0x01	; 1
    b256:	09 f0       	breq	.+2      	; 0xb25a <PrintIdle+0x81c>
    b258:	02 cf       	rjmp	.-508    	; 0xb05e <PrintIdle+0x620>
			       CarriegeReturn();
    b25a:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b25e:	00 d0       	rcall	.+0      	; 0xb260 <PrintIdle+0x822>
    b260:	00 d0       	rcall	.+0      	; 0xb262 <PrintIdle+0x824>
    b262:	ed b7       	in	r30, 0x3d	; 61
    b264:	fe b7       	in	r31, 0x3e	; 62
    b266:	d2 83       	std	Z+2, r29	; 0x02
    b268:	c1 83       	std	Z+1, r28	; 0x01
    b26a:	88 ea       	ldi	r24, 0xA8	; 168
    b26c:	98 e0       	ldi	r25, 0x08	; 8
    b26e:	94 83       	std	Z+4, r25	; 0x04
    b270:	83 83       	std	Z+3, r24	; 0x03
    b272:	c6 c1       	rjmp	.+908    	; 0xb600 <PrintIdle+0xbc2>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 17:
		       if (IsSignedField==True){
    b274:	80 91 af 02 	lds	r24, 0x02AF
    b278:	c2 eb       	ldi	r28, 0xB2	; 178
    b27a:	d2 e0       	ldi	r29, 0x02	; 2
    b27c:	81 30       	cpi	r24, 0x01	; 1
    b27e:	09 f0       	breq	.+2      	; 0xb282 <PrintIdle+0x844>
    b280:	ee ce       	rjmp	.-548    	; 0xb05e <PrintIdle+0x620>
			       CarriegeReturn();
    b282:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Tanda Tangan  (______________)"));
    b286:	00 d0       	rcall	.+0      	; 0xb288 <PrintIdle+0x84a>
    b288:	00 d0       	rcall	.+0      	; 0xb28a <PrintIdle+0x84c>
    b28a:	ad b7       	in	r26, 0x3d	; 61
    b28c:	be b7       	in	r27, 0x3e	; 62
    b28e:	12 96       	adiw	r26, 0x02	; 2
    b290:	dc 93       	st	X, r29
    b292:	ce 93       	st	-X, r28
    b294:	11 97       	sbiw	r26, 0x01	; 1
    b296:	85 e8       	ldi	r24, 0x85	; 133
    b298:	98 e0       	ldi	r25, 0x08	; 8
    b29a:	ae c1       	rjmp	.+860    	; 0xb5f8 <PrintIdle+0xbba>
               }else ClearMem(strPrint);
		       break;
          case 18:
		       if (IsSignedField==True){
    b29c:	80 91 af 02 	lds	r24, 0x02AF
    b2a0:	81 30       	cpi	r24, 0x01	; 1
    b2a2:	09 f0       	breq	.+2      	; 0xb2a6 <PrintIdle+0x868>
    b2a4:	ae c0       	rjmp	.+348    	; 0xb402 <PrintIdle+0x9c4>
			       IsSignedField=False;
    b2a6:	10 92 af 02 	sts	0x02AF, r1
    b2aa:	ab c0       	rjmp	.+342    	; 0xb402 <PrintIdle+0x9c4>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 19://PrintMOP Name
		       if (MOPType!=MOP_CASH){
    b2ac:	80 91 e4 01 	lds	r24, 0x01E4
    b2b0:	c2 eb       	ldi	r28, 0xB2	; 178
    b2b2:	d2 e0       	ldi	r29, 0x02	; 2
    b2b4:	88 23       	and	r24, r24
    b2b6:	09 f4       	brne	.+2      	; 0xb2ba <PrintIdle+0x87c>
    b2b8:	d2 ce       	rjmp	.-604    	; 0xb05e <PrintIdle+0x620>
			       CarriegeReturn();
    b2ba:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			       //RemSpaceLag(strMOPName);
			       sprintf_P(strPrint,PSTR("    .%s"),strMOPName);
    b2be:	00 d0       	rcall	.+0      	; 0xb2c0 <PrintIdle+0x882>
    b2c0:	00 d0       	rcall	.+0      	; 0xb2c2 <PrintIdle+0x884>
    b2c2:	00 d0       	rcall	.+0      	; 0xb2c4 <PrintIdle+0x886>
    b2c4:	ed b7       	in	r30, 0x3d	; 61
    b2c6:	fe b7       	in	r31, 0x3e	; 62
    b2c8:	31 96       	adiw	r30, 0x01	; 1
    b2ca:	ad b7       	in	r26, 0x3d	; 61
    b2cc:	be b7       	in	r27, 0x3e	; 62
    b2ce:	12 96       	adiw	r26, 0x02	; 2
    b2d0:	dc 93       	st	X, r29
    b2d2:	ce 93       	st	-X, r28
    b2d4:	11 97       	sbiw	r26, 0x01	; 1
    b2d6:	8d e7       	ldi	r24, 0x7D	; 125
    b2d8:	98 e0       	ldi	r25, 0x08	; 8
    b2da:	93 83       	std	Z+3, r25	; 0x03
    b2dc:	82 83       	std	Z+2, r24	; 0x02
    b2de:	8c e8       	ldi	r24, 0x8C	; 140
    b2e0:	97 e0       	ldi	r25, 0x07	; 7
    b2e2:	6f c1       	rjmp	.+734    	; 0xb5c2 <PrintIdle+0xb84>
			   }else ClearMem(strPrint);
		       break;
		  case 20:
		       if (MOPType!=MOP_CASH){
    b2e4:	80 91 e4 01 	lds	r24, 0x01E4
    b2e8:	c2 eb       	ldi	r28, 0xB2	; 178
    b2ea:	d2 e0       	ldi	r29, 0x02	; 2
    b2ec:	88 23       	and	r24, r24
    b2ee:	09 f4       	brne	.+2      	; 0xb2f2 <PrintIdle+0x8b4>
    b2f0:	b6 ce       	rjmp	.-660    	; 0xb05e <PrintIdle+0x620>
			       CarriegeReturn();
    b2f2:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("    ------------------------------"));
    b2f6:	00 d0       	rcall	.+0      	; 0xb2f8 <PrintIdle+0x8ba>
    b2f8:	00 d0       	rcall	.+0      	; 0xb2fa <PrintIdle+0x8bc>
    b2fa:	ad b7       	in	r26, 0x3d	; 61
    b2fc:	be b7       	in	r27, 0x3e	; 62
    b2fe:	12 96       	adiw	r26, 0x02	; 2
    b300:	dc 93       	st	X, r29
    b302:	ce 93       	st	-X, r28
    b304:	11 97       	sbiw	r26, 0x01	; 1
    b306:	8a e5       	ldi	r24, 0x5A	; 90
    b308:	98 e0       	ldi	r25, 0x08	; 8
    b30a:	76 c1       	rjmp	.+748    	; 0xb5f8 <PrintIdle+0xbba>
			   }else ClearMem(strPrint);
		       break;          
          //Loyalty
		  case 21:
		       CarriegeReturn();
    b30c:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("         LOYALTY INFORMATION      "));
    b310:	00 d0       	rcall	.+0      	; 0xb312 <PrintIdle+0x8d4>
    b312:	00 d0       	rcall	.+0      	; 0xb314 <PrintIdle+0x8d6>
    b314:	82 eb       	ldi	r24, 0xB2	; 178
    b316:	92 e0       	ldi	r25, 0x02	; 2
    b318:	ed b7       	in	r30, 0x3d	; 61
    b31a:	fe b7       	in	r31, 0x3e	; 62
    b31c:	92 83       	std	Z+2, r25	; 0x02
    b31e:	81 83       	std	Z+1, r24	; 0x01
    b320:	87 e3       	ldi	r24, 0x37	; 55
    b322:	98 e0       	ldi	r25, 0x08	; 8
    b324:	a4 cf       	rjmp	.-184    	; 0xb26e <PrintIdle+0x830>
		       break; 			            
		  case 22:
		       CarriegeReturn();
    b326:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Card ID      : %s"),strLoyCardID);
    b32a:	00 d0       	rcall	.+0      	; 0xb32c <PrintIdle+0x8ee>
    b32c:	00 d0       	rcall	.+0      	; 0xb32e <PrintIdle+0x8f0>
    b32e:	00 d0       	rcall	.+0      	; 0xb330 <PrintIdle+0x8f2>
    b330:	ed b7       	in	r30, 0x3d	; 61
    b332:	fe b7       	in	r31, 0x3e	; 62
    b334:	31 96       	adiw	r30, 0x01	; 1
    b336:	82 eb       	ldi	r24, 0xB2	; 178
    b338:	92 e0       	ldi	r25, 0x02	; 2
    b33a:	ad b7       	in	r26, 0x3d	; 61
    b33c:	be b7       	in	r27, 0x3e	; 62
    b33e:	12 96       	adiw	r26, 0x02	; 2
    b340:	9c 93       	st	X, r25
    b342:	8e 93       	st	-X, r24
    b344:	11 97       	sbiw	r26, 0x01	; 1
    b346:	80 e2       	ldi	r24, 0x20	; 32
    b348:	98 e0       	ldi	r25, 0x08	; 8
    b34a:	93 83       	std	Z+3, r25	; 0x03
    b34c:	82 83       	std	Z+2, r24	; 0x02
    b34e:	8d ee       	ldi	r24, 0xED	; 237
    b350:	94 e0       	ldi	r25, 0x04	; 4
    b352:	37 c1       	rjmp	.+622    	; 0xb5c2 <PrintIdle+0xb84>
		       break;
		  case 23:
		       CarriegeReturn();
    b354:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			   //RemSpaceLag(strLoyCardHolder);
		       sprintf_P(strPrint,PSTR("     Card Holder  : %s "),strLoyCardHolder);
    b358:	00 d0       	rcall	.+0      	; 0xb35a <PrintIdle+0x91c>
    b35a:	00 d0       	rcall	.+0      	; 0xb35c <PrintIdle+0x91e>
    b35c:	00 d0       	rcall	.+0      	; 0xb35e <PrintIdle+0x920>
    b35e:	ed b7       	in	r30, 0x3d	; 61
    b360:	fe b7       	in	r31, 0x3e	; 62
    b362:	31 96       	adiw	r30, 0x01	; 1
    b364:	82 eb       	ldi	r24, 0xB2	; 178
    b366:	92 e0       	ldi	r25, 0x02	; 2
    b368:	ad b7       	in	r26, 0x3d	; 61
    b36a:	be b7       	in	r27, 0x3e	; 62
    b36c:	12 96       	adiw	r26, 0x02	; 2
    b36e:	9c 93       	st	X, r25
    b370:	8e 93       	st	-X, r24
    b372:	11 97       	sbiw	r26, 0x01	; 1
    b374:	88 e0       	ldi	r24, 0x08	; 8
    b376:	98 e0       	ldi	r25, 0x08	; 8
    b378:	93 83       	std	Z+3, r25	; 0x03
    b37a:	82 83       	std	Z+2, r24	; 0x02
    b37c:	8a ec       	ldi	r24, 0xCA	; 202
    b37e:	94 e0       	ldi	r25, 0x04	; 4
    b380:	20 c1       	rjmp	.+576    	; 0xb5c2 <PrintIdle+0xb84>
		       break;
		  case 24:
		       if ((strlen(strCorporateID)>0)&&(SpaceOnly(strCorporateID)==False)){
    b382:	c5 e1       	ldi	r28, 0x15	; 21
    b384:	de e0       	ldi	r29, 0x0E	; 14
    b386:	80 91 15 0e 	lds	r24, 0x0E15
    b38a:	88 23       	and	r24, r24
    b38c:	d1 f1       	breq	.+116    	; 0xb402 <PrintIdle+0x9c4>
    b38e:	ce 01       	movw	r24, r28
    b390:	0e 94 44 21 	call	0x4288	; 0x4288 <SpaceOnly>
    b394:	88 23       	and	r24, r24
    b396:	a9 f5       	brne	.+106    	; 0xb402 <PrintIdle+0x9c4>
		           CarriegeReturn();
    b398:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
				   //RemSpaceLag(strCorporateID);
		           sprintf_P(strPrint,PSTR("     Corp ID      : %s"),strCorporateID);
    b39c:	00 d0       	rcall	.+0      	; 0xb39e <PrintIdle+0x960>
    b39e:	00 d0       	rcall	.+0      	; 0xb3a0 <PrintIdle+0x962>
    b3a0:	00 d0       	rcall	.+0      	; 0xb3a2 <PrintIdle+0x964>
    b3a2:	ed b7       	in	r30, 0x3d	; 61
    b3a4:	fe b7       	in	r31, 0x3e	; 62
    b3a6:	31 96       	adiw	r30, 0x01	; 1
    b3a8:	82 eb       	ldi	r24, 0xB2	; 178
    b3aa:	92 e0       	ldi	r25, 0x02	; 2
    b3ac:	ad b7       	in	r26, 0x3d	; 61
    b3ae:	be b7       	in	r27, 0x3e	; 62
    b3b0:	12 96       	adiw	r26, 0x02	; 2
    b3b2:	9c 93       	st	X, r25
    b3b4:	8e 93       	st	-X, r24
    b3b6:	11 97       	sbiw	r26, 0x01	; 1
    b3b8:	81 ef       	ldi	r24, 0xF1	; 241
    b3ba:	97 e0       	ldi	r25, 0x07	; 7
    b3bc:	1d c0       	rjmp	.+58     	; 0xb3f8 <PrintIdle+0x9ba>
			   }else ClearMem(strPrint);
		       break;
		  case 25:
		       if ((strlen(strCorporateName)>0)&&(SpaceOnly(strCorporateName)==False)){
    b3be:	c3 ed       	ldi	r28, 0xD3	; 211
    b3c0:	d5 e0       	ldi	r29, 0x05	; 5
    b3c2:	80 91 d3 05 	lds	r24, 0x05D3
    b3c6:	88 23       	and	r24, r24
    b3c8:	e1 f0       	breq	.+56     	; 0xb402 <PrintIdle+0x9c4>
    b3ca:	ce 01       	movw	r24, r28
    b3cc:	0e 94 44 21 	call	0x4288	; 0x4288 <SpaceOnly>
    b3d0:	88 23       	and	r24, r24
    b3d2:	b9 f4       	brne	.+46     	; 0xb402 <PrintIdle+0x9c4>
		           CarriegeReturn();
    b3d4:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
				   //RemSpaceLag(strCorporateName);
		           sprintf_P(strPrint,PSTR("     Corp Name    : %s"),strCorporateName);
    b3d8:	00 d0       	rcall	.+0      	; 0xb3da <PrintIdle+0x99c>
    b3da:	00 d0       	rcall	.+0      	; 0xb3dc <PrintIdle+0x99e>
    b3dc:	00 d0       	rcall	.+0      	; 0xb3de <PrintIdle+0x9a0>
    b3de:	ed b7       	in	r30, 0x3d	; 61
    b3e0:	fe b7       	in	r31, 0x3e	; 62
    b3e2:	31 96       	adiw	r30, 0x01	; 1
    b3e4:	82 eb       	ldi	r24, 0xB2	; 178
    b3e6:	92 e0       	ldi	r25, 0x02	; 2
    b3e8:	ad b7       	in	r26, 0x3d	; 61
    b3ea:	be b7       	in	r27, 0x3e	; 62
    b3ec:	12 96       	adiw	r26, 0x02	; 2
    b3ee:	9c 93       	st	X, r25
    b3f0:	8e 93       	st	-X, r24
    b3f2:	11 97       	sbiw	r26, 0x01	; 1
    b3f4:	8a ed       	ldi	r24, 0xDA	; 218
    b3f6:	97 e0       	ldi	r25, 0x07	; 7
    b3f8:	93 83       	std	Z+3, r25	; 0x03
    b3fa:	82 83       	std	Z+2, r24	; 0x02
    b3fc:	d5 83       	std	Z+5, r29	; 0x05
    b3fe:	c4 83       	std	Z+4, r28	; 0x04
    b400:	e2 c0       	rjmp	.+452    	; 0xb5c6 <PrintIdle+0xb88>
			   }else ClearMem(strPrint);
    b402:	82 eb       	ldi	r24, 0xB2	; 178
    b404:	92 e0       	ldi	r25, 0x02	; 2
    b406:	2c ce       	rjmp	.-936    	; 0xb060 <PrintIdle+0x622>
		       break;
		  case 26:
		       CarriegeReturn();
    b408:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Gain Points  : %s"),strGainPoints);
    b40c:	00 d0       	rcall	.+0      	; 0xb40e <PrintIdle+0x9d0>
    b40e:	00 d0       	rcall	.+0      	; 0xb410 <PrintIdle+0x9d2>
    b410:	00 d0       	rcall	.+0      	; 0xb412 <PrintIdle+0x9d4>
    b412:	ed b7       	in	r30, 0x3d	; 61
    b414:	fe b7       	in	r31, 0x3e	; 62
    b416:	31 96       	adiw	r30, 0x01	; 1
    b418:	82 eb       	ldi	r24, 0xB2	; 178
    b41a:	92 e0       	ldi	r25, 0x02	; 2
    b41c:	ad b7       	in	r26, 0x3d	; 61
    b41e:	be b7       	in	r27, 0x3e	; 62
    b420:	12 96       	adiw	r26, 0x02	; 2
    b422:	9c 93       	st	X, r25
    b424:	8e 93       	st	-X, r24
    b426:	11 97       	sbiw	r26, 0x01	; 1
    b428:	83 ec       	ldi	r24, 0xC3	; 195
    b42a:	97 e0       	ldi	r25, 0x07	; 7
    b42c:	93 83       	std	Z+3, r25	; 0x03
    b42e:	82 83       	std	Z+2, r24	; 0x02
    b430:	81 ec       	ldi	r24, 0xC1	; 193
    b432:	94 e0       	ldi	r25, 0x04	; 4
    b434:	c6 c0       	rjmp	.+396    	; 0xb5c2 <PrintIdle+0xb84>
		       break;
		  case 27:
		       CarriegeReturn();
    b436:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Prev Points  : %s"),strPrevPoints);
    b43a:	00 d0       	rcall	.+0      	; 0xb43c <PrintIdle+0x9fe>
    b43c:	00 d0       	rcall	.+0      	; 0xb43e <PrintIdle+0xa00>
    b43e:	00 d0       	rcall	.+0      	; 0xb440 <PrintIdle+0xa02>
    b440:	ed b7       	in	r30, 0x3d	; 61
    b442:	fe b7       	in	r31, 0x3e	; 62
    b444:	31 96       	adiw	r30, 0x01	; 1
    b446:	82 eb       	ldi	r24, 0xB2	; 178
    b448:	92 e0       	ldi	r25, 0x02	; 2
    b44a:	ad b7       	in	r26, 0x3d	; 61
    b44c:	be b7       	in	r27, 0x3e	; 62
    b44e:	12 96       	adiw	r26, 0x02	; 2
    b450:	9c 93       	st	X, r25
    b452:	8e 93       	st	-X, r24
    b454:	11 97       	sbiw	r26, 0x01	; 1
    b456:	8c ea       	ldi	r24, 0xAC	; 172
    b458:	97 e0       	ldi	r25, 0x07	; 7
    b45a:	93 83       	std	Z+3, r25	; 0x03
    b45c:	82 83       	std	Z+2, r24	; 0x02
    b45e:	8c e1       	ldi	r24, 0x1C	; 28
    b460:	9b e0       	ldi	r25, 0x0B	; 11
    b462:	af c0       	rjmp	.+350    	; 0xb5c2 <PrintIdle+0xb84>
		       break;
		  case 28:
		       CarriegeReturn();
    b464:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Curr Points  : %s"),strLoyCurrentPoints);
    b468:	00 d0       	rcall	.+0      	; 0xb46a <PrintIdle+0xa2c>
    b46a:	00 d0       	rcall	.+0      	; 0xb46c <PrintIdle+0xa2e>
    b46c:	00 d0       	rcall	.+0      	; 0xb46e <PrintIdle+0xa30>
    b46e:	ed b7       	in	r30, 0x3d	; 61
    b470:	fe b7       	in	r31, 0x3e	; 62
    b472:	31 96       	adiw	r30, 0x01	; 1
    b474:	82 eb       	ldi	r24, 0xB2	; 178
    b476:	92 e0       	ldi	r25, 0x02	; 2
    b478:	ad b7       	in	r26, 0x3d	; 61
    b47a:	be b7       	in	r27, 0x3e	; 62
    b47c:	12 96       	adiw	r26, 0x02	; 2
    b47e:	9c 93       	st	X, r25
    b480:	8e 93       	st	-X, r24
    b482:	11 97       	sbiw	r26, 0x01	; 1
    b484:	85 e9       	ldi	r24, 0x95	; 149
    b486:	97 e0       	ldi	r25, 0x07	; 7
    b488:	93 83       	std	Z+3, r25	; 0x03
    b48a:	82 83       	std	Z+2, r24	; 0x02
    b48c:	86 e6       	ldi	r24, 0x66	; 102
    b48e:	9a e0       	ldi	r25, 0x0A	; 10
    b490:	98 c0       	rjmp	.+304    	; 0xb5c2 <PrintIdle+0xb84>
		       break;
		  case 29:
		       CarriegeReturn();
    b492:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Expiry       : %s"),strLoyExpiry);
    b496:	00 d0       	rcall	.+0      	; 0xb498 <PrintIdle+0xa5a>
    b498:	00 d0       	rcall	.+0      	; 0xb49a <PrintIdle+0xa5c>
    b49a:	00 d0       	rcall	.+0      	; 0xb49c <PrintIdle+0xa5e>
    b49c:	ed b7       	in	r30, 0x3d	; 61
    b49e:	fe b7       	in	r31, 0x3e	; 62
    b4a0:	31 96       	adiw	r30, 0x01	; 1
    b4a2:	82 eb       	ldi	r24, 0xB2	; 178
    b4a4:	92 e0       	ldi	r25, 0x02	; 2
    b4a6:	ad b7       	in	r26, 0x3d	; 61
    b4a8:	be b7       	in	r27, 0x3e	; 62
    b4aa:	12 96       	adiw	r26, 0x02	; 2
    b4ac:	9c 93       	st	X, r25
    b4ae:	8e 93       	st	-X, r24
    b4b0:	11 97       	sbiw	r26, 0x01	; 1
    b4b2:	8e e7       	ldi	r24, 0x7E	; 126
    b4b4:	97 e0       	ldi	r25, 0x07	; 7
    b4b6:	93 83       	std	Z+3, r25	; 0x03
    b4b8:	82 83       	std	Z+2, r24	; 0x02
    b4ba:	83 e8       	ldi	r24, 0x83	; 131
    b4bc:	9e e0       	ldi	r25, 0x0E	; 14
    b4be:	81 c0       	rjmp	.+258    	; 0xb5c2 <PrintIdle+0xb84>
		       break;
		  case 30:
		       CarriegeReturn();
    b4c0:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			   //RemSpaceLag(strLoyRedeemPoints);
		       sprintf_P(strPrint,PSTR("     Total Redeem : %s"),strLoyRedeemPoints);
    b4c4:	00 d0       	rcall	.+0      	; 0xb4c6 <PrintIdle+0xa88>
    b4c6:	00 d0       	rcall	.+0      	; 0xb4c8 <PrintIdle+0xa8a>
    b4c8:	00 d0       	rcall	.+0      	; 0xb4ca <PrintIdle+0xa8c>
    b4ca:	ed b7       	in	r30, 0x3d	; 61
    b4cc:	fe b7       	in	r31, 0x3e	; 62
    b4ce:	31 96       	adiw	r30, 0x01	; 1
    b4d0:	82 eb       	ldi	r24, 0xB2	; 178
    b4d2:	92 e0       	ldi	r25, 0x02	; 2
    b4d4:	ad b7       	in	r26, 0x3d	; 61
    b4d6:	be b7       	in	r27, 0x3e	; 62
    b4d8:	12 96       	adiw	r26, 0x02	; 2
    b4da:	9c 93       	st	X, r25
    b4dc:	8e 93       	st	-X, r24
    b4de:	11 97       	sbiw	r26, 0x01	; 1
    b4e0:	87 e6       	ldi	r24, 0x67	; 103
    b4e2:	97 e0       	ldi	r25, 0x07	; 7
    b4e4:	93 83       	std	Z+3, r25	; 0x03
    b4e6:	82 83       	std	Z+2, r24	; 0x02
    b4e8:	80 ea       	ldi	r24, 0xA0	; 160
    b4ea:	95 e0       	ldi	r25, 0x05	; 5
    b4ec:	6a c0       	rjmp	.+212    	; 0xb5c2 <PrintIdle+0xb84>
		       break;
		  case 31:
		       CarriegeReturn();
    b4ee:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeV);
			   //FormatCurrency(strLoyCurrMonConsumeV);
		       sprintf_P(strPrint,PSTR("     Month Cons V : %s L"),strLoyCurrMonConsumeV);
    b4f2:	00 d0       	rcall	.+0      	; 0xb4f4 <PrintIdle+0xab6>
    b4f4:	00 d0       	rcall	.+0      	; 0xb4f6 <PrintIdle+0xab8>
    b4f6:	00 d0       	rcall	.+0      	; 0xb4f8 <PrintIdle+0xaba>
    b4f8:	ed b7       	in	r30, 0x3d	; 61
    b4fa:	fe b7       	in	r31, 0x3e	; 62
    b4fc:	31 96       	adiw	r30, 0x01	; 1
    b4fe:	82 eb       	ldi	r24, 0xB2	; 178
    b500:	92 e0       	ldi	r25, 0x02	; 2
    b502:	ad b7       	in	r26, 0x3d	; 61
    b504:	be b7       	in	r27, 0x3e	; 62
    b506:	12 96       	adiw	r26, 0x02	; 2
    b508:	9c 93       	st	X, r25
    b50a:	8e 93       	st	-X, r24
    b50c:	11 97       	sbiw	r26, 0x01	; 1
    b50e:	8e e4       	ldi	r24, 0x4E	; 78
    b510:	97 e0       	ldi	r25, 0x07	; 7
    b512:	93 83       	std	Z+3, r25	; 0x03
    b514:	82 83       	std	Z+2, r24	; 0x02
    b516:	88 ef       	ldi	r24, 0xF8	; 248
    b518:	9d e0       	ldi	r25, 0x0D	; 13
    b51a:	53 c0       	rjmp	.+166    	; 0xb5c2 <PrintIdle+0xb84>
		       break;
		  case 32:
		       CarriegeReturn();
    b51c:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeA);
			   //FormatCurrency(strLoyCurrMonConsumeA);
		       sprintf_P(strPrint,PSTR("     Month Cons A : Rp.%s"),strLoyCurrMonConsumeA);
    b520:	00 d0       	rcall	.+0      	; 0xb522 <PrintIdle+0xae4>
    b522:	00 d0       	rcall	.+0      	; 0xb524 <PrintIdle+0xae6>
    b524:	00 d0       	rcall	.+0      	; 0xb526 <PrintIdle+0xae8>
    b526:	ed b7       	in	r30, 0x3d	; 61
    b528:	fe b7       	in	r31, 0x3e	; 62
    b52a:	31 96       	adiw	r30, 0x01	; 1
    b52c:	82 eb       	ldi	r24, 0xB2	; 178
    b52e:	92 e0       	ldi	r25, 0x02	; 2
    b530:	ad b7       	in	r26, 0x3d	; 61
    b532:	be b7       	in	r27, 0x3e	; 62
    b534:	12 96       	adiw	r26, 0x02	; 2
    b536:	9c 93       	st	X, r25
    b538:	8e 93       	st	-X, r24
    b53a:	11 97       	sbiw	r26, 0x01	; 1
    b53c:	84 e3       	ldi	r24, 0x34	; 52
    b53e:	97 e0       	ldi	r25, 0x07	; 7
    b540:	93 83       	std	Z+3, r25	; 0x03
    b542:	82 83       	std	Z+2, r24	; 0x02
    b544:	84 e8       	ldi	r24, 0x84	; 132
    b546:	95 e0       	ldi	r25, 0x05	; 5
    b548:	3c c0       	rjmp	.+120    	; 0xb5c2 <PrintIdle+0xb84>
		       break;
		  case 33://EndOfLoyalty
		       CarriegeReturn();
    b54a:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b54e:	00 d0       	rcall	.+0      	; 0xb550 <PrintIdle+0xb12>
    b550:	00 d0       	rcall	.+0      	; 0xb552 <PrintIdle+0xb14>
    b552:	82 eb       	ldi	r24, 0xB2	; 178
    b554:	92 e0       	ldi	r25, 0x02	; 2
    b556:	ad b7       	in	r26, 0x3d	; 61
    b558:	be b7       	in	r27, 0x3e	; 62
    b55a:	12 96       	adiw	r26, 0x02	; 2
    b55c:	9c 93       	st	X, r25
    b55e:	8e 93       	st	-X, r24
    b560:	11 97       	sbiw	r26, 0x01	; 1
    b562:	81 e1       	ldi	r24, 0x11	; 17
    b564:	97 e0       	ldi	r25, 0x07	; 7
    b566:	48 c0       	rjmp	.+144    	; 0xb5f8 <PrintIdle+0xbba>
		       break;
		  case 34:
		       CarriegeReturn();
    b568:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Dsc: %s"),strSurchargeDesc);
    b56c:	00 d0       	rcall	.+0      	; 0xb56e <PrintIdle+0xb30>
    b56e:	00 d0       	rcall	.+0      	; 0xb570 <PrintIdle+0xb32>
    b570:	00 d0       	rcall	.+0      	; 0xb572 <PrintIdle+0xb34>
    b572:	ed b7       	in	r30, 0x3d	; 61
    b574:	fe b7       	in	r31, 0x3e	; 62
    b576:	31 96       	adiw	r30, 0x01	; 1
    b578:	82 eb       	ldi	r24, 0xB2	; 178
    b57a:	92 e0       	ldi	r25, 0x02	; 2
    b57c:	ad b7       	in	r26, 0x3d	; 61
    b57e:	be b7       	in	r27, 0x3e	; 62
    b580:	12 96       	adiw	r26, 0x02	; 2
    b582:	9c 93       	st	X, r25
    b584:	8e 93       	st	-X, r24
    b586:	11 97       	sbiw	r26, 0x01	; 1
    b588:	8a ef       	ldi	r24, 0xFA	; 250
    b58a:	96 e0       	ldi	r25, 0x06	; 6
    b58c:	93 83       	std	Z+3, r25	; 0x03
    b58e:	82 83       	std	Z+2, r24	; 0x02
    b590:	8b ef       	ldi	r24, 0xFB	; 251
    b592:	99 e0       	ldi	r25, 0x09	; 9
    b594:	16 c0       	rjmp	.+44     	; 0xb5c2 <PrintIdle+0xb84>
		       break;
		  case 35:
		       CarriegeReturn();
    b596:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Amt: %s"),strSurchargeAmount);
    b59a:	00 d0       	rcall	.+0      	; 0xb59c <PrintIdle+0xb5e>
    b59c:	00 d0       	rcall	.+0      	; 0xb59e <PrintIdle+0xb60>
    b59e:	00 d0       	rcall	.+0      	; 0xb5a0 <PrintIdle+0xb62>
    b5a0:	ed b7       	in	r30, 0x3d	; 61
    b5a2:	fe b7       	in	r31, 0x3e	; 62
    b5a4:	31 96       	adiw	r30, 0x01	; 1
    b5a6:	82 eb       	ldi	r24, 0xB2	; 178
    b5a8:	92 e0       	ldi	r25, 0x02	; 2
    b5aa:	ad b7       	in	r26, 0x3d	; 61
    b5ac:	be b7       	in	r27, 0x3e	; 62
    b5ae:	12 96       	adiw	r26, 0x02	; 2
    b5b0:	9c 93       	st	X, r25
    b5b2:	8e 93       	st	-X, r24
    b5b4:	11 97       	sbiw	r26, 0x01	; 1
    b5b6:	83 ee       	ldi	r24, 0xE3	; 227
    b5b8:	96 e0       	ldi	r25, 0x06	; 6
    b5ba:	93 83       	std	Z+3, r25	; 0x03
    b5bc:	82 83       	std	Z+2, r24	; 0x02
    b5be:	87 e8       	ldi	r24, 0x87	; 135
    b5c0:	9a e0       	ldi	r25, 0x0A	; 10
    b5c2:	95 83       	std	Z+5, r25	; 0x05
    b5c4:	84 83       	std	Z+4, r24	; 0x04
    b5c6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    b5ca:	ed b7       	in	r30, 0x3d	; 61
    b5cc:	fe b7       	in	r31, 0x3e	; 62
    b5ce:	36 96       	adiw	r30, 0x06	; 6
    b5d0:	0f b6       	in	r0, 0x3f	; 63
    b5d2:	f8 94       	cli
    b5d4:	fe bf       	out	0x3e, r31	; 62
    b5d6:	0f be       	out	0x3f, r0	; 63
    b5d8:	ed bf       	out	0x3d, r30	; 61
    b5da:	18 c0       	rjmp	.+48     	; 0xb60c <PrintIdle+0xbce>
		       break;
		  case 36:
		       CarriegeReturn();
    b5dc:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b5e0:	00 d0       	rcall	.+0      	; 0xb5e2 <PrintIdle+0xba4>
    b5e2:	00 d0       	rcall	.+0      	; 0xb5e4 <PrintIdle+0xba6>
    b5e4:	82 eb       	ldi	r24, 0xB2	; 178
    b5e6:	92 e0       	ldi	r25, 0x02	; 2
    b5e8:	ad b7       	in	r26, 0x3d	; 61
    b5ea:	be b7       	in	r27, 0x3e	; 62
    b5ec:	12 96       	adiw	r26, 0x02	; 2
    b5ee:	9c 93       	st	X, r25
    b5f0:	8e 93       	st	-X, r24
    b5f2:	11 97       	sbiw	r26, 0x01	; 1
    b5f4:	80 ec       	ldi	r24, 0xC0	; 192
    b5f6:	96 e0       	ldi	r25, 0x06	; 6
    b5f8:	14 96       	adiw	r26, 0x04	; 4
    b5fa:	9c 93       	st	X, r25
    b5fc:	8e 93       	st	-X, r24
    b5fe:	13 97       	sbiw	r26, 0x03	; 3
    b600:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    b604:	0f 90       	pop	r0
    b606:	0f 90       	pop	r0
    b608:	0f 90       	pop	r0
    b60a:	0f 90       	pop	r0
		       break;
		  }
		  iLoop=0;iSend=0;LSend=strlen(strPrint);
    b60c:	10 92 aa 02 	sts	0x02AA, r1
    b610:	10 92 a9 02 	sts	0x02A9, r1
    b614:	10 92 ae 02 	sts	0x02AE, r1
    b618:	10 92 ad 02 	sts	0x02AD, r1
    b61c:	e2 eb       	ldi	r30, 0xB2	; 178
    b61e:	f2 e0       	ldi	r31, 0x02	; 2
    b620:	01 90       	ld	r0, Z+
    b622:	00 20       	and	r0, r0
    b624:	e9 f7       	brne	.-6      	; 0xb620 <PrintIdle+0xbe2>
    b626:	31 97       	sbiw	r30, 0x01	; 1
    b628:	e2 5b       	subi	r30, 0xB2	; 178
    b62a:	f2 40       	sbci	r31, 0x02	; 2
    b62c:	f0 93 ac 02 	sts	0x02AC, r31
    b630:	e0 93 ab 02 	sts	0x02AB, r30
          stPrintIdle=piPrintMessage;
    b634:	8a e0       	ldi	r24, 0x0A	; 10
    b636:	f3 c0       	rjmp	.+486    	; 0xb81e <PrintIdle+0xde0>
	      break;
     case piPrintMessage:
	      if (iSend<LSend){
    b638:	20 91 ad 02 	lds	r18, 0x02AD
    b63c:	30 91 ae 02 	lds	r19, 0x02AE
    b640:	80 91 ab 02 	lds	r24, 0x02AB
    b644:	90 91 ac 02 	lds	r25, 0x02AC
    b648:	28 17       	cp	r18, r24
    b64a:	39 07       	cpc	r19, r25
    b64c:	78 f4       	brcc	.+30     	; 0xb66c <PrintIdle+0xc2e>
		      iLoop++;
    b64e:	80 91 a9 02 	lds	r24, 0x02A9
    b652:	90 91 aa 02 	lds	r25, 0x02AA
    b656:	01 96       	adiw	r24, 0x01	; 1
    b658:	90 93 aa 02 	sts	0x02AA, r25
    b65c:	80 93 a9 02 	sts	0x02A9, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    b660:	10 92 e2 01 	sts	0x01E2, r1
    b664:	10 92 e1 01 	sts	0x01E1, r1
				 stPrintIdle=piCheckPrintStatusMessage;
    b668:	8c e0       	ldi	r24, 0x0C	; 12
    b66a:	d9 c0       	rjmp	.+434    	; 0xb81e <PrintIdle+0xde0>
				 }
			  }
          else{iMessage++;
    b66c:	80 91 b1 02 	lds	r24, 0x02B1
    b670:	8f 5f       	subi	r24, 0xFF	; 255
    b672:	80 93 b1 02 	sts	0x02B1, r24
		      if (iMessage>MessageLine){
    b676:	90 91 b0 02 	lds	r25, 0x02B0
    b67a:	98 17       	cp	r25, r24
    b67c:	18 f4       	brcc	.+6      	; 0xb684 <PrintIdle+0xc46>
			      iFooter=0;
    b67e:	10 92 e1 02 	sts	0x02E1, r1
    b682:	5c c0       	rjmp	.+184    	; 0xb73c <PrintIdle+0xcfe>
				  stPrintIdle=piLoadFooter;
				  CarriegeReturn();
			  }
			  else stPrintIdle=piLoadMessage;
    b684:	89 e0       	ldi	r24, 0x09	; 9
    b686:	cb c0       	rjmp	.+406    	; 0xb81e <PrintIdle+0xde0>
			  }
	      break;
     case piCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    b688:	80 91 dd 01 	lds	r24, 0x01DD
    b68c:	88 23       	and	r24, r24
    b68e:	09 f0       	breq	.+2      	; 0xb692 <PrintIdle+0xc54>
    b690:	bc c0       	rjmp	.+376    	; 0xb80a <PrintIdle+0xdcc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    b692:	e0 91 ad 02 	lds	r30, 0x02AD
    b696:	f0 91 ae 02 	lds	r31, 0x02AE
    b69a:	ee 54       	subi	r30, 0x4E	; 78
    b69c:	fd 4f       	sbci	r31, 0xFD	; 253
    b69e:	61 e0       	ldi	r22, 0x01	; 1
    b6a0:	40 81       	ld	r20, Z
    b6a2:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
		      iSend++;
    b6a6:	80 91 ad 02 	lds	r24, 0x02AD
    b6aa:	90 91 ae 02 	lds	r25, 0x02AE
    b6ae:	01 96       	adiw	r24, 0x01	; 1
    b6b0:	90 93 ae 02 	sts	0x02AE, r25
    b6b4:	80 93 ad 02 	sts	0x02AD, r24
		      stPrintIdle=piPrintMessage;
    b6b8:	8a e0       	ldi	r24, 0x0A	; 10
    b6ba:	a5 c0       	rjmp	.+330    	; 0xb806 <PrintIdle+0xdc8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    b6bc:	60 91 e1 02 	lds	r22, 0x02E1
    b6c0:	89 e2       	ldi	r24, 0x29	; 41
    b6c2:	68 9f       	mul	r22, r24
    b6c4:	b0 01       	movw	r22, r0
    b6c6:	11 24       	eor	r1, r1
    b6c8:	63 5b       	subi	r22, 0xB3	; 179
    b6ca:	7c 4f       	sbci	r23, 0xFC	; 252
    b6cc:	82 eb       	ldi	r24, 0xB2	; 178
    b6ce:	92 e0       	ldi	r25, 0x02	; 2
    b6d0:	48 e2       	ldi	r20, 0x28	; 40
    b6d2:	50 e0       	ldi	r21, 0x00	; 0
    b6d4:	2c ea       	ldi	r18, 0xAC	; 172
    b6d6:	32 e1       	ldi	r19, 0x12	; 18
    b6d8:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
	      break;
		       
     case piLoadFooter:
	      FillChar(strPrint,0,sizeof(strPrint));
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    b6dc:	80 91 e1 02 	lds	r24, 0x02E1
    b6e0:	8f 5f       	subi	r24, 0xFF	; 255
    b6e2:	80 93 e1 02 	sts	0x02E1, r24
		  if (iFooter<=4){
    b6e6:	85 30       	cpi	r24, 0x05	; 5
    b6e8:	90 f4       	brcc	.+36     	; 0xb70e <PrintIdle+0xcd0>
		      if (SpaceOnly(strPrint)==True){
    b6ea:	82 eb       	ldi	r24, 0xB2	; 178
    b6ec:	92 e0       	ldi	r25, 0x02	; 2
    b6ee:	0e 94 44 21 	call	0x4288	; 0x4288 <SpaceOnly>
    b6f2:	81 30       	cpi	r24, 0x01	; 1
    b6f4:	11 f4       	brne	.+4      	; 0xb6fa <PrintIdle+0xcbc>
			      stPrintIdle=piLoadFooter;
    b6f6:	8e e0       	ldi	r24, 0x0E	; 14
    b6f8:	92 c0       	rjmp	.+292    	; 0xb81e <PrintIdle+0xde0>
				  }
			  else{
			      iSend=0;
    b6fa:	10 92 ae 02 	sts	0x02AE, r1
    b6fe:	10 92 ad 02 	sts	0x02AD, r1
				  iLoop=0;
    b702:	10 92 aa 02 	sts	0x02AA, r1
    b706:	10 92 a9 02 	sts	0x02A9, r1
				  stPrintIdle=piPrintFooter;
    b70a:	8f e0       	ldi	r24, 0x0F	; 15
    b70c:	88 c0       	rjmp	.+272    	; 0xb81e <PrintIdle+0xde0>
				  //RemSpaceLag(strPrint);
				  //CarriegeReturn();
			      }
		  }else{stPrintIdle=piInitScroll;
    b70e:	81 e1       	ldi	r24, 0x11	; 17
    b710:	86 c0       	rjmp	.+268    	; 0xb81e <PrintIdle+0xde0>
		        //iPrinted++;
			}
	      break;
     case piPrintFooter:
		  if (iSend<40){
    b712:	80 91 ad 02 	lds	r24, 0x02AD
    b716:	90 91 ae 02 	lds	r25, 0x02AE
    b71a:	88 97       	sbiw	r24, 0x28	; 40
    b71c:	78 f4       	brcc	.+30     	; 0xb73c <PrintIdle+0xcfe>
		      iLoop++;
    b71e:	80 91 a9 02 	lds	r24, 0x02A9
    b722:	90 91 aa 02 	lds	r25, 0x02AA
    b726:	01 96       	adiw	r24, 0x01	; 1
    b728:	90 93 aa 02 	sts	0x02AA, r25
    b72c:	80 93 a9 02 	sts	0x02A9, r24
			  if((iLoop%PRINT_DELAY)==0){
				TimPrintBusy=0;
    b730:	10 92 e2 01 	sts	0x01E2, r1
    b734:	10 92 e1 01 	sts	0x01E1, r1
				stPrintIdle=piCheckPrintStatusFooter;
    b738:	8d e0       	ldi	r24, 0x0D	; 13
    b73a:	71 c0       	rjmp	.+226    	; 0xb81e <PrintIdle+0xde0>
				}
			  }
          else {
		      stPrintIdle=piLoadFooter;
    b73c:	8e e0       	ldi	r24, 0x0E	; 14
    b73e:	80 93 e3 02 	sts	0x02E3, r24
			  CarriegeReturn();
    b742:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
    b746:	96 c0       	rjmp	.+300    	; 0xb874 <PrintIdle+0xe36>
			  }
	      break;
     case piCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    b748:	80 91 dd 01 	lds	r24, 0x01DD
    b74c:	88 23       	and	r24, r24
    b74e:	09 f0       	breq	.+2      	; 0xb752 <PrintIdle+0xd14>
    b750:	5c c0       	rjmp	.+184    	; 0xb80a <PrintIdle+0xdcc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    b752:	e0 91 ad 02 	lds	r30, 0x02AD
    b756:	f0 91 ae 02 	lds	r31, 0x02AE
    b75a:	ee 54       	subi	r30, 0x4E	; 78
    b75c:	fd 4f       	sbci	r31, 0xFD	; 253
    b75e:	61 e0       	ldi	r22, 0x01	; 1
    b760:	40 81       	ld	r20, Z
    b762:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
		      iSend++;
    b766:	80 91 ad 02 	lds	r24, 0x02AD
    b76a:	90 91 ae 02 	lds	r25, 0x02AE
    b76e:	01 96       	adiw	r24, 0x01	; 1
    b770:	90 93 ae 02 	sts	0x02AE, r25
    b774:	80 93 ad 02 	sts	0x02AD, r24
		      stPrintIdle=piPrintFooter;
    b778:	8f e0       	ldi	r24, 0x0F	; 15
    b77a:	45 c0       	rjmp	.+138    	; 0xb806 <PrintIdle+0xdc8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitScroll:
	      iPrinted++;
    b77c:	90 91 a8 02 	lds	r25, 0x02A8
    b780:	9f 5f       	subi	r25, 0xFF	; 255
    b782:	90 93 a8 02 	sts	0x02A8, r25
		  iScroll=0;
    b786:	10 92 e0 02 	sts	0x02E0, r1
		  iLoop=0;
    b78a:	10 92 aa 02 	sts	0x02AA, r1
    b78e:	10 92 a9 02 	sts	0x02A9, r1
		  if (iPrinted<PrintCopy){
    b792:	80 91 a7 02 	lds	r24, 0x02A7
    b796:	98 17       	cp	r25, r24
    b798:	28 f4       	brcc	.+10     	; 0xb7a4 <PrintIdle+0xd66>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b79a:	e1 99       	sbic	0x1c, 1	; 28
    b79c:	fe cf       	rjmp	.-4      	; 0xb79a <PrintIdle+0xd5c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b79e:	82 e3       	ldi	r24, 0x32	; 50
    b7a0:	90 e0       	ldi	r25, 0x00	; 0
    b7a2:	04 c0       	rjmp	.+8      	; 0xb7ac <PrintIdle+0xd6e>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b7a4:	e1 99       	sbic	0x1c, 1	; 28
    b7a6:	fe cf       	rjmp	.-4      	; 0xb7a4 <PrintIdle+0xd66>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b7a8:	81 e3       	ldi	r24, 0x31	; 49
    b7aa:	90 e0       	ldi	r25, 0x00	; 0
    b7ac:	9f bb       	out	0x1f, r25	; 31
    b7ae:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b7b0:	e0 9a       	sbi	0x1c, 0	; 28
    b7b2:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  }else if (iPrinted>=PrintCopy){		  	  
		      nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    b7b4:	80 93 df 02 	sts	0x02DF, r24
		  if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_TG02){
		      _uart_printf(0,1,PSTR("----Scrolled2-----"));

		      stPrintIdle=piPaperCut;
		  }*/
          stPrintIdle=piScrollPaper;              
    b7b8:	80 e1       	ldi	r24, 0x10	; 16
    b7ba:	31 c0       	rjmp	.+98     	; 0xb81e <PrintIdle+0xde0>
	      break;
     case piScrollPaper:
	      iLoop++;
    b7bc:	80 91 a9 02 	lds	r24, 0x02A9
    b7c0:	90 91 aa 02 	lds	r25, 0x02AA
    b7c4:	01 96       	adiw	r24, 0x01	; 1
    b7c6:	90 93 aa 02 	sts	0x02AA, r25
    b7ca:	80 93 a9 02 	sts	0x02A9, r24
		  if (iLoop%PRINT_DELAY==0){
			  TimPrintBusy=0;
    b7ce:	10 92 e2 01 	sts	0x01E2, r1
    b7d2:	10 92 e1 01 	sts	0x01E1, r1
			  stPrintIdle=piCheckPrintStatusScroll;
    b7d6:	82 e1       	ldi	r24, 0x12	; 18
    b7d8:	80 93 e3 02 	sts	0x02E3, r24
			  }
	      if (iScroll>nScroll)stPrintIdle=piPaperCut;
    b7dc:	90 91 e0 02 	lds	r25, 0x02E0
    b7e0:	80 91 df 02 	lds	r24, 0x02DF
    b7e4:	89 17       	cp	r24, r25
    b7e6:	08 f0       	brcs	.+2      	; 0xb7ea <PrintIdle+0xdac>
    b7e8:	45 c0       	rjmp	.+138    	; 0xb874 <PrintIdle+0xe36>
    b7ea:	83 e1       	ldi	r24, 0x13	; 19
    b7ec:	18 c0       	rjmp	.+48     	; 0xb81e <PrintIdle+0xde0>
	      break;
     case piCheckPrintStatusScroll:
	      if (IsBusyPrint==False){
    b7ee:	80 91 dd 01 	lds	r24, 0x01DD
    b7f2:	88 23       	and	r24, r24
    b7f4:	51 f4       	brne	.+20     	; 0xb80a <PrintIdle+0xdcc>
		      iScroll++;
    b7f6:	80 91 e0 02 	lds	r24, 0x02E0
    b7fa:	8f 5f       	subi	r24, 0xFF	; 255
    b7fc:	80 93 e0 02 	sts	0x02E0, r24
		      CarriegeReturn();
    b800:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		      stPrintIdle=piScrollPaper;
    b804:	80 e1       	ldi	r24, 0x10	; 16
    b806:	80 93 e3 02 	sts	0x02E3, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    b80a:	80 91 e1 01 	lds	r24, 0x01E1
    b80e:	90 91 e2 01 	lds	r25, 0x01E2
    b812:	0b 97       	sbiw	r24, 0x0b	; 11
    b814:	7c f1       	brlt	.+94     	; 0xb874 <PrintIdle+0xe36>
		      IsPrintERROR=True;
    b816:	81 e0       	ldi	r24, 0x01	; 1
    b818:	80 93 dc 01 	sts	0x01DC, r24
		      stPrintIdle=piFinishPrintIdle;
    b81c:	84 e1       	ldi	r24, 0x14	; 20
    b81e:	80 93 e3 02 	sts	0x02E3, r24
    b822:	28 c0       	rjmp	.+80     	; 0xb874 <PrintIdle+0xe36>
	      break;
     case piPaperCut:
	      //sprintf_P(strSend,PSTR("i:%d Copy:%d"),iPrinted,PrintCopy);
		  //_uart_print(0,1,strSend);

          if (iPrinted>=PrintCopy){
    b824:	90 91 a8 02 	lds	r25, 0x02A8
    b828:	80 91 a7 02 	lds	r24, 0x02A7
    b82c:	98 17       	cp	r25, r24
    b82e:	10 f0       	brcs	.+4      	; 0xb834 <PrintIdle+0xdf6>
		      stPrintIdle=piFinishPrintIdle;
    b830:	84 e1       	ldi	r24, 0x14	; 20
    b832:	05 c0       	rjmp	.+10     	; 0xb83e <PrintIdle+0xe00>
			  }
		  else {CarriegeReturn();
    b834:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		        CarriegeReturn();
    b838:	0e 94 9b 4a 	call	0x9536	; 0x9536 <CarriegeReturn>
		        stPrintIdle=piInit;
    b83c:	81 e0       	ldi	r24, 0x01	; 1
    b83e:	80 93 e3 02 	sts	0x02E3, r24
		       }
		  PaperCut();
    b842:	0e 94 42 4b 	call	0x9684	; 0x9684 <PaperCut>
    b846:	16 c0       	rjmp	.+44     	; 0xb874 <PrintIdle+0xe36>
	      break;
     case piFinishPrintIdle:
	      switch(IFType){
    b848:	80 91 25 01 	lds	r24, 0x0125
    b84c:	81 30       	cpi	r24, 0x01	; 1
    b84e:	19 f0       	breq	.+6      	; 0xb856 <PrintIdle+0xe18>
    b850:	82 30       	cpi	r24, 0x02	; 2
    b852:	61 f4       	brne	.+24     	; 0xb86c <PrintIdle+0xe2e>
    b854:	03 c0       	rjmp	.+6      	; 0xb85c <PrintIdle+0xe1e>
		  case IT_SLAVE:
		       sendMessage04();
    b856:	0e 94 25 52 	call	0xa44a	; 0xa44a <sendMessage04>
    b85a:	08 c0       	rjmp	.+16     	; 0xb86c <PrintIdle+0xe2e>
		       break;
		  case IT_STANDALONE:		  
		       UpdateStandaloneStatus((atoi(strFIP_ID)&0x0F),PS_PRINTED);
    b85c:	88 ec       	ldi	r24, 0xC8	; 200
    b85e:	99 e0       	ldi	r25, 0x09	; 9
    b860:	0e 94 6e b4 	call	0x168dc	; 0x168dc <atoi>
    b864:	8f 70       	andi	r24, 0x0F	; 15
    b866:	61 e1       	ldi	r22, 0x11	; 17
    b868:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <UpdateStandaloneStatus>
		       break;
		  }
		  IsBusyIdlePrinting=False;
    b86c:	10 92 df 01 	sts	0x01DF, r1
          stPrintIdle=piIdle;
    b870:	10 92 e3 02 	sts	0x02E3, r1
	      break;	 
	 }
}
    b874:	df 91       	pop	r29
    b876:	cf 91       	pop	r28
    b878:	08 95       	ret

0000b87a <systemPrinting>:
     

}

void systemPrinting(){
	 FreePrinting();
    b87a:	0e 94 89 52 	call	0xa512	; 0xa512 <FreePrinting>
	 PrintIdle();
    b87e:	0e 94 1f 55 	call	0xaa3e	; 0xaa3e <PrintIdle>
}
    b882:	08 95       	ret

0000b884 <procMessage11>:
}




void procMessage11(){
    b884:	af 92       	push	r10
    b886:	bf 92       	push	r11
    b888:	cf 92       	push	r12
    b88a:	df 92       	push	r13
    b88c:	ef 92       	push	r14
    b88e:	ff 92       	push	r15
    b890:	0f 93       	push	r16
    b892:	1f 93       	push	r17
    b894:	df 93       	push	r29
    b896:	cf 93       	push	r28
    b898:	cd b7       	in	r28, 0x3d	; 61
    b89a:	de b7       	in	r29, 0x3e	; 62
    b89c:	c5 55       	subi	r28, 0x55	; 85
    b89e:	d0 40       	sbci	r29, 0x00	; 0
    b8a0:	0f b6       	in	r0, 0x3f	; 63
    b8a2:	f8 94       	cli
    b8a4:	de bf       	out	0x3e, r29	; 62
    b8a6:	0f be       	out	0x3f, r0	; 63
    b8a8:	cd bf       	out	0x3d, r28	; 61
    b8aa:	20 e0       	ldi	r18, 0x00	; 0
    b8ac:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b8ae:	ae 01       	movw	r20, r28
    b8b0:	46 5f       	subi	r20, 0xF6	; 246
    b8b2:	5f 4f       	sbci	r21, 0xFF	; 255
    b8b4:	fa 01       	movw	r30, r20
    b8b6:	e2 0f       	add	r30, r18
    b8b8:	f3 1f       	adc	r31, r19
    b8ba:	d9 01       	movw	r26, r18
    b8bc:	ab 5d       	subi	r26, 0xDB	; 219
    b8be:	b4 4f       	sbci	r27, 0xF4	; 244
    b8c0:	9b 96       	adiw	r26, 0x2b	; 43
    b8c2:	8c 91       	ld	r24, X
    b8c4:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b8c6:	2f 5f       	subi	r18, 0xFF	; 255
    b8c8:	3f 4f       	sbci	r19, 0xFF	; 255
    b8ca:	2a 30       	cpi	r18, 0x0A	; 10
    b8cc:	31 05       	cpc	r19, r1
    b8ce:	91 f7       	brne	.-28     	; 0xb8b4 <procMessage11+0x30>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b8d0:	fa 01       	movw	r30, r20
    b8d2:	12 86       	std	Z+10, r1	; 0x0a
     char buffHeader[41];
	 char strProductName[13],strProductPrice[9],strTime[12],strDate[10];

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
    b8d4:	81 e0       	ldi	r24, 0x01	; 1
    b8d6:	ba 01       	movw	r22, r20
    b8d8:	0e 94 18 22 	call	0x4430	; 0x4430 <FormatDate>
    b8dc:	20 e0       	ldi	r18, 0x00	; 0
    b8de:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b8e0:	ae 01       	movw	r20, r28
    b8e2:	4c 5e       	subi	r20, 0xEC	; 236
    b8e4:	5f 4f       	sbci	r21, 0xFF	; 255
    b8e6:	fa 01       	movw	r30, r20
    b8e8:	e2 0f       	add	r30, r18
    b8ea:	f3 1f       	adc	r31, r19
    b8ec:	d9 01       	movw	r26, r18
    b8ee:	ab 5d       	subi	r26, 0xDB	; 219
    b8f0:	b4 4f       	sbci	r27, 0xF4	; 244
    b8f2:	d6 96       	adiw	r26, 0x36	; 54
    b8f4:	8c 91       	ld	r24, X
    b8f6:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b8f8:	2f 5f       	subi	r18, 0xFF	; 255
    b8fa:	3f 4f       	sbci	r19, 0xFF	; 255
    b8fc:	28 30       	cpi	r18, 0x08	; 8
    b8fe:	31 05       	cpc	r19, r1
    b900:	91 f7       	brne	.-28     	; 0xb8e6 <procMessage11+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b902:	1c 8e       	std	Y+28, r1	; 0x1c

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
	 StrPosCopy(rcv_trans,strTime,54,8);
	 _datetime(_DATETIME_WRITE,strDate,strTime);
    b904:	81 e0       	ldi	r24, 0x01	; 1
    b906:	be 01       	movw	r22, r28
    b908:	66 5f       	subi	r22, 0xF6	; 246
    b90a:	7f 4f       	sbci	r23, 0xFF	; 255
    b90c:	0e 94 fa b1 	call	0x163f4	; 0x163f4 <_datetime>
	  
     clearString(buffHeader);
    b910:	8e 01       	movw	r16, r28
    b912:	03 5d       	subi	r16, 0xD3	; 211
    b914:	1f 4f       	sbci	r17, 0xFF	; 255
    b916:	c8 01       	movw	r24, r16
    b918:	0e 94 97 24 	call	0x492e	; 0x492e <clearString>
    b91c:	20 e0       	ldi	r18, 0x00	; 0
    b91e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b920:	f8 01       	movw	r30, r16
    b922:	e2 0f       	add	r30, r18
    b924:	f3 1f       	adc	r31, r19
    b926:	d9 01       	movw	r26, r18
    b928:	ab 5d       	subi	r26, 0xDB	; 219
    b92a:	b4 4f       	sbci	r27, 0xF4	; 244
    b92c:	de 96       	adiw	r26, 0x3e	; 62
    b92e:	8c 91       	ld	r24, X
    b930:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b932:	2f 5f       	subi	r18, 0xFF	; 255
    b934:	3f 4f       	sbci	r19, 0xFF	; 255
    b936:	28 32       	cpi	r18, 0x28	; 40
    b938:	31 05       	cpc	r19, r1
    b93a:	91 f7       	brne	.-28     	; 0xb920 <procMessage11+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b93c:	fe 01       	movw	r30, r28
    b93e:	eb 5a       	subi	r30, 0xAB	; 171
    b940:	ff 4f       	sbci	r31, 0xFF	; 255
    b942:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    b944:	87 e5       	ldi	r24, 0x57	; 87
    b946:	92 e0       	ldi	r25, 0x02	; 2
    b948:	b8 01       	movw	r22, r16
    b94a:	48 e2       	ldi	r20, 0x28	; 40
    b94c:	50 e0       	ldi	r21, 0x00	; 0
    b94e:	24 eb       	ldi	r18, 0xB4	; 180
    b950:	32 e1       	ldi	r19, 0x12	; 18
    b952:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    b956:	20 e0       	ldi	r18, 0x00	; 0
    b958:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b95a:	be 01       	movw	r22, r28
    b95c:	63 5d       	subi	r22, 0xD3	; 211
    b95e:	7f 4f       	sbci	r23, 0xFF	; 255
    b960:	fb 01       	movw	r30, r22
    b962:	e2 0f       	add	r30, r18
    b964:	f3 1f       	adc	r31, r19
    b966:	d9 01       	movw	r26, r18
    b968:	a5 57       	subi	r26, 0x75	; 117
    b96a:	b4 4f       	sbci	r27, 0xF4	; 244
    b96c:	8c 91       	ld	r24, X
    b96e:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b970:	2f 5f       	subi	r18, 0xFF	; 255
    b972:	3f 4f       	sbci	r19, 0xFF	; 255
    b974:	28 32       	cpi	r18, 0x28	; 40
    b976:	31 05       	cpc	r19, r1
    b978:	99 f7       	brne	.-26     	; 0xb960 <procMessage11+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b97a:	fe 01       	movw	r30, r28
    b97c:	eb 5a       	subi	r30, 0xAB	; 171
    b97e:	ff 4f       	sbci	r31, 0xFF	; 255
    b980:	10 82       	st	Z, r1
    b982:	80 e8       	ldi	r24, 0x80	; 128
    b984:	92 e0       	ldi	r25, 0x02	; 2
    b986:	48 e2       	ldi	r20, 0x28	; 40
    b988:	50 e0       	ldi	r21, 0x00	; 0
    b98a:	24 eb       	ldi	r18, 0xB4	; 180
    b98c:	32 e1       	ldi	r19, 0x12	; 18
    b98e:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    b992:	20 e0       	ldi	r18, 0x00	; 0
    b994:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b996:	be 01       	movw	r22, r28
    b998:	63 5d       	subi	r22, 0xD3	; 211
    b99a:	7f 4f       	sbci	r23, 0xFF	; 255
    b99c:	fb 01       	movw	r30, r22
    b99e:	e2 0f       	add	r30, r18
    b9a0:	f3 1f       	adc	r31, r19
    b9a2:	d9 01       	movw	r26, r18
    b9a4:	ad 54       	subi	r26, 0x4D	; 77
    b9a6:	b4 4f       	sbci	r27, 0xF4	; 244
    b9a8:	8c 91       	ld	r24, X
    b9aa:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b9ac:	2f 5f       	subi	r18, 0xFF	; 255
    b9ae:	3f 4f       	sbci	r19, 0xFF	; 255
    b9b0:	28 32       	cpi	r18, 0x28	; 40
    b9b2:	31 05       	cpc	r19, r1
    b9b4:	99 f7       	brne	.-26     	; 0xb99c <procMessage11+0x118>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b9b6:	fe 01       	movw	r30, r28
    b9b8:	eb 5a       	subi	r30, 0xAB	; 171
    b9ba:	ff 4f       	sbci	r31, 0xFF	; 255
    b9bc:	10 82       	st	Z, r1
    b9be:	89 ea       	ldi	r24, 0xA9	; 169
    b9c0:	92 e0       	ldi	r25, 0x02	; 2
    b9c2:	48 e2       	ldi	r20, 0x28	; 40
    b9c4:	50 e0       	ldi	r21, 0x00	; 0
    b9c6:	24 eb       	ldi	r18, 0xB4	; 180
    b9c8:	32 e1       	ldi	r19, 0x12	; 18
    b9ca:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    b9ce:	20 e0       	ldi	r18, 0x00	; 0
    b9d0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    b9d2:	be 01       	movw	r22, r28
    b9d4:	63 5d       	subi	r22, 0xD3	; 211
    b9d6:	7f 4f       	sbci	r23, 0xFF	; 255
    b9d8:	fb 01       	movw	r30, r22
    b9da:	e2 0f       	add	r30, r18
    b9dc:	f3 1f       	adc	r31, r19
    b9de:	d9 01       	movw	r26, r18
    b9e0:	a5 52       	subi	r26, 0x25	; 37
    b9e2:	b4 4f       	sbci	r27, 0xF4	; 244
    b9e4:	8c 91       	ld	r24, X
    b9e6:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    b9e8:	2f 5f       	subi	r18, 0xFF	; 255
    b9ea:	3f 4f       	sbci	r19, 0xFF	; 255
    b9ec:	28 32       	cpi	r18, 0x28	; 40
    b9ee:	31 05       	cpc	r19, r1
    b9f0:	99 f7       	brne	.-26     	; 0xb9d8 <procMessage11+0x154>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    b9f2:	fe 01       	movw	r30, r28
    b9f4:	eb 5a       	subi	r30, 0xAB	; 171
    b9f6:	ff 4f       	sbci	r31, 0xFF	; 255
    b9f8:	10 82       	st	Z, r1
    b9fa:	82 ed       	ldi	r24, 0xD2	; 210
    b9fc:	92 e0       	ldi	r25, 0x02	; 2
    b9fe:	48 e2       	ldi	r20, 0x28	; 40
    ba00:	50 e0       	ldi	r21, 0x00	; 0
    ba02:	24 eb       	ldi	r18, 0xB4	; 180
    ba04:	32 e1       	ldi	r19, 0x12	; 18
    ba06:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    ba0a:	20 e0       	ldi	r18, 0x00	; 0
    ba0c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    ba0e:	be 01       	movw	r22, r28
    ba10:	63 5d       	subi	r22, 0xD3	; 211
    ba12:	7f 4f       	sbci	r23, 0xFF	; 255
    ba14:	fb 01       	movw	r30, r22
    ba16:	e2 0f       	add	r30, r18
    ba18:	f3 1f       	adc	r31, r19
    ba1a:	d9 01       	movw	r26, r18
    ba1c:	ad 5f       	subi	r26, 0xFD	; 253
    ba1e:	b3 4f       	sbci	r27, 0xF3	; 243
    ba20:	8c 91       	ld	r24, X
    ba22:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ba24:	2f 5f       	subi	r18, 0xFF	; 255
    ba26:	3f 4f       	sbci	r19, 0xFF	; 255
    ba28:	28 32       	cpi	r18, 0x28	; 40
    ba2a:	31 05       	cpc	r19, r1
    ba2c:	99 f7       	brne	.-26     	; 0xba14 <procMessage11+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ba2e:	fe 01       	movw	r30, r28
    ba30:	eb 5a       	subi	r30, 0xAB	; 171
    ba32:	ff 4f       	sbci	r31, 0xFF	; 255
    ba34:	10 82       	st	Z, r1
    ba36:	8b ef       	ldi	r24, 0xFB	; 251
    ba38:	92 e0       	ldi	r25, 0x02	; 2
    ba3a:	48 e2       	ldi	r20, 0x28	; 40
    ba3c:	50 e0       	ldi	r21, 0x00	; 0
    ba3e:	24 eb       	ldi	r18, 0xB4	; 180
    ba40:	32 e1       	ldi	r19, 0x12	; 18
    ba42:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    ba46:	20 e0       	ldi	r18, 0x00	; 0
    ba48:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    ba4a:	be 01       	movw	r22, r28
    ba4c:	63 5d       	subi	r22, 0xD3	; 211
    ba4e:	7f 4f       	sbci	r23, 0xFF	; 255
    ba50:	fb 01       	movw	r30, r22
    ba52:	e2 0f       	add	r30, r18
    ba54:	f3 1f       	adc	r31, r19
    ba56:	d9 01       	movw	r26, r18
    ba58:	a5 5d       	subi	r26, 0xD5	; 213
    ba5a:	b3 4f       	sbci	r27, 0xF3	; 243
    ba5c:	8c 91       	ld	r24, X
    ba5e:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ba60:	2f 5f       	subi	r18, 0xFF	; 255
    ba62:	3f 4f       	sbci	r19, 0xFF	; 255
    ba64:	28 32       	cpi	r18, 0x28	; 40
    ba66:	31 05       	cpc	r19, r1
    ba68:	99 f7       	brne	.-26     	; 0xba50 <procMessage11+0x1cc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ba6a:	fe 01       	movw	r30, r28
    ba6c:	eb 5a       	subi	r30, 0xAB	; 171
    ba6e:	ff 4f       	sbci	r31, 0xFF	; 255
    ba70:	10 82       	st	Z, r1
    ba72:	84 e2       	ldi	r24, 0x24	; 36
    ba74:	93 e0       	ldi	r25, 0x03	; 3
    ba76:	48 e2       	ldi	r20, 0x28	; 40
    ba78:	50 e0       	ldi	r21, 0x00	; 0
    ba7a:	24 eb       	ldi	r18, 0xB4	; 180
    ba7c:	32 e1       	ldi	r19, 0x12	; 18
    ba7e:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    ba82:	20 e0       	ldi	r18, 0x00	; 0
    ba84:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    ba86:	be 01       	movw	r22, r28
    ba88:	63 5d       	subi	r22, 0xD3	; 211
    ba8a:	7f 4f       	sbci	r23, 0xFF	; 255
    ba8c:	fb 01       	movw	r30, r22
    ba8e:	e2 0f       	add	r30, r18
    ba90:	f3 1f       	adc	r31, r19
    ba92:	d9 01       	movw	r26, r18
    ba94:	ad 5a       	subi	r26, 0xAD	; 173
    ba96:	b3 4f       	sbci	r27, 0xF3	; 243
    ba98:	8c 91       	ld	r24, X
    ba9a:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ba9c:	2f 5f       	subi	r18, 0xFF	; 255
    ba9e:	3f 4f       	sbci	r19, 0xFF	; 255
    baa0:	28 32       	cpi	r18, 0x28	; 40
    baa2:	31 05       	cpc	r19, r1
    baa4:	99 f7       	brne	.-26     	; 0xba8c <procMessage11+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    baa6:	fe 01       	movw	r30, r28
    baa8:	eb 5a       	subi	r30, 0xAB	; 171
    baaa:	ff 4f       	sbci	r31, 0xFF	; 255
    baac:	10 82       	st	Z, r1
    baae:	8d e4       	ldi	r24, 0x4D	; 77
    bab0:	93 e0       	ldi	r25, 0x03	; 3
    bab2:	48 e2       	ldi	r20, 0x28	; 40
    bab4:	50 e0       	ldi	r21, 0x00	; 0
    bab6:	24 eb       	ldi	r18, 0xB4	; 180
    bab8:	32 e1       	ldi	r19, 0x12	; 18
    baba:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    babe:	20 e0       	ldi	r18, 0x00	; 0
    bac0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bac2:	be 01       	movw	r22, r28
    bac4:	63 5d       	subi	r22, 0xD3	; 211
    bac6:	7f 4f       	sbci	r23, 0xFF	; 255
    bac8:	fb 01       	movw	r30, r22
    baca:	e2 0f       	add	r30, r18
    bacc:	f3 1f       	adc	r31, r19
    bace:	d9 01       	movw	r26, r18
    bad0:	a5 58       	subi	r26, 0x85	; 133
    bad2:	b3 4f       	sbci	r27, 0xF3	; 243
    bad4:	8c 91       	ld	r24, X
    bad6:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bad8:	2f 5f       	subi	r18, 0xFF	; 255
    bada:	3f 4f       	sbci	r19, 0xFF	; 255
    badc:	28 32       	cpi	r18, 0x28	; 40
    bade:	31 05       	cpc	r19, r1
    bae0:	99 f7       	brne	.-26     	; 0xbac8 <procMessage11+0x244>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bae2:	fe 01       	movw	r30, r28
    bae4:	eb 5a       	subi	r30, 0xAB	; 171
    bae6:	ff 4f       	sbci	r31, 0xFF	; 255
    bae8:	10 82       	st	Z, r1
    baea:	86 e7       	ldi	r24, 0x76	; 118
    baec:	93 e0       	ldi	r25, 0x03	; 3
    baee:	48 e2       	ldi	r20, 0x28	; 40
    baf0:	50 e0       	ldi	r21, 0x00	; 0
    baf2:	24 eb       	ldi	r18, 0xB4	; 180
    baf4:	32 e1       	ldi	r19, 0x12	; 18
    baf6:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    bafa:	20 e0       	ldi	r18, 0x00	; 0
    bafc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bafe:	be 01       	movw	r22, r28
    bb00:	63 5d       	subi	r22, 0xD3	; 211
    bb02:	7f 4f       	sbci	r23, 0xFF	; 255
    bb04:	fb 01       	movw	r30, r22
    bb06:	e2 0f       	add	r30, r18
    bb08:	f3 1f       	adc	r31, r19
    bb0a:	d9 01       	movw	r26, r18
    bb0c:	ad 55       	subi	r26, 0x5D	; 93
    bb0e:	b3 4f       	sbci	r27, 0xF3	; 243
    bb10:	8c 91       	ld	r24, X
    bb12:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bb14:	2f 5f       	subi	r18, 0xFF	; 255
    bb16:	3f 4f       	sbci	r19, 0xFF	; 255
    bb18:	28 32       	cpi	r18, 0x28	; 40
    bb1a:	31 05       	cpc	r19, r1
    bb1c:	99 f7       	brne	.-26     	; 0xbb04 <procMessage11+0x280>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bb1e:	fe 01       	movw	r30, r28
    bb20:	eb 5a       	subi	r30, 0xAB	; 171
    bb22:	ff 4f       	sbci	r31, 0xFF	; 255
    bb24:	10 82       	st	Z, r1
    bb26:	8f e9       	ldi	r24, 0x9F	; 159
    bb28:	93 e0       	ldi	r25, 0x03	; 3
    bb2a:	48 e2       	ldi	r20, 0x28	; 40
    bb2c:	50 e0       	ldi	r21, 0x00	; 0
    bb2e:	24 eb       	ldi	r18, 0xB4	; 180
    bb30:	32 e1       	ldi	r19, 0x12	; 18
    bb32:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    bb36:	20 e0       	ldi	r18, 0x00	; 0
    bb38:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bb3a:	be 01       	movw	r22, r28
    bb3c:	63 5d       	subi	r22, 0xD3	; 211
    bb3e:	7f 4f       	sbci	r23, 0xFF	; 255
    bb40:	fb 01       	movw	r30, r22
    bb42:	e2 0f       	add	r30, r18
    bb44:	f3 1f       	adc	r31, r19
    bb46:	d9 01       	movw	r26, r18
    bb48:	a5 53       	subi	r26, 0x35	; 53
    bb4a:	b3 4f       	sbci	r27, 0xF3	; 243
    bb4c:	8c 91       	ld	r24, X
    bb4e:	80 83       	st	Z, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bb50:	2f 5f       	subi	r18, 0xFF	; 255
    bb52:	3f 4f       	sbci	r19, 0xFF	; 255
    bb54:	28 32       	cpi	r18, 0x28	; 40
    bb56:	31 05       	cpc	r19, r1
    bb58:	99 f7       	brne	.-26     	; 0xbb40 <procMessage11+0x2bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bb5a:	fe 01       	movw	r30, r28
    bb5c:	eb 5a       	subi	r30, 0xAB	; 171
    bb5e:	ff 4f       	sbci	r31, 0xFF	; 255
    bb60:	10 82       	st	Z, r1
    bb62:	88 ec       	ldi	r24, 0xC8	; 200
    bb64:	93 e0       	ldi	r25, 0x03	; 3
    bb66:	48 e2       	ldi	r20, 0x28	; 40
    bb68:	50 e0       	ldi	r21, 0x00	; 0
    bb6a:	24 eb       	ldi	r18, 0xB4	; 180
    bb6c:	32 e1       	ldi	r19, 0x12	; 18
    bb6e:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    bb72:	0b ee       	ldi	r16, 0xEB	; 235
    bb74:	10 e0       	ldi	r17, 0x00	; 0
    bb76:	2b e0       	ldi	r18, 0x0B	; 11
    bb78:	e2 2e       	mov	r14, r18
    bb7a:	2d e0       	ldi	r18, 0x0D	; 13
    bb7c:	f2 2e       	mov	r15, r18
    bb7e:	90 e2       	ldi	r25, 0x20	; 32
    bb80:	c9 2e       	mov	r12, r25
    bb82:	d1 2c       	mov	r13, r1
    bb84:	cc 0e       	add	r12, r28
    bb86:	dd 1e       	adc	r13, r29
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bb88:	8c e2       	ldi	r24, 0x2C	; 44
    bb8a:	a8 2e       	mov	r10, r24
    bb8c:	b1 2c       	mov	r11, r1
    bb8e:	ac 0e       	add	r10, r28
    bb90:	bd 1e       	adc	r11, r29
    bb92:	f6 01       	movw	r30, r12
    bb94:	d7 01       	movw	r26, r14
	    Dest[i]=Source[IdxSource+i];
    bb96:	8d 91       	ld	r24, X+
    bb98:	81 93       	st	Z+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bb9a:	ea 15       	cp	r30, r10
    bb9c:	fb 05       	cpc	r31, r11
    bb9e:	d9 f7       	brne	.-10     	; 0xbb96 <procMessage11+0x312>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bba0:	1c a6       	std	Y+44, r1	; 0x2c
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
    bba2:	c6 01       	movw	r24, r12
    bba4:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
    bba8:	c8 01       	movw	r24, r16
    bbaa:	b6 01       	movw	r22, r12
    bbac:	4c e0       	ldi	r20, 0x0C	; 12
    bbae:	50 e0       	ldi	r21, 0x00	; 0
    bbb0:	24 eb       	ldi	r18, 0xB4	; 180
    bbb2:	32 e1       	ldi	r19, 0x12	; 18
    bbb4:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    bbb8:	03 5f       	subi	r16, 0xF3	; 243
    bbba:	1f 4f       	sbci	r17, 0xFF	; 255
    bbbc:	8c e0       	ldi	r24, 0x0C	; 12
    bbbe:	90 e0       	ldi	r25, 0x00	; 0
    bbc0:	e8 0e       	add	r14, r24
    bbc2:	f9 1e       	adc	r15, r25
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    bbc4:	91 e0       	ldi	r25, 0x01	; 1
    bbc6:	09 33       	cpi	r16, 0x39	; 57
    bbc8:	19 07       	cpc	r17, r25
    bbca:	19 f7       	brne	.-58     	; 0xbb92 <procMessage11+0x30e>
    bbcc:	05 eb       	ldi	r16, 0xB5	; 181
    bbce:	10 e0       	ldi	r17, 0x00	; 0
    bbd0:	b3 e5       	ldi	r27, 0x53	; 83
    bbd2:	eb 2e       	mov	r14, r27
    bbd4:	bd e0       	ldi	r27, 0x0D	; 13
    bbd6:	fb 2e       	mov	r15, r27
    bbd8:	6e 01       	movw	r12, r28
    bbda:	08 94       	sec
    bbdc:	c1 1c       	adc	r12, r1
    bbde:	d1 1c       	adc	r13, r1
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bbe0:	a9 e0       	ldi	r26, 0x09	; 9
    bbe2:	aa 2e       	mov	r10, r26
    bbe4:	b1 2c       	mov	r11, r1
    bbe6:	ac 0e       	add	r10, r28
    bbe8:	bd 1e       	adc	r11, r29
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    bbea:	f6 01       	movw	r30, r12
    bbec:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bbee:	8d 91       	ld	r24, X+
    bbf0:	81 93       	st	Z+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bbf2:	ea 15       	cp	r30, r10
    bbf4:	fb 05       	cpc	r31, r11
    bbf6:	d9 f7       	brne	.-10     	; 0xbbee <procMessage11+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bbf8:	19 86       	std	Y+9, r1	; 0x09
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
        StrPosCopy(rcv_trans,strProductPrice,(558+(i*8)),8);
		RemSpaceLag(strProductPrice);
    bbfa:	c6 01       	movw	r24, r12
    bbfc:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		RemZeroLead(strProductPrice);
    bc00:	c6 01       	movw	r24, r12
    bc02:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
		RemDecimal(strProductPrice);
    bc06:	c6 01       	movw	r24, r12
    bc08:	0e 94 61 21 	call	0x42c2	; 0x42c2 <RemDecimal>
    bc0c:	c8 01       	movw	r24, r16
    bc0e:	b6 01       	movw	r22, r12
    bc10:	48 e0       	ldi	r20, 0x08	; 8
    bc12:	50 e0       	ldi	r21, 0x00	; 0
    bc14:	24 eb       	ldi	r18, 0xB4	; 180
    bc16:	32 e1       	ldi	r19, 0x12	; 18
    bc18:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    bc1c:	07 5f       	subi	r16, 0xF7	; 247
    bc1e:	1f 4f       	sbci	r17, 0xFF	; 255
    bc20:	e8 e0       	ldi	r30, 0x08	; 8
    bc22:	f0 e0       	ldi	r31, 0x00	; 0
    bc24:	ee 0e       	add	r14, r30
    bc26:	ff 1e       	adc	r15, r31
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
    bc28:	f0 e0       	ldi	r31, 0x00	; 0
    bc2a:	0b 3e       	cpi	r16, 0xEB	; 235
    bc2c:	1f 07       	cpc	r17, r31
    bc2e:	e9 f6       	brne	.-70     	; 0xbbea <procMessage11+0x366>
		RemSpaceLag(strProductPrice);
		RemZeroLead(strProductPrice);
		RemDecimal(strProductPrice);
        eeprom_write_block((const void*) &strProductPrice, (void*) &DefProductPrice[i], 8);
	 }
}
    bc30:	cb 5a       	subi	r28, 0xAB	; 171
    bc32:	df 4f       	sbci	r29, 0xFF	; 255
    bc34:	0f b6       	in	r0, 0x3f	; 63
    bc36:	f8 94       	cli
    bc38:	de bf       	out	0x3e, r29	; 62
    bc3a:	0f be       	out	0x3f, r0	; 63
    bc3c:	cd bf       	out	0x3d, r28	; 61
    bc3e:	cf 91       	pop	r28
    bc40:	df 91       	pop	r29
    bc42:	1f 91       	pop	r17
    bc44:	0f 91       	pop	r16
    bc46:	ff 90       	pop	r15
    bc48:	ef 90       	pop	r14
    bc4a:	df 90       	pop	r13
    bc4c:	cf 90       	pop	r12
    bc4e:	bf 90       	pop	r11
    bc50:	af 90       	pop	r10
    bc52:	08 95       	ret

0000bc54 <FCloseShift>:
	 }
  return Result;
}


char FCloseShift(char ShiftType){//SHIFT_NONE,NEW_SHIFT,CONTINUE_SHIFT
    bc54:	df 92       	push	r13
    bc56:	ef 92       	push	r14
    bc58:	ff 92       	push	r15
    bc5a:	0f 93       	push	r16
    bc5c:	1f 93       	push	r17
    bc5e:	df 93       	push	r29
    bc60:	cf 93       	push	r28
    bc62:	cd b7       	in	r28, 0x3d	; 61
    bc64:	de b7       	in	r29, 0x3e	; 62
    bc66:	64 97       	sbiw	r28, 0x14	; 20
    bc68:	0f b6       	in	r0, 0x3f	; 63
    bc6a:	f8 94       	cli
    bc6c:	de bf       	out	0x3e, r29	; 62
    bc6e:	0f be       	out	0x3f, r0	; 63
    bc70:	cd bf       	out	0x3d, r28	; 61
    bc72:	18 2f       	mov	r17, r24
	 char KeyPressed;
	 char FIPAddr;


	 Result=MENU_NONE;
	 switch(stCloseShift){
    bc74:	80 91 3b 03 	lds	r24, 0x033B
    bc78:	87 30       	cpi	r24, 0x07	; 7
    bc7a:	09 f4       	brne	.+2      	; 0xbc7e <FCloseShift+0x2a>
    bc7c:	a6 c1       	rjmp	.+844    	; 0xbfca <FCloseShift+0x376>
    bc7e:	88 30       	cpi	r24, 0x08	; 8
    bc80:	78 f4       	brcc	.+30     	; 0xbca0 <FCloseShift+0x4c>
    bc82:	84 30       	cpi	r24, 0x04	; 4
    bc84:	09 f4       	brne	.+2      	; 0xbc88 <FCloseShift+0x34>
    bc86:	68 c0       	rjmp	.+208    	; 0xbd58 <FCloseShift+0x104>
    bc88:	85 30       	cpi	r24, 0x05	; 5
    bc8a:	18 f4       	brcc	.+6      	; 0xbc92 <FCloseShift+0x3e>
    bc8c:	88 23       	and	r24, r24
    bc8e:	c1 f0       	breq	.+48     	; 0xbcc0 <FCloseShift+0x6c>
    bc90:	22 c2       	rjmp	.+1092   	; 0xc0d6 <FCloseShift+0x482>
    bc92:	85 30       	cpi	r24, 0x05	; 5
    bc94:	09 f4       	brne	.+2      	; 0xbc98 <FCloseShift+0x44>
    bc96:	a6 c0       	rjmp	.+332    	; 0xbde4 <FCloseShift+0x190>
    bc98:	86 30       	cpi	r24, 0x06	; 6
    bc9a:	09 f0       	breq	.+2      	; 0xbc9e <FCloseShift+0x4a>
    bc9c:	1c c2       	rjmp	.+1080   	; 0xc0d6 <FCloseShift+0x482>
    bc9e:	a8 c0       	rjmp	.+336    	; 0xbdf0 <FCloseShift+0x19c>
    bca0:	8a 30       	cpi	r24, 0x0A	; 10
    bca2:	09 f4       	brne	.+2      	; 0xbca6 <FCloseShift+0x52>
    bca4:	d6 c1       	rjmp	.+940    	; 0xc052 <FCloseShift+0x3fe>
    bca6:	8b 30       	cpi	r24, 0x0B	; 11
    bca8:	20 f4       	brcc	.+8      	; 0xbcb2 <FCloseShift+0x5e>
    bcaa:	88 30       	cpi	r24, 0x08	; 8
    bcac:	09 f0       	breq	.+2      	; 0xbcb0 <FCloseShift+0x5c>
    bcae:	13 c2       	rjmp	.+1062   	; 0xc0d6 <FCloseShift+0x482>
    bcb0:	92 c1       	rjmp	.+804    	; 0xbfd6 <FCloseShift+0x382>
    bcb2:	8b 30       	cpi	r24, 0x0B	; 11
    bcb4:	09 f4       	brne	.+2      	; 0xbcb8 <FCloseShift+0x64>
    bcb6:	0b c2       	rjmp	.+1046   	; 0xc0ce <FCloseShift+0x47a>
    bcb8:	8c 30       	cpi	r24, 0x0C	; 12
    bcba:	09 f0       	breq	.+2      	; 0xbcbe <FCloseShift+0x6a>
    bcbc:	0c c2       	rjmp	.+1048   	; 0xc0d6 <FCloseShift+0x482>
    bcbe:	d2 c1       	rjmp	.+932    	; 0xc064 <FCloseShift+0x410>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    bcc0:	e1 99       	sbic	0x1c, 1	; 28
    bcc2:	fe cf       	rjmp	.-4      	; 0xbcc0 <FCloseShift+0x6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    bcc4:	89 e7       	ldi	r24, 0x79	; 121
    bcc6:	91 e0       	ldi	r25, 0x01	; 1
    bcc8:	9f bb       	out	0x1f, r25	; 31
    bcca:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    bccc:	e0 9a       	sbi	0x1c, 0	; 28
    bcce:	8d b3       	in	r24, 0x1d	; 29
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
    bcd0:	80 93 76 01 	sts	0x0176, r24
		  IsPumpBusy=False;
    bcd4:	10 92 3a 03 	sts	0x033A, r1
    bcd8:	ff 24       	eor	r15, r15
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
    bcda:	dd 24       	eor	r13, r13
    bcdc:	d3 94       	inc	r13
    bcde:	36 c0       	rjmp	.+108    	; 0xbd4c <FCloseShift+0xf8>
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
		       if ((strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_NONE))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_OFF))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_BUSY)))
    bce0:	0f 2d       	mov	r16, r15
    bce2:	10 e0       	ldi	r17, 0x00	; 0
    bce4:	f8 01       	movw	r30, r16
    bce6:	e9 5d       	subi	r30, 0xD9	; 217
    bce8:	fe 4f       	sbci	r31, 0xFE	; 254
    bcea:	e0 80       	ld	r14, Z
    bcec:	8e e0       	ldi	r24, 0x0E	; 14
    bcee:	0e 94 c2 12 	call	0x2584	; 0x2584 <GetPumpStatusLabel>
    bcf2:	e8 16       	cp	r14, r24
    bcf4:	81 f0       	breq	.+32     	; 0xbd16 <FCloseShift+0xc2>
    bcf6:	86 e0       	ldi	r24, 0x06	; 6
    bcf8:	0e 94 c2 12 	call	0x2584	; 0x2584 <GetPumpStatusLabel>
    bcfc:	e8 16       	cp	r14, r24
    bcfe:	59 f0       	breq	.+22     	; 0xbd16 <FCloseShift+0xc2>
    bd00:	89 e0       	ldi	r24, 0x09	; 9
    bd02:	0e 94 c2 12 	call	0x2584	; 0x2584 <GetPumpStatusLabel>
    bd06:	e8 16       	cp	r14, r24
    bd08:	31 f0       	breq	.+12     	; 0xbd16 <FCloseShift+0xc2>
				    UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    bd0a:	8f 2d       	mov	r24, r15
    bd0c:	0e 94 5a 1b 	call	0x36b4	; 0x36b4 <GetPumpID>
    bd10:	66 e0       	ldi	r22, 0x06	; 6
    bd12:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <UpdateStandaloneStatus>
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    bd16:	84 e1       	ldi	r24, 0x14	; 20
    bd18:	0e 94 c2 12 	call	0x2584	; 0x2584 <GetPumpStatusLabel>
    bd1c:	f8 01       	movw	r30, r16
    bd1e:	e9 5d       	subi	r30, 0xD9	; 217
    bd20:	fe 4f       	sbci	r31, 0xFE	; 254
    bd22:	90 81       	ld	r25, Z
    bd24:	98 17       	cp	r25, r24
    bd26:	31 f4       	brne	.+12     	; 0xbd34 <FCloseShift+0xe0>
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    bd28:	8f 2d       	mov	r24, r15
    bd2a:	0e 94 5a 1b 	call	0x36b4	; 0x36b4 <GetPumpID>
    bd2e:	66 e0       	ldi	r22, 0x06	; 6
    bd30:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <UpdateStandaloneStatus>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
    bd34:	89 e0       	ldi	r24, 0x09	; 9
    bd36:	0e 94 c2 12 	call	0x2584	; 0x2584 <GetPumpStatusLabel>
    bd3a:	09 5d       	subi	r16, 0xD9	; 217
    bd3c:	1e 4f       	sbci	r17, 0xFE	; 254
    bd3e:	d8 01       	movw	r26, r16
    bd40:	9c 91       	ld	r25, X
    bd42:	98 17       	cp	r25, r24
    bd44:	11 f4       	brne	.+4      	; 0xbd4a <FCloseShift+0xf6>
			       IsPumpBusy=True;
    bd46:	d0 92 3a 03 	sts	0x033A, r13
	 switch(stCloseShift){
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
    bd4a:	f3 94       	inc	r15
    bd4c:	80 91 76 01 	lds	r24, 0x0176
    bd50:	f8 16       	cp	r15, r24
    bd52:	30 f2       	brcs	.-116    	; 0xbce0 <FCloseShift+0x8c>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
			   }

          stCloseShift=csSendTotalizerALL;
    bd54:	84 e0       	ldi	r24, 0x04	; 4
    bd56:	b8 c1       	rjmp	.+880    	; 0xc0c8 <FCloseShift+0x474>
			  */
	      break;
     case csWaitPumpLocked:	     
	      break;
     case csSendTotalizerALL:
	      lcd_clear();
    bd58:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("Totalizer.."));
    bd5c:	81 e0       	ldi	r24, 0x01	; 1
    bd5e:	61 e0       	ldi	r22, 0x01	; 1
    bd60:	41 e0       	ldi	r20, 0x01	; 1
    bd62:	55 e1       	ldi	r21, 0x15	; 21
    bd64:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  
		  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    bd68:	00 91 76 01 	lds	r16, 0x0176
    bd6c:	10 e0       	ldi	r17, 0x00	; 0
    bd6e:	87 e2       	ldi	r24, 0x27	; 39
    bd70:	91 e0       	ldi	r25, 0x01	; 1
    bd72:	0e 94 9f 2c 	call	0x593e	; 0x593e <CountTotalizerSatus>
    bd76:	00 d0       	rcall	.+0      	; 0xbd78 <FCloseShift+0x124>
    bd78:	00 d0       	rcall	.+0      	; 0xbd7a <FCloseShift+0x126>
    bd7a:	00 d0       	rcall	.+0      	; 0xbd7c <FCloseShift+0x128>
    bd7c:	ed b7       	in	r30, 0x3d	; 61
    bd7e:	fe b7       	in	r31, 0x3e	; 62
    bd80:	31 96       	adiw	r30, 0x01	; 1
    bd82:	7e 01       	movw	r14, r28
    bd84:	08 94       	sec
    bd86:	e1 1c       	adc	r14, r1
    bd88:	f1 1c       	adc	r15, r1
    bd8a:	ad b7       	in	r26, 0x3d	; 61
    bd8c:	be b7       	in	r27, 0x3e	; 62
    bd8e:	12 96       	adiw	r26, 0x02	; 2
    bd90:	fc 92       	st	X, r15
    bd92:	ee 92       	st	-X, r14
    bd94:	11 97       	sbiw	r26, 0x01	; 1
    bd96:	23 ef       	ldi	r18, 0xF3	; 243
    bd98:	34 e1       	ldi	r19, 0x14	; 20
    bd9a:	33 83       	std	Z+3, r19	; 0x03
    bd9c:	22 83       	std	Z+2, r18	; 0x02
    bd9e:	08 1b       	sub	r16, r24
    bda0:	11 09       	sbc	r17, r1
    bda2:	15 83       	std	Z+5, r17	; 0x05
    bda4:	04 83       	std	Z+4, r16	; 0x04
    bda6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(2,1,lcdteks);
    bdaa:	ed b7       	in	r30, 0x3d	; 61
    bdac:	fe b7       	in	r31, 0x3e	; 62
    bdae:	36 96       	adiw	r30, 0x06	; 6
    bdb0:	0f b6       	in	r0, 0x3f	; 63
    bdb2:	f8 94       	cli
    bdb4:	fe bf       	out	0x3e, r31	; 62
    bdb6:	0f be       	out	0x3f, r0	; 63
    bdb8:	ed bf       	out	0x3d, r30	; 61
    bdba:	82 e0       	ldi	r24, 0x02	; 2
    bdbc:	61 e0       	ldi	r22, 0x01	; 1
    bdbe:	a7 01       	movw	r20, r14
    bdc0:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>


          IsNewPumpStatus=True;
    bdc4:	11 e0       	ldi	r17, 0x01	; 1
    bdc6:	10 93 26 01 	sts	0x0126, r17
		  DisplayPumpStatus(); 
    bdca:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <DisplayPumpStatus>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    bdce:	95 e0       	ldi	r25, 0x05	; 5
    bdd0:	90 93 b6 07 	sts	0x07B6, r25
	 PoolMsg=plMsg;
    bdd4:	82 e1       	ldi	r24, 0x12	; 18
    bdd6:	80 93 de 0d 	sts	0x0DDE, r24
     IsControlPooling=True;
    bdda:	10 93 ad 01 	sts	0x01AD, r17
          IsNewPumpStatus=True;
		  DisplayPumpStatus(); 
		  //SendCommand
	      //SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);          
		  SendPoolingCommand(SC_TOTALIZER,PUMP_ALL);
		  stCloseShift=csDisplayPumpStatus;
    bdde:	90 93 3b 03 	sts	0x033B, r25
    bde2:	79 c1       	rjmp	.+754    	; 0xc0d6 <FCloseShift+0x482>
	      break;
     case csDisplayPumpStatus:
		  DisplayPumpStatus(); 
    bde4:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <DisplayPumpStatus>
		  TimDisplay=0;         
    bde8:	10 92 bc 01 	sts	0x01BC, r1
          stCloseShift=csWaitTotalizerComplete;
    bdec:	86 e0       	ldi	r24, 0x06	; 6
    bdee:	6c c1       	rjmp	.+728    	; 0xc0c8 <FCloseShift+0x474>
	      break;
     case csWaitTotalizerComplete:
	      KeyPressed=_key_scan(1);
    bdf0:	81 e0       	ldi	r24, 0x01	; 1
    bdf2:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    bdf6:	d8 2e       	mov	r13, r24
		  if (IsNewPumpStatus==True){
    bdf8:	80 91 26 01 	lds	r24, 0x0126
    bdfc:	81 30       	cpi	r24, 0x01	; 1
    bdfe:	89 f5       	brne	.+98     	; 0xbe62 <FCloseShift+0x20e>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    be00:	00 91 76 01 	lds	r16, 0x0176
    be04:	10 e0       	ldi	r17, 0x00	; 0
    be06:	87 e2       	ldi	r24, 0x27	; 39
    be08:	91 e0       	ldi	r25, 0x01	; 1
    be0a:	0e 94 9f 2c 	call	0x593e	; 0x593e <CountTotalizerSatus>
    be0e:	00 d0       	rcall	.+0      	; 0xbe10 <FCloseShift+0x1bc>
    be10:	00 d0       	rcall	.+0      	; 0xbe12 <FCloseShift+0x1be>
    be12:	00 d0       	rcall	.+0      	; 0xbe14 <FCloseShift+0x1c0>
    be14:	ed b7       	in	r30, 0x3d	; 61
    be16:	fe b7       	in	r31, 0x3e	; 62
    be18:	31 96       	adiw	r30, 0x01	; 1
    be1a:	7e 01       	movw	r14, r28
    be1c:	08 94       	sec
    be1e:	e1 1c       	adc	r14, r1
    be20:	f1 1c       	adc	r15, r1
    be22:	ad b7       	in	r26, 0x3d	; 61
    be24:	be b7       	in	r27, 0x3e	; 62
    be26:	12 96       	adiw	r26, 0x02	; 2
    be28:	fc 92       	st	X, r15
    be2a:	ee 92       	st	-X, r14
    be2c:	11 97       	sbiw	r26, 0x01	; 1
    be2e:	25 ee       	ldi	r18, 0xE5	; 229
    be30:	34 e1       	ldi	r19, 0x14	; 20
    be32:	33 83       	std	Z+3, r19	; 0x03
    be34:	22 83       	std	Z+2, r18	; 0x02
    be36:	08 1b       	sub	r16, r24
    be38:	11 09       	sbc	r17, r1
    be3a:	15 83       	std	Z+5, r17	; 0x05
    be3c:	04 83       	std	Z+4, r16	; 0x04
    be3e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  lcd_print(2,1,lcdteks);
    be42:	ed b7       	in	r30, 0x3d	; 61
    be44:	fe b7       	in	r31, 0x3e	; 62
    be46:	36 96       	adiw	r30, 0x06	; 6
    be48:	0f b6       	in	r0, 0x3f	; 63
    be4a:	f8 94       	cli
    be4c:	fe bf       	out	0x3e, r31	; 62
    be4e:	0f be       	out	0x3f, r0	; 63
    be50:	ed bf       	out	0x3d, r30	; 61
    be52:	82 e0       	ldi	r24, 0x02	; 2
    be54:	61 e0       	ldi	r22, 0x01	; 1
    be56:	a7 01       	movw	r20, r14
    be58:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  	  stCloseShift=csDisplayPumpStatus;	 
    be5c:	85 e0       	ldi	r24, 0x05	; 5
    be5e:	80 93 3b 03 	sts	0x033B, r24
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
    be62:	87 e2       	ldi	r24, 0x27	; 39
    be64:	91 e0       	ldi	r25, 0x01	; 1
    be66:	0e 94 9f 2c 	call	0x593e	; 0x593e <CountTotalizerSatus>
    be6a:	90 91 76 01 	lds	r25, 0x0176
    be6e:	89 17       	cp	r24, r25
    be70:	a0 f0       	brcs	.+40     	; 0xbe9a <FCloseShift+0x246>
    be72:	80 91 bc 01 	lds	r24, 0x01BC
    be76:	86 30       	cpi	r24, 0x06	; 6
    be78:	80 f0       	brcs	.+32     	; 0xbe9a <FCloseShift+0x246>
    be7a:	10 e0       	ldi	r17, 0x00	; 0
    be7c:	07 c0       	rjmp	.+14     	; 0xbe8c <FCloseShift+0x238>
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    be7e:	81 2f       	mov	r24, r17
    be80:	0e 94 5a 1b 	call	0x36b4	; 0x36b4 <GetPumpID>
    be84:	66 e0       	ldi	r22, 0x06	; 6
    be86:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <UpdateStandaloneStatus>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
			  lcd_print(2,1,lcdteks);
		  	  stCloseShift=csDisplayPumpStatus;	 
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
    be8a:	1f 5f       	subi	r17, 0xFF	; 255
    be8c:	80 91 76 01 	lds	r24, 0x0176
    be90:	18 17       	cp	r17, r24
    be92:	a8 f3       	brcs	.-22     	; 0xbe7e <FCloseShift+0x22a>
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);

		      stCloseShift=csGenerateReport;		      
    be94:	88 e0       	ldi	r24, 0x08	; 8
    be96:	80 93 3b 03 	sts	0x033B, r24
			  }
          //sprintf_P(lcdteks,PSTR("TimSend:%d"),TimDisplay);
		  //lcd_print(3,1,lcdteks);

          if ((TimDisplay>15)&&(IsPumpBusy!=True)){
    be9a:	80 91 bc 01 	lds	r24, 0x01BC
    be9e:	80 31       	cpi	r24, 0x10	; 16
    bea0:	08 f4       	brcc	.+2      	; 0xbea4 <FCloseShift+0x250>
    bea2:	67 c0       	rjmp	.+206    	; 0xbf72 <FCloseShift+0x31e>
    bea4:	80 91 3a 03 	lds	r24, 0x033A
    bea8:	81 30       	cpi	r24, 0x01	; 1
    beaa:	09 f4       	brne	.+2      	; 0xbeae <FCloseShift+0x25a>
    beac:	62 c0       	rjmp	.+196    	; 0xbf72 <FCloseShift+0x31e>
		      if(CountNoPumpSatus(strPumpStatus)>=eeprom_read_byte(&DefActivePump)){
    beae:	87 e2       	ldi	r24, 0x27	; 39
    beb0:	91 e0       	ldi	r25, 0x01	; 1
    beb2:	0e 94 49 15 	call	0x2a92	; 0x2a92 <CountNoPumpSatus>
    beb6:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    beb8:	e1 99       	sbic	0x1c, 1	; 28
    beba:	fe cf       	rjmp	.-4      	; 0xbeb8 <FCloseShift+0x264>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    bebc:	89 e7       	ldi	r24, 0x79	; 121
    bebe:	91 e0       	ldi	r25, 0x01	; 1
    bec0:	9f bb       	out	0x1f, r25	; 31
    bec2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    bec4:	e0 9a       	sbi	0x1c, 0	; 28
    bec6:	8d b3       	in	r24, 0x1d	; 29
    bec8:	28 17       	cp	r18, r24
    beca:	08 f4       	brcc	.+2      	; 0xbece <FCloseShift+0x27a>
    becc:	52 c0       	rjmp	.+164    	; 0xbf72 <FCloseShift+0x31e>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
    bece:	00 91 76 01 	lds	r16, 0x0176
    bed2:	10 e0       	ldi	r17, 0x00	; 0
    bed4:	87 e2       	ldi	r24, 0x27	; 39
    bed6:	91 e0       	ldi	r25, 0x01	; 1
    bed8:	0e 94 49 15 	call	0x2a92	; 0x2a92 <CountNoPumpSatus>
    bedc:	00 d0       	rcall	.+0      	; 0xbede <FCloseShift+0x28a>
    bede:	00 d0       	rcall	.+0      	; 0xbee0 <FCloseShift+0x28c>
    bee0:	00 d0       	rcall	.+0      	; 0xbee2 <FCloseShift+0x28e>
    bee2:	ed b7       	in	r30, 0x3d	; 61
    bee4:	fe b7       	in	r31, 0x3e	; 62
    bee6:	31 96       	adiw	r30, 0x01	; 1
    bee8:	7e 01       	movw	r14, r28
    beea:	08 94       	sec
    beec:	e1 1c       	adc	r14, r1
    beee:	f1 1c       	adc	r15, r1
    bef0:	ad b7       	in	r26, 0x3d	; 61
    bef2:	be b7       	in	r27, 0x3e	; 62
    bef4:	12 96       	adiw	r26, 0x02	; 2
    bef6:	fc 92       	st	X, r15
    bef8:	ee 92       	st	-X, r14
    befa:	11 97       	sbiw	r26, 0x01	; 1
    befc:	21 ed       	ldi	r18, 0xD1	; 209
    befe:	34 e1       	ldi	r19, 0x14	; 20
    bf00:	33 83       	std	Z+3, r19	; 0x03
    bf02:	22 83       	std	Z+2, r18	; 0x02
    bf04:	08 1b       	sub	r16, r24
    bf06:	11 09       	sbc	r17, r1
    bf08:	15 83       	std	Z+5, r17	; 0x05
    bf0a:	04 83       	std	Z+4, r16	; 0x04
    bf0c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    bf10:	ed b7       	in	r30, 0x3d	; 61
    bf12:	fe b7       	in	r31, 0x3e	; 62
    bf14:	36 96       	adiw	r30, 0x06	; 6
    bf16:	0f b6       	in	r0, 0x3f	; 63
    bf18:	f8 94       	cli
    bf1a:	fe bf       	out	0x3e, r31	; 62
    bf1c:	0f be       	out	0x3f, r0	; 63
    bf1e:	ed bf       	out	0x3d, r30	; 61
    bf20:	83 e0       	ldi	r24, 0x03	; 3
    bf22:	61 e0       	ldi	r22, 0x01	; 1
    bf24:	a7 01       	movw	r20, r14
    bf26:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    bf2a:	10 e0       	ldi	r17, 0x00	; 0
    bf2c:	11 c0       	rjmp	.+34     	; 0xbf50 <FCloseShift+0x2fc>
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    bf2e:	84 e1       	ldi	r24, 0x14	; 20
    bf30:	0e 94 c2 12 	call	0x2584	; 0x2584 <GetPumpStatusLabel>
    bf34:	e1 2f       	mov	r30, r17
    bf36:	f0 e0       	ldi	r31, 0x00	; 0
    bf38:	e9 5d       	subi	r30, 0xD9	; 217
    bf3a:	fe 4f       	sbci	r31, 0xFE	; 254
    bf3c:	90 81       	ld	r25, Z
    bf3e:	98 17       	cp	r25, r24
    bf40:	31 f4       	brne	.+12     	; 0xbf4e <FCloseShift+0x2fa>
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    bf42:	81 2f       	mov	r24, r17
    bf44:	0e 94 5a 1b 	call	0x36b4	; 0x36b4 <GetPumpID>
    bf48:	66 e0       	ldi	r22, 0x06	; 6
    bf4a:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <UpdateStandaloneStatus>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
			  lcd_print(3,1,lcdteks);
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
    bf4e:	1f 5f       	subi	r17, 0xFF	; 255
    bf50:	80 91 76 01 	lds	r24, 0x0176
    bf54:	18 17       	cp	r17, r24
    bf56:	58 f3       	brcs	.-42     	; 0xbf2e <FCloseShift+0x2da>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    bf58:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    bf5a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    bf5c:	81 e0       	ldi	r24, 0x01	; 1
    bf5e:	90 e0       	ldi	r25, 0x00	; 0
    bf60:	90 93 ec 01 	sts	0x01EC, r25
    bf64:	80 93 eb 01 	sts	0x01EB, r24
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
			  }

			  system_beep(1);
			  TimDisplay=0;
    bf68:	10 92 bc 01 	sts	0x01BC, r1
			  stCloseShift=csNoPumpFound;		     
    bf6c:	87 e0       	ldi	r24, 0x07	; 7
    bf6e:	80 93 3b 03 	sts	0x033B, r24
			  }			  
		  }
		  if (KeyPressed==_KEY_CANCEL){
    bf72:	f7 ee       	ldi	r31, 0xE7	; 231
    bf74:	df 16       	cp	r13, r31
    bf76:	09 f0       	breq	.+2      	; 0xbf7a <FCloseShift+0x326>
    bf78:	ae c0       	rjmp	.+348    	; 0xc0d6 <FCloseShift+0x482>
			  sprintf_P(lcdteks,PSTR("Cancel"));
    bf7a:	00 d0       	rcall	.+0      	; 0xbf7c <FCloseShift+0x328>
    bf7c:	00 d0       	rcall	.+0      	; 0xbf7e <FCloseShift+0x32a>
    bf7e:	8e 01       	movw	r16, r28
    bf80:	0f 5f       	subi	r16, 0xFF	; 255
    bf82:	1f 4f       	sbci	r17, 0xFF	; 255
    bf84:	ad b7       	in	r26, 0x3d	; 61
    bf86:	be b7       	in	r27, 0x3e	; 62
    bf88:	12 96       	adiw	r26, 0x02	; 2
    bf8a:	1c 93       	st	X, r17
    bf8c:	0e 93       	st	-X, r16
    bf8e:	11 97       	sbiw	r26, 0x01	; 1
    bf90:	8a ec       	ldi	r24, 0xCA	; 202
    bf92:	94 e1       	ldi	r25, 0x14	; 20
    bf94:	14 96       	adiw	r26, 0x04	; 4
    bf96:	9c 93       	st	X, r25
    bf98:	8e 93       	st	-X, r24
    bf9a:	13 97       	sbiw	r26, 0x03	; 3
    bf9c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    bfa0:	0f 90       	pop	r0
    bfa2:	0f 90       	pop	r0
    bfa4:	0f 90       	pop	r0
    bfa6:	0f 90       	pop	r0
    bfa8:	83 e0       	ldi	r24, 0x03	; 3
    bfaa:	61 e0       	ldi	r22, 0x01	; 1
    bfac:	a8 01       	movw	r20, r16
    bfae:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    bfb2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    bfb4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    bfb6:	81 e0       	ldi	r24, 0x01	; 1
    bfb8:	90 e0       	ldi	r25, 0x00	; 0
    bfba:	90 93 ec 01 	sts	0x01EC, r25
    bfbe:	80 93 eb 01 	sts	0x01EB, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
			  sprintf_P(lcdteks,PSTR("Cancel"));
			  lcd_print(3,1,lcdteks);
			  system_beep(1);
			  TimDisplay=0;
    bfc2:	10 92 bc 01 	sts	0x01BC, r1
			  stCloseShift=csNoPumpFound;		     		  
    bfc6:	87 e0       	ldi	r24, 0x07	; 7
    bfc8:	7f c0       	rjmp	.+254    	; 0xc0c8 <FCloseShift+0x474>
		  }
	      break;
     case csNoPumpFound:
	      if (TimDisplay>TIM_DISPLAY){
    bfca:	80 91 bc 01 	lds	r24, 0x01BC
    bfce:	8b 30       	cpi	r24, 0x0B	; 11
    bfd0:	08 f4       	brcc	.+2      	; 0xbfd4 <FCloseShift+0x380>
    bfd2:	81 c0       	rjmp	.+258    	; 0xc0d6 <FCloseShift+0x482>
    bfd4:	78 c0       	rjmp	.+240    	; 0xc0c6 <FCloseShift+0x472>
		      stCloseShift=csFinishCloseShift;
		  }	      
	      break;
     case csGenerateReport:
		  lcd_printf(1,1,PSTR("Printing Totalizer"));
    bfd6:	81 e0       	ldi	r24, 0x01	; 1
    bfd8:	61 e0       	ldi	r22, 0x01	; 1
    bfda:	47 eb       	ldi	r20, 0xB7	; 183
    bfdc:	54 e1       	ldi	r21, 0x14	; 20
    bfde:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
          _datetime(0, strSystemDate, strSystemTime);
    bfe2:	00 ec       	ldi	r16, 0xC0	; 192
    bfe4:	15 e0       	ldi	r17, 0x05	; 5
    bfe6:	39 ea       	ldi	r19, 0xA9	; 169
    bfe8:	e3 2e       	mov	r14, r19
    bfea:	3a e0       	ldi	r19, 0x0A	; 10
    bfec:	f3 2e       	mov	r15, r19
    bfee:	80 e0       	ldi	r24, 0x00	; 0
    bff0:	b8 01       	movw	r22, r16
    bff2:	a7 01       	movw	r20, r14
    bff4:	0e 94 fa b1 	call	0x163f4	; 0x163f4 <_datetime>
		  sprintf_P(CurrentShiftDateTime,PSTR("%s %s"),strSystemDate,strSystemTime);
    bff8:	ed b7       	in	r30, 0x3d	; 61
    bffa:	fe b7       	in	r31, 0x3e	; 62
    bffc:	38 97       	sbiw	r30, 0x08	; 8
    bffe:	0f b6       	in	r0, 0x3f	; 63
    c000:	f8 94       	cli
    c002:	fe bf       	out	0x3e, r31	; 62
    c004:	0f be       	out	0x3f, r0	; 63
    c006:	ed bf       	out	0x3d, r30	; 61
    c008:	31 96       	adiw	r30, 0x01	; 1
    c00a:	8d e9       	ldi	r24, 0x9D	; 157
    c00c:	99 e0       	ldi	r25, 0x09	; 9
    c00e:	ad b7       	in	r26, 0x3d	; 61
    c010:	be b7       	in	r27, 0x3e	; 62
    c012:	12 96       	adiw	r26, 0x02	; 2
    c014:	9c 93       	st	X, r25
    c016:	8e 93       	st	-X, r24
    c018:	11 97       	sbiw	r26, 0x01	; 1
    c01a:	81 eb       	ldi	r24, 0xB1	; 177
    c01c:	94 e1       	ldi	r25, 0x14	; 20
    c01e:	93 83       	std	Z+3, r25	; 0x03
    c020:	82 83       	std	Z+2, r24	; 0x02
    c022:	15 83       	std	Z+5, r17	; 0x05
    c024:	04 83       	std	Z+4, r16	; 0x04
    c026:	f7 82       	std	Z+7, r15	; 0x07
    c028:	e6 82       	std	Z+6, r14	; 0x06
    c02a:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  IsGenerateReport=True;
    c02e:	81 e0       	ldi	r24, 0x01	; 1
    c030:	80 93 af 01 	sts	0x01AF, r24
		  IsFinishPrintingTotalizer=False;
    c034:	10 92 b0 01 	sts	0x01B0, r1
		  stCloseShift=csWaitPrintTotalizerComplete;
    c038:	8a e0       	ldi	r24, 0x0A	; 10
    c03a:	80 93 3b 03 	sts	0x033B, r24
    c03e:	80 e0       	ldi	r24, 0x00	; 0
    c040:	ed b7       	in	r30, 0x3d	; 61
    c042:	fe b7       	in	r31, 0x3e	; 62
    c044:	38 96       	adiw	r30, 0x08	; 8
    c046:	0f b6       	in	r0, 0x3f	; 63
    c048:	f8 94       	cli
    c04a:	fe bf       	out	0x3e, r31	; 62
    c04c:	0f be       	out	0x3f, r0	; 63
    c04e:	ed bf       	out	0x3d, r30	; 61
    c050:	43 c0       	rjmp	.+134    	; 0xc0d8 <FCloseShift+0x484>
	      break;
     case csWaitTotalizerALL:
	      break;
     case csWaitPrintTotalizerComplete:
	      if (IsFinishPrintingTotalizer==True){
    c052:	80 91 b0 01 	lds	r24, 0x01B0
    c056:	81 30       	cpi	r24, 0x01	; 1
    c058:	09 f0       	breq	.+2      	; 0xc05c <FCloseShift+0x408>
    c05a:	3d c0       	rjmp	.+122    	; 0xc0d6 <FCloseShift+0x482>
		      IsFinishPrintingTotalizer=False;
    c05c:	10 92 b0 01 	sts	0x01B0, r1
		      stCloseShift=csDumpShift;
    c060:	8c e0       	ldi	r24, 0x0C	; 12
    c062:	32 c0       	rjmp	.+100    	; 0xc0c8 <FCloseShift+0x474>
		  }
	      break;
     case csDumpShift://Increment CurrentShift save Current to Last
		  lcd_printf(1,1,PSTR("Saving ShiftData.. "));
    c064:	81 e0       	ldi	r24, 0x01	; 1
    c066:	61 e0       	ldi	r22, 0x01	; 1
    c068:	4d e9       	ldi	r20, 0x9D	; 157
    c06a:	54 e1       	ldi	r21, 0x14	; 20
    c06c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	      if (ShiftType==CONTINUE_SHIFT)//Shift=Shift+1
    c070:	12 30       	cpi	r17, 0x02	; 2
    c072:	71 f4       	brne	.+28     	; 0xc090 <FCloseShift+0x43c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c074:	e1 99       	sbic	0x1c, 1	; 28
    c076:	fe cf       	rjmp	.-4      	; 0xc074 <FCloseShift+0x420>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c078:	2f e6       	ldi	r18, 0x6F	; 111
    c07a:	31 e0       	ldi	r19, 0x01	; 1
    c07c:	3f bb       	out	0x1f, r19	; 31
    c07e:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c080:	e0 9a       	sbi	0x1c, 0	; 28
    c082:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c084:	e1 99       	sbic	0x1c, 1	; 28
    c086:	fe cf       	rjmp	.-4      	; 0xc084 <FCloseShift+0x430>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c088:	3f bb       	out	0x1f, r19	; 31
    c08a:	2e bb       	out	0x1e, r18	; 30
		      eeprom_write_byte(&DefShift,eeprom_read_byte(&DefShift)+1);	 
    c08c:	8f 5f       	subi	r24, 0xFF	; 255
    c08e:	09 c0       	rjmp	.+18     	; 0xc0a2 <FCloseShift+0x44e>
          else if (ShiftType==NEW_SHIFT)//Shift=1
    c090:	11 30       	cpi	r17, 0x01	; 1
    c092:	69 f4       	brne	.+26     	; 0xc0ae <FCloseShift+0x45a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c094:	e1 99       	sbic	0x1c, 1	; 28
    c096:	fe cf       	rjmp	.-4      	; 0xc094 <FCloseShift+0x440>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c098:	8f e6       	ldi	r24, 0x6F	; 111
    c09a:	91 e0       	ldi	r25, 0x01	; 1
    c09c:	9f bb       	out	0x1f, r25	; 31
    c09e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    c0a0:	81 e0       	ldi	r24, 0x01	; 1
    c0a2:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    c0a4:	0f b6       	in	r0, 0x3f	; 63
    c0a6:	f8 94       	cli
    c0a8:	e2 9a       	sbi	0x1c, 2	; 28
    c0aa:	e1 9a       	sbi	0x1c, 1	; 28
    c0ac:	0f be       	out	0x3f, r0	; 63
		      eeprom_write_byte(&DefShift,1);	 

          SaveTotalizerCurrentToLast();
    c0ae:	0e 94 35 44 	call	0x886a	; 0x886a <SaveTotalizerCurrentToLast>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    c0b2:	82 e7       	ldi	r24, 0x72	; 114
    c0b4:	98 e0       	ldi	r25, 0x08	; 8
    c0b6:	6d e9       	ldi	r22, 0x9D	; 157
    c0b8:	79 e0       	ldi	r23, 0x09	; 9
    c0ba:	44 e1       	ldi	r20, 0x14	; 20
    c0bc:	50 e0       	ldi	r21, 0x00	; 0
    c0be:	24 eb       	ldi	r18, 0xB4	; 180
    c0c0:	32 e1       	ldi	r19, 0x12	; 18
    c0c2:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
          eeprom_write_block((const void*) &CurrentShiftDateTime, (void*) &DefLastShiftDateTime,sizeof(DefLastShiftDateTime));
		  stCloseShift=csFinishCloseShift;
    c0c6:	8b e0       	ldi	r24, 0x0B	; 11
    c0c8:	80 93 3b 03 	sts	0x033B, r24
    c0cc:	04 c0       	rjmp	.+8      	; 0xc0d6 <FCloseShift+0x482>
	      break;
     case csFinishCloseShift:
          stCloseShift=csInitCloseShift;
    c0ce:	10 92 3b 03 	sts	0x033B, r1
    c0d2:	81 e0       	ldi	r24, 0x01	; 1
    c0d4:	01 c0       	rjmp	.+2      	; 0xc0d8 <FCloseShift+0x484>
    c0d6:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 //_uart_printf(0,1,PSTR("Close Shift"));	
   return Result;
}
    c0d8:	64 96       	adiw	r28, 0x14	; 20
    c0da:	0f b6       	in	r0, 0x3f	; 63
    c0dc:	f8 94       	cli
    c0de:	de bf       	out	0x3e, r29	; 62
    c0e0:	0f be       	out	0x3f, r0	; 63
    c0e2:	cd bf       	out	0x3d, r28	; 61
    c0e4:	cf 91       	pop	r28
    c0e6:	df 91       	pop	r29
    c0e8:	1f 91       	pop	r17
    c0ea:	0f 91       	pop	r16
    c0ec:	ff 90       	pop	r15
    c0ee:	ef 90       	pop	r14
    c0f0:	df 90       	pop	r13
    c0f2:	08 95       	ret

0000c0f4 <FMenuShift>:
     char SubMenu,KeyChar,KeyPressed;

     char Result;

Result=MENU_NONE;
     switch(stMenuShift){
    c0f4:	80 91 3c 03 	lds	r24, 0x033C
    c0f8:	82 30       	cpi	r24, 0x02	; 2
    c0fa:	09 f4       	brne	.+2      	; 0xc0fe <FMenuShift+0xa>
    c0fc:	48 c0       	rjmp	.+144    	; 0xc18e <FMenuShift+0x9a>
    c0fe:	83 30       	cpi	r24, 0x03	; 3
    c100:	30 f4       	brcc	.+12     	; 0xc10e <FMenuShift+0x1a>
    c102:	88 23       	and	r24, r24
    c104:	69 f0       	breq	.+26     	; 0xc120 <FMenuShift+0x2c>
    c106:	81 30       	cpi	r24, 0x01	; 1
    c108:	09 f0       	breq	.+2      	; 0xc10c <FMenuShift+0x18>
    c10a:	50 c0       	rjmp	.+160    	; 0xc1ac <FMenuShift+0xb8>
    c10c:	25 c0       	rjmp	.+74     	; 0xc158 <FMenuShift+0x64>
    c10e:	84 30       	cpi	r24, 0x04	; 4
    c110:	09 f4       	brne	.+2      	; 0xc114 <FMenuShift+0x20>
    c112:	4c c0       	rjmp	.+152    	; 0xc1ac <FMenuShift+0xb8>
    c114:	84 30       	cpi	r24, 0x04	; 4
    c116:	e8 f1       	brcs	.+122    	; 0xc192 <FMenuShift+0x9e>
    c118:	85 30       	cpi	r24, 0x05	; 5
    c11a:	09 f0       	breq	.+2      	; 0xc11e <FMenuShift+0x2a>
    c11c:	47 c0       	rjmp	.+142    	; 0xc1ac <FMenuShift+0xb8>
    c11e:	42 c0       	rjmp	.+132    	; 0xc1a4 <FMenuShift+0xb0>
	 case msInitMenuShift:
	      lcd_clear();
    c120:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Close Shift"));
    c124:	81 e0       	ldi	r24, 0x01	; 1
    c126:	61 e0       	ldi	r22, 0x01	; 1
    c128:	40 e3       	ldi	r20, 0x30	; 48
    c12a:	55 e1       	ldi	r21, 0x15	; 21
    c12c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Close Day  "));
    c130:	82 e0       	ldi	r24, 0x02	; 2
    c132:	61 e0       	ldi	r22, 0x01	; 1
    c134:	42 e2       	ldi	r20, 0x22	; 34
    c136:	55 e1       	ldi	r21, 0x15	; 21
    c138:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(3,1,PSTR("3.Lock Pump  "));
    c13c:	83 e0       	ldi	r24, 0x03	; 3
    c13e:	61 e0       	ldi	r22, 0x01	; 1
    c140:	44 e1       	ldi	r20, 0x14	; 20
    c142:	55 e1       	ldi	r21, 0x15	; 21
    c144:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit"));
    c148:	84 e0       	ldi	r24, 0x04	; 4
    c14a:	61 e0       	ldi	r22, 0x01	; 1
    c14c:	4d e0       	ldi	r20, 0x0D	; 13
    c14e:	55 e1       	ldi	r21, 0x15	; 21
    c150:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  stMenuShift=msSelectShift;
    c154:	81 e0       	ldi	r24, 0x01	; 1
    c156:	18 c0       	rjmp	.+48     	; 0xc188 <FMenuShift+0x94>
	      break;
     case msSelectShift:
          KeyPressed=_key_scan(1);
    c158:	81 e0       	ldi	r24, 0x01	; 1
    c15a:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    c15e:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
          switch(KeyChar){
    c162:	82 33       	cpi	r24, 0x32	; 50
    c164:	61 f0       	breq	.+24     	; 0xc17e <FMenuShift+0x8a>
    c166:	83 33       	cpi	r24, 0x33	; 51
    c168:	28 f4       	brcc	.+10     	; 0xc174 <FMenuShift+0x80>
    c16a:	8a 32       	cpi	r24, 0x2A	; 42
    c16c:	61 f0       	breq	.+24     	; 0xc186 <FMenuShift+0x92>
    c16e:	81 33       	cpi	r24, 0x31	; 49
    c170:	e9 f4       	brne	.+58     	; 0xc1ac <FMenuShift+0xb8>
    c172:	03 c0       	rjmp	.+6      	; 0xc17a <FMenuShift+0x86>
    c174:	83 33       	cpi	r24, 0x33	; 51
    c176:	d1 f4       	brne	.+52     	; 0xc1ac <FMenuShift+0xb8>
    c178:	04 c0       	rjmp	.+8      	; 0xc182 <FMenuShift+0x8e>
		  case '1':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseShift;
    c17a:	82 e0       	ldi	r24, 0x02	; 2
    c17c:	05 c0       	rjmp	.+10     	; 0xc188 <FMenuShift+0x94>
		       break; 
		  case '2':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseDay;
    c17e:	83 e0       	ldi	r24, 0x03	; 3
    c180:	03 c0       	rjmp	.+6      	; 0xc188 <FMenuShift+0x94>
		       break; 
		  case '3':
		       SubMenu=MENU_NONE;
		       stMenuShift=msLockPump;
    c182:	84 e0       	ldi	r24, 0x04	; 4
    c184:	01 c0       	rjmp	.+2      	; 0xc188 <FMenuShift+0x94>
		       break; 
		  case '*':
		       stMenuShift=msExitShift;
    c186:	85 e0       	ldi	r24, 0x05	; 5
    c188:	80 93 3c 03 	sts	0x033C, r24
    c18c:	09 c0       	rjmp	.+18     	; 0xc1a0 <FMenuShift+0xac>
		       break; 			   		  
		  }
		  break;
     case msCloseShift:
	      SubMenu=FCloseShift(CONTINUE_SHIFT);
    c18e:	82 e0       	ldi	r24, 0x02	; 2
    c190:	01 c0       	rjmp	.+2      	; 0xc194 <FMenuShift+0xa0>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
		  //IsGenerateReport=True;		  
	      break;
     case msCloseDay:
	      SubMenu=FCloseShift(NEW_SHIFT);
    c192:	81 e0       	ldi	r24, 0x01	; 1
    c194:	0e 94 2a 5e 	call	0xbc54	; 0xbc54 <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
    c198:	81 30       	cpi	r24, 0x01	; 1
    c19a:	41 f4       	brne	.+16     	; 0xc1ac <FMenuShift+0xb8>
    c19c:	10 92 3c 03 	sts	0x033C, r1
    c1a0:	80 e0       	ldi	r24, 0x00	; 0
    c1a2:	08 95       	ret
     case msLockPump:
	      SubMenu=FLockPump();
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
	      break;
     case msExitShift:
          stMenuShift=msInitMenuShift;
    c1a4:	10 92 3c 03 	sts	0x033C, r1
    c1a8:	81 e0       	ldi	r24, 0x01	; 1
    c1aa:	08 95       	ret
    c1ac:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 } 
   return Result;
}
    c1ae:	08 95       	ret

0000c1b0 <DisplayDateTime>:

void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}

void DisplayDateTime(){
    c1b0:	cf 92       	push	r12
    c1b2:	df 92       	push	r13
    c1b4:	ef 92       	push	r14
    c1b6:	ff 92       	push	r15
    c1b8:	0f 93       	push	r16
    c1ba:	1f 93       	push	r17
    c1bc:	df 93       	push	r29
    c1be:	cf 93       	push	r28
    c1c0:	cd b7       	in	r28, 0x3d	; 61
    c1c2:	de b7       	in	r29, 0x3e	; 62
    c1c4:	64 97       	sbiw	r28, 0x14	; 20
    c1c6:	0f b6       	in	r0, 0x3f	; 63
    c1c8:	f8 94       	cli
    c1ca:	de bf       	out	0x3e, r29	; 62
    c1cc:	0f be       	out	0x3f, r0	; 63
    c1ce:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20];
unsigned int RunTime=0;//MM:SS 
	 _datetime(0, strSystemDate, strSystemTime);
    c1d0:	50 ec       	ldi	r21, 0xC0	; 192
    c1d2:	e5 2e       	mov	r14, r21
    c1d4:	55 e0       	ldi	r21, 0x05	; 5
    c1d6:	f5 2e       	mov	r15, r21
    c1d8:	49 ea       	ldi	r20, 0xA9	; 169
    c1da:	c4 2e       	mov	r12, r20
    c1dc:	4a e0       	ldi	r20, 0x0A	; 10
    c1de:	d4 2e       	mov	r13, r20
    c1e0:	80 e0       	ldi	r24, 0x00	; 0
    c1e2:	b7 01       	movw	r22, r14
    c1e4:	a6 01       	movw	r20, r12
    c1e6:	0e 94 fa b1 	call	0x163f4	; 0x163f4 <_datetime>
	 sprintf_P(lcdteks,PSTR("%s %s"),strSystemDate,strSystemTime);
    c1ea:	8d b7       	in	r24, 0x3d	; 61
    c1ec:	9e b7       	in	r25, 0x3e	; 62
    c1ee:	08 97       	sbiw	r24, 0x08	; 8
    c1f0:	0f b6       	in	r0, 0x3f	; 63
    c1f2:	f8 94       	cli
    c1f4:	9e bf       	out	0x3e, r25	; 62
    c1f6:	0f be       	out	0x3f, r0	; 63
    c1f8:	8d bf       	out	0x3d, r24	; 61
    c1fa:	ed b7       	in	r30, 0x3d	; 61
    c1fc:	fe b7       	in	r31, 0x3e	; 62
    c1fe:	31 96       	adiw	r30, 0x01	; 1
    c200:	8e 01       	movw	r16, r28
    c202:	0f 5f       	subi	r16, 0xFF	; 255
    c204:	1f 4f       	sbci	r17, 0xFF	; 255
    c206:	ad b7       	in	r26, 0x3d	; 61
    c208:	be b7       	in	r27, 0x3e	; 62
    c20a:	12 96       	adiw	r26, 0x02	; 2
    c20c:	1c 93       	st	X, r17
    c20e:	0e 93       	st	-X, r16
    c210:	11 97       	sbiw	r26, 0x01	; 1
    c212:	8a e8       	ldi	r24, 0x8A	; 138
    c214:	9b e1       	ldi	r25, 0x1B	; 27
    c216:	93 83       	std	Z+3, r25	; 0x03
    c218:	82 83       	std	Z+2, r24	; 0x02
    c21a:	f5 82       	std	Z+5, r15	; 0x05
    c21c:	e4 82       	std	Z+4, r14	; 0x04
    c21e:	d7 82       	std	Z+7, r13	; 0x07
    c220:	c6 82       	std	Z+6, r12	; 0x06
    c222:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 lcd_print(2, 1, lcdteks);
    c226:	ed b7       	in	r30, 0x3d	; 61
    c228:	fe b7       	in	r31, 0x3e	; 62
    c22a:	38 96       	adiw	r30, 0x08	; 8
    c22c:	0f b6       	in	r0, 0x3f	; 63
    c22e:	f8 94       	cli
    c230:	fe bf       	out	0x3e, r31	; 62
    c232:	0f be       	out	0x3f, r0	; 63
    c234:	ed bf       	out	0x3d, r30	; 61
    c236:	82 e0       	ldi	r24, 0x02	; 2
    c238:	61 e0       	ldi	r22, 0x01	; 1
    c23a:	a8 01       	movw	r20, r16
    c23c:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	 
	 if (IsAutoCash==True){
    c240:	80 91 f5 01 	lds	r24, 0x01F5
    c244:	81 30       	cpi	r24, 0x01	; 1
    c246:	c1 f5       	brne	.+112    	; 0xc2b8 <DisplayDateTime+0x108>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    c248:	50 91 af 0a 	lds	r21, 0x0AAF
    c24c:	50 53       	subi	r21, 0x30	; 48
    c24e:	5a 30       	cpi	r21, 0x0A	; 10
    c250:	08 f0       	brcs	.+2      	; 0xc254 <DisplayDateTime+0xa4>
    c252:	50 e0       	ldi	r21, 0x00	; 0
	 sprintf_P(lcdteks,PSTR("%s %s"),strSystemDate,strSystemTime);
	 lcd_print(2, 1, lcdteks);
	 
	 if (IsAutoCash==True){
	     RunTime=(unsigned int)((unsigned int)((Ord(strSystemTime[3])*10) + Ord(strSystemTime[4]))*60) + ((Ord(strSystemTime[6])*10) + Ord(strSystemTime[7]));
	     if ((RunTime%30)==0){
    c254:	80 91 ac 0a 	lds	r24, 0x0AAC
    c258:	80 53       	subi	r24, 0x30	; 48
    c25a:	8a 30       	cpi	r24, 0x0A	; 10
    c25c:	08 f0       	brcs	.+2      	; 0xc260 <DisplayDateTime+0xb0>
    c25e:	80 e0       	ldi	r24, 0x00	; 0
    c260:	20 91 ad 0a 	lds	r18, 0x0AAD
    c264:	20 53       	subi	r18, 0x30	; 48
    c266:	2a 30       	cpi	r18, 0x0A	; 10
    c268:	08 f0       	brcs	.+2      	; 0xc26c <DisplayDateTime+0xbc>
    c26a:	20 e0       	ldi	r18, 0x00	; 0
    c26c:	60 91 b0 0a 	lds	r22, 0x0AB0
    c270:	60 53       	subi	r22, 0x30	; 48
    c272:	6a 30       	cpi	r22, 0x0A	; 10
    c274:	08 f0       	brcs	.+2      	; 0xc278 <DisplayDateTime+0xc8>
    c276:	60 e0       	ldi	r22, 0x00	; 0
    c278:	4a e0       	ldi	r20, 0x0A	; 10
    c27a:	84 9f       	mul	r24, r20
    c27c:	c0 01       	movw	r24, r0
    c27e:	11 24       	eor	r1, r1
    c280:	82 0f       	add	r24, r18
    c282:	91 1d       	adc	r25, r1
    c284:	2c e3       	ldi	r18, 0x3C	; 60
    c286:	30 e0       	ldi	r19, 0x00	; 0
    c288:	dc 01       	movw	r26, r24
    c28a:	a2 9f       	mul	r26, r18
    c28c:	c0 01       	movw	r24, r0
    c28e:	a3 9f       	mul	r26, r19
    c290:	90 0d       	add	r25, r0
    c292:	b2 9f       	mul	r27, r18
    c294:	90 0d       	add	r25, r0
    c296:	11 24       	eor	r1, r1
    c298:	54 9f       	mul	r21, r20
    c29a:	a0 01       	movw	r20, r0
    c29c:	11 24       	eor	r1, r1
    c29e:	84 0f       	add	r24, r20
    c2a0:	95 1f       	adc	r25, r21
    c2a2:	86 0f       	add	r24, r22
    c2a4:	91 1d       	adc	r25, r1
    c2a6:	6e e1       	ldi	r22, 0x1E	; 30
    c2a8:	70 e0       	ldi	r23, 0x00	; 0
    c2aa:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
    c2ae:	89 2b       	or	r24, r25
    c2b0:	19 f4       	brne	.+6      	; 0xc2b8 <DisplayDateTime+0x108>
		     CashTrigger=True;
    c2b2:	81 e0       	ldi	r24, 0x01	; 1
    c2b4:	80 93 f6 01 	sts	0x01F6, r24
         }
	 }
	 
}
    c2b8:	64 96       	adiw	r28, 0x14	; 20
    c2ba:	0f b6       	in	r0, 0x3f	; 63
    c2bc:	f8 94       	cli
    c2be:	de bf       	out	0x3e, r29	; 62
    c2c0:	0f be       	out	0x3f, r0	; 63
    c2c2:	cd bf       	out	0x3d, r28	; 61
    c2c4:	cf 91       	pop	r28
    c2c6:	df 91       	pop	r29
    c2c8:	1f 91       	pop	r17
    c2ca:	0f 91       	pop	r16
    c2cc:	ff 90       	pop	r15
    c2ce:	ef 90       	pop	r14
    c2d0:	df 90       	pop	r13
    c2d2:	cf 90       	pop	r12
    c2d4:	08 95       	ret

0000c2d6 <_menu_operator>:
}

void _menu_operator(void){
	char __result;

	__max_string = _MAX_OPP;
    c2d6:	82 e1       	ldi	r24, 0x12	; 18
    c2d8:	80 93 dc 03 	sts	0x03DC, r24
	__chr_count = 0;
    c2dc:	10 92 db 03 	sts	0x03DB, r1
	__buf_string[0] = '\0';
    c2e0:	10 92 be 0e 	sts	0x0EBE, r1

	lcd_clear();
    c2e4:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
	lcd_printf(1, 1, PSTR("OPERATOR :"));
    c2e8:	81 e0       	ldi	r24, 0x01	; 1
    c2ea:	61 e0       	ldi	r22, 0x01	; 1
    c2ec:	4f eb       	ldi	r20, 0xBF	; 191
    c2ee:	5b e0       	ldi	r21, 0x0B	; 11
    c2f0:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_printf(4, 1, PSTR("*)Cancel      #)Save"));
    c2f4:	84 e0       	ldi	r24, 0x04	; 4
    c2f6:	61 e0       	ldi	r22, 0x01	; 1
    c2f8:	4a ea       	ldi	r20, 0xAA	; 170
    c2fa:	5b e0       	ldi	r21, 0x0B	; 11
    c2fc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_xy(2, 1);
    c300:	82 e0       	ldi	r24, 0x02	; 2
    c302:	61 e0       	ldi	r22, 0x01	; 1
    c304:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
	__result = _key_string(1);
    c308:	81 e0       	ldi	r24, 0x01	; 1
    c30a:	0e 94 19 ae 	call	0x15c32	; 0x15c32 <_key_string>
	if(__result==0)
    c30e:	88 23       	and	r24, r24
    c310:	51 f4       	brne	.+20     	; 0xc326 <_menu_operator+0x50>
    c312:	85 e1       	ldi	r24, 0x15	; 21
    c314:	90 e0       	ldi	r25, 0x00	; 0
    c316:	6e eb       	ldi	r22, 0xBE	; 190
    c318:	7e e0       	ldi	r23, 0x0E	; 14
    c31a:	43 e1       	ldi	r20, 0x13	; 19
    c31c:	50 e0       	ldi	r21, 0x00	; 0
    c31e:	24 eb       	ldi	r18, 0xB4	; 180
    c320:	32 e1       	ldi	r19, 0x12	; 18
    c322:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
    c326:	08 95       	ret

0000c328 <_menu_setpassword>:
			}
		}
	}
}

void _menu_setpassword(unsigned char __level){
    c328:	cf 92       	push	r12
    c32a:	df 92       	push	r13
    c32c:	ff 92       	push	r15
    c32e:	0f 93       	push	r16
    c330:	1f 93       	push	r17
    c332:	df 93       	push	r29
    c334:	cf 93       	push	r28
    c336:	00 d0       	rcall	.+0      	; 0xc338 <_menu_setpassword+0x10>
    c338:	00 d0       	rcall	.+0      	; 0xc33a <_menu_setpassword+0x12>
    c33a:	0f 92       	push	r0
    c33c:	cd b7       	in	r28, 0x3d	; 61
    c33e:	de b7       	in	r29, 0x3e	; 62
    c340:	f8 2e       	mov	r15, r24
	unsigned char	__result = 0;
	unsigned char	__buff[5];

	__max_string = _MAX_PASS;
    c342:	8a e0       	ldi	r24, 0x0A	; 10
    c344:	80 93 dc 03 	sts	0x03DC, r24
    c348:	64 ec       	ldi	r22, 0xC4	; 196
    c34a:	c6 2e       	mov	r12, r22
    c34c:	69 e0       	ldi	r22, 0x09	; 9
    c34e:	d6 2e       	mov	r13, r22
	while(1){
		lcd_clear();_delay_ms(10);
		lcd_printf(1, 1, PSTR("PASSWORD (MAX   ):"));
		_f_inttostr(__buff, _MAX_PASS);
    c350:	8e 01       	movw	r16, r28
    c352:	0f 5f       	subi	r16, 0xFF	; 255
    c354:	1f 4f       	sbci	r17, 0xFF	; 255
	unsigned char	__result = 0;
	unsigned char	__buff[5];

	__max_string = _MAX_PASS;
	while(1){
		lcd_clear();_delay_ms(10);
    c356:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    c35a:	c6 01       	movw	r24, r12
    c35c:	01 97       	sbiw	r24, 0x01	; 1
    c35e:	f1 f7       	brne	.-4      	; 0xc35c <_menu_setpassword+0x34>
		lcd_printf(1, 1, PSTR("PASSWORD (MAX   ):"));
    c360:	81 e0       	ldi	r24, 0x01	; 1
    c362:	61 e0       	ldi	r22, 0x01	; 1
    c364:	47 e0       	ldi	r20, 0x07	; 7
    c366:	5c e0       	ldi	r21, 0x0C	; 12
    c368:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		_f_inttostr(__buff, _MAX_PASS);
    c36c:	c8 01       	movw	r24, r16
    c36e:	4a e0       	ldi	r20, 0x0A	; 10
    c370:	50 e0       	ldi	r21, 0x00	; 0
    c372:	60 e0       	ldi	r22, 0x00	; 0
    c374:	70 e0       	ldi	r23, 0x00	; 0
    c376:	0e 94 1c 18 	call	0x3038	; 0x3038 <_f_inttostr>
		_f_punctuation(__buff, 0, 2, 0);
    c37a:	c8 01       	movw	r24, r16
    c37c:	60 e0       	ldi	r22, 0x00	; 0
    c37e:	42 e0       	ldi	r20, 0x02	; 2
    c380:	20 e0       	ldi	r18, 0x00	; 0
    c382:	0e 94 3d 48 	call	0x907a	; 0x907a <_f_punctuation>
		lcd_print(1, 15, __buff);
    c386:	81 e0       	ldi	r24, 0x01	; 1
    c388:	6f e0       	ldi	r22, 0x0F	; 15
    c38a:	a8 01       	movw	r20, r16
    c38c:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		lcd_printf(4, 1, PSTR("*)Exit        #)Save"));
    c390:	84 e0       	ldi	r24, 0x04	; 4
    c392:	61 e0       	ldi	r22, 0x01	; 1
    c394:	42 ef       	ldi	r20, 0xF2	; 242
    c396:	5b e0       	ldi	r21, 0x0B	; 11
    c398:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		lcd_xy(2, 1);
    c39c:	82 e0       	ldi	r24, 0x02	; 2
    c39e:	61 e0       	ldi	r22, 0x01	; 1
    c3a0:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>

		
		__result = _key_string(2);
    c3a4:	82 e0       	ldi	r24, 0x02	; 2
    c3a6:	0e 94 19 ae 	call	0x15c32	; 0x15c32 <_key_string>
		if(__result)
    c3aa:	88 23       	and	r24, r24
    c3ac:	91 f4       	brne	.+36     	; 0xc3d2 <_menu_setpassword+0xaa>
			return;
		else
			switch(__level){
    c3ae:	ff 20       	and	r15, r15
    c3b0:	31 f0       	breq	.+12     	; 0xc3be <_menu_setpassword+0x96>
    c3b2:	81 e0       	ldi	r24, 0x01	; 1
    c3b4:	f8 16       	cp	r15, r24
    c3b6:	79 f6       	brne	.-98     	; 0xc356 <_menu_setpassword+0x2e>
    c3b8:	8b e0       	ldi	r24, 0x0B	; 11
    c3ba:	90 e0       	ldi	r25, 0x00	; 0
    c3bc:	02 c0       	rjmp	.+4      	; 0xc3c2 <_menu_setpassword+0x9a>
				case _SYS_PASS:
					eeprom_write_block((const void*) &__buf_string, (void*) &DefSysPassword, _MAX_PASS + 1);
					return;
    c3be:	81 e0       	ldi	r24, 0x01	; 1
    c3c0:	90 e0       	ldi	r25, 0x00	; 0
    c3c2:	6e eb       	ldi	r22, 0xBE	; 190
    c3c4:	7e e0       	ldi	r23, 0x0E	; 14
    c3c6:	4b e0       	ldi	r20, 0x0B	; 11
    c3c8:	50 e0       	ldi	r21, 0x00	; 0
    c3ca:	24 eb       	ldi	r18, 0xB4	; 180
    c3cc:	32 e1       	ldi	r19, 0x12	; 18
    c3ce:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
					eeprom_write_block((const void*) &__buf_string, (void*) &DefSpvPassword, _MAX_PASS + 1);
					return;
					break;
			}
	}
}
    c3d2:	0f 90       	pop	r0
    c3d4:	0f 90       	pop	r0
    c3d6:	0f 90       	pop	r0
    c3d8:	0f 90       	pop	r0
    c3da:	0f 90       	pop	r0
    c3dc:	cf 91       	pop	r28
    c3de:	df 91       	pop	r29
    c3e0:	1f 91       	pop	r17
    c3e2:	0f 91       	pop	r16
    c3e4:	ff 90       	pop	r15
    c3e6:	df 90       	pop	r13
    c3e8:	cf 90       	pop	r12
    c3ea:	08 95       	ret

0000c3ec <_menu_user>:
		}

	}
}

void _menu_user(void){
    c3ec:	cf 92       	push	r12
    c3ee:	df 92       	push	r13
    c3f0:	ef 92       	push	r14
    c3f2:	ff 92       	push	r15
    c3f4:	0f 93       	push	r16
    c3f6:	1f 93       	push	r17
    c3f8:	df 93       	push	r29
    c3fa:	cf 93       	push	r28
    c3fc:	cd b7       	in	r28, 0x3d	; 61
    c3fe:	de b7       	in	r29, 0x3e	; 62
    c400:	66 97       	sbiw	r28, 0x16	; 22
    c402:	0f b6       	in	r0, 0x3f	; 63
    c404:	f8 94       	cli
    c406:	de bf       	out	0x3e, r29	; 62
    c408:	0f be       	out	0x3f, r0	; 63
    c40a:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    c40c:	7e 01       	movw	r14, r28
    c40e:	08 94       	sec
    c410:	e1 1c       	adc	r14, r1
    c412:	f1 1c       	adc	r15, r1
    c414:	8e 01       	movw	r16, r28
    c416:	04 5f       	subi	r16, 0xF4	; 244
    c418:	1f 4f       	sbci	r17, 0xFF	; 255
    c41a:	74 ec       	ldi	r23, 0xC4	; 196
    c41c:	c7 2e       	mov	r12, r23
    c41e:	79 e0       	ldi	r23, 0x09	; 9
    c420:	d7 2e       	mov	r13, r23
    c422:	c7 01       	movw	r24, r14
    c424:	61 e0       	ldi	r22, 0x01	; 1
    c426:	70 e0       	ldi	r23, 0x00	; 0
    c428:	4b e0       	ldi	r20, 0x0B	; 11
    c42a:	50 e0       	ldi	r21, 0x00	; 0
    c42c:	2c ea       	ldi	r18, 0xAC	; 172
    c42e:	32 e1       	ldi	r19, 0x12	; 18
    c430:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
    c434:	c8 01       	movw	r24, r16
    c436:	6b e0       	ldi	r22, 0x0B	; 11
    c438:	70 e0       	ldi	r23, 0x00	; 0
    c43a:	4b e0       	ldi	r20, 0x0B	; 11
    c43c:	50 e0       	ldi	r21, 0x00	; 0
    c43e:	2c ea       	ldi	r18, 0xAC	; 172
    c440:	32 e1       	ldi	r19, 0x12	; 18
    c442:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>

	while(1){
		eeprom_read_block((void*) &__t_spv_pass, (const void*) &DefSpvPassword, _MAX_PASS + 1);
		eeprom_read_block((void*) &__t_sys_pass, (const void*) &DefSysPassword, _MAX_PASS + 1);
		
		lcd_clear();_delay_ms(10);
    c446:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    c44a:	c6 01       	movw	r24, r12
    c44c:	01 97       	sbiw	r24, 0x01	; 1
    c44e:	f1 f7       	brne	.-4      	; 0xc44c <_menu_user+0x60>
		lcd_printf(1, 1, PSTR("1)L1:"));
    c450:	81 e0       	ldi	r24, 0x01	; 1
    c452:	61 e0       	ldi	r22, 0x01	; 1
    c454:	47 e2       	ldi	r20, 0x27	; 39
    c456:	5c e0       	ldi	r21, 0x0C	; 12
    c458:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		lcd_printf(2, 1, PSTR("2)L2:"));
    c45c:	82 e0       	ldi	r24, 0x02	; 2
    c45e:	61 e0       	ldi	r22, 0x01	; 1
    c460:	41 e2       	ldi	r20, 0x21	; 33
    c462:	5c e0       	ldi	r21, 0x0C	; 12
    c464:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		lcd_print(1, 6, __t_spv_pass);
    c468:	81 e0       	ldi	r24, 0x01	; 1
    c46a:	66 e0       	ldi	r22, 0x06	; 6
    c46c:	a7 01       	movw	r20, r14
    c46e:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		lcd_print(2, 6, __t_sys_pass);
    c472:	82 e0       	ldi	r24, 0x02	; 2
    c474:	66 e0       	ldi	r22, 0x06	; 6
    c476:	a8 01       	movw	r20, r16
    c478:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		lcd_printf(4, 1, PSTR("*)Exit"));
    c47c:	84 e0       	ldi	r24, 0x04	; 4
    c47e:	61 e0       	ldi	r22, 0x01	; 1
    c480:	4a e1       	ldi	r20, 0x1A	; 26
    c482:	5c e0       	ldi	r21, 0x0C	; 12
    c484:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>

		while(1){
			
			__key = _key_scan(1);
    c488:	81 e0       	ldi	r24, 0x01	; 1
    c48a:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
			if(__key == _KEY_CANCEL)
    c48e:	87 3e       	cpi	r24, 0xE7	; 231
    c490:	51 f0       	breq	.+20     	; 0xc4a6 <_menu_user+0xba>
				return;
			if(__key == _KEY_1){
    c492:	8e 3e       	cpi	r24, 0xEE	; 238
    c494:	11 f4       	brne	.+4      	; 0xc49a <_menu_user+0xae>
				_menu_setpassword(_SPV_PASS);
    c496:	80 e0       	ldi	r24, 0x00	; 0
    c498:	03 c0       	rjmp	.+6      	; 0xc4a0 <_menu_user+0xb4>
				break;
			}
			if(__key == _KEY_2){
    c49a:	8e 3d       	cpi	r24, 0xDE	; 222
    c49c:	a9 f7       	brne	.-22     	; 0xc488 <_menu_user+0x9c>
				_menu_setpassword(_SYS_PASS);
    c49e:	81 e0       	ldi	r24, 0x01	; 1
    c4a0:	0e 94 94 61 	call	0xc328	; 0xc328 <_menu_setpassword>
    c4a4:	be cf       	rjmp	.-132    	; 0xc422 <_menu_user+0x36>
				break;
			}
		}
	}
}
    c4a6:	66 96       	adiw	r28, 0x16	; 22
    c4a8:	0f b6       	in	r0, 0x3f	; 63
    c4aa:	f8 94       	cli
    c4ac:	de bf       	out	0x3e, r29	; 62
    c4ae:	0f be       	out	0x3f, r0	; 63
    c4b0:	cd bf       	out	0x3d, r28	; 61
    c4b2:	cf 91       	pop	r28
    c4b4:	df 91       	pop	r29
    c4b6:	1f 91       	pop	r17
    c4b8:	0f 91       	pop	r16
    c4ba:	ff 90       	pop	r15
    c4bc:	ef 90       	pop	r14
    c4be:	df 90       	pop	r13
    c4c0:	cf 90       	pop	r12
    c4c2:	08 95       	ret

0000c4c4 <FSettingOperator>:
char FSettingHost(){
     _menu_host();
	 return MENU_DONE;
}
char FSettingOperator(){
     _menu_user();
    c4c4:	0e 94 f6 61 	call	0xc3ec	; 0xc3ec <_menu_user>
     return MENU_DONE;
}
    c4c8:	81 e0       	ldi	r24, 0x01	; 1
    c4ca:	08 95       	ret

0000c4cc <_menu_productinput>:
}

unsigned char _menu_productinput(void){
	char __result;

	__max_string = 5;
    c4cc:	85 e0       	ldi	r24, 0x05	; 5
    c4ce:	80 93 dc 03 	sts	0x03DC, r24
	lcd_printf(4, 1, PSTR("[*]Cancel    [#]Save"));
    c4d2:	84 e0       	ldi	r24, 0x04	; 4
    c4d4:	61 e0       	ldi	r22, 0x01	; 1
    c4d6:	44 e8       	ldi	r20, 0x84	; 132
    c4d8:	5e e0       	ldi	r21, 0x0E	; 14
    c4da:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	while(1){
		
		lcd_printf(2, 1,PSTR("                    "));
    c4de:	82 e0       	ldi	r24, 0x02	; 2
    c4e0:	61 e0       	ldi	r22, 0x01	; 1
    c4e2:	4f e6       	ldi	r20, 0x6F	; 111
    c4e4:	5e e0       	ldi	r21, 0x0E	; 14
    c4e6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		lcd_xy(2, 1);
    c4ea:	82 e0       	ldi	r24, 0x02	; 2
    c4ec:	61 e0       	ldi	r22, 0x01	; 1
    c4ee:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
		__result = _key_string(0);
    c4f2:	80 e0       	ldi	r24, 0x00	; 0
    c4f4:	0e 94 19 ae 	call	0x15c32	; 0x15c32 <_key_string>
		if(__result){
    c4f8:	88 23       	and	r24, r24
    c4fa:	29 f0       	breq	.+10     	; 0xc506 <_menu_productinput+0x3a>
			__chr_count = 0;
    c4fc:	10 92 db 03 	sts	0x03DB, r1
			__buf_string[0] = '\0';
    c500:	10 92 be 0e 	sts	0x0EBE, r1
    c504:	81 e0       	ldi	r24, 0x01	; 1
		}
		else
			return 0;
	}
	return 0;
}
    c506:	08 95       	ret

0000c508 <_menu_text>:
			}
		}
	}
}

void _menu_text(unsigned char __select){
    c508:	0f 93       	push	r16
    c50a:	1f 93       	push	r17
    c50c:	df 93       	push	r29
    c50e:	cf 93       	push	r28
    c510:	cd b7       	in	r28, 0x3d	; 61
    c512:	de b7       	in	r29, 0x3e	; 62
    c514:	2a 97       	sbiw	r28, 0x0a	; 10
    c516:	0f b6       	in	r0, 0x3f	; 63
    c518:	f8 94       	cli
    c51a:	de bf       	out	0x3e, r29	; 62
    c51c:	0f be       	out	0x3f, r0	; 63
    c51e:	cd bf       	out	0x3d, r28	; 61
	unsigned char	__result;
	unsigned char	__title[10];

	__max_string = _MAX_TEXT;
    c520:	96 e2       	ldi	r25, 0x26	; 38
    c522:	90 93 dc 03 	sts	0x03DC, r25
	__chr_count = 0;
    c526:	10 92 db 03 	sts	0x03DB, r1
	__buf_string[0] = '\0';
    c52a:	10 92 be 0e 	sts	0x0EBE, r1

	for(unsigned char __i = 0; __i < 10; __i ++)
		__title[__i] = pgm_read_byte(&__txttitle[__select][__i]);
    c52e:	08 2f       	mov	r16, r24
    c530:	10 e0       	ldi	r17, 0x00	; 0
    c532:	f8 01       	movw	r30, r16
    c534:	ee 0f       	add	r30, r30
    c536:	ff 1f       	adc	r31, r31
    c538:	c8 01       	movw	r24, r16
    c53a:	a3 e0       	ldi	r26, 0x03	; 3
    c53c:	88 0f       	add	r24, r24
    c53e:	99 1f       	adc	r25, r25
    c540:	aa 95       	dec	r26
    c542:	e1 f7       	brne	.-8      	; 0xc53c <_menu_text+0x34>
    c544:	e8 0f       	add	r30, r24
    c546:	f9 1f       	adc	r31, r25
    c548:	ee 5c       	subi	r30, 0xCE	; 206
    c54a:	fc 4f       	sbci	r31, 0xFC	; 252
    c54c:	de 01       	movw	r26, r28
    c54e:	11 96       	adiw	r26, 0x01	; 1

	__max_string = _MAX_TEXT;
	__chr_count = 0;
	__buf_string[0] = '\0';

	for(unsigned char __i = 0; __i < 10; __i ++)
    c550:	9e 01       	movw	r18, r28
    c552:	25 5f       	subi	r18, 0xF5	; 245
    c554:	3f 4f       	sbci	r19, 0xFF	; 255
		__title[__i] = pgm_read_byte(&__txttitle[__select][__i]);
    c556:	84 91       	lpm	r24, Z+
    c558:	8d 93       	st	X+, r24
    c55a:	31 96       	adiw	r30, 0x01	; 1

	__max_string = _MAX_TEXT;
	__chr_count = 0;
	__buf_string[0] = '\0';

	for(unsigned char __i = 0; __i < 10; __i ++)
    c55c:	a2 17       	cp	r26, r18
    c55e:	b3 07       	cpc	r27, r19
    c560:	d1 f7       	brne	.-12     	; 0xc556 <_menu_text+0x4e>
		__title[__i] = pgm_read_byte(&__txttitle[__select][__i]);

	lcd_clear();
    c562:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
	lcd_print(1, 1, __title);
    c566:	81 e0       	ldi	r24, 0x01	; 1
    c568:	61 e0       	ldi	r22, 0x01	; 1
    c56a:	ae 01       	movw	r20, r28
    c56c:	4f 5f       	subi	r20, 0xFF	; 255
    c56e:	5f 4f       	sbci	r21, 0xFF	; 255
    c570:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));
    c574:	84 e0       	ldi	r24, 0x04	; 4
    c576:	61 e0       	ldi	r22, 0x01	; 1
    c578:	48 ef       	ldi	r20, 0xF8	; 248
    c57a:	51 e1       	ldi	r21, 0x11	; 17
    c57c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_xy(2, 1);
    c580:	82 e0       	ldi	r24, 0x02	; 2
    c582:	61 e0       	ldi	r22, 0x01	; 1
    c584:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
	__result = _key_string(1);
    c588:	81 e0       	ldi	r24, 0x01	; 1
    c58a:	0e 94 19 ae 	call	0x15c32	; 0x15c32 <_key_string>
	if(__result==0)
    c58e:	88 23       	and	r24, r24
    c590:	a1 f4       	brne	.+40     	; 0xc5ba <_menu_text+0xb2>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    c592:	89 e2       	ldi	r24, 0x29	; 41
    c594:	90 e0       	ldi	r25, 0x00	; 0
    c596:	9c 01       	movw	r18, r24
    c598:	02 9f       	mul	r16, r18
    c59a:	c0 01       	movw	r24, r0
    c59c:	03 9f       	mul	r16, r19
    c59e:	90 0d       	add	r25, r0
    c5a0:	12 9f       	mul	r17, r18
    c5a2:	90 0d       	add	r25, r0
    c5a4:	11 24       	eor	r1, r1
    c5a6:	89 5a       	subi	r24, 0xA9	; 169
    c5a8:	9d 4f       	sbci	r25, 0xFD	; 253
    c5aa:	6e eb       	ldi	r22, 0xBE	; 190
    c5ac:	7e e0       	ldi	r23, 0x0E	; 14
    c5ae:	47 e2       	ldi	r20, 0x27	; 39
    c5b0:	50 e0       	ldi	r21, 0x00	; 0
    c5b2:	24 eb       	ldi	r18, 0xB4	; 180
    c5b4:	32 e1       	ldi	r19, 0x12	; 18
    c5b6:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
		eeprom_write_block((const void*) &__buf_string, (void*) &DefHeaderFooter[__select], _MAX_TEXT + 1);
}
    c5ba:	2a 96       	adiw	r28, 0x0a	; 10
    c5bc:	0f b6       	in	r0, 0x3f	; 63
    c5be:	f8 94       	cli
    c5c0:	de bf       	out	0x3e, r29	; 62
    c5c2:	0f be       	out	0x3f, r0	; 63
    c5c4:	cd bf       	out	0x3d, r28	; 61
    c5c6:	cf 91       	pop	r28
    c5c8:	df 91       	pop	r29
    c5ca:	1f 91       	pop	r17
    c5cc:	0f 91       	pop	r16
    c5ce:	08 95       	ret

0000c5d0 <_menu_footer>:

void _menu_footer(void){
	char __key;

	while(1){
		lcd_clear();
    c5d0:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		lcd_printf(1, 1, PSTR("1)Footer1  3)Footer3"));
    c5d4:	81 e0       	ldi	r24, 0x01	; 1
    c5d6:	61 e0       	ldi	r22, 0x01	; 1
    c5d8:	49 e2       	ldi	r20, 0x29	; 41
    c5da:	52 e1       	ldi	r21, 0x12	; 18
    c5dc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Footer2  4)Footer4"));
    c5e0:	82 e0       	ldi	r24, 0x02	; 2
    c5e2:	61 e0       	ldi	r22, 0x01	; 1
    c5e4:	44 e1       	ldi	r20, 0x14	; 20
    c5e6:	52 e1       	ldi	r21, 0x12	; 18
    c5e8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    c5ec:	84 e0       	ldi	r24, 0x04	; 4
    c5ee:	61 e0       	ldi	r22, 0x01	; 1
    c5f0:	4d e0       	ldi	r20, 0x0D	; 13
    c5f2:	52 e1       	ldi	r21, 0x12	; 18
    c5f4:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		
		while(1){
			__key = _key_scan(1);
    c5f8:	81 e0       	ldi	r24, 0x01	; 1
    c5fa:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
			if(__key == _KEY_CANCEL)
    c5fe:	87 3e       	cpi	r24, 0xE7	; 231
    c600:	91 f0       	breq	.+36     	; 0xc626 <_menu_footer+0x56>
				return;
			if(__key == _KEY_1){
    c602:	8e 3e       	cpi	r24, 0xEE	; 238
    c604:	11 f4       	brne	.+4      	; 0xc60a <_menu_footer+0x3a>
				_menu_text(4);
    c606:	84 e0       	ldi	r24, 0x04	; 4
    c608:	0b c0       	rjmp	.+22     	; 0xc620 <_menu_footer+0x50>
				break;
			}
			if(__key == _KEY_2){
    c60a:	8e 3d       	cpi	r24, 0xDE	; 222
    c60c:	11 f4       	brne	.+4      	; 0xc612 <_menu_footer+0x42>
				_menu_text(5);
    c60e:	85 e0       	ldi	r24, 0x05	; 5
    c610:	07 c0       	rjmp	.+14     	; 0xc620 <_menu_footer+0x50>
				break;
			}
			if(__key == _KEY_3){
    c612:	8e 3b       	cpi	r24, 0xBE	; 190
    c614:	11 f4       	brne	.+4      	; 0xc61a <_menu_footer+0x4a>
				_menu_text(6);
    c616:	86 e0       	ldi	r24, 0x06	; 6
    c618:	03 c0       	rjmp	.+6      	; 0xc620 <_menu_footer+0x50>
				break;
			}
			if(__key == _KEY_4){
    c61a:	8d 3e       	cpi	r24, 0xED	; 237
    c61c:	69 f7       	brne	.-38     	; 0xc5f8 <_menu_footer+0x28>
				_menu_text(7);
    c61e:	87 e0       	ldi	r24, 0x07	; 7
    c620:	0e 94 84 62 	call	0xc508	; 0xc508 <_menu_text>
    c624:	d5 cf       	rjmp	.-86     	; 0xc5d0 <_menu_footer>
    c626:	08 95       	ret

0000c628 <_menu_header>:

void _menu_header(void){
	char __key;

	while(1){
		lcd_clear();
    c628:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		lcd_printf(1, 1, PSTR("1)Header1  3)Header3"));
    c62c:	81 e0       	ldi	r24, 0x01	; 1
    c62e:	61 e0       	ldi	r22, 0x01	; 1
    c630:	4a e5       	ldi	r20, 0x5A	; 90
    c632:	52 e1       	ldi	r21, 0x12	; 18
    c634:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Header2  4)Header4"));
    c638:	82 e0       	ldi	r24, 0x02	; 2
    c63a:	61 e0       	ldi	r22, 0x01	; 1
    c63c:	45 e4       	ldi	r20, 0x45	; 69
    c63e:	52 e1       	ldi	r21, 0x12	; 18
    c640:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    c644:	84 e0       	ldi	r24, 0x04	; 4
    c646:	61 e0       	ldi	r22, 0x01	; 1
    c648:	4e e3       	ldi	r20, 0x3E	; 62
    c64a:	52 e1       	ldi	r21, 0x12	; 18
    c64c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		
		while(1){
			
			__key = _key_scan(1);
    c650:	81 e0       	ldi	r24, 0x01	; 1
    c652:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
			if(__key == _KEY_CANCEL)
    c656:	87 3e       	cpi	r24, 0xE7	; 231
    c658:	91 f0       	breq	.+36     	; 0xc67e <_menu_header+0x56>
				return;
			if(__key == _KEY_1){
    c65a:	8e 3e       	cpi	r24, 0xEE	; 238
    c65c:	11 f4       	brne	.+4      	; 0xc662 <_menu_header+0x3a>
				_menu_text(0);
    c65e:	80 e0       	ldi	r24, 0x00	; 0
    c660:	0b c0       	rjmp	.+22     	; 0xc678 <_menu_header+0x50>
				break;
			}
			if(__key == _KEY_2){
    c662:	8e 3d       	cpi	r24, 0xDE	; 222
    c664:	11 f4       	brne	.+4      	; 0xc66a <_menu_header+0x42>
				_menu_text(1);
    c666:	81 e0       	ldi	r24, 0x01	; 1
    c668:	07 c0       	rjmp	.+14     	; 0xc678 <_menu_header+0x50>
				break;
			}
			if(__key == _KEY_3){
    c66a:	8e 3b       	cpi	r24, 0xBE	; 190
    c66c:	11 f4       	brne	.+4      	; 0xc672 <_menu_header+0x4a>
				_menu_text(2);
    c66e:	82 e0       	ldi	r24, 0x02	; 2
    c670:	03 c0       	rjmp	.+6      	; 0xc678 <_menu_header+0x50>
				break;
			}
			if(__key == _KEY_4){
    c672:	8d 3e       	cpi	r24, 0xED	; 237
    c674:	69 f7       	brne	.-38     	; 0xc650 <_menu_header+0x28>
				_menu_text(3);
    c676:	83 e0       	ldi	r24, 0x03	; 3
    c678:	0e 94 84 62 	call	0xc508	; 0xc508 <_menu_text>
    c67c:	d5 cf       	rjmp	.-86     	; 0xc628 <_menu_header>
    c67e:	08 95       	ret

0000c680 <_menu_datetime>:
		}
	}
}


void _menu_datetime(void){
    c680:	8f 92       	push	r8
    c682:	9f 92       	push	r9
    c684:	af 92       	push	r10
    c686:	bf 92       	push	r11
    c688:	cf 92       	push	r12
    c68a:	df 92       	push	r13
    c68c:	ef 92       	push	r14
    c68e:	ff 92       	push	r15
    c690:	0f 93       	push	r16
    c692:	1f 93       	push	r17
    c694:	df 93       	push	r29
    c696:	cf 93       	push	r28
    c698:	cd b7       	in	r28, 0x3d	; 61
    c69a:	de b7       	in	r29, 0x3e	; 62
    c69c:	c2 54       	subi	r28, 0x42	; 66
    c69e:	d0 40       	sbci	r29, 0x00	; 0
    c6a0:	0f b6       	in	r0, 0x3f	; 63
    c6a2:	f8 94       	cli
    c6a4:	de bf       	out	0x3e, r29	; 62
    c6a6:	0f be       	out	0x3f, r0	; 63
    c6a8:	cd bf       	out	0x3d, r28	; 61
	char	__key, __chr;
	char	__date[9];
	char	__time[9];
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};
    c6aa:	de 01       	movw	r26, r28
    c6ac:	53 96       	adiw	r26, 0x13	; 19
    c6ae:	eb e3       	ldi	r30, 0x3B	; 59
    c6b0:	f1 e0       	ldi	r31, 0x01	; 1
    c6b2:	80 e3       	ldi	r24, 0x30	; 48
    c6b4:	01 90       	ld	r0, Z+
    c6b6:	0d 92       	st	X+, r0
    c6b8:	81 50       	subi	r24, 0x01	; 1
    c6ba:	e1 f7       	brne	.-8      	; 0xc6b4 <_menu_datetime+0x34>

	_datetime(_DATETIME_READ, __date, __time);
    c6bc:	8e 01       	movw	r16, r28
    c6be:	0f 5f       	subi	r16, 0xFF	; 255
    c6c0:	1f 4f       	sbci	r17, 0xFF	; 255
    c6c2:	b8 01       	movw	r22, r16
    c6c4:	ae 01       	movw	r20, r28
    c6c6:	46 5f       	subi	r20, 0xF6	; 246
    c6c8:	5f 4f       	sbci	r21, 0xFF	; 255
    c6ca:	0e 94 fa b1 	call	0x163f4	; 0x163f4 <_datetime>
    c6ce:	e5 e1       	ldi	r30, 0x15	; 21
    c6d0:	8e 2e       	mov	r8, r30
    c6d2:	91 2c       	mov	r9, r1
    c6d4:	8c 0e       	add	r8, r28
    c6d6:	9d 1e       	adc	r9, r29
    c6d8:	d4 01       	movw	r26, r8
    c6da:	20 e0       	ldi	r18, 0x00	; 0
    c6dc:	30 e0       	ldi	r19, 0x00	; 0
    c6de:	40 e0       	ldi	r20, 0x00	; 0
    c6e0:	50 e0       	ldi	r21, 0x00	; 0
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
    c6e2:	22 30       	cpi	r18, 0x02	; 2
    c6e4:	31 05       	cpc	r19, r1
    c6e6:	19 f0       	breq	.+6      	; 0xc6ee <_menu_datetime+0x6e>
    c6e8:	24 30       	cpi	r18, 0x04	; 4
    c6ea:	31 05       	cpc	r19, r1
    c6ec:	11 f4       	brne	.+4      	; 0xc6f2 <_menu_datetime+0x72>
			__ii++;
    c6ee:	4f 5f       	subi	r20, 0xFF	; 255
    c6f0:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __date[__ii];
    c6f2:	f8 01       	movw	r30, r16
    c6f4:	e4 0f       	add	r30, r20
    c6f6:	f5 1f       	adc	r31, r21
    c6f8:	80 81       	ld	r24, Z
    c6fa:	8c 93       	st	X, r24
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};

	_datetime(_DATETIME_READ, __date, __time);
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    c6fc:	2f 5f       	subi	r18, 0xFF	; 255
    c6fe:	3f 4f       	sbci	r19, 0xFF	; 255
    c700:	14 96       	adiw	r26, 0x04	; 4
    c702:	26 30       	cpi	r18, 0x06	; 6
    c704:	31 05       	cpc	r19, r1
    c706:	19 f0       	breq	.+6      	; 0xc70e <_menu_datetime+0x8e>
    c708:	4f 5f       	subi	r20, 0xFF	; 255
    c70a:	5f 4f       	sbci	r21, 0xFF	; 255
    c70c:	ea cf       	rjmp	.-44     	; 0xc6e2 <_menu_datetime+0x62>
    c70e:	7d e2       	ldi	r23, 0x2D	; 45
    c710:	a7 2e       	mov	r10, r23
    c712:	b1 2c       	mov	r11, r1
    c714:	ac 0e       	add	r10, r28
    c716:	bd 1e       	adc	r11, r29
    c718:	d5 01       	movw	r26, r10
    c71a:	40 e0       	ldi	r20, 0x00	; 0
    c71c:	50 e0       	ldi	r21, 0x00	; 0
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
    c71e:	6a e0       	ldi	r22, 0x0A	; 10
    c720:	e6 2e       	mov	r14, r22
    c722:	f1 2c       	mov	r15, r1
    c724:	ec 0e       	add	r14, r28
    c726:	fd 1e       	adc	r15, r29
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
    c728:	28 30       	cpi	r18, 0x08	; 8
    c72a:	31 05       	cpc	r19, r1
    c72c:	19 f0       	breq	.+6      	; 0xc734 <_menu_datetime+0xb4>
    c72e:	2a 30       	cpi	r18, 0x0A	; 10
    c730:	31 05       	cpc	r19, r1
    c732:	11 f4       	brne	.+4      	; 0xc738 <_menu_datetime+0xb8>
			__ii++;
    c734:	4f 5f       	subi	r20, 0xFF	; 255
    c736:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __time[__ii];
    c738:	f7 01       	movw	r30, r14
    c73a:	e4 0f       	add	r30, r20
    c73c:	f5 1f       	adc	r31, r21
    c73e:	80 81       	ld	r24, Z
    c740:	8c 93       	st	X, r24
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    c742:	2f 5f       	subi	r18, 0xFF	; 255
    c744:	3f 4f       	sbci	r19, 0xFF	; 255
    c746:	14 96       	adiw	r26, 0x04	; 4
    c748:	2c 30       	cpi	r18, 0x0C	; 12
    c74a:	31 05       	cpc	r19, r1
    c74c:	19 f0       	breq	.+6      	; 0xc754 <_menu_datetime+0xd4>
    c74e:	4f 5f       	subi	r20, 0xFF	; 255
    c750:	5f 4f       	sbci	r21, 0xFF	; 255
    c752:	ea cf       	rjmp	.-44     	; 0xc728 <_menu_datetime+0xa8>
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
	}

	lcd_clear();_delay_ms(10);
    c754:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    c758:	84 ec       	ldi	r24, 0xC4	; 196
    c75a:	99 e0       	ldi	r25, 0x09	; 9
    c75c:	01 97       	sbiw	r24, 0x01	; 1
    c75e:	f1 f7       	brne	.-4      	; 0xc75c <_menu_datetime+0xdc>
	lcd_printf(1, 1, PSTR("DATE : "));
    c760:	81 e0       	ldi	r24, 0x01	; 1
    c762:	61 e0       	ldi	r22, 0x01	; 1
    c764:	41 ee       	ldi	r20, 0xE1	; 225
    c766:	5c e0       	ldi	r21, 0x0C	; 12
    c768:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_printf(2, 1, PSTR("TIME : "));
    c76c:	82 e0       	ldi	r24, 0x02	; 2
    c76e:	61 e0       	ldi	r22, 0x01	; 1
    c770:	49 ed       	ldi	r20, 0xD9	; 217
    c772:	5c e0       	ldi	r21, 0x0C	; 12
    c774:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_print(1, 8, __date);
    c778:	81 e0       	ldi	r24, 0x01	; 1
    c77a:	68 e0       	ldi	r22, 0x08	; 8
    c77c:	8e 01       	movw	r16, r28
    c77e:	0f 5f       	subi	r16, 0xFF	; 255
    c780:	1f 4f       	sbci	r17, 0xFF	; 255
    c782:	a8 01       	movw	r20, r16
    c784:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	lcd_print(2, 8, __time);
    c788:	82 e0       	ldi	r24, 0x02	; 2
    c78a:	68 e0       	ldi	r22, 0x08	; 8
    c78c:	a7 01       	movw	r20, r14
    c78e:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	lcd_printf(4, 1, PSTR("*)Cancel      #)Save"));
    c792:	84 e0       	ldi	r24, 0x04	; 4
    c794:	61 e0       	ldi	r22, 0x01	; 1
    c796:	44 ec       	ldi	r20, 0xC4	; 196
    c798:	5c e0       	ldi	r21, 0x0C	; 12
    c79a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>

	__i = 0;
	lcd_xy(__map[__i][0], __map[__i][1]);
    c79e:	8b 89       	ldd	r24, Y+19	; 0x13
    c7a0:	6c 89       	ldd	r22, Y+20	; 0x14
    c7a2:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
	CURSOR_SHOW;
    c7a6:	8f e0       	ldi	r24, 0x0F	; 15
    c7a8:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
    c7ac:	ee 24       	eor	r14, r14
    c7ae:	ff 24       	eor	r15, r15
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    c7b0:	68 01       	movw	r12, r16
	lcd_xy(__map[__i][0], __map[__i][1]);
	CURSOR_SHOW;

	while(1){
		
		__key = _key_scan(1);
    c7b2:	81 e0       	ldi	r24, 0x01	; 1
    c7b4:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    c7b8:	18 2f       	mov	r17, r24
		__chr = _key_btn(__key);
    c7ba:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
    c7be:	48 2f       	mov	r20, r24
		if(__chr >= 0x30 && __chr <= 0x39){
    c7c0:	80 53       	subi	r24, 0x30	; 48
    c7c2:	8a 30       	cpi	r24, 0x0A	; 10
    c7c4:	08 f0       	brcs	.+2      	; 0xc7c8 <_menu_datetime+0x148>
    c7c6:	72 c0       	rjmp	.+228    	; 0xc8ac <_menu_datetime+0x22c>
			if(__i == 0 || __i == 2 || __i == 6 || __i == 8 || __i == 10){
    c7c8:	e1 14       	cp	r14, r1
    c7ca:	f1 04       	cpc	r15, r1
    c7cc:	81 f0       	breq	.+32     	; 0xc7ee <_menu_datetime+0x16e>
    c7ce:	82 e0       	ldi	r24, 0x02	; 2
    c7d0:	e8 16       	cp	r14, r24
    c7d2:	f1 04       	cpc	r15, r1
    c7d4:	61 f0       	breq	.+24     	; 0xc7ee <_menu_datetime+0x16e>
    c7d6:	96 e0       	ldi	r25, 0x06	; 6
    c7d8:	e9 16       	cp	r14, r25
    c7da:	f1 04       	cpc	r15, r1
    c7dc:	41 f0       	breq	.+16     	; 0xc7ee <_menu_datetime+0x16e>
    c7de:	a8 e0       	ldi	r26, 0x08	; 8
    c7e0:	ea 16       	cp	r14, r26
    c7e2:	f1 04       	cpc	r15, r1
    c7e4:	21 f0       	breq	.+8      	; 0xc7ee <_menu_datetime+0x16e>
    c7e6:	ba e0       	ldi	r27, 0x0A	; 10
    c7e8:	eb 16       	cp	r14, r27
    c7ea:	f1 04       	cpc	r15, r1
    c7ec:	81 f4       	brne	.+32     	; 0xc80e <_menu_datetime+0x18e>
				if((__chr - 0x30) <= __map[__i][3])
    c7ee:	84 2f       	mov	r24, r20
    c7f0:	90 e0       	ldi	r25, 0x00	; 0
    c7f2:	c0 97       	sbiw	r24, 0x30	; 48
    c7f4:	f7 01       	movw	r30, r14
    c7f6:	ee 0f       	add	r30, r30
    c7f8:	ff 1f       	adc	r31, r31
    c7fa:	ee 0f       	add	r30, r30
    c7fc:	ff 1f       	adc	r31, r31
    c7fe:	ec 0d       	add	r30, r12
    c800:	fd 1d       	adc	r31, r13
    c802:	25 89       	ldd	r18, Z+21	; 0x15
    c804:	30 e0       	ldi	r19, 0x00	; 0
    c806:	28 17       	cp	r18, r24
    c808:	39 07       	cpc	r19, r25
    c80a:	84 f5       	brge	.+96     	; 0xc86c <_menu_datetime+0x1ec>
    c80c:	4f c0       	rjmp	.+158    	; 0xc8ac <_menu_datetime+0x22c>
					goto CETAK;
				else
					goto LEWAT;
			}
			if(__i == 1){
    c80e:	81 e0       	ldi	r24, 0x01	; 1
    c810:	e8 16       	cp	r14, r24
    c812:	f1 04       	cpc	r15, r1
    c814:	61 f4       	brne	.+24     	; 0xc82e <_menu_datetime+0x1ae>
				if((__map[0][2] - 0x30) < __map[0][3])
    c816:	2d 89       	ldd	r18, Y+21	; 0x15
    c818:	30 e0       	ldi	r19, 0x00	; 0
    c81a:	2f 52       	subi	r18, 0x2F	; 47
    c81c:	30 40       	sbci	r19, 0x00	; 0
    c81e:	8e 89       	ldd	r24, Y+22	; 0x16
    c820:	90 e0       	ldi	r25, 0x00	; 0
    c822:	82 17       	cp	r24, r18
    c824:	93 07       	cpc	r25, r19
    c826:	14 f5       	brge	.+68     	; 0xc86c <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[0][2] - 0x30) >= __map[0][3]){
					if(__chr < 0x32)
    c828:	42 33       	cpi	r20, 0x32	; 50
    c82a:	00 f1       	brcs	.+64     	; 0xc86c <_menu_datetime+0x1ec>
    c82c:	3f c0       	rjmp	.+126    	; 0xc8ac <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 3){
    c82e:	93 e0       	ldi	r25, 0x03	; 3
    c830:	e9 16       	cp	r14, r25
    c832:	f1 04       	cpc	r15, r1
    c834:	61 f4       	brne	.+24     	; 0xc84e <_menu_datetime+0x1ce>
				if((__map[2][2] - 0x30) < __map[2][3])
    c836:	2d 8d       	ldd	r18, Y+29	; 0x1d
    c838:	30 e0       	ldi	r19, 0x00	; 0
    c83a:	2f 52       	subi	r18, 0x2F	; 47
    c83c:	30 40       	sbci	r19, 0x00	; 0
    c83e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    c840:	90 e0       	ldi	r25, 0x00	; 0
    c842:	82 17       	cp	r24, r18
    c844:	93 07       	cpc	r25, r19
    c846:	94 f4       	brge	.+36     	; 0xc86c <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[2][2] - 0x30) >= __map[2][3]){
					if(__chr < 0x33)
    c848:	43 33       	cpi	r20, 0x33	; 51
    c84a:	80 f0       	brcs	.+32     	; 0xc86c <_menu_datetime+0x1ec>
    c84c:	2f c0       	rjmp	.+94     	; 0xc8ac <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 7){
    c84e:	a7 e0       	ldi	r26, 0x07	; 7
    c850:	ea 16       	cp	r14, r26
    c852:	f1 04       	cpc	r15, r1
    c854:	59 f4       	brne	.+22     	; 0xc86c <_menu_datetime+0x1ec>
				if((__map[6][2] - 0x30) < __map[6][3])
    c856:	2d a5       	ldd	r18, Y+45	; 0x2d
    c858:	30 e0       	ldi	r19, 0x00	; 0
    c85a:	2f 52       	subi	r18, 0x2F	; 47
    c85c:	30 40       	sbci	r19, 0x00	; 0
    c85e:	8e a5       	ldd	r24, Y+46	; 0x2e
    c860:	90 e0       	ldi	r25, 0x00	; 0
    c862:	82 17       	cp	r24, r18
    c864:	93 07       	cpc	r25, r19
    c866:	14 f4       	brge	.+4      	; 0xc86c <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[6][2] - 0x30) >= __map[6][3]){
					if(__chr < 0x34)
    c868:	44 33       	cpi	r20, 0x34	; 52
    c86a:	00 f5       	brcc	.+64     	; 0xc8ac <_menu_datetime+0x22c>
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    c86c:	f7 01       	movw	r30, r14
    c86e:	ee 0f       	add	r30, r30
    c870:	ff 1f       	adc	r31, r31
    c872:	ee 0f       	add	r30, r30
    c874:	ff 1f       	adc	r31, r31
    c876:	ec 0d       	add	r30, r12
    c878:	fd 1d       	adc	r31, r13
    c87a:	44 8b       	std	Z+20, r20	; 0x14
			_lcd(__chr);
    c87c:	84 2f       	mov	r24, r20
    c87e:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
			__i++;
    c882:	08 94       	sec
    c884:	e1 1c       	adc	r14, r1
    c886:	f1 1c       	adc	r15, r1
    c888:	bc e0       	ldi	r27, 0x0C	; 12
    c88a:	eb 16       	cp	r14, r27
    c88c:	f1 04       	cpc	r15, r1
    c88e:	1c f0       	brlt	.+6      	; 0xc896 <_menu_datetime+0x216>
    c890:	9b e0       	ldi	r25, 0x0B	; 11
    c892:	e9 2e       	mov	r14, r25
    c894:	f1 2c       	mov	r15, r1
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
    c896:	f7 01       	movw	r30, r14
    c898:	ee 0f       	add	r30, r30
    c89a:	ff 1f       	adc	r31, r31
    c89c:	ee 0f       	add	r30, r30
    c89e:	ff 1f       	adc	r31, r31
    c8a0:	ec 0d       	add	r30, r12
    c8a2:	fd 1d       	adc	r31, r13
    c8a4:	82 89       	ldd	r24, Z+18	; 0x12
    c8a6:	63 89       	ldd	r22, Z+19	; 0x13
    c8a8:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
LEWAT:		;
		}
		if(__key == _KEY_SHIFT){
    c8ac:	1b 37       	cpi	r17, 0x7B	; 123
    c8ae:	59 f4       	brne	.+22     	; 0xc8c6 <_menu_datetime+0x246>
			__i++;
    c8b0:	08 94       	sec
    c8b2:	e1 1c       	adc	r14, r1
    c8b4:	f1 1c       	adc	r15, r1
    c8b6:	8c e0       	ldi	r24, 0x0C	; 12
    c8b8:	e8 16       	cp	r14, r24
    c8ba:	f1 04       	cpc	r15, r1
    c8bc:	6c f0       	brlt	.+26     	; 0xc8d8 <_menu_datetime+0x258>
    c8be:	0b e0       	ldi	r16, 0x0B	; 11
    c8c0:	e0 2e       	mov	r14, r16
    c8c2:	f1 2c       	mov	r15, r1
    c8c4:	09 c0       	rjmp	.+18     	; 0xc8d8 <_menu_datetime+0x258>
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CLEAR){
    c8c6:	17 37       	cpi	r17, 0x77	; 119
    c8c8:	99 f4       	brne	.+38     	; 0xc8f0 <_menu_datetime+0x270>
			__i--;
    c8ca:	08 94       	sec
    c8cc:	e1 08       	sbc	r14, r1
    c8ce:	f1 08       	sbc	r15, r1
    c8d0:	f7 fe       	sbrs	r15, 7
    c8d2:	02 c0       	rjmp	.+4      	; 0xc8d8 <_menu_datetime+0x258>
    c8d4:	ee 24       	eor	r14, r14
    c8d6:	ff 24       	eor	r15, r15
			if(__i <= 0)
				__i = 0;
			lcd_xy(__map[__i][0], __map[__i][1]);
    c8d8:	f7 01       	movw	r30, r14
    c8da:	ee 0f       	add	r30, r30
    c8dc:	ff 1f       	adc	r31, r31
    c8de:	ee 0f       	add	r30, r30
    c8e0:	ff 1f       	adc	r31, r31
    c8e2:	ec 0d       	add	r30, r12
    c8e4:	fd 1d       	adc	r31, r13
    c8e6:	82 89       	ldd	r24, Z+18	; 0x12
    c8e8:	63 89       	ldd	r22, Z+19	; 0x13
    c8ea:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
    c8ee:	61 cf       	rjmp	.-318    	; 0xc7b2 <_menu_datetime+0x132>
		}
		if(__key == _KEY_CANCEL)
    c8f0:	17 3e       	cpi	r17, 0xE7	; 231
    c8f2:	09 f4       	brne	.+2      	; 0xc8f6 <_menu_datetime+0x276>
    c8f4:	49 c0       	rjmp	.+146    	; 0xc988 <_menu_datetime+0x308>
			break;
		if(__key == _KEY_ENTER){
    c8f6:	17 3b       	cpi	r17, 0xB7	; 183
    c8f8:	09 f0       	breq	.+2      	; 0xc8fc <_menu_datetime+0x27c>
    c8fa:	5b cf       	rjmp	.-330    	; 0xc7b2 <_menu_datetime+0x132>
    c8fc:	20 e0       	ldi	r18, 0x00	; 0
    c8fe:	30 e0       	ldi	r19, 0x00	; 0
    c900:	40 e0       	ldi	r20, 0x00	; 0
    c902:	50 e0       	ldi	r21, 0x00	; 0
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
    c904:	be 01       	movw	r22, r28
    c906:	6f 5f       	subi	r22, 0xFF	; 255
    c908:	7f 4f       	sbci	r23, 0xFF	; 255
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
    c90a:	22 30       	cpi	r18, 0x02	; 2
    c90c:	31 05       	cpc	r19, r1
    c90e:	19 f0       	breq	.+6      	; 0xc916 <_menu_datetime+0x296>
    c910:	24 30       	cpi	r18, 0x04	; 4
    c912:	31 05       	cpc	r19, r1
    c914:	11 f4       	brne	.+4      	; 0xc91a <_menu_datetime+0x29a>
					__ii++;
    c916:	4f 5f       	subi	r20, 0xFF	; 255
    c918:	5f 4f       	sbci	r21, 0xFF	; 255
				__date[__ii] = __map[__i][2];
    c91a:	fb 01       	movw	r30, r22
    c91c:	e4 0f       	add	r30, r20
    c91e:	f5 1f       	adc	r31, r21
    c920:	d4 01       	movw	r26, r8
    c922:	8c 91       	ld	r24, X
    c924:	80 83       	st	Z, r24
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    c926:	2f 5f       	subi	r18, 0xFF	; 255
    c928:	3f 4f       	sbci	r19, 0xFF	; 255
    c92a:	84 e0       	ldi	r24, 0x04	; 4
    c92c:	90 e0       	ldi	r25, 0x00	; 0
    c92e:	88 0e       	add	r8, r24
    c930:	99 1e       	adc	r9, r25
    c932:	26 30       	cpi	r18, 0x06	; 6
    c934:	31 05       	cpc	r19, r1
    c936:	19 f0       	breq	.+6      	; 0xc93e <_menu_datetime+0x2be>
    c938:	4f 5f       	subi	r20, 0xFF	; 255
    c93a:	5f 4f       	sbci	r21, 0xFF	; 255
    c93c:	e6 cf       	rjmp	.-52     	; 0xc90a <_menu_datetime+0x28a>
    c93e:	60 e0       	ldi	r22, 0x00	; 0
    c940:	70 e0       	ldi	r23, 0x00	; 0
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
    c942:	ae 01       	movw	r20, r28
    c944:	46 5f       	subi	r20, 0xF6	; 246
    c946:	5f 4f       	sbci	r21, 0xFF	; 255
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
    c948:	28 30       	cpi	r18, 0x08	; 8
    c94a:	31 05       	cpc	r19, r1
    c94c:	19 f0       	breq	.+6      	; 0xc954 <_menu_datetime+0x2d4>
    c94e:	2a 30       	cpi	r18, 0x0A	; 10
    c950:	31 05       	cpc	r19, r1
    c952:	11 f4       	brne	.+4      	; 0xc958 <_menu_datetime+0x2d8>
					__ii++;
    c954:	6f 5f       	subi	r22, 0xFF	; 255
    c956:	7f 4f       	sbci	r23, 0xFF	; 255
				__time[__ii] = __map[__i][2];
    c958:	fa 01       	movw	r30, r20
    c95a:	e6 0f       	add	r30, r22
    c95c:	f7 1f       	adc	r31, r23
    c95e:	d5 01       	movw	r26, r10
    c960:	8c 91       	ld	r24, X
    c962:	80 83       	st	Z, r24
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    c964:	2f 5f       	subi	r18, 0xFF	; 255
    c966:	3f 4f       	sbci	r19, 0xFF	; 255
    c968:	84 e0       	ldi	r24, 0x04	; 4
    c96a:	90 e0       	ldi	r25, 0x00	; 0
    c96c:	a8 0e       	add	r10, r24
    c96e:	b9 1e       	adc	r11, r25
    c970:	2c 30       	cpi	r18, 0x0C	; 12
    c972:	31 05       	cpc	r19, r1
    c974:	19 f0       	breq	.+6      	; 0xc97c <_menu_datetime+0x2fc>
    c976:	6f 5f       	subi	r22, 0xFF	; 255
    c978:	7f 4f       	sbci	r23, 0xFF	; 255
    c97a:	e6 cf       	rjmp	.-52     	; 0xc948 <_menu_datetime+0x2c8>
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
			}
			_datetime(_DATETIME_WRITE, __date, __time);
    c97c:	81 e0       	ldi	r24, 0x01	; 1
    c97e:	be 01       	movw	r22, r28
    c980:	6f 5f       	subi	r22, 0xFF	; 255
    c982:	7f 4f       	sbci	r23, 0xFF	; 255
    c984:	0e 94 fa b1 	call	0x163f4	; 0x163f4 <_datetime>
			break;
		}
	}
	CURSOR_HIDE;
    c988:	8c e0       	ldi	r24, 0x0C	; 12
    c98a:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
}
    c98e:	ce 5b       	subi	r28, 0xBE	; 190
    c990:	df 4f       	sbci	r29, 0xFF	; 255
    c992:	0f b6       	in	r0, 0x3f	; 63
    c994:	f8 94       	cli
    c996:	de bf       	out	0x3e, r29	; 62
    c998:	0f be       	out	0x3f, r0	; 63
    c99a:	cd bf       	out	0x3d, r28	; 61
    c99c:	cf 91       	pop	r28
    c99e:	df 91       	pop	r29
    c9a0:	1f 91       	pop	r17
    c9a2:	0f 91       	pop	r16
    c9a4:	ff 90       	pop	r15
    c9a6:	ef 90       	pop	r14
    c9a8:	df 90       	pop	r13
    c9aa:	cf 90       	pop	r12
    c9ac:	bf 90       	pop	r11
    c9ae:	af 90       	pop	r10
    c9b0:	9f 90       	pop	r9
    c9b2:	8f 90       	pop	r8
    c9b4:	08 95       	ret

0000c9b6 <FSettingDatetime>:
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
    c9b6:	0e 94 40 63 	call	0xc680	; 0xc680 <_menu_datetime>
     return MENU_DONE;
}
    c9ba:	81 e0       	ldi	r24, 0x01	; 1
    c9bc:	08 95       	ret

0000c9be <menu_FIP>:
	 }
  return Result;
}


char menu_FIP(char *xFIP,char *sFIPUsed){
    c9be:	6f 92       	push	r6
    c9c0:	7f 92       	push	r7
    c9c2:	8f 92       	push	r8
    c9c4:	9f 92       	push	r9
    c9c6:	af 92       	push	r10
    c9c8:	bf 92       	push	r11
    c9ca:	cf 92       	push	r12
    c9cc:	df 92       	push	r13
    c9ce:	ef 92       	push	r14
    c9d0:	ff 92       	push	r15
    c9d2:	0f 93       	push	r16
    c9d4:	1f 93       	push	r17
    c9d6:	df 93       	push	r29
    c9d8:	cf 93       	push	r28
    c9da:	cd b7       	in	r28, 0x3d	; 61
    c9dc:	de b7       	in	r29, 0x3e	; 62
    c9de:	a2 97       	sbiw	r28, 0x22	; 34
    c9e0:	0f b6       	in	r0, 0x3f	; 63
    c9e2:	f8 94       	cli
    c9e4:	de bf       	out	0x3e, r29	; 62
    c9e6:	0f be       	out	0x3f, r0	; 63
    c9e8:	cd bf       	out	0x3d, r28	; 61
    c9ea:	7c 01       	movw	r14, r24
    c9ec:	8b 01       	movw	r16, r22
       char Result=FIP_NONE;
       char FIP[8],strPumpL[3],strPumpR[3],lcdteks[20];
static char KeyPressed=0,KeyChar,KeyCharLast=' ',FIP_Used=0;
static unsigned int iLoop;

       switch(stEnterFIP){
    c9ee:	80 91 73 03 	lds	r24, 0x0373
    c9f2:	81 30       	cpi	r24, 0x01	; 1
    c9f4:	09 f4       	brne	.+2      	; 0xc9f8 <menu_FIP+0x3a>
    c9f6:	b5 c0       	rjmp	.+362    	; 0xcb62 <menu_FIP+0x1a4>
    c9f8:	81 30       	cpi	r24, 0x01	; 1
    c9fa:	20 f0       	brcs	.+8      	; 0xca04 <menu_FIP+0x46>
    c9fc:	82 30       	cpi	r24, 0x02	; 2
    c9fe:	09 f0       	breq	.+2      	; 0xca02 <menu_FIP+0x44>
    ca00:	23 c1       	rjmp	.+582    	; 0xcc48 <menu_FIP+0x28a>
    ca02:	20 c1       	rjmp	.+576    	; 0xcc44 <menu_FIP+0x286>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    ca04:	8e 01       	movw	r16, r28
    ca06:	09 5f       	subi	r16, 0xF9	; 249
    ca08:	1f 4f       	sbci	r17, 0xFF	; 255
    ca0a:	c8 01       	movw	r24, r16
    ca0c:	65 e4       	ldi	r22, 0x45	; 69
    ca0e:	70 e0       	ldi	r23, 0x00	; 0
    ca10:	48 e0       	ldi	r20, 0x08	; 8
    ca12:	50 e0       	ldi	r21, 0x00	; 0
    ca14:	2c ea       	ldi	r18, 0xAC	; 172
    ca16:	32 e1       	ldi	r19, 0x12	; 18
    ca18:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
    ca1c:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    ca20:	f8 01       	movw	r30, r16
    ca22:	20 e0       	ldi	r18, 0x00	; 0
    ca24:	30 e0       	ldi	r19, 0x00	; 0
    ca26:	07 c0       	rjmp	.+14     	; 0xca36 <menu_FIP+0x78>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
    ca28:	80 81       	ld	r24, Z
    ca2a:	84 36       	cpi	r24, 0x64	; 100
    ca2c:	08 f0       	brcs	.+2      	; 0xca30 <menu_FIP+0x72>
    ca2e:	10 82       	st	Z, r1
    ca30:	2f 5f       	subi	r18, 0xFF	; 255
    ca32:	3f 4f       	sbci	r19, 0xFF	; 255
    ca34:	31 96       	adiw	r30, 0x01	; 1

       switch(stEnterFIP){
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
    ca36:	28 30       	cpi	r18, 0x08	; 8
    ca38:	31 05       	cpc	r19, r1
    ca3a:	b0 f3       	brcs	.-20     	; 0xca28 <menu_FIP+0x6a>
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    ca3c:	10 92 6f 03 	sts	0x036F, r1
    ca40:	10 92 6e 03 	sts	0x036E, r1
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
    ca44:	17 e0       	ldi	r17, 0x07	; 7
    ca46:	61 2e       	mov	r6, r17
    ca48:	71 2c       	mov	r7, r1
    ca4a:	6c 0e       	add	r6, r28
    ca4c:	7d 1e       	adc	r7, r29
    ca4e:	6e 01       	movw	r12, r28
    ca50:	08 94       	sec
    ca52:	c1 1c       	adc	r12, r1
    ca54:	d1 1c       	adc	r13, r1
    ca56:	bb e0       	ldi	r27, 0x0B	; 11
    ca58:	8b 2e       	mov	r8, r27
    ca5a:	91 2c       	mov	r9, r1
    ca5c:	8c 0e       	add	r8, r28
    ca5e:	9d 1e       	adc	r9, r29
    ca60:	a4 e0       	ldi	r26, 0x04	; 4
    ca62:	ea 2e       	mov	r14, r26
    ca64:	f1 2c       	mov	r15, r1
    ca66:	ec 0e       	add	r14, r28
    ca68:	fd 1e       	adc	r15, r29
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    ca6a:	8e 01       	movw	r16, r28
    ca6c:	01 5f       	subi	r16, 0xF1	; 241
    ca6e:	1f 4f       	sbci	r17, 0xFF	; 255
    ca70:	f2 e1       	ldi	r31, 0x12	; 18
    ca72:	af 2e       	mov	r10, r31
    ca74:	fb e1       	ldi	r31, 0x1B	; 27
    ca76:	bf 2e       	mov	r11, r31
    ca78:	4e c0       	rjmp	.+156    	; 0xcb16 <menu_FIP+0x158>
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
    ca7a:	e6 0d       	add	r30, r6
    ca7c:	f7 1d       	adc	r31, r7
    ca7e:	80 81       	ld	r24, Z
    ca80:	90 e0       	ldi	r25, 0x00	; 0
    ca82:	b6 01       	movw	r22, r12
    ca84:	0e 94 80 1a 	call	0x3500	; 0x3500 <leadingZero>
    ca88:	e0 91 6e 03 	lds	r30, 0x036E
    ca8c:	f0 91 6f 03 	lds	r31, 0x036F
    ca90:	e8 0d       	add	r30, r8
    ca92:	f9 1d       	adc	r31, r9
    ca94:	80 81       	ld	r24, Z
    ca96:	90 e0       	ldi	r25, 0x00	; 0
    ca98:	b7 01       	movw	r22, r14
    ca9a:	0e 94 80 1a 	call	0x3500	; 0x3500 <leadingZero>
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    ca9e:	80 91 6e 03 	lds	r24, 0x036E
    caa2:	90 91 6f 03 	lds	r25, 0x036F
    caa6:	2d b7       	in	r18, 0x3d	; 61
    caa8:	3e b7       	in	r19, 0x3e	; 62
    caaa:	2c 50       	subi	r18, 0x0C	; 12
    caac:	30 40       	sbci	r19, 0x00	; 0
    caae:	0f b6       	in	r0, 0x3f	; 63
    cab0:	f8 94       	cli
    cab2:	3e bf       	out	0x3e, r19	; 62
    cab4:	0f be       	out	0x3f, r0	; 63
    cab6:	2d bf       	out	0x3d, r18	; 61
    cab8:	ed b7       	in	r30, 0x3d	; 61
    caba:	fe b7       	in	r31, 0x3e	; 62
    cabc:	31 96       	adiw	r30, 0x01	; 1
    cabe:	ad b7       	in	r26, 0x3d	; 61
    cac0:	be b7       	in	r27, 0x3e	; 62
    cac2:	12 96       	adiw	r26, 0x02	; 2
    cac4:	1c 93       	st	X, r17
    cac6:	0e 93       	st	-X, r16
    cac8:	11 97       	sbiw	r26, 0x01	; 1
    caca:	b3 82       	std	Z+3, r11	; 0x03
    cacc:	a2 82       	std	Z+2, r10	; 0x02
    cace:	01 96       	adiw	r24, 0x01	; 1
    cad0:	95 83       	std	Z+5, r25	; 0x05
    cad2:	84 83       	std	Z+4, r24	; 0x04
    cad4:	d7 82       	std	Z+7, r13	; 0x07
    cad6:	c6 82       	std	Z+6, r12	; 0x06
    cad8:	04 96       	adiw	r24, 0x04	; 4
    cada:	91 87       	std	Z+9, r25	; 0x09
    cadc:	80 87       	std	Z+8, r24	; 0x08
    cade:	f3 86       	std	Z+11, r15	; 0x0b
    cae0:	e2 86       	std	Z+10, r14	; 0x0a
    cae2:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
                //sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
			    lcd_print((iLoop+1),1,lcdteks);
    cae6:	ed b7       	in	r30, 0x3d	; 61
    cae8:	fe b7       	in	r31, 0x3e	; 62
    caea:	3c 96       	adiw	r30, 0x0c	; 12
    caec:	0f b6       	in	r0, 0x3f	; 63
    caee:	f8 94       	cli
    caf0:	fe bf       	out	0x3e, r31	; 62
    caf2:	0f be       	out	0x3f, r0	; 63
    caf4:	ed bf       	out	0x3d, r30	; 61
    caf6:	80 91 6e 03 	lds	r24, 0x036E
    cafa:	8f 5f       	subi	r24, 0xFF	; 255
    cafc:	61 e0       	ldi	r22, 0x01	; 1
    cafe:	a8 01       	movw	r20, r16
    cb00:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    cb04:	80 91 6e 03 	lds	r24, 0x036E
    cb08:	90 91 6f 03 	lds	r25, 0x036F
    cb0c:	01 96       	adiw	r24, 0x01	; 1
    cb0e:	90 93 6f 03 	sts	0x036F, r25
    cb12:	80 93 6e 03 	sts	0x036E, r24
    cb16:	e0 91 6e 03 	lds	r30, 0x036E
    cb1a:	f0 91 6f 03 	lds	r31, 0x036F
    cb1e:	e4 30       	cpi	r30, 0x04	; 4
    cb20:	f1 05       	cpc	r31, r1
    cb22:	08 f4       	brcc	.+2      	; 0xcb26 <menu_FIP+0x168>
    cb24:	aa cf       	rjmp	.-172    	; 0xca7a <menu_FIP+0xbc>
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
                //sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
			    lcd_print((iLoop+1),1,lcdteks);
			}
		    lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
    cb26:	81 e0       	ldi	r24, 0x01	; 1
    cb28:	6f e0       	ldi	r22, 0x0F	; 15
    cb2a:	4c e0       	ldi	r20, 0x0C	; 12
    cb2c:	5b e1       	ldi	r21, 0x1B	; 27
    cb2e:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		    lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
    cb32:	82 e0       	ldi	r24, 0x02	; 2
    cb34:	6f e0       	ldi	r22, 0x0F	; 15
    cb36:	46 e0       	ldi	r20, 0x06	; 6
    cb38:	5b e1       	ldi	r21, 0x1B	; 27
    cb3a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		    lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
    cb3e:	83 e0       	ldi	r24, 0x03	; 3
    cb40:	6f e0       	ldi	r22, 0x0F	; 15
    cb42:	40 e0       	ldi	r20, 0x00	; 0
    cb44:	5b e1       	ldi	r21, 0x1B	; 27
    cb46:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	        lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
    cb4a:	84 e0       	ldi	r24, 0x04	; 4
    cb4c:	6f e0       	ldi	r22, 0x0F	; 15
    cb4e:	49 ef       	ldi	r20, 0xF9	; 249
    cb50:	5a e1       	ldi	r21, 0x1A	; 26
    cb52:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		    iLoop=0;
    cb56:	10 92 6f 03 	sts	0x036F, r1
    cb5a:	10 92 6e 03 	sts	0x036E, r1
		    stEnterFIP=efFIPInput;
    cb5e:	81 e0       	ldi	r24, 0x01	; 1
    cb60:	6e c0       	rjmp	.+220    	; 0xcc3e <menu_FIP+0x280>
	        break;
	   case efFIPInput:
		    iLoop++;
    cb62:	80 91 6e 03 	lds	r24, 0x036E
    cb66:	90 91 6f 03 	lds	r25, 0x036F
    cb6a:	01 96       	adiw	r24, 0x01	; 1
    cb6c:	90 93 6f 03 	sts	0x036F, r25
    cb70:	80 93 6e 03 	sts	0x036E, r24
		    KeyPressed=_key_scan(1);
    cb74:	81 e0       	ldi	r24, 0x01	; 1
    cb76:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    cb7a:	80 93 72 03 	sts	0x0372, r24
		    KeyChar=_key_btn(KeyPressed);
    cb7e:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
    cb82:	98 2f       	mov	r25, r24
    cb84:	80 93 71 03 	sts	0x0371, r24
		    if ((KeyChar>='1')&&(KeyChar<='8')){
    cb88:	81 53       	subi	r24, 0x31	; 49
    cb8a:	88 30       	cpi	r24, 0x08	; 8
    cb8c:	60 f4       	brcc	.+24     	; 0xcba6 <menu_FIP+0x1e8>
		 	     if (KeyCharLast!=KeyChar){
    cb8e:	80 91 6f 01 	lds	r24, 0x016F
    cb92:	89 17       	cp	r24, r25
    cb94:	41 f0       	breq	.+16     	; 0xcba6 <menu_FIP+0x1e8>
				     KeyCharLast=KeyChar;
    cb96:	90 93 6f 01 	sts	0x016F, r25
				     iLoop=1000;
    cb9a:	88 ee       	ldi	r24, 0xE8	; 232
    cb9c:	93 e0       	ldi	r25, 0x03	; 3
    cb9e:	90 93 6f 03 	sts	0x036F, r25
    cba2:	80 93 6e 03 	sts	0x036E, r24
                 }
		    }
 		    if ((iLoop%2000)==0){
    cba6:	80 91 6e 03 	lds	r24, 0x036E
    cbaa:	90 91 6f 03 	lds	r25, 0x036F
    cbae:	60 ed       	ldi	r22, 0xD0	; 208
    cbb0:	77 e0       	ldi	r23, 0x07	; 7
    cbb2:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
    cbb6:	89 2b       	or	r24, r25
    cbb8:	39 f4       	brne	.+14     	; 0xcbc8 <menu_FIP+0x20a>
		        lcd_xy(1,19);_lcd('_'); 
    cbba:	81 e0       	ldi	r24, 0x01	; 1
    cbbc:	63 e1       	ldi	r22, 0x13	; 19
    cbbe:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
    cbc2:	8f e5       	ldi	r24, 0x5F	; 95
    cbc4:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
			   }
           if ((iLoop%2000)==1000){
    cbc8:	80 91 6e 03 	lds	r24, 0x036E
    cbcc:	90 91 6f 03 	lds	r25, 0x036F
    cbd0:	60 ed       	ldi	r22, 0xD0	; 208
    cbd2:	77 e0       	ldi	r23, 0x07	; 7
    cbd4:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
    cbd8:	88 5e       	subi	r24, 0xE8	; 232
    cbda:	93 40       	sbci	r25, 0x03	; 3
    cbdc:	41 f4       	brne	.+16     	; 0xcbee <menu_FIP+0x230>
			    lcd_xy(1,19);_lcd(KeyCharLast); 
    cbde:	81 e0       	ldi	r24, 0x01	; 1
    cbe0:	63 e1       	ldi	r22, 0x13	; 19
    cbe2:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
    cbe6:	80 91 6f 01 	lds	r24, 0x016F
    cbea:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
			   }

		   if (((KeyChar>='1')&&(KeyChar<='8'))||(KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')){ 
    cbee:	80 91 71 03 	lds	r24, 0x0371
    cbf2:	81 53       	subi	r24, 0x31	; 49
    cbf4:	88 30       	cpi	r24, 0x08	; 8
    cbf6:	40 f0       	brcs	.+16     	; 0xcc08 <menu_FIP+0x24a>
    cbf8:	80 91 72 03 	lds	r24, 0x0372
    cbfc:	87 3b       	cpi	r24, 0xB7	; 183
    cbfe:	e1 f4       	brne	.+56     	; 0xcc38 <menu_FIP+0x27a>
    cc00:	80 91 6f 01 	lds	r24, 0x016F
    cc04:	80 32       	cpi	r24, 0x20	; 32
    cc06:	01 f1       	breq	.+64     	; 0xcc48 <menu_FIP+0x28a>
		         FIP_Used=FIP[KeyCharLast-'1'];
    cc08:	80 91 6f 01 	lds	r24, 0x016F
    cc0c:	fe 01       	movw	r30, r28
    cc0e:	ba 97       	sbiw	r30, 0x2a	; 42
    cc10:	e8 0f       	add	r30, r24
    cc12:	f1 1d       	adc	r31, r1
    cc14:	80 81       	ld	r24, Z
    cc16:	80 93 70 03 	sts	0x0370, r24
				 if (FIP_Used<=99){
    cc1a:	84 36       	cpi	r24, 0x64	; 100
    cc1c:	40 f4       	brcc	.+16     	; 0xcc2e <menu_FIP+0x270>
                    leadingZero(FIP_Used,sFIPUsed);
    cc1e:	90 e0       	ldi	r25, 0x00	; 0
    cc20:	b8 01       	movw	r22, r16
    cc22:	0e 94 80 1a 	call	0x3500	; 0x3500 <leadingZero>
					 //sprintf_P(sFIPUsed,PSTR("%.2d"),FIP_Used);
					 xFIP[0]=FIP_Used;
    cc26:	80 91 70 03 	lds	r24, 0x0370
    cc2a:	d7 01       	movw	r26, r14
    cc2c:	8c 93       	st	X, r24
					 }
				 Result=FIP_DONE;
                 stEnterFIP=efExitFIPInput;
    cc2e:	82 e0       	ldi	r24, 0x02	; 2
    cc30:	80 93 73 03 	sts	0x0373, r24
    cc34:	80 e0       	ldi	r24, 0x00	; 0
    cc36:	09 c0       	rjmp	.+18     	; 0xcc4a <menu_FIP+0x28c>
		   }
		   else
		   if (KeyPressed==_KEY_CANCEL){
    cc38:	87 3e       	cpi	r24, 0xE7	; 231
    cc3a:	31 f4       	brne	.+12     	; 0xcc48 <menu_FIP+0x28a>
               Result=FIP_CANCEL;
			   stEnterFIP=efExitFIPInput;
    cc3c:	82 e0       	ldi	r24, 0x02	; 2
    cc3e:	80 93 73 03 	sts	0x0373, r24
    cc42:	03 c0       	rjmp	.+6      	; 0xcc4a <menu_FIP+0x28c>
		   }
	       break;
      case efExitFIPInput:
           stEnterFIP=efInit;
    cc44:	10 92 73 03 	sts	0x0373, r1
    cc48:	81 e0       	ldi	r24, 0x01	; 1
	       break;
	 }
return Result;
}
    cc4a:	a2 96       	adiw	r28, 0x22	; 34
    cc4c:	0f b6       	in	r0, 0x3f	; 63
    cc4e:	f8 94       	cli
    cc50:	de bf       	out	0x3e, r29	; 62
    cc52:	0f be       	out	0x3f, r0	; 63
    cc54:	cd bf       	out	0x3d, r28	; 61
    cc56:	cf 91       	pop	r28
    cc58:	df 91       	pop	r29
    cc5a:	1f 91       	pop	r17
    cc5c:	0f 91       	pop	r16
    cc5e:	ff 90       	pop	r15
    cc60:	ef 90       	pop	r14
    cc62:	df 90       	pop	r13
    cc64:	cf 90       	pop	r12
    cc66:	bf 90       	pop	r11
    cc68:	af 90       	pop	r10
    cc6a:	9f 90       	pop	r9
    cc6c:	8f 90       	pop	r8
    cc6e:	7f 90       	pop	r7
    cc70:	6f 90       	pop	r6
    cc72:	08 95       	ret

0000cc74 <FMenuEDCTransaction>:
	      break;
	 }
	 return Result;
}

char FMenuEDCTransaction(){
    cc74:	0f 93       	push	r16
    cc76:	1f 93       	push	r17
static char KeyPressed=0,FIP_Used=0,FIPResult;
       char lcdteks[20],Result=MENU_NONE;
static unsigned int iLoop=0;

Result=MENU_NONE;
	 switch(stEtransaction){
    cc78:	80 91 66 03 	lds	r24, 0x0366
    cc7c:	85 30       	cpi	r24, 0x05	; 5
    cc7e:	09 f4       	brne	.+2      	; 0xcc82 <FMenuEDCTransaction+0xe>
    cc80:	9f c0       	rjmp	.+318    	; 0xcdc0 <FMenuEDCTransaction+0x14c>
    cc82:	86 30       	cpi	r24, 0x06	; 6
    cc84:	90 f4       	brcc	.+36     	; 0xccaa <FMenuEDCTransaction+0x36>
    cc86:	82 30       	cpi	r24, 0x02	; 2
    cc88:	09 f4       	brne	.+2      	; 0xcc8c <FMenuEDCTransaction+0x18>
    cc8a:	57 c0       	rjmp	.+174    	; 0xcd3a <FMenuEDCTransaction+0xc6>
    cc8c:	83 30       	cpi	r24, 0x03	; 3
    cc8e:	30 f4       	brcc	.+12     	; 0xcc9c <FMenuEDCTransaction+0x28>
    cc90:	88 23       	and	r24, r24
    cc92:	f1 f0       	breq	.+60     	; 0xccd0 <FMenuEDCTransaction+0x5c>
    cc94:	81 30       	cpi	r24, 0x01	; 1
    cc96:	09 f0       	breq	.+2      	; 0xcc9a <FMenuEDCTransaction+0x26>
    cc98:	dd c0       	rjmp	.+442    	; 0xce54 <FMenuEDCTransaction+0x1e0>
    cc9a:	36 c0       	rjmp	.+108    	; 0xcd08 <FMenuEDCTransaction+0x94>
    cc9c:	83 30       	cpi	r24, 0x03	; 3
    cc9e:	09 f4       	brne	.+2      	; 0xcca2 <FMenuEDCTransaction+0x2e>
    cca0:	5e c0       	rjmp	.+188    	; 0xcd5e <FMenuEDCTransaction+0xea>
    cca2:	84 30       	cpi	r24, 0x04	; 4
    cca4:	09 f0       	breq	.+2      	; 0xcca8 <FMenuEDCTransaction+0x34>
    cca6:	d6 c0       	rjmp	.+428    	; 0xce54 <FMenuEDCTransaction+0x1e0>
    cca8:	83 c0       	rjmp	.+262    	; 0xcdb0 <FMenuEDCTransaction+0x13c>
    ccaa:	88 30       	cpi	r24, 0x08	; 8
    ccac:	09 f4       	brne	.+2      	; 0xccb0 <FMenuEDCTransaction+0x3c>
    ccae:	c2 c0       	rjmp	.+388    	; 0xce34 <FMenuEDCTransaction+0x1c0>
    ccb0:	89 30       	cpi	r24, 0x09	; 9
    ccb2:	38 f4       	brcc	.+14     	; 0xccc2 <FMenuEDCTransaction+0x4e>
    ccb4:	86 30       	cpi	r24, 0x06	; 6
    ccb6:	09 f4       	brne	.+2      	; 0xccba <FMenuEDCTransaction+0x46>
    ccb8:	98 c0       	rjmp	.+304    	; 0xcdea <FMenuEDCTransaction+0x176>
    ccba:	87 30       	cpi	r24, 0x07	; 7
    ccbc:	09 f0       	breq	.+2      	; 0xccc0 <FMenuEDCTransaction+0x4c>
    ccbe:	ca c0       	rjmp	.+404    	; 0xce54 <FMenuEDCTransaction+0x1e0>
    ccc0:	96 c0       	rjmp	.+300    	; 0xcdee <FMenuEDCTransaction+0x17a>
    ccc2:	89 30       	cpi	r24, 0x09	; 9
    ccc4:	09 f4       	brne	.+2      	; 0xccc8 <FMenuEDCTransaction+0x54>
    ccc6:	bc c0       	rjmp	.+376    	; 0xce40 <FMenuEDCTransaction+0x1cc>
    ccc8:	8a 30       	cpi	r24, 0x0A	; 10
    ccca:	09 f0       	breq	.+2      	; 0xccce <FMenuEDCTransaction+0x5a>
    cccc:	c3 c0       	rjmp	.+390    	; 0xce54 <FMenuEDCTransaction+0x1e0>
    ccce:	be c0       	rjmp	.+380    	; 0xce4c <FMenuEDCTransaction+0x1d8>
	 case etInit:
	      lcd_clear();
    ccd0:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Card Type"));
    ccd4:	81 e0       	ldi	r24, 0x01	; 1
    ccd6:	61 e0       	ldi	r22, 0x01	; 1
    ccd8:	42 e9       	ldi	r20, 0x92	; 146
    ccda:	59 e1       	ldi	r21, 0x19	; 25
    ccdc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
          lcd_printf(1,1,PSTR("1.Debit/Flash Card  "));
    cce0:	81 e0       	ldi	r24, 0x01	; 1
    cce2:	61 e0       	ldi	r22, 0x01	; 1
    cce4:	4d e7       	ldi	r20, 0x7D	; 125
    cce6:	59 e1       	ldi	r21, 0x19	; 25
    cce8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Credit Card       "));
    ccec:	82 e0       	ldi	r24, 0x02	; 2
    ccee:	61 e0       	ldi	r22, 0x01	; 1
    ccf0:	48 e6       	ldi	r20, 0x68	; 104
    ccf2:	59 e1       	ldi	r21, 0x19	; 25
    ccf4:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
    ccf8:	84 e0       	ldi	r24, 0x04	; 4
    ccfa:	61 e0       	ldi	r22, 0x01	; 1
    ccfc:	43 e5       	ldi	r20, 0x53	; 83
    ccfe:	59 e1       	ldi	r21, 0x19	; 25
    cd00:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  stEtransaction=etInputEDC;
    cd04:	81 e0       	ldi	r24, 0x01	; 1
    cd06:	6e c0       	rjmp	.+220    	; 0xcde4 <FMenuEDCTransaction+0x170>
	      break;
     case etInputEDC:
	 	  KeyPressed=_key_scan(1);
    cd08:	81 e0       	ldi	r24, 0x01	; 1
    cd0a:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    cd0e:	80 93 64 03 	sts	0x0364, r24
		  KeyChar=_key_btn(KeyPressed);
    cd12:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
    cd16:	98 2f       	mov	r25, r24
    cd18:	80 93 65 03 	sts	0x0365, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
    cd1c:	81 53       	subi	r24, 0x31	; 49
    cd1e:	82 30       	cpi	r24, 0x02	; 2
    cd20:	30 f4       	brcc	.+12     	; 0xcd2e <FMenuEDCTransaction+0xba>
		       EDCType=KeyChar-'0';
    cd22:	90 53       	subi	r25, 0x30	; 48
    cd24:	90 93 3c 0a 	sts	0x0A3C, r25
		       stEtransaction=etSelectFIP;
    cd28:	82 e0       	ldi	r24, 0x02	; 2
    cd2a:	80 93 66 03 	sts	0x0366, r24
		     }
		  if (KeyPressed==_KEY_CANCEL)stEtransaction=etExitEDCTransaction;
    cd2e:	80 91 64 03 	lds	r24, 0x0364
    cd32:	87 3e       	cpi	r24, 0xE7	; 231
    cd34:	09 f0       	breq	.+2      	; 0xcd38 <FMenuEDCTransaction+0xc4>
    cd36:	8e c0       	rjmp	.+284    	; 0xce54 <FMenuEDCTransaction+0x1e0>
    cd38:	87 c0       	rjmp	.+270    	; 0xce48 <FMenuEDCTransaction+0x1d4>
	      break;
	 case etSelectFIP:
	      FIPResult=menu_FIP(FIP_Used,strFIP_ID);
    cd3a:	80 e0       	ldi	r24, 0x00	; 0
    cd3c:	90 e0       	ldi	r25, 0x00	; 0
    cd3e:	68 ec       	ldi	r22, 0xC8	; 200
    cd40:	79 e0       	ldi	r23, 0x09	; 9
    cd42:	0e 94 df 64 	call	0xc9be	; 0xc9be <menu_FIP>
    cd46:	80 93 63 03 	sts	0x0363, r24
		  if (FIPResult==FIP_DONE)stEtransaction=etInitMessage90;
    cd4a:	88 23       	and	r24, r24
    cd4c:	11 f4       	brne	.+4      	; 0xcd52 <FMenuEDCTransaction+0xde>
    cd4e:	83 e0       	ldi	r24, 0x03	; 3
    cd50:	49 c0       	rjmp	.+146    	; 0xcde4 <FMenuEDCTransaction+0x170>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
    cd52:	82 30       	cpi	r24, 0x02	; 2
    cd54:	09 f0       	breq	.+2      	; 0xcd58 <FMenuEDCTransaction+0xe4>
    cd56:	7e c0       	rjmp	.+252    	; 0xce54 <FMenuEDCTransaction+0x1e0>
    cd58:	10 92 66 03 	sts	0x0366, r1
    cd5c:	7b c0       	rjmp	.+246    	; 0xce54 <FMenuEDCTransaction+0x1e0>
    cd5e:	e9 e9       	ldi	r30, 0x99	; 153
    cd60:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    cd62:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    cd64:	8e e0       	ldi	r24, 0x0E	; 14
    cd66:	ee 3a       	cpi	r30, 0xAE	; 174
    cd68:	f8 07       	cpc	r31, r24
    cd6a:	d9 f7       	brne	.-10     	; 0xcd62 <FMenuEDCTransaction+0xee>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
	      break;
     case etInitMessage90:
	      FillChar(strRef1,sizeof(strRef1),0);
	      if (EDCType==1){
    cd6c:	80 91 3c 0a 	lds	r24, 0x0A3C
    cd70:	81 30       	cpi	r24, 0x01	; 1
    cd72:	19 f4       	brne	.+6      	; 0xcd7a <FMenuEDCTransaction+0x106>
		      AddSpaceLag(strRef1,20);
    cd74:	cf 01       	movw	r24, r30
    cd76:	45 97       	sbiw	r24, 0x15	; 21
    cd78:	16 c0       	rjmp	.+44     	; 0xcda6 <FMenuEDCTransaction+0x132>
          }
		  else
	      if (EDCType==2){
    cd7a:	82 30       	cpi	r24, 0x02	; 2
    cd7c:	b9 f4       	brne	.+46     	; 0xcdac <FMenuEDCTransaction+0x138>
		      sprintf_P(strRef1,PSTR("CREDITCARD"));
    cd7e:	00 d0       	rcall	.+0      	; 0xcd80 <FMenuEDCTransaction+0x10c>
    cd80:	00 d0       	rcall	.+0      	; 0xcd82 <FMenuEDCTransaction+0x10e>
    cd82:	8f 01       	movw	r16, r30
    cd84:	05 51       	subi	r16, 0x15	; 21
    cd86:	10 40       	sbci	r17, 0x00	; 0
    cd88:	ed b7       	in	r30, 0x3d	; 61
    cd8a:	fe b7       	in	r31, 0x3e	; 62
    cd8c:	12 83       	std	Z+2, r17	; 0x02
    cd8e:	01 83       	std	Z+1, r16	; 0x01
    cd90:	88 e4       	ldi	r24, 0x48	; 72
    cd92:	99 e1       	ldi	r25, 0x19	; 25
    cd94:	94 83       	std	Z+4, r25	; 0x04
    cd96:	83 83       	std	Z+3, r24	; 0x03
    cd98:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  AddSpaceLag(strRef1,20);
    cd9c:	0f 90       	pop	r0
    cd9e:	0f 90       	pop	r0
    cda0:	0f 90       	pop	r0
    cda2:	0f 90       	pop	r0
    cda4:	c8 01       	movw	r24, r16
    cda6:	64 e1       	ldi	r22, 0x14	; 20
    cda8:	0e 94 15 2a 	call	0x542a	; 0x542a <AddSpaceLag>
		  }	 
	      stEtransaction=etSendingMessage90;
    cdac:	84 e0       	ldi	r24, 0x04	; 4
    cdae:	1a c0       	rjmp	.+52     	; 0xcde4 <FMenuEDCTransaction+0x170>
	      break;
     case etSendingMessage90:
          sendMessage90();
    cdb0:	0e 94 66 4d 	call	0x9acc	; 0x9acc <sendMessage90>
		  TimSend=0;
    cdb4:	10 92 be 01 	sts	0x01BE, r1
    cdb8:	10 92 bd 01 	sts	0x01BD, r1
          stEtransaction=etWaitReply;
    cdbc:	85 e0       	ldi	r24, 0x05	; 5
    cdbe:	12 c0       	rjmp	.+36     	; 0xcde4 <FMenuEDCTransaction+0x170>
	      break;
     case etWaitReply:
	      if (TimSend>TIM_SEND)stEtransaction=etNoConnection;
    cdc0:	80 91 bd 01 	lds	r24, 0x01BD
    cdc4:	90 91 be 01 	lds	r25, 0x01BE
    cdc8:	0b 97       	sbiw	r24, 0x0b	; 11
    cdca:	18 f0       	brcs	.+6      	; 0xcdd2 <FMenuEDCTransaction+0x15e>
    cdcc:	88 e0       	ldi	r24, 0x08	; 8
    cdce:	80 93 66 03 	sts	0x0366, r24
		  if ((IsMessage91==True)||(IsMessage09==True))
    cdd2:	80 91 d4 01 	lds	r24, 0x01D4
    cdd6:	81 30       	cpi	r24, 0x01	; 1
    cdd8:	21 f0       	breq	.+8      	; 0xcde2 <FMenuEDCTransaction+0x16e>
    cdda:	80 91 d0 01 	lds	r24, 0x01D0
    cdde:	81 30       	cpi	r24, 0x01	; 1
    cde0:	c9 f5       	brne	.+114    	; 0xce54 <FMenuEDCTransaction+0x1e0>
		       stEtransaction=etSuccesEDC;
    cde2:	86 e0       	ldi	r24, 0x06	; 6
    cde4:	80 93 66 03 	sts	0x0366, r24
    cde8:	35 c0       	rjmp	.+106    	; 0xce54 <FMenuEDCTransaction+0x1e0>
	      break;
     case etSuccesEDC:
	      stEtransaction=etDisplayFreeMessage;
    cdea:	87 e0       	ldi	r24, 0x07	; 7
    cdec:	fb cf       	rjmp	.-10     	; 0xcde4 <FMenuEDCTransaction+0x170>
	      break;
     case etDisplayFreeMessage:
	      if (IsMessage09==True){
    cdee:	80 91 d0 01 	lds	r24, 0x01D0
    cdf2:	81 30       	cpi	r24, 0x01	; 1
    cdf4:	19 f5       	brne	.+70     	; 0xce3c <FMenuEDCTransaction+0x1c8>
		      IsMessage09=False;
    cdf6:	10 92 d0 01 	sts	0x01D0, r1
	          procMessage09();
    cdfa:	0e 94 10 16 	call	0x2c20	; 0x2c20 <procMessage09>
		      lcd_clear();
    cdfe:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		      lcd_print(1,1,strFreeMessageLine1);
    ce02:	81 e0       	ldi	r24, 0x01	; 1
    ce04:	61 e0       	ldi	r22, 0x01	; 1
    ce06:	47 ec       	ldi	r20, 0xC7	; 199
    ce08:	5a e0       	ldi	r21, 0x0A	; 10
    ce0a:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		      lcd_print(2,1,strFreeMessageLine2);
    ce0e:	82 e0       	ldi	r24, 0x02	; 2
    ce10:	61 e0       	ldi	r22, 0x01	; 1
    ce12:	42 eb       	ldi	r20, 0xB2	; 178
    ce14:	59 e0       	ldi	r21, 0x09	; 9
    ce16:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		      lcd_print(3,1,strFreeMessageLine3);
    ce1a:	83 e0       	ldi	r24, 0x03	; 3
    ce1c:	61 e0       	ldi	r22, 0x01	; 1
    ce1e:	4d e4       	ldi	r20, 0x4D	; 77
    ce20:	5a e0       	ldi	r21, 0x0A	; 10
    ce22:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  lcd_print(4,1,strFreeMessageLine4);
    ce26:	84 e0       	ldi	r24, 0x04	; 4
    ce28:	61 e0       	ldi	r22, 0x01	; 1
    ce2a:	41 ee       	ldi	r20, 0xE1	; 225
    ce2c:	5d e0       	ldi	r21, 0x0D	; 13
    ce2e:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    ce32:	02 c0       	rjmp	.+4      	; 0xce38 <FMenuEDCTransaction+0x1c4>
			  TimDisplay=0;
			  }
		  stEtransaction=etDelayExit;
	      break;
     case etNoConnection:
	      lcd_clear();
    ce34:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  TimDisplay=0;
    ce38:	10 92 bc 01 	sts	0x01BC, r1
		  stEtransaction=etDelayExit;
    ce3c:	89 e0       	ldi	r24, 0x09	; 9
    ce3e:	d2 cf       	rjmp	.-92     	; 0xcde4 <FMenuEDCTransaction+0x170>
	      break;
     case etDelayExit:
	      if (TimDisplay>8)stEtransaction=etExitEDCTransaction;
    ce40:	80 91 bc 01 	lds	r24, 0x01BC
    ce44:	89 30       	cpi	r24, 0x09	; 9
    ce46:	30 f0       	brcs	.+12     	; 0xce54 <FMenuEDCTransaction+0x1e0>
    ce48:	8a e0       	ldi	r24, 0x0A	; 10
    ce4a:	cc cf       	rjmp	.-104    	; 0xcde4 <FMenuEDCTransaction+0x170>
	      break;
     case etExitEDCTransaction:
	      stEtransaction=etInit;
    ce4c:	10 92 66 03 	sts	0x0366, r1
    ce50:	81 e0       	ldi	r24, 0x01	; 1
    ce52:	01 c0       	rjmp	.+2      	; 0xce56 <FMenuEDCTransaction+0x1e2>
    ce54:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    ce56:	1f 91       	pop	r17
    ce58:	0f 91       	pop	r16
    ce5a:	08 95       	ret

0000ce5c <FMenuLoyalty>:
	      break;
	 }
  return Result;
}

char FMenuLoyalty(){
    ce5c:	cf 92       	push	r12
    ce5e:	df 92       	push	r13
    ce60:	ef 92       	push	r14
    ce62:	ff 92       	push	r15
    ce64:	0f 93       	push	r16
    ce66:	1f 93       	push	r17
    ce68:	df 93       	push	r29
    ce6a:	cf 93       	push	r28
    ce6c:	cd b7       	in	r28, 0x3d	; 61
    ce6e:	de b7       	in	r29, 0x3e	; 62
    ce70:	64 97       	sbiw	r28, 0x14	; 20
    ce72:	0f b6       	in	r0, 0x3f	; 63
    ce74:	f8 94       	cli
    ce76:	de bf       	out	0x3e, r29	; 62
    ce78:	0f be       	out	0x3f, r0	; 63
    ce7a:	cd bf       	out	0x3d, r28	; 61
       char lcdteks[20];
       char FIPResult,FIP_USED;
	   char Result=MENU_NONE;

     Result=MENU_NONE;
	 switch(stLoyalty){
    ce7c:	00 91 6a 03 	lds	r16, 0x036A
    ce80:	07 30       	cpi	r16, 0x07	; 7
    ce82:	09 f4       	brne	.+2      	; 0xce86 <FMenuLoyalty+0x2a>
    ce84:	05 c1       	rjmp	.+522    	; 0xd090 <FMenuLoyalty+0x234>
    ce86:	08 30       	cpi	r16, 0x08	; 8
    ce88:	98 f4       	brcc	.+38     	; 0xceb0 <FMenuLoyalty+0x54>
    ce8a:	03 30       	cpi	r16, 0x03	; 3
    ce8c:	09 f4       	brne	.+2      	; 0xce90 <FMenuLoyalty+0x34>
    ce8e:	5a c0       	rjmp	.+180    	; 0xcf44 <FMenuLoyalty+0xe8>
    ce90:	04 30       	cpi	r16, 0x04	; 4
    ce92:	38 f4       	brcc	.+14     	; 0xcea2 <FMenuLoyalty+0x46>
    ce94:	01 30       	cpi	r16, 0x01	; 1
    ce96:	09 f4       	brne	.+2      	; 0xce9a <FMenuLoyalty+0x3e>
    ce98:	3f c0       	rjmp	.+126    	; 0xcf18 <FMenuLoyalty+0xbc>
    ce9a:	02 30       	cpi	r16, 0x02	; 2
    ce9c:	08 f0       	brcs	.+2      	; 0xcea0 <FMenuLoyalty+0x44>
    ce9e:	60 c0       	rjmp	.+192    	; 0xcf60 <FMenuLoyalty+0x104>
    cea0:	1d c0       	rjmp	.+58     	; 0xcedc <FMenuLoyalty+0x80>
    cea2:	05 30       	cpi	r16, 0x05	; 5
    cea4:	09 f4       	brne	.+2      	; 0xcea8 <FMenuLoyalty+0x4c>
    cea6:	a1 c0       	rjmp	.+322    	; 0xcfea <FMenuLoyalty+0x18e>
    cea8:	06 30       	cpi	r16, 0x06	; 6
    ceaa:	08 f0       	brcs	.+2      	; 0xceae <FMenuLoyalty+0x52>
    ceac:	bb c0       	rjmp	.+374    	; 0xd024 <FMenuLoyalty+0x1c8>
    ceae:	8b c0       	rjmp	.+278    	; 0xcfc6 <FMenuLoyalty+0x16a>
    ceb0:	0b 30       	cpi	r16, 0x0B	; 11
    ceb2:	09 f4       	brne	.+2      	; 0xceb6 <FMenuLoyalty+0x5a>
    ceb4:	36 c1       	rjmp	.+620    	; 0xd122 <FMenuLoyalty+0x2c6>
    ceb6:	0c 30       	cpi	r16, 0x0C	; 12
    ceb8:	38 f4       	brcc	.+14     	; 0xcec8 <FMenuLoyalty+0x6c>
    ceba:	09 30       	cpi	r16, 0x09	; 9
    cebc:	09 f4       	brne	.+2      	; 0xcec0 <FMenuLoyalty+0x64>
    cebe:	f3 c0       	rjmp	.+486    	; 0xd0a6 <FMenuLoyalty+0x24a>
    cec0:	0a 30       	cpi	r16, 0x0A	; 10
    cec2:	08 f0       	brcs	.+2      	; 0xcec6 <FMenuLoyalty+0x6a>
    cec4:	15 c1       	rjmp	.+554    	; 0xd0f0 <FMenuLoyalty+0x294>
    cec6:	e7 c0       	rjmp	.+462    	; 0xd096 <FMenuLoyalty+0x23a>
    cec8:	0d 30       	cpi	r16, 0x0D	; 13
    ceca:	09 f4       	brne	.+2      	; 0xcece <FMenuLoyalty+0x72>
    cecc:	ed c1       	rjmp	.+986    	; 0xd2a8 <FMenuLoyalty+0x44c>
    cece:	0d 30       	cpi	r16, 0x0D	; 13
    ced0:	08 f4       	brcc	.+2      	; 0xced4 <FMenuLoyalty+0x78>
    ced2:	d7 c1       	rjmp	.+942    	; 0xd282 <FMenuLoyalty+0x426>
    ced4:	0e 30       	cpi	r16, 0x0E	; 14
    ced6:	09 f0       	breq	.+2      	; 0xceda <FMenuLoyalty+0x7e>
    ced8:	f3 c1       	rjmp	.+998    	; 0xd2c0 <FMenuLoyalty+0x464>
    ceda:	ec c1       	rjmp	.+984    	; 0xd2b4 <FMenuLoyalty+0x458>
	 case mlInit:
	      lcd_clear();
    cedc:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("  Menu Loyalty   "));
    cee0:	81 e0       	ldi	r24, 0x01	; 1
    cee2:	61 e0       	ldi	r22, 0x01	; 1
    cee4:	41 e7       	ldi	r20, 0x71	; 113
    cee6:	5a e1       	ldi	r21, 0x1A	; 26
    cee8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
          lcd_printf(1,1,PSTR("1.Enquiry        "));
    ceec:	81 e0       	ldi	r24, 0x01	; 1
    ceee:	61 e0       	ldi	r22, 0x01	; 1
    cef0:	4f e5       	ldi	r20, 0x5F	; 95
    cef2:	5a e1       	ldi	r21, 0x1A	; 26
    cef4:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Loyalty Update "));
    cef8:	82 e0       	ldi	r24, 0x02	; 2
    cefa:	61 e0       	ldi	r22, 0x01	; 1
    cefc:	4d e4       	ldi	r20, 0x4D	; 77
    cefe:	5a e1       	ldi	r21, 0x1A	; 26
    cf00:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back          "));
    cf04:	84 e0       	ldi	r24, 0x04	; 4
    cf06:	61 e0       	ldi	r22, 0x01	; 1
    cf08:	4b e3       	ldi	r20, 0x3B	; 59
    cf0a:	5a e1       	ldi	r21, 0x1A	; 26
    cf0c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  IsLoyaltyUpdate=False;
    cf10:	10 92 67 03 	sts	0x0367, r1
		  stLoyalty=mlLoyaltySelect;
    cf14:	81 e0       	ldi	r24, 0x01	; 1
    cf16:	0a c0       	rjmp	.+20     	; 0xcf2c <FMenuLoyalty+0xd0>
	      break;
	 case mlLoyaltySelect:
	 	  KeyPressed=_key_scan(1);
    cf18:	81 e0       	ldi	r24, 0x01	; 1
    cf1a:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    cf1e:	80 93 69 03 	sts	0x0369, r24
		  if (KeyPressed==_KEY_1){
    cf22:	8e 3e       	cpi	r24, 0xEE	; 238
    cf24:	31 f4       	brne	.+12     	; 0xcf32 <FMenuLoyalty+0xd6>
		      IsLoyaltyUpdate=False;
    cf26:	10 92 67 03 	sts	0x0367, r1
		      stLoyalty=mlShowEnquiry;
    cf2a:	84 e0       	ldi	r24, 0x04	; 4
    cf2c:	80 93 6a 03 	sts	0x036A, r24
    cf30:	c7 c1       	rjmp	.+910    	; 0xd2c0 <FMenuLoyalty+0x464>
			  }
		  else
		  if (KeyPressed==_KEY_2){
    cf32:	8e 3d       	cpi	r24, 0xDE	; 222
    cf34:	19 f4       	brne	.+6      	; 0xcf3c <FMenuLoyalty+0xe0>
		      IsLoyaltyUpdate=True;
    cf36:	00 93 67 03 	sts	0x0367, r16
    cf3a:	6b c0       	rjmp	.+214    	; 0xd012 <FMenuLoyalty+0x1b6>
			  stLoyalty=mlSelectFIP;
			  }
		  if (KeyPressed==_KEY_CANCEL)stLoyalty=mlExitLoyalty;
    cf3c:	87 3e       	cpi	r24, 0xE7	; 231
    cf3e:	09 f4       	brne	.+2      	; 0xcf42 <FMenuLoyalty+0xe6>
    cf40:	b7 c1       	rjmp	.+878    	; 0xd2b0 <FMenuLoyalty+0x454>
    cf42:	be c1       	rjmp	.+892    	; 0xd2c0 <FMenuLoyalty+0x464>
	      break;
     case mlSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
    cf44:	88 e6       	ldi	r24, 0x68	; 104
    cf46:	93 e0       	ldi	r25, 0x03	; 3
    cf48:	68 ec       	ldi	r22, 0xC8	; 200
    cf4a:	79 e0       	ldi	r23, 0x09	; 9
    cf4c:	0e 94 df 64 	call	0xc9be	; 0xc9be <menu_FIP>
		  if (FIPResult==FIP_DONE)stLoyalty=mlUpdateLoyalty;
    cf50:	88 23       	and	r24, r24
    cf52:	11 f4       	brne	.+4      	; 0xcf58 <FMenuLoyalty+0xfc>
    cf54:	82 e0       	ldi	r24, 0x02	; 2
    cf56:	ea cf       	rjmp	.-44     	; 0xcf2c <FMenuLoyalty+0xd0>
		  else
		  if (FIPResult==FIP_CANCEL)stLoyalty=mlInit;
    cf58:	82 30       	cpi	r24, 0x02	; 2
    cf5a:	09 f0       	breq	.+2      	; 0xcf5e <FMenuLoyalty+0x102>
    cf5c:	b1 c1       	rjmp	.+866    	; 0xd2c0 <FMenuLoyalty+0x464>
    cf5e:	5b c0       	rjmp	.+182    	; 0xd016 <FMenuLoyalty+0x1ba>
	      break;
     case mlUpdateLoyalty: 
	      lcd_clear();
    cf60:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("FIP:%s"),strFIP_ID);
    cf64:	00 d0       	rcall	.+0      	; 0xcf66 <FMenuLoyalty+0x10a>
    cf66:	00 d0       	rcall	.+0      	; 0xcf68 <FMenuLoyalty+0x10c>
    cf68:	00 d0       	rcall	.+0      	; 0xcf6a <FMenuLoyalty+0x10e>
    cf6a:	ed b7       	in	r30, 0x3d	; 61
    cf6c:	fe b7       	in	r31, 0x3e	; 62
    cf6e:	31 96       	adiw	r30, 0x01	; 1
    cf70:	8e 01       	movw	r16, r28
    cf72:	0f 5f       	subi	r16, 0xFF	; 255
    cf74:	1f 4f       	sbci	r17, 0xFF	; 255
    cf76:	ad b7       	in	r26, 0x3d	; 61
    cf78:	be b7       	in	r27, 0x3e	; 62
    cf7a:	12 96       	adiw	r26, 0x02	; 2
    cf7c:	1c 93       	st	X, r17
    cf7e:	0e 93       	st	-X, r16
    cf80:	11 97       	sbiw	r26, 0x01	; 1
    cf82:	84 e3       	ldi	r24, 0x34	; 52
    cf84:	9a e1       	ldi	r25, 0x1A	; 26
    cf86:	93 83       	std	Z+3, r25	; 0x03
    cf88:	82 83       	std	Z+2, r24	; 0x02
    cf8a:	88 ec       	ldi	r24, 0xC8	; 200
    cf8c:	99 e0       	ldi	r25, 0x09	; 9
    cf8e:	95 83       	std	Z+5, r25	; 0x05
    cf90:	84 83       	std	Z+4, r24	; 0x04
    cf92:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    cf96:	8d b7       	in	r24, 0x3d	; 61
    cf98:	9e b7       	in	r25, 0x3e	; 62
    cf9a:	06 96       	adiw	r24, 0x06	; 6
    cf9c:	0f b6       	in	r0, 0x3f	; 63
    cf9e:	f8 94       	cli
    cfa0:	9e bf       	out	0x3e, r25	; 62
    cfa2:	0f be       	out	0x3f, r0	; 63
    cfa4:	8d bf       	out	0x3d, r24	; 61
    cfa6:	81 e0       	ldi	r24, 0x01	; 1
    cfa8:	61 e0       	ldi	r22, 0x01	; 1
    cfaa:	45 e2       	ldi	r20, 0x25	; 37
    cfac:	5a e1       	ldi	r21, 0x1A	; 26
    cfae:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_print(2,1,lcdteks);
    cfb2:	82 e0       	ldi	r24, 0x02	; 2
    cfb4:	61 e0       	ldi	r22, 0x01	; 1
    cfb6:	a8 01       	movw	r20, r16
    cfb8:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    cfbc:	84 e0       	ldi	r24, 0x04	; 4
    cfbe:	61 e0       	ldi	r22, 0x01	; 1
    cfc0:	42 e1       	ldi	r20, 0x12	; 18
    cfc2:	5a e1       	ldi	r21, 0x1A	; 26
    cfc4:	0c c0       	rjmp	.+24     	; 0xcfde <FMenuLoyalty+0x182>
		  IsRFIDDetected=False;
	      stLoyalty=mlInputRFID;
	      break;
	 case mlShowEnquiry:
	      lcd_clear();
    cfc6:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    cfca:	81 e0       	ldi	r24, 0x01	; 1
    cfcc:	61 e0       	ldi	r22, 0x01	; 1
    cfce:	43 e0       	ldi	r20, 0x03	; 3
    cfd0:	5a e1       	ldi	r21, 0x1A	; 26
    cfd2:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    cfd6:	84 e0       	ldi	r24, 0x04	; 4
    cfd8:	61 e0       	ldi	r22, 0x01	; 1
    cfda:	40 ef       	ldi	r20, 0xF0	; 240
    cfdc:	59 e1       	ldi	r21, 0x19	; 25
    cfde:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  IsRFIDDetected=False;
    cfe2:	10 92 c4 01 	sts	0x01C4, r1
		  stLoyalty=mlInputRFID;
    cfe6:	85 e0       	ldi	r24, 0x05	; 5
    cfe8:	a1 cf       	rjmp	.-190    	; 0xcf2c <FMenuLoyalty+0xd0>
	      break;
     case mlInputRFID:
	      if (IsRFIDDetected==True){
    cfea:	80 91 c4 01 	lds	r24, 0x01C4
    cfee:	81 30       	cpi	r24, 0x01	; 1
    cff0:	29 f4       	brne	.+10     	; 0xcffc <FMenuLoyalty+0x1a0>
		      IsRFIDDetected=False;
    cff2:	10 92 c4 01 	sts	0x01C4, r1
		      stLoyalty=mlShowProsesRFID;
    cff6:	86 e0       	ldi	r24, 0x06	; 6
    cff8:	80 93 6a 03 	sts	0x036A, r24
		  }
	 	  KeyPressed=_key_scan(1);
    cffc:	81 e0       	ldi	r24, 0x01	; 1
    cffe:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    d002:	80 93 69 03 	sts	0x0369, r24
		  if (KeyPressed==_KEY_CANCEL){
    d006:	87 3e       	cpi	r24, 0xE7	; 231
    d008:	49 f4       	brne	.+18     	; 0xd01c <FMenuLoyalty+0x1c0>
		      if (IsLoyaltyUpdate==True)
    d00a:	80 91 67 03 	lds	r24, 0x0367
    d00e:	81 30       	cpi	r24, 0x01	; 1
    d010:	11 f4       	brne	.+4      	; 0xd016 <FMenuLoyalty+0x1ba>
			       stLoyalty=mlSelectFIP;
    d012:	83 e0       	ldi	r24, 0x03	; 3
    d014:	8b cf       	rjmp	.-234    	; 0xcf2c <FMenuLoyalty+0xd0>
			  else stLoyalty=mlInit;
    d016:	10 92 6a 03 	sts	0x036A, r1
    d01a:	52 c1       	rjmp	.+676    	; 0xd2c0 <FMenuLoyalty+0x464>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stLoyalty=mlExitLoyalty;
    d01c:	87 3b       	cpi	r24, 0xB7	; 183
    d01e:	09 f0       	breq	.+2      	; 0xd022 <FMenuLoyalty+0x1c6>
    d020:	4f c1       	rjmp	.+670    	; 0xd2c0 <FMenuLoyalty+0x464>
    d022:	46 c1       	rjmp	.+652    	; 0xd2b0 <FMenuLoyalty+0x454>
	      break;
     case mlShowProsesRFID:
	      lcd_clear();
    d024:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("ID:%s"),strRFID);
    d028:	00 d0       	rcall	.+0      	; 0xd02a <FMenuLoyalty+0x1ce>
    d02a:	00 d0       	rcall	.+0      	; 0xd02c <FMenuLoyalty+0x1d0>
    d02c:	00 d0       	rcall	.+0      	; 0xd02e <FMenuLoyalty+0x1d2>
    d02e:	ed b7       	in	r30, 0x3d	; 61
    d030:	fe b7       	in	r31, 0x3e	; 62
    d032:	31 96       	adiw	r30, 0x01	; 1
    d034:	8e 01       	movw	r16, r28
    d036:	0f 5f       	subi	r16, 0xFF	; 255
    d038:	1f 4f       	sbci	r17, 0xFF	; 255
    d03a:	ad b7       	in	r26, 0x3d	; 61
    d03c:	be b7       	in	r27, 0x3e	; 62
    d03e:	12 96       	adiw	r26, 0x02	; 2
    d040:	1c 93       	st	X, r17
    d042:	0e 93       	st	-X, r16
    d044:	11 97       	sbiw	r26, 0x01	; 1
    d046:	8a ee       	ldi	r24, 0xEA	; 234
    d048:	99 e1       	ldi	r25, 0x19	; 25
    d04a:	93 83       	std	Z+3, r25	; 0x03
    d04c:	82 83       	std	Z+2, r24	; 0x02
    d04e:	8c e5       	ldi	r24, 0x5C	; 92
    d050:	9e e0       	ldi	r25, 0x0E	; 14
    d052:	95 83       	std	Z+5, r25	; 0x05
    d054:	84 83       	std	Z+4, r24	; 0x04
    d056:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print (1,1,lcdteks);	      
    d05a:	8d b7       	in	r24, 0x3d	; 61
    d05c:	9e b7       	in	r25, 0x3e	; 62
    d05e:	06 96       	adiw	r24, 0x06	; 6
    d060:	0f b6       	in	r0, 0x3f	; 63
    d062:	f8 94       	cli
    d064:	9e bf       	out	0x3e, r25	; 62
    d066:	0f be       	out	0x3f, r0	; 63
    d068:	8d bf       	out	0x3d, r24	; 61
    d06a:	81 e0       	ldi	r24, 0x01	; 1
    d06c:	61 e0       	ldi	r22, 0x01	; 1
    d06e:	a8 01       	movw	r20, r16
    d070:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_printf(2,1,PSTR("Proses"));	      
    d074:	82 e0       	ldi	r24, 0x02	; 2
    d076:	61 e0       	ldi	r22, 0x01	; 1
    d078:	43 ee       	ldi	r20, 0xE3	; 227
    d07a:	59 e1       	ldi	r21, 0x19	; 25
    d07c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  if (IsLoyaltyUpdate==True)stLoyalty=mlSendMessage24;
    d080:	80 91 67 03 	lds	r24, 0x0367
    d084:	81 30       	cpi	r24, 0x01	; 1
    d086:	11 f4       	brne	.+4      	; 0xd08c <FMenuLoyalty+0x230>
    d088:	88 e0       	ldi	r24, 0x08	; 8
    d08a:	50 cf       	rjmp	.-352    	; 0xcf2c <FMenuLoyalty+0xd0>
		  else stLoyalty=mlSendMessage22;
    d08c:	87 e0       	ldi	r24, 0x07	; 7
    d08e:	4e cf       	rjmp	.-356    	; 0xcf2c <FMenuLoyalty+0xd0>
	      break;
     case mlSendMessage22:
	      sendMessage22();
    d090:	0e 94 40 51 	call	0xa280	; 0xa280 <sendMessage22>
    d094:	02 c0       	rjmp	.+4      	; 0xd09a <FMenuLoyalty+0x23e>
		  TimSend=0;
          stLoyalty=mlWaitReply;
	      break;
     case mlSendMessage24:
	      sendMessage24();
    d096:	0e 94 b4 50 	call	0xa168	; 0xa168 <sendMessage24>
		  TimSend=0;
    d09a:	10 92 be 01 	sts	0x01BE, r1
    d09e:	10 92 bd 01 	sts	0x01BD, r1
          stLoyalty=mlWaitReply;
    d0a2:	89 e0       	ldi	r24, 0x09	; 9
    d0a4:	43 cf       	rjmp	.-378    	; 0xcf2c <FMenuLoyalty+0xd0>
	      break;
     case mlWaitReply:
	      if (TimSend>TIM_SEND)stLoyalty=mlNoConnection;
    d0a6:	80 91 bd 01 	lds	r24, 0x01BD
    d0aa:	90 91 be 01 	lds	r25, 0x01BE
    d0ae:	0b 97       	sbiw	r24, 0x0b	; 11
    d0b0:	18 f0       	brcs	.+6      	; 0xd0b8 <FMenuLoyalty+0x25c>
    d0b2:	8c e0       	ldi	r24, 0x0C	; 12
    d0b4:	80 93 6a 03 	sts	0x036A, r24
	      if (IsMessage23==True){
    d0b8:	80 91 cf 01 	lds	r24, 0x01CF
    d0bc:	81 30       	cpi	r24, 0x01	; 1
    d0be:	39 f4       	brne	.+14     	; 0xd0ce <FMenuLoyalty+0x272>
		      IsMessage23=False;
    d0c0:	10 92 cf 01 	sts	0x01CF, r1
			  procMessage23();
    d0c4:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <procMessage23>
			  stLoyalty=mlDispEnquiry;
    d0c8:	8b e0       	ldi	r24, 0x0B	; 11
    d0ca:	80 93 6a 03 	sts	0x036A, r24
		  }
	      if (IsMessage09==True){
    d0ce:	80 91 d0 01 	lds	r24, 0x01D0
    d0d2:	81 30       	cpi	r24, 0x01	; 1
    d0d4:	39 f4       	brne	.+14     	; 0xd0e4 <FMenuLoyalty+0x288>
		      IsMessage09=False;
    d0d6:	10 92 d0 01 	sts	0x01D0, r1
	          procMessage09();
    d0da:	0e 94 10 16 	call	0x2c20	; 0x2c20 <procMessage09>
              stLoyalty=mlDisplayFreeMessage;
    d0de:	8a e0       	ldi	r24, 0x0A	; 10
    d0e0:	80 93 6a 03 	sts	0x036A, r24
		  }
	      if (IsMessage99==True){
    d0e4:	80 91 cc 01 	lds	r24, 0x01CC
    d0e8:	81 30       	cpi	r24, 0x01	; 1
    d0ea:	09 f0       	breq	.+2      	; 0xd0ee <FMenuLoyalty+0x292>
    d0ec:	e9 c0       	rjmp	.+466    	; 0xd2c0 <FMenuLoyalty+0x464>
    d0ee:	da c0       	rjmp	.+436    	; 0xd2a4 <FMenuLoyalty+0x448>
              stLoyalty=mlDelayExitLoyalty;
		  }
	      break;
     case mlDisplayFreeMessage:
		  lcd_clear();
    d0f0:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    d0f4:	81 e0       	ldi	r24, 0x01	; 1
    d0f6:	61 e0       	ldi	r22, 0x01	; 1
    d0f8:	47 ec       	ldi	r20, 0xC7	; 199
    d0fa:	5a e0       	ldi	r21, 0x0A	; 10
    d0fc:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    d100:	82 e0       	ldi	r24, 0x02	; 2
    d102:	61 e0       	ldi	r22, 0x01	; 1
    d104:	42 eb       	ldi	r20, 0xB2	; 178
    d106:	59 e0       	ldi	r21, 0x09	; 9
    d108:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    d10c:	83 e0       	ldi	r24, 0x03	; 3
    d10e:	61 e0       	ldi	r22, 0x01	; 1
    d110:	4d e4       	ldi	r20, 0x4D	; 77
    d112:	5a e0       	ldi	r21, 0x0A	; 10
    d114:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    d118:	84 e0       	ldi	r24, 0x04	; 4
    d11a:	61 e0       	ldi	r22, 0x01	; 1
    d11c:	41 ee       	ldi	r20, 0xE1	; 225
    d11e:	5d e0       	ldi	r21, 0x0D	; 13
    d120:	ab c0       	rjmp	.+342    	; 0xd278 <FMenuLoyalty+0x41c>
		  TimDisplay=0;
		  stLoyalty=mlDelayExitLoyalty;
	      break;
     case mlDispEnquiry:	      
	      lcd_clear();
    d122:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  RemSpaceLag(strCardID);RemSpaceLag(strCardHolder);
    d126:	21 e9       	ldi	r18, 0x91	; 145
    d128:	c2 2e       	mov	r12, r18
    d12a:	2d e0       	ldi	r18, 0x0D	; 13
    d12c:	d2 2e       	mov	r13, r18
    d12e:	c6 01       	movw	r24, r12
    d130:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
    d134:	9a e2       	ldi	r25, 0x2A	; 42
    d136:	e9 2e       	mov	r14, r25
    d138:	95 e0       	ldi	r25, 0x05	; 5
    d13a:	f9 2e       	mov	r15, r25
    d13c:	c7 01       	movw	r24, r14
    d13e:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("%s:%s"),strCardID,strCardHolder);
    d142:	ad b7       	in	r26, 0x3d	; 61
    d144:	be b7       	in	r27, 0x3e	; 62
    d146:	18 97       	sbiw	r26, 0x08	; 8
    d148:	0f b6       	in	r0, 0x3f	; 63
    d14a:	f8 94       	cli
    d14c:	be bf       	out	0x3e, r27	; 62
    d14e:	0f be       	out	0x3f, r0	; 63
    d150:	ad bf       	out	0x3d, r26	; 61
    d152:	ed b7       	in	r30, 0x3d	; 61
    d154:	fe b7       	in	r31, 0x3e	; 62
    d156:	31 96       	adiw	r30, 0x01	; 1
    d158:	8e 01       	movw	r16, r28
    d15a:	0f 5f       	subi	r16, 0xFF	; 255
    d15c:	1f 4f       	sbci	r17, 0xFF	; 255
    d15e:	12 96       	adiw	r26, 0x02	; 2
    d160:	1c 93       	st	X, r17
    d162:	0e 93       	st	-X, r16
    d164:	11 97       	sbiw	r26, 0x01	; 1
    d166:	8d ed       	ldi	r24, 0xDD	; 221
    d168:	99 e1       	ldi	r25, 0x19	; 25
    d16a:	93 83       	std	Z+3, r25	; 0x03
    d16c:	82 83       	std	Z+2, r24	; 0x02
    d16e:	d5 82       	std	Z+5, r13	; 0x05
    d170:	c4 82       	std	Z+4, r12	; 0x04
    d172:	f7 82       	std	Z+7, r15	; 0x07
    d174:	e6 82       	std	Z+6, r14	; 0x06
    d176:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(1,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d17a:	8d b7       	in	r24, 0x3d	; 61
    d17c:	9e b7       	in	r25, 0x3e	; 62
    d17e:	08 96       	adiw	r24, 0x08	; 8
    d180:	0f b6       	in	r0, 0x3f	; 63
    d182:	f8 94       	cli
    d184:	9e bf       	out	0x3e, r25	; 62
    d186:	0f be       	out	0x3f, r0	; 63
    d188:	8d bf       	out	0x3d, r24	; 61
    d18a:	81 e0       	ldi	r24, 0x01	; 1
    d18c:	61 e0       	ldi	r22, 0x01	; 1
    d18e:	a8 01       	movw	r20, r16
    d190:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    d194:	86 e6       	ldi	r24, 0x66	; 102
    d196:	e8 2e       	mov	r14, r24
    d198:	8a e0       	ldi	r24, 0x0A	; 10
    d19a:	f8 2e       	mov	r15, r24
    d19c:	c7 01       	movw	r24, r14
    d19e:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Points:%s"),strLoyCurrentPoints);
    d1a2:	00 d0       	rcall	.+0      	; 0xd1a4 <FMenuLoyalty+0x348>
    d1a4:	00 d0       	rcall	.+0      	; 0xd1a6 <FMenuLoyalty+0x34a>
    d1a6:	00 d0       	rcall	.+0      	; 0xd1a8 <FMenuLoyalty+0x34c>
    d1a8:	ed b7       	in	r30, 0x3d	; 61
    d1aa:	fe b7       	in	r31, 0x3e	; 62
    d1ac:	31 96       	adiw	r30, 0x01	; 1
    d1ae:	ad b7       	in	r26, 0x3d	; 61
    d1b0:	be b7       	in	r27, 0x3e	; 62
    d1b2:	12 96       	adiw	r26, 0x02	; 2
    d1b4:	1c 93       	st	X, r17
    d1b6:	0e 93       	st	-X, r16
    d1b8:	11 97       	sbiw	r26, 0x01	; 1
    d1ba:	83 ed       	ldi	r24, 0xD3	; 211
    d1bc:	99 e1       	ldi	r25, 0x19	; 25
    d1be:	93 83       	std	Z+3, r25	; 0x03
    d1c0:	82 83       	std	Z+2, r24	; 0x02
    d1c2:	f5 82       	std	Z+5, r15	; 0x05
    d1c4:	e4 82       	std	Z+4, r14	; 0x04
    d1c6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(2,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d1ca:	8d b7       	in	r24, 0x3d	; 61
    d1cc:	9e b7       	in	r25, 0x3e	; 62
    d1ce:	06 96       	adiw	r24, 0x06	; 6
    d1d0:	0f b6       	in	r0, 0x3f	; 63
    d1d2:	f8 94       	cli
    d1d4:	9e bf       	out	0x3e, r25	; 62
    d1d6:	0f be       	out	0x3f, r0	; 63
    d1d8:	8d bf       	out	0x3d, r24	; 61
    d1da:	82 e0       	ldi	r24, 0x02	; 2
    d1dc:	61 e0       	ldi	r22, 0x01	; 1
    d1de:	a8 01       	movw	r20, r16
    d1e0:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    d1e4:	c7 01       	movw	r24, r14
    d1e6:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("CM Amt:%s"),strLoyCurrMonConsumeA);
    d1ea:	00 d0       	rcall	.+0      	; 0xd1ec <FMenuLoyalty+0x390>
    d1ec:	00 d0       	rcall	.+0      	; 0xd1ee <FMenuLoyalty+0x392>
    d1ee:	00 d0       	rcall	.+0      	; 0xd1f0 <FMenuLoyalty+0x394>
    d1f0:	ed b7       	in	r30, 0x3d	; 61
    d1f2:	fe b7       	in	r31, 0x3e	; 62
    d1f4:	31 96       	adiw	r30, 0x01	; 1
    d1f6:	ad b7       	in	r26, 0x3d	; 61
    d1f8:	be b7       	in	r27, 0x3e	; 62
    d1fa:	12 96       	adiw	r26, 0x02	; 2
    d1fc:	1c 93       	st	X, r17
    d1fe:	0e 93       	st	-X, r16
    d200:	11 97       	sbiw	r26, 0x01	; 1
    d202:	89 ec       	ldi	r24, 0xC9	; 201
    d204:	99 e1       	ldi	r25, 0x19	; 25
    d206:	93 83       	std	Z+3, r25	; 0x03
    d208:	82 83       	std	Z+2, r24	; 0x02
    d20a:	84 e8       	ldi	r24, 0x84	; 132
    d20c:	95 e0       	ldi	r25, 0x05	; 5
    d20e:	95 83       	std	Z+5, r25	; 0x05
    d210:	84 83       	std	Z+4, r24	; 0x04
    d212:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(3,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d216:	8d b7       	in	r24, 0x3d	; 61
    d218:	9e b7       	in	r25, 0x3e	; 62
    d21a:	06 96       	adiw	r24, 0x06	; 6
    d21c:	0f b6       	in	r0, 0x3f	; 63
    d21e:	f8 94       	cli
    d220:	9e bf       	out	0x3e, r25	; 62
    d222:	0f be       	out	0x3f, r0	; 63
    d224:	8d bf       	out	0x3d, r24	; 61
    d226:	83 e0       	ldi	r24, 0x03	; 3
    d228:	61 e0       	ldi	r22, 0x01	; 1
    d22a:	a8 01       	movw	r20, r16
    d22c:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    d230:	c7 01       	movw	r24, r14
    d232:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Cm Vol:%s"),strLoyCurrMonConsumeV);
    d236:	00 d0       	rcall	.+0      	; 0xd238 <FMenuLoyalty+0x3dc>
    d238:	00 d0       	rcall	.+0      	; 0xd23a <FMenuLoyalty+0x3de>
    d23a:	00 d0       	rcall	.+0      	; 0xd23c <FMenuLoyalty+0x3e0>
    d23c:	ed b7       	in	r30, 0x3d	; 61
    d23e:	fe b7       	in	r31, 0x3e	; 62
    d240:	31 96       	adiw	r30, 0x01	; 1
    d242:	ad b7       	in	r26, 0x3d	; 61
    d244:	be b7       	in	r27, 0x3e	; 62
    d246:	12 96       	adiw	r26, 0x02	; 2
    d248:	1c 93       	st	X, r17
    d24a:	0e 93       	st	-X, r16
    d24c:	11 97       	sbiw	r26, 0x01	; 1
    d24e:	8f eb       	ldi	r24, 0xBF	; 191
    d250:	99 e1       	ldi	r25, 0x19	; 25
    d252:	93 83       	std	Z+3, r25	; 0x03
    d254:	82 83       	std	Z+2, r24	; 0x02
    d256:	88 ef       	ldi	r24, 0xF8	; 248
    d258:	9d e0       	ldi	r25, 0x0D	; 13
    d25a:	95 83       	std	Z+5, r25	; 0x05
    d25c:	84 83       	std	Z+4, r24	; 0x04
    d25e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(4,1,lcdteks);
    d262:	8d b7       	in	r24, 0x3d	; 61
    d264:	9e b7       	in	r25, 0x3e	; 62
    d266:	06 96       	adiw	r24, 0x06	; 6
    d268:	0f b6       	in	r0, 0x3f	; 63
    d26a:	f8 94       	cli
    d26c:	9e bf       	out	0x3e, r25	; 62
    d26e:	0f be       	out	0x3f, r0	; 63
    d270:	8d bf       	out	0x3d, r24	; 61
    d272:	84 e0       	ldi	r24, 0x04	; 4
    d274:	61 e0       	ldi	r22, 0x01	; 1
    d276:	a8 01       	movw	r20, r16
    d278:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  TimDisplay=0;
    d27c:	10 92 bc 01 	sts	0x01BC, r1
    d280:	11 c0       	rjmp	.+34     	; 0xd2a4 <FMenuLoyalty+0x448>
		  stLoyalty=mlDelayExitLoyalty;
		  break;
     case mlNoConnection:
	      lcd_clear();
    d282:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
    d286:	82 e0       	ldi	r24, 0x02	; 2
    d288:	61 e0       	ldi	r22, 0x01	; 1
    d28a:	41 eb       	ldi	r20, 0xB1	; 177
    d28c:	59 e1       	ldi	r21, 0x19	; 25
    d28e:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
    d292:	83 e0       	ldi	r24, 0x03	; 3
    d294:	61 e0       	ldi	r22, 0x01	; 1
    d296:	43 ea       	ldi	r20, 0xA3	; 163
    d298:	59 e1       	ldi	r21, 0x19	; 25
    d29a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  TimDisplay=5;
    d29e:	85 e0       	ldi	r24, 0x05	; 5
    d2a0:	80 93 bc 01 	sts	0x01BC, r24
		  stLoyalty=mlDelayExitLoyalty;
    d2a4:	8d e0       	ldi	r24, 0x0D	; 13
    d2a6:	42 ce       	rjmp	.-892    	; 0xcf2c <FMenuLoyalty+0xd0>
	      break;
     case mlDelayExitLoyalty:
          if(TimDisplay>=10)stLoyalty=mlExitLoyalty;
    d2a8:	80 91 bc 01 	lds	r24, 0x01BC
    d2ac:	8a 30       	cpi	r24, 0x0A	; 10
    d2ae:	40 f0       	brcs	.+16     	; 0xd2c0 <FMenuLoyalty+0x464>
    d2b0:	8e e0       	ldi	r24, 0x0E	; 14
    d2b2:	3c ce       	rjmp	.-904    	; 0xcf2c <FMenuLoyalty+0xd0>
	      break;
	 case mlExitLoyalty:
	      lcd_clear();
    d2b4:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
	      stLoyalty=mlInit;
    d2b8:	10 92 6a 03 	sts	0x036A, r1
    d2bc:	81 e0       	ldi	r24, 0x01	; 1
    d2be:	01 c0       	rjmp	.+2      	; 0xd2c2 <FMenuLoyalty+0x466>
    d2c0:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 return Result;
}
    d2c2:	64 96       	adiw	r28, 0x14	; 20
    d2c4:	0f b6       	in	r0, 0x3f	; 63
    d2c6:	f8 94       	cli
    d2c8:	de bf       	out	0x3e, r29	; 62
    d2ca:	0f be       	out	0x3f, r0	; 63
    d2cc:	cd bf       	out	0x3d, r28	; 61
    d2ce:	cf 91       	pop	r28
    d2d0:	df 91       	pop	r29
    d2d2:	1f 91       	pop	r17
    d2d4:	0f 91       	pop	r16
    d2d6:	ff 90       	pop	r15
    d2d8:	ef 90       	pop	r14
    d2da:	df 90       	pop	r13
    d2dc:	cf 90       	pop	r12
    d2de:	08 95       	ret

0000d2e0 <FMenuSettingServerIP>:
		       break;     
		  }//EndSwitch	 
    return Result;
}

char FMenuSettingServerIP(){
    d2e0:	0f 93       	push	r16
    d2e2:	1f 93       	push	r17
    d2e4:	df 93       	push	r29
    d2e6:	cf 93       	push	r28
    d2e8:	cd b7       	in	r28, 0x3d	; 61
    d2ea:	de b7       	in	r29, 0x3e	; 62
    d2ec:	64 97       	sbiw	r28, 0x14	; 20
    d2ee:	0f b6       	in	r0, 0x3f	; 63
    d2f0:	f8 94       	cli
    d2f2:	de bf       	out	0x3e, r29	; 62
    d2f4:	0f be       	out	0x3f, r0	; 63
    d2f6:	cd bf       	out	0x3d, r28	; 61
     //Server IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
	 Result=MENU_NONE;
    d2f8:	10 92 1c 03 	sts	0x031C, r1
     switch(stClientIP){
    d2fc:	80 91 6d 01 	lds	r24, 0x016D
    d300:	82 30       	cpi	r24, 0x02	; 2
    d302:	09 f4       	brne	.+2      	; 0xd306 <FMenuSettingServerIP+0x26>
    d304:	7b c0       	rjmp	.+246    	; 0xd3fc <FMenuSettingServerIP+0x11c>
    d306:	83 30       	cpi	r24, 0x03	; 3
    d308:	20 f4       	brcc	.+8      	; 0xd312 <FMenuSettingServerIP+0x32>
    d30a:	81 30       	cpi	r24, 0x01	; 1
    d30c:	09 f0       	breq	.+2      	; 0xd310 <FMenuSettingServerIP+0x30>
    d30e:	65 c2       	rjmp	.+1226   	; 0xd7da <FMenuSettingServerIP+0x4fa>
    d310:	07 c0       	rjmp	.+14     	; 0xd320 <FMenuSettingServerIP+0x40>
    d312:	83 30       	cpi	r24, 0x03	; 3
    d314:	09 f4       	brne	.+2      	; 0xd318 <FMenuSettingServerIP+0x38>
    d316:	5c c2       	rjmp	.+1208   	; 0xd7d0 <FMenuSettingServerIP+0x4f0>
    d318:	84 30       	cpi	r24, 0x04	; 4
    d31a:	09 f0       	breq	.+2      	; 0xd31e <FMenuSettingServerIP+0x3e>
    d31c:	5e c2       	rjmp	.+1212   	; 0xd7da <FMenuSettingServerIP+0x4fa>
    d31e:	4a c2       	rjmp	.+1172   	; 0xd7b4 <FMenuSettingServerIP+0x4d4>
		  case cipInit:
			   lcd_clear();
    d320:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
	           lcd_printf(1,1,PSTR("Server IP"));
    d324:	81 e0       	ldi	r24, 0x01	; 1
    d326:	61 e0       	ldi	r22, 0x01	; 1
    d328:	47 e9       	ldi	r20, 0x97	; 151
    d32a:	51 e1       	ldi	r21, 0x11	; 17
    d32c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
    d330:	83 e1       	ldi	r24, 0x13	; 19
    d332:	93 e0       	ldi	r25, 0x03	; 3
    d334:	6c e2       	ldi	r22, 0x2C	; 44
    d336:	70 e0       	ldi	r23, 0x00	; 0
    d338:	44 e0       	ldi	r20, 0x04	; 4
    d33a:	50 e0       	ldi	r21, 0x00	; 0
    d33c:	2c ea       	ldi	r18, 0xAC	; 172
    d33e:	32 e1       	ldi	r19, 0x12	; 18
    d340:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    d344:	8d b7       	in	r24, 0x3d	; 61
    d346:	9e b7       	in	r25, 0x3e	; 62
    d348:	0c 97       	sbiw	r24, 0x0c	; 12
    d34a:	0f b6       	in	r0, 0x3f	; 63
    d34c:	f8 94       	cli
    d34e:	9e bf       	out	0x3e, r25	; 62
    d350:	0f be       	out	0x3f, r0	; 63
    d352:	8d bf       	out	0x3d, r24	; 61
    d354:	ed b7       	in	r30, 0x3d	; 61
    d356:	fe b7       	in	r31, 0x3e	; 62
    d358:	31 96       	adiw	r30, 0x01	; 1
    d35a:	8e 01       	movw	r16, r28
    d35c:	0f 5f       	subi	r16, 0xFF	; 255
    d35e:	1f 4f       	sbci	r17, 0xFF	; 255
    d360:	ad b7       	in	r26, 0x3d	; 61
    d362:	be b7       	in	r27, 0x3e	; 62
    d364:	12 96       	adiw	r26, 0x02	; 2
    d366:	1c 93       	st	X, r17
    d368:	0e 93       	st	-X, r16
    d36a:	11 97       	sbiw	r26, 0x01	; 1
    d36c:	86 e8       	ldi	r24, 0x86	; 134
    d36e:	91 e1       	ldi	r25, 0x11	; 17
    d370:	93 83       	std	Z+3, r25	; 0x03
    d372:	82 83       	std	Z+2, r24	; 0x02
    d374:	80 91 13 03 	lds	r24, 0x0313
    d378:	84 83       	std	Z+4, r24	; 0x04
    d37a:	15 82       	std	Z+5, r1	; 0x05
    d37c:	80 91 14 03 	lds	r24, 0x0314
    d380:	86 83       	std	Z+6, r24	; 0x06
    d382:	17 82       	std	Z+7, r1	; 0x07
    d384:	80 91 15 03 	lds	r24, 0x0315
    d388:	80 87       	std	Z+8, r24	; 0x08
    d38a:	11 86       	std	Z+9, r1	; 0x09
    d38c:	80 91 16 03 	lds	r24, 0x0316
    d390:	82 87       	std	Z+10, r24	; 0x0a
    d392:	13 86       	std	Z+11, r1	; 0x0b
    d394:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    d398:	ed b7       	in	r30, 0x3d	; 61
    d39a:	fe b7       	in	r31, 0x3e	; 62
    d39c:	3c 96       	adiw	r30, 0x0c	; 12
    d39e:	0f b6       	in	r0, 0x3f	; 63
    d3a0:	f8 94       	cli
    d3a2:	fe bf       	out	0x3e, r31	; 62
    d3a4:	0f be       	out	0x3f, r0	; 63
    d3a6:	ed bf       	out	0x3d, r30	; 61
    d3a8:	82 e0       	ldi	r24, 0x02	; 2
    d3aa:	61 e0       	ldi	r22, 0x01	; 1
    d3ac:	a8 01       	movw	r20, r16
    d3ae:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    d3b2:	83 e0       	ldi	r24, 0x03	; 3
    d3b4:	61 e0       	ldi	r22, 0x01	; 1
    d3b6:	41 e7       	ldi	r20, 0x71	; 113
    d3b8:	51 e1       	ldi	r21, 0x11	; 17
    d3ba:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    d3be:	84 e0       	ldi	r24, 0x04	; 4
    d3c0:	61 e0       	ldi	r22, 0x01	; 1
    d3c2:	4c e5       	ldi	r20, 0x5C	; 92
    d3c4:	51 e1       	ldi	r21, 0x11	; 17
    d3c6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
               iLoop=0;
    d3ca:	10 92 12 03 	sts	0x0312, r1
    d3ce:	10 92 11 03 	sts	0x0311, r1
			   y=3,x=8;
    d3d2:	83 e0       	ldi	r24, 0x03	; 3
    d3d4:	80 93 19 03 	sts	0x0319, r24
    d3d8:	88 e0       	ldi	r24, 0x08	; 8
    d3da:	80 93 1a 03 	sts	0x031A, r24
			   iInput=0; iBlok=0;
    d3de:	10 92 18 03 	sts	0x0318, r1
    d3e2:	10 92 10 03 	sts	0x0310, r1
    d3e6:	10 92 0f 03 	sts	0x030F, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d3ea:	80 e3       	ldi	r24, 0x30	; 48
    d3ec:	80 93 1e 03 	sts	0x031E, r24
    d3f0:	80 93 1f 03 	sts	0x031F, r24
    d3f4:	80 93 20 03 	sts	0x0320, r24
			   stClientIP=cipInputIP; 
    d3f8:	82 e0       	ldi	r24, 0x02	; 2
    d3fa:	e7 c1       	rjmp	.+974    	; 0xd7ca <FMenuSettingServerIP+0x4ea>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    d3fc:	80 91 11 03 	lds	r24, 0x0311
    d400:	90 91 12 03 	lds	r25, 0x0312
    d404:	01 96       	adiw	r24, 0x01	; 1
    d406:	90 93 12 03 	sts	0x0312, r25
    d40a:	80 93 11 03 	sts	0x0311, r24
			   if ((iLoop%2000)==0){
    d40e:	60 ed       	ldi	r22, 0xD0	; 208
    d410:	77 e0       	ldi	r23, 0x07	; 7
    d412:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
    d416:	89 2b       	or	r24, r25
    d418:	81 f4       	brne	.+32     	; 0xd43a <FMenuSettingServerIP+0x15a>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    d41a:	80 91 0f 03 	lds	r24, 0x030F
    d41e:	90 91 10 03 	lds	r25, 0x0310
    d422:	88 0f       	add	r24, r24
    d424:	99 1f       	adc	r25, r25
    d426:	88 0f       	add	r24, r24
    d428:	99 1f       	adc	r25, r25
    d42a:	60 91 1a 03 	lds	r22, 0x031A
    d42e:	68 0f       	add	r22, r24
    d430:	80 91 19 03 	lds	r24, 0x0319
    d434:	4f e5       	ldi	r20, 0x5F	; 95
    d436:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    d43a:	80 91 11 03 	lds	r24, 0x0311
    d43e:	90 91 12 03 	lds	r25, 0x0312
    d442:	60 ed       	ldi	r22, 0xD0	; 208
    d444:	77 e0       	ldi	r23, 0x07	; 7
    d446:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
    d44a:	88 5e       	subi	r24, 0xE8	; 232
    d44c:	93 40       	sbci	r25, 0x03	; 3
    d44e:	81 f4       	brne	.+32     	; 0xd470 <FMenuSettingServerIP+0x190>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    d450:	80 91 0f 03 	lds	r24, 0x030F
    d454:	90 91 10 03 	lds	r25, 0x0310
    d458:	88 0f       	add	r24, r24
    d45a:	99 1f       	adc	r25, r25
    d45c:	88 0f       	add	r24, r24
    d45e:	99 1f       	adc	r25, r25
    d460:	60 91 1a 03 	lds	r22, 0x031A
    d464:	68 0f       	add	r22, r24
    d466:	80 91 19 03 	lds	r24, 0x0319
    d46a:	40 e2       	ldi	r20, 0x20	; 32
    d46c:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    d470:	81 e0       	ldi	r24, 0x01	; 1
    d472:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    d476:	80 93 17 03 	sts	0x0317, r24
			   keyChar=_key_btn(keyPressed);
    d47a:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
    d47e:	28 2f       	mov	r18, r24
    d480:	80 93 1b 03 	sts	0x031B, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    d484:	80 53       	subi	r24, 0x30	; 48
    d486:	8a 30       	cpi	r24, 0x0A	; 10
    d488:	08 f0       	brcs	.+2      	; 0xd48c <FMenuSettingServerIP+0x1ac>
    d48a:	d6 c0       	rjmp	.+428    	; 0xd638 <FMenuSettingServerIP+0x358>
    d48c:	80 e5       	ldi	r24, 0x50	; 80
    d48e:	93 ec       	ldi	r25, 0xC3	; 195
    d490:	01 97       	sbiw	r24, 0x01	; 1
    d492:	f1 f7       	brne	.-4      	; 0xd490 <FMenuSettingServerIP+0x1b0>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    d494:	80 91 18 03 	lds	r24, 0x0318
    d498:	e8 2f       	mov	r30, r24
    d49a:	f0 e0       	ldi	r31, 0x00	; 0
    d49c:	e2 5e       	subi	r30, 0xE2	; 226
    d49e:	fc 4f       	sbci	r31, 0xFC	; 252
    d4a0:	20 83       	st	Z, r18
				   iInput++;                    
    d4a2:	8f 5f       	subi	r24, 0xFF	; 255
    d4a4:	80 93 18 03 	sts	0x0318, r24
				   for (i=1;i<(iInput+1);i++){
    d4a8:	81 e0       	ldi	r24, 0x01	; 1
    d4aa:	1c c0       	rjmp	.+56     	; 0xd4e4 <FMenuSettingServerIP+0x204>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    d4ac:	80 91 1a 03 	lds	r24, 0x031A
    d4b0:	68 0f       	add	r22, r24
    d4b2:	63 50       	subi	r22, 0x03	; 3
    d4b4:	80 91 0f 03 	lds	r24, 0x030F
    d4b8:	90 91 10 03 	lds	r25, 0x0310
    d4bc:	88 0f       	add	r24, r24
    d4be:	99 1f       	adc	r25, r25
    d4c0:	88 0f       	add	r24, r24
    d4c2:	99 1f       	adc	r25, r25
    d4c4:	68 0f       	add	r22, r24
    d4c6:	80 91 19 03 	lds	r24, 0x0319
    d4ca:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
    d4ce:	e0 91 1d 03 	lds	r30, 0x031D
    d4d2:	f0 e0       	ldi	r31, 0x00	; 0
    d4d4:	e3 5e       	subi	r30, 0xE3	; 227
    d4d6:	fc 4f       	sbci	r31, 0xFC	; 252
    d4d8:	80 81       	ld	r24, Z
    d4da:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    d4de:	80 91 1d 03 	lds	r24, 0x031D
    d4e2:	8f 5f       	subi	r24, 0xFF	; 255
    d4e4:	80 93 1d 03 	sts	0x031D, r24
    d4e8:	70 91 18 03 	lds	r23, 0x0318
    d4ec:	60 91 1d 03 	lds	r22, 0x031D
    d4f0:	27 2f       	mov	r18, r23
    d4f2:	30 e0       	ldi	r19, 0x00	; 0
    d4f4:	86 2f       	mov	r24, r22
    d4f6:	90 e0       	ldi	r25, 0x00	; 0
    d4f8:	28 17       	cp	r18, r24
    d4fa:	39 07       	cpc	r19, r25
    d4fc:	bc f6       	brge	.-82     	; 0xd4ac <FMenuSettingServerIP+0x1cc>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    d4fe:	73 30       	cpi	r23, 0x03	; 3
    d500:	08 f4       	brcc	.+2      	; 0xd504 <FMenuSettingServerIP+0x224>
    d502:	91 c0       	rjmp	.+290    	; 0xd626 <FMenuSettingServerIP+0x346>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d504:	40 91 0f 03 	lds	r20, 0x030F
    d508:	50 91 10 03 	lds	r21, 0x0310
    d50c:	fa 01       	movw	r30, r20
    d50e:	ed 5e       	subi	r30, 0xED	; 237
    d510:	fc 4f       	sbci	r31, 0xFC	; 252
    d512:	20 91 20 03 	lds	r18, 0x0320
    d516:	20 5d       	subi	r18, 0xD0	; 208
    d518:	80 91 1e 03 	lds	r24, 0x031E
    d51c:	34 e6       	ldi	r19, 0x64	; 100
    d51e:	83 9f       	mul	r24, r19
    d520:	c0 01       	movw	r24, r0
    d522:	11 24       	eor	r1, r1
    d524:	28 0f       	add	r18, r24
    d526:	80 91 1f 03 	lds	r24, 0x031F
    d52a:	3a e0       	ldi	r19, 0x0A	; 10
    d52c:	83 9f       	mul	r24, r19
    d52e:	c0 01       	movw	r24, r0
    d530:	11 24       	eor	r1, r1
    d532:	28 0f       	add	r18, r24
    d534:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d536:	80 e3       	ldi	r24, 0x30	; 48
    d538:	80 93 1e 03 	sts	0x031E, r24
    d53c:	80 93 1f 03 	sts	0x031F, r24
    d540:	80 93 20 03 	sts	0x0320, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    d544:	44 0f       	add	r20, r20
    d546:	55 1f       	adc	r21, r21
    d548:	44 0f       	add	r20, r20
    d54a:	55 1f       	adc	r21, r21
    d54c:	60 91 1a 03 	lds	r22, 0x031A
    d550:	64 0f       	add	r22, r20
    d552:	67 1b       	sub	r22, r23
    d554:	80 91 19 03 	lds	r24, 0x0319
    d558:	48 e5       	ldi	r20, 0x58	; 88
    d55a:	51 e1       	ldi	r21, 0x11	; 17
    d55c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d560:	00 d0       	rcall	.+0      	; 0xd562 <FMenuSettingServerIP+0x282>
    d562:	00 d0       	rcall	.+0      	; 0xd564 <FMenuSettingServerIP+0x284>
    d564:	00 d0       	rcall	.+0      	; 0xd566 <FMenuSettingServerIP+0x286>
    d566:	ad b7       	in	r26, 0x3d	; 61
    d568:	be b7       	in	r27, 0x3e	; 62
    d56a:	11 96       	adiw	r26, 0x01	; 1
    d56c:	8e 01       	movw	r16, r28
    d56e:	0f 5f       	subi	r16, 0xFF	; 255
    d570:	1f 4f       	sbci	r17, 0xFF	; 255
    d572:	ed b7       	in	r30, 0x3d	; 61
    d574:	fe b7       	in	r31, 0x3e	; 62
    d576:	12 83       	std	Z+2, r17	; 0x02
    d578:	01 83       	std	Z+1, r16	; 0x01
    d57a:	85 e5       	ldi	r24, 0x55	; 85
    d57c:	91 e1       	ldi	r25, 0x11	; 17
    d57e:	13 96       	adiw	r26, 0x03	; 3
    d580:	9c 93       	st	X, r25
    d582:	8e 93       	st	-X, r24
    d584:	12 97       	sbiw	r26, 0x02	; 2
    d586:	e0 91 0f 03 	lds	r30, 0x030F
    d58a:	f0 91 10 03 	lds	r31, 0x0310
    d58e:	ed 5e       	subi	r30, 0xED	; 237
    d590:	fc 4f       	sbci	r31, 0xFC	; 252
    d592:	80 81       	ld	r24, Z
    d594:	14 96       	adiw	r26, 0x04	; 4
    d596:	8c 93       	st	X, r24
    d598:	14 97       	sbiw	r26, 0x04	; 4
    d59a:	15 96       	adiw	r26, 0x05	; 5
    d59c:	1c 92       	st	X, r1
    d59e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d5a2:	f8 01       	movw	r30, r16
    d5a4:	01 90       	ld	r0, Z+
    d5a6:	00 20       	and	r0, r0
    d5a8:	e9 f7       	brne	.-6      	; 0xd5a4 <FMenuSettingServerIP+0x2c4>
    d5aa:	31 97       	sbiw	r30, 0x01	; 1
    d5ac:	e0 1b       	sub	r30, r16
    d5ae:	f1 0b       	sbc	r31, r17
    d5b0:	8d b7       	in	r24, 0x3d	; 61
    d5b2:	9e b7       	in	r25, 0x3e	; 62
    d5b4:	06 96       	adiw	r24, 0x06	; 6
    d5b6:	0f b6       	in	r0, 0x3f	; 63
    d5b8:	f8 94       	cli
    d5ba:	9e bf       	out	0x3e, r25	; 62
    d5bc:	0f be       	out	0x3f, r0	; 63
    d5be:	8d bf       	out	0x3d, r24	; 61
    d5c0:	60 91 1a 03 	lds	r22, 0x031A
    d5c4:	6f 5f       	subi	r22, 0xFF	; 255
    d5c6:	80 91 0f 03 	lds	r24, 0x030F
    d5ca:	90 91 10 03 	lds	r25, 0x0310
    d5ce:	88 0f       	add	r24, r24
    d5d0:	99 1f       	adc	r25, r25
    d5d2:	88 0f       	add	r24, r24
    d5d4:	99 1f       	adc	r25, r25
    d5d6:	68 0f       	add	r22, r24
    d5d8:	6e 1b       	sub	r22, r30
    d5da:	80 91 19 03 	lds	r24, 0x0319
    d5de:	a8 01       	movw	r20, r16
    d5e0:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d5e4:	80 91 0f 03 	lds	r24, 0x030F
    d5e8:	90 91 10 03 	lds	r25, 0x0310
    d5ec:	00 97       	sbiw	r24, 0x00	; 0
    d5ee:	81 f0       	breq	.+32     	; 0xd610 <FMenuSettingServerIP+0x330>
    d5f0:	60 91 1a 03 	lds	r22, 0x031A
    d5f4:	6f 5f       	subi	r22, 0xFF	; 255
    d5f6:	81 50       	subi	r24, 0x01	; 1
    d5f8:	90 4c       	sbci	r25, 0xC0	; 192
    d5fa:	88 0f       	add	r24, r24
    d5fc:	99 1f       	adc	r25, r25
    d5fe:	88 0f       	add	r24, r24
    d600:	99 1f       	adc	r25, r25
    d602:	68 0f       	add	r22, r24
    d604:	80 91 19 03 	lds	r24, 0x0319
    d608:	43 e5       	ldi	r20, 0x53	; 83
    d60a:	51 e1       	ldi	r21, 0x11	; 17
    d60c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
					   iInput=0;
    d610:	10 92 18 03 	sts	0x0318, r1
					   iBlok++;
    d614:	80 91 0f 03 	lds	r24, 0x030F
    d618:	90 91 10 03 	lds	r25, 0x0310
    d61c:	01 96       	adiw	r24, 0x01	; 1
    d61e:	90 93 10 03 	sts	0x0310, r25
    d622:	80 93 0f 03 	sts	0x030F, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    d626:	80 91 0f 03 	lds	r24, 0x030F
    d62a:	90 91 10 03 	lds	r25, 0x0310
    d62e:	04 97       	sbiw	r24, 0x04	; 4
    d630:	18 f0       	brcs	.+6      	; 0xd638 <FMenuSettingServerIP+0x358>
    d632:	84 e0       	ldi	r24, 0x04	; 4
    d634:	80 93 6d 01 	sts	0x016D, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    d638:	80 91 17 03 	lds	r24, 0x0317
    d63c:	87 3e       	cpi	r24, 0xE7	; 231
    d63e:	09 f4       	brne	.+2      	; 0xd642 <FMenuSettingServerIP+0x362>
    d640:	c3 c0       	rjmp	.+390    	; 0xd7c8 <FMenuSettingServerIP+0x4e8>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    d642:	87 3b       	cpi	r24, 0xB7	; 183
    d644:	09 f0       	breq	.+2      	; 0xd648 <FMenuSettingServerIP+0x368>
    d646:	c9 c0       	rjmp	.+402    	; 0xd7da <FMenuSettingServerIP+0x4fa>
			       //NextInput
			       if (iBlok<4){
    d648:	40 91 0f 03 	lds	r20, 0x030F
    d64c:	50 91 10 03 	lds	r21, 0x0310
    d650:	44 30       	cpi	r20, 0x04	; 4
    d652:	51 05       	cpc	r21, r1
    d654:	08 f0       	brcs	.+2      	; 0xd658 <FMenuSettingServerIP+0x378>
    d656:	a6 c0       	rjmp	.+332    	; 0xd7a4 <FMenuSettingServerIP+0x4c4>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    d658:	80 91 18 03 	lds	r24, 0x0318
    d65c:	81 30       	cpi	r24, 0x01	; 1
    d65e:	41 f4       	brne	.+16     	; 0xd670 <FMenuSettingServerIP+0x390>
    d660:	fa 01       	movw	r30, r20
    d662:	ed 5e       	subi	r30, 0xED	; 237
    d664:	fc 4f       	sbci	r31, 0xFC	; 252
    d666:	80 91 1e 03 	lds	r24, 0x031E
    d66a:	80 53       	subi	r24, 0x30	; 48
    d66c:	80 83       	st	Z, r24
    d66e:	22 c0       	rjmp	.+68     	; 0xd6b4 <FMenuSettingServerIP+0x3d4>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    d670:	82 30       	cpi	r24, 0x02	; 2
    d672:	49 f4       	brne	.+18     	; 0xd686 <FMenuSettingServerIP+0x3a6>
    d674:	fa 01       	movw	r30, r20
    d676:	ed 5e       	subi	r30, 0xED	; 237
    d678:	fc 4f       	sbci	r31, 0xFC	; 252
    d67a:	20 91 1f 03 	lds	r18, 0x031F
    d67e:	20 51       	subi	r18, 0x10	; 16
    d680:	80 91 1e 03 	lds	r24, 0x031E
    d684:	11 c0       	rjmp	.+34     	; 0xd6a8 <FMenuSettingServerIP+0x3c8>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d686:	83 30       	cpi	r24, 0x03	; 3
    d688:	a9 f4       	brne	.+42     	; 0xd6b4 <FMenuSettingServerIP+0x3d4>
    d68a:	fa 01       	movw	r30, r20
    d68c:	ed 5e       	subi	r30, 0xED	; 237
    d68e:	fc 4f       	sbci	r31, 0xFC	; 252
    d690:	20 91 20 03 	lds	r18, 0x0320
    d694:	20 5d       	subi	r18, 0xD0	; 208
    d696:	80 91 1e 03 	lds	r24, 0x031E
    d69a:	34 e6       	ldi	r19, 0x64	; 100
    d69c:	83 9f       	mul	r24, r19
    d69e:	c0 01       	movw	r24, r0
    d6a0:	11 24       	eor	r1, r1
    d6a2:	28 0f       	add	r18, r24
    d6a4:	80 91 1f 03 	lds	r24, 0x031F
    d6a8:	3a e0       	ldi	r19, 0x0A	; 10
    d6aa:	83 9f       	mul	r24, r19
    d6ac:	c0 01       	movw	r24, r0
    d6ae:	11 24       	eor	r1, r1
    d6b0:	28 0f       	add	r18, r24
    d6b2:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d6b4:	80 e3       	ldi	r24, 0x30	; 48
    d6b6:	80 93 1e 03 	sts	0x031E, r24
    d6ba:	80 93 1f 03 	sts	0x031F, r24
    d6be:	80 93 20 03 	sts	0x0320, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    d6c2:	60 91 1a 03 	lds	r22, 0x031A
    d6c6:	63 50       	subi	r22, 0x03	; 3
    d6c8:	44 0f       	add	r20, r20
    d6ca:	55 1f       	adc	r21, r21
    d6cc:	44 0f       	add	r20, r20
    d6ce:	55 1f       	adc	r21, r21
    d6d0:	64 0f       	add	r22, r20
    d6d2:	80 91 19 03 	lds	r24, 0x0319
    d6d6:	4f e4       	ldi	r20, 0x4F	; 79
    d6d8:	51 e1       	ldi	r21, 0x11	; 17
    d6da:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d6de:	00 d0       	rcall	.+0      	; 0xd6e0 <FMenuSettingServerIP+0x400>
    d6e0:	00 d0       	rcall	.+0      	; 0xd6e2 <FMenuSettingServerIP+0x402>
    d6e2:	00 d0       	rcall	.+0      	; 0xd6e4 <FMenuSettingServerIP+0x404>
    d6e4:	ad b7       	in	r26, 0x3d	; 61
    d6e6:	be b7       	in	r27, 0x3e	; 62
    d6e8:	11 96       	adiw	r26, 0x01	; 1
    d6ea:	8e 01       	movw	r16, r28
    d6ec:	0f 5f       	subi	r16, 0xFF	; 255
    d6ee:	1f 4f       	sbci	r17, 0xFF	; 255
    d6f0:	ed b7       	in	r30, 0x3d	; 61
    d6f2:	fe b7       	in	r31, 0x3e	; 62
    d6f4:	12 83       	std	Z+2, r17	; 0x02
    d6f6:	01 83       	std	Z+1, r16	; 0x01
    d6f8:	8c e4       	ldi	r24, 0x4C	; 76
    d6fa:	91 e1       	ldi	r25, 0x11	; 17
    d6fc:	13 96       	adiw	r26, 0x03	; 3
    d6fe:	9c 93       	st	X, r25
    d700:	8e 93       	st	-X, r24
    d702:	12 97       	sbiw	r26, 0x02	; 2
    d704:	e0 91 0f 03 	lds	r30, 0x030F
    d708:	f0 91 10 03 	lds	r31, 0x0310
    d70c:	ed 5e       	subi	r30, 0xED	; 237
    d70e:	fc 4f       	sbci	r31, 0xFC	; 252
    d710:	80 81       	ld	r24, Z
    d712:	14 96       	adiw	r26, 0x04	; 4
    d714:	8c 93       	st	X, r24
    d716:	14 97       	sbiw	r26, 0x04	; 4
    d718:	15 96       	adiw	r26, 0x05	; 5
    d71a:	1c 92       	st	X, r1
    d71c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d720:	f8 01       	movw	r30, r16
    d722:	01 90       	ld	r0, Z+
    d724:	00 20       	and	r0, r0
    d726:	e9 f7       	brne	.-6      	; 0xd722 <FMenuSettingServerIP+0x442>
    d728:	31 97       	sbiw	r30, 0x01	; 1
    d72a:	e0 1b       	sub	r30, r16
    d72c:	f1 0b       	sbc	r31, r17
    d72e:	8d b7       	in	r24, 0x3d	; 61
    d730:	9e b7       	in	r25, 0x3e	; 62
    d732:	06 96       	adiw	r24, 0x06	; 6
    d734:	0f b6       	in	r0, 0x3f	; 63
    d736:	f8 94       	cli
    d738:	9e bf       	out	0x3e, r25	; 62
    d73a:	0f be       	out	0x3f, r0	; 63
    d73c:	8d bf       	out	0x3d, r24	; 61
    d73e:	60 91 1a 03 	lds	r22, 0x031A
    d742:	6f 5f       	subi	r22, 0xFF	; 255
    d744:	80 91 0f 03 	lds	r24, 0x030F
    d748:	90 91 10 03 	lds	r25, 0x0310
    d74c:	88 0f       	add	r24, r24
    d74e:	99 1f       	adc	r25, r25
    d750:	88 0f       	add	r24, r24
    d752:	99 1f       	adc	r25, r25
    d754:	68 0f       	add	r22, r24
    d756:	6e 1b       	sub	r22, r30
    d758:	80 91 19 03 	lds	r24, 0x0319
    d75c:	a8 01       	movw	r20, r16
    d75e:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d762:	80 91 0f 03 	lds	r24, 0x030F
    d766:	90 91 10 03 	lds	r25, 0x0310
    d76a:	00 97       	sbiw	r24, 0x00	; 0
    d76c:	81 f0       	breq	.+32     	; 0xd78e <FMenuSettingServerIP+0x4ae>
    d76e:	60 91 1a 03 	lds	r22, 0x031A
    d772:	6f 5f       	subi	r22, 0xFF	; 255
    d774:	81 50       	subi	r24, 0x01	; 1
    d776:	90 4c       	sbci	r25, 0xC0	; 192
    d778:	88 0f       	add	r24, r24
    d77a:	99 1f       	adc	r25, r25
    d77c:	88 0f       	add	r24, r24
    d77e:	99 1f       	adc	r25, r25
    d780:	68 0f       	add	r22, r24
    d782:	80 91 19 03 	lds	r24, 0x0319
    d786:	4a e4       	ldi	r20, 0x4A	; 74
    d788:	51 e1       	ldi	r21, 0x11	; 17
    d78a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				       iInput=0;
    d78e:	10 92 18 03 	sts	0x0318, r1
					   iBlok++;	   
    d792:	80 91 0f 03 	lds	r24, 0x030F
    d796:	90 91 10 03 	lds	r25, 0x0310
    d79a:	01 96       	adiw	r24, 0x01	; 1
    d79c:	90 93 10 03 	sts	0x0310, r25
    d7a0:	80 93 0f 03 	sts	0x030F, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    d7a4:	80 91 0f 03 	lds	r24, 0x030F
    d7a8:	90 91 10 03 	lds	r25, 0x0310
    d7ac:	04 97       	sbiw	r24, 0x04	; 4
    d7ae:	a8 f0       	brcs	.+42     	; 0xd7da <FMenuSettingServerIP+0x4fa>
    d7b0:	84 e0       	ldi	r24, 0x04	; 4
    d7b2:	0b c0       	rjmp	.+22     	; 0xd7ca <FMenuSettingServerIP+0x4ea>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    d7b4:	8c e2       	ldi	r24, 0x2C	; 44
    d7b6:	90 e0       	ldi	r25, 0x00	; 0
    d7b8:	63 e1       	ldi	r22, 0x13	; 19
    d7ba:	73 e0       	ldi	r23, 0x03	; 3
    d7bc:	44 e0       	ldi	r20, 0x04	; 4
    d7be:	50 e0       	ldi	r21, 0x00	; 0
    d7c0:	24 eb       	ldi	r18, 0xB4	; 180
    d7c2:	32 e1       	ldi	r19, 0x12	; 18
    d7c4:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
			   }
		       break;
          case cipStoreIPblok:
		       //UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefServerIP,4);
			   stClientIP=cipExit;
    d7c8:	83 e0       	ldi	r24, 0x03	; 3
    d7ca:	80 93 6d 01 	sts	0x016D, r24
    d7ce:	05 c0       	rjmp	.+10     	; 0xd7da <FMenuSettingServerIP+0x4fa>
		       break; 
          case cipExit://Cancel IPConfig
			   stClientIP=cipInit;
    d7d0:	81 e0       	ldi	r24, 0x01	; 1
    d7d2:	80 93 6d 01 	sts	0x016D, r24
			   Result=MENU_DONE;
    d7d6:	80 93 1c 03 	sts	0x031C, r24
		       break;     
		  }//EndSwitch	 
	return Result;
}
    d7da:	80 91 1c 03 	lds	r24, 0x031C
    d7de:	64 96       	adiw	r28, 0x14	; 20
    d7e0:	0f b6       	in	r0, 0x3f	; 63
    d7e2:	f8 94       	cli
    d7e4:	de bf       	out	0x3e, r29	; 62
    d7e6:	0f be       	out	0x3f, r0	; 63
    d7e8:	cd bf       	out	0x3d, r28	; 61
    d7ea:	cf 91       	pop	r28
    d7ec:	df 91       	pop	r29
    d7ee:	1f 91       	pop	r17
    d7f0:	0f 91       	pop	r16
    d7f2:	08 95       	ret

0000d7f4 <FMenuSettingClientIP>:
	if(__result==0)
		eeprom_write_block((const void*) &__buf_string, (void*) &DefHeaderFooter[__select], _MAX_TEXT + 1);
}


char FMenuSettingClientIP(){
    d7f4:	0f 93       	push	r16
    d7f6:	1f 93       	push	r17
    d7f8:	df 93       	push	r29
    d7fa:	cf 93       	push	r28
    d7fc:	cd b7       	in	r28, 0x3d	; 61
    d7fe:	de b7       	in	r29, 0x3e	; 62
    d800:	64 97       	sbiw	r28, 0x14	; 20
    d802:	0f b6       	in	r0, 0x3f	; 63
    d804:	f8 94       	cli
    d806:	de bf       	out	0x3e, r29	; 62
    d808:	0f be       	out	0x3f, r0	; 63
    d80a:	cd bf       	out	0x3d, r28	; 61
     //Client IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
     Result=MENU_NONE;
    d80c:	10 92 2e 03 	sts	0x032E, r1
	 switch(stClientIP){
    d810:	80 91 6e 01 	lds	r24, 0x016E
    d814:	82 30       	cpi	r24, 0x02	; 2
    d816:	09 f4       	brne	.+2      	; 0xd81a <FMenuSettingClientIP+0x26>
    d818:	7b c0       	rjmp	.+246    	; 0xd910 <FMenuSettingClientIP+0x11c>
    d81a:	83 30       	cpi	r24, 0x03	; 3
    d81c:	20 f4       	brcc	.+8      	; 0xd826 <FMenuSettingClientIP+0x32>
    d81e:	81 30       	cpi	r24, 0x01	; 1
    d820:	09 f0       	breq	.+2      	; 0xd824 <FMenuSettingClientIP+0x30>
    d822:	65 c2       	rjmp	.+1226   	; 0xdcee <FMenuSettingClientIP+0x4fa>
    d824:	07 c0       	rjmp	.+14     	; 0xd834 <FMenuSettingClientIP+0x40>
    d826:	83 30       	cpi	r24, 0x03	; 3
    d828:	09 f4       	brne	.+2      	; 0xd82c <FMenuSettingClientIP+0x38>
    d82a:	5c c2       	rjmp	.+1208   	; 0xdce4 <FMenuSettingClientIP+0x4f0>
    d82c:	84 30       	cpi	r24, 0x04	; 4
    d82e:	09 f0       	breq	.+2      	; 0xd832 <FMenuSettingClientIP+0x3e>
    d830:	5e c2       	rjmp	.+1212   	; 0xdcee <FMenuSettingClientIP+0x4fa>
    d832:	4a c2       	rjmp	.+1172   	; 0xdcc8 <FMenuSettingClientIP+0x4d4>
		  case cipInit:
			   lcd_clear();
    d834:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
	           lcd_printf(1,1,PSTR("Client IP"));
    d838:	81 e0       	ldi	r24, 0x01	; 1
    d83a:	61 e0       	ldi	r22, 0x01	; 1
    d83c:	4e ee       	ldi	r20, 0xEE	; 238
    d83e:	51 e1       	ldi	r21, 0x11	; 17
    d840:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d844:	85 e2       	ldi	r24, 0x25	; 37
    d846:	93 e0       	ldi	r25, 0x03	; 3
    d848:	68 e2       	ldi	r22, 0x28	; 40
    d84a:	70 e0       	ldi	r23, 0x00	; 0
    d84c:	44 e0       	ldi	r20, 0x04	; 4
    d84e:	50 e0       	ldi	r21, 0x00	; 0
    d850:	2c ea       	ldi	r18, 0xAC	; 172
    d852:	32 e1       	ldi	r19, 0x12	; 18
    d854:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    d858:	8d b7       	in	r24, 0x3d	; 61
    d85a:	9e b7       	in	r25, 0x3e	; 62
    d85c:	0c 97       	sbiw	r24, 0x0c	; 12
    d85e:	0f b6       	in	r0, 0x3f	; 63
    d860:	f8 94       	cli
    d862:	9e bf       	out	0x3e, r25	; 62
    d864:	0f be       	out	0x3f, r0	; 63
    d866:	8d bf       	out	0x3d, r24	; 61
    d868:	ed b7       	in	r30, 0x3d	; 61
    d86a:	fe b7       	in	r31, 0x3e	; 62
    d86c:	31 96       	adiw	r30, 0x01	; 1
    d86e:	8e 01       	movw	r16, r28
    d870:	0f 5f       	subi	r16, 0xFF	; 255
    d872:	1f 4f       	sbci	r17, 0xFF	; 255
    d874:	ad b7       	in	r26, 0x3d	; 61
    d876:	be b7       	in	r27, 0x3e	; 62
    d878:	12 96       	adiw	r26, 0x02	; 2
    d87a:	1c 93       	st	X, r17
    d87c:	0e 93       	st	-X, r16
    d87e:	11 97       	sbiw	r26, 0x01	; 1
    d880:	8d ed       	ldi	r24, 0xDD	; 221
    d882:	91 e1       	ldi	r25, 0x11	; 17
    d884:	93 83       	std	Z+3, r25	; 0x03
    d886:	82 83       	std	Z+2, r24	; 0x02
    d888:	80 91 25 03 	lds	r24, 0x0325
    d88c:	84 83       	std	Z+4, r24	; 0x04
    d88e:	15 82       	std	Z+5, r1	; 0x05
    d890:	80 91 26 03 	lds	r24, 0x0326
    d894:	86 83       	std	Z+6, r24	; 0x06
    d896:	17 82       	std	Z+7, r1	; 0x07
    d898:	80 91 27 03 	lds	r24, 0x0327
    d89c:	80 87       	std	Z+8, r24	; 0x08
    d89e:	11 86       	std	Z+9, r1	; 0x09
    d8a0:	80 91 28 03 	lds	r24, 0x0328
    d8a4:	82 87       	std	Z+10, r24	; 0x0a
    d8a6:	13 86       	std	Z+11, r1	; 0x0b
    d8a8:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    d8ac:	ed b7       	in	r30, 0x3d	; 61
    d8ae:	fe b7       	in	r31, 0x3e	; 62
    d8b0:	3c 96       	adiw	r30, 0x0c	; 12
    d8b2:	0f b6       	in	r0, 0x3f	; 63
    d8b4:	f8 94       	cli
    d8b6:	fe bf       	out	0x3e, r31	; 62
    d8b8:	0f be       	out	0x3f, r0	; 63
    d8ba:	ed bf       	out	0x3d, r30	; 61
    d8bc:	82 e0       	ldi	r24, 0x02	; 2
    d8be:	61 e0       	ldi	r22, 0x01	; 1
    d8c0:	a8 01       	movw	r20, r16
    d8c2:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    d8c6:	83 e0       	ldi	r24, 0x03	; 3
    d8c8:	61 e0       	ldi	r22, 0x01	; 1
    d8ca:	48 ec       	ldi	r20, 0xC8	; 200
    d8cc:	51 e1       	ldi	r21, 0x11	; 17
    d8ce:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    d8d2:	84 e0       	ldi	r24, 0x04	; 4
    d8d4:	61 e0       	ldi	r22, 0x01	; 1
    d8d6:	43 eb       	ldi	r20, 0xB3	; 179
    d8d8:	51 e1       	ldi	r21, 0x11	; 17
    d8da:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
               iLoop=0;
    d8de:	10 92 24 03 	sts	0x0324, r1
    d8e2:	10 92 23 03 	sts	0x0323, r1
			   y=3,x=8;
    d8e6:	83 e0       	ldi	r24, 0x03	; 3
    d8e8:	80 93 2b 03 	sts	0x032B, r24
    d8ec:	88 e0       	ldi	r24, 0x08	; 8
    d8ee:	80 93 2c 03 	sts	0x032C, r24
			   iInput=0; iBlok=0;
    d8f2:	10 92 2a 03 	sts	0x032A, r1
    d8f6:	10 92 22 03 	sts	0x0322, r1
    d8fa:	10 92 21 03 	sts	0x0321, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d8fe:	80 e3       	ldi	r24, 0x30	; 48
    d900:	80 93 30 03 	sts	0x0330, r24
    d904:	80 93 31 03 	sts	0x0331, r24
    d908:	80 93 32 03 	sts	0x0332, r24
			   stClientIP=cipInputIP; 
    d90c:	82 e0       	ldi	r24, 0x02	; 2
    d90e:	e7 c1       	rjmp	.+974    	; 0xdcde <FMenuSettingClientIP+0x4ea>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    d910:	80 91 23 03 	lds	r24, 0x0323
    d914:	90 91 24 03 	lds	r25, 0x0324
    d918:	01 96       	adiw	r24, 0x01	; 1
    d91a:	90 93 24 03 	sts	0x0324, r25
    d91e:	80 93 23 03 	sts	0x0323, r24
			   if ((iLoop%2000)==0){
    d922:	60 ed       	ldi	r22, 0xD0	; 208
    d924:	77 e0       	ldi	r23, 0x07	; 7
    d926:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
    d92a:	89 2b       	or	r24, r25
    d92c:	81 f4       	brne	.+32     	; 0xd94e <FMenuSettingClientIP+0x15a>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    d92e:	80 91 21 03 	lds	r24, 0x0321
    d932:	90 91 22 03 	lds	r25, 0x0322
    d936:	88 0f       	add	r24, r24
    d938:	99 1f       	adc	r25, r25
    d93a:	88 0f       	add	r24, r24
    d93c:	99 1f       	adc	r25, r25
    d93e:	60 91 2c 03 	lds	r22, 0x032C
    d942:	68 0f       	add	r22, r24
    d944:	80 91 2b 03 	lds	r24, 0x032B
    d948:	4f e5       	ldi	r20, 0x5F	; 95
    d94a:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    d94e:	80 91 23 03 	lds	r24, 0x0323
    d952:	90 91 24 03 	lds	r25, 0x0324
    d956:	60 ed       	ldi	r22, 0xD0	; 208
    d958:	77 e0       	ldi	r23, 0x07	; 7
    d95a:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
    d95e:	88 5e       	subi	r24, 0xE8	; 232
    d960:	93 40       	sbci	r25, 0x03	; 3
    d962:	81 f4       	brne	.+32     	; 0xd984 <FMenuSettingClientIP+0x190>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    d964:	80 91 21 03 	lds	r24, 0x0321
    d968:	90 91 22 03 	lds	r25, 0x0322
    d96c:	88 0f       	add	r24, r24
    d96e:	99 1f       	adc	r25, r25
    d970:	88 0f       	add	r24, r24
    d972:	99 1f       	adc	r25, r25
    d974:	60 91 2c 03 	lds	r22, 0x032C
    d978:	68 0f       	add	r22, r24
    d97a:	80 91 2b 03 	lds	r24, 0x032B
    d97e:	40 e2       	ldi	r20, 0x20	; 32
    d980:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    d984:	81 e0       	ldi	r24, 0x01	; 1
    d986:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    d98a:	80 93 29 03 	sts	0x0329, r24
			   keyChar=_key_btn(keyPressed);
    d98e:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
    d992:	28 2f       	mov	r18, r24
    d994:	80 93 2d 03 	sts	0x032D, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    d998:	80 53       	subi	r24, 0x30	; 48
    d99a:	8a 30       	cpi	r24, 0x0A	; 10
    d99c:	08 f0       	brcs	.+2      	; 0xd9a0 <FMenuSettingClientIP+0x1ac>
    d99e:	d6 c0       	rjmp	.+428    	; 0xdb4c <FMenuSettingClientIP+0x358>
    d9a0:	80 e5       	ldi	r24, 0x50	; 80
    d9a2:	93 ec       	ldi	r25, 0xC3	; 195
    d9a4:	01 97       	sbiw	r24, 0x01	; 1
    d9a6:	f1 f7       	brne	.-4      	; 0xd9a4 <FMenuSettingClientIP+0x1b0>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    d9a8:	80 91 2a 03 	lds	r24, 0x032A
    d9ac:	e8 2f       	mov	r30, r24
    d9ae:	f0 e0       	ldi	r31, 0x00	; 0
    d9b0:	e0 5d       	subi	r30, 0xD0	; 208
    d9b2:	fc 4f       	sbci	r31, 0xFC	; 252
    d9b4:	20 83       	st	Z, r18
				   iInput++;                    
    d9b6:	8f 5f       	subi	r24, 0xFF	; 255
    d9b8:	80 93 2a 03 	sts	0x032A, r24
				   for (i=1;i<(iInput+1);i++){
    d9bc:	81 e0       	ldi	r24, 0x01	; 1
    d9be:	1c c0       	rjmp	.+56     	; 0xd9f8 <FMenuSettingClientIP+0x204>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    d9c0:	80 91 2c 03 	lds	r24, 0x032C
    d9c4:	68 0f       	add	r22, r24
    d9c6:	63 50       	subi	r22, 0x03	; 3
    d9c8:	80 91 21 03 	lds	r24, 0x0321
    d9cc:	90 91 22 03 	lds	r25, 0x0322
    d9d0:	88 0f       	add	r24, r24
    d9d2:	99 1f       	adc	r25, r25
    d9d4:	88 0f       	add	r24, r24
    d9d6:	99 1f       	adc	r25, r25
    d9d8:	68 0f       	add	r22, r24
    d9da:	80 91 2b 03 	lds	r24, 0x032B
    d9de:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
    d9e2:	e0 91 2f 03 	lds	r30, 0x032F
    d9e6:	f0 e0       	ldi	r31, 0x00	; 0
    d9e8:	e1 5d       	subi	r30, 0xD1	; 209
    d9ea:	fc 4f       	sbci	r31, 0xFC	; 252
    d9ec:	80 81       	ld	r24, Z
    d9ee:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    d9f2:	80 91 2f 03 	lds	r24, 0x032F
    d9f6:	8f 5f       	subi	r24, 0xFF	; 255
    d9f8:	80 93 2f 03 	sts	0x032F, r24
    d9fc:	70 91 2a 03 	lds	r23, 0x032A
    da00:	60 91 2f 03 	lds	r22, 0x032F
    da04:	27 2f       	mov	r18, r23
    da06:	30 e0       	ldi	r19, 0x00	; 0
    da08:	86 2f       	mov	r24, r22
    da0a:	90 e0       	ldi	r25, 0x00	; 0
    da0c:	28 17       	cp	r18, r24
    da0e:	39 07       	cpc	r19, r25
    da10:	bc f6       	brge	.-82     	; 0xd9c0 <FMenuSettingClientIP+0x1cc>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    da12:	73 30       	cpi	r23, 0x03	; 3
    da14:	08 f4       	brcc	.+2      	; 0xda18 <FMenuSettingClientIP+0x224>
    da16:	91 c0       	rjmp	.+290    	; 0xdb3a <FMenuSettingClientIP+0x346>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    da18:	40 91 21 03 	lds	r20, 0x0321
    da1c:	50 91 22 03 	lds	r21, 0x0322
    da20:	fa 01       	movw	r30, r20
    da22:	eb 5d       	subi	r30, 0xDB	; 219
    da24:	fc 4f       	sbci	r31, 0xFC	; 252
    da26:	20 91 32 03 	lds	r18, 0x0332
    da2a:	20 5d       	subi	r18, 0xD0	; 208
    da2c:	80 91 30 03 	lds	r24, 0x0330
    da30:	34 e6       	ldi	r19, 0x64	; 100
    da32:	83 9f       	mul	r24, r19
    da34:	c0 01       	movw	r24, r0
    da36:	11 24       	eor	r1, r1
    da38:	28 0f       	add	r18, r24
    da3a:	80 91 31 03 	lds	r24, 0x0331
    da3e:	3a e0       	ldi	r19, 0x0A	; 10
    da40:	83 9f       	mul	r24, r19
    da42:	c0 01       	movw	r24, r0
    da44:	11 24       	eor	r1, r1
    da46:	28 0f       	add	r18, r24
    da48:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    da4a:	80 e3       	ldi	r24, 0x30	; 48
    da4c:	80 93 30 03 	sts	0x0330, r24
    da50:	80 93 31 03 	sts	0x0331, r24
    da54:	80 93 32 03 	sts	0x0332, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    da58:	44 0f       	add	r20, r20
    da5a:	55 1f       	adc	r21, r21
    da5c:	44 0f       	add	r20, r20
    da5e:	55 1f       	adc	r21, r21
    da60:	60 91 2c 03 	lds	r22, 0x032C
    da64:	64 0f       	add	r22, r20
    da66:	67 1b       	sub	r22, r23
    da68:	80 91 2b 03 	lds	r24, 0x032B
    da6c:	4f ea       	ldi	r20, 0xAF	; 175
    da6e:	51 e1       	ldi	r21, 0x11	; 17
    da70:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    da74:	00 d0       	rcall	.+0      	; 0xda76 <FMenuSettingClientIP+0x282>
    da76:	00 d0       	rcall	.+0      	; 0xda78 <FMenuSettingClientIP+0x284>
    da78:	00 d0       	rcall	.+0      	; 0xda7a <FMenuSettingClientIP+0x286>
    da7a:	ad b7       	in	r26, 0x3d	; 61
    da7c:	be b7       	in	r27, 0x3e	; 62
    da7e:	11 96       	adiw	r26, 0x01	; 1
    da80:	8e 01       	movw	r16, r28
    da82:	0f 5f       	subi	r16, 0xFF	; 255
    da84:	1f 4f       	sbci	r17, 0xFF	; 255
    da86:	ed b7       	in	r30, 0x3d	; 61
    da88:	fe b7       	in	r31, 0x3e	; 62
    da8a:	12 83       	std	Z+2, r17	; 0x02
    da8c:	01 83       	std	Z+1, r16	; 0x01
    da8e:	8c ea       	ldi	r24, 0xAC	; 172
    da90:	91 e1       	ldi	r25, 0x11	; 17
    da92:	13 96       	adiw	r26, 0x03	; 3
    da94:	9c 93       	st	X, r25
    da96:	8e 93       	st	-X, r24
    da98:	12 97       	sbiw	r26, 0x02	; 2
    da9a:	e0 91 21 03 	lds	r30, 0x0321
    da9e:	f0 91 22 03 	lds	r31, 0x0322
    daa2:	eb 5d       	subi	r30, 0xDB	; 219
    daa4:	fc 4f       	sbci	r31, 0xFC	; 252
    daa6:	80 81       	ld	r24, Z
    daa8:	14 96       	adiw	r26, 0x04	; 4
    daaa:	8c 93       	st	X, r24
    daac:	14 97       	sbiw	r26, 0x04	; 4
    daae:	15 96       	adiw	r26, 0x05	; 5
    dab0:	1c 92       	st	X, r1
    dab2:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    dab6:	f8 01       	movw	r30, r16
    dab8:	01 90       	ld	r0, Z+
    daba:	00 20       	and	r0, r0
    dabc:	e9 f7       	brne	.-6      	; 0xdab8 <FMenuSettingClientIP+0x2c4>
    dabe:	31 97       	sbiw	r30, 0x01	; 1
    dac0:	e0 1b       	sub	r30, r16
    dac2:	f1 0b       	sbc	r31, r17
    dac4:	8d b7       	in	r24, 0x3d	; 61
    dac6:	9e b7       	in	r25, 0x3e	; 62
    dac8:	06 96       	adiw	r24, 0x06	; 6
    daca:	0f b6       	in	r0, 0x3f	; 63
    dacc:	f8 94       	cli
    dace:	9e bf       	out	0x3e, r25	; 62
    dad0:	0f be       	out	0x3f, r0	; 63
    dad2:	8d bf       	out	0x3d, r24	; 61
    dad4:	60 91 2c 03 	lds	r22, 0x032C
    dad8:	6f 5f       	subi	r22, 0xFF	; 255
    dada:	80 91 21 03 	lds	r24, 0x0321
    dade:	90 91 22 03 	lds	r25, 0x0322
    dae2:	88 0f       	add	r24, r24
    dae4:	99 1f       	adc	r25, r25
    dae6:	88 0f       	add	r24, r24
    dae8:	99 1f       	adc	r25, r25
    daea:	68 0f       	add	r22, r24
    daec:	6e 1b       	sub	r22, r30
    daee:	80 91 2b 03 	lds	r24, 0x032B
    daf2:	a8 01       	movw	r20, r16
    daf4:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    daf8:	80 91 21 03 	lds	r24, 0x0321
    dafc:	90 91 22 03 	lds	r25, 0x0322
    db00:	00 97       	sbiw	r24, 0x00	; 0
    db02:	81 f0       	breq	.+32     	; 0xdb24 <FMenuSettingClientIP+0x330>
    db04:	60 91 2c 03 	lds	r22, 0x032C
    db08:	6f 5f       	subi	r22, 0xFF	; 255
    db0a:	81 50       	subi	r24, 0x01	; 1
    db0c:	90 4c       	sbci	r25, 0xC0	; 192
    db0e:	88 0f       	add	r24, r24
    db10:	99 1f       	adc	r25, r25
    db12:	88 0f       	add	r24, r24
    db14:	99 1f       	adc	r25, r25
    db16:	68 0f       	add	r22, r24
    db18:	80 91 2b 03 	lds	r24, 0x032B
    db1c:	4a ea       	ldi	r20, 0xAA	; 170
    db1e:	51 e1       	ldi	r21, 0x11	; 17
    db20:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
					   iInput=0;
    db24:	10 92 2a 03 	sts	0x032A, r1
					   iBlok++;
    db28:	80 91 21 03 	lds	r24, 0x0321
    db2c:	90 91 22 03 	lds	r25, 0x0322
    db30:	01 96       	adiw	r24, 0x01	; 1
    db32:	90 93 22 03 	sts	0x0322, r25
    db36:	80 93 21 03 	sts	0x0321, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    db3a:	80 91 21 03 	lds	r24, 0x0321
    db3e:	90 91 22 03 	lds	r25, 0x0322
    db42:	04 97       	sbiw	r24, 0x04	; 4
    db44:	18 f0       	brcs	.+6      	; 0xdb4c <FMenuSettingClientIP+0x358>
    db46:	84 e0       	ldi	r24, 0x04	; 4
    db48:	80 93 6e 01 	sts	0x016E, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    db4c:	80 91 29 03 	lds	r24, 0x0329
    db50:	87 3e       	cpi	r24, 0xE7	; 231
    db52:	09 f4       	brne	.+2      	; 0xdb56 <FMenuSettingClientIP+0x362>
    db54:	c3 c0       	rjmp	.+390    	; 0xdcdc <FMenuSettingClientIP+0x4e8>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    db56:	87 3b       	cpi	r24, 0xB7	; 183
    db58:	09 f0       	breq	.+2      	; 0xdb5c <FMenuSettingClientIP+0x368>
    db5a:	c9 c0       	rjmp	.+402    	; 0xdcee <FMenuSettingClientIP+0x4fa>
			       //NextInput
			       if (iBlok<4){
    db5c:	40 91 21 03 	lds	r20, 0x0321
    db60:	50 91 22 03 	lds	r21, 0x0322
    db64:	44 30       	cpi	r20, 0x04	; 4
    db66:	51 05       	cpc	r21, r1
    db68:	08 f0       	brcs	.+2      	; 0xdb6c <FMenuSettingClientIP+0x378>
    db6a:	a6 c0       	rjmp	.+332    	; 0xdcb8 <FMenuSettingClientIP+0x4c4>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    db6c:	80 91 2a 03 	lds	r24, 0x032A
    db70:	81 30       	cpi	r24, 0x01	; 1
    db72:	41 f4       	brne	.+16     	; 0xdb84 <FMenuSettingClientIP+0x390>
    db74:	fa 01       	movw	r30, r20
    db76:	eb 5d       	subi	r30, 0xDB	; 219
    db78:	fc 4f       	sbci	r31, 0xFC	; 252
    db7a:	80 91 30 03 	lds	r24, 0x0330
    db7e:	80 53       	subi	r24, 0x30	; 48
    db80:	80 83       	st	Z, r24
    db82:	22 c0       	rjmp	.+68     	; 0xdbc8 <FMenuSettingClientIP+0x3d4>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    db84:	82 30       	cpi	r24, 0x02	; 2
    db86:	49 f4       	brne	.+18     	; 0xdb9a <FMenuSettingClientIP+0x3a6>
    db88:	fa 01       	movw	r30, r20
    db8a:	eb 5d       	subi	r30, 0xDB	; 219
    db8c:	fc 4f       	sbci	r31, 0xFC	; 252
    db8e:	20 91 31 03 	lds	r18, 0x0331
    db92:	20 51       	subi	r18, 0x10	; 16
    db94:	80 91 30 03 	lds	r24, 0x0330
    db98:	11 c0       	rjmp	.+34     	; 0xdbbc <FMenuSettingClientIP+0x3c8>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    db9a:	83 30       	cpi	r24, 0x03	; 3
    db9c:	a9 f4       	brne	.+42     	; 0xdbc8 <FMenuSettingClientIP+0x3d4>
    db9e:	fa 01       	movw	r30, r20
    dba0:	eb 5d       	subi	r30, 0xDB	; 219
    dba2:	fc 4f       	sbci	r31, 0xFC	; 252
    dba4:	20 91 32 03 	lds	r18, 0x0332
    dba8:	20 5d       	subi	r18, 0xD0	; 208
    dbaa:	80 91 30 03 	lds	r24, 0x0330
    dbae:	34 e6       	ldi	r19, 0x64	; 100
    dbb0:	83 9f       	mul	r24, r19
    dbb2:	c0 01       	movw	r24, r0
    dbb4:	11 24       	eor	r1, r1
    dbb6:	28 0f       	add	r18, r24
    dbb8:	80 91 31 03 	lds	r24, 0x0331
    dbbc:	3a e0       	ldi	r19, 0x0A	; 10
    dbbe:	83 9f       	mul	r24, r19
    dbc0:	c0 01       	movw	r24, r0
    dbc2:	11 24       	eor	r1, r1
    dbc4:	28 0f       	add	r18, r24
    dbc6:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    dbc8:	80 e3       	ldi	r24, 0x30	; 48
    dbca:	80 93 30 03 	sts	0x0330, r24
    dbce:	80 93 31 03 	sts	0x0331, r24
    dbd2:	80 93 32 03 	sts	0x0332, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    dbd6:	60 91 2c 03 	lds	r22, 0x032C
    dbda:	63 50       	subi	r22, 0x03	; 3
    dbdc:	44 0f       	add	r20, r20
    dbde:	55 1f       	adc	r21, r21
    dbe0:	44 0f       	add	r20, r20
    dbe2:	55 1f       	adc	r21, r21
    dbe4:	64 0f       	add	r22, r20
    dbe6:	80 91 2b 03 	lds	r24, 0x032B
    dbea:	46 ea       	ldi	r20, 0xA6	; 166
    dbec:	51 e1       	ldi	r21, 0x11	; 17
    dbee:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    dbf2:	00 d0       	rcall	.+0      	; 0xdbf4 <FMenuSettingClientIP+0x400>
    dbf4:	00 d0       	rcall	.+0      	; 0xdbf6 <FMenuSettingClientIP+0x402>
    dbf6:	00 d0       	rcall	.+0      	; 0xdbf8 <FMenuSettingClientIP+0x404>
    dbf8:	ad b7       	in	r26, 0x3d	; 61
    dbfa:	be b7       	in	r27, 0x3e	; 62
    dbfc:	11 96       	adiw	r26, 0x01	; 1
    dbfe:	8e 01       	movw	r16, r28
    dc00:	0f 5f       	subi	r16, 0xFF	; 255
    dc02:	1f 4f       	sbci	r17, 0xFF	; 255
    dc04:	ed b7       	in	r30, 0x3d	; 61
    dc06:	fe b7       	in	r31, 0x3e	; 62
    dc08:	12 83       	std	Z+2, r17	; 0x02
    dc0a:	01 83       	std	Z+1, r16	; 0x01
    dc0c:	83 ea       	ldi	r24, 0xA3	; 163
    dc0e:	91 e1       	ldi	r25, 0x11	; 17
    dc10:	13 96       	adiw	r26, 0x03	; 3
    dc12:	9c 93       	st	X, r25
    dc14:	8e 93       	st	-X, r24
    dc16:	12 97       	sbiw	r26, 0x02	; 2
    dc18:	e0 91 21 03 	lds	r30, 0x0321
    dc1c:	f0 91 22 03 	lds	r31, 0x0322
    dc20:	eb 5d       	subi	r30, 0xDB	; 219
    dc22:	fc 4f       	sbci	r31, 0xFC	; 252
    dc24:	80 81       	ld	r24, Z
    dc26:	14 96       	adiw	r26, 0x04	; 4
    dc28:	8c 93       	st	X, r24
    dc2a:	14 97       	sbiw	r26, 0x04	; 4
    dc2c:	15 96       	adiw	r26, 0x05	; 5
    dc2e:	1c 92       	st	X, r1
    dc30:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    dc34:	f8 01       	movw	r30, r16
    dc36:	01 90       	ld	r0, Z+
    dc38:	00 20       	and	r0, r0
    dc3a:	e9 f7       	brne	.-6      	; 0xdc36 <FMenuSettingClientIP+0x442>
    dc3c:	31 97       	sbiw	r30, 0x01	; 1
    dc3e:	e0 1b       	sub	r30, r16
    dc40:	f1 0b       	sbc	r31, r17
    dc42:	8d b7       	in	r24, 0x3d	; 61
    dc44:	9e b7       	in	r25, 0x3e	; 62
    dc46:	06 96       	adiw	r24, 0x06	; 6
    dc48:	0f b6       	in	r0, 0x3f	; 63
    dc4a:	f8 94       	cli
    dc4c:	9e bf       	out	0x3e, r25	; 62
    dc4e:	0f be       	out	0x3f, r0	; 63
    dc50:	8d bf       	out	0x3d, r24	; 61
    dc52:	60 91 2c 03 	lds	r22, 0x032C
    dc56:	6f 5f       	subi	r22, 0xFF	; 255
    dc58:	80 91 21 03 	lds	r24, 0x0321
    dc5c:	90 91 22 03 	lds	r25, 0x0322
    dc60:	88 0f       	add	r24, r24
    dc62:	99 1f       	adc	r25, r25
    dc64:	88 0f       	add	r24, r24
    dc66:	99 1f       	adc	r25, r25
    dc68:	68 0f       	add	r22, r24
    dc6a:	6e 1b       	sub	r22, r30
    dc6c:	80 91 2b 03 	lds	r24, 0x032B
    dc70:	a8 01       	movw	r20, r16
    dc72:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    dc76:	80 91 21 03 	lds	r24, 0x0321
    dc7a:	90 91 22 03 	lds	r25, 0x0322
    dc7e:	00 97       	sbiw	r24, 0x00	; 0
    dc80:	81 f0       	breq	.+32     	; 0xdca2 <FMenuSettingClientIP+0x4ae>
    dc82:	60 91 2c 03 	lds	r22, 0x032C
    dc86:	6f 5f       	subi	r22, 0xFF	; 255
    dc88:	81 50       	subi	r24, 0x01	; 1
    dc8a:	90 4c       	sbci	r25, 0xC0	; 192
    dc8c:	88 0f       	add	r24, r24
    dc8e:	99 1f       	adc	r25, r25
    dc90:	88 0f       	add	r24, r24
    dc92:	99 1f       	adc	r25, r25
    dc94:	68 0f       	add	r22, r24
    dc96:	80 91 2b 03 	lds	r24, 0x032B
    dc9a:	41 ea       	ldi	r20, 0xA1	; 161
    dc9c:	51 e1       	ldi	r21, 0x11	; 17
    dc9e:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				       iInput=0;
    dca2:	10 92 2a 03 	sts	0x032A, r1
					   iBlok++;	   
    dca6:	80 91 21 03 	lds	r24, 0x0321
    dcaa:	90 91 22 03 	lds	r25, 0x0322
    dcae:	01 96       	adiw	r24, 0x01	; 1
    dcb0:	90 93 22 03 	sts	0x0322, r25
    dcb4:	80 93 21 03 	sts	0x0321, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    dcb8:	80 91 21 03 	lds	r24, 0x0321
    dcbc:	90 91 22 03 	lds	r25, 0x0322
    dcc0:	04 97       	sbiw	r24, 0x04	; 4
    dcc2:	a8 f0       	brcs	.+42     	; 0xdcee <FMenuSettingClientIP+0x4fa>
    dcc4:	84 e0       	ldi	r24, 0x04	; 4
    dcc6:	0b c0       	rjmp	.+22     	; 0xdcde <FMenuSettingClientIP+0x4ea>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    dcc8:	88 e2       	ldi	r24, 0x28	; 40
    dcca:	90 e0       	ldi	r25, 0x00	; 0
    dccc:	65 e2       	ldi	r22, 0x25	; 37
    dcce:	73 e0       	ldi	r23, 0x03	; 3
    dcd0:	44 e0       	ldi	r20, 0x04	; 4
    dcd2:	50 e0       	ldi	r21, 0x00	; 0
    dcd4:	24 eb       	ldi	r18, 0xB4	; 180
    dcd6:	32 e1       	ldi	r19, 0x12	; 18
    dcd8:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
			   }
		       break;
          case cipStoreIPblok://UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefClientIP,4);
			   stClientIP=cipExit;
    dcdc:	83 e0       	ldi	r24, 0x03	; 3
    dcde:	80 93 6e 01 	sts	0x016E, r24
    dce2:	05 c0       	rjmp	.+10     	; 0xdcee <FMenuSettingClientIP+0x4fa>
		       break; 
          case cipExit://Cancel IPConfig
		       stClientIP=cipInit;
    dce4:	81 e0       	ldi	r24, 0x01	; 1
    dce6:	80 93 6e 01 	sts	0x016E, r24
		       Result=MENU_DONE;
    dcea:	80 93 2e 03 	sts	0x032E, r24
		       break;     
		  }//EndSwitch	 
    return Result;
}
    dcee:	80 91 2e 03 	lds	r24, 0x032E
    dcf2:	64 96       	adiw	r28, 0x14	; 20
    dcf4:	0f b6       	in	r0, 0x3f	; 63
    dcf6:	f8 94       	cli
    dcf8:	de bf       	out	0x3e, r29	; 62
    dcfa:	0f be       	out	0x3f, r0	; 63
    dcfc:	cd bf       	out	0x3d, r28	; 61
    dcfe:	cf 91       	pop	r28
    dd00:	df 91       	pop	r29
    dd02:	1f 91       	pop	r17
    dd04:	0f 91       	pop	r16
    dd06:	08 95       	ret

0000dd08 <DisplayStandaloneSequence>:
	 i++;
     _delay_ms(6500);
  return Result;
}

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
    dd08:	df 93       	push	r29
    dd0a:	cf 93       	push	r28
    dd0c:	cd b7       	in	r28, 0x3d	; 61
    dd0e:	de b7       	in	r29, 0x3e	; 62
    dd10:	28 97       	sbiw	r28, 0x08	; 8
    dd12:	0f b6       	in	r0, 0x3f	; 63
    dd14:	f8 94       	cli
    dd16:	de bf       	out	0x3e, r29	; 62
    dd18:	0f be       	out	0x3f, r0	; 63
    dd1a:	cd bf       	out	0x3d, r28	; 61
    dd1c:	58 2f       	mov	r21, r24
	 MapSequence[3]='/';
	 MapSequence[4]='-';
	 MapSequence[5]=164;//0x5C;
	 MapSequence[6]='|';
	 MapSequence[7]='/';
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    dd1e:	80 91 ac 01 	lds	r24, 0x01AC
    dd22:	88 23       	and	r24, r24
    dd24:	a1 f4       	brne	.+40     	; 0xdd4e <DisplayStandaloneSequence+0x46>

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
     char MapSequence[8];

     //sprintf_P(MapSequence,PSTR("-\|/-|/"));
	 MapSequence[0]='-';
    dd26:	3d e2       	ldi	r19, 0x2D	; 45
    dd28:	39 83       	std	Y+1, r19	; 0x01
	 MapSequence[1]='`';//0x5C;
    dd2a:	80 e6       	ldi	r24, 0x60	; 96
    dd2c:	8a 83       	std	Y+2, r24	; 0x02
	 MapSequence[2]='|';
    dd2e:	2c e7       	ldi	r18, 0x7C	; 124
    dd30:	2b 83       	std	Y+3, r18	; 0x03
	 MapSequence[3]='/';
    dd32:	9f e2       	ldi	r25, 0x2F	; 47
    dd34:	9c 83       	std	Y+4, r25	; 0x04
	 MapSequence[4]='-';
    dd36:	3d 83       	std	Y+5, r19	; 0x05
	 MapSequence[5]=164;//0x5C;
    dd38:	84 ea       	ldi	r24, 0xA4	; 164
    dd3a:	8e 83       	std	Y+6, r24	; 0x06
	 MapSequence[6]='|';
    dd3c:	2f 83       	std	Y+7, r18	; 0x07
	 MapSequence[7]='/';
    dd3e:	98 87       	std	Y+8, r25	; 0x08
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    dd40:	47 70       	andi	r20, 0x07	; 7
    dd42:	fe 01       	movw	r30, r28
    dd44:	e4 0f       	add	r30, r20
    dd46:	f1 1d       	adc	r31, r1
    dd48:	85 2f       	mov	r24, r21
    dd4a:	41 81       	ldd	r20, Z+1	; 0x01
    dd4c:	08 c0       	rjmp	.+16     	; 0xdd5e <DisplayStandaloneSequence+0x56>
	 else if (IsPoolingRestarted==True){
    dd4e:	80 91 ac 01 	lds	r24, 0x01AC
    dd52:	81 30       	cpi	r24, 0x01	; 1
    dd54:	31 f4       	brne	.+12     	; 0xdd62 <DisplayStandaloneSequence+0x5a>
	          IsPoolingRestarted=False;
    dd56:	10 92 ac 01 	sts	0x01AC, r1
	          lcd_put(x,y,'X');     
    dd5a:	85 2f       	mov	r24, r21
    dd5c:	48 e5       	ldi	r20, 0x58	; 88
    dd5e:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
			  }

}
    dd62:	28 96       	adiw	r28, 0x08	; 8
    dd64:	0f b6       	in	r0, 0x3f	; 63
    dd66:	f8 94       	cli
    dd68:	de bf       	out	0x3e, r29	; 62
    dd6a:	0f be       	out	0x3f, r0	; 63
    dd6c:	cd bf       	out	0x3d, r28	; 61
    dd6e:	cf 91       	pop	r28
    dd70:	df 91       	pop	r29
    dd72:	08 95       	ret

0000dd74 <FSettingPumpPooling>:
	      break;
	 }
     return Result;
}

char FSettingPumpPooling(){//Parameter: PumpCount,
    dd74:	0f 93       	push	r16
    dd76:	1f 93       	push	r17
    dd78:	df 93       	push	r29
    dd7a:	cf 93       	push	r28
    dd7c:	cd b7       	in	r28, 0x3d	; 61
    dd7e:	de b7       	in	r29, 0x3e	; 62
    dd80:	6a 97       	sbiw	r28, 0x1a	; 26
    dd82:	0f b6       	in	r0, 0x3f	; 63
    dd84:	f8 94       	cli
    dd86:	de bf       	out	0x3e, r29	; 62
    dd88:	0f be       	out	0x3f, r0	; 63
    dd8a:	cd bf       	out	0x3d, r28	; 61
static char stPumpPooling=ppInitMenu;
char i,lcdteks[20];
char KeyChar,Addr,PPoolingSetting[6];
     Result=MENU_NONE;

     switch(stPumpPooling){
    dd8c:	80 91 fc 02 	lds	r24, 0x02FC
    dd90:	82 30       	cpi	r24, 0x02	; 2
    dd92:	09 f4       	brne	.+2      	; 0xdd96 <FSettingPumpPooling+0x22>
    dd94:	1b c1       	rjmp	.+566    	; 0xdfcc <FSettingPumpPooling+0x258>
    dd96:	83 30       	cpi	r24, 0x03	; 3
    dd98:	30 f4       	brcc	.+12     	; 0xdda6 <FSettingPumpPooling+0x32>
    dd9a:	88 23       	and	r24, r24
    dd9c:	59 f0       	breq	.+22     	; 0xddb4 <FSettingPumpPooling+0x40>
    dd9e:	81 30       	cpi	r24, 0x01	; 1
    dda0:	09 f0       	breq	.+2      	; 0xdda4 <FSettingPumpPooling+0x30>
    dda2:	1b c2       	rjmp	.+1078   	; 0xe1da <FSettingPumpPooling+0x466>
    dda4:	09 c1       	rjmp	.+530    	; 0xdfb8 <FSettingPumpPooling+0x244>
    dda6:	83 30       	cpi	r24, 0x03	; 3
    dda8:	09 f4       	brne	.+2      	; 0xddac <FSettingPumpPooling+0x38>
    ddaa:	06 c2       	rjmp	.+1036   	; 0xe1b8 <FSettingPumpPooling+0x444>
    ddac:	84 30       	cpi	r24, 0x04	; 4
    ddae:	09 f0       	breq	.+2      	; 0xddb2 <FSettingPumpPooling+0x3e>
    ddb0:	14 c2       	rjmp	.+1064   	; 0xe1da <FSettingPumpPooling+0x466>
    ddb2:	0f c2       	rjmp	.+1054   	; 0xe1d2 <FSettingPumpPooling+0x45e>
	 case ppInitMenu:
          lcd_clear();
    ddb4:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    ddb8:	20 e0       	ldi	r18, 0x00	; 0
    ddba:	30 e0       	ldi	r19, 0x00	; 0
		  for (i=0;i<6;i++){
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
    ddbc:	ae 01       	movw	r20, r28
    ddbe:	4f 5f       	subi	r20, 0xFF	; 255
    ddc0:	5f 4f       	sbci	r21, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ddc2:	e1 99       	sbic	0x1c, 1	; 28
    ddc4:	fe cf       	rjmp	.-4      	; 0xddc2 <FSettingPumpPooling+0x4e>
    ddc6:	c9 01       	movw	r24, r18
    ddc8:	8c 58       	subi	r24, 0x8C	; 140
    ddca:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ddcc:	9f bb       	out	0x1f, r25	; 31
    ddce:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ddd0:	e0 9a       	sbi	0x1c, 0	; 28
    ddd2:	8d b3       	in	r24, 0x1d	; 29
    ddd4:	fa 01       	movw	r30, r20
    ddd6:	e2 0f       	add	r30, r18
    ddd8:	f3 1f       	adc	r31, r19
    ddda:	80 83       	st	Z, r24
    dddc:	2f 5f       	subi	r18, 0xFF	; 255
    ddde:	3f 4f       	sbci	r19, 0xFF	; 255
     Result=MENU_NONE;

     switch(stPumpPooling){
	 case ppInitMenu:
          lcd_clear();
		  for (i=0;i<6;i++){
    dde0:	26 30       	cpi	r18, 0x06	; 6
    dde2:	31 05       	cpc	r19, r1
    dde4:	71 f7       	brne	.-36     	; 0xddc2 <FSettingPumpPooling+0x4e>
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
		  }

		  sprintf_P(lcdteks,PSTR("1.MaxPump:%d"),PPoolingSetting[0]);lcd_print(1,1,lcdteks);
    dde6:	00 d0       	rcall	.+0      	; 0xdde8 <FSettingPumpPooling+0x74>
    dde8:	00 d0       	rcall	.+0      	; 0xddea <FSettingPumpPooling+0x76>
    ddea:	00 d0       	rcall	.+0      	; 0xddec <FSettingPumpPooling+0x78>
    ddec:	ed b7       	in	r30, 0x3d	; 61
    ddee:	fe b7       	in	r31, 0x3e	; 62
    ddf0:	31 96       	adiw	r30, 0x01	; 1
    ddf2:	8e 01       	movw	r16, r28
    ddf4:	09 5f       	subi	r16, 0xF9	; 249
    ddf6:	1f 4f       	sbci	r17, 0xFF	; 255
    ddf8:	ad b7       	in	r26, 0x3d	; 61
    ddfa:	be b7       	in	r27, 0x3e	; 62
    ddfc:	12 96       	adiw	r26, 0x02	; 2
    ddfe:	1c 93       	st	X, r17
    de00:	0e 93       	st	-X, r16
    de02:	11 97       	sbiw	r26, 0x01	; 1
    de04:	8b ef       	ldi	r24, 0xFB	; 251
    de06:	9e e0       	ldi	r25, 0x0E	; 14
    de08:	93 83       	std	Z+3, r25	; 0x03
    de0a:	82 83       	std	Z+2, r24	; 0x02
    de0c:	89 81       	ldd	r24, Y+1	; 0x01
    de0e:	84 83       	std	Z+4, r24	; 0x04
    de10:	15 82       	std	Z+5, r1	; 0x05
    de12:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    de16:	ed b7       	in	r30, 0x3d	; 61
    de18:	fe b7       	in	r31, 0x3e	; 62
    de1a:	36 96       	adiw	r30, 0x06	; 6
    de1c:	0f b6       	in	r0, 0x3f	; 63
    de1e:	f8 94       	cli
    de20:	fe bf       	out	0x3e, r31	; 62
    de22:	0f be       	out	0x3f, r0	; 63
    de24:	ed bf       	out	0x3d, r30	; 61
    de26:	81 e0       	ldi	r24, 0x01	; 1
    de28:	61 e0       	ldi	r22, 0x01	; 1
    de2a:	a8 01       	movw	r20, r16
    de2c:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
          sprintf_P(lcdteks,PSTR("2.nNoPump:%d"),PPoolingSetting[1]);lcd_print(2,1,lcdteks);
    de30:	00 d0       	rcall	.+0      	; 0xde32 <FSettingPumpPooling+0xbe>
    de32:	00 d0       	rcall	.+0      	; 0xde34 <FSettingPumpPooling+0xc0>
    de34:	00 d0       	rcall	.+0      	; 0xde36 <FSettingPumpPooling+0xc2>
    de36:	ed b7       	in	r30, 0x3d	; 61
    de38:	fe b7       	in	r31, 0x3e	; 62
    de3a:	31 96       	adiw	r30, 0x01	; 1
    de3c:	ad b7       	in	r26, 0x3d	; 61
    de3e:	be b7       	in	r27, 0x3e	; 62
    de40:	12 96       	adiw	r26, 0x02	; 2
    de42:	1c 93       	st	X, r17
    de44:	0e 93       	st	-X, r16
    de46:	11 97       	sbiw	r26, 0x01	; 1
    de48:	8e ee       	ldi	r24, 0xEE	; 238
    de4a:	9e e0       	ldi	r25, 0x0E	; 14
    de4c:	93 83       	std	Z+3, r25	; 0x03
    de4e:	82 83       	std	Z+2, r24	; 0x02
    de50:	8a 81       	ldd	r24, Y+2	; 0x02
    de52:	84 83       	std	Z+4, r24	; 0x04
    de54:	15 82       	std	Z+5, r1	; 0x05
    de56:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    de5a:	ed b7       	in	r30, 0x3d	; 61
    de5c:	fe b7       	in	r31, 0x3e	; 62
    de5e:	36 96       	adiw	r30, 0x06	; 6
    de60:	0f b6       	in	r0, 0x3f	; 63
    de62:	f8 94       	cli
    de64:	fe bf       	out	0x3e, r31	; 62
    de66:	0f be       	out	0x3f, r0	; 63
    de68:	ed bf       	out	0x3d, r30	; 61
    de6a:	82 e0       	ldi	r24, 0x02	; 2
    de6c:	61 e0       	ldi	r22, 0x01	; 1
    de6e:	a8 01       	movw	r20, r16
    de70:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
          sprintf_P(lcdteks,PSTR("3.TrySend:%d"),PPoolingSetting[2]);lcd_print(3,1,lcdteks);
    de74:	00 d0       	rcall	.+0      	; 0xde76 <FSettingPumpPooling+0x102>
    de76:	00 d0       	rcall	.+0      	; 0xde78 <FSettingPumpPooling+0x104>
    de78:	00 d0       	rcall	.+0      	; 0xde7a <FSettingPumpPooling+0x106>
    de7a:	ed b7       	in	r30, 0x3d	; 61
    de7c:	fe b7       	in	r31, 0x3e	; 62
    de7e:	31 96       	adiw	r30, 0x01	; 1
    de80:	ad b7       	in	r26, 0x3d	; 61
    de82:	be b7       	in	r27, 0x3e	; 62
    de84:	12 96       	adiw	r26, 0x02	; 2
    de86:	1c 93       	st	X, r17
    de88:	0e 93       	st	-X, r16
    de8a:	11 97       	sbiw	r26, 0x01	; 1
    de8c:	81 ee       	ldi	r24, 0xE1	; 225
    de8e:	9e e0       	ldi	r25, 0x0E	; 14
    de90:	93 83       	std	Z+3, r25	; 0x03
    de92:	82 83       	std	Z+2, r24	; 0x02
    de94:	8b 81       	ldd	r24, Y+3	; 0x03
    de96:	84 83       	std	Z+4, r24	; 0x04
    de98:	15 82       	std	Z+5, r1	; 0x05
    de9a:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    de9e:	ed b7       	in	r30, 0x3d	; 61
    dea0:	fe b7       	in	r31, 0x3e	; 62
    dea2:	36 96       	adiw	r30, 0x06	; 6
    dea4:	0f b6       	in	r0, 0x3f	; 63
    dea6:	f8 94       	cli
    dea8:	fe bf       	out	0x3e, r31	; 62
    deaa:	0f be       	out	0x3f, r0	; 63
    deac:	ed bf       	out	0x3d, r30	; 61
    deae:	83 e0       	ldi	r24, 0x03	; 3
    deb0:	61 e0       	ldi	r22, 0x01	; 1
    deb2:	a8 01       	movw	r20, r16
    deb4:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
          sprintf_P(lcdteks,PSTR("4.TimPool:%d"),PPoolingSetting[3]);lcd_print(4,1,lcdteks);
    deb8:	00 d0       	rcall	.+0      	; 0xdeba <FSettingPumpPooling+0x146>
    deba:	00 d0       	rcall	.+0      	; 0xdebc <FSettingPumpPooling+0x148>
    debc:	00 d0       	rcall	.+0      	; 0xdebe <FSettingPumpPooling+0x14a>
    debe:	ed b7       	in	r30, 0x3d	; 61
    dec0:	fe b7       	in	r31, 0x3e	; 62
    dec2:	31 96       	adiw	r30, 0x01	; 1
    dec4:	ad b7       	in	r26, 0x3d	; 61
    dec6:	be b7       	in	r27, 0x3e	; 62
    dec8:	12 96       	adiw	r26, 0x02	; 2
    deca:	1c 93       	st	X, r17
    decc:	0e 93       	st	-X, r16
    dece:	11 97       	sbiw	r26, 0x01	; 1
    ded0:	84 ed       	ldi	r24, 0xD4	; 212
    ded2:	9e e0       	ldi	r25, 0x0E	; 14
    ded4:	93 83       	std	Z+3, r25	; 0x03
    ded6:	82 83       	std	Z+2, r24	; 0x02
    ded8:	8c 81       	ldd	r24, Y+4	; 0x04
    deda:	84 83       	std	Z+4, r24	; 0x04
    dedc:	15 82       	std	Z+5, r1	; 0x05
    dede:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    dee2:	ed b7       	in	r30, 0x3d	; 61
    dee4:	fe b7       	in	r31, 0x3e	; 62
    dee6:	36 96       	adiw	r30, 0x06	; 6
    dee8:	0f b6       	in	r0, 0x3f	; 63
    deea:	f8 94       	cli
    deec:	fe bf       	out	0x3e, r31	; 62
    deee:	0f be       	out	0x3f, r0	; 63
    def0:	ed bf       	out	0x3d, r30	; 61
    def2:	84 e0       	ldi	r24, 0x04	; 4
    def4:	61 e0       	ldi	r22, 0x01	; 1
    def6:	a8 01       	movw	r20, r16
    def8:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
          sprintf_P(lcdteks,PSTR("5.Dly:%d"),PPoolingSetting[4]);lcd_print(1,13,lcdteks);
    defc:	00 d0       	rcall	.+0      	; 0xdefe <FSettingPumpPooling+0x18a>
    defe:	00 d0       	rcall	.+0      	; 0xdf00 <FSettingPumpPooling+0x18c>
    df00:	00 d0       	rcall	.+0      	; 0xdf02 <FSettingPumpPooling+0x18e>
    df02:	ed b7       	in	r30, 0x3d	; 61
    df04:	fe b7       	in	r31, 0x3e	; 62
    df06:	31 96       	adiw	r30, 0x01	; 1
    df08:	ad b7       	in	r26, 0x3d	; 61
    df0a:	be b7       	in	r27, 0x3e	; 62
    df0c:	12 96       	adiw	r26, 0x02	; 2
    df0e:	1c 93       	st	X, r17
    df10:	0e 93       	st	-X, r16
    df12:	11 97       	sbiw	r26, 0x01	; 1
    df14:	8b ec       	ldi	r24, 0xCB	; 203
    df16:	9e e0       	ldi	r25, 0x0E	; 14
    df18:	93 83       	std	Z+3, r25	; 0x03
    df1a:	82 83       	std	Z+2, r24	; 0x02
    df1c:	8d 81       	ldd	r24, Y+5	; 0x05
    df1e:	84 83       	std	Z+4, r24	; 0x04
    df20:	15 82       	std	Z+5, r1	; 0x05
    df22:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    df26:	ed b7       	in	r30, 0x3d	; 61
    df28:	fe b7       	in	r31, 0x3e	; 62
    df2a:	36 96       	adiw	r30, 0x06	; 6
    df2c:	0f b6       	in	r0, 0x3f	; 63
    df2e:	f8 94       	cli
    df30:	fe bf       	out	0x3e, r31	; 62
    df32:	0f be       	out	0x3f, r0	; 63
    df34:	ed bf       	out	0x3d, r30	; 61
    df36:	81 e0       	ldi	r24, 0x01	; 1
    df38:	6d e0       	ldi	r22, 0x0D	; 13
    df3a:	a8 01       	movw	r20, r16
    df3c:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
          sprintf_P(lcdteks,PSTR("6.Act:%d"),PPoolingSetting[5]);lcd_print(2,13,lcdteks);
    df40:	00 d0       	rcall	.+0      	; 0xdf42 <FSettingPumpPooling+0x1ce>
    df42:	00 d0       	rcall	.+0      	; 0xdf44 <FSettingPumpPooling+0x1d0>
    df44:	00 d0       	rcall	.+0      	; 0xdf46 <FSettingPumpPooling+0x1d2>
    df46:	ed b7       	in	r30, 0x3d	; 61
    df48:	fe b7       	in	r31, 0x3e	; 62
    df4a:	31 96       	adiw	r30, 0x01	; 1
    df4c:	ad b7       	in	r26, 0x3d	; 61
    df4e:	be b7       	in	r27, 0x3e	; 62
    df50:	12 96       	adiw	r26, 0x02	; 2
    df52:	1c 93       	st	X, r17
    df54:	0e 93       	st	-X, r16
    df56:	11 97       	sbiw	r26, 0x01	; 1
    df58:	82 ec       	ldi	r24, 0xC2	; 194
    df5a:	9e e0       	ldi	r25, 0x0E	; 14
    df5c:	93 83       	std	Z+3, r25	; 0x03
    df5e:	82 83       	std	Z+2, r24	; 0x02
    df60:	8e 81       	ldd	r24, Y+6	; 0x06
    df62:	84 83       	std	Z+4, r24	; 0x04
    df64:	15 82       	std	Z+5, r1	; 0x05
    df66:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    df6a:	ed b7       	in	r30, 0x3d	; 61
    df6c:	fe b7       	in	r31, 0x3e	; 62
    df6e:	36 96       	adiw	r30, 0x06	; 6
    df70:	0f b6       	in	r0, 0x3f	; 63
    df72:	f8 94       	cli
    df74:	fe bf       	out	0x3e, r31	; 62
    df76:	0f be       	out	0x3f, r0	; 63
    df78:	ed bf       	out	0x3d, r30	; 61
    df7a:	82 e0       	ldi	r24, 0x02	; 2
    df7c:	6d e0       	ldi	r22, 0x0D	; 13
    df7e:	a8 01       	movw	r20, r16
    df80:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
          sprintf_P(lcdteks,PSTR("[*]Exit"));lcd_print(4,13,lcdteks);
    df84:	00 d0       	rcall	.+0      	; 0xdf86 <FSettingPumpPooling+0x212>
    df86:	00 d0       	rcall	.+0      	; 0xdf88 <FSettingPumpPooling+0x214>
    df88:	ad b7       	in	r26, 0x3d	; 61
    df8a:	be b7       	in	r27, 0x3e	; 62
    df8c:	12 96       	adiw	r26, 0x02	; 2
    df8e:	1c 93       	st	X, r17
    df90:	0e 93       	st	-X, r16
    df92:	11 97       	sbiw	r26, 0x01	; 1
    df94:	8a eb       	ldi	r24, 0xBA	; 186
    df96:	9e e0       	ldi	r25, 0x0E	; 14
    df98:	14 96       	adiw	r26, 0x04	; 4
    df9a:	9c 93       	st	X, r25
    df9c:	8e 93       	st	-X, r24
    df9e:	13 97       	sbiw	r26, 0x03	; 3
    dfa0:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    dfa4:	0f 90       	pop	r0
    dfa6:	0f 90       	pop	r0
    dfa8:	0f 90       	pop	r0
    dfaa:	0f 90       	pop	r0
    dfac:	84 e0       	ldi	r24, 0x04	; 4
    dfae:	6d e0       	ldi	r22, 0x0D	; 13
    dfb0:	a8 01       	movw	r20, r16
    dfb2:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    dfb6:	08 c0       	rjmp	.+16     	; 0xdfc8 <FSettingPumpPooling+0x254>

          stPumpPooling=ppPoolingSettingInput;
	      break;
     case ppDisplaySequence:
          IsNewPoolingSequence=False;
    dfb8:	10 92 aa 01 	sts	0x01AA, r1
		  DisplayStandaloneSequence(3,14,iSequencePooling);
    dfbc:	83 e0       	ldi	r24, 0x03	; 3
    dfbe:	6e e0       	ldi	r22, 0x0E	; 14
    dfc0:	40 91 a9 01 	lds	r20, 0x01A9
    dfc4:	0e 94 84 6e 	call	0xdd08	; 0xdd08 <DisplayStandaloneSequence>
          stPumpPooling=ppPoolingSettingInput;
    dfc8:	82 e0       	ldi	r24, 0x02	; 2
    dfca:	f3 c0       	rjmp	.+486    	; 0xe1b2 <FSettingPumpPooling+0x43e>
	      break;
     case ppPoolingSettingInput:
	      if(IsNewPoolingSequence==True)stPumpPooling=ppDisplaySequence;
    dfcc:	80 91 aa 01 	lds	r24, 0x01AA
    dfd0:	81 30       	cpi	r24, 0x01	; 1
    dfd2:	11 f4       	brne	.+4      	; 0xdfd8 <FSettingPumpPooling+0x264>
    dfd4:	80 93 fc 02 	sts	0x02FC, r24

          KeyChar=_key_btn(_key_scan(1));
    dfd8:	81 e0       	ldi	r24, 0x01	; 1
    dfda:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    dfde:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    dfe2:	48 2f       	mov	r20, r24
    dfe4:	41 53       	subi	r20, 0x31	; 49
    dfe6:	46 30       	cpi	r20, 0x06	; 6
    dfe8:	10 f0       	brcs	.+4      	; 0xdfee <FSettingPumpPooling+0x27a>
    dfea:	40 e0       	ldi	r20, 0x00	; 0
    dfec:	06 c0       	rjmp	.+12     	; 0xdffa <FSettingPumpPooling+0x286>
		      Addr=KeyChar-'1';
			  TimSend=0;
    dfee:	10 92 be 01 	sts	0x01BE, r1
    dff2:	10 92 bd 01 	sts	0x01BD, r1
			  IsStandaloneAcknoledge=False;
    dff6:	10 92 ab 01 	sts	0x01AB, r1
          }
		  switch(KeyChar){
    dffa:	83 33       	cpi	r24, 0x33	; 51
    dffc:	09 f4       	brne	.+2      	; 0xe000 <FSettingPumpPooling+0x28c>
    dffe:	67 c0       	rjmp	.+206    	; 0xe0ce <FSettingPumpPooling+0x35a>
    e000:	84 33       	cpi	r24, 0x34	; 52
    e002:	48 f4       	brcc	.+18     	; 0xe016 <FSettingPumpPooling+0x2a2>
    e004:	81 33       	cpi	r24, 0x31	; 49
    e006:	89 f0       	breq	.+34     	; 0xe02a <FSettingPumpPooling+0x2b6>
    e008:	82 33       	cpi	r24, 0x32	; 50
    e00a:	08 f0       	brcs	.+2      	; 0xe00e <FSettingPumpPooling+0x29a>
    e00c:	3d c0       	rjmp	.+122    	; 0xe088 <FSettingPumpPooling+0x314>
    e00e:	8a 32       	cpi	r24, 0x2A	; 42
    e010:	09 f0       	breq	.+2      	; 0xe014 <FSettingPumpPooling+0x2a0>
    e012:	e3 c0       	rjmp	.+454    	; 0xe1da <FSettingPumpPooling+0x466>
    e014:	cd c0       	rjmp	.+410    	; 0xe1b0 <FSettingPumpPooling+0x43c>
    e016:	85 33       	cpi	r24, 0x35	; 53
    e018:	09 f4       	brne	.+2      	; 0xe01c <FSettingPumpPooling+0x2a8>
    e01a:	91 c0       	rjmp	.+290    	; 0xe13e <FSettingPumpPooling+0x3ca>
    e01c:	85 33       	cpi	r24, 0x35	; 53
    e01e:	08 f4       	brcc	.+2      	; 0xe022 <FSettingPumpPooling+0x2ae>
    e020:	78 c0       	rjmp	.+240    	; 0xe112 <FSettingPumpPooling+0x39e>
    e022:	86 33       	cpi	r24, 0x36	; 54
    e024:	09 f0       	breq	.+2      	; 0xe028 <FSettingPumpPooling+0x2b4>
    e026:	d9 c0       	rjmp	.+434    	; 0xe1da <FSettingPumpPooling+0x466>
    e028:	a0 c0       	rjmp	.+320    	; 0xe16a <FSettingPumpPooling+0x3f6>
		  case '1'://MaxPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%17);
    e02a:	24 2f       	mov	r18, r20
    e02c:	30 e0       	ldi	r19, 0x00	; 0
    e02e:	fe 01       	movw	r30, r28
    e030:	31 96       	adiw	r30, 0x01	; 1
    e032:	e2 0f       	add	r30, r18
    e034:	f3 1f       	adc	r31, r19
    e036:	80 81       	ld	r24, Z
    e038:	90 e0       	ldi	r25, 0x00	; 0
    e03a:	01 96       	adiw	r24, 0x01	; 1
    e03c:	61 e1       	ldi	r22, 0x11	; 17
    e03e:	70 e0       	ldi	r23, 0x00	; 0
    e040:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    e044:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    e046:	88 23       	and	r24, r24
    e048:	11 f4       	brne	.+4      	; 0xe04e <FSettingPumpPooling+0x2da>
    e04a:	81 e0       	ldi	r24, 0x01	; 1
    e04c:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
    e04e:	2c 0f       	add	r18, r28
    e050:	3d 1f       	adc	r19, r29
    e052:	f9 01       	movw	r30, r18
    e054:	21 81       	ldd	r18, Z+1	; 0x01
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e056:	85 e1       	ldi	r24, 0x15	; 21
    e058:	80 93 b6 07 	sts	0x07B6, r24
	 PoolMsg=plMsg;
    e05c:	20 93 de 0d 	sts	0x0DDE, r18
     IsControlPooling=True;
    e060:	81 e0       	ldi	r24, 0x01	; 1
    e062:	80 93 ad 01 	sts	0x01AD, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e066:	e1 99       	sbic	0x1c, 1	; 28
    e068:	fe cf       	rjmp	.-4      	; 0xe066 <FSettingPumpPooling+0x2f2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e06a:	84 2f       	mov	r24, r20
    e06c:	90 e0       	ldi	r25, 0x00	; 0
    e06e:	8c 58       	subi	r24, 0x8C	; 140
    e070:	9e 4f       	sbci	r25, 0xFE	; 254
    e072:	9f bb       	out	0x1f, r25	; 31
    e074:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    e076:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    e078:	0f b6       	in	r0, 0x3f	; 63
    e07a:	f8 94       	cli
    e07c:	e2 9a       	sbi	0x1c, 2	; 28
    e07e:	e1 9a       	sbi	0x1c, 1	; 28
    e080:	0f be       	out	0x3f, r0	; 63
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   PumpCountMax=PPoolingSetting[Addr];
    e082:	20 93 75 01 	sts	0x0175, r18
    e086:	21 c0       	rjmp	.+66     	; 0xe0ca <FSettingPumpPooling+0x356>
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '2'://NoPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e088:	fe 01       	movw	r30, r28
    e08a:	e4 0f       	add	r30, r20
    e08c:	f1 1d       	adc	r31, r1
    e08e:	81 81       	ldd	r24, Z+1	; 0x01
    e090:	90 e0       	ldi	r25, 0x00	; 0
    e092:	01 96       	adiw	r24, 0x01	; 1
    e094:	65 e1       	ldi	r22, 0x15	; 21
    e096:	70 e0       	ldi	r23, 0x00	; 0
    e098:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    e09c:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e09e:	84 e1       	ldi	r24, 0x14	; 20
    e0a0:	80 93 b6 07 	sts	0x07B6, r24
	 PoolMsg=plMsg;
    e0a4:	20 93 de 0d 	sts	0x0DDE, r18
     IsControlPooling=True;
    e0a8:	81 e0       	ldi	r24, 0x01	; 1
    e0aa:	80 93 ad 01 	sts	0x01AD, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e0ae:	e1 99       	sbic	0x1c, 1	; 28
    e0b0:	fe cf       	rjmp	.-4      	; 0xe0ae <FSettingPumpPooling+0x33a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e0b2:	84 2f       	mov	r24, r20
    e0b4:	90 e0       	ldi	r25, 0x00	; 0
    e0b6:	8c 58       	subi	r24, 0x8C	; 140
    e0b8:	9e 4f       	sbci	r25, 0xFE	; 254
    e0ba:	9f bb       	out	0x1f, r25	; 31
    e0bc:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    e0be:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    e0c0:	0f b6       	in	r0, 0x3f	; 63
    e0c2:	f8 94       	cli
    e0c4:	e2 9a       	sbi	0x1c, 2	; 28
    e0c6:	e1 9a       	sbi	0x1c, 1	; 28
    e0c8:	0f be       	out	0x3f, r0	; 63
			   //SendSlaveCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
    e0ca:	83 e0       	ldi	r24, 0x03	; 3
    e0cc:	72 c0       	rjmp	.+228    	; 0xe1b2 <FSettingPumpPooling+0x43e>
		       break;
		  case '3'://TrySend
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e0ce:	24 2f       	mov	r18, r20
    e0d0:	30 e0       	ldi	r19, 0x00	; 0
    e0d2:	fe 01       	movw	r30, r28
    e0d4:	31 96       	adiw	r30, 0x01	; 1
    e0d6:	e2 0f       	add	r30, r18
    e0d8:	f3 1f       	adc	r31, r19
    e0da:	80 81       	ld	r24, Z
    e0dc:	90 e0       	ldi	r25, 0x00	; 0
    e0de:	01 96       	adiw	r24, 0x01	; 1
    e0e0:	65 e1       	ldi	r22, 0x15	; 21
    e0e2:	70 e0       	ldi	r23, 0x00	; 0
    e0e4:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    e0e8:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    e0ea:	88 23       	and	r24, r24
    e0ec:	11 f4       	brne	.+4      	; 0xe0f2 <FSettingPumpPooling+0x37e>
    e0ee:	81 e0       	ldi	r24, 0x01	; 1
    e0f0:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
    e0f2:	2c 0f       	add	r18, r28
    e0f4:	3d 1f       	adc	r19, r29
    e0f6:	d9 01       	movw	r26, r18
    e0f8:	11 96       	adiw	r26, 0x01	; 1
    e0fa:	2c 91       	ld	r18, X
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e0fc:	86 e1       	ldi	r24, 0x16	; 22
    e0fe:	80 93 b6 07 	sts	0x07B6, r24
	 PoolMsg=plMsg;
    e102:	20 93 de 0d 	sts	0x0DDE, r18
     IsControlPooling=True;
    e106:	81 e0       	ldi	r24, 0x01	; 1
    e108:	80 93 ad 01 	sts	0x01AD, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e10c:	e1 99       	sbic	0x1c, 1	; 28
    e10e:	fe cf       	rjmp	.-4      	; 0xe10c <FSettingPumpPooling+0x398>
    e110:	d0 cf       	rjmp	.-96     	; 0xe0b2 <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '4'://TimPool
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e112:	fe 01       	movw	r30, r28
    e114:	e4 0f       	add	r30, r20
    e116:	f1 1d       	adc	r31, r1
    e118:	81 81       	ldd	r24, Z+1	; 0x01
    e11a:	90 e0       	ldi	r25, 0x00	; 0
    e11c:	01 96       	adiw	r24, 0x01	; 1
    e11e:	65 e1       	ldi	r22, 0x15	; 21
    e120:	70 e0       	ldi	r23, 0x00	; 0
    e122:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    e126:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e128:	87 e1       	ldi	r24, 0x17	; 23
    e12a:	80 93 b6 07 	sts	0x07B6, r24
	 PoolMsg=plMsg;
    e12e:	20 93 de 0d 	sts	0x0DDE, r18
     IsControlPooling=True;
    e132:	81 e0       	ldi	r24, 0x01	; 1
    e134:	80 93 ad 01 	sts	0x01AD, r24
    e138:	e1 99       	sbic	0x1c, 1	; 28
    e13a:	fe cf       	rjmp	.-4      	; 0xe138 <FSettingPumpPooling+0x3c4>
    e13c:	ba cf       	rjmp	.-140    	; 0xe0b2 <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '5'://DelayNextPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%41); 
    e13e:	fe 01       	movw	r30, r28
    e140:	e4 0f       	add	r30, r20
    e142:	f1 1d       	adc	r31, r1
    e144:	81 81       	ldd	r24, Z+1	; 0x01
    e146:	90 e0       	ldi	r25, 0x00	; 0
    e148:	01 96       	adiw	r24, 0x01	; 1
    e14a:	69 e2       	ldi	r22, 0x29	; 41
    e14c:	70 e0       	ldi	r23, 0x00	; 0
    e14e:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
    e152:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e154:	88 e1       	ldi	r24, 0x18	; 24
    e156:	80 93 b6 07 	sts	0x07B6, r24
	 PoolMsg=plMsg;
    e15a:	20 93 de 0d 	sts	0x0DDE, r18
     IsControlPooling=True;
    e15e:	81 e0       	ldi	r24, 0x01	; 1
    e160:	80 93 ad 01 	sts	0x01AD, r24
    e164:	e1 99       	sbic	0x1c, 1	; 28
    e166:	fe cf       	rjmp	.-4      	; 0xe164 <FSettingPumpPooling+0x3f0>
    e168:	a4 cf       	rjmp	.-184    	; 0xe0b2 <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
               stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '6'://ActivePump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%(1+eeprom_read_byte(&DefPoolingPumpMax))); 			       
    e16a:	fe 01       	movw	r30, r28
    e16c:	e4 0f       	add	r30, r20
    e16e:	f1 1d       	adc	r31, r1
    e170:	21 81       	ldd	r18, Z+1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e172:	e1 99       	sbic	0x1c, 1	; 28
    e174:	fe cf       	rjmp	.-4      	; 0xe172 <FSettingPumpPooling+0x3fe>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e176:	84 e7       	ldi	r24, 0x74	; 116
    e178:	91 e0       	ldi	r25, 0x01	; 1
    e17a:	9f bb       	out	0x1f, r25	; 31
    e17c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e17e:	e0 9a       	sbi	0x1c, 0	; 28
    e180:	6d b3       	in	r22, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e182:	e1 99       	sbic	0x1c, 1	; 28
    e184:	fe cf       	rjmp	.-4      	; 0xe182 <FSettingPumpPooling+0x40e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e186:	84 2f       	mov	r24, r20
    e188:	90 e0       	ldi	r25, 0x00	; 0
    e18a:	8c 58       	subi	r24, 0x8C	; 140
    e18c:	9e 4f       	sbci	r25, 0xFE	; 254
    e18e:	9f bb       	out	0x1f, r25	; 31
    e190:	8e bb       	out	0x1e, r24	; 30
    e192:	82 2f       	mov	r24, r18
    e194:	90 e0       	ldi	r25, 0x00	; 0
    e196:	70 e0       	ldi	r23, 0x00	; 0
    e198:	6f 5f       	subi	r22, 0xFF	; 255
    e19a:	7f 4f       	sbci	r23, 0xFF	; 255
    e19c:	01 96       	adiw	r24, 0x01	; 1
    e19e:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
#endif
    EEDR = __value;
    e1a2:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    e1a4:	0f b6       	in	r0, 0x3f	; 63
    e1a6:	f8 94       	cli
    e1a8:	e2 9a       	sbi	0x1c, 2	; 28
    e1aa:	e1 9a       	sbi	0x1c, 1	; 28
    e1ac:	0f be       	out	0x3f, r0	; 63
    e1ae:	0e c0       	rjmp	.+28     	; 0xe1cc <FSettingPumpPooling+0x458>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   stPumpPooling=ppInitMenu;
		       break;
		  case '*'://Exit
		       stPumpPooling=ppExitSettingPooling;		            
    e1b0:	84 e0       	ldi	r24, 0x04	; 4
    e1b2:	80 93 fc 02 	sts	0x02FC, r24
    e1b6:	11 c0       	rjmp	.+34     	; 0xe1da <FSettingPumpPooling+0x466>
		       break;
		  }  
	      break;
     case ppWaitPoolingRespond:	    
	      if ((IsStandaloneAcknoledge==True)||(TimSend>5))stPumpPooling=ppInitMenu;
    e1b8:	80 91 ab 01 	lds	r24, 0x01AB
    e1bc:	81 30       	cpi	r24, 0x01	; 1
    e1be:	31 f0       	breq	.+12     	; 0xe1cc <FSettingPumpPooling+0x458>
    e1c0:	80 91 bd 01 	lds	r24, 0x01BD
    e1c4:	90 91 be 01 	lds	r25, 0x01BE
    e1c8:	06 97       	sbiw	r24, 0x06	; 6
    e1ca:	38 f0       	brcs	.+14     	; 0xe1da <FSettingPumpPooling+0x466>
    e1cc:	10 92 fc 02 	sts	0x02FC, r1
    e1d0:	04 c0       	rjmp	.+8      	; 0xe1da <FSettingPumpPooling+0x466>
	      break;
     case ppExitSettingPooling:
          stPumpPooling=ppInitMenu;
    e1d2:	10 92 fc 02 	sts	0x02FC, r1
    e1d6:	81 e0       	ldi	r24, 0x01	; 1
    e1d8:	01 c0       	rjmp	.+2      	; 0xe1dc <FSettingPumpPooling+0x468>
    e1da:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
    }
return Result;
}
    e1dc:	6a 96       	adiw	r28, 0x1a	; 26
    e1de:	0f b6       	in	r0, 0x3f	; 63
    e1e0:	f8 94       	cli
    e1e2:	de bf       	out	0x3e, r29	; 62
    e1e4:	0f be       	out	0x3f, r0	; 63
    e1e6:	cd bf       	out	0x3d, r28	; 61
    e1e8:	cf 91       	pop	r28
    e1ea:	df 91       	pop	r29
    e1ec:	1f 91       	pop	r17
    e1ee:	0f 91       	pop	r16
    e1f0:	08 95       	ret

0000e1f2 <DisplayTicker>:
	 
}

void DisplayTicker(){
static char stDisplayTicker=tiRight;
	switch(stDisplayTicker){
    e1f2:	80 91 8c 03 	lds	r24, 0x038C
    e1f6:	81 30       	cpi	r24, 0x01	; 1
    e1f8:	81 f0       	breq	.+32     	; 0xe21a <DisplayTicker+0x28>
    e1fa:	81 30       	cpi	r24, 0x01	; 1
    e1fc:	28 f0       	brcs	.+10     	; 0xe208 <DisplayTicker+0x16>
    e1fe:	82 30       	cpi	r24, 0x02	; 2
    e200:	91 f0       	breq	.+36     	; 0xe226 <DisplayTicker+0x34>
    e202:	83 30       	cpi	r24, 0x03	; 3
    e204:	09 f5       	brne	.+66     	; 0xe248 <DisplayTicker+0x56>
    e206:	1a c0       	rjmp	.+52     	; 0xe23c <DisplayTicker+0x4a>
	case tiRight:
	     lcd_put(4, 1, '>');
    e208:	84 e0       	ldi	r24, 0x04	; 4
    e20a:	61 e0       	ldi	r22, 0x01	; 1
    e20c:	4e e3       	ldi	r20, 0x3E	; 62
    e20e:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
		 TimTicker=0;
    e212:	10 92 ba 01 	sts	0x01BA, r1
         stDisplayTicker=tiDelayRight;
    e216:	81 e0       	ldi	r24, 0x01	; 1
    e218:	0e c0       	rjmp	.+28     	; 0xe236 <DisplayTicker+0x44>
	break;
	case tiDelayRight:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiLeft;	     
    e21a:	80 91 ba 01 	lds	r24, 0x01BA
    e21e:	8b 30       	cpi	r24, 0x0B	; 11
    e220:	98 f0       	brcs	.+38     	; 0xe248 <DisplayTicker+0x56>
    e222:	82 e0       	ldi	r24, 0x02	; 2
    e224:	08 c0       	rjmp	.+16     	; 0xe236 <DisplayTicker+0x44>
	     break;
	case tiLeft:
	     lcd_put(4, 1, '<');
    e226:	84 e0       	ldi	r24, 0x04	; 4
    e228:	61 e0       	ldi	r22, 0x01	; 1
    e22a:	4c e3       	ldi	r20, 0x3C	; 60
    e22c:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
         TimTicker=0;
    e230:	10 92 ba 01 	sts	0x01BA, r1
         stDisplayTicker=tiDelayLeft;
    e234:	83 e0       	ldi	r24, 0x03	; 3
    e236:	80 93 8c 03 	sts	0x038C, r24
    e23a:	08 95       	ret
	break;
	case tiDelayLeft:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
    e23c:	80 91 ba 01 	lds	r24, 0x01BA
    e240:	8b 30       	cpi	r24, 0x0B	; 11
    e242:	10 f0       	brcs	.+4      	; 0xe248 <DisplayTicker+0x56>
    e244:	10 92 8c 03 	sts	0x038C, r1
    e248:	08 95       	ret

0000e24a <DisplayIdle>:
	          lcd_put(x,y,'X');     
			  }

}

void DisplayIdle(){
    e24a:	6f 92       	push	r6
    e24c:	7f 92       	push	r7
    e24e:	8f 92       	push	r8
    e250:	9f 92       	push	r9
    e252:	af 92       	push	r10
    e254:	bf 92       	push	r11
    e256:	cf 92       	push	r12
    e258:	df 92       	push	r13
    e25a:	ff 92       	push	r15
    e25c:	0f 93       	push	r16
    e25e:	1f 93       	push	r17
    e260:	df 93       	push	r29
    e262:	cf 93       	push	r28
    e264:	cd b7       	in	r28, 0x3d	; 61
    e266:	de b7       	in	r29, 0x3e	; 62
    e268:	67 97       	sbiw	r28, 0x17	; 23
    e26a:	0f b6       	in	r0, 0x3f	; 63
    e26c:	f8 94       	cli
    e26e:	de bf       	out	0x3e, r29	; 62
    e270:	0f be       	out	0x3f, r0	; 63
    e272:	cd bf       	out	0x3d, r28	; 61
static unsigned int iLoopDisplayIdle=0;
static char stDispIdle=diScan;
     char i,iDisp;
     char lcdteks[20],sFIP[3];

     iLoopDisplayIdle++;
    e274:	80 91 89 03 	lds	r24, 0x0389
    e278:	90 91 8a 03 	lds	r25, 0x038A
    e27c:	01 96       	adiw	r24, 0x01	; 1
    e27e:	90 93 8a 03 	sts	0x038A, r25
    e282:	80 93 89 03 	sts	0x0389, r24
     //Setting DateTime ON

	if ((iLoopDisplayIdle%50)==0){
    e286:	62 e3       	ldi	r22, 0x32	; 50
    e288:	70 e0       	ldi	r23, 0x00	; 0
    e28a:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
    e28e:	89 2b       	or	r24, r25
    e290:	29 f5       	brne	.+74     	; 0xe2dc <DisplayIdle+0x92>
	   if (IFType==IT_STANDALONE)DisplayPumpStatus();
    e292:	80 91 25 01 	lds	r24, 0x0125
    e296:	82 30       	cpi	r24, 0x02	; 2
    e298:	11 f4       	brne	.+4      	; 0xe29e <DisplayIdle+0x54>
    e29a:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <DisplayPumpStatus>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e29e:	e1 99       	sbic	0x1c, 1	; 28
    e2a0:	fe cf       	rjmp	.-4      	; 0xe29e <DisplayIdle+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e2a2:	87 e3       	ldi	r24, 0x37	; 55
    e2a4:	90 e0       	ldi	r25, 0x00	; 0
    e2a6:	9f bb       	out	0x1f, r25	; 31
    e2a8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e2aa:	e0 9a       	sbi	0x1c, 0	; 28
    e2ac:	8d b3       	in	r24, 0x1d	; 29
	   if(eeprom_read_byte(&__date_time)) DisplayDateTime();
    e2ae:	88 23       	and	r24, r24
    e2b0:	19 f0       	breq	.+6      	; 0xe2b8 <DisplayIdle+0x6e>
    e2b2:	0e 94 d8 60 	call	0xc1b0	; 0xc1b0 <DisplayDateTime>
    e2b6:	02 c0       	rjmp	.+4      	; 0xe2bc <DisplayIdle+0x72>
       else DisplayTicker();
    e2b8:	0e 94 f9 70 	call	0xe1f2	; 0xe1f2 <DisplayTicker>
	   //Display Standalone Sequnece
	   
	   if((IFType==IT_STANDALONE)&&(IsNewPoolingSequence==True)){
    e2bc:	80 91 25 01 	lds	r24, 0x0125
    e2c0:	82 30       	cpi	r24, 0x02	; 2
    e2c2:	61 f4       	brne	.+24     	; 0xe2dc <DisplayIdle+0x92>
    e2c4:	80 91 aa 01 	lds	r24, 0x01AA
    e2c8:	81 30       	cpi	r24, 0x01	; 1
    e2ca:	41 f4       	brne	.+16     	; 0xe2dc <DisplayIdle+0x92>
	       IsNewPoolingSequence=False;
    e2cc:	10 92 aa 01 	sts	0x01AA, r1
		   DisplayStandaloneSequence(4,18,iSequencePooling);
    e2d0:	84 e0       	ldi	r24, 0x04	; 4
    e2d2:	62 e1       	ldi	r22, 0x12	; 18
    e2d4:	40 91 a9 01 	lds	r20, 0x01A9
    e2d8:	0e 94 84 6e 	call	0xdd08	; 0xdd08 <DisplayStandaloneSequence>

	 }
     //DisplayPumpStatus Standalone Mode

	 //Display Printing FIP
	 switch (stDispIdle){
    e2dc:	f0 90 88 03 	lds	r15, 0x0388
    e2e0:	ff 20       	and	r15, r15
    e2e2:	29 f0       	breq	.+10     	; 0xe2ee <DisplayIdle+0xa4>
    e2e4:	81 e0       	ldi	r24, 0x01	; 1
    e2e6:	f8 16       	cp	r15, r24
    e2e8:	09 f0       	breq	.+2      	; 0xe2ec <DisplayIdle+0xa2>
    e2ea:	58 c0       	rjmp	.+176    	; 0xe39c <DisplayIdle+0x152>
    e2ec:	2f c0       	rjmp	.+94     	; 0xe34c <DisplayIdle+0x102>
	 case diScan:
	      if (IsBusyIdlePrinting==True){
    e2ee:	f0 90 df 01 	lds	r15, 0x01DF
    e2f2:	91 e0       	ldi	r25, 0x01	; 1
    e2f4:	f9 16       	cp	r15, r25
    e2f6:	09 f0       	breq	.+2      	; 0xe2fa <DisplayIdle+0xb0>
    e2f8:	51 c0       	rjmp	.+162    	; 0xe39c <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("Printing FIP%s "),strFIP_ID);
    e2fa:	00 d0       	rcall	.+0      	; 0xe2fc <DisplayIdle+0xb2>
    e2fc:	00 d0       	rcall	.+0      	; 0xe2fe <DisplayIdle+0xb4>
    e2fe:	00 d0       	rcall	.+0      	; 0xe300 <DisplayIdle+0xb6>
    e300:	ed b7       	in	r30, 0x3d	; 61
    e302:	fe b7       	in	r31, 0x3e	; 62
    e304:	31 96       	adiw	r30, 0x01	; 1
    e306:	8e 01       	movw	r16, r28
    e308:	0c 5f       	subi	r16, 0xFC	; 252
    e30a:	1f 4f       	sbci	r17, 0xFF	; 255
    e30c:	ad b7       	in	r26, 0x3d	; 61
    e30e:	be b7       	in	r27, 0x3e	; 62
    e310:	12 96       	adiw	r26, 0x02	; 2
    e312:	1c 93       	st	X, r17
    e314:	0e 93       	st	-X, r16
    e316:	11 97       	sbiw	r26, 0x01	; 1
    e318:	8e e6       	ldi	r24, 0x6E	; 110
    e31a:	9b e1       	ldi	r25, 0x1B	; 27
    e31c:	93 83       	std	Z+3, r25	; 0x03
    e31e:	82 83       	std	Z+2, r24	; 0x02
    e320:	88 ec       	ldi	r24, 0xC8	; 200
    e322:	99 e0       	ldi	r25, 0x09	; 9
    e324:	95 83       	std	Z+5, r25	; 0x05
    e326:	84 83       	std	Z+4, r24	; 0x04
    e328:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    e32c:	ed b7       	in	r30, 0x3d	; 61
    e32e:	fe b7       	in	r31, 0x3e	; 62
    e330:	36 96       	adiw	r30, 0x06	; 6
    e332:	0f b6       	in	r0, 0x3f	; 63
    e334:	f8 94       	cli
    e336:	fe bf       	out	0x3e, r31	; 62
    e338:	0f be       	out	0x3f, r0	; 63
    e33a:	ed bf       	out	0x3d, r30	; 61
    e33c:	83 e0       	ldi	r24, 0x03	; 3
    e33e:	61 e0       	ldi	r22, 0x01	; 1
    e340:	a8 01       	movw	r20, r16
    e342:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			   stDispIdle=diWaitNoBusy;
    e346:	f0 92 88 03 	sts	0x0388, r15
    e34a:	28 c0       	rjmp	.+80     	; 0xe39c <DisplayIdle+0x152>
		  }         
	      break;
     case diWaitNoBusy:
	      if (IsBusyIdlePrinting==False){
    e34c:	80 91 df 01 	lds	r24, 0x01DF
    e350:	88 23       	and	r24, r24
    e352:	21 f5       	brne	.+72     	; 0xe39c <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("                    "));
    e354:	00 d0       	rcall	.+0      	; 0xe356 <DisplayIdle+0x10c>
    e356:	00 d0       	rcall	.+0      	; 0xe358 <DisplayIdle+0x10e>
    e358:	8e 01       	movw	r16, r28
    e35a:	0c 5f       	subi	r16, 0xFC	; 252
    e35c:	1f 4f       	sbci	r17, 0xFF	; 255
    e35e:	ad b7       	in	r26, 0x3d	; 61
    e360:	be b7       	in	r27, 0x3e	; 62
    e362:	12 96       	adiw	r26, 0x02	; 2
    e364:	1c 93       	st	X, r17
    e366:	0e 93       	st	-X, r16
    e368:	11 97       	sbiw	r26, 0x01	; 1
    e36a:	89 e5       	ldi	r24, 0x59	; 89
    e36c:	9b e1       	ldi	r25, 0x1B	; 27
    e36e:	14 96       	adiw	r26, 0x04	; 4
    e370:	9c 93       	st	X, r25
    e372:	8e 93       	st	-X, r24
    e374:	13 97       	sbiw	r26, 0x03	; 3
    e376:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    e37a:	0f 90       	pop	r0
    e37c:	0f 90       	pop	r0
    e37e:	0f 90       	pop	r0
    e380:	0f 90       	pop	r0
    e382:	83 e0       	ldi	r24, 0x03	; 3
    e384:	61 e0       	ldi	r22, 0x01	; 1
    e386:	a8 01       	movw	r20, r16
    e388:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			   stDispIdle=diScan;
    e38c:	10 92 88 03 	sts	0x0388, r1
			   if (nLocalAccount>0)IsViewFillingFIP=True;
    e390:	80 91 b9 01 	lds	r24, 0x01B9
    e394:	88 23       	and	r24, r24
    e396:	11 f0       	breq	.+4      	; 0xe39c <DisplayIdle+0x152>
    e398:	f0 92 c2 01 	sts	0x01C2, r15
		  }
	      break;     
	 }
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
    e39c:	80 91 c2 01 	lds	r24, 0x01C2
    e3a0:	81 30       	cpi	r24, 0x01	; 1
    e3a2:	09 f0       	breq	.+2      	; 0xe3a6 <DisplayIdle+0x15c>
    e3a4:	69 c0       	rjmp	.+210    	; 0xe478 <DisplayIdle+0x22e>
	     IsViewFillingFIP=False;
    e3a6:	10 92 c2 01 	sts	0x01C2, r1
		 if (nLocalAccount>0){
    e3aa:	80 91 b9 01 	lds	r24, 0x01B9
    e3ae:	88 23       	and	r24, r24
    e3b0:	09 f4       	brne	.+2      	; 0xe3b4 <DisplayIdle+0x16a>
    e3b2:	5c c0       	rjmp	.+184    	; 0xe46c <DisplayIdle+0x222>
		     lcd_printf(3,1,PSTR("@FIP:"));
    e3b4:	83 e0       	ldi	r24, 0x03	; 3
    e3b6:	61 e0       	ldi	r22, 0x01	; 1
    e3b8:	43 e5       	ldi	r20, 0x53	; 83
    e3ba:	5b e1       	ldi	r21, 0x1B	; 27
    e3bc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
    e3c0:	ff 24       	eor	r15, r15
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    e3c2:	5e 01       	movw	r10, r28
    e3c4:	08 94       	sec
    e3c6:	a1 1c       	adc	r10, r1
    e3c8:	b1 1c       	adc	r11, r1
    e3ca:	3e e4       	ldi	r19, 0x4E	; 78
    e3cc:	63 2e       	mov	r6, r19
    e3ce:	3b e1       	ldi	r19, 0x1B	; 27
    e3d0:	73 2e       	mov	r7, r19
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    e3d2:	24 e0       	ldi	r18, 0x04	; 4
    e3d4:	c2 2e       	mov	r12, r18
    e3d6:	d1 2c       	mov	r13, r1
    e3d8:	cc 0e       	add	r12, r28
    e3da:	dd 1e       	adc	r13, r29
    e3dc:	9a e4       	ldi	r25, 0x4A	; 74
    e3de:	89 2e       	mov	r8, r25
    e3e0:	9b e1       	ldi	r25, 0x1B	; 27
    e3e2:	99 2e       	mov	r9, r25
    e3e4:	3d c0       	rjmp	.+122    	; 0xe460 <DisplayIdle+0x216>
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    e3e6:	0f 2d       	mov	r16, r15
    e3e8:	10 e0       	ldi	r17, 0x00	; 0
    e3ea:	00 d0       	rcall	.+0      	; 0xe3ec <DisplayIdle+0x1a2>
    e3ec:	00 d0       	rcall	.+0      	; 0xe3ee <DisplayIdle+0x1a4>
    e3ee:	00 d0       	rcall	.+0      	; 0xe3f0 <DisplayIdle+0x1a6>
    e3f0:	ad b7       	in	r26, 0x3d	; 61
    e3f2:	be b7       	in	r27, 0x3e	; 62
    e3f4:	11 96       	adiw	r26, 0x01	; 1
    e3f6:	ed b7       	in	r30, 0x3d	; 61
    e3f8:	fe b7       	in	r31, 0x3e	; 62
    e3fa:	b2 82       	std	Z+2, r11	; 0x02
    e3fc:	a1 82       	std	Z+1, r10	; 0x01
    e3fe:	13 96       	adiw	r26, 0x03	; 3
    e400:	7c 92       	st	X, r7
    e402:	6e 92       	st	-X, r6
    e404:	12 97       	sbiw	r26, 0x02	; 2
    e406:	f8 01       	movw	r30, r16
    e408:	e4 5a       	subi	r30, 0xA4	; 164
    e40a:	fa 4f       	sbci	r31, 0xFA	; 250
    e40c:	80 81       	ld	r24, Z
    e40e:	14 96       	adiw	r26, 0x04	; 4
    e410:	8c 93       	st	X, r24
    e412:	14 97       	sbiw	r26, 0x04	; 4
    e414:	15 96       	adiw	r26, 0x05	; 5
    e416:	1c 92       	st	X, r1
    e418:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    e41c:	ed b7       	in	r30, 0x3d	; 61
    e41e:	fe b7       	in	r31, 0x3e	; 62
    e420:	31 96       	adiw	r30, 0x01	; 1
    e422:	ad b7       	in	r26, 0x3d	; 61
    e424:	be b7       	in	r27, 0x3e	; 62
    e426:	12 96       	adiw	r26, 0x02	; 2
    e428:	dc 92       	st	X, r13
    e42a:	ce 92       	st	-X, r12
    e42c:	11 97       	sbiw	r26, 0x01	; 1
    e42e:	93 82       	std	Z+3, r9	; 0x03
    e430:	82 82       	std	Z+2, r8	; 0x02
    e432:	b5 82       	std	Z+5, r11	; 0x05
    e434:	a4 82       	std	Z+4, r10	; 0x04
    e436:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			      lcd_print(3,6+(iDisp*3),lcdteks);
    e43a:	ed b7       	in	r30, 0x3d	; 61
    e43c:	fe b7       	in	r31, 0x3e	; 62
    e43e:	36 96       	adiw	r30, 0x06	; 6
    e440:	0f b6       	in	r0, 0x3f	; 63
    e442:	f8 94       	cli
    e444:	fe bf       	out	0x3e, r31	; 62
    e446:	0f be       	out	0x3f, r0	; 63
    e448:	ed bf       	out	0x3d, r30	; 61
    e44a:	b8 01       	movw	r22, r16
    e44c:	66 0f       	add	r22, r22
    e44e:	77 1f       	adc	r23, r23
    e450:	60 0f       	add	r22, r16
    e452:	71 1f       	adc	r23, r17
    e454:	6a 5f       	subi	r22, 0xFA	; 250
    e456:	83 e0       	ldi	r24, 0x03	; 3
    e458:	a6 01       	movw	r20, r12
    e45a:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
    e45e:	f3 94       	inc	r15
    e460:	80 91 b9 01 	lds	r24, 0x01B9
    e464:	f8 16       	cp	r15, r24
    e466:	08 f4       	brcc	.+2      	; 0xe46a <DisplayIdle+0x220>
    e468:	be cf       	rjmp	.-132    	; 0xe3e6 <DisplayIdle+0x19c>
    e46a:	06 c0       	rjmp	.+12     	; 0xe478 <DisplayIdle+0x22e>
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
			      lcd_print(3,6+(iDisp*3),lcdteks);
		     }
		 }else{
		 lcd_printf(3,1,PSTR("                    "));
    e46c:	83 e0       	ldi	r24, 0x03	; 3
    e46e:	61 e0       	ldi	r22, 0x01	; 1
    e470:	45 e3       	ldi	r20, 0x35	; 53
    e472:	5b e1       	ldi	r21, 0x1B	; 27
    e474:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		 }    
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
    e478:	80 91 d6 01 	lds	r24, 0x01D6
    e47c:	81 30       	cpi	r24, 0x01	; 1
    e47e:	c1 f4       	brne	.+48     	; 0xe4b0 <DisplayIdle+0x266>
	     IsCompleteFilling=False;
    e480:	10 92 d6 01 	sts	0x01D6, r1
	     if (nLocalAccount>0){
    e484:	90 91 b9 01 	lds	r25, 0x01B9
    e488:	99 23       	and	r25, r25
    e48a:	91 f0       	breq	.+36     	; 0xe4b0 <DisplayIdle+0x266>
    e48c:	ec e5       	ldi	r30, 0x5C	; 92
    e48e:	f5 e0       	ldi	r31, 0x05	; 5
			 for(i=0;i<nLocalAccount;i++){//Shift data
    e490:	29 2f       	mov	r18, r25
    e492:	30 e0       	ldi	r19, 0x00	; 0
    e494:	2e 0f       	add	r18, r30
    e496:	3f 1f       	adc	r19, r31
    e498:	02 c0       	rjmp	.+4      	; 0xe49e <DisplayIdle+0x254>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
    e49a:	81 81       	ldd	r24, Z+1	; 0x01
    e49c:	81 93       	st	Z+, r24
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
	     IsCompleteFilling=False;
	     if (nLocalAccount>0){
			 for(i=0;i<nLocalAccount;i++){//Shift data
    e49e:	e2 17       	cp	r30, r18
    e4a0:	f3 07       	cpc	r31, r19
    e4a2:	d9 f7       	brne	.-10     	; 0xe49a <DisplayIdle+0x250>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
			 }
			 nLocalAccount--;
    e4a4:	91 50       	subi	r25, 0x01	; 1
    e4a6:	90 93 b9 01 	sts	0x01B9, r25
             IsViewFillingFIP=True; 
    e4aa:	81 e0       	ldi	r24, 0x01	; 1
    e4ac:	80 93 c2 01 	sts	0x01C2, r24
		 }
	 }
}
    e4b0:	67 96       	adiw	r28, 0x17	; 23
    e4b2:	0f b6       	in	r0, 0x3f	; 63
    e4b4:	f8 94       	cli
    e4b6:	de bf       	out	0x3e, r29	; 62
    e4b8:	0f be       	out	0x3f, r0	; 63
    e4ba:	cd bf       	out	0x3d, r28	; 61
    e4bc:	cf 91       	pop	r28
    e4be:	df 91       	pop	r29
    e4c0:	1f 91       	pop	r17
    e4c2:	0f 91       	pop	r16
    e4c4:	ff 90       	pop	r15
    e4c6:	df 90       	pop	r13
    e4c8:	cf 90       	pop	r12
    e4ca:	bf 90       	pop	r11
    e4cc:	af 90       	pop	r10
    e4ce:	9f 90       	pop	r9
    e4d0:	8f 90       	pop	r8
    e4d2:	7f 90       	pop	r7
    e4d4:	6f 90       	pop	r6
    e4d6:	08 95       	ret

0000e4d8 <ValidateRestoreCode>:
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
     WrapCode(strKeyStamp);
}

char ValidateRestoreCode(char *sKeyStamp, char *sRestoreCode){//==RC_VALID
    e4d8:	ef 92       	push	r14
    e4da:	ff 92       	push	r15
    e4dc:	0f 93       	push	r16
    e4de:	1f 93       	push	r17
    e4e0:	cf 93       	push	r28
    e4e2:	df 93       	push	r29
    e4e4:	ec 01       	movw	r28, r24
    e4e6:	7b 01       	movw	r14, r22

	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //_uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
    e4e8:	08 81       	ld	r16, Y
    e4ea:	00 53       	subi	r16, 0x30	; 48
    e4ec:	10 e0       	ldi	r17, 0x00	; 0
    e4ee:	04 c0       	rjmp	.+8      	; 0xe4f8 <ValidateRestoreCode+0x20>
	 for (i=0;i<nSum;i++){
         WrapCode(sKeyStamp);
    e4f0:	ce 01       	movw	r24, r28
    e4f2:	0e 94 24 2d 	call	0x5a48	; 0x5a48 <WrapCode>
	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //_uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
	 for (i=0;i<nSum;i++){
    e4f6:	1f 5f       	subi	r17, 0xFF	; 255
    e4f8:	10 17       	cp	r17, r16
    e4fa:	d0 f3       	brcs	.-12     	; 0xe4f0 <ValidateRestoreCode+0x18>
	 //_uart_print(1,1,strSend);
     
	 //sprintf_P(strSend,PSTR("WrapStamp:%s"),sRestoreCode);
	 //_uart_print(1,1,strSend);

	 if (strcmp(sKeyStamp,sRestoreCode)==0)
    e4fc:	ce 01       	movw	r24, r28
    e4fe:	b7 01       	movw	r22, r14
    e500:	0e 94 93 b4 	call	0x16926	; 0x16926 <strcmp>
    e504:	00 97       	sbiw	r24, 0x00	; 0
    e506:	11 f0       	breq	.+4      	; 0xe50c <ValidateRestoreCode+0x34>
    e508:	82 e0       	ldi	r24, 0x02	; 2
    e50a:	01 c0       	rjmp	.+2      	; 0xe50e <ValidateRestoreCode+0x36>
    e50c:	81 e0       	ldi	r24, 0x01	; 1
	     Result=RC_VALID;	 
     else Result=RC_INVALID;

   return Result;
}
    e50e:	df 91       	pop	r29
    e510:	cf 91       	pop	r28
    e512:	1f 91       	pop	r17
    e514:	0f 91       	pop	r16
    e516:	ff 90       	pop	r15
    e518:	ef 90       	pop	r14
    e51a:	08 95       	ret

0000e51c <ValidateGeniusCode>:
          }
	 }sTemp[iAdd]=0;
	 sprintf_P(strSource,PSTR("%s"),sTemp);
}

char ValidateGeniusCode(char *sDate, char *sGenCode){//==GC_VALID
    e51c:	ef 92       	push	r14
    e51e:	ff 92       	push	r15
    e520:	0f 93       	push	r16
    e522:	1f 93       	push	r17
    e524:	df 93       	push	r29
    e526:	cf 93       	push	r28
    e528:	cd b7       	in	r28, 0x3d	; 61
    e52a:	de b7       	in	r29, 0x3e	; 62
    e52c:	2a 97       	sbiw	r28, 0x0a	; 10
    e52e:	0f b6       	in	r0, 0x3f	; 63
    e530:	f8 94       	cli
    e532:	de bf       	out	0x3e, r29	; 62
    e534:	0f be       	out	0x3f, r0	; 63
    e536:	cd bf       	out	0x3d, r28	; 61
    e538:	7b 01       	movw	r14, r22
     char Result=GC_NONE;
	 char sAutoGen[10],strSend[20];
     Result=GC_NONE;
	 if (strlen(sGenCode)==8){//Length musti  8
    e53a:	fb 01       	movw	r30, r22
    e53c:	01 90       	ld	r0, Z+
    e53e:	00 20       	and	r0, r0
    e540:	e9 f7       	brne	.-6      	; 0xe53c <ValidateGeniusCode+0x20>
    e542:	39 97       	sbiw	r30, 0x09	; 9
    e544:	e6 17       	cp	r30, r22
    e546:	f7 07       	cpc	r31, r23
    e548:	11 f0       	breq	.+4      	; 0xe54e <ValidateGeniusCode+0x32>
    e54a:	80 e0       	ldi	r24, 0x00	; 0
    e54c:	11 c0       	rjmp	.+34     	; 0xe570 <ValidateGeniusCode+0x54>
	     //sDate: 05012001		 
		 GenerateGeniusCode(sDate,sGenCode[0],sAutoGen);
    e54e:	fb 01       	movw	r30, r22
    e550:	60 81       	ld	r22, Z
    e552:	8e 01       	movw	r16, r28
    e554:	0f 5f       	subi	r16, 0xFF	; 255
    e556:	1f 4f       	sbci	r17, 0xFF	; 255
    e558:	a8 01       	movw	r20, r16
    e55a:	0e 94 22 2e 	call	0x5c44	; 0x5c44 <GenerateGeniusCode>
		 //sprintf_P(strSend,PSTR("Auto:%s"),sAutoGen); 
         //_uart_print(1,1,strSend);

         if (strcmp(sAutoGen,sGenCode)==0)
    e55e:	c8 01       	movw	r24, r16
    e560:	b7 01       	movw	r22, r14
    e562:	0e 94 93 b4 	call	0x16926	; 0x16926 <strcmp>
    e566:	00 97       	sbiw	r24, 0x00	; 0
    e568:	11 f0       	breq	.+4      	; 0xe56e <ValidateGeniusCode+0x52>
    e56a:	82 e0       	ldi	r24, 0x02	; 2
    e56c:	01 c0       	rjmp	.+2      	; 0xe570 <ValidateGeniusCode+0x54>
    e56e:	81 e0       	ldi	r24, 0x01	; 1
	        Result=GC_VALID;	 
         else Result=GC_INVALID;
	 }
   return Result;
}
    e570:	2a 96       	adiw	r28, 0x0a	; 10
    e572:	0f b6       	in	r0, 0x3f	; 63
    e574:	f8 94       	cli
    e576:	de bf       	out	0x3e, r29	; 62
    e578:	0f be       	out	0x3f, r0	; 63
    e57a:	cd bf       	out	0x3d, r28	; 61
    e57c:	cf 91       	pop	r28
    e57e:	df 91       	pop	r29
    e580:	1f 91       	pop	r17
    e582:	0f 91       	pop	r16
    e584:	ff 90       	pop	r15
    e586:	ef 90       	pop	r14
    e588:	08 95       	ret

0000e58a <_menu_password>:

//****************************************************************
// menu autorisasi
// untuk masuk dgn password untuk merubah parameter
//****************************************************************
unsigned char _menu_password(void){
    e58a:	df 92       	push	r13
    e58c:	ef 92       	push	r14
    e58e:	ff 92       	push	r15
    e590:	0f 93       	push	r16
    e592:	1f 93       	push	r17
    e594:	df 93       	push	r29
    e596:	cf 93       	push	r28
    e598:	cd b7       	in	r28, 0x3d	; 61
    e59a:	de b7       	in	r29, 0x3e	; 62
    e59c:	66 97       	sbiw	r28, 0x16	; 22
    e59e:	0f b6       	in	r0, 0x3f	; 63
    e5a0:	f8 94       	cli
    e5a2:	de bf       	out	0x3e, r29	; 62
    e5a4:	0f be       	out	0x3f, r0	; 63
    e5a6:	cd bf       	out	0x3d, r28	; 61
	char	__pad = 0, __ret = 3;
	char	__t_spv_pass[_MAX_PASS + 1];
	char	__t_sys_pass[_MAX_PASS + 1];

	__max_string = _MAX_PASS;	
    e5a8:	8a e0       	ldi	r24, 0x0A	; 10
    e5aa:	80 93 dc 03 	sts	0x03DC, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    e5ae:	7e 01       	movw	r14, r28
    e5b0:	08 94       	sec
    e5b2:	e1 1c       	adc	r14, r1
    e5b4:	f1 1c       	adc	r15, r1
    e5b6:	c7 01       	movw	r24, r14
    e5b8:	61 e0       	ldi	r22, 0x01	; 1
    e5ba:	70 e0       	ldi	r23, 0x00	; 0
    e5bc:	4b e0       	ldi	r20, 0x0B	; 11
    e5be:	50 e0       	ldi	r21, 0x00	; 0
    e5c0:	2c ea       	ldi	r18, 0xAC	; 172
    e5c2:	32 e1       	ldi	r19, 0x12	; 18
    e5c4:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
	eeprom_read_block((void*) &__t_spv_pass, (const void*) &DefSpvPassword, _MAX_PASS + 1);
	eeprom_read_block((void*) &__t_sys_pass, (const void*) &DefSysPassword, _MAX_PASS + 1);


	lcd_clear();_delay_ms(10);
    e5c8:	8e 01       	movw	r16, r28
    e5ca:	04 5f       	subi	r16, 0xF4	; 244
    e5cc:	1f 4f       	sbci	r17, 0xFF	; 255
    e5ce:	c8 01       	movw	r24, r16
    e5d0:	6b e0       	ldi	r22, 0x0B	; 11
    e5d2:	70 e0       	ldi	r23, 0x00	; 0
    e5d4:	4b e0       	ldi	r20, 0x0B	; 11
    e5d6:	50 e0       	ldi	r21, 0x00	; 0
    e5d8:	2c ea       	ldi	r18, 0xAC	; 172
    e5da:	32 e1       	ldi	r19, 0x12	; 18
    e5dc:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
    e5e0:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    e5e4:	84 ec       	ldi	r24, 0xC4	; 196
    e5e6:	99 e0       	ldi	r25, 0x09	; 9
    e5e8:	01 97       	sbiw	r24, 0x01	; 1
    e5ea:	f1 f7       	brne	.-4      	; 0xe5e8 <_menu_password+0x5e>
//	lcd_print(3, 1, __t_sys_pass);
	lcd_printf(1, 1, PSTR("PASSWORD:"));
    e5ec:	81 e0       	ldi	r24, 0x01	; 1
    e5ee:	61 e0       	ldi	r22, 0x01	; 1
    e5f0:	4c e9       	ldi	r20, 0x9C	; 156
    e5f2:	57 e1       	ldi	r21, 0x17	; 23
    e5f4:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_printf(4, 1, PSTR("[*]Cancel   [#]Enter"));
    e5f8:	84 e0       	ldi	r24, 0x04	; 4
    e5fa:	61 e0       	ldi	r22, 0x01	; 1
    e5fc:	47 e8       	ldi	r20, 0x87	; 135
    e5fe:	57 e1       	ldi	r21, 0x17	; 23
    e600:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	lcd_xy(2, 1);
    e604:	82 e0       	ldi	r24, 0x02	; 2
    e606:	61 e0       	ldi	r22, 0x01	; 1
    e608:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>

	while(1){
		__pad = _key_string(2);
		if(!__pad){
			if(strcmp(__buf_string, __t_sys_pass) == 0){
    e60c:	d0 2e       	mov	r13, r16
    e60e:	01 2f       	mov	r16, r17
				__ret = 0x36;
				break;
			}
			else if(strcmp(__buf_string, __t_spv_pass) == 0){
    e610:	1e 2d       	mov	r17, r14
    e612:	ef 2c       	mov	r14, r15
	lcd_printf(1, 1, PSTR("PASSWORD:"));
	lcd_printf(4, 1, PSTR("[*]Cancel   [#]Enter"));
	lcd_xy(2, 1);

	while(1){
		__pad = _key_string(2);
    e614:	82 e0       	ldi	r24, 0x02	; 2
    e616:	0e 94 19 ae 	call	0x15c32	; 0x15c32 <_key_string>
		if(!__pad){
    e61a:	88 23       	and	r24, r24
    e61c:	11 f0       	breq	.+4      	; 0xe622 <_menu_password+0x98>
    e61e:	80 e0       	ldi	r24, 0x00	; 0
    e620:	20 c0       	rjmp	.+64     	; 0xe662 <_menu_password+0xd8>
			if(strcmp(__buf_string, __t_sys_pass) == 0){
    e622:	8e eb       	ldi	r24, 0xBE	; 190
    e624:	9e e0       	ldi	r25, 0x0E	; 14
    e626:	6d 2d       	mov	r22, r13
    e628:	70 2f       	mov	r23, r16
    e62a:	0e 94 93 b4 	call	0x16926	; 0x16926 <strcmp>
    e62e:	00 97       	sbiw	r24, 0x00	; 0
    e630:	b9 f0       	breq	.+46     	; 0xe660 <_menu_password+0xd6>
				__ret = 0x36;
				break;
			}
			else if(strcmp(__buf_string, __t_spv_pass) == 0){
    e632:	8e eb       	ldi	r24, 0xBE	; 190
    e634:	9e e0       	ldi	r25, 0x0E	; 14
    e636:	61 2f       	mov	r22, r17
    e638:	7e 2d       	mov	r23, r14
    e63a:	0e 94 93 b4 	call	0x16926	; 0x16926 <strcmp>
    e63e:	00 97       	sbiw	r24, 0x00	; 0
    e640:	11 f4       	brne	.+4      	; 0xe646 <_menu_password+0xbc>
    e642:	83 e6       	ldi	r24, 0x63	; 99
    e644:	0e c0       	rjmp	.+28     	; 0xe662 <_menu_password+0xd8>
				__ret = 0x63;
				break;
			}
			else{
				lcd_print(2, 1, "                    ");
    e646:	82 e0       	ldi	r24, 0x02	; 2
    e648:	61 e0       	ldi	r22, 0x01	; 1
    e64a:	40 e1       	ldi	r20, 0x10	; 16
    e64c:	51 e0       	ldi	r21, 0x01	; 1
    e64e:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
				lcd_xy(2, 1);
    e652:	82 e0       	ldi	r24, 0x02	; 2
    e654:	61 e0       	ldi	r22, 0x01	; 1
    e656:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
				__chr_count = 0;
    e65a:	10 92 db 03 	sts	0x03DB, r1
    e65e:	da cf       	rjmp	.-76     	; 0xe614 <_menu_password+0x8a>
    e660:	86 e3       	ldi	r24, 0x36	; 54
			__ret = 0x00;
			break;
		}
	}
	return __ret;
}
    e662:	66 96       	adiw	r28, 0x16	; 22
    e664:	0f b6       	in	r0, 0x3f	; 63
    e666:	f8 94       	cli
    e668:	de bf       	out	0x3e, r29	; 62
    e66a:	0f be       	out	0x3f, r0	; 63
    e66c:	cd bf       	out	0x3d, r28	; 61
    e66e:	cf 91       	pop	r28
    e670:	df 91       	pop	r29
    e672:	1f 91       	pop	r17
    e674:	0f 91       	pop	r16
    e676:	ff 90       	pop	r15
    e678:	ef 90       	pop	r14
    e67a:	df 90       	pop	r13
    e67c:	08 95       	ret

0000e67e <FMenuSettingPassword>:
	 }
   return Result;
}
char FMenuSettingPassword(){
     char Result;
   _menu_password();
    e67e:	0e 94 c5 72 	call	0xe58a	; 0xe58a <_menu_password>
   Result=MENU_DONE;
   return Result;
}
    e682:	81 e0       	ldi	r24, 0x01	; 1
    e684:	08 95       	ret

0000e686 <systemMaster>:
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
}

void systemMaster(){
  	_spi_init(1, 0);         //Master
    e686:	81 e0       	ldi	r24, 0x01	; 1
    e688:	60 e0       	ldi	r22, 0x00	; 0
    e68a:	0e 94 03 b0 	call	0x16006	; 0x16006 <_spi_init>
    _spi_enable(_SPI_SLAVE); //Enable SS 
    e68e:	81 e0       	ldi	r24, 0x01	; 1
    e690:	0e 94 16 b0 	call	0x1602c	; 0x1602c <_spi_enable>
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
    e694:	bb 98       	cbi	0x17, 3	; 23
    e696:	c3 9a       	sbi	0x18, 3	; 24
	sbi(DDRB,2);             //MOSI Output
    e698:	ba 9a       	sbi	0x17, 2	; 23
}
    e69a:	08 95       	ret

0000e69c <systemSlave>:




void systemSlave(){
    _spi_enable(_SPI_NONE);	
    e69c:	80 e0       	ldi	r24, 0x00	; 0
    e69e:	0e 94 16 b0 	call	0x1602c	; 0x1602c <_spi_enable>
  	_spi_init(0, 1);         //Slave
    e6a2:	80 e0       	ldi	r24, 0x00	; 0
    e6a4:	61 e0       	ldi	r22, 0x01	; 1
    e6a6:	0e 94 03 b0 	call	0x16006	; 0x16006 <_spi_init>
	sbi(DDRB,3);             //MISO Output
    e6aa:	bb 9a       	sbi	0x17, 3	; 23
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    e6ac:	bb 9a       	sbi	0x17, 3	; 23
    e6ae:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    e6b0:	ba 98       	cbi	0x17, 2	; 23
    e6b2:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    e6b4:	b9 98       	cbi	0x17, 1	; 23
    e6b6:	c1 9a       	sbi	0x18, 1	; 24
}
    e6b8:	08 95       	ret

0000e6ba <EDCSendByte>:
    _spi_enable(_SPI_SLAVE); //Enable SS 
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
	sbi(DDRB,2);             //MOSI Output
}

void EDCSendByte(char EDCData){
    e6ba:	1f 93       	push	r17
    e6bc:	18 2f       	mov	r17, r24
     systemMaster();	 
    e6be:	0e 94 43 73 	call	0xe686	; 0xe686 <systemMaster>
     _spi(EDCData);
    e6c2:	81 2f       	mov	r24, r17
    e6c4:	0e 94 2d b0 	call	0x1605a	; 0x1605a <_spi>
     systemSlave();
    e6c8:	0e 94 4e 73 	call	0xe69c	; 0xe69c <systemSlave>
}
    e6cc:	1f 91       	pop	r17
    e6ce:	08 95       	ret

0000e6d0 <SendEDCMessage>:
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}

void SendEDCMessage(){
    e6d0:	cf 92       	push	r12
    e6d2:	df 92       	push	r13
    e6d4:	ef 92       	push	r14
    e6d6:	ff 92       	push	r15
    e6d8:	0f 93       	push	r16
    e6da:	1f 93       	push	r17
    e6dc:	df 93       	push	r29
    e6de:	cf 93       	push	r28
    e6e0:	cd b7       	in	r28, 0x3d	; 61
    e6e2:	de b7       	in	r29, 0x3e	; 62
    e6e4:	ec 97       	sbiw	r28, 0x3c	; 60
    e6e6:	0f b6       	in	r0, 0x3f	; 63
    e6e8:	f8 94       	cli
    e6ea:	de bf       	out	0x3e, r29	; 62
    e6ec:	0f be       	out	0x3f, r0	; 63
    e6ee:	cd bf       	out	0x3d, r28	; 61

     //GenerateData
	 //sprintf_P(strAmount,PSTR("%d"),100);//Testing Only
	 //AddZeroLead(strAmount,8);
	 //_uart_printf(0,0,PSTR("StrStatus:"));_uart_print(0,1,strStatus);
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     
    e6f0:	8d b7       	in	r24, 0x3d	; 61
    e6f2:	9e b7       	in	r25, 0x3e	; 62
    e6f4:	42 97       	sbiw	r24, 0x12	; 18
    e6f6:	0f b6       	in	r0, 0x3f	; 63
    e6f8:	f8 94       	cli
    e6fa:	9e bf       	out	0x3e, r25	; 62
    e6fc:	0f be       	out	0x3f, r0	; 63
    e6fe:	8d bf       	out	0x3d, r24	; 61
    e700:	ed b7       	in	r30, 0x3d	; 61
    e702:	fe b7       	in	r31, 0x3e	; 62
    e704:	31 96       	adiw	r30, 0x01	; 1
    e706:	8e 01       	movw	r16, r28
    e708:	0f 5f       	subi	r16, 0xFF	; 255
    e70a:	1f 4f       	sbci	r17, 0xFF	; 255
    e70c:	ad b7       	in	r26, 0x3d	; 61
    e70e:	be b7       	in	r27, 0x3e	; 62
    e710:	12 96       	adiw	r26, 0x02	; 2
    e712:	1c 93       	st	X, r17
    e714:	0e 93       	st	-X, r16
    e716:	11 97       	sbiw	r26, 0x01	; 1
    e718:	82 e2       	ldi	r24, 0x22	; 34
    e71a:	9b e1       	ldi	r25, 0x1B	; 27
    e71c:	93 83       	std	Z+3, r25	; 0x03
    e71e:	82 83       	std	Z+2, r24	; 0x02
    e720:	82 e9       	ldi	r24, 0x92	; 146
    e722:	9e e0       	ldi	r25, 0x0E	; 14
    e724:	95 83       	std	Z+5, r25	; 0x05
    e726:	84 83       	std	Z+4, r24	; 0x04
    e728:	88 ec       	ldi	r24, 0xC8	; 200
    e72a:	99 e0       	ldi	r25, 0x09	; 9
    e72c:	97 83       	std	Z+7, r25	; 0x07
    e72e:	86 83       	std	Z+6, r24	; 0x06
    e730:	8d e3       	ldi	r24, 0x3D	; 61
    e732:	9a e0       	ldi	r25, 0x0A	; 10
    e734:	91 87       	std	Z+9, r25	; 0x09
    e736:	80 87       	std	Z+8, r24	; 0x08
    e738:	8d ea       	ldi	r24, 0xAD	; 173
    e73a:	97 e0       	ldi	r25, 0x07	; 7
    e73c:	93 87       	std	Z+11, r25	; 0x0b
    e73e:	82 87       	std	Z+10, r24	; 0x0a
    e740:	8b e7       	ldi	r24, 0x7B	; 123
    e742:	95 e0       	ldi	r25, 0x05	; 5
    e744:	95 87       	std	Z+13, r25	; 0x0d
    e746:	84 87       	std	Z+12, r24	; 0x0c
    e748:	8b eb       	ldi	r24, 0xBB	; 187
    e74a:	9d e0       	ldi	r25, 0x0D	; 13
    e74c:	97 87       	std	Z+15, r25	; 0x0f
    e74e:	86 87       	std	Z+14, r24	; 0x0e
    e750:	80 e9       	ldi	r24, 0x90	; 144
    e752:	95 e0       	ldi	r25, 0x05	; 5
    e754:	91 8b       	std	Z+17, r25	; 0x11
    e756:	80 8b       	std	Z+16, r24	; 0x10
    e758:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
    e75c:	8d b7       	in	r24, 0x3d	; 61
    e75e:	9e b7       	in	r25, 0x3e	; 62
    e760:	42 96       	adiw	r24, 0x12	; 18
    e762:	0f b6       	in	r0, 0x3f	; 63
    e764:	f8 94       	cli
    e766:	9e bf       	out	0x3e, r25	; 62
    e768:	0f be       	out	0x3f, r0	; 63
    e76a:	8d bf       	out	0x3d, r24	; 61
    e76c:	82 e0       	ldi	r24, 0x02	; 2
    e76e:	0e 94 5d 73 	call	0xe6ba	; 0xe6ba <EDCSendByte>
    e772:	ff 24       	eor	r15, r15
    e774:	52 e0       	ldi	r21, 0x02	; 2
    e776:	e5 2e       	mov	r14, r21
    e778:	44 ec       	ldi	r20, 0xC4	; 196
    e77a:	c4 2e       	mov	r12, r20
    e77c:	49 e0       	ldi	r20, 0x09	; 9
    e77e:	d4 2e       	mov	r13, r20
    e780:	0a c0       	rjmp	.+20     	; 0xe796 <SendEDCMessage+0xc6>
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
    e782:	a0 0f       	add	r26, r16
    e784:	b1 1f       	adc	r27, r17
    e786:	8c 91       	ld	r24, X
     systemSlave();
}

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
    e788:	e8 26       	eor	r14, r24
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
    e78a:	0e 94 5d 73 	call	0xe6ba	; 0xe6ba <EDCSendByte>
    e78e:	c6 01       	movw	r24, r12
    e790:	01 97       	sbiw	r24, 0x01	; 1
    e792:	f1 f7       	brne	.-4      	; 0xe790 <SendEDCMessage+0xc0>
	 //_uart_printf(0,0,PSTR("StrStatus:"));_uart_print(0,1,strStatus);
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
    e794:	f3 94       	inc	r15
    e796:	f8 01       	movw	r30, r16
    e798:	01 90       	ld	r0, Z+
    e79a:	00 20       	and	r0, r0
    e79c:	e9 f7       	brne	.-6      	; 0xe798 <SendEDCMessage+0xc8>
    e79e:	31 97       	sbiw	r30, 0x01	; 1
    e7a0:	e0 1b       	sub	r30, r16
    e7a2:	f1 0b       	sbc	r31, r17
    e7a4:	af 2d       	mov	r26, r15
    e7a6:	b0 e0       	ldi	r27, 0x00	; 0
    e7a8:	ae 17       	cp	r26, r30
    e7aa:	bf 07       	cpc	r27, r31
    e7ac:	50 f3       	brcs	.-44     	; 0xe782 <SendEDCMessage+0xb2>
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
		  //_uart(0,1,SerialEDC[i]);
		  _delay_ms(10);//min:8
	 }
     EDCSendByte(0x03);
    e7ae:	83 e0       	ldi	r24, 0x03	; 3
    e7b0:	0e 94 5d 73 	call	0xe6ba	; 0xe6ba <EDCSendByte>
	 xCRC=CalcLRC(xCRC,0x03);	      
	 EDCSendByte(xCRC);
    e7b4:	83 e0       	ldi	r24, 0x03	; 3
    e7b6:	8e 25       	eor	r24, r14
    e7b8:	0e 94 5d 73 	call	0xe6ba	; 0xe6ba <EDCSendByte>
}
    e7bc:	ec 96       	adiw	r28, 0x3c	; 60
    e7be:	0f b6       	in	r0, 0x3f	; 63
    e7c0:	f8 94       	cli
    e7c2:	de bf       	out	0x3e, r29	; 62
    e7c4:	0f be       	out	0x3f, r0	; 63
    e7c6:	cd bf       	out	0x3d, r28	; 61
    e7c8:	cf 91       	pop	r28
    e7ca:	df 91       	pop	r29
    e7cc:	1f 91       	pop	r17
    e7ce:	0f 91       	pop	r16
    e7d0:	ff 90       	pop	r15
    e7d2:	ef 90       	pop	r14
    e7d4:	df 90       	pop	r13
    e7d6:	cf 90       	pop	r12
    e7d8:	08 95       	ret

0000e7da <SendSlaveCommand>:
void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
	 PoolMsg=plMsg;
     IsControlPooling=True;
}
void SendSlaveCommand(char SlaveCommand,char SlaveMessage){     
    e7da:	0f 93       	push	r16
    e7dc:	1f 93       	push	r17
    e7de:	18 2f       	mov	r17, r24
    e7e0:	06 2f       	mov	r16, r22
	 systemMaster();
    e7e2:	0e 94 43 73 	call	0xe686	; 0xe686 <systemMaster>
	 _spi(0x05);
    e7e6:	85 e0       	ldi	r24, 0x05	; 5
    e7e8:	0e 94 2d b0 	call	0x1605a	; 0x1605a <_spi>
	 _spi(SlaveCommand);
    e7ec:	81 2f       	mov	r24, r17
    e7ee:	0e 94 2d b0 	call	0x1605a	; 0x1605a <_spi>
	 _spi(SlaveMessage);
    e7f2:	80 2f       	mov	r24, r16
    e7f4:	0e 94 2d b0 	call	0x1605a	; 0x1605a <_spi>
	 _spi(0x06);
    e7f8:	86 e0       	ldi	r24, 0x06	; 6
    e7fa:	0e 94 2d b0 	call	0x1605a	; 0x1605a <_spi>
	 systemSlave();
    e7fe:	0e 94 4e 73 	call	0xe69c	; 0xe69c <systemSlave>
}
    e802:	1f 91       	pop	r17
    e804:	0f 91       	pop	r16
    e806:	08 95       	ret

0000e808 <FSettingPumpID>:
     if ((*Value)>MinValue){
	     (*Value)--;
	 }else *Value=MaxValue;
}

char FSettingPumpID(){
    e808:	9f 92       	push	r9
    e80a:	af 92       	push	r10
    e80c:	bf 92       	push	r11
    e80e:	cf 92       	push	r12
    e810:	df 92       	push	r13
    e812:	ef 92       	push	r14
    e814:	ff 92       	push	r15
    e816:	0f 93       	push	r16
    e818:	1f 93       	push	r17
    e81a:	df 93       	push	r29
    e81c:	cf 93       	push	r28
    e81e:	cd b7       	in	r28, 0x3d	; 61
    e820:	de b7       	in	r29, 0x3e	; 62
    e822:	64 97       	sbiw	r28, 0x14	; 20
    e824:	0f b6       	in	r0, 0x3f	; 63
    e826:	f8 94       	cli
    e828:	de bf       	out	0x3e, r29	; 62
    e82a:	0f be       	out	0x3f, r0	; 63
    e82c:	cd bf       	out	0x3d, r28	; 61
	 char iLoop,Result,KeyChar,KeyPressed,i,j,CheckPump;
	 char lcdteks[20];
	 static char Idx,PPumpId[8],MsgPumpId,PumpCount;
     
	 Result=MENU_NONE;
	 switch (stMenuPumpID){
    e82e:	80 91 fb 02 	lds	r24, 0x02FB
    e832:	85 30       	cpi	r24, 0x05	; 5
    e834:	09 f4       	brne	.+2      	; 0xe838 <FSettingPumpID+0x30>
    e836:	88 c1       	rjmp	.+784    	; 0xeb48 <FSettingPumpID+0x340>
    e838:	86 30       	cpi	r24, 0x06	; 6
    e83a:	90 f4       	brcc	.+36     	; 0xe860 <FSettingPumpID+0x58>
    e83c:	82 30       	cpi	r24, 0x02	; 2
    e83e:	09 f4       	brne	.+2      	; 0xe842 <FSettingPumpID+0x3a>
    e840:	8f c0       	rjmp	.+286    	; 0xe960 <FSettingPumpID+0x158>
    e842:	83 30       	cpi	r24, 0x03	; 3
    e844:	30 f4       	brcc	.+12     	; 0xe852 <FSettingPumpID+0x4a>
    e846:	88 23       	and	r24, r24
    e848:	f1 f0       	breq	.+60     	; 0xe886 <FSettingPumpID+0x7e>
    e84a:	81 30       	cpi	r24, 0x01	; 1
    e84c:	09 f0       	breq	.+2      	; 0xe850 <FSettingPumpID+0x48>
    e84e:	73 c2       	rjmp	.+1254   	; 0xed36 <FSettingPumpID+0x52e>
    e850:	2d c0       	rjmp	.+90     	; 0xe8ac <FSettingPumpID+0xa4>
    e852:	83 30       	cpi	r24, 0x03	; 3
    e854:	09 f4       	brne	.+2      	; 0xe858 <FSettingPumpID+0x50>
    e856:	51 c1       	rjmp	.+674    	; 0xeafa <FSettingPumpID+0x2f2>
    e858:	84 30       	cpi	r24, 0x04	; 4
    e85a:	09 f0       	breq	.+2      	; 0xe85e <FSettingPumpID+0x56>
    e85c:	6c c2       	rjmp	.+1240   	; 0xed36 <FSettingPumpID+0x52e>
    e85e:	6d c1       	rjmp	.+730    	; 0xeb3a <FSettingPumpID+0x332>
    e860:	88 30       	cpi	r24, 0x08	; 8
    e862:	09 f4       	brne	.+2      	; 0xe866 <FSettingPumpID+0x5e>
    e864:	fc c1       	rjmp	.+1016   	; 0xec5e <FSettingPumpID+0x456>
    e866:	89 30       	cpi	r24, 0x09	; 9
    e868:	38 f4       	brcc	.+14     	; 0xe878 <FSettingPumpID+0x70>
    e86a:	86 30       	cpi	r24, 0x06	; 6
    e86c:	09 f4       	brne	.+2      	; 0xe870 <FSettingPumpID+0x68>
    e86e:	9b c1       	rjmp	.+822    	; 0xeba6 <FSettingPumpID+0x39e>
    e870:	87 30       	cpi	r24, 0x07	; 7
    e872:	09 f0       	breq	.+2      	; 0xe876 <FSettingPumpID+0x6e>
    e874:	60 c2       	rjmp	.+1216   	; 0xed36 <FSettingPumpID+0x52e>
    e876:	45 c2       	rjmp	.+1162   	; 0xed02 <FSettingPumpID+0x4fa>
    e878:	89 30       	cpi	r24, 0x09	; 9
    e87a:	09 f4       	brne	.+2      	; 0xe87e <FSettingPumpID+0x76>
    e87c:	4a c2       	rjmp	.+1172   	; 0xed12 <FSettingPumpID+0x50a>
    e87e:	8a 30       	cpi	r24, 0x0A	; 10
    e880:	09 f0       	breq	.+2      	; 0xe884 <FSettingPumpID+0x7c>
    e882:	59 c2       	rjmp	.+1202   	; 0xed36 <FSettingPumpID+0x52e>
    e884:	4c c2       	rjmp	.+1176   	; 0xed1e <FSettingPumpID+0x516>
	 case mpInitPumpId:	      
	      //Disable PumpPooling
		  if (IFType==IT_STANDALONE)SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    e886:	80 91 25 01 	lds	r24, 0x0125
    e88a:	82 30       	cpi	r24, 0x02	; 2
    e88c:	21 f4       	brne	.+8      	; 0xe896 <FSettingPumpID+0x8e>
    e88e:	8f e1       	ldi	r24, 0x1F	; 31
    e890:	60 e0       	ldi	r22, 0x00	; 0
    e892:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
    e896:	81 ef       	ldi	r24, 0xF1	; 241
    e898:	92 e0       	ldi	r25, 0x02	; 2
    e89a:	65 e4       	ldi	r22, 0x45	; 69
    e89c:	70 e0       	ldi	r23, 0x00	; 0
    e89e:	48 e0       	ldi	r20, 0x08	; 8
    e8a0:	50 e0       	ldi	r21, 0x00	; 0
    e8a2:	2c ea       	ldi	r18, 0xAC	; 172
    e8a4:	32 e1       	ldi	r19, 0x12	; 18
    e8a6:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
    e8aa:	4c c1       	rjmp	.+664    	; 0xeb44 <FSettingPumpID+0x33c>
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
    e8ac:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    e8b0:	b1 ef       	ldi	r27, 0xF1	; 241
    e8b2:	eb 2e       	mov	r14, r27
    e8b4:	b2 e0       	ldi	r27, 0x02	; 2
    e8b6:	fb 2e       	mov	r15, r27
    e8b8:	01 e0       	ldi	r16, 0x01	; 1
    e8ba:	10 e0       	ldi	r17, 0x00	; 0
		  for (iLoop=0;iLoop<4;iLoop++){
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    e8bc:	6e 01       	movw	r12, r28
    e8be:	08 94       	sec
    e8c0:	c1 1c       	adc	r12, r1
    e8c2:	d1 1c       	adc	r13, r1
    e8c4:	ad ec       	ldi	r26, 0xCD	; 205
    e8c6:	aa 2e       	mov	r10, r26
    e8c8:	ad e0       	ldi	r26, 0x0D	; 13
    e8ca:	ba 2e       	mov	r11, r26
    e8cc:	8d b7       	in	r24, 0x3d	; 61
    e8ce:	9e b7       	in	r25, 0x3e	; 62
    e8d0:	0c 97       	sbiw	r24, 0x0c	; 12
    e8d2:	0f b6       	in	r0, 0x3f	; 63
    e8d4:	f8 94       	cli
    e8d6:	9e bf       	out	0x3e, r25	; 62
    e8d8:	0f be       	out	0x3f, r0	; 63
    e8da:	8d bf       	out	0x3d, r24	; 61
    e8dc:	ed b7       	in	r30, 0x3d	; 61
    e8de:	fe b7       	in	r31, 0x3e	; 62
    e8e0:	31 96       	adiw	r30, 0x01	; 1
    e8e2:	ad b7       	in	r26, 0x3d	; 61
    e8e4:	be b7       	in	r27, 0x3e	; 62
    e8e6:	12 96       	adiw	r26, 0x02	; 2
    e8e8:	dc 92       	st	X, r13
    e8ea:	ce 92       	st	-X, r12
    e8ec:	11 97       	sbiw	r26, 0x01	; 1
    e8ee:	b3 82       	std	Z+3, r11	; 0x03
    e8f0:	a2 82       	std	Z+2, r10	; 0x02
    e8f2:	15 83       	std	Z+5, r17	; 0x05
    e8f4:	04 83       	std	Z+4, r16	; 0x04
    e8f6:	d7 01       	movw	r26, r14
    e8f8:	8c 91       	ld	r24, X
    e8fa:	86 83       	std	Z+6, r24	; 0x06
    e8fc:	17 82       	std	Z+7, r1	; 0x07
    e8fe:	0c 5f       	subi	r16, 0xFC	; 252
    e900:	1f 4f       	sbci	r17, 0xFF	; 255
    e902:	11 87       	std	Z+9, r17	; 0x09
    e904:	00 87       	std	Z+8, r16	; 0x08
    e906:	04 50       	subi	r16, 0x04	; 4
    e908:	10 40       	sbci	r17, 0x00	; 0
    e90a:	14 96       	adiw	r26, 0x04	; 4
    e90c:	8c 91       	ld	r24, X
    e90e:	82 87       	std	Z+10, r24	; 0x0a
    e910:	13 86       	std	Z+11, r1	; 0x0b
    e912:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  lcd_print((iLoop+1),1,lcdteks);
    e916:	ed b7       	in	r30, 0x3d	; 61
    e918:	fe b7       	in	r31, 0x3e	; 62
    e91a:	3c 96       	adiw	r30, 0x0c	; 12
    e91c:	0f b6       	in	r0, 0x3f	; 63
    e91e:	f8 94       	cli
    e920:	fe bf       	out	0x3e, r31	; 62
    e922:	0f be       	out	0x3f, r0	; 63
    e924:	ed bf       	out	0x3d, r30	; 61
    e926:	80 2f       	mov	r24, r16
    e928:	61 e0       	ldi	r22, 0x01	; 1
    e92a:	a6 01       	movw	r20, r12
    e92c:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    e930:	08 94       	sec
    e932:	e1 1c       	adc	r14, r1
    e934:	f1 1c       	adc	r15, r1
    e936:	0f 5f       	subi	r16, 0xFF	; 255
    e938:	1f 4f       	sbci	r17, 0xFF	; 255
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
		  for (iLoop=0;iLoop<4;iLoop++){
    e93a:	f5 ef       	ldi	r31, 0xF5	; 245
    e93c:	ef 16       	cp	r14, r31
    e93e:	f2 e0       	ldi	r31, 0x02	; 2
    e940:	ff 06       	cpc	r15, r31
    e942:	21 f6       	brne	.-120    	; 0xe8cc <FSettingPumpID+0xc4>
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
			  lcd_print((iLoop+1),1,lcdteks);
          }
          lcd_printf(3,15,PSTR("*)Back"));
    e944:	83 e0       	ldi	r24, 0x03	; 3
    e946:	6f e0       	ldi	r22, 0x0F	; 15
    e948:	46 ec       	ldi	r20, 0xC6	; 198
    e94a:	5d e0       	ldi	r21, 0x0D	; 13
    e94c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	      lcd_printf(4,15,PSTR("#)Save"));
    e950:	84 e0       	ldi	r24, 0x04	; 4
    e952:	6f e0       	ldi	r22, 0x0F	; 15
    e954:	4f eb       	ldi	r20, 0xBF	; 191
    e956:	5d e0       	ldi	r21, 0x0D	; 13
    e958:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
          stMenuPumpID=mpSelectInput;
    e95c:	82 e0       	ldi	r24, 0x02	; 2
    e95e:	d6 c1       	rjmp	.+940    	; 0xed0c <FSettingPumpID+0x504>
	      break;
     case mpSelectInput:
	      KeyPressed=_key_scan(1);
    e960:	81 e0       	ldi	r24, 0x01	; 1
    e962:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    e966:	98 2e       	mov	r9, r24
	      KeyChar=_key_btn(KeyPressed);
    e968:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
    e96c:	98 2f       	mov	r25, r24
          if ((KeyChar>='1') && (KeyChar<='8')){
    e96e:	81 53       	subi	r24, 0x31	; 49
    e970:	88 30       	cpi	r24, 0x08	; 8
    e972:	08 f0       	brcs	.+2      	; 0xe976 <FSettingPumpID+0x16e>
    e974:	85 c0       	rjmp	.+266    	; 0xea80 <FSettingPumpID+0x278>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
    e976:	80 91 25 01 	lds	r24, 0x0125
    e97a:	81 30       	cpi	r24, 0x01	; 1
    e97c:	19 f0       	breq	.+6      	; 0xe984 <FSettingPumpID+0x17c>
    e97e:	82 30       	cpi	r24, 0x02	; 2
    e980:	a1 f5       	brne	.+104    	; 0xe9ea <FSettingPumpID+0x1e2>
    e982:	17 c0       	rjmp	.+46     	; 0xe9b2 <FSettingPumpID+0x1aa>
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
    e984:	80 91 fa 02 	lds	r24, 0x02FA
    e988:	88 23       	and	r24, r24
    e98a:	41 f4       	brne	.+16     	; 0xe99c <FSettingPumpID+0x194>
    e98c:	e9 2f       	mov	r30, r25
    e98e:	f0 e0       	ldi	r31, 0x00	; 0
    e990:	e0 54       	subi	r30, 0x40	; 64
    e992:	fd 4f       	sbci	r31, 0xFD	; 253
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    e994:	80 81       	ld	r24, Z
    e996:	83 36       	cpi	r24, 0x63	; 99
    e998:	c8 f4       	brcc	.+50     	; 0xe9cc <FSettingPumpID+0x1c4>
    e99a:	16 c0       	rjmp	.+44     	; 0xe9c8 <FSettingPumpID+0x1c0>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
    e99c:	81 30       	cpi	r24, 0x01	; 1
    e99e:	29 f5       	brne	.+74     	; 0xe9ea <FSettingPumpID+0x1e2>
    e9a0:	e9 2f       	mov	r30, r25
    e9a2:	f0 e0       	ldi	r31, 0x00	; 0
    e9a4:	e0 54       	subi	r30, 0x40	; 64
    e9a6:	fd 4f       	sbci	r31, 0xFD	; 253
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    e9a8:	80 81       	ld	r24, Z
    e9aa:	88 23       	and	r24, r24
    e9ac:	d1 f4       	brne	.+52     	; 0xe9e2 <FSettingPumpID+0x1da>
	     (*Value)--;
	 }else *Value=MaxValue;
    e9ae:	83 e6       	ldi	r24, 0x63	; 99
    e9b0:	1b c0       	rjmp	.+54     	; 0xe9e8 <FSettingPumpID+0x1e0>
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
    e9b2:	80 91 fa 02 	lds	r24, 0x02FA
    e9b6:	88 23       	and	r24, r24
    e9b8:	59 f4       	brne	.+22     	; 0xe9d0 <FSettingPumpID+0x1c8>
    e9ba:	e9 2f       	mov	r30, r25
    e9bc:	f0 e0       	ldi	r31, 0x00	; 0
    e9be:	e0 54       	subi	r30, 0x40	; 64
    e9c0:	fd 4f       	sbci	r31, 0xFD	; 253
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    e9c2:	80 81       	ld	r24, Z
    e9c4:	80 31       	cpi	r24, 0x10	; 16
    e9c6:	10 f4       	brcc	.+4      	; 0xe9cc <FSettingPumpID+0x1c4>
	     (*Value)++;
    e9c8:	8f 5f       	subi	r24, 0xFF	; 255
    e9ca:	0e c0       	rjmp	.+28     	; 0xe9e8 <FSettingPumpID+0x1e0>
	 }else *Value=MinValue;
    e9cc:	10 82       	st	Z, r1
    e9ce:	0d c0       	rjmp	.+26     	; 0xe9ea <FSettingPumpID+0x1e2>
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
    e9d0:	81 30       	cpi	r24, 0x01	; 1
    e9d2:	59 f4       	brne	.+22     	; 0xe9ea <FSettingPumpID+0x1e2>
    e9d4:	e9 2f       	mov	r30, r25
    e9d6:	f0 e0       	ldi	r31, 0x00	; 0
    e9d8:	e0 54       	subi	r30, 0x40	; 64
    e9da:	fd 4f       	sbci	r31, 0xFD	; 253
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    e9dc:	80 81       	ld	r24, Z
    e9de:	88 23       	and	r24, r24
    e9e0:	11 f0       	breq	.+4      	; 0xe9e6 <FSettingPumpID+0x1de>
	     (*Value)--;
    e9e2:	81 50       	subi	r24, 0x01	; 1
    e9e4:	01 c0       	rjmp	.+2      	; 0xe9e8 <FSettingPumpID+0x1e0>
	 }else *Value=MaxValue;
    e9e6:	80 e1       	ldi	r24, 0x10	; 16
    e9e8:	80 83       	st	Z, r24
    e9ea:	f1 ef       	ldi	r31, 0xF1	; 241
    e9ec:	ef 2e       	mov	r14, r31
    e9ee:	f2 e0       	ldi	r31, 0x02	; 2
    e9f0:	ff 2e       	mov	r15, r31
    e9f2:	01 e0       	ldi	r16, 0x01	; 1
    e9f4:	10 e0       	ldi	r17, 0x00	; 0
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    e9f6:	6e 01       	movw	r12, r28
    e9f8:	08 94       	sec
    e9fa:	c1 1c       	adc	r12, r1
    e9fc:	d1 1c       	adc	r13, r1
    e9fe:	eb ea       	ldi	r30, 0xAB	; 171
    ea00:	ae 2e       	mov	r10, r30
    ea02:	ed e0       	ldi	r30, 0x0D	; 13
    ea04:	be 2e       	mov	r11, r30
    ea06:	8d b7       	in	r24, 0x3d	; 61
    ea08:	9e b7       	in	r25, 0x3e	; 62
    ea0a:	0c 97       	sbiw	r24, 0x0c	; 12
    ea0c:	0f b6       	in	r0, 0x3f	; 63
    ea0e:	f8 94       	cli
    ea10:	9e bf       	out	0x3e, r25	; 62
    ea12:	0f be       	out	0x3f, r0	; 63
    ea14:	8d bf       	out	0x3d, r24	; 61
    ea16:	ed b7       	in	r30, 0x3d	; 61
    ea18:	fe b7       	in	r31, 0x3e	; 62
    ea1a:	31 96       	adiw	r30, 0x01	; 1
    ea1c:	ad b7       	in	r26, 0x3d	; 61
    ea1e:	be b7       	in	r27, 0x3e	; 62
    ea20:	12 96       	adiw	r26, 0x02	; 2
    ea22:	dc 92       	st	X, r13
    ea24:	ce 92       	st	-X, r12
    ea26:	11 97       	sbiw	r26, 0x01	; 1
    ea28:	b3 82       	std	Z+3, r11	; 0x03
    ea2a:	a2 82       	std	Z+2, r10	; 0x02
    ea2c:	15 83       	std	Z+5, r17	; 0x05
    ea2e:	04 83       	std	Z+4, r16	; 0x04
    ea30:	d7 01       	movw	r26, r14
    ea32:	8c 91       	ld	r24, X
    ea34:	86 83       	std	Z+6, r24	; 0x06
    ea36:	17 82       	std	Z+7, r1	; 0x07
    ea38:	0c 5f       	subi	r16, 0xFC	; 252
    ea3a:	1f 4f       	sbci	r17, 0xFF	; 255
    ea3c:	11 87       	std	Z+9, r17	; 0x09
    ea3e:	00 87       	std	Z+8, r16	; 0x08
    ea40:	04 50       	subi	r16, 0x04	; 4
    ea42:	10 40       	sbci	r17, 0x00	; 0
    ea44:	14 96       	adiw	r26, 0x04	; 4
    ea46:	8c 91       	ld	r24, X
    ea48:	82 87       	std	Z+10, r24	; 0x0a
    ea4a:	13 86       	std	Z+11, r1	; 0x0b
    ea4c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
				  lcd_print((iLoop+1),1,lcdteks);
    ea50:	ed b7       	in	r30, 0x3d	; 61
    ea52:	fe b7       	in	r31, 0x3e	; 62
    ea54:	3c 96       	adiw	r30, 0x0c	; 12
    ea56:	0f b6       	in	r0, 0x3f	; 63
    ea58:	f8 94       	cli
    ea5a:	fe bf       	out	0x3e, r31	; 62
    ea5c:	0f be       	out	0x3f, r0	; 63
    ea5e:	ed bf       	out	0x3d, r30	; 61
    ea60:	80 2f       	mov	r24, r16
    ea62:	61 e0       	ldi	r22, 0x01	; 1
    ea64:	a6 01       	movw	r20, r12
    ea66:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    ea6a:	08 94       	sec
    ea6c:	e1 1c       	adc	r14, r1
    ea6e:	f1 1c       	adc	r15, r1
    ea70:	0f 5f       	subi	r16, 0xFF	; 255
    ea72:	1f 4f       	sbci	r17, 0xFF	; 255
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
    ea74:	f5 ef       	ldi	r31, 0xF5	; 245
    ea76:	ef 16       	cp	r14, r31
    ea78:	f2 e0       	ldi	r31, 0x02	; 2
    ea7a:	ff 06       	cpc	r15, r31
    ea7c:	21 f6       	brne	.-120    	; 0xea06 <FSettingPumpID+0x1fe>
    ea7e:	2b c0       	rjmp	.+86     	; 0xead6 <FSettingPumpID+0x2ce>
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
    ea80:	93 32       	cpi	r25, 0x23	; 35
    ea82:	21 f5       	brne	.+72     	; 0xeacc <FSettingPumpID+0x2c4>
    ea84:	40 e0       	ldi	r20, 0x00	; 0
    ea86:	20 e0       	ldi	r18, 0x00	; 0
    ea88:	30 e0       	ldi	r19, 0x00	; 0
    ea8a:	52 2f       	mov	r21, r18
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
    ea8c:	f9 01       	movw	r30, r18
    ea8e:	ef 50       	subi	r30, 0x0F	; 15
    ea90:	fd 4f       	sbci	r31, 0xFD	; 253
    ea92:	e0 81       	ld	r30, Z
				   if (CheckPump>0){
    ea94:	ee 23       	and	r30, r30
    ea96:	69 f0       	breq	.+26     	; 0xeab2 <FSettingPumpID+0x2aa>
    ea98:	a1 ef       	ldi	r26, 0xF1	; 241
    ea9a:	b2 e0       	ldi	r27, 0x02	; 2
    ea9c:	90 e0       	ldi	r25, 0x00	; 0
				      for(j=0;j<8;j++){					      
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
    ea9e:	59 17       	cp	r21, r25
    eaa0:	21 f0       	breq	.+8      	; 0xeaaa <FSettingPumpID+0x2a2>
    eaa2:	8c 91       	ld	r24, X
    eaa4:	e8 17       	cp	r30, r24
    eaa6:	09 f4       	brne	.+2      	; 0xeaaa <FSettingPumpID+0x2a2>
						       PumpCount++;
    eaa8:	4f 5f       	subi	r20, 0xFF	; 255
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
				   if (CheckPump>0){
				      for(j=0;j<8;j++){					      
    eaaa:	9f 5f       	subi	r25, 0xFF	; 255
    eaac:	11 96       	adiw	r26, 0x01	; 1
    eaae:	98 30       	cpi	r25, 0x08	; 8
    eab0:	b1 f7       	brne	.-20     	; 0xea9e <FSettingPumpID+0x296>
    eab2:	2f 5f       	subi	r18, 0xFF	; 255
    eab4:	3f 4f       	sbci	r19, 0xFF	; 255
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
    eab6:	28 30       	cpi	r18, 0x08	; 8
    eab8:	31 05       	cpc	r19, r1
    eaba:	39 f7       	brne	.-50     	; 0xea8a <FSettingPumpID+0x282>
    eabc:	40 93 ef 02 	sts	0x02EF, r20
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
						       PumpCount++;
					  }
				    }				     
				  }			       			  			  
			  if (PumpCount>0) stMenuPumpID=mpSaveFailed;
    eac0:	44 23       	and	r20, r20
    eac2:	11 f0       	breq	.+4      	; 0xeac8 <FSettingPumpID+0x2c0>
    eac4:	83 e0       	ldi	r24, 0x03	; 3
    eac6:	05 c0       	rjmp	.+10     	; 0xead2 <FSettingPumpID+0x2ca>
			  else stMenuPumpID=mpSavingPumpId;
    eac8:	85 e0       	ldi	r24, 0x05	; 5
    eaca:	03 c0       	rjmp	.+6      	; 0xead2 <FSettingPumpID+0x2ca>
		  }	
		  else if (KeyChar=='*'){
    eacc:	9a 32       	cpi	r25, 0x2A	; 42
    eace:	19 f4       	brne	.+6      	; 0xead6 <FSettingPumpID+0x2ce>
		      stMenuPumpID=mpExitPumpId;
    ead0:	8a e0       	ldi	r24, 0x0A	; 10
    ead2:	80 93 fb 02 	sts	0x02FB, r24
		  }
		  if (KeyPressed==_KEY_SHIFT){
    ead6:	8b e7       	ldi	r24, 0x7B	; 123
    ead8:	98 16       	cp	r9, r24
    eada:	09 f0       	breq	.+2      	; 0xeade <FSettingPumpID+0x2d6>
    eadc:	2c c1       	rjmp	.+600    	; 0xed36 <FSettingPumpID+0x52e>
		      if (IsShift==False)IsShift=True;
    eade:	80 91 fa 02 	lds	r24, 0x02FA
    eae2:	88 23       	and	r24, r24
    eae4:	21 f4       	brne	.+8      	; 0xeaee <FSettingPumpID+0x2e6>
    eae6:	81 e0       	ldi	r24, 0x01	; 1
    eae8:	80 93 fa 02 	sts	0x02FA, r24
    eaec:	24 c1       	rjmp	.+584    	; 0xed36 <FSettingPumpID+0x52e>
			  else
			  if (IsShift==True)IsShift=False;
    eaee:	81 30       	cpi	r24, 0x01	; 1
    eaf0:	09 f0       	breq	.+2      	; 0xeaf4 <FSettingPumpID+0x2ec>
    eaf2:	21 c1       	rjmp	.+578    	; 0xed36 <FSettingPumpID+0x52e>
    eaf4:	10 92 fa 02 	sts	0x02FA, r1
    eaf8:	1e c1       	rjmp	.+572    	; 0xed36 <FSettingPumpID+0x52e>
		  }
	      break;
     case mpSaveFailed:
	      lcd_clear();
    eafa:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("      Warning!      "));
    eafe:	81 e0       	ldi	r24, 0x01	; 1
    eb00:	61 e0       	ldi	r22, 0x01	; 1
    eb02:	46 e9       	ldi	r20, 0x96	; 150
    eb04:	5d e0       	ldi	r21, 0x0D	; 13
    eb06:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
    eb0a:	82 e0       	ldi	r24, 0x02	; 2
    eb0c:	61 e0       	ldi	r22, 0x01	; 1
    eb0e:	41 e8       	ldi	r20, 0x81	; 129
    eb10:	5d e0       	ldi	r21, 0x0D	; 13
    eb12:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
    eb16:	83 e0       	ldi	r24, 0x03	; 3
    eb18:	61 e0       	ldi	r22, 0x01	; 1
    eb1a:	4c e6       	ldi	r20, 0x6C	; 108
    eb1c:	5d e0       	ldi	r21, 0x0D	; 13
    eb1e:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    eb22:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    eb24:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    eb26:	82 e0       	ldi	r24, 0x02	; 2
    eb28:	90 e0       	ldi	r25, 0x00	; 0
    eb2a:	90 93 ec 01 	sts	0x01EC, r25
    eb2e:	80 93 eb 01 	sts	0x01EB, r24
	      lcd_clear();
		  lcd_printf(1,1,PSTR("      Warning!      "));
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
		  system_beep(2);
	      TimDisplay=0;
    eb32:	10 92 bc 01 	sts	0x01BC, r1
	      stMenuPumpID=mpDisplayFailed;
    eb36:	84 e0       	ldi	r24, 0x04	; 4
    eb38:	e9 c0       	rjmp	.+466    	; 0xed0c <FSettingPumpID+0x504>
          break;	 
     case mpDisplayFailed:
	      if (TimDisplay>6) stMenuPumpID=mpDisplayPumpId;
    eb3a:	80 91 bc 01 	lds	r24, 0x01BC
    eb3e:	87 30       	cpi	r24, 0x07	; 7
    eb40:	08 f4       	brcc	.+2      	; 0xeb44 <FSettingPumpID+0x33c>
    eb42:	f9 c0       	rjmp	.+498    	; 0xed36 <FSettingPumpID+0x52e>
    eb44:	81 e0       	ldi	r24, 0x01	; 1
    eb46:	e2 c0       	rjmp	.+452    	; 0xed0c <FSettingPumpID+0x504>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    eb48:	85 e4       	ldi	r24, 0x45	; 69
    eb4a:	90 e0       	ldi	r25, 0x00	; 0
    eb4c:	61 ef       	ldi	r22, 0xF1	; 241
    eb4e:	72 e0       	ldi	r23, 0x02	; 2
    eb50:	48 e0       	ldi	r20, 0x08	; 8
    eb52:	50 e0       	ldi	r21, 0x00	; 0
    eb54:	24 eb       	ldi	r18, 0xB4	; 180
    eb56:	32 e1       	ldi	r19, 0x12	; 18
    eb58:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
	      break;
     case mpSavingPumpId:
	      eeprom_write_block((const void*) &PPumpId, (void*) &DefPumpMap, 8);
		  if (IFType==IT_STANDALONE){
    eb5c:	80 91 25 01 	lds	r24, 0x0125
    eb60:	82 30       	cpi	r24, 0x02	; 2
    eb62:	e9 f4       	brne	.+58     	; 0xeb9e <FSettingPumpID+0x396>
		      //SendConfig to Slave
			  lcd_clear();
    eb64:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
              lcd_printf(1,1,PSTR("-PumpID-"));
    eb68:	81 e0       	ldi	r24, 0x01	; 1
    eb6a:	61 e0       	ldi	r22, 0x01	; 1
    eb6c:	43 e6       	ldi	r20, 0x63	; 99
    eb6e:	5d e0       	ldi	r21, 0x0D	; 13
    eb70:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
              lcd_printf(2,1,PSTR("Saving.."));
    eb74:	82 e0       	ldi	r24, 0x02	; 2
    eb76:	61 e0       	ldi	r22, 0x01	; 1
    eb78:	4a e5       	ldi	r20, 0x5A	; 90
    eb7a:	5d e0       	ldi	r21, 0x0D	; 13
    eb7c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
			  Idx=0;
    eb80:	10 92 f9 02 	sts	0x02F9, r1
			  PumpCount=0;
    eb84:	10 92 ef 02 	sts	0x02EF, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    eb88:	81 ef       	ldi	r24, 0xF1	; 241
    eb8a:	92 e0       	ldi	r25, 0x02	; 2
    eb8c:	65 e4       	ldi	r22, 0x45	; 69
    eb8e:	70 e0       	ldi	r23, 0x00	; 0
    eb90:	48 e0       	ldi	r20, 0x08	; 8
    eb92:	50 e0       	ldi	r21, 0x00	; 0
    eb94:	2c ea       	ldi	r18, 0xAC	; 172
    eb96:	32 e1       	ldi	r19, 0x12	; 18
    eb98:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
    eb9c:	b6 c0       	rjmp	.+364    	; 0xed0a <FSettingPumpID+0x502>
              eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
              stMenuPumpID=mpSendConfigToSlave;
		  }else if (IFType==IT_SLAVE){
    eb9e:	81 30       	cpi	r24, 0x01	; 1
    eba0:	09 f0       	breq	.+2      	; 0xeba4 <FSettingPumpID+0x39c>
    eba2:	c9 c0       	rjmp	.+402    	; 0xed36 <FSettingPumpID+0x52e>
    eba4:	ba c0       	rjmp	.+372    	; 0xed1a <FSettingPumpID+0x512>
		      //SendConfig to Slave              
              stMenuPumpID=mpExitPumpId;
		  }
	      break;
     case mpSendConfigToSlave:
	      IsStandaloneAcknoledge=False;
    eba6:	10 92 ab 01 	sts	0x01AB, r1
	      if (PPumpId[Idx]!=0){
    ebaa:	90 91 f9 02 	lds	r25, 0x02F9
    ebae:	29 2f       	mov	r18, r25
    ebb0:	30 e0       	ldi	r19, 0x00	; 0
    ebb2:	f9 01       	movw	r30, r18
    ebb4:	ef 50       	subi	r30, 0x0F	; 15
    ebb6:	fd 4f       	sbci	r31, 0xFD	; 253
    ebb8:	60 81       	ld	r22, Z
    ebba:	66 23       	and	r22, r22
    ebbc:	81 f0       	breq	.+32     	; 0xebde <FSettingPumpID+0x3d6>
		      PumpCount++;
    ebbe:	80 91 ef 02 	lds	r24, 0x02EF
    ebc2:	8f 5f       	subi	r24, 0xFF	; 255
    ebc4:	80 93 ef 02 	sts	0x02EF, r24
		      MsgPumpId=((Idx<<4)|(0x0F&PPumpId[Idx]));//[Idx][PumpId]
    ebc8:	6f 70       	andi	r22, 0x0F	; 15
    ebca:	74 e0       	ldi	r23, 0x04	; 4
    ebcc:	22 0f       	add	r18, r18
    ebce:	33 1f       	adc	r19, r19
    ebd0:	7a 95       	dec	r23
    ebd2:	e1 f7       	brne	.-8      	; 0xebcc <FSettingPumpID+0x3c4>
    ebd4:	62 2b       	or	r22, r18
    ebd6:	60 93 f0 02 	sts	0x02F0, r22
	         //SendPoolingCommand(SC_SET_PUMPID,MsgPumpId);
			  SendSlaveCommand(SC_SET_PUMPID,MsgPumpId);
    ebda:	8d e1       	ldi	r24, 0x1D	; 29
    ebdc:	02 c0       	rjmp	.+4      	; 0xebe2 <FSettingPumpID+0x3da>
		  }else SendSlaveCommand(SC_CLEAR_PUMPID,Idx);//SendPoolingCommand(SC_CLEAR_PUMPID,Idx);
    ebde:	8e e1       	ldi	r24, 0x1E	; 30
    ebe0:	69 2f       	mov	r22, r25
    ebe2:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
		  sprintf_P(lcdteks,PSTR("Id[%d]=%.2d  "),Idx+1,PPumpId[Idx]);
    ebe6:	e0 91 f9 02 	lds	r30, 0x02F9
    ebea:	f0 e0       	ldi	r31, 0x00	; 0
    ebec:	ad b7       	in	r26, 0x3d	; 61
    ebee:	be b7       	in	r27, 0x3e	; 62
    ebf0:	18 97       	sbiw	r26, 0x08	; 8
    ebf2:	0f b6       	in	r0, 0x3f	; 63
    ebf4:	f8 94       	cli
    ebf6:	be bf       	out	0x3e, r27	; 62
    ebf8:	0f be       	out	0x3f, r0	; 63
    ebfa:	ad bf       	out	0x3d, r26	; 61
    ebfc:	2d b7       	in	r18, 0x3d	; 61
    ebfe:	3e b7       	in	r19, 0x3e	; 62
    ec00:	2f 5f       	subi	r18, 0xFF	; 255
    ec02:	3f 4f       	sbci	r19, 0xFF	; 255
    ec04:	8e 01       	movw	r16, r28
    ec06:	0f 5f       	subi	r16, 0xFF	; 255
    ec08:	1f 4f       	sbci	r17, 0xFF	; 255
    ec0a:	12 96       	adiw	r26, 0x02	; 2
    ec0c:	1c 93       	st	X, r17
    ec0e:	0e 93       	st	-X, r16
    ec10:	11 97       	sbiw	r26, 0x01	; 1
    ec12:	8c e4       	ldi	r24, 0x4C	; 76
    ec14:	9d e0       	ldi	r25, 0x0D	; 13
    ec16:	d9 01       	movw	r26, r18
    ec18:	13 96       	adiw	r26, 0x03	; 3
    ec1a:	9c 93       	st	X, r25
    ec1c:	8e 93       	st	-X, r24
    ec1e:	12 97       	sbiw	r26, 0x02	; 2
    ec20:	31 96       	adiw	r30, 0x01	; 1
    ec22:	15 96       	adiw	r26, 0x05	; 5
    ec24:	fc 93       	st	X, r31
    ec26:	ee 93       	st	-X, r30
    ec28:	14 97       	sbiw	r26, 0x04	; 4
    ec2a:	31 97       	sbiw	r30, 0x01	; 1
    ec2c:	ef 50       	subi	r30, 0x0F	; 15
    ec2e:	fd 4f       	sbci	r31, 0xFD	; 253
    ec30:	80 81       	ld	r24, Z
    ec32:	16 96       	adiw	r26, 0x06	; 6
    ec34:	8c 93       	st	X, r24
    ec36:	16 97       	sbiw	r26, 0x06	; 6
    ec38:	17 96       	adiw	r26, 0x07	; 7
    ec3a:	1c 92       	st	X, r1
    ec3c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(3,1,lcdteks);
    ec40:	ed b7       	in	r30, 0x3d	; 61
    ec42:	fe b7       	in	r31, 0x3e	; 62
    ec44:	38 96       	adiw	r30, 0x08	; 8
    ec46:	0f b6       	in	r0, 0x3f	; 63
    ec48:	f8 94       	cli
    ec4a:	fe bf       	out	0x3e, r31	; 62
    ec4c:	0f be       	out	0x3f, r0	; 63
    ec4e:	ed bf       	out	0x3d, r30	; 61
    ec50:	83 e0       	ldi	r24, 0x03	; 3
    ec52:	61 e0       	ldi	r22, 0x01	; 1
    ec54:	a8 01       	movw	r20, r16
    ec56:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
          stMenuPumpID=mpWaitSlaveReply;
    ec5a:	88 e0       	ldi	r24, 0x08	; 8
    ec5c:	57 c0       	rjmp	.+174    	; 0xed0c <FSettingPumpID+0x504>
	      break;
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
    ec5e:	81 e0       	ldi	r24, 0x01	; 1
    ec60:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
	      KeyChar=_key_btn(KeyPressed);
    ec64:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
		  if (KeyChar=='*'){
    ec68:	8a 32       	cpi	r24, 0x2A	; 42
    ec6a:	99 f4       	brne	.+38     	; 0xec92 <FSettingPumpID+0x48a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    ec6c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    ec6e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    ec70:	82 e0       	ldi	r24, 0x02	; 2
    ec72:	90 e0       	ldi	r25, 0x00	; 0
    ec74:	90 93 ec 01 	sts	0x01EC, r25
    ec78:	80 93 eb 01 	sts	0x01EB, r24
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
	      KeyChar=_key_btn(KeyPressed);
		  if (KeyChar=='*'){
		      system_beep(2);
		      lcd_printf(2,1,PSTR("Cancel     "));
    ec7c:	82 e0       	ldi	r24, 0x02	; 2
    ec7e:	61 e0       	ldi	r22, 0x01	; 1
    ec80:	40 e4       	ldi	r20, 0x40	; 64
    ec82:	5d e0       	ldi	r21, 0x0D	; 13
    ec84:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
			  TimDisplay=0;
    ec88:	10 92 bc 01 	sts	0x01BC, r1
		      stMenuPumpID=mpDelayExitPumpId;
    ec8c:	89 e0       	ldi	r24, 0x09	; 9
    ec8e:	80 93 fb 02 	sts	0x02FB, r24
			  }
          if (IsStandaloneAcknoledge==True){
    ec92:	80 91 ab 01 	lds	r24, 0x01AB
    ec96:	81 30       	cpi	r24, 0x01	; 1
    ec98:	09 f0       	breq	.+2      	; 0xec9c <FSettingPumpID+0x494>
    ec9a:	4d c0       	rjmp	.+154    	; 0xed36 <FSettingPumpID+0x52e>
		      Idx++;
    ec9c:	80 91 f9 02 	lds	r24, 0x02F9
    eca0:	8f 5f       	subi	r24, 0xFF	; 255
    eca2:	80 93 f9 02 	sts	0x02F9, r24
		      if (Idx<8){//Finish, Send MaxPumpCount
    eca6:	88 30       	cpi	r24, 0x08	; 8
    eca8:	10 f5       	brcc	.+68     	; 0xecee <FSettingPumpID+0x4e6>
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
    ecaa:	20 91 ef 02 	lds	r18, 0x02EF
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ecae:	e1 99       	sbic	0x1c, 1	; 28
    ecb0:	fe cf       	rjmp	.-4      	; 0xecae <FSettingPumpID+0x4a6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ecb2:	84 e7       	ldi	r24, 0x74	; 116
    ecb4:	91 e0       	ldi	r25, 0x01	; 1
    ecb6:	9f bb       	out	0x1f, r25	; 31
    ecb8:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    ecba:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    ecbc:	0f b6       	in	r0, 0x3f	; 63
    ecbe:	f8 94       	cli
    ecc0:	e2 9a       	sbi	0x1c, 2	; 28
    ecc2:	e1 9a       	sbi	0x1c, 1	; 28
    ecc4:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ecc6:	e1 99       	sbic	0x1c, 1	; 28
    ecc8:	fe cf       	rjmp	.-4      	; 0xecc6 <FSettingPumpID+0x4be>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ecca:	9f bb       	out	0x1f, r25	; 31
    eccc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ecce:	e0 9a       	sbi	0x1c, 0	; 28
    ecd0:	9d b3       	in	r25, 0x1d	; 29
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    ecd2:	90 93 75 01 	sts	0x0175, r25
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    ecd6:	85 e1       	ldi	r24, 0x15	; 21
    ecd8:	80 93 b6 07 	sts	0x07B6, r24
	 PoolMsg=plMsg;
    ecdc:	90 93 de 0d 	sts	0x0DDE, r25
     IsControlPooling=True;
    ece0:	81 e0       	ldi	r24, 0x01	; 1
    ece2:	80 93 ad 01 	sts	0x01AD, r24
		      Idx++;
		      if (Idx<8){//Finish, Send MaxPumpCount
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
                  SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PumpCountMax);
			      TimDisplay=0;		 
    ece6:	10 92 bc 01 	sts	0x01BC, r1
				  stMenuPumpID=mpDelaySaveConfig;
    ecea:	87 e0       	ldi	r24, 0x07	; 7
    ecec:	0f c0       	rjmp	.+30     	; 0xed0c <FSettingPumpID+0x504>
			  }else{lcd_printf(2,1,PSTR("Completed"));
    ecee:	82 e0       	ldi	r24, 0x02	; 2
    ecf0:	61 e0       	ldi	r22, 0x01	; 1
    ecf2:	46 e3       	ldi	r20, 0x36	; 54
    ecf4:	5d e0       	ldi	r21, 0x0D	; 13
    ecf6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
					TimDisplay=0;
    ecfa:	10 92 bc 01 	sts	0x01BC, r1
				    stMenuPumpID=mpDelayExitPumpId;
    ecfe:	89 e0       	ldi	r24, 0x09	; 9
    ed00:	05 c0       	rjmp	.+10     	; 0xed0c <FSettingPumpID+0x504>
				   }
			  }		  
	      break;
     case mpDelaySaveConfig:
	      if (TimDisplay>2)stMenuPumpID=mpSendConfigToSlave;
    ed02:	80 91 bc 01 	lds	r24, 0x01BC
    ed06:	83 30       	cpi	r24, 0x03	; 3
    ed08:	b0 f0       	brcs	.+44     	; 0xed36 <FSettingPumpID+0x52e>
    ed0a:	86 e0       	ldi	r24, 0x06	; 6
    ed0c:	80 93 fb 02 	sts	0x02FB, r24
    ed10:	12 c0       	rjmp	.+36     	; 0xed36 <FSettingPumpID+0x52e>
	      break;
     case mpDelayExitPumpId:
	      if (TimDisplay>8)stMenuPumpID=mpExitPumpId;
    ed12:	80 91 bc 01 	lds	r24, 0x01BC
    ed16:	89 30       	cpi	r24, 0x09	; 9
    ed18:	70 f0       	brcs	.+28     	; 0xed36 <FSettingPumpID+0x52e>
    ed1a:	8a e0       	ldi	r24, 0x0A	; 10
    ed1c:	f7 cf       	rjmp	.-18     	; 0xed0c <FSettingPumpID+0x504>
	      break;
     case mpExitPumpId:
	      if (IFType==IT_STANDALONE)
    ed1e:	80 91 25 01 	lds	r24, 0x0125
    ed22:	82 30       	cpi	r24, 0x02	; 2
    ed24:	21 f4       	brne	.+8      	; 0xed2e <FSettingPumpID+0x526>
		      SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    ed26:	80 e2       	ldi	r24, 0x20	; 32
    ed28:	60 e0       	ldi	r22, 0x00	; 0
    ed2a:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
	      Result=MENU_DONE;
          stMenuPumpID=mpInitPumpId;
    ed2e:	10 92 fb 02 	sts	0x02FB, r1
    ed32:	81 e0       	ldi	r24, 0x01	; 1
    ed34:	01 c0       	rjmp	.+2      	; 0xed38 <FSettingPumpID+0x530>
    ed36:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
    ed38:	64 96       	adiw	r28, 0x14	; 20
    ed3a:	0f b6       	in	r0, 0x3f	; 63
    ed3c:	f8 94       	cli
    ed3e:	de bf       	out	0x3e, r29	; 62
    ed40:	0f be       	out	0x3f, r0	; 63
    ed42:	cd bf       	out	0x3d, r28	; 61
    ed44:	cf 91       	pop	r28
    ed46:	df 91       	pop	r29
    ed48:	1f 91       	pop	r17
    ed4a:	0f 91       	pop	r16
    ed4c:	ff 90       	pop	r15
    ed4e:	ef 90       	pop	r14
    ed50:	df 90       	pop	r13
    ed52:	cf 90       	pop	r12
    ed54:	bf 90       	pop	r11
    ed56:	af 90       	pop	r10
    ed58:	9f 90       	pop	r9
    ed5a:	08 95       	ret

0000ed5c <_menu_pumpid>:

void _menu_pumpid(void){
	while(1){
	   if (FSettingPumpID()==MENU_DONE){
    ed5c:	0e 94 04 74 	call	0xe808	; 0xe808 <FSettingPumpID>
    ed60:	81 30       	cpi	r24, 0x01	; 1
    ed62:	e1 f7       	brne	.-8      	; 0xed5c <_menu_pumpid>
	       break;
	   }	   
	}
}
    ed64:	08 95       	ret

0000ed66 <_menu_pump>:
			return 0;
	}
	return 0;
}

void _menu_pump(void){
    ed66:	cf 93       	push	r28
    ed68:	df 93       	push	r29
    ed6a:	c4 ec       	ldi	r28, 0xC4	; 196
    ed6c:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;

	while(1){
		lcd_clear();_delay_ms(10);
    ed6e:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    ed72:	ce 01       	movw	r24, r28
    ed74:	01 97       	sbiw	r24, 0x01	; 1
    ed76:	f1 f7       	brne	.-4      	; 0xed74 <_menu_pump+0xe>
		lcd_printf(1, 1, PSTR("1)ID"));
    ed78:	81 e0       	ldi	r24, 0x01	; 1
    ed7a:	61 e0       	ldi	r22, 0x01	; 1
    ed7c:	4a e6       	ldi	r20, 0x6A	; 106
    ed7e:	5e e0       	ldi	r21, 0x0E	; 14
    ed80:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Product"));
    ed84:	82 e0       	ldi	r24, 0x02	; 2
    ed86:	61 e0       	ldi	r22, 0x01	; 1
    ed88:	40 e6       	ldi	r20, 0x60	; 96
    ed8a:	5e e0       	ldi	r21, 0x0E	; 14
    ed8c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    ed90:	84 e0       	ldi	r24, 0x04	; 4
    ed92:	61 e0       	ldi	r22, 0x01	; 1
    ed94:	49 e5       	ldi	r20, 0x59	; 89
    ed96:	5e e0       	ldi	r21, 0x0E	; 14
    ed98:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>

		while(1){
			__key = _key_scan(1);
    ed9c:	81 e0       	ldi	r24, 0x01	; 1
    ed9e:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
			if(__key == _KEY_CANCEL)
    eda2:	87 3e       	cpi	r24, 0xE7	; 231
    eda4:	51 f0       	breq	.+20     	; 0xedba <_menu_pump+0x54>
				return;
			if(__key == _KEY_1){
    eda6:	8e 3e       	cpi	r24, 0xEE	; 238
    eda8:	19 f4       	brne	.+6      	; 0xedb0 <_menu_pump+0x4a>
				_menu_pumpid();
    edaa:	0e 94 ae 76 	call	0xed5c	; 0xed5c <_menu_pumpid>
    edae:	df cf       	rjmp	.-66     	; 0xed6e <_menu_pump+0x8>
				break;
			}
			if(__key == _KEY_2){
    edb0:	8e 3d       	cpi	r24, 0xDE	; 222
    edb2:	a1 f7       	brne	.-24     	; 0xed9c <_menu_pump+0x36>
				_menu_pumpprod();
    edb4:	0e 94 81 46 	call	0x8d02	; 0x8d02 <_menu_pumpprod>
    edb8:	da cf       	rjmp	.-76     	; 0xed6e <_menu_pump+0x8>
				break;
			}
		}
	}
}
    edba:	df 91       	pop	r29
    edbc:	cf 91       	pop	r28
    edbe:	08 95       	ret

0000edc0 <FMenuPumpType>:





void FMenuPumpType(){
    edc0:	cf 92       	push	r12
    edc2:	df 92       	push	r13
    edc4:	ef 92       	push	r14
    edc6:	ff 92       	push	r15
    edc8:	0f 93       	push	r16
    edca:	1f 93       	push	r17
    edcc:	df 93       	push	r29
    edce:	cf 93       	push	r28
    edd0:	cd b7       	in	r28, 0x3d	; 61
    edd2:	de b7       	in	r29, 0x3e	; 62
    edd4:	a8 97       	sbiw	r28, 0x28	; 40
    edd6:	0f b6       	in	r0, 0x3f	; 63
    edd8:	f8 94       	cli
    edda:	de bf       	out	0x3e, r29	; 62
    eddc:	0f be       	out	0x3f, r0	; 63
    edde:	cd bf       	out	0x3d, r28	; 61
     stPumpType=ptInitMenu;
	 IsRunPumpType=True;
	 while(IsRunPumpType==True){
		  switch(stPumpType){
		  case ptInitMenu:
		       lcd_clear();
    ede0:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
			   lcd_printf(1,1,PSTR("-Dispenser Brand-"));
    ede4:	81 e0       	ldi	r24, 0x01	; 1
    ede6:	61 e0       	ldi	r22, 0x01	; 1
    ede8:	47 e4       	ldi	r20, 0x47	; 71
    edea:	5e e0       	ldi	r21, 0x0E	; 14
    edec:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    edf0:	e1 99       	sbic	0x1c, 1	; 28
    edf2:	fe cf       	rjmp	.-4      	; 0xedf0 <FMenuPumpType+0x30>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    edf4:	87 e6       	ldi	r24, 0x67	; 103
    edf6:	91 e0       	ldi	r25, 0x01	; 1
    edf8:	9f bb       	out	0x1f, r25	; 31
    edfa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    edfc:	e0 9a       	sbi	0x1c, 0	; 28
    edfe:	0d b3       	in	r16, 0x1d	; 29
			   IdxType=eeprom_read_byte(&DefDispenserBrand);
			   //Brand Selection
			   if (IdxType>=3) IdxType=0;
    ee00:	03 30       	cpi	r16, 0x03	; 3
    ee02:	08 f0       	brcs	.+2      	; 0xee06 <FMenuPumpType+0x46>
    ee04:	00 e0       	ldi	r16, 0x00	; 0
               strcpy_P(DispenserBrandName,(PGM_P)pgm_read_word(&(DefListDispenserName[IdxType])));
    ee06:	10 e0       	ldi	r17, 0x00	; 0
    ee08:	f8 01       	movw	r30, r16
    ee0a:	ee 0f       	add	r30, r30
    ee0c:	ff 1f       	adc	r31, r31
    ee0e:	e1 55       	subi	r30, 0x51	; 81
    ee10:	fc 4f       	sbci	r31, 0xFC	; 252
    ee12:	65 91       	lpm	r22, Z+
    ee14:	74 91       	lpm	r23, Z+
    ee16:	85 e1       	ldi	r24, 0x15	; 21
    ee18:	c8 2e       	mov	r12, r24
    ee1a:	d1 2c       	mov	r13, r1
    ee1c:	cc 0e       	add	r12, r28
    ee1e:	dd 1e       	adc	r13, r29
    ee20:	c6 01       	movw	r24, r12
    ee22:	0e 94 8c b4 	call	0x16918	; 0x16918 <strcpy_P>
			   sprintf_P(lcdteks,PSTR("%d.%s"),IdxType+1,DispenserBrandName);
    ee26:	8d b7       	in	r24, 0x3d	; 61
    ee28:	9e b7       	in	r25, 0x3e	; 62
    ee2a:	08 97       	sbiw	r24, 0x08	; 8
    ee2c:	0f b6       	in	r0, 0x3f	; 63
    ee2e:	f8 94       	cli
    ee30:	9e bf       	out	0x3e, r25	; 62
    ee32:	0f be       	out	0x3f, r0	; 63
    ee34:	8d bf       	out	0x3d, r24	; 61
    ee36:	ed b7       	in	r30, 0x3d	; 61
    ee38:	fe b7       	in	r31, 0x3e	; 62
    ee3a:	31 96       	adiw	r30, 0x01	; 1
    ee3c:	7e 01       	movw	r14, r28
    ee3e:	08 94       	sec
    ee40:	e1 1c       	adc	r14, r1
    ee42:	f1 1c       	adc	r15, r1
    ee44:	ad b7       	in	r26, 0x3d	; 61
    ee46:	be b7       	in	r27, 0x3e	; 62
    ee48:	12 96       	adiw	r26, 0x02	; 2
    ee4a:	fc 92       	st	X, r15
    ee4c:	ee 92       	st	-X, r14
    ee4e:	11 97       	sbiw	r26, 0x01	; 1
    ee50:	81 e4       	ldi	r24, 0x41	; 65
    ee52:	9e e0       	ldi	r25, 0x0E	; 14
    ee54:	93 83       	std	Z+3, r25	; 0x03
    ee56:	82 83       	std	Z+2, r24	; 0x02
    ee58:	0f 5f       	subi	r16, 0xFF	; 255
    ee5a:	1f 4f       	sbci	r17, 0xFF	; 255
    ee5c:	15 83       	std	Z+5, r17	; 0x05
    ee5e:	04 83       	std	Z+4, r16	; 0x04
    ee60:	d7 82       	std	Z+7, r13	; 0x07
    ee62:	c6 82       	std	Z+6, r12	; 0x06
    ee64:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			   lcd_print(2,1,lcdteks);
    ee68:	8d b7       	in	r24, 0x3d	; 61
    ee6a:	9e b7       	in	r25, 0x3e	; 62
    ee6c:	08 96       	adiw	r24, 0x08	; 8
    ee6e:	0f b6       	in	r0, 0x3f	; 63
    ee70:	f8 94       	cli
    ee72:	9e bf       	out	0x3e, r25	; 62
    ee74:	0f be       	out	0x3f, r0	; 63
    ee76:	8d bf       	out	0x3d, r24	; 61
    ee78:	82 e0       	ldi	r24, 0x02	; 2
    ee7a:	61 e0       	ldi	r22, 0x01	; 1
    ee7c:	a7 01       	movw	r20, r14
    ee7e:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Exit  [#]Change "));
    ee82:	84 e0       	ldi	r24, 0x04	; 4
    ee84:	61 e0       	ldi	r22, 0x01	; 1
    ee86:	4d e2       	ldi	r20, 0x2D	; 45
    ee88:	5e e0       	ldi	r21, 0x0E	; 14
    ee8a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
			   if (IFType==IT_STANDALONE)
    ee8e:	80 91 25 01 	lds	r24, 0x0125
    ee92:	82 30       	cpi	r24, 0x02	; 2
    ee94:	21 f4       	brne	.+8      	; 0xee9e <FMenuPumpType+0xde>
			       SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    ee96:	8f e1       	ldi	r24, 0x1F	; 31
    ee98:	60 e0       	ldi	r22, 0x00	; 0
    ee9a:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
			   stPumpType=ptSelectBrand;
	 		   break;
          case ptSelectBrand:
		       KeyPressed = _key_scan(1);
    ee9e:	81 e0       	ldi	r24, 0x01	; 1
    eea0:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
		       KeyChar    = _key_btn(KeyPressed);
    eea4:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>

			   if (KeyChar=='#'){
    eea8:	83 32       	cpi	r24, 0x23	; 35
    eeaa:	09 f0       	breq	.+2      	; 0xeeae <FMenuPumpType+0xee>
    eeac:	2d c0       	rjmp	.+90     	; 0xef08 <FMenuPumpType+0x148>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    eeae:	e1 99       	sbic	0x1c, 1	; 28
    eeb0:	fe cf       	rjmp	.-4      	; 0xeeae <FMenuPumpType+0xee>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eeb2:	07 e6       	ldi	r16, 0x67	; 103
    eeb4:	11 e0       	ldi	r17, 0x01	; 1
    eeb6:	1f bb       	out	0x1f, r17	; 31
    eeb8:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    eeba:	e0 9a       	sbi	0x1c, 0	; 28
    eebc:	8d b3       	in	r24, 0x1d	; 29
			       DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
				   if (DispenserBrand<ST_WAYNE_DART)
    eebe:	82 30       	cpi	r24, 0x02	; 2
    eec0:	20 f4       	brcc	.+8      	; 0xeeca <FMenuPumpType+0x10a>
				        DispenserBrand++;
    eec2:	8f 5f       	subi	r24, 0xFF	; 255
    eec4:	80 93 77 01 	sts	0x0177, r24
    eec8:	02 c0       	rjmp	.+4      	; 0xeece <FMenuPumpType+0x10e>
				   else DispenserBrand=ST_NONE;
    eeca:	10 92 77 01 	sts	0x0177, r1
                   //Apply DecimalSetting  
				   SetDispenser(DispenserBrand);
    eece:	80 91 77 01 	lds	r24, 0x0177
    eed2:	0e 94 b6 19 	call	0x336c	; 0x336c <SetDispenser>

			       eeprom_write_byte(&DefDispenserBrand,DispenserBrand);
    eed6:	80 91 77 01 	lds	r24, 0x0177
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    eeda:	e1 99       	sbic	0x1c, 1	; 28
    eedc:	fe cf       	rjmp	.-4      	; 0xeeda <FMenuPumpType+0x11a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eede:	1f bb       	out	0x1f, r17	; 31
    eee0:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    eee2:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    eee4:	0f b6       	in	r0, 0x3f	; 63
    eee6:	f8 94       	cli
    eee8:	e2 9a       	sbi	0x1c, 2	; 28
    eeea:	e1 9a       	sbi	0x1c, 1	; 28
    eeec:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    eeee:	e1 99       	sbic	0x1c, 1	; 28
    eef0:	fe cf       	rjmp	.-4      	; 0xeeee <FMenuPumpType+0x12e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eef2:	1f bb       	out	0x1f, r17	; 31
    eef4:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    eef6:	e0 9a       	sbi	0x1c, 0	; 28
    eef8:	6d b3       	in	r22, 0x1d	; 29
				   //SendPoolingCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
				   SendSlaveCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
    eefa:	8c e1       	ldi	r24, 0x1C	; 28
    eefc:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
				   IsSetPumpType=True;//False;
    ef00:	81 e0       	ldi	r24, 0x01	; 1
    ef02:	80 93 38 01 	sts	0x0138, r24
    ef06:	0c c0       	rjmp	.+24     	; 0xef20 <FMenuPumpType+0x160>
			       stPumpType=ptUpdated;			   
			   }else
			   if (KeyChar=='*'){
    ef08:	8a 32       	cpi	r24, 0x2A	; 42
    ef0a:	09 f0       	breq	.+2      	; 0xef0e <FMenuPumpType+0x14e>
    ef0c:	c8 cf       	rjmp	.-112    	; 0xee9e <FMenuPumpType+0xde>
			       IsRunPumpType=False;
				   if (IFType==IT_STANDALONE)SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    ef0e:	80 91 25 01 	lds	r24, 0x0125
    ef12:	82 30       	cpi	r24, 0x02	; 2
    ef14:	51 f4       	brne	.+20     	; 0xef2a <FMenuPumpType+0x16a>
    ef16:	80 e2       	ldi	r24, 0x20	; 32
    ef18:	60 e0       	ldi	r22, 0x00	; 0
    ef1a:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
    ef1e:	05 c0       	rjmp	.+10     	; 0xef2a <FMenuPumpType+0x16a>
			   }
		       break;
          case ptUpdated:
		       if (IsSetPumpType==True){
    ef20:	80 91 38 01 	lds	r24, 0x0138
    ef24:	81 30       	cpi	r24, 0x01	; 1
    ef26:	e1 f7       	brne	.-8      	; 0xef20 <FMenuPumpType+0x160>
    ef28:	5b cf       	rjmp	.-330    	; 0xede0 <FMenuPumpType+0x20>
			       stPumpType=ptInitMenu;
			   }
		       break;		         
	      }
	 }     
}
    ef2a:	a8 96       	adiw	r28, 0x28	; 40
    ef2c:	0f b6       	in	r0, 0x3f	; 63
    ef2e:	f8 94       	cli
    ef30:	de bf       	out	0x3e, r29	; 62
    ef32:	0f be       	out	0x3f, r0	; 63
    ef34:	cd bf       	out	0x3d, r28	; 61
    ef36:	cf 91       	pop	r28
    ef38:	df 91       	pop	r29
    ef3a:	1f 91       	pop	r17
    ef3c:	0f 91       	pop	r16
    ef3e:	ff 90       	pop	r15
    ef40:	ef 90       	pop	r14
    ef42:	df 90       	pop	r13
    ef44:	cf 90       	pop	r12
    ef46:	08 95       	ret

0000ef48 <FSettingPump>:
   return Result;
}

char FSettingPump(){
	 char __key,Result;
		lcd_clear();_delay_ms(10);
    ef48:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
    ef4c:	84 ec       	ldi	r24, 0xC4	; 196
    ef4e:	99 e0       	ldi	r25, 0x09	; 9
    ef50:	01 97       	sbiw	r24, 0x01	; 1
    ef52:	f1 f7       	brne	.-4      	; 0xef50 <FSettingPump+0x8>
		lcd_printf(1,1, PSTR("1)ID     "));
    ef54:	81 e0       	ldi	r24, 0x01	; 1
    ef56:	61 e0       	ldi	r22, 0x01	; 1
    ef58:	4a e1       	ldi	r20, 0x1A	; 26
    ef5a:	50 e1       	ldi	r21, 0x10	; 16
    ef5c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		lcd_printf(2,1, PSTR("2)Product"));
    ef60:	82 e0       	ldi	r24, 0x02	; 2
    ef62:	61 e0       	ldi	r22, 0x01	; 1
    ef64:	40 e1       	ldi	r20, 0x10	; 16
    ef66:	50 e1       	ldi	r21, 0x10	; 16
    ef68:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		if (IFType==IT_STANDALONE){
    ef6c:	80 91 25 01 	lds	r24, 0x0125
    ef70:	82 30       	cpi	r24, 0x02	; 2
    ef72:	61 f4       	brne	.+24     	; 0xef8c <FSettingPump+0x44>
		    lcd_printf(3,1, PSTR("3)Label  "));
    ef74:	83 e0       	ldi	r24, 0x03	; 3
    ef76:	61 e0       	ldi	r22, 0x01	; 1
    ef78:	46 e0       	ldi	r20, 0x06	; 6
    ef7a:	50 e1       	ldi	r21, 0x10	; 16
    ef7c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		    lcd_printf(4,1, PSTR("4)Brand  *)Exit"));
    ef80:	84 e0       	ldi	r24, 0x04	; 4
    ef82:	61 e0       	ldi	r22, 0x01	; 1
    ef84:	46 ef       	ldi	r20, 0xF6	; 246
    ef86:	5f e0       	ldi	r21, 0x0F	; 15
    ef88:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		}

		while(1){
			__key = _key_scan(1);
    ef8c:	81 e0       	ldi	r24, 0x01	; 1
    ef8e:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
			if(__key == _KEY_CANCEL)
    ef92:	87 3e       	cpi	r24, 0xE7	; 231
    ef94:	d9 f0       	breq	.+54     	; 0xefcc <FSettingPump+0x84>
				break;
			if(__key == _KEY_1){
    ef96:	8e 3e       	cpi	r24, 0xEE	; 238
    ef98:	19 f4       	brne	.+6      	; 0xefa0 <FSettingPump+0x58>
				_menu_pumpid();
    ef9a:	0e 94 ae 76 	call	0xed5c	; 0xed5c <_menu_pumpid>
    ef9e:	16 c0       	rjmp	.+44     	; 0xefcc <FSettingPump+0x84>
				break;
			}
			if(__key == _KEY_2){
    efa0:	8e 3d       	cpi	r24, 0xDE	; 222
    efa2:	19 f4       	brne	.+6      	; 0xefaa <FSettingPump+0x62>
				_menu_pumpprod();
    efa4:	0e 94 81 46 	call	0x8d02	; 0x8d02 <_menu_pumpprod>
    efa8:	11 c0       	rjmp	.+34     	; 0xefcc <FSettingPump+0x84>
				break;
			}

			if((__key == _KEY_3)&&(IFType==IT_STANDALONE)){
    efaa:	8e 3b       	cpi	r24, 0xBE	; 190
    efac:	39 f4       	brne	.+14     	; 0xefbc <FSettingPump+0x74>
    efae:	80 91 25 01 	lds	r24, 0x0125
    efb2:	82 30       	cpi	r24, 0x02	; 2
    efb4:	59 f7       	brne	.-42     	; 0xef8c <FSettingPump+0x44>
			    FMenuPumpLabel();
    efb6:	0e 94 aa 46 	call	0x8d54	; 0x8d54 <FMenuPumpLabel>
    efba:	08 c0       	rjmp	.+16     	; 0xefcc <FSettingPump+0x84>
				break;
			}
			if((__key == _KEY_4)&&(IFType==IT_STANDALONE)){
    efbc:	8d 3e       	cpi	r24, 0xED	; 237
    efbe:	31 f7       	brne	.-52     	; 0xef8c <FSettingPump+0x44>
    efc0:	80 91 25 01 	lds	r24, 0x0125
    efc4:	82 30       	cpi	r24, 0x02	; 2
    efc6:	11 f7       	brne	.-60     	; 0xef8c <FSettingPump+0x44>
			    FMenuPumpType();
    efc8:	0e 94 e0 76 	call	0xedc0	; 0xedc0 <FMenuPumpType>

		}

	Result=MENU_DONE;
	return Result;
}
    efcc:	81 e0       	ldi	r24, 0x01	; 1
    efce:	08 95       	ret

0000efd0 <InitStandalone>:
stInitStandalone=isSendType;

while (RunInitStandalone==True){
     switch(stInitStandalone){
	 case isSendType:
	      IsStandaloneAcknoledge=False;
    efd0:	10 92 ab 01 	sts	0x01AB, r1
          SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    efd4:	82 e0       	ldi	r24, 0x02	; 2
    efd6:	60 91 77 01 	lds	r22, 0x0177
    efda:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
		  TimSend=0;
    efde:	10 92 be 01 	sts	0x01BE, r1
    efe2:	10 92 bd 01 	sts	0x01BD, r1
		  stInitStandalone=isWaitAcknoledge1;
	      break;
     case isWaitAcknoledge1:
          if (IsStandaloneAcknoledge==True){
    efe6:	80 91 ab 01 	lds	r24, 0x01AB
    efea:	81 30       	cpi	r24, 0x01	; 1
    efec:	11 f4       	brne	.+4      	; 0xeff2 <InitStandalone+0x22>
		      IsStandaloneAcknoledge=False;
    efee:	10 92 ab 01 	sts	0x01AB, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    eff2:	e1 99       	sbic	0x1c, 1	; 28
    eff4:	fe cf       	rjmp	.-4      	; 0xeff2 <InitStandalone+0x22>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eff6:	84 e7       	ldi	r24, 0x74	; 116
    eff8:	91 e0       	ldi	r25, 0x01	; 1
    effa:	9f bb       	out	0x1f, r25	; 31
    effc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    effe:	e0 9a       	sbi	0x1c, 0	; 28
    f000:	6d b3       	in	r22, 0x1d	; 29
		      stInitStandalone=isSendPumpConfig;
		  }
     case isSendPumpConfig:
          SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,eeprom_read_byte(&DefPoolingPumpMax));
    f002:	85 e1       	ldi	r24, 0x15	; 21
    f004:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
		  TimSend=0;
    f008:	10 92 be 01 	sts	0x01BE, r1
    f00c:	10 92 bd 01 	sts	0x01BD, r1
		  stInitStandalone=isWaitAcknoledge2;
	      break;
     case isWaitAcknoledge2:
          if (IsStandaloneAcknoledge==True){
    f010:	80 91 ab 01 	lds	r24, 0x01AB
    f014:	81 30       	cpi	r24, 0x01	; 1
    f016:	e1 f7       	brne	.-8      	; 0xf010 <InitStandalone+0x40>
		      IsStandaloneAcknoledge=False;
    f018:	10 92 ab 01 	sts	0x01AB, r1
     case isFinishInitStandalone:
	      RunInitStandalone=False;
	      break;
	 }
  }
}
    f01c:	08 95       	ret

0000f01e <InitializeConnection>:
void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
	 ActivePump=eeprom_read_byte(&DefActivePump);
}

void InitializeConnection(){
    f01e:	af 92       	push	r10
    f020:	bf 92       	push	r11
    f022:	cf 92       	push	r12
    f024:	df 92       	push	r13
    f026:	ef 92       	push	r14
    f028:	ff 92       	push	r15
    f02a:	0f 93       	push	r16
    f02c:	1f 93       	push	r17
    f02e:	df 93       	push	r29
    f030:	cf 93       	push	r28
    f032:	cd b7       	in	r28, 0x3d	; 61
    f034:	de b7       	in	r29, 0x3e	; 62
    f036:	64 97       	sbiw	r28, 0x14	; 20
    f038:	0f b6       	in	r0, 0x3f	; 63
    f03a:	f8 94       	cli
    f03c:	de bf       	out	0x3e, r29	; 62
    f03e:	0f be       	out	0x3f, r0	; 63
    f040:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f042:	e1 99       	sbic	0x1c, 1	; 28
    f044:	fe cf       	rjmp	.-4      	; 0xf042 <InitializeConnection+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f046:	46 e6       	ldi	r20, 0x66	; 102
    f048:	a4 2e       	mov	r10, r20
    f04a:	41 e0       	ldi	r20, 0x01	; 1
    f04c:	b4 2e       	mov	r11, r20
    f04e:	bf ba       	out	0x1f, r11	; 31
    f050:	ae ba       	out	0x1e, r10	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f052:	e0 9a       	sbi	0x1c, 0	; 28
    f054:	9d b3       	in	r25, 0x1d	; 29
	unsigned int tConnect=0;
	char ForceType=IT_NONE,iCon=0,iTry=0;
	char lcdteks[20];
	IFType=eeprom_read_byte(&DefInitIFT);
    f056:	90 93 25 01 	sts	0x0125, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f05a:	e1 99       	sbic	0x1c, 1	; 28
    f05c:	fe cf       	rjmp	.-4      	; 0xf05a <InitializeConnection+0x3c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f05e:	37 e6       	ldi	r19, 0x67	; 103
    f060:	c3 2e       	mov	r12, r19
    f062:	31 e0       	ldi	r19, 0x01	; 1
    f064:	d3 2e       	mov	r13, r19
    f066:	df ba       	out	0x1f, r13	; 31
    f068:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f06a:	e0 9a       	sbi	0x1c, 0	; 28
    f06c:	8d b3       	in	r24, 0x1d	; 29
	DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    f06e:	80 93 77 01 	sts	0x0177, r24

    //Send Msg10
	if  (IFType==IT_SLAVE){
    f072:	91 30       	cpi	r25, 0x01	; 1
    f074:	09 f0       	breq	.+2      	; 0xf078 <InitializeConnection+0x5a>
    f076:	4d c0       	rjmp	.+154    	; 0xf112 <InitializeConnection+0xf4>
	     SendSlaveCommand(SC_SLAVE,ST_NONE);
    f078:	81 e0       	ldi	r24, 0x01	; 1
    f07a:	60 e0       	ldi	r22, 0x00	; 0
    f07c:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
		 char_count=0;
    f080:	10 92 b2 01 	sts	0x01B2, r1
    f084:	10 92 b1 01 	sts	0x01B1, r1
         sendMessage10();
    f088:	0e 94 c5 51 	call	0xa38a	; 0xa38a <sendMessage10>
         lcd_printf(4,1,PSTR("Connect         "));
    f08c:	84 e0       	ldi	r24, 0x04	; 4
    f08e:	61 e0       	ldi	r22, 0x01	; 1
    f090:	49 ef       	ldi	r20, 0xF9	; 249
    f092:	5b e1       	ldi	r21, 0x1B	; 27
    f094:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		 lcd_printf(4,1,PSTR("Connect"));
    f098:	84 e0       	ldi	r24, 0x04	; 4
    f09a:	61 e0       	ldi	r22, 0x01	; 1
    f09c:	41 ef       	ldi	r20, 0xF1	; 241
    f09e:	5b e1       	ldi	r21, 0x1B	; 27
    f0a0:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
    f0a4:	10 92 cd 01 	sts	0x01CD, r1
    f0a8:	ee 24       	eor	r14, r14
    f0aa:	ff 24       	eor	r15, r15
    f0ac:	10 e0       	ldi	r17, 0x00	; 0
    f0ae:	00 e0       	ldi	r16, 0x00	; 0
    f0b0:	2c c0       	rjmp	.+88     	; 0xf10a <InitializeConnection+0xec>
		  //SlaveIdentification
		 while (IsMessage11==False){
		        lcd_put(4,(8+iCon),'.');
    f0b2:	61 2f       	mov	r22, r17
    f0b4:	68 5f       	subi	r22, 0xF8	; 248
    f0b6:	84 e0       	ldi	r24, 0x04	; 4
    f0b8:	4e e2       	ldi	r20, 0x2E	; 46
    f0ba:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
                tConnect++;
    f0be:	08 94       	sec
    f0c0:	e1 1c       	adc	r14, r1
    f0c2:	f1 1c       	adc	r15, r1
			    if ((tConnect%400)==0)iCon++;
    f0c4:	c7 01       	movw	r24, r14
    f0c6:	60 e9       	ldi	r22, 0x90	; 144
    f0c8:	71 e0       	ldi	r23, 0x01	; 1
    f0ca:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
    f0ce:	89 2b       	or	r24, r25
    f0d0:	09 f4       	brne	.+2      	; 0xf0d4 <InitializeConnection+0xb6>
    f0d2:	1f 5f       	subi	r17, 0xFF	; 255
			    if (iCon>5){
    f0d4:	16 30       	cpi	r17, 0x06	; 6
    f0d6:	70 f0       	brcs	.+28     	; 0xf0f4 <InitializeConnection+0xd6>
			        lcd_printf(4,1,PSTR("Connect         "));
    f0d8:	84 e0       	ldi	r24, 0x04	; 4
    f0da:	61 e0       	ldi	r22, 0x01	; 1
    f0dc:	40 ee       	ldi	r20, 0xE0	; 224
    f0de:	5b e1       	ldi	r21, 0x1B	; 27
    f0e0:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				    sendMessage10();
    f0e4:	0e 94 c5 51 	call	0xa38a	; 0xa38a <sendMessage10>
				    SendSlaveCommand(SC_SLAVE,ST_NONE);
    f0e8:	81 e0       	ldi	r24, 0x01	; 1
    f0ea:	60 e0       	ldi	r22, 0x00	; 0
    f0ec:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
			        iCon=0;
				    iTry++;}
    f0f0:	0f 5f       	subi	r16, 0xFF	; 255
    f0f2:	10 e0       	ldi	r17, 0x00	; 0
			    if (iTry>3){
    f0f4:	04 30       	cpi	r16, 0x04	; 4
    f0f6:	48 f0       	brcs	.+18     	; 0xf10a <InitializeConnection+0xec>
			        IsErrorTCPIP=True;
    f0f8:	81 e0       	ldi	r24, 0x01	; 1
    f0fa:	80 93 ca 01 	sts	0x01CA, r24
				    IsAdvanzStartupInfo=False;		
    f0fe:	10 92 d7 01 	sts	0x01D7, r1
					IFType=IT_STANDALONE;
    f102:	82 e0       	ldi	r24, 0x02	; 2
    f104:	80 93 25 01 	sts	0x0125, r24
    f108:	04 c0       	rjmp	.+8      	; 0xf112 <InitializeConnection+0xf4>
         lcd_printf(4,1,PSTR("Connect         "));
		 lcd_printf(4,1,PSTR("Connect"));
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
		  //SlaveIdentification
		 while (IsMessage11==False){
    f10a:	80 91 cd 01 	lds	r24, 0x01CD
    f10e:	88 23       	and	r24, r24
    f110:	81 f2       	breq	.-96     	; 0xf0b2 <InitializeConnection+0x94>
				    break;
			    }
            }//EndWhile
		}

	if (IFType==IT_STANDALONE){
    f112:	80 91 25 01 	lds	r24, 0x0125
    f116:	82 30       	cpi	r24, 0x02	; 2
    f118:	09 f0       	breq	.+2      	; 0xf11c <InitializeConnection+0xfe>
    f11a:	72 c0       	rjmp	.+228    	; 0xf200 <InitializeConnection+0x1e2>
        IsStandAloneDetected=False;		
    f11c:	10 92 c8 01 	sts	0x01C8, r1
		SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f120:	60 91 77 01 	lds	r22, 0x0177
    f124:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
		tConnect=0,iCon=0,iTry=0;
	    lcd_clear();
    f128:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
	    lcd_printf(1,1,PSTR("Scan Pump"));
    f12c:	81 e0       	ldi	r24, 0x01	; 1
    f12e:	61 e0       	ldi	r22, 0x01	; 1
    f130:	46 ed       	ldi	r20, 0xD6	; 214
    f132:	5b e1       	ldi	r21, 0x1B	; 27
    f134:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f138:	e1 99       	sbic	0x1c, 1	; 28
    f13a:	fe cf       	rjmp	.-4      	; 0xf138 <InitializeConnection+0x11a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f13c:	df ba       	out	0x1f, r13	; 31
    f13e:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f140:	e0 9a       	sbi	0x1c, 0	; 28
    f142:	8d b3       	in	r24, 0x1d	; 29
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
    f144:	e8 2f       	mov	r30, r24
    f146:	f0 e0       	ldi	r31, 0x00	; 0
    f148:	ee 0f       	add	r30, r30
    f14a:	ff 1f       	adc	r31, r31
    f14c:	e1 55       	subi	r30, 0x51	; 81
    f14e:	fc 4f       	sbci	r31, 0xFC	; 252
    f150:	65 91       	lpm	r22, Z+
    f152:	74 91       	lpm	r23, Z+
    f154:	8e 01       	movw	r16, r28
    f156:	0f 5f       	subi	r16, 0xFF	; 255
    f158:	1f 4f       	sbci	r17, 0xFF	; 255
    f15a:	c8 01       	movw	r24, r16
    f15c:	0e 94 8c b4 	call	0x16918	; 0x16918 <strcpy_P>
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
    f160:	00 d0       	rcall	.+0      	; 0xf162 <InitializeConnection+0x144>
    f162:	00 d0       	rcall	.+0      	; 0xf164 <InitializeConnection+0x146>
    f164:	00 d0       	rcall	.+0      	; 0xf166 <InitializeConnection+0x148>
    f166:	ed b7       	in	r30, 0x3d	; 61
    f168:	fe b7       	in	r31, 0x3e	; 62
    f16a:	31 96       	adiw	r30, 0x01	; 1
    f16c:	ad b7       	in	r26, 0x3d	; 61
    f16e:	be b7       	in	r27, 0x3e	; 62
    f170:	12 96       	adiw	r26, 0x02	; 2
    f172:	1c 93       	st	X, r17
    f174:	0e 93       	st	-X, r16
    f176:	11 97       	sbiw	r26, 0x01	; 1
    f178:	83 ed       	ldi	r24, 0xD3	; 211
    f17a:	9b e1       	ldi	r25, 0x1B	; 27
    f17c:	93 83       	std	Z+3, r25	; 0x03
    f17e:	82 83       	std	Z+2, r24	; 0x02
    f180:	15 83       	std	Z+5, r17	; 0x05
    f182:	04 83       	std	Z+4, r16	; 0x04
    f184:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	    lcd_print(2,1,lcdteks);
    f188:	8d b7       	in	r24, 0x3d	; 61
    f18a:	9e b7       	in	r25, 0x3e	; 62
    f18c:	06 96       	adiw	r24, 0x06	; 6
    f18e:	0f b6       	in	r0, 0x3f	; 63
    f190:	f8 94       	cli
    f192:	9e bf       	out	0x3e, r25	; 62
    f194:	0f be       	out	0x3f, r0	; 63
    f196:	8d bf       	out	0x3d, r24	; 61
    f198:	82 e0       	ldi	r24, 0x02	; 2
    f19a:	61 e0       	ldi	r22, 0x01	; 1
    f19c:	a8 01       	movw	r20, r16
    f19e:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
    f1a2:	00 e0       	ldi	r16, 0x00	; 0
    f1a4:	10 e0       	ldi	r17, 0x00	; 0
    f1a6:	ff 24       	eor	r15, r15
    f1a8:	dd 24       	eor	r13, r13
    f1aa:	26 c0       	rjmp	.+76     	; 0xf1f8 <InitializeConnection+0x1da>

	    while (IsStandAloneDetected==False){
		       lcd_put(4,(1+iCon),'.');
    f1ac:	ef 2c       	mov	r14, r15
    f1ae:	e3 94       	inc	r14
    f1b0:	84 e0       	ldi	r24, 0x04	; 4
    f1b2:	6e 2d       	mov	r22, r14
    f1b4:	4e e2       	ldi	r20, 0x2E	; 46
    f1b6:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
		       tConnect++;
    f1ba:	0f 5f       	subi	r16, 0xFF	; 255
    f1bc:	1f 4f       	sbci	r17, 0xFF	; 255
		       if ((tConnect%100)==0)iCon++;
    f1be:	c8 01       	movw	r24, r16
    f1c0:	64 e6       	ldi	r22, 0x64	; 100
    f1c2:	70 e0       	ldi	r23, 0x00	; 0
    f1c4:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
    f1c8:	89 2b       	or	r24, r25
    f1ca:	09 f4       	brne	.+2      	; 0xf1ce <InitializeConnection+0x1b0>
    f1cc:	fe 2c       	mov	r15, r14
		       if (iCon>16){
    f1ce:	90 e1       	ldi	r25, 0x10	; 16
    f1d0:	9f 15       	cp	r25, r15
    f1d2:	78 f4       	brcc	.+30     	; 0xf1f2 <InitializeConnection+0x1d4>
			       lcd_printf(4,1,PSTR("                   "));
    f1d4:	84 e0       	ldi	r24, 0x04	; 4
    f1d6:	61 e0       	ldi	r22, 0x01	; 1
    f1d8:	4f eb       	ldi	r20, 0xBF	; 191
    f1da:	5b e1       	ldi	r21, 0x1B	; 27
    f1dc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				   //IsStandaloneAcknoledge=False;
		           SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f1e0:	82 e0       	ldi	r24, 0x02	; 2
    f1e2:	60 91 77 01 	lds	r22, 0x0177
    f1e6:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
                   //InitStandalone();

			       DisplayPumpStatus();
    f1ea:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <DisplayPumpStatus>
			       iCon=0;
			       iTry++;}
    f1ee:	d3 94       	inc	r13
    f1f0:	ff 24       	eor	r15, r15
		           if (iTry>3) break; 
    f1f2:	a3 e0       	ldi	r26, 0x03	; 3
    f1f4:	ad 15       	cp	r26, r13
    f1f6:	20 f0       	brcs	.+8      	; 0xf200 <InitializeConnection+0x1e2>
	    lcd_printf(1,1,PSTR("Scan Pump"));
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
	    lcd_print(2,1,lcdteks);

	    while (IsStandAloneDetected==False){
    f1f8:	80 91 c8 01 	lds	r24, 0x01C8
    f1fc:	88 23       	and	r24, r24
    f1fe:	b1 f2       	breq	.-84     	; 0xf1ac <InitializeConnection+0x18e>
			       iCon=0;
			       iTry++;}
		           if (iTry>3) break; 
	    }
	}//EndIf
	if(IsMessage11==True){
    f200:	80 91 cd 01 	lds	r24, 0x01CD
    f204:	81 30       	cpi	r24, 0x01	; 1
    f206:	c9 f4       	brne	.+50     	; 0xf23a <InitializeConnection+0x21c>
	   lcd_printf(4,1,PSTR("Connected"));
    f208:	84 e0       	ldi	r24, 0x04	; 4
    f20a:	61 e0       	ldi	r22, 0x01	; 1
    f20c:	45 eb       	ldi	r20, 0xB5	; 181
    f20e:	5b e1       	ldi	r21, 0x1B	; 27
    f210:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f214:	e1 99       	sbic	0x1c, 1	; 28
    f216:	fe cf       	rjmp	.-4      	; 0xf214 <InitializeConnection+0x1f6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f218:	bf ba       	out	0x1f, r11	; 31
    f21a:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f21c:	11 e0       	ldi	r17, 0x01	; 1
    f21e:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    f220:	0f b6       	in	r0, 0x3f	; 63
    f222:	f8 94       	cli
    f224:	e2 9a       	sbi	0x1c, 2	; 28
    f226:	e1 9a       	sbi	0x1c, 1	; 28
    f228:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_SLAVE);
	   IFType=IT_SLAVE;
    f22a:	10 93 25 01 	sts	0x0125, r17
	   IsErrorTCPIP=False;
    f22e:	10 92 ca 01 	sts	0x01CA, r1
	   procMessage11();
    f232:	0e 94 42 5c 	call	0xb884	; 0xb884 <procMessage11>
	   IsAdvanzStartupInfo=True;
    f236:	10 93 d7 01 	sts	0x01D7, r17
	}
	if(IsStandAloneDetected==True){
    f23a:	80 91 c8 01 	lds	r24, 0x01C8
    f23e:	81 30       	cpi	r24, 0x01	; 1
    f240:	99 f4       	brne	.+38     	; 0xf268 <InitializeConnection+0x24a>
	   lcd_printf(4,1,PSTR("PumpFound"));
    f242:	84 e0       	ldi	r24, 0x04	; 4
    f244:	61 e0       	ldi	r22, 0x01	; 1
    f246:	4b ea       	ldi	r20, 0xAB	; 171
    f248:	5b e1       	ldi	r21, 0x1B	; 27
    f24a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f24e:	e1 99       	sbic	0x1c, 1	; 28
    f250:	fe cf       	rjmp	.-4      	; 0xf24e <InitializeConnection+0x230>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f252:	bf ba       	out	0x1f, r11	; 31
    f254:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f256:	82 e0       	ldi	r24, 0x02	; 2
    f258:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    f25a:	0f b6       	in	r0, 0x3f	; 63
    f25c:	f8 94       	cli
    f25e:	e2 9a       	sbi	0x1c, 2	; 28
    f260:	e1 9a       	sbi	0x1c, 1	; 28
    f262:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_STANDALONE);
	   IFType=IT_STANDALONE;
    f264:	80 93 25 01 	sts	0x0125, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f268:	e1 99       	sbic	0x1c, 1	; 28
    f26a:	fe cf       	rjmp	.-4      	; 0xf268 <InitializeConnection+0x24a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f26c:	85 e6       	ldi	r24, 0x65	; 101
    f26e:	91 e0       	ldi	r25, 0x01	; 1
    f270:	9f bb       	out	0x1f, r25	; 31
    f272:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f274:	e0 9a       	sbi	0x1c, 0	; 28
    f276:	8d b3       	in	r24, 0x1d	; 29
	}
	//PrintStatus
	if (eeprom_read_byte(&DefPrintInitialize)==True)GeneratePrintInit();
    f278:	81 30       	cpi	r24, 0x01	; 1
    f27a:	11 f4       	brne	.+4      	; 0xf280 <InitializeConnection+0x262>
    f27c:	0e 94 e5 2e 	call	0x5dca	; 0x5dca <GeneratePrintInit>
	if ((IsStandAloneDetected==False)&&(IsMessage11==False)){		
    f280:	80 91 c8 01 	lds	r24, 0x01C8
    f284:	88 23       	and	r24, r24
    f286:	09 f0       	breq	.+2      	; 0xf28a <InitializeConnection+0x26c>
    f288:	38 c0       	rjmp	.+112    	; 0xf2fa <InitializeConnection+0x2dc>
    f28a:	80 91 cd 01 	lds	r24, 0x01CD
    f28e:	88 23       	and	r24, r24
    f290:	09 f0       	breq	.+2      	; 0xf294 <InitializeConnection+0x276>
    f292:	33 c0       	rjmp	.+102    	; 0xf2fa <InitializeConnection+0x2dc>
		 lcd_printf(2,1,PSTR("TCP/IP Error"));
    f294:	82 e0       	ldi	r24, 0x02	; 2
    f296:	61 e0       	ldi	r22, 0x01	; 1
    f298:	4e e9       	ldi	r20, 0x9E	; 158
    f29a:	5b e1       	ldi	r21, 0x1B	; 27
    f29c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		 lcd_printf(3,1,PSTR("No Pump Found"));
    f2a0:	83 e0       	ldi	r24, 0x03	; 3
    f2a2:	61 e0       	ldi	r22, 0x01	; 1
    f2a4:	40 e9       	ldi	r20, 0x90	; 144
    f2a6:	5b e1       	ldi	r21, 0x1B	; 27
    f2a8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
    f2ac:	80 e2       	ldi	r24, 0x20	; 32
    f2ae:	9e e4       	ldi	r25, 0x4E	; 78
    f2b0:	29 e1       	ldi	r18, 0x19	; 25
    f2b2:	30 e0       	ldi	r19, 0x00	; 0
    f2b4:	f9 01       	movw	r30, r18
    f2b6:	31 97       	sbiw	r30, 0x01	; 1
    f2b8:	f1 f7       	brne	.-4      	; 0xf2b6 <InitializeConnection+0x298>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    f2ba:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    f2bc:	d9 f7       	brne	.-10     	; 0xf2b4 <InitializeConnection+0x296>
		 _delay_ms(2000);
		 ForceType=systemForceType();
    f2be:	0e 94 4f 43 	call	0x869e	; 0x869e <systemForceType>
		 if (ForceType=='1'){
    f2c2:	81 33       	cpi	r24, 0x31	; 49
    f2c4:	29 f4       	brne	.+10     	; 0xf2d0 <InitializeConnection+0x2b2>
		     IFType=IT_SLAVE;
    f2c6:	81 e0       	ldi	r24, 0x01	; 1
    f2c8:	80 93 25 01 	sts	0x0125, r24
			 SendSlaveCommand(SC_SLAVE,ST_NONE);
    f2cc:	60 e0       	ldi	r22, 0x00	; 0
    f2ce:	07 c0       	rjmp	.+14     	; 0xf2de <InitializeConnection+0x2c0>
         }
		 else
		 if (ForceType=='2'){
    f2d0:	82 33       	cpi	r24, 0x32	; 50
    f2d2:	39 f4       	brne	.+14     	; 0xf2e2 <InitializeConnection+0x2c4>
		     IFType=IT_STANDALONE;
    f2d4:	82 e0       	ldi	r24, 0x02	; 2
    f2d6:	80 93 25 01 	sts	0x0125, r24
			 SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f2da:	60 91 77 01 	lds	r22, 0x0177
    f2de:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>

			 //SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,eeprom_read_byte(&DefPoolingPumpMax));

			 //InitStandalone();
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
    f2e2:	80 91 25 01 	lds	r24, 0x0125
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f2e6:	e1 99       	sbic	0x1c, 1	; 28
    f2e8:	fe cf       	rjmp	.-4      	; 0xf2e6 <InitializeConnection+0x2c8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f2ea:	bf ba       	out	0x1f, r11	; 31
    f2ec:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f2ee:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    f2f0:	0f b6       	in	r0, 0x3f	; 63
    f2f2:	f8 94       	cli
    f2f4:	e2 9a       	sbi	0x1c, 2	; 28
    f2f6:	e1 9a       	sbi	0x1c, 1	; 28
    f2f8:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f2fa:	e1 99       	sbic	0x1c, 1	; 28
    f2fc:	fe cf       	rjmp	.-4      	; 0xf2fa <InitializeConnection+0x2dc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f2fe:	84 e7       	ldi	r24, 0x74	; 116
    f300:	91 e0       	ldi	r25, 0x01	; 1
    f302:	9f bb       	out	0x1f, r25	; 31
    f304:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f306:	e0 9a       	sbi	0x1c, 0	; 28
    f308:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    f30a:	80 93 75 01 	sts	0x0175, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f30e:	e1 99       	sbic	0x1c, 1	; 28
    f310:	fe cf       	rjmp	.-4      	; 0xf30e <InitializeConnection+0x2f0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f312:	89 e7       	ldi	r24, 0x79	; 121
    f314:	91 e0       	ldi	r25, 0x01	; 1
    f316:	9f bb       	out	0x1f, r25	; 31
    f318:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f31a:	e0 9a       	sbi	0x1c, 0	; 28
    f31c:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    f31e:	80 93 76 01 	sts	0x0176, r24
			 //InitStandalone();
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
	}
	InitMemory();
}
    f322:	64 96       	adiw	r28, 0x14	; 20
    f324:	0f b6       	in	r0, 0x3f	; 63
    f326:	f8 94       	cli
    f328:	de bf       	out	0x3e, r29	; 62
    f32a:	0f be       	out	0x3f, r0	; 63
    f32c:	cd bf       	out	0x3d, r28	; 61
    f32e:	cf 91       	pop	r28
    f330:	df 91       	pop	r29
    f332:	1f 91       	pop	r17
    f334:	0f 91       	pop	r16
    f336:	ff 90       	pop	r15
    f338:	ef 90       	pop	r14
    f33a:	df 90       	pop	r13
    f33c:	cf 90       	pop	r12
    f33e:	bf 90       	pop	r11
    f340:	af 90       	pop	r10
    f342:	08 95       	ret

0000f344 <StoreStandaloneTransData>:
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
}
         
			                                         //      STX     MSGID  PumpID              6        8        8
void StoreStandaloneTransData(char *strRawTransData){//  [0x50,0x05]  01      01      1       004500   00000200  00000012 [0x06,0x60] = 24
    f344:	2f 92       	push	r2
    f346:	3f 92       	push	r3
    f348:	4f 92       	push	r4
    f34a:	5f 92       	push	r5
    f34c:	6f 92       	push	r6
    f34e:	7f 92       	push	r7
    f350:	8f 92       	push	r8
    f352:	9f 92       	push	r9
    f354:	af 92       	push	r10
    f356:	bf 92       	push	r11
    f358:	cf 92       	push	r12
    f35a:	df 92       	push	r13
    f35c:	ef 92       	push	r14
    f35e:	ff 92       	push	r15
    f360:	0f 93       	push	r16
    f362:	1f 93       	push	r17
    f364:	df 93       	push	r29
    f366:	cf 93       	push	r28
    f368:	cd b7       	in	r28, 0x3d	; 61
    f36a:	de b7       	in	r29, 0x3e	; 62
    f36c:	e1 97       	sbiw	r28, 0x31	; 49
    f36e:	0f b6       	in	r0, 0x3f	; 63
    f370:	f8 94       	cli
    f372:	de bf       	out	0x3e, r29	; 62
    f374:	0f be       	out	0x3f, r0	; 63
    f376:	cd bf       	out	0x3d, r28	; 61
    f378:	7c 01       	movw	r14, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f37a:	dc 01       	movw	r26, r24
    f37c:	12 96       	adiw	r26, 0x02	; 2
    f37e:	8c 91       	ld	r24, X
    f380:	12 97       	sbiw	r26, 0x02	; 2
    f382:	89 83       	std	Y+1, r24	; 0x01
    f384:	13 96       	adiw	r26, 0x03	; 3
    f386:	8c 91       	ld	r24, X
    f388:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    f38a:	1b 82       	std	Y+3, r1	; 0x03
	 char strSend[30];
	 char TransDigit;
	 char FIPAddr;
      
	 StrPosCopy(strRawTransData,strPumpID,2,2);
	 RemZeroLead(strPumpID);
    f38c:	8e 01       	movw	r16, r28
    f38e:	0f 5f       	subi	r16, 0xFF	; 255
    f390:	1f 4f       	sbci	r17, 0xFF	; 255
    f392:	c8 01       	movw	r24, r16
    f394:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
	 iPumpID=atoi(strPumpID); 
    f398:	c8 01       	movw	r24, r16
    f39a:	0e 94 6e b4 	call	0x168dc	; 0x168dc <atoi>
    f39e:	38 2e       	mov	r3, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    f3a0:	0e 94 bd 1a 	call	0x357a	; 0x357a <GetFIPAddr>
    f3a4:	d8 2e       	mov	r13, r24
	 if (FIPAddr>0){
    f3a6:	88 23       	and	r24, r24
    f3a8:	09 f4       	brne	.+2      	; 0xf3ac <StoreStandaloneTransData+0x68>
    f3aa:	1a c2       	rjmp	.+1076   	; 0xf7e0 <StoreStandaloneTransData+0x49c>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    f3ac:	f7 01       	movw	r30, r14
    f3ae:	f4 81       	ldd	r31, Z+4	; 0x04
    f3b0:	f9 ab       	std	Y+49, r31	; 0x31

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f3b2:	d7 01       	movw	r26, r14
    f3b4:	15 96       	adiw	r26, 0x05	; 5
    f3b6:	2c 90       	ld	r2, X
    f3b8:	e4 e0       	ldi	r30, 0x04	; 4
    f3ba:	8e 2e       	mov	r8, r30
    f3bc:	91 2c       	mov	r9, r1
    f3be:	8c 0e       	add	r8, r28
    f3c0:	9d 1e       	adc	r9, r29
    f3c2:	f4 01       	movw	r30, r8
    f3c4:	ce 01       	movw	r24, r28
    f3c6:	0b 96       	adiw	r24, 0x0b	; 11
	     strMemory[i]=data;
    f3c8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f3ca:	e8 17       	cp	r30, r24
    f3cc:	f9 07       	cpc	r31, r25
    f3ce:	e1 f7       	brne	.-8      	; 0xf3c8 <StoreStandaloneTransData+0x84>
    f3d0:	7d e1       	ldi	r23, 0x1D	; 29
    f3d2:	67 2e       	mov	r6, r23
    f3d4:	71 2c       	mov	r7, r1
    f3d6:	6c 0e       	add	r6, r28
    f3d8:	7d 1e       	adc	r7, r29
    f3da:	93 01       	movw	r18, r6
	     strMemory[i]=data;
    f3dc:	ce 01       	movw	r24, r28
    f3de:	87 96       	adiw	r24, 0x27	; 39
    f3e0:	f9 01       	movw	r30, r18
    f3e2:	11 92       	st	Z+, r1
    f3e4:	9f 01       	movw	r18, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f3e6:	e8 17       	cp	r30, r24
    f3e8:	f9 07       	cpc	r31, r25
    f3ea:	d1 f7       	brne	.-12     	; 0xf3e0 <StoreStandaloneTransData+0x9c>
    f3ec:	2f 01       	movw	r4, r30
	     strMemory[i]=data;
    f3ee:	ce 01       	movw	r24, r28
    f3f0:	c1 96       	adiw	r24, 0x31	; 49
    f3f2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f3f4:	e8 17       	cp	r30, r24
    f3f6:	f9 07       	cpc	r31, r25
    f3f8:	e1 f7       	brne	.-8      	; 0xf3f2 <StoreStandaloneTransData+0xae>
    f3fa:	a7 01       	movw	r20, r14
    f3fc:	d7 01       	movw	r26, r14
    f3fe:	f4 01       	movw	r30, r8
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f400:	be 01       	movw	r22, r28
    f402:	66 5f       	subi	r22, 0xF6	; 246
    f404:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f406:	16 96       	adiw	r26, 0x06	; 6
    f408:	8c 91       	ld	r24, X
    f40a:	16 97       	sbiw	r26, 0x06	; 6
    f40c:	81 93       	st	Z+, r24
    f40e:	11 96       	adiw	r26, 0x01	; 1
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f410:	e6 17       	cp	r30, r22
    f412:	f7 07       	cpc	r31, r23
    f414:	c1 f7       	brne	.-16     	; 0xf406 <StoreStandaloneTransData+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f416:	1a 86       	std	Y+10, r1	; 0x0a
    f418:	d7 01       	movw	r26, r14
    f41a:	f3 01       	movw	r30, r6
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f41c:	be 01       	movw	r22, r28
    f41e:	6b 5d       	subi	r22, 0xDB	; 219
    f420:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f422:	1c 96       	adiw	r26, 0x0c	; 12
    f424:	8c 91       	ld	r24, X
    f426:	1c 97       	sbiw	r26, 0x0c	; 12
    f428:	81 93       	st	Z+, r24
    f42a:	11 96       	adiw	r26, 0x01	; 1
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f42c:	e6 17       	cp	r30, r22
    f42e:	f7 07       	cpc	r31, r23
    f430:	c1 f7       	brne	.-16     	; 0xf422 <StoreStandaloneTransData+0xde>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f432:	1d a2       	std	Y+37, r1	; 0x25
    f434:	f9 01       	movw	r30, r18
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f436:	be 01       	movw	r22, r28
    f438:	69 5d       	subi	r22, 0xD9	; 217
    f43a:	7f 4f       	sbci	r23, 0xFF	; 255
    f43c:	9e 01       	movw	r18, r28
    f43e:	21 5d       	subi	r18, 0xD1	; 209
    f440:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f442:	da 01       	movw	r26, r20
    f444:	54 96       	adiw	r26, 0x14	; 20
    f446:	8c 91       	ld	r24, X
    f448:	81 93       	st	Z+, r24
    f44a:	4f 5f       	subi	r20, 0xFF	; 255
    f44c:	5f 4f       	sbci	r21, 0xFF	; 255
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f44e:	e2 17       	cp	r30, r18
    f450:	f3 07       	cpc	r31, r19
    f452:	b9 f7       	brne	.-18     	; 0xf442 <StoreStandaloneTransData+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f454:	1f a6       	std	Y+47, r1	; 0x2f
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    f456:	f7 01       	movw	r30, r14
    f458:	84 8d       	ldd	r24, Z+28	; 0x1c
    f45a:	80 53       	subi	r24, 0x30	; 48
    f45c:	8a 30       	cpi	r24, 0x0A	; 10
    f45e:	98 f4       	brcc	.+38     	; 0xf486 <StoreStandaloneTransData+0x142>

		 TransDigit=Ord(CharPosCopy(strRawTransData,28));
		 //Normalize7Digit
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //_uart_print(1,1,strSend);
		 if  (TransDigit==8){
    f460:	88 30       	cpi	r24, 0x08	; 8
    f462:	89 f4       	brne	.+34     	; 0xf486 <StoreStandaloneTransData+0x142>
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
    f464:	fb 01       	movw	r30, r22
    f466:	01 90       	ld	r0, Z+
    f468:	00 20       	and	r0, r0
    f46a:	e9 f7       	brne	.-6      	; 0xf466 <StoreStandaloneTransData+0x122>
    f46c:	e6 1b       	sub	r30, r22
    f46e:	f7 0b       	sbc	r31, r23
    f470:	32 97       	sbiw	r30, 0x02	; 2
    f472:	80 e0       	ldi	r24, 0x00	; 0
    f474:	90 e0       	ldi	r25, 0x00	; 0
    f476:	01 c0       	rjmp	.+2      	; 0xf47a <StoreStandaloneTransData+0x136>
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f478:	01 96       	adiw	r24, 0x01	; 1
    f47a:	8e 17       	cp	r24, r30
    f47c:	9f 07       	cpc	r25, r31
    f47e:	e0 f3       	brcs	.-8      	; 0xf478 <StoreStandaloneTransData+0x134>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f480:	ec 0f       	add	r30, r28
    f482:	fd 1f       	adc	r31, r29
    f484:	17 a2       	std	Z+39, r1	; 0x27
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //_uart_print(1,1,strSend);
		 if  (TransDigit==8){
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
		 }
		 RemZeroLead(strPPU);
    f486:	64 e0       	ldi	r22, 0x04	; 4
    f488:	e6 2e       	mov	r14, r22
    f48a:	f1 2c       	mov	r15, r1
    f48c:	ec 0e       	add	r14, r28
    f48e:	fd 1e       	adc	r15, r29
    f490:	c7 01       	movw	r24, r14
    f492:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
		 RemZeroLead(strPVolume);
    f496:	5d e1       	ldi	r21, 0x1D	; 29
    f498:	a5 2e       	mov	r10, r21
    f49a:	b1 2c       	mov	r11, r1
    f49c:	ac 0e       	add	r10, r28
    f49e:	bd 1e       	adc	r11, r29
    f4a0:	c5 01       	movw	r24, r10
    f4a2:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
		 RemZeroLead(strPMoney);
    f4a6:	8e 01       	movw	r16, r28
    f4a8:	09 5d       	subi	r16, 0xD9	; 217
    f4aa:	1f 4f       	sbci	r17, 0xFF	; 255
    f4ac:	c8 01       	movw	r24, r16
    f4ae:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
		 //sprintf_P(strSend,PSTR("Money: %s"),strPMoney);
		 //_uart_print(1,1,strSend);


		 //Void Detection
		 if (atoi(strPMoney)==0)TransactionStatus=TS_VOID;
    f4b2:	c8 01       	movw	r24, r16
    f4b4:	0e 94 6e b4 	call	0x168dc	; 0x168dc <atoi>
    f4b8:	89 2b       	or	r24, r25
    f4ba:	09 f0       	breq	.+2      	; 0xf4be <StoreStandaloneTransData+0x17a>
    f4bc:	46 c1       	rjmp	.+652    	; 0xf74a <StoreStandaloneTransData+0x406>
		 else TransactionStatus=TS_NEW;
		 
		 if (TransactionStatus==TS_VOID){//RejectData
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
    f4be:	83 2d       	mov	r24, r3
    f4c0:	8f 70       	andi	r24, 0x0F	; 15
    f4c2:	63 e1       	ldi	r22, 0x13	; 19
    f4c4:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <UpdateStandaloneStatus>
    f4c8:	8b c1       	rjmp	.+790    	; 0xf7e0 <StoreStandaloneTransData+0x49c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f4ca:	e1 99       	sbic	0x1c, 1	; 28
    f4cc:	fe cf       	rjmp	.-4      	; 0xf4ca <StoreStandaloneTransData+0x186>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f4ce:	8f e6       	ldi	r24, 0x6F	; 111
    f4d0:	91 e0       	ldi	r25, 0x01	; 1
    f4d2:	9f bb       	out	0x1f, r25	; 31
    f4d4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f4d6:	e0 9a       	sbi	0x1c, 0	; 28
    f4d8:	2d b3       	in	r18, 0x1d	; 29
			 //_uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    f4da:	00 d0       	rcall	.+0      	; 0xf4dc <StoreStandaloneTransData+0x198>
    f4dc:	00 d0       	rcall	.+0      	; 0xf4de <StoreStandaloneTransData+0x19a>
    f4de:	00 d0       	rcall	.+0      	; 0xf4e0 <StoreStandaloneTransData+0x19c>
    f4e0:	ed b7       	in	r30, 0x3d	; 61
    f4e2:	fe b7       	in	r31, 0x3e	; 62
    f4e4:	31 96       	adiw	r30, 0x01	; 1
    f4e6:	83 e7       	ldi	r24, 0x73	; 115
    f4e8:	9e e0       	ldi	r25, 0x0E	; 14
    f4ea:	ad b7       	in	r26, 0x3d	; 61
    f4ec:	be b7       	in	r27, 0x3e	; 62
    f4ee:	12 96       	adiw	r26, 0x02	; 2
    f4f0:	9c 93       	st	X, r25
    f4f2:	8e 93       	st	-X, r24
    f4f4:	11 97       	sbiw	r26, 0x01	; 1
    f4f6:	8d e3       	ldi	r24, 0x3D	; 61
    f4f8:	92 e2       	ldi	r25, 0x22	; 34
    f4fa:	93 83       	std	Z+3, r25	; 0x03
    f4fc:	82 83       	std	Z+2, r24	; 0x02
    f4fe:	24 83       	std	Z+4, r18	; 0x04
    f500:	15 82       	std	Z+5, r1	; 0x05
    f502:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
    f506:	e2 e9       	ldi	r30, 0x92	; 146
    f508:	fe e0       	ldi	r31, 0x0E	; 14
    f50a:	df 01       	movw	r26, r30
    f50c:	0d 90       	ld	r0, X+
    f50e:	00 20       	and	r0, r0
    f510:	e9 f7       	brne	.-6      	; 0xf50c <StoreStandaloneTransData+0x1c8>
    f512:	9d 01       	movw	r18, r26
    f514:	21 50       	subi	r18, 0x01	; 1
    f516:	30 40       	sbci	r19, 0x00	; 0
    f518:	2e 1b       	sub	r18, r30
    f51a:	3f 0b       	sbc	r19, r31
    f51c:	85 e3       	ldi	r24, 0x35	; 53
    f51e:	90 e0       	ldi	r25, 0x00	; 0
    f520:	c8 9e       	mul	r12, r24
    f522:	d0 01       	movw	r26, r0
    f524:	c9 9e       	mul	r12, r25
    f526:	b0 0d       	add	r27, r0
    f528:	d8 9e       	mul	r13, r24
    f52a:	b0 0d       	add	r27, r0
    f52c:	11 24       	eor	r1, r1
    f52e:	a6 54       	subi	r26, 0x46	; 70
    f530:	b8 4f       	sbci	r27, 0xF8	; 248
    f532:	4d b7       	in	r20, 0x3d	; 61
    f534:	5e b7       	in	r21, 0x3e	; 62
    f536:	4a 5f       	subi	r20, 0xFA	; 250
    f538:	5f 4f       	sbci	r21, 0xFF	; 255
    f53a:	0f b6       	in	r0, 0x3f	; 63
    f53c:	f8 94       	cli
    f53e:	5e bf       	out	0x3e, r21	; 62
    f540:	0f be       	out	0x3f, r0	; 63
    f542:	4d bf       	out	0x3d, r20	; 61
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f544:	a9 01       	movw	r20, r18
    f546:	4e 0f       	add	r20, r30
    f548:	5f 1f       	adc	r21, r31
    f54a:	02 c0       	rjmp	.+4      	; 0xf550 <StoreStandaloneTransData+0x20c>
	    Dest[i]=Source[IdxSource+i];
    f54c:	81 91       	ld	r24, Z+
    f54e:	8d 93       	st	X+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f550:	e4 17       	cp	r30, r20
    f552:	f5 07       	cpc	r31, r21
    f554:	d9 f7       	brne	.-10     	; 0xf54c <StoreStandaloneTransData+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f556:	85 e3       	ldi	r24, 0x35	; 53
    f558:	90 e0       	ldi	r25, 0x00	; 0
    f55a:	dc 01       	movw	r26, r24
    f55c:	ca 9e       	mul	r12, r26
    f55e:	c0 01       	movw	r24, r0
    f560:	cb 9e       	mul	r12, r27
    f562:	90 0d       	add	r25, r0
    f564:	da 9e       	mul	r13, r26
    f566:	90 0d       	add	r25, r0
    f568:	11 24       	eor	r1, r1
    f56a:	fc 01       	movw	r30, r24
    f56c:	e9 54       	subi	r30, 0x49	; 73
    f56e:	f8 4f       	sbci	r31, 0xF8	; 248
    f570:	e2 0f       	add	r30, r18
    f572:	f3 1f       	adc	r31, r19
    f574:	13 82       	std	Z+3, r1	; 0x03
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
    f576:	fe 01       	movw	r30, r28
    f578:	3b 96       	adiw	r30, 0x0b	; 11
    f57a:	df 01       	movw	r26, r30
    f57c:	0d 90       	ld	r0, X+
    f57e:	00 20       	and	r0, r0
    f580:	e9 f7       	brne	.-6      	; 0xf57c <StoreStandaloneTransData+0x238>
    f582:	11 97       	sbiw	r26, 0x01	; 1
    f584:	ae 1b       	sub	r26, r30
    f586:	bf 0b       	sbc	r27, r31
    f588:	bf 01       	movw	r22, r30
    f58a:	9c 01       	movw	r18, r24
    f58c:	2f 53       	subi	r18, 0x3F	; 63
    f58e:	38 4f       	sbci	r19, 0xF8	; 248
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f590:	af 01       	movw	r20, r30
    f592:	4a 0f       	add	r20, r26
    f594:	5b 1f       	adc	r21, r27
    f596:	06 c0       	rjmp	.+12     	; 0xf5a4 <StoreStandaloneTransData+0x260>
	    Dest[i]=Source[IdxSource+i];
    f598:	fb 01       	movw	r30, r22
    f59a:	81 91       	ld	r24, Z+
    f59c:	bf 01       	movw	r22, r30
    f59e:	f9 01       	movw	r30, r18
    f5a0:	81 93       	st	Z+, r24
    f5a2:	9f 01       	movw	r18, r30
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f5a4:	64 17       	cp	r22, r20
    f5a6:	75 07       	cpc	r23, r21
    f5a8:	b9 f7       	brne	.-18     	; 0xf598 <StoreStandaloneTransData+0x254>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f5aa:	85 e3       	ldi	r24, 0x35	; 53
    f5ac:	90 e0       	ldi	r25, 0x00	; 0
    f5ae:	9c 01       	movw	r18, r24
    f5b0:	c2 9e       	mul	r12, r18
    f5b2:	c0 01       	movw	r24, r0
    f5b4:	c3 9e       	mul	r12, r19
    f5b6:	90 0d       	add	r25, r0
    f5b8:	d2 9e       	mul	r13, r18
    f5ba:	90 0d       	add	r25, r0
    f5bc:	11 24       	eor	r1, r1
    f5be:	fc 01       	movw	r30, r24
    f5c0:	e9 54       	subi	r30, 0x49	; 73
    f5c2:	f8 4f       	sbci	r31, 0xF8	; 248
    f5c4:	ea 0f       	add	r30, r26
    f5c6:	fb 1f       	adc	r31, r27
    f5c8:	12 86       	std	Z+10, r1	; 0x0a
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
    f5ca:	fe 01       	movw	r30, r28
    f5cc:	74 96       	adiw	r30, 0x14	; 20
    f5ce:	df 01       	movw	r26, r30
    f5d0:	0d 90       	ld	r0, X+
    f5d2:	00 20       	and	r0, r0
    f5d4:	e9 f7       	brne	.-6      	; 0xf5d0 <StoreStandaloneTransData+0x28c>
    f5d6:	11 97       	sbiw	r26, 0x01	; 1
    f5d8:	ae 1b       	sub	r26, r30
    f5da:	bf 0b       	sbc	r27, r31
    f5dc:	bf 01       	movw	r22, r30
    f5de:	9c 01       	movw	r18, r24
    f5e0:	26 53       	subi	r18, 0x36	; 54
    f5e2:	38 4f       	sbci	r19, 0xF8	; 248
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f5e4:	af 01       	movw	r20, r30
    f5e6:	4a 0f       	add	r20, r26
    f5e8:	5b 1f       	adc	r21, r27
    f5ea:	06 c0       	rjmp	.+12     	; 0xf5f8 <StoreStandaloneTransData+0x2b4>
	    Dest[i]=Source[IdxSource+i];
    f5ec:	fb 01       	movw	r30, r22
    f5ee:	81 91       	ld	r24, Z+
    f5f0:	bf 01       	movw	r22, r30
    f5f2:	f9 01       	movw	r30, r18
    f5f4:	81 93       	st	Z+, r24
    f5f6:	9f 01       	movw	r18, r30
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f5f8:	64 17       	cp	r22, r20
    f5fa:	75 07       	cpc	r23, r21
    f5fc:	b9 f7       	brne	.-18     	; 0xf5ec <StoreStandaloneTransData+0x2a8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f5fe:	85 e3       	ldi	r24, 0x35	; 53
    f600:	90 e0       	ldi	r25, 0x00	; 0
    f602:	c8 9e       	mul	r12, r24
    f604:	70 01       	movw	r14, r0
    f606:	c9 9e       	mul	r12, r25
    f608:	f0 0c       	add	r15, r0
    f60a:	d8 9e       	mul	r13, r24
    f60c:	f0 0c       	add	r15, r0
    f60e:	11 24       	eor	r1, r1
    f610:	87 01       	movw	r16, r14
    f612:	09 54       	subi	r16, 0x49	; 73
    f614:	18 4f       	sbci	r17, 0xF8	; 248
    f616:	a0 0f       	add	r26, r16
    f618:	b1 1f       	adc	r27, r17
    f61a:	53 96       	adiw	r26, 0x13	; 19
    f61c:	1c 92       	st	X, r1
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
			 //Grade Nozzle Shift
			 RecPumpData[FIPAddr].Grade=PGrade;
    f61e:	f0 ed       	ldi	r31, 0xD0	; 208
    f620:	2f 0e       	add	r2, r31
    f622:	d8 01       	movw	r26, r16
    f624:	2c 92       	st	X, r2
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
    f626:	b9 a9       	ldd	r27, Y+49	; 0x31
    f628:	b0 53       	subi	r27, 0x30	; 48
    f62a:	f8 01       	movw	r30, r16
    f62c:	b1 83       	std	Z+1, r27	; 0x01
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
    f62e:	83 e7       	ldi	r24, 0x73	; 115
    f630:	9e e0       	ldi	r25, 0x0E	; 14
    f632:	0e 94 6e b4 	call	0x168dc	; 0x168dc <atoi>
    f636:	d8 01       	movw	r26, r16
    f638:	12 96       	adiw	r26, 0x02	; 2
    f63a:	8c 93       	st	X, r24
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
    f63c:	fe 01       	movw	r30, r28
    f63e:	34 96       	adiw	r30, 0x04	; 4
    f640:	df 01       	movw	r26, r30
    f642:	0d 90       	ld	r0, X+
    f644:	00 20       	and	r0, r0
    f646:	e9 f7       	brne	.-6      	; 0xf642 <StoreStandaloneTransData+0x2fe>
    f648:	11 97       	sbiw	r26, 0x01	; 1
    f64a:	ae 1b       	sub	r26, r30
    f64c:	bf 0b       	sbc	r27, r31
    f64e:	97 01       	movw	r18, r14
    f650:	2d 52       	subi	r18, 0x2D	; 45
    f652:	38 4f       	sbci	r19, 0xF8	; 248
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f654:	af 01       	movw	r20, r30
    f656:	4a 0f       	add	r20, r26
    f658:	5b 1f       	adc	r21, r27
    f65a:	06 c0       	rjmp	.+12     	; 0xf668 <StoreStandaloneTransData+0x324>
	    Dest[i]=Source[IdxSource+i];
    f65c:	f4 01       	movw	r30, r8
    f65e:	81 91       	ld	r24, Z+
    f660:	4f 01       	movw	r8, r30
    f662:	f9 01       	movw	r30, r18
    f664:	81 93       	st	Z+, r24
    f666:	9f 01       	movw	r18, r30
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f668:	84 16       	cp	r8, r20
    f66a:	95 06       	cpc	r9, r21
    f66c:	b9 f7       	brne	.-18     	; 0xf65c <StoreStandaloneTransData+0x318>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f66e:	85 e3       	ldi	r24, 0x35	; 53
    f670:	90 e0       	ldi	r25, 0x00	; 0
    f672:	9c 01       	movw	r18, r24
    f674:	c2 9e       	mul	r12, r18
    f676:	c0 01       	movw	r24, r0
    f678:	c3 9e       	mul	r12, r19
    f67a:	90 0d       	add	r25, r0
    f67c:	d2 9e       	mul	r13, r18
    f67e:	90 0d       	add	r25, r0
    f680:	11 24       	eor	r1, r1
    f682:	fc 01       	movw	r30, r24
    f684:	e9 54       	subi	r30, 0x49	; 73
    f686:	f8 4f       	sbci	r31, 0xF8	; 248
    f688:	ea 0f       	add	r30, r26
    f68a:	fb 1f       	adc	r31, r27
    f68c:	14 8e       	std	Z+28, r1	; 0x1c
			 RecPumpData[FIPAddr].Grade=PGrade;
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
    f68e:	fe 01       	movw	r30, r28
    f690:	7d 96       	adiw	r30, 0x1d	; 29
    f692:	df 01       	movw	r26, r30
    f694:	0d 90       	ld	r0, X+
    f696:	00 20       	and	r0, r0
    f698:	e9 f7       	brne	.-6      	; 0xf694 <StoreStandaloneTransData+0x350>
    f69a:	11 97       	sbiw	r26, 0x01	; 1
    f69c:	ae 1b       	sub	r26, r30
    f69e:	bf 0b       	sbc	r27, r31
    f6a0:	9c 01       	movw	r18, r24
    f6a2:	26 52       	subi	r18, 0x26	; 38
    f6a4:	38 4f       	sbci	r19, 0xF8	; 248
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f6a6:	af 01       	movw	r20, r30
    f6a8:	4a 0f       	add	r20, r26
    f6aa:	5b 1f       	adc	r21, r27
    f6ac:	06 c0       	rjmp	.+12     	; 0xf6ba <StoreStandaloneTransData+0x376>
	    Dest[i]=Source[IdxSource+i];
    f6ae:	f3 01       	movw	r30, r6
    f6b0:	81 91       	ld	r24, Z+
    f6b2:	3f 01       	movw	r6, r30
    f6b4:	f9 01       	movw	r30, r18
    f6b6:	81 93       	st	Z+, r24
    f6b8:	9f 01       	movw	r18, r30
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f6ba:	64 16       	cp	r6, r20
    f6bc:	75 06       	cpc	r7, r21
    f6be:	b9 f7       	brne	.-18     	; 0xf6ae <StoreStandaloneTransData+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f6c0:	85 e3       	ldi	r24, 0x35	; 53
    f6c2:	90 e0       	ldi	r25, 0x00	; 0
    f6c4:	9c 01       	movw	r18, r24
    f6c6:	c2 9e       	mul	r12, r18
    f6c8:	c0 01       	movw	r24, r0
    f6ca:	c3 9e       	mul	r12, r19
    f6cc:	90 0d       	add	r25, r0
    f6ce:	d2 9e       	mul	r13, r18
    f6d0:	90 0d       	add	r25, r0
    f6d2:	11 24       	eor	r1, r1
    f6d4:	fc 01       	movw	r30, r24
    f6d6:	e9 54       	subi	r30, 0x49	; 73
    f6d8:	f8 4f       	sbci	r31, 0xF8	; 248
    f6da:	ea 0f       	add	r30, r26
    f6dc:	fb 1f       	adc	r31, r27
    f6de:	13 a2       	std	Z+35, r1	; 0x23
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));
    f6e0:	fe 01       	movw	r30, r28
    f6e2:	b7 96       	adiw	r30, 0x27	; 39
    f6e4:	df 01       	movw	r26, r30
    f6e6:	0d 90       	ld	r0, X+
    f6e8:	00 20       	and	r0, r0
    f6ea:	e9 f7       	brne	.-6      	; 0xf6e6 <StoreStandaloneTransData+0x3a2>
    f6ec:	11 97       	sbiw	r26, 0x01	; 1
    f6ee:	ae 1b       	sub	r26, r30
    f6f0:	bf 0b       	sbc	r27, r31
    f6f2:	9c 01       	movw	r18, r24
    f6f4:	2d 51       	subi	r18, 0x1D	; 29
    f6f6:	38 4f       	sbci	r19, 0xF8	; 248
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f6f8:	af 01       	movw	r20, r30
    f6fa:	4a 0f       	add	r20, r26
    f6fc:	5b 1f       	adc	r21, r27
    f6fe:	06 c0       	rjmp	.+12     	; 0xf70c <StoreStandaloneTransData+0x3c8>
	    Dest[i]=Source[IdxSource+i];
    f700:	f2 01       	movw	r30, r4
    f702:	81 91       	ld	r24, Z+
    f704:	2f 01       	movw	r4, r30
    f706:	f9 01       	movw	r30, r18
    f708:	81 93       	st	Z+, r24
    f70a:	9f 01       	movw	r18, r30
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f70c:	44 16       	cp	r4, r20
    f70e:	55 06       	cpc	r5, r21
    f710:	b9 f7       	brne	.-18     	; 0xf700 <StoreStandaloneTransData+0x3bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f712:	85 e3       	ldi	r24, 0x35	; 53
    f714:	90 e0       	ldi	r25, 0x00	; 0
    f716:	c8 9e       	mul	r12, r24
    f718:	f0 01       	movw	r30, r0
    f71a:	c9 9e       	mul	r12, r25
    f71c:	f0 0d       	add	r31, r0
    f71e:	d8 9e       	mul	r13, r24
    f720:	f0 0d       	add	r31, r0
    f722:	11 24       	eor	r1, r1
    f724:	e9 54       	subi	r30, 0x49	; 73
    f726:	f8 4f       	sbci	r31, 0xF8	; 248
    f728:	ea 0f       	add	r30, r26
    f72a:	fb 1f       	adc	r31, r27
    f72c:	14 a6       	std	Z+44, r1	; 0x2c
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));

			 UpdateStandaloneStatus((iPumpID&0x0F),PS_PRINT_READY);
    f72e:	83 2d       	mov	r24, r3
    f730:	8f 70       	andi	r24, 0x0F	; 15
    f732:	60 e1       	ldi	r22, 0x10	; 16
    f734:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <UpdateStandaloneStatus>
			 
			 SetIncomingTransStatus(iPumpID,TS_NEW);		 
    f738:	83 2d       	mov	r24, r3
    f73a:	62 e0       	ldi	r22, 0x02	; 2
    f73c:	0e 94 68 19 	call	0x32d0	; 0x32d0 <SetIncomingTransStatus>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
    f740:	8b e0       	ldi	r24, 0x0B	; 11
    f742:	63 2d       	mov	r22, r3
    f744:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
    f748:	4b c0       	rjmp	.+150    	; 0xf7e0 <StoreStandaloneTransData+0x49c>
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
		 }
		 else 
		 if (TransactionStatus=TS_NEW){ 
			 //Update ReprintReady
			 ReprintReady[FIPAddr]=True;//Ready for Printing
    f74a:	da 94       	dec	r13
    f74c:	cd 2c       	mov	r12, r13
    f74e:	dd 24       	eor	r13, r13
    f750:	f6 01       	movw	r30, r12
    f752:	e8 56       	subi	r30, 0x68	; 104
    f754:	fe 4f       	sbci	r31, 0xFE	; 254
    f756:	81 e0       	ldi	r24, 0x01	; 1
    f758:	80 83       	st	Z, r24
			  
			 FormatPrice(strPPU);
    f75a:	c7 01       	movw	r24, r14
    f75c:	0e 94 c4 30 	call	0x6188	; 0x6188 <FormatPrice>
			 FormatMoney(strPMoney);
    f760:	c8 01       	movw	r24, r16
    f762:	0e 94 b7 30 	call	0x616e	; 0x616e <FormatMoney>
			 FormatVolume(strPVolume);
    f766:	c5 01       	movw	r24, r10
    f768:	0e 94 aa 30 	call	0x6154	; 0x6154 <FormatVolume>

			 //_uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
    f76c:	82 e9       	ldi	r24, 0x92	; 146
    f76e:	9e e0       	ldi	r25, 0x0E	; 14
    f770:	0e 94 a0 47 	call	0x8f40	; 0x8f40 <GenerateTransactionNum>
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
    f774:	00 d0       	rcall	.+0      	; 0xf776 <StoreStandaloneTransData+0x432>
    f776:	00 d0       	rcall	.+0      	; 0xf778 <StoreStandaloneTransData+0x434>
    f778:	00 d0       	rcall	.+0      	; 0xf77a <StoreStandaloneTransData+0x436>
    f77a:	ed b7       	in	r30, 0x3d	; 61
    f77c:	fe b7       	in	r31, 0x3e	; 62
    f77e:	31 96       	adiw	r30, 0x01	; 1
    f780:	ce 01       	movw	r24, r28
    f782:	0b 96       	adiw	r24, 0x0b	; 11
    f784:	ad b7       	in	r26, 0x3d	; 61
    f786:	be b7       	in	r27, 0x3e	; 62
    f788:	12 96       	adiw	r26, 0x02	; 2
    f78a:	9c 93       	st	X, r25
    f78c:	8e 93       	st	-X, r24
    f78e:	11 97       	sbiw	r26, 0x01	; 1
    f790:	83 e4       	ldi	r24, 0x43	; 67
    f792:	92 e2       	ldi	r25, 0x22	; 34
    f794:	93 83       	std	Z+3, r25	; 0x03
    f796:	82 83       	std	Z+2, r24	; 0x02
    f798:	80 ec       	ldi	r24, 0xC0	; 192
    f79a:	95 e0       	ldi	r25, 0x05	; 5
    f79c:	95 83       	std	Z+5, r25	; 0x05
    f79e:	84 83       	std	Z+4, r24	; 0x04
    f7a0:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
    f7a4:	ed b7       	in	r30, 0x3d	; 61
    f7a6:	fe b7       	in	r31, 0x3e	; 62
    f7a8:	31 96       	adiw	r30, 0x01	; 1
    f7aa:	ce 01       	movw	r24, r28
    f7ac:	44 96       	adiw	r24, 0x14	; 20
    f7ae:	ad b7       	in	r26, 0x3d	; 61
    f7b0:	be b7       	in	r27, 0x3e	; 62
    f7b2:	12 96       	adiw	r26, 0x02	; 2
    f7b4:	9c 93       	st	X, r25
    f7b6:	8e 93       	st	-X, r24
    f7b8:	11 97       	sbiw	r26, 0x01	; 1
    f7ba:	80 e4       	ldi	r24, 0x40	; 64
    f7bc:	92 e2       	ldi	r25, 0x22	; 34
    f7be:	93 83       	std	Z+3, r25	; 0x03
    f7c0:	82 83       	std	Z+2, r24	; 0x02
    f7c2:	89 ea       	ldi	r24, 0xA9	; 169
    f7c4:	9a e0       	ldi	r25, 0x0A	; 10
    f7c6:	95 83       	std	Z+5, r25	; 0x05
    f7c8:	84 83       	std	Z+4, r24	; 0x04
    f7ca:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    f7ce:	ed b7       	in	r30, 0x3d	; 61
    f7d0:	fe b7       	in	r31, 0x3e	; 62
    f7d2:	36 96       	adiw	r30, 0x06	; 6
    f7d4:	0f b6       	in	r0, 0x3f	; 63
    f7d6:	f8 94       	cli
    f7d8:	fe bf       	out	0x3e, r31	; 62
    f7da:	0f be       	out	0x3f, r0	; 63
    f7dc:	ed bf       	out	0x3d, r30	; 61
    f7de:	75 ce       	rjmp	.-790    	; 0xf4ca <StoreStandaloneTransData+0x186>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
		 }		 
	 }    
     //_uart_print(0,1,strRawTransData);
}
    f7e0:	e1 96       	adiw	r28, 0x31	; 49
    f7e2:	0f b6       	in	r0, 0x3f	; 63
    f7e4:	f8 94       	cli
    f7e6:	de bf       	out	0x3e, r29	; 62
    f7e8:	0f be       	out	0x3f, r0	; 63
    f7ea:	cd bf       	out	0x3d, r28	; 61
    f7ec:	cf 91       	pop	r28
    f7ee:	df 91       	pop	r29
    f7f0:	1f 91       	pop	r17
    f7f2:	0f 91       	pop	r16
    f7f4:	ff 90       	pop	r15
    f7f6:	ef 90       	pop	r14
    f7f8:	df 90       	pop	r13
    f7fa:	cf 90       	pop	r12
    f7fc:	bf 90       	pop	r11
    f7fe:	af 90       	pop	r10
    f800:	9f 90       	pop	r9
    f802:	8f 90       	pop	r8
    f804:	7f 90       	pop	r7
    f806:	6f 90       	pop	r6
    f808:	5f 90       	pop	r5
    f80a:	4f 90       	pop	r4
    f80c:	3f 90       	pop	r3
    f80e:	2f 90       	pop	r2
    f810:	08 95       	ret

0000f812 <StoreStandaloneTotalizerData>:
      systemPrinting();
	  systemEDC();
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}

void StoreStandaloneTotalizerData(char *strRawTransData){//Sending FlowSPI_Protocol <STX>   [MsgID][PumpID][Volume1][Amount1][Volume2][Amount2][Volume3][Amount3][Volume4][Amount4][Volume5][Amount5][Volume6][Amount6]<ETX>
    f812:	2f 92       	push	r2
    f814:	3f 92       	push	r3
    f816:	4f 92       	push	r4
    f818:	5f 92       	push	r5
    f81a:	7f 92       	push	r7
    f81c:	8f 92       	push	r8
    f81e:	9f 92       	push	r9
    f820:	af 92       	push	r10
    f822:	bf 92       	push	r11
    f824:	cf 92       	push	r12
    f826:	df 92       	push	r13
    f828:	ef 92       	push	r14
    f82a:	ff 92       	push	r15
    f82c:	0f 93       	push	r16
    f82e:	1f 93       	push	r17
    f830:	df 93       	push	r29
    f832:	cf 93       	push	r28
    f834:	cd b7       	in	r28, 0x3d	; 61
    f836:	de b7       	in	r29, 0x3e	; 62
    f838:	a1 97       	sbiw	r28, 0x21	; 33
    f83a:	0f b6       	in	r0, 0x3f	; 63
    f83c:	f8 94       	cli
    f83e:	de bf       	out	0x3e, r29	; 62
    f840:	0f be       	out	0x3f, r0	; 63
    f842:	cd bf       	out	0x3d, r28	; 61
    f844:	7c 01       	movw	r14, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f846:	fc 01       	movw	r30, r24
    f848:	82 81       	ldd	r24, Z+2	; 0x02
    f84a:	89 83       	std	Y+1, r24	; 0x01
    f84c:	83 81       	ldd	r24, Z+3	; 0x03
    f84e:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    f850:	1b 82       	std	Y+3, r1	; 0x03
	 //for(i=0;i<strlen(strRawTransData);i++){
	 //    _uart(1,1,strRawTransData[i]); 
	 // }

     StrPosCopy(strRawTransData,strPumpID,2,2);
	 RemZeroLead(strPumpID);
    f852:	8e 01       	movw	r16, r28
    f854:	0f 5f       	subi	r16, 0xFF	; 255
    f856:	1f 4f       	sbci	r17, 0xFF	; 255
    f858:	c8 01       	movw	r24, r16
    f85a:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
	 iPumpID=atoi(strPumpID);  
    f85e:	c8 01       	movw	r24, r16
    f860:	0e 94 6e b4 	call	0x168dc	; 0x168dc <atoi>
    f864:	c8 2e       	mov	r12, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    f866:	0e 94 bd 1a 	call	0x357a	; 0x357a <GetFIPAddr>
	 if (FIPAddr>0){
    f86a:	88 23       	and	r24, r24
    f86c:	09 f4       	brne	.+2      	; 0xf870 <StoreStandaloneTotalizerData+0x5e>
    f86e:	43 c0       	rjmp	.+134    	; 0xf8f6 <StoreStandaloneTotalizerData+0xe4>
	     FIPAddr=FIPAddr-1;
    f870:	78 2e       	mov	r7, r24
    f872:	7a 94       	dec	r7
    f874:	80 e1       	ldi	r24, 0x10	; 16
    f876:	90 e0       	ldi	r25, 0x00	; 0
    f878:	e8 0e       	add	r14, r24
    f87a:	f9 1e       	adc	r15, r25
    f87c:	dd 24       	eor	r13, r13
    f87e:	d3 94       	inc	r13
    f880:	14 e0       	ldi	r17, 0x04	; 4
    f882:	81 2e       	mov	r8, r17
    f884:	91 2c       	mov	r9, r1
    f886:	8c 0e       	add	r8, r28
    f888:	9d 1e       	adc	r9, r29
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f88a:	b0 e1       	ldi	r27, 0x10	; 16
    f88c:	2b 2e       	mov	r2, r27
    f88e:	31 2c       	mov	r3, r1
    f890:	2c 0e       	add	r2, r28
    f892:	3d 1e       	adc	r3, r29
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f894:	a3 e1       	ldi	r26, 0x13	; 19
    f896:	aa 2e       	mov	r10, r26
    f898:	b1 2c       	mov	r11, r1
    f89a:	ac 0e       	add	r10, r28
    f89c:	bd 1e       	adc	r11, r29
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f89e:	ff e1       	ldi	r31, 0x1F	; 31
    f8a0:	4f 2e       	mov	r4, r31
    f8a2:	51 2c       	mov	r5, r1
    f8a4:	4c 0e       	add	r4, r28
    f8a6:	5d 1e       	adc	r5, r29
	 RemZeroLead(strPumpID);
	 iPumpID=atoi(strPumpID);  
	 
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
    f8a8:	d7 01       	movw	r26, r14
    f8aa:	1c 97       	sbiw	r26, 0x0c	; 12
    f8ac:	f4 01       	movw	r30, r8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f8ae:	8d 91       	ld	r24, X+
    f8b0:	81 93       	st	Z+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f8b2:	e2 15       	cp	r30, r2
    f8b4:	f3 05       	cpc	r31, r3
    f8b6:	d9 f7       	brne	.-10     	; 0xf8ae <StoreStandaloneTotalizerData+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f8b8:	18 8a       	std	Y+16, r1	; 0x10
    f8ba:	f5 01       	movw	r30, r10
    f8bc:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f8be:	8d 91       	ld	r24, X+
    f8c0:	81 93       	st	Z+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f8c2:	e4 15       	cp	r30, r4
    f8c4:	f5 05       	cpc	r31, r5
    f8c6:	d9 f7       	brne	.-10     	; 0xf8be <StoreStandaloneTotalizerData+0xac>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f8c8:	1f 8e       	std	Y+31, r1	; 0x1f

		 for (iGrade=1;iGrade<=6;iGrade++){          
			  StrPosCopy(strRawTransData,strGVolume,(4+((iGrade-1)*24)),12);
			  StrPosCopy(strRawTransData,strGMoney,(16+((iGrade-1)*24)),12);
			  
			  SetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strGVolume);
    f8ca:	80 e0       	ldi	r24, 0x00	; 0
    f8cc:	61 e0       	ldi	r22, 0x01	; 1
    f8ce:	47 2d       	mov	r20, r7
    f8d0:	2d 2d       	mov	r18, r13
    f8d2:	84 01       	movw	r16, r8
    f8d4:	0e 94 74 43 	call	0x86e8	; 0x86e8 <SetTotalizerData>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
    f8d8:	81 e0       	ldi	r24, 0x01	; 1
    f8da:	61 e0       	ldi	r22, 0x01	; 1
    f8dc:	47 2d       	mov	r20, r7
    f8de:	2d 2d       	mov	r18, r13
    f8e0:	85 01       	movw	r16, r10
    f8e2:	0e 94 74 43 	call	0x86e8	; 0x86e8 <SetTotalizerData>
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
		 //_uart_printf(1,1,PSTR("Totalizer:"));

		 for (iGrade=1;iGrade<=6;iGrade++){          
    f8e6:	d3 94       	inc	r13
    f8e8:	e8 e1       	ldi	r30, 0x18	; 24
    f8ea:	f0 e0       	ldi	r31, 0x00	; 0
    f8ec:	ee 0e       	add	r14, r30
    f8ee:	ff 1e       	adc	r15, r31
    f8f0:	f7 e0       	ldi	r31, 0x07	; 7
    f8f2:	df 16       	cp	r13, r31
    f8f4:	c9 f6       	brne	.-78     	; 0xf8a8 <StoreStandaloneTotalizerData+0x96>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
			  //sprintf_P(strSend,PSTR("Nozzle:%d Volume:%s Money:%s"),iGrade,strGVolume,strGMoney);
			  //_uart_print(0,1,strSend);
		 }	
	}
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
    f8f6:	8d e0       	ldi	r24, 0x0D	; 13
    f8f8:	6c 2d       	mov	r22, r12
    f8fa:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
    f8fe:	8c 2d       	mov	r24, r12
    f900:	8f 70       	andi	r24, 0x0F	; 15
    f902:	64 e1       	ldi	r22, 0x14	; 20
    f904:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <UpdateStandaloneStatus>
}
    f908:	a1 96       	adiw	r28, 0x21	; 33
    f90a:	0f b6       	in	r0, 0x3f	; 63
    f90c:	f8 94       	cli
    f90e:	de bf       	out	0x3e, r29	; 62
    f910:	0f be       	out	0x3f, r0	; 63
    f912:	cd bf       	out	0x3d, r28	; 61
    f914:	cf 91       	pop	r28
    f916:	df 91       	pop	r29
    f918:	1f 91       	pop	r17
    f91a:	0f 91       	pop	r16
    f91c:	ff 90       	pop	r15
    f91e:	ef 90       	pop	r14
    f920:	df 90       	pop	r13
    f922:	cf 90       	pop	r12
    f924:	bf 90       	pop	r11
    f926:	af 90       	pop	r10
    f928:	9f 90       	pop	r9
    f92a:	8f 90       	pop	r8
    f92c:	7f 90       	pop	r7
    f92e:	5f 90       	pop	r5
    f930:	4f 90       	pop	r4
    f932:	3f 90       	pop	r3
    f934:	2f 90       	pop	r2
    f936:	08 95       	ret

0000f938 <ScanStandaloneFlow>:
	 _spi(SlaveMessage);
	 _spi(0x06);
	 systemSlave();
}

void ScanStandaloneFlow(char data){  //<STX>[PumpID][STA]<ETX> --> 0x07 0xF1 0xF2 0x08
    f938:	0f 93       	push	r16
    f93a:	1f 93       	push	r17
    f93c:	08 2f       	mov	r16, r24

      DataPumpID=0;
      DataPumpStatus=0;
	  MixData=0;
      //Shift data
      zDataFlow[4]=zDataFlow[3];
    f93e:	80 91 d2 03 	lds	r24, 0x03D2
    f942:	80 93 d3 03 	sts	0x03D3, r24
	  zDataFlow[3]=zDataFlow[2];
    f946:	80 91 d1 03 	lds	r24, 0x03D1
    f94a:	80 93 d2 03 	sts	0x03D2, r24
	  zDataFlow[2]=zDataFlow[1];
    f94e:	80 91 d0 03 	lds	r24, 0x03D0
    f952:	80 93 d1 03 	sts	0x03D1, r24
      zDataFlow[1]=zDataFlow[0];
    f956:	90 91 cf 03 	lds	r25, 0x03CF
    f95a:	90 93 d0 03 	sts	0x03D0, r25
      zDataFlow[0]=data;
    f95e:	00 93 cf 03 	sts	0x03CF, r16

      //Scan UpdatedPumpStatus Flow
	  //<STX>[ID][STA]<ETX>: 0x07[ID STA]0x08
	  if((zDataFlow[2]==0x07)&&(zDataFlow[0]==0x08)){
    f962:	87 30       	cpi	r24, 0x07	; 7
    f964:	79 f4       	brne	.+30     	; 0xf984 <ScanStandaloneFlow+0x4c>
    f966:	08 30       	cpi	r16, 0x08	; 8
    f968:	69 f4       	brne	.+26     	; 0xf984 <ScanStandaloneFlow+0x4c>
          MixData=zDataFlow[1];
	      DataPumpID=((MixData&0xF0)>>4);
		  DataPumpStatus=(MixData&0x0F);
    f96a:	19 2f       	mov	r17, r25
    f96c:	1f 70       	andi	r17, 0x0F	; 15
		  UpdateStandaloneStatus(DataPumpID,DataPumpStatus);
    f96e:	89 2f       	mov	r24, r25
    f970:	82 95       	swap	r24
    f972:	8f 70       	andi	r24, 0x0F	; 15
    f974:	61 2f       	mov	r22, r17
    f976:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <UpdateStandaloneStatus>
		  if (DataPumpStatus!=PUMP_NONE)IsStandAloneDetected=True;
    f97a:	1e 30       	cpi	r17, 0x0E	; 14
    f97c:	19 f0       	breq	.+6      	; 0xf984 <ScanStandaloneFlow+0x4c>
    f97e:	81 e0       	ldi	r24, 0x01	; 1
    f980:	80 93 c8 01 	sts	0x01C8, r24
		  //sprintf_P(strSend,PSTR("PS:%d Id:%d"),MixData,DataPumpID);
		  //_uart_print(0,1,strSend);
	  }

	  //Scan Transaction Completion FEOT
	  if (IsStandaloneTrans==True){
    f984:	80 91 c9 01 	lds	r24, 0x01C9
    f988:	81 30       	cpi	r24, 0x01	; 1
    f98a:	69 f4       	brne	.+26     	; 0xf9a6 <ScanStandaloneFlow+0x6e>
	      strStandReceived[iFlow]=data;
    f98c:	80 91 cd 03 	lds	r24, 0x03CD
    f990:	90 91 ce 03 	lds	r25, 0x03CE
    f994:	fc 01       	movw	r30, r24
    f996:	e4 5f       	subi	r30, 0xF4	; 244
    f998:	fa 4f       	sbci	r31, 0xFA	; 250
    f99a:	00 83       	st	Z, r16
		  iFlow++;
    f99c:	01 96       	adiw	r24, 0x01	; 1
    f99e:	90 93 ce 03 	sts	0x03CE, r25
    f9a2:	80 93 cd 03 	sts	0x03CD, r24
	  }
	  if((zDataFlow[1]==0x05)&&(zDataFlow[0]==0x50)){
    f9a6:	80 91 d0 03 	lds	r24, 0x03D0
    f9aa:	85 30       	cpi	r24, 0x05	; 5
    f9ac:	61 f4       	brne	.+24     	; 0xf9c6 <ScanStandaloneFlow+0x8e>
    f9ae:	80 91 cf 03 	lds	r24, 0x03CF
    f9b2:	80 35       	cpi	r24, 0x50	; 80
    f9b4:	41 f5       	brne	.+80     	; 0xfa06 <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=True;
    f9b6:	81 e0       	ldi	r24, 0x01	; 1
    f9b8:	80 93 c9 01 	sts	0x01C9, r24
		  iFlow=0;
    f9bc:	10 92 ce 03 	sts	0x03CE, r1
    f9c0:	10 92 cd 03 	sts	0x03CD, r1
    f9c4:	20 c0       	rjmp	.+64     	; 0xfa06 <ScanStandaloneFlow+0xce>
	  }
	  if((zDataFlow[1]==0x06)&&(zDataFlow[0]==0x60)){
    f9c6:	86 30       	cpi	r24, 0x06	; 6
    f9c8:	f1 f4       	brne	.+60     	; 0xfa06 <ScanStandaloneFlow+0xce>
    f9ca:	80 91 cf 03 	lds	r24, 0x03CF
    f9ce:	80 36       	cpi	r24, 0x60	; 96
    f9d0:	d1 f4       	brne	.+52     	; 0xfa06 <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=False;
    f9d2:	10 92 c9 01 	sts	0x01C9, r1
	      strStandReceived[iFlow]=0;
    f9d6:	e0 91 cd 03 	lds	r30, 0x03CD
    f9da:	f0 91 ce 03 	lds	r31, 0x03CE
    f9de:	e4 5f       	subi	r30, 0xF4	; 244
    f9e0:	fa 4f       	sbci	r31, 0xFA	; 250
    f9e2:	10 82       	st	Z, r1

		  //_uart_print(1,1,strStandReceived);

		  MsgIDx=GetMessageID(strStandReceived);
    f9e4:	8c e0       	ldi	r24, 0x0C	; 12
    f9e6:	95 e0       	ldi	r25, 0x05	; 5
    f9e8:	0e 94 7c 3f 	call	0x7ef8	; 0x7ef8 <GetMessageID>
          if (MsgIDx==0x01)StoreStandaloneTransData(strStandReceived);
    f9ec:	81 30       	cpi	r24, 0x01	; 1
    f9ee:	29 f4       	brne	.+10     	; 0xf9fa <ScanStandaloneFlow+0xc2>
    f9f0:	8c e0       	ldi	r24, 0x0C	; 12
    f9f2:	95 e0       	ldi	r25, 0x05	; 5
    f9f4:	0e 94 a2 79 	call	0xf344	; 0xf344 <StoreStandaloneTransData>
    f9f8:	06 c0       	rjmp	.+12     	; 0xfa06 <ScanStandaloneFlow+0xce>
		  else
          if (MsgIDx==0x02)StoreStandaloneTotalizerData(strStandReceived);
    f9fa:	82 30       	cpi	r24, 0x02	; 2
    f9fc:	21 f4       	brne	.+8      	; 0xfa06 <ScanStandaloneFlow+0xce>
    f9fe:	8c e0       	ldi	r24, 0x0C	; 12
    fa00:	95 e0       	ldi	r25, 0x05	; 5
    fa02:	0e 94 09 7c 	call	0xf812	; 0xf812 <StoreStandaloneTotalizerData>
	  }
	  //AcknoledgeCommand
	  if ((zDataFlow[3]==0x09)&&(zDataFlow[0]==0x0A)){
    fa06:	80 91 d2 03 	lds	r24, 0x03D2
    fa0a:	89 30       	cpi	r24, 0x09	; 9
    fa0c:	c1 f5       	brne	.+112    	; 0xfa7e <ScanStandaloneFlow+0x146>
    fa0e:	80 91 cf 03 	lds	r24, 0x03CF
    fa12:	8a 30       	cpi	r24, 0x0A	; 10
    fa14:	a1 f5       	brne	.+104    	; 0xfa7e <ScanStandaloneFlow+0x146>
	      
	      AcknoledgePump=zDataFlow[1];
    fa16:	90 91 d0 03 	lds	r25, 0x03D0
    fa1a:	90 93 f7 0d 	sts	0x0DF7, r25
	      AcknoledgeCommand=zDataFlow[2];	  
    fa1e:	80 91 d1 03 	lds	r24, 0x03D1
    fa22:	80 93 ac 07 	sts	0x07AC, r24
		  switch(AcknoledgeCommand){
    fa26:	89 31       	cpi	r24, 0x19	; 25
    fa28:	51 f0       	breq	.+20     	; 0xfa3e <ScanStandaloneFlow+0x106>
    fa2a:	8a 31       	cpi	r24, 0x1A	; 26
    fa2c:	18 f4       	brcc	.+6      	; 0xfa34 <ScanStandaloneFlow+0xfc>
    fa2e:	85 30       	cpi	r24, 0x05	; 5
    fa30:	19 f5       	brne	.+70     	; 0xfa78 <ScanStandaloneFlow+0x140>
    fa32:	17 c0       	rjmp	.+46     	; 0xfa62 <ScanStandaloneFlow+0x12a>
    fa34:	8a 31       	cpi	r24, 0x1A	; 26
    fa36:	c9 f0       	breq	.+50     	; 0xfa6a <ScanStandaloneFlow+0x132>
    fa38:	8c 31       	cpi	r24, 0x1C	; 28
    fa3a:	f1 f4       	brne	.+60     	; 0xfa78 <ScanStandaloneFlow+0x140>
    fa3c:	1a c0       	rjmp	.+52     	; 0xfa72 <ScanStandaloneFlow+0x13a>
		  case SC_LIVE_SEQUENCE:
		       iSequencePooling=AcknoledgePump;
    fa3e:	90 93 a9 01 	sts	0x01A9, r25
			   IsNewPoolingSequence=True;
    fa42:	81 e0       	ldi	r24, 0x01	; 1
    fa44:	80 93 aa 01 	sts	0x01AA, r24
			   //SendPoolingCommand()
			   if (IsControlPooling==True){
    fa48:	80 91 ad 01 	lds	r24, 0x01AD
    fa4c:	81 30       	cpi	r24, 0x01	; 1
    fa4e:	a1 f4       	brne	.+40     	; 0xfa78 <ScanStandaloneFlow+0x140>
			       IsControlPooling=False;
    fa50:	10 92 ad 01 	sts	0x01AD, r1
				   SendSlaveCommand(PoolCmd,PoolMsg);
    fa54:	80 91 b6 07 	lds	r24, 0x07B6
    fa58:	60 91 de 0d 	lds	r22, 0x0DDE
    fa5c:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
    fa60:	0b c0       	rjmp	.+22     	; 0xfa78 <ScanStandaloneFlow+0x140>
                }
		       break;
          case SC_TOTALIZER:
		       IsTotalizerReceived=True;
    fa62:	81 e0       	ldi	r24, 0x01	; 1
    fa64:	80 93 db 01 	sts	0x01DB, r24
    fa68:	07 c0       	rjmp	.+14     	; 0xfa78 <ScanStandaloneFlow+0x140>
		       break;
		  case SC_POOL_RESTARTED:
		       IsPoolingRestarted=True;
    fa6a:	81 e0       	ldi	r24, 0x01	; 1
    fa6c:	80 93 ac 01 	sts	0x01AC, r24
    fa70:	03 c0       	rjmp	.+6      	; 0xfa78 <ScanStandaloneFlow+0x140>
		       break;
          case SC_SET_PUMP_TYPE:
		       IsSetPumpType=True;
    fa72:	81 e0       	ldi	r24, 0x01	; 1
    fa74:	80 93 38 01 	sts	0x0138, r24
		       break;
		  }
       IsStandaloneAcknoledge=True;
    fa78:	81 e0       	ldi	r24, 0x01	; 1
    fa7a:	80 93 ab 01 	sts	0x01AB, r24
	  }
}
    fa7e:	1f 91       	pop	r17
    fa80:	0f 91       	pop	r16
    fa82:	08 95       	ret

0000fa84 <__vector_17>:
//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  _uart_print(1,0,SerialSend);
	 }
}

ISR(SPI_STC_vect){
    fa84:	1f 92       	push	r1
    fa86:	0f 92       	push	r0
    fa88:	0f b6       	in	r0, 0x3f	; 63
    fa8a:	0f 92       	push	r0
    fa8c:	0b b6       	in	r0, 0x3b	; 59
    fa8e:	0f 92       	push	r0
    fa90:	11 24       	eor	r1, r1
    fa92:	1f 93       	push	r17
    fa94:	2f 93       	push	r18
    fa96:	3f 93       	push	r19
    fa98:	4f 93       	push	r20
    fa9a:	5f 93       	push	r21
    fa9c:	6f 93       	push	r22
    fa9e:	7f 93       	push	r23
    faa0:	8f 93       	push	r24
    faa2:	9f 93       	push	r25
    faa4:	af 93       	push	r26
    faa6:	bf 93       	push	r27
    faa8:	ef 93       	push	r30
    faaa:	ff 93       	push	r31
char dataSPI;
char Reply=0;
    //_uart(0,1,SPDR);
	dataSPI=SPDR;
    faac:	1f b1       	in	r17, 0x0f	; 15
	ScanRFIDFlow(dataSPI);
    faae:	81 2f       	mov	r24, r17
    fab0:	0e 94 bf 13 	call	0x277e	; 0x277e <ScanRFIDFlow>
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
    fab4:	80 91 25 01 	lds	r24, 0x0125
    fab8:	81 30       	cpi	r24, 0x01	; 1
    faba:	21 f4       	brne	.+8      	; 0xfac4 <__vector_17+0x40>
    fabc:	81 2f       	mov	r24, r17
    fabe:	0e 94 fd 12 	call	0x25fa	; 0x25fa <ScanEDCFlow>
    fac2:	05 c0       	rjmp	.+10     	; 0xface <__vector_17+0x4a>
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
    fac4:	82 30       	cpi	r24, 0x02	; 2
    fac6:	19 f4       	brne	.+6      	; 0xface <__vector_17+0x4a>
    fac8:	81 2f       	mov	r24, r17
    faca:	0e 94 9c 7c 	call	0xf938	; 0xf938 <ScanStandaloneFlow>
}
    face:	ff 91       	pop	r31
    fad0:	ef 91       	pop	r30
    fad2:	bf 91       	pop	r27
    fad4:	af 91       	pop	r26
    fad6:	9f 91       	pop	r25
    fad8:	8f 91       	pop	r24
    fada:	7f 91       	pop	r23
    fadc:	6f 91       	pop	r22
    fade:	5f 91       	pop	r21
    fae0:	4f 91       	pop	r20
    fae2:	3f 91       	pop	r19
    fae4:	2f 91       	pop	r18
    fae6:	1f 91       	pop	r17
    fae8:	0f 90       	pop	r0
    faea:	0b be       	out	0x3b, r0	; 59
    faec:	0f 90       	pop	r0
    faee:	0f be       	out	0x3f, r0	; 63
    faf0:	0f 90       	pop	r0
    faf2:	1f 90       	pop	r1
    faf4:	18 95       	reti

0000faf6 <UserInput>:
void ShowMessage(char *Message){//Display Message on Line3
     char i;
}


char UserInput(char TypeUI,char xPos, char yPos,char *strResult, unsigned int MaxValue, char MaxLength){
    faf6:	af 92       	push	r10
    faf8:	bf 92       	push	r11
    fafa:	cf 92       	push	r12
    fafc:	df 92       	push	r13
    fafe:	ef 92       	push	r14
    fb00:	ff 92       	push	r15
    fb02:	0f 93       	push	r16
    fb04:	1f 93       	push	r17
    fb06:	cf 93       	push	r28
    fb08:	df 93       	push	r29
    fb0a:	f8 2e       	mov	r15, r24
    fb0c:	e9 01       	movw	r28, r18
    fb0e:	68 01       	movw	r12, r16
    fb10:	ae 2c       	mov	r10, r14
	 static char iHit=0,KeyByte=0,IsShifted=False,IsSameKey=False,IsNextKey=False,IsNewKey=False,IsFirst=False;
	 static unsigned int iLoop=0,TimerPressed=0,KeyTimeout,NewKeyTimeout;
	        unsigned int NumbValue=0;
	 char KeyPressed=0,KeyChar=0,iDisp=0;
     Result=USER_NONE;
	 switch(stUserInput){// 100 ->199 500 90
    fb12:	10 91 86 03 	lds	r17, 0x0386
    fb16:	12 30       	cpi	r17, 0x02	; 2
    fb18:	09 f4       	brne	.+2      	; 0xfb1c <UserInput+0x26>
    fb1a:	ec c1       	rjmp	.+984    	; 0xfef4 <UserInput+0x3fe>
    fb1c:	13 30       	cpi	r17, 0x03	; 3
    fb1e:	30 f4       	brcc	.+12     	; 0xfb2c <UserInput+0x36>
    fb20:	11 23       	and	r17, r17
    fb22:	59 f0       	breq	.+22     	; 0xfb3a <UserInput+0x44>
    fb24:	11 30       	cpi	r17, 0x01	; 1
    fb26:	09 f0       	breq	.+2      	; 0xfb2a <UserInput+0x34>
    fb28:	90 c2       	rjmp	.+1312   	; 0x1004a <UserInput+0x554>
    fb2a:	2c c0       	rjmp	.+88     	; 0xfb84 <UserInput+0x8e>
    fb2c:	13 30       	cpi	r17, 0x03	; 3
    fb2e:	09 f4       	brne	.+2      	; 0xfb32 <UserInput+0x3c>
    fb30:	26 c2       	rjmp	.+1100   	; 0xff7e <UserInput+0x488>
    fb32:	14 30       	cpi	r17, 0x04	; 4
    fb34:	09 f0       	breq	.+2      	; 0xfb38 <UserInput+0x42>
    fb36:	89 c2       	rjmp	.+1298   	; 0x1004a <UserInput+0x554>
    fb38:	8a c2       	rjmp	.+1300   	; 0x1004e <UserInput+0x558>
	 case uiInit:
	      iLoop=0;
    fb3a:	10 92 78 03 	sts	0x0378, r1
    fb3e:	10 92 77 03 	sts	0x0377, r1
		  stUserInput=uiInput;
		  xChar=xPos;yChar=yPos;
    fb42:	60 93 85 03 	sts	0x0385, r22
    fb46:	40 93 84 03 	sts	0x0384, r20
          iValuePos=0;
    fb4a:	10 92 83 03 	sts	0x0383, r1
		  KeyTimeout=0;
    fb4e:	10 92 76 03 	sts	0x0376, r1
    fb52:	10 92 75 03 	sts	0x0375, r1
		  IsSameKey=False;
    fb56:	10 92 7c 03 	sts	0x037C, r1
		  IsNextKey=False;
    fb5a:	10 92 7b 03 	sts	0x037B, r1
		  IsNewKey=False;
    fb5e:	10 92 7a 03 	sts	0x037A, r1
		  IsShifted=True;
    fb62:	91 e0       	ldi	r25, 0x01	; 1
    fb64:	90 93 7d 03 	sts	0x037D, r25
		  zKeyChar=' ';
    fb68:	80 e2       	ldi	r24, 0x20	; 32
    fb6a:	80 93 82 03 	sts	0x0382, r24
		  iHit=0;
    fb6e:	10 92 7e 03 	sts	0x037E, r1
		  IsFirst=False;
    fb72:	10 92 79 03 	sts	0x0379, r1
		  IsDelete=False;
    fb76:	10 92 7f 03 	sts	0x037F, r1
		  Result=USER_NO_DATA;
		  stUserInput=uiInput;
    fb7a:	90 93 86 03 	sts	0x0386, r25
    fb7e:	95 e0       	ldi	r25, 0x05	; 5
    fb80:	e9 2e       	mov	r14, r25
    fb82:	69 c2       	rjmp	.+1234   	; 0x10056 <UserInput+0x560>
	      break;
	 case uiInput:
	      KeyPressed=_key_scan(1);                  //  _  ABC DEF GHI JKL MNO PQRS TUV WXYZ
    fb84:	81 e0       	ldi	r24, 0x01	; 1
    fb86:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
    fb8a:	b8 2e       	mov	r11, r24
		  KeyChar= _key_btn(KeyPressed);            //  1   2   3   4   5   6   7    8   9
    fb8c:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
    fb90:	e8 2e       	mov	r14, r24
		  if (KeyPressed==_KEY_SHIFT){
    fb92:	2b e7       	ldi	r18, 0x7B	; 123
    fb94:	b2 16       	cp	r11, r18
    fb96:	59 f4       	brne	.+22     	; 0xfbae <UserInput+0xb8>
		      if (IsShifted==False)IsShifted=True;
    fb98:	80 91 7d 03 	lds	r24, 0x037D
    fb9c:	88 23       	and	r24, r24
    fb9e:	19 f4       	brne	.+6      	; 0xfba6 <UserInput+0xb0>
    fba0:	10 93 7d 03 	sts	0x037D, r17
    fba4:	04 c0       	rjmp	.+8      	; 0xfbae <UserInput+0xb8>
			  else
		      if (IsShifted==True)IsShifted=False;
    fba6:	81 30       	cpi	r24, 0x01	; 1
    fba8:	11 f4       	brne	.+4      	; 0xfbae <UserInput+0xb8>
    fbaa:	10 92 7d 03 	sts	0x037D, r1
			  }
          
		  if (IsSameKey==True){
    fbae:	80 91 7c 03 	lds	r24, 0x037C
    fbb2:	81 30       	cpi	r24, 0x01	; 1
    fbb4:	e9 f4       	brne	.+58     	; 0xfbf0 <UserInput+0xfa>
		      KeyTimeout++;
    fbb6:	80 91 75 03 	lds	r24, 0x0375
    fbba:	90 91 76 03 	lds	r25, 0x0376
    fbbe:	01 96       	adiw	r24, 0x01	; 1
    fbc0:	90 93 76 03 	sts	0x0376, r25
    fbc4:	80 93 75 03 	sts	0x0375, r24
              if (KeyTimeout>1000){
    fbc8:	89 5e       	subi	r24, 0xE9	; 233
    fbca:	93 40       	sbci	r25, 0x03	; 3
    fbcc:	88 f0       	brcs	.+34     	; 0xfbf0 <UserInput+0xfa>
			      if (TypeUI==UI_ALPHANUM_PASSWORD)lcd_put(xChar,yChar,'*');
    fbce:	f5 e0       	ldi	r31, 0x05	; 5
    fbd0:	ff 16       	cp	r15, r31
    fbd2:	39 f4       	brne	.+14     	; 0xfbe2 <UserInput+0xec>
    fbd4:	80 91 85 03 	lds	r24, 0x0385
    fbd8:	60 91 84 03 	lds	r22, 0x0384
    fbdc:	4a e2       	ldi	r20, 0x2A	; 42
    fbde:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>

		          IsNextKey=True;
    fbe2:	81 e0       	ldi	r24, 0x01	; 1
    fbe4:	80 93 7b 03 	sts	0x037B, r24
				  iLoop=0;
    fbe8:	10 92 78 03 	sts	0x0378, r1
    fbec:	10 92 77 03 	sts	0x0377, r1
			     }
              }
 
 		  if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<=MaxLength))||(IsNextKey==True)){
    fbf0:	8e 2d       	mov	r24, r14
    fbf2:	80 53       	subi	r24, 0x30	; 48
    fbf4:	8a 30       	cpi	r24, 0x0A	; 10
    fbf6:	20 f4       	brcc	.+8      	; 0xfc00 <UserInput+0x10a>
    fbf8:	80 91 83 03 	lds	r24, 0x0383
    fbfc:	a8 16       	cp	r10, r24
    fbfe:	40 f4       	brcc	.+16     	; 0xfc10 <UserInput+0x11a>
    fc00:	80 91 7b 03 	lds	r24, 0x037B
    fc04:	81 30       	cpi	r24, 0x01	; 1
    fc06:	21 f0       	breq	.+8      	; 0xfc10 <UserInput+0x11a>
    fc08:	ee 24       	eor	r14, r14
    fc0a:	00 e0       	ldi	r16, 0x00	; 0
    fc0c:	10 e0       	ldi	r17, 0x00	; 0
    fc0e:	be c0       	rjmp	.+380    	; 0xfd8c <UserInput+0x296>
    fc10:	84 e2       	ldi	r24, 0x24	; 36
    fc12:	94 ef       	ldi	r25, 0xF4	; 244
    fc14:	01 97       	sbiw	r24, 0x01	; 1
    fc16:	f1 f7       	brne	.-4      	; 0xfc14 <UserInput+0x11e>
		       _delay_ms(250);
		       strResult[iValuePos]=KeyChar;
    fc18:	80 91 83 03 	lds	r24, 0x0383
    fc1c:	fe 01       	movw	r30, r28
    fc1e:	e8 0f       	add	r30, r24
    fc20:	f1 1d       	adc	r31, r1
    fc22:	e0 82       	st	Z, r14
		       strResult[iValuePos+1]=0;
    fc24:	11 82       	std	Z+1, r1	; 0x01

			   if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)) 
    fc26:	8f 2d       	mov	r24, r15
    fc28:	81 50       	subi	r24, 0x01	; 1
    fc2a:	82 30       	cpi	r24, 0x02	; 2
    fc2c:	30 f0       	brcs	.+12     	; 0xfc3a <UserInput+0x144>
    fc2e:	24 e0       	ldi	r18, 0x04	; 4
    fc30:	f2 16       	cp	r15, r18
    fc32:	19 f0       	breq	.+6      	; 0xfc3a <UserInput+0x144>
    fc34:	00 e0       	ldi	r16, 0x00	; 0
    fc36:	10 e0       	ldi	r17, 0x00	; 0
    fc38:	04 c0       	rjmp	.+8      	; 0xfc42 <UserInput+0x14c>
			        NumbValue=atoi(strResult);
    fc3a:	ce 01       	movw	r24, r28
    fc3c:	0e 94 6e b4 	call	0x168dc	; 0x168dc <atoi>
    fc40:	8c 01       	movw	r16, r24
			   else NumbValue=0;
				
			   if ((TypeUI==UI_ALPHANUM_R)||(TypeUI==UI_ALPHANUM_PASSWORD)){
    fc42:	83 e0       	ldi	r24, 0x03	; 3
    fc44:	f8 16       	cp	r15, r24
    fc46:	21 f0       	breq	.+8      	; 0xfc50 <UserInput+0x15a>
    fc48:	e5 e0       	ldi	r30, 0x05	; 5
    fc4a:	fe 16       	cp	r15, r30
    fc4c:	09 f0       	breq	.+2      	; 0xfc50 <UserInput+0x15a>
    fc4e:	63 c0       	rjmp	.+198    	; 0xfd16 <UserInput+0x220>
			       if (KeyChar!=zKeyChar){
    fc50:	80 91 82 03 	lds	r24, 0x0382
    fc54:	e8 16       	cp	r14, r24
    fc56:	71 f0       	breq	.+28     	; 0xfc74 <UserInput+0x17e>
					   IsSameKey=False;
    fc58:	10 92 7c 03 	sts	0x037C, r1
					   IsNewKey=True;
    fc5c:	81 e0       	ldi	r24, 0x01	; 1
    fc5e:	80 93 7a 03 	sts	0x037A, r24
				       iHit=0;
    fc62:	10 92 7e 03 	sts	0x037E, r1
					   iLoop=1000;
    fc66:	88 ee       	ldi	r24, 0xE8	; 232
    fc68:	93 e0       	ldi	r25, 0x03	; 3
    fc6a:	90 93 78 03 	sts	0x0378, r25
    fc6e:	80 93 77 03 	sts	0x0377, r24
    fc72:	51 c0       	rjmp	.+162    	; 0xfd16 <UserInput+0x220>
				   }
                   else{
				   if (IsNewKey==True){
    fc74:	80 91 7a 03 	lds	r24, 0x037A
    fc78:	81 30       	cpi	r24, 0x01	; 1
    fc7a:	71 f4       	brne	.+28     	; 0xfc98 <UserInput+0x1a2>
					   IsNewKey=False;
    fc7c:	10 92 7a 03 	sts	0x037A, r1
					   yChar--;
    fc80:	80 91 84 03 	lds	r24, 0x0384
    fc84:	81 50       	subi	r24, 0x01	; 1
    fc86:	80 93 84 03 	sts	0x0384, r24
					   if (iValuePos>0) iValuePos--;
    fc8a:	80 91 83 03 	lds	r24, 0x0383
    fc8e:	88 23       	and	r24, r24
    fc90:	19 f0       	breq	.+6      	; 0xfc98 <UserInput+0x1a2>
    fc92:	81 50       	subi	r24, 0x01	; 1
    fc94:	80 93 83 03 	sts	0x0383, r24
					   }
				   KeyTimeout=0;
    fc98:	10 92 76 03 	sts	0x0376, r1
    fc9c:	10 92 75 03 	sts	0x0375, r1
				   IsSameKey=True;
    fca0:	81 e0       	ldi	r24, 0x01	; 1
    fca2:	80 93 7c 03 	sts	0x037C, r24
				   if (iHit<pgm_read_byte(&MaxKeyHit[(zKeyChar-'0')])) iHit++;
    fca6:	80 91 7e 03 	lds	r24, 0x037E
    fcaa:	e0 91 82 03 	lds	r30, 0x0382
    fcae:	f0 e0       	ldi	r31, 0x00	; 0
    fcb0:	ee 5a       	subi	r30, 0xAE	; 174
    fcb2:	fc 4f       	sbci	r31, 0xFC	; 252
    fcb4:	e4 91       	lpm	r30, Z+
    fcb6:	8e 17       	cp	r24, r30
    fcb8:	20 f4       	brcc	.+8      	; 0xfcc2 <UserInput+0x1cc>
    fcba:	8f 5f       	subi	r24, 0xFF	; 255
    fcbc:	80 93 7e 03 	sts	0x037E, r24
    fcc0:	02 c0       	rjmp	.+4      	; 0xfcc6 <UserInput+0x1d0>
                   else iHit=0;
    fcc2:	10 92 7e 03 	sts	0x037E, r1
				   iLoop=1000;
    fcc6:	88 ee       	ldi	r24, 0xE8	; 232
    fcc8:	93 e0       	ldi	r25, 0x03	; 3
    fcca:	90 93 78 03 	sts	0x0378, r25
    fcce:	80 93 77 03 	sts	0x0377, r24

                   zAlphaChar=AlphaChar;
    fcd2:	80 91 80 03 	lds	r24, 0x0380
    fcd6:	80 93 81 03 	sts	0x0381, r24
			       AlphaChar=_table_alphanum(IsShifted,KeyPressed,iHit);			   
    fcda:	80 91 7d 03 	lds	r24, 0x037D
    fcde:	6b 2d       	mov	r22, r11
    fce0:	40 91 7e 03 	lds	r20, 0x037E
    fce4:	0e 94 f8 ac 	call	0x159f0	; 0x159f0 <_table_alphanum>
    fce8:	80 93 80 03 	sts	0x0380, r24
                   
				   if (IsNextKey==True){
    fcec:	80 91 7b 03 	lds	r24, 0x037B
    fcf0:	81 30       	cpi	r24, 0x01	; 1
    fcf2:	41 f4       	brne	.+16     	; 0xfd04 <UserInput+0x20e>
                       AlphaChar=zAlphaChar;       
    fcf4:	80 91 81 03 	lds	r24, 0x0381
    fcf8:	80 93 80 03 	sts	0x0380, r24
					   IsNextKey=False;
    fcfc:	10 92 7b 03 	sts	0x037B, r1
					   IsSameKey=False;
    fd00:	10 92 7c 03 	sts	0x037C, r1
				   }   
				   strResult[iValuePos]=AlphaChar;
    fd04:	80 91 83 03 	lds	r24, 0x0383
    fd08:	fe 01       	movw	r30, r28
    fd0a:	e8 0f       	add	r30, r24
    fd0c:	f1 1d       	adc	r31, r1
    fd0e:	80 91 80 03 	lds	r24, 0x0380
    fd12:	80 83       	st	Z, r24
		           strResult[iValuePos+1]=0;
    fd14:	11 82       	std	Z+1, r1	; 0x01
				 }//endElse 
				 
			   }//EndAlphaNum

			 if (TypeUI==UI_NUMBER_L){
    fd16:	f2 e0       	ldi	r31, 0x02	; 2
    fd18:	ff 16       	cp	r15, r31
    fd1a:	71 f4       	brne	.+28     	; 0xfd38 <UserInput+0x242>
			    if ((NumbValue<=MaxValue)||(MaxValue==0)){
    fd1c:	c0 16       	cp	r12, r16
    fd1e:	d1 06       	cpc	r13, r17
    fd20:	18 f4       	brcc	.+6      	; 0xfd28 <UserInput+0x232>
    fd22:	c1 14       	cp	r12, r1
    fd24:	d1 04       	cpc	r13, r1
    fd26:	71 f5       	brne	.+92     	; 0xfd84 <UserInput+0x28e>
				     iValuePos++;
    fd28:	80 91 83 03 	lds	r24, 0x0383
    fd2c:	8f 5f       	subi	r24, 0xFF	; 255
    fd2e:	80 93 83 03 	sts	0x0383, r24
					 stUserInput=uiInputDisp;
    fd32:	83 e0       	ldi	r24, 0x03	; 3
    fd34:	80 93 86 03 	sts	0x0386, r24
				} 
			 }
  
			   if ((NumbValue<=MaxValue)||(MaxValue==0)){
    fd38:	c0 16       	cp	r12, r16
    fd3a:	d1 06       	cpc	r13, r17
    fd3c:	18 f4       	brcc	.+6      	; 0xfd44 <UserInput+0x24e>
    fd3e:	c1 14       	cp	r12, r1
    fd40:	d1 04       	cpc	r13, r1
    fd42:	01 f5       	brne	.+64     	; 0xfd84 <UserInput+0x28e>
			       if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    fd44:	21 e0       	ldi	r18, 0x01	; 1
    fd46:	f2 16       	cp	r15, r18
    fd48:	49 f0       	breq	.+18     	; 0xfd5c <UserInput+0x266>
    fd4a:	83 e0       	ldi	r24, 0x03	; 3
    fd4c:	f8 16       	cp	r15, r24
    fd4e:	31 f0       	breq	.+12     	; 0xfd5c <UserInput+0x266>
    fd50:	e4 e0       	ldi	r30, 0x04	; 4
    fd52:	fe 16       	cp	r15, r30
    fd54:	19 f0       	breq	.+6      	; 0xfd5c <UserInput+0x266>
    fd56:	f5 e0       	ldi	r31, 0x05	; 5
    fd58:	ff 16       	cp	r15, r31
    fd5a:	a1 f4       	brne	.+40     	; 0xfd84 <UserInput+0x28e>
				       (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
				      if (IsSameKey==False){
    fd5c:	80 91 7c 03 	lds	r24, 0x037C
    fd60:	88 23       	and	r24, r24
    fd62:	69 f4       	brne	.+26     	; 0xfd7e <UserInput+0x288>
					      IsFirst=True;
    fd64:	81 e0       	ldi	r24, 0x01	; 1
    fd66:	80 93 79 03 	sts	0x0379, r24
					      iValuePos++;
    fd6a:	80 91 83 03 	lds	r24, 0x0383
    fd6e:	8f 5f       	subi	r24, 0xFF	; 255
    fd70:	80 93 83 03 	sts	0x0383, r24
					      yChar++;
    fd74:	80 91 84 03 	lds	r24, 0x0384
    fd78:	8f 5f       	subi	r24, 0xFF	; 255
    fd7a:	80 93 84 03 	sts	0x0384, r24
						  }
                  stUserInput=uiInputDisp;
    fd7e:	83 e0       	ldi	r24, 0x03	; 3
    fd80:	80 93 86 03 	sts	0x0386, r24
				  }
			   }
              zKeyChar=KeyChar;
    fd84:	e0 92 82 03 	sts	0x0382, r14
    fd88:	84 e0       	ldi	r24, 0x04	; 4
    fd8a:	e8 2e       	mov	r14, r24
             Result=USER_ENTRY;
             }//EndKeyChar
			 
                 
              if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)){
    fd8c:	2f 2d       	mov	r18, r15
    fd8e:	21 50       	subi	r18, 0x01	; 1
    fd90:	22 30       	cpi	r18, 0x02	; 2
    fd92:	18 f0       	brcs	.+6      	; 0xfd9a <UserInput+0x2a4>
    fd94:	84 e0       	ldi	r24, 0x04	; 4
    fd96:	f8 16       	cp	r15, r24
    fd98:	89 f4       	brne	.+34     	; 0xfdbc <UserInput+0x2c6>
                   if((NumbValue>MaxValue)||(iValuePos==MaxLength)){
    fd9a:	c0 16       	cp	r12, r16
    fd9c:	d1 06       	cpc	r13, r17
    fd9e:	20 f0       	brcs	.+8      	; 0xfda8 <UserInput+0x2b2>
    fda0:	80 91 83 03 	lds	r24, 0x0383
    fda4:	8a 15       	cp	r24, r10
    fda6:	51 f4       	brne	.+20     	; 0xfdbc <UserInput+0x2c6>
			           if (MaxValue>0)system_beep(1);
    fda8:	cd 28       	or	r12, r13
    fdaa:	41 f0       	breq	.+16     	; 0xfdbc <UserInput+0x2c6>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    fdac:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    fdae:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    fdb0:	81 e0       	ldi	r24, 0x01	; 1
    fdb2:	90 e0       	ldi	r25, 0x00	; 0
    fdb4:	90 93 ec 01 	sts	0x01EC, r25
    fdb8:	80 93 eb 01 	sts	0x01EB, r24
			           if (MaxValue>0)system_beep(1);
				   }
                 }
		  
		  //CANCEL OK
		  if (KeyPressed==_KEY_CANCEL){
    fdbc:	e7 ee       	ldi	r30, 0xE7	; 231
    fdbe:	be 16       	cp	r11, r30
    fdc0:	71 f4       	brne	.+28     	; 0xfdde <UserInput+0x2e8>
		      if (iValuePos>0){
    fdc2:	80 91 83 03 	lds	r24, 0x0383
    fdc6:	88 23       	and	r24, r24
    fdc8:	41 f0       	breq	.+16     	; 0xfdda <UserInput+0x2e4>
			      iLoop=1999;
    fdca:	8f ec       	ldi	r24, 0xCF	; 207
    fdcc:	97 e0       	ldi	r25, 0x07	; 7
    fdce:	90 93 78 03 	sts	0x0378, r25
    fdd2:	80 93 77 03 	sts	0x0377, r24
				  stUserInput=uiClearDisplay;
    fdd6:	82 e0       	ldi	r24, 0x02	; 2
    fdd8:	26 c0       	rjmp	.+76     	; 0xfe26 <UserInput+0x330>
				  }
			  else{
			      UserInputResult=USER_CANCEL;
    fdda:	81 e0       	ldi	r24, 0x01	; 1
    fddc:	21 c0       	rjmp	.+66     	; 0xfe20 <UserInput+0x32a>
			      stUserInput=uiFinished;
				  }
		  }
		  else {
		  if (KeyPressed==_KEY_ENTER){
    fdde:	f7 eb       	ldi	r31, 0xB7	; 183
    fde0:	bf 16       	cp	r11, r31
    fde2:	19 f5       	brne	.+70     	; 0xfe2a <UserInput+0x334>
		      strResult[iValuePos]=0;
    fde4:	80 91 83 03 	lds	r24, 0x0383
    fde8:	fe 01       	movw	r30, r28
    fdea:	e8 0f       	add	r30, r24
    fdec:	f1 1d       	adc	r31, r1
    fdee:	10 82       	st	Z, r1
			  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)){
    fdf0:	22 30       	cpi	r18, 0x02	; 2
    fdf2:	a8 f4       	brcc	.+42     	; 0xfe1e <UserInput+0x328>
			       if (iValuePos==0)sprintf_P(strResult,PSTR("0"));
    fdf4:	88 23       	and	r24, r24
    fdf6:	81 f4       	brne	.+32     	; 0xfe18 <UserInput+0x322>
    fdf8:	00 d0       	rcall	.+0      	; 0xfdfa <UserInput+0x304>
    fdfa:	00 d0       	rcall	.+0      	; 0xfdfc <UserInput+0x306>
    fdfc:	ed b7       	in	r30, 0x3d	; 61
    fdfe:	fe b7       	in	r31, 0x3e	; 62
    fe00:	d2 83       	std	Z+2, r29	; 0x02
    fe02:	c1 83       	std	Z+1, r28	; 0x01
    fe04:	83 e3       	ldi	r24, 0x33	; 51
    fe06:	9b e1       	ldi	r25, 0x1B	; 27
    fe08:	94 83       	std	Z+4, r25	; 0x04
    fe0a:	83 83       	std	Z+3, r24	; 0x03
    fe0c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
    fe10:	0f 90       	pop	r0
    fe12:	0f 90       	pop	r0
    fe14:	0f 90       	pop	r0
    fe16:	0f 90       	pop	r0
			       RemZeroLead(strResult);
    fe18:	ce 01       	movw	r24, r28
    fe1a:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
				  }
		      UserInputResult=USER_OK;
    fe1e:	83 e0       	ldi	r24, 0x03	; 3
    fe20:	80 93 87 03 	sts	0x0387, r24
		      stUserInput=uiFinished;
    fe24:	84 e0       	ldi	r24, 0x04	; 4
    fe26:	80 93 86 03 	sts	0x0386, r24
			  }
		  }//EndElse

		  if ((iLoop%2000)==0){
    fe2a:	80 91 77 03 	lds	r24, 0x0377
    fe2e:	90 91 78 03 	lds	r25, 0x0378
    fe32:	60 ed       	ldi	r22, 0xD0	; 208
    fe34:	77 e0       	ldi	r23, 0x07	; 7
    fe36:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
    fe3a:	89 2b       	or	r24, r25
    fe3c:	59 f5       	brne	.+86     	; 0xfe94 <UserInput+0x39e>
		      if (IsSameKey==True)lcd_put(xChar,yChar,AlphaChar); 
    fe3e:	80 91 7c 03 	lds	r24, 0x037C
    fe42:	81 30       	cpi	r24, 0x01	; 1
    fe44:	49 f4       	brne	.+18     	; 0xfe58 <UserInput+0x362>
    fe46:	80 91 85 03 	lds	r24, 0x0385
    fe4a:	60 91 84 03 	lds	r22, 0x0384
    fe4e:	40 91 80 03 	lds	r20, 0x0380
    fe52:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
    fe56:	1e c0       	rjmp	.+60     	; 0xfe94 <UserInput+0x39e>
			  else {
			      if((TypeUI==UI_ALPHANUM_PASSWORD)&&(iValuePos>0))lcd_put(xChar,yChar-1,'*'); 
    fe58:	f5 e0       	ldi	r31, 0x05	; 5
    fe5a:	ff 16       	cp	r15, r31
    fe5c:	61 f4       	brne	.+24     	; 0xfe76 <UserInput+0x380>
    fe5e:	80 91 83 03 	lds	r24, 0x0383
    fe62:	88 23       	and	r24, r24
    fe64:	41 f0       	breq	.+16     	; 0xfe76 <UserInput+0x380>
    fe66:	60 91 84 03 	lds	r22, 0x0384
    fe6a:	61 50       	subi	r22, 0x01	; 1
    fe6c:	80 91 85 03 	lds	r24, 0x0385
    fe70:	4a e2       	ldi	r20, 0x2A	; 42
    fe72:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
			      lcd_put(xChar,yChar,'_'); 
    fe76:	80 91 85 03 	lds	r24, 0x0385
    fe7a:	60 91 84 03 	lds	r22, 0x0384
    fe7e:	4f e5       	ldi	r20, 0x5F	; 95
    fe80:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
				  if (IsFirst==True){
    fe84:	80 91 79 03 	lds	r24, 0x0379
    fe88:	81 30       	cpi	r24, 0x01	; 1
    fe8a:	21 f4       	brne	.+8      	; 0xfe94 <UserInput+0x39e>
				      IsFirst=False;
    fe8c:	10 92 79 03 	sts	0x0379, r1
				      zKeyChar=0;
    fe90:	10 92 82 03 	sts	0x0382, r1
					  }
				  }
			  }
          if ((iLoop%2000)==1000){
    fe94:	80 91 77 03 	lds	r24, 0x0377
    fe98:	90 91 78 03 	lds	r25, 0x0378
    fe9c:	60 ed       	ldi	r22, 0xD0	; 208
    fe9e:	77 e0       	ldi	r23, 0x07	; 7
    fea0:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
    fea4:	88 5e       	subi	r24, 0xE8	; 232
    fea6:	93 40       	sbci	r25, 0x03	; 3
    fea8:	d9 f4       	brne	.+54     	; 0xfee0 <UserInput+0x3ea>
		      if (IsSameKey==True){
    feaa:	80 91 7c 03 	lds	r24, 0x037C
    feae:	81 30       	cpi	r24, 0x01	; 1
    feb0:	81 f4       	brne	.+32     	; 0xfed2 <UserInput+0x3dc>
			      if (TypeUI!=UI_NUM_PASSWORD)
    feb2:	84 e0       	ldi	r24, 0x04	; 4
    feb4:	f8 16       	cp	r15, r24
    feb6:	39 f0       	breq	.+14     	; 0xfec6 <UserInput+0x3d0>
				       lcd_put(xChar,yChar,AlphaChar); 
    feb8:	80 91 85 03 	lds	r24, 0x0385
    febc:	60 91 84 03 	lds	r22, 0x0384
    fec0:	40 91 80 03 	lds	r20, 0x0380
    fec4:	0b c0       	rjmp	.+22     	; 0xfedc <UserInput+0x3e6>
				  else lcd_put(xChar,yChar,'*'); 
    fec6:	80 91 85 03 	lds	r24, 0x0385
    feca:	60 91 84 03 	lds	r22, 0x0384
    fece:	4a e2       	ldi	r20, 0x2A	; 42
    fed0:	05 c0       	rjmp	.+10     	; 0xfedc <UserInput+0x3e6>
			  }
			  else lcd_put(xChar,yChar,' '); 
    fed2:	80 91 85 03 	lds	r24, 0x0385
    fed6:	60 91 84 03 	lds	r22, 0x0384
    feda:	40 e2       	ldi	r20, 0x20	; 32
    fedc:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
			  }
          iLoop++;
    fee0:	80 91 77 03 	lds	r24, 0x0377
    fee4:	90 91 78 03 	lds	r25, 0x0378
    fee8:	01 96       	adiw	r24, 0x01	; 1
    feea:	90 93 78 03 	sts	0x0378, r25
    feee:	80 93 77 03 	sts	0x0377, r24
    fef2:	b1 c0       	rjmp	.+354    	; 0x10056 <UserInput+0x560>
          break;
     case uiClearDisplay:
          if (TypeUI==UI_NUMBER_L){
    fef4:	e2 e0       	ldi	r30, 0x02	; 2
    fef6:	8e 17       	cp	r24, r30
    fef8:	99 f4       	brne	.+38     	; 0xff20 <UserInput+0x42a>
		      lcd_put(xChar,(yChar-iValuePos),' '); // 123_ 1_
    fefa:	60 91 84 03 	lds	r22, 0x0384
    fefe:	80 91 83 03 	lds	r24, 0x0383
    ff02:	68 1b       	sub	r22, r24
    ff04:	80 91 85 03 	lds	r24, 0x0385
    ff08:	40 e2       	ldi	r20, 0x20	; 32
    ff0a:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
		      strResult[iValuePos]=0;
    ff0e:	80 91 83 03 	lds	r24, 0x0383
    ff12:	c8 0f       	add	r28, r24
    ff14:	d1 1d       	adc	r29, r1
    ff16:	18 82       	st	Y, r1
		      iValuePos--;
    ff18:	81 50       	subi	r24, 0x01	; 1
    ff1a:	80 93 83 03 	sts	0x0383, r24
    ff1e:	23 c0       	rjmp	.+70     	; 0xff66 <UserInput+0x470>
			  }
          else
		  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    ff20:	f1 e0       	ldi	r31, 0x01	; 1
    ff22:	8f 17       	cp	r24, r31
    ff24:	49 f0       	breq	.+18     	; 0xff38 <UserInput+0x442>
    ff26:	23 e0       	ldi	r18, 0x03	; 3
    ff28:	82 17       	cp	r24, r18
    ff2a:	31 f0       	breq	.+12     	; 0xff38 <UserInput+0x442>
    ff2c:	84 e0       	ldi	r24, 0x04	; 4
    ff2e:	f8 16       	cp	r15, r24
    ff30:	19 f0       	breq	.+6      	; 0xff38 <UserInput+0x442>
    ff32:	e5 e0       	ldi	r30, 0x05	; 5
    ff34:	fe 16       	cp	r15, r30
    ff36:	b9 f4       	brne	.+46     	; 0xff66 <UserInput+0x470>
		      (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
		      lcd_put(xChar,yChar,' '); // 123_ 1_
    ff38:	80 91 85 03 	lds	r24, 0x0385
    ff3c:	60 91 84 03 	lds	r22, 0x0384
    ff40:	40 e2       	ldi	r20, 0x20	; 32
    ff42:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
		      strResult[iValuePos]=0;
    ff46:	80 91 83 03 	lds	r24, 0x0383
    ff4a:	c8 0f       	add	r28, r24
    ff4c:	d1 1d       	adc	r29, r1
    ff4e:	18 82       	st	Y, r1
		      iValuePos--;
    ff50:	81 50       	subi	r24, 0x01	; 1
    ff52:	80 93 83 03 	sts	0x0383, r24
			  yChar--;
    ff56:	80 91 84 03 	lds	r24, 0x0384
    ff5a:	81 50       	subi	r24, 0x01	; 1
    ff5c:	80 93 84 03 	sts	0x0384, r24
			  IsDelete=True;
    ff60:	81 e0       	ldi	r24, 0x01	; 1
    ff62:	80 93 7f 03 	sts	0x037F, r24
		  }
		  if (iValuePos==0)Result=USER_NO_DATA;
    ff66:	80 91 83 03 	lds	r24, 0x0383
    ff6a:	88 23       	and	r24, r24
    ff6c:	19 f4       	brne	.+6      	; 0xff74 <UserInput+0x47e>
    ff6e:	05 e0       	ldi	r16, 0x05	; 5
    ff70:	e0 2e       	mov	r14, r16
    ff72:	01 c0       	rjmp	.+2      	; 0xff76 <UserInput+0x480>
    ff74:	ee 24       	eor	r14, r14
		  stUserInput=uiInputDisp;//Redraw
    ff76:	83 e0       	ldi	r24, 0x03	; 3
    ff78:	80 93 86 03 	sts	0x0386, r24
    ff7c:	6c c0       	rjmp	.+216    	; 0x10056 <UserInput+0x560>
	      break;      
     case uiInputDisp:
	      if(TypeUI==UI_ALPHANUM_PASSWORD){
    ff7e:	f5 e0       	ldi	r31, 0x05	; 5
    ff80:	8f 17       	cp	r24, r31
    ff82:	09 f5       	brne	.+66     	; 0xffc6 <UserInput+0x4d0>
			  if (iValuePos>0){
    ff84:	80 91 83 03 	lds	r24, 0x0383
    ff88:	88 23       	and	r24, r24
    ff8a:	a1 f0       	breq	.+40     	; 0xffb4 <UserInput+0x4be>
                  lcd_put(xChar,(yChar-2),'*');
    ff8c:	60 91 84 03 	lds	r22, 0x0384
    ff90:	62 50       	subi	r22, 0x02	; 2
    ff92:	80 91 85 03 	lds	r24, 0x0385
    ff96:	4a e2       	ldi	r20, 0x2A	; 42
    ff98:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
			      if (IsDelete==True){
    ff9c:	80 91 7f 03 	lds	r24, 0x037F
    ffa0:	60 91 84 03 	lds	r22, 0x0384
    ffa4:	81 30       	cpi	r24, 0x01	; 1
    ffa6:	61 f0       	breq	.+24     	; 0xffc0 <UserInput+0x4ca>
				      IsDelete=False;
			          lcd_put(xChar,(yChar-1),'*');
			          }
				  else lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
    ffa8:	61 50       	subi	r22, 0x01	; 1
    ffaa:	80 91 83 03 	lds	r24, 0x0383
    ffae:	c8 0f       	add	r28, r24
    ffb0:	d1 1d       	adc	r29, r1
    ffb2:	2f c0       	rjmp	.+94     	; 0x10012 <UserInput+0x51c>
			      }
			  else{ if(IsDelete==True){
    ffb4:	80 91 7f 03 	lds	r24, 0x037F
    ffb8:	60 91 84 03 	lds	r22, 0x0384
    ffbc:	81 30       	cpi	r24, 0x01	; 1
    ffbe:	91 f5       	brne	.+100    	; 0x10024 <UserInput+0x52e>
			           IsDelete=False;
    ffc0:	10 92 7f 03 	sts	0x037F, r1
    ffc4:	39 c0       	rjmp	.+114    	; 0x10038 <UserInput+0x542>
					   lcd_put(xChar,(yChar-1),'*');
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
    ffc6:	22 e0       	ldi	r18, 0x02	; 2
    ffc8:	82 17       	cp	r24, r18
    ffca:	a1 f4       	brne	.+40     	; 0xfff4 <UserInput+0x4fe>
    ffcc:	10 e0       	ldi	r17, 0x00	; 0
    ffce:	0d c0       	rjmp	.+26     	; 0xffea <UserInput+0x4f4>
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
			      lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
    ffd0:	60 91 84 03 	lds	r22, 0x0384
    ffd4:	68 1b       	sub	r22, r24
    ffd6:	61 0f       	add	r22, r17
    ffd8:	fe 01       	movw	r30, r28
    ffda:	e1 0f       	add	r30, r17
    ffdc:	f1 1d       	adc	r31, r1
    ffde:	80 91 85 03 	lds	r24, 0x0385
    ffe2:	40 81       	ld	r20, Z
    ffe4:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
    ffe8:	1f 5f       	subi	r17, 0xFF	; 255
    ffea:	80 91 83 03 	lds	r24, 0x0383
    ffee:	18 17       	cp	r17, r24
    fff0:	78 f3       	brcs	.-34     	; 0xffd0 <UserInput+0x4da>
    fff2:	28 c0       	rjmp	.+80     	; 0x10044 <UserInput+0x54e>
			      lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
		      }
		  }else
	      if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)){
    fff4:	81 e0       	ldi	r24, 0x01	; 1
    fff6:	f8 16       	cp	r15, r24
    fff8:	19 f0       	breq	.+6      	; 0x10000 <UserInput+0x50a>
    fffa:	e3 e0       	ldi	r30, 0x03	; 3
    fffc:	fe 16       	cp	r15, r30
    fffe:	b9 f4       	brne	.+46     	; 0x1002e <UserInput+0x538>
		      
			  if (iValuePos>0) lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
   10000:	20 91 83 03 	lds	r18, 0x0383
   10004:	60 91 84 03 	lds	r22, 0x0384
   10008:	22 23       	and	r18, r18
   1000a:	29 f0       	breq	.+10     	; 0x10016 <UserInput+0x520>
   1000c:	61 50       	subi	r22, 0x01	; 1
   1000e:	c2 0f       	add	r28, r18
   10010:	d1 1d       	adc	r29, r1
   10012:	21 97       	sbiw	r28, 0x01	; 1
   10014:	08 c0       	rjmp	.+16     	; 0x10026 <UserInput+0x530>
			  else{ if ((yChar-1)>=yPos)lcd_put(xChar,(yChar-1),strResult[iValuePos]);
   10016:	26 2f       	mov	r18, r22
   10018:	30 e0       	ldi	r19, 0x00	; 0
   1001a:	84 2f       	mov	r24, r20
   1001c:	90 e0       	ldi	r25, 0x00	; 0
   1001e:	82 17       	cp	r24, r18
   10020:	93 07       	cpc	r25, r19
   10022:	84 f4       	brge	.+32     	; 0x10044 <UserInput+0x54e>
   10024:	61 50       	subi	r22, 0x01	; 1
   10026:	80 91 85 03 	lds	r24, 0x0385
   1002a:	48 81       	ld	r20, Y
   1002c:	09 c0       	rjmp	.+18     	; 0x10040 <UserInput+0x54a>
			  }
		  }else
		  //DisplayAsterik *
		  if (TypeUI==UI_NUM_PASSWORD){
   1002e:	f4 e0       	ldi	r31, 0x04	; 4
   10030:	ff 16       	cp	r15, r31
   10032:	41 f4       	brne	.+16     	; 0x10044 <UserInput+0x54e>
		      lcd_put(xChar,(yChar-1),'*');
   10034:	60 91 84 03 	lds	r22, 0x0384
   10038:	61 50       	subi	r22, 0x01	; 1
   1003a:	80 91 85 03 	lds	r24, 0x0385
   1003e:	4a e2       	ldi	r20, 0x2A	; 42
   10040:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
		  }


          stUserInput=uiInput;
   10044:	81 e0       	ldi	r24, 0x01	; 1
   10046:	80 93 86 03 	sts	0x0386, r24
   1004a:	ee 24       	eor	r14, r14
   1004c:	04 c0       	rjmp	.+8      	; 0x10056 <UserInput+0x560>
	      break;	 
     case uiFinished:
	      Result=UserInputResult;
   1004e:	e0 90 87 03 	lds	r14, 0x0387
	      stUserInput=uiInit;
   10052:	10 92 86 03 	sts	0x0386, r1
	      break;
	 }
	 return Result;
}
   10056:	8e 2d       	mov	r24, r14
   10058:	df 91       	pop	r29
   1005a:	cf 91       	pop	r28
   1005c:	1f 91       	pop	r17
   1005e:	0f 91       	pop	r16
   10060:	ff 90       	pop	r15
   10062:	ef 90       	pop	r14
   10064:	df 90       	pop	r13
   10066:	cf 90       	pop	r12
   10068:	bf 90       	pop	r11
   1006a:	af 90       	pop	r10
   1006c:	08 95       	ret

0001006e <TestUserInput>:
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//_uart_print(0,1,strSend);
}


char TestUserInput(){
   1006e:	6f 92       	push	r6
   10070:	7f 92       	push	r7
   10072:	8f 92       	push	r8
   10074:	9f 92       	push	r9
   10076:	af 92       	push	r10
   10078:	bf 92       	push	r11
   1007a:	cf 92       	push	r12
   1007c:	df 92       	push	r13
   1007e:	ef 92       	push	r14
   10080:	ff 92       	push	r15
   10082:	0f 93       	push	r16
   10084:	1f 93       	push	r17
   10086:	df 93       	push	r29
   10088:	cf 93       	push	r28
   1008a:	cd b7       	in	r28, 0x3d	; 61
   1008c:	de b7       	in	r29, 0x3e	; 62
   1008e:	ce 56       	subi	r28, 0x6E	; 110
   10090:	d0 40       	sbci	r29, 0x00	; 0
   10092:	0f b6       	in	r0, 0x3f	; 63
   10094:	f8 94       	cli
   10096:	de bf       	out	0x3e, r29	; 62
   10098:	0f be       	out	0x3f, r0	; 63
   1009a:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],strSend[30];
char SVolume[15],SMoney[15],STotalVolume[15],STotalMoney[15];
char Result;

char uiResult;
	uiResult=UserInput(UI_ALPHANUM_R,2,1,strNumber,0,10);
   1009c:	60 e1       	ldi	r22, 0x10	; 16
   1009e:	66 2e       	mov	r6, r22
   100a0:	62 e0       	ldi	r22, 0x02	; 2
   100a2:	76 2e       	mov	r7, r22
   100a4:	83 e0       	ldi	r24, 0x03	; 3
   100a6:	62 e0       	ldi	r22, 0x02	; 2
   100a8:	41 e0       	ldi	r20, 0x01	; 1
   100aa:	93 01       	movw	r18, r6
   100ac:	00 e0       	ldi	r16, 0x00	; 0
   100ae:	10 e0       	ldi	r17, 0x00	; 0
   100b0:	5a e0       	ldi	r21, 0x0A	; 10
   100b2:	e5 2e       	mov	r14, r21
   100b4:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
	Result=MENU_NONE;
    if (uiResult==USER_OK){
   100b8:	83 30       	cpi	r24, 0x03	; 3
   100ba:	09 f0       	breq	.+2      	; 0x100be <TestUserInput+0x50>
   100bc:	ed c1       	rjmp	.+986    	; 0x10498 <TestUserInput+0x42a>
	    sprintf_P(lcdteks,PSTR("Data:%s"),strNumber);
   100be:	00 d0       	rcall	.+0      	; 0x100c0 <TestUserInput+0x52>
   100c0:	00 d0       	rcall	.+0      	; 0x100c2 <TestUserInput+0x54>
   100c2:	00 d0       	rcall	.+0      	; 0x100c4 <TestUserInput+0x56>
   100c4:	ed b7       	in	r30, 0x3d	; 61
   100c6:	fe b7       	in	r31, 0x3e	; 62
   100c8:	31 96       	adiw	r30, 0x01	; 1
   100ca:	8e 01       	movw	r16, r28
   100cc:	03 5c       	subi	r16, 0xC3	; 195
   100ce:	1f 4f       	sbci	r17, 0xFF	; 255
   100d0:	ad b7       	in	r26, 0x3d	; 61
   100d2:	be b7       	in	r27, 0x3e	; 62
   100d4:	12 96       	adiw	r26, 0x02	; 2
   100d6:	1c 93       	st	X, r17
   100d8:	0e 93       	st	-X, r16
   100da:	11 97       	sbiw	r26, 0x01	; 1
   100dc:	81 e7       	ldi	r24, 0x71	; 113
   100de:	94 e0       	ldi	r25, 0x04	; 4
   100e0:	93 83       	std	Z+3, r25	; 0x03
   100e2:	82 83       	std	Z+2, r24	; 0x02
   100e4:	75 82       	std	Z+5, r7	; 0x05
   100e6:	64 82       	std	Z+4, r6	; 0x04
   100e8:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	   lcd_print(3,1,lcdteks);
   100ec:	8d b7       	in	r24, 0x3d	; 61
   100ee:	9e b7       	in	r25, 0x3e	; 62
   100f0:	06 96       	adiw	r24, 0x06	; 6
   100f2:	0f b6       	in	r0, 0x3f	; 63
   100f4:	f8 94       	cli
   100f6:	9e bf       	out	0x3e, r25	; 62
   100f8:	0f be       	out	0x3f, r0	; 63
   100fa:	8d bf       	out	0x3d, r24	; 61
   100fc:	83 e0       	ldi	r24, 0x03	; 3
   100fe:	61 e0       	ldi	r22, 0x01	; 1
   10100:	a8 01       	movw	r20, r16
   10102:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	   //FormatCurrency(strNumber);
	   //FormatMoney(strNumber);
	   //RemZeroLead(strNumber);
	   sprintf_P(SVolume,PSTR("%s"),strNumber);
   10106:	00 d0       	rcall	.+0      	; 0x10108 <TestUserInput+0x9a>
   10108:	00 d0       	rcall	.+0      	; 0x1010a <TestUserInput+0x9c>
   1010a:	00 d0       	rcall	.+0      	; 0x1010c <TestUserInput+0x9e>
   1010c:	ed b7       	in	r30, 0x3d	; 61
   1010e:	fe b7       	in	r31, 0x3e	; 62
   10110:	31 96       	adiw	r30, 0x01	; 1
   10112:	7e 01       	movw	r14, r28
   10114:	08 94       	sec
   10116:	e1 1c       	adc	r14, r1
   10118:	f1 1c       	adc	r15, r1
   1011a:	ad b7       	in	r26, 0x3d	; 61
   1011c:	be b7       	in	r27, 0x3e	; 62
   1011e:	12 96       	adiw	r26, 0x02	; 2
   10120:	fc 92       	st	X, r15
   10122:	ee 92       	st	-X, r14
   10124:	11 97       	sbiw	r26, 0x01	; 1
   10126:	8e e6       	ldi	r24, 0x6E	; 110
   10128:	94 e0       	ldi	r25, 0x04	; 4
   1012a:	93 83       	std	Z+3, r25	; 0x03
   1012c:	82 83       	std	Z+2, r24	; 0x02
   1012e:	75 82       	std	Z+5, r7	; 0x05
   10130:	64 82       	std	Z+4, r6	; 0x04
   10132:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	   sprintf_P(SMoney,PSTR("%s"),strNumber);
   10136:	ed b7       	in	r30, 0x3d	; 61
   10138:	fe b7       	in	r31, 0x3e	; 62
   1013a:	31 96       	adiw	r30, 0x01	; 1
   1013c:	40 e1       	ldi	r20, 0x10	; 16
   1013e:	a4 2e       	mov	r10, r20
   10140:	b1 2c       	mov	r11, r1
   10142:	ac 0e       	add	r10, r28
   10144:	bd 1e       	adc	r11, r29
   10146:	ad b7       	in	r26, 0x3d	; 61
   10148:	be b7       	in	r27, 0x3e	; 62
   1014a:	12 96       	adiw	r26, 0x02	; 2
   1014c:	bc 92       	st	X, r11
   1014e:	ae 92       	st	-X, r10
   10150:	11 97       	sbiw	r26, 0x01	; 1
   10152:	8b e6       	ldi	r24, 0x6B	; 107
   10154:	94 e0       	ldi	r25, 0x04	; 4
   10156:	93 83       	std	Z+3, r25	; 0x03
   10158:	82 83       	std	Z+2, r24	; 0x02
   1015a:	75 82       	std	Z+5, r7	; 0x05
   1015c:	64 82       	std	Z+4, r6	; 0x04
   1015e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	   sprintf_P(STotalVolume,PSTR("%s"),strNumber);
   10162:	ed b7       	in	r30, 0x3d	; 61
   10164:	fe b7       	in	r31, 0x3e	; 62
   10166:	31 96       	adiw	r30, 0x01	; 1
   10168:	3f e1       	ldi	r19, 0x1F	; 31
   1016a:	83 2e       	mov	r8, r19
   1016c:	91 2c       	mov	r9, r1
   1016e:	8c 0e       	add	r8, r28
   10170:	9d 1e       	adc	r9, r29
   10172:	ad b7       	in	r26, 0x3d	; 61
   10174:	be b7       	in	r27, 0x3e	; 62
   10176:	12 96       	adiw	r26, 0x02	; 2
   10178:	9c 92       	st	X, r9
   1017a:	8e 92       	st	-X, r8
   1017c:	11 97       	sbiw	r26, 0x01	; 1
   1017e:	88 e6       	ldi	r24, 0x68	; 104
   10180:	94 e0       	ldi	r25, 0x04	; 4
   10182:	93 83       	std	Z+3, r25	; 0x03
   10184:	82 83       	std	Z+2, r24	; 0x02
   10186:	75 82       	std	Z+5, r7	; 0x05
   10188:	64 82       	std	Z+4, r6	; 0x04
   1018a:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	   sprintf_P(STotalMoney,PSTR("%s"),strNumber);
   1018e:	ed b7       	in	r30, 0x3d	; 61
   10190:	fe b7       	in	r31, 0x3e	; 62
   10192:	31 96       	adiw	r30, 0x01	; 1
   10194:	2e e2       	ldi	r18, 0x2E	; 46
   10196:	c2 2e       	mov	r12, r18
   10198:	d1 2c       	mov	r13, r1
   1019a:	cc 0e       	add	r12, r28
   1019c:	dd 1e       	adc	r13, r29
   1019e:	ad b7       	in	r26, 0x3d	; 61
   101a0:	be b7       	in	r27, 0x3e	; 62
   101a2:	12 96       	adiw	r26, 0x02	; 2
   101a4:	dc 92       	st	X, r13
   101a6:	ce 92       	st	-X, r12
   101a8:	11 97       	sbiw	r26, 0x01	; 1
   101aa:	85 e6       	ldi	r24, 0x65	; 101
   101ac:	94 e0       	ldi	r25, 0x04	; 4
   101ae:	93 83       	std	Z+3, r25	; 0x03
   101b0:	82 83       	std	Z+2, r24	; 0x02
   101b2:	75 82       	std	Z+5, r7	; 0x05
   101b4:	64 82       	std	Z+4, r6	; 0x04
   101b6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>

	   sprintf_P(lcdteks,PSTR("Formated:%s"),strNumber);
   101ba:	ed b7       	in	r30, 0x3d	; 61
   101bc:	fe b7       	in	r31, 0x3e	; 62
   101be:	31 96       	adiw	r30, 0x01	; 1
   101c0:	ad b7       	in	r26, 0x3d	; 61
   101c2:	be b7       	in	r27, 0x3e	; 62
   101c4:	12 96       	adiw	r26, 0x02	; 2
   101c6:	1c 93       	st	X, r17
   101c8:	0e 93       	st	-X, r16
   101ca:	11 97       	sbiw	r26, 0x01	; 1
   101cc:	89 e5       	ldi	r24, 0x59	; 89
   101ce:	94 e0       	ldi	r25, 0x04	; 4
   101d0:	93 83       	std	Z+3, r25	; 0x03
   101d2:	82 83       	std	Z+2, r24	; 0x02
   101d4:	75 82       	std	Z+5, r7	; 0x05
   101d6:	64 82       	std	Z+4, r6	; 0x04
   101d8:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
       lcd_print(4,1,lcdteks);
   101dc:	8d b7       	in	r24, 0x3d	; 61
   101de:	9e b7       	in	r25, 0x3e	; 62
   101e0:	06 96       	adiw	r24, 0x06	; 6
   101e2:	0f b6       	in	r0, 0x3f	; 63
   101e4:	f8 94       	cli
   101e6:	9e bf       	out	0x3e, r25	; 62
   101e8:	0f be       	out	0x3f, r0	; 63
   101ea:	8d bf       	out	0x3d, r24	; 61
   101ec:	84 e0       	ldi	r24, 0x04	; 4
   101ee:	61 e0       	ldi	r22, 0x01	; 1
   101f0:	a8 01       	movw	r20, r16
   101f2:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	   sprintf_P(strSend,PSTR("Raw:%s"),strNumber);
   101f6:	00 d0       	rcall	.+0      	; 0x101f8 <TestUserInput+0x18a>
   101f8:	00 d0       	rcall	.+0      	; 0x101fa <TestUserInput+0x18c>
   101fa:	00 d0       	rcall	.+0      	; 0x101fc <TestUserInput+0x18e>
   101fc:	ed b7       	in	r30, 0x3d	; 61
   101fe:	fe b7       	in	r31, 0x3e	; 62
   10200:	31 96       	adiw	r30, 0x01	; 1
   10202:	8e 01       	movw	r16, r28
   10204:	0f 5a       	subi	r16, 0xAF	; 175
   10206:	1f 4f       	sbci	r17, 0xFF	; 255
   10208:	ad b7       	in	r26, 0x3d	; 61
   1020a:	be b7       	in	r27, 0x3e	; 62
   1020c:	12 96       	adiw	r26, 0x02	; 2
   1020e:	1c 93       	st	X, r17
   10210:	0e 93       	st	-X, r16
   10212:	11 97       	sbiw	r26, 0x01	; 1
   10214:	82 e5       	ldi	r24, 0x52	; 82
   10216:	94 e0       	ldi	r25, 0x04	; 4
   10218:	93 83       	std	Z+3, r25	; 0x03
   1021a:	82 83       	std	Z+2, r24	; 0x02
   1021c:	75 82       	std	Z+5, r7	; 0x05
   1021e:	64 82       	std	Z+4, r6	; 0x04
   10220:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	   _uart_print(0,1,strSend);
   10224:	8d b7       	in	r24, 0x3d	; 61
   10226:	9e b7       	in	r25, 0x3e	; 62
   10228:	06 96       	adiw	r24, 0x06	; 6
   1022a:	0f b6       	in	r0, 0x3f	; 63
   1022c:	f8 94       	cli
   1022e:	9e bf       	out	0x3e, r25	; 62
   10230:	0f be       	out	0x3f, r0	; 63
   10232:	8d bf       	out	0x3d, r24	; 61
   10234:	80 e0       	ldi	r24, 0x00	; 0
   10236:	61 e0       	ldi	r22, 0x01	; 1
   10238:	a8 01       	movw	r20, r16
   1023a:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>

	   RemoveMinus(strNumber);
   1023e:	c3 01       	movw	r24, r6
   10240:	0e 94 a3 20 	call	0x4146	; 0x4146 <RemoveMinus>

	   sprintf_P(strSend,PSTR("Minus:%s"),strNumber);
   10244:	00 d0       	rcall	.+0      	; 0x10246 <TestUserInput+0x1d8>
   10246:	00 d0       	rcall	.+0      	; 0x10248 <TestUserInput+0x1da>
   10248:	00 d0       	rcall	.+0      	; 0x1024a <TestUserInput+0x1dc>
   1024a:	ed b7       	in	r30, 0x3d	; 61
   1024c:	fe b7       	in	r31, 0x3e	; 62
   1024e:	31 96       	adiw	r30, 0x01	; 1
   10250:	ad b7       	in	r26, 0x3d	; 61
   10252:	be b7       	in	r27, 0x3e	; 62
   10254:	12 96       	adiw	r26, 0x02	; 2
   10256:	1c 93       	st	X, r17
   10258:	0e 93       	st	-X, r16
   1025a:	11 97       	sbiw	r26, 0x01	; 1
   1025c:	89 e4       	ldi	r24, 0x49	; 73
   1025e:	94 e0       	ldi	r25, 0x04	; 4
   10260:	93 83       	std	Z+3, r25	; 0x03
   10262:	82 83       	std	Z+2, r24	; 0x02
   10264:	75 82       	std	Z+5, r7	; 0x05
   10266:	64 82       	std	Z+4, r6	; 0x04
   10268:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	   _uart_print(0,1,strSend);
   1026c:	8d b7       	in	r24, 0x3d	; 61
   1026e:	9e b7       	in	r25, 0x3e	; 62
   10270:	06 96       	adiw	r24, 0x06	; 6
   10272:	0f b6       	in	r0, 0x3f	; 63
   10274:	f8 94       	cli
   10276:	9e bf       	out	0x3e, r25	; 62
   10278:	0f be       	out	0x3f, r0	; 63
   1027a:	8d bf       	out	0x3d, r24	; 61
   1027c:	80 e0       	ldi	r24, 0x00	; 0
   1027e:	61 e0       	ldi	r22, 0x01	; 1
   10280:	a8 01       	movw	r20, r16
   10282:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>

       
	   RemZeroLead(strNumber);
   10286:	c3 01       	movw	r24, r6
   10288:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
	   sprintf_P(strSend,PSTR("Removed:%s"),strNumber);
   1028c:	00 d0       	rcall	.+0      	; 0x1028e <TestUserInput+0x220>
   1028e:	00 d0       	rcall	.+0      	; 0x10290 <TestUserInput+0x222>
   10290:	00 d0       	rcall	.+0      	; 0x10292 <TestUserInput+0x224>
   10292:	ed b7       	in	r30, 0x3d	; 61
   10294:	fe b7       	in	r31, 0x3e	; 62
   10296:	31 96       	adiw	r30, 0x01	; 1
   10298:	ad b7       	in	r26, 0x3d	; 61
   1029a:	be b7       	in	r27, 0x3e	; 62
   1029c:	12 96       	adiw	r26, 0x02	; 2
   1029e:	1c 93       	st	X, r17
   102a0:	0e 93       	st	-X, r16
   102a2:	11 97       	sbiw	r26, 0x01	; 1
   102a4:	8e e3       	ldi	r24, 0x3E	; 62
   102a6:	94 e0       	ldi	r25, 0x04	; 4
   102a8:	93 83       	std	Z+3, r25	; 0x03
   102aa:	82 83       	std	Z+2, r24	; 0x02
   102ac:	75 82       	std	Z+5, r7	; 0x05
   102ae:	64 82       	std	Z+4, r6	; 0x04
   102b0:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	   _uart_print(0,1,strSend);
   102b4:	8d b7       	in	r24, 0x3d	; 61
   102b6:	9e b7       	in	r25, 0x3e	; 62
   102b8:	06 96       	adiw	r24, 0x06	; 6
   102ba:	0f b6       	in	r0, 0x3f	; 63
   102bc:	f8 94       	cli
   102be:	9e bf       	out	0x3e, r25	; 62
   102c0:	0f be       	out	0x3f, r0	; 63
   102c2:	8d bf       	out	0x3d, r24	; 61
   102c4:	80 e0       	ldi	r24, 0x00	; 0
   102c6:	61 e0       	ldi	r22, 0x01	; 1
   102c8:	a8 01       	movw	r20, r16
   102ca:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>

RemZeroLead(SVolume);
   102ce:	c7 01       	movw	r24, r14
   102d0:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
RemZeroLead(SMoney);
   102d4:	c5 01       	movw	r24, r10
   102d6:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
RemZeroLead(STotalVolume);
   102da:	c4 01       	movw	r24, r8
   102dc:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
RemZeroLead(STotalMoney);
   102e0:	c6 01       	movw	r24, r12
   102e2:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
       
	   
	   FormatVolume(SVolume); 
   102e6:	c7 01       	movw	r24, r14
   102e8:	0e 94 aa 30 	call	0x6154	; 0x6154 <FormatVolume>
	   FormatMoney(SMoney);
   102ec:	c5 01       	movw	r24, r10
   102ee:	0e 94 b7 30 	call	0x616e	; 0x616e <FormatMoney>
	   FormatTotalizerMoney(STotalVolume);
   102f2:	c4 01       	movw	r24, r8
   102f4:	0e 94 9d 30 	call	0x613a	; 0x613a <FormatTotalizerMoney>
	   FormatTotalizerVolume(STotalMoney);
   102f8:	c6 01       	movw	r24, r12
   102fa:	0e 94 90 30 	call	0x6120	; 0x6120 <FormatTotalizerVolume>

	   sprintf_P(strSend,PSTR("Volume:%s"),SVolume);
   102fe:	00 d0       	rcall	.+0      	; 0x10300 <TestUserInput+0x292>
   10300:	00 d0       	rcall	.+0      	; 0x10302 <TestUserInput+0x294>
   10302:	00 d0       	rcall	.+0      	; 0x10304 <TestUserInput+0x296>
   10304:	ed b7       	in	r30, 0x3d	; 61
   10306:	fe b7       	in	r31, 0x3e	; 62
   10308:	31 96       	adiw	r30, 0x01	; 1
   1030a:	ad b7       	in	r26, 0x3d	; 61
   1030c:	be b7       	in	r27, 0x3e	; 62
   1030e:	12 96       	adiw	r26, 0x02	; 2
   10310:	1c 93       	st	X, r17
   10312:	0e 93       	st	-X, r16
   10314:	11 97       	sbiw	r26, 0x01	; 1
   10316:	84 e3       	ldi	r24, 0x34	; 52
   10318:	94 e0       	ldi	r25, 0x04	; 4
   1031a:	93 83       	std	Z+3, r25	; 0x03
   1031c:	82 83       	std	Z+2, r24	; 0x02
   1031e:	f5 82       	std	Z+5, r15	; 0x05
   10320:	e4 82       	std	Z+4, r14	; 0x04
   10322:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	   _uart_print(0,1,strSend);
   10326:	8d b7       	in	r24, 0x3d	; 61
   10328:	9e b7       	in	r25, 0x3e	; 62
   1032a:	06 96       	adiw	r24, 0x06	; 6
   1032c:	0f b6       	in	r0, 0x3f	; 63
   1032e:	f8 94       	cli
   10330:	9e bf       	out	0x3e, r25	; 62
   10332:	0f be       	out	0x3f, r0	; 63
   10334:	8d bf       	out	0x3d, r24	; 61
   10336:	80 e0       	ldi	r24, 0x00	; 0
   10338:	61 e0       	ldi	r22, 0x01	; 1
   1033a:	a8 01       	movw	r20, r16
   1033c:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	   sprintf_P(strSend,PSTR("Money:%s"),SMoney);
   10340:	00 d0       	rcall	.+0      	; 0x10342 <TestUserInput+0x2d4>
   10342:	00 d0       	rcall	.+0      	; 0x10344 <TestUserInput+0x2d6>
   10344:	00 d0       	rcall	.+0      	; 0x10346 <TestUserInput+0x2d8>
   10346:	ed b7       	in	r30, 0x3d	; 61
   10348:	fe b7       	in	r31, 0x3e	; 62
   1034a:	31 96       	adiw	r30, 0x01	; 1
   1034c:	ad b7       	in	r26, 0x3d	; 61
   1034e:	be b7       	in	r27, 0x3e	; 62
   10350:	12 96       	adiw	r26, 0x02	; 2
   10352:	1c 93       	st	X, r17
   10354:	0e 93       	st	-X, r16
   10356:	11 97       	sbiw	r26, 0x01	; 1
   10358:	8b e2       	ldi	r24, 0x2B	; 43
   1035a:	94 e0       	ldi	r25, 0x04	; 4
   1035c:	93 83       	std	Z+3, r25	; 0x03
   1035e:	82 83       	std	Z+2, r24	; 0x02
   10360:	b5 82       	std	Z+5, r11	; 0x05
   10362:	a4 82       	std	Z+4, r10	; 0x04
   10364:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	   _uart_print(0,1,strSend);
   10368:	8d b7       	in	r24, 0x3d	; 61
   1036a:	9e b7       	in	r25, 0x3e	; 62
   1036c:	06 96       	adiw	r24, 0x06	; 6
   1036e:	0f b6       	in	r0, 0x3f	; 63
   10370:	f8 94       	cli
   10372:	9e bf       	out	0x3e, r25	; 62
   10374:	0f be       	out	0x3f, r0	; 63
   10376:	8d bf       	out	0x3d, r24	; 61
   10378:	80 e0       	ldi	r24, 0x00	; 0
   1037a:	61 e0       	ldi	r22, 0x01	; 1
   1037c:	a8 01       	movw	r20, r16
   1037e:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	   sprintf_P(strSend,PSTR("TVolume:%s"),STotalVolume);
   10382:	00 d0       	rcall	.+0      	; 0x10384 <TestUserInput+0x316>
   10384:	00 d0       	rcall	.+0      	; 0x10386 <TestUserInput+0x318>
   10386:	00 d0       	rcall	.+0      	; 0x10388 <TestUserInput+0x31a>
   10388:	ed b7       	in	r30, 0x3d	; 61
   1038a:	fe b7       	in	r31, 0x3e	; 62
   1038c:	31 96       	adiw	r30, 0x01	; 1
   1038e:	ad b7       	in	r26, 0x3d	; 61
   10390:	be b7       	in	r27, 0x3e	; 62
   10392:	12 96       	adiw	r26, 0x02	; 2
   10394:	1c 93       	st	X, r17
   10396:	0e 93       	st	-X, r16
   10398:	11 97       	sbiw	r26, 0x01	; 1
   1039a:	80 e2       	ldi	r24, 0x20	; 32
   1039c:	94 e0       	ldi	r25, 0x04	; 4
   1039e:	93 83       	std	Z+3, r25	; 0x03
   103a0:	82 83       	std	Z+2, r24	; 0x02
   103a2:	95 82       	std	Z+5, r9	; 0x05
   103a4:	84 82       	std	Z+4, r8	; 0x04
   103a6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	   _uart_print(0,1,strSend);
   103aa:	8d b7       	in	r24, 0x3d	; 61
   103ac:	9e b7       	in	r25, 0x3e	; 62
   103ae:	06 96       	adiw	r24, 0x06	; 6
   103b0:	0f b6       	in	r0, 0x3f	; 63
   103b2:	f8 94       	cli
   103b4:	9e bf       	out	0x3e, r25	; 62
   103b6:	0f be       	out	0x3f, r0	; 63
   103b8:	8d bf       	out	0x3d, r24	; 61
   103ba:	80 e0       	ldi	r24, 0x00	; 0
   103bc:	61 e0       	ldi	r22, 0x01	; 1
   103be:	a8 01       	movw	r20, r16
   103c0:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	   sprintf_P(strSend,PSTR("TMoney:%s"),STotalMoney);
   103c4:	00 d0       	rcall	.+0      	; 0x103c6 <TestUserInput+0x358>
   103c6:	00 d0       	rcall	.+0      	; 0x103c8 <TestUserInput+0x35a>
   103c8:	00 d0       	rcall	.+0      	; 0x103ca <TestUserInput+0x35c>
   103ca:	ed b7       	in	r30, 0x3d	; 61
   103cc:	fe b7       	in	r31, 0x3e	; 62
   103ce:	31 96       	adiw	r30, 0x01	; 1
   103d0:	ad b7       	in	r26, 0x3d	; 61
   103d2:	be b7       	in	r27, 0x3e	; 62
   103d4:	12 96       	adiw	r26, 0x02	; 2
   103d6:	1c 93       	st	X, r17
   103d8:	0e 93       	st	-X, r16
   103da:	11 97       	sbiw	r26, 0x01	; 1
   103dc:	86 e1       	ldi	r24, 0x16	; 22
   103de:	94 e0       	ldi	r25, 0x04	; 4
   103e0:	93 83       	std	Z+3, r25	; 0x03
   103e2:	82 83       	std	Z+2, r24	; 0x02
   103e4:	d5 82       	std	Z+5, r13	; 0x05
   103e6:	c4 82       	std	Z+4, r12	; 0x04
   103e8:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	   _uart_print(0,1,strSend);
   103ec:	8d b7       	in	r24, 0x3d	; 61
   103ee:	9e b7       	in	r25, 0x3e	; 62
   103f0:	06 96       	adiw	r24, 0x06	; 6
   103f2:	0f b6       	in	r0, 0x3f	; 63
   103f4:	f8 94       	cli
   103f6:	9e bf       	out	0x3e, r25	; 62
   103f8:	0f be       	out	0x3f, r0	; 63
   103fa:	8d bf       	out	0x3d, r24	; 61
   103fc:	80 e0       	ldi	r24, 0x00	; 0
   103fe:	61 e0       	ldi	r22, 0x01	; 1
   10400:	a8 01       	movw	r20, r16
   10402:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>

	   FormatCurrency(SMoney);
   10406:	c5 01       	movw	r24, r10
   10408:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>
	   FormatCurrency(STotalMoney);
   1040c:	c6 01       	movw	r24, r12
   1040e:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>
    
	   sprintf_P(strSend,PSTR("FmtMoney:%s"),SMoney);
   10412:	00 d0       	rcall	.+0      	; 0x10414 <TestUserInput+0x3a6>
   10414:	00 d0       	rcall	.+0      	; 0x10416 <TestUserInput+0x3a8>
   10416:	00 d0       	rcall	.+0      	; 0x10418 <TestUserInput+0x3aa>
   10418:	ed b7       	in	r30, 0x3d	; 61
   1041a:	fe b7       	in	r31, 0x3e	; 62
   1041c:	31 96       	adiw	r30, 0x01	; 1
   1041e:	ad b7       	in	r26, 0x3d	; 61
   10420:	be b7       	in	r27, 0x3e	; 62
   10422:	12 96       	adiw	r26, 0x02	; 2
   10424:	1c 93       	st	X, r17
   10426:	0e 93       	st	-X, r16
   10428:	11 97       	sbiw	r26, 0x01	; 1
   1042a:	8a e0       	ldi	r24, 0x0A	; 10
   1042c:	94 e0       	ldi	r25, 0x04	; 4
   1042e:	93 83       	std	Z+3, r25	; 0x03
   10430:	82 83       	std	Z+2, r24	; 0x02
   10432:	b5 82       	std	Z+5, r11	; 0x05
   10434:	a4 82       	std	Z+4, r10	; 0x04
   10436:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	   _uart_print(0,1,strSend);
   1043a:	8d b7       	in	r24, 0x3d	; 61
   1043c:	9e b7       	in	r25, 0x3e	; 62
   1043e:	06 96       	adiw	r24, 0x06	; 6
   10440:	0f b6       	in	r0, 0x3f	; 63
   10442:	f8 94       	cli
   10444:	9e bf       	out	0x3e, r25	; 62
   10446:	0f be       	out	0x3f, r0	; 63
   10448:	8d bf       	out	0x3d, r24	; 61
   1044a:	80 e0       	ldi	r24, 0x00	; 0
   1044c:	61 e0       	ldi	r22, 0x01	; 1
   1044e:	a8 01       	movw	r20, r16
   10450:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
	   sprintf_P(strSend,PSTR("FmtTMoney:%s"),STotalMoney);
   10454:	00 d0       	rcall	.+0      	; 0x10456 <TestUserInput+0x3e8>
   10456:	00 d0       	rcall	.+0      	; 0x10458 <TestUserInput+0x3ea>
   10458:	00 d0       	rcall	.+0      	; 0x1045a <TestUserInput+0x3ec>
   1045a:	ed b7       	in	r30, 0x3d	; 61
   1045c:	fe b7       	in	r31, 0x3e	; 62
   1045e:	31 96       	adiw	r30, 0x01	; 1
   10460:	ad b7       	in	r26, 0x3d	; 61
   10462:	be b7       	in	r27, 0x3e	; 62
   10464:	12 96       	adiw	r26, 0x02	; 2
   10466:	1c 93       	st	X, r17
   10468:	0e 93       	st	-X, r16
   1046a:	11 97       	sbiw	r26, 0x01	; 1
   1046c:	8d ef       	ldi	r24, 0xFD	; 253
   1046e:	93 e0       	ldi	r25, 0x03	; 3
   10470:	93 83       	std	Z+3, r25	; 0x03
   10472:	82 83       	std	Z+2, r24	; 0x02
   10474:	d5 82       	std	Z+5, r13	; 0x05
   10476:	c4 82       	std	Z+4, r12	; 0x04
   10478:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	   _uart_print(0,1,strSend);
   1047c:	8d b7       	in	r24, 0x3d	; 61
   1047e:	9e b7       	in	r25, 0x3e	; 62
   10480:	06 96       	adiw	r24, 0x06	; 6
   10482:	0f b6       	in	r0, 0x3f	; 63
   10484:	f8 94       	cli
   10486:	9e bf       	out	0x3e, r25	; 62
   10488:	0f be       	out	0x3f, r0	; 63
   1048a:	8d bf       	out	0x3d, r24	; 61
   1048c:	80 e0       	ldi	r24, 0x00	; 0
   1048e:	61 e0       	ldi	r22, 0x01	; 1
   10490:	a8 01       	movw	r20, r16
   10492:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
   10496:	02 c0       	rjmp	.+4      	; 0x1049c <TestUserInput+0x42e>


   	
	}else    
	if (uiResult==USER_CANCEL){
   10498:	81 30       	cpi	r24, 0x01	; 1
   1049a:	11 f0       	breq	.+4      	; 0x104a0 <TestUserInput+0x432>
   1049c:	80 e0       	ldi	r24, 0x00	; 0
   1049e:	0b c0       	rjmp	.+22     	; 0x104b6 <TestUserInput+0x448>
	   lcd_clear();
   104a0:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
   104a4:	fe 01       	movw	r30, r28
   104a6:	fd 96       	adiw	r30, 0x3d	; 61

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   104a8:	cf 01       	movw	r24, r30
   104aa:	0f 96       	adiw	r24, 0x0f	; 15
	     strMemory[i]=data;
   104ac:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   104ae:	e8 17       	cp	r30, r24
   104b0:	f9 07       	cpc	r31, r25
   104b2:	e1 f7       	brne	.-8      	; 0x104ac <TestUserInput+0x43e>
   104b4:	81 e0       	ldi	r24, 0x01	; 1
       Result=MENU_DONE;   
	   //lcd_printf(1,1,PSTR("InputNumber:"));
       //lcd_printf(2,1,PSTR("_         "));
	}
  return Result;
}
   104b6:	c2 59       	subi	r28, 0x92	; 146
   104b8:	df 4f       	sbci	r29, 0xFF	; 255
   104ba:	0f b6       	in	r0, 0x3f	; 63
   104bc:	f8 94       	cli
   104be:	de bf       	out	0x3e, r29	; 62
   104c0:	0f be       	out	0x3f, r0	; 63
   104c2:	cd bf       	out	0x3d, r28	; 61
   104c4:	cf 91       	pop	r28
   104c6:	df 91       	pop	r29
   104c8:	1f 91       	pop	r17
   104ca:	0f 91       	pop	r16
   104cc:	ff 90       	pop	r15
   104ce:	ef 90       	pop	r14
   104d0:	df 90       	pop	r13
   104d2:	cf 90       	pop	r12
   104d4:	bf 90       	pop	r11
   104d6:	af 90       	pop	r10
   104d8:	9f 90       	pop	r9
   104da:	8f 90       	pop	r8
   104dc:	7f 90       	pop	r7
   104de:	6f 90       	pop	r6
   104e0:	08 95       	ret

000104e2 <FSettingDec>:

	Result=MENU_DONE;
	return Result;
}

char FSettingDec(){
   104e2:	df 92       	push	r13
   104e4:	ef 92       	push	r14
   104e6:	ff 92       	push	r15
   104e8:	0f 93       	push	r16
   104ea:	1f 93       	push	r17
   104ec:	df 93       	push	r29
   104ee:	cf 93       	push	r28
   104f0:	cd b7       	in	r28, 0x3d	; 61
   104f2:	de b7       	in	r29, 0x3e	; 62
   104f4:	64 97       	sbiw	r28, 0x14	; 20
   104f6:	0f b6       	in	r0, 0x3f	; 63
   104f8:	f8 94       	cli
   104fa:	de bf       	out	0x3e, r29	; 62
   104fc:	0f be       	out	0x3f, r0	; 63
   104fe:	cd bf       	out	0x3d, r28	; 61
static char stSettingDecimal=sdInitDisplay;
     char PDecimalConfig[4],Addr,KeyChar,Result;
	 char lcdteks[20];

     Result=MENU_NONE;
	 switch(stSettingDecimal){
   10500:	80 91 fe 02 	lds	r24, 0x02FE
   10504:	82 30       	cpi	r24, 0x02	; 2
   10506:	09 f4       	brne	.+2      	; 0x1050a <FSettingDec+0x28>
   10508:	c7 c0       	rjmp	.+398    	; 0x10698 <FSettingDec+0x1b6>
   1050a:	83 30       	cpi	r24, 0x03	; 3
   1050c:	30 f4       	brcc	.+12     	; 0x1051a <FSettingDec+0x38>
   1050e:	88 23       	and	r24, r24
   10510:	71 f0       	breq	.+28     	; 0x1052e <FSettingDec+0x4c>
   10512:	81 30       	cpi	r24, 0x01	; 1
   10514:	09 f0       	breq	.+2      	; 0x10518 <FSettingDec+0x36>
   10516:	c3 c1       	rjmp	.+902    	; 0x1089e <FSettingDec+0x3bc>
   10518:	92 c0       	rjmp	.+292    	; 0x1063e <FSettingDec+0x15c>
   1051a:	84 30       	cpi	r24, 0x04	; 4
   1051c:	09 f4       	brne	.+2      	; 0x10520 <FSettingDec+0x3e>
   1051e:	b3 c1       	rjmp	.+870    	; 0x10886 <FSettingDec+0x3a4>
   10520:	84 30       	cpi	r24, 0x04	; 4
   10522:	08 f4       	brcc	.+2      	; 0x10526 <FSettingDec+0x44>
   10524:	68 c1       	rjmp	.+720    	; 0x107f6 <FSettingDec+0x314>
   10526:	85 30       	cpi	r24, 0x05	; 5
   10528:	09 f0       	breq	.+2      	; 0x1052c <FSettingDec+0x4a>
   1052a:	b9 c1       	rjmp	.+882    	; 0x1089e <FSettingDec+0x3bc>
   1052c:	b4 c1       	rjmp	.+872    	; 0x10896 <FSettingDec+0x3b4>
	 case sdInitDisplay:
	      lcd_clear();         //"12345678901234567890
   1052e:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10532:	e1 99       	sbic	0x1c, 1	; 28
   10534:	fe cf       	rjmp	.-4      	; 0x10532 <FSettingDec+0x50>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10536:	89 e3       	ldi	r24, 0x39	; 57
   10538:	90 e0       	ldi	r25, 0x00	; 0
   1053a:	9f bb       	out	0x1f, r25	; 31
   1053c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1053e:	e0 9a       	sbi	0x1c, 0	; 28
   10540:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10542:	e1 99       	sbic	0x1c, 1	; 28
   10544:	fe cf       	rjmp	.-4      	; 0x10542 <FSettingDec+0x60>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10546:	8a e3       	ldi	r24, 0x3A	; 58
   10548:	90 e0       	ldi	r25, 0x00	; 0
   1054a:	9f bb       	out	0x1f, r25	; 31
   1054c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1054e:	e0 9a       	sbi	0x1c, 0	; 28
   10550:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10552:	e1 99       	sbic	0x1c, 1	; 28
   10554:	fe cf       	rjmp	.-4      	; 0x10552 <FSettingDec+0x70>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10556:	8b e3       	ldi	r24, 0x3B	; 59
   10558:	90 e0       	ldi	r25, 0x00	; 0
   1055a:	9f bb       	out	0x1f, r25	; 31
   1055c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1055e:	e0 9a       	sbi	0x1c, 0	; 28
   10560:	fd b2       	in	r15, 0x1d	; 29
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalPrice);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalVolume);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMoney);

		  sprintf_P(lcdteks,PSTR("1.Price :%d"),PDecimalConfig[0]);
   10562:	00 d0       	rcall	.+0      	; 0x10564 <FSettingDec+0x82>
   10564:	00 d0       	rcall	.+0      	; 0x10566 <FSettingDec+0x84>
   10566:	00 d0       	rcall	.+0      	; 0x10568 <FSettingDec+0x86>
   10568:	ed b7       	in	r30, 0x3d	; 61
   1056a:	fe b7       	in	r31, 0x3e	; 62
   1056c:	31 96       	adiw	r30, 0x01	; 1
   1056e:	8e 01       	movw	r16, r28
   10570:	0f 5f       	subi	r16, 0xFF	; 255
   10572:	1f 4f       	sbci	r17, 0xFF	; 255
   10574:	ad b7       	in	r26, 0x3d	; 61
   10576:	be b7       	in	r27, 0x3e	; 62
   10578:	12 96       	adiw	r26, 0x02	; 2
   1057a:	1c 93       	st	X, r17
   1057c:	0e 93       	st	-X, r16
   1057e:	11 97       	sbiw	r26, 0x01	; 1
   10580:	8a ee       	ldi	r24, 0xEA	; 234
   10582:	9f e0       	ldi	r25, 0x0F	; 15
   10584:	93 83       	std	Z+3, r25	; 0x03
   10586:	82 83       	std	Z+2, r24	; 0x02
   10588:	24 83       	std	Z+4, r18	; 0x04
   1058a:	15 82       	std	Z+5, r1	; 0x05
   1058c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   10590:	8d b7       	in	r24, 0x3d	; 61
   10592:	9e b7       	in	r25, 0x3e	; 62
   10594:	06 96       	adiw	r24, 0x06	; 6
   10596:	0f b6       	in	r0, 0x3f	; 63
   10598:	f8 94       	cli
   1059a:	9e bf       	out	0x3e, r25	; 62
   1059c:	0f be       	out	0x3f, r0	; 63
   1059e:	8d bf       	out	0x3d, r24	; 61
   105a0:	81 e0       	ldi	r24, 0x01	; 1
   105a2:	61 e0       	ldi	r22, 0x01	; 1
   105a4:	a8 01       	movw	r20, r16
   105a6:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.Volume:%d"),PDecimalConfig[1]);
   105aa:	00 d0       	rcall	.+0      	; 0x105ac <FSettingDec+0xca>
   105ac:	00 d0       	rcall	.+0      	; 0x105ae <FSettingDec+0xcc>
   105ae:	00 d0       	rcall	.+0      	; 0x105b0 <FSettingDec+0xce>
   105b0:	ed b7       	in	r30, 0x3d	; 61
   105b2:	fe b7       	in	r31, 0x3e	; 62
   105b4:	31 96       	adiw	r30, 0x01	; 1
   105b6:	ad b7       	in	r26, 0x3d	; 61
   105b8:	be b7       	in	r27, 0x3e	; 62
   105ba:	12 96       	adiw	r26, 0x02	; 2
   105bc:	1c 93       	st	X, r17
   105be:	0e 93       	st	-X, r16
   105c0:	11 97       	sbiw	r26, 0x01	; 1
   105c2:	8e ed       	ldi	r24, 0xDE	; 222
   105c4:	9f e0       	ldi	r25, 0x0F	; 15
   105c6:	93 83       	std	Z+3, r25	; 0x03
   105c8:	82 83       	std	Z+2, r24	; 0x02
   105ca:	e4 82       	std	Z+4, r14	; 0x04
   105cc:	15 82       	std	Z+5, r1	; 0x05
   105ce:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   105d2:	8d b7       	in	r24, 0x3d	; 61
   105d4:	9e b7       	in	r25, 0x3e	; 62
   105d6:	06 96       	adiw	r24, 0x06	; 6
   105d8:	0f b6       	in	r0, 0x3f	; 63
   105da:	f8 94       	cli
   105dc:	9e bf       	out	0x3e, r25	; 62
   105de:	0f be       	out	0x3f, r0	; 63
   105e0:	8d bf       	out	0x3d, r24	; 61
   105e2:	82 e0       	ldi	r24, 0x02	; 2
   105e4:	61 e0       	ldi	r22, 0x01	; 1
   105e6:	a8 01       	movw	r20, r16
   105e8:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Money :%d"),PDecimalConfig[2]);
   105ec:	00 d0       	rcall	.+0      	; 0x105ee <FSettingDec+0x10c>
   105ee:	00 d0       	rcall	.+0      	; 0x105f0 <FSettingDec+0x10e>
   105f0:	00 d0       	rcall	.+0      	; 0x105f2 <FSettingDec+0x110>
   105f2:	ed b7       	in	r30, 0x3d	; 61
   105f4:	fe b7       	in	r31, 0x3e	; 62
   105f6:	31 96       	adiw	r30, 0x01	; 1
   105f8:	ad b7       	in	r26, 0x3d	; 61
   105fa:	be b7       	in	r27, 0x3e	; 62
   105fc:	12 96       	adiw	r26, 0x02	; 2
   105fe:	1c 93       	st	X, r17
   10600:	0e 93       	st	-X, r16
   10602:	11 97       	sbiw	r26, 0x01	; 1
   10604:	82 ed       	ldi	r24, 0xD2	; 210
   10606:	9f e0       	ldi	r25, 0x0F	; 15
   10608:	93 83       	std	Z+3, r25	; 0x03
   1060a:	82 83       	std	Z+2, r24	; 0x02
   1060c:	f4 82       	std	Z+4, r15	; 0x04
   1060e:	15 82       	std	Z+5, r1	; 0x05
   10610:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   10614:	8d b7       	in	r24, 0x3d	; 61
   10616:	9e b7       	in	r25, 0x3e	; 62
   10618:	06 96       	adiw	r24, 0x06	; 6
   1061a:	0f b6       	in	r0, 0x3f	; 63
   1061c:	f8 94       	cli
   1061e:	9e bf       	out	0x3e, r25	; 62
   10620:	0f be       	out	0x3f, r0	; 63
   10622:	8d bf       	out	0x3d, r24	; 61
   10624:	83 e0       	ldi	r24, 0x03	; 3
   10626:	61 e0       	ldi	r22, 0x01	; 1
   10628:	a8 01       	movw	r20, r16
   1062a:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]Back  [#]Next"));
   1062e:	84 e0       	ldi	r24, 0x04	; 4
   10630:	61 e0       	ldi	r22, 0x01	; 1
   10632:	41 ec       	ldi	r20, 0xC1	; 193
   10634:	5f e0       	ldi	r21, 0x0F	; 15
   10636:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  stSettingDecimal=sdSelectKey1;
   1063a:	81 e0       	ldi	r24, 0x01	; 1
   1063c:	29 c1       	rjmp	.+594    	; 0x10890 <FSettingDec+0x3ae>
		  break;
     case sdSelectKey1:
          KeyChar=_key_btn(_key_scan(1));
   1063e:	81 e0       	ldi	r24, 0x01	; 1
   10640:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   10644:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='3')){
   10648:	98 2f       	mov	r25, r24
   1064a:	91 53       	subi	r25, 0x31	; 49
   1064c:	93 30       	cpi	r25, 0x03	; 3
   1064e:	e0 f4       	brcc	.+56     	; 0x10688 <FSettingDec+0x1a6>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalPrice+Addr);
   10650:	29 2f       	mov	r18, r25
   10652:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10654:	e1 99       	sbic	0x1c, 1	; 28
   10656:	fe cf       	rjmp	.-4      	; 0x10654 <FSettingDec+0x172>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10658:	c9 01       	movw	r24, r18
   1065a:	87 5c       	subi	r24, 0xC7	; 199
   1065c:	9f 4f       	sbci	r25, 0xFF	; 255
   1065e:	9f bb       	out	0x1f, r25	; 31
   10660:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10662:	e0 9a       	sbi	0x1c, 0	; 28
   10664:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   10666:	e1 99       	sbic	0x1c, 1	; 28
   10668:	fe cf       	rjmp	.-4      	; 0x10666 <FSettingDec+0x184>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1066a:	27 5c       	subi	r18, 0xC7	; 199
   1066c:	3f 4f       	sbci	r19, 0xFF	; 255
   1066e:	3f bb       	out	0x1f, r19	; 31
   10670:	2e bb       	out	0x1e, r18	; 30
			  PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
   10672:	90 e0       	ldi	r25, 0x00	; 0
   10674:	01 96       	adiw	r24, 0x01	; 1
   10676:	83 70       	andi	r24, 0x03	; 3
   10678:	90 70       	andi	r25, 0x00	; 0
#endif
    EEDR = __value;
   1067a:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   1067c:	0f b6       	in	r0, 0x3f	; 63
   1067e:	f8 94       	cli
   10680:	e2 9a       	sbi	0x1c, 2	; 28
   10682:	e1 9a       	sbi	0x1c, 1	; 28
   10684:	0f be       	out	0x3f, r0	; 63
   10686:	f6 c0       	rjmp	.+492    	; 0x10874 <FSettingDec+0x392>

			  eeprom_write_byte(&DefDecimalPrice+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay;
		  }else if (KeyChar=='*') stSettingDecimal=sdExitSettingDecimal;
   10688:	8a 32       	cpi	r24, 0x2A	; 42
   1068a:	11 f4       	brne	.+4      	; 0x10690 <FSettingDec+0x1ae>
   1068c:	85 e0       	ldi	r24, 0x05	; 5
   1068e:	00 c1       	rjmp	.+512    	; 0x10890 <FSettingDec+0x3ae>
		  else if (KeyChar=='#') stSettingDecimal=sdInitDisplay2;
   10690:	83 32       	cpi	r24, 0x23	; 35
   10692:	09 f0       	breq	.+2      	; 0x10696 <FSettingDec+0x1b4>
   10694:	04 c1       	rjmp	.+520    	; 0x1089e <FSettingDec+0x3bc>
   10696:	fb c0       	rjmp	.+502    	; 0x1088e <FSettingDec+0x3ac>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10698:	e1 99       	sbic	0x1c, 1	; 28
   1069a:	fe cf       	rjmp	.-4      	; 0x10698 <FSettingDec+0x1b6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1069c:	8c e3       	ldi	r24, 0x3C	; 60
   1069e:	90 e0       	ldi	r25, 0x00	; 0
   106a0:	9f bb       	out	0x1f, r25	; 31
   106a2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   106a4:	e0 9a       	sbi	0x1c, 0	; 28
   106a6:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   106a8:	e1 99       	sbic	0x1c, 1	; 28
   106aa:	fe cf       	rjmp	.-4      	; 0x106a8 <FSettingDec+0x1c6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   106ac:	8d e3       	ldi	r24, 0x3D	; 61
   106ae:	90 e0       	ldi	r25, 0x00	; 0
   106b0:	9f bb       	out	0x1f, r25	; 31
   106b2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   106b4:	e0 9a       	sbi	0x1c, 0	; 28
   106b6:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   106b8:	e1 99       	sbic	0x1c, 1	; 28
   106ba:	fe cf       	rjmp	.-4      	; 0x106b8 <FSettingDec+0x1d6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   106bc:	8e e3       	ldi	r24, 0x3E	; 62
   106be:	90 e0       	ldi	r25, 0x00	; 0
   106c0:	9f bb       	out	0x1f, r25	; 31
   106c2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   106c4:	e0 9a       	sbi	0x1c, 0	; 28
   106c6:	dd b2       	in	r13, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   106c8:	e1 99       	sbic	0x1c, 1	; 28
   106ca:	fe cf       	rjmp	.-4      	; 0x106c8 <FSettingDec+0x1e6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   106cc:	8f e3       	ldi	r24, 0x3F	; 63
   106ce:	90 e0       	ldi	r25, 0x00	; 0
   106d0:	9f bb       	out	0x1f, r25	; 31
   106d2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   106d4:	e0 9a       	sbi	0x1c, 0	; 28
   106d6:	fd b2       	in	r15, 0x1d	; 29
     case sdInitDisplay2:
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalTotalVolume);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalTotalMoney);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMark);
		  PDecimalConfig[3]=eeprom_read_byte(&DefCurrencyMark);
		  sprintf_P(lcdteks,PSTR("1.T.Volume:%d  5.Test"),PDecimalConfig[0]);
   106d8:	00 d0       	rcall	.+0      	; 0x106da <FSettingDec+0x1f8>
   106da:	00 d0       	rcall	.+0      	; 0x106dc <FSettingDec+0x1fa>
   106dc:	00 d0       	rcall	.+0      	; 0x106de <FSettingDec+0x1fc>
   106de:	ed b7       	in	r30, 0x3d	; 61
   106e0:	fe b7       	in	r31, 0x3e	; 62
   106e2:	31 96       	adiw	r30, 0x01	; 1
   106e4:	8e 01       	movw	r16, r28
   106e6:	0f 5f       	subi	r16, 0xFF	; 255
   106e8:	1f 4f       	sbci	r17, 0xFF	; 255
   106ea:	ad b7       	in	r26, 0x3d	; 61
   106ec:	be b7       	in	r27, 0x3e	; 62
   106ee:	12 96       	adiw	r26, 0x02	; 2
   106f0:	1c 93       	st	X, r17
   106f2:	0e 93       	st	-X, r16
   106f4:	11 97       	sbiw	r26, 0x01	; 1
   106f6:	8b ea       	ldi	r24, 0xAB	; 171
   106f8:	9f e0       	ldi	r25, 0x0F	; 15
   106fa:	93 83       	std	Z+3, r25	; 0x03
   106fc:	82 83       	std	Z+2, r24	; 0x02
   106fe:	24 83       	std	Z+4, r18	; 0x04
   10700:	15 82       	std	Z+5, r1	; 0x05
   10702:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   10706:	8d b7       	in	r24, 0x3d	; 61
   10708:	9e b7       	in	r25, 0x3e	; 62
   1070a:	06 96       	adiw	r24, 0x06	; 6
   1070c:	0f b6       	in	r0, 0x3f	; 63
   1070e:	f8 94       	cli
   10710:	9e bf       	out	0x3e, r25	; 62
   10712:	0f be       	out	0x3f, r0	; 63
   10714:	8d bf       	out	0x3d, r24	; 61
   10716:	81 e0       	ldi	r24, 0x01	; 1
   10718:	61 e0       	ldi	r22, 0x01	; 1
   1071a:	a8 01       	movw	r20, r16
   1071c:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.T.Money :%d "),PDecimalConfig[1]);
   10720:	00 d0       	rcall	.+0      	; 0x10722 <FSettingDec+0x240>
   10722:	00 d0       	rcall	.+0      	; 0x10724 <FSettingDec+0x242>
   10724:	00 d0       	rcall	.+0      	; 0x10726 <FSettingDec+0x244>
   10726:	ed b7       	in	r30, 0x3d	; 61
   10728:	fe b7       	in	r31, 0x3e	; 62
   1072a:	31 96       	adiw	r30, 0x01	; 1
   1072c:	ad b7       	in	r26, 0x3d	; 61
   1072e:	be b7       	in	r27, 0x3e	; 62
   10730:	12 96       	adiw	r26, 0x02	; 2
   10732:	1c 93       	st	X, r17
   10734:	0e 93       	st	-X, r16
   10736:	11 97       	sbiw	r26, 0x01	; 1
   10738:	8c e9       	ldi	r24, 0x9C	; 156
   1073a:	9f e0       	ldi	r25, 0x0F	; 15
   1073c:	93 83       	std	Z+3, r25	; 0x03
   1073e:	82 83       	std	Z+2, r24	; 0x02
   10740:	e4 82       	std	Z+4, r14	; 0x04
   10742:	15 82       	std	Z+5, r1	; 0x05
   10744:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   10748:	8d b7       	in	r24, 0x3d	; 61
   1074a:	9e b7       	in	r25, 0x3e	; 62
   1074c:	06 96       	adiw	r24, 0x06	; 6
   1074e:	0f b6       	in	r0, 0x3f	; 63
   10750:	f8 94       	cli
   10752:	9e bf       	out	0x3e, r25	; 62
   10754:	0f be       	out	0x3f, r0	; 63
   10756:	8d bf       	out	0x3d, r24	; 61
   10758:	82 e0       	ldi	r24, 0x02	; 2
   1075a:	61 e0       	ldi	r22, 0x01	; 1
   1075c:	a8 01       	movw	r20, r16
   1075e:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Decimal :%c "),PDecimalConfig[2]);
   10762:	00 d0       	rcall	.+0      	; 0x10764 <FSettingDec+0x282>
   10764:	00 d0       	rcall	.+0      	; 0x10766 <FSettingDec+0x284>
   10766:	00 d0       	rcall	.+0      	; 0x10768 <FSettingDec+0x286>
   10768:	ed b7       	in	r30, 0x3d	; 61
   1076a:	fe b7       	in	r31, 0x3e	; 62
   1076c:	31 96       	adiw	r30, 0x01	; 1
   1076e:	ad b7       	in	r26, 0x3d	; 61
   10770:	be b7       	in	r27, 0x3e	; 62
   10772:	12 96       	adiw	r26, 0x02	; 2
   10774:	1c 93       	st	X, r17
   10776:	0e 93       	st	-X, r16
   10778:	11 97       	sbiw	r26, 0x01	; 1
   1077a:	8d e8       	ldi	r24, 0x8D	; 141
   1077c:	9f e0       	ldi	r25, 0x0F	; 15
   1077e:	93 83       	std	Z+3, r25	; 0x03
   10780:	82 83       	std	Z+2, r24	; 0x02
   10782:	d4 82       	std	Z+4, r13	; 0x04
   10784:	15 82       	std	Z+5, r1	; 0x05
   10786:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   1078a:	8d b7       	in	r24, 0x3d	; 61
   1078c:	9e b7       	in	r25, 0x3e	; 62
   1078e:	06 96       	adiw	r24, 0x06	; 6
   10790:	0f b6       	in	r0, 0x3f	; 63
   10792:	f8 94       	cli
   10794:	9e bf       	out	0x3e, r25	; 62
   10796:	0f be       	out	0x3f, r0	; 63
   10798:	8d bf       	out	0x3d, r24	; 61
   1079a:	83 e0       	ldi	r24, 0x03	; 3
   1079c:	61 e0       	ldi	r22, 0x01	; 1
   1079e:	a8 01       	movw	r20, r16
   107a0:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  sprintf_P(lcdteks,PSTR("4.Sparator:%c "),PDecimalConfig[3]);
   107a4:	00 d0       	rcall	.+0      	; 0x107a6 <FSettingDec+0x2c4>
   107a6:	00 d0       	rcall	.+0      	; 0x107a8 <FSettingDec+0x2c6>
   107a8:	00 d0       	rcall	.+0      	; 0x107aa <FSettingDec+0x2c8>
   107aa:	ed b7       	in	r30, 0x3d	; 61
   107ac:	fe b7       	in	r31, 0x3e	; 62
   107ae:	31 96       	adiw	r30, 0x01	; 1
   107b0:	ad b7       	in	r26, 0x3d	; 61
   107b2:	be b7       	in	r27, 0x3e	; 62
   107b4:	12 96       	adiw	r26, 0x02	; 2
   107b6:	1c 93       	st	X, r17
   107b8:	0e 93       	st	-X, r16
   107ba:	11 97       	sbiw	r26, 0x01	; 1
   107bc:	8e e7       	ldi	r24, 0x7E	; 126
   107be:	9f e0       	ldi	r25, 0x0F	; 15
   107c0:	93 83       	std	Z+3, r25	; 0x03
   107c2:	82 83       	std	Z+2, r24	; 0x02
   107c4:	f4 82       	std	Z+4, r15	; 0x04
   107c6:	15 82       	std	Z+5, r1	; 0x05
   107c8:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(4,1,lcdteks);
   107cc:	8d b7       	in	r24, 0x3d	; 61
   107ce:	9e b7       	in	r25, 0x3e	; 62
   107d0:	06 96       	adiw	r24, 0x06	; 6
   107d2:	0f b6       	in	r0, 0x3f	; 63
   107d4:	f8 94       	cli
   107d6:	9e bf       	out	0x3e, r25	; 62
   107d8:	0f be       	out	0x3f, r0	; 63
   107da:	8d bf       	out	0x3d, r24	; 61
   107dc:	84 e0       	ldi	r24, 0x04	; 4
   107de:	61 e0       	ldi	r22, 0x01	; 1
   107e0:	a8 01       	movw	r20, r16
   107e2:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_printf(4,14,PSTR("*)Back"));
   107e6:	84 e0       	ldi	r24, 0x04	; 4
   107e8:	6e e0       	ldi	r22, 0x0E	; 14
   107ea:	47 e7       	ldi	r20, 0x77	; 119
   107ec:	5f e0       	ldi	r21, 0x0F	; 15
   107ee:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	      stSettingDecimal=sdSelectKey2;
   107f2:	83 e0       	ldi	r24, 0x03	; 3
   107f4:	4d c0       	rjmp	.+154    	; 0x10890 <FSettingDec+0x3ae>
	      break;
     case sdSelectKey2:
          KeyChar=_key_btn(_key_scan(1));
   107f6:	81 e0       	ldi	r24, 0x01	; 1
   107f8:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   107fc:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   10800:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
   10802:	98 2f       	mov	r25, r24
   10804:	91 53       	subi	r25, 0x31	; 49
   10806:	92 30       	cpi	r25, 0x02	; 2
   10808:	b0 f4       	brcc	.+44     	; 0x10836 <FSettingDec+0x354>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
   1080a:	29 2f       	mov	r18, r25
   1080c:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1080e:	e1 99       	sbic	0x1c, 1	; 28
   10810:	fe cf       	rjmp	.-4      	; 0x1080e <FSettingDec+0x32c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10812:	c9 01       	movw	r24, r18
   10814:	84 5c       	subi	r24, 0xC4	; 196
   10816:	9f 4f       	sbci	r25, 0xFF	; 255
   10818:	9f bb       	out	0x1f, r25	; 31
   1081a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1081c:	e0 9a       	sbi	0x1c, 0	; 28
   1081e:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   10820:	e1 99       	sbic	0x1c, 1	; 28
   10822:	fe cf       	rjmp	.-4      	; 0x10820 <FSettingDec+0x33e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10824:	24 5c       	subi	r18, 0xC4	; 196
   10826:	3f 4f       	sbci	r19, 0xFF	; 255
   10828:	3f bb       	out	0x1f, r19	; 31
   1082a:	2e bb       	out	0x1e, r18	; 30
		      PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
   1082c:	90 e0       	ldi	r25, 0x00	; 0
   1082e:	01 96       	adiw	r24, 0x01	; 1
   10830:	83 70       	andi	r24, 0x03	; 3
   10832:	90 70       	andi	r25, 0x00	; 0
   10834:	16 c0       	rjmp	.+44     	; 0x10862 <FSettingDec+0x380>

			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if ((KeyChar>='3')&&(KeyChar<='4')){
   10836:	83 53       	subi	r24, 0x33	; 51
   10838:	82 30       	cpi	r24, 0x02	; 2
   1083a:	d0 f4       	brcc	.+52     	; 0x10870 <FSettingDec+0x38e>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
   1083c:	09 2f       	mov	r16, r25
   1083e:	10 e0       	ldi	r17, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10840:	e1 99       	sbic	0x1c, 1	; 28
   10842:	fe cf       	rjmp	.-4      	; 0x10840 <FSettingDec+0x35e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10844:	c8 01       	movw	r24, r16
   10846:	84 5c       	subi	r24, 0xC4	; 196
   10848:	9f 4f       	sbci	r25, 0xFF	; 255
   1084a:	9f bb       	out	0x1f, r25	; 31
   1084c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1084e:	e0 9a       	sbi	0x1c, 0	; 28
   10850:	8d b3       	in	r24, 0x1d	; 29
			  PDecimalConfig[Addr]=SelectMark(PDecimalConfig[Addr]);
   10852:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <SelectMark>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   10856:	e1 99       	sbic	0x1c, 1	; 28
   10858:	fe cf       	rjmp	.-4      	; 0x10856 <FSettingDec+0x374>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1085a:	04 5c       	subi	r16, 0xC4	; 196
   1085c:	1f 4f       	sbci	r17, 0xFF	; 255
   1085e:	1f bb       	out	0x1f, r17	; 31
   10860:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   10862:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   10864:	0f b6       	in	r0, 0x3f	; 63
   10866:	f8 94       	cli
   10868:	e2 9a       	sbi	0x1c, 2	; 28
   1086a:	e1 9a       	sbi	0x1c, 1	; 28
   1086c:	0f be       	out	0x3f, r0	; 63
   1086e:	0f c0       	rjmp	.+30     	; 0x1088e <FSettingDec+0x3ac>
			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if (KeyChar=='*') stSettingDecimal=sdInitDisplay;
   10870:	2a 32       	cpi	r18, 0x2A	; 42
   10872:	19 f4       	brne	.+6      	; 0x1087a <FSettingDec+0x398>
   10874:	10 92 fe 02 	sts	0x02FE, r1
   10878:	12 c0       	rjmp	.+36     	; 0x1089e <FSettingDec+0x3bc>
		  else if (KeyChar=='5'){
   1087a:	25 33       	cpi	r18, 0x35	; 53
   1087c:	81 f4       	brne	.+32     	; 0x1089e <FSettingDec+0x3bc>
		          lcd_clear();
   1087e:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		          stSettingDecimal=sdTestInput;
   10882:	84 e0       	ldi	r24, 0x04	; 4
   10884:	05 c0       	rjmp	.+10     	; 0x10890 <FSettingDec+0x3ae>
				  }
          break;
     case sdTestInput:
	      if (TestUserInput()==MENU_DONE)stSettingDecimal=sdInitDisplay2;
   10886:	0e 94 37 80 	call	0x1006e	; 0x1006e <TestUserInput>
   1088a:	81 30       	cpi	r24, 0x01	; 1
   1088c:	41 f4       	brne	.+16     	; 0x1089e <FSettingDec+0x3bc>
   1088e:	82 e0       	ldi	r24, 0x02	; 2
   10890:	80 93 fe 02 	sts	0x02FE, r24
   10894:	04 c0       	rjmp	.+8      	; 0x1089e <FSettingDec+0x3bc>
	      break;
	 case sdExitSettingDecimal:
          stSettingDecimal=sdInitDisplay;
   10896:	10 92 fe 02 	sts	0x02FE, r1
   1089a:	81 e0       	ldi	r24, 0x01	; 1
   1089c:	01 c0       	rjmp	.+2      	; 0x108a0 <FSettingDec+0x3be>
   1089e:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
    return Result;
}
   108a0:	64 96       	adiw	r28, 0x14	; 20
   108a2:	0f b6       	in	r0, 0x3f	; 63
   108a4:	f8 94       	cli
   108a6:	de bf       	out	0x3e, r29	; 62
   108a8:	0f be       	out	0x3f, r0	; 63
   108aa:	cd bf       	out	0x3d, r28	; 61
   108ac:	cf 91       	pop	r28
   108ae:	df 91       	pop	r29
   108b0:	1f 91       	pop	r17
   108b2:	0f 91       	pop	r16
   108b4:	ff 90       	pop	r15
   108b6:	ef 90       	pop	r14
   108b8:	df 90       	pop	r13
   108ba:	08 95       	ret

000108bc <FTestCalculation>:
	 }
  return Result;
}


void FTestCalculation(){
   108bc:	cf 92       	push	r12
   108be:	df 92       	push	r13
   108c0:	ef 92       	push	r14
   108c2:	ff 92       	push	r15
   108c4:	0f 93       	push	r16
   108c6:	1f 93       	push	r17
   108c8:	df 93       	push	r29
   108ca:	cf 93       	push	r28
   108cc:	cd b7       	in	r28, 0x3d	; 61
   108ce:	de b7       	in	r29, 0x3e	; 62
   108d0:	64 97       	sbiw	r28, 0x14	; 20
   108d2:	0f b6       	in	r0, 0x3f	; 63
   108d4:	f8 94       	cli
   108d6:	de bf       	out	0x3e, r29	; 62
   108d8:	0f be       	out	0x3f, r0	; 63
   108da:	cd bf       	out	0x3d, r28	; 61
static char stTestCalc=tcInitData,uiResult=USER_NONE;
static char InputA[20],InputB[20],OutputC[20];
     char lcdteks[20],KeyChar;
     
	 switch(stTestCalc){
   108dc:	80 91 6f 02 	lds	r24, 0x026F
   108e0:	82 30       	cpi	r24, 0x02	; 2
   108e2:	09 f4       	brne	.+2      	; 0x108e6 <FTestCalculation+0x2a>
   108e4:	4b c0       	rjmp	.+150    	; 0x1097c <FTestCalculation+0xc0>
   108e6:	83 30       	cpi	r24, 0x03	; 3
   108e8:	30 f4       	brcc	.+12     	; 0x108f6 <FTestCalculation+0x3a>
   108ea:	88 23       	and	r24, r24
   108ec:	71 f0       	breq	.+28     	; 0x1090a <FTestCalculation+0x4e>
   108ee:	81 30       	cpi	r24, 0x01	; 1
   108f0:	09 f0       	breq	.+2      	; 0x108f4 <FTestCalculation+0x38>
   108f2:	e7 c0       	rjmp	.+462    	; 0x10ac2 <FTestCalculation+0x206>
   108f4:	2f c0       	rjmp	.+94     	; 0x10954 <FTestCalculation+0x98>
   108f6:	84 30       	cpi	r24, 0x04	; 4
   108f8:	09 f4       	brne	.+2      	; 0x108fc <FTestCalculation+0x40>
   108fa:	82 c0       	rjmp	.+260    	; 0x10a00 <FTestCalculation+0x144>
   108fc:	84 30       	cpi	r24, 0x04	; 4
   108fe:	08 f4       	brcc	.+2      	; 0x10902 <FTestCalculation+0x46>
   10900:	6d c0       	rjmp	.+218    	; 0x109dc <FTestCalculation+0x120>
   10902:	85 30       	cpi	r24, 0x05	; 5
   10904:	09 f0       	breq	.+2      	; 0x10908 <FTestCalculation+0x4c>
   10906:	dd c0       	rjmp	.+442    	; 0x10ac2 <FTestCalculation+0x206>
   10908:	d1 c0       	rjmp	.+418    	; 0x10aac <FTestCalculation+0x1f0>
	 case tcInitData:
	      lcd_clear();
   1090a:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("Operation Multiply"));
   1090e:	81 e0       	ldi	r24, 0x01	; 1
   10910:	61 e0       	ldi	r22, 0x01	; 1
   10912:	49 e5       	ldi	r20, 0x59	; 89
   10914:	56 e0       	ldi	r21, 0x06	; 6
   10916:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(2,1,PSTR("InA:_"));
   1091a:	82 e0       	ldi	r24, 0x02	; 2
   1091c:	61 e0       	ldi	r22, 0x01	; 1
   1091e:	43 e5       	ldi	r20, 0x53	; 83
   10920:	56 e0       	ldi	r21, 0x06	; 6
   10922:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
   10926:	aa e5       	ldi	r26, 0x5A	; 90
   10928:	b2 e0       	ldi	r27, 0x02	; 2
   1092a:	fd 01       	movw	r30, r26
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   1092c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   1092e:	82 e0       	ldi	r24, 0x02	; 2
   10930:	ee 36       	cpi	r30, 0x6E	; 110
   10932:	f8 07       	cpc	r31, r24
   10934:	d9 f7       	brne	.-10     	; 0x1092c <FTestCalculation+0x70>
   10936:	74 97       	sbiw	r30, 0x14	; 20
	     strMemory[i]=data;
   10938:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   1093a:	92 e0       	ldi	r25, 0x02	; 2
   1093c:	ee 36       	cpi	r30, 0x6E	; 110
   1093e:	f9 07       	cpc	r31, r25
   10940:	d9 f7       	brne	.-10     	; 0x10938 <FTestCalculation+0x7c>
	     strMemory[i]=data;
   10942:	1d 92       	st	X+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10944:	82 e0       	ldi	r24, 0x02	; 2
   10946:	ae 36       	cpi	r26, 0x6E	; 110
   10948:	b8 07       	cpc	r27, r24
   1094a:	d9 f7       	brne	.-10     	; 0x10942 <FTestCalculation+0x86>
		  lcd_printf(2,1,PSTR("InA:_"));
		  FillChar(InputA,sizeof(InputA),0);
		  FillChar(InputA,sizeof(InputB),0);
		  FillChar(InputA,sizeof(OutputC),0);

		  uiResult=USER_NONE;
   1094c:	10 92 6e 02 	sts	0x026E, r1
          stTestCalc=tcInputA;
   10950:	81 e0       	ldi	r24, 0x01	; 1
   10952:	11 c0       	rjmp	.+34     	; 0x10976 <FTestCalculation+0xba>
	      break;
     case tcInputA:
	      uiResult=UserInput(UI_ALPHANUM_R,2,5,InputA,0,15);
   10954:	83 e0       	ldi	r24, 0x03	; 3
   10956:	62 e0       	ldi	r22, 0x02	; 2
   10958:	45 e0       	ldi	r20, 0x05	; 5
   1095a:	2a e5       	ldi	r18, 0x5A	; 90
   1095c:	32 e0       	ldi	r19, 0x02	; 2
   1095e:	00 e0       	ldi	r16, 0x00	; 0
   10960:	10 e0       	ldi	r17, 0x00	; 0
   10962:	9f e0       	ldi	r25, 0x0F	; 15
   10964:	e9 2e       	mov	r14, r25
   10966:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
   1096a:	80 93 6e 02 	sts	0x026E, r24
	      if (uiResult==USER_OK)stTestCalc=tcDispInputA;
   1096e:	83 30       	cpi	r24, 0x03	; 3
   10970:	09 f0       	breq	.+2      	; 0x10974 <FTestCalculation+0xb8>
   10972:	a7 c0       	rjmp	.+334    	; 0x10ac2 <FTestCalculation+0x206>
   10974:	82 e0       	ldi	r24, 0x02	; 2
   10976:	80 93 6f 02 	sts	0x026F, r24
   1097a:	a3 c0       	rjmp	.+326    	; 0x10ac2 <FTestCalculation+0x206>
	      break;
     case tcDispInputA:
	      sprintf_P(lcdteks,PSTR("InA:%s"),InputA);
   1097c:	00 d0       	rcall	.+0      	; 0x1097e <FTestCalculation+0xc2>
   1097e:	00 d0       	rcall	.+0      	; 0x10980 <FTestCalculation+0xc4>
   10980:	00 d0       	rcall	.+0      	; 0x10982 <FTestCalculation+0xc6>
   10982:	ed b7       	in	r30, 0x3d	; 61
   10984:	fe b7       	in	r31, 0x3e	; 62
   10986:	31 96       	adiw	r30, 0x01	; 1
   10988:	8e 01       	movw	r16, r28
   1098a:	0f 5f       	subi	r16, 0xFF	; 255
   1098c:	1f 4f       	sbci	r17, 0xFF	; 255
   1098e:	ad b7       	in	r26, 0x3d	; 61
   10990:	be b7       	in	r27, 0x3e	; 62
   10992:	12 96       	adiw	r26, 0x02	; 2
   10994:	1c 93       	st	X, r17
   10996:	0e 93       	st	-X, r16
   10998:	11 97       	sbiw	r26, 0x01	; 1
   1099a:	8c e4       	ldi	r24, 0x4C	; 76
   1099c:	96 e0       	ldi	r25, 0x06	; 6
   1099e:	93 83       	std	Z+3, r25	; 0x03
   109a0:	82 83       	std	Z+2, r24	; 0x02
   109a2:	8a e5       	ldi	r24, 0x5A	; 90
   109a4:	92 e0       	ldi	r25, 0x02	; 2
   109a6:	95 83       	std	Z+5, r25	; 0x05
   109a8:	84 83       	std	Z+4, r24	; 0x04
   109aa:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   109ae:	8d b7       	in	r24, 0x3d	; 61
   109b0:	9e b7       	in	r25, 0x3e	; 62
   109b2:	06 96       	adiw	r24, 0x06	; 6
   109b4:	0f b6       	in	r0, 0x3f	; 63
   109b6:	f8 94       	cli
   109b8:	9e bf       	out	0x3e, r25	; 62
   109ba:	0f be       	out	0x3f, r0	; 63
   109bc:	8d bf       	out	0x3d, r24	; 61
   109be:	82 e0       	ldi	r24, 0x02	; 2
   109c0:	61 e0       	ldi	r22, 0x01	; 1
   109c2:	a8 01       	movw	r20, r16
   109c4:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_printf(3,1,PSTR("InB:_"));
   109c8:	83 e0       	ldi	r24, 0x03	; 3
   109ca:	61 e0       	ldi	r22, 0x01	; 1
   109cc:	46 e4       	ldi	r20, 0x46	; 70
   109ce:	56 e0       	ldi	r21, 0x06	; 6
   109d0:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  uiResult=USER_NONE;
   109d4:	10 92 6e 02 	sts	0x026E, r1
          stTestCalc=tcInputB;
   109d8:	83 e0       	ldi	r24, 0x03	; 3
   109da:	cd cf       	rjmp	.-102    	; 0x10976 <FTestCalculation+0xba>
	      break;
     case tcInputB:
	 	  uiResult=UserInput(UI_ALPHANUM_R,3,5,InputB,0,15);
   109dc:	83 e0       	ldi	r24, 0x03	; 3
   109de:	63 e0       	ldi	r22, 0x03	; 3
   109e0:	45 e0       	ldi	r20, 0x05	; 5
   109e2:	26 e4       	ldi	r18, 0x46	; 70
   109e4:	32 e0       	ldi	r19, 0x02	; 2
   109e6:	00 e0       	ldi	r16, 0x00	; 0
   109e8:	10 e0       	ldi	r17, 0x00	; 0
   109ea:	bf e0       	ldi	r27, 0x0F	; 15
   109ec:	eb 2e       	mov	r14, r27
   109ee:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
   109f2:	80 93 6e 02 	sts	0x026E, r24
	      if (uiResult==USER_OK)stTestCalc=tcCalcualte;
   109f6:	83 30       	cpi	r24, 0x03	; 3
   109f8:	09 f0       	breq	.+2      	; 0x109fc <FTestCalculation+0x140>
   109fa:	63 c0       	rjmp	.+198    	; 0x10ac2 <FTestCalculation+0x206>
   109fc:	84 e0       	ldi	r24, 0x04	; 4
   109fe:	bb cf       	rjmp	.-138    	; 0x10976 <FTestCalculation+0xba>
	      break;
     case tcCalcualte:
	      sprintf_P(lcdteks,PSTR("InB:%s"),InputB);
   10a00:	00 d0       	rcall	.+0      	; 0x10a02 <FTestCalculation+0x146>
   10a02:	00 d0       	rcall	.+0      	; 0x10a04 <FTestCalculation+0x148>
   10a04:	00 d0       	rcall	.+0      	; 0x10a06 <FTestCalculation+0x14a>
   10a06:	ed b7       	in	r30, 0x3d	; 61
   10a08:	fe b7       	in	r31, 0x3e	; 62
   10a0a:	31 96       	adiw	r30, 0x01	; 1
   10a0c:	8e 01       	movw	r16, r28
   10a0e:	0f 5f       	subi	r16, 0xFF	; 255
   10a10:	1f 4f       	sbci	r17, 0xFF	; 255
   10a12:	ad b7       	in	r26, 0x3d	; 61
   10a14:	be b7       	in	r27, 0x3e	; 62
   10a16:	12 96       	adiw	r26, 0x02	; 2
   10a18:	1c 93       	st	X, r17
   10a1a:	0e 93       	st	-X, r16
   10a1c:	11 97       	sbiw	r26, 0x01	; 1
   10a1e:	8f e3       	ldi	r24, 0x3F	; 63
   10a20:	96 e0       	ldi	r25, 0x06	; 6
   10a22:	93 83       	std	Z+3, r25	; 0x03
   10a24:	82 83       	std	Z+2, r24	; 0x02
   10a26:	a6 e4       	ldi	r26, 0x46	; 70
   10a28:	ea 2e       	mov	r14, r26
   10a2a:	a2 e0       	ldi	r26, 0x02	; 2
   10a2c:	fa 2e       	mov	r15, r26
   10a2e:	f5 82       	std	Z+5, r15	; 0x05
   10a30:	e4 82       	std	Z+4, r14	; 0x04
   10a32:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   10a36:	8d b7       	in	r24, 0x3d	; 61
   10a38:	9e b7       	in	r25, 0x3e	; 62
   10a3a:	06 96       	adiw	r24, 0x06	; 6
   10a3c:	0f b6       	in	r0, 0x3f	; 63
   10a3e:	f8 94       	cli
   10a40:	9e bf       	out	0x3e, r25	; 62
   10a42:	0f be       	out	0x3f, r0	; 63
   10a44:	8d bf       	out	0x3d, r24	; 61
   10a46:	83 e0       	ldi	r24, 0x03	; 3
   10a48:	61 e0       	ldi	r22, 0x01	; 1
   10a4a:	a8 01       	movw	r20, r16
   10a4c:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  //StrCalc(TMINUS,InputA,InputB,OutputC);
		  //StrCalc(TPLUS,InputA,InputB,OutputC);
		  StrCalc(TMULTIPLY,InputA,InputB,OutputC);
   10a50:	72 e3       	ldi	r23, 0x32	; 50
   10a52:	c7 2e       	mov	r12, r23
   10a54:	72 e0       	ldi	r23, 0x02	; 2
   10a56:	d7 2e       	mov	r13, r23
   10a58:	82 e0       	ldi	r24, 0x02	; 2
   10a5a:	6a e5       	ldi	r22, 0x5A	; 90
   10a5c:	72 e0       	ldi	r23, 0x02	; 2
   10a5e:	a7 01       	movw	r20, r14
   10a60:	96 01       	movw	r18, r12
   10a62:	0e 94 db 25 	call	0x4bb6	; 0x4bb6 <StrCalc>
	      sprintf_P(lcdteks,PSTR("A+B:%s"),OutputC);
   10a66:	00 d0       	rcall	.+0      	; 0x10a68 <FTestCalculation+0x1ac>
   10a68:	00 d0       	rcall	.+0      	; 0x10a6a <FTestCalculation+0x1ae>
   10a6a:	00 d0       	rcall	.+0      	; 0x10a6c <FTestCalculation+0x1b0>
   10a6c:	ed b7       	in	r30, 0x3d	; 61
   10a6e:	fe b7       	in	r31, 0x3e	; 62
   10a70:	31 96       	adiw	r30, 0x01	; 1
   10a72:	ad b7       	in	r26, 0x3d	; 61
   10a74:	be b7       	in	r27, 0x3e	; 62
   10a76:	12 96       	adiw	r26, 0x02	; 2
   10a78:	1c 93       	st	X, r17
   10a7a:	0e 93       	st	-X, r16
   10a7c:	11 97       	sbiw	r26, 0x01	; 1
   10a7e:	88 e3       	ldi	r24, 0x38	; 56
   10a80:	96 e0       	ldi	r25, 0x06	; 6
   10a82:	93 83       	std	Z+3, r25	; 0x03
   10a84:	82 83       	std	Z+2, r24	; 0x02
   10a86:	d5 82       	std	Z+5, r13	; 0x05
   10a88:	c4 82       	std	Z+4, r12	; 0x04
   10a8a:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(4,1,lcdteks);
   10a8e:	8d b7       	in	r24, 0x3d	; 61
   10a90:	9e b7       	in	r25, 0x3e	; 62
   10a92:	06 96       	adiw	r24, 0x06	; 6
   10a94:	0f b6       	in	r0, 0x3f	; 63
   10a96:	f8 94       	cli
   10a98:	9e bf       	out	0x3e, r25	; 62
   10a9a:	0f be       	out	0x3f, r0	; 63
   10a9c:	8d bf       	out	0x3d, r24	; 61
   10a9e:	84 e0       	ldi	r24, 0x04	; 4
   10aa0:	61 e0       	ldi	r22, 0x01	; 1
   10aa2:	a8 01       	movw	r20, r16
   10aa4:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
          stTestCalc=tcWaitEnter;
   10aa8:	85 e0       	ldi	r24, 0x05	; 5
   10aaa:	65 cf       	rjmp	.-310    	; 0x10976 <FTestCalculation+0xba>
	      break;
     case tcWaitEnter:
	      KeyChar= _key_btn(_key_scan(1));       
   10aac:	81 e0       	ldi	r24, 0x01	; 1
   10aae:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   10ab2:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
		  if (KeyChar=='#')stTestCalc=tcInitData;
   10ab6:	83 32       	cpi	r24, 0x23	; 35
   10ab8:	11 f0       	breq	.+4      	; 0x10abe <FTestCalculation+0x202>
		  else
		  if (KeyChar=='*')stTestCalc=tcInitData;
   10aba:	8a 32       	cpi	r24, 0x2A	; 42
   10abc:	11 f4       	brne	.+4      	; 0x10ac2 <FTestCalculation+0x206>
   10abe:	10 92 6f 02 	sts	0x026F, r1
	      break;	 
	 }
}
   10ac2:	64 96       	adiw	r28, 0x14	; 20
   10ac4:	0f b6       	in	r0, 0x3f	; 63
   10ac6:	f8 94       	cli
   10ac8:	de bf       	out	0x3e, r29	; 62
   10aca:	0f be       	out	0x3f, r0	; 63
   10acc:	cd bf       	out	0x3d, r28	; 61
   10ace:	cf 91       	pop	r28
   10ad0:	df 91       	pop	r29
   10ad2:	1f 91       	pop	r17
   10ad4:	0f 91       	pop	r16
   10ad6:	ff 90       	pop	r15
   10ad8:	ef 90       	pop	r14
   10ada:	df 90       	pop	r13
   10adc:	cf 90       	pop	r12
   10ade:	08 95       	ret

00010ae0 <FMenuTicket>:
	    StrResult[2]='0'+Val;
	    StrResult[3]=0;
		}   
}

char FMenuTicket(){
   10ae0:	ef 92       	push	r14
   10ae2:	0f 93       	push	r16
   10ae4:	1f 93       	push	r17
   10ae6:	df 93       	push	r29
   10ae8:	cf 93       	push	r28
   10aea:	cd b7       	in	r28, 0x3d	; 61
   10aec:	de b7       	in	r29, 0x3e	; 62
   10aee:	64 97       	sbiw	r28, 0x14	; 20
   10af0:	0f b6       	in	r0, 0x3f	; 63
   10af2:	f8 94       	cli
   10af4:	de bf       	out	0x3e, r29	; 62
   10af6:	0f be       	out	0x3f, r0	; 63
   10af8:	cd bf       	out	0x3d, r28	; 61
static char uiResult=USER_NONE,iPos,iSend,KeyPressed,KeyChar,FIP_Used,zFIP_Used;
static unsigned int iLoop=0;
     char Result=MENU_NONE,lcdteks[20];

    Result=MENU_NONE;   
    switch(stMenuTicket){
   10afa:	80 91 ed 02 	lds	r24, 0x02ED
   10afe:	86 30       	cpi	r24, 0x06	; 6
   10b00:	09 f4       	brne	.+2      	; 0x10b04 <FMenuTicket+0x24>
   10b02:	c8 c0       	rjmp	.+400    	; 0x10c94 <FMenuTicket+0x1b4>
   10b04:	87 30       	cpi	r24, 0x07	; 7
   10b06:	90 f4       	brcc	.+36     	; 0x10b2c <FMenuTicket+0x4c>
   10b08:	82 30       	cpi	r24, 0x02	; 2
   10b0a:	09 f4       	brne	.+2      	; 0x10b0e <FMenuTicket+0x2e>
   10b0c:	3f c0       	rjmp	.+126    	; 0x10b8c <FMenuTicket+0xac>
   10b0e:	83 30       	cpi	r24, 0x03	; 3
   10b10:	30 f4       	brcc	.+12     	; 0x10b1e <FMenuTicket+0x3e>
   10b12:	88 23       	and	r24, r24
   10b14:	09 f1       	breq	.+66     	; 0x10b58 <FMenuTicket+0x78>
   10b16:	81 30       	cpi	r24, 0x01	; 1
   10b18:	09 f0       	breq	.+2      	; 0x10b1c <FMenuTicket+0x3c>
   10b1a:	33 c1       	rjmp	.+614    	; 0x10d82 <FMenuTicket+0x2a2>
   10b1c:	1f c0       	rjmp	.+62     	; 0x10b5c <FMenuTicket+0x7c>
   10b1e:	84 30       	cpi	r24, 0x04	; 4
   10b20:	09 f4       	brne	.+2      	; 0x10b24 <FMenuTicket+0x44>
   10b22:	8d c0       	rjmp	.+282    	; 0x10c3e <FMenuTicket+0x15e>
   10b24:	85 30       	cpi	r24, 0x05	; 5
   10b26:	08 f0       	brcs	.+2      	; 0x10b2a <FMenuTicket+0x4a>
   10b28:	af c0       	rjmp	.+350    	; 0x10c88 <FMenuTicket+0x1a8>
   10b2a:	51 c0       	rjmp	.+162    	; 0x10bce <FMenuTicket+0xee>
   10b2c:	89 30       	cpi	r24, 0x09	; 9
   10b2e:	09 f4       	brne	.+2      	; 0x10b32 <FMenuTicket+0x52>
   10b30:	03 c1       	rjmp	.+518    	; 0x10d38 <FMenuTicket+0x258>
   10b32:	8a 30       	cpi	r24, 0x0A	; 10
   10b34:	38 f4       	brcc	.+14     	; 0x10b44 <FMenuTicket+0x64>
   10b36:	87 30       	cpi	r24, 0x07	; 7
   10b38:	09 f4       	brne	.+2      	; 0x10b3c <FMenuTicket+0x5c>
   10b3a:	df c0       	rjmp	.+446    	; 0x10cfa <FMenuTicket+0x21a>
   10b3c:	88 30       	cpi	r24, 0x08	; 8
   10b3e:	09 f0       	breq	.+2      	; 0x10b42 <FMenuTicket+0x62>
   10b40:	20 c1       	rjmp	.+576    	; 0x10d82 <FMenuTicket+0x2a2>
   10b42:	cb c0       	rjmp	.+406    	; 0x10cda <FMenuTicket+0x1fa>
   10b44:	8b 30       	cpi	r24, 0x0B	; 11
   10b46:	09 f4       	brne	.+2      	; 0x10b4a <FMenuTicket+0x6a>
   10b48:	fd c0       	rjmp	.+506    	; 0x10d44 <FMenuTicket+0x264>
   10b4a:	8b 30       	cpi	r24, 0x0B	; 11
   10b4c:	08 f4       	brcc	.+2      	; 0x10b50 <FMenuTicket+0x70>
   10b4e:	13 c1       	rjmp	.+550    	; 0x10d76 <FMenuTicket+0x296>
   10b50:	8c 30       	cpi	r24, 0x0C	; 12
   10b52:	09 f0       	breq	.+2      	; 0x10b56 <FMenuTicket+0x76>
   10b54:	16 c1       	rjmp	.+556    	; 0x10d82 <FMenuTicket+0x2a2>
   10b56:	11 c1       	rjmp	.+546    	; 0x10d7a <FMenuTicket+0x29a>
	case mtInit:
		 stMenuTicket=mtPlatNo;
   10b58:	81 e0       	ldi	r24, 0x01	; 1
   10b5a:	81 c0       	rjmp	.+258    	; 0x10c5e <FMenuTicket+0x17e>
	     break;
    case mtPlatNo:
	     lcd_clear();
   10b5c:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
	     lcd_printf(1,1,PSTR("Input Plat No: "));
   10b60:	81 e0       	ldi	r24, 0x01	; 1
   10b62:	61 e0       	ldi	r22, 0x01	; 1
   10b64:	4a e9       	ldi	r20, 0x9A	; 154
   10b66:	5b e0       	ldi	r21, 0x0B	; 11
   10b68:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	     lcd_printf(2,1,PSTR("_"));
   10b6c:	82 e0       	ldi	r24, 0x02	; 2
   10b6e:	61 e0       	ldi	r22, 0x01	; 1
   10b70:	48 e9       	ldi	r20, 0x98	; 152
   10b72:	5b e0       	ldi	r21, 0x0B	; 11
   10b74:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   10b78:	84 e0       	ldi	r24, 0x04	; 4
   10b7a:	61 e0       	ldi	r22, 0x01	; 1
   10b7c:	43 e8       	ldi	r20, 0x83	; 131
   10b7e:	5b e0       	ldi	r21, 0x0B	; 11
   10b80:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		 uiResult=USER_NONE;
   10b84:	10 92 ec 02 	sts	0x02EC, r1
		 stMenuTicket=mtInputPlatNo;
   10b88:	82 e0       	ldi	r24, 0x02	; 2
   10b8a:	69 c0       	rjmp	.+210    	; 0x10c5e <FMenuTicket+0x17e>
	     break;
    case mtInputPlatNo:
	     uiResult=UserInput(UI_ALPHANUM_R,2,1,strLicPlate,0,10);
   10b8c:	83 e0       	ldi	r24, 0x03	; 3
   10b8e:	62 e0       	ldi	r22, 0x02	; 2
   10b90:	41 e0       	ldi	r20, 0x01	; 1
   10b92:	22 e0       	ldi	r18, 0x02	; 2
   10b94:	3b e0       	ldi	r19, 0x0B	; 11
   10b96:	00 e0       	ldi	r16, 0x00	; 0
   10b98:	10 e0       	ldi	r17, 0x00	; 0
   10b9a:	7a e0       	ldi	r23, 0x0A	; 10
   10b9c:	e7 2e       	mov	r14, r23
   10b9e:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
   10ba2:	80 93 ec 02 	sts	0x02EC, r24
		 if (uiResult==USER_OK)stMenuTicket=mtOdometer;
   10ba6:	83 30       	cpi	r24, 0x03	; 3
   10ba8:	09 f4       	brne	.+2      	; 0x10bac <FMenuTicket+0xcc>
   10baa:	59 c0       	rjmp	.+178    	; 0x10c5e <FMenuTicket+0x17e>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtExitMenuTicket;
   10bac:	81 30       	cpi	r24, 0x01	; 1
   10bae:	09 f4       	brne	.+2      	; 0x10bb2 <FMenuTicket+0xd2>
   10bb0:	e2 c0       	rjmp	.+452    	; 0x10d76 <FMenuTicket+0x296>
         else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10bb2:	84 30       	cpi	r24, 0x04	; 4
   10bb4:	21 f4       	brne	.+8      	; 0x10bbe <FMenuTicket+0xde>
   10bb6:	61 e0       	ldi	r22, 0x01	; 1
   10bb8:	4e e6       	ldi	r20, 0x6E	; 110
   10bba:	5b e0       	ldi	r21, 0x0B	; 11
   10bbc:	62 c0       	rjmp	.+196    	; 0x10c82 <FMenuTicket+0x1a2>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10bbe:	85 30       	cpi	r24, 0x05	; 5
   10bc0:	09 f0       	breq	.+2      	; 0x10bc4 <FMenuTicket+0xe4>
   10bc2:	df c0       	rjmp	.+446    	; 0x10d82 <FMenuTicket+0x2a2>
   10bc4:	84 e0       	ldi	r24, 0x04	; 4
   10bc6:	61 e0       	ldi	r22, 0x01	; 1
   10bc8:	49 e5       	ldi	r20, 0x59	; 89
   10bca:	5b e0       	ldi	r21, 0x0B	; 11
   10bcc:	5a c0       	rjmp	.+180    	; 0x10c82 <FMenuTicket+0x1a2>
	     break;
    case mtOdometer:
	     lcd_clear();
   10bce:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		 sprintf_P(lcdteks,PSTR("Plat No: %s "),strLicPlate);
   10bd2:	00 d0       	rcall	.+0      	; 0x10bd4 <FMenuTicket+0xf4>
   10bd4:	00 d0       	rcall	.+0      	; 0x10bd6 <FMenuTicket+0xf6>
   10bd6:	00 d0       	rcall	.+0      	; 0x10bd8 <FMenuTicket+0xf8>
   10bd8:	ed b7       	in	r30, 0x3d	; 61
   10bda:	fe b7       	in	r31, 0x3e	; 62
   10bdc:	31 96       	adiw	r30, 0x01	; 1
   10bde:	8e 01       	movw	r16, r28
   10be0:	0f 5f       	subi	r16, 0xFF	; 255
   10be2:	1f 4f       	sbci	r17, 0xFF	; 255
   10be4:	ad b7       	in	r26, 0x3d	; 61
   10be6:	be b7       	in	r27, 0x3e	; 62
   10be8:	12 96       	adiw	r26, 0x02	; 2
   10bea:	1c 93       	st	X, r17
   10bec:	0e 93       	st	-X, r16
   10bee:	11 97       	sbiw	r26, 0x01	; 1
   10bf0:	8c e4       	ldi	r24, 0x4C	; 76
   10bf2:	9b e0       	ldi	r25, 0x0B	; 11
   10bf4:	93 83       	std	Z+3, r25	; 0x03
   10bf6:	82 83       	std	Z+2, r24	; 0x02
   10bf8:	82 e0       	ldi	r24, 0x02	; 2
   10bfa:	9b e0       	ldi	r25, 0x0B	; 11
   10bfc:	95 83       	std	Z+5, r25	; 0x05
   10bfe:	84 83       	std	Z+4, r24	; 0x04
   10c00:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
	     lcd_print(1,1,lcdteks);
   10c04:	8d b7       	in	r24, 0x3d	; 61
   10c06:	9e b7       	in	r25, 0x3e	; 62
   10c08:	06 96       	adiw	r24, 0x06	; 6
   10c0a:	0f b6       	in	r0, 0x3f	; 63
   10c0c:	f8 94       	cli
   10c0e:	9e bf       	out	0x3e, r25	; 62
   10c10:	0f be       	out	0x3f, r0	; 63
   10c12:	8d bf       	out	0x3d, r24	; 61
   10c14:	81 e0       	ldi	r24, 0x01	; 1
   10c16:	61 e0       	ldi	r22, 0x01	; 1
   10c18:	a8 01       	movw	r20, r16
   10c1a:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	     lcd_printf(2,1,PSTR("Odometer:_ "));
   10c1e:	82 e0       	ldi	r24, 0x02	; 2
   10c20:	61 e0       	ldi	r22, 0x01	; 1
   10c22:	40 e4       	ldi	r20, 0x40	; 64
   10c24:	5b e0       	ldi	r21, 0x0B	; 11
   10c26:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   10c2a:	84 e0       	ldi	r24, 0x04	; 4
   10c2c:	61 e0       	ldi	r22, 0x01	; 1
   10c2e:	4b e2       	ldi	r20, 0x2B	; 43
   10c30:	5b e0       	ldi	r21, 0x0B	; 11
   10c32:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		 uiResult=USER_NONE;
   10c36:	10 92 ec 02 	sts	0x02EC, r1
		 stMenuTicket=mtInputOdometer;
   10c3a:	84 e0       	ldi	r24, 0x04	; 4
   10c3c:	10 c0       	rjmp	.+32     	; 0x10c5e <FMenuTicket+0x17e>
	     break;
    case mtInputOdometer:
	     uiResult=UserInput(UI_NUMBER_R,2,10,strOdometer,0,10);
   10c3e:	81 e0       	ldi	r24, 0x01	; 1
   10c40:	62 e0       	ldi	r22, 0x02	; 2
   10c42:	4a e0       	ldi	r20, 0x0A	; 10
   10c44:	29 ec       	ldi	r18, 0xC9	; 201
   10c46:	35 e0       	ldi	r19, 0x05	; 5
   10c48:	00 e0       	ldi	r16, 0x00	; 0
   10c4a:	10 e0       	ldi	r17, 0x00	; 0
   10c4c:	5a e0       	ldi	r21, 0x0A	; 10
   10c4e:	e5 2e       	mov	r14, r21
   10c50:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
   10c54:	80 93 ec 02 	sts	0x02EC, r24
		 if (uiResult==USER_OK)stMenuTicket=mtFIP;
   10c58:	83 30       	cpi	r24, 0x03	; 3
   10c5a:	21 f4       	brne	.+8      	; 0x10c64 <FMenuTicket+0x184>
   10c5c:	85 e0       	ldi	r24, 0x05	; 5
   10c5e:	80 93 ed 02 	sts	0x02ED, r24
   10c62:	8f c0       	rjmp	.+286    	; 0x10d82 <FMenuTicket+0x2a2>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtPlatNo;
   10c64:	81 30       	cpi	r24, 0x01	; 1
   10c66:	d9 f3       	breq	.-10     	; 0x10c5e <FMenuTicket+0x17e>
		 else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10c68:	84 30       	cpi	r24, 0x04	; 4
   10c6a:	21 f4       	brne	.+8      	; 0x10c74 <FMenuTicket+0x194>
   10c6c:	61 e0       	ldi	r22, 0x01	; 1
   10c6e:	46 e1       	ldi	r20, 0x16	; 22
   10c70:	5b e0       	ldi	r21, 0x0B	; 11
   10c72:	07 c0       	rjmp	.+14     	; 0x10c82 <FMenuTicket+0x1a2>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10c74:	85 30       	cpi	r24, 0x05	; 5
   10c76:	09 f0       	breq	.+2      	; 0x10c7a <FMenuTicket+0x19a>
   10c78:	84 c0       	rjmp	.+264    	; 0x10d82 <FMenuTicket+0x2a2>
   10c7a:	84 e0       	ldi	r24, 0x04	; 4
   10c7c:	61 e0       	ldi	r22, 0x01	; 1
   10c7e:	41 e0       	ldi	r20, 0x01	; 1
   10c80:	5b e0       	ldi	r21, 0x0B	; 11
   10c82:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
   10c86:	7d c0       	rjmp	.+250    	; 0x10d82 <FMenuTicket+0x2a2>
	     break;
    case mtFIP:
	     lcd_clear();
   10c88:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		 _scr_pump();
   10c8c:	0e 94 16 41 	call	0x822c	; 0x822c <_scr_pump>
		 stMenuTicket=mtInputFIP;
   10c90:	86 e0       	ldi	r24, 0x06	; 6
   10c92:	e5 cf       	rjmp	.-54     	; 0x10c5e <FMenuTicket+0x17e>
	     break;
    case mtInputFIP:
	     KeyPressed=_key_scan(1);
   10c94:	81 e0       	ldi	r24, 0x01	; 1
   10c96:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   10c9a:	80 93 e9 02 	sts	0x02E9, r24
		 KeyChar=_key_btn(KeyPressed);
   10c9e:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   10ca2:	80 93 e8 02 	sts	0x02E8, r24
		 if ((KeyChar>='1')&&(KeyChar<='8')){
   10ca6:	81 53       	subi	r24, 0x31	; 49
   10ca8:	88 30       	cpi	r24, 0x08	; 8
   10caa:	40 f4       	brcc	.+16     	; 0x10cbc <FMenuTicket+0x1dc>
		     FIP_Used=KeyChar-'0';
   10cac:	8f 5f       	subi	r24, 0xFF	; 255
   10cae:	80 93 e7 02 	sts	0x02E7, r24
			 zFIP_Used=FIP_Used;
   10cb2:	80 93 e6 02 	sts	0x02E6, r24
		     stMenuTicket=mtSendMsg98;
   10cb6:	87 e0       	ldi	r24, 0x07	; 7
   10cb8:	80 93 ed 02 	sts	0x02ED, r24
		 }
		 if (KeyPressed==_KEY_CANCEL){
   10cbc:	80 91 e9 02 	lds	r24, 0x02E9
   10cc0:	87 3e       	cpi	r24, 0xE7	; 231
   10cc2:	11 f4       	brne	.+4      	; 0x10cc8 <FMenuTicket+0x1e8>
             stMenuTicket=mtOdometer;
   10cc4:	83 e0       	ldi	r24, 0x03	; 3
   10cc6:	cb cf       	rjmp	.-106    	; 0x10c5e <FMenuTicket+0x17e>
		 }else
		 if (KeyPressed==_KEY_ENTER){
   10cc8:	87 3b       	cpi	r24, 0xB7	; 183
   10cca:	09 f0       	breq	.+2      	; 0x10cce <FMenuTicket+0x1ee>
   10ccc:	5a c0       	rjmp	.+180    	; 0x10d82 <FMenuTicket+0x2a2>
		     FIP_Used=zFIP_Used;
   10cce:	80 91 e6 02 	lds	r24, 0x02E6
   10cd2:	80 93 e7 02 	sts	0x02E7, r24
             stMenuTicket=mtInitWaitMessage99;
   10cd6:	88 e0       	ldi	r24, 0x08	; 8
   10cd8:	c2 cf       	rjmp	.-124    	; 0x10c5e <FMenuTicket+0x17e>
		 }
	     break;	
    case mtInitWaitMessage99:
	     lcd_clear();
   10cda:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		 lcd_printf(2,1,PSTR("Send Request"));
   10cde:	82 e0       	ldi	r24, 0x02	; 2
   10ce0:	61 e0       	ldi	r22, 0x01	; 1
   10ce2:	44 ef       	ldi	r20, 0xF4	; 244
   10ce4:	5a e0       	ldi	r21, 0x0A	; 10
   10ce6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		 lcd_printf(3,1,PSTR("Proses"));
   10cea:	83 e0       	ldi	r24, 0x03	; 3
   10cec:	61 e0       	ldi	r22, 0x01	; 1
   10cee:	4d ee       	ldi	r20, 0xED	; 237
   10cf0:	5a e0       	ldi	r21, 0x0A	; 10
   10cf2:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
         stMenuTicket=mtSendMsg98;
   10cf6:	87 e0       	ldi	r24, 0x07	; 7
   10cf8:	b2 cf       	rjmp	.-156    	; 0x10c5e <FMenuTicket+0x17e>
	     break;
    case mtSendMsg98:
	     iPos=0;
   10cfa:	10 92 eb 02 	sts	0x02EB, r1
		 iSend=0;
   10cfe:	10 92 ea 02 	sts	0x02EA, r1
		 IsMessage99=False;
   10d02:	10 92 cc 01 	sts	0x01CC, r1
		 TimSend=0;
   10d06:	10 92 be 01 	sts	0x01BE, r1
   10d0a:	10 92 bd 01 	sts	0x01BD, r1
		 iLoop=0;
   10d0e:	10 92 e5 02 	sts	0x02E5, r1
   10d12:	10 92 e4 02 	sts	0x02E4, r1
		 if (IFType==IT_SLAVE)sendMessage98(FIP_Used);
   10d16:	80 91 25 01 	lds	r24, 0x0125
   10d1a:	81 30       	cpi	r24, 0x01	; 1
   10d1c:	29 f4       	brne	.+10     	; 0x10d28 <FMenuTicket+0x248>
   10d1e:	80 91 e7 02 	lds	r24, 0x02E7
   10d22:	0e 94 5f 4b 	call	0x96be	; 0x96be <sendMessage98>
   10d26:	27 c0       	rjmp	.+78     	; 0x10d76 <FMenuTicket+0x296>
		 else 
		 if (IFType==IT_STANDALONE)PrintStandalone(FIP_Used,False);
   10d28:	82 30       	cpi	r24, 0x02	; 2
   10d2a:	29 f5       	brne	.+74     	; 0x10d76 <FMenuTicket+0x296>
   10d2c:	80 91 e7 02 	lds	r24, 0x02E7
   10d30:	60 e0       	ldi	r22, 0x00	; 0
   10d32:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <PrintStandalone>
   10d36:	1f c0       	rjmp	.+62     	; 0x10d76 <FMenuTicket+0x296>
	                     stMenuTicket=mtSendMsg98;
				  }
			 }
		 }
		 */
		 if (IsMessage99==True){ 
   10d38:	80 91 cc 01 	lds	r24, 0x01CC
   10d3c:	81 30       	cpi	r24, 0x01	; 1
   10d3e:	09 f5       	brne	.+66     	; 0x10d82 <FMenuTicket+0x2a2>
		    stMenuTicket=mtMessage99Received;
   10d40:	8a e0       	ldi	r24, 0x0A	; 10
   10d42:	8d cf       	rjmp	.-230    	; 0x10c5e <FMenuTicket+0x17e>
	     break;
    case mtMessage99Received:
	     stMenuTicket=mtExitMenuTicket;
		 break;
    case mtNoConnection:
	     lcd_clear();
   10d44:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		 lcd_printf(2,1,PSTR("Error No Connection"));
   10d48:	82 e0       	ldi	r24, 0x02	; 2
   10d4a:	61 e0       	ldi	r22, 0x01	; 1
   10d4c:	49 ed       	ldi	r20, 0xD9	; 217
   10d4e:	5a e0       	ldi	r21, 0x0A	; 10
   10d50:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   10d54:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   10d56:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   10d58:	82 e0       	ldi	r24, 0x02	; 2
   10d5a:	90 e0       	ldi	r25, 0x00	; 0
   10d5c:	90 93 ec 01 	sts	0x01EC, r25
   10d60:	80 93 eb 01 	sts	0x01EB, r24
   10d64:	80 e2       	ldi	r24, 0x20	; 32
   10d66:	9e e4       	ldi	r25, 0x4E	; 78
   10d68:	29 e1       	ldi	r18, 0x19	; 25
   10d6a:	30 e0       	ldi	r19, 0x00	; 0
   10d6c:	f9 01       	movw	r30, r18
   10d6e:	31 97       	sbiw	r30, 0x01	; 1
   10d70:	f1 f7       	brne	.-4      	; 0x10d6e <FMenuTicket+0x28e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   10d72:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   10d74:	d9 f7       	brne	.-10     	; 0x10d6c <FMenuTicket+0x28c>
    case mtNoConnection:
	     lcd_clear();
		 lcd_printf(2,1,PSTR("Error No Connection"));
		 system_beep(2);
		 _delay_ms(2000);
         stMenuTicket=mtExitMenuTicket;
   10d76:	8c e0       	ldi	r24, 0x0C	; 12
   10d78:	72 cf       	rjmp	.-284    	; 0x10c5e <FMenuTicket+0x17e>
	     break;
    case mtExitMenuTicket:
	     Result=MENU_DONE;
	     stMenuTicket=mtInit;
   10d7a:	10 92 ed 02 	sts	0x02ED, r1
   10d7e:	81 e0       	ldi	r24, 0x01	; 1
   10d80:	01 c0       	rjmp	.+2      	; 0x10d84 <FMenuTicket+0x2a4>
   10d82:	80 e0       	ldi	r24, 0x00	; 0
	     break;
	}
  return Result;
}
   10d84:	64 96       	adiw	r28, 0x14	; 20
   10d86:	0f b6       	in	r0, 0x3f	; 63
   10d88:	f8 94       	cli
   10d8a:	de bf       	out	0x3e, r29	; 62
   10d8c:	0f be       	out	0x3f, r0	; 63
   10d8e:	cd bf       	out	0x3d, r28	; 61
   10d90:	cf 91       	pop	r28
   10d92:	df 91       	pop	r29
   10d94:	1f 91       	pop	r17
   10d96:	0f 91       	pop	r16
   10d98:	ef 90       	pop	r14
   10d9a:	08 95       	ret

00010d9c <FSettingProduct>:

void menu_product(){

}

char FSettingProduct(){//Using strDescription
   10d9c:	6f 92       	push	r6
   10d9e:	7f 92       	push	r7
   10da0:	8f 92       	push	r8
   10da2:	9f 92       	push	r9
   10da4:	af 92       	push	r10
   10da6:	bf 92       	push	r11
   10da8:	cf 92       	push	r12
   10daa:	df 92       	push	r13
   10dac:	ef 92       	push	r14
   10dae:	ff 92       	push	r15
   10db0:	0f 93       	push	r16
   10db2:	1f 93       	push	r17
   10db4:	df 93       	push	r29
   10db6:	cf 93       	push	r28
   10db8:	cd b7       	in	r28, 0x3d	; 61
   10dba:	de b7       	in	r29, 0x3e	; 62
   10dbc:	a1 97       	sbiw	r28, 0x21	; 33
   10dbe:	0f b6       	in	r0, 0x3f	; 63
   10dc0:	f8 94       	cli
   10dc2:	de bf       	out	0x3e, r29	; 62
   10dc4:	0f be       	out	0x3f, r0	; 63
   10dc6:	cd bf       	out	0x3d, r28	; 61
     char x,y,i;
	 char strProductName[13],lcdteks[20];
	 char Result=MENU_NONE;
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
   10dc8:	80 91 0a 03 	lds	r24, 0x030A
   10dcc:	83 30       	cpi	r24, 0x03	; 3
   10dce:	09 f4       	brne	.+2      	; 0x10dd2 <FSettingProduct+0x36>
   10dd0:	ff c0       	rjmp	.+510    	; 0x10fd0 <FSettingProduct+0x234>
   10dd2:	84 30       	cpi	r24, 0x04	; 4
   10dd4:	38 f4       	brcc	.+14     	; 0x10de4 <FSettingProduct+0x48>
   10dd6:	81 30       	cpi	r24, 0x01	; 1
   10dd8:	09 f4       	brne	.+2      	; 0x10ddc <FSettingProduct+0x40>
   10dda:	72 c0       	rjmp	.+228    	; 0x10ec0 <FSettingProduct+0x124>
   10ddc:	82 30       	cpi	r24, 0x02	; 2
   10dde:	08 f0       	brcs	.+2      	; 0x10de2 <FSettingProduct+0x46>
   10de0:	82 c0       	rjmp	.+260    	; 0x10ee6 <FSettingProduct+0x14a>
   10de2:	0a c0       	rjmp	.+20     	; 0x10df8 <FSettingProduct+0x5c>
   10de4:	85 30       	cpi	r24, 0x05	; 5
   10de6:	09 f4       	brne	.+2      	; 0x10dea <FSettingProduct+0x4e>
   10de8:	83 c1       	rjmp	.+774    	; 0x110f0 <FSettingProduct+0x354>
   10dea:	85 30       	cpi	r24, 0x05	; 5
   10dec:	08 f4       	brcc	.+2      	; 0x10df0 <FSettingProduct+0x54>
   10dee:	a2 c1       	rjmp	.+836    	; 0x11134 <FSettingProduct+0x398>
   10df0:	86 30       	cpi	r24, 0x06	; 6
   10df2:	09 f0       	breq	.+2      	; 0x10df6 <FSettingProduct+0x5a>
   10df4:	c9 c1       	rjmp	.+914    	; 0x11188 <FSettingProduct+0x3ec>
   10df6:	c4 c1       	rjmp	.+904    	; 0x11180 <FSettingProduct+0x3e4>
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   10df8:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
   10dfc:	9b ee       	ldi	r25, 0xEB	; 235
   10dfe:	c9 2e       	mov	r12, r25
   10e00:	90 e0       	ldi	r25, 0x00	; 0
   10e02:	d9 2e       	mov	r13, r25
   10e04:	81 e0       	ldi	r24, 0x01	; 1
   10e06:	e8 2e       	mov	r14, r24
   10e08:	f1 2c       	mov	r15, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   10e0a:	4e 01       	movw	r8, r28
   10e0c:	08 94       	sec
   10e0e:	81 1c       	adc	r8, r1
   10e10:	91 1c       	adc	r9, r1
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   10e12:	0e e0       	ldi	r16, 0x0E	; 14
   10e14:	a0 2e       	mov	r10, r16
   10e16:	b1 2c       	mov	r11, r1
   10e18:	ac 0e       	add	r10, r28
   10e1a:	bd 1e       	adc	r11, r29
   10e1c:	1c e9       	ldi	r17, 0x9C	; 156
   10e1e:	61 2e       	mov	r6, r17
   10e20:	10 e1       	ldi	r17, 0x10	; 16
   10e22:	71 2e       	mov	r7, r17
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   10e24:	0a e0       	ldi	r16, 0x0A	; 10
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   10e26:	1e 2d       	mov	r17, r14
   10e28:	11 50       	subi	r17, 0x01	; 1
   10e2a:	c4 01       	movw	r24, r8
   10e2c:	b6 01       	movw	r22, r12
   10e2e:	4d e0       	ldi	r20, 0x0D	; 13
   10e30:	50 e0       	ldi	r21, 0x00	; 0
   10e32:	2c ea       	ldi	r18, 0xAC	; 172
   10e34:	32 e1       	ldi	r19, 0x12	; 18
   10e36:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   10e3a:	8d b7       	in	r24, 0x3d	; 61
   10e3c:	9e b7       	in	r25, 0x3e	; 62
   10e3e:	08 97       	sbiw	r24, 0x08	; 8
   10e40:	0f b6       	in	r0, 0x3f	; 63
   10e42:	f8 94       	cli
   10e44:	9e bf       	out	0x3e, r25	; 62
   10e46:	0f be       	out	0x3f, r0	; 63
   10e48:	8d bf       	out	0x3d, r24	; 61
   10e4a:	ed b7       	in	r30, 0x3d	; 61
   10e4c:	fe b7       	in	r31, 0x3e	; 62
   10e4e:	31 96       	adiw	r30, 0x01	; 1
   10e50:	ad b7       	in	r26, 0x3d	; 61
   10e52:	be b7       	in	r27, 0x3e	; 62
   10e54:	12 96       	adiw	r26, 0x02	; 2
   10e56:	bc 92       	st	X, r11
   10e58:	ae 92       	st	-X, r10
   10e5a:	11 97       	sbiw	r26, 0x01	; 1
   10e5c:	73 82       	std	Z+3, r7	; 0x03
   10e5e:	62 82       	std	Z+2, r6	; 0x02
   10e60:	f5 82       	std	Z+5, r15	; 0x05
   10e62:	e4 82       	std	Z+4, r14	; 0x04
   10e64:	97 82       	std	Z+7, r9	; 0x07
   10e66:	86 82       	std	Z+6, r8	; 0x06
   10e68:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   10e6c:	8d b7       	in	r24, 0x3d	; 61
   10e6e:	9e b7       	in	r25, 0x3e	; 62
   10e70:	08 96       	adiw	r24, 0x08	; 8
   10e72:	0f b6       	in	r0, 0x3f	; 63
   10e74:	f8 94       	cli
   10e76:	9e bf       	out	0x3e, r25	; 62
   10e78:	0f be       	out	0x3f, r0	; 63
   10e7a:	8d bf       	out	0x3d, r24	; 61
   10e7c:	61 2f       	mov	r22, r17
   10e7e:	66 95       	lsr	r22
   10e80:	66 95       	lsr	r22
   10e82:	60 9f       	mul	r22, r16
   10e84:	b0 01       	movw	r22, r0
   10e86:	11 24       	eor	r1, r1
   10e88:	6f 5f       	subi	r22, 0xFF	; 255
   10e8a:	13 70       	andi	r17, 0x03	; 3
   10e8c:	81 2f       	mov	r24, r17
   10e8e:	8f 5f       	subi	r24, 0xFF	; 255
   10e90:	a5 01       	movw	r20, r10
   10e92:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
   10e96:	ad e0       	ldi	r26, 0x0D	; 13
   10e98:	b0 e0       	ldi	r27, 0x00	; 0
   10e9a:	ca 0e       	add	r12, r26
   10e9c:	db 1e       	adc	r13, r27
   10e9e:	08 94       	sec
   10ea0:	e1 1c       	adc	r14, r1
   10ea2:	f1 1c       	adc	r15, r1
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
   10ea4:	b9 e3       	ldi	r27, 0x39	; 57
   10ea6:	cb 16       	cp	r12, r27
   10ea8:	b1 e0       	ldi	r27, 0x01	; 1
   10eaa:	db 06       	cpc	r13, r27
   10eac:	09 f0       	breq	.+2      	; 0x10eb0 <FSettingProduct+0x114>
   10eae:	bb cf       	rjmp	.-138    	; 0x10e26 <FSettingProduct+0x8a>
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
		  }
		  lcd_printf(4,11,PSTR("*)Back"));
   10eb0:	84 e0       	ldi	r24, 0x04	; 4
   10eb2:	6b e0       	ldi	r22, 0x0B	; 11
   10eb4:	45 e9       	ldi	r20, 0x95	; 149
   10eb6:	50 e1       	ldi	r21, 0x10	; 16
   10eb8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
          stMenuProduct=mpChangeProduct;
   10ebc:	81 e0       	ldi	r24, 0x01	; 1
   10ebe:	5a c1       	rjmp	.+692    	; 0x11174 <FSettingProduct+0x3d8>
	      break;
     case mpChangeProduct:
		  KeyPressed=_key_scan(1);
   10ec0:	81 e0       	ldi	r24, 0x01	; 1
   10ec2:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   10ec6:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   10ec8:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   10ecc:	81 53       	subi	r24, 0x31	; 49
   10ece:	86 30       	cpi	r24, 0x06	; 6
   10ed0:	28 f4       	brcc	.+10     	; 0x10edc <FSettingProduct+0x140>
		      ProdID=KeyChar-'1';
   10ed2:	80 93 09 03 	sts	0x0309, r24
			  stMenuProduct=mpDispPrice;
   10ed6:	82 e0       	ldi	r24, 0x02	; 2
   10ed8:	80 93 0a 03 	sts	0x030A, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
   10edc:	17 3e       	cpi	r17, 0xE7	; 231
   10ede:	09 f0       	breq	.+2      	; 0x10ee2 <FSettingProduct+0x146>
   10ee0:	53 c1       	rjmp	.+678    	; 0x11188 <FSettingProduct+0x3ec>
		      stMenuProduct=mpExitMenuProduct;
   10ee2:	86 e0       	ldi	r24, 0x06	; 6
   10ee4:	47 c1       	rjmp	.+654    	; 0x11174 <FSettingProduct+0x3d8>
   10ee6:	60 91 09 03 	lds	r22, 0x0309
   10eea:	8d e0       	ldi	r24, 0x0D	; 13
   10eec:	68 9f       	mul	r22, r24
   10eee:	b0 01       	movw	r22, r0
   10ef0:	11 24       	eor	r1, r1
   10ef2:	65 51       	subi	r22, 0x15	; 21
   10ef4:	7f 4f       	sbci	r23, 0xFF	; 255
   10ef6:	7e 01       	movw	r14, r28
   10ef8:	08 94       	sec
   10efa:	e1 1c       	adc	r14, r1
   10efc:	f1 1c       	adc	r15, r1
   10efe:	c7 01       	movw	r24, r14
   10f00:	4d e0       	ldi	r20, 0x0D	; 13
   10f02:	50 e0       	ldi	r21, 0x00	; 0
   10f04:	2c ea       	ldi	r18, 0xAC	; 172
   10f06:	32 e1       	ldi	r19, 0x12	; 18
   10f08:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
		  }
	      break;
     case mpDispPrice:
	 	  eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		  eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[ProdID], 9);
		  sprintf_P(lcdteks,PSTR("1)%s"),strProductName);
   10f0c:	bf ef       	ldi	r27, 0xFF	; 255
   10f0e:	cb 2e       	mov	r12, r27
   10f10:	b2 e0       	ldi	r27, 0x02	; 2
   10f12:	db 2e       	mov	r13, r27
   10f14:	60 91 09 03 	lds	r22, 0x0309
   10f18:	89 e0       	ldi	r24, 0x09	; 9
   10f1a:	68 9f       	mul	r22, r24
   10f1c:	b0 01       	movw	r22, r0
   10f1e:	11 24       	eor	r1, r1
   10f20:	6b 54       	subi	r22, 0x4B	; 75
   10f22:	7f 4f       	sbci	r23, 0xFF	; 255
   10f24:	c6 01       	movw	r24, r12
   10f26:	49 e0       	ldi	r20, 0x09	; 9
   10f28:	50 e0       	ldi	r21, 0x00	; 0
   10f2a:	2c ea       	ldi	r18, 0xAC	; 172
   10f2c:	32 e1       	ldi	r19, 0x12	; 18
   10f2e:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
   10f32:	00 d0       	rcall	.+0      	; 0x10f34 <FSettingProduct+0x198>
   10f34:	00 d0       	rcall	.+0      	; 0x10f36 <FSettingProduct+0x19a>
   10f36:	00 d0       	rcall	.+0      	; 0x10f38 <FSettingProduct+0x19c>
   10f38:	ed b7       	in	r30, 0x3d	; 61
   10f3a:	fe b7       	in	r31, 0x3e	; 62
   10f3c:	31 96       	adiw	r30, 0x01	; 1
   10f3e:	8e 01       	movw	r16, r28
   10f40:	02 5f       	subi	r16, 0xF2	; 242
   10f42:	1f 4f       	sbci	r17, 0xFF	; 255
   10f44:	ad b7       	in	r26, 0x3d	; 61
   10f46:	be b7       	in	r27, 0x3e	; 62
   10f48:	12 96       	adiw	r26, 0x02	; 2
   10f4a:	1c 93       	st	X, r17
   10f4c:	0e 93       	st	-X, r16
   10f4e:	11 97       	sbiw	r26, 0x01	; 1
   10f50:	80 e9       	ldi	r24, 0x90	; 144
   10f52:	90 e1       	ldi	r25, 0x10	; 16
   10f54:	93 83       	std	Z+3, r25	; 0x03
   10f56:	82 83       	std	Z+2, r24	; 0x02
   10f58:	f5 82       	std	Z+5, r15	; 0x05
   10f5a:	e4 82       	std	Z+4, r14	; 0x04
   10f5c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_clear();lcd_print(1,1,lcdteks);
   10f60:	8d b7       	in	r24, 0x3d	; 61
   10f62:	9e b7       	in	r25, 0x3e	; 62
   10f64:	06 96       	adiw	r24, 0x06	; 6
   10f66:	0f b6       	in	r0, 0x3f	; 63
   10f68:	f8 94       	cli
   10f6a:	9e bf       	out	0x3e, r25	; 62
   10f6c:	0f be       	out	0x3f, r0	; 63
   10f6e:	8d bf       	out	0x3d, r24	; 61
   10f70:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
   10f74:	81 e0       	ldi	r24, 0x01	; 1
   10f76:	61 e0       	ldi	r22, 0x01	; 1
   10f78:	a8 01       	movw	r20, r16
   10f7a:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2)%s"),strPrice);
   10f7e:	00 d0       	rcall	.+0      	; 0x10f80 <FSettingProduct+0x1e4>
   10f80:	00 d0       	rcall	.+0      	; 0x10f82 <FSettingProduct+0x1e6>
   10f82:	00 d0       	rcall	.+0      	; 0x10f84 <FSettingProduct+0x1e8>
   10f84:	ed b7       	in	r30, 0x3d	; 61
   10f86:	fe b7       	in	r31, 0x3e	; 62
   10f88:	31 96       	adiw	r30, 0x01	; 1
   10f8a:	ad b7       	in	r26, 0x3d	; 61
   10f8c:	be b7       	in	r27, 0x3e	; 62
   10f8e:	12 96       	adiw	r26, 0x02	; 2
   10f90:	1c 93       	st	X, r17
   10f92:	0e 93       	st	-X, r16
   10f94:	11 97       	sbiw	r26, 0x01	; 1
   10f96:	8b e8       	ldi	r24, 0x8B	; 139
   10f98:	90 e1       	ldi	r25, 0x10	; 16
   10f9a:	93 83       	std	Z+3, r25	; 0x03
   10f9c:	82 83       	std	Z+2, r24	; 0x02
   10f9e:	d5 82       	std	Z+5, r13	; 0x05
   10fa0:	c4 82       	std	Z+4, r12	; 0x04
   10fa2:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   10fa6:	8d b7       	in	r24, 0x3d	; 61
   10fa8:	9e b7       	in	r25, 0x3e	; 62
   10faa:	06 96       	adiw	r24, 0x06	; 6
   10fac:	0f b6       	in	r0, 0x3f	; 63
   10fae:	f8 94       	cli
   10fb0:	9e bf       	out	0x3e, r25	; 62
   10fb2:	0f be       	out	0x3f, r0	; 63
   10fb4:	8d bf       	out	0x3d, r24	; 61
   10fb6:	82 e0       	ldi	r24, 0x02	; 2
   10fb8:	61 e0       	ldi	r22, 0x01	; 1
   10fba:	a8 01       	movw	r20, r16
   10fbc:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_printf(4,1,PSTR("*)Back       "));
   10fc0:	84 e0       	ldi	r24, 0x04	; 4
   10fc2:	61 e0       	ldi	r22, 0x01	; 1
   10fc4:	4d e7       	ldi	r20, 0x7D	; 125
   10fc6:	50 e1       	ldi	r21, 0x10	; 16
   10fc8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  stMenuProduct=mpIsEdit;
   10fcc:	83 e0       	ldi	r24, 0x03	; 3
   10fce:	d2 c0       	rjmp	.+420    	; 0x11174 <FSettingProduct+0x3d8>
	      break;
     case mpIsEdit:
		  KeyPressed=_key_scan(1);
   10fd0:	81 e0       	ldi	r24, 0x01	; 1
   10fd2:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   10fd6:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
		  if (KeyChar=='*'){
   10fda:	8a 32       	cpi	r24, 0x2A	; 42
   10fdc:	09 f4       	brne	.+2      	; 0x10fe0 <FSettingProduct+0x244>
   10fde:	a7 c0       	rjmp	.+334    	; 0x1112e <FSettingProduct+0x392>
		      stMenuProduct=mpInitProduct;
		  }else
		  if (KeyChar=='1'){
   10fe0:	81 33       	cpi	r24, 0x31	; 49
   10fe2:	09 f0       	breq	.+2      	; 0x10fe6 <FSettingProduct+0x24a>
   10fe4:	4c c0       	rjmp	.+152    	; 0x1107e <FSettingProduct+0x2e2>
   10fe6:	60 91 09 03 	lds	r22, 0x0309
   10fea:	8d e0       	ldi	r24, 0x0D	; 13
   10fec:	68 9f       	mul	r22, r24
   10fee:	b0 01       	movw	r22, r0
   10ff0:	11 24       	eor	r1, r1
   10ff2:	65 51       	subi	r22, 0x15	; 21
   10ff4:	7f 4f       	sbci	r23, 0xFF	; 255
   10ff6:	8e 01       	movw	r16, r28
   10ff8:	0f 5f       	subi	r16, 0xFF	; 255
   10ffa:	1f 4f       	sbci	r17, 0xFF	; 255
   10ffc:	c8 01       	movw	r24, r16
   10ffe:	4d e0       	ldi	r20, 0x0D	; 13
   11000:	50 e0       	ldi	r21, 0x00	; 0
   11002:	2c ea       	ldi	r18, 0xAC	; 172
   11004:	32 e1       	ldi	r19, 0x12	; 18
   11006:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
		      eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		      sprintf_P(lcdteks,PSTR("Old:%s"),strProductName);
   1100a:	00 d0       	rcall	.+0      	; 0x1100c <FSettingProduct+0x270>
   1100c:	00 d0       	rcall	.+0      	; 0x1100e <FSettingProduct+0x272>
   1100e:	00 d0       	rcall	.+0      	; 0x11010 <FSettingProduct+0x274>
   11010:	ed b7       	in	r30, 0x3d	; 61
   11012:	fe b7       	in	r31, 0x3e	; 62
   11014:	31 96       	adiw	r30, 0x01	; 1
   11016:	ae e0       	ldi	r26, 0x0E	; 14
   11018:	ea 2e       	mov	r14, r26
   1101a:	f1 2c       	mov	r15, r1
   1101c:	ec 0e       	add	r14, r28
   1101e:	fd 1e       	adc	r15, r29
   11020:	ad b7       	in	r26, 0x3d	; 61
   11022:	be b7       	in	r27, 0x3e	; 62
   11024:	12 96       	adiw	r26, 0x02	; 2
   11026:	fc 92       	st	X, r15
   11028:	ee 92       	st	-X, r14
   1102a:	11 97       	sbiw	r26, 0x01	; 1
   1102c:	86 e7       	ldi	r24, 0x76	; 118
   1102e:	90 e1       	ldi	r25, 0x10	; 16
   11030:	93 83       	std	Z+3, r25	; 0x03
   11032:	82 83       	std	Z+2, r24	; 0x02
   11034:	15 83       	std	Z+5, r17	; 0x05
   11036:	04 83       	std	Z+4, r16	; 0x04
   11038:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  lcd_printf(1,1,PSTR("Edit Product Name   "));
   1103c:	8d b7       	in	r24, 0x3d	; 61
   1103e:	9e b7       	in	r25, 0x3e	; 62
   11040:	06 96       	adiw	r24, 0x06	; 6
   11042:	0f b6       	in	r0, 0x3f	; 63
   11044:	f8 94       	cli
   11046:	9e bf       	out	0x3e, r25	; 62
   11048:	0f be       	out	0x3f, r0	; 63
   1104a:	8d bf       	out	0x3d, r24	; 61
   1104c:	81 e0       	ldi	r24, 0x01	; 1
   1104e:	61 e0       	ldi	r22, 0x01	; 1
   11050:	41 e6       	ldi	r20, 0x61	; 97
   11052:	50 e1       	ldi	r21, 0x10	; 16
   11054:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		       lcd_print(2,1,lcdteks);
   11058:	82 e0       	ldi	r24, 0x02	; 2
   1105a:	61 e0       	ldi	r22, 0x01	; 1
   1105c:	a7 01       	movw	r20, r14
   1105e:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   11062:	83 e0       	ldi	r24, 0x03	; 3
   11064:	61 e0       	ldi	r22, 0x01	; 1
   11066:	4b e5       	ldi	r20, 0x5B	; 91
   11068:	50 e1       	ldi	r21, 0x10	; 16
   1106a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   1106e:	84 e0       	ldi	r24, 0x04	; 4
   11070:	61 e0       	ldi	r22, 0x01	; 1
   11072:	46 e4       	ldi	r20, 0x46	; 70
   11074:	50 e1       	ldi	r21, 0x10	; 16
   11076:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		      stMenuProduct=mpEditProductName;
   1107a:	85 e0       	ldi	r24, 0x05	; 5
   1107c:	7b c0       	rjmp	.+246    	; 0x11174 <FSettingProduct+0x3d8>
		  }else
		  if (KeyChar=='2'){
   1107e:	82 33       	cpi	r24, 0x32	; 50
   11080:	09 f0       	breq	.+2      	; 0x11084 <FSettingProduct+0x2e8>
   11082:	82 c0       	rjmp	.+260    	; 0x11188 <FSettingProduct+0x3ec>
		      uiResult=USER_NONE;
   11084:	10 92 08 03 	sts	0x0308, r1
		      sprintf_P(lcdteks,PSTR("Old:%s"),strPrice);
   11088:	00 d0       	rcall	.+0      	; 0x1108a <FSettingProduct+0x2ee>
   1108a:	00 d0       	rcall	.+0      	; 0x1108c <FSettingProduct+0x2f0>
   1108c:	00 d0       	rcall	.+0      	; 0x1108e <FSettingProduct+0x2f2>
   1108e:	ed b7       	in	r30, 0x3d	; 61
   11090:	fe b7       	in	r31, 0x3e	; 62
   11092:	31 96       	adiw	r30, 0x01	; 1
   11094:	8e 01       	movw	r16, r28
   11096:	02 5f       	subi	r16, 0xF2	; 242
   11098:	1f 4f       	sbci	r17, 0xFF	; 255
   1109a:	ad b7       	in	r26, 0x3d	; 61
   1109c:	be b7       	in	r27, 0x3e	; 62
   1109e:	12 96       	adiw	r26, 0x02	; 2
   110a0:	1c 93       	st	X, r17
   110a2:	0e 93       	st	-X, r16
   110a4:	11 97       	sbiw	r26, 0x01	; 1
   110a6:	8f e3       	ldi	r24, 0x3F	; 63
   110a8:	90 e1       	ldi	r25, 0x10	; 16
   110aa:	93 83       	std	Z+3, r25	; 0x03
   110ac:	82 83       	std	Z+2, r24	; 0x02
   110ae:	8f ef       	ldi	r24, 0xFF	; 255
   110b0:	92 e0       	ldi	r25, 0x02	; 2
   110b2:	95 83       	std	Z+5, r25	; 0x05
   110b4:	84 83       	std	Z+4, r24	; 0x04
   110b6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		       lcd_print(2,1,lcdteks);
   110ba:	8d b7       	in	r24, 0x3d	; 61
   110bc:	9e b7       	in	r25, 0x3e	; 62
   110be:	06 96       	adiw	r24, 0x06	; 6
   110c0:	0f b6       	in	r0, 0x3f	; 63
   110c2:	f8 94       	cli
   110c4:	9e bf       	out	0x3e, r25	; 62
   110c6:	0f be       	out	0x3f, r0	; 63
   110c8:	8d bf       	out	0x3d, r24	; 61
   110ca:	82 e0       	ldi	r24, 0x02	; 2
   110cc:	61 e0       	ldi	r22, 0x01	; 1
   110ce:	a8 01       	movw	r20, r16
   110d0:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   110d4:	83 e0       	ldi	r24, 0x03	; 3
   110d6:	61 e0       	ldi	r22, 0x01	; 1
   110d8:	49 e3       	ldi	r20, 0x39	; 57
   110da:	50 e1       	ldi	r21, 0x10	; 16
   110dc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   110e0:	84 e0       	ldi	r24, 0x04	; 4
   110e2:	61 e0       	ldi	r22, 0x01	; 1
   110e4:	44 e2       	ldi	r20, 0x24	; 36
   110e6:	50 e1       	ldi	r21, 0x10	; 16
   110e8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		      stMenuProduct=mpEditPrice;
   110ec:	84 e0       	ldi	r24, 0x04	; 4
   110ee:	42 c0       	rjmp	.+132    	; 0x11174 <FSettingProduct+0x3d8>
		  }
	      break;
     case mpEditProductName:
	      uiResult=UserInput(UI_ALPHANUM_R,3,5,strDescription,0,10);
   110f0:	83 e0       	ldi	r24, 0x03	; 3
   110f2:	63 e0       	ldi	r22, 0x03	; 3
   110f4:	45 e0       	ldi	r20, 0x05	; 5
   110f6:	2d e3       	ldi	r18, 0x3D	; 61
   110f8:	3a e0       	ldi	r19, 0x0A	; 10
   110fa:	00 e0       	ldi	r16, 0x00	; 0
   110fc:	10 e0       	ldi	r17, 0x00	; 0
   110fe:	fa e0       	ldi	r31, 0x0A	; 10
   11100:	ef 2e       	mov	r14, r31
   11102:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
   11106:	80 93 08 03 	sts	0x0308, r24
		  if (uiResult==USER_OK){
   1110a:	83 30       	cpi	r24, 0x03	; 3
   1110c:	b1 f5       	brne	.+108    	; 0x1117a <FSettingProduct+0x3de>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   1110e:	80 91 09 03 	lds	r24, 0x0309
   11112:	2d e0       	ldi	r18, 0x0D	; 13
   11114:	82 9f       	mul	r24, r18
   11116:	c0 01       	movw	r24, r0
   11118:	11 24       	eor	r1, r1
   1111a:	85 51       	subi	r24, 0x15	; 21
   1111c:	9f 4f       	sbci	r25, 0xFF	; 255
   1111e:	6d e3       	ldi	r22, 0x3D	; 61
   11120:	7a e0       	ldi	r23, 0x0A	; 10
   11122:	4d e0       	ldi	r20, 0x0D	; 13
   11124:	50 e0       	ldi	r21, 0x00	; 0
   11126:	24 eb       	ldi	r18, 0xB4	; 180
   11128:	32 e1       	ldi	r19, 0x12	; 18
   1112a:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
		      eeprom_write_block((const void*)&strDescription,(void*)&DefProductName[ProdID], 13);
		      stMenuProduct=mpInitProduct;
   1112e:	10 92 0a 03 	sts	0x030A, r1
   11132:	2a c0       	rjmp	.+84     	; 0x11188 <FSettingProduct+0x3ec>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
	      break;
     case mpEditPrice:
	      uiResult=UserInput(UI_NUMBER_R,3,5,strPrice,0,7);
   11134:	81 e0       	ldi	r24, 0x01	; 1
   11136:	63 e0       	ldi	r22, 0x03	; 3
   11138:	45 e0       	ldi	r20, 0x05	; 5
   1113a:	2f ef       	ldi	r18, 0xFF	; 255
   1113c:	32 e0       	ldi	r19, 0x02	; 2
   1113e:	00 e0       	ldi	r16, 0x00	; 0
   11140:	10 e0       	ldi	r17, 0x00	; 0
   11142:	e7 e0       	ldi	r30, 0x07	; 7
   11144:	ee 2e       	mov	r14, r30
   11146:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
   1114a:	80 93 08 03 	sts	0x0308, r24
		  if (uiResult==USER_OK){
   1114e:	83 30       	cpi	r24, 0x03	; 3
   11150:	a1 f4       	brne	.+40     	; 0x1117a <FSettingProduct+0x3de>
   11152:	80 91 09 03 	lds	r24, 0x0309
   11156:	29 e0       	ldi	r18, 0x09	; 9
   11158:	82 9f       	mul	r24, r18
   1115a:	c0 01       	movw	r24, r0
   1115c:	11 24       	eor	r1, r1
   1115e:	8b 54       	subi	r24, 0x4B	; 75
   11160:	9f 4f       	sbci	r25, 0xFF	; 255
   11162:	6f ef       	ldi	r22, 0xFF	; 255
   11164:	72 e0       	ldi	r23, 0x02	; 2
   11166:	49 e0       	ldi	r20, 0x09	; 9
   11168:	50 e0       	ldi	r21, 0x00	; 0
   1116a:	24 eb       	ldi	r18, 0xB4	; 180
   1116c:	32 e1       	ldi	r19, 0x12	; 18
   1116e:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
		      eeprom_write_block((const void*)&strPrice,(void*)&DefProductPrice[ProdID], 9);
		      stMenuProduct=mpDispPrice;//stMenuProduct=mpInit;
   11172:	82 e0       	ldi	r24, 0x02	; 2
   11174:	80 93 0a 03 	sts	0x030A, r24
   11178:	07 c0       	rjmp	.+14     	; 0x11188 <FSettingProduct+0x3ec>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
   1117a:	81 30       	cpi	r24, 0x01	; 1
   1117c:	29 f4       	brne	.+10     	; 0x11188 <FSettingProduct+0x3ec>
   1117e:	f9 cf       	rjmp	.-14     	; 0x11172 <FSettingProduct+0x3d6>
	      break;
     case mpExitMenuProduct:
	      stMenuProduct=mpInitProduct;
   11180:	10 92 0a 03 	sts	0x030A, r1
   11184:	81 e0       	ldi	r24, 0x01	; 1
   11186:	01 c0       	rjmp	.+2      	; 0x1118a <FSettingProduct+0x3ee>
   11188:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   1118a:	a1 96       	adiw	r28, 0x21	; 33
   1118c:	0f b6       	in	r0, 0x3f	; 63
   1118e:	f8 94       	cli
   11190:	de bf       	out	0x3e, r29	; 62
   11192:	0f be       	out	0x3f, r0	; 63
   11194:	cd bf       	out	0x3d, r28	; 61
   11196:	cf 91       	pop	r28
   11198:	df 91       	pop	r29
   1119a:	1f 91       	pop	r17
   1119c:	0f 91       	pop	r16
   1119e:	ff 90       	pop	r15
   111a0:	ef 90       	pop	r14
   111a2:	df 90       	pop	r13
   111a4:	cf 90       	pop	r12
   111a6:	bf 90       	pop	r11
   111a8:	af 90       	pop	r10
   111aa:	9f 90       	pop	r9
   111ac:	8f 90       	pop	r8
   111ae:	7f 90       	pop	r7
   111b0:	6f 90       	pop	r6
   111b2:	08 95       	ret

000111b4 <FMenuSettingFooter>:
	 }
   //_menu_header();   
   return Result;
}

char FMenuSettingFooter(){
   111b4:	ef 92       	push	r14
   111b6:	0f 93       	push	r16
   111b8:	1f 93       	push	r17
   111ba:	df 93       	push	r29
   111bc:	cf 93       	push	r28
   111be:	cd b7       	in	r28, 0x3d	; 61
   111c0:	de b7       	in	r29, 0x3e	; 62
   111c2:	ed 97       	sbiw	r28, 0x3d	; 61
   111c4:	0f b6       	in	r0, 0x3f	; 63
   111c6:	f8 94       	cli
   111c8:	de bf       	out	0x3e, r29	; 62
   111ca:	0f be       	out	0x3f, r0	; 63
   111cc:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[41];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   111ce:	80 91 35 03 	lds	r24, 0x0335
   111d2:	83 30       	cpi	r24, 0x03	; 3
   111d4:	09 f4       	brne	.+2      	; 0x111d8 <FMenuSettingFooter+0x24>
   111d6:	c1 c0       	rjmp	.+386    	; 0x1135a <FMenuSettingFooter+0x1a6>
   111d8:	84 30       	cpi	r24, 0x04	; 4
   111da:	30 f4       	brcc	.+12     	; 0x111e8 <FMenuSettingFooter+0x34>
   111dc:	81 30       	cpi	r24, 0x01	; 1
   111de:	51 f1       	breq	.+84     	; 0x11234 <FMenuSettingFooter+0x80>
   111e0:	82 30       	cpi	r24, 0x02	; 2
   111e2:	08 f0       	brcs	.+2      	; 0x111e6 <FMenuSettingFooter+0x32>
   111e4:	6d c0       	rjmp	.+218    	; 0x112c0 <FMenuSettingFooter+0x10c>
   111e6:	0a c0       	rjmp	.+20     	; 0x111fc <FMenuSettingFooter+0x48>
   111e8:	85 30       	cpi	r24, 0x05	; 5
   111ea:	09 f4       	brne	.+2      	; 0x111ee <FMenuSettingFooter+0x3a>
   111ec:	47 c1       	rjmp	.+654    	; 0x1147c <FMenuSettingFooter+0x2c8>
   111ee:	85 30       	cpi	r24, 0x05	; 5
   111f0:	08 f4       	brcc	.+2      	; 0x111f4 <FMenuSettingFooter+0x40>
   111f2:	33 c1       	rjmp	.+614    	; 0x1145a <FMenuSettingFooter+0x2a6>
   111f4:	86 30       	cpi	r24, 0x06	; 6
   111f6:	09 f0       	breq	.+2      	; 0x111fa <FMenuSettingFooter+0x46>
   111f8:	7f c1       	rjmp	.+766    	; 0x114f8 <FMenuSettingFooter+0x344>
   111fa:	7a c1       	rjmp	.+756    	; 0x114f0 <FMenuSettingFooter+0x33c>
	 case shInitHeader:
	      lcd_clear();
   111fc:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Footer1  3)Footer3"));
   11200:	81 e0       	ldi	r24, 0x01	; 1
   11202:	61 e0       	ldi	r22, 0x01	; 1
   11204:	49 e3       	ldi	r20, 0x39	; 57
   11206:	53 e1       	ldi	r21, 0x13	; 19
   11208:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Footer2  4)Footer4"));
   1120c:	82 e0       	ldi	r24, 0x02	; 2
   1120e:	61 e0       	ldi	r22, 0x01	; 1
   11210:	44 e2       	ldi	r20, 0x24	; 36
   11212:	53 e1       	ldi	r21, 0x13	; 19
   11214:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(3,1,PSTR("                    "));
   11218:	83 e0       	ldi	r24, 0x03	; 3
   1121a:	61 e0       	ldi	r22, 0x01	; 1
   1121c:	4f e0       	ldi	r20, 0x0F	; 15
   1121e:	53 e1       	ldi	r21, 0x13	; 19
   11220:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   11224:	84 e0       	ldi	r24, 0x04	; 4
   11226:	61 e0       	ldi	r22, 0x01	; 1
   11228:	4a ef       	ldi	r20, 0xFA	; 250
   1122a:	52 e1       	ldi	r21, 0x12	; 18
   1122c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   11230:	81 e0       	ldi	r24, 0x01	; 1
   11232:	1d c1       	rjmp	.+570    	; 0x1146e <FMenuSettingFooter+0x2ba>
	      break;
     case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   11234:	81 e0       	ldi	r24, 0x01	; 1
   11236:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   1123a:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   1123e:	80 93 33 03 	sts	0x0333, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   11242:	81 53       	subi	r24, 0x31	; 49
   11244:	84 30       	cpi	r24, 0x04	; 4
   11246:	a8 f5       	brcc	.+106    	; 0x112b2 <FMenuSettingFooter+0xfe>
		       HeaderIdx=KeyChar-'1';//
   11248:	80 93 34 03 	sts	0x0334, r24
			   lcd_clear();
   1124c:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Footer%d Line1"),HeaderIdx+1);
   11250:	00 d0       	rcall	.+0      	; 0x11252 <FMenuSettingFooter+0x9e>
   11252:	00 d0       	rcall	.+0      	; 0x11254 <FMenuSettingFooter+0xa0>
   11254:	00 d0       	rcall	.+0      	; 0x11256 <FMenuSettingFooter+0xa2>
   11256:	ed b7       	in	r30, 0x3d	; 61
   11258:	fe b7       	in	r31, 0x3e	; 62
   1125a:	31 96       	adiw	r30, 0x01	; 1
   1125c:	8e 01       	movw	r16, r28
   1125e:	0f 5f       	subi	r16, 0xFF	; 255
   11260:	1f 4f       	sbci	r17, 0xFF	; 255
   11262:	ad b7       	in	r26, 0x3d	; 61
   11264:	be b7       	in	r27, 0x3e	; 62
   11266:	12 96       	adiw	r26, 0x02	; 2
   11268:	1c 93       	st	X, r17
   1126a:	0e 93       	st	-X, r16
   1126c:	11 97       	sbiw	r26, 0x01	; 1
   1126e:	86 ee       	ldi	r24, 0xE6	; 230
   11270:	92 e1       	ldi	r25, 0x12	; 18
   11272:	93 83       	std	Z+3, r25	; 0x03
   11274:	82 83       	std	Z+2, r24	; 0x02
   11276:	80 91 34 03 	lds	r24, 0x0334
   1127a:	90 e0       	ldi	r25, 0x00	; 0
   1127c:	01 96       	adiw	r24, 0x01	; 1
   1127e:	95 83       	std	Z+5, r25	; 0x05
   11280:	84 83       	std	Z+4, r24	; 0x04
   11282:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			   lcd_print(1,1,lcdteks);
   11286:	8d b7       	in	r24, 0x3d	; 61
   11288:	9e b7       	in	r25, 0x3e	; 62
   1128a:	06 96       	adiw	r24, 0x06	; 6
   1128c:	0f b6       	in	r0, 0x3f	; 63
   1128e:	f8 94       	cli
   11290:	9e bf       	out	0x3e, r25	; 62
   11292:	0f be       	out	0x3f, r0	; 63
   11294:	8d bf       	out	0x3d, r24	; 61
   11296:	81 e0       	ldi	r24, 0x01	; 1
   11298:	61 e0       	ldi	r22, 0x01	; 1
   1129a:	a8 01       	movw	r20, r16
   1129c:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   112a0:	84 e0       	ldi	r24, 0x04	; 4
   112a2:	61 e0       	ldi	r22, 0x01	; 1
   112a4:	47 ed       	ldi	r20, 0xD7	; 215
   112a6:	52 e1       	ldi	r21, 0x12	; 18
   112a8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
			   stSettingHeader=shEditHeader1;
   112ac:	82 e0       	ldi	r24, 0x02	; 2
   112ae:	80 93 35 03 	sts	0x0335, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   112b2:	80 91 33 03 	lds	r24, 0x0333
   112b6:	8a 32       	cpi	r24, 0x2A	; 42
   112b8:	09 f0       	breq	.+2      	; 0x112bc <FMenuSettingFooter+0x108>
   112ba:	1e c1       	rjmp	.+572    	; 0x114f8 <FMenuSettingFooter+0x344>
   112bc:	86 e0       	ldi	r24, 0x06	; 6
   112be:	d7 c0       	rjmp	.+430    	; 0x1146e <FMenuSettingFooter+0x2ba>
	      break;
     case shEditHeader1:
          uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
   112c0:	83 e0       	ldi	r24, 0x03	; 3
   112c2:	62 e0       	ldi	r22, 0x02	; 2
   112c4:	41 e0       	ldi	r20, 0x01	; 1
   112c6:	27 ec       	ldi	r18, 0xC7	; 199
   112c8:	3a e0       	ldi	r19, 0x0A	; 10
   112ca:	00 e0       	ldi	r16, 0x00	; 0
   112cc:	10 e0       	ldi	r17, 0x00	; 0
   112ce:	74 e1       	ldi	r23, 0x14	; 20
   112d0:	e7 2e       	mov	r14, r23
   112d2:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
   112d6:	e8 2e       	mov	r14, r24
		  if (uiResult==USER_OK){
   112d8:	93 e0       	ldi	r25, 0x03	; 3
   112da:	89 17       	cp	r24, r25
   112dc:	c9 f5       	brne	.+114    	; 0x11350 <FMenuSettingFooter+0x19c>
			  lcd_clear();
   112de:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
			  sprintf_P(lcdteks,PSTR("Edit Footer%d Line2"),HeaderIdx+1);
   112e2:	00 d0       	rcall	.+0      	; 0x112e4 <FMenuSettingFooter+0x130>
   112e4:	00 d0       	rcall	.+0      	; 0x112e6 <FMenuSettingFooter+0x132>
   112e6:	00 d0       	rcall	.+0      	; 0x112e8 <FMenuSettingFooter+0x134>
   112e8:	ed b7       	in	r30, 0x3d	; 61
   112ea:	fe b7       	in	r31, 0x3e	; 62
   112ec:	31 96       	adiw	r30, 0x01	; 1
   112ee:	8e 01       	movw	r16, r28
   112f0:	0f 5f       	subi	r16, 0xFF	; 255
   112f2:	1f 4f       	sbci	r17, 0xFF	; 255
   112f4:	ad b7       	in	r26, 0x3d	; 61
   112f6:	be b7       	in	r27, 0x3e	; 62
   112f8:	12 96       	adiw	r26, 0x02	; 2
   112fa:	1c 93       	st	X, r17
   112fc:	0e 93       	st	-X, r16
   112fe:	11 97       	sbiw	r26, 0x01	; 1
   11300:	83 ec       	ldi	r24, 0xC3	; 195
   11302:	92 e1       	ldi	r25, 0x12	; 18
   11304:	93 83       	std	Z+3, r25	; 0x03
   11306:	82 83       	std	Z+2, r24	; 0x02
   11308:	80 91 34 03 	lds	r24, 0x0334
   1130c:	90 e0       	ldi	r25, 0x00	; 0
   1130e:	01 96       	adiw	r24, 0x01	; 1
   11310:	95 83       	std	Z+5, r25	; 0x05
   11312:	84 83       	std	Z+4, r24	; 0x04
   11314:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  lcd_print(1,1,lcdteks);
   11318:	8d b7       	in	r24, 0x3d	; 61
   1131a:	9e b7       	in	r25, 0x3e	; 62
   1131c:	06 96       	adiw	r24, 0x06	; 6
   1131e:	0f b6       	in	r0, 0x3f	; 63
   11320:	f8 94       	cli
   11322:	9e bf       	out	0x3e, r25	; 62
   11324:	0f be       	out	0x3f, r0	; 63
   11326:	8d bf       	out	0x3d, r24	; 61
   11328:	81 e0       	ldi	r24, 0x01	; 1
   1132a:	61 e0       	ldi	r22, 0x01	; 1
   1132c:	a8 01       	movw	r20, r16
   1132e:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  lcd_print(2,1,strFreeMessageLine1);
   11332:	82 e0       	ldi	r24, 0x02	; 2
   11334:	61 e0       	ldi	r22, 0x01	; 1
   11336:	47 ec       	ldi	r20, 0xC7	; 199
   11338:	5a e0       	ldi	r21, 0x0A	; 10
   1133a:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   1133e:	84 e0       	ldi	r24, 0x04	; 4
   11340:	61 e0       	ldi	r22, 0x01	; 1
   11342:	44 eb       	ldi	r20, 0xB4	; 180
   11344:	52 e1       	ldi	r21, 0x12	; 18
   11346:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		      stSettingHeader=shEditHeader2;
   1134a:	e0 92 35 03 	sts	0x0335, r14
   1134e:	d4 c0       	rjmp	.+424    	; 0x114f8 <FMenuSettingFooter+0x344>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   11350:	91 e0       	ldi	r25, 0x01	; 1
   11352:	89 17       	cp	r24, r25
   11354:	09 f0       	breq	.+2      	; 0x11358 <FMenuSettingFooter+0x1a4>
   11356:	d0 c0       	rjmp	.+416    	; 0x114f8 <FMenuSettingFooter+0x344>
   11358:	c8 c0       	rjmp	.+400    	; 0x114ea <FMenuSettingFooter+0x336>
	      break;
     case shEditHeader2:
          uiResult=UserInput(UI_ALPHANUM_R,3,1,strFreeMessageLine2,0,20);
   1135a:	83 e0       	ldi	r24, 0x03	; 3
   1135c:	63 e0       	ldi	r22, 0x03	; 3
   1135e:	41 e0       	ldi	r20, 0x01	; 1
   11360:	22 eb       	ldi	r18, 0xB2	; 178
   11362:	39 e0       	ldi	r19, 0x09	; 9
   11364:	00 e0       	ldi	r16, 0x00	; 0
   11366:	10 e0       	ldi	r17, 0x00	; 0
   11368:	54 e1       	ldi	r21, 0x14	; 20
   1136a:	e5 2e       	mov	r14, r21
   1136c:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
		  if (uiResult==USER_OK){
   11370:	83 30       	cpi	r24, 0x03	; 3
   11372:	f1 f5       	brne	.+124    	; 0x113f0 <FMenuSettingFooter+0x23c>
			  lcd_clear();
   11374:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
              lcd_print(1,1,strFreeMessageLine1);
   11378:	81 e0       	ldi	r24, 0x01	; 1
   1137a:	61 e0       	ldi	r22, 0x01	; 1
   1137c:	47 ec       	ldi	r20, 0xC7	; 199
   1137e:	5a e0       	ldi	r21, 0x0A	; 10
   11380:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);
   11384:	82 e0       	ldi	r24, 0x02	; 2
   11386:	61 e0       	ldi	r22, 0x01	; 1
   11388:	42 eb       	ldi	r20, 0xB2	; 178
   1138a:	59 e0       	ldi	r21, 0x09	; 9
   1138c:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  sprintf_P(lcdteks,PSTR("Save Footer%d ?"),HeaderIdx+1);
   11390:	00 d0       	rcall	.+0      	; 0x11392 <FMenuSettingFooter+0x1de>
   11392:	00 d0       	rcall	.+0      	; 0x11394 <FMenuSettingFooter+0x1e0>
   11394:	00 d0       	rcall	.+0      	; 0x11396 <FMenuSettingFooter+0x1e2>
   11396:	ed b7       	in	r30, 0x3d	; 61
   11398:	fe b7       	in	r31, 0x3e	; 62
   1139a:	31 96       	adiw	r30, 0x01	; 1
   1139c:	8e 01       	movw	r16, r28
   1139e:	0f 5f       	subi	r16, 0xFF	; 255
   113a0:	1f 4f       	sbci	r17, 0xFF	; 255
   113a2:	ad b7       	in	r26, 0x3d	; 61
   113a4:	be b7       	in	r27, 0x3e	; 62
   113a6:	12 96       	adiw	r26, 0x02	; 2
   113a8:	1c 93       	st	X, r17
   113aa:	0e 93       	st	-X, r16
   113ac:	11 97       	sbiw	r26, 0x01	; 1
   113ae:	84 ea       	ldi	r24, 0xA4	; 164
   113b0:	92 e1       	ldi	r25, 0x12	; 18
   113b2:	93 83       	std	Z+3, r25	; 0x03
   113b4:	82 83       	std	Z+2, r24	; 0x02
   113b6:	80 91 34 03 	lds	r24, 0x0334
   113ba:	90 e0       	ldi	r25, 0x00	; 0
   113bc:	01 96       	adiw	r24, 0x01	; 1
   113be:	95 83       	std	Z+5, r25	; 0x05
   113c0:	84 83       	std	Z+4, r24	; 0x04
   113c2:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  lcd_print(3,1,lcdteks);
   113c6:	8d b7       	in	r24, 0x3d	; 61
   113c8:	9e b7       	in	r25, 0x3e	; 62
   113ca:	06 96       	adiw	r24, 0x06	; 6
   113cc:	0f b6       	in	r0, 0x3f	; 63
   113ce:	f8 94       	cli
   113d0:	9e bf       	out	0x3e, r25	; 62
   113d2:	0f be       	out	0x3f, r0	; 63
   113d4:	8d bf       	out	0x3d, r24	; 61
   113d6:	83 e0       	ldi	r24, 0x03	; 3
   113d8:	61 e0       	ldi	r22, 0x01	; 1
   113da:	a8 01       	movw	r20, r16
   113dc:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  lcd_printf(4,1,PSTR("[*]No [#]Yes"));
   113e0:	84 e0       	ldi	r24, 0x04	; 4
   113e2:	61 e0       	ldi	r22, 0x01	; 1
   113e4:	47 e9       	ldi	r20, 0x97	; 151
   113e6:	52 e1       	ldi	r21, 0x12	; 18
   113e8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		      stSettingHeader=shSaveHeaderQuestions;
   113ec:	84 e0       	ldi	r24, 0x04	; 4
   113ee:	3f c0       	rjmp	.+126    	; 0x1146e <FMenuSettingFooter+0x2ba>
		  }
		  else
		  if (uiResult==USER_CANCEL){
   113f0:	81 30       	cpi	r24, 0x01	; 1
   113f2:	09 f0       	breq	.+2      	; 0x113f6 <FMenuSettingFooter+0x242>
   113f4:	81 c0       	rjmp	.+258    	; 0x114f8 <FMenuSettingFooter+0x344>
		  	  lcd_clear();
   113f6:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
			  sprintf_P(lcdteks,PSTR("Edit Footer%d Line1"),HeaderIdx+1);
   113fa:	00 d0       	rcall	.+0      	; 0x113fc <FMenuSettingFooter+0x248>
   113fc:	00 d0       	rcall	.+0      	; 0x113fe <FMenuSettingFooter+0x24a>
   113fe:	00 d0       	rcall	.+0      	; 0x11400 <FMenuSettingFooter+0x24c>
   11400:	ed b7       	in	r30, 0x3d	; 61
   11402:	fe b7       	in	r31, 0x3e	; 62
   11404:	31 96       	adiw	r30, 0x01	; 1
   11406:	8e 01       	movw	r16, r28
   11408:	0f 5f       	subi	r16, 0xFF	; 255
   1140a:	1f 4f       	sbci	r17, 0xFF	; 255
   1140c:	ad b7       	in	r26, 0x3d	; 61
   1140e:	be b7       	in	r27, 0x3e	; 62
   11410:	12 96       	adiw	r26, 0x02	; 2
   11412:	1c 93       	st	X, r17
   11414:	0e 93       	st	-X, r16
   11416:	11 97       	sbiw	r26, 0x01	; 1
   11418:	83 e8       	ldi	r24, 0x83	; 131
   1141a:	92 e1       	ldi	r25, 0x12	; 18
   1141c:	93 83       	std	Z+3, r25	; 0x03
   1141e:	82 83       	std	Z+2, r24	; 0x02
   11420:	80 91 34 03 	lds	r24, 0x0334
   11424:	90 e0       	ldi	r25, 0x00	; 0
   11426:	01 96       	adiw	r24, 0x01	; 1
   11428:	95 83       	std	Z+5, r25	; 0x05
   1142a:	84 83       	std	Z+4, r24	; 0x04
   1142c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  lcd_print(1,1,lcdteks);
   11430:	8d b7       	in	r24, 0x3d	; 61
   11432:	9e b7       	in	r25, 0x3e	; 62
   11434:	06 96       	adiw	r24, 0x06	; 6
   11436:	0f b6       	in	r0, 0x3f	; 63
   11438:	f8 94       	cli
   1143a:	9e bf       	out	0x3e, r25	; 62
   1143c:	0f be       	out	0x3f, r0	; 63
   1143e:	8d bf       	out	0x3d, r24	; 61
   11440:	81 e0       	ldi	r24, 0x01	; 1
   11442:	61 e0       	ldi	r22, 0x01	; 1
   11444:	a8 01       	movw	r20, r16
   11446:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   1144a:	84 e0       	ldi	r24, 0x04	; 4
   1144c:	61 e0       	ldi	r22, 0x01	; 1
   1144e:	44 e7       	ldi	r20, 0x74	; 116
   11450:	52 e1       	ldi	r21, 0x12	; 18
   11452:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		      stSettingHeader=shEditHeader1;
   11456:	82 e0       	ldi	r24, 0x02	; 2
   11458:	0a c0       	rjmp	.+20     	; 0x1146e <FMenuSettingFooter+0x2ba>
		  }
	      break;
     case shSaveHeaderQuestions:
          KeyChar=_key_btn(_key_scan(1));
   1145a:	81 e0       	ldi	r24, 0x01	; 1
   1145c:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   11460:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   11464:	80 93 33 03 	sts	0x0333, r24
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   11468:	83 32       	cpi	r24, 0x23	; 35
   1146a:	21 f4       	brne	.+8      	; 0x11474 <FMenuSettingFooter+0x2c0>
   1146c:	85 e0       	ldi	r24, 0x05	; 5
   1146e:	80 93 35 03 	sts	0x0335, r24
   11472:	42 c0       	rjmp	.+132    	; 0x114f8 <FMenuSettingFooter+0x344>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   11474:	8a 32       	cpi	r24, 0x2A	; 42
   11476:	09 f0       	breq	.+2      	; 0x1147a <FMenuSettingFooter+0x2c6>
   11478:	3f c0       	rjmp	.+126    	; 0x114f8 <FMenuSettingFooter+0x344>
   1147a:	37 c0       	rjmp	.+110    	; 0x114ea <FMenuSettingFooter+0x336>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
   1147c:	ad b7       	in	r26, 0x3d	; 61
   1147e:	be b7       	in	r27, 0x3e	; 62
   11480:	18 97       	sbiw	r26, 0x08	; 8
   11482:	0f b6       	in	r0, 0x3f	; 63
   11484:	f8 94       	cli
   11486:	be bf       	out	0x3e, r27	; 62
   11488:	0f be       	out	0x3f, r0	; 63
   1148a:	ad bf       	out	0x3d, r26	; 61
   1148c:	ed b7       	in	r30, 0x3d	; 61
   1148e:	fe b7       	in	r31, 0x3e	; 62
   11490:	31 96       	adiw	r30, 0x01	; 1
   11492:	8e 01       	movw	r16, r28
   11494:	0b 5e       	subi	r16, 0xEB	; 235
   11496:	1f 4f       	sbci	r17, 0xFF	; 255
   11498:	12 96       	adiw	r26, 0x02	; 2
   1149a:	1c 93       	st	X, r17
   1149c:	0e 93       	st	-X, r16
   1149e:	11 97       	sbiw	r26, 0x01	; 1
   114a0:	8f e6       	ldi	r24, 0x6F	; 111
   114a2:	92 e1       	ldi	r25, 0x12	; 18
   114a4:	93 83       	std	Z+3, r25	; 0x03
   114a6:	82 83       	std	Z+2, r24	; 0x02
   114a8:	87 ec       	ldi	r24, 0xC7	; 199
   114aa:	9a e0       	ldi	r25, 0x0A	; 10
   114ac:	95 83       	std	Z+5, r25	; 0x05
   114ae:	84 83       	std	Z+4, r24	; 0x04
   114b0:	82 eb       	ldi	r24, 0xB2	; 178
   114b2:	99 e0       	ldi	r25, 0x09	; 9
   114b4:	97 83       	std	Z+7, r25	; 0x07
   114b6:	86 83       	std	Z+6, r24	; 0x06
   114b8:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   114bc:	8d b7       	in	r24, 0x3d	; 61
   114be:	9e b7       	in	r25, 0x3e	; 62
   114c0:	08 96       	adiw	r24, 0x08	; 8
   114c2:	0f b6       	in	r0, 0x3f	; 63
   114c4:	f8 94       	cli
   114c6:	9e bf       	out	0x3e, r25	; 62
   114c8:	0f be       	out	0x3f, r0	; 63
   114ca:	8d bf       	out	0x3d, r24	; 61
   114cc:	80 91 34 03 	lds	r24, 0x0334
   114d0:	29 e2       	ldi	r18, 0x29	; 41
   114d2:	82 9f       	mul	r24, r18
   114d4:	c0 01       	movw	r24, r0
   114d6:	11 24       	eor	r1, r1
   114d8:	83 5b       	subi	r24, 0xB3	; 179
   114da:	9c 4f       	sbci	r25, 0xFC	; 252
   114dc:	b8 01       	movw	r22, r16
   114de:	48 e2       	ldi	r20, 0x28	; 40
   114e0:	50 e0       	ldi	r21, 0x00	; 0
   114e2:	24 eb       	ldi	r18, 0xB4	; 180
   114e4:	32 e1       	ldi	r19, 0x12	; 18
   114e6:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx+6],40);
          stSettingHeader=shInitHeader;
   114ea:	10 92 35 03 	sts	0x0335, r1
   114ee:	04 c0       	rjmp	.+8      	; 0x114f8 <FMenuSettingFooter+0x344>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   114f0:	10 92 35 03 	sts	0x0335, r1
   114f4:	81 e0       	ldi	r24, 0x01	; 1
   114f6:	01 c0       	rjmp	.+2      	; 0x114fa <FMenuSettingFooter+0x346>
   114f8:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   return Result;
}
   114fa:	ed 96       	adiw	r28, 0x3d	; 61
   114fc:	0f b6       	in	r0, 0x3f	; 63
   114fe:	f8 94       	cli
   11500:	de bf       	out	0x3e, r29	; 62
   11502:	0f be       	out	0x3f, r0	; 63
   11504:	cd bf       	out	0x3d, r28	; 61
   11506:	cf 91       	pop	r28
   11508:	df 91       	pop	r29
   1150a:	1f 91       	pop	r17
   1150c:	0f 91       	pop	r16
   1150e:	ef 90       	pop	r14
   11510:	08 95       	ret

00011512 <FMenuSettingHeader>:
	      break;
	 }
   return Result;
}

char FMenuSettingHeader(){
   11512:	ef 92       	push	r14
   11514:	0f 93       	push	r16
   11516:	1f 93       	push	r17
   11518:	df 93       	push	r29
   1151a:	cf 93       	push	r28
   1151c:	cd b7       	in	r28, 0x3d	; 61
   1151e:	de b7       	in	r29, 0x3e	; 62
   11520:	ed 97       	sbiw	r28, 0x3d	; 61
   11522:	0f b6       	in	r0, 0x3f	; 63
   11524:	f8 94       	cli
   11526:	de bf       	out	0x3e, r29	; 62
   11528:	0f be       	out	0x3f, r0	; 63
   1152a:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[41];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   1152c:	80 91 38 03 	lds	r24, 0x0338
   11530:	83 30       	cpi	r24, 0x03	; 3
   11532:	09 f4       	brne	.+2      	; 0x11536 <FMenuSettingHeader+0x24>
   11534:	c1 c0       	rjmp	.+386    	; 0x116b8 <FMenuSettingHeader+0x1a6>
   11536:	84 30       	cpi	r24, 0x04	; 4
   11538:	30 f4       	brcc	.+12     	; 0x11546 <FMenuSettingHeader+0x34>
   1153a:	81 30       	cpi	r24, 0x01	; 1
   1153c:	51 f1       	breq	.+84     	; 0x11592 <FMenuSettingHeader+0x80>
   1153e:	82 30       	cpi	r24, 0x02	; 2
   11540:	08 f0       	brcs	.+2      	; 0x11544 <FMenuSettingHeader+0x32>
   11542:	6d c0       	rjmp	.+218    	; 0x1161e <FMenuSettingHeader+0x10c>
   11544:	0a c0       	rjmp	.+20     	; 0x1155a <FMenuSettingHeader+0x48>
   11546:	85 30       	cpi	r24, 0x05	; 5
   11548:	09 f4       	brne	.+2      	; 0x1154c <FMenuSettingHeader+0x3a>
   1154a:	47 c1       	rjmp	.+654    	; 0x117da <FMenuSettingHeader+0x2c8>
   1154c:	85 30       	cpi	r24, 0x05	; 5
   1154e:	08 f4       	brcc	.+2      	; 0x11552 <FMenuSettingHeader+0x40>
   11550:	33 c1       	rjmp	.+614    	; 0x117b8 <FMenuSettingHeader+0x2a6>
   11552:	86 30       	cpi	r24, 0x06	; 6
   11554:	09 f0       	breq	.+2      	; 0x11558 <FMenuSettingHeader+0x46>
   11556:	7f c1       	rjmp	.+766    	; 0x11856 <FMenuSettingHeader+0x344>
   11558:	7a c1       	rjmp	.+756    	; 0x1184e <FMenuSettingHeader+0x33c>
	 case shInitHeader:
	      lcd_clear();
   1155a:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Header1  4)Header4"));
   1155e:	81 e0       	ldi	r24, 0x01	; 1
   11560:	61 e0       	ldi	r22, 0x01	; 1
   11562:	48 e1       	ldi	r20, 0x18	; 24
   11564:	54 e1       	ldi	r21, 0x14	; 20
   11566:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Header2  5)Header5"));
   1156a:	82 e0       	ldi	r24, 0x02	; 2
   1156c:	61 e0       	ldi	r22, 0x01	; 1
   1156e:	43 e0       	ldi	r20, 0x03	; 3
   11570:	54 e1       	ldi	r21, 0x14	; 20
   11572:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(3,1,PSTR("3)Header3  6)Header6"));
   11576:	83 e0       	ldi	r24, 0x03	; 3
   11578:	61 e0       	ldi	r22, 0x01	; 1
   1157a:	4e ee       	ldi	r20, 0xEE	; 238
   1157c:	53 e1       	ldi	r21, 0x13	; 19
   1157e:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   11582:	84 e0       	ldi	r24, 0x04	; 4
   11584:	61 e0       	ldi	r22, 0x01	; 1
   11586:	49 ed       	ldi	r20, 0xD9	; 217
   11588:	53 e1       	ldi	r21, 0x13	; 19
   1158a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   1158e:	81 e0       	ldi	r24, 0x01	; 1
   11590:	1d c1       	rjmp	.+570    	; 0x117cc <FMenuSettingHeader+0x2ba>
	      break;
     case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   11592:	81 e0       	ldi	r24, 0x01	; 1
   11594:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   11598:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   1159c:	80 93 36 03 	sts	0x0336, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   115a0:	81 53       	subi	r24, 0x31	; 49
   115a2:	86 30       	cpi	r24, 0x06	; 6
   115a4:	a8 f5       	brcc	.+106    	; 0x11610 <FMenuSettingHeader+0xfe>
		       HeaderIdx=KeyChar-'1';//
   115a6:	80 93 37 03 	sts	0x0337, r24
			   lcd_clear();
   115aa:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Header%d Line1"),HeaderIdx+1);
   115ae:	00 d0       	rcall	.+0      	; 0x115b0 <FMenuSettingHeader+0x9e>
   115b0:	00 d0       	rcall	.+0      	; 0x115b2 <FMenuSettingHeader+0xa0>
   115b2:	00 d0       	rcall	.+0      	; 0x115b4 <FMenuSettingHeader+0xa2>
   115b4:	ed b7       	in	r30, 0x3d	; 61
   115b6:	fe b7       	in	r31, 0x3e	; 62
   115b8:	31 96       	adiw	r30, 0x01	; 1
   115ba:	8e 01       	movw	r16, r28
   115bc:	0f 5f       	subi	r16, 0xFF	; 255
   115be:	1f 4f       	sbci	r17, 0xFF	; 255
   115c0:	ad b7       	in	r26, 0x3d	; 61
   115c2:	be b7       	in	r27, 0x3e	; 62
   115c4:	12 96       	adiw	r26, 0x02	; 2
   115c6:	1c 93       	st	X, r17
   115c8:	0e 93       	st	-X, r16
   115ca:	11 97       	sbiw	r26, 0x01	; 1
   115cc:	85 ec       	ldi	r24, 0xC5	; 197
   115ce:	93 e1       	ldi	r25, 0x13	; 19
   115d0:	93 83       	std	Z+3, r25	; 0x03
   115d2:	82 83       	std	Z+2, r24	; 0x02
   115d4:	80 91 37 03 	lds	r24, 0x0337
   115d8:	90 e0       	ldi	r25, 0x00	; 0
   115da:	01 96       	adiw	r24, 0x01	; 1
   115dc:	95 83       	std	Z+5, r25	; 0x05
   115de:	84 83       	std	Z+4, r24	; 0x04
   115e0:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			   lcd_print(1,1,lcdteks);
   115e4:	8d b7       	in	r24, 0x3d	; 61
   115e6:	9e b7       	in	r25, 0x3e	; 62
   115e8:	06 96       	adiw	r24, 0x06	; 6
   115ea:	0f b6       	in	r0, 0x3f	; 63
   115ec:	f8 94       	cli
   115ee:	9e bf       	out	0x3e, r25	; 62
   115f0:	0f be       	out	0x3f, r0	; 63
   115f2:	8d bf       	out	0x3d, r24	; 61
   115f4:	81 e0       	ldi	r24, 0x01	; 1
   115f6:	61 e0       	ldi	r22, 0x01	; 1
   115f8:	a8 01       	movw	r20, r16
   115fa:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   115fe:	84 e0       	ldi	r24, 0x04	; 4
   11600:	61 e0       	ldi	r22, 0x01	; 1
   11602:	46 eb       	ldi	r20, 0xB6	; 182
   11604:	53 e1       	ldi	r21, 0x13	; 19
   11606:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
			   stSettingHeader=shEditHeader1;
   1160a:	82 e0       	ldi	r24, 0x02	; 2
   1160c:	80 93 38 03 	sts	0x0338, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   11610:	80 91 36 03 	lds	r24, 0x0336
   11614:	8a 32       	cpi	r24, 0x2A	; 42
   11616:	09 f0       	breq	.+2      	; 0x1161a <FMenuSettingHeader+0x108>
   11618:	1e c1       	rjmp	.+572    	; 0x11856 <FMenuSettingHeader+0x344>
   1161a:	86 e0       	ldi	r24, 0x06	; 6
   1161c:	d7 c0       	rjmp	.+430    	; 0x117cc <FMenuSettingHeader+0x2ba>
	      break;
     case shEditHeader1:
          uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
   1161e:	83 e0       	ldi	r24, 0x03	; 3
   11620:	62 e0       	ldi	r22, 0x02	; 2
   11622:	41 e0       	ldi	r20, 0x01	; 1
   11624:	27 ec       	ldi	r18, 0xC7	; 199
   11626:	3a e0       	ldi	r19, 0x0A	; 10
   11628:	00 e0       	ldi	r16, 0x00	; 0
   1162a:	10 e0       	ldi	r17, 0x00	; 0
   1162c:	f4 e1       	ldi	r31, 0x14	; 20
   1162e:	ef 2e       	mov	r14, r31
   11630:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
   11634:	e8 2e       	mov	r14, r24
		  if (uiResult==USER_OK){
   11636:	93 e0       	ldi	r25, 0x03	; 3
   11638:	89 17       	cp	r24, r25
   1163a:	c9 f5       	brne	.+114    	; 0x116ae <FMenuSettingHeader+0x19c>
			  lcd_clear();
   1163c:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
			  sprintf_P(lcdteks,PSTR("Edit Header%d Line2"),HeaderIdx+1);
   11640:	00 d0       	rcall	.+0      	; 0x11642 <FMenuSettingHeader+0x130>
   11642:	00 d0       	rcall	.+0      	; 0x11644 <FMenuSettingHeader+0x132>
   11644:	00 d0       	rcall	.+0      	; 0x11646 <FMenuSettingHeader+0x134>
   11646:	ed b7       	in	r30, 0x3d	; 61
   11648:	fe b7       	in	r31, 0x3e	; 62
   1164a:	31 96       	adiw	r30, 0x01	; 1
   1164c:	8e 01       	movw	r16, r28
   1164e:	0f 5f       	subi	r16, 0xFF	; 255
   11650:	1f 4f       	sbci	r17, 0xFF	; 255
   11652:	ad b7       	in	r26, 0x3d	; 61
   11654:	be b7       	in	r27, 0x3e	; 62
   11656:	12 96       	adiw	r26, 0x02	; 2
   11658:	1c 93       	st	X, r17
   1165a:	0e 93       	st	-X, r16
   1165c:	11 97       	sbiw	r26, 0x01	; 1
   1165e:	82 ea       	ldi	r24, 0xA2	; 162
   11660:	93 e1       	ldi	r25, 0x13	; 19
   11662:	93 83       	std	Z+3, r25	; 0x03
   11664:	82 83       	std	Z+2, r24	; 0x02
   11666:	80 91 37 03 	lds	r24, 0x0337
   1166a:	90 e0       	ldi	r25, 0x00	; 0
   1166c:	01 96       	adiw	r24, 0x01	; 1
   1166e:	95 83       	std	Z+5, r25	; 0x05
   11670:	84 83       	std	Z+4, r24	; 0x04
   11672:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  lcd_print(1,1,lcdteks);
   11676:	8d b7       	in	r24, 0x3d	; 61
   11678:	9e b7       	in	r25, 0x3e	; 62
   1167a:	06 96       	adiw	r24, 0x06	; 6
   1167c:	0f b6       	in	r0, 0x3f	; 63
   1167e:	f8 94       	cli
   11680:	9e bf       	out	0x3e, r25	; 62
   11682:	0f be       	out	0x3f, r0	; 63
   11684:	8d bf       	out	0x3d, r24	; 61
   11686:	81 e0       	ldi	r24, 0x01	; 1
   11688:	61 e0       	ldi	r22, 0x01	; 1
   1168a:	a8 01       	movw	r20, r16
   1168c:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  lcd_print(2,1,strFreeMessageLine1);
   11690:	82 e0       	ldi	r24, 0x02	; 2
   11692:	61 e0       	ldi	r22, 0x01	; 1
   11694:	47 ec       	ldi	r20, 0xC7	; 199
   11696:	5a e0       	ldi	r21, 0x0A	; 10
   11698:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   1169c:	84 e0       	ldi	r24, 0x04	; 4
   1169e:	61 e0       	ldi	r22, 0x01	; 1
   116a0:	43 e9       	ldi	r20, 0x93	; 147
   116a2:	53 e1       	ldi	r21, 0x13	; 19
   116a4:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		      stSettingHeader=shEditHeader2;
   116a8:	e0 92 38 03 	sts	0x0338, r14
   116ac:	d4 c0       	rjmp	.+424    	; 0x11856 <FMenuSettingHeader+0x344>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   116ae:	91 e0       	ldi	r25, 0x01	; 1
   116b0:	89 17       	cp	r24, r25
   116b2:	09 f0       	breq	.+2      	; 0x116b6 <FMenuSettingHeader+0x1a4>
   116b4:	d0 c0       	rjmp	.+416    	; 0x11856 <FMenuSettingHeader+0x344>
   116b6:	c8 c0       	rjmp	.+400    	; 0x11848 <FMenuSettingHeader+0x336>
	      break;
     case shEditHeader2:
          uiResult=UserInput(UI_ALPHANUM_R,3,1,strFreeMessageLine2,0,20);
   116b8:	83 e0       	ldi	r24, 0x03	; 3
   116ba:	63 e0       	ldi	r22, 0x03	; 3
   116bc:	41 e0       	ldi	r20, 0x01	; 1
   116be:	22 eb       	ldi	r18, 0xB2	; 178
   116c0:	39 e0       	ldi	r19, 0x09	; 9
   116c2:	00 e0       	ldi	r16, 0x00	; 0
   116c4:	10 e0       	ldi	r17, 0x00	; 0
   116c6:	e4 e1       	ldi	r30, 0x14	; 20
   116c8:	ee 2e       	mov	r14, r30
   116ca:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
		  if (uiResult==USER_OK){
   116ce:	83 30       	cpi	r24, 0x03	; 3
   116d0:	f1 f5       	brne	.+124    	; 0x1174e <FMenuSettingHeader+0x23c>
			  lcd_clear();
   116d2:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
              lcd_print(1,1,strFreeMessageLine1);
   116d6:	81 e0       	ldi	r24, 0x01	; 1
   116d8:	61 e0       	ldi	r22, 0x01	; 1
   116da:	47 ec       	ldi	r20, 0xC7	; 199
   116dc:	5a e0       	ldi	r21, 0x0A	; 10
   116de:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);
   116e2:	82 e0       	ldi	r24, 0x02	; 2
   116e4:	61 e0       	ldi	r22, 0x01	; 1
   116e6:	42 eb       	ldi	r20, 0xB2	; 178
   116e8:	59 e0       	ldi	r21, 0x09	; 9
   116ea:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  sprintf_P(lcdteks,PSTR("Save Header%d ?"),HeaderIdx+1);
   116ee:	00 d0       	rcall	.+0      	; 0x116f0 <FMenuSettingHeader+0x1de>
   116f0:	00 d0       	rcall	.+0      	; 0x116f2 <FMenuSettingHeader+0x1e0>
   116f2:	00 d0       	rcall	.+0      	; 0x116f4 <FMenuSettingHeader+0x1e2>
   116f4:	ed b7       	in	r30, 0x3d	; 61
   116f6:	fe b7       	in	r31, 0x3e	; 62
   116f8:	31 96       	adiw	r30, 0x01	; 1
   116fa:	8e 01       	movw	r16, r28
   116fc:	0f 5f       	subi	r16, 0xFF	; 255
   116fe:	1f 4f       	sbci	r17, 0xFF	; 255
   11700:	ad b7       	in	r26, 0x3d	; 61
   11702:	be b7       	in	r27, 0x3e	; 62
   11704:	12 96       	adiw	r26, 0x02	; 2
   11706:	1c 93       	st	X, r17
   11708:	0e 93       	st	-X, r16
   1170a:	11 97       	sbiw	r26, 0x01	; 1
   1170c:	83 e8       	ldi	r24, 0x83	; 131
   1170e:	93 e1       	ldi	r25, 0x13	; 19
   11710:	93 83       	std	Z+3, r25	; 0x03
   11712:	82 83       	std	Z+2, r24	; 0x02
   11714:	80 91 37 03 	lds	r24, 0x0337
   11718:	90 e0       	ldi	r25, 0x00	; 0
   1171a:	01 96       	adiw	r24, 0x01	; 1
   1171c:	95 83       	std	Z+5, r25	; 0x05
   1171e:	84 83       	std	Z+4, r24	; 0x04
   11720:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  lcd_print(3,1,lcdteks);
   11724:	8d b7       	in	r24, 0x3d	; 61
   11726:	9e b7       	in	r25, 0x3e	; 62
   11728:	06 96       	adiw	r24, 0x06	; 6
   1172a:	0f b6       	in	r0, 0x3f	; 63
   1172c:	f8 94       	cli
   1172e:	9e bf       	out	0x3e, r25	; 62
   11730:	0f be       	out	0x3f, r0	; 63
   11732:	8d bf       	out	0x3d, r24	; 61
   11734:	83 e0       	ldi	r24, 0x03	; 3
   11736:	61 e0       	ldi	r22, 0x01	; 1
   11738:	a8 01       	movw	r20, r16
   1173a:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  lcd_printf(4,1,PSTR("[*]No [#]Yes"));
   1173e:	84 e0       	ldi	r24, 0x04	; 4
   11740:	61 e0       	ldi	r22, 0x01	; 1
   11742:	46 e7       	ldi	r20, 0x76	; 118
   11744:	53 e1       	ldi	r21, 0x13	; 19
   11746:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		      stSettingHeader=shSaveHeaderQuestions;
   1174a:	84 e0       	ldi	r24, 0x04	; 4
   1174c:	3f c0       	rjmp	.+126    	; 0x117cc <FMenuSettingHeader+0x2ba>
		  }
		  else
		  if (uiResult==USER_CANCEL){
   1174e:	81 30       	cpi	r24, 0x01	; 1
   11750:	09 f0       	breq	.+2      	; 0x11754 <FMenuSettingHeader+0x242>
   11752:	81 c0       	rjmp	.+258    	; 0x11856 <FMenuSettingHeader+0x344>
		  	  lcd_clear();
   11754:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
			  sprintf_P(lcdteks,PSTR("Edit Header%d Line1"),HeaderIdx+1);
   11758:	00 d0       	rcall	.+0      	; 0x1175a <FMenuSettingHeader+0x248>
   1175a:	00 d0       	rcall	.+0      	; 0x1175c <FMenuSettingHeader+0x24a>
   1175c:	00 d0       	rcall	.+0      	; 0x1175e <FMenuSettingHeader+0x24c>
   1175e:	ed b7       	in	r30, 0x3d	; 61
   11760:	fe b7       	in	r31, 0x3e	; 62
   11762:	31 96       	adiw	r30, 0x01	; 1
   11764:	8e 01       	movw	r16, r28
   11766:	0f 5f       	subi	r16, 0xFF	; 255
   11768:	1f 4f       	sbci	r17, 0xFF	; 255
   1176a:	ad b7       	in	r26, 0x3d	; 61
   1176c:	be b7       	in	r27, 0x3e	; 62
   1176e:	12 96       	adiw	r26, 0x02	; 2
   11770:	1c 93       	st	X, r17
   11772:	0e 93       	st	-X, r16
   11774:	11 97       	sbiw	r26, 0x01	; 1
   11776:	82 e6       	ldi	r24, 0x62	; 98
   11778:	93 e1       	ldi	r25, 0x13	; 19
   1177a:	93 83       	std	Z+3, r25	; 0x03
   1177c:	82 83       	std	Z+2, r24	; 0x02
   1177e:	80 91 37 03 	lds	r24, 0x0337
   11782:	90 e0       	ldi	r25, 0x00	; 0
   11784:	01 96       	adiw	r24, 0x01	; 1
   11786:	95 83       	std	Z+5, r25	; 0x05
   11788:	84 83       	std	Z+4, r24	; 0x04
   1178a:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  lcd_print(1,1,lcdteks);
   1178e:	8d b7       	in	r24, 0x3d	; 61
   11790:	9e b7       	in	r25, 0x3e	; 62
   11792:	06 96       	adiw	r24, 0x06	; 6
   11794:	0f b6       	in	r0, 0x3f	; 63
   11796:	f8 94       	cli
   11798:	9e bf       	out	0x3e, r25	; 62
   1179a:	0f be       	out	0x3f, r0	; 63
   1179c:	8d bf       	out	0x3d, r24	; 61
   1179e:	81 e0       	ldi	r24, 0x01	; 1
   117a0:	61 e0       	ldi	r22, 0x01	; 1
   117a2:	a8 01       	movw	r20, r16
   117a4:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
			  lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   117a8:	84 e0       	ldi	r24, 0x04	; 4
   117aa:	61 e0       	ldi	r22, 0x01	; 1
   117ac:	43 e5       	ldi	r20, 0x53	; 83
   117ae:	53 e1       	ldi	r21, 0x13	; 19
   117b0:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		      stSettingHeader=shEditHeader1;
   117b4:	82 e0       	ldi	r24, 0x02	; 2
   117b6:	0a c0       	rjmp	.+20     	; 0x117cc <FMenuSettingHeader+0x2ba>
		  }
	      break;
     case shSaveHeaderQuestions:
	      KeyChar=_key_btn(_key_scan(1));
   117b8:	81 e0       	ldi	r24, 0x01	; 1
   117ba:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   117be:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   117c2:	80 93 36 03 	sts	0x0336, r24
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   117c6:	83 32       	cpi	r24, 0x23	; 35
   117c8:	21 f4       	brne	.+8      	; 0x117d2 <FMenuSettingHeader+0x2c0>
   117ca:	85 e0       	ldi	r24, 0x05	; 5
   117cc:	80 93 38 03 	sts	0x0338, r24
   117d0:	42 c0       	rjmp	.+132    	; 0x11856 <FMenuSettingHeader+0x344>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   117d2:	8a 32       	cpi	r24, 0x2A	; 42
   117d4:	09 f0       	breq	.+2      	; 0x117d8 <FMenuSettingHeader+0x2c6>
   117d6:	3f c0       	rjmp	.+126    	; 0x11856 <FMenuSettingHeader+0x344>
   117d8:	37 c0       	rjmp	.+110    	; 0x11848 <FMenuSettingHeader+0x336>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
   117da:	ad b7       	in	r26, 0x3d	; 61
   117dc:	be b7       	in	r27, 0x3e	; 62
   117de:	18 97       	sbiw	r26, 0x08	; 8
   117e0:	0f b6       	in	r0, 0x3f	; 63
   117e2:	f8 94       	cli
   117e4:	be bf       	out	0x3e, r27	; 62
   117e6:	0f be       	out	0x3f, r0	; 63
   117e8:	ad bf       	out	0x3d, r26	; 61
   117ea:	ed b7       	in	r30, 0x3d	; 61
   117ec:	fe b7       	in	r31, 0x3e	; 62
   117ee:	31 96       	adiw	r30, 0x01	; 1
   117f0:	8e 01       	movw	r16, r28
   117f2:	0b 5e       	subi	r16, 0xEB	; 235
   117f4:	1f 4f       	sbci	r17, 0xFF	; 255
   117f6:	12 96       	adiw	r26, 0x02	; 2
   117f8:	1c 93       	st	X, r17
   117fa:	0e 93       	st	-X, r16
   117fc:	11 97       	sbiw	r26, 0x01	; 1
   117fe:	8e e4       	ldi	r24, 0x4E	; 78
   11800:	93 e1       	ldi	r25, 0x13	; 19
   11802:	93 83       	std	Z+3, r25	; 0x03
   11804:	82 83       	std	Z+2, r24	; 0x02
   11806:	87 ec       	ldi	r24, 0xC7	; 199
   11808:	9a e0       	ldi	r25, 0x0A	; 10
   1180a:	95 83       	std	Z+5, r25	; 0x05
   1180c:	84 83       	std	Z+4, r24	; 0x04
   1180e:	82 eb       	ldi	r24, 0xB2	; 178
   11810:	99 e0       	ldi	r25, 0x09	; 9
   11812:	97 83       	std	Z+7, r25	; 0x07
   11814:	86 83       	std	Z+6, r24	; 0x06
   11816:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   1181a:	8d b7       	in	r24, 0x3d	; 61
   1181c:	9e b7       	in	r25, 0x3e	; 62
   1181e:	08 96       	adiw	r24, 0x08	; 8
   11820:	0f b6       	in	r0, 0x3f	; 63
   11822:	f8 94       	cli
   11824:	9e bf       	out	0x3e, r25	; 62
   11826:	0f be       	out	0x3f, r0	; 63
   11828:	8d bf       	out	0x3d, r24	; 61
   1182a:	80 91 37 03 	lds	r24, 0x0337
   1182e:	29 e2       	ldi	r18, 0x29	; 41
   11830:	82 9f       	mul	r24, r18
   11832:	c0 01       	movw	r24, r0
   11834:	11 24       	eor	r1, r1
   11836:	89 5a       	subi	r24, 0xA9	; 169
   11838:	9d 4f       	sbci	r25, 0xFD	; 253
   1183a:	b8 01       	movw	r22, r16
   1183c:	48 e2       	ldi	r20, 0x28	; 40
   1183e:	50 e0       	ldi	r21, 0x00	; 0
   11840:	24 eb       	ldi	r18, 0xB4	; 180
   11842:	32 e1       	ldi	r19, 0x12	; 18
   11844:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx],40);
          stSettingHeader=shInitHeader;
   11848:	10 92 38 03 	sts	0x0338, r1
   1184c:	04 c0       	rjmp	.+8      	; 0x11856 <FMenuSettingHeader+0x344>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   1184e:	10 92 38 03 	sts	0x0338, r1
   11852:	81 e0       	ldi	r24, 0x01	; 1
   11854:	01 c0       	rjmp	.+2      	; 0x11858 <FMenuSettingHeader+0x346>
   11856:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   //_menu_header();   
   return Result;
}
   11858:	ed 96       	adiw	r28, 0x3d	; 61
   1185a:	0f b6       	in	r0, 0x3f	; 63
   1185c:	f8 94       	cli
   1185e:	de bf       	out	0x3e, r29	; 62
   11860:	0f be       	out	0x3f, r0	; 63
   11862:	cd bf       	out	0x3d, r28	; 61
   11864:	cf 91       	pop	r28
   11866:	df 91       	pop	r29
   11868:	1f 91       	pop	r17
   1186a:	0f 91       	pop	r16
   1186c:	ef 90       	pop	r14
   1186e:	08 95       	ret

00011870 <FMenuAdminSettings>:

char FMenuAdminSettings(){
     static char stAdminSettings=asInitMenu;
	 char SubMenu,Result,KeyChar;
	 Result=MENU_NONE;
	 switch(stAdminSettings){
   11870:	80 91 39 03 	lds	r24, 0x0339
   11874:	83 30       	cpi	r24, 0x03	; 3
   11876:	09 f4       	brne	.+2      	; 0x1187a <FMenuAdminSettings+0xa>
   11878:	6e c0       	rjmp	.+220    	; 0x11956 <FMenuAdminSettings+0xe6>
   1187a:	84 30       	cpi	r24, 0x04	; 4
   1187c:	30 f4       	brcc	.+12     	; 0x1188a <FMenuAdminSettings+0x1a>
   1187e:	81 30       	cpi	r24, 0x01	; 1
   11880:	e9 f1       	breq	.+122    	; 0x118fc <FMenuAdminSettings+0x8c>
   11882:	82 30       	cpi	r24, 0x02	; 2
   11884:	08 f0       	brcs	.+2      	; 0x11888 <FMenuAdminSettings+0x18>
   11886:	64 c0       	rjmp	.+200    	; 0x11950 <FMenuAdminSettings+0xe0>
   11888:	0d c0       	rjmp	.+26     	; 0x118a4 <FMenuAdminSettings+0x34>
   1188a:	85 30       	cpi	r24, 0x05	; 5
   1188c:	09 f4       	brne	.+2      	; 0x11890 <FMenuAdminSettings+0x20>
   1188e:	69 c0       	rjmp	.+210    	; 0x11962 <FMenuAdminSettings+0xf2>
   11890:	85 30       	cpi	r24, 0x05	; 5
   11892:	08 f4       	brcc	.+2      	; 0x11896 <FMenuAdminSettings+0x26>
   11894:	63 c0       	rjmp	.+198    	; 0x1195c <FMenuAdminSettings+0xec>
   11896:	86 30       	cpi	r24, 0x06	; 6
   11898:	09 f4       	brne	.+2      	; 0x1189c <FMenuAdminSettings+0x2c>
   1189a:	66 c0       	rjmp	.+204    	; 0x11968 <FMenuAdminSettings+0xf8>
   1189c:	87 30       	cpi	r24, 0x07	; 7
   1189e:	09 f0       	breq	.+2      	; 0x118a2 <FMenuAdminSettings+0x32>
   118a0:	6f c0       	rjmp	.+222    	; 0x11980 <FMenuAdminSettings+0x110>
   118a2:	6a c0       	rjmp	.+212    	; 0x11978 <FMenuAdminSettings+0x108>
	 case asInitMenu:
          lcd_clear();
   118a4:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  if (IFType==IT_SLAVE){
   118a8:	80 91 25 01 	lds	r24, 0x0125
   118ac:	81 30       	cpi	r24, 0x01	; 1
   118ae:	51 f4       	brne	.+20     	; 0x118c4 <FMenuAdminSettings+0x54>
		      lcd_printf(1,1, PSTR("1)Header    4)Client"));
   118b0:	61 e0       	ldi	r22, 0x01	; 1
   118b2:	48 e8       	ldi	r20, 0x88	; 136
   118b4:	54 e1       	ldi	r21, 0x14	; 20
   118b6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer    5)Server"));
   118ba:	82 e0       	ldi	r24, 0x02	; 2
   118bc:	61 e0       	ldi	r22, 0x01	; 1
   118be:	43 e7       	ldi	r20, 0x73	; 115
   118c0:	54 e1       	ldi	r21, 0x14	; 20
   118c2:	0c c0       	rjmp	.+24     	; 0x118dc <FMenuAdminSettings+0x6c>
		  }else
		  if (IFType==IT_STANDALONE){
   118c4:	82 30       	cpi	r24, 0x02	; 2
   118c6:	61 f4       	brne	.+24     	; 0x118e0 <FMenuAdminSettings+0x70>
		      lcd_printf(1,1, PSTR("1)Header            "));
   118c8:	81 e0       	ldi	r24, 0x01	; 1
   118ca:	61 e0       	ldi	r22, 0x01	; 1
   118cc:	4e e5       	ldi	r20, 0x5E	; 94
   118ce:	54 e1       	ldi	r21, 0x14	; 20
   118d0:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer            "));
   118d4:	82 e0       	ldi	r24, 0x02	; 2
   118d6:	61 e0       	ldi	r22, 0x01	; 1
   118d8:	49 e4       	ldi	r20, 0x49	; 73
   118da:	54 e1       	ldi	r21, 0x14	; 20
   118dc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  }
		  lcd_printf(3,1, PSTR("3)Password          "));
   118e0:	83 e0       	ldi	r24, 0x03	; 3
   118e2:	61 e0       	ldi	r22, 0x01	; 1
   118e4:	44 e3       	ldi	r20, 0x34	; 52
   118e6:	54 e1       	ldi	r21, 0x14	; 20
   118e8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(4,1, PSTR("*)Exit"));
   118ec:	84 e0       	ldi	r24, 0x04	; 4
   118ee:	61 e0       	ldi	r22, 0x01	; 1
   118f0:	4d e2       	ldi	r20, 0x2D	; 45
   118f2:	54 e1       	ldi	r21, 0x14	; 20
   118f4:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  stAdminSettings=asAdminSettingsOption;
   118f8:	81 e0       	ldi	r24, 0x01	; 1
   118fa:	27 c0       	rjmp	.+78     	; 0x1194a <FMenuAdminSettings+0xda>
		  break;
     case asAdminSettingsOption:
	      KeyChar=_key_btn(_key_scan(1));
   118fc:	81 e0       	ldi	r24, 0x01	; 1
   118fe:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   11902:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   11906:	98 2f       	mov	r25, r24
		  switch(KeyChar){
   11908:	82 33       	cpi	r24, 0x32	; 50
   1190a:	61 f0       	breq	.+24     	; 0x11924 <FMenuAdminSettings+0xb4>
   1190c:	83 33       	cpi	r24, 0x33	; 51
   1190e:	28 f4       	brcc	.+10     	; 0x1191a <FMenuAdminSettings+0xaa>
   11910:	8a 32       	cpi	r24, 0x2A	; 42
   11912:	61 f0       	breq	.+24     	; 0x1192c <FMenuAdminSettings+0xbc>
   11914:	81 33       	cpi	r24, 0x31	; 49
   11916:	69 f4       	brne	.+26     	; 0x11932 <FMenuAdminSettings+0xc2>
   11918:	03 c0       	rjmp	.+6      	; 0x11920 <FMenuAdminSettings+0xb0>
   1191a:	83 33       	cpi	r24, 0x33	; 51
   1191c:	51 f4       	brne	.+20     	; 0x11932 <FMenuAdminSettings+0xc2>
   1191e:	04 c0       	rjmp	.+8      	; 0x11928 <FMenuAdminSettings+0xb8>
		  case '1':stAdminSettings=asAdminSettingHeader;
   11920:	82 e0       	ldi	r24, 0x02	; 2
   11922:	05 c0       	rjmp	.+10     	; 0x1192e <FMenuAdminSettings+0xbe>
		       break;
		  case '2':stAdminSettings=asAdminSettingFooter;
   11924:	83 e0       	ldi	r24, 0x03	; 3
   11926:	03 c0       	rjmp	.+6      	; 0x1192e <FMenuAdminSettings+0xbe>
		       break;
		  case '3':stAdminSettings=asAdminSettingPassword;
   11928:	84 e0       	ldi	r24, 0x04	; 4
   1192a:	01 c0       	rjmp	.+2      	; 0x1192e <FMenuAdminSettings+0xbe>
		       break;
		  case '*':stAdminSettings=asExitAdminSetting;
   1192c:	87 e0       	ldi	r24, 0x07	; 7
   1192e:	80 93 39 03 	sts	0x0339, r24
		       break;			   
		  }
		  if (IFType==IT_SLAVE){
   11932:	80 91 25 01 	lds	r24, 0x0125
   11936:	81 30       	cpi	r24, 0x01	; 1
   11938:	19 f5       	brne	.+70     	; 0x11980 <FMenuAdminSettings+0x110>
			  switch(KeyChar){
   1193a:	94 33       	cpi	r25, 0x34	; 52
   1193c:	19 f0       	breq	.+6      	; 0x11944 <FMenuAdminSettings+0xd4>
   1193e:	95 33       	cpi	r25, 0x35	; 53
   11940:	f9 f4       	brne	.+62     	; 0x11980 <FMenuAdminSettings+0x110>
   11942:	02 c0       	rjmp	.+4      	; 0x11948 <FMenuAdminSettings+0xd8>
			  case '4':stAdminSettings=asAdminSettingClientIP;
   11944:	85 e0       	ldi	r24, 0x05	; 5
   11946:	01 c0       	rjmp	.+2      	; 0x1194a <FMenuAdminSettings+0xda>
				   break;
			  case '5':stAdminSettings=asAdminSettingServerIP;
   11948:	86 e0       	ldi	r24, 0x06	; 6
   1194a:	80 93 39 03 	sts	0x0339, r24
   1194e:	12 c0       	rjmp	.+36     	; 0x11974 <FMenuAdminSettings+0x104>
				   break;
			  }
		  }
	      break;
	 case asAdminSettingHeader:
	      SubMenu=FMenuSettingHeader();
   11950:	0e 94 89 8a 	call	0x11512	; 0x11512 <FMenuSettingHeader>
   11954:	0b c0       	rjmp	.+22     	; 0x1196c <FMenuAdminSettings+0xfc>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;
	      break;
	 case asAdminSettingFooter:
	      SubMenu=FMenuSettingFooter();
   11956:	0e 94 da 88 	call	0x111b4	; 0x111b4 <FMenuSettingFooter>
   1195a:	08 c0       	rjmp	.+16     	; 0x1196c <FMenuAdminSettings+0xfc>
	 }
   return Result;
}
char FMenuSettingPassword(){
     char Result;
   _menu_password();
   1195c:	0e 94 c5 72 	call	0xe58a	; 0xe58a <_menu_password>
   11960:	07 c0       	rjmp	.+14     	; 0x11970 <FMenuAdminSettings+0x100>
	 case asAdminSettingPassword:
	      SubMenu=FMenuSettingPassword();
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
     case asAdminSettingClientIP:
	      SubMenu=FMenuSettingClientIP();
   11962:	0e 94 fa 6b 	call	0xd7f4	; 0xd7f4 <FMenuSettingClientIP>
   11966:	02 c0       	rjmp	.+4      	; 0x1196c <FMenuAdminSettings+0xfc>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
	 case asAdminSettingServerIP:
	      SubMenu=FMenuSettingServerIP();
   11968:	0e 94 70 69 	call	0xd2e0	; 0xd2e0 <FMenuSettingServerIP>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
   1196c:	81 30       	cpi	r24, 0x01	; 1
   1196e:	41 f4       	brne	.+16     	; 0x11980 <FMenuAdminSettings+0x110>
   11970:	10 92 39 03 	sts	0x0339, r1
   11974:	80 e0       	ldi	r24, 0x00	; 0
   11976:	08 95       	ret
	      break;
     case asExitAdminSetting:
	      stAdminSettings=asInitMenu;
   11978:	10 92 39 03 	sts	0x0339, r1
   1197c:	81 e0       	ldi	r24, 0x01	; 1
   1197e:	08 95       	ret
   11980:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   11982:	08 95       	ret

00011984 <FMenuMaster>:
     else Result=RC_INVALID;

   return Result;
}

char FMenuMaster(){ 
   11984:	ef 92       	push	r14
   11986:	ff 92       	push	r15
   11988:	0f 93       	push	r16
   1198a:	1f 93       	push	r17
   1198c:	df 93       	push	r29
   1198e:	cf 93       	push	r28
   11990:	cd b7       	in	r28, 0x3d	; 61
   11992:	de b7       	in	r29, 0x3e	; 62
   11994:	e2 97       	sbiw	r28, 0x32	; 50
   11996:	0f b6       	in	r0, 0x3f	; 63
   11998:	f8 94       	cli
   1199a:	de bf       	out	0x3e, r29	; 62
   1199c:	0f be       	out	0x3f, r0	; 63
   1199e:	cd bf       	out	0x3d, r28	; 61
static char stMenuMaster=mmInitMaster;
     char KeyPressed,KeyChar,Result=MENU_NONE;
	 char uiResult,lcdteks[20],PTime[10],PDate[10],strNewPassword[10];
	 char strSend[20];

	 switch(stMenuMaster){
   119a0:	80 91 3e 03 	lds	r24, 0x033E
   119a4:	e8 2f       	mov	r30, r24
   119a6:	f0 e0       	ldi	r31, 0x00	; 0
   119a8:	e1 31       	cpi	r30, 0x11	; 17
   119aa:	f1 05       	cpc	r31, r1
   119ac:	08 f0       	brcs	.+2      	; 0x119b0 <FMenuMaster+0x2c>
   119ae:	f3 c1       	rjmp	.+998    	; 0x11d96 <FMenuMaster+0x412>
   119b0:	ed 54       	subi	r30, 0x4D	; 77
   119b2:	ff 4f       	sbci	r31, 0xFF	; 255
   119b4:	ee 0f       	add	r30, r30
   119b6:	ff 1f       	adc	r31, r31
   119b8:	05 90       	lpm	r0, Z+
   119ba:	f4 91       	lpm	r31, Z+
   119bc:	e0 2d       	mov	r30, r0
   119be:	09 94       	ijmp
	 case mmInitMaster:
	      lcd_clear();
   119c0:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("-System Admin Level-"));
   119c4:	81 e0       	ldi	r24, 0x01	; 1
   119c6:	61 e0       	ldi	r22, 0x01	; 1
   119c8:	4e ef       	ldi	r20, 0xFE	; 254
   119ca:	56 e1       	ldi	r21, 0x16	; 22
   119cc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Restore Password  "));
   119d0:	82 e0       	ldi	r24, 0x02	; 2
   119d2:	61 e0       	ldi	r22, 0x01	; 1
   119d4:	49 ee       	ldi	r20, 0xE9	; 233
   119d6:	56 e1       	ldi	r21, 0x16	; 22
   119d8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Change Password   "));
   119dc:	83 e0       	ldi	r24, 0x03	; 3
   119de:	61 e0       	ldi	r22, 0x01	; 1
   119e0:	44 ed       	ldi	r20, 0xD4	; 212
   119e2:	56 e1       	ldi	r21, 0x16	; 22
   119e4:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Exit             "));
   119e8:	84 e0       	ldi	r24, 0x04	; 4
   119ea:	61 e0       	ldi	r22, 0x01	; 1
   119ec:	4f eb       	ldi	r20, 0xBF	; 191
   119ee:	56 e1       	ldi	r21, 0x16	; 22
   119f0:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>

		  //_uart_printf(1,1,PSTR("-System Admin Level-"));

		  stMenuMaster=mmMasterSelect;
   119f4:	81 e0       	ldi	r24, 0x01	; 1
   119f6:	f6 c0       	rjmp	.+492    	; 0x11be4 <FMenuMaster+0x260>
	      break;
     case mmMasterSelect:
	 	  KeyPressed=_key_scan(1);
   119f8:	81 e0       	ldi	r24, 0x01	; 1
   119fa:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   119fe:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
          switch(KeyChar){
   11a02:	81 33       	cpi	r24, 0x31	; 49
   11a04:	09 f4       	brne	.+2      	; 0x11a08 <FMenuMaster+0x84>
   11a06:	ed c0       	rjmp	.+474    	; 0x11be2 <FMenuMaster+0x25e>
   11a08:	82 33       	cpi	r24, 0x32	; 50
   11a0a:	21 f0       	breq	.+8      	; 0x11a14 <FMenuMaster+0x90>
   11a0c:	8a 32       	cpi	r24, 0x2A	; 42
   11a0e:	09 f0       	breq	.+2      	; 0x11a12 <FMenuMaster+0x8e>
   11a10:	c2 c1       	rjmp	.+900    	; 0x11d96 <FMenuMaster+0x412>
   11a12:	bb c1       	rjmp	.+886    	; 0x11d8a <FMenuMaster+0x406>
		  case '1':
               stMenuMaster=mmRestorePasswordMenu;
		       break;
		  case '2':
		       stMenuMaster=mmChangePassword;
   11a14:	8e e0       	ldi	r24, 0x0E	; 14
   11a16:	e6 c0       	rjmp	.+460    	; 0x11be4 <FMenuMaster+0x260>
		       stMenuMaster=mmExitMaster;
		       break;
		  }
	      break;
     case mmChangePassword:
	      stMenuMaster=mmInitMaster;
   11a18:	10 92 3e 03 	sts	0x033E, r1
   11a1c:	bc c1       	rjmp	.+888    	; 0x11d96 <FMenuMaster+0x412>
	      break;
     case mmRestorePasswordMenu:	      
	      lcd_clear();
   11a1e:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("Enter GeNiUs Code   "));
   11a22:	81 e0       	ldi	r24, 0x01	; 1
   11a24:	61 e0       	ldi	r22, 0x01	; 1
   11a26:	4a ea       	ldi	r20, 0xAA	; 170
   11a28:	56 e1       	ldi	r21, 0x16	; 22
   11a2a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(2,1,PSTR("_                   "));
   11a2e:	82 e0       	ldi	r24, 0x02	; 2
   11a30:	61 e0       	ldi	r22, 0x01	; 1
   11a32:	45 e9       	ldi	r20, 0x95	; 149
   11a34:	56 e1       	ldi	r21, 0x16	; 22
   11a36:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(4,4,PSTR("[*]Cancel   [#]Enter"));
   11a3a:	84 e0       	ldi	r24, 0x04	; 4
   11a3c:	64 e0       	ldi	r22, 0x04	; 4
   11a3e:	40 e8       	ldi	r20, 0x80	; 128
   11a40:	56 e1       	ldi	r21, 0x16	; 22
   11a42:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  sprintf_P(strGeniusCode,PSTR(""));
   11a46:	00 d0       	rcall	.+0      	; 0x11a48 <FMenuMaster+0xc4>
   11a48:	00 d0       	rcall	.+0      	; 0x11a4a <FMenuMaster+0xc6>
   11a4a:	81 ea       	ldi	r24, 0xA1	; 161
   11a4c:	97 e0       	ldi	r25, 0x07	; 7
   11a4e:	ad b7       	in	r26, 0x3d	; 61
   11a50:	be b7       	in	r27, 0x3e	; 62
   11a52:	12 96       	adiw	r26, 0x02	; 2
   11a54:	9c 93       	st	X, r25
   11a56:	8e 93       	st	-X, r24
   11a58:	11 97       	sbiw	r26, 0x01	; 1
   11a5a:	8f e7       	ldi	r24, 0x7F	; 127
   11a5c:	96 e1       	ldi	r25, 0x16	; 22
   11a5e:	14 96       	adiw	r26, 0x04	; 4
   11a60:	9c 93       	st	X, r25
   11a62:	8e 93       	st	-X, r24
   11a64:	13 97       	sbiw	r26, 0x03	; 3
   11a66:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
          stMenuMaster=mmGeniusCodeEntry;
   11a6a:	83 e0       	ldi	r24, 0x03	; 3
   11a6c:	80 93 3e 03 	sts	0x033E, r24
   11a70:	80 e0       	ldi	r24, 0x00	; 0
   11a72:	0f 90       	pop	r0
   11a74:	0f 90       	pop	r0
   11a76:	0f 90       	pop	r0
   11a78:	0f 90       	pop	r0
   11a7a:	8e c1       	rjmp	.+796    	; 0x11d98 <FMenuMaster+0x414>
	      break;
     case mmGeniusCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,2,1,strGeniusCode,0,10);
   11a7c:	81 e0       	ldi	r24, 0x01	; 1
   11a7e:	62 e0       	ldi	r22, 0x02	; 2
   11a80:	41 e0       	ldi	r20, 0x01	; 1
   11a82:	21 ea       	ldi	r18, 0xA1	; 161
   11a84:	37 e0       	ldi	r19, 0x07	; 7
   11a86:	00 e0       	ldi	r16, 0x00	; 0
   11a88:	10 e0       	ldi	r17, 0x00	; 0
   11a8a:	9a e0       	ldi	r25, 0x0A	; 10
   11a8c:	e9 2e       	mov	r14, r25
   11a8e:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
		  switch(uiResult){
   11a92:	83 30       	cpi	r24, 0x03	; 3
   11a94:	49 f0       	breq	.+18     	; 0x11aa8 <FMenuMaster+0x124>
   11a96:	84 30       	cpi	r24, 0x04	; 4
   11a98:	08 f4       	brcc	.+2      	; 0x11a9c <FMenuMaster+0x118>
   11a9a:	f2 c0       	rjmp	.+484    	; 0x11c80 <FMenuMaster+0x2fc>
   11a9c:	84 30       	cpi	r24, 0x04	; 4
   11a9e:	69 f0       	breq	.+26     	; 0x11aba <FMenuMaster+0x136>
   11aa0:	85 30       	cpi	r24, 0x05	; 5
   11aa2:	09 f0       	breq	.+2      	; 0x11aa6 <FMenuMaster+0x122>
   11aa4:	78 c1       	rjmp	.+752    	; 0x11d96 <FMenuMaster+0x412>
   11aa6:	0e c0       	rjmp	.+28     	; 0x11ac4 <FMenuMaster+0x140>
		  case USER_OK:
               
			   //_uart_printf(1,0,PSTR("GeniusCode: "));
			   //_uart_print(1,1,strGeniusCode);

		       _datetime(0, strSystemDate, strSystemTime);
   11aa8:	80 e0       	ldi	r24, 0x00	; 0
   11aaa:	60 ec       	ldi	r22, 0xC0	; 192
   11aac:	75 e0       	ldi	r23, 0x05	; 5
   11aae:	49 ea       	ldi	r20, 0xA9	; 169
   11ab0:	5a e0       	ldi	r21, 0x0A	; 10
   11ab2:	0e 94 fa b1 	call	0x163f4	; 0x163f4 <_datetime>
               stMenuMaster=mmIsValidGeniusCode;
   11ab6:	84 e0       	ldi	r24, 0x04	; 4
   11ab8:	95 c0       	rjmp	.+298    	; 0x11be4 <FMenuMaster+0x260>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11aba:	84 e0       	ldi	r24, 0x04	; 4
   11abc:	61 e0       	ldi	r22, 0x01	; 1
   11abe:	4a e6       	ldi	r20, 0x6A	; 106
   11ac0:	56 e1       	ldi	r21, 0x16	; 22
   11ac2:	f3 c0       	rjmp	.+486    	; 0x11caa <FMenuMaster+0x326>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11ac4:	84 e0       	ldi	r24, 0x04	; 4
   11ac6:	61 e0       	ldi	r22, 0x01	; 1
   11ac8:	45 e5       	ldi	r20, 0x55	; 85
   11aca:	56 e1       	ldi	r21, 0x16	; 22
   11acc:	ee c0       	rjmp	.+476    	; 0x11caa <FMenuMaster+0x326>
		       break;
		  }
	      break;
     case mmIsValidGeniusCode:
	      //GetDate
		      sprintf_P(PDate,PSTR("%s"),strSystemDate);
   11ace:	00 d0       	rcall	.+0      	; 0x11ad0 <FMenuMaster+0x14c>
   11ad0:	00 d0       	rcall	.+0      	; 0x11ad2 <FMenuMaster+0x14e>
   11ad2:	00 d0       	rcall	.+0      	; 0x11ad4 <FMenuMaster+0x150>
   11ad4:	ed b7       	in	r30, 0x3d	; 61
   11ad6:	fe b7       	in	r31, 0x3e	; 62
   11ad8:	31 96       	adiw	r30, 0x01	; 1
   11ada:	8e 01       	movw	r16, r28
   11adc:	05 5f       	subi	r16, 0xF5	; 245
   11ade:	1f 4f       	sbci	r17, 0xFF	; 255
   11ae0:	ad b7       	in	r26, 0x3d	; 61
   11ae2:	be b7       	in	r27, 0x3e	; 62
   11ae4:	12 96       	adiw	r26, 0x02	; 2
   11ae6:	1c 93       	st	X, r17
   11ae8:	0e 93       	st	-X, r16
   11aea:	11 97       	sbiw	r26, 0x01	; 1
   11aec:	82 e5       	ldi	r24, 0x52	; 82
   11aee:	96 e1       	ldi	r25, 0x16	; 22
   11af0:	93 83       	std	Z+3, r25	; 0x03
   11af2:	82 83       	std	Z+2, r24	; 0x02
   11af4:	80 ec       	ldi	r24, 0xC0	; 192
   11af6:	95 e0       	ldi	r25, 0x05	; 5
   11af8:	95 83       	std	Z+5, r25	; 0x05
   11afa:	84 83       	std	Z+4, r24	; 0x04
   11afc:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  RemoveChar(PDate,'/');
   11b00:	ed b7       	in	r30, 0x3d	; 61
   11b02:	fe b7       	in	r31, 0x3e	; 62
   11b04:	36 96       	adiw	r30, 0x06	; 6
   11b06:	0f b6       	in	r0, 0x3f	; 63
   11b08:	f8 94       	cli
   11b0a:	fe bf       	out	0x3e, r31	; 62
   11b0c:	0f be       	out	0x3f, r0	; 63
   11b0e:	ed bf       	out	0x3d, r30	; 61
   11b10:	c8 01       	movw	r24, r16
   11b12:	6f e2       	ldi	r22, 0x2F	; 47
   11b14:	0e 94 cd 2c 	call	0x599a	; 0x599a <RemoveChar>
		  if (ValidateGeniusCode(PDate,strGeniusCode)==GC_VALID){
   11b18:	c8 01       	movw	r24, r16
   11b1a:	61 ea       	ldi	r22, 0xA1	; 161
   11b1c:	77 e0       	ldi	r23, 0x07	; 7
   11b1e:	0e 94 8e 72 	call	0xe51c	; 0xe51c <ValidateGeniusCode>
   11b22:	81 30       	cpi	r24, 0x01	; 1
   11b24:	09 f0       	breq	.+2      	; 0x11b28 <FMenuMaster+0x1a4>
   11b26:	44 c0       	rjmp	.+136    	; 0x11bb0 <FMenuMaster+0x22c>

		  	  sprintf_P(PTime,PSTR("%s"),strSystemTime);
   11b28:	00 d0       	rcall	.+0      	; 0x11b2a <FMenuMaster+0x1a6>
   11b2a:	00 d0       	rcall	.+0      	; 0x11b2c <FMenuMaster+0x1a8>
   11b2c:	00 d0       	rcall	.+0      	; 0x11b2e <FMenuMaster+0x1aa>
   11b2e:	ed b7       	in	r30, 0x3d	; 61
   11b30:	fe b7       	in	r31, 0x3e	; 62
   11b32:	31 96       	adiw	r30, 0x01	; 1
   11b34:	8e 01       	movw	r16, r28
   11b36:	0f 5f       	subi	r16, 0xFF	; 255
   11b38:	1f 4f       	sbci	r17, 0xFF	; 255
   11b3a:	ad b7       	in	r26, 0x3d	; 61
   11b3c:	be b7       	in	r27, 0x3e	; 62
   11b3e:	12 96       	adiw	r26, 0x02	; 2
   11b40:	1c 93       	st	X, r17
   11b42:	0e 93       	st	-X, r16
   11b44:	11 97       	sbiw	r26, 0x01	; 1
   11b46:	8f e4       	ldi	r24, 0x4F	; 79
   11b48:	96 e1       	ldi	r25, 0x16	; 22
   11b4a:	93 83       	std	Z+3, r25	; 0x03
   11b4c:	82 83       	std	Z+2, r24	; 0x02
   11b4e:	89 ea       	ldi	r24, 0xA9	; 169
   11b50:	9a e0       	ldi	r25, 0x0A	; 10
   11b52:	95 83       	std	Z+5, r25	; 0x05
   11b54:	84 83       	std	Z+4, r24	; 0x04
   11b56:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			  RemoveChar(PTime,':');sprintf_P(strKeyStamp,PSTR(""));
   11b5a:	ed b7       	in	r30, 0x3d	; 61
   11b5c:	fe b7       	in	r31, 0x3e	; 62
   11b5e:	36 96       	adiw	r30, 0x06	; 6
   11b60:	0f b6       	in	r0, 0x3f	; 63
   11b62:	f8 94       	cli
   11b64:	fe bf       	out	0x3e, r31	; 62
   11b66:	0f be       	out	0x3f, r0	; 63
   11b68:	ed bf       	out	0x3d, r30	; 61
   11b6a:	c8 01       	movw	r24, r16
   11b6c:	6a e3       	ldi	r22, 0x3A	; 58
   11b6e:	0e 94 cd 2c 	call	0x599a	; 0x599a <RemoveChar>
   11b72:	00 d0       	rcall	.+0      	; 0x11b74 <FMenuMaster+0x1f0>
   11b74:	00 d0       	rcall	.+0      	; 0x11b76 <FMenuMaster+0x1f2>
   11b76:	bf ed       	ldi	r27, 0xDF	; 223
   11b78:	eb 2e       	mov	r14, r27
   11b7a:	b9 e0       	ldi	r27, 0x09	; 9
   11b7c:	fb 2e       	mov	r15, r27
   11b7e:	ad b7       	in	r26, 0x3d	; 61
   11b80:	be b7       	in	r27, 0x3e	; 62
   11b82:	12 96       	adiw	r26, 0x02	; 2
   11b84:	fc 92       	st	X, r15
   11b86:	ee 92       	st	-X, r14
   11b88:	11 97       	sbiw	r26, 0x01	; 1
   11b8a:	8e e4       	ldi	r24, 0x4E	; 78
   11b8c:	96 e1       	ldi	r25, 0x16	; 22
   11b8e:	14 96       	adiw	r26, 0x04	; 4
   11b90:	9c 93       	st	X, r25
   11b92:	8e 93       	st	-X, r24
   11b94:	13 97       	sbiw	r26, 0x03	; 3
   11b96:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>

              //sprintf_P(strSend,PSTR("Time:%s"),PTime);
			  // _uart_print(1,1,strSend);

		      GenerateKeyStamp(PTime,strGeniusCode,strKeyStamp);			  
   11b9a:	0f 90       	pop	r0
   11b9c:	0f 90       	pop	r0
   11b9e:	0f 90       	pop	r0
   11ba0:	0f 90       	pop	r0
   11ba2:	c8 01       	movw	r24, r16
   11ba4:	61 ea       	ldi	r22, 0xA1	; 161
   11ba6:	77 e0       	ldi	r23, 0x07	; 7
   11ba8:	a7 01       	movw	r20, r14
   11baa:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <GenerateKeyStamp>
   11bae:	d5 c0       	rjmp	.+426    	; 0x11d5a <FMenuMaster+0x3d6>
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
   11bb0:	85 e0       	ldi	r24, 0x05	; 5
   11bb2:	18 c0       	rjmp	.+48     	; 0x11be4 <FMenuMaster+0x260>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11bb4:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   11bb6:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11bb8:	81 e0       	ldi	r24, 0x01	; 1
   11bba:	90 e0       	ldi	r25, 0x00	; 0
   11bbc:	90 93 ec 01 	sts	0x01EC, r25
   11bc0:	80 93 eb 01 	sts	0x01EB, r24
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
	      break;
     case mmDisplayInvalidCode:
	      system_beep(1);
          lcd_printf(3,1,PSTR("Invalid Code        "));
   11bc4:	83 e0       	ldi	r24, 0x03	; 3
   11bc6:	61 e0       	ldi	r22, 0x01	; 1
   11bc8:	49 e3       	ldi	r20, 0x39	; 57
   11bca:	56 e1       	ldi	r21, 0x16	; 22
   11bcc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
          TimDisplay=0; 
   11bd0:	10 92 bc 01 	sts	0x01BC, r1
		  stMenuMaster=mmDelayDisplayInvalidCode;
   11bd4:	86 e0       	ldi	r24, 0x06	; 6
   11bd6:	06 c0       	rjmp	.+12     	; 0x11be4 <FMenuMaster+0x260>
	      break;
     case mmDelayDisplayInvalidCode:
	      if (TimDisplay>5)stMenuMaster=mmRestorePasswordMenu;
   11bd8:	80 91 bc 01 	lds	r24, 0x01BC
   11bdc:	86 30       	cpi	r24, 0x06	; 6
   11bde:	08 f4       	brcc	.+2      	; 0x11be2 <FMenuMaster+0x25e>
   11be0:	da c0       	rjmp	.+436    	; 0x11d96 <FMenuMaster+0x412>
   11be2:	82 e0       	ldi	r24, 0x02	; 2
   11be4:	80 93 3e 03 	sts	0x033E, r24
   11be8:	d6 c0       	rjmp	.+428    	; 0x11d96 <FMenuMaster+0x412>
	      break;
     case mmDisplayKeyStamp:
	      lcd_clear();
   11bea:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("Key Stamp:%s "),strKeyStamp);
   11bee:	00 d0       	rcall	.+0      	; 0x11bf0 <FMenuMaster+0x26c>
   11bf0:	00 d0       	rcall	.+0      	; 0x11bf2 <FMenuMaster+0x26e>
   11bf2:	00 d0       	rcall	.+0      	; 0x11bf4 <FMenuMaster+0x270>
   11bf4:	ed b7       	in	r30, 0x3d	; 61
   11bf6:	fe b7       	in	r31, 0x3e	; 62
   11bf8:	31 96       	adiw	r30, 0x01	; 1
   11bfa:	8e 01       	movw	r16, r28
   11bfc:	01 5e       	subi	r16, 0xE1	; 225
   11bfe:	1f 4f       	sbci	r17, 0xFF	; 255
   11c00:	ad b7       	in	r26, 0x3d	; 61
   11c02:	be b7       	in	r27, 0x3e	; 62
   11c04:	12 96       	adiw	r26, 0x02	; 2
   11c06:	1c 93       	st	X, r17
   11c08:	0e 93       	st	-X, r16
   11c0a:	11 97       	sbiw	r26, 0x01	; 1
   11c0c:	8b e2       	ldi	r24, 0x2B	; 43
   11c0e:	96 e1       	ldi	r25, 0x16	; 22
   11c10:	93 83       	std	Z+3, r25	; 0x03
   11c12:	82 83       	std	Z+2, r24	; 0x02
   11c14:	8f ed       	ldi	r24, 0xDF	; 223
   11c16:	99 e0       	ldi	r25, 0x09	; 9
   11c18:	95 83       	std	Z+5, r25	; 0x05
   11c1a:	84 83       	std	Z+4, r24	; 0x04
   11c1c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   11c20:	ed b7       	in	r30, 0x3d	; 61
   11c22:	fe b7       	in	r31, 0x3e	; 62
   11c24:	36 96       	adiw	r30, 0x06	; 6
   11c26:	0f b6       	in	r0, 0x3f	; 63
   11c28:	f8 94       	cli
   11c2a:	fe bf       	out	0x3e, r31	; 62
   11c2c:	0f be       	out	0x3f, r0	; 63
   11c2e:	ed bf       	out	0x3d, r30	; 61
   11c30:	81 e0       	ldi	r24, 0x01	; 1
   11c32:	61 e0       	ldi	r22, 0x01	; 1
   11c34:	a8 01       	movw	r20, r16
   11c36:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_printf(2,1,PSTR("Enter Restore Code  "));
   11c3a:	82 e0       	ldi	r24, 0x02	; 2
   11c3c:	61 e0       	ldi	r22, 0x01	; 1
   11c3e:	46 e1       	ldi	r20, 0x16	; 22
   11c40:	56 e1       	ldi	r21, 0x16	; 22
   11c42:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(3,1,PSTR("_                   "));
   11c46:	83 e0       	ldi	r24, 0x03	; 3
   11c48:	61 e0       	ldi	r22, 0x01	; 1
   11c4a:	41 e0       	ldi	r20, 0x01	; 1
   11c4c:	56 e1       	ldi	r21, 0x16	; 22
   11c4e:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11c52:	84 e0       	ldi	r24, 0x04	; 4
   11c54:	61 e0       	ldi	r22, 0x01	; 1
   11c56:	4c ee       	ldi	r20, 0xEC	; 236
   11c58:	55 e1       	ldi	r21, 0x15	; 21
   11c5a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
          stMenuMaster=mmRestoreCodeEntry;
   11c5e:	88 e0       	ldi	r24, 0x08	; 8
   11c60:	c1 cf       	rjmp	.-126    	; 0x11be4 <FMenuMaster+0x260>
	      break;
     case mmRestoreCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,3,1,strRestoreCode,0,10);
   11c62:	81 e0       	ldi	r24, 0x01	; 1
   11c64:	63 e0       	ldi	r22, 0x03	; 3
   11c66:	41 e0       	ldi	r20, 0x01	; 1
   11c68:	26 e6       	ldi	r18, 0x66	; 102
   11c6a:	3e e0       	ldi	r19, 0x0E	; 14
   11c6c:	00 e0       	ldi	r16, 0x00	; 0
   11c6e:	10 e0       	ldi	r17, 0x00	; 0
   11c70:	aa e0       	ldi	r26, 0x0A	; 10
   11c72:	ea 2e       	mov	r14, r26
   11c74:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
		  switch(uiResult){
   11c78:	83 30       	cpi	r24, 0x03	; 3
   11c7a:	61 f0       	breq	.+24     	; 0x11c94 <FMenuMaster+0x310>
   11c7c:	84 30       	cpi	r24, 0x04	; 4
   11c7e:	20 f4       	brcc	.+8      	; 0x11c88 <FMenuMaster+0x304>
   11c80:	81 30       	cpi	r24, 0x01	; 1
   11c82:	09 f0       	breq	.+2      	; 0x11c86 <FMenuMaster+0x302>
   11c84:	88 c0       	rjmp	.+272    	; 0x11d96 <FMenuMaster+0x412>
   11c86:	81 c0       	rjmp	.+258    	; 0x11d8a <FMenuMaster+0x406>
   11c88:	84 30       	cpi	r24, 0x04	; 4
   11c8a:	31 f0       	breq	.+12     	; 0x11c98 <FMenuMaster+0x314>
   11c8c:	85 30       	cpi	r24, 0x05	; 5
   11c8e:	09 f0       	breq	.+2      	; 0x11c92 <FMenuMaster+0x30e>
   11c90:	82 c0       	rjmp	.+260    	; 0x11d96 <FMenuMaster+0x412>
   11c92:	07 c0       	rjmp	.+14     	; 0x11ca2 <FMenuMaster+0x31e>
		  case USER_OK:
               stMenuMaster=mmIsValidRestoreCode;
   11c94:	89 e0       	ldi	r24, 0x09	; 9
   11c96:	a6 cf       	rjmp	.-180    	; 0x11be4 <FMenuMaster+0x260>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11c98:	84 e0       	ldi	r24, 0x04	; 4
   11c9a:	61 e0       	ldi	r22, 0x01	; 1
   11c9c:	47 ed       	ldi	r20, 0xD7	; 215
   11c9e:	55 e1       	ldi	r21, 0x15	; 21
   11ca0:	04 c0       	rjmp	.+8      	; 0x11caa <FMenuMaster+0x326>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11ca2:	84 e0       	ldi	r24, 0x04	; 4
   11ca4:	61 e0       	ldi	r22, 0x01	; 1
   11ca6:	42 ec       	ldi	r20, 0xC2	; 194
   11ca8:	55 e1       	ldi	r21, 0x15	; 21
   11caa:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
   11cae:	73 c0       	rjmp	.+230    	; 0x11d96 <FMenuMaster+0x412>
		       break;
		  }
	      break;
     case mmIsValidRestoreCode:
	      if (ValidateRestoreCode(strKeyStamp,strRestoreCode)==RC_VALID){
   11cb0:	8f ed       	ldi	r24, 0xDF	; 223
   11cb2:	99 e0       	ldi	r25, 0x09	; 9
   11cb4:	66 e6       	ldi	r22, 0x66	; 102
   11cb6:	7e e0       	ldi	r23, 0x0E	; 14
   11cb8:	0e 94 6c 72 	call	0xe4d8	; 0xe4d8 <ValidateRestoreCode>
   11cbc:	81 30       	cpi	r24, 0x01	; 1
   11cbe:	11 f4       	brne	.+4      	; 0x11cc4 <FMenuMaster+0x340>
		      stMenuMaster=mmRestorePassword;
   11cc0:	8c e0       	ldi	r24, 0x0C	; 12
   11cc2:	90 cf       	rjmp	.-224    	; 0x11be4 <FMenuMaster+0x260>
		  }else stMenuMaster=mmDisplayInvalidRestoreCode;
   11cc4:	8a e0       	ldi	r24, 0x0A	; 10
   11cc6:	8e cf       	rjmp	.-228    	; 0x11be4 <FMenuMaster+0x260>
	      break;
     case mmRestorePassword:
	      sprintf_P(strNewPassword,PSTR(SPV_DEFAULT_PASS));
   11cc8:	00 d0       	rcall	.+0      	; 0x11cca <FMenuMaster+0x346>
   11cca:	00 d0       	rcall	.+0      	; 0x11ccc <FMenuMaster+0x348>
   11ccc:	8e 01       	movw	r16, r28
   11cce:	0b 5e       	subi	r16, 0xEB	; 235
   11cd0:	1f 4f       	sbci	r17, 0xFF	; 255
   11cd2:	ad b7       	in	r26, 0x3d	; 61
   11cd4:	be b7       	in	r27, 0x3e	; 62
   11cd6:	12 96       	adiw	r26, 0x02	; 2
   11cd8:	1c 93       	st	X, r17
   11cda:	0e 93       	st	-X, r16
   11cdc:	11 97       	sbiw	r26, 0x01	; 1
   11cde:	8c eb       	ldi	r24, 0xBC	; 188
   11ce0:	95 e1       	ldi	r25, 0x15	; 21
   11ce2:	14 96       	adiw	r26, 0x04	; 4
   11ce4:	9c 93       	st	X, r25
   11ce6:	8e 93       	st	-X, r24
   11ce8:	13 97       	sbiw	r26, 0x03	; 3
   11cea:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   11cee:	0f 90       	pop	r0
   11cf0:	0f 90       	pop	r0
   11cf2:	0f 90       	pop	r0
   11cf4:	0f 90       	pop	r0
   11cf6:	81 e0       	ldi	r24, 0x01	; 1
   11cf8:	90 e0       	ldi	r25, 0x00	; 0
   11cfa:	b8 01       	movw	r22, r16
   11cfc:	4a e0       	ldi	r20, 0x0A	; 10
   11cfe:	50 e0       	ldi	r21, 0x00	; 0
   11d00:	24 eb       	ldi	r18, 0xB4	; 180
   11d02:	32 e1       	ldi	r19, 0x12	; 18
   11d04:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSpvPassword,sizeof(DefSpvPassword));
		  sprintf_P(strNewPassword,PSTR(SYS_DEFAULT_PASS));
   11d08:	00 d0       	rcall	.+0      	; 0x11d0a <FMenuMaster+0x386>
   11d0a:	00 d0       	rcall	.+0      	; 0x11d0c <FMenuMaster+0x388>
   11d0c:	ed b7       	in	r30, 0x3d	; 61
   11d0e:	fe b7       	in	r31, 0x3e	; 62
   11d10:	12 83       	std	Z+2, r17	; 0x02
   11d12:	01 83       	std	Z+1, r16	; 0x01
   11d14:	86 eb       	ldi	r24, 0xB6	; 182
   11d16:	95 e1       	ldi	r25, 0x15	; 21
   11d18:	94 83       	std	Z+4, r25	; 0x04
   11d1a:	83 83       	std	Z+3, r24	; 0x03
   11d1c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   11d20:	0f 90       	pop	r0
   11d22:	0f 90       	pop	r0
   11d24:	0f 90       	pop	r0
   11d26:	0f 90       	pop	r0
   11d28:	8b e0       	ldi	r24, 0x0B	; 11
   11d2a:	90 e0       	ldi	r25, 0x00	; 0
   11d2c:	b8 01       	movw	r22, r16
   11d2e:	4a e0       	ldi	r20, 0x0A	; 10
   11d30:	50 e0       	ldi	r21, 0x00	; 0
   11d32:	24 eb       	ldi	r18, 0xB4	; 180
   11d34:	32 e1       	ldi	r19, 0x12	; 18
   11d36:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSysPassword,sizeof(DefSysPassword));	      		  
	      stMenuMaster=mmDisplaySuccess;
   11d3a:	8d e0       	ldi	r24, 0x0D	; 13
   11d3c:	53 cf       	rjmp	.-346    	; 0x11be4 <FMenuMaster+0x260>
	      break;
     case mmDisplayInvalidRestoreCode:
	      lcd_printf(3,1,PSTR("Invalid Restore  "));
   11d3e:	83 e0       	ldi	r24, 0x03	; 3
   11d40:	61 e0       	ldi	r22, 0x01	; 1
   11d42:	44 ea       	ldi	r20, 0xA4	; 164
   11d44:	55 e1       	ldi	r21, 0x15	; 21
   11d46:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  TimDisplay=0;
   11d4a:	10 92 bc 01 	sts	0x01BC, r1
          stMenuMaster=mmDelayInvalidRestoreCode;
   11d4e:	8b e0       	ldi	r24, 0x0B	; 11
   11d50:	49 cf       	rjmp	.-366    	; 0x11be4 <FMenuMaster+0x260>
	      break;
     case mmDelayInvalidRestoreCode:
	      if (TimDisplay>5)stMenuMaster=mmDisplayKeyStamp;
   11d52:	80 91 bc 01 	lds	r24, 0x01BC
   11d56:	86 30       	cpi	r24, 0x06	; 6
   11d58:	f0 f0       	brcs	.+60     	; 0x11d96 <FMenuMaster+0x412>
   11d5a:	87 e0       	ldi	r24, 0x07	; 7
   11d5c:	43 cf       	rjmp	.-378    	; 0x11be4 <FMenuMaster+0x260>
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
   11d5e:	83 e0       	ldi	r24, 0x03	; 3
   11d60:	61 e0       	ldi	r22, 0x01	; 1
   11d62:	42 e9       	ldi	r20, 0x92	; 146
   11d64:	55 e1       	ldi	r21, 0x15	; 21
   11d66:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11d6a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   11d6c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11d6e:	81 e0       	ldi	r24, 0x01	; 1
   11d70:	90 e0       	ldi	r25, 0x00	; 0
   11d72:	90 93 ec 01 	sts	0x01EC, r25
   11d76:	80 93 eb 01 	sts	0x01EB, r24
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
		  system_beep(1);
		  TimDisplay=0;
   11d7a:	10 92 bc 01 	sts	0x01BC, r1
          stMenuMaster=mmDelayExit;
   11d7e:	8f e0       	ldi	r24, 0x0F	; 15
   11d80:	31 cf       	rjmp	.-414    	; 0x11be4 <FMenuMaster+0x260>
	      break;
     case mmDelayExit:
	      if (TimDisplay>=5)stMenuMaster=mmExitMaster;
   11d82:	80 91 bc 01 	lds	r24, 0x01BC
   11d86:	85 30       	cpi	r24, 0x05	; 5
   11d88:	30 f0       	brcs	.+12     	; 0x11d96 <FMenuMaster+0x412>
   11d8a:	80 e1       	ldi	r24, 0x10	; 16
   11d8c:	2b cf       	rjmp	.-426    	; 0x11be4 <FMenuMaster+0x260>
	      break;
     case mmExitMaster:
	      stMenuMaster=mmInitMaster;
   11d8e:	10 92 3e 03 	sts	0x033E, r1
   11d92:	81 e0       	ldi	r24, 0x01	; 1
   11d94:	01 c0       	rjmp	.+2      	; 0x11d98 <FMenuMaster+0x414>
   11d96:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;

}
   11d98:	e2 96       	adiw	r28, 0x32	; 50
   11d9a:	0f b6       	in	r0, 0x3f	; 63
   11d9c:	f8 94       	cli
   11d9e:	de bf       	out	0x3e, r29	; 62
   11da0:	0f be       	out	0x3f, r0	; 63
   11da2:	cd bf       	out	0x3d, r28	; 61
   11da4:	cf 91       	pop	r28
   11da6:	df 91       	pop	r29
   11da8:	1f 91       	pop	r17
   11daa:	0f 91       	pop	r16
   11dac:	ff 90       	pop	r15
   11dae:	ef 90       	pop	r14
   11db0:	08 95       	ret

00011db2 <FMenuPassword>:
   return Result;	 
}



char FMenuPassword(){
   11db2:	af 92       	push	r10
   11db4:	bf 92       	push	r11
   11db6:	cf 92       	push	r12
   11db8:	df 92       	push	r13
   11dba:	ef 92       	push	r14
   11dbc:	0f 93       	push	r16
   11dbe:	1f 93       	push	r17
   11dc0:	df 93       	push	r29
   11dc2:	cf 93       	push	r28
   11dc4:	cd b7       	in	r28, 0x3d	; 61
   11dc6:	de b7       	in	r29, 0x3e	; 62
   11dc8:	6e 97       	sbiw	r28, 0x1e	; 30
   11dca:	0f b6       	in	r0, 0x3f	; 63
   11dcc:	f8 94       	cli
   11dce:	de bf       	out	0x3e, r29	; 62
   11dd0:	0f be       	out	0x3f, r0	; 63
   11dd2:	cd bf       	out	0x3d, r28	; 61
static char stMenuPasword=mpInitPassword,uiResult,strPassword[10],PassStatus=MP_NONE;;
char Result=MP_NONE,strMasterPass[10],strSystemPass[10],strAdminPass[10];

     Result=MP_NONE;
     switch(stMenuPasword){
   11dd4:	e0 90 4b 03 	lds	r14, 0x034B
   11dd8:	81 e0       	ldi	r24, 0x01	; 1
   11dda:	e8 16       	cp	r14, r24
   11ddc:	09 f1       	breq	.+66     	; 0x11e20 <FMenuPassword+0x6e>
   11dde:	e8 16       	cp	r14, r24
   11de0:	48 f0       	brcs	.+18     	; 0x11df4 <FMenuPassword+0x42>
   11de2:	e2 e0       	ldi	r30, 0x02	; 2
   11de4:	ee 16       	cp	r14, r30
   11de6:	09 f4       	brne	.+2      	; 0x11dea <FMenuPassword+0x38>
   11de8:	3f c0       	rjmp	.+126    	; 0x11e68 <FMenuPassword+0xb6>
   11dea:	f3 e0       	ldi	r31, 0x03	; 3
   11dec:	ef 16       	cp	r14, r31
   11dee:	09 f0       	breq	.+2      	; 0x11df2 <FMenuPassword+0x40>
   11df0:	92 c0       	rjmp	.+292    	; 0x11f16 <FMenuPassword+0x164>
   11df2:	8c c0       	rjmp	.+280    	; 0x11f0c <FMenuPassword+0x15a>
	 case mpInitPassword:
	      lcd_clear();
   11df4:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("PASSWORD:"));
   11df8:	81 e0       	ldi	r24, 0x01	; 1
   11dfa:	61 e0       	ldi	r22, 0x01	; 1
   11dfc:	4f e6       	ldi	r20, 0x6F	; 111
   11dfe:	57 e1       	ldi	r21, 0x17	; 23
   11e00:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   11e04:	82 e0       	ldi	r24, 0x02	; 2
   11e06:	61 e0       	ldi	r22, 0x01	; 1
   11e08:	4d e6       	ldi	r20, 0x6D	; 109
   11e0a:	57 e1       	ldi	r21, 0x17	; 23
   11e0c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11e10:	84 e0       	ldi	r24, 0x04	; 4
   11e12:	61 e0       	ldi	r22, 0x01	; 1
   11e14:	48 e5       	ldi	r20, 0x58	; 88
   11e16:	57 e1       	ldi	r21, 0x17	; 23
   11e18:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  FillChar(strPassword,0,sizeof(strPassword));
		  stMenuPasword=mpInputPasword;
   11e1c:	81 e0       	ldi	r24, 0x01	; 1
   11e1e:	73 c0       	rjmp	.+230    	; 0x11f06 <FMenuPassword+0x154>
	      break;
     case mpInputPasword:
	 	      uiResult=UserInput(UI_NUM_PASSWORD,2,1,strPassword,0,8);
   11e20:	84 e0       	ldi	r24, 0x04	; 4
   11e22:	62 e0       	ldi	r22, 0x02	; 2
   11e24:	41 e0       	ldi	r20, 0x01	; 1
   11e26:	20 e4       	ldi	r18, 0x40	; 64
   11e28:	33 e0       	ldi	r19, 0x03	; 3
   11e2a:	00 e0       	ldi	r16, 0x00	; 0
   11e2c:	10 e0       	ldi	r17, 0x00	; 0
   11e2e:	58 e0       	ldi	r21, 0x08	; 8
   11e30:	e5 2e       	mov	r14, r21
   11e32:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
   11e36:	80 93 4a 03 	sts	0x034A, r24
		  if (uiResult==USER_OK){
   11e3a:	83 30       	cpi	r24, 0x03	; 3
   11e3c:	11 f4       	brne	.+4      	; 0x11e42 <FMenuPassword+0x90>
		      stMenuPasword=mpProcessPassword;
   11e3e:	82 e0       	ldi	r24, 0x02	; 2
   11e40:	62 c0       	rjmp	.+196    	; 0x11f06 <FMenuPassword+0x154>
			  }
		  else
		  if (uiResult==USER_CANCEL){
   11e42:	81 30       	cpi	r24, 0x01	; 1
   11e44:	09 f4       	brne	.+2      	; 0x11e48 <FMenuPassword+0x96>
   11e46:	50 c0       	rjmp	.+160    	; 0x11ee8 <FMenuPassword+0x136>
		      PassStatus=MP_CANCEL;
		      stMenuPasword=mpExit;
			  }
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11e48:	84 30       	cpi	r24, 0x04	; 4
   11e4a:	21 f4       	brne	.+8      	; 0x11e54 <FMenuPassword+0xa2>
   11e4c:	61 e0       	ldi	r22, 0x01	; 1
   11e4e:	43 e4       	ldi	r20, 0x43	; 67
   11e50:	57 e1       	ldi	r21, 0x17	; 23
   11e52:	07 c0       	rjmp	.+14     	; 0x11e62 <FMenuPassword+0xb0>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11e54:	85 30       	cpi	r24, 0x05	; 5
   11e56:	09 f0       	breq	.+2      	; 0x11e5a <FMenuPassword+0xa8>
   11e58:	5e c0       	rjmp	.+188    	; 0x11f16 <FMenuPassword+0x164>
   11e5a:	84 e0       	ldi	r24, 0x04	; 4
   11e5c:	61 e0       	ldi	r22, 0x01	; 1
   11e5e:	4e e2       	ldi	r20, 0x2E	; 46
   11e60:	57 e1       	ldi	r21, 0x17	; 23
   11e62:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
   11e66:	57 c0       	rjmp	.+174    	; 0x11f16 <FMenuPassword+0x164>
          break;	 
	 case mpProcessPassword:
		      
	      sprintf_P(strMasterPass,PSTR(MASTER_PASSWORD)); 
   11e68:	00 d0       	rcall	.+0      	; 0x11e6a <FMenuPassword+0xb8>
   11e6a:	00 d0       	rcall	.+0      	; 0x11e6c <FMenuPassword+0xba>
   11e6c:	8e 01       	movw	r16, r28
   11e6e:	0f 5f       	subi	r16, 0xFF	; 255
   11e70:	1f 4f       	sbci	r17, 0xFF	; 255
   11e72:	ed b7       	in	r30, 0x3d	; 61
   11e74:	fe b7       	in	r31, 0x3e	; 62
   11e76:	12 83       	std	Z+2, r17	; 0x02
   11e78:	01 83       	std	Z+1, r16	; 0x01
   11e7a:	86 e2       	ldi	r24, 0x26	; 38
   11e7c:	97 e1       	ldi	r25, 0x17	; 23
   11e7e:	94 83       	std	Z+4, r25	; 0x04
   11e80:	83 83       	std	Z+3, r24	; 0x03
   11e82:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   11e86:	0f 90       	pop	r0
   11e88:	0f 90       	pop	r0
   11e8a:	0f 90       	pop	r0
   11e8c:	0f 90       	pop	r0
   11e8e:	35 e1       	ldi	r19, 0x15	; 21
   11e90:	c3 2e       	mov	r12, r19
   11e92:	d1 2c       	mov	r13, r1
   11e94:	cc 0e       	add	r12, r28
   11e96:	dd 1e       	adc	r13, r29
   11e98:	c6 01       	movw	r24, r12
   11e9a:	61 e0       	ldi	r22, 0x01	; 1
   11e9c:	70 e0       	ldi	r23, 0x00	; 0
   11e9e:	4a e0       	ldi	r20, 0x0A	; 10
   11ea0:	50 e0       	ldi	r21, 0x00	; 0
   11ea2:	2c ea       	ldi	r18, 0xAC	; 172
   11ea4:	32 e1       	ldi	r19, 0x12	; 18
   11ea6:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
	      eeprom_read_block((void*) &strAdminPass, (const void*) &DefSpvPassword, 10);
	      eeprom_read_block((void*) &strSystemPass, (const void*) &DefSysPassword, 10);
		  
		  if (strcmp(strMasterPass,strPassword)==0)
   11eaa:	2b e0       	ldi	r18, 0x0B	; 11
   11eac:	a2 2e       	mov	r10, r18
   11eae:	b1 2c       	mov	r11, r1
   11eb0:	ac 0e       	add	r10, r28
   11eb2:	bd 1e       	adc	r11, r29
   11eb4:	c5 01       	movw	r24, r10
   11eb6:	6b e0       	ldi	r22, 0x0B	; 11
   11eb8:	70 e0       	ldi	r23, 0x00	; 0
   11eba:	4a e0       	ldi	r20, 0x0A	; 10
   11ebc:	50 e0       	ldi	r21, 0x00	; 0
   11ebe:	2c ea       	ldi	r18, 0xAC	; 172
   11ec0:	32 e1       	ldi	r19, 0x12	; 18
   11ec2:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
   11ec6:	c8 01       	movw	r24, r16
   11ec8:	60 e4       	ldi	r22, 0x40	; 64
   11eca:	73 e0       	ldi	r23, 0x03	; 3
   11ecc:	0e 94 93 b4 	call	0x16926	; 0x16926 <strcmp>
   11ed0:	00 97       	sbiw	r24, 0x00	; 0
   11ed2:	11 f4       	brne	.+4      	; 0x11ed8 <FMenuPassword+0x126>
		       PassStatus=MP_VALID_MASTER;
   11ed4:	83 e0       	ldi	r24, 0x03	; 3
   11ed6:	08 c0       	rjmp	.+16     	; 0x11ee8 <FMenuPassword+0x136>
		  else
	      if (strcmp(strAdminPass,strPassword)==0){
   11ed8:	c6 01       	movw	r24, r12
   11eda:	60 e4       	ldi	r22, 0x40	; 64
   11edc:	73 e0       	ldi	r23, 0x03	; 3
   11ede:	0e 94 93 b4 	call	0x16926	; 0x16926 <strcmp>
   11ee2:	00 97       	sbiw	r24, 0x00	; 0
   11ee4:	21 f4       	brne	.+8      	; 0x11eee <FMenuPassword+0x13c>
		       PassStatus=MP_VALID_ADMIN;
   11ee6:	84 e0       	ldi	r24, 0x04	; 4
   11ee8:	80 93 3f 03 	sts	0x033F, r24
   11eec:	0b c0       	rjmp	.+22     	; 0x11f04 <FMenuPassword+0x152>
               //lcd_printf(3,1,PSTR("Admin"));
               //_delay_ms(5000);
			   }
		  else if (strcmp(strSystemPass,strPassword)==0){
   11eee:	c5 01       	movw	r24, r10
   11ef0:	60 e4       	ldi	r22, 0x40	; 64
   11ef2:	73 e0       	ldi	r23, 0x03	; 3
   11ef4:	0e 94 93 b4 	call	0x16926	; 0x16926 <strcmp>
   11ef8:	00 97       	sbiw	r24, 0x00	; 0
   11efa:	11 f4       	brne	.+4      	; 0x11f00 <FMenuPassword+0x14e>
		       PassStatus=MP_VALID_SYSTEM;
   11efc:	85 e0       	ldi	r24, 0x05	; 5
   11efe:	f4 cf       	rjmp	.-24     	; 0x11ee8 <FMenuPassword+0x136>
			   //lcd_printf(3,1,PSTR("System"));
               //_delay_ms(5000);
			   }
		  else PassStatus=MP_INVALID;
   11f00:	e0 92 3f 03 	sts	0x033F, r14
		  stMenuPasword=mpExit;
   11f04:	83 e0       	ldi	r24, 0x03	; 3
   11f06:	80 93 4b 03 	sts	0x034B, r24
   11f0a:	05 c0       	rjmp	.+10     	; 0x11f16 <FMenuPassword+0x164>
	      break;
	 case mpExit:
	      //lcd_print(3,1,strPassword);
		  //_delay_ms(5000);
	      stMenuPasword=mpInitPassword;
   11f0c:	10 92 4b 03 	sts	0x034B, r1
	      Result=PassStatus;
   11f10:	80 91 3f 03 	lds	r24, 0x033F
   11f14:	01 c0       	rjmp	.+2      	; 0x11f18 <FMenuPassword+0x166>
   11f16:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
   11f18:	6e 96       	adiw	r28, 0x1e	; 30
   11f1a:	0f b6       	in	r0, 0x3f	; 63
   11f1c:	f8 94       	cli
   11f1e:	de bf       	out	0x3e, r29	; 62
   11f20:	0f be       	out	0x3f, r0	; 63
   11f22:	cd bf       	out	0x3d, r28	; 61
   11f24:	cf 91       	pop	r28
   11f26:	df 91       	pop	r29
   11f28:	1f 91       	pop	r17
   11f2a:	0f 91       	pop	r16
   11f2c:	ef 90       	pop	r14
   11f2e:	df 90       	pop	r13
   11f30:	cf 90       	pop	r12
   11f32:	bf 90       	pop	r11
   11f34:	af 90       	pop	r10
   11f36:	08 95       	ret

00011f38 <FMenuReprint>:
	       break;
	 }
return Result;
}

char FMenuReprint(){
   11f38:	0f 93       	push	r16
   11f3a:	1f 93       	push	r17
   11f3c:	df 93       	push	r29
   11f3e:	cf 93       	push	r28
   11f40:	cd b7       	in	r28, 0x3d	; 61
   11f42:	de b7       	in	r29, 0x3e	; 62
   11f44:	64 97       	sbiw	r28, 0x14	; 20
   11f46:	0f b6       	in	r0, 0x3f	; 63
   11f48:	f8 94       	cli
   11f4a:	de bf       	out	0x3e, r29	; 62
   11f4c:	0f be       	out	0x3f, r0	; 63
   11f4e:	cd bf       	out	0x3d, r28	; 61
static char KeyPressed=0,FIP_Used=0;
       char lcdteks[20],FIPResult,FIP_USED,KeyChar;
	   char PassResult,Result=MENU_NONE,ReprintResult;

     Result=MENU_NONE;
	 switch(stReprint){
   11f50:	80 91 6d 03 	lds	r24, 0x036D
   11f54:	87 30       	cpi	r24, 0x07	; 7
   11f56:	09 f4       	brne	.+2      	; 0x11f5a <FMenuReprint+0x22>
   11f58:	8e c0       	rjmp	.+284    	; 0x12076 <FMenuReprint+0x13e>
   11f5a:	88 30       	cpi	r24, 0x08	; 8
   11f5c:	90 f4       	brcc	.+36     	; 0x11f82 <FMenuReprint+0x4a>
   11f5e:	83 30       	cpi	r24, 0x03	; 3
   11f60:	09 f4       	brne	.+2      	; 0x11f64 <FMenuReprint+0x2c>
   11f62:	43 c0       	rjmp	.+134    	; 0x11fea <FMenuReprint+0xb2>
   11f64:	84 30       	cpi	r24, 0x04	; 4
   11f66:	30 f4       	brcc	.+12     	; 0x11f74 <FMenuReprint+0x3c>
   11f68:	81 30       	cpi	r24, 0x01	; 1
   11f6a:	09 f4       	brne	.+2      	; 0x11f6e <FMenuReprint+0x36>
   11f6c:	55 c0       	rjmp	.+170    	; 0x12018 <FMenuReprint+0xe0>
   11f6e:	82 30       	cpi	r24, 0x02	; 2
   11f70:	48 f5       	brcc	.+82     	; 0x11fc4 <FMenuReprint+0x8c>
   11f72:	1d c0       	rjmp	.+58     	; 0x11fae <FMenuReprint+0x76>
   11f74:	85 30       	cpi	r24, 0x05	; 5
   11f76:	09 f4       	brne	.+2      	; 0x11f7a <FMenuReprint+0x42>
   11f78:	6c c0       	rjmp	.+216    	; 0x12052 <FMenuReprint+0x11a>
   11f7a:	86 30       	cpi	r24, 0x06	; 6
   11f7c:	08 f0       	brcs	.+2      	; 0x11f80 <FMenuReprint+0x48>
   11f7e:	50 c0       	rjmp	.+160    	; 0x12020 <FMenuReprint+0xe8>
   11f80:	45 c0       	rjmp	.+138    	; 0x1200c <FMenuReprint+0xd4>
   11f82:	8b 30       	cpi	r24, 0x0B	; 11
   11f84:	09 f4       	brne	.+2      	; 0x11f88 <FMenuReprint+0x50>
   11f86:	da c0       	rjmp	.+436    	; 0x1213c <FMenuReprint+0x204>
   11f88:	8c 30       	cpi	r24, 0x0C	; 12
   11f8a:	38 f4       	brcc	.+14     	; 0x11f9a <FMenuReprint+0x62>
   11f8c:	89 30       	cpi	r24, 0x09	; 9
   11f8e:	09 f4       	brne	.+2      	; 0x11f92 <FMenuReprint+0x5a>
   11f90:	b8 c0       	rjmp	.+368    	; 0x12102 <FMenuReprint+0x1ca>
   11f92:	8a 30       	cpi	r24, 0x0A	; 10
   11f94:	08 f0       	brcs	.+2      	; 0x11f98 <FMenuReprint+0x60>
   11f96:	ca c0       	rjmp	.+404    	; 0x1212c <FMenuReprint+0x1f4>
   11f98:	7c c0       	rjmp	.+248    	; 0x12092 <FMenuReprint+0x15a>
   11f9a:	8d 30       	cpi	r24, 0x0D	; 13
   11f9c:	09 f4       	brne	.+2      	; 0x11fa0 <FMenuReprint+0x68>
   11f9e:	ed c0       	rjmp	.+474    	; 0x1217a <FMenuReprint+0x242>
   11fa0:	8d 30       	cpi	r24, 0x0D	; 13
   11fa2:	08 f4       	brcc	.+2      	; 0x11fa6 <FMenuReprint+0x6e>
   11fa4:	d7 c0       	rjmp	.+430    	; 0x12154 <FMenuReprint+0x21c>
   11fa6:	8e 30       	cpi	r24, 0x0E	; 14
   11fa8:	09 f0       	breq	.+2      	; 0x11fac <FMenuReprint+0x74>
   11faa:	f0 c0       	rjmp	.+480    	; 0x1218c <FMenuReprint+0x254>
   11fac:	eb c0       	rjmp	.+470    	; 0x12184 <FMenuReprint+0x24c>
	 case rtInit:
	      lcd_clear();
   11fae:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
          if (IFType==IT_SLAVE)stReprint=rtFIP;
   11fb2:	80 91 25 01 	lds	r24, 0x0125
   11fb6:	81 30       	cpi	r24, 0x01	; 1
   11fb8:	09 f4       	brne	.+2      	; 0x11fbc <FMenuReprint+0x84>
   11fba:	b3 c0       	rjmp	.+358    	; 0x12122 <FMenuReprint+0x1ea>
		  else
		  if (IFType==IT_STANDALONE)stReprint=rtStandaloneFIP;//rtValidPassword;//rtStandaloneFIP;
   11fbc:	82 30       	cpi	r24, 0x02	; 2
   11fbe:	09 f0       	breq	.+2      	; 0x11fc2 <FMenuReprint+0x8a>
   11fc0:	e5 c0       	rjmp	.+458    	; 0x1218c <FMenuReprint+0x254>
   11fc2:	04 c0       	rjmp	.+8      	; 0x11fcc <FMenuReprint+0x94>
	      break;
     case rtValidPassword:
	      PassResult=FMenuPassword();
   11fc4:	0e 94 d9 8e 	call	0x11db2	; 0x11db2 <FMenuPassword>
	      if (PassResult==MP_VALID_ADMIN)stReprint=rtStandaloneFIP;
   11fc8:	84 30       	cpi	r24, 0x04	; 4
   11fca:	11 f4       	brne	.+4      	; 0x11fd0 <FMenuReprint+0x98>
   11fcc:	81 e0       	ldi	r24, 0x01	; 1
   11fce:	0a c0       	rjmp	.+20     	; 0x11fe4 <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_VALID_SYSTEM)stReprint=rtInvalidPassword;
   11fd0:	85 30       	cpi	r24, 0x05	; 5
   11fd2:	11 f0       	breq	.+4      	; 0x11fd8 <FMenuReprint+0xa0>
          else
	      if (PassResult==MP_INVALID)stReprint=rtInvalidPassword;
   11fd4:	82 30       	cpi	r24, 0x02	; 2
   11fd6:	11 f4       	brne	.+4      	; 0x11fdc <FMenuReprint+0xa4>
   11fd8:	83 e0       	ldi	r24, 0x03	; 3
   11fda:	04 c0       	rjmp	.+8      	; 0x11fe4 <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
   11fdc:	81 30       	cpi	r24, 0x01	; 1
   11fde:	09 f0       	breq	.+2      	; 0x11fe2 <FMenuReprint+0xaa>
   11fe0:	d5 c0       	rjmp	.+426    	; 0x1218c <FMenuReprint+0x254>
   11fe2:	8e e0       	ldi	r24, 0x0E	; 14
   11fe4:	80 93 6d 03 	sts	0x036D, r24
   11fe8:	d1 c0       	rjmp	.+418    	; 0x1218c <FMenuReprint+0x254>
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
   11fea:	10 92 bc 01 	sts	0x01BC, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11fee:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   11ff0:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11ff2:	81 e0       	ldi	r24, 0x01	; 1
   11ff4:	90 e0       	ldi	r25, 0x00	; 0
   11ff6:	90 93 ec 01 	sts	0x01EC, r25
   11ffa:	80 93 eb 01 	sts	0x01EB, r24
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   11ffe:	83 e0       	ldi	r24, 0x03	; 3
   12000:	61 e0       	ldi	r22, 0x01	; 1
   12002:	4b ee       	ldi	r20, 0xEB	; 235
   12004:	5a e1       	ldi	r21, 0x1A	; 26
   12006:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
   1200a:	33 c0       	rjmp	.+102    	; 0x12072 <FMenuReprint+0x13a>
          stReprint=rtTimDisplayInvalid;
	      break;
     case rtTimDisplayInvalid:
	      if (TimDisplay>2)stReprint=rtExitReprint;
   1200c:	80 91 bc 01 	lds	r24, 0x01BC
   12010:	83 30       	cpi	r24, 0x03	; 3
   12012:	08 f4       	brcc	.+2      	; 0x12016 <FMenuReprint+0xde>
   12014:	bb c0       	rjmp	.+374    	; 0x1218c <FMenuReprint+0x254>
   12016:	e5 cf       	rjmp	.-54     	; 0x11fe2 <FMenuReprint+0xaa>
	      break;
     case rtStandaloneFIP:
	      _scr_pump();
   12018:	0e 94 16 41 	call	0x822c	; 0x822c <_scr_pump>
		  stReprint=rtStandaloneInputFIP;
   1201c:	86 e0       	ldi	r24, 0x06	; 6
   1201e:	e2 cf       	rjmp	.-60     	; 0x11fe4 <FMenuReprint+0xac>
	      break;
     case rtStandaloneInputFIP:
		  KeyChar=_key_btn(_key_scan(1));
   12020:	81 e0       	ldi	r24, 0x01	; 1
   12022:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   12026:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   1202a:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='8')){
   1202c:	81 53       	subi	r24, 0x31	; 49
   1202e:	88 30       	cpi	r24, 0x08	; 8
   12030:	60 f4       	brcc	.+24     	; 0x1204a <FMenuReprint+0x112>
		       ReprintResult=PrintStandalone(KeyChar-'0',True);
   12032:	8f 5f       	subi	r24, 0xFF	; 255
   12034:	61 e0       	ldi	r22, 0x01	; 1
   12036:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <PrintStandalone>
			   if (ReprintResult==PS_NO_DATA)stReprint=rtDisplayNoTransaction;
   1203a:	82 31       	cpi	r24, 0x12	; 18
   1203c:	11 f4       	brne	.+4      	; 0x12042 <FMenuReprint+0x10a>
   1203e:	85 e0       	ldi	r24, 0x05	; 5
   12040:	d1 cf       	rjmp	.-94     	; 0x11fe4 <FMenuReprint+0xac>
			   else if (ReprintResult==PS_PRINTED)stReprint=rtExitReprint;
   12042:	81 31       	cpi	r24, 0x11	; 17
   12044:	09 f0       	breq	.+2      	; 0x12048 <FMenuReprint+0x110>
   12046:	a2 c0       	rjmp	.+324    	; 0x1218c <FMenuReprint+0x254>
   12048:	cc cf       	rjmp	.-104    	; 0x11fe2 <FMenuReprint+0xaa>

		  }else if (KeyChar=='*')stReprint=rtExitReprint;
   1204a:	9a 32       	cpi	r25, 0x2A	; 42
   1204c:	09 f0       	breq	.+2      	; 0x12050 <FMenuReprint+0x118>
   1204e:	9e c0       	rjmp	.+316    	; 0x1218c <FMenuReprint+0x254>
   12050:	c8 cf       	rjmp	.-112    	; 0x11fe2 <FMenuReprint+0xaa>

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   12052:	83 e0       	ldi	r24, 0x03	; 3
   12054:	61 e0       	ldi	r22, 0x01	; 1
   12056:	46 ed       	ldi	r20, 0xD6	; 214
   12058:	5a e1       	ldi	r21, 0x1A	; 26
   1205a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1205e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   12060:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   12062:	81 e0       	ldi	r24, 0x01	; 1
   12064:	90 e0       	ldi	r25, 0x00	; 0
   12066:	90 93 ec 01 	sts	0x01EC, r25
   1206a:	80 93 eb 01 	sts	0x01EB, r24

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
		  system_beep(1);
          TimDisplay=0;
   1206e:	10 92 bc 01 	sts	0x01BC, r1
		  stReprint=rtTimDisplayInvalid;
   12072:	84 e0       	ldi	r24, 0x04	; 4
   12074:	b7 cf       	rjmp	.-146    	; 0x11fe4 <FMenuReprint+0xac>
	      break;
	 case rtFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   12076:	8b e6       	ldi	r24, 0x6B	; 107
   12078:	93 e0       	ldi	r25, 0x03	; 3
   1207a:	68 ec       	ldi	r22, 0xC8	; 200
   1207c:	79 e0       	ldi	r23, 0x09	; 9
   1207e:	0e 94 df 64 	call	0xc9be	; 0xc9be <menu_FIP>
		  if (FIPResult==FIP_DONE){
   12082:	88 23       	and	r24, r24
   12084:	11 f4       	brne	.+4      	; 0x1208a <FMenuReprint+0x152>
		      stReprint=rtRFID;
   12086:	88 e0       	ldi	r24, 0x08	; 8
   12088:	ad cf       	rjmp	.-166    	; 0x11fe4 <FMenuReprint+0xac>
			  }
		  else
		  if (FIPResult==FIP_CANCEL)stReprint=rtExitReprint;
   1208a:	82 30       	cpi	r24, 0x02	; 2
   1208c:	09 f0       	breq	.+2      	; 0x12090 <FMenuReprint+0x158>
   1208e:	7e c0       	rjmp	.+252    	; 0x1218c <FMenuReprint+0x254>
   12090:	a8 cf       	rjmp	.-176    	; 0x11fe2 <FMenuReprint+0xaa>
	      break;
	 case rtRFID:
	      lcd_clear();
   12092:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("RePrint FIP:%s "),strFIP_ID);lcd_print(1,1,lcdteks);
   12096:	00 d0       	rcall	.+0      	; 0x12098 <FMenuReprint+0x160>
   12098:	00 d0       	rcall	.+0      	; 0x1209a <FMenuReprint+0x162>
   1209a:	00 d0       	rcall	.+0      	; 0x1209c <FMenuReprint+0x164>
   1209c:	ed b7       	in	r30, 0x3d	; 61
   1209e:	fe b7       	in	r31, 0x3e	; 62
   120a0:	31 96       	adiw	r30, 0x01	; 1
   120a2:	8e 01       	movw	r16, r28
   120a4:	0f 5f       	subi	r16, 0xFF	; 255
   120a6:	1f 4f       	sbci	r17, 0xFF	; 255
   120a8:	ad b7       	in	r26, 0x3d	; 61
   120aa:	be b7       	in	r27, 0x3e	; 62
   120ac:	12 96       	adiw	r26, 0x02	; 2
   120ae:	1c 93       	st	X, r17
   120b0:	0e 93       	st	-X, r16
   120b2:	11 97       	sbiw	r26, 0x01	; 1
   120b4:	86 ec       	ldi	r24, 0xC6	; 198
   120b6:	9a e1       	ldi	r25, 0x1A	; 26
   120b8:	93 83       	std	Z+3, r25	; 0x03
   120ba:	82 83       	std	Z+2, r24	; 0x02
   120bc:	88 ec       	ldi	r24, 0xC8	; 200
   120be:	99 e0       	ldi	r25, 0x09	; 9
   120c0:	95 83       	std	Z+5, r25	; 0x05
   120c2:	84 83       	std	Z+4, r24	; 0x04
   120c4:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   120c8:	8d b7       	in	r24, 0x3d	; 61
   120ca:	9e b7       	in	r25, 0x3e	; 62
   120cc:	06 96       	adiw	r24, 0x06	; 6
   120ce:	0f b6       	in	r0, 0x3f	; 63
   120d0:	f8 94       	cli
   120d2:	9e bf       	out	0x3e, r25	; 62
   120d4:	0f be       	out	0x3f, r0	; 63
   120d6:	8d bf       	out	0x3d, r24	; 61
   120d8:	81 e0       	ldi	r24, 0x01	; 1
   120da:	61 e0       	ldi	r22, 0x01	; 1
   120dc:	a8 01       	movw	r20, r16
   120de:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_printf(2,1,PSTR(  "Tap Supervisor Card"));
   120e2:	82 e0       	ldi	r24, 0x02	; 2
   120e4:	61 e0       	ldi	r22, 0x01	; 1
   120e6:	42 eb       	ldi	r20, 0xB2	; 178
   120e8:	5a e1       	ldi	r21, 0x1A	; 26
   120ea:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
          lcd_printf(4,1,PSTR(  "[*]Back    [#]Exit"));
   120ee:	84 e0       	ldi	r24, 0x04	; 4
   120f0:	61 e0       	ldi	r22, 0x01	; 1
   120f2:	4f e9       	ldi	r20, 0x9F	; 159
   120f4:	5a e1       	ldi	r21, 0x1A	; 26
   120f6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  IsRFIDDetected=False;
   120fa:	10 92 c4 01 	sts	0x01C4, r1
		  stReprint=rtInputRFID;
   120fe:	89 e0       	ldi	r24, 0x09	; 9
   12100:	71 cf       	rjmp	.-286    	; 0x11fe4 <FMenuReprint+0xac>
	      break;
	 case rtInputRFID:
	      if (IsRFIDDetected==True){
   12102:	80 91 c4 01 	lds	r24, 0x01C4
   12106:	81 30       	cpi	r24, 0x01	; 1
   12108:	29 f4       	brne	.+10     	; 0x12114 <FMenuReprint+0x1dc>
		      IsRFIDDetected=False;
   1210a:	10 92 c4 01 	sts	0x01C4, r1
		      stReprint=rtSendMessage28;
   1210e:	8a e0       	ldi	r24, 0x0A	; 10
   12110:	80 93 6d 03 	sts	0x036D, r24
		  }
	 	  KeyPressed=_key_scan(1);
   12114:	81 e0       	ldi	r24, 0x01	; 1
   12116:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   1211a:	80 93 6c 03 	sts	0x036C, r24
		  if (KeyPressed==_KEY_CANCEL){
   1211e:	87 3e       	cpi	r24, 0xE7	; 231
   12120:	11 f4       	brne	.+4      	; 0x12126 <FMenuReprint+0x1ee>
		      stReprint=rtFIP;
   12122:	87 e0       	ldi	r24, 0x07	; 7
   12124:	5f cf       	rjmp	.-322    	; 0x11fe4 <FMenuReprint+0xac>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stReprint=rtExitReprint;
   12126:	87 3b       	cpi	r24, 0xB7	; 183
   12128:	89 f5       	brne	.+98     	; 0x1218c <FMenuReprint+0x254>
   1212a:	5b cf       	rjmp	.-330    	; 0x11fe2 <FMenuReprint+0xaa>
	      break;
     case rtSendMessage28:
		  sendMessage28();
   1212c:	0e 94 28 50 	call	0xa050	; 0xa050 <sendMessage28>
		  TimSend=0;
   12130:	10 92 be 01 	sts	0x01BE, r1
   12134:	10 92 bd 01 	sts	0x01BD, r1
		  stReprint=rtWaitReply;
   12138:	8b e0       	ldi	r24, 0x0B	; 11
   1213a:	54 cf       	rjmp	.-344    	; 0x11fe4 <FMenuReprint+0xac>
		  break;
     case rtWaitReply:
	      if (TimSend>TIM_SEND)stReprint=rtNoConnection;
   1213c:	80 91 bd 01 	lds	r24, 0x01BD
   12140:	90 91 be 01 	lds	r25, 0x01BE
   12144:	0b 97       	sbiw	r24, 0x0b	; 11
   12146:	18 f0       	brcs	.+6      	; 0x1214e <FMenuReprint+0x216>
   12148:	8c e0       	ldi	r24, 0x0C	; 12
   1214a:	80 93 6d 03 	sts	0x036D, r24
	      if (IsMessage99==True){
   1214e:	80 91 cc 01 	lds	r24, 0x01CC
   12152:	44 cf       	rjmp	.-376    	; 0x11fdc <FMenuReprint+0xa4>
		      stReprint=rtExitReprint;
		  }
	      break;
     case rtNoConnection:
	      lcd_clear();
   12154:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
   12158:	82 e0       	ldi	r24, 0x02	; 2
   1215a:	61 e0       	ldi	r22, 0x01	; 1
   1215c:	41 e9       	ldi	r20, 0x91	; 145
   1215e:	5a e1       	ldi	r21, 0x1A	; 26
   12160:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
   12164:	83 e0       	ldi	r24, 0x03	; 3
   12166:	61 e0       	ldi	r22, 0x01	; 1
   12168:	43 e8       	ldi	r20, 0x83	; 131
   1216a:	5a e1       	ldi	r21, 0x1A	; 26
   1216c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  TimDisplay=5;
   12170:	85 e0       	ldi	r24, 0x05	; 5
   12172:	80 93 bc 01 	sts	0x01BC, r24
		  stReprint=rtDelayExitReprint;
   12176:	8d e0       	ldi	r24, 0x0D	; 13
   12178:	35 cf       	rjmp	.-406    	; 0x11fe4 <FMenuReprint+0xac>
	      break;
     case rtDelayExitReprint:
	      if(TimDisplay>=10)stReprint=rtExitReprint;
   1217a:	80 91 bc 01 	lds	r24, 0x01BC
   1217e:	8a 30       	cpi	r24, 0x0A	; 10
   12180:	28 f0       	brcs	.+10     	; 0x1218c <FMenuReprint+0x254>
   12182:	2f cf       	rjmp	.-418    	; 0x11fe2 <FMenuReprint+0xaa>
	      break;
	 case rtExitReprint:
	      stReprint=rtInit;
   12184:	10 92 6d 03 	sts	0x036D, r1
   12188:	81 e0       	ldi	r24, 0x01	; 1
   1218a:	01 c0       	rjmp	.+2      	; 0x1218e <FMenuReprint+0x256>
   1218c:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   1218e:	64 96       	adiw	r28, 0x14	; 20
   12190:	0f b6       	in	r0, 0x3f	; 63
   12192:	f8 94       	cli
   12194:	de bf       	out	0x3e, r29	; 62
   12196:	0f be       	out	0x3f, r0	; 63
   12198:	cd bf       	out	0x3d, r28	; 61
   1219a:	cf 91       	pop	r28
   1219c:	df 91       	pop	r29
   1219e:	1f 91       	pop	r17
   121a0:	0f 91       	pop	r16
   121a2:	08 95       	ret

000121a4 <FMenuAdmin>:

char FMenuAdmin(){
static char stMenuAdmin=maInitAdmin;
	 char SubMenu,KeyPressed,KeyChar,Result=MENU_NONE;
     
	 switch(stMenuAdmin){
   121a4:	80 91 3d 03 	lds	r24, 0x033D
   121a8:	83 30       	cpi	r24, 0x03	; 3
   121aa:	09 f4       	brne	.+2      	; 0x121ae <FMenuAdmin+0xa>
   121ac:	66 c0       	rjmp	.+204    	; 0x1227a <FMenuAdmin+0xd6>
   121ae:	84 30       	cpi	r24, 0x04	; 4
   121b0:	30 f4       	brcc	.+12     	; 0x121be <FMenuAdmin+0x1a>
   121b2:	81 30       	cpi	r24, 0x01	; 1
   121b4:	69 f1       	breq	.+90     	; 0x12210 <FMenuAdmin+0x6c>
   121b6:	82 30       	cpi	r24, 0x02	; 2
   121b8:	08 f0       	brcs	.+2      	; 0x121bc <FMenuAdmin+0x18>
   121ba:	4d c0       	rjmp	.+154    	; 0x12256 <FMenuAdmin+0xb2>
   121bc:	0d c0       	rjmp	.+26     	; 0x121d8 <FMenuAdmin+0x34>
   121be:	85 30       	cpi	r24, 0x05	; 5
   121c0:	09 f4       	brne	.+2      	; 0x121c4 <FMenuAdmin+0x20>
   121c2:	4e c0       	rjmp	.+156    	; 0x12260 <FMenuAdmin+0xbc>
   121c4:	85 30       	cpi	r24, 0x05	; 5
   121c6:	08 f4       	brcc	.+2      	; 0x121ca <FMenuAdmin+0x26>
   121c8:	49 c0       	rjmp	.+146    	; 0x1225c <FMenuAdmin+0xb8>
   121ca:	86 30       	cpi	r24, 0x06	; 6
   121cc:	09 f4       	brne	.+2      	; 0x121d0 <FMenuAdmin+0x2c>
   121ce:	51 c0       	rjmp	.+162    	; 0x12272 <FMenuAdmin+0xce>
   121d0:	87 30       	cpi	r24, 0x07	; 7
   121d2:	09 f0       	breq	.+2      	; 0x121d6 <FMenuAdmin+0x32>
   121d4:	5a c0       	rjmp	.+180    	; 0x1228a <FMenuAdmin+0xe6>
   121d6:	55 c0       	rjmp	.+170    	; 0x12282 <FMenuAdmin+0xde>
	 case maInitAdmin:
		  lcd_clear();
   121d8:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)RePrint           "));
   121dc:	81 e0       	ldi	r24, 0x01	; 1
   121de:	61 e0       	ldi	r22, 0x01	; 1
   121e0:	4d e7       	ldi	r20, 0x7D	; 125
   121e2:	55 e1       	ldi	r21, 0x15	; 21
   121e4:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(2,1,PSTR("2)CloseShift        "));
   121e8:	82 e0       	ldi	r24, 0x02	; 2
   121ea:	61 e0       	ldi	r22, 0x01	; 1
   121ec:	48 e6       	ldi	r20, 0x68	; 104
   121ee:	55 e1       	ldi	r21, 0x15	; 21
   121f0:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(3,1,PSTR("3)CloseDay          "));		  
   121f4:	83 e0       	ldi	r24, 0x03	; 3
   121f6:	61 e0       	ldi	r22, 0x01	; 1
   121f8:	43 e5       	ldi	r20, 0x53	; 83
   121fa:	55 e1       	ldi	r21, 0x15	; 21
   121fc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(4,1,PSTR("4)Settings   *)Exit "));
   12200:	84 e0       	ldi	r24, 0x04	; 4
   12202:	61 e0       	ldi	r22, 0x01	; 1
   12204:	4e e3       	ldi	r20, 0x3E	; 62
   12206:	55 e1       	ldi	r21, 0x15	; 21
   12208:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	      stMenuAdmin=maSelectOptions;
   1220c:	81 e0       	ldi	r24, 0x01	; 1
   1220e:	2e c0       	rjmp	.+92     	; 0x1226c <FMenuAdmin+0xc8>
	      break;
	 case maSelectOptions:
          KeyPressed=_key_scan(1);
   12210:	81 e0       	ldi	r24, 0x01	; 1
   12212:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   12216:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
		  switch (KeyChar){
   1221a:	82 33       	cpi	r24, 0x32	; 50
   1221c:	71 f0       	breq	.+28     	; 0x1223a <FMenuAdmin+0x96>
   1221e:	83 33       	cpi	r24, 0x33	; 51
   12220:	28 f4       	brcc	.+10     	; 0x1222c <FMenuAdmin+0x88>
   12222:	8a 32       	cpi	r24, 0x2A	; 42
   12224:	11 f1       	breq	.+68     	; 0x1226a <FMenuAdmin+0xc6>
   12226:	81 33       	cpi	r24, 0x31	; 49
   12228:	81 f5       	brne	.+96     	; 0x1228a <FMenuAdmin+0xe6>
   1222a:	05 c0       	rjmp	.+10     	; 0x12236 <FMenuAdmin+0x92>
   1222c:	83 33       	cpi	r24, 0x33	; 51
   1222e:	59 f0       	breq	.+22     	; 0x12246 <FMenuAdmin+0xa2>
   12230:	84 33       	cpi	r24, 0x34	; 52
   12232:	59 f5       	brne	.+86     	; 0x1228a <FMenuAdmin+0xe6>
   12234:	0e c0       	rjmp	.+28     	; 0x12252 <FMenuAdmin+0xae>
		  case '1':
		       stMenuAdmin=maMenuReprint;//maMenuAdminConfig;
   12236:	82 e0       	ldi	r24, 0x02	; 2
   12238:	19 c0       	rjmp	.+50     	; 0x1226c <FMenuAdmin+0xc8>
		       break;  
		  case '2':
		       if (IFType==IT_STANDALONE)
   1223a:	80 91 25 01 	lds	r24, 0x0125
   1223e:	82 30       	cpi	r24, 0x02	; 2
   12240:	e1 f4       	brne	.+56     	; 0x1227a <FMenuAdmin+0xd6>
			       stMenuAdmin=maMenuCloseShift;
   12242:	84 e0       	ldi	r24, 0x04	; 4
   12244:	13 c0       	rjmp	.+38     	; 0x1226c <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '3':
		       if (IFType==IT_STANDALONE)stMenuAdmin=maMenuCloseDay;
   12246:	80 91 25 01 	lds	r24, 0x0125
   1224a:	82 30       	cpi	r24, 0x02	; 2
   1224c:	b1 f4       	brne	.+44     	; 0x1227a <FMenuAdmin+0xd6>
   1224e:	85 e0       	ldi	r24, 0x05	; 5
   12250:	0d c0       	rjmp	.+26     	; 0x1226c <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '4':
		  	   stMenuAdmin=maMenuAdminSettings;
   12252:	86 e0       	ldi	r24, 0x06	; 6
   12254:	0b c0       	rjmp	.+22     	; 0x1226c <FMenuAdmin+0xc8>
    		   stMenuAdmin=maExitMenuAdmin;
		       break;  		  
		  }		  
	      break;
     case maMenuReprint:
	      SubMenu=FMenuReprint();
   12256:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <FMenuReprint>
   1225a:	05 c0       	rjmp	.+10     	; 0x12266 <FMenuAdmin+0xc2>
	 case maMenuAdminConfig://ChangePassword[],RePrint,PumpTest
	      SubMenu=FSubMenuAdmin();
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;
          break;	 
	 case maMenuCloseShift:
	 	  SubMenu=FCloseShift(CONTINUE_SHIFT);
   1225c:	82 e0       	ldi	r24, 0x02	; 2
   1225e:	01 c0       	rjmp	.+2      	; 0x12262 <FMenuAdmin+0xbe>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
	      break;
     case maMenuCloseDay://maMenuCloseShift,maMenuCloseDay
	 	  SubMenu=FCloseShift(NEW_SHIFT);
   12260:	81 e0       	ldi	r24, 0x01	; 1
   12262:	0e 94 2a 5e 	call	0xbc54	; 0xbc54 <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
   12266:	81 30       	cpi	r24, 0x01	; 1
   12268:	81 f4       	brne	.+32     	; 0x1228a <FMenuAdmin+0xe6>
   1226a:	87 e0       	ldi	r24, 0x07	; 7
   1226c:	80 93 3d 03 	sts	0x033D, r24
   12270:	06 c0       	rjmp	.+12     	; 0x1227e <FMenuAdmin+0xda>
	      break;
     case maMenuAdminSettings:
	      SubMenu=FMenuAdminSettings();
   12272:	0e 94 38 8c 	call	0x11870	; 0x11870 <FMenuAdminSettings>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;	      
   12276:	81 30       	cpi	r24, 0x01	; 1
   12278:	41 f4       	brne	.+16     	; 0x1228a <FMenuAdmin+0xe6>
   1227a:	10 92 3d 03 	sts	0x033D, r1
   1227e:	80 e0       	ldi	r24, 0x00	; 0
   12280:	08 95       	ret
	      break;
     case maExitMenuAdmin:
	      stMenuAdmin=maInitAdmin;	      
   12282:	10 92 3d 03 	sts	0x033D, r1
   12286:	81 e0       	ldi	r24, 0x01	; 1
   12288:	08 95       	ret
   1228a:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
          break;	 
	 }
   return Result;
}
   1228c:	08 95       	ret

0001228e <FMenuChangeMOP>:
	      break;
	 }
   return Result;
}

char FMenuChangeMOP(){
   1228e:	af 92       	push	r10
   12290:	bf 92       	push	r11
   12292:	cf 92       	push	r12
   12294:	df 92       	push	r13
   12296:	ef 92       	push	r14
   12298:	ff 92       	push	r15
   1229a:	0f 93       	push	r16
   1229c:	1f 93       	push	r17
   1229e:	df 93       	push	r29
   122a0:	cf 93       	push	r28
   122a2:	cd b7       	in	r28, 0x3d	; 61
   122a4:	de b7       	in	r29, 0x3e	; 62
   122a6:	a3 97       	sbiw	r28, 0x23	; 35
   122a8:	0f b6       	in	r0, 0x3f	; 63
   122aa:	f8 94       	cli
   122ac:	de bf       	out	0x3e, r29	; 62
   122ae:	0f be       	out	0x3f, r0	; 63
   122b0:	cd bf       	out	0x3d, r28	; 61
	   char strBankName[11],strSurcharge[4],Result;
static char BankIdx=0,Surcharge=0,uiResult;
     
Result=MENU_NONE; 

	 switch(stChangeMOP){
   122b2:	80 91 62 03 	lds	r24, 0x0362
   122b6:	e8 2f       	mov	r30, r24
   122b8:	f0 e0       	ldi	r31, 0x00	; 0
   122ba:	ee 31       	cpi	r30, 0x1E	; 30
   122bc:	f1 05       	cpc	r31, r1
   122be:	08 f0       	brcs	.+2      	; 0x122c2 <FMenuChangeMOP+0x34>
   122c0:	0b c4       	rjmp	.+2070   	; 0x12ad8 <FMenuChangeMOP+0x84a>
   122c2:	ec 53       	subi	r30, 0x3C	; 60
   122c4:	ff 4f       	sbci	r31, 0xFF	; 255
   122c6:	ee 0f       	add	r30, r30
   122c8:	ff 1f       	adc	r31, r31
   122ca:	05 90       	lpm	r0, Z+
   122cc:	f4 91       	lpm	r31, Z+
   122ce:	e0 2d       	mov	r30, r0
   122d0:	09 94       	ijmp
	 case cmInit:
	      MOPType=PAY_NONE;
   122d2:	85 e0       	ldi	r24, 0x05	; 5
   122d4:	80 93 e4 01 	sts	0x01E4, r24
   122d8:	4e c1       	rjmp	.+668    	; 0x12576 <FMenuChangeMOP+0x2e8>
		  stChangeMOP=cmDisplayMOPOption;
	      break;
	 case cmDisplayMOPOption: //12345678901234567890
	      lcd_clear();
   122da:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
	      lcd_printf(1,1,PSTR("   Select Payment   "));
   122de:	81 e0       	ldi	r24, 0x01	; 1
   122e0:	61 e0       	ldi	r22, 0x01	; 1
   122e2:	43 e3       	ldi	r20, 0x33	; 51
   122e4:	59 e1       	ldi	r21, 0x19	; 25
   122e6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	      lcd_printf(2,1,PSTR("1.Account 3.Voucher "));
   122ea:	82 e0       	ldi	r24, 0x02	; 2
   122ec:	61 e0       	ldi	r22, 0x01	; 1
   122ee:	4e e1       	ldi	r20, 0x1E	; 30
   122f0:	59 e1       	ldi	r21, 0x19	; 25
   122f2:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	      lcd_printf(3,1,PSTR("2.Bank    4.PumpTest"));
   122f6:	83 e0       	ldi	r24, 0x03	; 3
   122f8:	61 e0       	ldi	r22, 0x01	; 1
   122fa:	49 e0       	ldi	r20, 0x09	; 9
   122fc:	59 e1       	ldi	r21, 0x19	; 25
   122fe:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
   12302:	84 e0       	ldi	r24, 0x04	; 4
   12304:	61 e0       	ldi	r22, 0x01	; 1
   12306:	44 ef       	ldi	r20, 0xF4	; 244
   12308:	58 e1       	ldi	r21, 0x18	; 24
   1230a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
          stChangeMOP=cmInputMOP;		 
   1230e:	82 e0       	ldi	r24, 0x02	; 2
   12310:	b5 c1       	rjmp	.+874    	; 0x1267c <FMenuChangeMOP+0x3ee>
		  break;
	 case cmInputMOP:
	      KeyPressed=_key_scan(1);
   12312:	81 e0       	ldi	r24, 0x01	; 1
   12314:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   12318:	80 93 5d 03 	sts	0x035D, r24
		  KeyChar=_key_btn(KeyPressed);
   1231c:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   12320:	98 2f       	mov	r25, r24
   12322:	80 93 5e 03 	sts	0x035E, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   12326:	81 53       	subi	r24, 0x31	; 49
   12328:	84 30       	cpi	r24, 0x04	; 4
   1232a:	f0 f4       	brcc	.+60     	; 0x12368 <FMenuChangeMOP+0xda>
              switch(KeyChar){
   1232c:	92 33       	cpi	r25, 0x32	; 50
   1232e:	61 f0       	breq	.+24     	; 0x12348 <FMenuChangeMOP+0xba>
   12330:	93 33       	cpi	r25, 0x33	; 51
   12332:	18 f4       	brcc	.+6      	; 0x1233a <FMenuChangeMOP+0xac>
   12334:	91 33       	cpi	r25, 0x31	; 49
   12336:	c1 f4       	brne	.+48     	; 0x12368 <FMenuChangeMOP+0xda>
   12338:	05 c0       	rjmp	.+10     	; 0x12344 <FMenuChangeMOP+0xb6>
   1233a:	93 33       	cpi	r25, 0x33	; 51
   1233c:	51 f0       	breq	.+20     	; 0x12352 <FMenuChangeMOP+0xc4>
   1233e:	94 33       	cpi	r25, 0x34	; 52
   12340:	99 f4       	brne	.+38     	; 0x12368 <FMenuChangeMOP+0xda>
   12342:	0c c0       	rjmp	.+24     	; 0x1235c <FMenuChangeMOP+0xce>
		        case '1':MOPType=PAY_ACCOUNT; stChangeMOP=cmSelectFIP;         break;
   12344:	81 e0       	ldi	r24, 0x01	; 1
   12346:	0b c0       	rjmp	.+22     	; 0x1235e <FMenuChangeMOP+0xd0>
		        case '2':MOPType=PAY_BANK;    stChangeMOP=cmSelectBankName;    break;
   12348:	82 e0       	ldi	r24, 0x02	; 2
   1234a:	80 93 e4 01 	sts	0x01E4, r24
   1234e:	8b e0       	ldi	r24, 0x0B	; 11
   12350:	09 c0       	rjmp	.+18     	; 0x12364 <FMenuChangeMOP+0xd6>
		        case '3':MOPType=PAY_VOUCHER; stChangeMOP=cmDispInputVoucher;  break;
   12352:	83 e0       	ldi	r24, 0x03	; 3
   12354:	80 93 e4 01 	sts	0x01E4, r24
   12358:	8f e0       	ldi	r24, 0x0F	; 15
   1235a:	04 c0       	rjmp	.+8      	; 0x12364 <FMenuChangeMOP+0xd6>
		        case '4':MOPType=PAY_PUMPTEST;stChangeMOP=cmSelectFIP;         break;
   1235c:	84 e0       	ldi	r24, 0x04	; 4
   1235e:	80 93 e4 01 	sts	0x01E4, r24
   12362:	89 e0       	ldi	r24, 0x09	; 9
   12364:	80 93 62 03 	sts	0x0362, r24
		     }
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmExitChangeMOP;
   12368:	80 91 5d 03 	lds	r24, 0x035D
   1236c:	87 3e       	cpi	r24, 0xE7	; 231
   1236e:	09 f0       	breq	.+2      	; 0x12372 <FMenuChangeMOP+0xe4>
   12370:	b3 c3       	rjmp	.+1894   	; 0x12ad8 <FMenuChangeMOP+0x84a>
   12372:	aa c3       	rjmp	.+1876   	; 0x12ac8 <FMenuChangeMOP+0x83a>
	      break;
	 case cmDispInputVoucher://Enter Voucher number
          lcd_clear();
   12374:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("Kode Voucher"));
   12378:	81 e0       	ldi	r24, 0x01	; 1
   1237a:	61 e0       	ldi	r22, 0x01	; 1
   1237c:	47 ee       	ldi	r20, 0xE7	; 231
   1237e:	58 e1       	ldi	r21, 0x18	; 24
   12380:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   12384:	82 e0       	ldi	r24, 0x02	; 2
   12386:	61 e0       	ldi	r22, 0x01	; 1
   12388:	45 ee       	ldi	r20, 0xE5	; 229
   1238a:	58 e1       	ldi	r21, 0x18	; 24
   1238c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12390:	84 e0       	ldi	r24, 0x04	; 4
   12392:	61 e0       	ldi	r22, 0x01	; 1
   12394:	40 ed       	ldi	r20, 0xD0	; 208
   12396:	58 e1       	ldi	r21, 0x18	; 24
   12398:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
   1239c:	e7 e4       	ldi	r30, 0x47	; 71
   1239e:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   123a0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   123a2:	8e e0       	ldi	r24, 0x0E	; 14
   123a4:	ec 35       	cpi	r30, 0x5C	; 92
   123a6:	f8 07       	cpc	r31, r24
   123a8:	d9 f7       	brne	.-10     	; 0x123a0 <FMenuChangeMOP+0x112>
          lcd_clear();
		  lcd_printf(1,1,PSTR("Kode Voucher"));
		  lcd_printf(2,1,PSTR("_"));
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
		  FillChar(strVoucherNum,sizeof(strVoucherNum),0);
          stChangeMOP=cmInputVoucher;
   123aa:	87 e0       	ldi	r24, 0x07	; 7
   123ac:	80 93 62 03 	sts	0x0362, r24
		  uiResult=USER_NONE;
   123b0:	10 92 4e 03 	sts	0x034E, r1
   123b4:	91 c3       	rjmp	.+1826   	; 0x12ad8 <FMenuChangeMOP+0x84a>
	      break;
     case cmInputVoucher:
          uiResult=UserInput(UI_NUMBER_R,2,1,strVoucherNum,0,13);
   123b6:	81 e0       	ldi	r24, 0x01	; 1
   123b8:	62 e0       	ldi	r22, 0x02	; 2
   123ba:	41 e0       	ldi	r20, 0x01	; 1
   123bc:	27 e4       	ldi	r18, 0x47	; 71
   123be:	3e e0       	ldi	r19, 0x0E	; 14
   123c0:	00 e0       	ldi	r16, 0x00	; 0
   123c2:	10 e0       	ldi	r17, 0x00	; 0
   123c4:	5d e0       	ldi	r21, 0x0D	; 13
   123c6:	e5 2e       	mov	r14, r21
   123c8:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
   123cc:	80 93 4e 03 	sts	0x034E, r24
	      if (uiResult==USER_OK){
   123d0:	83 30       	cpi	r24, 0x03	; 3
   123d2:	11 f4       	brne	.+4      	; 0x123d8 <FMenuChangeMOP+0x14a>
		     stChangeMOP=cmSelectFIP;
   123d4:	89 e0       	ldi	r24, 0x09	; 9
   123d6:	52 c1       	rjmp	.+676    	; 0x1267c <FMenuChangeMOP+0x3ee>
			 }
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmDisplayMOPOption;
   123d8:	81 30       	cpi	r24, 0x01	; 1
   123da:	09 f4       	brne	.+2      	; 0x123de <FMenuChangeMOP+0x150>
   123dc:	4f c1       	rjmp	.+670    	; 0x1267c <FMenuChangeMOP+0x3ee>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   123de:	84 30       	cpi	r24, 0x04	; 4
   123e0:	21 f4       	brne	.+8      	; 0x123ea <FMenuChangeMOP+0x15c>
   123e2:	61 e0       	ldi	r22, 0x01	; 1
   123e4:	4b eb       	ldi	r20, 0xBB	; 187
   123e6:	58 e1       	ldi	r21, 0x18	; 24
   123e8:	31 c1       	rjmp	.+610    	; 0x1264c <FMenuChangeMOP+0x3be>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   123ea:	85 30       	cpi	r24, 0x05	; 5
   123ec:	09 f0       	breq	.+2      	; 0x123f0 <FMenuChangeMOP+0x162>
   123ee:	74 c3       	rjmp	.+1768   	; 0x12ad8 <FMenuChangeMOP+0x84a>
   123f0:	84 e0       	ldi	r24, 0x04	; 4
   123f2:	61 e0       	ldi	r22, 0x01	; 1
   123f4:	46 ea       	ldi	r20, 0xA6	; 166
   123f6:	58 e1       	ldi	r21, 0x18	; 24
   123f8:	29 c1       	rjmp	.+594    	; 0x1264c <FMenuChangeMOP+0x3be>
	      break;
	 case cmSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   123fa:	8c e5       	ldi	r24, 0x5C	; 92
   123fc:	93 e0       	ldi	r25, 0x03	; 3
   123fe:	68 ec       	ldi	r22, 0xC8	; 200
   12400:	79 e0       	ldi	r23, 0x09	; 9
   12402:	0e 94 df 64 	call	0xc9be	; 0xc9be <menu_FIP>
   12406:	80 93 61 03 	sts	0x0361, r24
		  if (FIPResult==FIP_DONE){
   1240a:	88 23       	and	r24, r24
   1240c:	11 f4       	brne	.+4      	; 0x12412 <FMenuChangeMOP+0x184>
		      //sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
		      stChangeMOP=cmFlowFIP;
   1240e:	8e e0       	ldi	r24, 0x0E	; 14
   12410:	35 c1       	rjmp	.+618    	; 0x1267c <FMenuChangeMOP+0x3ee>
		  }
		  else
		  if (FIPResult==FIP_CANCEL){
   12412:	82 30       	cpi	r24, 0x02	; 2
   12414:	09 f0       	breq	.+2      	; 0x12418 <FMenuChangeMOP+0x18a>
   12416:	60 c3       	rjmp	.+1728   	; 0x12ad8 <FMenuChangeMOP+0x84a>
		      if (MOPType==PAY_ACCOUNT)stChangeMOP=cmDisplayMOPOption;
   12418:	80 91 e4 01 	lds	r24, 0x01E4
   1241c:	81 30       	cpi	r24, 0x01	; 1
   1241e:	09 f4       	brne	.+2      	; 0x12422 <FMenuChangeMOP+0x194>
   12420:	2d c1       	rjmp	.+602    	; 0x1267c <FMenuChangeMOP+0x3ee>
		      if (MOPType==PAY_BANK)stChangeMOP=cmSelectBankName;
   12422:	82 30       	cpi	r24, 0x02	; 2
   12424:	09 f4       	brne	.+2      	; 0x12428 <FMenuChangeMOP+0x19a>
   12426:	03 c1       	rjmp	.+518    	; 0x1262e <FMenuChangeMOP+0x3a0>
		      if (MOPType==PAY_VOUCHER)stChangeMOP=cmDispInputVoucher;
   12428:	83 30       	cpi	r24, 0x03	; 3
   1242a:	11 f4       	brne	.+4      	; 0x12430 <FMenuChangeMOP+0x1a2>
   1242c:	8f e0       	ldi	r24, 0x0F	; 15
   1242e:	26 c1       	rjmp	.+588    	; 0x1267c <FMenuChangeMOP+0x3ee>
		      if (MOPType==PAY_PUMPTEST)stChangeMOP=cmDisplayMOPOption;		  
   12430:	84 30       	cpi	r24, 0x04	; 4
   12432:	09 f4       	brne	.+2      	; 0x12436 <FMenuChangeMOP+0x1a8>
   12434:	a0 c0       	rjmp	.+320    	; 0x12576 <FMenuChangeMOP+0x2e8>
   12436:	50 c3       	rjmp	.+1696   	; 0x12ad8 <FMenuChangeMOP+0x84a>
     case cmSelectFIPInput:
		
	      break;
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
   12438:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Bank"));
   1243c:	81 e0       	ldi	r24, 0x01	; 1
   1243e:	61 e0       	ldi	r22, 0x01	; 1
   12440:	4a e9       	ldi	r20, 0x9A	; 154
   12442:	58 e1       	ldi	r21, 0x18	; 24
   12444:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   12448:	10 92 51 03 	sts	0x0351, r1
   1244c:	10 92 50 03 	sts	0x0350, r1
   12450:	8e 01       	movw	r16, r28
   12452:	0b 5f       	subi	r16, 0xFB	; 251
   12454:	1f 4f       	sbci	r17, 0xFF	; 255
   12456:	2b e0       	ldi	r18, 0x0B	; 11
   12458:	a2 2e       	mov	r10, r18
   1245a:	b1 2c       	mov	r11, r1
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   1245c:	90 e1       	ldi	r25, 0x10	; 16
   1245e:	e9 2e       	mov	r14, r25
   12460:	f1 2c       	mov	r15, r1
   12462:	ec 0e       	add	r14, r28
   12464:	fd 1e       	adc	r15, r29
   12466:	84 e9       	ldi	r24, 0x94	; 148
   12468:	c8 2e       	mov	r12, r24
   1246a:	88 e1       	ldi	r24, 0x18	; 24
   1246c:	d8 2e       	mov	r13, r24
   1246e:	5d c0       	rjmp	.+186    	; 0x1252a <FMenuChangeMOP+0x29c>
   12470:	8a 9d       	mul	r24, r10
   12472:	b0 01       	movw	r22, r0
   12474:	8b 9d       	mul	r24, r11
   12476:	70 0d       	add	r23, r0
   12478:	9a 9d       	mul	r25, r10
   1247a:	70 0d       	add	r23, r0
   1247c:	11 24       	eor	r1, r1
   1247e:	67 5c       	subi	r22, 0xC7	; 199
   12480:	7e 4f       	sbci	r23, 0xFE	; 254
   12482:	c8 01       	movw	r24, r16
   12484:	4b e0       	ldi	r20, 0x0B	; 11
   12486:	50 e0       	ldi	r21, 0x00	; 0
   12488:	2c ea       	ldi	r18, 0xAC	; 172
   1248a:	32 e1       	ldi	r19, 0x12	; 18
   1248c:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
   12490:	e0 e0       	ldi	r30, 0x00	; 0
   12492:	f0 e0       	ldi	r31, 0x00	; 0
   12494:	0b 30       	cpi	r16, 0x0B	; 11
   12496:	11 05       	cpc	r17, r1
   12498:	10 f4       	brcc	.+4      	; 0x1249e <FMenuChangeMOP+0x210>
   1249a:	e1 e0       	ldi	r30, 0x01	; 1
   1249c:	f0 e0       	ldi	r31, 0x00	; 0
   1249e:	80 81       	ld	r24, Z
   124a0:	88 23       	and	r24, r24
   124a2:	d1 f1       	breq	.+116    	; 0x12518 <FMenuChangeMOP+0x28a>
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   124a4:	ad b7       	in	r26, 0x3d	; 61
   124a6:	be b7       	in	r27, 0x3e	; 62
   124a8:	18 97       	sbiw	r26, 0x08	; 8
   124aa:	0f b6       	in	r0, 0x3f	; 63
   124ac:	f8 94       	cli
   124ae:	be bf       	out	0x3e, r27	; 62
   124b0:	0f be       	out	0x3f, r0	; 63
   124b2:	ad bf       	out	0x3d, r26	; 61
   124b4:	ed b7       	in	r30, 0x3d	; 61
   124b6:	fe b7       	in	r31, 0x3e	; 62
   124b8:	31 96       	adiw	r30, 0x01	; 1
   124ba:	12 96       	adiw	r26, 0x02	; 2
   124bc:	fc 92       	st	X, r15
   124be:	ee 92       	st	-X, r14
   124c0:	11 97       	sbiw	r26, 0x01	; 1
   124c2:	d3 82       	std	Z+3, r13	; 0x03
   124c4:	c2 82       	std	Z+2, r12	; 0x02
   124c6:	80 91 50 03 	lds	r24, 0x0350
   124ca:	90 91 51 03 	lds	r25, 0x0351
   124ce:	01 96       	adiw	r24, 0x01	; 1
   124d0:	95 83       	std	Z+5, r25	; 0x05
   124d2:	84 83       	std	Z+4, r24	; 0x04
   124d4:	17 83       	std	Z+7, r17	; 0x07
   124d6:	06 83       	std	Z+6, r16	; 0x06
   124d8:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
   124dc:	20 91 50 03 	lds	r18, 0x0350
   124e0:	30 91 51 03 	lds	r19, 0x0351
   124e4:	ed b7       	in	r30, 0x3d	; 61
   124e6:	fe b7       	in	r31, 0x3e	; 62
   124e8:	38 96       	adiw	r30, 0x08	; 8
   124ea:	0f b6       	in	r0, 0x3f	; 63
   124ec:	f8 94       	cli
   124ee:	fe bf       	out	0x3e, r31	; 62
   124f0:	0f be       	out	0x3f, r0	; 63
   124f2:	ed bf       	out	0x3d, r30	; 61
   124f4:	82 2f       	mov	r24, r18
   124f6:	81 70       	andi	r24, 0x01	; 1
   124f8:	36 95       	lsr	r19
   124fa:	27 95       	ror	r18
   124fc:	b9 01       	movw	r22, r18
   124fe:	66 0f       	add	r22, r22
   12500:	77 1f       	adc	r23, r23
   12502:	62 0f       	add	r22, r18
   12504:	73 1f       	adc	r23, r19
   12506:	66 0f       	add	r22, r22
   12508:	77 1f       	adc	r23, r23
   1250a:	66 0f       	add	r22, r22
   1250c:	77 1f       	adc	r23, r23
   1250e:	6f 5f       	subi	r22, 0xFF	; 255
   12510:	8e 5f       	subi	r24, 0xFE	; 254
   12512:	a7 01       	movw	r20, r14
   12514:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   12518:	80 91 50 03 	lds	r24, 0x0350
   1251c:	90 91 51 03 	lds	r25, 0x0351
   12520:	01 96       	adiw	r24, 0x01	; 1
   12522:	90 93 51 03 	sts	0x0351, r25
   12526:	80 93 50 03 	sts	0x0350, r24
   1252a:	80 91 50 03 	lds	r24, 0x0350
   1252e:	90 91 51 03 	lds	r25, 0x0351
   12532:	84 30       	cpi	r24, 0x04	; 4
   12534:	91 05       	cpc	r25, r1
   12536:	08 f4       	brcc	.+2      	; 0x1253a <FMenuChangeMOP+0x2ac>
   12538:	9b cf       	rjmp	.-202    	; 0x12470 <FMenuChangeMOP+0x1e2>
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
				 }
		  }
	      lcd_printf(4,1,PSTR("[*]Back"));
   1253a:	84 e0       	ldi	r24, 0x04	; 4
   1253c:	61 e0       	ldi	r22, 0x01	; 1
   1253e:	4c e8       	ldi	r20, 0x8C	; 140
   12540:	58 e1       	ldi	r21, 0x18	; 24
   12542:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  stChangeMOP=cmSelectBankNameInput;
   12546:	8c e0       	ldi	r24, 0x0C	; 12
   12548:	99 c0       	rjmp	.+306    	; 0x1267c <FMenuChangeMOP+0x3ee>
	      break;
     case cmSelectBankNameInput:
		  KeyPressed=_key_scan(1);
   1254a:	81 e0       	ldi	r24, 0x01	; 1
   1254c:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   12550:	80 93 5d 03 	sts	0x035D, r24
		  KeyChar=_key_btn(KeyPressed);
   12554:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   12558:	80 93 5e 03 	sts	0x035E, r24
          if ((KeyChar>='1')&&(KeyChar<='4')){
   1255c:	81 53       	subi	r24, 0x31	; 49
   1255e:	84 30       	cpi	r24, 0x04	; 4
   12560:	28 f4       	brcc	.+10     	; 0x1256c <FMenuChangeMOP+0x2de>
		      BankIdx=KeyChar-'1';
   12562:	80 93 4f 03 	sts	0x034F, r24
			  stChangeMOP=cmSelectFIP;
   12566:	89 e0       	ldi	r24, 0x09	; 9
   12568:	80 93 62 03 	sts	0x0362, r24
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmDisplayMOPOption;
   1256c:	80 91 5d 03 	lds	r24, 0x035D
   12570:	87 3e       	cpi	r24, 0xE7	; 231
   12572:	09 f0       	breq	.+2      	; 0x12576 <FMenuChangeMOP+0x2e8>
   12574:	b1 c2       	rjmp	.+1378   	; 0x12ad8 <FMenuChangeMOP+0x84a>
   12576:	81 e0       	ldi	r24, 0x01	; 1
   12578:	81 c0       	rjmp	.+258    	; 0x1267c <FMenuChangeMOP+0x3ee>

	      break;
     case cmDispBankSurcharge:
	      lcd_clear();
   1257a:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
   1257e:	e5 e0       	ldi	r30, 0x05	; 5
   12580:	ee 2e       	mov	r14, r30
   12582:	f1 2c       	mov	r15, r1
   12584:	ec 0e       	add	r14, r28
   12586:	fd 1e       	adc	r15, r29
   12588:	60 91 4f 03 	lds	r22, 0x034F
   1258c:	8b e0       	ldi	r24, 0x0B	; 11
   1258e:	68 9f       	mul	r22, r24
   12590:	b0 01       	movw	r22, r0
   12592:	11 24       	eor	r1, r1
   12594:	67 5c       	subi	r22, 0xC7	; 199
   12596:	7e 4f       	sbci	r23, 0xFE	; 254
   12598:	c7 01       	movw	r24, r14
   1259a:	4b e0       	ldi	r20, 0x0B	; 11
   1259c:	50 e0       	ldi	r21, 0x00	; 0
   1259e:	2c ea       	ldi	r18, 0xAC	; 172
   125a0:	32 e1       	ldi	r19, 0x12	; 18
   125a2:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
		  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		  sprintf_P(lcdteks,PSTR("%s"),strBankName);
   125a6:	00 d0       	rcall	.+0      	; 0x125a8 <FMenuChangeMOP+0x31a>
   125a8:	00 d0       	rcall	.+0      	; 0x125aa <FMenuChangeMOP+0x31c>
   125aa:	00 d0       	rcall	.+0      	; 0x125ac <FMenuChangeMOP+0x31e>
   125ac:	ed b7       	in	r30, 0x3d	; 61
   125ae:	fe b7       	in	r31, 0x3e	; 62
   125b0:	31 96       	adiw	r30, 0x01	; 1
   125b2:	8e 01       	movw	r16, r28
   125b4:	00 5f       	subi	r16, 0xF0	; 240
   125b6:	1f 4f       	sbci	r17, 0xFF	; 255
   125b8:	ad b7       	in	r26, 0x3d	; 61
   125ba:	be b7       	in	r27, 0x3e	; 62
   125bc:	12 96       	adiw	r26, 0x02	; 2
   125be:	1c 93       	st	X, r17
   125c0:	0e 93       	st	-X, r16
   125c2:	11 97       	sbiw	r26, 0x01	; 1
   125c4:	89 e8       	ldi	r24, 0x89	; 137
   125c6:	98 e1       	ldi	r25, 0x18	; 24
   125c8:	93 83       	std	Z+3, r25	; 0x03
   125ca:	82 83       	std	Z+2, r24	; 0x02
   125cc:	f5 82       	std	Z+5, r15	; 0x05
   125ce:	e4 82       	std	Z+4, r14	; 0x04
   125d0:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   125d4:	ed b7       	in	r30, 0x3d	; 61
   125d6:	fe b7       	in	r31, 0x3e	; 62
   125d8:	36 96       	adiw	r30, 0x06	; 6
   125da:	0f b6       	in	r0, 0x3f	; 63
   125dc:	f8 94       	cli
   125de:	fe bf       	out	0x3e, r31	; 62
   125e0:	0f be       	out	0x3f, r0	; 63
   125e2:	ed bf       	out	0x3d, r30	; 61
   125e4:	81 e0       	ldi	r24, 0x01	; 1
   125e6:	61 e0       	ldi	r22, 0x01	; 1
   125e8:	a8 01       	movw	r20, r16
   125ea:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_printf(2,1,PSTR("Surcharge:   _%"));
   125ee:	82 e0       	ldi	r24, 0x02	; 2
   125f0:	61 e0       	ldi	r22, 0x01	; 1
   125f2:	49 e7       	ldi	r20, 0x79	; 121
   125f4:	58 e1       	ldi	r21, 0x18	; 24
   125f6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   125fa:	84 e0       	ldi	r24, 0x04	; 4
   125fc:	61 e0       	ldi	r22, 0x01	; 1
   125fe:	44 e6       	ldi	r20, 0x64	; 100
   12600:	58 e1       	ldi	r21, 0x18	; 24
   12602:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
          stChangeMOP=cmInputBankSurcharge;
   12606:	8d e0       	ldi	r24, 0x0D	; 13
   12608:	39 c0       	rjmp	.+114    	; 0x1267c <FMenuChangeMOP+0x3ee>
	      break;
	 case cmInputBankSurcharge:
	      uiResult=UserInput(UI_NUMBER_L,2,14,ValueChar,100,3);
   1260a:	82 e0       	ldi	r24, 0x02	; 2
   1260c:	62 e0       	ldi	r22, 0x02	; 2
   1260e:	4e e0       	ldi	r20, 0x0E	; 14
   12610:	22 e5       	ldi	r18, 0x52	; 82
   12612:	33 e0       	ldi	r19, 0x03	; 3
   12614:	04 e6       	ldi	r16, 0x64	; 100
   12616:	10 e0       	ldi	r17, 0x00	; 0
   12618:	73 e0       	ldi	r23, 0x03	; 3
   1261a:	e7 2e       	mov	r14, r23
   1261c:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
   12620:	80 93 4e 03 	sts	0x034E, r24
	      if (uiResult==USER_OK)stChangeMOP=cmGenerateData;
   12624:	83 30       	cpi	r24, 0x03	; 3
   12626:	09 f4       	brne	.+2      	; 0x1262a <FMenuChangeMOP+0x39c>
   12628:	cb c0       	rjmp	.+406    	; 0x127c0 <FMenuChangeMOP+0x532>
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmSelectBankName;
   1262a:	81 30       	cpi	r24, 0x01	; 1
   1262c:	11 f4       	brne	.+4      	; 0x12632 <FMenuChangeMOP+0x3a4>
   1262e:	8b e0       	ldi	r24, 0x0B	; 11
   12630:	25 c0       	rjmp	.+74     	; 0x1267c <FMenuChangeMOP+0x3ee>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12632:	84 30       	cpi	r24, 0x04	; 4
   12634:	21 f4       	brne	.+8      	; 0x1263e <FMenuChangeMOP+0x3b0>
   12636:	61 e0       	ldi	r22, 0x01	; 1
   12638:	4f e4       	ldi	r20, 0x4F	; 79
   1263a:	58 e1       	ldi	r21, 0x18	; 24
   1263c:	07 c0       	rjmp	.+14     	; 0x1264c <FMenuChangeMOP+0x3be>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1263e:	85 30       	cpi	r24, 0x05	; 5
   12640:	09 f0       	breq	.+2      	; 0x12644 <FMenuChangeMOP+0x3b6>
   12642:	4a c2       	rjmp	.+1172   	; 0x12ad8 <FMenuChangeMOP+0x84a>
   12644:	84 e0       	ldi	r24, 0x04	; 4
   12646:	61 e0       	ldi	r22, 0x01	; 1
   12648:	4a e3       	ldi	r20, 0x3A	; 58
   1264a:	58 e1       	ldi	r21, 0x18	; 24
   1264c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
   12650:	43 c2       	rjmp	.+1158   	; 0x12ad8 <FMenuChangeMOP+0x84a>
	      break;
     case cmFlowFIP:
          switch(MOPType){
   12652:	80 91 e4 01 	lds	r24, 0x01E4
   12656:	82 30       	cpi	r24, 0x02	; 2
   12658:	61 f0       	breq	.+24     	; 0x12672 <FMenuChangeMOP+0x3e4>
   1265a:	83 30       	cpi	r24, 0x03	; 3
   1265c:	20 f4       	brcc	.+8      	; 0x12666 <FMenuChangeMOP+0x3d8>
   1265e:	81 30       	cpi	r24, 0x01	; 1
   12660:	09 f0       	breq	.+2      	; 0x12664 <FMenuChangeMOP+0x3d6>
   12662:	3a c2       	rjmp	.+1140   	; 0x12ad8 <FMenuChangeMOP+0x84a>
   12664:	0a c0       	rjmp	.+20     	; 0x1267a <FMenuChangeMOP+0x3ec>
   12666:	83 30       	cpi	r24, 0x03	; 3
   12668:	31 f0       	breq	.+12     	; 0x12676 <FMenuChangeMOP+0x3e8>
   1266a:	84 30       	cpi	r24, 0x04	; 4
   1266c:	09 f0       	breq	.+2      	; 0x12670 <FMenuChangeMOP+0x3e2>
   1266e:	34 c2       	rjmp	.+1128   	; 0x12ad8 <FMenuChangeMOP+0x84a>
   12670:	04 c0       	rjmp	.+8      	; 0x1267a <FMenuChangeMOP+0x3ec>
		  case PAY_ACCOUNT: stChangeMOP=cmDispCardTap;       break;
		  case PAY_BANK:    stChangeMOP=cmDispBankSurcharge; break;
   12672:	81 e1       	ldi	r24, 0x11	; 17
   12674:	03 c0       	rjmp	.+6      	; 0x1267c <FMenuChangeMOP+0x3ee>
		  case PAY_VOUCHER: stChangeMOP=cmProsesVoucher;      break;
   12676:	85 e1       	ldi	r24, 0x15	; 21
   12678:	01 c0       	rjmp	.+2      	; 0x1267c <FMenuChangeMOP+0x3ee>
		  case PAY_PUMPTEST:stChangeMOP=cmDispCardTap;       break;
   1267a:	82 e1       	ldi	r24, 0x12	; 18
   1267c:	80 93 62 03 	sts	0x0362, r24
   12680:	2b c2       	rjmp	.+1110   	; 0x12ad8 <FMenuChangeMOP+0x84a>
		  }
	      break;
     case cmDispCardTap:
	      lcd_clear();
   12682:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
	      lcd_printf(1,1,PSTR("Tap Kartu RFID"));
   12686:	81 e0       	ldi	r24, 0x01	; 1
   12688:	61 e0       	ldi	r22, 0x01	; 1
   1268a:	4b e2       	ldi	r20, 0x2B	; 43
   1268c:	58 e1       	ldi	r21, 0x18	; 24
   1268e:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  sprintf_P(lcdteks,PSTR("FIP%s"),strFIP_ID);
   12692:	00 d0       	rcall	.+0      	; 0x12694 <FMenuChangeMOP+0x406>
   12694:	00 d0       	rcall	.+0      	; 0x12696 <FMenuChangeMOP+0x408>
   12696:	00 d0       	rcall	.+0      	; 0x12698 <FMenuChangeMOP+0x40a>
   12698:	ed b7       	in	r30, 0x3d	; 61
   1269a:	fe b7       	in	r31, 0x3e	; 62
   1269c:	31 96       	adiw	r30, 0x01	; 1
   1269e:	8e 01       	movw	r16, r28
   126a0:	00 5f       	subi	r16, 0xF0	; 240
   126a2:	1f 4f       	sbci	r17, 0xFF	; 255
   126a4:	ad b7       	in	r26, 0x3d	; 61
   126a6:	be b7       	in	r27, 0x3e	; 62
   126a8:	12 96       	adiw	r26, 0x02	; 2
   126aa:	1c 93       	st	X, r17
   126ac:	0e 93       	st	-X, r16
   126ae:	11 97       	sbiw	r26, 0x01	; 1
   126b0:	85 e2       	ldi	r24, 0x25	; 37
   126b2:	98 e1       	ldi	r25, 0x18	; 24
   126b4:	93 83       	std	Z+3, r25	; 0x03
   126b6:	82 83       	std	Z+2, r24	; 0x02
   126b8:	88 ec       	ldi	r24, 0xC8	; 200
   126ba:	99 e0       	ldi	r25, 0x09	; 9
   126bc:	95 83       	std	Z+5, r25	; 0x05
   126be:	84 83       	std	Z+4, r24	; 0x04
   126c0:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   126c4:	ed b7       	in	r30, 0x3d	; 61
   126c6:	fe b7       	in	r31, 0x3e	; 62
   126c8:	36 96       	adiw	r30, 0x06	; 6
   126ca:	0f b6       	in	r0, 0x3f	; 63
   126cc:	f8 94       	cli
   126ce:	fe bf       	out	0x3e, r31	; 62
   126d0:	0f be       	out	0x3f, r0	; 63
   126d2:	ed bf       	out	0x3d, r30	; 61
   126d4:	82 e0       	ldi	r24, 0x02	; 2
   126d6:	61 e0       	ldi	r22, 0x01	; 1
   126d8:	a8 01       	movw	r20, r16
   126da:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
   126de:	84 e0       	ldi	r24, 0x04	; 4
   126e0:	61 e0       	ldi	r22, 0x01	; 1
   126e2:	42 e1       	ldi	r20, 0x12	; 18
   126e4:	58 e1       	ldi	r21, 0x18	; 24
   126e6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  IsRFIDDetected=False;
   126ea:	10 92 c4 01 	sts	0x01C4, r1
          stChangeMOP=cmRFIDCardInput;
   126ee:	83 e1       	ldi	r24, 0x13	; 19
   126f0:	c5 cf       	rjmp	.-118    	; 0x1267c <FMenuChangeMOP+0x3ee>
	      break;
	 case cmRFIDCardInput:
		  KeyPressed=_key_scan(1);
   126f2:	81 e0       	ldi	r24, 0x01	; 1
   126f4:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   126f8:	80 93 5d 03 	sts	0x035D, r24
		  KeyChar=_key_btn(KeyPressed);
   126fc:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   12700:	80 93 5e 03 	sts	0x035E, r24
		  if (KeyPressed==_KEY_ENTER){
   12704:	80 91 5d 03 	lds	r24, 0x035D
   12708:	87 3b       	cpi	r24, 0xB7	; 183
   1270a:	11 f4       	brne	.+4      	; 0x12710 <FMenuChangeMOP+0x482>
		      stChangeMOP=cmExitChangeMOP;
   1270c:	8c e1       	ldi	r24, 0x1C	; 28
   1270e:	03 c0       	rjmp	.+6      	; 0x12716 <FMenuChangeMOP+0x488>
		  }
		  else
		  if (KeyPressed==_KEY_CANCEL){
   12710:	87 3e       	cpi	r24, 0xE7	; 231
   12712:	19 f4       	brne	.+6      	; 0x1271a <FMenuChangeMOP+0x48c>
   		      stChangeMOP=cmSelectFIP;
   12714:	89 e0       	ldi	r24, 0x09	; 9
   12716:	80 93 62 03 	sts	0x0362, r24
			 }
          if (IsRFIDDetected==True){
   1271a:	80 91 c4 01 	lds	r24, 0x01C4
   1271e:	81 30       	cpi	r24, 0x01	; 1
   12720:	09 f0       	breq	.+2      	; 0x12724 <FMenuChangeMOP+0x496>
   12722:	da c1       	rjmp	.+948    	; 0x12ad8 <FMenuChangeMOP+0x84a>
		      IsRFIDDetected=False;
   12724:	10 92 c4 01 	sts	0x01C4, r1
			   stChangeMOP=cmProsesRFID;
   12728:	84 e1       	ldi	r24, 0x14	; 20
   1272a:	a8 cf       	rjmp	.-176    	; 0x1267c <FMenuChangeMOP+0x3ee>
   1272c:	20 e0       	ldi	r18, 0x00	; 0
   1272e:	30 e0       	ldi	r19, 0x00	; 0
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   12730:	f9 01       	movw	r30, r18
   12732:	ef 56       	subi	r30, 0x6F	; 111
   12734:	f2 4f       	sbci	r31, 0xF2	; 242
   12736:	d9 01       	movw	r26, r18
   12738:	a4 5a       	subi	r26, 0xA4	; 164
   1273a:	b1 4f       	sbci	r27, 0xF1	; 241
   1273c:	8c 91       	ld	r24, X
   1273e:	80 83       	st	Z, r24
   12740:	2f 5f       	subi	r18, 0xFF	; 255
   12742:	3f 4f       	sbci	r19, 0xFF	; 255
	 }strCardID[20]=0;     
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   12744:	28 30       	cpi	r18, 0x08	; 8
   12746:	31 05       	cpc	r19, r1
   12748:	99 f7       	brne	.-26     	; 0x12730 <FMenuChangeMOP+0x4a2>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   1274a:	10 92 99 0d 	sts	0x0D99, r1
			   stChangeMOP=cmProsesRFID;
			 }
	      break;
     case cmProsesRFID:
	      ViewCardID();
          sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   1274e:	00 d0       	rcall	.+0      	; 0x12750 <FMenuChangeMOP+0x4c2>
   12750:	00 d0       	rcall	.+0      	; 0x12752 <FMenuChangeMOP+0x4c4>
   12752:	00 d0       	rcall	.+0      	; 0x12754 <FMenuChangeMOP+0x4c6>
   12754:	ed b7       	in	r30, 0x3d	; 61
   12756:	fe b7       	in	r31, 0x3e	; 62
   12758:	31 96       	adiw	r30, 0x01	; 1
   1275a:	8e 01       	movw	r16, r28
   1275c:	00 5f       	subi	r16, 0xF0	; 240
   1275e:	1f 4f       	sbci	r17, 0xFF	; 255
   12760:	ad b7       	in	r26, 0x3d	; 61
   12762:	be b7       	in	r27, 0x3e	; 62
   12764:	12 96       	adiw	r26, 0x02	; 2
   12766:	1c 93       	st	X, r17
   12768:	0e 93       	st	-X, r16
   1276a:	11 97       	sbiw	r26, 0x01	; 1
   1276c:	8c e0       	ldi	r24, 0x0C	; 12
   1276e:	98 e1       	ldi	r25, 0x18	; 24
   12770:	93 83       	std	Z+3, r25	; 0x03
   12772:	82 83       	std	Z+2, r24	; 0x02
   12774:	81 e9       	ldi	r24, 0x91	; 145
   12776:	9d e0       	ldi	r25, 0x0D	; 13
   12778:	95 83       	std	Z+5, r25	; 0x05
   1277a:	84 83       	std	Z+4, r24	; 0x04
   1277c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   12780:	ed b7       	in	r30, 0x3d	; 61
   12782:	fe b7       	in	r31, 0x3e	; 62
   12784:	36 96       	adiw	r30, 0x06	; 6
   12786:	0f b6       	in	r0, 0x3f	; 63
   12788:	f8 94       	cli
   1278a:	fe bf       	out	0x3e, r31	; 62
   1278c:	0f be       	out	0x3f, r0	; 63
   1278e:	ed bf       	out	0x3d, r30	; 61
   12790:	82 e0       	ldi	r24, 0x02	; 2
   12792:	61 e0       	ldi	r22, 0x01	; 1
   12794:	a8 01       	movw	r20, r16
   12796:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
          lcd_printf(3,1,PSTR("Proses"));
   1279a:	83 e0       	ldi	r24, 0x03	; 3
   1279c:	61 e0       	ldi	r22, 0x01	; 1
   1279e:	45 e0       	ldi	r20, 0x05	; 5
   127a0:	58 e1       	ldi	r21, 0x18	; 24
   127a2:	0c c0       	rjmp	.+24     	; 0x127bc <FMenuChangeMOP+0x52e>
		  stChangeMOP=cmGenerateData;
	      break;
     case cmProsesVoucher:
          lcd_clear();
   127a4:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
          lcd_printf(1,1,PSTR("-MOP Voucher-")); 
   127a8:	81 e0       	ldi	r24, 0x01	; 1
   127aa:	61 e0       	ldi	r22, 0x01	; 1
   127ac:	47 ef       	ldi	r20, 0xF7	; 247
   127ae:	57 e1       	ldi	r21, 0x17	; 23
   127b0:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
          lcd_printf(3,1,PSTR("Proses"));
   127b4:	83 e0       	ldi	r24, 0x03	; 3
   127b6:	61 e0       	ldi	r22, 0x01	; 1
   127b8:	40 ef       	ldi	r20, 0xF0	; 240
   127ba:	57 e1       	ldi	r21, 0x17	; 23
   127bc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  stChangeMOP=cmGenerateData;
   127c0:	86 e1       	ldi	r24, 0x16	; 22
   127c2:	5c cf       	rjmp	.-328    	; 0x1267c <FMenuChangeMOP+0x3ee>
	      break;
   127c4:	e9 e9       	ldi	r30, 0x99	; 153
   127c6:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   127c8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   127ca:	8e e0       	ldi	r24, 0x0E	; 14
   127cc:	ee 3a       	cpi	r30, 0xAE	; 174
   127ce:	f8 07       	cpc	r31, r24
   127d0:	d9 f7       	brne	.-10     	; 0x127c8 <FMenuChangeMOP+0x53a>
   127d2:	e6 ea       	ldi	r30, 0xA6	; 166
   127d4:	fd e0       	ldi	r31, 0x0D	; 13
	     strMemory[i]=data;
   127d6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   127d8:	9d e0       	ldi	r25, 0x0D	; 13
   127da:	eb 3b       	cpi	r30, 0xBB	; 187
   127dc:	f9 07       	cpc	r31, r25
   127de:	d9 f7       	brne	.-10     	; 0x127d6 <FMenuChangeMOP+0x548>
   127e0:	e2 eb       	ldi	r30, 0xB2	; 178
   127e2:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
   127e4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   127e6:	aa e0       	ldi	r26, 0x0A	; 10
   127e8:	e7 3c       	cpi	r30, 0xC7	; 199
   127ea:	fa 07       	cpc	r31, r26
   127ec:	d9 f7       	brne	.-10     	; 0x127e4 <FMenuChangeMOP+0x556>
   127ee:	6b ea       	ldi	r22, 0xAB	; 171
   127f0:	e6 2e       	mov	r14, r22
   127f2:	65 e0       	ldi	r22, 0x05	; 5
   127f4:	f6 2e       	mov	r15, r22
	     strMemory[i]=data;
   127f6:	f7 01       	movw	r30, r14
   127f8:	11 92       	st	Z+, r1
   127fa:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   127fc:	f0 ec       	ldi	r31, 0xC0	; 192
   127fe:	ef 16       	cp	r14, r31
   12800:	f5 e0       	ldi	r31, 0x05	; 5
   12802:	ff 06       	cpc	r15, r31
   12804:	c1 f7       	brne	.-16     	; 0x127f6 <FMenuChangeMOP+0x568>
     case cmGenerateData:
	      FillChar(strRef1,sizeof(strRef1),0);
	      FillChar(strRef2,sizeof(strRef2),0);
	      FillChar(strRef3,sizeof(strRef3),0);
	      FillChar(strRef4,sizeof(strRef4),0);
          switch(MOPType){
   12806:	80 91 e4 01 	lds	r24, 0x01E4
   1280a:	82 30       	cpi	r24, 0x02	; 2
   1280c:	f1 f0       	breq	.+60     	; 0x1284a <FMenuChangeMOP+0x5bc>
   1280e:	83 30       	cpi	r24, 0x03	; 3
   12810:	20 f4       	brcc	.+8      	; 0x1281a <FMenuChangeMOP+0x58c>
   12812:	81 30       	cpi	r24, 0x01	; 1
   12814:	09 f0       	breq	.+2      	; 0x12818 <FMenuChangeMOP+0x58a>
   12816:	ad c0       	rjmp	.+346    	; 0x12972 <FMenuChangeMOP+0x6e4>
   12818:	07 c0       	rjmp	.+14     	; 0x12828 <FMenuChangeMOP+0x59a>
   1281a:	83 30       	cpi	r24, 0x03	; 3
   1281c:	09 f4       	brne	.+2      	; 0x12820 <FMenuChangeMOP+0x592>
   1281e:	64 c0       	rjmp	.+200    	; 0x128e8 <FMenuChangeMOP+0x65a>
   12820:	84 30       	cpi	r24, 0x04	; 4
   12822:	09 f0       	breq	.+2      	; 0x12826 <FMenuChangeMOP+0x598>
   12824:	a6 c0       	rjmp	.+332    	; 0x12972 <FMenuChangeMOP+0x6e4>
   12826:	75 c0       	rjmp	.+234    	; 0x12912 <FMenuChangeMOP+0x684>
		  case PAY_ACCOUNT:
		       sprintf_P(strRef1,PSTR("%s"),strCardID); 
   12828:	00 d0       	rcall	.+0      	; 0x1282a <FMenuChangeMOP+0x59c>
   1282a:	00 d0       	rcall	.+0      	; 0x1282c <FMenuChangeMOP+0x59e>
   1282c:	00 d0       	rcall	.+0      	; 0x1282e <FMenuChangeMOP+0x5a0>
   1282e:	ed b7       	in	r30, 0x3d	; 61
   12830:	fe b7       	in	r31, 0x3e	; 62
   12832:	31 96       	adiw	r30, 0x01	; 1
   12834:	89 e9       	ldi	r24, 0x99	; 153
   12836:	9e e0       	ldi	r25, 0x0E	; 14
   12838:	ad b7       	in	r26, 0x3d	; 61
   1283a:	be b7       	in	r27, 0x3e	; 62
   1283c:	12 96       	adiw	r26, 0x02	; 2
   1283e:	9c 93       	st	X, r25
   12840:	8e 93       	st	-X, r24
   12842:	11 97       	sbiw	r26, 0x01	; 1
   12844:	8d ee       	ldi	r24, 0xED	; 237
   12846:	97 e1       	ldi	r25, 0x17	; 23
   12848:	84 c0       	rjmp	.+264    	; 0x12952 <FMenuChangeMOP+0x6c4>
   1284a:	8e 01       	movw	r16, r28
   1284c:	0b 5f       	subi	r16, 0xFB	; 251
   1284e:	1f 4f       	sbci	r17, 0xFF	; 255
   12850:	60 91 4f 03 	lds	r22, 0x034F
   12854:	8b e0       	ldi	r24, 0x0B	; 11
   12856:	68 9f       	mul	r22, r24
   12858:	b0 01       	movw	r22, r0
   1285a:	11 24       	eor	r1, r1
   1285c:	67 5c       	subi	r22, 0xC7	; 199
   1285e:	7e 4f       	sbci	r23, 0xFE	; 254
   12860:	c8 01       	movw	r24, r16
   12862:	4b e0       	ldi	r20, 0x0B	; 11
   12864:	50 e0       	ldi	r21, 0x00	; 0
   12866:	2c ea       	ldi	r18, 0xAC	; 172
   12868:	32 e1       	ldi	r19, 0x12	; 18
   1286a:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
		       break;
		  case PAY_BANK:
		  	   eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		       sprintf_P(lcdteks,PSTR("%s"),strBankName);
   1286e:	00 d0       	rcall	.+0      	; 0x12870 <FMenuChangeMOP+0x5e2>
   12870:	00 d0       	rcall	.+0      	; 0x12872 <FMenuChangeMOP+0x5e4>
   12872:	00 d0       	rcall	.+0      	; 0x12874 <FMenuChangeMOP+0x5e6>
   12874:	ed b7       	in	r30, 0x3d	; 61
   12876:	fe b7       	in	r31, 0x3e	; 62
   12878:	31 96       	adiw	r30, 0x01	; 1
   1287a:	ce 01       	movw	r24, r28
   1287c:	40 96       	adiw	r24, 0x10	; 16
   1287e:	ad b7       	in	r26, 0x3d	; 61
   12880:	be b7       	in	r27, 0x3e	; 62
   12882:	12 96       	adiw	r26, 0x02	; 2
   12884:	9c 93       	st	X, r25
   12886:	8e 93       	st	-X, r24
   12888:	11 97       	sbiw	r26, 0x01	; 1
   1288a:	8a ee       	ldi	r24, 0xEA	; 234
   1288c:	97 e1       	ldi	r25, 0x17	; 23
   1288e:	93 83       	std	Z+3, r25	; 0x03
   12890:	82 83       	std	Z+2, r24	; 0x02
   12892:	15 83       	std	Z+5, r17	; 0x05
   12894:	04 83       	std	Z+4, r16	; 0x04
   12896:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		       sprintf_P(strRef1,PSTR("%s"),strBankName); 
   1289a:	ed b7       	in	r30, 0x3d	; 61
   1289c:	fe b7       	in	r31, 0x3e	; 62
   1289e:	31 96       	adiw	r30, 0x01	; 1
   128a0:	89 e9       	ldi	r24, 0x99	; 153
   128a2:	9e e0       	ldi	r25, 0x0E	; 14
   128a4:	ad b7       	in	r26, 0x3d	; 61
   128a6:	be b7       	in	r27, 0x3e	; 62
   128a8:	12 96       	adiw	r26, 0x02	; 2
   128aa:	9c 93       	st	X, r25
   128ac:	8e 93       	st	-X, r24
   128ae:	11 97       	sbiw	r26, 0x01	; 1
   128b0:	87 ee       	ldi	r24, 0xE7	; 231
   128b2:	97 e1       	ldi	r25, 0x17	; 23
   128b4:	93 83       	std	Z+3, r25	; 0x03
   128b6:	82 83       	std	Z+2, r24	; 0x02
   128b8:	15 83       	std	Z+5, r17	; 0x05
   128ba:	04 83       	std	Z+4, r16	; 0x04
   128bc:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		       sprintf_P(strRef4,PSTR("%s"),strSurcharge); 
   128c0:	ed b7       	in	r30, 0x3d	; 61
   128c2:	fe b7       	in	r31, 0x3e	; 62
   128c4:	31 96       	adiw	r30, 0x01	; 1
   128c6:	8b ee       	ldi	r24, 0xEB	; 235
   128c8:	9f ef       	ldi	r25, 0xFF	; 255
   128ca:	e8 0e       	add	r14, r24
   128cc:	f9 1e       	adc	r15, r25
   128ce:	ad b7       	in	r26, 0x3d	; 61
   128d0:	be b7       	in	r27, 0x3e	; 62
   128d2:	12 96       	adiw	r26, 0x02	; 2
   128d4:	fc 92       	st	X, r15
   128d6:	ee 92       	st	-X, r14
   128d8:	11 97       	sbiw	r26, 0x01	; 1
   128da:	84 ee       	ldi	r24, 0xE4	; 228
   128dc:	97 e1       	ldi	r25, 0x17	; 23
   128de:	93 83       	std	Z+3, r25	; 0x03
   128e0:	82 83       	std	Z+2, r24	; 0x02
   128e2:	ce 01       	movw	r24, r28
   128e4:	01 96       	adiw	r24, 0x01	; 1
   128e6:	39 c0       	rjmp	.+114    	; 0x1295a <FMenuChangeMOP+0x6cc>
		       break;
		  case PAY_VOUCHER://Load data Ref1=Voucher on cmVoucherInput
		  	   sprintf_P(strRef1,PSTR("%s"),strVoucherNum); 
   128e8:	00 d0       	rcall	.+0      	; 0x128ea <FMenuChangeMOP+0x65c>
   128ea:	00 d0       	rcall	.+0      	; 0x128ec <FMenuChangeMOP+0x65e>
   128ec:	00 d0       	rcall	.+0      	; 0x128ee <FMenuChangeMOP+0x660>
   128ee:	ed b7       	in	r30, 0x3d	; 61
   128f0:	fe b7       	in	r31, 0x3e	; 62
   128f2:	31 96       	adiw	r30, 0x01	; 1
   128f4:	89 e9       	ldi	r24, 0x99	; 153
   128f6:	9e e0       	ldi	r25, 0x0E	; 14
   128f8:	ad b7       	in	r26, 0x3d	; 61
   128fa:	be b7       	in	r27, 0x3e	; 62
   128fc:	12 96       	adiw	r26, 0x02	; 2
   128fe:	9c 93       	st	X, r25
   12900:	8e 93       	st	-X, r24
   12902:	11 97       	sbiw	r26, 0x01	; 1
   12904:	81 ee       	ldi	r24, 0xE1	; 225
   12906:	97 e1       	ldi	r25, 0x17	; 23
   12908:	93 83       	std	Z+3, r25	; 0x03
   1290a:	82 83       	std	Z+2, r24	; 0x02
   1290c:	87 e4       	ldi	r24, 0x47	; 71
   1290e:	9e e0       	ldi	r25, 0x0E	; 14
   12910:	24 c0       	rjmp	.+72     	; 0x1295a <FMenuChangeMOP+0x6cc>
		       break;
		  case PAY_PUMPTEST:
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
   12912:	00 d0       	rcall	.+0      	; 0x12914 <FMenuChangeMOP+0x686>
   12914:	00 d0       	rcall	.+0      	; 0x12916 <FMenuChangeMOP+0x688>
   12916:	89 e9       	ldi	r24, 0x99	; 153
   12918:	9e e0       	ldi	r25, 0x0E	; 14
   1291a:	ad b7       	in	r26, 0x3d	; 61
   1291c:	be b7       	in	r27, 0x3e	; 62
   1291e:	12 96       	adiw	r26, 0x02	; 2
   12920:	9c 93       	st	X, r25
   12922:	8e 93       	st	-X, r24
   12924:	11 97       	sbiw	r26, 0x01	; 1
   12926:	87 ed       	ldi	r24, 0xD7	; 215
   12928:	97 e1       	ldi	r25, 0x17	; 23
   1292a:	14 96       	adiw	r26, 0x04	; 4
   1292c:	9c 93       	st	X, r25
   1292e:	8e 93       	st	-X, r24
   12930:	13 97       	sbiw	r26, 0x03	; 3
   12932:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
   12936:	00 d0       	rcall	.+0      	; 0x12938 <FMenuChangeMOP+0x6aa>
   12938:	ed b7       	in	r30, 0x3d	; 61
   1293a:	fe b7       	in	r31, 0x3e	; 62
   1293c:	31 96       	adiw	r30, 0x01	; 1
   1293e:	86 ea       	ldi	r24, 0xA6	; 166
   12940:	9d e0       	ldi	r25, 0x0D	; 13
   12942:	ad b7       	in	r26, 0x3d	; 61
   12944:	be b7       	in	r27, 0x3e	; 62
   12946:	12 96       	adiw	r26, 0x02	; 2
   12948:	9c 93       	st	X, r25
   1294a:	8e 93       	st	-X, r24
   1294c:	11 97       	sbiw	r26, 0x01	; 1
   1294e:	84 ed       	ldi	r24, 0xD4	; 212
   12950:	97 e1       	ldi	r25, 0x17	; 23
   12952:	93 83       	std	Z+3, r25	; 0x03
   12954:	82 83       	std	Z+2, r24	; 0x02
   12956:	81 e9       	ldi	r24, 0x91	; 145
   12958:	9d e0       	ldi	r25, 0x0D	; 13
   1295a:	95 83       	std	Z+5, r25	; 0x05
   1295c:	84 83       	std	Z+4, r24	; 0x04
   1295e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   12962:	ed b7       	in	r30, 0x3d	; 61
   12964:	fe b7       	in	r31, 0x3e	; 62
   12966:	36 96       	adiw	r30, 0x06	; 6
   12968:	0f b6       	in	r0, 0x3f	; 63
   1296a:	f8 94       	cli
   1296c:	fe bf       	out	0x3e, r31	; 62
   1296e:	0f be       	out	0x3f, r0	; 63
   12970:	ed bf       	out	0x3d, r30	; 61
		       break;
		  }
		  leadingZero(MOPType,strPaymentType);
   12972:	80 91 e4 01 	lds	r24, 0x01E4
   12976:	90 e0       	ldi	r25, 0x00	; 0
   12978:	6f e5       	ldi	r22, 0x5F	; 95
   1297a:	79 e0       	ldi	r23, 0x09	; 9
   1297c:	0e 94 80 1a 	call	0x3500	; 0x3500 <leadingZero>
		  AddSpaceLead(strRef1,20);
   12980:	89 e9       	ldi	r24, 0x99	; 153
   12982:	9e e0       	ldi	r25, 0x0E	; 14
   12984:	64 e1       	ldi	r22, 0x14	; 20
   12986:	0e 94 ae 29 	call	0x535c	; 0x535c <AddSpaceLead>
		  AddSpaceLead(strRef2,20);
   1298a:	86 ea       	ldi	r24, 0xA6	; 166
   1298c:	9d e0       	ldi	r25, 0x0D	; 13
   1298e:	64 e1       	ldi	r22, 0x14	; 20
   12990:	0e 94 ae 29 	call	0x535c	; 0x535c <AddSpaceLead>
		  AddSpaceLead(strRef3,20);
   12994:	82 eb       	ldi	r24, 0xB2	; 178
   12996:	9a e0       	ldi	r25, 0x0A	; 10
   12998:	64 e1       	ldi	r22, 0x14	; 20
   1299a:	0e 94 ae 29 	call	0x535c	; 0x535c <AddSpaceLead>
		  AddSpaceLead(strRef4,20);
   1299e:	8b ea       	ldi	r24, 0xAB	; 171
   129a0:	95 e0       	ldi	r25, 0x05	; 5
   129a2:	64 e1       	ldi	r22, 0x14	; 20
   129a4:	0e 94 ae 29 	call	0x535c	; 0x535c <AddSpaceLead>
		  iWait=0;
   129a8:	10 92 5f 03 	sts	0x035F, r1
		  IsMessage09=False;
   129ac:	10 92 d0 01 	sts	0x01D0, r1
		  stChangeMOP=cmSendMessage32;	      
   129b0:	87 e1       	ldi	r24, 0x17	; 23
   129b2:	64 ce       	rjmp	.-824    	; 0x1267c <FMenuChangeMOP+0x3ee>
	      break;
     case cmSendMessage32://SendMessage32
	      sendMessage32();
   129b4:	0e 94 4d 4f 	call	0x9e9a	; 0x9e9a <sendMessage32>
		  iLoop=0;
   129b8:	10 92 51 03 	sts	0x0351, r1
   129bc:	10 92 50 03 	sts	0x0350, r1
		  iPos=0;
   129c0:	10 92 60 03 	sts	0x0360, r1
		  lcd_printf(3,1,PSTR("Please Wait"));
   129c4:	83 e0       	ldi	r24, 0x03	; 3
   129c6:	61 e0       	ldi	r22, 0x01	; 1
   129c8:	48 ec       	ldi	r20, 0xC8	; 200
   129ca:	57 e1       	ldi	r21, 0x17	; 23
   129cc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  stChangeMOP=cmWaitReplyMessage;	      
   129d0:	88 e1       	ldi	r24, 0x18	; 24
   129d2:	54 ce       	rjmp	.-856    	; 0x1267c <FMenuChangeMOP+0x3ee>
	      break;
     case cmWaitReplyMessage:
          iLoop++;
   129d4:	80 91 50 03 	lds	r24, 0x0350
   129d8:	90 91 51 03 	lds	r25, 0x0351
   129dc:	01 96       	adiw	r24, 0x01	; 1
   129de:	90 93 51 03 	sts	0x0351, r25
   129e2:	80 93 50 03 	sts	0x0350, r24
		  if ((iLoop%MSG_WAIT_TIMOUT)==0){
   129e6:	68 e9       	ldi	r22, 0x98	; 152
   129e8:	7a e3       	ldi	r23, 0x3A	; 58
   129ea:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
   129ee:	89 2b       	or	r24, r25
   129f0:	19 f5       	brne	.+70     	; 0x12a38 <FMenuChangeMOP+0x7aa>
			 if (iPos<5){
   129f2:	60 91 60 03 	lds	r22, 0x0360
   129f6:	65 30       	cpi	r22, 0x05	; 5
   129f8:	68 f4       	brcc	.+26     	; 0x12a14 <FMenuChangeMOP+0x786>
				 lcd_xy(3,(13+iPos));_lcd('.');
   129fa:	63 5f       	subi	r22, 0xF3	; 243
   129fc:	83 e0       	ldi	r24, 0x03	; 3
   129fe:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
   12a02:	8e e2       	ldi	r24, 0x2E	; 46
   12a04:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
				 iPos++;
   12a08:	80 91 60 03 	lds	r24, 0x0360
   12a0c:	8f 5f       	subi	r24, 0xFF	; 255
   12a0e:	80 93 60 03 	sts	0x0360, r24
   12a12:	12 c0       	rjmp	.+36     	; 0x12a38 <FMenuChangeMOP+0x7aa>
				}
			 else{
				 iPos=0;
   12a14:	10 92 60 03 	sts	0x0360, r1
				 lcd_printf(3,(13+iPos),PSTR("       "));
   12a18:	83 e0       	ldi	r24, 0x03	; 3
   12a1a:	6d e0       	ldi	r22, 0x0D	; 13
   12a1c:	40 ec       	ldi	r20, 0xC0	; 192
   12a1e:	57 e1       	ldi	r21, 0x17	; 23
   12a20:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				 //Resend Message32
				 if (iWait<5)stChangeMOP=cmSendMessage32;
   12a24:	90 91 5f 03 	lds	r25, 0x035F
   12a28:	95 30       	cpi	r25, 0x05	; 5
   12a2a:	18 f4       	brcc	.+6      	; 0x12a32 <FMenuChangeMOP+0x7a4>
   12a2c:	87 e1       	ldi	r24, 0x17	; 23
   12a2e:	80 93 62 03 	sts	0x0362, r24
				iWait++;
   12a32:	9f 5f       	subi	r25, 0xFF	; 255
   12a34:	90 93 5f 03 	sts	0x035F, r25
				}
		  }
		  if (iWait>5)stChangeMOP=cmNoReply;
   12a38:	80 91 5f 03 	lds	r24, 0x035F
   12a3c:	86 30       	cpi	r24, 0x06	; 6
   12a3e:	18 f0       	brcs	.+6      	; 0x12a46 <FMenuChangeMOP+0x7b8>
   12a40:	8a e1       	ldi	r24, 0x1A	; 26
   12a42:	80 93 62 03 	sts	0x0362, r24
		  if (IsMessage09==True)stChangeMOP=cmDisplayFreeMessage;
   12a46:	80 91 d0 01 	lds	r24, 0x01D0
   12a4a:	81 30       	cpi	r24, 0x01	; 1
   12a4c:	19 f4       	brne	.+6      	; 0x12a54 <FMenuChangeMOP+0x7c6>
   12a4e:	89 e1       	ldi	r24, 0x19	; 25
   12a50:	80 93 62 03 	sts	0x0362, r24
		  if (IsMessage99==True)stChangeMOP=cmFinishChangeMOP;
   12a54:	80 91 cc 01 	lds	r24, 0x01CC
   12a58:	81 30       	cpi	r24, 0x01	; 1
   12a5a:	f1 f5       	brne	.+124    	; 0x12ad8 <FMenuChangeMOP+0x84a>
   12a5c:	37 c0       	rjmp	.+110    	; 0x12acc <FMenuChangeMOP+0x83e>
		  break;
     case cmDisplayFreeMessage:
	      IsMessage09=False;
   12a5e:	10 92 d0 01 	sts	0x01D0, r1
	      msgResult=procMessage09();
   12a62:	0e 94 10 16 	call	0x2c20	; 0x2c20 <procMessage09>
		  lcd_clear();
   12a66:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
   12a6a:	81 e0       	ldi	r24, 0x01	; 1
   12a6c:	61 e0       	ldi	r22, 0x01	; 1
   12a6e:	47 ec       	ldi	r20, 0xC7	; 199
   12a70:	5a e0       	ldi	r21, 0x0A	; 10
   12a72:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   12a76:	82 e0       	ldi	r24, 0x02	; 2
   12a78:	61 e0       	ldi	r22, 0x01	; 1
   12a7a:	42 eb       	ldi	r20, 0xB2	; 178
   12a7c:	59 e0       	ldi	r21, 0x09	; 9
   12a7e:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
   12a82:	83 e0       	ldi	r24, 0x03	; 3
   12a84:	61 e0       	ldi	r22, 0x01	; 1
   12a86:	4d e4       	ldi	r20, 0x4D	; 77
   12a88:	5a e0       	ldi	r21, 0x0A	; 10
   12a8a:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
   12a8e:	84 e0       	ldi	r24, 0x04	; 4
   12a90:	61 e0       	ldi	r22, 0x01	; 1
   12a92:	41 ee       	ldi	r20, 0xE1	; 225
   12a94:	5d e0       	ldi	r21, 0x0D	; 13
   12a96:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
   12a9a:	0e c0       	rjmp	.+28     	; 0x12ab8 <FMenuChangeMOP+0x82a>
		  TimDisplay=0;
          stChangeMOP=cmDelayMOP;
	      break;
     case cmNoReply:
	      lcd_clear();
   12a9c:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(2,1,PSTR("No Reply    "));
   12aa0:	82 e0       	ldi	r24, 0x02	; 2
   12aa2:	61 e0       	ldi	r22, 0x01	; 1
   12aa4:	43 eb       	ldi	r20, 0xB3	; 179
   12aa6:	57 e1       	ldi	r21, 0x17	; 23
   12aa8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	      lcd_printf(3,1,PSTR("TCP/IP Error"));
   12aac:	83 e0       	ldi	r24, 0x03	; 3
   12aae:	61 e0       	ldi	r22, 0x01	; 1
   12ab0:	46 ea       	ldi	r20, 0xA6	; 166
   12ab2:	57 e1       	ldi	r21, 0x17	; 23
   12ab4:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  TimDisplay=0;
   12ab8:	10 92 bc 01 	sts	0x01BC, r1
          stChangeMOP=cmDelayMOP;
   12abc:	8b e1       	ldi	r24, 0x1B	; 27
   12abe:	de cd       	rjmp	.-1092   	; 0x1267c <FMenuChangeMOP+0x3ee>
	      break;
     case cmDelayMOP:
	      if (TimDisplay>9)stChangeMOP=cmExitChangeMOP;
   12ac0:	80 91 bc 01 	lds	r24, 0x01BC
   12ac4:	8a 30       	cpi	r24, 0x0A	; 10
   12ac6:	40 f0       	brcs	.+16     	; 0x12ad8 <FMenuChangeMOP+0x84a>
   12ac8:	8c e1       	ldi	r24, 0x1C	; 28
   12aca:	d8 cd       	rjmp	.-1104   	; 0x1267c <FMenuChangeMOP+0x3ee>
	      break;
     case cmExitChangeMOP:
	      stChangeMOP=cmFinishChangeMOP;
   12acc:	8d e1       	ldi	r24, 0x1D	; 29
   12ace:	d6 cd       	rjmp	.-1108   	; 0x1267c <FMenuChangeMOP+0x3ee>
	      break;
     case cmFinishChangeMOP:
	      stChangeMOP=cmInit;
   12ad0:	10 92 62 03 	sts	0x0362, r1
   12ad4:	81 e0       	ldi	r24, 0x01	; 1
   12ad6:	01 c0       	rjmp	.+2      	; 0x12ada <FMenuChangeMOP+0x84c>
   12ad8:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   12ada:	a3 96       	adiw	r28, 0x23	; 35
   12adc:	0f b6       	in	r0, 0x3f	; 63
   12ade:	f8 94       	cli
   12ae0:	de bf       	out	0x3e, r29	; 62
   12ae2:	0f be       	out	0x3f, r0	; 63
   12ae4:	cd bf       	out	0x3d, r28	; 61
   12ae6:	cf 91       	pop	r28
   12ae8:	df 91       	pop	r29
   12aea:	1f 91       	pop	r17
   12aec:	0f 91       	pop	r16
   12aee:	ff 90       	pop	r15
   12af0:	ef 90       	pop	r14
   12af2:	df 90       	pop	r13
   12af4:	cf 90       	pop	r12
   12af6:	bf 90       	pop	r11
   12af8:	af 90       	pop	r10
   12afa:	08 95       	ret

00012afc <FMenuLocalAccount>:
		 }
	 else PORTG=PORTG|0x02;
}


char FMenuLocalAccount(){
   12afc:	af 92       	push	r10
   12afe:	bf 92       	push	r11
   12b00:	cf 92       	push	r12
   12b02:	df 92       	push	r13
   12b04:	ef 92       	push	r14
   12b06:	ff 92       	push	r15
   12b08:	0f 93       	push	r16
   12b0a:	1f 93       	push	r17
   12b0c:	df 93       	push	r29
   12b0e:	cf 93       	push	r28
   12b10:	cd b7       	in	r28, 0x3d	; 61
   12b12:	de b7       	in	r29, 0x3e	; 62
   12b14:	a9 97       	sbiw	r28, 0x29	; 41
   12b16:	0f b6       	in	r0, 0x3f	; 63
   12b18:	f8 94       	cli
   12b1a:	de bf       	out	0x3e, r29	; 62
   12b1c:	0f be       	out	0x3f, r0	; 63
   12b1e:	cd bf       	out	0x3d, r28	; 61
static char ProductName[11],FIP_Used=0,ProdId=0,IsFullAuthorized=False;
       char strName[21],strPumpL[3],strPumpR[3];
static unsigned int iLoop=0; 
	   Result=MENU_NONE;
	                                 //|   Local Account   |          
	       switch(stLocalAccount){   //|ID: ACD12345       |
   12b20:	80 91 71 01 	lds	r24, 0x0171
   12b24:	90 e0       	ldi	r25, 0x00	; 0
   12b26:	fc 01       	movw	r30, r24
   12b28:	31 97       	sbiw	r30, 0x01	; 1
   12b2a:	ef 31       	cpi	r30, 0x1F	; 31
   12b2c:	f1 05       	cpc	r31, r1
   12b2e:	10 f0       	brcs	.+4      	; 0x12b34 <FMenuLocalAccount+0x38>
   12b30:	0c 94 ab 9f 	jmp	0x13f56	; 0x13f56 <FMenuLocalAccount+0x145a>
   12b34:	ee 51       	subi	r30, 0x1E	; 30
   12b36:	ff 4f       	sbci	r31, 0xFF	; 255
   12b38:	ee 0f       	add	r30, r30
   12b3a:	ff 1f       	adc	r31, r31
   12b3c:	05 90       	lpm	r0, Z+
   12b3e:	f4 91       	lpm	r31, Z+
   12b40:	e0 2d       	mov	r30, r0
   12b42:	09 94       	ijmp
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
   12b44:	81 e0       	ldi	r24, 0x01	; 1
   12b46:	80 93 e2 03 	sts	0x03E2, r24
   12b4a:	10 92 e3 03 	sts	0x03E3, r1
   12b4e:	80 91 65 00 	lds	r24, 0x0065
   12b52:	8d 7f       	andi	r24, 0xFD	; 253
   12b54:	80 93 65 00 	sts	0x0065, r24
   12b58:	20 e0       	ldi	r18, 0x00	; 0
   12b5a:	30 e0       	ldi	r19, 0x00	; 0
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   12b5c:	f9 01       	movw	r30, r18
   12b5e:	ef 56       	subi	r30, 0x6F	; 111
   12b60:	f2 4f       	sbci	r31, 0xF2	; 242
   12b62:	d9 01       	movw	r26, r18
   12b64:	a4 5a       	subi	r26, 0xA4	; 164
   12b66:	b1 4f       	sbci	r27, 0xF1	; 241
   12b68:	8c 91       	ld	r24, X
   12b6a:	80 83       	st	Z, r24
   12b6c:	2f 5f       	subi	r18, 0xFF	; 255
   12b6e:	3f 4f       	sbci	r19, 0xFF	; 255
	 }strCardID[20]=0;     
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   12b70:	28 30       	cpi	r18, 0x08	; 8
   12b72:	31 05       	cpc	r19, r1
   12b74:	99 f7       	brne	.-26     	; 0x12b5c <FMenuLocalAccount+0x60>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   12b76:	10 92 99 0d 	sts	0x0D99, r1
	       switch(stLocalAccount){   //|ID: ACD12345       |
	       case laInit:              //|Process ...        |
		        //Process RFID Data  //|                   |
				//UpdateCardID();
                BackLightTrig();ViewCardID();
	            lcd_clear();
   12b7a:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
	            lcd_printf(1,1,PSTR("   Local Account   "));
   12b7e:	81 e0       	ldi	r24, 0x01	; 1
   12b80:	61 e0       	ldi	r22, 0x01	; 1
   12b82:	44 e2       	ldi	r20, 0x24	; 36
   12b84:	50 e2       	ldi	r21, 0x20	; 32
   12b86:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	            sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   12b8a:	00 d0       	rcall	.+0      	; 0x12b8c <FMenuLocalAccount+0x90>
   12b8c:	00 d0       	rcall	.+0      	; 0x12b8e <FMenuLocalAccount+0x92>
   12b8e:	00 d0       	rcall	.+0      	; 0x12b90 <FMenuLocalAccount+0x94>
   12b90:	ed b7       	in	r30, 0x3d	; 61
   12b92:	fe b7       	in	r31, 0x3e	; 62
   12b94:	31 96       	adiw	r30, 0x01	; 1
   12b96:	8e 01       	movw	r16, r28
   12b98:	0f 5f       	subi	r16, 0xFF	; 255
   12b9a:	1f 4f       	sbci	r17, 0xFF	; 255
   12b9c:	ad b7       	in	r26, 0x3d	; 61
   12b9e:	be b7       	in	r27, 0x3e	; 62
   12ba0:	12 96       	adiw	r26, 0x02	; 2
   12ba2:	1c 93       	st	X, r17
   12ba4:	0e 93       	st	-X, r16
   12ba6:	11 97       	sbiw	r26, 0x01	; 1
   12ba8:	8e e1       	ldi	r24, 0x1E	; 30
   12baa:	90 e2       	ldi	r25, 0x20	; 32
   12bac:	93 83       	std	Z+3, r25	; 0x03
   12bae:	82 83       	std	Z+2, r24	; 0x02
   12bb0:	81 e9       	ldi	r24, 0x91	; 145
   12bb2:	9d e0       	ldi	r25, 0x0D	; 13
   12bb4:	95 83       	std	Z+5, r25	; 0x05
   12bb6:	84 83       	std	Z+4, r24	; 0x04
   12bb8:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   12bbc:	ed b7       	in	r30, 0x3d	; 61
   12bbe:	fe b7       	in	r31, 0x3e	; 62
   12bc0:	36 96       	adiw	r30, 0x06	; 6
   12bc2:	0f b6       	in	r0, 0x3f	; 63
   12bc4:	f8 94       	cli
   12bc6:	fe bf       	out	0x3e, r31	; 62
   12bc8:	0f be       	out	0x3f, r0	; 63
   12bca:	ed bf       	out	0x3d, r30	; 61
   12bcc:	82 e0       	ldi	r24, 0x02	; 2
   12bce:	61 e0       	ldi	r22, 0x01	; 1
   12bd0:	a8 01       	movw	r20, r16
   12bd2:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
                lcd_printf(3,1,PSTR("Proses"));
   12bd6:	83 e0       	ldi	r24, 0x03	; 3
   12bd8:	61 e0       	ldi	r22, 0x01	; 1
   12bda:	47 e1       	ldi	r20, 0x17	; 23
   12bdc:	50 e2       	ldi	r21, 0x20	; 32
   12bde:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				iPos=0;iLoop=0;
   12be2:	10 92 be 03 	sts	0x03BE, r1
   12be6:	10 92 8e 03 	sts	0x038E, r1
   12bea:	10 92 8d 03 	sts	0x038D, r1
				IsFullAuthorized=False;
   12bee:	10 92 8f 03 	sts	0x038F, r1
		        stLocalAccount=laSendID;
   12bf2:	82 e0       	ldi	r24, 0x02	; 2
   12bf4:	dd c6       	rjmp	.+3514   	; 0x139b0 <FMenuLocalAccount+0xeb4>
				break;         
           case laSendID://sendMessage56 
				IsMessage57=False;
   12bf6:	10 92 d2 01 	sts	0x01D2, r1
                sendMessage56();
   12bfa:	0e 94 e5 4e 	call	0x9dca	; 0x9dca <sendMessage56>
				iWait=0;iLoop=0;iPos=0;
   12bfe:	10 92 bd 03 	sts	0x03BD, r1
   12c02:	10 92 8e 03 	sts	0x038E, r1
   12c06:	10 92 8d 03 	sts	0x038D, r1
   12c0a:	10 92 be 03 	sts	0x03BE, r1
				stLocalAccount=laWaitMessage57;
   12c0e:	83 e0       	ldi	r24, 0x03	; 3
   12c10:	cf c6       	rjmp	.+3486   	; 0x139b0 <FMenuLocalAccount+0xeb4>
		        break;
           case laWaitMessage57:
		        iLoop++;
   12c12:	80 91 8d 03 	lds	r24, 0x038D
   12c16:	90 91 8e 03 	lds	r25, 0x038E
   12c1a:	01 96       	adiw	r24, 0x01	; 1
   12c1c:	90 93 8e 03 	sts	0x038E, r25
   12c20:	80 93 8d 03 	sts	0x038D, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   12c24:	68 e9       	ldi	r22, 0x98	; 152
   12c26:	7a e3       	ldi	r23, 0x3A	; 58
   12c28:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
   12c2c:	89 2b       	or	r24, r25
   12c2e:	e1 f4       	brne	.+56     	; 0x12c68 <FMenuLocalAccount+0x16c>
				   if (iPos<5){
   12c30:	60 91 be 03 	lds	r22, 0x03BE
   12c34:	65 30       	cpi	r22, 0x05	; 5
   12c36:	58 f4       	brcc	.+22     	; 0x12c4e <FMenuLocalAccount+0x152>
					   lcd_put(3,(8+iPos),'.');
   12c38:	68 5f       	subi	r22, 0xF8	; 248
   12c3a:	83 e0       	ldi	r24, 0x03	; 3
   12c3c:	4e e2       	ldi	r20, 0x2E	; 46
   12c3e:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
				       iPos++;
   12c42:	80 91 be 03 	lds	r24, 0x03BE
   12c46:	8f 5f       	subi	r24, 0xFF	; 255
   12c48:	80 93 be 03 	sts	0x03BE, r24
   12c4c:	0d c0       	rjmp	.+26     	; 0x12c68 <FMenuLocalAccount+0x16c>
					   }
				   else{
				       iPos=0;
   12c4e:	10 92 be 03 	sts	0x03BE, r1
					   lcd_printf(3,(9+iPos),PSTR("       "));
   12c52:	83 e0       	ldi	r24, 0x03	; 3
   12c54:	69 e0       	ldi	r22, 0x09	; 9
   12c56:	4f e0       	ldi	r20, 0x0F	; 15
   12c58:	50 e2       	ldi	r21, 0x20	; 32
   12c5a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
					   iWait++;
   12c5e:	80 91 bd 03 	lds	r24, 0x03BD
   12c62:	8f 5f       	subi	r24, 0xFF	; 255
   12c64:	80 93 bd 03 	sts	0x03BD, r24
					   }
				}
				if (iWait>3){
   12c68:	80 91 bd 03 	lds	r24, 0x03BD
   12c6c:	84 30       	cpi	r24, 0x04	; 4
   12c6e:	78 f0       	brcs	.+30     	; 0x12c8e <FMenuLocalAccount+0x192>
				    stLocalAccount=laConTimout;
   12c70:	84 e0       	ldi	r24, 0x04	; 4
   12c72:	80 93 71 01 	sts	0x0171, r24
					TimLocAcc=0;
   12c76:	10 92 e8 01 	sts	0x01E8, r1
   12c7a:	10 92 e7 01 	sts	0x01E7, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   12c7e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   12c80:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   12c82:	82 e0       	ldi	r24, 0x02	; 2
   12c84:	90 e0       	ldi	r25, 0x00	; 0
   12c86:	90 93 ec 01 	sts	0x01EC, r25
   12c8a:	80 93 eb 01 	sts	0x01EB, r24
				if (iWait>3){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage57==True){
   12c8e:	80 91 d2 01 	lds	r24, 0x01D2
   12c92:	81 30       	cpi	r24, 0x01	; 1
   12c94:	11 f0       	breq	.+4      	; 0x12c9a <FMenuLocalAccount+0x19e>
   12c96:	0c 94 ab 9f 	jmp	0x13f56	; 0x13f56 <FMenuLocalAccount+0x145a>
				    IsMessage57=False;
   12c9a:	10 92 d2 01 	sts	0x01D2, r1
				    stLocalAccount=laProcMessage57;
   12c9e:	85 e0       	ldi	r24, 0x05	; 5
   12ca0:	87 c6       	rjmp	.+3342   	; 0x139b0 <FMenuLocalAccount+0xeb4>
					}
		        break;
           case laConTimout:
		        IsErrorTCPIP=True;
   12ca2:	81 e0       	ldi	r24, 0x01	; 1
   12ca4:	80 93 ca 01 	sts	0x01CA, r24
				lcd_printf(3,1,PSTR("Sending Failed      "));
   12ca8:	83 e0       	ldi	r24, 0x03	; 3
   12caa:	61 e0       	ldi	r22, 0x01	; 1
   12cac:	4a ef       	ldi	r20, 0xFA	; 250
   12cae:	5f e1       	ldi	r21, 0x1F	; 31
   12cb0:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
   12cb4:	84 e0       	ldi	r24, 0x04	; 4
   12cb6:	61 e0       	ldi	r22, 0x01	; 1
   12cb8:	45 ee       	ldi	r20, 0xE5	; 229
   12cba:	5f e1       	ldi	r21, 0x1F	; 31
   12cbc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
   12cc0:	80 91 e7 01 	lds	r24, 0x01E7
   12cc4:	90 91 e8 01 	lds	r25, 0x01E8
   12cc8:	03 97       	sbiw	r24, 0x03	; 3
   12cca:	10 f4       	brcc	.+4      	; 0x12cd0 <FMenuLocalAccount+0x1d4>
   12ccc:	0c 94 ab 9f 	jmp	0x13f56	; 0x13f56 <FMenuLocalAccount+0x145a>
   12cd0:	0c 94 a2 9f 	jmp	0x13f44	; 0x13f44 <FMenuLocalAccount+0x1448>
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
   12cd4:	83 e0       	ldi	r24, 0x03	; 3
   12cd6:	61 e0       	ldi	r22, 0x01	; 1
   12cd8:	40 ed       	ldi	r20, 0xD0	; 208
   12cda:	5f e1       	ldi	r21, 0x1F	; 31
   12cdc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				LocAccStatus=GetLocAccStatus(procMessage57());
   12ce0:	0e 94 0a 24 	call	0x4814	; 0x4814 <procMessage57>


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
   12ce4:	81 30       	cpi	r24, 0x01	; 1
   12ce6:	29 f0       	breq	.+10     	; 0x12cf2 <FMenuLocalAccount+0x1f6>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
   12ce8:	82 30       	cpi	r24, 0x02	; 2
   12cea:	19 f0       	breq	.+6      	; 0x12cf2 <FMenuLocalAccount+0x1f6>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
   12cec:	83 30       	cpi	r24, 0x03	; 3
   12cee:	09 f0       	breq	.+2      	; 0x12cf2 <FMenuLocalAccount+0x1f6>
   12cf0:	80 e0       	ldi	r24, 0x00	; 0
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
				LocAccStatus=GetLocAccStatus(procMessage57());
   12cf2:	80 93 bf 03 	sts	0x03BF, r24
				TimLocAcc=0;
   12cf6:	10 92 e8 01 	sts	0x01E8, r1
   12cfa:	10 92 e7 01 	sts	0x01E7, r1
				stLocalAccount=laDispStatus;
   12cfe:	86 e0       	ldi	r24, 0x06	; 6
   12d00:	57 c6       	rjmp	.+3246   	; 0x139b0 <FMenuLocalAccount+0xeb4>
		        break;
           case laDispStatus://Display Status
		        if (LocAccStatus==LA_INVALID){
   12d02:	80 91 bf 03 	lds	r24, 0x03BF
   12d06:	81 30       	cpi	r24, 0x01	; 1
   12d08:	29 f4       	brne	.+10     	; 0x12d14 <FMenuLocalAccount+0x218>
					lcd_printf(3,1,PSTR("Tidak Terdaftar     "));    
   12d0a:	83 e0       	ldi	r24, 0x03	; 3
   12d0c:	61 e0       	ldi	r22, 0x01	; 1
   12d0e:	4b eb       	ldi	r20, 0xBB	; 187
   12d10:	5f e1       	ldi	r21, 0x1F	; 31
   12d12:	0d c0       	rjmp	.+26     	; 0x12d2e <FMenuLocalAccount+0x232>
					TimLocAcc=0;
				    stLocalAccount=laDelayExit;
				}
				else
                if (LocAccStatus==LA_VALID) {
   12d14:	82 30       	cpi	r24, 0x02	; 2
   12d16:	31 f4       	brne	.+12     	; 0x12d24 <FMenuLocalAccount+0x228>
				    stLocalAccount=laDispValid; 
   12d18:	87 e0       	ldi	r24, 0x07	; 7
   12d1a:	80 93 71 01 	sts	0x0171, r24
					lcd_clear();
   12d1e:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
   12d22:	0e c0       	rjmp	.+28     	; 0x12d40 <FMenuLocalAccount+0x244>
					}
				else
                if (LocAccStatus==LA_LIMITED){
   12d24:	83 30       	cpi	r24, 0x03	; 3
   12d26:	61 f4       	brne	.+24     	; 0x12d40 <FMenuLocalAccount+0x244>
					lcd_printf(3,1,PSTR("Kartu Terbatas      "));    
   12d28:	61 e0       	ldi	r22, 0x01	; 1
   12d2a:	46 ea       	ldi	r20, 0xA6	; 166
   12d2c:	5f e1       	ldi	r21, 0x1F	; 31
   12d2e:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
					TimLocAcc=0;
   12d32:	10 92 e8 01 	sts	0x01E8, r1
   12d36:	10 92 e7 01 	sts	0x01E7, r1
				    stLocalAccount=laDelayExit;
   12d3a:	8e e1       	ldi	r24, 0x1E	; 30
   12d3c:	80 93 71 01 	sts	0x0171, r24
				}
                if (TimLocAcc>5)stLocalAccount=laExitLocAcc;
   12d40:	80 91 e7 01 	lds	r24, 0x01E7
   12d44:	90 91 e8 01 	lds	r25, 0x01E8
   12d48:	06 97       	sbiw	r24, 0x06	; 6
   12d4a:	10 f4       	brcc	.+4      	; 0x12d50 <FMenuLocalAccount+0x254>
   12d4c:	0c 94 ab 9f 	jmp	0x13f56	; 0x13f56 <FMenuLocalAccount+0x145a>
   12d50:	0c 94 a2 9f 	jmp	0x13f44	; 0x13f44 <FMenuLocalAccount+0x1448>
		        break;
           case laDispValid://Display VALID ID
		        lcd_clear();
   12d54:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
   12d58:	00 d0       	rcall	.+0      	; 0x12d5a <FMenuLocalAccount+0x25e>
   12d5a:	00 d0       	rcall	.+0      	; 0x12d5c <FMenuLocalAccount+0x260>
   12d5c:	00 d0       	rcall	.+0      	; 0x12d5e <FMenuLocalAccount+0x262>
   12d5e:	ed b7       	in	r30, 0x3d	; 61
   12d60:	fe b7       	in	r31, 0x3e	; 62
   12d62:	31 96       	adiw	r30, 0x01	; 1
   12d64:	8a e2       	ldi	r24, 0x2A	; 42
   12d66:	9e e0       	ldi	r25, 0x0E	; 14
   12d68:	ad b7       	in	r26, 0x3d	; 61
   12d6a:	be b7       	in	r27, 0x3e	; 62
   12d6c:	12 96       	adiw	r26, 0x02	; 2
   12d6e:	9c 93       	st	X, r25
   12d70:	8e 93       	st	-X, r24
   12d72:	11 97       	sbiw	r26, 0x01	; 1
   12d74:	83 ea       	ldi	r24, 0xA3	; 163
   12d76:	9f e1       	ldi	r25, 0x1F	; 31
   12d78:	93 83       	std	Z+3, r25	; 0x03
   12d7a:	82 83       	std	Z+2, r24	; 0x02
   12d7c:	03 e0       	ldi	r16, 0x03	; 3
   12d7e:	1e e0       	ldi	r17, 0x0E	; 14
   12d80:	15 83       	std	Z+5, r17	; 0x05
   12d82:	04 83       	std	Z+4, r16	; 0x04
   12d84:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
				FormatCurrency(strBalance);
   12d88:	ed b7       	in	r30, 0x3d	; 61
   12d8a:	fe b7       	in	r31, 0x3e	; 62
   12d8c:	36 96       	adiw	r30, 0x06	; 6
   12d8e:	0f b6       	in	r0, 0x3f	; 63
   12d90:	f8 94       	cli
   12d92:	fe bf       	out	0x3e, r31	; 62
   12d94:	0f be       	out	0x3f, r0	; 63
   12d96:	ed bf       	out	0x3d, r30	; 61
   12d98:	c8 01       	movw	r24, r16
   12d9a:	0e 94 5c 2f 	call	0x5eb8	; 0x5eb8 <FormatCurrency>
   12d9e:	20 e0       	ldi	r18, 0x00	; 0
   12da0:	30 e0       	ldi	r19, 0x00	; 0


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
   12da2:	45 e1       	ldi	r20, 0x15	; 21
   12da4:	e4 2e       	mov	r14, r20
   12da6:	f1 2c       	mov	r15, r1
   12da8:	ec 0e       	add	r14, r28
   12daa:	fd 1e       	adc	r15, r29
   12dac:	f7 01       	movw	r30, r14
   12dae:	e2 0f       	add	r30, r18
   12db0:	f3 1f       	adc	r31, r19
   12db2:	d9 01       	movw	r26, r18
   12db4:	a6 5d       	subi	r26, 0xD6	; 214
   12db6:	ba 4f       	sbci	r27, 0xFA	; 250
   12db8:	8c 91       	ld	r24, X
   12dba:	80 83       	st	Z, r24
   12dbc:	2f 5f       	subi	r18, 0xFF	; 255
   12dbe:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
   12dc0:	24 31       	cpi	r18, 0x14	; 20
   12dc2:	31 05       	cpc	r19, r1
   12dc4:	99 f7       	brne	.-26     	; 0x12dac <FMenuLocalAccount+0x2b0>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
   12dc6:	19 a6       	std	Y+41, r1	; 0x29
		        lcd_clear();
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
				FormatCurrency(strBalance);

		        StringCopy(strCardHolder,strName,20);  				                                                        
		        sprintf_P(lcdteks,PSTR("%s"),strCompName);               lcd_print(1,1,lcdteks);   //[CompName]
   12dc8:	00 d0       	rcall	.+0      	; 0x12dca <FMenuLocalAccount+0x2ce>
   12dca:	00 d0       	rcall	.+0      	; 0x12dcc <FMenuLocalAccount+0x2d0>
   12dcc:	00 d0       	rcall	.+0      	; 0x12dce <FMenuLocalAccount+0x2d2>
   12dce:	ed b7       	in	r30, 0x3d	; 61
   12dd0:	fe b7       	in	r31, 0x3e	; 62
   12dd2:	31 96       	adiw	r30, 0x01	; 1
   12dd4:	8e 01       	movw	r16, r28
   12dd6:	0f 5f       	subi	r16, 0xFF	; 255
   12dd8:	1f 4f       	sbci	r17, 0xFF	; 255
   12dda:	ad b7       	in	r26, 0x3d	; 61
   12ddc:	be b7       	in	r27, 0x3e	; 62
   12dde:	12 96       	adiw	r26, 0x02	; 2
   12de0:	1c 93       	st	X, r17
   12de2:	0e 93       	st	-X, r16
   12de4:	11 97       	sbiw	r26, 0x01	; 1
   12de6:	80 ea       	ldi	r24, 0xA0	; 160
   12de8:	9f e1       	ldi	r25, 0x1F	; 31
   12dea:	93 83       	std	Z+3, r25	; 0x03
   12dec:	82 83       	std	Z+2, r24	; 0x02
   12dee:	88 e8       	ldi	r24, 0x88	; 136
   12df0:	99 e0       	ldi	r25, 0x09	; 9
   12df2:	95 83       	std	Z+5, r25	; 0x05
   12df4:	84 83       	std	Z+4, r24	; 0x04
   12df6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   12dfa:	ed b7       	in	r30, 0x3d	; 61
   12dfc:	fe b7       	in	r31, 0x3e	; 62
   12dfe:	36 96       	adiw	r30, 0x06	; 6
   12e00:	0f b6       	in	r0, 0x3f	; 63
   12e02:	f8 94       	cli
   12e04:	fe bf       	out	0x3e, r31	; 62
   12e06:	0f be       	out	0x3f, r0	; 63
   12e08:	ed bf       	out	0x3d, r30	; 61
   12e0a:	81 e0       	ldi	r24, 0x01	; 1
   12e0c:	61 e0       	ldi	r22, 0x01	; 1
   12e0e:	a8 01       	movw	r20, r16
   12e10:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
                //sprintf(lcdteks,"%s %s",strCardID,strName);    lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
				sprintf_P(lcdteks,PSTR("%s"),strName);                   lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
   12e14:	00 d0       	rcall	.+0      	; 0x12e16 <FMenuLocalAccount+0x31a>
   12e16:	00 d0       	rcall	.+0      	; 0x12e18 <FMenuLocalAccount+0x31c>
   12e18:	00 d0       	rcall	.+0      	; 0x12e1a <FMenuLocalAccount+0x31e>
   12e1a:	ed b7       	in	r30, 0x3d	; 61
   12e1c:	fe b7       	in	r31, 0x3e	; 62
   12e1e:	31 96       	adiw	r30, 0x01	; 1
   12e20:	ad b7       	in	r26, 0x3d	; 61
   12e22:	be b7       	in	r27, 0x3e	; 62
   12e24:	12 96       	adiw	r26, 0x02	; 2
   12e26:	1c 93       	st	X, r17
   12e28:	0e 93       	st	-X, r16
   12e2a:	11 97       	sbiw	r26, 0x01	; 1
   12e2c:	8d e9       	ldi	r24, 0x9D	; 157
   12e2e:	9f e1       	ldi	r25, 0x1F	; 31
   12e30:	93 83       	std	Z+3, r25	; 0x03
   12e32:	82 83       	std	Z+2, r24	; 0x02
   12e34:	f5 82       	std	Z+5, r15	; 0x05
   12e36:	e4 82       	std	Z+4, r14	; 0x04
   12e38:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   12e3c:	ed b7       	in	r30, 0x3d	; 61
   12e3e:	fe b7       	in	r31, 0x3e	; 62
   12e40:	36 96       	adiw	r30, 0x06	; 6
   12e42:	0f b6       	in	r0, 0x3f	; 63
   12e44:	f8 94       	cli
   12e46:	fe bf       	out	0x3e, r31	; 62
   12e48:	0f be       	out	0x3f, r0	; 63
   12e4a:	ed bf       	out	0x3d, r30	; 61
   12e4c:	82 e0       	ldi	r24, 0x02	; 2
   12e4e:	61 e0       	ldi	r22, 0x01	; 1
   12e50:	a8 01       	movw	r20, r16
   12e52:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
				sprintf_P(lcdteks,PSTR("%s %s"),strLicPlate,strBalance); lcd_print(3,1,lcdteks);   //[LicPlate][Balance] 
   12e56:	2d b7       	in	r18, 0x3d	; 61
   12e58:	3e b7       	in	r19, 0x3e	; 62
   12e5a:	28 50       	subi	r18, 0x08	; 8
   12e5c:	30 40       	sbci	r19, 0x00	; 0
   12e5e:	0f b6       	in	r0, 0x3f	; 63
   12e60:	f8 94       	cli
   12e62:	3e bf       	out	0x3e, r19	; 62
   12e64:	0f be       	out	0x3f, r0	; 63
   12e66:	2d bf       	out	0x3d, r18	; 61
   12e68:	ed b7       	in	r30, 0x3d	; 61
   12e6a:	fe b7       	in	r31, 0x3e	; 62
   12e6c:	31 96       	adiw	r30, 0x01	; 1
   12e6e:	ad b7       	in	r26, 0x3d	; 61
   12e70:	be b7       	in	r27, 0x3e	; 62
   12e72:	12 96       	adiw	r26, 0x02	; 2
   12e74:	1c 93       	st	X, r17
   12e76:	0e 93       	st	-X, r16
   12e78:	11 97       	sbiw	r26, 0x01	; 1
   12e7a:	87 e9       	ldi	r24, 0x97	; 151
   12e7c:	9f e1       	ldi	r25, 0x1F	; 31
   12e7e:	93 83       	std	Z+3, r25	; 0x03
   12e80:	82 83       	std	Z+2, r24	; 0x02
   12e82:	82 e0       	ldi	r24, 0x02	; 2
   12e84:	9b e0       	ldi	r25, 0x0B	; 11
   12e86:	95 83       	std	Z+5, r25	; 0x05
   12e88:	84 83       	std	Z+4, r24	; 0x04
   12e8a:	83 e0       	ldi	r24, 0x03	; 3
   12e8c:	9e e0       	ldi	r25, 0x0E	; 14
   12e8e:	97 83       	std	Z+7, r25	; 0x07
   12e90:	86 83       	std	Z+6, r24	; 0x06
   12e92:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   12e96:	ed b7       	in	r30, 0x3d	; 61
   12e98:	fe b7       	in	r31, 0x3e	; 62
   12e9a:	38 96       	adiw	r30, 0x08	; 8
   12e9c:	0f b6       	in	r0, 0x3f	; 63
   12e9e:	f8 94       	cli
   12ea0:	fe bf       	out	0x3e, r31	; 62
   12ea2:	0f be       	out	0x3f, r0	; 63
   12ea4:	ed bf       	out	0x3d, r30	; 61
   12ea6:	83 e0       	ldi	r24, 0x03	; 3
   12ea8:	61 e0       	ldi	r22, 0x01	; 1
   12eaa:	a8 01       	movw	r20, r16
   12eac:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
	            lcd_printf(4,1,PSTR("[*]Batal       [#]OK"));   //[*]Batal       [#]OK
   12eb0:	84 e0       	ldi	r24, 0x04	; 4
   12eb2:	61 e0       	ldi	r22, 0x01	; 1
   12eb4:	42 e8       	ldi	r20, 0x82	; 130
   12eb6:	5f e1       	ldi	r21, 0x1F	; 31
   12eb8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				stLocalAccount=laDispValidInput;
   12ebc:	88 e0       	ldi	r24, 0x08	; 8
   12ebe:	78 c5       	rjmp	.+2800   	; 0x139b0 <FMenuLocalAccount+0xeb4>
		        break;
           case laDispValidInput:
                KeyPressed=_key_scan(1);
   12ec0:	81 e0       	ldi	r24, 0x01	; 1
   12ec2:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   12ec6:	80 93 b7 03 	sts	0x03B7, r24
				if (KeyPressed==_KEY_ENTER) stLocalAccount=laSelectFIP;
   12eca:	87 3b       	cpi	r24, 0xB7	; 183
   12ecc:	09 f4       	brne	.+2      	; 0x12ed0 <FMenuLocalAccount+0x3d4>
   12ece:	82 c2       	rjmp	.+1284   	; 0x133d4 <FMenuLocalAccount+0x8d8>
				else
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laExitLocAcc;
   12ed0:	87 3e       	cpi	r24, 0xE7	; 231
   12ed2:	11 f0       	breq	.+4      	; 0x12ed8 <FMenuLocalAccount+0x3dc>
   12ed4:	0c 94 ab 9f 	jmp	0x13f56	; 0x13f56 <FMenuLocalAccount+0x145a>
   12ed8:	0c 94 a2 9f 	jmp	0x13f44	; 0x13f44 <FMenuLocalAccount+0x1448>
   12edc:	8d e9       	ldi	r24, 0x9D	; 157
   12ede:	93 e0       	ldi	r25, 0x03	; 3
   12ee0:	65 e4       	ldi	r22, 0x45	; 69
   12ee2:	70 e0       	ldi	r23, 0x00	; 0
   12ee4:	48 e0       	ldi	r20, 0x08	; 8
   12ee6:	50 e0       	ldi	r21, 0x00	; 0
   12ee8:	2c ea       	ldi	r18, 0xAC	; 172
   12eea:	32 e1       	ldi	r19, 0x12	; 18
   12eec:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
		        break;
           case laSelectFIP:       
		  		eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				lcd_clear(); 
   12ef0:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
				//for (iLoop=0;iLoop<8;iLoop++){
				//     if (FIP[iLoop]>16) FIP[iLoop]=0;
				//	 }
				for (iLoop=0;iLoop<4;iLoop++){
   12ef4:	10 92 8e 03 	sts	0x038E, r1
   12ef8:	10 92 8d 03 	sts	0x038D, r1
                     //leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                     //sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
					 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
   12efc:	8e 01       	movw	r16, r28
   12efe:	0f 5f       	subi	r16, 0xFF	; 255
   12f00:	1f 4f       	sbci	r17, 0xFF	; 255
   12f02:	2e e6       	ldi	r18, 0x6E	; 110
   12f04:	e2 2e       	mov	r14, r18
   12f06:	2f e1       	ldi	r18, 0x1F	; 31
   12f08:	f2 2e       	mov	r15, r18
   12f0a:	41 c0       	rjmp	.+130    	; 0x12f8e <FMenuLocalAccount+0x492>
   12f0c:	8d b7       	in	r24, 0x3d	; 61
   12f0e:	9e b7       	in	r25, 0x3e	; 62
   12f10:	0c 97       	sbiw	r24, 0x0c	; 12
   12f12:	0f b6       	in	r0, 0x3f	; 63
   12f14:	f8 94       	cli
   12f16:	9e bf       	out	0x3e, r25	; 62
   12f18:	0f be       	out	0x3f, r0	; 63
   12f1a:	8d bf       	out	0x3d, r24	; 61
   12f1c:	ed b7       	in	r30, 0x3d	; 61
   12f1e:	fe b7       	in	r31, 0x3e	; 62
   12f20:	31 96       	adiw	r30, 0x01	; 1
   12f22:	ad b7       	in	r26, 0x3d	; 61
   12f24:	be b7       	in	r27, 0x3e	; 62
   12f26:	12 96       	adiw	r26, 0x02	; 2
   12f28:	1c 93       	st	X, r17
   12f2a:	0e 93       	st	-X, r16
   12f2c:	11 97       	sbiw	r26, 0x01	; 1
   12f2e:	f3 82       	std	Z+3, r15	; 0x03
   12f30:	e2 82       	std	Z+2, r14	; 0x02
   12f32:	2f 5f       	subi	r18, 0xFF	; 255
   12f34:	3f 4f       	sbci	r19, 0xFF	; 255
   12f36:	35 83       	std	Z+5, r19	; 0x05
   12f38:	24 83       	std	Z+4, r18	; 0x04
   12f3a:	21 50       	subi	r18, 0x01	; 1
   12f3c:	30 40       	sbci	r19, 0x00	; 0
   12f3e:	d9 01       	movw	r26, r18
   12f40:	a3 56       	subi	r26, 0x63	; 99
   12f42:	bc 4f       	sbci	r27, 0xFC	; 252
   12f44:	8c 91       	ld	r24, X
   12f46:	86 83       	std	Z+6, r24	; 0x06
   12f48:	17 82       	std	Z+7, r1	; 0x07
   12f4a:	2b 5f       	subi	r18, 0xFB	; 251
   12f4c:	3f 4f       	sbci	r19, 0xFF	; 255
   12f4e:	31 87       	std	Z+9, r19	; 0x09
   12f50:	20 87       	std	Z+8, r18	; 0x08
   12f52:	14 96       	adiw	r26, 0x04	; 4
   12f54:	8c 91       	ld	r24, X
   12f56:	82 87       	std	Z+10, r24	; 0x0a
   12f58:	13 86       	std	Z+11, r1	; 0x0b
   12f5a:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
					 lcd_print((iLoop+1),1,lcdteks);
   12f5e:	ed b7       	in	r30, 0x3d	; 61
   12f60:	fe b7       	in	r31, 0x3e	; 62
   12f62:	3c 96       	adiw	r30, 0x0c	; 12
   12f64:	0f b6       	in	r0, 0x3f	; 63
   12f66:	f8 94       	cli
   12f68:	fe bf       	out	0x3e, r31	; 62
   12f6a:	0f be       	out	0x3f, r0	; 63
   12f6c:	ed bf       	out	0x3d, r30	; 61
   12f6e:	80 91 8d 03 	lds	r24, 0x038D
   12f72:	8f 5f       	subi	r24, 0xFF	; 255
   12f74:	61 e0       	ldi	r22, 0x01	; 1
   12f76:	a8 01       	movw	r20, r16
   12f78:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  		eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				lcd_clear(); 
				//for (iLoop=0;iLoop<8;iLoop++){
				//     if (FIP[iLoop]>16) FIP[iLoop]=0;
				//	 }
				for (iLoop=0;iLoop<4;iLoop++){
   12f7c:	80 91 8d 03 	lds	r24, 0x038D
   12f80:	90 91 8e 03 	lds	r25, 0x038E
   12f84:	01 96       	adiw	r24, 0x01	; 1
   12f86:	90 93 8e 03 	sts	0x038E, r25
   12f8a:	80 93 8d 03 	sts	0x038D, r24
   12f8e:	20 91 8d 03 	lds	r18, 0x038D
   12f92:	30 91 8e 03 	lds	r19, 0x038E
   12f96:	24 30       	cpi	r18, 0x04	; 4
   12f98:	31 05       	cpc	r19, r1
   12f9a:	08 f4       	brcc	.+2      	; 0x12f9e <FMenuLocalAccount+0x4a2>
   12f9c:	b7 cf       	rjmp	.-146    	; 0x12f0c <FMenuLocalAccount+0x410>
                     //leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                     //sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
					 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
					 lcd_print((iLoop+1),1,lcdteks);
					 }
		        lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
   12f9e:	81 e0       	ldi	r24, 0x01	; 1
   12fa0:	6f e0       	ldi	r22, 0x0F	; 15
   12fa2:	48 e6       	ldi	r20, 0x68	; 104
   12fa4:	5f e1       	ldi	r21, 0x1F	; 31
   12fa6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
   12faa:	82 e0       	ldi	r24, 0x02	; 2
   12fac:	6f e0       	ldi	r22, 0x0F	; 15
   12fae:	42 e6       	ldi	r20, 0x62	; 98
   12fb0:	5f e1       	ldi	r21, 0x1F	; 31
   12fb2:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
   12fb6:	83 e0       	ldi	r24, 0x03	; 3
   12fb8:	6f e0       	ldi	r22, 0x0F	; 15
   12fba:	4c e5       	ldi	r20, 0x5C	; 92
   12fbc:	5f e1       	ldi	r21, 0x1F	; 31
   12fbe:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	            lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
   12fc2:	84 e0       	ldi	r24, 0x04	; 4
   12fc4:	6f e0       	ldi	r22, 0x0F	; 15
   12fc6:	45 e5       	ldi	r20, 0x55	; 85
   12fc8:	5f e1       	ldi	r21, 0x1F	; 31
   12fca:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				//eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				iLoop=0;
   12fce:	10 92 8e 03 	sts	0x038E, r1
   12fd2:	10 92 8d 03 	sts	0x038D, r1
				stLocalAccount=laSelectFIPInput;
   12fd6:	8a e0       	ldi	r24, 0x0A	; 10
   12fd8:	eb c4       	rjmp	.+2518   	; 0x139b0 <FMenuLocalAccount+0xeb4>
		        break; 
           case laSelectFIPInput:
			    //Blinking 50% _ 
			    iLoop++;
   12fda:	80 91 8d 03 	lds	r24, 0x038D
   12fde:	90 91 8e 03 	lds	r25, 0x038E
   12fe2:	01 96       	adiw	r24, 0x01	; 1
   12fe4:	90 93 8e 03 	sts	0x038E, r25
   12fe8:	80 93 8d 03 	sts	0x038D, r24
			    //GetKeyPressed
			    KeyPressed=_key_scan(1);
   12fec:	81 e0       	ldi	r24, 0x01	; 1
   12fee:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   12ff2:	80 93 b7 03 	sts	0x03B7, r24
			    KeyChar=_key_btn(KeyPressed);
   12ff6:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   12ffa:	98 2f       	mov	r25, r24
   12ffc:	80 93 bc 03 	sts	0x03BC, r24
				if ((KeyChar>='1')&&(KeyChar<='8')){
   13000:	81 53       	subi	r24, 0x31	; 49
   13002:	88 30       	cpi	r24, 0x08	; 8
   13004:	60 f4       	brcc	.+24     	; 0x1301e <FMenuLocalAccount+0x522>
				    if (KeyCharLast!=KeyChar){
   13006:	80 91 70 01 	lds	r24, 0x0170
   1300a:	89 17       	cp	r24, r25
   1300c:	41 f0       	breq	.+16     	; 0x1301e <FMenuLocalAccount+0x522>
					    KeyCharLast=KeyChar;
   1300e:	90 93 70 01 	sts	0x0170, r25
						iLoop=1000;
   13012:	88 ee       	ldi	r24, 0xE8	; 232
   13014:	93 e0       	ldi	r25, 0x03	; 3
   13016:	90 93 8e 03 	sts	0x038E, r25
   1301a:	80 93 8d 03 	sts	0x038D, r24
                    }
				}

			    if ((iLoop%2000)==0){
   1301e:	80 91 8d 03 	lds	r24, 0x038D
   13022:	90 91 8e 03 	lds	r25, 0x038E
   13026:	60 ed       	ldi	r22, 0xD0	; 208
   13028:	77 e0       	ldi	r23, 0x07	; 7
   1302a:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
   1302e:	89 2b       	or	r24, r25
   13030:	39 f4       	brne	.+14     	; 0x13040 <FMenuLocalAccount+0x544>
			       lcd_xy(1,19);_lcd('_'); 
   13032:	81 e0       	ldi	r24, 0x01	; 1
   13034:	63 e1       	ldi	r22, 0x13	; 19
   13036:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
   1303a:	8f e5       	ldi	r24, 0x5F	; 95
   1303c:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
			    }
			    if ((iLoop%2000)==1000){
   13040:	80 91 8d 03 	lds	r24, 0x038D
   13044:	90 91 8e 03 	lds	r25, 0x038E
   13048:	60 ed       	ldi	r22, 0xD0	; 208
   1304a:	77 e0       	ldi	r23, 0x07	; 7
   1304c:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
   13050:	88 5e       	subi	r24, 0xE8	; 232
   13052:	93 40       	sbci	r25, 0x03	; 3
   13054:	41 f4       	brne	.+16     	; 0x13066 <FMenuLocalAccount+0x56a>
			       lcd_xy(1,19);_lcd(KeyCharLast); 
   13056:	81 e0       	ldi	r24, 0x01	; 1
   13058:	63 e1       	ldi	r22, 0x13	; 19
   1305a:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
   1305e:	80 91 70 01 	lds	r24, 0x0170
   13062:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
			    }
				if (((KeyChar>='1')&&(KeyChar<='8'))||
   13066:	80 91 bc 03 	lds	r24, 0x03BC
   1306a:	81 53       	subi	r24, 0x31	; 49
   1306c:	88 30       	cpi	r24, 0x08	; 8
   1306e:	50 f0       	brcs	.+20     	; 0x13084 <FMenuLocalAccount+0x588>
   13070:	80 91 b7 03 	lds	r24, 0x03B7
   13074:	87 3b       	cpi	r24, 0xB7	; 183
   13076:	09 f0       	breq	.+2      	; 0x1307a <FMenuLocalAccount+0x57e>
   13078:	57 c0       	rjmp	.+174    	; 0x13128 <FMenuLocalAccount+0x62c>
   1307a:	80 91 70 01 	lds	r24, 0x0170
   1307e:	80 32       	cpi	r24, 0x20	; 32
   13080:	09 f4       	brne	.+2      	; 0x13084 <FMenuLocalAccount+0x588>
   13082:	69 c7       	rjmp	.+3794   	; 0x13f56 <FMenuLocalAccount+0x145a>
				    (KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')
					){
				    stLocalAccount=laSelectProduct;
   13084:	8b e0       	ldi	r24, 0x0B	; 11
   13086:	80 93 71 01 	sts	0x0171, r24
					FIP_Used=FIP[KeyCharLast-'1'];
   1308a:	e0 91 70 01 	lds	r30, 0x0170
   1308e:	f0 e0       	ldi	r31, 0x00	; 0
   13090:	e4 59       	subi	r30, 0x94	; 148
   13092:	fc 4f       	sbci	r31, 0xFC	; 252
   13094:	20 81       	ld	r18, Z
   13096:	20 93 91 03 	sts	0x0391, r18
					if (FIP_Used<=99){
   1309a:	24 36       	cpi	r18, 0x64	; 100
   1309c:	08 f0       	brcs	.+2      	; 0x130a0 <FMenuLocalAccount+0x5a4>
   1309e:	5b c7       	rjmp	.+3766   	; 0x13f56 <FMenuLocalAccount+0x145a>
					    //leadingZero(FIP_Used,strFIP);
						//leadingZero(FIP_Used,strFIP_ID);
						sprintf_P(strFIP,PSTR("%.2d"),FIP_Used);
   130a0:	00 d0       	rcall	.+0      	; 0x130a2 <FMenuLocalAccount+0x5a6>
   130a2:	00 d0       	rcall	.+0      	; 0x130a4 <FMenuLocalAccount+0x5a8>
   130a4:	00 d0       	rcall	.+0      	; 0x130a6 <FMenuLocalAccount+0x5aa>
   130a6:	ed b7       	in	r30, 0x3d	; 61
   130a8:	fe b7       	in	r31, 0x3e	; 62
   130aa:	31 96       	adiw	r30, 0x01	; 1
   130ac:	88 eb       	ldi	r24, 0xB8	; 184
   130ae:	93 e0       	ldi	r25, 0x03	; 3
   130b0:	ad b7       	in	r26, 0x3d	; 61
   130b2:	be b7       	in	r27, 0x3e	; 62
   130b4:	12 96       	adiw	r26, 0x02	; 2
   130b6:	9c 93       	st	X, r25
   130b8:	8e 93       	st	-X, r24
   130ba:	11 97       	sbiw	r26, 0x01	; 1
   130bc:	80 e5       	ldi	r24, 0x50	; 80
   130be:	9f e1       	ldi	r25, 0x1F	; 31
   130c0:	93 83       	std	Z+3, r25	; 0x03
   130c2:	82 83       	std	Z+2, r24	; 0x02
   130c4:	24 83       	std	Z+4, r18	; 0x04
   130c6:	15 82       	std	Z+5, r1	; 0x05
   130c8:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
						sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
   130cc:	ed b7       	in	r30, 0x3d	; 61
   130ce:	fe b7       	in	r31, 0x3e	; 62
   130d0:	31 96       	adiw	r30, 0x01	; 1
   130d2:	88 ec       	ldi	r24, 0xC8	; 200
   130d4:	99 e0       	ldi	r25, 0x09	; 9
   130d6:	ad b7       	in	r26, 0x3d	; 61
   130d8:	be b7       	in	r27, 0x3e	; 62
   130da:	12 96       	adiw	r26, 0x02	; 2
   130dc:	9c 93       	st	X, r25
   130de:	8e 93       	st	-X, r24
   130e0:	11 97       	sbiw	r26, 0x01	; 1
   130e2:	8b e4       	ldi	r24, 0x4B	; 75
   130e4:	9f e1       	ldi	r25, 0x1F	; 31
   130e6:	93 83       	std	Z+3, r25	; 0x03
   130e8:	82 83       	std	Z+2, r24	; 0x02
   130ea:	80 91 91 03 	lds	r24, 0x0391
   130ee:	84 83       	std	Z+4, r24	; 0x04
   130f0:	15 82       	std	Z+5, r1	; 0x05
   130f2:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   130f6:	ed b7       	in	r30, 0x3d	; 61
   130f8:	fe b7       	in	r31, 0x3e	; 62
   130fa:	36 96       	adiw	r30, 0x06	; 6
   130fc:	0f b6       	in	r0, 0x3f	; 63
   130fe:	f8 94       	cli
   13100:	fe bf       	out	0x3e, r31	; 62
   13102:	0f be       	out	0x3f, r0	; 63
   13104:	ed bf       	out	0x3d, r30	; 61
   13106:	60 91 70 01 	lds	r22, 0x0170
   1310a:	86 e0       	ldi	r24, 0x06	; 6
   1310c:	68 9f       	mul	r22, r24
   1310e:	b0 01       	movw	r22, r0
   13110:	11 24       	eor	r1, r1
   13112:	61 5d       	subi	r22, 0xD1	; 209
   13114:	70 40       	sbci	r23, 0x00	; 0
   13116:	85 ea       	ldi	r24, 0xA5	; 165
   13118:	93 e0       	ldi	r25, 0x03	; 3
   1311a:	46 e0       	ldi	r20, 0x06	; 6
   1311c:	50 e0       	ldi	r21, 0x00	; 0
   1311e:	2c ea       	ldi	r18, 0xAC	; 172
   13120:	32 e1       	ldi	r19, 0x12	; 18
   13122:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
   13126:	17 c7       	rjmp	.+3630   	; 0x13f56 <FMenuLocalAccount+0x145a>

						eeprom_read_block((void*) &ProductID, (const void*) &DefNozzleMap[(KeyCharLast-'1')], 6);
						}
					}
				else
				if (KeyPressed==_KEY_CANCEL){
   13128:	87 3e       	cpi	r24, 0xE7	; 231
   1312a:	09 f0       	breq	.+2      	; 0x1312e <FMenuLocalAccount+0x632>
   1312c:	14 c7       	rjmp	.+3624   	; 0x13f56 <FMenuLocalAccount+0x145a>
				    stLocalAccount=laDispValid;
   1312e:	87 e0       	ldi	r24, 0x07	; 7
   13130:	3f c4       	rjmp	.+2174   	; 0x139b0 <FMenuLocalAccount+0xeb4>
					}
		        break;
           case laSelectProduct://NozzleID
				lcd_clear();
   13132:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		        sprintf_P(lcdteks,PSTR("Pompa-%s"),strFIP);lcd_print(1,1,lcdteks);
   13136:	00 d0       	rcall	.+0      	; 0x13138 <FMenuLocalAccount+0x63c>
   13138:	00 d0       	rcall	.+0      	; 0x1313a <FMenuLocalAccount+0x63e>
   1313a:	00 d0       	rcall	.+0      	; 0x1313c <FMenuLocalAccount+0x640>
   1313c:	ed b7       	in	r30, 0x3d	; 61
   1313e:	fe b7       	in	r31, 0x3e	; 62
   13140:	31 96       	adiw	r30, 0x01	; 1
   13142:	8e 01       	movw	r16, r28
   13144:	0f 5f       	subi	r16, 0xFF	; 255
   13146:	1f 4f       	sbci	r17, 0xFF	; 255
   13148:	ad b7       	in	r26, 0x3d	; 61
   1314a:	be b7       	in	r27, 0x3e	; 62
   1314c:	12 96       	adiw	r26, 0x02	; 2
   1314e:	1c 93       	st	X, r17
   13150:	0e 93       	st	-X, r16
   13152:	11 97       	sbiw	r26, 0x01	; 1
   13154:	82 e4       	ldi	r24, 0x42	; 66
   13156:	9f e1       	ldi	r25, 0x1F	; 31
   13158:	93 83       	std	Z+3, r25	; 0x03
   1315a:	82 83       	std	Z+2, r24	; 0x02
   1315c:	88 eb       	ldi	r24, 0xB8	; 184
   1315e:	93 e0       	ldi	r25, 0x03	; 3
   13160:	95 83       	std	Z+5, r25	; 0x05
   13162:	84 83       	std	Z+4, r24	; 0x04
   13164:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   13168:	ed b7       	in	r30, 0x3d	; 61
   1316a:	fe b7       	in	r31, 0x3e	; 62
   1316c:	36 96       	adiw	r30, 0x06	; 6
   1316e:	0f b6       	in	r0, 0x3f	; 63
   13170:	f8 94       	cli
   13172:	fe bf       	out	0x3e, r31	; 62
   13174:	0f be       	out	0x3f, r0	; 63
   13176:	ed bf       	out	0x3d, r30	; 61
   13178:	81 e0       	ldi	r24, 0x01	; 1
   1317a:	61 e0       	ldi	r22, 0x01	; 1
   1317c:	a8 01       	movw	r20, r16
   1317e:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
				//Not MPD->Single Product
				if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&
   13182:	90 91 a5 03 	lds	r25, 0x03A5
   13186:	89 2f       	mov	r24, r25
   13188:	81 50       	subi	r24, 0x01	; 1
   1318a:	86 30       	cpi	r24, 0x06	; 6
   1318c:	08 f0       	brcs	.+2      	; 0x13190 <FMenuLocalAccount+0x694>
   1318e:	49 c0       	rjmp	.+146    	; 0x13222 <FMenuLocalAccount+0x726>
   13190:	80 91 a6 03 	lds	r24, 0x03A6
   13194:	88 23       	and	r24, r24
   13196:	09 f0       	breq	.+2      	; 0x1319a <FMenuLocalAccount+0x69e>
   13198:	44 c0       	rjmp	.+136    	; 0x13222 <FMenuLocalAccount+0x726>
   1319a:	80 91 a7 03 	lds	r24, 0x03A7
   1319e:	88 23       	and	r24, r24
   131a0:	09 f0       	breq	.+2      	; 0x131a4 <FMenuLocalAccount+0x6a8>
   131a2:	3f c0       	rjmp	.+126    	; 0x13222 <FMenuLocalAccount+0x726>
   131a4:	80 91 a8 03 	lds	r24, 0x03A8
   131a8:	88 23       	and	r24, r24
   131aa:	d9 f5       	brne	.+118    	; 0x13222 <FMenuLocalAccount+0x726>
   131ac:	6d e0       	ldi	r22, 0x0D	; 13
   131ae:	96 9f       	mul	r25, r22
   131b0:	b0 01       	movw	r22, r0
   131b2:	11 24       	eor	r1, r1
   131b4:	65 51       	subi	r22, 0x15	; 21
   131b6:	7f 4f       	sbci	r23, 0xFF	; 255
   131b8:	82 e9       	ldi	r24, 0x92	; 146
   131ba:	93 e0       	ldi	r25, 0x03	; 3
   131bc:	4a e0       	ldi	r20, 0x0A	; 10
   131be:	50 e0       	ldi	r21, 0x00	; 0
   131c0:	2c ea       	ldi	r18, 0xAC	; 172
   131c2:	32 e1       	ldi	r19, 0x12	; 18
   131c4:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
   131c8:	a2 e9       	ldi	r26, 0x92	; 146
   131ca:	b3 e0       	ldi	r27, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   131cc:	11 96       	adiw	r26, 0x01	; 1
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   131ce:	f3 e0       	ldi	r31, 0x03	; 3
   131d0:	aa 39       	cpi	r26, 0x9A	; 154
   131d2:	bf 07       	cpc	r27, r31
   131d4:	d9 f7       	brne	.-10     	; 0x131cc <FMenuLocalAccount+0x6d0>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   131d6:	1c 92       	st	X, r1
				if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      
					 eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProductID[0]],10);
					 StrPosCopy(ProductName,ProductName,0,8);
					 sprintf_P(strProduct,PSTR("%s"),ProductName);
   131d8:	00 d0       	rcall	.+0      	; 0x131da <FMenuLocalAccount+0x6de>
   131da:	00 d0       	rcall	.+0      	; 0x131dc <FMenuLocalAccount+0x6e0>
   131dc:	00 d0       	rcall	.+0      	; 0x131de <FMenuLocalAccount+0x6e2>
   131de:	2d b7       	in	r18, 0x3d	; 61
   131e0:	3e b7       	in	r19, 0x3e	; 62
   131e2:	2f 5f       	subi	r18, 0xFF	; 255
   131e4:	3f 4f       	sbci	r19, 0xFF	; 255
   131e6:	8d e6       	ldi	r24, 0x6D	; 109
   131e8:	99 e0       	ldi	r25, 0x09	; 9
   131ea:	ed b7       	in	r30, 0x3d	; 61
   131ec:	fe b7       	in	r31, 0x3e	; 62
   131ee:	92 83       	std	Z+2, r25	; 0x02
   131f0:	81 83       	std	Z+1, r24	; 0x01
   131f2:	8f e3       	ldi	r24, 0x3F	; 63
   131f4:	9f e1       	ldi	r25, 0x1F	; 31
   131f6:	f9 01       	movw	r30, r18
   131f8:	93 83       	std	Z+3, r25	; 0x03
   131fa:	82 83       	std	Z+2, r24	; 0x02
   131fc:	18 97       	sbiw	r26, 0x08	; 8
   131fe:	b5 83       	std	Z+5, r27	; 0x05
   13200:	a4 83       	std	Z+4, r26	; 0x04
   13202:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
                     stLocalAccount=laSelectBalanceType;
   13206:	8d e0       	ldi	r24, 0x0D	; 13
   13208:	80 93 71 01 	sts	0x0171, r24
   1320c:	80 e0       	ldi	r24, 0x00	; 0
   1320e:	2d b7       	in	r18, 0x3d	; 61
   13210:	3e b7       	in	r19, 0x3e	; 62
   13212:	2a 5f       	subi	r18, 0xFA	; 250
   13214:	3f 4f       	sbci	r19, 0xFF	; 255
   13216:	0f b6       	in	r0, 0x3f	; 63
   13218:	f8 94       	cli
   1321a:	3e bf       	out	0x3e, r19	; 62
   1321c:	0f be       	out	0x3f, r0	; 63
   1321e:	2d bf       	out	0x3d, r18	; 61
   13220:	9b c6       	rjmp	.+3382   	; 0x13f58 <FMenuLocalAccount+0x145c>
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   13222:	10 92 b5 03 	sts	0x03B5, r1
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   13226:	8e 01       	movw	r16, r28
   13228:	0f 5f       	subi	r16, 0xFF	; 255
   1322a:	1f 4f       	sbci	r17, 0xFF	; 255
   1322c:	93 e3       	ldi	r25, 0x33	; 51
   1322e:	c9 2e       	mov	r12, r25
   13230:	9f e1       	ldi	r25, 0x1F	; 31
   13232:	d9 2e       	mov	r13, r25
   13234:	8d e0       	ldi	r24, 0x0D	; 13
   13236:	a8 2e       	mov	r10, r24
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   13238:	b9 e3       	ldi	r27, 0x39	; 57
   1323a:	eb 2e       	mov	r14, r27
   1323c:	bf e1       	ldi	r27, 0x1F	; 31
   1323e:	fb 2e       	mov	r15, r27
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   13240:	ab e0       	ldi	r26, 0x0B	; 11
   13242:	ba 2e       	mov	r11, r26
   13244:	6b c0       	rjmp	.+214    	; 0x1331c <FMenuLocalAccount+0x820>
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
   13246:	f0 e0       	ldi	r31, 0x00	; 0
   13248:	eb 55       	subi	r30, 0x5B	; 91
   1324a:	fc 4f       	sbci	r31, 0xFC	; 252
   1324c:	e0 81       	ld	r30, Z
   1324e:	e0 93 90 03 	sts	0x0390, r30
					if ((ProdId>=1)&&(ProdId<=6)){
   13252:	8e 2f       	mov	r24, r30
   13254:	81 50       	subi	r24, 0x01	; 1
   13256:	86 30       	cpi	r24, 0x06	; 6
   13258:	e8 f5       	brcc	.+122    	; 0x132d4 <FMenuLocalAccount+0x7d8>
   1325a:	ea 9d       	mul	r30, r10
   1325c:	b0 01       	movw	r22, r0
   1325e:	11 24       	eor	r1, r1
   13260:	62 52       	subi	r22, 0x22	; 34
   13262:	7f 4f       	sbci	r23, 0xFF	; 255
   13264:	82 e9       	ldi	r24, 0x92	; 146
   13266:	93 e0       	ldi	r25, 0x03	; 3
   13268:	4a e0       	ldi	r20, 0x0A	; 10
   1326a:	50 e0       	ldi	r21, 0x00	; 0
   1326c:	2c ea       	ldi	r18, 0xAC	; 172
   1326e:	32 e1       	ldi	r19, 0x12	; 18
   13270:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
   13274:	a2 e9       	ldi	r26, 0x92	; 146
   13276:	b3 e0       	ldi	r27, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   13278:	11 96       	adiw	r26, 0x01	; 1
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1327a:	33 e0       	ldi	r19, 0x03	; 3
   1327c:	aa 39       	cpi	r26, 0x9A	; 154
   1327e:	b3 07       	cpc	r27, r19
   13280:	d9 f7       	brne	.-10     	; 0x13278 <FMenuLocalAccount+0x77c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   13282:	1c 92       	st	X, r1
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   13284:	8d b7       	in	r24, 0x3d	; 61
   13286:	9e b7       	in	r25, 0x3e	; 62
   13288:	08 97       	sbiw	r24, 0x08	; 8
   1328a:	0f b6       	in	r0, 0x3f	; 63
   1328c:	f8 94       	cli
   1328e:	9e bf       	out	0x3e, r25	; 62
   13290:	0f be       	out	0x3f, r0	; 63
   13292:	8d bf       	out	0x3d, r24	; 61
   13294:	2d b7       	in	r18, 0x3d	; 61
   13296:	3e b7       	in	r19, 0x3e	; 62
   13298:	2f 5f       	subi	r18, 0xFF	; 255
   1329a:	3f 4f       	sbci	r19, 0xFF	; 255
   1329c:	ed b7       	in	r30, 0x3d	; 61
   1329e:	fe b7       	in	r31, 0x3e	; 62
   132a0:	12 83       	std	Z+2, r17	; 0x02
   132a2:	01 83       	std	Z+1, r16	; 0x01
   132a4:	f9 01       	movw	r30, r18
   132a6:	f3 82       	std	Z+3, r15	; 0x03
   132a8:	e2 82       	std	Z+2, r14	; 0x02
   132aa:	80 91 b5 03 	lds	r24, 0x03B5
   132ae:	90 e0       	ldi	r25, 0x00	; 0
   132b0:	01 96       	adiw	r24, 0x01	; 1
   132b2:	95 83       	std	Z+5, r25	; 0x05
   132b4:	84 83       	std	Z+4, r24	; 0x04
   132b6:	18 97       	sbiw	r26, 0x08	; 8
   132b8:	b7 83       	std	Z+7, r27	; 0x07
   132ba:	a6 83       	std	Z+6, r26	; 0x06
   132bc:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   132c0:	2d b7       	in	r18, 0x3d	; 61
   132c2:	3e b7       	in	r19, 0x3e	; 62
   132c4:	28 5f       	subi	r18, 0xF8	; 248
   132c6:	3f 4f       	sbci	r19, 0xFF	; 255
   132c8:	0f b6       	in	r0, 0x3f	; 63
   132ca:	f8 94       	cli
   132cc:	3e bf       	out	0x3e, r19	; 62
   132ce:	0f be       	out	0x3f, r0	; 63
   132d0:	2d bf       	out	0x3d, r18	; 61
   132d2:	12 c0       	rjmp	.+36     	; 0x132f8 <FMenuLocalAccount+0x7fc>
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   132d4:	00 d0       	rcall	.+0      	; 0x132d6 <FMenuLocalAccount+0x7da>
   132d6:	00 d0       	rcall	.+0      	; 0x132d8 <FMenuLocalAccount+0x7dc>
   132d8:	ad b7       	in	r26, 0x3d	; 61
   132da:	be b7       	in	r27, 0x3e	; 62
   132dc:	12 96       	adiw	r26, 0x02	; 2
   132de:	1c 93       	st	X, r17
   132e0:	0e 93       	st	-X, r16
   132e2:	11 97       	sbiw	r26, 0x01	; 1
   132e4:	14 96       	adiw	r26, 0x04	; 4
   132e6:	dc 92       	st	X, r13
   132e8:	ce 92       	st	-X, r12
   132ea:	13 97       	sbiw	r26, 0x03	; 3
   132ec:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   132f0:	0f 90       	pop	r0
   132f2:	0f 90       	pop	r0
   132f4:	0f 90       	pop	r0
   132f6:	0f 90       	pop	r0
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   132f8:	80 91 b5 03 	lds	r24, 0x03B5
   132fc:	68 2f       	mov	r22, r24
   132fe:	66 95       	lsr	r22
   13300:	6b 9d       	mul	r22, r11
   13302:	b0 01       	movw	r22, r0
   13304:	11 24       	eor	r1, r1
   13306:	6f 5f       	subi	r22, 0xFF	; 255
   13308:	81 70       	andi	r24, 0x01	; 1
   1330a:	8e 5f       	subi	r24, 0xFE	; 254
   1330c:	a8 01       	movw	r20, r16
   1330e:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
                     stLocalAccount=laSelectBalanceType;
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   13312:	80 91 b5 03 	lds	r24, 0x03B5
   13316:	8f 5f       	subi	r24, 0xFF	; 255
   13318:	80 93 b5 03 	sts	0x03B5, r24
   1331c:	e0 91 b5 03 	lds	r30, 0x03B5
   13320:	e4 30       	cpi	r30, 0x04	; 4
   13322:	08 f4       	brcc	.+2      	; 0x13326 <FMenuLocalAccount+0x82a>
   13324:	90 cf       	rjmp	.-224    	; 0x13246 <FMenuLocalAccount+0x74a>
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
				}
	            lcd_printf(4,1,PSTR("[*]Back             "));   //"[*]Back             "				
   13326:	84 e0       	ldi	r24, 0x04	; 4
   13328:	61 e0       	ldi	r22, 0x01	; 1
   1332a:	4e e1       	ldi	r20, 0x1E	; 30
   1332c:	5f e1       	ldi	r21, 0x1F	; 31
   1332e:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				stLocalAccount=laSelectProductInput;
   13332:	8c e0       	ldi	r24, 0x0C	; 12
   13334:	3d c3       	rjmp	.+1658   	; 0x139b0 <FMenuLocalAccount+0xeb4>
				}
		        break; 
           case laSelectProductInput:
				KeyPressed=_key_scan(1);
   13336:	81 e0       	ldi	r24, 0x01	; 1
   13338:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   1333c:	80 93 b7 03 	sts	0x03B7, r24
			    KeyChar=_key_btn(KeyPressed);
   13340:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   13344:	80 93 bc 03 	sts	0x03BC, r24
				if ((KeyChar>='1')&&(KeyChar<='4')){
   13348:	81 53       	subi	r24, 0x31	; 49
   1334a:	84 30       	cpi	r24, 0x04	; 4
   1334c:	f0 f5       	brcc	.+124    	; 0x133ca <FMenuLocalAccount+0x8ce>
				    iNozzle=KeyChar-'1';
   1334e:	80 93 b5 03 	sts	0x03B5, r24
   13352:	02 e9       	ldi	r16, 0x92	; 146
   13354:	13 e0       	ldi	r17, 0x03	; 3
   13356:	e8 2f       	mov	r30, r24
   13358:	f0 e0       	ldi	r31, 0x00	; 0
   1335a:	eb 55       	subi	r30, 0x5B	; 91
   1335c:	fc 4f       	sbci	r31, 0xFC	; 252
   1335e:	60 81       	ld	r22, Z
   13360:	fd e0       	ldi	r31, 0x0D	; 13
   13362:	ff 2e       	mov	r15, r31
   13364:	6f 9d       	mul	r22, r15
   13366:	b0 01       	movw	r22, r0
   13368:	11 24       	eor	r1, r1
   1336a:	62 52       	subi	r22, 0x22	; 34
   1336c:	7f 4f       	sbci	r23, 0xFF	; 255
   1336e:	c8 01       	movw	r24, r16
   13370:	4a e0       	ldi	r20, 0x0A	; 10
   13372:	50 e0       	ldi	r21, 0x00	; 0
   13374:	2c ea       	ldi	r18, 0xAC	; 172
   13376:	32 e1       	ldi	r19, 0x12	; 18
   13378:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
				    eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProductID[iNozzle]-1],10);
					sprintf_P(strProduct,PSTR("%s"),ProductName);
   1337c:	00 d0       	rcall	.+0      	; 0x1337e <FMenuLocalAccount+0x882>
   1337e:	00 d0       	rcall	.+0      	; 0x13380 <FMenuLocalAccount+0x884>
   13380:	00 d0       	rcall	.+0      	; 0x13382 <FMenuLocalAccount+0x886>
   13382:	ed b7       	in	r30, 0x3d	; 61
   13384:	fe b7       	in	r31, 0x3e	; 62
   13386:	31 96       	adiw	r30, 0x01	; 1
   13388:	8d e6       	ldi	r24, 0x6D	; 109
   1338a:	99 e0       	ldi	r25, 0x09	; 9
   1338c:	ad b7       	in	r26, 0x3d	; 61
   1338e:	be b7       	in	r27, 0x3e	; 62
   13390:	12 96       	adiw	r26, 0x02	; 2
   13392:	9c 93       	st	X, r25
   13394:	8e 93       	st	-X, r24
   13396:	11 97       	sbiw	r26, 0x01	; 1
   13398:	8b e1       	ldi	r24, 0x1B	; 27
   1339a:	9f e1       	ldi	r25, 0x1F	; 31
   1339c:	93 83       	std	Z+3, r25	; 0x03
   1339e:	82 83       	std	Z+2, r24	; 0x02
   133a0:	15 83       	std	Z+5, r17	; 0x05
   133a2:	04 83       	std	Z+4, r16	; 0x04
   133a4:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
					NozzleID=iNozzle+1;
   133a8:	80 91 b5 03 	lds	r24, 0x03B5
   133ac:	8f 5f       	subi	r24, 0xFF	; 255
   133ae:	80 93 7c 09 	sts	0x097C, r24
                    stLocalAccount=laSelectBalanceType;
   133b2:	f0 92 71 01 	sts	0x0171, r15
					lcd_clear();
   133b6:	ed b7       	in	r30, 0x3d	; 61
   133b8:	fe b7       	in	r31, 0x3e	; 62
   133ba:	36 96       	adiw	r30, 0x06	; 6
   133bc:	0f b6       	in	r0, 0x3f	; 63
   133be:	f8 94       	cli
   133c0:	fe bf       	out	0x3e, r31	; 62
   133c2:	0f be       	out	0x3f, r0	; 63
   133c4:	ed bf       	out	0x3d, r30	; 61
   133c6:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
					}                
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laSelectFIP;//Back To Pump Selection
   133ca:	80 91 b7 03 	lds	r24, 0x03B7
   133ce:	87 3e       	cpi	r24, 0xE7	; 231
   133d0:	09 f0       	breq	.+2      	; 0x133d4 <FMenuLocalAccount+0x8d8>
   133d2:	c1 c5       	rjmp	.+2946   	; 0x13f56 <FMenuLocalAccount+0x145a>
   133d4:	89 e0       	ldi	r24, 0x09	; 9
   133d6:	ec c2       	rjmp	.+1496   	; 0x139b0 <FMenuLocalAccount+0xeb4>
		        break;
           case laSelectBalanceType:
		        lcd_clear();
   133d8:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		        sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   133dc:	2d b7       	in	r18, 0x3d	; 61
   133de:	3e b7       	in	r19, 0x3e	; 62
   133e0:	28 50       	subi	r18, 0x08	; 8
   133e2:	30 40       	sbci	r19, 0x00	; 0
   133e4:	0f b6       	in	r0, 0x3f	; 63
   133e6:	f8 94       	cli
   133e8:	3e bf       	out	0x3e, r19	; 62
   133ea:	0f be       	out	0x3f, r0	; 63
   133ec:	2d bf       	out	0x3d, r18	; 61
   133ee:	ed b7       	in	r30, 0x3d	; 61
   133f0:	fe b7       	in	r31, 0x3e	; 62
   133f2:	31 96       	adiw	r30, 0x01	; 1
   133f4:	8e 01       	movw	r16, r28
   133f6:	0f 5f       	subi	r16, 0xFF	; 255
   133f8:	1f 4f       	sbci	r17, 0xFF	; 255
   133fa:	ad b7       	in	r26, 0x3d	; 61
   133fc:	be b7       	in	r27, 0x3e	; 62
   133fe:	12 96       	adiw	r26, 0x02	; 2
   13400:	1c 93       	st	X, r17
   13402:	0e 93       	st	-X, r16
   13404:	11 97       	sbiw	r26, 0x01	; 1
   13406:	83 e1       	ldi	r24, 0x13	; 19
   13408:	9f e1       	ldi	r25, 0x1F	; 31
   1340a:	93 83       	std	Z+3, r25	; 0x03
   1340c:	82 83       	std	Z+2, r24	; 0x02
   1340e:	88 eb       	ldi	r24, 0xB8	; 184
   13410:	93 e0       	ldi	r25, 0x03	; 3
   13412:	95 83       	std	Z+5, r25	; 0x05
   13414:	84 83       	std	Z+4, r24	; 0x04
   13416:	8d e6       	ldi	r24, 0x6D	; 109
   13418:	99 e0       	ldi	r25, 0x09	; 9
   1341a:	97 83       	std	Z+7, r25	; 0x07
   1341c:	86 83       	std	Z+6, r24	; 0x06
   1341e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
				 lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   13422:	ed b7       	in	r30, 0x3d	; 61
   13424:	fe b7       	in	r31, 0x3e	; 62
   13426:	38 96       	adiw	r30, 0x08	; 8
   13428:	0f b6       	in	r0, 0x3f	; 63
   1342a:	f8 94       	cli
   1342c:	fe bf       	out	0x3e, r31	; 62
   1342e:	0f be       	out	0x3f, r0	; 63
   13430:	ed bf       	out	0x3d, r30	; 61
   13432:	81 e0       	ldi	r24, 0x01	; 1
   13434:	61 e0       	ldi	r22, 0x01	; 1
   13436:	a8 01       	movw	r20, r16
   13438:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		        lcd_printf(2,1,PSTR("[1]Volume           "));   //"[1]Premium          "                                                                      
   1343c:	82 e0       	ldi	r24, 0x02	; 2
   1343e:	61 e0       	ldi	r22, 0x01	; 1
   13440:	4e ef       	ldi	r20, 0xFE	; 254
   13442:	5e e1       	ldi	r21, 0x1E	; 30
   13444:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				lcd_printf(3,1,PSTR("[2]Amount           "));   //"[2]Pertamax         "
   13448:	83 e0       	ldi	r24, 0x03	; 3
   1344a:	61 e0       	ldi	r22, 0x01	; 1
   1344c:	49 ee       	ldi	r20, 0xE9	; 233
   1344e:	5e e1       	ldi	r21, 0x1E	; 30
   13450:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
   13454:	84 e0       	ldi	r24, 0x04	; 4
   13456:	61 e0       	ldi	r22, 0x01	; 1
   13458:	44 ed       	ldi	r20, 0xD4	; 212
   1345a:	5e e1       	ldi	r21, 0x1E	; 30
   1345c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	            //lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
                stLocalAccount=laSelectBalanceTypeInput;   
   13460:	8e e0       	ldi	r24, 0x0E	; 14
   13462:	a6 c2       	rjmp	.+1356   	; 0x139b0 <FMenuLocalAccount+0xeb4>
		        break;
           case laSelectBalanceTypeInput:
				KeyPressed=_key_scan(1);
   13464:	81 e0       	ldi	r24, 0x01	; 1
   13466:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   1346a:	80 93 b7 03 	sts	0x03B7, r24
			    KeyChar=_key_btn(KeyPressed);
   1346e:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   13472:	98 2f       	mov	r25, r24
   13474:	80 93 bc 03 	sts	0x03BC, r24
				if ((KeyChar>='1')&&(KeyChar<='2')){
   13478:	81 53       	subi	r24, 0x31	; 49
   1347a:	82 30       	cpi	r24, 0x02	; 2
   1347c:	80 f5       	brcc	.+96     	; 0x134de <FMenuLocalAccount+0x9e2>
                    if(KeyChar=='1'){
   1347e:	91 33       	cpi	r25, 0x31	; 49
   13480:	a1 f4       	brne	.+40     	; 0x134aa <FMenuLocalAccount+0x9ae>
					   BalanceType=1;
   13482:	81 e0       	ldi	r24, 0x01	; 1
   13484:	80 93 bb 03 	sts	0x03BB, r24
					   sprintf_P(strBalanceType,PSTR("V"));
   13488:	00 d0       	rcall	.+0      	; 0x1348a <FMenuLocalAccount+0x98e>
   1348a:	00 d0       	rcall	.+0      	; 0x1348c <FMenuLocalAccount+0x990>
   1348c:	89 ea       	ldi	r24, 0xA9	; 169
   1348e:	95 e0       	ldi	r25, 0x05	; 5
   13490:	ad b7       	in	r26, 0x3d	; 61
   13492:	be b7       	in	r27, 0x3e	; 62
   13494:	12 96       	adiw	r26, 0x02	; 2
   13496:	9c 93       	st	X, r25
   13498:	8e 93       	st	-X, r24
   1349a:	11 97       	sbiw	r26, 0x01	; 1
   1349c:	82 ed       	ldi	r24, 0xD2	; 210
   1349e:	9e e1       	ldi	r25, 0x1E	; 30
   134a0:	14 96       	adiw	r26, 0x04	; 4
   134a2:	9c 93       	st	X, r25
   134a4:	8e 93       	st	-X, r24
   134a6:	13 97       	sbiw	r26, 0x03	; 3
   134a8:	11 c0       	rjmp	.+34     	; 0x134cc <FMenuLocalAccount+0x9d0>
					   }
					else
                    if(KeyChar=='2'){
   134aa:	92 33       	cpi	r25, 0x32	; 50
   134ac:	a9 f4       	brne	.+42     	; 0x134d8 <FMenuLocalAccount+0x9dc>
					   BalanceType=2;
   134ae:	82 e0       	ldi	r24, 0x02	; 2
   134b0:	80 93 bb 03 	sts	0x03BB, r24
                       sprintf_P(strBalanceType,PSTR("A"));
   134b4:	00 d0       	rcall	.+0      	; 0x134b6 <FMenuLocalAccount+0x9ba>
   134b6:	00 d0       	rcall	.+0      	; 0x134b8 <FMenuLocalAccount+0x9bc>
   134b8:	89 ea       	ldi	r24, 0xA9	; 169
   134ba:	95 e0       	ldi	r25, 0x05	; 5
   134bc:	ed b7       	in	r30, 0x3d	; 61
   134be:	fe b7       	in	r31, 0x3e	; 62
   134c0:	92 83       	std	Z+2, r25	; 0x02
   134c2:	81 83       	std	Z+1, r24	; 0x01
   134c4:	80 ed       	ldi	r24, 0xD0	; 208
   134c6:	9e e1       	ldi	r25, 0x1E	; 30
   134c8:	94 83       	std	Z+4, r25	; 0x04
   134ca:	83 83       	std	Z+3, r24	; 0x03
   134cc:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   134d0:	0f 90       	pop	r0
   134d2:	0f 90       	pop	r0
   134d4:	0f 90       	pop	r0
   134d6:	0f 90       	pop	r0
					   }
				    stLocalAccount=laBalanceValue;  
   134d8:	8f e0       	ldi	r24, 0x0F	; 15
   134da:	80 93 71 01 	sts	0x0171, r24
					}              
				if (KeyPressed==_KEY_CANCEL){
   134de:	80 91 b7 03 	lds	r24, 0x03B7
   134e2:	87 3e       	cpi	r24, 0xE7	; 231
   134e4:	c9 f4       	brne	.+50     	; 0x13518 <FMenuLocalAccount+0xa1c>
				    if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&(ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0))
   134e6:	80 91 a5 03 	lds	r24, 0x03A5
   134ea:	81 50       	subi	r24, 0x01	; 1
   134ec:	86 30       	cpi	r24, 0x06	; 6
   134ee:	70 f4       	brcc	.+28     	; 0x1350c <FMenuLocalAccount+0xa10>
   134f0:	80 91 a6 03 	lds	r24, 0x03A6
   134f4:	88 23       	and	r24, r24
   134f6:	51 f4       	brne	.+20     	; 0x1350c <FMenuLocalAccount+0xa10>
   134f8:	80 91 a7 03 	lds	r24, 0x03A7
   134fc:	88 23       	and	r24, r24
   134fe:	31 f4       	brne	.+12     	; 0x1350c <FMenuLocalAccount+0xa10>
   13500:	80 91 a8 03 	lds	r24, 0x03A8
   13504:	88 23       	and	r24, r24
   13506:	11 f4       	brne	.+4      	; 0x1350c <FMenuLocalAccount+0xa10>
					     stLocalAccount=laSelectFIP;//Back To FIP Select Non MPD
   13508:	89 e0       	ldi	r24, 0x09	; 9
   1350a:	01 c0       	rjmp	.+2      	; 0x1350e <FMenuLocalAccount+0xa12>
                    else stLocalAccount=laSelectProduct;//Back To Product Selection MPD
   1350c:	8b e0       	ldi	r24, 0x0B	; 11
   1350e:	80 93 71 01 	sts	0x0171, r24
					lcd_clear();
   13512:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
   13516:	1f c5       	rjmp	.+2622   	; 0x13f56 <FMenuLocalAccount+0x145a>
					}
                else
				if (KeyPressed==_KEY_ENTER){
   13518:	87 3b       	cpi	r24, 0xB7	; 183
   1351a:	09 f0       	breq	.+2      	; 0x1351e <FMenuLocalAccount+0xa22>
   1351c:	1c c5       	rjmp	.+2616   	; 0x13f56 <FMenuLocalAccount+0x145a>
				    BalanceType=1;
   1351e:	11 e0       	ldi	r17, 0x01	; 1
   13520:	10 93 bb 03 	sts	0x03BB, r17
					sprintf_P(strBalanceType,PSTR("A"));
   13524:	00 d0       	rcall	.+0      	; 0x13526 <FMenuLocalAccount+0xa2a>
   13526:	00 d0       	rcall	.+0      	; 0x13528 <FMenuLocalAccount+0xa2c>
   13528:	89 ea       	ldi	r24, 0xA9	; 169
   1352a:	95 e0       	ldi	r25, 0x05	; 5
   1352c:	ad b7       	in	r26, 0x3d	; 61
   1352e:	be b7       	in	r27, 0x3e	; 62
   13530:	12 96       	adiw	r26, 0x02	; 2
   13532:	9c 93       	st	X, r25
   13534:	8e 93       	st	-X, r24
   13536:	11 97       	sbiw	r26, 0x01	; 1
   13538:	8e ec       	ldi	r24, 0xCE	; 206
   1353a:	9e e1       	ldi	r25, 0x1E	; 30
   1353c:	14 96       	adiw	r26, 0x04	; 4
   1353e:	9c 93       	st	X, r25
   13540:	8e 93       	st	-X, r24
   13542:	13 97       	sbiw	r26, 0x03	; 3
   13544:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
					//sprintf_P(strBalanceValue,PSTR("999"));
					IsFullAuthorized=True;
   13548:	10 93 8f 03 	sts	0x038F, r17
                    stLocalAccount=laOdometer;//FullAuthorized
   1354c:	81 e1       	ldi	r24, 0x11	; 17
   1354e:	80 93 71 01 	sts	0x0171, r24
   13552:	80 e0       	ldi	r24, 0x00	; 0
   13554:	0f 90       	pop	r0
   13556:	0f 90       	pop	r0
   13558:	0f 90       	pop	r0
   1355a:	0f 90       	pop	r0
   1355c:	fd c4       	rjmp	.+2554   	; 0x13f58 <FMenuLocalAccount+0x145c>
					}

		        break;
           case laBalanceValue:
		        lcd_clear();
   1355e:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		        if(BalanceType==1){
   13562:	80 91 bb 03 	lds	r24, 0x03BB
   13566:	81 30       	cpi	r24, 0x01	; 1
   13568:	f1 f5       	brne	.+124    	; 0x135e6 <FMenuLocalAccount+0xaea>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   1356a:	ed b7       	in	r30, 0x3d	; 61
   1356c:	fe b7       	in	r31, 0x3e	; 62
   1356e:	38 97       	sbiw	r30, 0x08	; 8
   13570:	0f b6       	in	r0, 0x3f	; 63
   13572:	f8 94       	cli
   13574:	fe bf       	out	0x3e, r31	; 62
   13576:	0f be       	out	0x3f, r0	; 63
   13578:	ed bf       	out	0x3d, r30	; 61
   1357a:	31 96       	adiw	r30, 0x01	; 1
   1357c:	8e 01       	movw	r16, r28
   1357e:	0f 5f       	subi	r16, 0xFF	; 255
   13580:	1f 4f       	sbci	r17, 0xFF	; 255
   13582:	ad b7       	in	r26, 0x3d	; 61
   13584:	be b7       	in	r27, 0x3e	; 62
   13586:	12 96       	adiw	r26, 0x02	; 2
   13588:	1c 93       	st	X, r17
   1358a:	0e 93       	st	-X, r16
   1358c:	11 97       	sbiw	r26, 0x01	; 1
   1358e:	86 ec       	ldi	r24, 0xC6	; 198
   13590:	9e e1       	ldi	r25, 0x1E	; 30
   13592:	93 83       	std	Z+3, r25	; 0x03
   13594:	82 83       	std	Z+2, r24	; 0x02
   13596:	88 eb       	ldi	r24, 0xB8	; 184
   13598:	93 e0       	ldi	r25, 0x03	; 3
   1359a:	95 83       	std	Z+5, r25	; 0x05
   1359c:	84 83       	std	Z+4, r24	; 0x04
   1359e:	8d e6       	ldi	r24, 0x6D	; 109
   135a0:	99 e0       	ldi	r25, 0x09	; 9
   135a2:	97 83       	std	Z+7, r25	; 0x07
   135a4:	86 83       	std	Z+6, r24	; 0x06
   135a6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
				    lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   135aa:	ed b7       	in	r30, 0x3d	; 61
   135ac:	fe b7       	in	r31, 0x3e	; 62
   135ae:	38 96       	adiw	r30, 0x08	; 8
   135b0:	0f b6       	in	r0, 0x3f	; 63
   135b2:	f8 94       	cli
   135b4:	fe bf       	out	0x3e, r31	; 62
   135b6:	0f be       	out	0x3f, r0	; 63
   135b8:	ed bf       	out	0x3d, r30	; 61
   135ba:	81 e0       	ldi	r24, 0x01	; 1
   135bc:	61 e0       	ldi	r22, 0x01	; 1
   135be:	a8 01       	movw	r20, r16
   135c0:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		           lcd_printf(2,1,PSTR("[1]Volume:_         "));   //"[1]Volume:_         "                                                                      
   135c4:	82 e0       	ldi	r24, 0x02	; 2
   135c6:	61 e0       	ldi	r22, 0x01	; 1
   135c8:	41 eb       	ldi	r20, 0xB1	; 177
   135ca:	5e e1       	ldi	r21, 0x1E	; 30
   135cc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				   lcd_printf(3,1,PSTR("                    "));   //"                    "
   135d0:	83 e0       	ldi	r24, 0x03	; 3
   135d2:	61 e0       	ldi	r22, 0x01	; 1
   135d4:	4c e9       	ldi	r20, 0x9C	; 156
   135d6:	5e e1       	ldi	r21, 0x1E	; 30
   135d8:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK     "						        
   135dc:	84 e0       	ldi	r24, 0x04	; 4
   135de:	61 e0       	ldi	r22, 0x01	; 1
   135e0:	47 e8       	ldi	r20, 0x87	; 135
   135e2:	5e e1       	ldi	r21, 0x1E	; 30
   135e4:	43 c0       	rjmp	.+134    	; 0x1366c <FMenuLocalAccount+0xb70>
				   }
                else
		        if(BalanceType==2){
   135e6:	82 30       	cpi	r24, 0x02	; 2
   135e8:	09 f0       	breq	.+2      	; 0x135ec <FMenuLocalAccount+0xaf0>
   135ea:	42 c0       	rjmp	.+132    	; 0x13670 <FMenuLocalAccount+0xb74>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   135ec:	2d b7       	in	r18, 0x3d	; 61
   135ee:	3e b7       	in	r19, 0x3e	; 62
   135f0:	28 50       	subi	r18, 0x08	; 8
   135f2:	30 40       	sbci	r19, 0x00	; 0
   135f4:	0f b6       	in	r0, 0x3f	; 63
   135f6:	f8 94       	cli
   135f8:	3e bf       	out	0x3e, r19	; 62
   135fa:	0f be       	out	0x3f, r0	; 63
   135fc:	2d bf       	out	0x3d, r18	; 61
   135fe:	ed b7       	in	r30, 0x3d	; 61
   13600:	fe b7       	in	r31, 0x3e	; 62
   13602:	31 96       	adiw	r30, 0x01	; 1
   13604:	8e 01       	movw	r16, r28
   13606:	0f 5f       	subi	r16, 0xFF	; 255
   13608:	1f 4f       	sbci	r17, 0xFF	; 255
   1360a:	ad b7       	in	r26, 0x3d	; 61
   1360c:	be b7       	in	r27, 0x3e	; 62
   1360e:	12 96       	adiw	r26, 0x02	; 2
   13610:	1c 93       	st	X, r17
   13612:	0e 93       	st	-X, r16
   13614:	11 97       	sbiw	r26, 0x01	; 1
   13616:	8f e7       	ldi	r24, 0x7F	; 127
   13618:	9e e1       	ldi	r25, 0x1E	; 30
   1361a:	93 83       	std	Z+3, r25	; 0x03
   1361c:	82 83       	std	Z+2, r24	; 0x02
   1361e:	88 eb       	ldi	r24, 0xB8	; 184
   13620:	93 e0       	ldi	r25, 0x03	; 3
   13622:	95 83       	std	Z+5, r25	; 0x05
   13624:	84 83       	std	Z+4, r24	; 0x04
   13626:	8d e6       	ldi	r24, 0x6D	; 109
   13628:	99 e0       	ldi	r25, 0x09	; 9
   1362a:	97 83       	std	Z+7, r25	; 0x07
   1362c:	86 83       	std	Z+6, r24	; 0x06
   1362e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
				   lcd_print(1,1,lcdteks);                         //"P01-Pertamax        "                                                                      
   13632:	ed b7       	in	r30, 0x3d	; 61
   13634:	fe b7       	in	r31, 0x3e	; 62
   13636:	38 96       	adiw	r30, 0x08	; 8
   13638:	0f b6       	in	r0, 0x3f	; 63
   1363a:	f8 94       	cli
   1363c:	fe bf       	out	0x3e, r31	; 62
   1363e:	0f be       	out	0x3f, r0	; 63
   13640:	ed bf       	out	0x3d, r30	; 61
   13642:	81 e0       	ldi	r24, 0x01	; 1
   13644:	61 e0       	ldi	r22, 0x01	; 1
   13646:	a8 01       	movw	r20, r16
   13648:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		           lcd_printf(2,1,PSTR("                    "));   //"                    "                                                                      
   1364c:	82 e0       	ldi	r24, 0x02	; 2
   1364e:	61 e0       	ldi	r22, 0x01	; 1
   13650:	4a e6       	ldi	r20, 0x6A	; 106
   13652:	5e e1       	ldi	r21, 0x1E	; 30
   13654:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				   lcd_printf(3,1,PSTR("[2]Amount:_         "));   //"[2]Amount:_         "
   13658:	83 e0       	ldi	r24, 0x03	; 3
   1365a:	61 e0       	ldi	r22, 0x01	; 1
   1365c:	45 e5       	ldi	r20, 0x55	; 85
   1365e:	5e e1       	ldi	r21, 0x1E	; 30
   13660:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK      "			        
   13664:	84 e0       	ldi	r24, 0x04	; 4
   13666:	61 e0       	ldi	r22, 0x01	; 1
   13668:	40 e4       	ldi	r20, 0x40	; 64
   1366a:	5e e1       	ldi	r21, 0x1E	; 30
   1366c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				   }
                iLoop=0;
   13670:	10 92 8e 03 	sts	0x038E, r1
   13674:	10 92 8d 03 	sts	0x038D, r1
				iValuePos=0;
   13678:	10 92 b6 03 	sts	0x03B6, r1
				ValueChar[iValuePos]=' ';
   1367c:	80 e2       	ldi	r24, 0x20	; 32
   1367e:	80 93 ab 03 	sts	0x03AB, r24
		        stLocalAccount=laBalanceValueInput;  
   13682:	80 e1       	ldi	r24, 0x10	; 16
   13684:	95 c1       	rjmp	.+810    	; 0x139b0 <FMenuLocalAccount+0xeb4>
		        break; 
           case laBalanceValueInput:
			    //Blinking 50% _      BalanceValue Volume=999  Amount=65536
			    iLoop++;
   13686:	80 91 8d 03 	lds	r24, 0x038D
   1368a:	90 91 8e 03 	lds	r25, 0x038E
   1368e:	01 96       	adiw	r24, 0x01	; 1
   13690:	90 93 8e 03 	sts	0x038E, r25
   13694:	80 93 8d 03 	sts	0x038D, r24
			    //GetKeyPressed
			    KeyPressed=_key_scan(1);
   13698:	81 e0       	ldi	r24, 0x01	; 1
   1369a:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   1369e:	80 93 b7 03 	sts	0x03B7, r24
			    KeyChar=_key_btn(KeyPressed);
   136a2:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   136a6:	98 2f       	mov	r25, r24
   136a8:	80 93 bc 03 	sts	0x03BC, r24
				if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<6)&&(BalanceType==2))||//Max Rp.999999
   136ac:	80 53       	subi	r24, 0x30	; 48
   136ae:	8a 30       	cpi	r24, 0x0A	; 10
   136b0:	38 f5       	brcc	.+78     	; 0x13700 <FMenuLocalAccount+0xc04>
   136b2:	e0 91 b6 03 	lds	r30, 0x03B6
   136b6:	e6 30       	cpi	r30, 0x06	; 6
   136b8:	18 f5       	brcc	.+70     	; 0x13700 <FMenuLocalAccount+0xc04>
   136ba:	80 91 bb 03 	lds	r24, 0x03BB
   136be:	82 30       	cpi	r24, 0x02	; 2
   136c0:	21 f0       	breq	.+8      	; 0x136ca <FMenuLocalAccount+0xbce>
   136c2:	e3 30       	cpi	r30, 0x03	; 3
   136c4:	e8 f4       	brcc	.+58     	; 0x13700 <FMenuLocalAccount+0xc04>
   136c6:	81 30       	cpi	r24, 0x01	; 1
   136c8:	d9 f4       	brne	.+54     	; 0x13700 <FMenuLocalAccount+0xc04>
				   ((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<3)&&(BalanceType==1))){ //Max       999L
				    ValueChar[iValuePos]=KeyChar;
   136ca:	f0 e0       	ldi	r31, 0x00	; 0
   136cc:	e5 55       	subi	r30, 0x55	; 85
   136ce:	fc 4f       	sbci	r31, 0xFC	; 252
   136d0:	90 83       	st	Z, r25
					iValuePos++;
   136d2:	60 91 b6 03 	lds	r22, 0x03B6
   136d6:	6f 5f       	subi	r22, 0xFF	; 255
   136d8:	60 93 b6 03 	sts	0x03B6, r22
					lcd_xy(1+BalanceType,(10+iValuePos));_lcd(ValueChar[iValuePos-1]); 
   136dc:	80 91 bb 03 	lds	r24, 0x03BB
   136e0:	66 5f       	subi	r22, 0xF6	; 246
   136e2:	8f 5f       	subi	r24, 0xFF	; 255
   136e4:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
   136e8:	e0 91 b6 03 	lds	r30, 0x03B6
   136ec:	f0 e0       	ldi	r31, 0x00	; 0
   136ee:	e6 55       	subi	r30, 0x56	; 86
   136f0:	fc 4f       	sbci	r31, 0xFC	; 252
   136f2:	80 81       	ld	r24, Z
   136f4:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
   136f8:	80 e5       	ldi	r24, 0x50	; 80
   136fa:	93 ec       	ldi	r25, 0xC3	; 195
   136fc:	01 97       	sbiw	r24, 0x01	; 1
   136fe:	f1 f7       	brne	.-4      	; 0x136fc <FMenuLocalAccount+0xc00>
					_delay_ms(200);
					}
			    if ((iLoop%2000)==0){
   13700:	80 91 8d 03 	lds	r24, 0x038D
   13704:	90 91 8e 03 	lds	r25, 0x038E
   13708:	60 ed       	ldi	r22, 0xD0	; 208
   1370a:	77 e0       	ldi	r23, 0x07	; 7
   1370c:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
   13710:	89 2b       	or	r24, r25
   13712:	59 f4       	brne	.+22     	; 0x1372a <FMenuLocalAccount+0xc2e>
				     lcd_xy((1+BalanceType),(11+iValuePos));_lcd('_'); 
   13714:	80 91 bb 03 	lds	r24, 0x03BB
   13718:	60 91 b6 03 	lds	r22, 0x03B6
   1371c:	65 5f       	subi	r22, 0xF5	; 245
   1371e:	8f 5f       	subi	r24, 0xFF	; 255
   13720:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
   13724:	8f e5       	ldi	r24, 0x5F	; 95
   13726:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
			    }
			    if ((iLoop%2000)==1000){
   1372a:	80 91 8d 03 	lds	r24, 0x038D
   1372e:	90 91 8e 03 	lds	r25, 0x038E
   13732:	60 ed       	ldi	r22, 0xD0	; 208
   13734:	77 e0       	ldi	r23, 0x07	; 7
   13736:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
   1373a:	88 5e       	subi	r24, 0xE8	; 232
   1373c:	93 40       	sbci	r25, 0x03	; 3
   1373e:	59 f4       	brne	.+22     	; 0x13756 <FMenuLocalAccount+0xc5a>
				     lcd_xy((1+BalanceType),(11+iValuePos));_lcd(' '); 
   13740:	80 91 bb 03 	lds	r24, 0x03BB
   13744:	60 91 b6 03 	lds	r22, 0x03B6
   13748:	65 5f       	subi	r22, 0xF5	; 245
   1374a:	8f 5f       	subi	r24, 0xFF	; 255
   1374c:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
   13750:	80 e2       	ldi	r24, 0x20	; 32
   13752:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
			    }
				if (KeyPressed==_KEY_CANCEL){
   13756:	80 91 b7 03 	lds	r24, 0x03B7
   1375a:	87 3e       	cpi	r24, 0xE7	; 231
   1375c:	39 f4       	brne	.+14     	; 0x1376c <FMenuLocalAccount+0xc70>
				    lcd_clear();
   1375e:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
   13762:	88 ea       	ldi	r24, 0xA8	; 168
   13764:	91 e6       	ldi	r25, 0x61	; 97
   13766:	01 97       	sbiw	r24, 0x01	; 1
   13768:	f1 f7       	brne	.-4      	; 0x13766 <FMenuLocalAccount+0xc6a>
   1376a:	1f c1       	rjmp	.+574    	; 0x139aa <FMenuLocalAccount+0xeae>
					_delay_ms(100);		        
				    stLocalAccount=laSelectBalanceType;		        
					}
				else
				if (KeyPressed==_KEY_ENTER){				    
   1376c:	87 3b       	cpi	r24, 0xB7	; 183
   1376e:	09 f0       	breq	.+2      	; 0x13772 <FMenuLocalAccount+0xc76>
   13770:	f2 c3       	rjmp	.+2020   	; 0x13f56 <FMenuLocalAccount+0x145a>
                    ValueChar[iValuePos]=0;
   13772:	e0 91 b6 03 	lds	r30, 0x03B6
   13776:	f0 e0       	ldi	r31, 0x00	; 0
   13778:	e5 55       	subi	r30, 0x55	; 85
   1377a:	fc 4f       	sbci	r31, 0xFC	; 252
   1377c:	10 82       	st	Z, r1
					sprintf_P(strBalanceValue,PSTR("%s"),ValueChar);
   1377e:	00 d0       	rcall	.+0      	; 0x13780 <FMenuLocalAccount+0xc84>
   13780:	00 d0       	rcall	.+0      	; 0x13782 <FMenuLocalAccount+0xc86>
   13782:	00 d0       	rcall	.+0      	; 0x13784 <FMenuLocalAccount+0xc88>
   13784:	ed b7       	in	r30, 0x3d	; 61
   13786:	fe b7       	in	r31, 0x3e	; 62
   13788:	31 96       	adiw	r30, 0x01	; 1
   1378a:	8a e2       	ldi	r24, 0x2A	; 42
   1378c:	9e e0       	ldi	r25, 0x0E	; 14
   1378e:	ad b7       	in	r26, 0x3d	; 61
   13790:	be b7       	in	r27, 0x3e	; 62
   13792:	12 96       	adiw	r26, 0x02	; 2
   13794:	9c 93       	st	X, r25
   13796:	8e 93       	st	-X, r24
   13798:	11 97       	sbiw	r26, 0x01	; 1
   1379a:	8d e3       	ldi	r24, 0x3D	; 61
   1379c:	9e e1       	ldi	r25, 0x1E	; 30
   1379e:	93 83       	std	Z+3, r25	; 0x03
   137a0:	82 83       	std	Z+2, r24	; 0x02
   137a2:	8b ea       	ldi	r24, 0xAB	; 171
   137a4:	93 e0       	ldi	r25, 0x03	; 3
   137a6:	95 83       	std	Z+5, r25	; 0x05
   137a8:	84 83       	std	Z+4, r24	; 0x04
   137aa:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
				    stLocalAccount=laOdometer;
   137ae:	81 e1       	ldi	r24, 0x11	; 17
   137b0:	80 93 71 01 	sts	0x0171, r24
					lcd_clear();
   137b4:	ed b7       	in	r30, 0x3d	; 61
   137b6:	fe b7       	in	r31, 0x3e	; 62
   137b8:	36 96       	adiw	r30, 0x06	; 6
   137ba:	0f b6       	in	r0, 0x3f	; 63
   137bc:	f8 94       	cli
   137be:	fe bf       	out	0x3e, r31	; 62
   137c0:	0f be       	out	0x3f, r0	; 63
   137c2:	ed bf       	out	0x3d, r30	; 61
   137c4:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
   137c8:	88 ea       	ldi	r24, 0xA8	; 168
   137ca:	91 e6       	ldi	r25, 0x61	; 97
   137cc:	01 97       	sbiw	r24, 0x01	; 1
   137ce:	f1 f7       	brne	.-4      	; 0x137cc <FMenuLocalAccount+0xcd0>
   137d0:	c2 c3       	rjmp	.+1924   	; 0x13f56 <FMenuLocalAccount+0x145a>
					_delay_ms(100);		        
					}
		        break;
           case laOdometer://GetOdometer			
		        lcd_clear();
   137d2:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
				if (IsFullAuthorized==True){
   137d6:	80 91 8f 03 	lds	r24, 0x038F
   137da:	81 30       	cpi	r24, 0x01	; 1
   137dc:	09 f0       	breq	.+2      	; 0x137e0 <FMenuLocalAccount+0xce4>
   137de:	4a c0       	rjmp	.+148    	; 0x13874 <FMenuLocalAccount+0xd78>
				    lcd_printf(1,1,PSTR("Pump Product   Full"));
   137e0:	61 e0       	ldi	r22, 0x01	; 1
   137e2:	49 e2       	ldi	r20, 0x29	; 41
   137e4:	5e e1       	ldi	r21, 0x1E	; 30
   137e6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   137ea:	2d b7       	in	r18, 0x3d	; 61
   137ec:	3e b7       	in	r19, 0x3e	; 62
   137ee:	28 50       	subi	r18, 0x08	; 8
   137f0:	30 40       	sbci	r19, 0x00	; 0
   137f2:	0f b6       	in	r0, 0x3f	; 63
   137f4:	f8 94       	cli
   137f6:	3e bf       	out	0x3e, r19	; 62
   137f8:	0f be       	out	0x3f, r0	; 63
   137fa:	2d bf       	out	0x3d, r18	; 61
   137fc:	ed b7       	in	r30, 0x3d	; 61
   137fe:	fe b7       	in	r31, 0x3e	; 62
   13800:	31 96       	adiw	r30, 0x01	; 1
   13802:	8e 01       	movw	r16, r28
   13804:	0f 5f       	subi	r16, 0xFF	; 255
   13806:	1f 4f       	sbci	r17, 0xFF	; 255
   13808:	ad b7       	in	r26, 0x3d	; 61
   1380a:	be b7       	in	r27, 0x3e	; 62
   1380c:	12 96       	adiw	r26, 0x02	; 2
   1380e:	1c 93       	st	X, r17
   13810:	0e 93       	st	-X, r16
   13812:	11 97       	sbiw	r26, 0x01	; 1
   13814:	80 e2       	ldi	r24, 0x20	; 32
   13816:	9e e1       	ldi	r25, 0x1E	; 30
   13818:	93 83       	std	Z+3, r25	; 0x03
   1381a:	82 83       	std	Z+2, r24	; 0x02
   1381c:	88 eb       	ldi	r24, 0xB8	; 184
   1381e:	93 e0       	ldi	r25, 0x03	; 3
   13820:	95 83       	std	Z+5, r25	; 0x05
   13822:	84 83       	std	Z+4, r24	; 0x04
   13824:	8d e6       	ldi	r24, 0x6D	; 109
   13826:	99 e0       	ldi	r25, 0x09	; 9
   13828:	97 83       	std	Z+7, r25	; 0x07
   1382a:	86 83       	std	Z+6, r24	; 0x06
   1382c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   13830:	ed b7       	in	r30, 0x3d	; 61
   13832:	fe b7       	in	r31, 0x3e	; 62
   13834:	38 96       	adiw	r30, 0x08	; 8
   13836:	0f b6       	in	r0, 0x3f	; 63
   13838:	f8 94       	cli
   1383a:	fe bf       	out	0x3e, r31	; 62
   1383c:	0f be       	out	0x3f, r0	; 63
   1383e:	ed bf       	out	0x3d, r30	; 61
   13840:	82 e0       	ldi	r24, 0x02	; 2
   13842:	61 e0       	ldi	r22, 0x01	; 1
   13844:	a8 01       	movw	r20, r16
   13846:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		            sprintf_P(lcdteks,PSTR("  Tank"));            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   1384a:	00 d0       	rcall	.+0      	; 0x1384c <FMenuLocalAccount+0xd50>
   1384c:	00 d0       	rcall	.+0      	; 0x1384e <FMenuLocalAccount+0xd52>
   1384e:	ad b7       	in	r26, 0x3d	; 61
   13850:	be b7       	in	r27, 0x3e	; 62
   13852:	12 96       	adiw	r26, 0x02	; 2
   13854:	1c 93       	st	X, r17
   13856:	0e 93       	st	-X, r16
   13858:	11 97       	sbiw	r26, 0x01	; 1
   1385a:	89 e1       	ldi	r24, 0x19	; 25
   1385c:	9e e1       	ldi	r25, 0x1E	; 30
   1385e:	14 96       	adiw	r26, 0x04	; 4
   13860:	9c 93       	st	X, r25
   13862:	8e 93       	st	-X, r24
   13864:	13 97       	sbiw	r26, 0x03	; 3
   13866:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   1386a:	0f 90       	pop	r0
   1386c:	0f 90       	pop	r0
   1386e:	0f 90       	pop	r0
   13870:	0f 90       	pop	r0
   13872:	5e c0       	rjmp	.+188    	; 0x13930 <FMenuLocalAccount+0xe34>
				}
                else{
		            if (BalanceType==1) lcd_printf(1,1,PSTR("Pump Product Volume"));
   13874:	80 91 bb 03 	lds	r24, 0x03BB
   13878:	81 30       	cpi	r24, 0x01	; 1
   1387a:	29 f4       	brne	.+10     	; 0x13886 <FMenuLocalAccount+0xd8a>
   1387c:	61 e0       	ldi	r22, 0x01	; 1
   1387e:	45 e0       	ldi	r20, 0x05	; 5
   13880:	5e e1       	ldi	r21, 0x1E	; 30
   13882:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
                    if (BalanceType==2) lcd_printf(1,1,PSTR("Pump Product Amount"));//"Pump Product  Amount" 
   13886:	80 91 bb 03 	lds	r24, 0x03BB
   1388a:	82 30       	cpi	r24, 0x02	; 2
   1388c:	31 f4       	brne	.+12     	; 0x1389a <FMenuLocalAccount+0xd9e>
   1388e:	81 e0       	ldi	r24, 0x01	; 1
   13890:	61 e0       	ldi	r22, 0x01	; 1
   13892:	41 ef       	ldi	r20, 0xF1	; 241
   13894:	5d e1       	ldi	r21, 0x1D	; 29
   13896:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   1389a:	ed b7       	in	r30, 0x3d	; 61
   1389c:	fe b7       	in	r31, 0x3e	; 62
   1389e:	38 97       	sbiw	r30, 0x08	; 8
   138a0:	0f b6       	in	r0, 0x3f	; 63
   138a2:	f8 94       	cli
   138a4:	fe bf       	out	0x3e, r31	; 62
   138a6:	0f be       	out	0x3f, r0	; 63
   138a8:	ed bf       	out	0x3d, r30	; 61
   138aa:	31 96       	adiw	r30, 0x01	; 1
   138ac:	8e 01       	movw	r16, r28
   138ae:	0f 5f       	subi	r16, 0xFF	; 255
   138b0:	1f 4f       	sbci	r17, 0xFF	; 255
   138b2:	ad b7       	in	r26, 0x3d	; 61
   138b4:	be b7       	in	r27, 0x3e	; 62
   138b6:	12 96       	adiw	r26, 0x02	; 2
   138b8:	1c 93       	st	X, r17
   138ba:	0e 93       	st	-X, r16
   138bc:	11 97       	sbiw	r26, 0x01	; 1
   138be:	88 ee       	ldi	r24, 0xE8	; 232
   138c0:	9d e1       	ldi	r25, 0x1D	; 29
   138c2:	93 83       	std	Z+3, r25	; 0x03
   138c4:	82 83       	std	Z+2, r24	; 0x02
   138c6:	88 eb       	ldi	r24, 0xB8	; 184
   138c8:	93 e0       	ldi	r25, 0x03	; 3
   138ca:	95 83       	std	Z+5, r25	; 0x05
   138cc:	84 83       	std	Z+4, r24	; 0x04
   138ce:	8d e6       	ldi	r24, 0x6D	; 109
   138d0:	99 e0       	ldi	r25, 0x09	; 9
   138d2:	97 83       	std	Z+7, r25	; 0x07
   138d4:	86 83       	std	Z+6, r24	; 0x06
   138d6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   138da:	ed b7       	in	r30, 0x3d	; 61
   138dc:	fe b7       	in	r31, 0x3e	; 62
   138de:	38 96       	adiw	r30, 0x08	; 8
   138e0:	0f b6       	in	r0, 0x3f	; 63
   138e2:	f8 94       	cli
   138e4:	fe bf       	out	0x3e, r31	; 62
   138e6:	0f be       	out	0x3f, r0	; 63
   138e8:	ed bf       	out	0x3d, r30	; 61
   138ea:	82 e0       	ldi	r24, 0x02	; 2
   138ec:	61 e0       	ldi	r22, 0x01	; 1
   138ee:	a8 01       	movw	r20, r16
   138f0:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		            sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   138f4:	00 d0       	rcall	.+0      	; 0x138f6 <FMenuLocalAccount+0xdfa>
   138f6:	00 d0       	rcall	.+0      	; 0x138f8 <FMenuLocalAccount+0xdfc>
   138f8:	00 d0       	rcall	.+0      	; 0x138fa <FMenuLocalAccount+0xdfe>
   138fa:	ed b7       	in	r30, 0x3d	; 61
   138fc:	fe b7       	in	r31, 0x3e	; 62
   138fe:	31 96       	adiw	r30, 0x01	; 1
   13900:	ad b7       	in	r26, 0x3d	; 61
   13902:	be b7       	in	r27, 0x3e	; 62
   13904:	12 96       	adiw	r26, 0x02	; 2
   13906:	1c 93       	st	X, r17
   13908:	0e 93       	st	-X, r16
   1390a:	11 97       	sbiw	r26, 0x01	; 1
   1390c:	84 ee       	ldi	r24, 0xE4	; 228
   1390e:	9d e1       	ldi	r25, 0x1D	; 29
   13910:	93 83       	std	Z+3, r25	; 0x03
   13912:	82 83       	std	Z+2, r24	; 0x02
   13914:	8a e2       	ldi	r24, 0x2A	; 42
   13916:	9e e0       	ldi	r25, 0x0E	; 14
   13918:	95 83       	std	Z+5, r25	; 0x05
   1391a:	84 83       	std	Z+4, r24	; 0x04
   1391c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   13920:	ed b7       	in	r30, 0x3d	; 61
   13922:	fe b7       	in	r31, 0x3e	; 62
   13924:	36 96       	adiw	r30, 0x06	; 6
   13926:	0f b6       	in	r0, 0x3f	; 63
   13928:	f8 94       	cli
   1392a:	fe bf       	out	0x3e, r31	; 62
   1392c:	0f be       	out	0x3f, r0	; 63
   1392e:	ed bf       	out	0x3d, r30	; 61
   13930:	82 e0       	ldi	r24, 0x02	; 2
   13932:	6e e0       	ldi	r22, 0x0E	; 14
   13934:	a8 01       	movw	r20, r16
   13936:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>

				}
				lcd_printf(3,1,PSTR("Odometer:_       "));                                //"Odometer:_          "
   1393a:	83 e0       	ldi	r24, 0x03	; 3
   1393c:	61 e0       	ldi	r22, 0x01	; 1
   1393e:	42 ed       	ldi	r20, 0xD2	; 210
   13940:	5d e1       	ldi	r21, 0x1D	; 29
   13942:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	            lcd_printf(4,1,PSTR("[*]Back  [#]OK   "));                                //"[*]Back  [#]OK      "						        
   13946:	84 e0       	ldi	r24, 0x04	; 4
   13948:	61 e0       	ldi	r22, 0x01	; 1
   1394a:	40 ec       	ldi	r20, 0xC0	; 192
   1394c:	5d e1       	ldi	r21, 0x1D	; 29
   1394e:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
                //iLoop=0;
				//iValuePos=0;
				//ValueChar[iValuePos]=' ';        
				ClearMem(strOdometer);
   13952:	89 ec       	ldi	r24, 0xC9	; 201
   13954:	95 e0       	ldi	r25, 0x05	; 5
   13956:	0e 94 2b ac 	call	0x15856	; 0x15856 <ClearMem>
		        stLocalAccount=laOdometerInput;
   1395a:	82 e1       	ldi	r24, 0x12	; 18
   1395c:	29 c0       	rjmp	.+82     	; 0x139b0 <FMenuLocalAccount+0xeb4>
		        break;
           case laOdometerInput:
		        //Blinking 50% _      BalanceValue Volume=999  Amount=65536
			    //iLoop++;
				uiResult=UserInput(UI_NUMBER_R,3,10,strOdometer,0,10);
   1395e:	e9 ec       	ldi	r30, 0xC9	; 201
   13960:	ce 2e       	mov	r12, r30
   13962:	e5 e0       	ldi	r30, 0x05	; 5
   13964:	de 2e       	mov	r13, r30
   13966:	81 e0       	ldi	r24, 0x01	; 1
   13968:	63 e0       	ldi	r22, 0x03	; 3
   1396a:	4a e0       	ldi	r20, 0x0A	; 10
   1396c:	96 01       	movw	r18, r12
   1396e:	00 e0       	ldi	r16, 0x00	; 0
   13970:	10 e0       	ldi	r17, 0x00	; 0
   13972:	7a e0       	ldi	r23, 0x0A	; 10
   13974:	e7 2e       	mov	r14, r23
   13976:	0e 94 7b 7d 	call	0xfaf6	; 0xfaf6 <UserInput>
				if (uiResult==USER_OK){
   1397a:	83 30       	cpi	r24, 0x03	; 3
   1397c:	79 f4       	brne	.+30     	; 0x1399c <FMenuLocalAccount+0xea0>
				    if ((strlen(strOdometer)==1)&&(strOdometer[0]=='0'))
   1397e:	f6 01       	movw	r30, r12
   13980:	01 90       	ld	r0, Z+
   13982:	00 20       	and	r0, r0
   13984:	e9 f7       	brne	.-6      	; 0x13980 <FMenuLocalAccount+0xe84>
   13986:	eb 5c       	subi	r30, 0xCB	; 203
   13988:	f5 40       	sbci	r31, 0x05	; 5
   1398a:	31 f4       	brne	.+12     	; 0x13998 <FMenuLocalAccount+0xe9c>
   1398c:	80 91 c9 05 	lds	r24, 0x05C9
   13990:	80 33       	cpi	r24, 0x30	; 48
   13992:	11 f4       	brne	.+4      	; 0x13998 <FMenuLocalAccount+0xe9c>
					    strOdometer[0]=0;
   13994:	10 92 c9 05 	sts	0x05C9, r1

				    stLocalAccount=laDataConfirm;
   13998:	83 e1       	ldi	r24, 0x13	; 19
   1399a:	0a c0       	rjmp	.+20     	; 0x139b0 <FMenuLocalAccount+0xeb4>
					}
			    else
			    if (uiResult==USER_CANCEL){
   1399c:	81 30       	cpi	r24, 0x01	; 1
   1399e:	09 f0       	breq	.+2      	; 0x139a2 <FMenuLocalAccount+0xea6>
   139a0:	da c2       	rjmp	.+1460   	; 0x13f56 <FMenuLocalAccount+0x145a>
				    if (IsFullAuthorized==True)
   139a2:	80 91 8f 03 	lds	r24, 0x038F
   139a6:	81 30       	cpi	r24, 0x01	; 1
   139a8:	11 f4       	brne	.+4      	; 0x139ae <FMenuLocalAccount+0xeb2>
					     stLocalAccount=laSelectBalanceType;
   139aa:	8d e0       	ldi	r24, 0x0D	; 13
   139ac:	01 c0       	rjmp	.+2      	; 0x139b0 <FMenuLocalAccount+0xeb4>
					else stLocalAccount=laBalanceValue;		        
   139ae:	8f e0       	ldi	r24, 0x0F	; 15
   139b0:	80 93 71 01 	sts	0x0171, r24
   139b4:	d0 c2       	rjmp	.+1440   	; 0x13f56 <FMenuLocalAccount+0x145a>
					}
                */

		        break;
           case laDataConfirm: 
		        lcd_clear();
   139b6:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
   139ba:	e3 e3       	ldi	r30, 0x33	; 51
   139bc:	f5 e0       	ldi	r31, 0x05	; 5
   139be:	de 01       	movw	r26, r28
   139c0:	55 96       	adiw	r26, 0x15	; 21
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
   139c2:	81 91       	ld	r24, Z+
   139c4:	8d 93       	st	X+, r24
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
   139c6:	35 e0       	ldi	r19, 0x05	; 5
   139c8:	ed 33       	cpi	r30, 0x3D	; 61
   139ca:	f3 07       	cpc	r31, r19
   139cc:	d1 f7       	brne	.-12     	; 0x139c2 <FMenuLocalAccount+0xec6>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
   139ce:	1f 8e       	std	Y+31, r1	; 0x1f

		        break;
           case laDataConfirm: 
		        lcd_clear();
		        StringCopyPos(strCardHolder,strName,9,10);                                          //Data Confirmation   
                sprintf_P(lcdteks,PSTR("%s "),strName);                  lcd_print(1,1,lcdteks);    //"Iyan The Man        "
   139d0:	00 d0       	rcall	.+0      	; 0x139d2 <FMenuLocalAccount+0xed6>
   139d2:	00 d0       	rcall	.+0      	; 0x139d4 <FMenuLocalAccount+0xed8>
   139d4:	00 d0       	rcall	.+0      	; 0x139d6 <FMenuLocalAccount+0xeda>
   139d6:	ed b7       	in	r30, 0x3d	; 61
   139d8:	fe b7       	in	r31, 0x3e	; 62
   139da:	31 96       	adiw	r30, 0x01	; 1
   139dc:	8e 01       	movw	r16, r28
   139de:	0f 5f       	subi	r16, 0xFF	; 255
   139e0:	1f 4f       	sbci	r17, 0xFF	; 255
   139e2:	ad b7       	in	r26, 0x3d	; 61
   139e4:	be b7       	in	r27, 0x3e	; 62
   139e6:	12 96       	adiw	r26, 0x02	; 2
   139e8:	1c 93       	st	X, r17
   139ea:	0e 93       	st	-X, r16
   139ec:	11 97       	sbiw	r26, 0x01	; 1
   139ee:	8c eb       	ldi	r24, 0xBC	; 188
   139f0:	9d e1       	ldi	r25, 0x1D	; 29
   139f2:	93 83       	std	Z+3, r25	; 0x03
   139f4:	82 83       	std	Z+2, r24	; 0x02
   139f6:	ce 01       	movw	r24, r28
   139f8:	45 96       	adiw	r24, 0x15	; 21
   139fa:	95 83       	std	Z+5, r25	; 0x05
   139fc:	84 83       	std	Z+4, r24	; 0x04
   139fe:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   13a02:	ed b7       	in	r30, 0x3d	; 61
   13a04:	fe b7       	in	r31, 0x3e	; 62
   13a06:	36 96       	adiw	r30, 0x06	; 6
   13a08:	0f b6       	in	r0, 0x3f	; 63
   13a0a:	f8 94       	cli
   13a0c:	fe bf       	out	0x3e, r31	; 62
   13a0e:	0f be       	out	0x3f, r0	; 63
   13a10:	ed bf       	out	0x3d, r30	; 61
   13a12:	81 e0       	ldi	r24, 0x01	; 1
   13a14:	61 e0       	ldi	r22, 0x01	; 1
   13a16:	a8 01       	movw	r20, r16
   13a18:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		        sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);             lcd_print(2,1,lcdteks);    //"ID1CCDA565 OD:123456"
   13a1c:	00 d0       	rcall	.+0      	; 0x13a1e <FMenuLocalAccount+0xf22>
   13a1e:	00 d0       	rcall	.+0      	; 0x13a20 <FMenuLocalAccount+0xf24>
   13a20:	00 d0       	rcall	.+0      	; 0x13a22 <FMenuLocalAccount+0xf26>
   13a22:	ed b7       	in	r30, 0x3d	; 61
   13a24:	fe b7       	in	r31, 0x3e	; 62
   13a26:	31 96       	adiw	r30, 0x01	; 1
   13a28:	ad b7       	in	r26, 0x3d	; 61
   13a2a:	be b7       	in	r27, 0x3e	; 62
   13a2c:	12 96       	adiw	r26, 0x02	; 2
   13a2e:	1c 93       	st	X, r17
   13a30:	0e 93       	st	-X, r16
   13a32:	11 97       	sbiw	r26, 0x01	; 1
   13a34:	85 eb       	ldi	r24, 0xB5	; 181
   13a36:	9d e1       	ldi	r25, 0x1D	; 29
   13a38:	93 83       	std	Z+3, r25	; 0x03
   13a3a:	82 83       	std	Z+2, r24	; 0x02
   13a3c:	81 e9       	ldi	r24, 0x91	; 145
   13a3e:	9d e0       	ldi	r25, 0x0D	; 13
   13a40:	95 83       	std	Z+5, r25	; 0x05
   13a42:	84 83       	std	Z+4, r24	; 0x04
   13a44:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   13a48:	ed b7       	in	r30, 0x3d	; 61
   13a4a:	fe b7       	in	r31, 0x3e	; 62
   13a4c:	36 96       	adiw	r30, 0x06	; 6
   13a4e:	0f b6       	in	r0, 0x3f	; 63
   13a50:	f8 94       	cli
   13a52:	fe bf       	out	0x3e, r31	; 62
   13a54:	0f be       	out	0x3f, r0	; 63
   13a56:	ed bf       	out	0x3d, r30	; 61
   13a58:	82 e0       	ldi	r24, 0x02	; 2
   13a5a:	61 e0       	ldi	r22, 0x01	; 1
   13a5c:	a8 01       	movw	r20, r16
   13a5e:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
				sprintf_P(lcdteks,PSTR("%s  %s "),strFIP,strProduct);    lcd_print(3,1,lcdteks);    //"P01  Pertamax 500000"
   13a62:	2d b7       	in	r18, 0x3d	; 61
   13a64:	3e b7       	in	r19, 0x3e	; 62
   13a66:	28 50       	subi	r18, 0x08	; 8
   13a68:	30 40       	sbci	r19, 0x00	; 0
   13a6a:	0f b6       	in	r0, 0x3f	; 63
   13a6c:	f8 94       	cli
   13a6e:	3e bf       	out	0x3e, r19	; 62
   13a70:	0f be       	out	0x3f, r0	; 63
   13a72:	2d bf       	out	0x3d, r18	; 61
   13a74:	ed b7       	in	r30, 0x3d	; 61
   13a76:	fe b7       	in	r31, 0x3e	; 62
   13a78:	31 96       	adiw	r30, 0x01	; 1
   13a7a:	ad b7       	in	r26, 0x3d	; 61
   13a7c:	be b7       	in	r27, 0x3e	; 62
   13a7e:	12 96       	adiw	r26, 0x02	; 2
   13a80:	1c 93       	st	X, r17
   13a82:	0e 93       	st	-X, r16
   13a84:	11 97       	sbiw	r26, 0x01	; 1
   13a86:	8d ea       	ldi	r24, 0xAD	; 173
   13a88:	9d e1       	ldi	r25, 0x1D	; 29
   13a8a:	93 83       	std	Z+3, r25	; 0x03
   13a8c:	82 83       	std	Z+2, r24	; 0x02
   13a8e:	88 eb       	ldi	r24, 0xB8	; 184
   13a90:	93 e0       	ldi	r25, 0x03	; 3
   13a92:	95 83       	std	Z+5, r25	; 0x05
   13a94:	84 83       	std	Z+4, r24	; 0x04
   13a96:	8d e6       	ldi	r24, 0x6D	; 109
   13a98:	99 e0       	ldi	r25, 0x09	; 9
   13a9a:	97 83       	std	Z+7, r25	; 0x07
   13a9c:	86 83       	std	Z+6, r24	; 0x06
   13a9e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   13aa2:	ed b7       	in	r30, 0x3d	; 61
   13aa4:	fe b7       	in	r31, 0x3e	; 62
   13aa6:	38 96       	adiw	r30, 0x08	; 8
   13aa8:	0f b6       	in	r0, 0x3f	; 63
   13aaa:	f8 94       	cli
   13aac:	fe bf       	out	0x3e, r31	; 62
   13aae:	0f be       	out	0x3f, r0	; 63
   13ab0:	ed bf       	out	0x3d, r30	; 61
   13ab2:	83 e0       	ldi	r24, 0x03	; 3
   13ab4:	61 e0       	ldi	r22, 0x01	; 1
   13ab6:	a8 01       	movw	r20, r16
   13ab8:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		        if (IsFullAuthorized==True){
   13abc:	80 91 8f 03 	lds	r24, 0x038F
   13ac0:	81 30       	cpi	r24, 0x01	; 1
   13ac2:	39 f4       	brne	.+14     	; 0x13ad2 <FMenuLocalAccount+0xfd6>
                    lcd_printf(3,15,PSTR(" Full"));
   13ac4:	83 e0       	ldi	r24, 0x03	; 3
   13ac6:	6f e0       	ldi	r22, 0x0F	; 15
   13ac8:	47 ea       	ldi	r20, 0xA7	; 167
   13aca:	5d e1       	ldi	r21, 0x1D	; 29
   13acc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
   13ad0:	23 c0       	rjmp	.+70     	; 0x13b18 <FMenuLocalAccount+0x101c>
				}
				else {
				    sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);          lcd_print(3,15,lcdteks);   //"[*]Back [0]ESC [#]OK " 
   13ad2:	00 d0       	rcall	.+0      	; 0x13ad4 <FMenuLocalAccount+0xfd8>
   13ad4:	00 d0       	rcall	.+0      	; 0x13ad6 <FMenuLocalAccount+0xfda>
   13ad6:	00 d0       	rcall	.+0      	; 0x13ad8 <FMenuLocalAccount+0xfdc>
   13ad8:	ed b7       	in	r30, 0x3d	; 61
   13ada:	fe b7       	in	r31, 0x3e	; 62
   13adc:	31 96       	adiw	r30, 0x01	; 1
   13ade:	ad b7       	in	r26, 0x3d	; 61
   13ae0:	be b7       	in	r27, 0x3e	; 62
   13ae2:	12 96       	adiw	r26, 0x02	; 2
   13ae4:	1c 93       	st	X, r17
   13ae6:	0e 93       	st	-X, r16
   13ae8:	11 97       	sbiw	r26, 0x01	; 1
   13aea:	83 ea       	ldi	r24, 0xA3	; 163
   13aec:	9d e1       	ldi	r25, 0x1D	; 29
   13aee:	93 83       	std	Z+3, r25	; 0x03
   13af0:	82 83       	std	Z+2, r24	; 0x02
   13af2:	8a e2       	ldi	r24, 0x2A	; 42
   13af4:	9e e0       	ldi	r25, 0x0E	; 14
   13af6:	95 83       	std	Z+5, r25	; 0x05
   13af8:	84 83       	std	Z+4, r24	; 0x04
   13afa:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   13afe:	ed b7       	in	r30, 0x3d	; 61
   13b00:	fe b7       	in	r31, 0x3e	; 62
   13b02:	36 96       	adiw	r30, 0x06	; 6
   13b04:	0f b6       	in	r0, 0x3f	; 63
   13b06:	f8 94       	cli
   13b08:	fe bf       	out	0x3e, r31	; 62
   13b0a:	0f be       	out	0x3f, r0	; 63
   13b0c:	ed bf       	out	0x3d, r30	; 61
   13b0e:	83 e0       	ldi	r24, 0x03	; 3
   13b10:	6f e0       	ldi	r22, 0x0F	; 15
   13b12:	a8 01       	movw	r20, r16
   13b14:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
					}
	            lcd_printf(4,1,PSTR("[*]Back [0]ESC [#]OK"));    
   13b18:	84 e0       	ldi	r24, 0x04	; 4
   13b1a:	61 e0       	ldi	r22, 0x01	; 1
   13b1c:	4e e8       	ldi	r20, 0x8E	; 142
   13b1e:	5d e1       	ldi	r21, 0x1D	; 29
   13b20:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
                stLocalAccount=laDataConfirmInput;
   13b24:	84 e1       	ldi	r24, 0x14	; 20
   13b26:	44 cf       	rjmp	.-376    	; 0x139b0 <FMenuLocalAccount+0xeb4>
                //while(1){};   
		        break;
           case laDataConfirmInput:
                KeyPressed=_key_scan(1);
   13b28:	81 e0       	ldi	r24, 0x01	; 1
   13b2a:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   13b2e:	80 93 b7 03 	sts	0x03B7, r24
                if (KeyPressed==_KEY_CANCEL)stLocalAccount=laOdometer;		        
   13b32:	87 3e       	cpi	r24, 0xE7	; 231
   13b34:	11 f4       	brne	.+4      	; 0x13b3a <FMenuLocalAccount+0x103e>
   13b36:	81 e1       	ldi	r24, 0x11	; 17
   13b38:	3b cf       	rjmp	.-394    	; 0x139b0 <FMenuLocalAccount+0xeb4>
				else
				if (KeyPressed==_KEY_ENTER)stLocalAccount=laProceedTransaction;
   13b3a:	87 3b       	cpi	r24, 0xB7	; 183
   13b3c:	11 f4       	brne	.+4      	; 0x13b42 <FMenuLocalAccount+0x1046>
   13b3e:	85 e1       	ldi	r24, 0x15	; 21
   13b40:	37 cf       	rjmp	.-402    	; 0x139b0 <FMenuLocalAccount+0xeb4>
				else
				if (KeyPressed==_KEY_0){
   13b42:	87 3d       	cpi	r24, 0xD7	; 215
   13b44:	09 f0       	breq	.+2      	; 0x13b48 <FMenuLocalAccount+0x104c>
   13b46:	07 c2       	rjmp	.+1038   	; 0x13f56 <FMenuLocalAccount+0x145a>
				   //ShowCancel
				   TimLocAcc=0;
   13b48:	10 92 e8 01 	sts	0x01E8, r1
   13b4c:	10 92 e7 01 	sts	0x01E7, r1
                   lcd_clear();
   13b50:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
				   lcd_printf(1,1,PSTR("Cancel Transaction  "));    //"Cancel Transaction"
   13b54:	81 e0       	ldi	r24, 0x01	; 1
   13b56:	61 e0       	ldi	r22, 0x01	; 1
   13b58:	49 e7       	ldi	r20, 0x79	; 121
   13b5a:	5d e1       	ldi	r21, 0x1D	; 29
   13b5c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
   13b60:	e9 c1       	rjmp	.+978    	; 0x13f34 <FMenuLocalAccount+0x1438>
				   stLocalAccount=laDelayExit;
				   }
		        break;
           case laProceedTransaction:
		        sendMessage58();
   13b62:	0e 94 0d 4e 	call	0x9c1a	; 0x9c1a <sendMessage58>
                RemZeroLead(strCardID);
   13b66:	81 e9       	ldi	r24, 0x91	; 145
   13b68:	9d e0       	ldi	r25, 0x0D	; 13
   13b6a:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
                RemZeroLead(strBalanceValue);
   13b6e:	6a e2       	ldi	r22, 0x2A	; 42
   13b70:	e6 2e       	mov	r14, r22
   13b72:	6e e0       	ldi	r22, 0x0E	; 14
   13b74:	f6 2e       	mov	r15, r22
   13b76:	c7 01       	movw	r24, r14
   13b78:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
				sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct);       lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   13b7c:	2d b7       	in	r18, 0x3d	; 61
   13b7e:	3e b7       	in	r19, 0x3e	; 62
   13b80:	28 50       	subi	r18, 0x08	; 8
   13b82:	30 40       	sbci	r19, 0x00	; 0
   13b84:	0f b6       	in	r0, 0x3f	; 63
   13b86:	f8 94       	cli
   13b88:	3e bf       	out	0x3e, r19	; 62
   13b8a:	0f be       	out	0x3f, r0	; 63
   13b8c:	2d bf       	out	0x3d, r18	; 61
   13b8e:	ed b7       	in	r30, 0x3d	; 61
   13b90:	fe b7       	in	r31, 0x3e	; 62
   13b92:	31 96       	adiw	r30, 0x01	; 1
   13b94:	8e 01       	movw	r16, r28
   13b96:	0f 5f       	subi	r16, 0xFF	; 255
   13b98:	1f 4f       	sbci	r17, 0xFF	; 255
   13b9a:	ad b7       	in	r26, 0x3d	; 61
   13b9c:	be b7       	in	r27, 0x3e	; 62
   13b9e:	12 96       	adiw	r26, 0x02	; 2
   13ba0:	1c 93       	st	X, r17
   13ba2:	0e 93       	st	-X, r16
   13ba4:	11 97       	sbiw	r26, 0x01	; 1
   13ba6:	81 e7       	ldi	r24, 0x71	; 113
   13ba8:	9d e1       	ldi	r25, 0x1D	; 29
   13baa:	93 83       	std	Z+3, r25	; 0x03
   13bac:	82 83       	std	Z+2, r24	; 0x02
   13bae:	88 eb       	ldi	r24, 0xB8	; 184
   13bb0:	93 e0       	ldi	r25, 0x03	; 3
   13bb2:	95 83       	std	Z+5, r25	; 0x05
   13bb4:	84 83       	std	Z+4, r24	; 0x04
   13bb6:	8d e6       	ldi	r24, 0x6D	; 109
   13bb8:	99 e0       	ldi	r25, 0x09	; 9
   13bba:	97 83       	std	Z+7, r25	; 0x07
   13bbc:	86 83       	std	Z+6, r24	; 0x06
   13bbe:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   13bc2:	ed b7       	in	r30, 0x3d	; 61
   13bc4:	fe b7       	in	r31, 0x3e	; 62
   13bc6:	38 96       	adiw	r30, 0x08	; 8
   13bc8:	0f b6       	in	r0, 0x3f	; 63
   13bca:	f8 94       	cli
   13bcc:	fe bf       	out	0x3e, r31	; 62
   13bce:	0f be       	out	0x3f, r0	; 63
   13bd0:	ed bf       	out	0x3d, r30	; 61
   13bd2:	81 e0       	ldi	r24, 0x01	; 1
   13bd4:	61 e0       	ldi	r22, 0x01	; 1
   13bd6:	a8 01       	movw	r20, r16
   13bd8:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);              lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   13bdc:	00 d0       	rcall	.+0      	; 0x13bde <FMenuLocalAccount+0x10e2>
   13bde:	00 d0       	rcall	.+0      	; 0x13be0 <FMenuLocalAccount+0x10e4>
   13be0:	00 d0       	rcall	.+0      	; 0x13be2 <FMenuLocalAccount+0x10e6>
   13be2:	ed b7       	in	r30, 0x3d	; 61
   13be4:	fe b7       	in	r31, 0x3e	; 62
   13be6:	31 96       	adiw	r30, 0x01	; 1
   13be8:	ad b7       	in	r26, 0x3d	; 61
   13bea:	be b7       	in	r27, 0x3e	; 62
   13bec:	12 96       	adiw	r26, 0x02	; 2
   13bee:	1c 93       	st	X, r17
   13bf0:	0e 93       	st	-X, r16
   13bf2:	11 97       	sbiw	r26, 0x01	; 1
   13bf4:	8e e6       	ldi	r24, 0x6E	; 110
   13bf6:	9d e1       	ldi	r25, 0x1D	; 29
   13bf8:	93 83       	std	Z+3, r25	; 0x03
   13bfa:	82 83       	std	Z+2, r24	; 0x02
   13bfc:	f5 82       	std	Z+5, r15	; 0x05
   13bfe:	e4 82       	std	Z+4, r14	; 0x04
   13c00:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   13c04:	ed b7       	in	r30, 0x3d	; 61
   13c06:	fe b7       	in	r31, 0x3e	; 62
   13c08:	36 96       	adiw	r30, 0x06	; 6
   13c0a:	0f b6       	in	r0, 0x3f	; 63
   13c0c:	f8 94       	cli
   13c0e:	fe bf       	out	0x3e, r31	; 62
   13c10:	0f be       	out	0x3f, r0	; 63
   13c12:	ed bf       	out	0x3d, r30	; 61
   13c14:	81 e0       	ldi	r24, 0x01	; 1
   13c16:	6f e0       	ldi	r22, 0x0F	; 15
   13c18:	a8 01       	movw	r20, r16
   13c1a:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
                lcd_printf(3,1,PSTR("Mohon Tunggu        "));                                         //"Mohon Tunggu ...    "
   13c1e:	83 e0       	ldi	r24, 0x03	; 3
   13c20:	61 e0       	ldi	r22, 0x01	; 1
   13c22:	49 e5       	ldi	r20, 0x59	; 89
   13c24:	5d e1       	ldi	r21, 0x1D	; 29
   13c26:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		        lcd_printf(4,1,PSTR("                    "));                                  //"                    "
   13c2a:	84 e0       	ldi	r24, 0x04	; 4
   13c2c:	61 e0       	ldi	r22, 0x01	; 1
   13c2e:	44 e4       	ldi	r20, 0x44	; 68
   13c30:	5d e1       	ldi	r21, 0x1D	; 29
   13c32:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				IsMessage00=False;
   13c36:	10 92 cb 01 	sts	0x01CB, r1
				TimLocAcc=0;
   13c3a:	10 92 e8 01 	sts	0x01E8, r1
   13c3e:	10 92 e7 01 	sts	0x01E7, r1
				iLoop=0;iPos=0;iWait=0;
   13c42:	10 92 8e 03 	sts	0x038E, r1
   13c46:	10 92 8d 03 	sts	0x038D, r1
   13c4a:	10 92 be 03 	sts	0x03BE, r1
   13c4e:	10 92 bd 03 	sts	0x03BD, r1
				stLocalAccount=laWaitMessage00;
   13c52:	87 e1       	ldi	r24, 0x17	; 23
   13c54:	ad ce       	rjmp	.-678    	; 0x139b0 <FMenuLocalAccount+0xeb4>
		        break;
           case laWaitMessage00:
                iLoop++;
   13c56:	80 91 8d 03 	lds	r24, 0x038D
   13c5a:	90 91 8e 03 	lds	r25, 0x038E
   13c5e:	01 96       	adiw	r24, 0x01	; 1
   13c60:	90 93 8e 03 	sts	0x038E, r25
   13c64:	80 93 8d 03 	sts	0x038D, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   13c68:	68 e9       	ldi	r22, 0x98	; 152
   13c6a:	7a e3       	ldi	r23, 0x3A	; 58
   13c6c:	0e 94 bc b7 	call	0x16f78	; 0x16f78 <__udivmodhi4>
   13c70:	89 2b       	or	r24, r25
   13c72:	e1 f4       	brne	.+56     	; 0x13cac <FMenuLocalAccount+0x11b0>
				   if (iPos<5){
   13c74:	60 91 be 03 	lds	r22, 0x03BE
   13c78:	65 30       	cpi	r22, 0x05	; 5
   13c7a:	58 f4       	brcc	.+22     	; 0x13c92 <FMenuLocalAccount+0x1196>
				       iPos++;
   13c7c:	6f 5f       	subi	r22, 0xFF	; 255
   13c7e:	60 93 be 03 	sts	0x03BE, r22
					   lcd_xy(3,(14+iPos));_lcd('.');
   13c82:	62 5f       	subi	r22, 0xF2	; 242
   13c84:	83 e0       	ldi	r24, 0x03	; 3
   13c86:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
   13c8a:	8e e2       	ldi	r24, 0x2E	; 46
   13c8c:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
   13c90:	0d c0       	rjmp	.+26     	; 0x13cac <FMenuLocalAccount+0x11b0>
					   }
				   else{
				       iPos=0;
   13c92:	10 92 be 03 	sts	0x03BE, r1
					   lcd_printf(3,(14+iPos),PSTR("       "));
   13c96:	83 e0       	ldi	r24, 0x03	; 3
   13c98:	6e e0       	ldi	r22, 0x0E	; 14
   13c9a:	4c e3       	ldi	r20, 0x3C	; 60
   13c9c:	5d e1       	ldi	r21, 0x1D	; 29
   13c9e:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
					   iWait++;
   13ca2:	80 91 bd 03 	lds	r24, 0x03BD
   13ca6:	8f 5f       	subi	r24, 0xFF	; 255
   13ca8:	80 93 bd 03 	sts	0x03BD, r24
					   }
				}
				if (iWait>5){
   13cac:	80 91 bd 03 	lds	r24, 0x03BD
   13cb0:	86 30       	cpi	r24, 0x06	; 6
   13cb2:	78 f0       	brcs	.+30     	; 0x13cd2 <FMenuLocalAccount+0x11d6>
				    stLocalAccount=laConTimout;
   13cb4:	84 e0       	ldi	r24, 0x04	; 4
   13cb6:	80 93 71 01 	sts	0x0171, r24
					TimLocAcc=0;
   13cba:	10 92 e8 01 	sts	0x01E8, r1
   13cbe:	10 92 e7 01 	sts	0x01E7, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   13cc2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   13cc4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   13cc6:	82 e0       	ldi	r24, 0x02	; 2
   13cc8:	90 e0       	ldi	r25, 0x00	; 0
   13cca:	90 93 ec 01 	sts	0x01EC, r25
   13cce:	80 93 eb 01 	sts	0x01EB, r24
				if (iWait>5){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage00==True){
   13cd2:	80 91 cb 01 	lds	r24, 0x01CB
   13cd6:	81 30       	cpi	r24, 0x01	; 1
   13cd8:	09 f0       	breq	.+2      	; 0x13cdc <FMenuLocalAccount+0x11e0>
   13cda:	3d c1       	rjmp	.+634    	; 0x13f56 <FMenuLocalAccount+0x145a>
                    IsMessage00=False;
   13cdc:	10 92 cb 01 	sts	0x01CB, r1
				    stLocalAccount=laProcMessage00;
   13ce0:	88 e1       	ldi	r24, 0x18	; 24
   13ce2:	66 ce       	rjmp	.-820    	; 0x139b0 <FMenuLocalAccount+0xeb4>
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   13ce4:	80 91 25 0b 	lds	r24, 0x0B25
   13ce8:	81 30       	cpi	r24, 0x01	; 1
   13cea:	51 f4       	brne	.+20     	; 0x13d00 <FMenuLocalAccount+0x1204>
   13cec:	80 91 b3 01 	lds	r24, 0x01B3
   13cf0:	90 91 b4 01 	lds	r25, 0x01B4
   13cf4:	8f 97       	sbiw	r24, 0x2f	; 47
   13cf6:	21 f4       	brne	.+8      	; 0x13d00 <FMenuLocalAccount+0x1204>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
   13cf8:	80 91 4a 0b 	lds	r24, 0x0B4A
   13cfc:	80 53       	subi	r24, 0x30	; 48
   13cfe:	01 c0       	rjmp	.+2      	; 0x13d02 <FMenuLocalAccount+0x1206>
   13d00:	80 e0       	ldi	r24, 0x00	; 0
                    IsMessage00=False;
				    stLocalAccount=laProcMessage00;
					}
		        break;
           case laProcMessage00:
		        LocAccStatus=procMessage00();
   13d02:	80 93 bf 03 	sts	0x03BF, r24
                lcd_clear();
   13d06:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		        switch(LocAccStatus){
   13d0a:	10 91 bf 03 	lds	r17, 0x03BF
   13d0e:	11 30       	cpi	r17, 0x01	; 1
   13d10:	51 f0       	breq	.+20     	; 0x13d26 <FMenuLocalAccount+0x122a>
   13d12:	11 30       	cpi	r17, 0x01	; 1
   13d14:	18 f0       	brcs	.+6      	; 0x13d1c <FMenuLocalAccount+0x1220>
   13d16:	13 30       	cpi	r17, 0x03	; 3
   13d18:	69 f5       	brne	.+90     	; 0x13d74 <FMenuLocalAccount+0x1278>
   13d1a:	1b c0       	rjmp	.+54     	; 0x13d52 <FMenuLocalAccount+0x1256>
				case MSG00_NACK:
                     lcd_printf(2,1,PSTR("Authorisasi Gagal   "));
   13d1c:	82 e0       	ldi	r24, 0x02	; 2
   13d1e:	61 e0       	ldi	r22, 0x01	; 1
   13d20:	47 e2       	ldi	r20, 0x27	; 39
   13d22:	5d e1       	ldi	r21, 0x1D	; 29
   13d24:	1a c0       	rjmp	.+52     	; 0x13d5a <FMenuLocalAccount+0x125e>
					 system_beep(2); 
					 stLocalAccount=laDelayExit;
				     break;
                case MSG00_ACK:
				     lcd_printf(2,1,PSTR("Authorisasi Berhasil"));
   13d26:	82 e0       	ldi	r24, 0x02	; 2
   13d28:	61 e0       	ldi	r22, 0x01	; 1
   13d2a:	42 e1       	ldi	r20, 0x12	; 18
   13d2c:	5d e1       	ldi	r21, 0x1D	; 29
   13d2e:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				     LocalAccountFIP[nLocalAccount]=FIP_Used;
   13d32:	90 91 b9 01 	lds	r25, 0x01B9
   13d36:	e9 2f       	mov	r30, r25
   13d38:	f0 e0       	ldi	r31, 0x00	; 0
   13d3a:	e4 5a       	subi	r30, 0xA4	; 164
   13d3c:	fa 4f       	sbci	r31, 0xFA	; 250
   13d3e:	80 91 91 03 	lds	r24, 0x0391
   13d42:	80 83       	st	Z, r24
					 nLocalAccount++;
   13d44:	9f 5f       	subi	r25, 0xFF	; 255
   13d46:	90 93 b9 01 	sts	0x01B9, r25
					 IsViewFillingFIP=True;
   13d4a:	10 93 c2 01 	sts	0x01C2, r17
					 stLocalAccount=laViewStatus;
   13d4e:	86 e1       	ldi	r24, 0x16	; 22
   13d50:	0f c0       	rjmp	.+30     	; 0x13d70 <FMenuLocalAccount+0x1274>
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
   13d52:	82 e0       	ldi	r24, 0x02	; 2
   13d54:	61 e0       	ldi	r22, 0x01	; 1
   13d56:	4f ef       	ldi	r20, 0xFF	; 255
   13d58:	5c e1       	ldi	r21, 0x1C	; 28
   13d5a:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   13d5e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   13d60:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   13d62:	82 e0       	ldi	r24, 0x02	; 2
   13d64:	90 e0       	ldi	r25, 0x00	; 0
   13d66:	90 93 ec 01 	sts	0x01EC, r25
   13d6a:	80 93 eb 01 	sts	0x01EB, r24
					 stLocalAccount=laViewStatus;
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
					 system_beep(2);
					 stLocalAccount=laDelayExit;
   13d6e:	8e e1       	ldi	r24, 0x1E	; 30
   13d70:	80 93 71 01 	sts	0x0171, r24
				     break;
				}
				TimLocAcc=0;
   13d74:	10 92 e8 01 	sts	0x01E8, r1
   13d78:	10 92 e7 01 	sts	0x01E7, r1
				ClearMem(strOdometer);
   13d7c:	89 ec       	ldi	r24, 0xC9	; 201
   13d7e:	95 e0       	ldi	r25, 0x05	; 5
   13d80:	0e 94 2b ac 	call	0x15856	; 0x15856 <ClearMem>
	            ClearMem(strLicPlate);
   13d84:	82 e0       	ldi	r24, 0x02	; 2
   13d86:	9b e0       	ldi	r25, 0x0B	; 11
   13d88:	0e 94 2b ac 	call	0x15856	; 0x15856 <ClearMem>
   13d8c:	e4 c0       	rjmp	.+456    	; 0x13f56 <FMenuLocalAccount+0x145a>
		        break;
           case laViewStatus:
                if (TimLocAcc>20)stLocalAccount=laExitLocAcc;//laDisplayTransaction;
   13d8e:	80 91 e7 01 	lds	r24, 0x01E7
   13d92:	90 91 e8 01 	lds	r25, 0x01E8
   13d96:	45 97       	sbiw	r24, 0x15	; 21
   13d98:	08 f4       	brcc	.+2      	; 0x13d9c <FMenuLocalAccount+0x12a0>
   13d9a:	dd c0       	rjmp	.+442    	; 0x13f56 <FMenuLocalAccount+0x145a>
   13d9c:	d3 c0       	rjmp	.+422    	; 0x13f44 <FMenuLocalAccount+0x1448>
		        break; 
           case laDisplayTransaction:
		        lcd_clear();
   13d9e:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
                sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct); lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   13da2:	2d b7       	in	r18, 0x3d	; 61
   13da4:	3e b7       	in	r19, 0x3e	; 62
   13da6:	28 50       	subi	r18, 0x08	; 8
   13da8:	30 40       	sbci	r19, 0x00	; 0
   13daa:	0f b6       	in	r0, 0x3f	; 63
   13dac:	f8 94       	cli
   13dae:	3e bf       	out	0x3e, r19	; 62
   13db0:	0f be       	out	0x3f, r0	; 63
   13db2:	2d bf       	out	0x3d, r18	; 61
   13db4:	ed b7       	in	r30, 0x3d	; 61
   13db6:	fe b7       	in	r31, 0x3e	; 62
   13db8:	31 96       	adiw	r30, 0x01	; 1
   13dba:	7e 01       	movw	r14, r28
   13dbc:	08 94       	sec
   13dbe:	e1 1c       	adc	r14, r1
   13dc0:	f1 1c       	adc	r15, r1
   13dc2:	ad b7       	in	r26, 0x3d	; 61
   13dc4:	be b7       	in	r27, 0x3e	; 62
   13dc6:	12 96       	adiw	r26, 0x02	; 2
   13dc8:	fc 92       	st	X, r15
   13dca:	ee 92       	st	-X, r14
   13dcc:	11 97       	sbiw	r26, 0x01	; 1
   13dce:	87 ef       	ldi	r24, 0xF7	; 247
   13dd0:	9c e1       	ldi	r25, 0x1C	; 28
   13dd2:	93 83       	std	Z+3, r25	; 0x03
   13dd4:	82 83       	std	Z+2, r24	; 0x02
   13dd6:	88 eb       	ldi	r24, 0xB8	; 184
   13dd8:	93 e0       	ldi	r25, 0x03	; 3
   13dda:	95 83       	std	Z+5, r25	; 0x05
   13ddc:	84 83       	std	Z+4, r24	; 0x04
   13dde:	8d e6       	ldi	r24, 0x6D	; 109
   13de0:	99 e0       	ldi	r25, 0x09	; 9
   13de2:	97 83       	std	Z+7, r25	; 0x07
   13de4:	86 83       	std	Z+6, r24	; 0x06
   13de6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   13dea:	ed b7       	in	r30, 0x3d	; 61
   13dec:	fe b7       	in	r31, 0x3e	; 62
   13dee:	38 96       	adiw	r30, 0x08	; 8
   13df0:	0f b6       	in	r0, 0x3f	; 63
   13df2:	f8 94       	cli
   13df4:	fe bf       	out	0x3e, r31	; 62
   13df6:	0f be       	out	0x3f, r0	; 63
   13df8:	ed bf       	out	0x3d, r30	; 61
   13dfa:	81 e0       	ldi	r24, 0x01	; 1
   13dfc:	61 e0       	ldi	r22, 0x01	; 1
   13dfe:	a7 01       	movw	r20, r14
   13e00:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);        lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   13e04:	00 d0       	rcall	.+0      	; 0x13e06 <FMenuLocalAccount+0x130a>
   13e06:	00 d0       	rcall	.+0      	; 0x13e08 <FMenuLocalAccount+0x130c>
   13e08:	00 d0       	rcall	.+0      	; 0x13e0a <FMenuLocalAccount+0x130e>
   13e0a:	ed b7       	in	r30, 0x3d	; 61
   13e0c:	fe b7       	in	r31, 0x3e	; 62
   13e0e:	31 96       	adiw	r30, 0x01	; 1
   13e10:	ad b7       	in	r26, 0x3d	; 61
   13e12:	be b7       	in	r27, 0x3e	; 62
   13e14:	12 96       	adiw	r26, 0x02	; 2
   13e16:	fc 92       	st	X, r15
   13e18:	ee 92       	st	-X, r14
   13e1a:	11 97       	sbiw	r26, 0x01	; 1
   13e1c:	84 ef       	ldi	r24, 0xF4	; 244
   13e1e:	9c e1       	ldi	r25, 0x1C	; 28
   13e20:	93 83       	std	Z+3, r25	; 0x03
   13e22:	82 83       	std	Z+2, r24	; 0x02
   13e24:	8a e2       	ldi	r24, 0x2A	; 42
   13e26:	9e e0       	ldi	r25, 0x0E	; 14
   13e28:	95 83       	std	Z+5, r25	; 0x05
   13e2a:	84 83       	std	Z+4, r24	; 0x04
   13e2c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   13e30:	ed b7       	in	r30, 0x3d	; 61
   13e32:	fe b7       	in	r31, 0x3e	; 62
   13e34:	36 96       	adiw	r30, 0x06	; 6
   13e36:	0f b6       	in	r0, 0x3f	; 63
   13e38:	f8 94       	cli
   13e3a:	fe bf       	out	0x3e, r31	; 62
   13e3c:	0f be       	out	0x3f, r0	; 63
   13e3e:	ed bf       	out	0x3d, r30	; 61
   13e40:	81 e0       	ldi	r24, 0x01	; 1
   13e42:	6f e0       	ldi	r22, 0x0F	; 15
   13e44:	a7 01       	movw	r20, r14
   13e46:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
                RemSpaceLead(strCardID);
   13e4a:	01 e9       	ldi	r16, 0x91	; 145
   13e4c:	1d e0       	ldi	r17, 0x0D	; 13
   13e4e:	c8 01       	movw	r24, r16
   13e50:	0e 94 8c 23 	call	0x4718	; 0x4718 <RemSpaceLead>
				sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);          lcd_print(2,1,lcdteks);
   13e54:	00 d0       	rcall	.+0      	; 0x13e56 <FMenuLocalAccount+0x135a>
   13e56:	00 d0       	rcall	.+0      	; 0x13e58 <FMenuLocalAccount+0x135c>
   13e58:	00 d0       	rcall	.+0      	; 0x13e5a <FMenuLocalAccount+0x135e>
   13e5a:	ed b7       	in	r30, 0x3d	; 61
   13e5c:	fe b7       	in	r31, 0x3e	; 62
   13e5e:	31 96       	adiw	r30, 0x01	; 1
   13e60:	ad b7       	in	r26, 0x3d	; 61
   13e62:	be b7       	in	r27, 0x3e	; 62
   13e64:	12 96       	adiw	r26, 0x02	; 2
   13e66:	fc 92       	st	X, r15
   13e68:	ee 92       	st	-X, r14
   13e6a:	11 97       	sbiw	r26, 0x01	; 1
   13e6c:	8d ee       	ldi	r24, 0xED	; 237
   13e6e:	9c e1       	ldi	r25, 0x1C	; 28
   13e70:	93 83       	std	Z+3, r25	; 0x03
   13e72:	82 83       	std	Z+2, r24	; 0x02
   13e74:	15 83       	std	Z+5, r17	; 0x05
   13e76:	04 83       	std	Z+4, r16	; 0x04
   13e78:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   13e7c:	ed b7       	in	r30, 0x3d	; 61
   13e7e:	fe b7       	in	r31, 0x3e	; 62
   13e80:	36 96       	adiw	r30, 0x06	; 6
   13e82:	0f b6       	in	r0, 0x3f	; 63
   13e84:	f8 94       	cli
   13e86:	fe bf       	out	0x3e, r31	; 62
   13e88:	0f be       	out	0x3f, r0	; 63
   13e8a:	ed bf       	out	0x3d, r30	; 61
   13e8c:	82 e0       	ldi	r24, 0x02	; 2
   13e8e:	61 e0       	ldi	r22, 0x01	; 1
   13e90:	a7 01       	movw	r20, r14
   13e92:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
				TimLocAcc=0;
   13e96:	10 92 e8 01 	sts	0x01E8, r1
   13e9a:	10 92 e7 01 	sts	0x01E7, r1
		        IsCompleteFilling=False;
   13e9e:	10 92 d6 01 	sts	0x01D6, r1
				stLocalAccount=laWaitFilling;
   13ea2:	8d e1       	ldi	r24, 0x1D	; 29
   13ea4:	85 cd       	rjmp	.-1270   	; 0x139b0 <FMenuLocalAccount+0xeb4>
		        break; 
           case laWaitFilling:
				if ((IsCompleteFilling==True)||(TimLocAcc>FILLING_TIMOUT)){
   13ea6:	80 91 d6 01 	lds	r24, 0x01D6
   13eaa:	81 30       	cpi	r24, 0x01	; 1
   13eac:	39 f0       	breq	.+14     	; 0x13ebc <FMenuLocalAccount+0x13c0>
   13eae:	80 91 e7 01 	lds	r24, 0x01E7
   13eb2:	90 91 e8 01 	lds	r25, 0x01E8
   13eb6:	0b 97       	sbiw	r24, 0x0b	; 11
   13eb8:	08 f4       	brcc	.+2      	; 0x13ebc <FMenuLocalAccount+0x13c0>
   13eba:	4d c0       	rjmp	.+154    	; 0x13f56 <FMenuLocalAccount+0x145a>
				    IsCompleteFilling=False;
   13ebc:	10 92 d6 01 	sts	0x01D6, r1
				    stLocalAccount=laSuccessTransaction;
   13ec0:	89 e1       	ldi	r24, 0x19	; 25
   13ec2:	80 93 71 01 	sts	0x0171, r24
					TimLocAcc=0;
   13ec6:	10 92 e8 01 	sts	0x01E8, r1
   13eca:	10 92 e7 01 	sts	0x01E7, r1
   13ece:	43 c0       	rjmp	.+134    	; 0x13f56 <FMenuLocalAccount+0x145a>
					}
		        break;
           case laSuccessTransaction:
				lcd_clear();lcd_printf(2,1,PSTR("Transaksi Selesai"));
   13ed0:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
   13ed4:	82 e0       	ldi	r24, 0x02	; 2
   13ed6:	61 e0       	ldi	r22, 0x01	; 1
   13ed8:	4b ed       	ldi	r20, 0xDB	; 219
   13eda:	5c e1       	ldi	r21, 0x1C	; 28
   13edc:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
				//Show Status FIP
				sprintf_P(lcdteks,PSTR("Fueling @FIP:#%d"),FIP_Used);
   13ee0:	00 d0       	rcall	.+0      	; 0x13ee2 <FMenuLocalAccount+0x13e6>
   13ee2:	00 d0       	rcall	.+0      	; 0x13ee4 <FMenuLocalAccount+0x13e8>
   13ee4:	00 d0       	rcall	.+0      	; 0x13ee6 <FMenuLocalAccount+0x13ea>
   13ee6:	ed b7       	in	r30, 0x3d	; 61
   13ee8:	fe b7       	in	r31, 0x3e	; 62
   13eea:	31 96       	adiw	r30, 0x01	; 1
   13eec:	8e 01       	movw	r16, r28
   13eee:	0f 5f       	subi	r16, 0xFF	; 255
   13ef0:	1f 4f       	sbci	r17, 0xFF	; 255
   13ef2:	ad b7       	in	r26, 0x3d	; 61
   13ef4:	be b7       	in	r27, 0x3e	; 62
   13ef6:	12 96       	adiw	r26, 0x02	; 2
   13ef8:	1c 93       	st	X, r17
   13efa:	0e 93       	st	-X, r16
   13efc:	11 97       	sbiw	r26, 0x01	; 1
   13efe:	8a ec       	ldi	r24, 0xCA	; 202
   13f00:	9c e1       	ldi	r25, 0x1C	; 28
   13f02:	93 83       	std	Z+3, r25	; 0x03
   13f04:	82 83       	std	Z+2, r24	; 0x02
   13f06:	80 91 91 03 	lds	r24, 0x0391
   13f0a:	84 83       	std	Z+4, r24	; 0x04
   13f0c:	15 82       	std	Z+5, r1	; 0x05
   13f0e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
				lcd_print(3,1,lcdteks);
   13f12:	ed b7       	in	r30, 0x3d	; 61
   13f14:	fe b7       	in	r31, 0x3e	; 62
   13f16:	36 96       	adiw	r30, 0x06	; 6
   13f18:	0f b6       	in	r0, 0x3f	; 63
   13f1a:	f8 94       	cli
   13f1c:	fe bf       	out	0x3e, r31	; 62
   13f1e:	0f be       	out	0x3f, r0	; 63
   13f20:	ed bf       	out	0x3d, r30	; 61
   13f22:	83 e0       	ldi	r24, 0x03	; 3
   13f24:	61 e0       	ldi	r22, 0x01	; 1
   13f26:	a8 01       	movw	r20, r16
   13f28:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>

				TimLocAcc=0;
				stLocalAccount=laDelayExit;
		        break;
           case laFailedTransaction:
		        TimLocAcc=0;
   13f2c:	10 92 e8 01 	sts	0x01E8, r1
   13f30:	10 92 e7 01 	sts	0x01E7, r1
		        //Show Failed Report
				stLocalAccount=laDelayExit;
   13f34:	8e e1       	ldi	r24, 0x1E	; 30
   13f36:	3c cd       	rjmp	.-1416   	; 0x139b0 <FMenuLocalAccount+0xeb4>
		        break;
           case laDelayExit:
		        if (TimLocAcc>15)stLocalAccount=laExitLocAcc;
   13f38:	80 91 e7 01 	lds	r24, 0x01E7
   13f3c:	90 91 e8 01 	lds	r25, 0x01E8
   13f40:	40 97       	sbiw	r24, 0x10	; 16
   13f42:	48 f0       	brcs	.+18     	; 0x13f56 <FMenuLocalAccount+0x145a>
   13f44:	8f e1       	ldi	r24, 0x1F	; 31
   13f46:	34 cd       	rjmp	.-1432   	; 0x139b0 <FMenuLocalAccount+0xeb4>
		        break;
           case laExitLocAcc:
		        Result=MENU_DONE;
				stLocalAccount=laInit;
   13f48:	81 e0       	ldi	r24, 0x01	; 1
   13f4a:	80 93 71 01 	sts	0x0171, r24
				lcd_clear();
   13f4e:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
   13f52:	81 e0       	ldi	r24, 0x01	; 1
   13f54:	01 c0       	rjmp	.+2      	; 0x13f58 <FMenuLocalAccount+0x145c>
   13f56:	80 e0       	ldi	r24, 0x00	; 0
		        break;
	       }//EndSwitch
return Result;
}
   13f58:	a9 96       	adiw	r28, 0x29	; 41
   13f5a:	0f b6       	in	r0, 0x3f	; 63
   13f5c:	f8 94       	cli
   13f5e:	de bf       	out	0x3e, r29	; 62
   13f60:	0f be       	out	0x3f, r0	; 63
   13f62:	cd bf       	out	0x3d, r28	; 61
   13f64:	cf 91       	pop	r28
   13f66:	df 91       	pop	r29
   13f68:	1f 91       	pop	r17
   13f6a:	0f 91       	pop	r16
   13f6c:	ff 90       	pop	r15
   13f6e:	ef 90       	pop	r14
   13f70:	df 90       	pop	r13
   13f72:	cf 90       	pop	r12
   13f74:	bf 90       	pop	r11
   13f76:	af 90       	pop	r10
   13f78:	08 95       	ret

00013f7a <SetBaudRate>:
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
	 IsFreePrinting=True;
}

void SetBaudRate(char ComAddr,char brMap){//Com1..Com4
   13f7a:	28 2f       	mov	r18, r24
   13f7c:	96 2f       	mov	r25, r22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
   13f7e:	81 50       	subi	r24, 0x01	; 1
   13f80:	82 30       	cpi	r24, 0x02	; 2
   13f82:	b8 f4       	brcc	.+46     	; 0x13fb2 <SetBaudRate+0x38>
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   13f84:	62 30       	cpi	r22, 0x02	; 2
   13f86:	59 f0       	breq	.+22     	; 0x13f9e <SetBaudRate+0x24>
   13f88:	62 30       	cpi	r22, 0x02	; 2
   13f8a:	18 f0       	brcs	.+6      	; 0x13f92 <SetBaudRate+0x18>
   13f8c:	63 30       	cpi	r22, 0x03	; 3
   13f8e:	21 f4       	brne	.+8      	; 0x13f98 <SetBaudRate+0x1e>
   13f90:	09 c0       	rjmp	.+18     	; 0x13fa4 <SetBaudRate+0x2a>
   13f92:	40 e8       	ldi	r20, 0x80	; 128
   13f94:	55 e2       	ldi	r21, 0x25	; 37
   13f96:	08 c0       	rjmp	.+16     	; 0x13fa8 <SetBaudRate+0x2e>
   13f98:	40 e0       	ldi	r20, 0x00	; 0
   13f9a:	50 e0       	ldi	r21, 0x00	; 0
   13f9c:	05 c0       	rjmp	.+10     	; 0x13fa8 <SetBaudRate+0x2e>
   13f9e:	40 e0       	ldi	r20, 0x00	; 0
   13fa0:	5b e4       	ldi	r21, 0x4B	; 75
   13fa2:	02 c0       	rjmp	.+4      	; 0x13fa8 <SetBaudRate+0x2e>
   13fa4:	4b e9       	ldi	r20, 0x9B	; 155
   13fa6:	56 e1       	ldi	r21, 0x16	; 22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
	     brValue=GetBaudrate(brMap);
	      _uart_init((ComAddr-1),brValue);
   13fa8:	60 e0       	ldi	r22, 0x00	; 0
   13faa:	70 e0       	ldi	r23, 0x00	; 0
   13fac:	0e 94 eb b2 	call	0x165d6	; 0x165d6 <_uart_init>
   13fb0:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
   13fb2:	82 2f       	mov	r24, r18
   13fb4:	83 50       	subi	r24, 0x03	; 3
   13fb6:	82 30       	cpi	r24, 0x02	; 2
   13fb8:	a8 f4       	brcc	.+42     	; 0x13fe4 <SetBaudRate+0x6a>
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
   13fba:	9f 70       	andi	r25, 0x0F	; 15
   13fbc:	62 2f       	mov	r22, r18
   13fbe:	62 95       	swap	r22
   13fc0:	60 7f       	andi	r22, 0xF0	; 240
   13fc2:	69 2b       	or	r22, r25
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
   13fc4:	80 91 a9 01 	lds	r24, 0x01A9
   13fc8:	88 23       	and	r24, r24
   13fca:	49 f0       	breq	.+18     	; 0x13fde <SetBaudRate+0x64>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
   13fcc:	86 e0       	ldi	r24, 0x06	; 6
   13fce:	80 93 b6 07 	sts	0x07B6, r24
	 PoolMsg=plMsg;
   13fd2:	60 93 de 0d 	sts	0x0DDE, r22
     IsControlPooling=True;
   13fd6:	81 e0       	ldi	r24, 0x01	; 1
   13fd8:	80 93 ad 01 	sts	0x01AD, r24
   13fdc:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
		 else SendSlaveCommand(SC_BAUDRATE,brMessage);
   13fde:	86 e0       	ldi	r24, 0x06	; 6
   13fe0:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
   13fe4:	08 95       	ret

00013fe6 <FSettingSystem>:
char FSettingOperator(){
     _menu_user();
     return MENU_DONE;
}

char FSettingSystem(){
   13fe6:	af 92       	push	r10
   13fe8:	bf 92       	push	r11
   13fea:	cf 92       	push	r12
   13fec:	df 92       	push	r13
   13fee:	ef 92       	push	r14
   13ff0:	ff 92       	push	r15
   13ff2:	0f 93       	push	r16
   13ff4:	1f 93       	push	r17
   13ff6:	df 93       	push	r29
   13ff8:	cf 93       	push	r28
   13ffa:	cd b7       	in	r28, 0x3d	; 61
   13ffc:	de b7       	in	r29, 0x3e	; 62
   13ffe:	64 97       	sbiw	r28, 0x14	; 20
   14000:	0f b6       	in	r0, 0x3f	; 63
   14002:	f8 94       	cli
   14004:	de bf       	out	0x3e, r29	; 62
   14006:	0f be       	out	0x3f, r0	; 63
   14008:	cd bf       	out	0x3d, r28	; 61
       char KeyPressed,KeyChar,brVal,i;  
       char SubMenu,Result=MENU_NONE;
       char lcdteks[20];
	   int bValue;

     switch(stSettingSytem){
   1400a:	80 91 fd 02 	lds	r24, 0x02FD
   1400e:	82 30       	cpi	r24, 0x02	; 2
   14010:	09 f4       	brne	.+2      	; 0x14014 <FSettingSystem+0x2e>
   14012:	94 c0       	rjmp	.+296    	; 0x1413c <FSettingSystem+0x156>
   14014:	83 30       	cpi	r24, 0x03	; 3
   14016:	30 f4       	brcc	.+12     	; 0x14024 <FSettingSystem+0x3e>
   14018:	88 23       	and	r24, r24
   1401a:	71 f0       	breq	.+28     	; 0x14038 <FSettingSystem+0x52>
   1401c:	81 30       	cpi	r24, 0x01	; 1
   1401e:	09 f0       	breq	.+2      	; 0x14022 <FSettingSystem+0x3c>
   14020:	34 c1       	rjmp	.+616    	; 0x1428a <FSettingSystem+0x2a4>
   14022:	61 c0       	rjmp	.+194    	; 0x140e6 <FSettingSystem+0x100>
   14024:	84 30       	cpi	r24, 0x04	; 4
   14026:	09 f4       	brne	.+2      	; 0x1402a <FSettingSystem+0x44>
   14028:	25 c1       	rjmp	.+586    	; 0x14274 <FSettingSystem+0x28e>
   1402a:	84 30       	cpi	r24, 0x04	; 4
   1402c:	08 f4       	brcc	.+2      	; 0x14030 <FSettingSystem+0x4a>
   1402e:	f0 c0       	rjmp	.+480    	; 0x14210 <FSettingSystem+0x22a>
   14030:	85 30       	cpi	r24, 0x05	; 5
   14032:	09 f0       	breq	.+2      	; 0x14036 <FSettingSystem+0x50>
   14034:	2a c1       	rjmp	.+596    	; 0x1428a <FSettingSystem+0x2a4>
   14036:	25 c1       	rjmp	.+586    	; 0x14282 <FSettingSystem+0x29c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14038:	e1 99       	sbic	0x1c, 1	; 28
   1403a:	fe cf       	rjmp	.-4      	; 0x14038 <FSettingSystem+0x52>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1403c:	86 e6       	ldi	r24, 0x66	; 102
   1403e:	91 e0       	ldi	r25, 0x01	; 1
   14040:	9f bb       	out	0x1f, r25	; 31
   14042:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14044:	e0 9a       	sbi	0x1c, 0	; 28
   14046:	8d b3       	in	r24, 0x1d	; 29
	 case ssInitSettingSystem:
	      IFType=eeprom_read_byte(&DefInitIFT);
   14048:	80 93 25 01 	sts	0x0125, r24

	      if (IFType==IT_NONE)sprintf_P(lcdteks,PSTR("1.Mode:None"));
   1404c:	88 23       	and	r24, r24
   1404e:	69 f4       	brne	.+26     	; 0x1406a <FSettingSystem+0x84>
   14050:	00 d0       	rcall	.+0      	; 0x14052 <FSettingSystem+0x6c>
   14052:	00 d0       	rcall	.+0      	; 0x14054 <FSettingSystem+0x6e>
   14054:	ce 01       	movw	r24, r28
   14056:	01 96       	adiw	r24, 0x01	; 1
   14058:	ad b7       	in	r26, 0x3d	; 61
   1405a:	be b7       	in	r27, 0x3e	; 62
   1405c:	12 96       	adiw	r26, 0x02	; 2
   1405e:	9c 93       	st	X, r25
   14060:	8e 93       	st	-X, r24
   14062:	11 97       	sbiw	r26, 0x01	; 1
   14064:	8b e6       	ldi	r24, 0x6B	; 107
   14066:	9f e0       	ldi	r25, 0x0F	; 15
   14068:	1d c0       	rjmp	.+58     	; 0x140a4 <FSettingSystem+0xbe>
		  else
	      if (IFType==IT_SLAVE)sprintf_P(lcdteks,PSTR("1.Mode:Slave"));
   1406a:	81 30       	cpi	r24, 0x01	; 1
   1406c:	69 f4       	brne	.+26     	; 0x14088 <FSettingSystem+0xa2>
   1406e:	00 d0       	rcall	.+0      	; 0x14070 <FSettingSystem+0x8a>
   14070:	00 d0       	rcall	.+0      	; 0x14072 <FSettingSystem+0x8c>
   14072:	ce 01       	movw	r24, r28
   14074:	01 96       	adiw	r24, 0x01	; 1
   14076:	ed b7       	in	r30, 0x3d	; 61
   14078:	fe b7       	in	r31, 0x3e	; 62
   1407a:	92 83       	std	Z+2, r25	; 0x02
   1407c:	81 83       	std	Z+1, r24	; 0x01
   1407e:	8e e5       	ldi	r24, 0x5E	; 94
   14080:	9f e0       	ldi	r25, 0x0F	; 15
   14082:	94 83       	std	Z+4, r25	; 0x04
   14084:	83 83       	std	Z+3, r24	; 0x03
   14086:	12 c0       	rjmp	.+36     	; 0x140ac <FSettingSystem+0xc6>
		  else
	      if (IFType==IT_STANDALONE)sprintf_P(lcdteks,PSTR("1.Mode:Standalone"));
   14088:	82 30       	cpi	r24, 0x02	; 2
   1408a:	b1 f4       	brne	.+44     	; 0x140b8 <FSettingSystem+0xd2>
   1408c:	00 d0       	rcall	.+0      	; 0x1408e <FSettingSystem+0xa8>
   1408e:	00 d0       	rcall	.+0      	; 0x14090 <FSettingSystem+0xaa>
   14090:	ce 01       	movw	r24, r28
   14092:	01 96       	adiw	r24, 0x01	; 1
   14094:	ad b7       	in	r26, 0x3d	; 61
   14096:	be b7       	in	r27, 0x3e	; 62
   14098:	12 96       	adiw	r26, 0x02	; 2
   1409a:	9c 93       	st	X, r25
   1409c:	8e 93       	st	-X, r24
   1409e:	11 97       	sbiw	r26, 0x01	; 1
   140a0:	8c e4       	ldi	r24, 0x4C	; 76
   140a2:	9f e0       	ldi	r25, 0x0F	; 15
   140a4:	14 96       	adiw	r26, 0x04	; 4
   140a6:	9c 93       	st	X, r25
   140a8:	8e 93       	st	-X, r24
   140aa:	13 97       	sbiw	r26, 0x03	; 3
   140ac:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   140b0:	0f 90       	pop	r0
   140b2:	0f 90       	pop	r0
   140b4:	0f 90       	pop	r0
   140b6:	0f 90       	pop	r0

	      lcd_clear();
   140b8:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_print(1,1,lcdteks);
   140bc:	81 e0       	ldi	r24, 0x01	; 1
   140be:	61 e0       	ldi	r22, 0x01	; 1
   140c0:	ae 01       	movw	r20, r28
   140c2:	4f 5f       	subi	r20, 0xFF	; 255
   140c4:	5f 4f       	sbci	r21, 0xFF	; 255
   140c6:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		  lcd_printf(2,1,PSTR("2.Baudrate"));
   140ca:	82 e0       	ldi	r24, 0x02	; 2
   140cc:	61 e0       	ldi	r22, 0x01	; 1
   140ce:	41 e4       	ldi	r20, 0x41	; 65
   140d0:	5f e0       	ldi	r21, 0x0F	; 15
   140d2:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  //lcd_printf(3,1,PSTR("3.Pump Pooling"));
		  lcd_printf(4,1,PSTR("[*]Back      "));
   140d6:	84 e0       	ldi	r24, 0x04	; 4
   140d8:	61 e0       	ldi	r22, 0x01	; 1
   140da:	43 e3       	ldi	r20, 0x33	; 51
   140dc:	5f e0       	ldi	r21, 0x0F	; 15
   140de:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  stSettingSytem=ssMenuSelect;
   140e2:	81 e0       	ldi	r24, 0x01	; 1
   140e4:	c4 c0       	rjmp	.+392    	; 0x1426e <FSettingSystem+0x288>
	      break;
     case ssMenuSelect:
          KeyPressed=_key_scan(1);
   140e6:	81 e0       	ldi	r24, 0x01	; 1
   140e8:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   140ec:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
		  if (KeyChar=='1'){
   140f0:	81 33       	cpi	r24, 0x31	; 49
   140f2:	e9 f4       	brne	.+58     	; 0x1412e <FSettingSystem+0x148>
		      IFType=((IFType+1)%3);
   140f4:	80 91 25 01 	lds	r24, 0x0125
   140f8:	90 e0       	ldi	r25, 0x00	; 0
   140fa:	01 96       	adiw	r24, 0x01	; 1
   140fc:	63 e0       	ldi	r22, 0x03	; 3
   140fe:	70 e0       	ldi	r23, 0x00	; 0
   14100:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
   14104:	80 93 25 01 	sts	0x0125, r24
			  SendSlaveCommand(IFType,DispenserBrand);
   14108:	60 91 77 01 	lds	r22, 0x0177
   1410c:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
			  eeprom_write_byte(&DefInitIFT,IFType);
   14110:	20 91 25 01 	lds	r18, 0x0125
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   14114:	e1 99       	sbic	0x1c, 1	; 28
   14116:	fe cf       	rjmp	.-4      	; 0x14114 <FSettingSystem+0x12e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14118:	86 e6       	ldi	r24, 0x66	; 102
   1411a:	91 e0       	ldi	r25, 0x01	; 1
   1411c:	9f bb       	out	0x1f, r25	; 31
   1411e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   14120:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   14122:	0f b6       	in	r0, 0x3f	; 63
   14124:	f8 94       	cli
   14126:	e2 9a       	sbi	0x1c, 2	; 28
   14128:	e1 9a       	sbi	0x1c, 1	; 28
   1412a:	0f be       	out	0x3f, r0	; 63
   1412c:	a7 c0       	rjmp	.+334    	; 0x1427c <FSettingSystem+0x296>
			  stSettingSytem=ssInitSettingSystem;
		  }
		  else
		  if (KeyChar=='2'){
   1412e:	82 33       	cpi	r24, 0x32	; 50
   14130:	09 f4       	brne	.+2      	; 0x14134 <FSettingSystem+0x14e>
   14132:	98 c0       	rjmp	.+304    	; 0x14264 <FSettingSystem+0x27e>
		  else
		  //if (KeyChar=='3'){
		  //    stSettingSytem=ssPumpPoolingSettings;
		  //}
		  //else
		  if (KeyChar=='*'){
   14134:	8a 32       	cpi	r24, 0x2A	; 42
   14136:	09 f0       	breq	.+2      	; 0x1413a <FSettingSystem+0x154>
   14138:	a8 c0       	rjmp	.+336    	; 0x1428a <FSettingSystem+0x2a4>
   1413a:	98 c0       	rjmp	.+304    	; 0x1426c <FSettingSystem+0x286>
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
   1413c:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   14140:	81 e0       	ldi	r24, 0x01	; 1
   14142:	61 e0       	ldi	r22, 0x01	; 1
   14144:	4e e1       	ldi	r20, 0x1E	; 30
   14146:	5f e0       	ldi	r21, 0x0F	; 15
   14148:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
   1414c:	01 e0       	ldi	r16, 0x01	; 1
   1414e:	10 e0       	ldi	r17, 0x00	; 0

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   14150:	6e 01       	movw	r12, r28
   14152:	08 94       	sec
   14154:	c1 1c       	adc	r12, r1
   14156:	d1 1c       	adc	r13, r1
   14158:	65 e1       	ldi	r22, 0x15	; 21
   1415a:	a6 2e       	mov	r10, r22
   1415c:	6f e0       	ldi	r22, 0x0F	; 15
   1415e:	b6 2e       	mov	r11, r22
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   14160:	5b e0       	ldi	r21, 0x0B	; 11
   14162:	e5 2e       	mov	r14, r21
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   14164:	f0 2e       	mov	r15, r16
   14166:	fa 94       	dec	r15
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14168:	e1 99       	sbic	0x1c, 1	; 28
   1416a:	fe cf       	rjmp	.-4      	; 0x14168 <FSettingSystem+0x182>
   1416c:	c8 01       	movw	r24, r16
   1416e:	81 59       	subi	r24, 0x91	; 145
   14170:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14172:	9f bb       	out	0x1f, r25	; 31
   14174:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14176:	e0 9a       	sbi	0x1c, 0	; 28
   14178:	8d b3       	in	r24, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   1417a:	82 30       	cpi	r24, 0x02	; 2
   1417c:	69 f0       	breq	.+26     	; 0x14198 <FSettingSystem+0x1b2>
   1417e:	82 30       	cpi	r24, 0x02	; 2
   14180:	28 f0       	brcs	.+10     	; 0x1418c <FSettingSystem+0x1a6>
   14182:	83 30       	cpi	r24, 0x03	; 3
   14184:	31 f4       	brne	.+12     	; 0x14192 <FSettingSystem+0x1ac>
   14186:	85 eb       	ldi	r24, 0xB5	; 181
   14188:	9f e2       	ldi	r25, 0x2F	; 47
   1418a:	08 c0       	rjmp	.+16     	; 0x1419c <FSettingSystem+0x1b6>
   1418c:	80 e8       	ldi	r24, 0x80	; 128
   1418e:	95 e2       	ldi	r25, 0x25	; 37
   14190:	05 c0       	rjmp	.+10     	; 0x1419c <FSettingSystem+0x1b6>
   14192:	80 e0       	ldi	r24, 0x00	; 0
   14194:	90 e0       	ldi	r25, 0x00	; 0
   14196:	02 c0       	rjmp	.+4      	; 0x1419c <FSettingSystem+0x1b6>
   14198:	80 e0       	ldi	r24, 0x00	; 0
   1419a:	9b e4       	ldi	r25, 0x4B	; 75
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   1419c:	ed b7       	in	r30, 0x3d	; 61
   1419e:	fe b7       	in	r31, 0x3e	; 62
   141a0:	38 97       	sbiw	r30, 0x08	; 8
   141a2:	0f b6       	in	r0, 0x3f	; 63
   141a4:	f8 94       	cli
   141a6:	fe bf       	out	0x3e, r31	; 62
   141a8:	0f be       	out	0x3f, r0	; 63
   141aa:	ed bf       	out	0x3d, r30	; 61
   141ac:	31 96       	adiw	r30, 0x01	; 1
   141ae:	ad b7       	in	r26, 0x3d	; 61
   141b0:	be b7       	in	r27, 0x3e	; 62
   141b2:	12 96       	adiw	r26, 0x02	; 2
   141b4:	dc 92       	st	X, r13
   141b6:	ce 92       	st	-X, r12
   141b8:	11 97       	sbiw	r26, 0x01	; 1
   141ba:	b3 82       	std	Z+3, r11	; 0x03
   141bc:	a2 82       	std	Z+2, r10	; 0x02
   141be:	15 83       	std	Z+5, r17	; 0x05
   141c0:	04 83       	std	Z+4, r16	; 0x04
   141c2:	97 83       	std	Z+7, r25	; 0x07
   141c4:	86 83       	std	Z+6, r24	; 0x06
   141c6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   141ca:	ed b7       	in	r30, 0x3d	; 61
   141cc:	fe b7       	in	r31, 0x3e	; 62
   141ce:	38 96       	adiw	r30, 0x08	; 8
   141d0:	0f b6       	in	r0, 0x3f	; 63
   141d2:	f8 94       	cli
   141d4:	fe bf       	out	0x3e, r31	; 62
   141d6:	0f be       	out	0x3f, r0	; 63
   141d8:	ed bf       	out	0x3d, r30	; 61
   141da:	6f 2d       	mov	r22, r15
   141dc:	66 95       	lsr	r22
   141de:	6e 9d       	mul	r22, r14
   141e0:	b0 01       	movw	r22, r0
   141e2:	11 24       	eor	r1, r1
   141e4:	6f 5f       	subi	r22, 0xFF	; 255
   141e6:	f1 e0       	ldi	r31, 0x01	; 1
   141e8:	ff 22       	and	r15, r31
   141ea:	8f 2d       	mov	r24, r15
   141ec:	8e 5f       	subi	r24, 0xFE	; 254
   141ee:	a6 01       	movw	r20, r12
   141f0:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
   141f4:	0f 5f       	subi	r16, 0xFF	; 255
   141f6:	1f 4f       	sbci	r17, 0xFF	; 255
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
   141f8:	05 30       	cpi	r16, 0x05	; 5
   141fa:	11 05       	cpc	r17, r1
   141fc:	09 f0       	breq	.+2      	; 0x14200 <FSettingSystem+0x21a>
   141fe:	b2 cf       	rjmp	.-156    	; 0x14164 <FSettingSystem+0x17e>
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
		  }
		  lcd_printf(4,1,PSTR("[*]Back     "));
   14200:	84 e0       	ldi	r24, 0x04	; 4
   14202:	61 e0       	ldi	r22, 0x01	; 1
   14204:	48 e0       	ldi	r20, 0x08	; 8
   14206:	5f e0       	ldi	r21, 0x0F	; 15
   14208:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  stSettingSytem=ssBaudrateInput;
   1420c:	83 e0       	ldi	r24, 0x03	; 3
   1420e:	2f c0       	rjmp	.+94     	; 0x1426e <FSettingSystem+0x288>
	      break;
     case ssBaudrateInput:
	      KeyPressed=_key_scan(1);
   14210:	81 e0       	ldi	r24, 0x01	; 1
   14212:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   14216:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   1421a:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   1421c:	81 53       	subi	r24, 0x31	; 49
   1421e:	84 30       	cpi	r24, 0x04	; 4
   14220:	18 f5       	brcc	.+70     	; 0x14268 <FSettingSystem+0x282>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14222:	e1 99       	sbic	0x1c, 1	; 28
   14224:	fe cf       	rjmp	.-4      	; 0x14222 <FSettingSystem+0x23c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14226:	02 2f       	mov	r16, r18
   14228:	10 e0       	ldi	r17, 0x00	; 0
   1422a:	01 5c       	subi	r16, 0xC1	; 193
   1422c:	1e 4f       	sbci	r17, 0xFE	; 254
   1422e:	1f bb       	out	0x1f, r17	; 31
   14230:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14232:	e0 9a       	sbi	0x1c, 0	; 28
   14234:	8d b3       	in	r24, 0x1d	; 29
		       brVal=eeprom_read_byte(&DefBaudrate[KeyChar-'1']);
			   brVal=((brVal+1)%3)+1;
   14236:	90 e0       	ldi	r25, 0x00	; 0
   14238:	01 96       	adiw	r24, 0x01	; 1
   1423a:	63 e0       	ldi	r22, 0x03	; 3
   1423c:	70 e0       	ldi	r23, 0x00	; 0
   1423e:	0e 94 d0 b7 	call	0x16fa0	; 0x16fa0 <__divmodhi4>
   14242:	f8 2e       	mov	r15, r24
   14244:	f3 94       	inc	r15
			   SetBaudRate(KeyChar-'0',brVal);
   14246:	82 2f       	mov	r24, r18
   14248:	80 53       	subi	r24, 0x30	; 48
   1424a:	6f 2d       	mov	r22, r15
   1424c:	0e 94 bd 9f 	call	0x13f7a	; 0x13f7a <SetBaudRate>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   14250:	e1 99       	sbic	0x1c, 1	; 28
   14252:	fe cf       	rjmp	.-4      	; 0x14250 <FSettingSystem+0x26a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14254:	1f bb       	out	0x1f, r17	; 31
   14256:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   14258:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
   1425a:	0f b6       	in	r0, 0x3f	; 63
   1425c:	f8 94       	cli
   1425e:	e2 9a       	sbi	0x1c, 2	; 28
   14260:	e1 9a       	sbi	0x1c, 1	; 28
   14262:	0f be       	out	0x3f, r0	; 63
			   eeprom_write_byte(&DefBaudrate[KeyChar-'1'],brVal);
               stSettingSytem=ssComSettings;
   14264:	82 e0       	ldi	r24, 0x02	; 2
   14266:	03 c0       	rjmp	.+6      	; 0x1426e <FSettingSystem+0x288>
		  }else if (KeyChar=='*')
   14268:	2a 32       	cpi	r18, 0x2A	; 42
   1426a:	79 f4       	brne	.+30     	; 0x1428a <FSettingSystem+0x2a4>
		      stSettingSytem=ssExitSystemSettings;		  	
   1426c:	85 e0       	ldi	r24, 0x05	; 5
   1426e:	80 93 fd 02 	sts	0x02FD, r24
   14272:	0b c0       	rjmp	.+22     	; 0x1428a <FSettingSystem+0x2a4>
	      break;
	 case ssPumpPoolingSettings:
          SubMenu=FSettingPumpPooling();
   14274:	0e 94 ba 6e 	call	0xdd74	; 0xdd74 <FSettingPumpPooling>
		  if (SubMenu==MENU_DONE)stSettingSytem=ssInitSettingSystem;
   14278:	81 30       	cpi	r24, 0x01	; 1
   1427a:	39 f4       	brne	.+14     	; 0x1428a <FSettingSystem+0x2a4>
   1427c:	10 92 fd 02 	sts	0x02FD, r1
   14280:	04 c0       	rjmp	.+8      	; 0x1428a <FSettingSystem+0x2a4>
	      break;
     case ssExitSystemSettings:
	      stSettingSytem=ssInitSettingSystem;
   14282:	10 92 fd 02 	sts	0x02FD, r1
   14286:	81 e0       	ldi	r24, 0x01	; 1
   14288:	01 c0       	rjmp	.+2      	; 0x1428c <FSettingSystem+0x2a6>
   1428a:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
   1428c:	64 96       	adiw	r28, 0x14	; 20
   1428e:	0f b6       	in	r0, 0x3f	; 63
   14290:	f8 94       	cli
   14292:	de bf       	out	0x3e, r29	; 62
   14294:	0f be       	out	0x3f, r0	; 63
   14296:	cd bf       	out	0x3d, r28	; 61
   14298:	cf 91       	pop	r28
   1429a:	df 91       	pop	r29
   1429c:	1f 91       	pop	r17
   1429e:	0f 91       	pop	r16
   142a0:	ff 90       	pop	r15
   142a2:	ef 90       	pop	r14
   142a4:	df 90       	pop	r13
   142a6:	cf 90       	pop	r12
   142a8:	bf 90       	pop	r11
   142aa:	af 90       	pop	r10
   142ac:	08 95       	ret

000142ae <FMenuSettings>:


char FMenuSettings(){
char Result=MENU_NONE;
static char stMenuSettings=msInit,PageSetting=1,KeyPressed,KeyChar,SubMenu;
     switch(stMenuSettings){
   142ae:	80 91 0e 03 	lds	r24, 0x030E
   142b2:	e8 2f       	mov	r30, r24
   142b4:	f0 e0       	ldi	r31, 0x00	; 0
   142b6:	e3 31       	cpi	r30, 0x13	; 19
   142b8:	f1 05       	cpc	r31, r1
   142ba:	08 f0       	brcs	.+2      	; 0x142be <FMenuSettings+0x10>
   142bc:	cd c0       	rjmp	.+410    	; 0x14458 <FMenuSettings+0x1aa>
   142be:	ef 5f       	subi	r30, 0xFF	; 255
   142c0:	fe 4f       	sbci	r31, 0xFE	; 254
   142c2:	ee 0f       	add	r30, r30
   142c4:	ff 1f       	adc	r31, r31
   142c6:	05 90       	lpm	r0, Z+
   142c8:	f4 91       	lpm	r31, Z+
   142ca:	e0 2d       	mov	r30, r0
   142cc:	09 94       	ijmp
	 case msInit:
		  lcd_clear();
   142ce:	0e 94 eb ab 	call	0x157d6	; 0x157d6 <lcd_clear>
		  PageSetting=1;
   142d2:	81 e0       	ldi	r24, 0x01	; 1
   142d4:	80 93 6c 01 	sts	0x016C, r24
   142d8:	95 c0       	rjmp	.+298    	; 0x14404 <FMenuSettings+0x156>
		  stMenuSettings=msDisplayPage;
		  break;
	 case msDisplayPage:
	      stMenuSettings=msDisplayPage+PageSetting;
   142da:	80 91 6c 01 	lds	r24, 0x016C
   142de:	8f 5f       	subi	r24, 0xFF	; 255
   142e0:	91 c0       	rjmp	.+290    	; 0x14404 <FMenuSettings+0x156>
          break; 	 
	 case msDisplayPage1:
		  lcd_printf(1, 1, PSTR("1)Product  5)Printer"));
   142e2:	81 e0       	ldi	r24, 0x01	; 1
   142e4:	61 e0       	ldi	r22, 0x01	; 1
   142e6:	45 e3       	ldi	r20, 0x35	; 53
   142e8:	51 e1       	ldi	r21, 0x11	; 17
   142ea:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)Pump     6)Host   "));
   142ee:	82 e0       	ldi	r24, 0x02	; 2
   142f0:	61 e0       	ldi	r22, 0x01	; 1
   142f2:	40 e2       	ldi	r20, 0x20	; 32
   142f4:	51 e1       	ldi	r21, 0x11	; 17
   142f6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)Decimal  7)Next   "));
   142fa:	83 e0       	ldi	r24, 0x03	; 3
   142fc:	61 e0       	ldi	r22, 0x01	; 1
   142fe:	4b e0       	ldi	r20, 0x0B	; 11
   14300:	51 e1       	ldi	r21, 0x11	; 17
   14302:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(4, 1, PSTR("4)Datetime *)Exit   "));
   14306:	84 e0       	ldi	r24, 0x04	; 4
   14308:	61 e0       	ldi	r22, 0x01	; 1
   1430a:	46 ef       	ldi	r20, 0xF6	; 246
   1430c:	50 e1       	ldi	r21, 0x10	; 16
   1430e:	16 c0       	rjmp	.+44     	; 0x1433c <FMenuSettings+0x8e>
		  stMenuSettings=msSelection;
	      break;
	 case msDisplayPage2:
		  lcd_printf(1, 1, PSTR("1)Operator          "));
   14310:	81 e0       	ldi	r24, 0x01	; 1
   14312:	61 e0       	ldi	r22, 0x01	; 1
   14314:	41 ee       	ldi	r20, 0xE1	; 225
   14316:	50 e1       	ldi	r21, 0x10	; 16
   14318:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)System            "));
   1431c:	82 e0       	ldi	r24, 0x02	; 2
   1431e:	61 e0       	ldi	r22, 0x01	; 1
   14320:	4c ec       	ldi	r20, 0xCC	; 204
   14322:	50 e1       	ldi	r21, 0x10	; 16
   14324:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)PumpPooling       "));
   14328:	83 e0       	ldi	r24, 0x03	; 3
   1432a:	61 e0       	ldi	r22, 0x01	; 1
   1432c:	47 eb       	ldi	r20, 0xB7	; 183
   1432e:	50 e1       	ldi	r21, 0x10	; 16
   14330:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  lcd_printf(4, 1, PSTR("*)Back              "));
   14334:	84 e0       	ldi	r24, 0x04	; 4
   14336:	61 e0       	ldi	r22, 0x01	; 1
   14338:	42 ea       	ldi	r20, 0xA2	; 162
   1433a:	50 e1       	ldi	r21, 0x10	; 16
   1433c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  stMenuSettings=msSelection;
   14340:	84 e0       	ldi	r24, 0x04	; 4
   14342:	60 c0       	rjmp	.+192    	; 0x14404 <FMenuSettings+0x156>
	      break;
	 case msSelection:
	      stMenuSettings=msSelection+PageSetting;
   14344:	80 91 6c 01 	lds	r24, 0x016C
   14348:	8c 5f       	subi	r24, 0xFC	; 252
   1434a:	5c c0       	rjmp	.+184    	; 0x14404 <FMenuSettings+0x156>
          break;	 
	 case msSelectionPage1:
		  KeyPressed=_key_scan(1);
   1434c:	81 e0       	ldi	r24, 0x01	; 1
   1434e:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   14352:	80 93 0d 03 	sts	0x030D, r24
		  KeyChar=_key_btn(KeyPressed);
   14356:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   1435a:	80 93 0c 03 	sts	0x030C, r24
		  switch(KeyChar){
   1435e:	84 33       	cpi	r24, 0x34	; 52
   14360:	d1 f0       	breq	.+52     	; 0x14396 <FMenuSettings+0xe8>
   14362:	85 33       	cpi	r24, 0x35	; 53
   14364:	50 f4       	brcc	.+20     	; 0x1437a <FMenuSettings+0xcc>
   14366:	82 33       	cpi	r24, 0x32	; 50
   14368:	91 f0       	breq	.+36     	; 0x1438e <FMenuSettings+0xe0>
   1436a:	83 33       	cpi	r24, 0x33	; 51
   1436c:	90 f4       	brcc	.+36     	; 0x14392 <FMenuSettings+0xe4>
   1436e:	8a 32       	cpi	r24, 0x2A	; 42
   14370:	d1 f0       	breq	.+52     	; 0x143a6 <FMenuSettings+0xf8>
   14372:	81 33       	cpi	r24, 0x31	; 49
   14374:	09 f0       	breq	.+2      	; 0x14378 <FMenuSettings+0xca>
   14376:	70 c0       	rjmp	.+224    	; 0x14458 <FMenuSettings+0x1aa>
   14378:	08 c0       	rjmp	.+16     	; 0x1438a <FMenuSettings+0xdc>
   1437a:	86 33       	cpi	r24, 0x36	; 54
   1437c:	81 f0       	breq	.+32     	; 0x1439e <FMenuSettings+0xf0>
   1437e:	86 33       	cpi	r24, 0x36	; 54
   14380:	60 f0       	brcs	.+24     	; 0x1439a <FMenuSettings+0xec>
   14382:	87 33       	cpi	r24, 0x37	; 55
   14384:	09 f0       	breq	.+2      	; 0x14388 <FMenuSettings+0xda>
   14386:	68 c0       	rjmp	.+208    	; 0x14458 <FMenuSettings+0x1aa>
   14388:	0c c0       	rjmp	.+24     	; 0x143a2 <FMenuSettings+0xf4>
		  case '1':
		       stMenuSettings=msMenuSettingProduct;
   1438a:	89 e0       	ldi	r24, 0x09	; 9
   1438c:	3b c0       	rjmp	.+118    	; 0x14404 <FMenuSettings+0x156>
		       break;
		  case '2': 
		       stMenuSettings=msMenuSettingPump;
   1438e:	8a e0       	ldi	r24, 0x0A	; 10
   14390:	39 c0       	rjmp	.+114    	; 0x14404 <FMenuSettings+0x156>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingDec;
   14392:	8b e0       	ldi	r24, 0x0B	; 11
   14394:	37 c0       	rjmp	.+110    	; 0x14404 <FMenuSettings+0x156>
		       break;
		  case '4':
		       stMenuSettings=msMenuSettingDatetime;
   14396:	8c e0       	ldi	r24, 0x0C	; 12
   14398:	35 c0       	rjmp	.+106    	; 0x14404 <FMenuSettings+0x156>
		       break;
		  case '5':
		       stMenuSettings=msMenuSettingPrinter;
   1439a:	8d e0       	ldi	r24, 0x0D	; 13
   1439c:	33 c0       	rjmp	.+102    	; 0x14404 <FMenuSettings+0x156>
		       break;
		  case '6':
		       stMenuSettings=msMenuSettingHost;
   1439e:	8e e0       	ldi	r24, 0x0E	; 14
   143a0:	31 c0       	rjmp	.+98     	; 0x14404 <FMenuSettings+0x156>
		       break;
		  case '7':
		       stMenuSettings=msMenuSettingNextPage;
   143a2:	87 e0       	ldi	r24, 0x07	; 7
   143a4:	2f c0       	rjmp	.+94     	; 0x14404 <FMenuSettings+0x156>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingExit;
   143a6:	82 e1       	ldi	r24, 0x12	; 18
   143a8:	2d c0       	rjmp	.+90     	; 0x14404 <FMenuSettings+0x156>
		       break;			   
		  }
	      break;
	 case msSelectionPage2:
	 	  KeyPressed=_key_scan(1);
   143aa:	81 e0       	ldi	r24, 0x01	; 1
   143ac:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   143b0:	80 93 0d 03 	sts	0x030D, r24
		  KeyChar=_key_btn(KeyPressed);
   143b4:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   143b8:	80 93 0c 03 	sts	0x030C, r24
		  switch(KeyChar){
   143bc:	82 33       	cpi	r24, 0x32	; 50
   143be:	71 f0       	breq	.+28     	; 0x143dc <FMenuSettings+0x12e>
   143c0:	83 33       	cpi	r24, 0x33	; 51
   143c2:	30 f4       	brcc	.+12     	; 0x143d0 <FMenuSettings+0x122>
   143c4:	8a 32       	cpi	r24, 0x2A	; 42
   143c6:	71 f0       	breq	.+28     	; 0x143e4 <FMenuSettings+0x136>
   143c8:	81 33       	cpi	r24, 0x31	; 49
   143ca:	09 f0       	breq	.+2      	; 0x143ce <FMenuSettings+0x120>
   143cc:	45 c0       	rjmp	.+138    	; 0x14458 <FMenuSettings+0x1aa>
   143ce:	04 c0       	rjmp	.+8      	; 0x143d8 <FMenuSettings+0x12a>
   143d0:	83 33       	cpi	r24, 0x33	; 51
   143d2:	09 f0       	breq	.+2      	; 0x143d6 <FMenuSettings+0x128>
   143d4:	41 c0       	rjmp	.+130    	; 0x14458 <FMenuSettings+0x1aa>
   143d6:	04 c0       	rjmp	.+8      	; 0x143e0 <FMenuSettings+0x132>
		  case '1':
		       stMenuSettings=msMenuSettingOperator;
   143d8:	8f e0       	ldi	r24, 0x0F	; 15
   143da:	14 c0       	rjmp	.+40     	; 0x14404 <FMenuSettings+0x156>
		       break;
		  case '2':
		       stMenuSettings=msMenuSettingSystem;
   143dc:	80 e1       	ldi	r24, 0x10	; 16
   143de:	12 c0       	rjmp	.+36     	; 0x14404 <FMenuSettings+0x156>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingPumpPooling;
   143e0:	81 e1       	ldi	r24, 0x11	; 17
   143e2:	10 c0       	rjmp	.+32     	; 0x14404 <FMenuSettings+0x156>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingBackPage;
   143e4:	88 e0       	ldi	r24, 0x08	; 8
   143e6:	0e c0       	rjmp	.+28     	; 0x14404 <FMenuSettings+0x156>
		       break;		  
		  }
	      break;
		  
	 case msMenuSettingNextPage:
	      if (PageSetting<2)PageSetting++;
   143e8:	80 91 6c 01 	lds	r24, 0x016C
   143ec:	82 30       	cpi	r24, 0x02	; 2
   143ee:	48 f4       	brcc	.+18     	; 0x14402 <FMenuSettings+0x154>
   143f0:	8f 5f       	subi	r24, 0xFF	; 255
   143f2:	05 c0       	rjmp	.+10     	; 0x143fe <FMenuSettings+0x150>
		  stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingBackPage:
	      if (PageSetting>1)PageSetting--;
   143f4:	80 91 6c 01 	lds	r24, 0x016C
   143f8:	82 30       	cpi	r24, 0x02	; 2
   143fa:	18 f0       	brcs	.+6      	; 0x14402 <FMenuSettings+0x154>
   143fc:	81 50       	subi	r24, 0x01	; 1
   143fe:	80 93 6c 01 	sts	0x016C, r24
		  stMenuSettings=msDisplayPage;
   14402:	81 e0       	ldi	r24, 0x01	; 1
   14404:	80 93 0e 03 	sts	0x030E, r24
   14408:	80 e0       	ldi	r24, 0x00	; 0
   1440a:	08 95       	ret
	      break;
//---Sub Menu Operations--------------------------------------------		  
     case msMenuSettingProduct:
	      SubMenu=FSettingProduct();
   1440c:	0e 94 ce 86 	call	0x10d9c	; 0x10d9c <FSettingProduct>
   14410:	1a c0       	rjmp	.+52     	; 0x14446 <FMenuSettings+0x198>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingPump:
	      SubMenu=FSettingPump();
   14412:	0e 94 a4 77 	call	0xef48	; 0xef48 <FSettingPump>
   14416:	17 c0       	rjmp	.+46     	; 0x14446 <FMenuSettings+0x198>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingDec:
	      SubMenu=FSettingDec();
   14418:	0e 94 71 82 	call	0x104e2	; 0x104e2 <FSettingDec>
   1441c:	14 c0       	rjmp	.+40     	; 0x14446 <FMenuSettings+0x198>
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
   1441e:	0e 94 40 63 	call	0xc680	; 0xc680 <_menu_datetime>
   14422:	08 c0       	rjmp	.+16     	; 0x14434 <FMenuSettings+0x186>
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
   14424:	0e 94 26 49 	call	0x924c	; 0x924c <_menu_printer>
   14428:	05 c0       	rjmp	.+10     	; 0x14434 <FMenuSettings+0x186>
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
   1442a:	0e 94 b3 41 	call	0x8366	; 0x8366 <_menu_host>
   1442e:	02 c0       	rjmp	.+4      	; 0x14434 <FMenuSettings+0x186>
	 return MENU_DONE;
}
char FSettingOperator(){
     _menu_user();
   14430:	0e 94 f6 61 	call	0xc3ec	; 0xc3ec <_menu_user>
	 case msMenuSettingHost:
	      SubMenu=FSettingHost();
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
     case msMenuSettingOperator:
          SubMenu=FSettingOperator();
   14434:	81 e0       	ldi	r24, 0x01	; 1
   14436:	80 93 0b 03 	sts	0x030B, r24
   1443a:	e4 cf       	rjmp	.-56     	; 0x14404 <FMenuSettings+0x156>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingSystem:
	      SubMenu=FSettingSystem();
   1443c:	0e 94 f3 9f 	call	0x13fe6	; 0x13fe6 <FSettingSystem>
   14440:	02 c0       	rjmp	.+4      	; 0x14446 <FMenuSettings+0x198>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;	 
     case msMenuSettingPumpPooling:
	      SubMenu=FSettingPumpPooling();
   14442:	0e 94 ba 6e 	call	0xdd74	; 0xdd74 <FSettingPumpPooling>
   14446:	80 93 0b 03 	sts	0x030B, r24
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
   1444a:	81 30       	cpi	r24, 0x01	; 1
   1444c:	29 f4       	brne	.+10     	; 0x14458 <FMenuSettings+0x1aa>
   1444e:	da cf       	rjmp	.-76     	; 0x14404 <FMenuSettings+0x156>
	      break;
//------------------------------------------------------------------
     case msMenuSettingExit:
	      stMenuSettings=msInit;
   14450:	10 92 0e 03 	sts	0x030E, r1
   14454:	81 e0       	ldi	r24, 0x01	; 1
   14456:	08 95       	ret
   14458:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   1445a:	08 95       	ret

0001445c <FMenuAuthorization>:
}

char FMenuAuthorization(){
char Result=MENU_NONE,PassResult=MP_NONE,SubMenu=MENU_NONE;
static char stMenuAuthorization=maInit,PassTry=0;
     switch(stMenuAuthorization){
   1445c:	80 91 4d 03 	lds	r24, 0x034D
   14460:	83 30       	cpi	r24, 0x03	; 3
   14462:	69 f1       	breq	.+90     	; 0x144be <FMenuAuthorization+0x62>
   14464:	84 30       	cpi	r24, 0x04	; 4
   14466:	28 f4       	brcc	.+10     	; 0x14472 <FMenuAuthorization+0x16>
   14468:	81 30       	cpi	r24, 0x01	; 1
   1446a:	89 f0       	breq	.+34     	; 0x1448e <FMenuAuthorization+0x32>
   1446c:	82 30       	cpi	r24, 0x02	; 2
   1446e:	50 f5       	brcc	.+84     	; 0x144c4 <FMenuAuthorization+0x68>
   14470:	0b c0       	rjmp	.+22     	; 0x14488 <FMenuAuthorization+0x2c>
   14472:	85 30       	cpi	r24, 0x05	; 5
   14474:	79 f1       	breq	.+94     	; 0x144d4 <FMenuAuthorization+0x78>
   14476:	85 30       	cpi	r24, 0x05	; 5
   14478:	40 f1       	brcs	.+80     	; 0x144ca <FMenuAuthorization+0x6e>
   1447a:	86 30       	cpi	r24, 0x06	; 6
   1447c:	09 f4       	brne	.+2      	; 0x14480 <FMenuAuthorization+0x24>
   1447e:	41 c0       	rjmp	.+130    	; 0x14502 <FMenuAuthorization+0xa6>
   14480:	87 30       	cpi	r24, 0x07	; 7
   14482:	09 f0       	breq	.+2      	; 0x14486 <FMenuAuthorization+0x2a>
   14484:	51 c0       	rjmp	.+162    	; 0x14528 <FMenuAuthorization+0xcc>
   14486:	4c c0       	rjmp	.+152    	; 0x14520 <FMenuAuthorization+0xc4>
	 case maInit:
	      PassTry=0;
   14488:	10 92 4c 03 	sts	0x034C, r1
   1448c:	42 c0       	rjmp	.+132    	; 0x14512 <FMenuAuthorization+0xb6>
		  stMenuAuthorization=maInputPassword;
	      break;
	 case maInputPassword:
	      PassResult=FMenuPassword();
   1448e:	0e 94 d9 8e 	call	0x11db2	; 0x11db2 <FMenuPassword>
		  switch(PassResult){
   14492:	83 30       	cpi	r24, 0x03	; 3
   14494:	09 f4       	brne	.+2      	; 0x14498 <FMenuAuthorization+0x3c>
   14496:	40 c0       	rjmp	.+128    	; 0x14518 <FMenuAuthorization+0xbc>
   14498:	84 30       	cpi	r24, 0x04	; 4
   1449a:	30 f4       	brcc	.+12     	; 0x144a8 <FMenuAuthorization+0x4c>
   1449c:	81 30       	cpi	r24, 0x01	; 1
   1449e:	d9 f1       	breq	.+118    	; 0x14516 <FMenuAuthorization+0xba>
   144a0:	82 30       	cpi	r24, 0x02	; 2
   144a2:	09 f0       	breq	.+2      	; 0x144a6 <FMenuAuthorization+0x4a>
   144a4:	41 c0       	rjmp	.+130    	; 0x14528 <FMenuAuthorization+0xcc>
   144a6:	09 c0       	rjmp	.+18     	; 0x144ba <FMenuAuthorization+0x5e>
   144a8:	84 30       	cpi	r24, 0x04	; 4
   144aa:	19 f0       	breq	.+6      	; 0x144b2 <FMenuAuthorization+0x56>
   144ac:	85 30       	cpi	r24, 0x05	; 5
   144ae:	e1 f5       	brne	.+120    	; 0x14528 <FMenuAuthorization+0xcc>
   144b0:	02 c0       	rjmp	.+4      	; 0x144b6 <FMenuAuthorization+0x5a>
		  case MP_VALID_ADMIN:
		       stMenuAuthorization=maMenuAdmin;
   144b2:	82 e0       	ldi	r24, 0x02	; 2
   144b4:	31 c0       	rjmp	.+98     	; 0x14518 <FMenuAuthorization+0xbc>
		       break;
		  case MP_VALID_SYSTEM:
		       stMenuAuthorization=maMenuSettings;
   144b6:	84 e0       	ldi	r24, 0x04	; 4
   144b8:	2f c0       	rjmp	.+94     	; 0x14518 <FMenuAuthorization+0xbc>
		       break;
		  case MP_INVALID:
		       stMenuAuthorization=maInvalidAuthorization;
   144ba:	85 e0       	ldi	r24, 0x05	; 5
   144bc:	2d c0       	rjmp	.+90     	; 0x14518 <FMenuAuthorization+0xbc>
		  else
	      if (PassResult==MP_CANCEL)stMenuAuthorization=maExitAuthorization;
		  */
	      break;
	 case maMenuMaster:
	      SubMenu=FMenuMaster();
   144be:	0e 94 c2 8c 	call	0x11984	; 0x11984 <FMenuMaster>
   144c2:	05 c0       	rjmp	.+10     	; 0x144ce <FMenuAuthorization+0x72>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
	      break;
	 case maMenuAdmin:
          SubMenu=FMenuAdmin();
   144c4:	0e 94 d2 90 	call	0x121a4	; 0x121a4 <FMenuAdmin>
   144c8:	02 c0       	rjmp	.+4      	; 0x144ce <FMenuAuthorization+0x72>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;          
		  break;
	 case maMenuSettings:
	      SubMenu=FMenuSettings();
   144ca:	0e 94 57 a1 	call	0x142ae	; 0x142ae <FMenuSettings>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
   144ce:	81 30       	cpi	r24, 0x01	; 1
   144d0:	59 f5       	brne	.+86     	; 0x14528 <FMenuAuthorization+0xcc>
   144d2:	21 c0       	rjmp	.+66     	; 0x14516 <FMenuAuthorization+0xba>
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
   144d4:	80 91 4c 03 	lds	r24, 0x034C
   144d8:	8f 5f       	subi	r24, 0xFF	; 255
   144da:	80 93 4c 03 	sts	0x034C, r24
	      TimDisplay=0;
   144de:	10 92 bc 01 	sts	0x01BC, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   144e2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   144e4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   144e6:	81 e0       	ldi	r24, 0x01	; 1
   144e8:	90 e0       	ldi	r25, 0x00	; 0
   144ea:	90 93 ec 01 	sts	0x01EC, r25
   144ee:	80 93 eb 01 	sts	0x01EB, r24
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
	      TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   144f2:	83 e0       	ldi	r24, 0x03	; 3
   144f4:	61 e0       	ldi	r22, 0x01	; 1
   144f6:	49 e7       	ldi	r20, 0x79	; 121
   144f8:	57 e1       	ldi	r21, 0x17	; 23
   144fa:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		  stMenuAuthorization=maDelayExitAuthorization;
   144fe:	86 e0       	ldi	r24, 0x06	; 6
   14500:	0b c0       	rjmp	.+22     	; 0x14518 <FMenuAuthorization+0xbc>
          break;	 
	 case maDelayExitAuthorization:
	      if (TimDisplay>2){
   14502:	80 91 bc 01 	lds	r24, 0x01BC
   14506:	83 30       	cpi	r24, 0x03	; 3
   14508:	78 f0       	brcs	.+30     	; 0x14528 <FMenuAuthorization+0xcc>
		      if (PassTry<3)stMenuAuthorization=maInputPassword;
   1450a:	80 91 4c 03 	lds	r24, 0x034C
   1450e:	83 30       	cpi	r24, 0x03	; 3
   14510:	10 f4       	brcc	.+4      	; 0x14516 <FMenuAuthorization+0xba>
   14512:	81 e0       	ldi	r24, 0x01	; 1
   14514:	01 c0       	rjmp	.+2      	; 0x14518 <FMenuAuthorization+0xbc>
			  else stMenuAuthorization=maExitAuthorization;
   14516:	87 e0       	ldi	r24, 0x07	; 7
   14518:	80 93 4d 03 	sts	0x034D, r24
   1451c:	80 e0       	ldi	r24, 0x00	; 0
   1451e:	08 95       	ret
		  }
	      break;
	 case maExitAuthorization:
	      stMenuAuthorization=maInit;
   14520:	10 92 4d 03 	sts	0x034D, r1
   14524:	81 e0       	ldi	r24, 0x01	; 1
   14526:	08 95       	ret
   14528:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;	 
}
   1452a:	08 95       	ret

0001452c <FMenuIdle>:
	     ProcTimeOut++;
	}
	TimSend++;
}

void FMenuIdle(){
   1452c:	1f 93       	push	r17
	static char stMenuIdle=miInit,KeyPressed=0,KeyChar=0,ButtonID=0,PrintStandaloneResult=PS_NONE;
    static unsigned int iLoopIdle=0;
	char lcdteks[20];

	switch(stMenuIdle){
   1452e:	80 91 d7 03 	lds	r24, 0x03D7
   14532:	e8 2f       	mov	r30, r24
   14534:	f0 e0       	ldi	r31, 0x00	; 0
   14536:	ea 31       	cpi	r30, 0x1A	; 26
   14538:	f1 05       	cpc	r31, r1
   1453a:	08 f0       	brcs	.+2      	; 0x1453e <FMenuIdle+0x12>
   1453c:	a3 c1       	rjmp	.+838    	; 0x14884 <FMenuIdle+0x358>
   1453e:	ec 5e       	subi	r30, 0xEC	; 236
   14540:	fe 4f       	sbci	r31, 0xFE	; 254
   14542:	ee 0f       	add	r30, r30
   14544:	ff 1f       	adc	r31, r31
   14546:	05 90       	lpm	r0, Z+
   14548:	f4 91       	lpm	r31, Z+
   1454a:	e0 2d       	mov	r30, r0
   1454c:	09 94       	ijmp
	case miInit:
         _scr_idle();
   1454e:	0e 94 92 40 	call	0x8124	; 0x8124 <_scr_idle>
   14552:	57 c1       	rjmp	.+686    	; 0x14802 <FMenuIdle+0x2d6>
		 stMenuIdle=miScan;		
	     break;
	case miScan:
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
   14554:	81 e0       	ldi	r24, 0x01	; 1
   14556:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   1455a:	80 93 d6 03 	sts	0x03D6, r24
		 KeyChar= _key_btn(KeyPressed);       
   1455e:	0e 94 91 ac 	call	0x15922	; 0x15922 <_key_btn>
   14562:	80 93 d5 03 	sts	0x03D5, r24

		 switch(KeyPressed){
   14566:	80 91 d6 03 	lds	r24, 0x03D6
   1456a:	8d 3b       	cpi	r24, 0xBD	; 189
   1456c:	09 f4       	brne	.+2      	; 0x14570 <FMenuIdle+0x44>
   1456e:	6d c0       	rjmp	.+218    	; 0x1464a <FMenuIdle+0x11e>
   14570:	8e 3b       	cpi	r24, 0xBE	; 190
   14572:	80 f4       	brcc	.+32     	; 0x14594 <FMenuIdle+0x68>
   14574:	8d 37       	cpi	r24, 0x7D	; 125
   14576:	21 f1       	breq	.+72     	; 0x145c0 <FMenuIdle+0x94>
   14578:	8e 37       	cpi	r24, 0x7E	; 126
   1457a:	30 f4       	brcc	.+12     	; 0x14588 <FMenuIdle+0x5c>
   1457c:	87 37       	cpi	r24, 0x77	; 119
   1457e:	89 f1       	breq	.+98     	; 0x145e2 <FMenuIdle+0xb6>
   14580:	8b 37       	cpi	r24, 0x7B	; 123
   14582:	09 f0       	breq	.+2      	; 0x14586 <FMenuIdle+0x5a>
   14584:	73 c0       	rjmp	.+230    	; 0x1466c <FMenuIdle+0x140>
   14586:	24 c0       	rjmp	.+72     	; 0x145d0 <FMenuIdle+0xa4>
   14588:	8e 37       	cpi	r24, 0x7E	; 126
   1458a:	a1 f0       	breq	.+40     	; 0x145b4 <FMenuIdle+0x88>
   1458c:	8b 3b       	cpi	r24, 0xBB	; 187
   1458e:	09 f0       	breq	.+2      	; 0x14592 <FMenuIdle+0x66>
   14590:	6d c0       	rjmp	.+218    	; 0x1466c <FMenuIdle+0x140>
   14592:	65 c0       	rjmp	.+202    	; 0x1465e <FMenuIdle+0x132>
   14594:	8e 3d       	cpi	r24, 0xDE	; 222
   14596:	d9 f1       	breq	.+118    	; 0x1460e <FMenuIdle+0xe2>
   14598:	8f 3d       	cpi	r24, 0xDF	; 223
   1459a:	30 f4       	brcc	.+12     	; 0x145a8 <FMenuIdle+0x7c>
   1459c:	87 3d       	cpi	r24, 0xD7	; 215
   1459e:	39 f1       	breq	.+78     	; 0x145ee <FMenuIdle+0xc2>
   145a0:	8d 3d       	cpi	r24, 0xDD	; 221
   145a2:	09 f0       	breq	.+2      	; 0x145a6 <FMenuIdle+0x7a>
   145a4:	63 c0       	rjmp	.+198    	; 0x1466c <FMenuIdle+0x140>
   145a6:	47 c0       	rjmp	.+142    	; 0x14636 <FMenuIdle+0x10a>
   145a8:	8d 3e       	cpi	r24, 0xED	; 237
   145aa:	d9 f1       	breq	.+118    	; 0x14622 <FMenuIdle+0xf6>
   145ac:	8e 3e       	cpi	r24, 0xEE	; 238
   145ae:	09 f0       	breq	.+2      	; 0x145b2 <FMenuIdle+0x86>
   145b0:	5d c0       	rjmp	.+186    	; 0x1466c <FMenuIdle+0x140>
   145b2:	23 c0       	rjmp	.+70     	; 0x145fa <FMenuIdle+0xce>
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
   145b4:	82 e0       	ldi	r24, 0x02	; 2
   145b6:	90 e0       	ldi	r25, 0x00	; 0
   145b8:	0e 94 13 14 	call	0x2826	; 0x2826 <system_beep>
   145bc:	81 e0       	ldi	r24, 0x01	; 1
   145be:	0d c0       	rjmp	.+26     	; 0x145da <FMenuIdle+0xae>
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
   145c0:	82 e0       	ldi	r24, 0x02	; 2
   145c2:	90 e0       	ldi	r25, 0x00	; 0
   145c4:	0e 94 13 14 	call	0x2826	; 0x2826 <system_beep>
   145c8:	82 e0       	ldi	r24, 0x02	; 2
   145ca:	80 93 d4 03 	sts	0x03D4, r24
   145ce:	4c c0       	rjmp	.+152    	; 0x14668 <FMenuIdle+0x13c>
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
   145d0:	82 e0       	ldi	r24, 0x02	; 2
   145d2:	90 e0       	ldi	r25, 0x00	; 0
   145d4:	0e 94 13 14 	call	0x2826	; 0x2826 <system_beep>
   145d8:	83 e0       	ldi	r24, 0x03	; 3
   145da:	80 93 d4 03 	sts	0x03D4, r24
   145de:	82 e0       	ldi	r24, 0x02	; 2
   145e0:	43 c0       	rjmp	.+134    	; 0x14668 <FMenuIdle+0x13c>
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;
   145e2:	82 e0       	ldi	r24, 0x02	; 2
   145e4:	90 e0       	ldi	r25, 0x00	; 0
   145e6:	0e 94 13 14 	call	0x2826	; 0x2826 <system_beep>
   145ea:	84 e0       	ldi	r24, 0x04	; 4
   145ec:	f6 cf       	rjmp	.-20     	; 0x145da <FMenuIdle+0xae>
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
   145ee:	82 e0       	ldi	r24, 0x02	; 2
   145f0:	90 e0       	ldi	r25, 0x00	; 0
   145f2:	0e 94 13 14 	call	0x2826	; 0x2826 <system_beep>
   145f6:	8c e0       	ldi	r24, 0x0C	; 12
   145f8:	37 c0       	rjmp	.+110    	; 0x14668 <FMenuIdle+0x13c>
	     case _KEY_1:    system_beep(2);system_beep(2); stMenuIdle=miToggleAutoCash; break;//stMenuIdle=miRunTotalizer; break;
   145fa:	82 e0       	ldi	r24, 0x02	; 2
   145fc:	90 e0       	ldi	r25, 0x00	; 0
   145fe:	0e 94 13 14 	call	0x2826	; 0x2826 <system_beep>
   14602:	82 e0       	ldi	r24, 0x02	; 2
   14604:	90 e0       	ldi	r25, 0x00	; 0
   14606:	0e 94 13 14 	call	0x2826	; 0x2826 <system_beep>
   1460a:	88 e1       	ldi	r24, 0x18	; 24
   1460c:	2d c0       	rjmp	.+90     	; 0x14668 <FMenuIdle+0x13c>
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   1460e:	80 91 25 01 	lds	r24, 0x0125
   14612:	81 30       	cpi	r24, 0x01	; 1
   14614:	59 f5       	brne	.+86     	; 0x1466c <FMenuIdle+0x140>
   14616:	82 e0       	ldi	r24, 0x02	; 2
   14618:	90 e0       	ldi	r25, 0x00	; 0
   1461a:	0e 94 13 14 	call	0x2826	; 0x2826 <system_beep>
   1461e:	80 e1       	ldi	r24, 0x10	; 16
   14620:	23 c0       	rjmp	.+70     	; 0x14668 <FMenuIdle+0x13c>
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   14622:	80 91 25 01 	lds	r24, 0x0125
   14626:	81 30       	cpi	r24, 0x01	; 1
   14628:	09 f5       	brne	.+66     	; 0x1466c <FMenuIdle+0x140>
   1462a:	82 e0       	ldi	r24, 0x02	; 2
   1462c:	90 e0       	ldi	r25, 0x00	; 0
   1462e:	0e 94 13 14 	call	0x2826	; 0x2826 <system_beep>
   14632:	82 e1       	ldi	r24, 0x12	; 18
   14634:	19 c0       	rjmp	.+50     	; 0x14668 <FMenuIdle+0x13c>
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   14636:	80 91 25 01 	lds	r24, 0x0125
   1463a:	81 30       	cpi	r24, 0x01	; 1
   1463c:	b9 f4       	brne	.+46     	; 0x1466c <FMenuIdle+0x140>
   1463e:	82 e0       	ldi	r24, 0x02	; 2
   14640:	90 e0       	ldi	r25, 0x00	; 0
   14642:	0e 94 13 14 	call	0x2826	; 0x2826 <system_beep>
   14646:	81 e1       	ldi	r24, 0x11	; 17
   14648:	0f c0       	rjmp	.+30     	; 0x14668 <FMenuIdle+0x13c>
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   1464a:	80 91 25 01 	lds	r24, 0x0125
   1464e:	81 30       	cpi	r24, 0x01	; 1
   14650:	69 f4       	brne	.+26     	; 0x1466c <FMenuIdle+0x140>
   14652:	82 e0       	ldi	r24, 0x02	; 2
   14654:	90 e0       	ldi	r25, 0x00	; 0
   14656:	0e 94 13 14 	call	0x2826	; 0x2826 <system_beep>
   1465a:	8f e0       	ldi	r24, 0x0F	; 15
   1465c:	05 c0       	rjmp	.+10     	; 0x14668 <FMenuIdle+0x13c>
		 //case _KEY_8:    system_beep(2);           stMenuIdle=miRunTestChar;   break;
		 case _KEY_9:    system_beep(2);stMenuIdle=miRunAuth;      break;
   1465e:	82 e0       	ldi	r24, 0x02	; 2
   14660:	90 e0       	ldi	r25, 0x00	; 0
   14662:	0e 94 13 14 	call	0x2826	; 0x2826 <system_beep>
   14666:	8d e0       	ldi	r24, 0x0D	; 13
   14668:	80 93 d7 03 	sts	0x03D7, r24
		 }
		 if (CashTrigger==True){
   1466c:	80 91 f6 01 	lds	r24, 0x01F6
   14670:	81 30       	cpi	r24, 0x01	; 1
   14672:	09 f0       	breq	.+2      	; 0x14676 <FMenuIdle+0x14a>
   14674:	07 c1       	rjmp	.+526    	; 0x14884 <FMenuIdle+0x358>
		     CashTrigger=False;		     
   14676:	10 92 f6 01 	sts	0x01F6, r1
		     AutoCashID++;
   1467a:	80 91 f7 01 	lds	r24, 0x01F7
   1467e:	8f 5f       	subi	r24, 0xFF	; 255
   14680:	80 93 f7 01 	sts	0x01F7, r24
		     stMenuIdle=miAutoCash;
   14684:	89 e1       	ldi	r24, 0x19	; 25
   14686:	fc c0       	rjmp	.+504    	; 0x14880 <FMenuIdle+0x354>
		 }
	     break;
    case miToggleAutoCash:
	
	     if (IsAutoCash==False){
   14688:	80 91 f5 01 	lds	r24, 0x01F5
   1468c:	88 23       	and	r24, r24
   1468e:	39 f4       	brne	.+14     	; 0x1469e <FMenuIdle+0x172>
		     IsAutoCash=True;
   14690:	81 e0       	ldi	r24, 0x01	; 1
   14692:	80 93 f5 01 	sts	0x01F5, r24
			 lcd_printf(1,16,PSTR("Auto"));
   14696:	60 e1       	ldi	r22, 0x10	; 16
   14698:	48 e2       	ldi	r20, 0x28	; 40
   1469a:	53 e2       	ldi	r21, 0x23	; 35
   1469c:	b0 c0       	rjmp	.+352    	; 0x147fe <FMenuIdle+0x2d2>
			 }
		 else {
		     lcd_printf(1,16,PSTR("    "));
   1469e:	81 e0       	ldi	r24, 0x01	; 1
   146a0:	60 e1       	ldi	r22, 0x10	; 16
   146a2:	43 e2       	ldi	r20, 0x23	; 35
   146a4:	53 e2       	ldi	r21, 0x23	; 35
   146a6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		     IsAutoCash=False;
   146aa:	10 92 f5 01 	sts	0x01F5, r1
   146ae:	a9 c0       	rjmp	.+338    	; 0x14802 <FMenuIdle+0x2d6>
			 }
		 stMenuIdle=miScan;		 
	     break;
	case miDisplayProses:
	     if (IsBusyIdlePrinting==False){
   146b0:	80 91 df 01 	lds	r24, 0x01DF
   146b4:	88 23       	and	r24, r24
   146b6:	09 f0       	breq	.+2      	; 0x146ba <FMenuIdle+0x18e>
   146b8:	a4 c0       	rjmp	.+328    	; 0x14802 <FMenuIdle+0x2d6>
		     lcd_printf(3,1,PSTR("SedangProses"));
   146ba:	83 e0       	ldi	r24, 0x03	; 3
   146bc:	61 e0       	ldi	r22, 0x01	; 1
   146be:	46 e1       	ldi	r20, 0x16	; 22
   146c0:	53 e2       	ldi	r21, 0x23	; 35
   146c2:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	         TimDisplay=0;
   146c6:	10 92 bc 01 	sts	0x01BC, r1
			 stMenuIdle=miWaitProses;
   146ca:	83 e0       	ldi	r24, 0x03	; 3
   146cc:	d9 c0       	rjmp	.+434    	; 0x14880 <FMenuIdle+0x354>
         }else stMenuIdle=miScan;
	     break;
    case miWaitProses:
	     if (TimDisplay>1){
   146ce:	80 91 bc 01 	lds	r24, 0x01BC
   146d2:	82 30       	cpi	r24, 0x02	; 2
   146d4:	08 f4       	brcc	.+2      	; 0x146d8 <FMenuIdle+0x1ac>
   146d6:	d6 c0       	rjmp	.+428    	; 0x14884 <FMenuIdle+0x358>
		     if (IFType==IT_SLAVE)stMenuIdle=miSendMessage98;
   146d8:	80 91 25 01 	lds	r24, 0x0125
   146dc:	81 30       	cpi	r24, 0x01	; 1
   146de:	11 f4       	brne	.+4      	; 0x146e4 <FMenuIdle+0x1b8>
   146e0:	84 e0       	ldi	r24, 0x04	; 4
   146e2:	ce c0       	rjmp	.+412    	; 0x14880 <FMenuIdle+0x354>
			 else
		     if (IFType==IT_STANDALONE)stMenuIdle=miPrintStandalone;
   146e4:	82 30       	cpi	r24, 0x02	; 2
   146e6:	09 f0       	breq	.+2      	; 0x146ea <FMenuIdle+0x1be>
   146e8:	cd c0       	rjmp	.+410    	; 0x14884 <FMenuIdle+0x358>
   146ea:	87 e0       	ldi	r24, 0x07	; 7
   146ec:	c9 c0       	rjmp	.+402    	; 0x14880 <FMenuIdle+0x354>
		 }
	     break;
    case miPrintStandalone:
	     PrintStandaloneResult=PrintStandalone(ButtonID,False);
   146ee:	80 91 d4 03 	lds	r24, 0x03D4
   146f2:	60 e0       	ldi	r22, 0x00	; 0
   146f4:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <PrintStandalone>
   146f8:	80 93 72 01 	sts	0x0172, r24
	     if (PrintStandaloneResult==PS_PRINTED)stMenuIdle=miReady;
   146fc:	81 31       	cpi	r24, 0x11	; 17
   146fe:	09 f4       	brne	.+2      	; 0x14702 <FMenuIdle+0x1d6>
   14700:	b6 c0       	rjmp	.+364    	; 0x1486e <FMenuIdle+0x342>
		 else
		 if (PrintStandaloneResult==PS_NO_DATA)stMenuIdle=miDisplayNoTransaction;
   14702:	82 31       	cpi	r24, 0x12	; 18
   14704:	09 f0       	breq	.+2      	; 0x14708 <FMenuIdle+0x1dc>
   14706:	be c0       	rjmp	.+380    	; 0x14884 <FMenuIdle+0x358>
   14708:	88 e0       	ldi	r24, 0x08	; 8
   1470a:	ba c0       	rjmp	.+372    	; 0x14880 <FMenuIdle+0x354>
	     break;
    case miDisplayNoTransaction:
	     lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   1470c:	83 e0       	ldi	r24, 0x03	; 3
   1470e:	61 e0       	ldi	r22, 0x01	; 1
   14710:	41 e0       	ldi	r20, 0x01	; 1
   14712:	53 e2       	ldi	r21, 0x23	; 35
   14714:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
         TimDisplay=0;
   14718:	10 92 bc 01 	sts	0x01BC, r1
		 stMenuIdle=miWaitDisplayNoTransaction;
   1471c:	89 e0       	ldi	r24, 0x09	; 9
   1471e:	b0 c0       	rjmp	.+352    	; 0x14880 <FMenuIdle+0x354>
	     break;
    case miWaitDisplayNoTransaction:
	     if (TimDisplay>1){
   14720:	80 91 bc 01 	lds	r24, 0x01BC
   14724:	82 30       	cpi	r24, 0x02	; 2
   14726:	08 f4       	brcc	.+2      	; 0x1472a <FMenuIdle+0x1fe>
   14728:	ad c0       	rjmp	.+346    	; 0x14884 <FMenuIdle+0x358>
	         lcd_printf(3,1,PSTR("Ready...            "));
   1472a:	83 e0       	ldi	r24, 0x03	; 3
   1472c:	61 e0       	ldi	r22, 0x01	; 1
   1472e:	4c ee       	ldi	r20, 0xEC	; 236
   14730:	52 e2       	ldi	r21, 0x22	; 34
   14732:	36 c0       	rjmp	.+108    	; 0x147a0 <FMenuIdle+0x274>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
		 }
	     break;
    case miSendMessage98:
	     lcd_printf(3,1,PSTR("Please Wait..       "));
   14734:	83 e0       	ldi	r24, 0x03	; 3
   14736:	61 e0       	ldi	r22, 0x01	; 1
   14738:	47 ed       	ldi	r20, 0xD7	; 215
   1473a:	52 e2       	ldi	r21, 0x22	; 34
   1473c:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	     sendMessage98(ButtonID);
   14740:	80 91 d4 03 	lds	r24, 0x03D4
   14744:	0e 94 5f 4b 	call	0x96be	; 0x96be <sendMessage98>
		 ProcTimeOut=0;
   14748:	10 92 f2 01 	sts	0x01F2, r1
   1474c:	10 92 f1 01 	sts	0x01F1, r1
		 stMenuIdle=miWaitPlease;
   14750:	85 e0       	ldi	r24, 0x05	; 5
   14752:	96 c0       	rjmp	.+300    	; 0x14880 <FMenuIdle+0x354>
	     break;
    case miWaitPlease:
         if (ProcTimeOut>TIM_NO_RESPONSE){
   14754:	80 91 f1 01 	lds	r24, 0x01F1
   14758:	90 91 f2 01 	lds	r25, 0x01F2
   1475c:	0f 97       	sbiw	r24, 0x0f	; 15
   1475e:	58 f0       	brcs	.+22     	; 0x14776 <FMenuIdle+0x24a>
	         lcd_printf(3,1,PSTR("No Response..       "));
   14760:	83 e0       	ldi	r24, 0x03	; 3
   14762:	61 e0       	ldi	r22, 0x01	; 1
   14764:	42 ec       	ldi	r20, 0xC2	; 194
   14766:	52 e2       	ldi	r21, 0x22	; 34
   14768:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		     stMenuIdle=miNoResponse;
   1476c:	86 e0       	ldi	r24, 0x06	; 6
   1476e:	80 93 d7 03 	sts	0x03D7, r24
			 TimDisplay=0;		 
   14772:	10 92 bc 01 	sts	0x01BC, r1
		 }
		 if ((IsMessage99==True)||(IsMessage00==True)){
   14776:	80 91 cc 01 	lds	r24, 0x01CC
   1477a:	81 30       	cpi	r24, 0x01	; 1
   1477c:	29 f0       	breq	.+10     	; 0x14788 <FMenuIdle+0x25c>
   1477e:	80 91 cb 01 	lds	r24, 0x01CB
   14782:	81 30       	cpi	r24, 0x01	; 1
   14784:	09 f0       	breq	.+2      	; 0x14788 <FMenuIdle+0x25c>
   14786:	7e c0       	rjmp	.+252    	; 0x14884 <FMenuIdle+0x358>
		     ClearMem(strOdometer);
   14788:	89 ec       	ldi	r24, 0xC9	; 201
   1478a:	95 e0       	ldi	r25, 0x05	; 5
   1478c:	0e 94 2b ac 	call	0x15856	; 0x15856 <ClearMem>
		     ClearMem(strLicPlate);
   14790:	82 e0       	ldi	r24, 0x02	; 2
   14792:	9b e0       	ldi	r25, 0x0B	; 11
   14794:	0e 94 2b ac 	call	0x15856	; 0x15856 <ClearMem>
	         lcd_printf(3,1,PSTR("Ready...            "));
   14798:	83 e0       	ldi	r24, 0x03	; 3
   1479a:	61 e0       	ldi	r22, 0x01	; 1
   1479c:	4d ea       	ldi	r20, 0xAD	; 173
   1479e:	52 e2       	ldi	r21, 0x22	; 34
   147a0:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		     stMenuIdle=miWaitReady;
   147a4:	8a e0       	ldi	r24, 0x0A	; 10
   147a6:	80 93 d7 03 	sts	0x03D7, r24
			 TimDisplay=0;
   147aa:	10 92 bc 01 	sts	0x01BC, r1
   147ae:	6a c0       	rjmp	.+212    	; 0x14884 <FMenuIdle+0x358>



	     break;
    case miNoResponse:
         if (TimDisplay>1){
   147b0:	80 91 bc 01 	lds	r24, 0x01BC
   147b4:	82 30       	cpi	r24, 0x02	; 2
   147b6:	08 f4       	brcc	.+2      	; 0x147ba <FMenuIdle+0x28e>
   147b8:	65 c0       	rjmp	.+202    	; 0x14884 <FMenuIdle+0x358>
	         lcd_printf(3,1,PSTR("Ready...            "));
   147ba:	83 e0       	ldi	r24, 0x03	; 3
   147bc:	61 e0       	ldi	r22, 0x01	; 1
   147be:	48 e9       	ldi	r20, 0x98	; 152
   147c0:	52 e2       	ldi	r21, 0x22	; 34
   147c2:	ee cf       	rjmp	.-36     	; 0x147a0 <FMenuIdle+0x274>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
			 }	     
	     break;
    case miWaitReady:
         if (TimDisplay>1){
   147c4:	80 91 bc 01 	lds	r24, 0x01BC
   147c8:	82 30       	cpi	r24, 0x02	; 2
   147ca:	08 f4       	brcc	.+2      	; 0x147ce <FMenuIdle+0x2a2>
   147cc:	5b c0       	rjmp	.+182    	; 0x14884 <FMenuIdle+0x358>
	         lcd_printf(3,1,PSTR("                "));
   147ce:	83 e0       	ldi	r24, 0x03	; 3
   147d0:	61 e0       	ldi	r22, 0x01	; 1
   147d2:	47 e8       	ldi	r20, 0x87	; 135
   147d4:	52 e2       	ldi	r21, 0x22	; 34
   147d6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		     stMenuIdle=miReady;
   147da:	8b e0       	ldi	r24, 0x0B	; 11
   147dc:	e4 cf       	rjmp	.-56     	; 0x147a6 <FMenuIdle+0x27a>
			 TimDisplay=0;
			 }	     
	     break;
    case miReady:
	     _scr_idle();
   147de:	0e 94 92 40 	call	0x8124	; 0x8124 <_scr_idle>
		 if (IFType==IT_STANDALONE)IsNewPumpStatus=True;
   147e2:	80 91 25 01 	lds	r24, 0x0125
   147e6:	82 30       	cpi	r24, 0x02	; 2
   147e8:	19 f4       	brne	.+6      	; 0x147f0 <FMenuIdle+0x2c4>
   147ea:	81 e0       	ldi	r24, 0x01	; 1
   147ec:	80 93 26 01 	sts	0x0126, r24

		 if (IsAutoCash==True) lcd_printf(1,16,PSTR("Auto"));
   147f0:	80 91 f5 01 	lds	r24, 0x01F5
   147f4:	81 30       	cpi	r24, 0x01	; 1
   147f6:	29 f4       	brne	.+10     	; 0x14802 <FMenuIdle+0x2d6>
   147f8:	60 e1       	ldi	r22, 0x10	; 16
   147fa:	42 e8       	ldi	r20, 0x82	; 130
   147fc:	52 e2       	ldi	r21, 0x22	; 34
   147fe:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>

		 stMenuIdle=miScan;
   14802:	81 e0       	ldi	r24, 0x01	; 1
   14804:	3d c0       	rjmp	.+122    	; 0x14880 <FMenuIdle+0x354>
	     break;
	case miRunTicket://Slave,Standalone
		 if (FMenuTicket()==MENU_DONE)
   14806:	0e 94 70 85 	call	0x10ae0	; 0x10ae0 <FMenuTicket>
   1480a:	2f c0       	rjmp	.+94     	; 0x1486a <FMenuIdle+0x33e>
		     stMenuIdle=miReady;
	     break;
	case miRunAuth://Slave,Standalone
		 if (FMenuAuthorization()==MENU_DONE)
   1480c:	0e 94 2e a2 	call	0x1445c	; 0x1445c <FMenuAuthorization>
   14810:	2c c0       	rjmp	.+88     	; 0x1486a <FMenuIdle+0x33e>
		     stMenuIdle=miReady;
	     break;
		 
    case miRunLocalAccount://Slave
		 if (FMenuLocalAccount()==MENU_DONE)
   14812:	0e 94 7e 95 	call	0x12afc	; 0x12afc <FMenuLocalAccount>
   14816:	29 c0       	rjmp	.+82     	; 0x1486a <FMenuIdle+0x33e>
		     stMenuIdle=miReady;
	     break;  
    case miRunChangeMOP://Slave
	     if (FMenuChangeMOP()==MENU_DONE)
   14818:	0e 94 47 91 	call	0x1228e	; 0x1228e <FMenuChangeMOP>
   1481c:	26 c0       	rjmp	.+76     	; 0x1486a <FMenuIdle+0x33e>
		     stMenuIdle=miReady;
	     break;
    case miRunEDC://Slave
	     if (FMenuEDCTransaction()==MENU_DONE)
   1481e:	0e 94 3a 66 	call	0xcc74	; 0xcc74 <FMenuEDCTransaction>
   14822:	23 c0       	rjmp	.+70     	; 0x1486a <FMenuIdle+0x33e>
		     stMenuIdle=miReady;
         break;
    case miRunLoyalty://Slave
	     if (FMenuLoyalty()==MENU_DONE)
   14824:	0e 94 2e 67 	call	0xce5c	; 0xce5c <FMenuLoyalty>
   14828:	20 c0       	rjmp	.+64     	; 0x1486a <FMenuIdle+0x33e>
		     stMenuIdle=miReady;
	     break;
    case miRunReprint://Slave,Standalone
	     if (FMenuReprint()==MENU_DONE)
   1482a:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <FMenuReprint>
   1482e:	1d c0       	rjmp	.+58     	; 0x1486a <FMenuIdle+0x33e>
		     stMenuIdle=miReady;
	     break;
    case miRunViewFreeMessage://Slave
	     if (FViewFreeMessage()==MENU_DONE)
   14830:	0e 94 58 40 	call	0x80b0	; 0x80b0 <FViewFreeMessage>
   14834:	1a c0       	rjmp	.+52     	; 0x1486a <FMenuIdle+0x33e>
		     stMenuIdle=miReady;
	     break;
    case miClearTotalizer://Standalone
	     lcd_printf(3,1,PSTR("Clear Data Totalizer"));
   14836:	83 e0       	ldi	r24, 0x03	; 3
   14838:	61 e0       	ldi	r22, 0x01	; 1
   1483a:	4d e6       	ldi	r20, 0x6D	; 109
   1483c:	52 e2       	ldi	r21, 0x22	; 34
   1483e:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	     ResetTotalizer(TOTALIZER_LAST);
   14842:	80 e0       	ldi	r24, 0x00	; 0
   14844:	0e 94 a8 44 	call	0x8950	; 0x8950 <ResetTotalizer>
         ResetTotalizer(TOTALIZER_NOW);
   14848:	81 e0       	ldi	r24, 0x01	; 1
   1484a:	0e 94 a8 44 	call	0x8950	; 0x8950 <ResetTotalizer>
   1484e:	0f c0       	rjmp	.+30     	; 0x1486e <FMenuIdle+0x342>
         stMenuIdle=miReady;	      
	     break;
    case miRunTotalizer://Standalone
	     lcd_printf(3,1,PSTR("TotalizerAll     "));
   14850:	83 e0       	ldi	r24, 0x03	; 3
   14852:	61 e0       	ldi	r22, 0x01	; 1
   14854:	4b e5       	ldi	r20, 0x5B	; 91
   14856:	52 e2       	ldi	r21, 0x22	; 34
   14858:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
	     SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);
   1485c:	85 e0       	ldi	r24, 0x05	; 5
   1485e:	62 e1       	ldi	r22, 0x12	; 18
   14860:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendSlaveCommand>
   14864:	04 c0       	rjmp	.+8      	; 0x1486e <FMenuIdle+0x342>
		 stMenuIdle=miReady;	      
	     break;
    case miRunTestChar:	     
 	     if (FTestChar()==MENU_DONE)
   14866:	0e 94 9b 3f 	call	0x7f36	; 0x7f36 <FTestChar>
   1486a:	81 30       	cpi	r24, 0x01	; 1
   1486c:	59 f4       	brne	.+22     	; 0x14884 <FMenuIdle+0x358>
         stMenuIdle=miReady;
   1486e:	8b e0       	ldi	r24, 0x0B	; 11
   14870:	07 c0       	rjmp	.+14     	; 0x14880 <FMenuIdle+0x354>
	     break;
    case miAutoCash:
	     ButtonID=((AutoCashID)%4)+1;
   14872:	80 91 f7 01 	lds	r24, 0x01F7
   14876:	83 70       	andi	r24, 0x03	; 3
   14878:	8f 5f       	subi	r24, 0xFF	; 255
   1487a:	80 93 d4 03 	sts	0x03D4, r24
		 //sprintf_P(lcdteks,PSTR("ID:%.2d"),ButtonID);
		 //lcd_print(1,1,lcdteks);
		 stMenuIdle=miDisplayProses;		 
   1487e:	82 e0       	ldi	r24, 0x02	; 2
   14880:	80 93 d7 03 	sts	0x03D7, r24

	}
//----------SYSTEM_PROC--------------------------------

        //Bank InfoUpdated
        if (IsMessage21==True){
   14884:	80 91 ce 01 	lds	r24, 0x01CE
   14888:	81 30       	cpi	r24, 0x01	; 1
   1488a:	21 f4       	brne	.+8      	; 0x14894 <FMenuIdle+0x368>
		    IsMessage21=False;
   1488c:	10 92 ce 01 	sts	0x01CE, r1
			procMessage21();
   14890:	0e 94 00 45 	call	0x8a00	; 0x8a00 <procMessage21>

        }
        //Transaction Status
        if (IsMessage00==True){
   14894:	80 91 cb 01 	lds	r24, 0x01CB
   14898:	81 30       	cpi	r24, 0x01	; 1
   1489a:	91 f4       	brne	.+36     	; 0x148c0 <FMenuIdle+0x394>
		    IsMessage00=False;
   1489c:	10 92 cb 01 	sts	0x01CB, r1
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   148a0:	20 91 25 0b 	lds	r18, 0x0B25
   148a4:	21 30       	cpi	r18, 0x01	; 1
   148a6:	61 f4       	brne	.+24     	; 0x148c0 <FMenuIdle+0x394>
   148a8:	80 91 b3 01 	lds	r24, 0x01B3
   148ac:	90 91 b4 01 	lds	r25, 0x01B4
   148b0:	8f 97       	sbiw	r24, 0x2f	; 47
   148b2:	31 f4       	brne	.+12     	; 0x148c0 <FMenuIdle+0x394>

        }
        //Transaction Status
        if (IsMessage00==True){
		    IsMessage00=False;
			if (procMessage00()==MSG00_NO_PRINT){
   148b4:	80 91 4a 0b 	lds	r24, 0x0B4A
   148b8:	84 33       	cpi	r24, 0x34	; 52
   148ba:	11 f4       	brne	.+4      	; 0x148c0 <FMenuIdle+0x394>
			    IsNoTransaction=True;
   148bc:	20 93 d8 01 	sts	0x01D8, r18
				}
		}
  
		//Send EDC Message Information;
		if (IsSendMessageEDC==True){
   148c0:	80 91 c3 01 	lds	r24, 0x01C3
   148c4:	81 30       	cpi	r24, 0x01	; 1
   148c6:	21 f4       	brne	.+8      	; 0x148d0 <FMenuIdle+0x3a4>
		    IsSendMessageEDC=False;
   148c8:	10 92 c3 01 	sts	0x01C3, r1
			SendEDCMessage();
   148cc:	0e 94 68 73 	call	0xe6d0	; 0xe6d0 <SendEDCMessage>
		}
		if (IsEDCApproved==True){
   148d0:	80 91 c5 01 	lds	r24, 0x01C5
   148d4:	81 30       	cpi	r24, 0x01	; 1
   148d6:	21 f4       	brne	.+8      	; 0x148e0 <FMenuIdle+0x3b4>
		    IsEDCApproved=False;
   148d8:	10 92 c5 01 	sts	0x01C5, r1
            sendMessage92();
   148dc:	0e 94 87 4c 	call	0x990e	; 0x990e <sendMessage92>
		}
		if (IsVoidTransaction==True){
   148e0:	80 91 c7 01 	lds	r24, 0x01C7
   148e4:	81 30       	cpi	r24, 0x01	; 1
   148e6:	21 f4       	brne	.+8      	; 0x148f0 <FMenuIdle+0x3c4>
		    IsVoidTransaction=False;
   148e8:	10 92 c7 01 	sts	0x01C7, r1
            sendMessage94();
   148ec:	0e 94 e0 4b 	call	0x97c0	; 0x97c0 <sendMessage94>
		}


        //Message99 Detection 
        if (IsMessage99==True){
   148f0:	10 91 cc 01 	lds	r17, 0x01CC
   148f4:	11 30       	cpi	r17, 0x01	; 1
   148f6:	31 f4       	brne	.+12     	; 0x14904 <FMenuIdle+0x3d8>
	        IsMessage99=False;
   148f8:	10 92 cc 01 	sts	0x01CC, r1
		    procMessage99();
   148fc:	0e 94 43 3d 	call	0x7a86	; 0x7a86 <procMessage99>
		    IsPrinting=True;
   14900:	10 93 d9 01 	sts	0x01D9, r17
		}
		//No Transaction
		if (IsNoTransaction==True){
   14904:	80 91 d8 01 	lds	r24, 0x01D8
   14908:	81 30       	cpi	r24, 0x01	; 1
   1490a:	41 f4       	brne	.+16     	; 0x1491c <FMenuIdle+0x3f0>
			IsNoTransaction=False;
   1490c:	10 92 d8 01 	sts	0x01D8, r1
			lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   14910:	83 e0       	ldi	r24, 0x03	; 3
   14912:	61 e0       	ldi	r22, 0x01	; 1
   14914:	46 e4       	ldi	r20, 0x46	; 70
   14916:	52 e2       	ldi	r21, 0x22	; 34
   14918:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
		}
        
		//Display Idle
		if (stMenuIdle==miScan){//||(stMenuIdle=miWaitPlease)){ 
   1491c:	80 91 d7 03 	lds	r24, 0x03D7
   14920:	81 30       	cpi	r24, 0x01	; 1
   14922:	11 f4       	brne	.+4      	; 0x14928 <FMenuIdle+0x3fc>
		    DisplayIdle();			
   14924:	0e 94 25 71 	call	0xe24a	; 0xe24a <DisplayIdle>
			}        

        //Display FreeMessage
		if (stMenuIdle==miScan){ 
   14928:	80 91 d7 03 	lds	r24, 0x03D7
   1492c:	81 30       	cpi	r24, 0x01	; 1
   1492e:	59 f4       	brne	.+22     	; 0x14946 <FMenuIdle+0x41a>
		    if (IsMessage09==True){
   14930:	80 91 d0 01 	lds	r24, 0x01D0
   14934:	81 30       	cpi	r24, 0x01	; 1
   14936:	39 f4       	brne	.+14     	; 0x14946 <FMenuIdle+0x41a>
			    IsMessage09=False;
   14938:	10 92 d0 01 	sts	0x01D0, r1
				procMessage09();
   1493c:	0e 94 10 16 	call	0x2c20	; 0x2c20 <procMessage09>
				stMenuIdle=miRunViewFreeMessage;
   14940:	83 e1       	ldi	r24, 0x13	; 19
   14942:	80 93 d7 03 	sts	0x03D7, r24
			   }
			}

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
   14946:	80 91 d7 03 	lds	r24, 0x03D7
   1494a:	81 30       	cpi	r24, 0x01	; 1
   1494c:	69 f4       	brne	.+26     	; 0x14968 <FMenuIdle+0x43c>
   1494e:	80 91 c4 01 	lds	r24, 0x01C4
   14952:	81 30       	cpi	r24, 0x01	; 1
   14954:	49 f4       	brne	.+18     	; 0x14968 <FMenuIdle+0x43c>
		    IsRFIDDetected=False;
   14956:	10 92 c4 01 	sts	0x01C4, r1
		    system_beep(2);           
   1495a:	82 e0       	ldi	r24, 0x02	; 2
   1495c:	90 e0       	ldi	r25, 0x00	; 0
   1495e:	0e 94 13 14 	call	0x2826	; 0x2826 <system_beep>
			stMenuIdle=miRunLocalAccount;
   14962:	8e e0       	ldi	r24, 0x0E	; 14
   14964:	80 93 d7 03 	sts	0x03D7, r24
		}
        //Print Spooling
		if (IsMessage81==True){
   14968:	10 91 d3 01 	lds	r17, 0x01D3
   1496c:	11 30       	cpi	r17, 0x01	; 1
   1496e:	41 f4       	brne	.+16     	; 0x14980 <FMenuIdle+0x454>
		    IsMessage81=False;
   14970:	10 92 d3 01 	sts	0x01D3, r1
			//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
			cmdPrint=procMessage81();
   14974:	0e 94 ed 16 	call	0x2dda	; 0x2dda <procMessage81>
   14978:	80 93 e0 01 	sts	0x01E0, r24
			IsFreePrinting=True;
   1497c:	10 93 d5 01 	sts	0x01D5, r17
         }

    //SystemService
      systemGenerateReport();
   14980:	0e 94 d1 30 	call	0x61a2	; 0x61a2 <systemGenerateReport>
      systemPrinting();
   14984:	0e 94 3d 5c 	call	0xb87a	; 0xb87a <systemPrinting>
	  systemEDC();
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}
   14988:	1f 91       	pop	r17
   1498a:	08 95       	ret

0001498c <InitComport>:
     	  break;	 
	 }
   return Result;
}

void InitComport(){
   1498c:	af 92       	push	r10
   1498e:	bf 92       	push	r11
   14990:	cf 92       	push	r12
   14992:	df 92       	push	r13
   14994:	ff 92       	push	r15
   14996:	0f 93       	push	r16
   14998:	1f 93       	push	r17
   1499a:	df 93       	push	r29
   1499c:	cf 93       	push	r28
   1499e:	cd b7       	in	r28, 0x3d	; 61
   149a0:	de b7       	in	r29, 0x3e	; 62
   149a2:	64 97       	sbiw	r28, 0x14	; 20
   149a4:	0f b6       	in	r0, 0x3f	; 63
   149a6:	f8 94       	cli
   149a8:	de bf       	out	0x3e, r29	; 62
   149aa:	0f be       	out	0x3f, r0	; 63
   149ac:	cd bf       	out	0x3d, r28	; 61
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
   149ae:	83 e0       	ldi	r24, 0x03	; 3
   149b0:	61 e0       	ldi	r22, 0x01	; 1
   149b2:	4e e1       	ldi	r20, 0x1E	; 30
   149b4:	5c e1       	ldi	r21, 0x1C	; 28
   149b6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
   149ba:	01 e0       	ldi	r16, 0x01	; 1
   149bc:	10 e0       	ldi	r17, 0x00	; 0
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   149be:	6e 01       	movw	r12, r28
   149c0:	08 94       	sec
   149c2:	c1 1c       	adc	r12, r1
   149c4:	d1 1c       	adc	r13, r1
   149c6:	7a e0       	ldi	r23, 0x0A	; 10
   149c8:	a7 2e       	mov	r10, r23
   149ca:	7c e1       	ldi	r23, 0x1C	; 28
   149cc:	b7 2e       	mov	r11, r23
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   149ce:	e1 99       	sbic	0x1c, 1	; 28
   149d0:	fe cf       	rjmp	.-4      	; 0x149ce <InitComport+0x42>
   149d2:	c8 01       	movw	r24, r16
   149d4:	81 59       	subi	r24, 0x91	; 145
   149d6:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   149d8:	9f bb       	out	0x1f, r25	; 31
   149da:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   149dc:	e0 9a       	sbi	0x1c, 0	; 28
   149de:	fd b2       	in	r15, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   149e0:	22 e0       	ldi	r18, 0x02	; 2
   149e2:	f2 16       	cp	r15, r18
   149e4:	71 f0       	breq	.+28     	; 0x14a02 <InitComport+0x76>
   149e6:	f2 16       	cp	r15, r18
   149e8:	30 f0       	brcs	.+12     	; 0x149f6 <InitComport+0x6a>
   149ea:	33 e0       	ldi	r19, 0x03	; 3
   149ec:	f3 16       	cp	r15, r19
   149ee:	31 f4       	brne	.+12     	; 0x149fc <InitComport+0x70>
   149f0:	85 eb       	ldi	r24, 0xB5	; 181
   149f2:	9f e2       	ldi	r25, 0x2F	; 47
   149f4:	08 c0       	rjmp	.+16     	; 0x14a06 <InitComport+0x7a>
   149f6:	80 e8       	ldi	r24, 0x80	; 128
   149f8:	95 e2       	ldi	r25, 0x25	; 37
   149fa:	05 c0       	rjmp	.+10     	; 0x14a06 <InitComport+0x7a>
   149fc:	80 e0       	ldi	r24, 0x00	; 0
   149fe:	90 e0       	ldi	r25, 0x00	; 0
   14a00:	02 c0       	rjmp	.+4      	; 0x14a06 <InitComport+0x7a>
   14a02:	80 e0       	ldi	r24, 0x00	; 0
   14a04:	9b e4       	ldi	r25, 0x4B	; 75
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   14a06:	ad b7       	in	r26, 0x3d	; 61
   14a08:	be b7       	in	r27, 0x3e	; 62
   14a0a:	18 97       	sbiw	r26, 0x08	; 8
   14a0c:	0f b6       	in	r0, 0x3f	; 63
   14a0e:	f8 94       	cli
   14a10:	be bf       	out	0x3e, r27	; 62
   14a12:	0f be       	out	0x3f, r0	; 63
   14a14:	ad bf       	out	0x3d, r26	; 61
   14a16:	ed b7       	in	r30, 0x3d	; 61
   14a18:	fe b7       	in	r31, 0x3e	; 62
   14a1a:	31 96       	adiw	r30, 0x01	; 1
   14a1c:	12 96       	adiw	r26, 0x02	; 2
   14a1e:	dc 92       	st	X, r13
   14a20:	ce 92       	st	-X, r12
   14a22:	11 97       	sbiw	r26, 0x01	; 1
   14a24:	b3 82       	std	Z+3, r11	; 0x03
   14a26:	a2 82       	std	Z+2, r10	; 0x02
   14a28:	15 83       	std	Z+5, r17	; 0x05
   14a2a:	04 83       	std	Z+4, r16	; 0x04
   14a2c:	97 83       	std	Z+7, r25	; 0x07
   14a2e:	86 83       	std	Z+6, r24	; 0x06
   14a30:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		 lcd_print(4,1,lcdteks);
   14a34:	2d b7       	in	r18, 0x3d	; 61
   14a36:	3e b7       	in	r19, 0x3e	; 62
   14a38:	28 5f       	subi	r18, 0xF8	; 248
   14a3a:	3f 4f       	sbci	r19, 0xFF	; 255
   14a3c:	0f b6       	in	r0, 0x3f	; 63
   14a3e:	f8 94       	cli
   14a40:	3e bf       	out	0x3e, r19	; 62
   14a42:	0f be       	out	0x3f, r0	; 63
   14a44:	2d bf       	out	0x3d, r18	; 61
   14a46:	84 e0       	ldi	r24, 0x04	; 4
   14a48:	61 e0       	ldi	r22, 0x01	; 1
   14a4a:	a6 01       	movw	r20, r12
   14a4c:	0e 94 92 ab 	call	0x15724	; 0x15724 <lcd_print>
		 SetBaudRate(i+1,brMap);
   14a50:	80 2f       	mov	r24, r16
   14a52:	6f 2d       	mov	r22, r15
   14a54:	0e 94 bd 9f 	call	0x13f7a	; 0x13f7a <SetBaudRate>
 	     TimDisplay=0;
   14a58:	10 92 bc 01 	sts	0x01BC, r1
   14a5c:	04 c0       	rjmp	.+8      	; 0x14a66 <InitComport+0xda>
	     while(TimDisplay<2){
		     if (TimDisplay>2)break;
   14a5e:	80 91 bc 01 	lds	r24, 0x01BC
   14a62:	83 30       	cpi	r24, 0x03	; 3
   14a64:	20 f4       	brcc	.+8      	; 0x14a6e <InitComport+0xe2>
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
		 lcd_print(4,1,lcdteks);
		 SetBaudRate(i+1,brMap);
 	     TimDisplay=0;
	     while(TimDisplay<2){
   14a66:	80 91 bc 01 	lds	r24, 0x01BC
   14a6a:	82 30       	cpi	r24, 0x02	; 2
   14a6c:	c0 f3       	brcs	.-16     	; 0x14a5e <InitComport+0xd2>
   14a6e:	0f 5f       	subi	r16, 0xFF	; 255
   14a70:	1f 4f       	sbci	r17, 0xFF	; 255

void InitComport(){
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
   14a72:	05 30       	cpi	r16, 0x05	; 5
   14a74:	11 05       	cpc	r17, r1
   14a76:	09 f0       	breq	.+2      	; 0x14a7a <InitComport+0xee>
   14a78:	aa cf       	rjmp	.-172    	; 0x149ce <InitComport+0x42>
	     while(TimDisplay<2){
		     if (TimDisplay>2)break;
		 };

	 }
}
   14a7a:	64 96       	adiw	r28, 0x14	; 20
   14a7c:	0f b6       	in	r0, 0x3f	; 63
   14a7e:	f8 94       	cli
   14a80:	de bf       	out	0x3e, r29	; 62
   14a82:	0f be       	out	0x3f, r0	; 63
   14a84:	cd bf       	out	0x3d, r28	; 61
   14a86:	cf 91       	pop	r28
   14a88:	df 91       	pop	r29
   14a8a:	1f 91       	pop	r17
   14a8c:	0f 91       	pop	r16
   14a8e:	ff 90       	pop	r15
   14a90:	df 90       	pop	r13
   14a92:	cf 90       	pop	r12
   14a94:	bf 90       	pop	r11
   14a96:	af 90       	pop	r10
   14a98:	08 95       	ret

00014a9a <SendConfigParamater>:
//		 _uart_print(1,1,strSend); 
	 }    
	 _uart_printf(1,1,PSTR("<OK>")); 
}

void SendConfigParamater(){
   14a9a:	8f 92       	push	r8
   14a9c:	9f 92       	push	r9
   14a9e:	af 92       	push	r10
   14aa0:	bf 92       	push	r11
   14aa2:	cf 92       	push	r12
   14aa4:	df 92       	push	r13
   14aa6:	ef 92       	push	r14
   14aa8:	ff 92       	push	r15
   14aaa:	0f 93       	push	r16
   14aac:	1f 93       	push	r17
   14aae:	df 93       	push	r29
   14ab0:	cf 93       	push	r28
   14ab2:	cd b7       	in	r28, 0x3d	; 61
   14ab4:	de b7       	in	r29, 0x3e	; 62
   14ab6:	c5 56       	subi	r28, 0x65	; 101
   14ab8:	d0 40       	sbci	r29, 0x00	; 0
   14aba:	0f b6       	in	r0, 0x3f	; 63
   14abc:	f8 94       	cli
   14abe:	de bf       	out	0x3e, r29	; 62
   14ac0:	0f be       	out	0x3f, r0	; 63
   14ac2:	cd bf       	out	0x3d, r28	; 61
char i,j,strSend[60];
char strEEPROM[41],xEEPROM;

     //Start
	 _uart_printf(1,0,PSTR("<"));
   14ac4:	81 e0       	ldi	r24, 0x01	; 1
   14ac6:	60 e0       	ldi	r22, 0x00	; 0
   14ac8:	4d ef       	ldi	r20, 0xFD	; 253
   14aca:	51 e2       	ldi	r21, 0x21	; 33
   14acc:	0e 94 43 b3 	call	0x16686	; 0x16686 <_uart_printf>
   14ad0:	07 e5       	ldi	r16, 0x57	; 87
   14ad2:	12 e0       	ldi	r17, 0x02	; 2
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   14ad4:	6e 01       	movw	r12, r28
   14ad6:	08 94       	sec
   14ad8:	c1 1c       	adc	r12, r1
   14ada:	d1 1c       	adc	r13, r1
     //Header Footer 400
	 for (i=0;i<10;i++){
	      eeprom_read_block((void*) &strEEPROM, (const void*) &DefHeaderFooter[i],sizeof(DefHeaderFooter[i]));
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14adc:	7a e2       	ldi	r23, 0x2A	; 42
   14ade:	e7 2e       	mov	r14, r23
   14ae0:	f1 2c       	mov	r15, r1
   14ae2:	ec 0e       	add	r14, r28
   14ae4:	fd 1e       	adc	r15, r29
   14ae6:	6a ef       	ldi	r22, 0xFA	; 250
   14ae8:	a6 2e       	mov	r10, r22
   14aea:	61 e2       	ldi	r22, 0x21	; 33
   14aec:	b6 2e       	mov	r11, r22
   14aee:	c6 01       	movw	r24, r12
   14af0:	b8 01       	movw	r22, r16
   14af2:	49 e2       	ldi	r20, 0x29	; 41
   14af4:	50 e0       	ldi	r21, 0x00	; 0
   14af6:	2c ea       	ldi	r18, 0xAC	; 172
   14af8:	32 e1       	ldi	r19, 0x12	; 18
   14afa:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
   14afe:	00 d0       	rcall	.+0      	; 0x14b00 <SendConfigParamater+0x66>
   14b00:	00 d0       	rcall	.+0      	; 0x14b02 <SendConfigParamater+0x68>
   14b02:	00 d0       	rcall	.+0      	; 0x14b04 <SendConfigParamater+0x6a>
   14b04:	ed b7       	in	r30, 0x3d	; 61
   14b06:	fe b7       	in	r31, 0x3e	; 62
   14b08:	31 96       	adiw	r30, 0x01	; 1
   14b0a:	ad b7       	in	r26, 0x3d	; 61
   14b0c:	be b7       	in	r27, 0x3e	; 62
   14b0e:	12 96       	adiw	r26, 0x02	; 2
   14b10:	fc 92       	st	X, r15
   14b12:	ee 92       	st	-X, r14
   14b14:	11 97       	sbiw	r26, 0x01	; 1
   14b16:	b3 82       	std	Z+3, r11	; 0x03
   14b18:	a2 82       	std	Z+2, r10	; 0x02
   14b1a:	d5 82       	std	Z+5, r13	; 0x05
   14b1c:	c4 82       	std	Z+4, r12	; 0x04
   14b1e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  AddSpaceLag(strSend,40);
   14b22:	ed b7       	in	r30, 0x3d	; 61
   14b24:	fe b7       	in	r31, 0x3e	; 62
   14b26:	36 96       	adiw	r30, 0x06	; 6
   14b28:	0f b6       	in	r0, 0x3f	; 63
   14b2a:	f8 94       	cli
   14b2c:	fe bf       	out	0x3e, r31	; 62
   14b2e:	0f be       	out	0x3f, r0	; 63
   14b30:	ed bf       	out	0x3d, r30	; 61
   14b32:	c7 01       	movw	r24, r14
   14b34:	68 e2       	ldi	r22, 0x28	; 40
   14b36:	0e 94 15 2a 	call	0x542a	; 0x542a <AddSpaceLag>
		  _uart_print(1,0,strSend);
   14b3a:	81 e0       	ldi	r24, 0x01	; 1
   14b3c:	60 e0       	ldi	r22, 0x00	; 0
   14b3e:	a7 01       	movw	r20, r14
   14b40:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
   14b44:	07 5d       	subi	r16, 0xD7	; 215
   14b46:	1f 4f       	sbci	r17, 0xFF	; 255
char strEEPROM[41],xEEPROM;

     //Start
	 _uart_printf(1,0,PSTR("<"));
     //Header Footer 400
	 for (i=0;i<10;i++){
   14b48:	f3 e0       	ldi	r31, 0x03	; 3
   14b4a:	01 3f       	cpi	r16, 0xF1	; 241
   14b4c:	1f 07       	cpc	r17, r31
   14b4e:	79 f6       	brne	.-98     	; 0x14aee <SendConfigParamater+0x54>
   14b50:	0b ee       	ldi	r16, 0xEB	; 235
   14b52:	10 e0       	ldi	r17, 0x00	; 0
   14b54:	6e 01       	movw	r12, r28
   14b56:	08 94       	sec
   14b58:	c1 1c       	adc	r12, r1
   14b5a:	d1 1c       	adc	r13, r1
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductName[i],sizeof(DefProductName[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14b5c:	5a e2       	ldi	r21, 0x2A	; 42
   14b5e:	e5 2e       	mov	r14, r21
   14b60:	f1 2c       	mov	r15, r1
   14b62:	ec 0e       	add	r14, r28
   14b64:	fd 1e       	adc	r15, r29
   14b66:	47 ef       	ldi	r20, 0xF7	; 247
   14b68:	a4 2e       	mov	r10, r20
   14b6a:	41 e2       	ldi	r20, 0x21	; 33
   14b6c:	b4 2e       	mov	r11, r20
   14b6e:	c6 01       	movw	r24, r12
   14b70:	b8 01       	movw	r22, r16
   14b72:	4d e0       	ldi	r20, 0x0D	; 13
   14b74:	50 e0       	ldi	r21, 0x00	; 0
   14b76:	2c ea       	ldi	r18, 0xAC	; 172
   14b78:	32 e1       	ldi	r19, 0x12	; 18
   14b7a:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
   14b7e:	00 d0       	rcall	.+0      	; 0x14b80 <SendConfigParamater+0xe6>
   14b80:	00 d0       	rcall	.+0      	; 0x14b82 <SendConfigParamater+0xe8>
   14b82:	00 d0       	rcall	.+0      	; 0x14b84 <SendConfigParamater+0xea>
   14b84:	ed b7       	in	r30, 0x3d	; 61
   14b86:	fe b7       	in	r31, 0x3e	; 62
   14b88:	31 96       	adiw	r30, 0x01	; 1
   14b8a:	ad b7       	in	r26, 0x3d	; 61
   14b8c:	be b7       	in	r27, 0x3e	; 62
   14b8e:	12 96       	adiw	r26, 0x02	; 2
   14b90:	fc 92       	st	X, r15
   14b92:	ee 92       	st	-X, r14
   14b94:	11 97       	sbiw	r26, 0x01	; 1
   14b96:	b3 82       	std	Z+3, r11	; 0x03
   14b98:	a2 82       	std	Z+2, r10	; 0x02
   14b9a:	d5 82       	std	Z+5, r13	; 0x05
   14b9c:	c4 82       	std	Z+4, r12	; 0x04
   14b9e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		 AddSpaceLag(strSend,12);
   14ba2:	ed b7       	in	r30, 0x3d	; 61
   14ba4:	fe b7       	in	r31, 0x3e	; 62
   14ba6:	36 96       	adiw	r30, 0x06	; 6
   14ba8:	0f b6       	in	r0, 0x3f	; 63
   14baa:	f8 94       	cli
   14bac:	fe bf       	out	0x3e, r31	; 62
   14bae:	0f be       	out	0x3f, r0	; 63
   14bb0:	ed bf       	out	0x3d, r30	; 61
   14bb2:	c7 01       	movw	r24, r14
   14bb4:	6c e0       	ldi	r22, 0x0C	; 12
   14bb6:	0e 94 15 2a 	call	0x542a	; 0x542a <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14bba:	81 e0       	ldi	r24, 0x01	; 1
   14bbc:	60 e0       	ldi	r22, 0x00	; 0
   14bbe:	a7 01       	movw	r20, r14
   14bc0:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
   14bc4:	03 5f       	subi	r16, 0xF3	; 243
   14bc6:	1f 4f       	sbci	r17, 0xFF	; 255
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
		  AddSpaceLag(strSend,40);
		  _uart_print(1,0,strSend);
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
   14bc8:	f1 e0       	ldi	r31, 0x01	; 1
   14bca:	09 33       	cpi	r16, 0x39	; 57
   14bcc:	1f 07       	cpc	r17, r31
   14bce:	79 f6       	brne	.-98     	; 0x14b6e <SendConfigParamater+0xd4>
   14bd0:	05 eb       	ldi	r16, 0xB5	; 181
   14bd2:	10 e0       	ldi	r17, 0x00	; 0
   14bd4:	6e 01       	movw	r12, r28
   14bd6:	08 94       	sec
   14bd8:	c1 1c       	adc	r12, r1
   14bda:	d1 1c       	adc	r13, r1
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductPrice[i],sizeof(DefProductPrice[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14bdc:	3a e2       	ldi	r19, 0x2A	; 42
   14bde:	e3 2e       	mov	r14, r19
   14be0:	f1 2c       	mov	r15, r1
   14be2:	ec 0e       	add	r14, r28
   14be4:	fd 1e       	adc	r15, r29
   14be6:	24 ef       	ldi	r18, 0xF4	; 244
   14be8:	a2 2e       	mov	r10, r18
   14bea:	21 e2       	ldi	r18, 0x21	; 33
   14bec:	b2 2e       	mov	r11, r18
   14bee:	c6 01       	movw	r24, r12
   14bf0:	b8 01       	movw	r22, r16
   14bf2:	49 e0       	ldi	r20, 0x09	; 9
   14bf4:	50 e0       	ldi	r21, 0x00	; 0
   14bf6:	2c ea       	ldi	r18, 0xAC	; 172
   14bf8:	32 e1       	ldi	r19, 0x12	; 18
   14bfa:	0e 94 a3 b4 	call	0x16946	; 0x16946 <__eerd_block>
   14bfe:	00 d0       	rcall	.+0      	; 0x14c00 <SendConfigParamater+0x166>
   14c00:	00 d0       	rcall	.+0      	; 0x14c02 <SendConfigParamater+0x168>
   14c02:	00 d0       	rcall	.+0      	; 0x14c04 <SendConfigParamater+0x16a>
   14c04:	ed b7       	in	r30, 0x3d	; 61
   14c06:	fe b7       	in	r31, 0x3e	; 62
   14c08:	31 96       	adiw	r30, 0x01	; 1
   14c0a:	ad b7       	in	r26, 0x3d	; 61
   14c0c:	be b7       	in	r27, 0x3e	; 62
   14c0e:	12 96       	adiw	r26, 0x02	; 2
   14c10:	fc 92       	st	X, r15
   14c12:	ee 92       	st	-X, r14
   14c14:	11 97       	sbiw	r26, 0x01	; 1
   14c16:	b3 82       	std	Z+3, r11	; 0x03
   14c18:	a2 82       	std	Z+2, r10	; 0x02
   14c1a:	d5 82       	std	Z+5, r13	; 0x05
   14c1c:	c4 82       	std	Z+4, r12	; 0x04
   14c1e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		 AddSpaceLag(strSend,5);
   14c22:	ed b7       	in	r30, 0x3d	; 61
   14c24:	fe b7       	in	r31, 0x3e	; 62
   14c26:	36 96       	adiw	r30, 0x06	; 6
   14c28:	0f b6       	in	r0, 0x3f	; 63
   14c2a:	f8 94       	cli
   14c2c:	fe bf       	out	0x3e, r31	; 62
   14c2e:	0f be       	out	0x3f, r0	; 63
   14c30:	ed bf       	out	0x3d, r30	; 61
   14c32:	c7 01       	movw	r24, r14
   14c34:	65 e0       	ldi	r22, 0x05	; 5
   14c36:	0e 94 15 2a 	call	0x542a	; 0x542a <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14c3a:	81 e0       	ldi	r24, 0x01	; 1
   14c3c:	60 e0       	ldi	r22, 0x00	; 0
   14c3e:	a7 01       	movw	r20, r14
   14c40:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
   14c44:	07 5f       	subi	r16, 0xF7	; 247
   14c46:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,12);
		 _uart_print(1,0,strSend);
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
   14c48:	f0 e0       	ldi	r31, 0x00	; 0
   14c4a:	0b 3e       	cpi	r16, 0xEB	; 235
   14c4c:	1f 07       	cpc	r17, r31
   14c4e:	79 f6       	brne	.-98     	; 0x14bee <SendConfigParamater+0x154>
   14c50:	05 e4       	ldi	r16, 0x45	; 69
   14c52:	10 e0       	ldi	r17, 0x00	; 0
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14c54:	9a e2       	ldi	r25, 0x2A	; 42
   14c56:	e9 2e       	mov	r14, r25
   14c58:	f1 2c       	mov	r15, r1
   14c5a:	ec 0e       	add	r14, r28
   14c5c:	fd 1e       	adc	r15, r29
   14c5e:	8f ee       	ldi	r24, 0xEF	; 239
   14c60:	c8 2e       	mov	r12, r24
   14c62:	81 e2       	ldi	r24, 0x21	; 33
   14c64:	d8 2e       	mov	r13, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14c66:	e1 99       	sbic	0x1c, 1	; 28
   14c68:	fe cf       	rjmp	.-4      	; 0x14c66 <SendConfigParamater+0x1cc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14c6a:	1f bb       	out	0x1f, r17	; 31
   14c6c:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14c6e:	e0 9a       	sbi	0x1c, 0	; 28
   14c70:	8d b3       	in	r24, 0x1d	; 29
		 _uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   14c72:	84 36       	cpi	r24, 0x64	; 100
   14c74:	08 f0       	brcs	.+2      	; 0x14c78 <SendConfigParamater+0x1de>
   14c76:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14c78:	00 d0       	rcall	.+0      	; 0x14c7a <SendConfigParamater+0x1e0>
   14c7a:	00 d0       	rcall	.+0      	; 0x14c7c <SendConfigParamater+0x1e2>
   14c7c:	00 d0       	rcall	.+0      	; 0x14c7e <SendConfigParamater+0x1e4>
   14c7e:	ed b7       	in	r30, 0x3d	; 61
   14c80:	fe b7       	in	r31, 0x3e	; 62
   14c82:	31 96       	adiw	r30, 0x01	; 1
   14c84:	ad b7       	in	r26, 0x3d	; 61
   14c86:	be b7       	in	r27, 0x3e	; 62
   14c88:	12 96       	adiw	r26, 0x02	; 2
   14c8a:	fc 92       	st	X, r15
   14c8c:	ee 92       	st	-X, r14
   14c8e:	11 97       	sbiw	r26, 0x01	; 1
   14c90:	d3 82       	std	Z+3, r13	; 0x03
   14c92:	c2 82       	std	Z+2, r12	; 0x02
   14c94:	84 83       	std	Z+4, r24	; 0x04
   14c96:	15 82       	std	Z+5, r1	; 0x05
   14c98:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  AddSpaceLag(strSend,2);
   14c9c:	ed b7       	in	r30, 0x3d	; 61
   14c9e:	fe b7       	in	r31, 0x3e	; 62
   14ca0:	36 96       	adiw	r30, 0x06	; 6
   14ca2:	0f b6       	in	r0, 0x3f	; 63
   14ca4:	f8 94       	cli
   14ca6:	fe bf       	out	0x3e, r31	; 62
   14ca8:	0f be       	out	0x3f, r0	; 63
   14caa:	ed bf       	out	0x3d, r30	; 61
   14cac:	c7 01       	movw	r24, r14
   14cae:	62 e0       	ldi	r22, 0x02	; 2
   14cb0:	0e 94 15 2a 	call	0x542a	; 0x542a <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14cb4:	81 e0       	ldi	r24, 0x01	; 1
   14cb6:	60 e0       	ldi	r22, 0x00	; 0
   14cb8:	a7 01       	movw	r20, r14
   14cba:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
   14cbe:	0f 5f       	subi	r16, 0xFF	; 255
   14cc0:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,5);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
   14cc2:	f0 e0       	ldi	r31, 0x00	; 0
   14cc4:	0d 34       	cpi	r16, 0x4D	; 77
   14cc6:	1f 07       	cpc	r17, r31
   14cc8:	71 f6       	brne	.-100    	; 0x14c66 <SendConfigParamater+0x1cc>
   14cca:	15 e5       	ldi	r17, 0x55	; 85
   14ccc:	e1 2e       	mov	r14, r17
   14cce:	10 e0       	ldi	r17, 0x00	; 0
   14cd0:	f1 2e       	mov	r15, r17
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14cd2:	ba e2       	ldi	r27, 0x2A	; 42
   14cd4:	ab 2e       	mov	r10, r27
   14cd6:	b1 2c       	mov	r11, r1
   14cd8:	ac 0e       	add	r10, r28
   14cda:	bd 1e       	adc	r11, r29
   14cdc:	ac ee       	ldi	r26, 0xEC	; 236
   14cde:	8a 2e       	mov	r8, r26
   14ce0:	a1 e2       	ldi	r26, 0x21	; 33
   14ce2:	9a 2e       	mov	r9, r26
   14ce4:	37 c0       	rjmp	.+110    	; 0x14d54 <SendConfigParamater+0x2ba>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14ce6:	e1 99       	sbic	0x1c, 1	; 28
   14ce8:	fe cf       	rjmp	.-4      	; 0x14ce6 <SendConfigParamater+0x24c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14cea:	1f bb       	out	0x1f, r17	; 31
   14cec:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14cee:	e0 9a       	sbi	0x1c, 0	; 28
   14cf0:	8d b3       	in	r24, 0x1d	; 29
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
   14cf2:	8a 30       	cpi	r24, 0x0A	; 10
   14cf4:	08 f0       	brcs	.+2      	; 0x14cf8 <SendConfigParamater+0x25e>
   14cf6:	80 e0       	ldi	r24, 0x00	; 0
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14cf8:	00 d0       	rcall	.+0      	; 0x14cfa <SendConfigParamater+0x260>
   14cfa:	00 d0       	rcall	.+0      	; 0x14cfc <SendConfigParamater+0x262>
   14cfc:	00 d0       	rcall	.+0      	; 0x14cfe <SendConfigParamater+0x264>
   14cfe:	ed b7       	in	r30, 0x3d	; 61
   14d00:	fe b7       	in	r31, 0x3e	; 62
   14d02:	31 96       	adiw	r30, 0x01	; 1
   14d04:	ad b7       	in	r26, 0x3d	; 61
   14d06:	be b7       	in	r27, 0x3e	; 62
   14d08:	12 96       	adiw	r26, 0x02	; 2
   14d0a:	bc 92       	st	X, r11
   14d0c:	ae 92       	st	-X, r10
   14d0e:	11 97       	sbiw	r26, 0x01	; 1
   14d10:	93 82       	std	Z+3, r9	; 0x03
   14d12:	82 82       	std	Z+2, r8	; 0x02
   14d14:	84 83       	std	Z+4, r24	; 0x04
   14d16:	15 82       	std	Z+5, r1	; 0x05
   14d18:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
			   _uart_print(1,0,strSend);
   14d1c:	ed b7       	in	r30, 0x3d	; 61
   14d1e:	fe b7       	in	r31, 0x3e	; 62
   14d20:	36 96       	adiw	r30, 0x06	; 6
   14d22:	0f b6       	in	r0, 0x3f	; 63
   14d24:	f8 94       	cli
   14d26:	fe bf       	out	0x3e, r31	; 62
   14d28:	0f be       	out	0x3f, r0	; 63
   14d2a:	ed bf       	out	0x3d, r30	; 61
   14d2c:	81 e0       	ldi	r24, 0x01	; 1
   14d2e:	60 e0       	ldi	r22, 0x00	; 0
   14d30:	a5 01       	movw	r20, r10
   14d32:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
   14d36:	d3 94       	inc	r13
   14d38:	0f 5f       	subi	r16, 0xFF	; 255
   14d3a:	1f 4f       	sbci	r17, 0xFF	; 255
   14d3c:	f6 e0       	ldi	r31, 0x06	; 6
   14d3e:	df 16       	cp	r13, r31
   14d40:	91 f6       	brne	.-92     	; 0x14ce6 <SendConfigParamater+0x24c>
   14d42:	86 e0       	ldi	r24, 0x06	; 6
   14d44:	90 e0       	ldi	r25, 0x00	; 0
   14d46:	e8 0e       	add	r14, r24
   14d48:	f9 1e       	adc	r15, r25
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
   14d4a:	95 e8       	ldi	r25, 0x85	; 133
   14d4c:	e9 16       	cp	r14, r25
   14d4e:	90 e0       	ldi	r25, 0x00	; 0
   14d50:	f9 06       	cpc	r15, r25
   14d52:	19 f0       	breq	.+6      	; 0x14d5a <SendConfigParamater+0x2c0>
   14d54:	87 01       	movw	r16, r14
   14d56:	dd 24       	eor	r13, r13
   14d58:	c6 cf       	rjmp	.-116    	; 0x14ce6 <SendConfigParamater+0x24c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14d5a:	e1 99       	sbic	0x1c, 1	; 28
   14d5c:	fe cf       	rjmp	.-4      	; 0x14d5a <SendConfigParamater+0x2c0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14d5e:	81 ef       	ldi	r24, 0xF1	; 241
   14d60:	93 e0       	ldi	r25, 0x03	; 3
   14d62:	9f bb       	out	0x1f, r25	; 31
   14d64:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14d66:	e0 9a       	sbi	0x1c, 0	; 28
   14d68:	8d b3       	in	r24, 0x1d	; 29
   14d6a:	9e 01       	movw	r18, r28
   14d6c:	26 5d       	subi	r18, 0xD6	; 214
   14d6e:	3f 4f       	sbci	r19, 0xFF	; 255
			   _uart_print(1,0,strSend);
		  }
	 }
	 //PrintNoMoney
	 xEEPROM=eeprom_read_byte(&DefPrintMoney);
	 if (xEEPROM==True){
   14d70:	81 30       	cpi	r24, 0x01	; 1
   14d72:	79 f4       	brne	.+30     	; 0x14d92 <SendConfigParamater+0x2f8>
		 sprintf_P(strSend,PSTR("1"));
   14d74:	00 d0       	rcall	.+0      	; 0x14d76 <SendConfigParamater+0x2dc>
   14d76:	00 d0       	rcall	.+0      	; 0x14d78 <SendConfigParamater+0x2de>
   14d78:	ad b7       	in	r26, 0x3d	; 61
   14d7a:	be b7       	in	r27, 0x3e	; 62
   14d7c:	12 96       	adiw	r26, 0x02	; 2
   14d7e:	3c 93       	st	X, r19
   14d80:	2e 93       	st	-X, r18
   14d82:	11 97       	sbiw	r26, 0x01	; 1
   14d84:	8a ee       	ldi	r24, 0xEA	; 234
   14d86:	91 e2       	ldi	r25, 0x21	; 33
   14d88:	14 96       	adiw	r26, 0x04	; 4
   14d8a:	9c 93       	st	X, r25
   14d8c:	8e 93       	st	-X, r24
   14d8e:	13 97       	sbiw	r26, 0x03	; 3
   14d90:	0a c0       	rjmp	.+20     	; 0x14da6 <SendConfigParamater+0x30c>
	 }else{
	     sprintf_P(strSend,PSTR("0"));
   14d92:	00 d0       	rcall	.+0      	; 0x14d94 <SendConfigParamater+0x2fa>
   14d94:	00 d0       	rcall	.+0      	; 0x14d96 <SendConfigParamater+0x2fc>
   14d96:	ed b7       	in	r30, 0x3d	; 61
   14d98:	fe b7       	in	r31, 0x3e	; 62
   14d9a:	32 83       	std	Z+2, r19	; 0x02
   14d9c:	21 83       	std	Z+1, r18	; 0x01
   14d9e:	88 ee       	ldi	r24, 0xE8	; 232
   14da0:	91 e2       	ldi	r25, 0x21	; 33
   14da2:	94 83       	std	Z+4, r25	; 0x04
   14da4:	83 83       	std	Z+3, r24	; 0x03
   14da6:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   14daa:	0f 90       	pop	r0
   14dac:	0f 90       	pop	r0
   14dae:	0f 90       	pop	r0
   14db0:	0f 90       	pop	r0
	 }_uart_print(1,0,strSend);
   14db2:	81 e0       	ldi	r24, 0x01	; 1
   14db4:	60 e0       	ldi	r22, 0x00	; 0
   14db6:	ae 01       	movw	r20, r28
   14db8:	46 5d       	subi	r20, 0xD6	; 214
   14dba:	5f 4f       	sbci	r21, 0xFF	; 255
   14dbc:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14dc0:	e1 99       	sbic	0x1c, 1	; 28
   14dc2:	fe cf       	rjmp	.-4      	; 0x14dc0 <SendConfigParamater+0x326>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14dc4:	80 e0       	ldi	r24, 0x00	; 0
   14dc6:	90 e0       	ldi	r25, 0x00	; 0
   14dc8:	9f bb       	out	0x1f, r25	; 31
   14dca:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14dcc:	e0 9a       	sbi	0x1c, 0	; 28
   14dce:	2d b3       	in	r18, 0x1d	; 29
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14dd0:	00 d0       	rcall	.+0      	; 0x14dd2 <SendConfigParamater+0x338>
   14dd2:	00 d0       	rcall	.+0      	; 0x14dd4 <SendConfigParamater+0x33a>
   14dd4:	00 d0       	rcall	.+0      	; 0x14dd6 <SendConfigParamater+0x33c>
   14dd6:	ed b7       	in	r30, 0x3d	; 61
   14dd8:	fe b7       	in	r31, 0x3e	; 62
   14dda:	31 96       	adiw	r30, 0x01	; 1
   14ddc:	8e 01       	movw	r16, r28
   14dde:	06 5d       	subi	r16, 0xD6	; 214
   14de0:	1f 4f       	sbci	r17, 0xFF	; 255
   14de2:	ad b7       	in	r26, 0x3d	; 61
   14de4:	be b7       	in	r27, 0x3e	; 62
   14de6:	12 96       	adiw	r26, 0x02	; 2
   14de8:	1c 93       	st	X, r17
   14dea:	0e 93       	st	-X, r16
   14dec:	11 97       	sbiw	r26, 0x01	; 1
   14dee:	83 ee       	ldi	r24, 0xE3	; 227
   14df0:	91 e2       	ldi	r25, 0x21	; 33
   14df2:	93 83       	std	Z+3, r25	; 0x03
   14df4:	82 83       	std	Z+2, r24	; 0x02
   14df6:	24 83       	std	Z+4, r18	; 0x04
   14df8:	15 82       	std	Z+5, r1	; 0x05
   14dfa:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
     _uart_print(1,0,strSend);
   14dfe:	ed b7       	in	r30, 0x3d	; 61
   14e00:	fe b7       	in	r31, 0x3e	; 62
   14e02:	36 96       	adiw	r30, 0x06	; 6
   14e04:	0f b6       	in	r0, 0x3f	; 63
   14e06:	f8 94       	cli
   14e08:	fe bf       	out	0x3e, r31	; 62
   14e0a:	0f be       	out	0x3f, r0	; 63
   14e0c:	ed bf       	out	0x3d, r30	; 61
   14e0e:	81 e0       	ldi	r24, 0x01	; 1
   14e10:	60 e0       	ldi	r22, 0x00	; 0
   14e12:	a8 01       	movw	r20, r16
   14e14:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
   14e18:	fd e4       	ldi	r31, 0x4D	; 77
   14e1a:	ef 2e       	mov	r14, r31
   14e1c:	f0 e0       	ldi	r31, 0x00	; 0
   14e1e:	ff 2e       	mov	r15, r31
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14e20:	d0 2e       	mov	r13, r16
   14e22:	01 2f       	mov	r16, r17
   14e24:	ee ed       	ldi	r30, 0xDE	; 222
   14e26:	ae 2e       	mov	r10, r30
   14e28:	e1 e2       	ldi	r30, 0x21	; 33
   14e2a:	be 2e       	mov	r11, r30
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14e2c:	e1 99       	sbic	0x1c, 1	; 28
   14e2e:	fe cf       	rjmp	.-4      	; 0x14e2c <SendConfigParamater+0x392>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14e30:	ff ba       	out	0x1f, r15	; 31
   14e32:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14e34:	e0 9a       	sbi	0x1c, 0	; 28
   14e36:	8d b3       	in	r24, 0x1d	; 29
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     _uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   14e38:	84 36       	cpi	r24, 0x64	; 100
   14e3a:	08 f0       	brcs	.+2      	; 0x14e3e <SendConfigParamater+0x3a4>
   14e3c:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14e3e:	00 d0       	rcall	.+0      	; 0x14e40 <SendConfigParamater+0x3a6>
   14e40:	00 d0       	rcall	.+0      	; 0x14e42 <SendConfigParamater+0x3a8>
   14e42:	00 d0       	rcall	.+0      	; 0x14e44 <SendConfigParamater+0x3aa>
   14e44:	ed b7       	in	r30, 0x3d	; 61
   14e46:	fe b7       	in	r31, 0x3e	; 62
   14e48:	31 96       	adiw	r30, 0x01	; 1
   14e4a:	ad b7       	in	r26, 0x3d	; 61
   14e4c:	be b7       	in	r27, 0x3e	; 62
   14e4e:	11 96       	adiw	r26, 0x01	; 1
   14e50:	dc 92       	st	X, r13
   14e52:	11 97       	sbiw	r26, 0x01	; 1
   14e54:	12 96       	adiw	r26, 0x02	; 2
   14e56:	0c 93       	st	X, r16
   14e58:	b3 82       	std	Z+3, r11	; 0x03
   14e5a:	a2 82       	std	Z+2, r10	; 0x02
   14e5c:	84 83       	std	Z+4, r24	; 0x04
   14e5e:	15 82       	std	Z+5, r1	; 0x05
   14e60:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
		  AddSpaceLag(strSend,2);
   14e64:	ed b7       	in	r30, 0x3d	; 61
   14e66:	fe b7       	in	r31, 0x3e	; 62
   14e68:	36 96       	adiw	r30, 0x06	; 6
   14e6a:	0f b6       	in	r0, 0x3f	; 63
   14e6c:	f8 94       	cli
   14e6e:	fe bf       	out	0x3e, r31	; 62
   14e70:	0f be       	out	0x3f, r0	; 63
   14e72:	ed bf       	out	0x3d, r30	; 61
   14e74:	8d 2d       	mov	r24, r13
   14e76:	90 2f       	mov	r25, r16
   14e78:	62 e0       	ldi	r22, 0x02	; 2
   14e7a:	0e 94 15 2a 	call	0x542a	; 0x542a <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14e7e:	81 e0       	ldi	r24, 0x01	; 1
   14e80:	60 e0       	ldi	r22, 0x00	; 0
   14e82:	4d 2d       	mov	r20, r13
   14e84:	50 2f       	mov	r21, r16
   14e86:	0e 94 1b b3 	call	0x16636	; 0x16636 <_uart_print>
   14e8a:	08 94       	sec
   14e8c:	e1 1c       	adc	r14, r1
   14e8e:	f1 1c       	adc	r15, r1
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     _uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
   14e90:	f5 e5       	ldi	r31, 0x55	; 85
   14e92:	ef 16       	cp	r14, r31
   14e94:	f0 e0       	ldi	r31, 0x00	; 0
   14e96:	ff 06       	cpc	r15, r31
   14e98:	49 f6       	brne	.-110    	; 0x14e2c <SendConfigParamater+0x392>
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 _uart_printf(1,1,PSTR(">"));
   14e9a:	81 e0       	ldi	r24, 0x01	; 1
   14e9c:	61 e0       	ldi	r22, 0x01	; 1
   14e9e:	4c ed       	ldi	r20, 0xDC	; 220
   14ea0:	51 e2       	ldi	r21, 0x21	; 33
   14ea2:	0e 94 43 b3 	call	0x16686	; 0x16686 <_uart_printf>
	 //End
}
   14ea6:	cb 59       	subi	r28, 0x9B	; 155
   14ea8:	df 4f       	sbci	r29, 0xFF	; 255
   14eaa:	0f b6       	in	r0, 0x3f	; 63
   14eac:	f8 94       	cli
   14eae:	de bf       	out	0x3e, r29	; 62
   14eb0:	0f be       	out	0x3f, r0	; 63
   14eb2:	cd bf       	out	0x3d, r28	; 61
   14eb4:	cf 91       	pop	r28
   14eb6:	df 91       	pop	r29
   14eb8:	1f 91       	pop	r17
   14eba:	0f 91       	pop	r16
   14ebc:	ff 90       	pop	r15
   14ebe:	ef 90       	pop	r14
   14ec0:	df 90       	pop	r13
   14ec2:	cf 90       	pop	r12
   14ec4:	bf 90       	pop	r11
   14ec6:	af 90       	pop	r10
   14ec8:	9f 90       	pop	r9
   14eca:	8f 90       	pop	r8
   14ecc:	08 95       	ret

00014ece <SaveConfigParameter>:
     char Result;
	 Result=False;
   return Result;
}

void SaveConfigParameter(){
   14ece:	8f 92       	push	r8
   14ed0:	9f 92       	push	r9
   14ed2:	af 92       	push	r10
   14ed4:	bf 92       	push	r11
   14ed6:	cf 92       	push	r12
   14ed8:	df 92       	push	r13
   14eda:	ef 92       	push	r14
   14edc:	ff 92       	push	r15
   14ede:	0f 93       	push	r16
   14ee0:	1f 93       	push	r17
   14ee2:	df 93       	push	r29
   14ee4:	cf 93       	push	r28
   14ee6:	cd b7       	in	r28, 0x3d	; 61
   14ee8:	de b7       	in	r29, 0x3e	; 62
   14eea:	c6 54       	subi	r28, 0x46	; 70
   14eec:	d0 40       	sbci	r29, 0x00	; 0
   14eee:	0f b6       	in	r0, 0x3f	; 63
   14ef0:	f8 94       	cli
   14ef2:	de bf       	out	0x3e, r29	; 62
   14ef4:	0f be       	out	0x3f, r0	; 63
   14ef6:	cd bf       	out	0x3d, r28	; 61
char strEEPROM[50],xEEPROM;
unsigned int StrPos;
char strSend[20];

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
   14ef8:	81 e0       	ldi	r24, 0x01	; 1
   14efa:	61 e0       	ldi	r22, 0x01	; 1
   14efc:	4d e0       	ldi	r20, 0x0D	; 13
   14efe:	52 e2       	ldi	r21, 0x22	; 34
   14f00:	0e 94 43 b3 	call	0x16686	; 0x16686 <_uart_printf>
   14f04:	07 e5       	ldi	r16, 0x57	; 87
   14f06:	12 e0       	ldi	r17, 0x02	; 2
   14f08:	a5 e2       	ldi	r26, 0x25	; 37
   14f0a:	ea 2e       	mov	r14, r26
   14f0c:	ab e0       	ldi	r26, 0x0B	; 11
   14f0e:	fa 2e       	mov	r15, r26
   14f10:	f5 e1       	ldi	r31, 0x15	; 21
   14f12:	af 2e       	mov	r10, r31
   14f14:	b1 2c       	mov	r11, r1
   14f16:	ac 0e       	add	r10, r28
   14f18:	bd 1e       	adc	r11, r29
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14f1a:	ed e3       	ldi	r30, 0x3D	; 61
   14f1c:	ce 2e       	mov	r12, r30
   14f1e:	d1 2c       	mov	r13, r1
   14f20:	cc 0e       	add	r12, r28
   14f22:	dd 1e       	adc	r13, r29
char strEEPROM[50],xEEPROM;
unsigned int StrPos;
char strSend[20];

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
   14f24:	d7 01       	movw	r26, r14
   14f26:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14f28:	8d 91       	ld	r24, X+
   14f2a:	81 93       	st	Z+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14f2c:	ec 15       	cp	r30, r12
   14f2e:	fd 05       	cpc	r31, r13
   14f30:	d9 f7       	brne	.-10     	; 0x14f28 <SaveConfigParameter+0x5a>
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(40*i)),40);
		 strEEPROM[40]=0;
   14f32:	1d ae       	std	Y+61, r1	; 0x3d
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   14f34:	c8 01       	movw	r24, r16
   14f36:	b5 01       	movw	r22, r10
   14f38:	49 e2       	ldi	r20, 0x29	; 41
   14f3a:	50 e0       	ldi	r21, 0x00	; 0
   14f3c:	24 eb       	ldi	r18, 0xB4	; 180
   14f3e:	32 e1       	ldi	r19, 0x12	; 18
   14f40:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
   14f44:	07 5d       	subi	r16, 0xD7	; 215
   14f46:	1f 4f       	sbci	r17, 0xFF	; 255
   14f48:	88 e2       	ldi	r24, 0x28	; 40
   14f4a:	90 e0       	ldi	r25, 0x00	; 0
   14f4c:	e8 0e       	add	r14, r24
   14f4e:	f9 1e       	adc	r15, r25
char strSend[20];

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   14f50:	93 e0       	ldi	r25, 0x03	; 3
   14f52:	01 3f       	cpi	r16, 0xF1	; 241
   14f54:	19 07       	cpc	r17, r25
   14f56:	31 f7       	brne	.-52     	; 0x14f24 <SaveConfigParameter+0x56>
   14f58:	0b ee       	ldi	r16, 0xEB	; 235
   14f5a:	10 e0       	ldi	r17, 0x00	; 0
   14f5c:	75 eb       	ldi	r23, 0xB5	; 181
   14f5e:	e7 2e       	mov	r14, r23
   14f60:	7c e0       	ldi	r23, 0x0C	; 12
   14f62:	f7 2e       	mov	r15, r23
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14f64:	65 e1       	ldi	r22, 0x15	; 21
   14f66:	c6 2e       	mov	r12, r22
   14f68:	d1 2c       	mov	r13, r1
   14f6a:	cc 0e       	add	r12, r28
   14f6c:	dd 1e       	adc	r13, r29
   14f6e:	51 e2       	ldi	r21, 0x21	; 33
   14f70:	85 2e       	mov	r8, r21
   14f72:	91 2c       	mov	r9, r1
   14f74:	8c 0e       	add	r8, r28
   14f76:	9d 1e       	adc	r9, r29
char strSend[20];

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   14f78:	d7 01       	movw	r26, r14
   14f7a:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14f7c:	8d 91       	ld	r24, X+
   14f7e:	81 93       	st	Z+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14f80:	e8 15       	cp	r30, r8
   14f82:	f9 05       	cpc	r31, r9
   14f84:	d9 f7       	brne	.-10     	; 0x14f7c <SaveConfigParameter+0xae>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   14f86:	19 a2       	std	Y+33, r1	; 0x21
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(12*i)),12);
		 RemSpaceLag(strEEPROM);
   14f88:	c6 01       	movw	r24, r12
   14f8a:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
		 strEEPROM[strlen(strEEPROM)]=0;
   14f8e:	f6 01       	movw	r30, r12
   14f90:	01 90       	ld	r0, Z+
   14f92:	00 20       	and	r0, r0
   14f94:	e9 f7       	brne	.-6      	; 0x14f90 <SaveConfigParameter+0xc2>
   14f96:	31 97       	sbiw	r30, 0x01	; 1
   14f98:	10 82       	st	Z, r1
   14f9a:	c8 01       	movw	r24, r16
   14f9c:	b6 01       	movw	r22, r12
   14f9e:	4d e0       	ldi	r20, 0x0D	; 13
   14fa0:	50 e0       	ldi	r21, 0x00	; 0
   14fa2:	24 eb       	ldi	r18, 0xB4	; 180
   14fa4:	32 e1       	ldi	r19, 0x12	; 18
   14fa6:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
   14faa:	03 5f       	subi	r16, 0xF3	; 243
   14fac:	1f 4f       	sbci	r17, 0xFF	; 255
   14fae:	ac e0       	ldi	r26, 0x0C	; 12
   14fb0:	b0 e0       	ldi	r27, 0x00	; 0
   14fb2:	ea 0e       	add	r14, r26
   14fb4:	fb 1e       	adc	r15, r27
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //_uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   14fb6:	b1 e0       	ldi	r27, 0x01	; 1
   14fb8:	09 33       	cpi	r16, 0x39	; 57
   14fba:	1b 07       	cpc	r17, r27
   14fbc:	e9 f6       	brne	.-70     	; 0x14f78 <SaveConfigParameter+0xaa>
   14fbe:	05 eb       	ldi	r16, 0xB5	; 181
   14fc0:	10 e0       	ldi	r17, 0x00	; 0
   14fc2:	4d ef       	ldi	r20, 0xFD	; 253
   14fc4:	e4 2e       	mov	r14, r20
   14fc6:	4c e0       	ldi	r20, 0x0C	; 12
   14fc8:	f4 2e       	mov	r15, r20
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14fca:	35 e1       	ldi	r19, 0x15	; 21
   14fcc:	c3 2e       	mov	r12, r19
   14fce:	d1 2c       	mov	r13, r1
   14fd0:	cc 0e       	add	r12, r28
   14fd2:	dd 1e       	adc	r13, r29
   14fd4:	2a e1       	ldi	r18, 0x1A	; 26
   14fd6:	82 2e       	mov	r8, r18
   14fd8:	91 2c       	mov	r9, r1
   14fda:	8c 0e       	add	r8, r28
   14fdc:	9d 1e       	adc	r9, r29
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //_uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   14fde:	d7 01       	movw	r26, r14
   14fe0:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14fe2:	8d 91       	ld	r24, X+
   14fe4:	81 93       	st	Z+, r24
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14fe6:	e8 15       	cp	r30, r8
   14fe8:	f9 05       	cpc	r31, r9
   14fea:	d9 f7       	brne	.-10     	; 0x14fe2 <SaveConfigParameter+0x114>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   14fec:	1a 8e       	std	Y+26, r1	; 0x1a
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(5*i)),5);
		 RemSpaceLag(strEEPROM);
   14fee:	c6 01       	movw	r24, r12
   14ff0:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <RemSpaceLag>
   14ff4:	c8 01       	movw	r24, r16
   14ff6:	b6 01       	movw	r22, r12
   14ff8:	49 e0       	ldi	r20, 0x09	; 9
   14ffa:	50 e0       	ldi	r21, 0x00	; 0
   14ffc:	24 eb       	ldi	r18, 0xB4	; 180
   14ffe:	32 e1       	ldi	r19, 0x12	; 18
   15000:	0e 94 bf b4 	call	0x1697e	; 0x1697e <__eewr_block>
   15004:	07 5f       	subi	r16, 0xF7	; 247
   15006:	1f 4f       	sbci	r17, 0xFF	; 255
   15008:	e5 e0       	ldi	r30, 0x05	; 5
   1500a:	f0 e0       	ldi	r31, 0x00	; 0
   1500c:	ee 0e       	add	r14, r30
   1500e:	ff 1e       	adc	r15, r31
		// _uart_print(1,1,strEEPROM);

	 }    
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
   15010:	f0 e0       	ldi	r31, 0x00	; 0
   15012:	0b 3e       	cpi	r16, 0xEB	; 235
   15014:	1f 07       	cpc	r17, r31
   15016:	19 f7       	brne	.-58     	; 0x14fde <SaveConfigParameter+0x110>
   15018:	0b e1       	ldi	r16, 0x1B	; 27
   1501a:	1d e0       	ldi	r17, 0x0D	; 13
   1501c:	95 e4       	ldi	r25, 0x45	; 69
   1501e:	e9 2e       	mov	r14, r25
   15020:	90 e0       	ldi	r25, 0x00	; 0
   15022:	f9 2e       	mov	r15, r25
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   15024:	85 e1       	ldi	r24, 0x15	; 21
   15026:	c8 2e       	mov	r12, r24
   15028:	d1 2c       	mov	r13, r1
   1502a:	cc 0e       	add	r12, r28
   1502c:	dd 1e       	adc	r13, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   1502e:	4e 01       	movw	r8, r28
   15030:	08 94       	sec
   15032:	81 1c       	adc	r8, r1
   15034:	91 1c       	adc	r9, r1
   15036:	ba e0       	ldi	r27, 0x0A	; 10
   15038:	ab 2e       	mov	r10, r27
   1503a:	b2 e2       	ldi	r27, 0x22	; 34
   1503c:	bb 2e       	mov	r11, r27
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1503e:	d8 01       	movw	r26, r16
   15040:	8c 91       	ld	r24, X
   15042:	8d 8b       	std	Y+21, r24	; 0x15
   15044:	11 96       	adiw	r26, 0x01	; 1
   15046:	8c 91       	ld	r24, X
   15048:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   1504a:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   1504c:	c6 01       	movw	r24, r12
   1504e:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   15052:	c6 01       	movw	r24, r12
   15054:	0e 94 6e b4 	call	0x168dc	; 0x168dc <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15058:	e1 99       	sbic	0x1c, 1	; 28
   1505a:	fe cf       	rjmp	.-4      	; 0x15058 <SaveConfigParameter+0x18a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1505c:	ff ba       	out	0x1f, r15	; 31
   1505e:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   15060:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   15062:	0f b6       	in	r0, 0x3f	; 63
   15064:	f8 94       	cli
   15066:	e2 9a       	sbi	0x1c, 2	; 28
   15068:	e1 9a       	sbi	0x1c, 1	; 28
   1506a:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   1506c:	00 d0       	rcall	.+0      	; 0x1506e <SaveConfigParameter+0x1a0>
   1506e:	00 d0       	rcall	.+0      	; 0x15070 <SaveConfigParameter+0x1a2>
   15070:	00 d0       	rcall	.+0      	; 0x15072 <SaveConfigParameter+0x1a4>
   15072:	ed b7       	in	r30, 0x3d	; 61
   15074:	fe b7       	in	r31, 0x3e	; 62
   15076:	31 96       	adiw	r30, 0x01	; 1
   15078:	ad b7       	in	r26, 0x3d	; 61
   1507a:	be b7       	in	r27, 0x3e	; 62
   1507c:	12 96       	adiw	r26, 0x02	; 2
   1507e:	9c 92       	st	X, r9
   15080:	8e 92       	st	-X, r8
   15082:	11 97       	sbiw	r26, 0x01	; 1
   15084:	b3 82       	std	Z+3, r11	; 0x03
   15086:	a2 82       	std	Z+2, r10	; 0x02
   15088:	84 83       	std	Z+4, r24	; 0x04
   1508a:	15 82       	std	Z+5, r1	; 0x05
   1508c:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   15090:	0e 5f       	subi	r16, 0xFE	; 254
   15092:	1f 4f       	sbci	r17, 0xFF	; 255
   15094:	08 94       	sec
   15096:	e1 1c       	adc	r14, r1
   15098:	f1 1c       	adc	r15, r1
		// _uart_print(1,1,strEEPROM);

	 }    
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
   1509a:	ed b7       	in	r30, 0x3d	; 61
   1509c:	fe b7       	in	r31, 0x3e	; 62
   1509e:	36 96       	adiw	r30, 0x06	; 6
   150a0:	0f b6       	in	r0, 0x3f	; 63
   150a2:	f8 94       	cli
   150a4:	fe bf       	out	0x3e, r31	; 62
   150a6:	0f be       	out	0x3f, r0	; 63
   150a8:	ed bf       	out	0x3d, r30	; 61
   150aa:	fd e0       	ldi	r31, 0x0D	; 13
   150ac:	0b 32       	cpi	r16, 0x2B	; 43
   150ae:	1f 07       	cpc	r17, r31
   150b0:	09 f0       	breq	.+2      	; 0x150b4 <SaveConfigParameter+0x1e6>
   150b2:	c5 cf       	rjmp	.-118    	; 0x1503e <SaveConfigParameter+0x170>
   150b4:	45 e5       	ldi	r20, 0x55	; 85
   150b6:	50 e0       	ldi	r21, 0x00	; 0
   150b8:	b8 01       	movw	r22, r16
   150ba:	1d c0       	rjmp	.+58     	; 0x150f6 <SaveConfigParameter+0x228>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   150bc:	90 81       	ld	r25, Z
   150be:	90 53       	subi	r25, 0x30	; 48
   150c0:	9a 30       	cpi	r25, 0x0A	; 10
   150c2:	08 f0       	brcs	.+2      	; 0x150c6 <SaveConfigParameter+0x1f8>
   150c4:	90 e0       	ldi	r25, 0x00	; 0
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   150c6:	e1 99       	sbic	0x1c, 1	; 28
   150c8:	fe cf       	rjmp	.-4      	; 0x150c6 <SaveConfigParameter+0x1f8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   150ca:	3f bb       	out	0x1f, r19	; 31
   150cc:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
   150ce:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
   150d0:	0f b6       	in	r0, 0x3f	; 63
   150d2:	f8 94       	cli
   150d4:	e2 9a       	sbi	0x1c, 2	; 28
   150d6:	e1 9a       	sbi	0x1c, 1	; 28
   150d8:	0f be       	out	0x3f, r0	; 63

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
	     for (j=0;j<6;j++){
   150da:	8f 5f       	subi	r24, 0xFF	; 255
   150dc:	31 96       	adiw	r30, 0x01	; 1
   150de:	2f 5f       	subi	r18, 0xFF	; 255
   150e0:	3f 4f       	sbci	r19, 0xFF	; 255
   150e2:	86 30       	cpi	r24, 0x06	; 6
   150e4:	59 f7       	brne	.-42     	; 0x150bc <SaveConfigParameter+0x1ee>
   150e6:	4a 5f       	subi	r20, 0xFA	; 250
   150e8:	5f 4f       	sbci	r21, 0xFF	; 255
   150ea:	6a 5f       	subi	r22, 0xFA	; 250
   150ec:	7f 4f       	sbci	r23, 0xFF	; 255
		// _uart_print(1,1,strSend); 

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
   150ee:	80 e0       	ldi	r24, 0x00	; 0
   150f0:	45 38       	cpi	r20, 0x85	; 133
   150f2:	58 07       	cpc	r21, r24
   150f4:	21 f0       	breq	.+8      	; 0x150fe <SaveConfigParameter+0x230>
   150f6:	fb 01       	movw	r30, r22
   150f8:	9a 01       	movw	r18, r20
   150fa:	80 e0       	ldi	r24, 0x00	; 0
   150fc:	df cf       	rjmp	.-66     	; 0x150bc <SaveConfigParameter+0x1ee>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   150fe:	80 91 5b 0d 	lds	r24, 0x0D5B
   15102:	80 53       	subi	r24, 0x30	; 48
   15104:	8a 30       	cpi	r24, 0x0A	; 10
   15106:	10 f0       	brcs	.+4      	; 0x1510c <SaveConfigParameter+0x23e>
   15108:	20 e0       	ldi	r18, 0x00	; 0
   1510a:	03 c0       	rjmp	.+6      	; 0x15112 <SaveConfigParameter+0x244>
   1510c:	81 11       	cpse	r24, r1
   1510e:	81 e0       	ldi	r24, 0x01	; 1
   15110:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15112:	e1 99       	sbic	0x1c, 1	; 28
   15114:	fe cf       	rjmp	.-4      	; 0x15112 <SaveConfigParameter+0x244>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15116:	81 ef       	ldi	r24, 0xF1	; 241
   15118:	93 e0       	ldi	r25, 0x03	; 3
   1511a:	9f bb       	out	0x1f, r25	; 31
   1511c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   1511e:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   15120:	0f b6       	in	r0, 0x3f	; 63
   15122:	f8 94       	cli
   15124:	e2 9a       	sbi	0x1c, 2	; 28
   15126:	e1 9a       	sbi	0x1c, 1	; 28
   15128:	0f be       	out	0x3f, r0	; 63
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1512a:	80 91 5c 0d 	lds	r24, 0x0D5C
   1512e:	8d 8b       	std	Y+21, r24	; 0x15
   15130:	80 91 5d 0d 	lds	r24, 0x0D5D
   15134:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   15136:	1f 8a       	std	Y+23, r1	; 0x17

	 //TermID
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1;
     FillChar(strEEPROM,0,sizeof(strEEPROM));   
	 StrPosCopy(rcv_trans,strEEPROM,StrPos,2);
	 RemZeroLead(strEEPROM);
   15138:	8e 01       	movw	r16, r28
   1513a:	0b 5e       	subi	r16, 0xEB	; 235
   1513c:	1f 4f       	sbci	r17, 0xFF	; 255
   1513e:	c8 01       	movw	r24, r16
   15140:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
	 xEEPROM=atoi(strEEPROM);
   15144:	c8 01       	movw	r24, r16
   15146:	0e 94 6e b4 	call	0x168dc	; 0x168dc <atoi>
   1514a:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1514c:	e1 99       	sbic	0x1c, 1	; 28
   1514e:	fe cf       	rjmp	.-4      	; 0x1514c <SaveConfigParameter+0x27e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15150:	80 e0       	ldi	r24, 0x00	; 0
   15152:	90 e0       	ldi	r25, 0x00	; 0
   15154:	9f bb       	out	0x1f, r25	; 31
   15156:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   15158:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   1515a:	0f b6       	in	r0, 0x3f	; 63
   1515c:	f8 94       	cli
   1515e:	e2 9a       	sbi	0x1c, 2	; 28
   15160:	e1 9a       	sbi	0x1c, 1	; 28
   15162:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefIFT_ID,xEEPROM);
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   15164:	00 d0       	rcall	.+0      	; 0x15166 <SaveConfigParameter+0x298>
   15166:	00 d0       	rcall	.+0      	; 0x15168 <SaveConfigParameter+0x29a>
   15168:	00 d0       	rcall	.+0      	; 0x1516a <SaveConfigParameter+0x29c>
   1516a:	ed b7       	in	r30, 0x3d	; 61
   1516c:	fe b7       	in	r31, 0x3e	; 62
   1516e:	31 96       	adiw	r30, 0x01	; 1
   15170:	8e 01       	movw	r16, r28
   15172:	0f 5f       	subi	r16, 0xFF	; 255
   15174:	1f 4f       	sbci	r17, 0xFF	; 255
   15176:	ad b7       	in	r26, 0x3d	; 61
   15178:	be b7       	in	r27, 0x3e	; 62
   1517a:	12 96       	adiw	r26, 0x02	; 2
   1517c:	1c 93       	st	X, r17
   1517e:	0e 93       	st	-X, r16
   15180:	11 97       	sbiw	r26, 0x01	; 1
   15182:	87 e0       	ldi	r24, 0x07	; 7
   15184:	92 e2       	ldi	r25, 0x22	; 34
   15186:	93 83       	std	Z+3, r25	; 0x03
   15188:	82 83       	std	Z+2, r24	; 0x02
   1518a:	24 83       	std	Z+4, r18	; 0x04
   1518c:	15 82       	std	Z+5, r1	; 0x05
   1518e:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   15192:	ae e5       	ldi	r26, 0x5E	; 94
   15194:	ea 2e       	mov	r14, r26
   15196:	ad e0       	ldi	r26, 0x0D	; 13
   15198:	fa 2e       	mov	r15, r26
   1519a:	fd e4       	ldi	r31, 0x4D	; 77
   1519c:	cf 2e       	mov	r12, r31
   1519e:	f0 e0       	ldi	r31, 0x00	; 0
   151a0:	df 2e       	mov	r13, r31
   151a2:	ed b7       	in	r30, 0x3d	; 61
   151a4:	fe b7       	in	r31, 0x3e	; 62
   151a6:	36 96       	adiw	r30, 0x06	; 6
   151a8:	0f b6       	in	r0, 0x3f	; 63
   151aa:	f8 94       	cli
   151ac:	fe bf       	out	0x3e, r31	; 62
   151ae:	0f be       	out	0x3f, r0	; 63
   151b0:	ed bf       	out	0x3d, r30	; 61
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   151b2:	e5 e1       	ldi	r30, 0x15	; 21
   151b4:	ae 2e       	mov	r10, r30
   151b6:	b1 2c       	mov	r11, r1
   151b8:	ac 0e       	add	r10, r28
   151ba:	bd 1e       	adc	r11, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   151bc:	48 01       	movw	r8, r16
   151be:	04 e0       	ldi	r16, 0x04	; 4
   151c0:	12 e2       	ldi	r17, 0x22	; 34
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   151c2:	d7 01       	movw	r26, r14
   151c4:	8c 91       	ld	r24, X
   151c6:	8d 8b       	std	Y+21, r24	; 0x15
   151c8:	11 96       	adiw	r26, 0x01	; 1
   151ca:	8c 91       	ld	r24, X
   151cc:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   151ce:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   151d0:	c5 01       	movw	r24, r10
   151d2:	0e 94 69 22 	call	0x44d2	; 0x44d2 <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   151d6:	c5 01       	movw	r24, r10
   151d8:	0e 94 6e b4 	call	0x168dc	; 0x168dc <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   151dc:	e1 99       	sbic	0x1c, 1	; 28
   151de:	fe cf       	rjmp	.-4      	; 0x151dc <SaveConfigParameter+0x30e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   151e0:	df ba       	out	0x1f, r13	; 31
   151e2:	ce ba       	out	0x1e, r12	; 30
#endif
    EEDR = __value;
   151e4:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   151e6:	0f b6       	in	r0, 0x3f	; 63
   151e8:	f8 94       	cli
   151ea:	e2 9a       	sbi	0x1c, 2	; 28
   151ec:	e1 9a       	sbi	0x1c, 1	; 28
   151ee:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   151f0:	00 d0       	rcall	.+0      	; 0x151f2 <SaveConfigParameter+0x324>
   151f2:	00 d0       	rcall	.+0      	; 0x151f4 <SaveConfigParameter+0x326>
   151f4:	00 d0       	rcall	.+0      	; 0x151f6 <SaveConfigParameter+0x328>
   151f6:	ed b7       	in	r30, 0x3d	; 61
   151f8:	fe b7       	in	r31, 0x3e	; 62
   151fa:	31 96       	adiw	r30, 0x01	; 1
   151fc:	ad b7       	in	r26, 0x3d	; 61
   151fe:	be b7       	in	r27, 0x3e	; 62
   15200:	11 96       	adiw	r26, 0x01	; 1
   15202:	8c 92       	st	X, r8
   15204:	11 97       	sbiw	r26, 0x01	; 1
   15206:	12 96       	adiw	r26, 0x02	; 2
   15208:	9c 92       	st	X, r9
   1520a:	13 83       	std	Z+3, r17	; 0x03
   1520c:	02 83       	std	Z+2, r16	; 0x02
   1520e:	84 83       	std	Z+4, r24	; 0x04
   15210:	15 82       	std	Z+5, r1	; 0x05
   15212:	0e 94 e3 b4 	call	0x169c6	; 0x169c6 <sprintf_P>
   15216:	e2 e0       	ldi	r30, 0x02	; 2
   15218:	f0 e0       	ldi	r31, 0x00	; 0
   1521a:	ee 0e       	add	r14, r30
   1521c:	ff 1e       	adc	r15, r31
   1521e:	08 94       	sec
   15220:	c1 1c       	adc	r12, r1
   15222:	d1 1c       	adc	r13, r1
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//	 _uart_print(1,1,strSend); 

	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
   15224:	8d b7       	in	r24, 0x3d	; 61
   15226:	9e b7       	in	r25, 0x3e	; 62
   15228:	06 96       	adiw	r24, 0x06	; 6
   1522a:	0f b6       	in	r0, 0x3f	; 63
   1522c:	f8 94       	cli
   1522e:	9e bf       	out	0x3e, r25	; 62
   15230:	0f be       	out	0x3f, r0	; 63
   15232:	8d bf       	out	0x3d, r24	; 61
   15234:	9e e6       	ldi	r25, 0x6E	; 110
   15236:	e9 16       	cp	r14, r25
   15238:	9d e0       	ldi	r25, 0x0D	; 13
   1523a:	f9 06       	cpc	r15, r25
   1523c:	09 f0       	breq	.+2      	; 0x15240 <SaveConfigParameter+0x372>
   1523e:	c1 cf       	rjmp	.-126    	; 0x151c2 <SaveConfigParameter+0x2f4>
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//		 _uart_print(1,1,strSend); 
	 }    
	 _uart_printf(1,1,PSTR("<OK>")); 
   15240:	81 e0       	ldi	r24, 0x01	; 1
   15242:	61 e0       	ldi	r22, 0x01	; 1
   15244:	4f ef       	ldi	r20, 0xFF	; 255
   15246:	51 e2       	ldi	r21, 0x21	; 33
   15248:	0e 94 43 b3 	call	0x16686	; 0x16686 <_uart_printf>
}
   1524c:	ca 5b       	subi	r28, 0xBA	; 186
   1524e:	df 4f       	sbci	r29, 0xFF	; 255
   15250:	0f b6       	in	r0, 0x3f	; 63
   15252:	f8 94       	cli
   15254:	de bf       	out	0x3e, r29	; 62
   15256:	0f be       	out	0x3f, r0	; 63
   15258:	cd bf       	out	0x3d, r28	; 61
   1525a:	cf 91       	pop	r28
   1525c:	df 91       	pop	r29
   1525e:	1f 91       	pop	r17
   15260:	0f 91       	pop	r16
   15262:	ff 90       	pop	r15
   15264:	ef 90       	pop	r14
   15266:	df 90       	pop	r13
   15268:	cf 90       	pop	r12
   1526a:	bf 90       	pop	r11
   1526c:	af 90       	pop	r10
   1526e:	9f 90       	pop	r9
   15270:	8f 90       	pop	r8
   15272:	08 95       	ret

00015274 <ConfigProtocol>:
	 }
	 _uart_printf(1,1,PSTR(">"));
	 //End
}

void ConfigProtocol(char dataIn){
   15274:	1f 93       	push	r17
   15276:	18 2f       	mov	r17, r24
     static char Conflow[7];
    //Configuration Data Request 
	if ((Conflow[6]=='i')&&(Conflow[5]=='C')&&(Conflow[4]=='o')&&(Conflow[3]=='n')&&(Conflow[2]=='f')&&(Conflow[1]=='?')&&(Conflow[0]==0x0D)&&(dataIn==0x0A)){
   15278:	80 91 c8 03 	lds	r24, 0x03C8
   1527c:	89 36       	cpi	r24, 0x69	; 105
   1527e:	e1 f4       	brne	.+56     	; 0x152b8 <ConfigProtocol+0x44>
   15280:	80 91 c7 03 	lds	r24, 0x03C7
   15284:	83 34       	cpi	r24, 0x43	; 67
   15286:	c1 f4       	brne	.+48     	; 0x152b8 <ConfigProtocol+0x44>
   15288:	80 91 c6 03 	lds	r24, 0x03C6
   1528c:	8f 36       	cpi	r24, 0x6F	; 111
   1528e:	a1 f4       	brne	.+40     	; 0x152b8 <ConfigProtocol+0x44>
   15290:	80 91 c5 03 	lds	r24, 0x03C5
   15294:	8e 36       	cpi	r24, 0x6E	; 110
   15296:	81 f4       	brne	.+32     	; 0x152b8 <ConfigProtocol+0x44>
   15298:	80 91 c4 03 	lds	r24, 0x03C4
   1529c:	86 36       	cpi	r24, 0x66	; 102
   1529e:	61 f4       	brne	.+24     	; 0x152b8 <ConfigProtocol+0x44>
   152a0:	80 91 c3 03 	lds	r24, 0x03C3
   152a4:	8f 33       	cpi	r24, 0x3F	; 63
   152a6:	41 f4       	brne	.+16     	; 0x152b8 <ConfigProtocol+0x44>
   152a8:	80 91 c2 03 	lds	r24, 0x03C2
   152ac:	8d 30       	cpi	r24, 0x0D	; 13
   152ae:	21 f4       	brne	.+8      	; 0x152b8 <ConfigProtocol+0x44>
   152b0:	1a 30       	cpi	r17, 0x0A	; 10
   152b2:	11 f4       	brne	.+4      	; 0x152b8 <ConfigProtocol+0x44>
	     SendConfigParamater();        
   152b4:	0e 94 4d a5 	call	0x14a9a	; 0x14a9a <SendConfigParamater>
	}

	if (IsConfigFlow==True){        
   152b8:	80 91 ae 01 	lds	r24, 0x01AE
   152bc:	81 30       	cpi	r24, 0x01	; 1
   152be:	69 f4       	brne	.+26     	; 0x152da <ConfigProtocol+0x66>
	    rcv_trans[char_count]=dataIn;
   152c0:	80 91 b1 01 	lds	r24, 0x01B1
   152c4:	90 91 b2 01 	lds	r25, 0x01B2
   152c8:	fc 01       	movw	r30, r24
   152ca:	eb 5d       	subi	r30, 0xDB	; 219
   152cc:	f4 4f       	sbci	r31, 0xF4	; 244
   152ce:	10 83       	st	Z, r17
	    char_count++; 
   152d0:	01 96       	adiw	r24, 0x01	; 1
   152d2:	90 93 b2 01 	sts	0x01B2, r25
   152d6:	80 93 b1 01 	sts	0x01B1, r24
	}
	if ((Conflow[0]==0x04)&&(dataIn==0x40)){
   152da:	80 91 c2 03 	lds	r24, 0x03C2
   152de:	84 30       	cpi	r24, 0x04	; 4
   152e0:	51 f4       	brne	.+20     	; 0x152f6 <ConfigProtocol+0x82>
   152e2:	10 34       	cpi	r17, 0x40	; 64
   152e4:	81 f4       	brne	.+32     	; 0x15306 <ConfigProtocol+0x92>
	     IsConfigFlow=True;
   152e6:	81 e0       	ldi	r24, 0x01	; 1
   152e8:	80 93 ae 01 	sts	0x01AE, r24
		 char_count=0;
   152ec:	10 92 b2 01 	sts	0x01B2, r1
   152f0:	10 92 b1 01 	sts	0x01B1, r1
   152f4:	08 c0       	rjmp	.+16     	; 0x15306 <ConfigProtocol+0x92>
	}
	//SavingData
	if ((Conflow[0]==0x05)&&(dataIn==0x50)){
   152f6:	85 30       	cpi	r24, 0x05	; 5
   152f8:	31 f4       	brne	.+12     	; 0x15306 <ConfigProtocol+0x92>
   152fa:	10 35       	cpi	r17, 0x50	; 80
   152fc:	21 f4       	brne	.+8      	; 0x15306 <ConfigProtocol+0x92>
	     IsConfigFlow=False;
   152fe:	10 92 ae 01 	sts	0x01AE, r1
		 SaveConfigParameter();
   15302:	0e 94 67 a7 	call	0x14ece	; 0x14ece <SaveConfigParameter>
	}

	//Shifting
	Conflow[6]=Conflow[5];
   15306:	80 91 c7 03 	lds	r24, 0x03C7
   1530a:	80 93 c8 03 	sts	0x03C8, r24
	Conflow[5]=Conflow[4];
   1530e:	80 91 c6 03 	lds	r24, 0x03C6
   15312:	80 93 c7 03 	sts	0x03C7, r24
	Conflow[4]=Conflow[3];
   15316:	80 91 c5 03 	lds	r24, 0x03C5
   1531a:	80 93 c6 03 	sts	0x03C6, r24
	Conflow[3]=Conflow[2];
   1531e:	80 91 c4 03 	lds	r24, 0x03C4
   15322:	80 93 c5 03 	sts	0x03C5, r24
	Conflow[2]=Conflow[1];
   15326:	80 91 c3 03 	lds	r24, 0x03C3
   1532a:	80 93 c4 03 	sts	0x03C4, r24
	Conflow[1]=Conflow[0];
   1532e:	80 91 c2 03 	lds	r24, 0x03C2
   15332:	80 93 c3 03 	sts	0x03C3, r24
	Conflow[0]=dataIn;
   15336:	10 93 c2 03 	sts	0x03C2, r17

}
   1533a:	1f 91       	pop	r17
   1533c:	08 95       	ret

0001533e <__vector_30>:

// NotSuccessful! 


ISR(USART1_RX_vect){
   1533e:	1f 92       	push	r1
   15340:	0f 92       	push	r0
   15342:	0f b6       	in	r0, 0x3f	; 63
   15344:	0f 92       	push	r0
   15346:	0b b6       	in	r0, 0x3b	; 59
   15348:	0f 92       	push	r0
   1534a:	11 24       	eor	r1, r1
   1534c:	1f 93       	push	r17
   1534e:	2f 93       	push	r18
   15350:	3f 93       	push	r19
   15352:	4f 93       	push	r20
   15354:	5f 93       	push	r21
   15356:	6f 93       	push	r22
   15358:	7f 93       	push	r23
   1535a:	8f 93       	push	r24
   1535c:	9f 93       	push	r25
   1535e:	af 93       	push	r26
   15360:	bf 93       	push	r27
   15362:	ef 93       	push	r30
   15364:	ff 93       	push	r31
	char dataTX1,serialSend[12];
	static char IsNewPacket=False,IsAdvanZProtocol=False;
	unsigned int i;
	dataTX1 = UDR1;
   15366:	10 91 9c 00 	lds	r17, 0x009C

	//NewPacket
	if (IsNewPacket==True){
   1536a:	80 91 c1 03 	lds	r24, 0x03C1
   1536e:	81 30       	cpi	r24, 0x01	; 1
   15370:	51 f4       	brne	.+20     	; 0x15386 <__vector_30+0x48>
	    if (dataTX1==0x01){
   15372:	11 30       	cpi	r17, 0x01	; 1
   15374:	41 f4       	brne	.+16     	; 0x15386 <__vector_30+0x48>
		    char_count=0;
   15376:	10 92 b2 01 	sts	0x01B2, r1
   1537a:	10 92 b1 01 	sts	0x01B1, r1
            IsNewPacket=False;
   1537e:	10 92 c1 03 	sts	0x03C1, r1
			IsAdvanZProtocol=True;
   15382:	10 93 c0 03 	sts	0x03C0, r17
			}
	}
    //Save data to buffer if AdvanZ MSG
	if (IsAdvanZProtocol==True){
   15386:	80 91 c0 03 	lds	r24, 0x03C0
   1538a:	81 30       	cpi	r24, 0x01	; 1
   1538c:	69 f4       	brne	.+26     	; 0x153a8 <__vector_30+0x6a>
	    rcv_trans[char_count]=dataTX1;
   1538e:	80 91 b1 01 	lds	r24, 0x01B1
   15392:	90 91 b2 01 	lds	r25, 0x01B2
   15396:	fc 01       	movw	r30, r24
   15398:	eb 5d       	subi	r30, 0xDB	; 219
   1539a:	f4 4f       	sbci	r31, 0xF4	; 244
   1539c:	10 83       	st	Z, r17
	    char_count++; 
   1539e:	01 96       	adiw	r24, 0x01	; 1
   153a0:	90 93 b2 01 	sts	0x01B2, r25
   153a4:	80 93 b1 01 	sts	0x01B1, r24
	}

	if (dataTX1==0x02){
   153a8:	12 30       	cpi	r17, 0x02	; 2
   153aa:	d1 f5       	brne	.+116    	; 0x15420 <__vector_30+0xe2>
		transLength=char_count;
   153ac:	60 91 b1 01 	lds	r22, 0x01B1
   153b0:	70 91 b2 01 	lds	r23, 0x01B2
   153b4:	70 93 b4 01 	sts	0x01B4, r23
   153b8:	60 93 b3 01 	sts	0x01B3, r22
		char_count=0;
   153bc:	10 92 b2 01 	sts	0x01B2, r1
   153c0:	10 92 b1 01 	sts	0x01B1, r1
		IsAdvanZProtocol=False;
   153c4:	10 92 c0 03 	sts	0x03C0, r1

		//MessageIdentification
        if (MsgCode!=MSG_NONE)MsgCode=MSG_NONE;
	    MsgCode=((rcv_trans[35]-'0')*10)+(rcv_trans[36]-'0');
   153c8:	20 91 49 0b 	lds	r18, 0x0B49
   153cc:	20 51       	subi	r18, 0x10	; 16
   153ce:	80 91 48 0b 	lds	r24, 0x0B48
   153d2:	3a e0       	ldi	r19, 0x0A	; 10
   153d4:	83 9f       	mul	r24, r19
   153d6:	c0 01       	movw	r24, r0
   153d8:	11 24       	eor	r1, r1
   153da:	28 0f       	add	r18, r24
   153dc:	20 93 39 01 	sts	0x0139, r18
     
	    IdentifyMessage(rcv_trans[0],transLength);
   153e0:	80 91 25 0b 	lds	r24, 0x0B25
   153e4:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <IdentifyMessage>
		IsNewPacket=True;
   153e8:	21 e0       	ldi	r18, 0x01	; 1
   153ea:	20 93 c1 03 	sts	0x03C1, r18
		char_count=0;
   153ee:	10 92 b2 01 	sts	0x01B2, r1
   153f2:	10 92 b1 01 	sts	0x01B1, r1
		if ((rcv_trans[35]=='8')&&(rcv_trans[36]=='1')){
   153f6:	80 91 48 0b 	lds	r24, 0x0B48
   153fa:	88 33       	cpi	r24, 0x38	; 56
   153fc:	89 f4       	brne	.+34     	; 0x15420 <__vector_30+0xe2>
   153fe:	80 91 49 0b 	lds	r24, 0x0B49
   15402:	81 33       	cpi	r24, 0x31	; 49
   15404:	69 f4       	brne	.+26     	; 0x15420 <__vector_30+0xe2>
		   LengthMessage81=transLength-12-44;
   15406:	80 91 b3 01 	lds	r24, 0x01B3
   1540a:	90 91 b4 01 	lds	r25, 0x01B4
   1540e:	c8 97       	sbiw	r24, 0x38	; 56
   15410:	90 93 b6 01 	sts	0x01B6, r25
   15414:	80 93 b5 01 	sts	0x01B5, r24
		   IsMessage81=True;
   15418:	20 93 d3 01 	sts	0x01D3, r18
		   IsCompleteFilling=True;
   1541c:	20 93 d6 01 	sts	0x01D6, r18
		

	}//Endif(dataTX1==0x02)

	//ConfigDetection: iConf?<0D><0A>
	if (IsNewPacket!=True)ConfigProtocol(dataTX1);
   15420:	80 91 c1 03 	lds	r24, 0x03C1
   15424:	81 30       	cpi	r24, 0x01	; 1
   15426:	19 f0       	breq	.+6      	; 0x1542e <__vector_30+0xf0>
   15428:	81 2f       	mov	r24, r17
   1542a:	0e 94 3a a9 	call	0x15274	; 0x15274 <ConfigProtocol>
	//GeniusDetection: [CMD][MSG][CSUM][0x0D]
	if ((IFType==IT_STANDALONE)&&(IsNewPacket!=True))GeniusProtocol(dataTX1);
   1542e:	80 91 25 01 	lds	r24, 0x0125
   15432:	82 30       	cpi	r24, 0x02	; 2
   15434:	39 f4       	brne	.+14     	; 0x15444 <__vector_30+0x106>
   15436:	80 91 c1 03 	lds	r24, 0x03C1
   1543a:	81 30       	cpi	r24, 0x01	; 1
   1543c:	19 f0       	breq	.+6      	; 0x15444 <__vector_30+0x106>
   1543e:	81 2f       	mov	r24, r17
   15440:	0e 94 c6 3c 	call	0x798c	; 0x798c <GeniusProtocol>
    //_uart(0,1,dataTX1);



	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}
   15444:	ff 91       	pop	r31
   15446:	ef 91       	pop	r30
   15448:	bf 91       	pop	r27
   1544a:	af 91       	pop	r26
   1544c:	9f 91       	pop	r25
   1544e:	8f 91       	pop	r24
   15450:	7f 91       	pop	r23
   15452:	6f 91       	pop	r22
   15454:	5f 91       	pop	r21
   15456:	4f 91       	pop	r20
   15458:	3f 91       	pop	r19
   1545a:	2f 91       	pop	r18
   1545c:	1f 91       	pop	r17
   1545e:	0f 90       	pop	r0
   15460:	0b be       	out	0x3b, r0	; 59
   15462:	0f 90       	pop	r0
   15464:	0f be       	out	0x3f, r0	; 63
   15466:	0f 90       	pop	r0
   15468:	1f 90       	pop	r1
   1546a:	18 95       	reti

0001546c <__vector_12>:
	  strDispenserName3,
	  strDispenserName4,
	  strDispenserName5,
};

ISR(TIMER1_COMPA_vect){//Timer Overflow 1ms
   1546c:	1f 92       	push	r1
   1546e:	0f 92       	push	r0
   15470:	0f b6       	in	r0, 0x3f	; 63
   15472:	0f 92       	push	r0
   15474:	0b b6       	in	r0, 0x3b	; 59
   15476:	0f 92       	push	r0
   15478:	11 24       	eor	r1, r1
   1547a:	2f 93       	push	r18
   1547c:	3f 93       	push	r19
   1547e:	4f 93       	push	r20
   15480:	5f 93       	push	r21
   15482:	6f 93       	push	r22
   15484:	7f 93       	push	r23
   15486:	8f 93       	push	r24
   15488:	9f 93       	push	r25
   1548a:	af 93       	push	r26
   1548c:	bf 93       	push	r27
   1548e:	ef 93       	push	r30
   15490:	ff 93       	push	r31
static char __i_timer=0;
	if(__timer){
   15492:	80 91 27 04 	lds	r24, 0x0427
   15496:	88 23       	and	r24, r24
   15498:	81 f0       	breq	.+32     	; 0x154ba <__vector_12+0x4e>
        _TIME_IN;
   1549a:	81 e0       	ldi	r24, 0x01	; 1
   1549c:	80 93 28 04 	sts	0x0428, r24
		__timercount++;
   154a0:	80 91 ec 03 	lds	r24, 0x03EC
   154a4:	8f 5f       	subi	r24, 0xFF	; 255
   154a6:	80 93 ec 03 	sts	0x03EC, r24
		if(__timercount==24){
   154aa:	88 31       	cpi	r24, 0x18	; 24
   154ac:	31 f4       	brne	.+12     	; 0x154ba <__vector_12+0x4e>
            _TIMER_OFF;
   154ae:	10 92 27 04 	sts	0x0427, r1
            _TIMER_RESET;
   154b2:	10 92 ec 03 	sts	0x03EC, r1
            _TIME_OUT;
   154b6:	10 92 28 04 	sts	0x0428, r1
		}
	}
	if(__sec_flag){
   154ba:	80 91 ed 03 	lds	r24, 0x03ED
   154be:	88 23       	and	r24, r24
   154c0:	61 f0       	breq	.+24     	; 0x154da <__vector_12+0x6e>
		_SEC_TICK;
   154c2:	80 91 25 04 	lds	r24, 0x0425
   154c6:	8f 5f       	subi	r24, 0xFF	; 255
   154c8:	80 93 25 04 	sts	0x0425, r24
		if(__sec_count == 250)
   154cc:	8a 3f       	cpi	r24, 0xFA	; 250
   154ce:	29 f4       	brne	.+10     	; 0x154da <__vector_12+0x6e>
			_SEC_OFF;
   154d0:	10 92 ed 03 	sts	0x03ED, r1
   154d4:	81 e0       	ldi	r24, 0x01	; 1
   154d6:	80 93 ee 03 	sts	0x03EE, r24
	}

	_light_ticker();
   154da:	0e 94 e3 ac 	call	0x159c6	; 0x159c6 <_light_ticker>
	_shift_ticker();
   154de:	0e 94 d9 af 	call	0x15fb2	; 0x15fb2 <_shift_ticker>

	__i_timer++;
   154e2:	80 91 d8 03 	lds	r24, 0x03D8
   154e6:	8f 5f       	subi	r24, 0xFF	; 255
   154e8:	80 93 d8 03 	sts	0x03D8, r24
	if (__i_timer > 5){
   154ec:	86 30       	cpi	r24, 0x06	; 6
   154ee:	30 f0       	brcs	.+12     	; 0x154fc <__vector_12+0x90>
		__i_timer = 0;
   154f0:	10 92 d8 03 	sts	0x03D8, r1
		PORTE = PORTE^0x04;
   154f4:	83 b1       	in	r24, 0x03	; 3
   154f6:	94 e0       	ldi	r25, 0x04	; 4
   154f8:	89 27       	eor	r24, r25
   154fa:	83 b9       	out	0x03, r24	; 3
	}
	//Beep
	if (TimBeep>0){
   154fc:	80 91 eb 01 	lds	r24, 0x01EB
   15500:	90 91 ec 01 	lds	r25, 0x01EC
   15504:	00 97       	sbiw	r24, 0x00	; 0
   15506:	41 f0       	breq	.+16     	; 0x15518 <__vector_12+0xac>
	    TimBeep--;
   15508:	01 97       	sbiw	r24, 0x01	; 1
   1550a:	90 93 ec 01 	sts	0x01EC, r25
   1550e:	80 93 eb 01 	sts	0x01EB, r24
		DDRB=(DDRB|0b00100000);
   15512:	bd 9a       	sbi	0x17, 5	; 23
	    PORTB=(PORTB&0b11011111);
   15514:	c5 98       	cbi	0x18, 5	; 24
   15516:	05 c0       	rjmp	.+10     	; 0x15522 <__vector_12+0xb6>
	    }
	else{PORTB=(PORTB|~PORTB);
   15518:	98 b3       	in	r25, 0x18	; 24
   1551a:	88 b3       	in	r24, 0x18	; 24
   1551c:	80 95       	com	r24
   1551e:	89 2b       	or	r24, r25
   15520:	88 bb       	out	0x18, r24	; 24
		}
    //LocalAccount
	TimLocAcc++;
   15522:	80 91 e7 01 	lds	r24, 0x01E7
   15526:	90 91 e8 01 	lds	r25, 0x01E8
   1552a:	01 96       	adiw	r24, 0x01	; 1
   1552c:	90 93 e8 01 	sts	0x01E8, r25
   15530:	80 93 e7 01 	sts	0x01E7, r24
	//DisplaTicker
    TimTicker++;
   15534:	80 91 ba 01 	lds	r24, 0x01BA
   15538:	8f 5f       	subi	r24, 0xFF	; 255
   1553a:	80 93 ba 01 	sts	0x01BA, r24
	TimPressed++;
   1553e:	20 91 bb 01 	lds	r18, 0x01BB
   15542:	2f 5f       	subi	r18, 0xFF	; 255
   15544:	20 93 bb 01 	sts	0x01BB, r18
	if ((TimPressed%5)==0){
   15548:	82 2f       	mov	r24, r18
   1554a:	65 e0       	ldi	r22, 0x05	; 5
   1554c:	0e 94 a3 b7 	call	0x16f46	; 0x16f46 <__udivmodqi4>
   15550:	99 23       	and	r25, r25
   15552:	71 f4       	brne	.+28     	; 0x15570 <__vector_12+0x104>
	    TimDisplay++;
   15554:	80 91 bc 01 	lds	r24, 0x01BC
   15558:	8f 5f       	subi	r24, 0xFF	; 255
   1555a:	80 93 bc 01 	sts	0x01BC, r24
		TimPrintBusy++;
   1555e:	80 91 e1 01 	lds	r24, 0x01E1
   15562:	90 91 e2 01 	lds	r25, 0x01E2
   15566:	01 96       	adiw	r24, 0x01	; 1
   15568:	90 93 e2 01 	sts	0x01E2, r25
   1556c:	80 93 e1 01 	sts	0x01E1, r24
		//FBackLight();
	}
	if ((TimPressed%PRESSED_DELAY)==0){
   15570:	82 2f       	mov	r24, r18
   15572:	6a e0       	ldi	r22, 0x0A	; 10
   15574:	0e 94 a3 b7 	call	0x16f46	; 0x16f46 <__udivmodqi4>
   15578:	99 23       	and	r25, r25
   1557a:	49 f4       	brne	.+18     	; 0x1558e <__vector_12+0x122>
	     ProcTimeOut++;
   1557c:	80 91 f1 01 	lds	r24, 0x01F1
   15580:	90 91 f2 01 	lds	r25, 0x01F2
   15584:	01 96       	adiw	r24, 0x01	; 1
   15586:	90 93 f2 01 	sts	0x01F2, r25
   1558a:	80 93 f1 01 	sts	0x01F1, r24
	}
	TimSend++;
   1558e:	80 91 bd 01 	lds	r24, 0x01BD
   15592:	90 91 be 01 	lds	r25, 0x01BE
   15596:	01 96       	adiw	r24, 0x01	; 1
   15598:	90 93 be 01 	sts	0x01BE, r25
   1559c:	80 93 bd 01 	sts	0x01BD, r24
}
   155a0:	ff 91       	pop	r31
   155a2:	ef 91       	pop	r30
   155a4:	bf 91       	pop	r27
   155a6:	af 91       	pop	r26
   155a8:	9f 91       	pop	r25
   155aa:	8f 91       	pop	r24
   155ac:	7f 91       	pop	r23
   155ae:	6f 91       	pop	r22
   155b0:	5f 91       	pop	r21
   155b2:	4f 91       	pop	r20
   155b4:	3f 91       	pop	r19
   155b6:	2f 91       	pop	r18
   155b8:	0f 90       	pop	r0
   155ba:	0b be       	out	0x3b, r0	; 59
   155bc:	0f 90       	pop	r0
   155be:	0f be       	out	0x3f, r0	; 63
   155c0:	0f 90       	pop	r0
   155c2:	1f 90       	pop	r1
   155c4:	18 95       	reti

000155c6 <lcd_command>:
	lcd_command(0x0c);
	lcd_command(0x06);
}

void lcd_command(unsigned char __chr){
	_LCD_PORT = __chr & 0xF0;
   155c6:	98 2f       	mov	r25, r24
   155c8:	90 7f       	andi	r25, 0xF0	; 240
   155ca:	95 bb       	out	0x15, r25	; 21
	cbi(_LCD_PORT, _LCD_RS);
   155cc:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   155ce:	a9 9a       	sbi	0x15, 1	; 21
   155d0:	48 ee       	ldi	r20, 0xE8	; 232
   155d2:	53 e0       	ldi	r21, 0x03	; 3
   155d4:	fa 01       	movw	r30, r20
   155d6:	31 97       	sbiw	r30, 0x01	; 1
   155d8:	f1 f7       	brne	.-4      	; 0x155d6 <lcd_command+0x10>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   155da:	a9 98       	cbi	0x15, 1	; 21
   155dc:	fa 01       	movw	r30, r20
   155de:	31 97       	sbiw	r30, 0x01	; 1
   155e0:	f1 f7       	brne	.-4      	; 0x155de <lcd_command+0x18>
	_LCD_BUSY;

	_LCD_PORT = (__chr & 0x0F) << 4;
   155e2:	28 2f       	mov	r18, r24
   155e4:	30 e0       	ldi	r19, 0x00	; 0
   155e6:	94 e0       	ldi	r25, 0x04	; 4
   155e8:	22 0f       	add	r18, r18
   155ea:	33 1f       	adc	r19, r19
   155ec:	9a 95       	dec	r25
   155ee:	e1 f7       	brne	.-8      	; 0x155e8 <lcd_command+0x22>
   155f0:	25 bb       	out	0x15, r18	; 21
	cbi(_LCD_PORT, _LCD_RS);
   155f2:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   155f4:	a9 9a       	sbi	0x15, 1	; 21
   155f6:	fa 01       	movw	r30, r20
   155f8:	31 97       	sbiw	r30, 0x01	; 1
   155fa:	f1 f7       	brne	.-4      	; 0x155f8 <lcd_command+0x32>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   155fc:	a9 98       	cbi	0x15, 1	; 21
   155fe:	fa 01       	movw	r30, r20
   15600:	31 97       	sbiw	r30, 0x01	; 1
   15602:	f1 f7       	brne	.-4      	; 0x15600 <lcd_command+0x3a>
	_LCD_BUSY;
	_LCD_BUSY;
	if (__chr==0x01) _delay_ms(50);
   15604:	fa 01       	movw	r30, r20
   15606:	31 97       	sbiw	r30, 0x01	; 1
   15608:	f1 f7       	brne	.-4      	; 0x15606 <lcd_command+0x40>
   1560a:	81 30       	cpi	r24, 0x01	; 1
   1560c:	21 f4       	brne	.+8      	; 0x15616 <lcd_command+0x50>
   1560e:	84 ed       	ldi	r24, 0xD4	; 212
   15610:	90 e3       	ldi	r25, 0x30	; 48
   15612:	01 97       	sbiw	r24, 0x01	; 1
   15614:	f1 f7       	brne	.-4      	; 0x15612 <lcd_command+0x4c>
   15616:	08 95       	ret

00015618 <lcd_init>:
   15618:	86 ea       	ldi	r24, 0xA6	; 166
   1561a:	9e e0       	ldi	r25, 0x0E	; 14
   1561c:	01 97       	sbiw	r24, 0x01	; 1
   1561e:	f1 f7       	brne	.-4      	; 0x1561c <lcd_init+0x4>

#define _LCD_BUSY	_delay_ms(4);

void lcd_init(void){
	_delay_ms(15);
	_LCD_PORT = 0x00;
   15620:	15 ba       	out	0x15, r1	; 21
	_LCD_DDR |= (1 << _LCD_D7) | (1 << _LCD_D6) | (1 << _LCD_D5) | (1 << _LCD_D4);
   15622:	84 b3       	in	r24, 0x14	; 20
   15624:	80 6f       	ori	r24, 0xF0	; 240
   15626:	84 bb       	out	0x14, r24	; 20
	_LCD_DDR |= (1 << _LCD_E) | (1 << _LCD_RW) | (1 << _LCD_RS);
   15628:	84 b3       	in	r24, 0x14	; 20
   1562a:	8e 60       	ori	r24, 0x0E	; 14
   1562c:	84 bb       	out	0x14, r24	; 20

	_LCD_PORT = 0x30;
   1562e:	20 e3       	ldi	r18, 0x30	; 48
   15630:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15632:	a9 9a       	sbi	0x15, 1	; 21
   15634:	88 ee       	ldi	r24, 0xE8	; 232
   15636:	93 e0       	ldi	r25, 0x03	; 3
   15638:	fc 01       	movw	r30, r24
   1563a:	31 97       	sbiw	r30, 0x01	; 1
   1563c:	f1 f7       	brne	.-4      	; 0x1563a <lcd_init+0x22>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   1563e:	a9 98       	cbi	0x15, 1	; 21
   15640:	fc 01       	movw	r30, r24
   15642:	31 97       	sbiw	r30, 0x01	; 1
   15644:	f1 f7       	brne	.-4      	; 0x15642 <lcd_init+0x2a>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   15646:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15648:	a9 9a       	sbi	0x15, 1	; 21
   1564a:	fc 01       	movw	r30, r24
   1564c:	31 97       	sbiw	r30, 0x01	; 1
   1564e:	f1 f7       	brne	.-4      	; 0x1564c <lcd_init+0x34>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15650:	a9 98       	cbi	0x15, 1	; 21
   15652:	fc 01       	movw	r30, r24
   15654:	31 97       	sbiw	r30, 0x01	; 1
   15656:	f1 f7       	brne	.-4      	; 0x15654 <lcd_init+0x3c>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   15658:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   1565a:	a9 9a       	sbi	0x15, 1	; 21
   1565c:	fc 01       	movw	r30, r24
   1565e:	31 97       	sbiw	r30, 0x01	; 1
   15660:	f1 f7       	brne	.-4      	; 0x1565e <lcd_init+0x46>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15662:	a9 98       	cbi	0x15, 1	; 21
   15664:	fc 01       	movw	r30, r24
   15666:	31 97       	sbiw	r30, 0x01	; 1
   15668:	f1 f7       	brne	.-4      	; 0x15666 <lcd_init+0x4e>
	_LCD_BUSY;

	_LCD_PORT = 0x20;
   1566a:	20 e2       	ldi	r18, 0x20	; 32
   1566c:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   1566e:	a9 9a       	sbi	0x15, 1	; 21
   15670:	fc 01       	movw	r30, r24
   15672:	31 97       	sbiw	r30, 0x01	; 1
   15674:	f1 f7       	brne	.-4      	; 0x15672 <lcd_init+0x5a>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15676:	a9 98       	cbi	0x15, 1	; 21
   15678:	01 97       	sbiw	r24, 0x01	; 1
   1567a:	f1 f7       	brne	.-4      	; 0x15678 <lcd_init+0x60>
	_LCD_BUSY;

	_LIGHT_PORT = 0x01;
   1567c:	81 e0       	ldi	r24, 0x01	; 1
   1567e:	80 93 65 00 	sts	0x0065, r24
	_LIGHT_DDR |= (1 << _LIGHT_PIN);
   15682:	e4 e6       	ldi	r30, 0x64	; 100
   15684:	f0 e0       	ldi	r31, 0x00	; 0
   15686:	80 81       	ld	r24, Z
   15688:	82 60       	ori	r24, 0x02	; 2
   1568a:	80 83       	st	Z, r24

	lcd_command(0x28);
   1568c:	88 e2       	ldi	r24, 0x28	; 40
   1568e:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
	lcd_command(0x0c);
   15692:	8c e0       	ldi	r24, 0x0C	; 12
   15694:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
	lcd_command(0x06);
   15698:	86 e0       	ldi	r24, 0x06	; 6
   1569a:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
}
   1569e:	08 95       	ret

000156a0 <_lcd>:
	if (__chr==0x01) _delay_ms(50);

}

void _lcd(unsigned char __chr){
	_LCD_PORT =((__chr & 0xF0));
   156a0:	28 2f       	mov	r18, r24
   156a2:	20 7f       	andi	r18, 0xF0	; 240
   156a4:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_RS);
   156a6:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   156a8:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   156aa:	a9 98       	cbi	0x15, 1	; 21

	_LCD_PORT = (((__chr & 0x0F) << 4));
   156ac:	90 e0       	ldi	r25, 0x00	; 0
   156ae:	24 e0       	ldi	r18, 0x04	; 4
   156b0:	88 0f       	add	r24, r24
   156b2:	99 1f       	adc	r25, r25
   156b4:	2a 95       	dec	r18
   156b6:	e1 f7       	brne	.-8      	; 0x156b0 <_lcd+0x10>
   156b8:	85 bb       	out	0x15, r24	; 21
	sbi(_LCD_PORT, _LCD_RS);
   156ba:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   156bc:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   156be:	a9 98       	cbi	0x15, 1	; 21
   156c0:	88 ee       	ldi	r24, 0xE8	; 232
   156c2:	93 e0       	ldi	r25, 0x03	; 3
   156c4:	01 97       	sbiw	r24, 0x01	; 1
   156c6:	f1 f7       	brne	.-4      	; 0x156c4 <_lcd+0x24>
	_LCD_BUSY;
	_delay_ms(1);
}
   156c8:	8a ef       	ldi	r24, 0xFA	; 250
   156ca:	90 e0       	ldi	r25, 0x00	; 0
   156cc:	01 97       	sbiw	r24, 0x01	; 1
   156ce:	f1 f7       	brne	.-4      	; 0x156cc <_lcd+0x2c>
   156d0:	08 95       	ret

000156d2 <lcd_string>:
     lcd_printf(2,1,PSTR("                    "));
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
   156d2:	cf 93       	push	r28
   156d4:	df 93       	push	r29
   156d6:	ec 01       	movw	r28, r24
   156d8:	03 c0       	rjmp	.+6      	; 0x156e0 <lcd_string+0xe>
	while(*__string)
		_lcd(*__string++);
   156da:	21 96       	adiw	r28, 0x01	; 1
   156dc:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
	while(*__string)
   156e0:	88 81       	ld	r24, Y
   156e2:	88 23       	and	r24, r24
   156e4:	d1 f7       	brne	.-12     	; 0x156da <lcd_string+0x8>
		_lcd(*__string++);
}
   156e6:	df 91       	pop	r29
   156e8:	cf 91       	pop	r28
   156ea:	08 95       	ret

000156ec <lcd_xy>:

void lcd_xy(unsigned char __x, unsigned char __y){
	switch(__x){
   156ec:	82 30       	cpi	r24, 0x02	; 2
   156ee:	69 f0       	breq	.+26     	; 0x1570a <lcd_xy+0x1e>
   156f0:	83 30       	cpi	r24, 0x03	; 3
   156f2:	18 f4       	brcc	.+6      	; 0x156fa <lcd_xy+0xe>
   156f4:	81 30       	cpi	r24, 0x01	; 1
   156f6:	a9 f4       	brne	.+42     	; 0x15722 <lcd_xy+0x36>
   156f8:	05 c0       	rjmp	.+10     	; 0x15704 <lcd_xy+0x18>
   156fa:	83 30       	cpi	r24, 0x03	; 3
   156fc:	49 f0       	breq	.+18     	; 0x15710 <lcd_xy+0x24>
   156fe:	84 30       	cpi	r24, 0x04	; 4
   15700:	81 f4       	brne	.+32     	; 0x15722 <lcd_xy+0x36>
   15702:	0b c0       	rjmp	.+22     	; 0x1571a <lcd_xy+0x2e>
		case 1:
			lcd_command(0x80 + __y - 1);
   15704:	86 2f       	mov	r24, r22
   15706:	81 58       	subi	r24, 0x81	; 129
   15708:	05 c0       	rjmp	.+10     	; 0x15714 <lcd_xy+0x28>
			break;
		case 2:
			lcd_command(0xC0 + __y - 1);
   1570a:	86 2f       	mov	r24, r22
   1570c:	81 54       	subi	r24, 0x41	; 65
   1570e:	02 c0       	rjmp	.+4      	; 0x15714 <lcd_xy+0x28>
			break;
		case 3:
			lcd_command(0x94 + __y - 1);
   15710:	86 2f       	mov	r24, r22
   15712:	8d 56       	subi	r24, 0x6D	; 109
   15714:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
   15718:	08 95       	ret
			break;
		case 4:
			lcd_command(0xD4 + __y - 1);
   1571a:	86 2f       	mov	r24, r22
   1571c:	8d 52       	subi	r24, 0x2D	; 45
   1571e:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
   15722:	08 95       	ret

00015724 <lcd_print>:
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
	 }     
}

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
   15724:	df 92       	push	r13
   15726:	ef 92       	push	r14
   15728:	ff 92       	push	r15
   1572a:	0f 93       	push	r16
   1572c:	1f 93       	push	r17
   1572e:	cf 93       	push	r28
   15730:	df 93       	push	r29
   15732:	06 2f       	mov	r16, r22
   15734:	d4 2e       	mov	r13, r20
   15736:	15 2f       	mov	r17, r21
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
   15738:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
   1573c:	2d 2d       	mov	r18, r13
   1573e:	31 2f       	mov	r19, r17
   15740:	c9 01       	movw	r24, r18
   15742:	ec 01       	movw	r28, r24
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   15744:	34 e1       	ldi	r19, 0x14	; 20
   15746:	e3 2e       	mov	r14, r19
   15748:	f1 2c       	mov	r15, r1
   1574a:	e0 1a       	sub	r14, r16
   1574c:	f1 08       	sbc	r15, r1
   1574e:	04 c0       	rjmp	.+8      	; 0x15758 <lcd_print+0x34>
		_lcd(*__string);__string++;
   15750:	82 2f       	mov	r24, r18
   15752:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
   15756:	21 96       	adiw	r28, 0x01	; 1
   15758:	9e 01       	movw	r18, r28
   1575a:	2d 19       	sub	r18, r13
   1575c:	82 2f       	mov	r24, r18

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   1575e:	28 81       	ld	r18, Y
   15760:	22 23       	and	r18, r18
   15762:	21 f0       	breq	.+8      	; 0x1576c <lcd_print+0x48>
   15764:	90 e0       	ldi	r25, 0x00	; 0
   15766:	e8 16       	cp	r14, r24
   15768:	f9 06       	cpc	r15, r25
   1576a:	94 f7       	brge	.-28     	; 0x15750 <lcd_print+0x2c>
		_lcd(*__string);__string++;
		iPos++;
		}    
}
   1576c:	df 91       	pop	r29
   1576e:	cf 91       	pop	r28
   15770:	1f 91       	pop	r17
   15772:	0f 91       	pop	r16
   15774:	ff 90       	pop	r15
   15776:	ef 90       	pop	r14
   15778:	df 90       	pop	r13
   1577a:	08 95       	ret

0001577c <lcd_printf>:

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
   1577c:	df 92       	push	r13
   1577e:	ef 92       	push	r14
   15780:	ff 92       	push	r15
   15782:	0f 93       	push	r16
   15784:	1f 93       	push	r17
   15786:	cf 93       	push	r28
   15788:	df 93       	push	r29
   1578a:	06 2f       	mov	r16, r22
   1578c:	d4 2e       	mov	r13, r20
   1578e:	15 2f       	mov	r17, r21
    char iPos=0;
	lcd_xy(__x, __y);
   15790:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
   15794:	8d 2d       	mov	r24, r13
   15796:	91 2f       	mov	r25, r17
   15798:	fc 01       	movw	r30, r24
   1579a:	ef 01       	movw	r28, r30
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   1579c:	44 e1       	ldi	r20, 0x14	; 20
   1579e:	e4 2e       	mov	r14, r20
   157a0:	f1 2c       	mov	r15, r1
   157a2:	e0 1a       	sub	r14, r16
   157a4:	f1 08       	sbc	r15, r1
   157a6:	04 c0       	rjmp	.+8      	; 0x157b0 <lcd_printf+0x34>
		_lcd(pgm_read_byte(&(*__string)));
   157a8:	82 2f       	mov	r24, r18
   157aa:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
		__string++;
   157ae:	21 96       	adiw	r28, 0x01	; 1
   157b0:	9e 01       	movw	r18, r28
   157b2:	2d 19       	sub	r18, r13
   157b4:	82 2f       	mov	r24, r18

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
    char iPos=0;
	lcd_xy(__x, __y);
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   157b6:	fe 01       	movw	r30, r28
   157b8:	24 91       	lpm	r18, Z+
   157ba:	22 23       	and	r18, r18
   157bc:	21 f0       	breq	.+8      	; 0x157c6 <lcd_printf+0x4a>
   157be:	90 e0       	ldi	r25, 0x00	; 0
   157c0:	e8 16       	cp	r14, r24
   157c2:	f9 06       	cpc	r15, r25
   157c4:	8c f7       	brge	.-30     	; 0x157a8 <lcd_printf+0x2c>
		_lcd(pgm_read_byte(&(*__string)));
		__string++;
		iPos++;
		}
}
   157c6:	df 91       	pop	r29
   157c8:	cf 91       	pop	r28
   157ca:	1f 91       	pop	r17
   157cc:	0f 91       	pop	r16
   157ce:	ff 90       	pop	r15
   157d0:	ef 90       	pop	r14
   157d2:	df 90       	pop	r13
   157d4:	08 95       	ret

000157d6 <lcd_clear>:
	_LCD_BUSY;
	_delay_ms(1);
}

void lcd_clear(){
     lcd_printf(1,1,PSTR("                    "));
   157d6:	81 e0       	ldi	r24, 0x01	; 1
   157d8:	61 e0       	ldi	r22, 0x01	; 1
   157da:	4c e6       	ldi	r20, 0x6C	; 108
   157dc:	53 e2       	ldi	r21, 0x23	; 35
   157de:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
     lcd_printf(2,1,PSTR("                    "));
   157e2:	82 e0       	ldi	r24, 0x02	; 2
   157e4:	61 e0       	ldi	r22, 0x01	; 1
   157e6:	47 e5       	ldi	r20, 0x57	; 87
   157e8:	53 e2       	ldi	r21, 0x23	; 35
   157ea:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
     lcd_printf(3,1,PSTR("                    "));
   157ee:	83 e0       	ldi	r24, 0x03	; 3
   157f0:	61 e0       	ldi	r22, 0x01	; 1
   157f2:	42 e4       	ldi	r20, 0x42	; 66
   157f4:	53 e2       	ldi	r21, 0x23	; 35
   157f6:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
     lcd_printf(4,1,PSTR("                    "));
   157fa:	84 e0       	ldi	r24, 0x04	; 4
   157fc:	61 e0       	ldi	r22, 0x01	; 1
   157fe:	4d e2       	ldi	r20, 0x2D	; 45
   15800:	53 e2       	ldi	r21, 0x23	; 35
   15802:	0e 94 be ab 	call	0x1577c	; 0x1577c <lcd_printf>
}
   15806:	08 95       	ret

00015808 <lcd_put>:
		__string++;
		iPos++;
		}
}

void lcd_put(unsigned char __x, unsigned char __y, unsigned char __chr){
   15808:	1f 93       	push	r17
   1580a:	14 2f       	mov	r17, r20
	lcd_xy(__x, __y);
   1580c:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
	_lcd(__chr);
   15810:	81 2f       	mov	r24, r17
   15812:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
}
   15816:	1f 91       	pop	r17
   15818:	08 95       	ret

0001581a <lcd_cgram>:

void lcd_cgram(unsigned char location, char *ptr){
   1581a:	0f 93       	push	r16
   1581c:	1f 93       	push	r17
   1581e:	cf 93       	push	r28
   15820:	df 93       	push	r29
   15822:	8b 01       	movw	r16, r22
	unsigned char i;
    if(location < 8){
   15824:	88 30       	cpi	r24, 0x08	; 8
   15826:	90 f4       	brcc	.+36     	; 0x1584c <lcd_cgram+0x32>
		lcd_command(0x40 + (location * 8));
   15828:	88 0f       	add	r24, r24
   1582a:	88 0f       	add	r24, r24
   1582c:	88 0f       	add	r24, r24
   1582e:	80 5c       	subi	r24, 0xC0	; 192
   15830:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
   15834:	c0 e0       	ldi	r28, 0x00	; 0
   15836:	d0 e0       	ldi	r29, 0x00	; 0
		for(i = 0; i < 8; i++)
			_lcd(ptr[i]);
   15838:	f8 01       	movw	r30, r16
   1583a:	ec 0f       	add	r30, r28
   1583c:	fd 1f       	adc	r31, r29
   1583e:	80 81       	ld	r24, Z
   15840:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
   15844:	21 96       	adiw	r28, 0x01	; 1

void lcd_cgram(unsigned char location, char *ptr){
	unsigned char i;
    if(location < 8){
		lcd_command(0x40 + (location * 8));
		for(i = 0; i < 8; i++)
   15846:	c8 30       	cpi	r28, 0x08	; 8
   15848:	d1 05       	cpc	r29, r1
   1584a:	b1 f7       	brne	.-20     	; 0x15838 <lcd_cgram+0x1e>
			_lcd(ptr[i]);
	}
}
   1584c:	df 91       	pop	r29
   1584e:	cf 91       	pop	r28
   15850:	1f 91       	pop	r17
   15852:	0f 91       	pop	r16
   15854:	08 95       	ret

00015856 <ClearMem>:
			lcd_command(0xD4 + __y - 1);
			break;
	}
}

void ClearMem(char *string){
   15856:	cf 93       	push	r28
   15858:	df 93       	push	r29
   1585a:	20 e0       	ldi	r18, 0x00	; 0
   1585c:	04 c0       	rjmp	.+8      	; 0x15866 <ClearMem+0x10>
     char i;
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
   1585e:	c8 0f       	add	r28, r24
   15860:	d9 1f       	adc	r29, r25
   15862:	18 82       	st	Y, r1
	}
}

void ClearMem(char *string){
     char i;
	 for (i=0;i<strlen(string);i++){
   15864:	2f 5f       	subi	r18, 0xFF	; 255
   15866:	c2 2f       	mov	r28, r18
   15868:	d0 e0       	ldi	r29, 0x00	; 0
   1586a:	fc 01       	movw	r30, r24
   1586c:	01 90       	ld	r0, Z+
   1586e:	00 20       	and	r0, r0
   15870:	e9 f7       	brne	.-6      	; 0x1586c <ClearMem+0x16>
   15872:	31 97       	sbiw	r30, 0x01	; 1
   15874:	e8 1b       	sub	r30, r24
   15876:	f9 0b       	sbc	r31, r25
   15878:	ce 17       	cp	r28, r30
   1587a:	df 07       	cpc	r29, r31
   1587c:	80 f3       	brcs	.-32     	; 0x1585e <ClearMem+0x8>
          string[i]=0;
	 }     
}
   1587e:	df 91       	pop	r29
   15880:	cf 91       	pop	r28
   15882:	08 95       	ret

00015884 <_key_hit>:
													 {'7', 'P', 'Q', 'R', 'S', '\0'},
											         {'8', 'T', 'U', 'V', '\0'}, 
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
   15884:	df 93       	push	r29
   15886:	cf 93       	push	r28
   15888:	00 d0       	rcall	.+0      	; 0x1588a <_key_hit+0x6>
   1588a:	00 d0       	rcall	.+0      	; 0x1588c <_key_hit+0x8>
   1588c:	cd b7       	in	r28, 0x3d	; 61
   1588e:	de b7       	in	r29, 0x3e	; 62
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15890:	8f ee       	ldi	r24, 0xEF	; 239
   15892:	89 83       	std	Y+1, r24	; 0x01
   15894:	8f ed       	ldi	r24, 0xDF	; 223
   15896:	8a 83       	std	Y+2, r24	; 0x02
   15898:	8f eb       	ldi	r24, 0xBF	; 191
   1589a:	8b 83       	std	Y+3, r24	; 0x03
   1589c:	8f e7       	ldi	r24, 0x7F	; 127
   1589e:	8c 83       	std	Y+4, r24	; 0x04
   158a0:	de 01       	movw	r26, r28
   158a2:	11 96       	adiw	r26, 0x01	; 1
   158a4:	2a ef       	ldi	r18, 0xFA	; 250
   158a6:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   158a8:	ae 01       	movw	r20, r28
   158aa:	4b 5f       	subi	r20, 0xFB	; 251
   158ac:	5f 4f       	sbci	r21, 0xFF	; 255
   158ae:	c9 01       	movw	r24, r18
   158b0:	01 97       	sbiw	r24, 0x01	; 1
   158b2:	f1 f7       	brne	.-4      	; 0x158b0 <_key_hit+0x2c>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   158b4:	8c 91       	ld	r24, X
   158b6:	80 93 62 00 	sts	0x0062, r24
   158ba:	f9 01       	movw	r30, r18
   158bc:	31 97       	sbiw	r30, 0x01	; 1
   158be:	f1 f7       	brne	.-4      	; 0x158bc <_key_hit+0x38>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   158c0:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) break;
   158c2:	98 17       	cp	r25, r24
   158c4:	21 f4       	brne	.+8      	; 0x158ce <_key_hit+0x4a>
   158c6:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   158c8:	a4 17       	cp	r26, r20
   158ca:	b5 07       	cpc	r27, r21
   158cc:	81 f7       	brne	.-32     	; 0x158ae <_key_hit+0x2a>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
		if (keyhit!=outmap[i]) break;
	}
	return keyhit;
}
   158ce:	89 2f       	mov	r24, r25
   158d0:	0f 90       	pop	r0
   158d2:	0f 90       	pop	r0
   158d4:	0f 90       	pop	r0
   158d6:	0f 90       	pop	r0
   158d8:	cf 91       	pop	r28
   158da:	df 91       	pop	r29
   158dc:	08 95       	ret

000158de <_key_crr>:

char _key_crr(char __key){
	if(	__key != _KEY_1 && __key != _KEY_2 &&
   158de:	8e 3e       	cpi	r24, 0xEE	; 238
   158e0:	f9 f0       	breq	.+62     	; 0x15920 <_key_crr+0x42>
   158e2:	8e 3d       	cpi	r24, 0xDE	; 222
   158e4:	e9 f0       	breq	.+58     	; 0x15920 <_key_crr+0x42>
   158e6:	8e 3b       	cpi	r24, 0xBE	; 190
   158e8:	d9 f0       	breq	.+54     	; 0x15920 <_key_crr+0x42>
   158ea:	8d 3e       	cpi	r24, 0xED	; 237
   158ec:	c9 f0       	breq	.+50     	; 0x15920 <_key_crr+0x42>
   158ee:	8d 3d       	cpi	r24, 0xDD	; 221
   158f0:	b9 f0       	breq	.+46     	; 0x15920 <_key_crr+0x42>
   158f2:	8d 3b       	cpi	r24, 0xBD	; 189
   158f4:	a9 f0       	breq	.+42     	; 0x15920 <_key_crr+0x42>
   158f6:	8b 3e       	cpi	r24, 0xEB	; 235
   158f8:	99 f0       	breq	.+38     	; 0x15920 <_key_crr+0x42>
   158fa:	8b 3d       	cpi	r24, 0xDB	; 219
   158fc:	89 f0       	breq	.+34     	; 0x15920 <_key_crr+0x42>
   158fe:	8b 3b       	cpi	r24, 0xBB	; 187
   15900:	79 f0       	breq	.+30     	; 0x15920 <_key_crr+0x42>
   15902:	87 3d       	cpi	r24, 0xD7	; 215
   15904:	69 f0       	breq	.+26     	; 0x15920 <_key_crr+0x42>
   15906:	87 3e       	cpi	r24, 0xE7	; 231
   15908:	59 f0       	breq	.+22     	; 0x15920 <_key_crr+0x42>
   1590a:	87 3b       	cpi	r24, 0xB7	; 183
   1590c:	49 f0       	breq	.+18     	; 0x15920 <_key_crr+0x42>
   1590e:	8e 37       	cpi	r24, 0x7E	; 126
   15910:	39 f0       	breq	.+14     	; 0x15920 <_key_crr+0x42>
   15912:	8d 37       	cpi	r24, 0x7D	; 125
   15914:	29 f0       	breq	.+10     	; 0x15920 <_key_crr+0x42>
   15916:	8b 37       	cpi	r24, 0x7B	; 123
   15918:	19 f0       	breq	.+6      	; 0x15920 <_key_crr+0x42>
   1591a:	87 37       	cpi	r24, 0x77	; 119
   1591c:	09 f0       	breq	.+2      	; 0x15920 <_key_crr+0x42>
   1591e:	80 e0       	ldi	r24, 0x00	; 0
		__key != _KEY_CANCEL && __key != _KEY_ENTER &&
		__key != _KEY_TIKET && __key != _KEY_MENU &&
		__key != _KEY_SHIFT && __key != _KEY_CLEAR)
		return _KEY_NULL;
	return __key;
}
   15920:	08 95       	ret

00015922 <_key_btn>:

char _key_btn(char __key){
	char __keychar = 0;
	
	switch (__key){
   15922:	8e 3b       	cpi	r24, 0xBE	; 190
   15924:	91 f1       	breq	.+100    	; 0x1598a <_key_btn+0x68>
   15926:	8f 3b       	cpi	r24, 0xBF	; 191
   15928:	a8 f4       	brcc	.+42     	; 0x15954 <_key_btn+0x32>
   1592a:	8e 37       	cpi	r24, 0x7E	; 126
   1592c:	09 f4       	brne	.+2      	; 0x15930 <_key_btn+0xe>
   1592e:	41 c0       	rjmp	.+130    	; 0x159b2 <_key_btn+0x90>
   15930:	8f 37       	cpi	r24, 0x7F	; 127
   15932:	48 f4       	brcc	.+18     	; 0x15946 <_key_btn+0x24>
   15934:	8b 37       	cpi	r24, 0x7B	; 123
   15936:	09 f4       	brne	.+2      	; 0x1593a <_key_btn+0x18>
   15938:	40 c0       	rjmp	.+128    	; 0x159ba <_key_btn+0x98>
   1593a:	8d 37       	cpi	r24, 0x7D	; 125
   1593c:	e1 f1       	breq	.+120    	; 0x159b6 <_key_btn+0x94>
   1593e:	87 37       	cpi	r24, 0x77	; 119
   15940:	09 f0       	breq	.+2      	; 0x15944 <_key_btn+0x22>
   15942:	3f c0       	rjmp	.+126    	; 0x159c2 <_key_btn+0xa0>
   15944:	3c c0       	rjmp	.+120    	; 0x159be <_key_btn+0x9c>
   15946:	8b 3b       	cpi	r24, 0xBB	; 187
   15948:	61 f1       	breq	.+88     	; 0x159a2 <_key_btn+0x80>
   1594a:	8d 3b       	cpi	r24, 0xBD	; 189
   1594c:	21 f1       	breq	.+72     	; 0x15996 <_key_btn+0x74>
   1594e:	87 3b       	cpi	r24, 0xB7	; 183
   15950:	c1 f5       	brne	.+112    	; 0x159c2 <_key_btn+0xa0>
   15952:	2d c0       	rjmp	.+90     	; 0x159ae <_key_btn+0x8c>
   15954:	8e 3d       	cpi	r24, 0xDE	; 222
   15956:	a9 f0       	breq	.+42     	; 0x15982 <_key_btn+0x60>
   15958:	8f 3d       	cpi	r24, 0xDF	; 223
   1595a:	38 f4       	brcc	.+14     	; 0x1596a <_key_btn+0x48>
   1595c:	8b 3d       	cpi	r24, 0xDB	; 219
   1595e:	f9 f0       	breq	.+62     	; 0x1599e <_key_btn+0x7c>
   15960:	8d 3d       	cpi	r24, 0xDD	; 221
   15962:	b9 f0       	breq	.+46     	; 0x15992 <_key_btn+0x70>
   15964:	87 3d       	cpi	r24, 0xD7	; 215
   15966:	69 f5       	brne	.+90     	; 0x159c2 <_key_btn+0xa0>
   15968:	1e c0       	rjmp	.+60     	; 0x159a6 <_key_btn+0x84>
   1596a:	8b 3e       	cpi	r24, 0xEB	; 235
   1596c:	b1 f0       	breq	.+44     	; 0x1599a <_key_btn+0x78>
   1596e:	8c 3e       	cpi	r24, 0xEC	; 236
   15970:	18 f4       	brcc	.+6      	; 0x15978 <_key_btn+0x56>
   15972:	87 3e       	cpi	r24, 0xE7	; 231
   15974:	31 f5       	brne	.+76     	; 0x159c2 <_key_btn+0xa0>
   15976:	19 c0       	rjmp	.+50     	; 0x159aa <_key_btn+0x88>
   15978:	8d 3e       	cpi	r24, 0xED	; 237
   1597a:	49 f0       	breq	.+18     	; 0x1598e <_key_btn+0x6c>
   1597c:	8e 3e       	cpi	r24, 0xEE	; 238
   1597e:	09 f5       	brne	.+66     	; 0x159c2 <_key_btn+0xa0>
   15980:	02 c0       	rjmp	.+4      	; 0x15986 <_key_btn+0x64>
   15982:	82 e3       	ldi	r24, 0x32	; 50
   15984:	08 95       	ret
   15986:	81 e3       	ldi	r24, 0x31	; 49
   15988:	08 95       	ret
   1598a:	83 e3       	ldi	r24, 0x33	; 51
   1598c:	08 95       	ret
		case 0xDE:
			__keychar = 0x32; //2
			break;
		case 0xBE:
			__keychar = 0x33; //3
			break;
   1598e:	84 e3       	ldi	r24, 0x34	; 52
   15990:	08 95       	ret
		case 0xED:
			__keychar = 0x34; //4
			break;
   15992:	85 e3       	ldi	r24, 0x35	; 53
   15994:	08 95       	ret
		case 0xDD:
			__keychar = 0x35; //5
			break;
   15996:	86 e3       	ldi	r24, 0x36	; 54
   15998:	08 95       	ret
		case 0xBD:
			__keychar = 0x36; //6
			break;
   1599a:	87 e3       	ldi	r24, 0x37	; 55
   1599c:	08 95       	ret
		case 0xEB:
			__keychar = 0x37; //7
			break;
   1599e:	88 e3       	ldi	r24, 0x38	; 56
   159a0:	08 95       	ret
		case 0xDB:
			__keychar = 0x38; //8
			break;
   159a2:	89 e3       	ldi	r24, 0x39	; 57
   159a4:	08 95       	ret
		case 0xBB:
			__keychar = 0x39; //9
			break;
   159a6:	80 e3       	ldi	r24, 0x30	; 48
   159a8:	08 95       	ret
		case 0xD7:
			__keychar = 0x30; //0
			break;
   159aa:	8a e2       	ldi	r24, 0x2A	; 42
   159ac:	08 95       	ret
		case 0xE7:
			__keychar = 0x2a; //*
			break;
   159ae:	83 e2       	ldi	r24, 0x23	; 35
   159b0:	08 95       	ret
		case 0xB7:
			__keychar = 0x23; //#
			break;
   159b2:	81 ef       	ldi	r24, 0xF1	; 241
   159b4:	08 95       	ret
		case 0x7E:
			__keychar = 0xF1; //Menu 1
			break;
   159b6:	82 ef       	ldi	r24, 0xF2	; 242
   159b8:	08 95       	ret
		case 0x7D:
			__keychar = 0xF2; //Menu 2
			break;
   159ba:	83 ef       	ldi	r24, 0xF3	; 243
   159bc:	08 95       	ret
		case 0x7B:
			__keychar = 0xF3; //Menu 3
			break;
   159be:	84 ef       	ldi	r24, 0xF4	; 244
   159c0:	08 95       	ret
		case 0x77:
			__keychar = 0xF4; //Menu 4
			break;
   159c2:	80 e0       	ldi	r24, 0x00	; 0
			__keychar = 0x00;
			break;

	}
	return __keychar;
}
   159c4:	08 95       	ret

000159c6 <_light_ticker>:

void _light_ticker(void){
	if(__key_light == 1){
   159c6:	80 91 e2 03 	lds	r24, 0x03E2
   159ca:	81 30       	cpi	r24, 0x01	; 1
   159cc:	81 f4       	brne	.+32     	; 0x159ee <_light_ticker+0x28>
		__key_lgtcnt++;
   159ce:	80 91 e3 03 	lds	r24, 0x03E3
   159d2:	8f 5f       	subi	r24, 0xFF	; 255
   159d4:	80 93 e3 03 	sts	0x03E3, r24
		if(__key_lgtcnt == 150){
   159d8:	86 39       	cpi	r24, 0x96	; 150
   159da:	49 f4       	brne	.+18     	; 0x159ee <_light_ticker+0x28>
		   __key_light = 0; __key_lgtcnt = 0; sbi(PORTG, 1);
   159dc:	10 92 e2 03 	sts	0x03E2, r1
   159e0:	10 92 e3 03 	sts	0x03E3, r1
   159e4:	80 91 65 00 	lds	r24, 0x0065
   159e8:	82 60       	ori	r24, 0x02	; 2
   159ea:	80 93 65 00 	sts	0x0065, r24
   159ee:	08 95       	ret

000159f0 <_table_alphanum>:
	}
	_PAD_1st;
	return __key;
}

char _table_alphanum(char __caps, char __key, char __hit){
   159f0:	98 2f       	mov	r25, r24
unsigned char __retchar = 0;

	switch(__key){
   159f2:	6d 3d       	cpi	r22, 0xDD	; 221
   159f4:	11 f1       	breq	.+68     	; 0x15a3a <_table_alphanum+0x4a>
   159f6:	6e 3d       	cpi	r22, 0xDE	; 222
   159f8:	60 f4       	brcc	.+24     	; 0x15a12 <_table_alphanum+0x22>
   159fa:	6d 3b       	cpi	r22, 0xBD	; 189
   159fc:	01 f1       	breq	.+64     	; 0x15a3e <_table_alphanum+0x4e>
   159fe:	6e 3b       	cpi	r22, 0xBE	; 190
   15a00:	18 f4       	brcc	.+6      	; 0x15a08 <_table_alphanum+0x18>
   15a02:	6b 3b       	cpi	r22, 0xBB	; 187
   15a04:	21 f5       	brne	.+72     	; 0x15a4e <_table_alphanum+0x5e>
   15a06:	21 c0       	rjmp	.+66     	; 0x15a4a <_table_alphanum+0x5a>
   15a08:	6e 3b       	cpi	r22, 0xBE	; 190
   15a0a:	99 f0       	breq	.+38     	; 0x15a32 <_table_alphanum+0x42>
   15a0c:	6b 3d       	cpi	r22, 0xDB	; 219
   15a0e:	f9 f4       	brne	.+62     	; 0x15a4e <_table_alphanum+0x5e>
   15a10:	1a c0       	rjmp	.+52     	; 0x15a46 <_table_alphanum+0x56>
   15a12:	6b 3e       	cpi	r22, 0xEB	; 235
   15a14:	b1 f0       	breq	.+44     	; 0x15a42 <_table_alphanum+0x52>
   15a16:	6c 3e       	cpi	r22, 0xEC	; 236
   15a18:	18 f4       	brcc	.+6      	; 0x15a20 <_table_alphanum+0x30>
   15a1a:	6e 3d       	cpi	r22, 0xDE	; 222
   15a1c:	c1 f4       	brne	.+48     	; 0x15a4e <_table_alphanum+0x5e>
   15a1e:	05 c0       	rjmp	.+10     	; 0x15a2a <_table_alphanum+0x3a>
   15a20:	6d 3e       	cpi	r22, 0xED	; 237
   15a22:	49 f0       	breq	.+18     	; 0x15a36 <_table_alphanum+0x46>
   15a24:	6e 3e       	cpi	r22, 0xEE	; 238
   15a26:	99 f4       	brne	.+38     	; 0x15a4e <_table_alphanum+0x5e>
   15a28:	02 c0       	rjmp	.+4      	; 0x15a2e <_table_alphanum+0x3e>
   15a2a:	82 e0       	ldi	r24, 0x02	; 2
   15a2c:	11 c0       	rjmp	.+34     	; 0x15a50 <_table_alphanum+0x60>
   15a2e:	81 e0       	ldi	r24, 0x01	; 1
   15a30:	0f c0       	rjmp	.+30     	; 0x15a50 <_table_alphanum+0x60>
   15a32:	83 e0       	ldi	r24, 0x03	; 3
   15a34:	0d c0       	rjmp	.+26     	; 0x15a50 <_table_alphanum+0x60>
		case 0xDE:
			__key = 2; //2
			break;
		case 0xBE:
			__key = 3; //3
			break;
   15a36:	84 e0       	ldi	r24, 0x04	; 4
   15a38:	0b c0       	rjmp	.+22     	; 0x15a50 <_table_alphanum+0x60>
		case 0xED:
			__key = 4; //4
			break;
   15a3a:	85 e0       	ldi	r24, 0x05	; 5
   15a3c:	09 c0       	rjmp	.+18     	; 0x15a50 <_table_alphanum+0x60>
		case 0xDD:
			__key = 5; //5
			break;
   15a3e:	86 e0       	ldi	r24, 0x06	; 6
   15a40:	07 c0       	rjmp	.+14     	; 0x15a50 <_table_alphanum+0x60>
		case 0xBD:
			__key = 6; //6
			break;
   15a42:	87 e0       	ldi	r24, 0x07	; 7
   15a44:	05 c0       	rjmp	.+10     	; 0x15a50 <_table_alphanum+0x60>
		case 0xEB:
			__key = 7; //7
			break;
   15a46:	88 e0       	ldi	r24, 0x08	; 8
   15a48:	03 c0       	rjmp	.+6      	; 0x15a50 <_table_alphanum+0x60>
		case 0xDB:
			__key = 8; //8
			break;
   15a4a:	89 e0       	ldi	r24, 0x09	; 9
   15a4c:	01 c0       	rjmp	.+2      	; 0x15a50 <_table_alphanum+0x60>
		case 0xBB:
			__key = 9; //9
			break;
   15a4e:	80 e0       	ldi	r24, 0x00	; 0
		default:
			__key = 0;
			break;	
	}

	if(__hit <= pgm_read_byte(&__maxchar[__key]))
   15a50:	28 2f       	mov	r18, r24
   15a52:	30 e0       	ldi	r19, 0x00	; 0
   15a54:	f9 01       	movw	r30, r18
   15a56:	e7 50       	subi	r30, 0x07	; 7
   15a58:	fc 4d       	sbci	r31, 0xDC	; 220
   15a5a:	e4 91       	lpm	r30, Z+
   15a5c:	e4 17       	cp	r30, r20
   15a5e:	10 f4       	brcc	.+4      	; 0x15a64 <_table_alphanum+0x74>
   15a60:	80 e0       	ldi	r24, 0x00	; 0
   15a62:	08 95       	ret
		__retchar = pgm_read_byte(&__alphanum[__caps][__key][__hit]);
   15a64:	ec e3       	ldi	r30, 0x3C	; 60
   15a66:	9e 9f       	mul	r25, r30
   15a68:	f0 01       	movw	r30, r0
   15a6a:	11 24       	eor	r1, r1
   15a6c:	e4 0f       	add	r30, r20
   15a6e:	f1 1d       	adc	r31, r1
   15a70:	c9 01       	movw	r24, r18
   15a72:	88 0f       	add	r24, r24
   15a74:	99 1f       	adc	r25, r25
   15a76:	82 0f       	add	r24, r18
   15a78:	93 1f       	adc	r25, r19
   15a7a:	88 0f       	add	r24, r24
   15a7c:	99 1f       	adc	r25, r25
   15a7e:	e8 0f       	add	r30, r24
   15a80:	f9 1f       	adc	r31, r25
   15a82:	ef 57       	subi	r30, 0x7F	; 127
   15a84:	fc 4d       	sbci	r31, 0xDC	; 220
   15a86:	84 91       	lpm	r24, Z+
	else __retchar = '\0';

	return __retchar;
}
   15a88:	08 95       	ret

00015a8a <_key_scan>:
		if((_COUNTSHIFT & (__chr_count < __max_string)))
			_SHIFT_RST;
	}
}

char _key_scan(char __select){
   15a8a:	8f 92       	push	r8
   15a8c:	9f 92       	push	r9
   15a8e:	af 92       	push	r10
   15a90:	bf 92       	push	r11
   15a92:	cf 92       	push	r12
   15a94:	df 92       	push	r13
   15a96:	ef 92       	push	r14
   15a98:	ff 92       	push	r15
   15a9a:	0f 93       	push	r16
   15a9c:	1f 93       	push	r17
   15a9e:	df 93       	push	r29
   15aa0:	cf 93       	push	r28
   15aa2:	00 d0       	rcall	.+0      	; 0x15aa4 <_key_scan+0x1a>
   15aa4:	00 d0       	rcall	.+0      	; 0x15aa6 <_key_scan+0x1c>
   15aa6:	cd b7       	in	r28, 0x3d	; 61
   15aa8:	de b7       	in	r29, 0x3e	; 62
   15aaa:	18 2f       	mov	r17, r24
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
   15aac:	81 50       	subi	r24, 0x01	; 1
   15aae:	82 30       	cpi	r24, 0x02	; 2
   15ab0:	08 f0       	brcs	.+2      	; 0x15ab4 <_key_scan+0x2a>
   15ab2:	aa c0       	rjmp	.+340    	; 0x15c08 <_key_scan+0x17e>
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15ab4:	8f ee       	ldi	r24, 0xEF	; 239
   15ab6:	89 83       	std	Y+1, r24	; 0x01
   15ab8:	8f ed       	ldi	r24, 0xDF	; 223
   15aba:	8a 83       	std	Y+2, r24	; 0x02
   15abc:	8f eb       	ldi	r24, 0xBF	; 191
   15abe:	8b 83       	std	Y+3, r24	; 0x03
   15ac0:	8f e7       	ldi	r24, 0x7F	; 127
   15ac2:	8c 83       	std	Y+4, r24	; 0x04
   15ac4:	de 01       	movw	r26, r28
   15ac6:	11 96       	adiw	r26, 0x01	; 1
   15ac8:	2a ef       	ldi	r18, 0xFA	; 250
   15aca:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   15acc:	ae 01       	movw	r20, r28
   15ace:	4b 5f       	subi	r20, 0xFB	; 251
   15ad0:	5f 4f       	sbci	r21, 0xFF	; 255
   15ad2:	c9 01       	movw	r24, r18
   15ad4:	01 97       	sbiw	r24, 0x01	; 1
   15ad6:	f1 f7       	brne	.-4      	; 0x15ad4 <_key_scan+0x4a>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15ad8:	8c 91       	ld	r24, X
   15ada:	80 93 62 00 	sts	0x0062, r24
   15ade:	f9 01       	movw	r30, r18
   15ae0:	31 97       	sbiw	r30, 0x01	; 1
   15ae2:	f1 f7       	brne	.-4      	; 0x15ae0 <_key_scan+0x56>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15ae4:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) break;
   15ae6:	98 17       	cp	r25, r24
   15ae8:	21 f4       	brne	.+8      	; 0x15af2 <_key_scan+0x68>
   15aea:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15aec:	a4 17       	cp	r26, r20
   15aee:	b5 07       	cpc	r27, r21
   15af0:	81 f7       	brne	.-32     	; 0x15ad2 <_key_scan+0x48>
char _key_scan(char __select){
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
		__key = _key_hit();
		__key = _key_crr(__key);
   15af2:	89 2f       	mov	r24, r25
   15af4:	0e 94 6f ac 	call	0x158de	; 0x158de <_key_crr>
   15af8:	28 2f       	mov	r18, r24

		if(__key!=_KEY_NULL){
   15afa:	88 23       	and	r24, r24
   15afc:	09 f4       	brne	.+2      	; 0x15b00 <_key_scan+0x76>
   15afe:	85 c0       	rjmp	.+266    	; 0x15c0a <_key_scan+0x180>
			_LIGHT_SET;
   15b00:	91 e0       	ldi	r25, 0x01	; 1
   15b02:	90 93 e2 03 	sts	0x03E2, r25
   15b06:	10 92 e3 03 	sts	0x03E3, r1
   15b0a:	80 91 65 00 	lds	r24, 0x0065
   15b0e:	8d 7f       	andi	r24, 0xFD	; 253
   15b10:	80 93 65 00 	sts	0x0065, r24
			if(__sec_par)
   15b14:	80 91 c0 04 	lds	r24, 0x04C0
   15b18:	88 23       	and	r24, r24
   15b1a:	31 f0       	breq	.+12     	; 0x15b28 <_key_scan+0x9e>
				_SEC_ON;
   15b1c:	90 93 ed 03 	sts	0x03ED, r25
   15b20:	10 92 25 04 	sts	0x0425, r1
   15b24:	10 92 ee 03 	sts	0x03EE, r1

			if(_IS1st){
   15b28:	80 91 e9 03 	lds	r24, 0x03E9
   15b2c:	88 23       	and	r24, r24
   15b2e:	71 f4       	brne	.+28     	; 0x15b4c <_key_scan+0xc2>
				if(	__key == _KEY_CANCEL || __key == _KEY_ENTER)
   15b30:	27 3e       	cpi	r18, 0xE7	; 231
   15b32:	11 f0       	breq	.+4      	; 0x15b38 <_key_scan+0xae>
   15b34:	27 3b       	cpi	r18, 0xB7	; 183
   15b36:	31 f4       	brne	.+12     	; 0x15b44 <_key_scan+0xba>
					if(__lock_num)
   15b38:	80 91 de 03 	lds	r24, 0x03DE
   15b3c:	88 23       	and	r24, r24
   15b3e:	11 f0       	breq	.+4      	; 0x15b44 <_key_scan+0xba>
						__lock_num = 0;
   15b40:	10 92 de 03 	sts	0x03DE, r1
				_PAD_2nd;
   15b44:	81 e0       	ldi	r24, 0x01	; 1
   15b46:	80 93 e9 03 	sts	0x03E9, r24
   15b4a:	59 c0       	rjmp	.+178    	; 0x15bfe <_key_scan+0x174>
				//_spi_tx(0x24, _SPI_SLAVE, "~");
				_delay_ms(5);
				return __key;
			}
			if(_IS2nd){
   15b4c:	81 30       	cpi	r24, 0x01	; 1
   15b4e:	09 f0       	breq	.+2      	; 0x15b52 <_key_scan+0xc8>
   15b50:	5c c0       	rjmp	.+184    	; 0x15c0a <_key_scan+0x180>
				if(__select==_PAD_MULTI){
   15b52:	12 30       	cpi	r17, 0x02	; 2
   15b54:	21 f5       	brne	.+72     	; 0x15b9e <_key_scan+0x114>
					if(	__key==_KEY_0 || __key==_KEY_1 || __key==_KEY_2 || __key==_KEY_3||
   15b56:	27 3d       	cpi	r18, 0xD7	; 215
   15b58:	91 f0       	breq	.+36     	; 0x15b7e <_key_scan+0xf4>
   15b5a:	2e 3e       	cpi	r18, 0xEE	; 238
   15b5c:	81 f0       	breq	.+32     	; 0x15b7e <_key_scan+0xf4>
   15b5e:	2e 3d       	cpi	r18, 0xDE	; 222
   15b60:	71 f0       	breq	.+28     	; 0x15b7e <_key_scan+0xf4>
   15b62:	2e 3b       	cpi	r18, 0xBE	; 190
   15b64:	61 f0       	breq	.+24     	; 0x15b7e <_key_scan+0xf4>
   15b66:	2d 3e       	cpi	r18, 0xED	; 237
   15b68:	51 f0       	breq	.+20     	; 0x15b7e <_key_scan+0xf4>
   15b6a:	2d 3d       	cpi	r18, 0xDD	; 221
   15b6c:	41 f0       	breq	.+16     	; 0x15b7e <_key_scan+0xf4>
   15b6e:	2d 3b       	cpi	r18, 0xBD	; 189
   15b70:	31 f0       	breq	.+12     	; 0x15b7e <_key_scan+0xf4>
   15b72:	2b 3e       	cpi	r18, 0xEB	; 235
   15b74:	21 f0       	breq	.+8      	; 0x15b7e <_key_scan+0xf4>
   15b76:	2b 3d       	cpi	r18, 0xDB	; 219
   15b78:	11 f0       	breq	.+4      	; 0x15b7e <_key_scan+0xf4>
   15b7a:	2b 3b       	cpi	r18, 0xBB	; 187
   15b7c:	81 f4       	brne	.+32     	; 0x15b9e <_key_scan+0x114>
						__key==_KEY_4 || __key==_KEY_5 || __key==_KEY_6 ||
						__key==_KEY_7 || __key==_KEY_8 || __key==_KEY_9){
						if(__lock_num){
   15b7e:	80 91 de 03 	lds	r24, 0x03DE
   15b82:	88 23       	and	r24, r24
   15b84:	49 f0       	breq	.+18     	; 0x15b98 <_key_scan+0x10e>
							_SHIFT_SET;
   15b86:	81 e0       	ldi	r24, 0x01	; 1
   15b88:	80 93 df 03 	sts	0x03DF, r24
   15b8c:	10 92 e0 03 	sts	0x03E0, r1
							CURSOR_HIDE;
   15b90:	8c e0       	ldi	r24, 0x0C	; 12
   15b92:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
   15b96:	03 c0       	rjmp	.+6      	; 0x15b9e <_key_scan+0x114>
						}
						else
							__lock_num = 1;
   15b98:	81 e0       	ldi	r24, 0x01	; 1
   15b9a:	80 93 de 03 	sts	0x03DE, r24
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15b9e:	ff ee       	ldi	r31, 0xEF	; 239
   15ba0:	8f 2e       	mov	r8, r31
   15ba2:	ef ed       	ldi	r30, 0xDF	; 223
   15ba4:	9e 2e       	mov	r9, r30
   15ba6:	7f eb       	ldi	r23, 0xBF	; 191
   15ba8:	a7 2e       	mov	r10, r23
   15baa:	6f e7       	ldi	r22, 0x7F	; 127
   15bac:	b6 2e       	mov	r11, r22
   15bae:	6e 01       	movw	r12, r28
   15bb0:	08 94       	sec
   15bb2:	c1 1c       	adc	r12, r1
   15bb4:	d1 1c       	adc	r13, r1
   15bb6:	0a ef       	ldi	r16, 0xFA	; 250
   15bb8:	10 e0       	ldi	r17, 0x00	; 0

	for(i=0; i<4; i++){
   15bba:	55 e0       	ldi	r21, 0x05	; 5
   15bbc:	e5 2e       	mov	r14, r21
   15bbe:	f1 2c       	mov	r15, r1
   15bc0:	ec 0e       	add	r14, r28
   15bc2:	fd 1e       	adc	r15, r29
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15bc4:	89 82       	std	Y+1, r8	; 0x01
   15bc6:	9a 82       	std	Y+2, r9	; 0x02
   15bc8:	ab 82       	std	Y+3, r10	; 0x03
   15bca:	bc 82       	std	Y+4, r11	; 0x04
   15bcc:	d6 01       	movw	r26, r12
   15bce:	c8 01       	movw	r24, r16
   15bd0:	01 97       	sbiw	r24, 0x01	; 1
   15bd2:	f1 f7       	brne	.-4      	; 0x15bd0 <_key_scan+0x146>

	for(i=0; i<4; i++){
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15bd4:	8c 91       	ld	r24, X
   15bd6:	80 93 62 00 	sts	0x0062, r24
   15bda:	f8 01       	movw	r30, r16
   15bdc:	31 97       	sbiw	r30, 0x01	; 1
   15bde:	f1 f7       	brne	.-4      	; 0x15bdc <_key_scan+0x152>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15be0:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) break;
   15be2:	98 17       	cp	r25, r24
   15be4:	21 f4       	brne	.+8      	; 0x15bee <_key_scan+0x164>
   15be6:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15be8:	ae 15       	cp	r26, r14
   15bea:	bf 05       	cpc	r27, r15
   15bec:	81 f7       	brne	.-32     	; 0x15bce <_key_scan+0x144>
							__lock_num = 1;
					}
				}
				do{
					__key = _key_hit();
					__key = _key_crr(__key);
   15bee:	89 2f       	mov	r24, r25
   15bf0:	0e 94 6f ac 	call	0x158de	; 0x158de <_key_crr>
   15bf4:	28 2f       	mov	r18, r24
				}while(__key!=_KEY_NULL);
   15bf6:	88 23       	and	r24, r24
   15bf8:	29 f7       	brne	.-54     	; 0x15bc4 <_key_scan+0x13a>
				_PAD_1st;
   15bfa:	10 92 e9 03 	sts	0x03E9, r1
   15bfe:	82 ee       	ldi	r24, 0xE2	; 226
   15c00:	94 e0       	ldi	r25, 0x04	; 4
   15c02:	01 97       	sbiw	r24, 0x01	; 1
   15c04:	f1 f7       	brne	.-4      	; 0x15c02 <_key_scan+0x178>
   15c06:	03 c0       	rjmp	.+6      	; 0x15c0e <_key_scan+0x184>
				_delay_ms(5);
				return _KEY_NULL;
   15c08:	20 e0       	ldi	r18, 0x00	; 0
			}
		}
	}
	_PAD_1st;
   15c0a:	10 92 e9 03 	sts	0x03E9, r1
	return __key;
}
   15c0e:	82 2f       	mov	r24, r18
   15c10:	0f 90       	pop	r0
   15c12:	0f 90       	pop	r0
   15c14:	0f 90       	pop	r0
   15c16:	0f 90       	pop	r0
   15c18:	cf 91       	pop	r28
   15c1a:	df 91       	pop	r29
   15c1c:	1f 91       	pop	r17
   15c1e:	0f 91       	pop	r16
   15c20:	ff 90       	pop	r15
   15c22:	ef 90       	pop	r14
   15c24:	df 90       	pop	r13
   15c26:	cf 90       	pop	r12
   15c28:	bf 90       	pop	r11
   15c2a:	af 90       	pop	r10
   15c2c:	9f 90       	pop	r9
   15c2e:	8f 90       	pop	r8
   15c30:	08 95       	ret

00015c32 <_key_string>:
	else __retchar = '\0';

	return __retchar;
}

char _key_string(char __mode){
   15c32:	ef 92       	push	r14
   15c34:	ff 92       	push	r15
   15c36:	0f 93       	push	r16
   15c38:	1f 93       	push	r17
   15c3a:	cf 93       	push	r28
   15c3c:	df 93       	push	r29
	unsigned char	 __chr = 0, __i = 0;
	uint8_t  __key = 0;

	if(__mode==0){
   15c3e:	88 23       	and	r24, r24
   15c40:	09 f0       	breq	.+2      	; 0x15c44 <_key_string+0x12>
   15c42:	56 c0       	rjmp	.+172    	; 0x15cf0 <_key_string+0xbe>
		CURSOR_SHOW;
   15c44:	8f e0       	ldi	r24, 0x0F	; 15
   15c46:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
		while(1){
			__key = _key_scan(_PAD_SINGLE);
   15c4a:	81 e0       	ldi	r24, 0x01	; 1
   15c4c:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   15c50:	e8 2e       	mov	r14, r24
			if(__key==_KEY_NULL || __key==_KEY_TIKET || __key==_KEY_MENU || __key==_KEY_SHIFT);
   15c52:	88 23       	and	r24, r24
   15c54:	d1 f3       	breq	.-12     	; 0x15c4a <_key_string+0x18>
   15c56:	8e e7       	ldi	r24, 0x7E	; 126
   15c58:	e8 16       	cp	r14, r24
   15c5a:	b9 f3       	breq	.-18     	; 0x15c4a <_key_string+0x18>
   15c5c:	9d e7       	ldi	r25, 0x7D	; 125
   15c5e:	e9 16       	cp	r14, r25
   15c60:	a1 f3       	breq	.-24     	; 0x15c4a <_key_string+0x18>
   15c62:	eb e7       	ldi	r30, 0x7B	; 123
   15c64:	ee 16       	cp	r14, r30
   15c66:	89 f3       	breq	.-30     	; 0x15c4a <_key_string+0x18>
			else if(__key==_KEY_CANCEL){
   15c68:	f7 ee       	ldi	r31, 0xE7	; 231
   15c6a:	ef 16       	cp	r14, r31
   15c6c:	19 f4       	brne	.+6      	; 0x15c74 <_key_string+0x42>
				__chr_count = 0;
   15c6e:	10 92 db 03 	sts	0x03DB, r1
   15c72:	50 c0       	rjmp	.+160    	; 0x15d14 <_key_string+0xe2>
				CURSOR_HIDE;
				_SHIFT_OFF;//
				return 1;
			}
			else if(__key==_KEY_ENTER){
   15c74:	87 eb       	ldi	r24, 0xB7	; 183
   15c76:	e8 16       	cp	r14, r24
   15c78:	19 f4       	brne	.+6      	; 0x15c80 <_key_string+0x4e>
				__chr_count = 0;
   15c7a:	10 92 db 03 	sts	0x03DB, r1
   15c7e:	52 c0       	rjmp	.+164    	; 0x15d24 <_key_string+0xf2>
   15c80:	90 91 db 03 	lds	r25, 0x03DB
				CURSOR_HIDE;
				_SHIFT_OFF;//
				return 0;
			}
			else if(__key==_KEY_CLEAR){
   15c84:	e7 e7       	ldi	r30, 0x77	; 119
   15c86:	ee 16       	cp	r14, r30
   15c88:	b1 f4       	brne	.+44     	; 0x15cb6 <_key_string+0x84>
				if(__chr_count>0){
   15c8a:	99 23       	and	r25, r25
   15c8c:	f1 f2       	breq	.-68     	; 0x15c4a <_key_string+0x18>
					_LCD_LEFT;
   15c8e:	80 e1       	ldi	r24, 0x10	; 16
   15c90:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
					_lcd(0x10);
   15c94:	80 e1       	ldi	r24, 0x10	; 16
   15c96:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
					_LCD_LEFT;
   15c9a:	80 e1       	ldi	r24, 0x10	; 16
   15c9c:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
					__buf_string[__chr_count-1] = '\0';
   15ca0:	80 91 db 03 	lds	r24, 0x03DB
   15ca4:	e8 2f       	mov	r30, r24
   15ca6:	f0 e0       	ldi	r31, 0x00	; 0
   15ca8:	e3 54       	subi	r30, 0x43	; 67
   15caa:	f1 4f       	sbci	r31, 0xF1	; 241
   15cac:	10 82       	st	Z, r1
					__chr_count--;
   15cae:	81 50       	subi	r24, 0x01	; 1
   15cb0:	80 93 db 03 	sts	0x03DB, r24
   15cb4:	ca cf       	rjmp	.-108    	; 0x15c4a <_key_string+0x18>
				}
			}
			else{
				if(__chr_count<__max_string){
   15cb6:	80 91 dc 03 	lds	r24, 0x03DC
   15cba:	98 17       	cp	r25, r24
   15cbc:	30 f6       	brcc	.-116    	; 0x15c4a <_key_string+0x18>
					_lcd(_table_alphanum(0, __key, 0));
   15cbe:	80 e0       	ldi	r24, 0x00	; 0
   15cc0:	6e 2d       	mov	r22, r14
   15cc2:	40 e0       	ldi	r20, 0x00	; 0
   15cc4:	0e 94 f8 ac 	call	0x159f0	; 0x159f0 <_table_alphanum>
   15cc8:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
					__buf_string[__chr_count] = _table_alphanum(0, __key, 0);
   15ccc:	f0 90 db 03 	lds	r15, 0x03DB
   15cd0:	0f 2d       	mov	r16, r15
   15cd2:	10 e0       	ldi	r17, 0x00	; 0
   15cd4:	80 e0       	ldi	r24, 0x00	; 0
   15cd6:	6e 2d       	mov	r22, r14
   15cd8:	40 e0       	ldi	r20, 0x00	; 0
   15cda:	0e 94 f8 ac 	call	0x159f0	; 0x159f0 <_table_alphanum>
   15cde:	02 54       	subi	r16, 0x42	; 66
   15ce0:	11 4f       	sbci	r17, 0xF1	; 241
   15ce2:	f8 01       	movw	r30, r16
   15ce4:	80 83       	st	Z, r24
					__buf_string[__chr_count + 1] = '\0';
   15ce6:	11 82       	std	Z+1, r1	; 0x01
					__chr_count++;
   15ce8:	f3 94       	inc	r15
   15cea:	f0 92 db 03 	sts	0x03DB, r15
   15cee:	ad cf       	rjmp	.-166    	; 0x15c4a <_key_string+0x18>
				}
			}
		}
	}
	if(__mode==_STRING_ALPHANUM){
   15cf0:	81 30       	cpi	r24, 0x01	; 1
   15cf2:	09 f0       	breq	.+2      	; 0x15cf6 <_key_string+0xc4>
   15cf4:	a0 c0       	rjmp	.+320    	; 0x15e36 <_key_string+0x204>
		while(1){
		   CURSOR_SHOW; 
   15cf6:	8f e0       	ldi	r24, 0x0F	; 15
   15cf8:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
			__key = _key_scan(_PAD_MULTI);
   15cfc:	82 e0       	ldi	r24, 0x02	; 2
   15cfe:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   15d02:	08 2f       	mov	r16, r24
			if(__key == _KEY_NULL || __key == _KEY_TIKET || __key == _KEY_MENU);
   15d04:	88 23       	and	r24, r24
   15d06:	b9 f3       	breq	.-18     	; 0x15cf6 <_key_string+0xc4>
   15d08:	8e 37       	cpi	r24, 0x7E	; 126
   15d0a:	a9 f3       	breq	.-22     	; 0x15cf6 <_key_string+0xc4>
   15d0c:	8d 37       	cpi	r24, 0x7D	; 125
   15d0e:	99 f3       	breq	.-26     	; 0x15cf6 <_key_string+0xc4>
			else if(__key == _KEY_CANCEL){
   15d10:	87 3e       	cpi	r24, 0xE7	; 231
   15d12:	31 f4       	brne	.+12     	; 0x15d20 <_key_string+0xee>
				CURSOR_HIDE;
   15d14:	8c e0       	ldi	r24, 0x0C	; 12
   15d16:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
				_SHIFT_OFF;
   15d1a:	10 92 df 03 	sts	0x03DF, r1
   15d1e:	fe c0       	rjmp	.+508    	; 0x15f1c <_key_string+0x2ea>
				return 1;
			}
			else if(__key == _KEY_ENTER){
   15d20:	87 3b       	cpi	r24, 0xB7	; 183
   15d22:	31 f4       	brne	.+12     	; 0x15d30 <_key_string+0xfe>
				CURSOR_HIDE;
   15d24:	8c e0       	ldi	r24, 0x0C	; 12
   15d26:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
				_SHIFT_OFF;
   15d2a:	10 92 df 03 	sts	0x03DF, r1
   15d2e:	39 c1       	rjmp	.+626    	; 0x15fa2 <_key_string+0x370>
				return 0;
			}
			else if(__key == _KEY_SHIFT){
   15d30:	8b 37       	cpi	r24, 0x7B	; 123
   15d32:	39 f4       	brne	.+14     	; 0x15d42 <_key_string+0x110>
				__caps_lock = __caps_lock ^ 1;
   15d34:	80 91 dd 03 	lds	r24, 0x03DD
   15d38:	91 e0       	ldi	r25, 0x01	; 1
   15d3a:	89 27       	eor	r24, r25
   15d3c:	80 93 dd 03 	sts	0x03DD, r24
   15d40:	da cf       	rjmp	.-76     	; 0x15cf6 <_key_string+0xc4>
   15d42:	90 91 db 03 	lds	r25, 0x03DB
			}
			else if(__key == _KEY_CLEAR){
   15d46:	87 37       	cpi	r24, 0x77	; 119
   15d48:	39 f5       	brne	.+78     	; 0x15d98 <_key_string+0x166>
				if(__chr_count > 0){
   15d4a:	99 23       	and	r25, r25
   15d4c:	a1 f2       	breq	.-88     	; 0x15cf6 <_key_string+0xc4>
				if(!__key_shift){
   15d4e:	80 91 df 03 	lds	r24, 0x03DF
   15d52:	88 23       	and	r24, r24
   15d54:	81 f6       	brne	.-96     	; 0x15cf6 <_key_string+0xc4>
					_LCD_LEFT;
   15d56:	80 e1       	ldi	r24, 0x10	; 16
   15d58:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
					_lcd(0x10);
   15d5c:	80 e1       	ldi	r24, 0x10	; 16
   15d5e:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
					_LCD_LEFT;
   15d62:	80 e1       	ldi	r24, 0x10	; 16
   15d64:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
					__buf_string[__chr_count - 1] = '\0';
   15d68:	80 91 db 03 	lds	r24, 0x03DB
   15d6c:	e8 2f       	mov	r30, r24
   15d6e:	f0 e0       	ldi	r31, 0x00	; 0
   15d70:	e3 54       	subi	r30, 0x43	; 67
   15d72:	f1 4f       	sbci	r31, 0xF1	; 241
   15d74:	10 82       	st	Z, r1
					__chr_count--;
   15d76:	81 50       	subi	r24, 0x01	; 1
   15d78:	80 93 db 03 	sts	0x03DB, r24
					if(__chr_count == 19){
   15d7c:	83 31       	cpi	r24, 0x13	; 19
   15d7e:	49 f4       	brne	.+18     	; 0x15d92 <_key_string+0x160>
						lcd_put(2, 20, 0x10);
   15d80:	82 e0       	ldi	r24, 0x02	; 2
   15d82:	64 e1       	ldi	r22, 0x14	; 20
   15d84:	40 e1       	ldi	r20, 0x10	; 16
   15d86:	0e 94 04 ac 	call	0x15808	; 0x15808 <lcd_put>
						lcd_xy(2, 20);
   15d8a:	82 e0       	ldi	r24, 0x02	; 2
   15d8c:	64 e1       	ldi	r22, 0x14	; 20
   15d8e:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
					}
					_SHIFT_OFF;
   15d92:	10 92 df 03 	sts	0x03DF, r1
   15d96:	4b c0       	rjmp	.+150    	; 0x15e2e <_key_string+0x1fc>
					//_SHIFT_FREE;
				}
				}
			}
			else{
				if(__chr_count < __max_string){
   15d98:	80 91 dc 03 	lds	r24, 0x03DC
   15d9c:	98 17       	cp	r25, r24
   15d9e:	08 f0       	brcs	.+2      	; 0x15da2 <_key_string+0x170>
   15da0:	46 c0       	rjmp	.+140    	; 0x15e2e <_key_string+0x1fc>
					if(__key != __buf_anum){
   15da2:	80 91 d9 03 	lds	r24, 0x03D9
   15da6:	08 17       	cp	r16, r24
   15da8:	b9 f0       	breq	.+46     	; 0x15dd8 <_key_string+0x1a6>
						__buf_anum = __key;
   15daa:	00 93 d9 03 	sts	0x03D9, r16
						__hit_count = 0;
   15dae:	10 92 da 03 	sts	0x03DA, r1
						if(__key_shift == 1 && __buf_anum != 0){
   15db2:	80 91 df 03 	lds	r24, 0x03DF
   15db6:	81 30       	cpi	r24, 0x01	; 1
   15db8:	a1 f4       	brne	.+40     	; 0x15de2 <_key_string+0x1b0>
							_LCD_RIGHT;
   15dba:	84 e1       	ldi	r24, 0x14	; 20
   15dbc:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
							__chr_count++;
   15dc0:	80 91 db 03 	lds	r24, 0x03DB
   15dc4:	8f 5f       	subi	r24, 0xFF	; 255
   15dc6:	80 93 db 03 	sts	0x03DB, r24
							if(__chr_count == 20)
   15dca:	84 31       	cpi	r24, 0x14	; 20
   15dcc:	51 f4       	brne	.+20     	; 0x15de2 <_key_string+0x1b0>
								lcd_xy(3, 1);
   15dce:	83 e0       	ldi	r24, 0x03	; 3
   15dd0:	61 e0       	ldi	r22, 0x01	; 1
   15dd2:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
   15dd6:	05 c0       	rjmp	.+10     	; 0x15de2 <_key_string+0x1b0>
						}
					}
					else{
						__hit_count++;
   15dd8:	80 91 da 03 	lds	r24, 0x03DA
   15ddc:	8f 5f       	subi	r24, 0xFF	; 255
   15dde:	80 93 da 03 	sts	0x03DA, r24
					}
					__chr = _table_alphanum(__caps_lock, __key, __hit_count);
   15de2:	e0 90 dd 03 	lds	r14, 0x03DD
   15de6:	8e 2d       	mov	r24, r14
   15de8:	60 2f       	mov	r22, r16
   15dea:	40 91 da 03 	lds	r20, 0x03DA
   15dee:	0e 94 f8 ac 	call	0x159f0	; 0x159f0 <_table_alphanum>
   15df2:	f8 2e       	mov	r15, r24
					if(__chr == '\0'){
   15df4:	88 23       	and	r24, r24
   15df6:	41 f4       	brne	.+16     	; 0x15e08 <_key_string+0x1d6>
						__hit_count = 0;
   15df8:	10 92 da 03 	sts	0x03DA, r1
						__chr = _table_alphanum(__caps_lock, __key, __hit_count);
   15dfc:	8e 2d       	mov	r24, r14
   15dfe:	60 2f       	mov	r22, r16
   15e00:	40 e0       	ldi	r20, 0x00	; 0
   15e02:	0e 94 f8 ac 	call	0x159f0	; 0x159f0 <_table_alphanum>
   15e06:	f8 2e       	mov	r15, r24
					}
					if(__chr_count < __max_string){
   15e08:	90 91 db 03 	lds	r25, 0x03DB
   15e0c:	80 91 dc 03 	lds	r24, 0x03DC
   15e10:	98 17       	cp	r25, r24
   15e12:	68 f4       	brcc	.+26     	; 0x15e2e <_key_string+0x1fc>
						_lcd(__chr);
   15e14:	8f 2d       	mov	r24, r15
   15e16:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
						_LCD_LEFT;
   15e1a:	80 e1       	ldi	r24, 0x10	; 16
   15e1c:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
						__buf_string[__chr_count] = __chr;
   15e20:	e0 91 db 03 	lds	r30, 0x03DB
   15e24:	f0 e0       	ldi	r31, 0x00	; 0
   15e26:	e2 54       	subi	r30, 0x42	; 66
   15e28:	f1 4f       	sbci	r31, 0xF1	; 241
   15e2a:	f0 82       	st	Z, r15
						__buf_string[__chr_count + 1] = '\0';
   15e2c:	11 82       	std	Z+1, r1	; 0x01
					}
				}
				CURSOR_SHOW;
   15e2e:	8f e0       	ldi	r24, 0x0F	; 15
   15e30:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
   15e34:	60 cf       	rjmp	.-320    	; 0x15cf6 <_key_string+0xc4>
				//else _SHIFT_LOCK;
			}
		}
	}
	if(__mode==_STRING_PASSWORD){
   15e36:	82 30       	cpi	r24, 0x02	; 2
   15e38:	09 f0       	breq	.+2      	; 0x15e3c <_key_string+0x20a>
   15e3a:	4e c0       	rjmp	.+156    	; 0x15ed8 <_key_string+0x2a6>
		CURSOR_SHOW;
   15e3c:	8f e0       	ldi	r24, 0x0F	; 15
   15e3e:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
		while(1){
			__key = _key_scan(_PAD_SINGLE);
   15e42:	81 e0       	ldi	r24, 0x01	; 1
   15e44:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   15e48:	e8 2e       	mov	r14, r24
			if(__key==_KEY_NULL || __key==_KEY_TIKET || __key==_KEY_MENU || __key==_KEY_SHIFT);
   15e4a:	88 23       	and	r24, r24
   15e4c:	d1 f3       	breq	.-12     	; 0x15e42 <_key_string+0x210>
   15e4e:	fe e7       	ldi	r31, 0x7E	; 126
   15e50:	8f 17       	cp	r24, r31
   15e52:	b9 f3       	breq	.-18     	; 0x15e42 <_key_string+0x210>
   15e54:	8d e7       	ldi	r24, 0x7D	; 125
   15e56:	e8 16       	cp	r14, r24
   15e58:	a1 f3       	breq	.-24     	; 0x15e42 <_key_string+0x210>
   15e5a:	9b e7       	ldi	r25, 0x7B	; 123
   15e5c:	e9 16       	cp	r14, r25
   15e5e:	89 f3       	breq	.-30     	; 0x15e42 <_key_string+0x210>
			else if(__key==_KEY_CANCEL){
   15e60:	e7 ee       	ldi	r30, 0xE7	; 231
   15e62:	ee 16       	cp	r14, r30
   15e64:	09 f4       	brne	.+2      	; 0x15e68 <_key_string+0x236>
   15e66:	55 c0       	rjmp	.+170    	; 0x15f12 <_key_string+0x2e0>
				__chr_count = 0;
				CURSOR_HIDE;
				return 1;
			}
			else if(__key==_KEY_ENTER){
   15e68:	f7 eb       	ldi	r31, 0xB7	; 183
   15e6a:	ef 16       	cp	r14, r31
   15e6c:	09 f4       	brne	.+2      	; 0x15e70 <_key_string+0x23e>
   15e6e:	62 c0       	rjmp	.+196    	; 0x15f34 <_key_string+0x302>
   15e70:	90 91 db 03 	lds	r25, 0x03DB
				__chr_count = 0;
				CURSOR_HIDE;
				return 0;
			}
			else if(__key==_KEY_CLEAR){
   15e74:	87 e7       	ldi	r24, 0x77	; 119
   15e76:	e8 16       	cp	r14, r24
   15e78:	b1 f4       	brne	.+44     	; 0x15ea6 <_key_string+0x274>
				if(__chr_count>0){
   15e7a:	99 23       	and	r25, r25
   15e7c:	11 f3       	breq	.-60     	; 0x15e42 <_key_string+0x210>
					_LCD_LEFT;
   15e7e:	80 e1       	ldi	r24, 0x10	; 16
   15e80:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
					_lcd(0x10);
   15e84:	80 e1       	ldi	r24, 0x10	; 16
   15e86:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
					_LCD_LEFT;
   15e8a:	80 e1       	ldi	r24, 0x10	; 16
   15e8c:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
					__buf_string[__chr_count-1] = '\0';
   15e90:	80 91 db 03 	lds	r24, 0x03DB
   15e94:	e8 2f       	mov	r30, r24
   15e96:	f0 e0       	ldi	r31, 0x00	; 0
   15e98:	e3 54       	subi	r30, 0x43	; 67
   15e9a:	f1 4f       	sbci	r31, 0xF1	; 241
   15e9c:	10 82       	st	Z, r1
					__chr_count--;
   15e9e:	81 50       	subi	r24, 0x01	; 1
   15ea0:	80 93 db 03 	sts	0x03DB, r24
   15ea4:	ce cf       	rjmp	.-100    	; 0x15e42 <_key_string+0x210>
				}
			}
			else{
				if(__chr_count<__max_string){
   15ea6:	80 91 dc 03 	lds	r24, 0x03DC
   15eaa:	98 17       	cp	r25, r24
   15eac:	50 f6       	brcc	.-108    	; 0x15e42 <_key_string+0x210>
					_lcd(0x2a);
   15eae:	8a e2       	ldi	r24, 0x2A	; 42
   15eb0:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
					__buf_string[__chr_count] = _table_alphanum(0, __key, 0);
   15eb4:	f0 90 db 03 	lds	r15, 0x03DB
   15eb8:	0f 2d       	mov	r16, r15
   15eba:	10 e0       	ldi	r17, 0x00	; 0
   15ebc:	80 e0       	ldi	r24, 0x00	; 0
   15ebe:	6e 2d       	mov	r22, r14
   15ec0:	40 e0       	ldi	r20, 0x00	; 0
   15ec2:	0e 94 f8 ac 	call	0x159f0	; 0x159f0 <_table_alphanum>
   15ec6:	02 54       	subi	r16, 0x42	; 66
   15ec8:	11 4f       	sbci	r17, 0xF1	; 241
   15eca:	f8 01       	movw	r30, r16
   15ecc:	80 83       	st	Z, r24
					__buf_string[__chr_count + 1] = '\0';
   15ece:	11 82       	std	Z+1, r1	; 0x01
					__chr_count++;
   15ed0:	f3 94       	inc	r15
   15ed2:	f0 92 db 03 	sts	0x03DB, r15
   15ed6:	b5 cf       	rjmp	.-150    	; 0x15e42 <_key_string+0x210>
				}
			}
		}
	}
	if(__mode==_STRING_VALUE){
   15ed8:	83 30       	cpi	r24, 0x03	; 3
   15eda:	09 f0       	breq	.+2      	; 0x15ede <_key_string+0x2ac>
   15edc:	62 c0       	rjmp	.+196    	; 0x15fa2 <_key_string+0x370>
   15ede:	00 e0       	ldi	r16, 0x00	; 0
   15ee0:	04 c0       	rjmp	.+8      	; 0x15eea <_key_string+0x2b8>
		for(__i=0; __i<__max_string; __i++)
			_lcd('0');
   15ee2:	80 e3       	ldi	r24, 0x30	; 48
   15ee4:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
				}
			}
		}
	}
	if(__mode==_STRING_VALUE){
		for(__i=0; __i<__max_string; __i++)
   15ee8:	0f 5f       	subi	r16, 0xFF	; 255
   15eea:	80 91 dc 03 	lds	r24, 0x03DC
   15eee:	08 17       	cp	r16, r24
   15ef0:	c0 f3       	brcs	.-16     	; 0x15ee2 <_key_string+0x2b0>
			_lcd('0');
		while(1){
			__key = _key_scan(_PAD_SINGLE);
   15ef2:	81 e0       	ldi	r24, 0x01	; 1
   15ef4:	0e 94 45 ad 	call	0x15a8a	; 0x15a8a <_key_scan>
   15ef8:	68 2f       	mov	r22, r24
			if(__key==_KEY_NULL || __key==_KEY_TIKET || __key==_KEY_MENU || __key==_KEY_SHIFT || __key==_KEY_CLEAR);
   15efa:	88 23       	and	r24, r24
   15efc:	d1 f3       	breq	.-12     	; 0x15ef2 <_key_string+0x2c0>
   15efe:	8e 37       	cpi	r24, 0x7E	; 126
   15f00:	c1 f3       	breq	.-16     	; 0x15ef2 <_key_string+0x2c0>
   15f02:	8d 37       	cpi	r24, 0x7D	; 125
   15f04:	b1 f3       	breq	.-20     	; 0x15ef2 <_key_string+0x2c0>
   15f06:	8b 37       	cpi	r24, 0x7B	; 123
   15f08:	a1 f3       	breq	.-24     	; 0x15ef2 <_key_string+0x2c0>
   15f0a:	87 37       	cpi	r24, 0x77	; 119
   15f0c:	91 f3       	breq	.-28     	; 0x15ef2 <_key_string+0x2c0>
			else if(__key==_KEY_CANCEL){
   15f0e:	87 3e       	cpi	r24, 0xE7	; 231
   15f10:	39 f4       	brne	.+14     	; 0x15f20 <_key_string+0x2ee>
				__chr_count = 0;
   15f12:	10 92 db 03 	sts	0x03DB, r1
				CURSOR_HIDE;
   15f16:	8c e0       	ldi	r24, 0x0C	; 12
   15f18:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
   15f1c:	81 e0       	ldi	r24, 0x01	; 1
   15f1e:	42 c0       	rjmp	.+132    	; 0x15fa4 <_key_string+0x372>
				return 1;
			}
			else if(__key==_KEY_ENTER){
   15f20:	87 3b       	cpi	r24, 0xB7	; 183
   15f22:	41 f0       	breq	.+16     	; 0x15f34 <_key_string+0x302>
				__chr_count = 0;
				CURSOR_HIDE;
				return 0;
			}
			else{
				for(__i=0; __i<__max_string - 1; __i++)
   15f24:	80 91 dc 03 	lds	r24, 0x03DC
   15f28:	e8 2e       	mov	r14, r24
   15f2a:	ff 24       	eor	r15, r15
   15f2c:	e7 01       	movw	r28, r14
   15f2e:	21 97       	sbiw	r28, 0x01	; 1
   15f30:	90 e0       	ldi	r25, 0x00	; 0
   15f32:	0b c0       	rjmp	.+22     	; 0x15f4a <_key_string+0x318>
				__chr_count = 0;
				CURSOR_HIDE;
				return 1;
			}
			else if(__key==_KEY_ENTER){
				__chr_count = 0;
   15f34:	10 92 db 03 	sts	0x03DB, r1
				CURSOR_HIDE;
   15f38:	8c e0       	ldi	r24, 0x0C	; 12
   15f3a:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
   15f3e:	31 c0       	rjmp	.+98     	; 0x15fa2 <_key_string+0x370>
				return 0;
			}
			else{
				for(__i=0; __i<__max_string - 1; __i++)
					__buf_string[__i] = __buf_string[__i + 1];
   15f40:	e2 54       	subi	r30, 0x42	; 66
   15f42:	f1 4f       	sbci	r31, 0xF1	; 241
   15f44:	81 81       	ldd	r24, Z+1	; 0x01
   15f46:	80 83       	st	Z, r24
				__chr_count = 0;
				CURSOR_HIDE;
				return 0;
			}
			else{
				for(__i=0; __i<__max_string - 1; __i++)
   15f48:	9f 5f       	subi	r25, 0xFF	; 255
   15f4a:	e9 2f       	mov	r30, r25
   15f4c:	f0 e0       	ldi	r31, 0x00	; 0
   15f4e:	ec 17       	cp	r30, r28
   15f50:	fd 07       	cpc	r31, r29
   15f52:	b4 f3       	brlt	.-20     	; 0x15f40 <_key_string+0x30e>
					__buf_string[__i] = __buf_string[__i + 1];
				__buf_string[__max_string - 1] = _table_alphanum(0, __key, 0);
   15f54:	80 e0       	ldi	r24, 0x00	; 0
   15f56:	40 e0       	ldi	r20, 0x00	; 0
   15f58:	0e 94 f8 ac 	call	0x159f0	; 0x159f0 <_table_alphanum>
   15f5c:	c2 54       	subi	r28, 0x42	; 66
   15f5e:	d1 4f       	sbci	r29, 0xF1	; 241
   15f60:	88 83       	st	Y, r24
				__buf_string[__max_string] = '\0';
   15f62:	8e eb       	ldi	r24, 0xBE	; 190
   15f64:	9e e0       	ldi	r25, 0x0E	; 14
   15f66:	e8 0e       	add	r14, r24
   15f68:	f9 1e       	adc	r15, r25
   15f6a:	f7 01       	movw	r30, r14
   15f6c:	10 82       	st	Z, r1
   15f6e:	00 e0       	ldi	r16, 0x00	; 0
   15f70:	04 c0       	rjmp	.+8      	; 0x15f7a <_key_string+0x348>
				for(__i=0; __i<__max_string; __i++)
					_LCD_LEFT;
   15f72:	80 e1       	ldi	r24, 0x10	; 16
   15f74:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
			else{
				for(__i=0; __i<__max_string - 1; __i++)
					__buf_string[__i] = __buf_string[__i + 1];
				__buf_string[__max_string - 1] = _table_alphanum(0, __key, 0);
				__buf_string[__max_string] = '\0';
				for(__i=0; __i<__max_string; __i++)
   15f78:	0f 5f       	subi	r16, 0xFF	; 255
   15f7a:	80 91 dc 03 	lds	r24, 0x03DC
   15f7e:	08 17       	cp	r16, r24
   15f80:	c0 f3       	brcs	.-16     	; 0x15f72 <_key_string+0x340>
   15f82:	00 e0       	ldi	r16, 0x00	; 0
   15f84:	08 c0       	rjmp	.+16     	; 0x15f96 <_key_string+0x364>
					_LCD_LEFT;
				for(__i=0; __i<__max_string; __i++)
					_lcd(__buf_string[__i]);
   15f86:	e0 2f       	mov	r30, r16
   15f88:	f0 e0       	ldi	r31, 0x00	; 0
   15f8a:	e2 54       	subi	r30, 0x42	; 66
   15f8c:	f1 4f       	sbci	r31, 0xF1	; 241
   15f8e:	80 81       	ld	r24, Z
   15f90:	0e 94 50 ab 	call	0x156a0	; 0x156a0 <_lcd>
					__buf_string[__i] = __buf_string[__i + 1];
				__buf_string[__max_string - 1] = _table_alphanum(0, __key, 0);
				__buf_string[__max_string] = '\0';
				for(__i=0; __i<__max_string; __i++)
					_LCD_LEFT;
				for(__i=0; __i<__max_string; __i++)
   15f94:	0f 5f       	subi	r16, 0xFF	; 255
   15f96:	80 91 dc 03 	lds	r24, 0x03DC
   15f9a:	08 17       	cp	r16, r24
   15f9c:	08 f0       	brcs	.+2      	; 0x15fa0 <_key_string+0x36e>
   15f9e:	a9 cf       	rjmp	.-174    	; 0x15ef2 <_key_string+0x2c0>
   15fa0:	f2 cf       	rjmp	.-28     	; 0x15f86 <_key_string+0x354>
   15fa2:	80 e0       	ldi	r24, 0x00	; 0
					_lcd(__buf_string[__i]);
			}
		}
	}
	return 0;
}
   15fa4:	df 91       	pop	r29
   15fa6:	cf 91       	pop	r28
   15fa8:	1f 91       	pop	r17
   15faa:	0f 91       	pop	r16
   15fac:	ff 90       	pop	r15
   15fae:	ef 90       	pop	r14
   15fb0:	08 95       	ret

00015fb2 <_shift_ticker>:
		   }
	}
}

void _shift_ticker(void){
	if(_ISSHIFT){
   15fb2:	80 91 df 03 	lds	r24, 0x03DF
   15fb6:	81 30       	cpi	r24, 0x01	; 1
   15fb8:	29 f5       	brne	.+74     	; 0x16004 <_shift_ticker+0x52>
        _SHIFT_TICK;
   15fba:	80 91 e0 03 	lds	r24, 0x03E0
   15fbe:	8f 5f       	subi	r24, 0xFF	; 255
   15fc0:	80 93 e0 03 	sts	0x03E0, r24
		if((_COUNTSHIFT & (__chr_count < __max_string)))
   15fc4:	90 91 db 03 	lds	r25, 0x03DB
   15fc8:	84 31       	cpi	r24, 0x14	; 20
   15fca:	e1 f4       	brne	.+56     	; 0x16004 <_shift_ticker+0x52>
   15fcc:	80 91 dc 03 	lds	r24, 0x03DC
   15fd0:	98 17       	cp	r25, r24
   15fd2:	c0 f4       	brcc	.+48     	; 0x16004 <_shift_ticker+0x52>
			_SHIFT_RST;
   15fd4:	10 92 df 03 	sts	0x03DF, r1
   15fd8:	10 92 e0 03 	sts	0x03E0, r1
   15fdc:	10 92 d9 03 	sts	0x03D9, r1
   15fe0:	10 92 da 03 	sts	0x03DA, r1
   15fe4:	89 2f       	mov	r24, r25
   15fe6:	8f 5f       	subi	r24, 0xFF	; 255
   15fe8:	80 93 db 03 	sts	0x03DB, r24
   15fec:	84 31       	cpi	r24, 0x14	; 20
   15fee:	21 f4       	brne	.+8      	; 0x15ff8 <_shift_ticker+0x46>
   15ff0:	83 e0       	ldi	r24, 0x03	; 3
   15ff2:	61 e0       	ldi	r22, 0x01	; 1
   15ff4:	0e 94 76 ab 	call	0x156ec	; 0x156ec <lcd_xy>
   15ff8:	84 e1       	ldi	r24, 0x14	; 20
   15ffa:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
   15ffe:	8f e0       	ldi	r24, 0x0F	; 15
   16000:	0e 94 e3 aa 	call	0x155c6	; 0x155c6 <lcd_command>
   16004:	08 95       	ret

00016006 <_spi_init>:
unsigned char	__spi_i;
unsigned char	__spi_isstart = 0;
unsigned char	__spi_ismessage = 0;

void _spi_init(unsigned char __mode, unsigned char __interrupt){
	if(__mode){
   16006:	88 23       	and	r24, r24
   16008:	41 f0       	breq	.+16     	; 0x1601a <_spi_init+0x14>
		_SPI_DDR = (1 << _SPI_MOSI) | (1 << _SPI_SCK);
   1600a:	86 e0       	ldi	r24, 0x06	; 6
   1600c:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   1600e:	66 23       	and	r22, r22
   16010:	11 f0       	breq	.+4      	; 0x16016 <_spi_init+0x10>
			SPCR = (1 << SPIE) | (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   16012:	82 ed       	ldi	r24, 0xD2	; 210
   16014:	09 c0       	rjmp	.+18     	; 0x16028 <_spi_init+0x22>
		else
			SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   16016:	82 e5       	ldi	r24, 0x52	; 82
   16018:	07 c0       	rjmp	.+14     	; 0x16028 <_spi_init+0x22>
	}
	else{
		_SPI_DDR = (1 << _SPI_MISO);
   1601a:	88 e0       	ldi	r24, 0x08	; 8
   1601c:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   1601e:	66 23       	and	r22, r22
   16020:	11 f0       	breq	.+4      	; 0x16026 <_spi_init+0x20>
			SPCR = (1 << SPIE) | (1 << SPE);
   16022:	80 ec       	ldi	r24, 0xC0	; 192
   16024:	01 c0       	rjmp	.+2      	; 0x16028 <_spi_init+0x22>
		else
			SPCR = (1 << SPE);
   16026:	80 e4       	ldi	r24, 0x40	; 64
   16028:	8d b9       	out	0x0d, r24	; 13
   1602a:	08 95       	ret

0001602c <_spi_enable>:
	}
}

void _spi_enable(unsigned char __select){
	if(__select == 0){
   1602c:	88 23       	and	r24, r24
   1602e:	19 f4       	brne	.+6      	; 0x16036 <_spi_enable+0xa>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   16030:	db 9a       	sbi	0x1b, 3	; 27
		sbi(_MMC_PORT, _MMC_PIN);
   16032:	1b 9a       	sbi	0x03, 3	; 3
   16034:	08 95       	ret
	}
	if(__select == 1){
   16036:	81 30       	cpi	r24, 0x01	; 1
   16038:	39 f4       	brne	.+14     	; 0x16048 <_spi_enable+0x1c>
		sbi(_MMC_PORT, _MMC_PIN);
   1603a:	1b 9a       	sbi	0x03, 3	; 3
   1603c:	82 ee       	ldi	r24, 0xE2	; 226
   1603e:	94 e0       	ldi	r25, 0x04	; 4
   16040:	01 97       	sbiw	r24, 0x01	; 1
   16042:	f1 f7       	brne	.-4      	; 0x16040 <_spi_enable+0x14>
		_delay_ms(5);
		cbi(_SLAVE_PORT, _SLAVE_PIN);
   16044:	db 98       	cbi	0x1b, 3	; 27
   16046:	08 95       	ret
	}
	if(__select == 2){
   16048:	82 30       	cpi	r24, 0x02	; 2
   1604a:	31 f4       	brne	.+12     	; 0x16058 <_spi_enable+0x2c>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   1604c:	db 9a       	sbi	0x1b, 3	; 27
   1604e:	82 ee       	ldi	r24, 0xE2	; 226
   16050:	94 e0       	ldi	r25, 0x04	; 4
   16052:	01 97       	sbiw	r24, 0x01	; 1
   16054:	f1 f7       	brne	.-4      	; 0x16052 <_spi_enable+0x26>
		_delay_ms(5);
		cbi(_MMC_PORT, _MMC_PIN);
   16056:	1b 98       	cbi	0x03, 3	; 3
   16058:	08 95       	ret

0001605a <_spi>:
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   1605a:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1605c:	77 9b       	sbis	0x0e, 7	; 14
   1605e:	fe cf       	rjmp	.-4      	; 0x1605c <_spi+0x2>
	return SPDR;
   16060:	8f b1       	in	r24, 0x0f	; 15
}
   16062:	08 95       	ret

00016064 <_spi_rx>:


unsigned char _spi_rx(unsigned char __select){
	unsigned char __i = 0;

	_spi_enable(__select);
   16064:	0e 94 16 b0 	call	0x1602c	; 0x1602c <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16068:	81 e4       	ldi	r24, 0x41	; 65
   1606a:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1606c:	77 9b       	sbis	0x0e, 7	; 14
   1606e:	fe cf       	rjmp	.-4      	; 0x1606c <_spi_rx+0x8>
	return SPDR;
   16070:	8f b1       	in	r24, 0x0f	; 15
unsigned char _spi_rx(unsigned char __select){
	unsigned char __i = 0;

	_spi_enable(__select);

		__spi_char = _spi(0x41);
   16072:	80 93 d3 0e 	sts	0x0ED3, r24
		if(__spi_char==0xff) return 0;
   16076:	8f 3f       	cpi	r24, 0xFF	; 255
   16078:	11 f4       	brne	.+4      	; 0x1607e <_spi_rx+0x1a>
   1607a:	80 e0       	ldi	r24, 0x00	; 0
   1607c:	08 95       	ret
		if(__spi_char==0x55) return 1;
   1607e:	85 35       	cpi	r24, 0x55	; 85
   16080:	11 f4       	brne	.+4      	; 0x16086 <_spi_rx+0x22>
   16082:	81 e0       	ldi	r24, 0x01	; 1
   16084:	08 95       	ret
		if(__spi_char==0x02) return 2;
   16086:	82 30       	cpi	r24, 0x02	; 2
   16088:	21 f0       	breq	.+8      	; 0x16092 <_spi_rx+0x2e>
	_spi_enable(_SPI_NONE);
   1608a:	80 e0       	ldi	r24, 0x00	; 0
   1608c:	0e 94 16 b0 	call	0x1602c	; 0x1602c <_spi_enable>
   16090:	85 e1       	ldi	r24, 0x15	; 21
	return 21;
}
   16092:	08 95       	ret

00016094 <_spi_tx>:

unsigned char _spi_tx(unsigned char __command, unsigned char __select, char* __message){
   16094:	1f 93       	push	r17
   16096:	cf 93       	push	r28
   16098:	df 93       	push	r29
   1609a:	18 2f       	mov	r17, r24
   1609c:	86 2f       	mov	r24, r22
   1609e:	ea 01       	movw	r28, r20
	_spi_enable(__select);
   160a0:	0e 94 16 b0 	call	0x1602c	; 0x1602c <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   160a4:	8b e7       	ldi	r24, 0x7B	; 123
   160a6:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   160a8:	77 9b       	sbis	0x0e, 7	; 14
   160aa:	fe cf       	rjmp	.-4      	; 0x160a8 <_spi_tx+0x14>
	return SPDR;
   160ac:	8f b1       	in	r24, 0x0f	; 15
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   160ae:	1f b9       	out	0x0f, r17	; 15
	while(!(SPSR & (1 << SPIF)));
   160b0:	77 9b       	sbis	0x0e, 7	; 14
   160b2:	fe cf       	rjmp	.-4      	; 0x160b0 <_spi_tx+0x1c>
	return SPDR;
   160b4:	8f b1       	in	r24, 0x0f	; 15
unsigned char _spi_tx(unsigned char __command, unsigned char __select, char* __message){
	_spi_enable(__select);
	_spi(0x7B);
	_spi(__command);

	if(strlen(__message) > 0){
   160b6:	88 81       	ld	r24, Y
   160b8:	88 23       	and	r24, r24
   160ba:	91 f0       	breq	.+36     	; 0x160e0 <_spi_tx+0x4c>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   160bc:	88 e2       	ldi	r24, 0x28	; 40
   160be:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   160c0:	77 9b       	sbis	0x0e, 7	; 14
   160c2:	fe cf       	rjmp	.-4      	; 0x160c0 <_spi_tx+0x2c>
   160c4:	04 c0       	rjmp	.+8      	; 0x160ce <_spi_tx+0x3a>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   160c6:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   160c8:	77 9b       	sbis	0x0e, 7	; 14
   160ca:	fe cf       	rjmp	.-4      	; 0x160c8 <_spi_tx+0x34>
	_spi(__command);

	if(strlen(__message) > 0){
		_spi(0x28);
		while(*__message)
			_spi(*__message++);
   160cc:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
	while(!(SPSR & (1 << SPIF)));
	return SPDR;
   160ce:	8f b1       	in	r24, 0x0f	; 15
	_spi(0x7B);
	_spi(__command);

	if(strlen(__message) > 0){
		_spi(0x28);
		while(*__message)
   160d0:	88 81       	ld	r24, Y
   160d2:	88 23       	and	r24, r24
   160d4:	c1 f7       	brne	.-16     	; 0x160c6 <_spi_tx+0x32>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   160d6:	89 e2       	ldi	r24, 0x29	; 41
   160d8:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   160da:	77 9b       	sbis	0x0e, 7	; 14
   160dc:	fe cf       	rjmp	.-4      	; 0x160da <_spi_tx+0x46>
	return SPDR;
   160de:	8f b1       	in	r24, 0x0f	; 15
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   160e0:	8d e7       	ldi	r24, 0x7D	; 125
   160e2:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   160e4:	77 9b       	sbis	0x0e, 7	; 14
   160e6:	fe cf       	rjmp	.-4      	; 0x160e4 <_spi_tx+0x50>
	return SPDR;
   160e8:	8f b1       	in	r24, 0x0f	; 15
			_spi(*__message++);
		_spi(0x29);
	}

	_spi(0x7D);
	_spi_enable(_SPI_NONE);
   160ea:	80 e0       	ldi	r24, 0x00	; 0
   160ec:	0e 94 16 b0 	call	0x1602c	; 0x1602c <_spi_enable>
	return 0;
}
   160f0:	80 e0       	ldi	r24, 0x00	; 0
   160f2:	df 91       	pop	r29
   160f4:	cf 91       	pop	r28
   160f6:	1f 91       	pop	r17
   160f8:	08 95       	ret

000160fa <_spi_txnum>:

unsigned char _spi_txnum(unsigned char __command, unsigned char __select, char* __message, unsigned char __num){
   160fa:	ff 92       	push	r15
   160fc:	0f 93       	push	r16
   160fe:	1f 93       	push	r17
   16100:	86 2f       	mov	r24, r22
   16102:	14 2f       	mov	r17, r20
   16104:	05 2f       	mov	r16, r21
   16106:	f2 2e       	mov	r15, r18
	unsigned char	__i;

	_spi_enable(__select);
   16108:	0e 94 16 b0 	call	0x1602c	; 0x1602c <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   1610c:	82 e0       	ldi	r24, 0x02	; 2
   1610e:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16110:	77 9b       	sbis	0x0e, 7	; 14
   16112:	fe cf       	rjmp	.-4      	; 0x16110 <_spi_txnum+0x16>
	return SPDR;
   16114:	8f b1       	in	r24, 0x0f	; 15
	unsigned char	__i;

	_spi_enable(__select);
	_spi(0x02);

	if(__num > 0){
   16116:	ff 20       	and	r15, r15
   16118:	79 f0       	breq	.+30     	; 0x16138 <_spi_txnum+0x3e>
   1611a:	81 2f       	mov	r24, r17
   1611c:	90 2f       	mov	r25, r16
   1611e:	9c 01       	movw	r18, r24
   16120:	f9 01       	movw	r30, r18
   16122:	90 e0       	ldi	r25, 0x00	; 0
   16124:	07 c0       	rjmp	.+14     	; 0x16134 <_spi_txnum+0x3a>
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
   16126:	80 81       	ld	r24, Z
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16128:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1612a:	77 9b       	sbis	0x0e, 7	; 14
   1612c:	fe cf       	rjmp	.-4      	; 0x1612a <_spi_txnum+0x30>
	return SPDR;
   1612e:	8f b1       	in	r24, 0x0f	; 15

	_spi_enable(__select);
	_spi(0x02);

	if(__num > 0){
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
   16130:	9f 5f       	subi	r25, 0xFF	; 255
   16132:	31 96       	adiw	r30, 0x01	; 1
   16134:	9f 15       	cp	r25, r15
   16136:	b8 f3       	brcs	.-18     	; 0x16126 <_spi_txnum+0x2c>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16138:	83 e0       	ldi	r24, 0x03	; 3
   1613a:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1613c:	77 9b       	sbis	0x0e, 7	; 14
   1613e:	fe cf       	rjmp	.-4      	; 0x1613c <_spi_txnum+0x42>
	return SPDR;
   16140:	8f b1       	in	r24, 0x0f	; 15
	if(__num > 0){
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
				}// for

	_spi(0x03);
	_spi_enable(_SPI_NONE);
   16142:	80 e0       	ldi	r24, 0x00	; 0
   16144:	0e 94 16 b0 	call	0x1602c	; 0x1602c <_spi_enable>
	return 0;
}
   16148:	80 e0       	ldi	r24, 0x00	; 0
   1614a:	1f 91       	pop	r17
   1614c:	0f 91       	pop	r16
   1614e:	ff 90       	pop	r15
   16150:	08 95       	ret

00016152 <_spi_interrupt>:

unsigned char _spi_interrupt(void){
	__spi_char = SPDR;
   16152:	9f b1       	in	r25, 0x0f	; 15
   16154:	90 93 d3 0e 	sts	0x0ED3, r25

	if(__spi_char == 0xFF){
   16158:	9f 3f       	cpi	r25, 0xFF	; 255
   1615a:	e9 f4       	brne	.+58     	; 0x16196 <_spi_interrupt+0x44>
		if(__spi_istransmit){
   1615c:	80 91 21 04 	lds	r24, 0x0421
   16160:	88 23       	and	r24, r24
   16162:	b9 f0       	breq	.+46     	; 0x16192 <_spi_interrupt+0x40>
			SPDR = __command[__spi_i];
   16164:	90 91 d2 0e 	lds	r25, 0x0ED2
   16168:	e9 2f       	mov	r30, r25
   1616a:	f0 e0       	ldi	r31, 0x00	; 0
   1616c:	e1 51       	subi	r30, 0x11	; 17
   1616e:	fc 4f       	sbci	r31, 0xFC	; 252
   16170:	80 81       	ld	r24, Z
   16172:	8f b9       	out	0x0f, r24	; 15
			if(__command[__spi_i] == 0x7D){
   16174:	8d 37       	cpi	r24, 0x7D	; 125
   16176:	19 f4       	brne	.+6      	; 0x1617e <_spi_interrupt+0x2c>
				__spi_i = 0;
   16178:	10 92 d2 0e 	sts	0x0ED2, r1
   1617c:	07 c0       	rjmp	.+14     	; 0x1618c <_spi_interrupt+0x3a>
				__spi_istransmit = 0;
			}
			else{
				__spi_i++;
   1617e:	89 2f       	mov	r24, r25
   16180:	8f 5f       	subi	r24, 0xFF	; 255
   16182:	80 93 d2 0e 	sts	0x0ED2, r24
				if(__spi_i == _MAX_COMMAND)
   16186:	82 33       	cpi	r24, 0x32	; 50
   16188:	09 f0       	breq	.+2      	; 0x1618c <_spi_interrupt+0x3a>
   1618a:	3f c0       	rjmp	.+126    	; 0x1620a <_spi_interrupt+0xb8>
					__spi_istransmit = 0;
   1618c:	10 92 21 04 	sts	0x0421, r1
   16190:	3c c0       	rjmp	.+120    	; 0x1620a <_spi_interrupt+0xb8>
			}
		}
		else
			SPDR = 0xFF;
   16192:	9f b9       	out	0x0f, r25	; 15
   16194:	3a c0       	rjmp	.+116    	; 0x1620a <_spi_interrupt+0xb8>
	}
	else{
		if(__spi_char == 0x7D && __spi_isstart){
   16196:	9d 37       	cpi	r25, 0x7D	; 125
   16198:	69 f4       	brne	.+26     	; 0x161b4 <_spi_interrupt+0x62>
   1619a:	80 91 ea 03 	lds	r24, 0x03EA
   1619e:	88 23       	and	r24, r24
   161a0:	49 f0       	breq	.+18     	; 0x161b4 <_spi_interrupt+0x62>
			__spi_isstart = 0;
   161a2:	10 92 ea 03 	sts	0x03EA, r1
			__spi_ismessage = 0;
   161a6:	10 92 eb 03 	sts	0x03EB, r1
			__spi_i = 0;
   161aa:	10 92 d2 0e 	sts	0x0ED2, r1
			__command_flag = 1;
   161ae:	81 e0       	ldi	r24, 0x01	; 1
   161b0:	80 93 24 04 	sts	0x0424, r24
		}
		if(__spi_isstart && __spi_ismessage){
   161b4:	20 91 ea 03 	lds	r18, 0x03EA
   161b8:	22 23       	and	r18, r18
   161ba:	f1 f0       	breq	.+60     	; 0x161f8 <_spi_interrupt+0xa6>
   161bc:	80 91 eb 03 	lds	r24, 0x03EB
   161c0:	88 23       	and	r24, r24
   161c2:	29 f1       	breq	.+74     	; 0x1620e <_spi_interrupt+0xbc>
			if(__spi_char != 0x29){
   161c4:	99 32       	cpi	r25, 0x29	; 41
   161c6:	c1 f0       	breq	.+48     	; 0x161f8 <_spi_interrupt+0xa6>
				__package[__spi_i] = __spi_char;
   161c8:	80 91 d2 0e 	lds	r24, 0x0ED2
   161cc:	e8 2f       	mov	r30, r24
   161ce:	f0 e0       	ldi	r31, 0x00	; 0
   161d0:	e6 5d       	subi	r30, 0xD6	; 214
   161d2:	fb 4f       	sbci	r31, 0xFB	; 251
   161d4:	90 83       	st	Z, r25
				__package[__spi_i + 1] = '\0';
   161d6:	11 82       	std	Z+1, r1	; 0x01
				__spi_i++;
   161d8:	8f 5f       	subi	r24, 0xFF	; 255
   161da:	80 93 d2 0e 	sts	0x0ED2, r24
				if(__spi_i == _MAX_PACKAGE)
   161de:	82 38       	cpi	r24, 0x82	; 130
   161e0:	59 f4       	brne	.+22     	; 0x161f8 <_spi_interrupt+0xa6>
					__spi_i = 0;
   161e2:	10 92 d2 0e 	sts	0x0ED2, r1
   161e6:	08 c0       	rjmp	.+16     	; 0x161f8 <_spi_interrupt+0xa6>
			}
		}
		if(__spi_isstart && !__spi_ismessage){
			if(__spi_char == 0x28){
				__spi_ismessage = 1;
   161e8:	81 e0       	ldi	r24, 0x01	; 1
   161ea:	80 93 eb 03 	sts	0x03EB, r24
				__spi_i = 0;
   161ee:	10 92 d2 0e 	sts	0x0ED2, r1
   161f2:	0b c0       	rjmp	.+22     	; 0x1620a <_spi_interrupt+0xb8>
			}
			else
				__command_set = __spi_char;
   161f4:	90 93 26 04 	sts	0x0426, r25
		}
		if(__spi_char == 0x7B && !__spi_isstart){
   161f8:	9b 37       	cpi	r25, 0x7B	; 123
   161fa:	39 f4       	brne	.+14     	; 0x1620a <_spi_interrupt+0xb8>
   161fc:	22 23       	and	r18, r18
   161fe:	29 f4       	brne	.+10     	; 0x1620a <_spi_interrupt+0xb8>
			__spi_isstart = 1;
   16200:	81 e0       	ldi	r24, 0x01	; 1
   16202:	80 93 ea 03 	sts	0x03EA, r24
			__spi_ismessage = 0;
   16206:	10 92 eb 03 	sts	0x03EB, r1
		}
	}

	return 0;
}
   1620a:	80 e0       	ldi	r24, 0x00	; 0
   1620c:	08 95       	ret
				if(__spi_i == _MAX_PACKAGE)
					__spi_i = 0;
			}
		}
		if(__spi_isstart && !__spi_ismessage){
			if(__spi_char == 0x28){
   1620e:	98 32       	cpi	r25, 0x28	; 40
   16210:	89 f7       	brne	.-30     	; 0x161f4 <_spi_interrupt+0xa2>
   16212:	ea cf       	rjmp	.-44     	; 0x161e8 <_spi_interrupt+0x96>

00016214 <_spi_command>:
	}

	return 0;
}

void _spi_command(unsigned char __cmd, char* __cell){
   16214:	fb 01       	movw	r30, r22
	unsigned char __i = 0;

	__command[__i++] = 0x7B;
   16216:	9b e7       	ldi	r25, 0x7B	; 123
   16218:	90 93 ef 03 	sts	0x03EF, r25
	__command[__i++] = __cmd;
   1621c:	80 93 f0 03 	sts	0x03F0, r24

	if(strlen(__cell) > 0){
   16220:	80 81       	ld	r24, Z
   16222:	88 23       	and	r24, r24
   16224:	11 f4       	brne	.+4      	; 0x1622a <_spi_command+0x16>
   16226:	92 e0       	ldi	r25, 0x02	; 2
   16228:	16 c0       	rjmp	.+44     	; 0x16256 <_spi_command+0x42>
		__command[__i++] = 0x28;
   1622a:	88 e2       	ldi	r24, 0x28	; 40
   1622c:	80 93 f1 03 	sts	0x03F1, r24
   16230:	83 e0       	ldi	r24, 0x03	; 3
   16232:	05 c0       	rjmp	.+10     	; 0x1623e <_spi_command+0x2a>

		while(*__cell)
			__command[__i++] = *__cell++;
   16234:	a1 51       	subi	r26, 0x11	; 17
   16236:	bc 4f       	sbci	r27, 0xFC	; 252
   16238:	9c 93       	st	X, r25
   1623a:	82 2f       	mov	r24, r18
   1623c:	31 96       	adiw	r30, 0x01	; 1
	__command[__i++] = __cmd;

	if(strlen(__cell) > 0){
		__command[__i++] = 0x28;

		while(*__cell)
   1623e:	90 81       	ld	r25, Z
   16240:	a8 2f       	mov	r26, r24
   16242:	b0 e0       	ldi	r27, 0x00	; 0
   16244:	28 2f       	mov	r18, r24
   16246:	2f 5f       	subi	r18, 0xFF	; 255
   16248:	99 23       	and	r25, r25
   1624a:	a1 f7       	brne	.-24     	; 0x16234 <_spi_command+0x20>
			__command[__i++] = *__cell++;

		__command[__i++] = 0x29;
   1624c:	a1 51       	subi	r26, 0x11	; 17
   1624e:	bc 4f       	sbci	r27, 0xFC	; 252
   16250:	89 e2       	ldi	r24, 0x29	; 41
   16252:	8c 93       	st	X, r24
   16254:	92 2f       	mov	r25, r18
	}

	__command[__i++] = 0x7D;
   16256:	e9 2f       	mov	r30, r25
   16258:	f0 e0       	ldi	r31, 0x00	; 0
   1625a:	e1 51       	subi	r30, 0x11	; 17
   1625c:	fc 4f       	sbci	r31, 0xFC	; 252
   1625e:	8d e7       	ldi	r24, 0x7D	; 125
   16260:	80 83       	st	Z, r24
	__command[__i++] = '\0';
   16262:	9f 5f       	subi	r25, 0xFF	; 255
   16264:	e9 2f       	mov	r30, r25
   16266:	f0 e0       	ldi	r31, 0x00	; 0
   16268:	e1 51       	subi	r30, 0x11	; 17
   1626a:	fc 4f       	sbci	r31, 0xFC	; 252
   1626c:	10 82       	st	Z, r1
}
   1626e:	08 95       	ret

00016270 <_rtc>:

#include <compat/twi.h>

#include "RTC.h"

unsigned char _rtc(int __addr, int __len, char* __datetime, unsigned char __dir){
   16270:	98 2f       	mov	r25, r24
	int				__twcr;
	unsigned char	__i = 0;
	
	if(__dir){
   16272:	22 23       	and	r18, r18
   16274:	09 f4       	brne	.+2      	; 0x16278 <_rtc+0x8>
   16276:	49 c0       	rjmp	.+146    	; 0x1630a <_rtc+0x9a>
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   16278:	84 ea       	ldi	r24, 0xA4	; 164
   1627a:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1627e:	80 91 74 00 	lds	r24, 0x0074
   16282:	87 ff       	sbrs	r24, 7
   16284:	fc cf       	rjmp	.-8      	; 0x1627e <_rtc+0xe>
		if(TW_STATUS != TW_START)
   16286:	80 91 71 00 	lds	r24, 0x0071
   1628a:	88 7f       	andi	r24, 0xF8	; 248
   1628c:	88 30       	cpi	r24, 0x08	; 8
   1628e:	09 f0       	breq	.+2      	; 0x16292 <_rtc+0x22>
   16290:	af c0       	rjmp	.+350    	; 0x163f0 <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   16292:	80 ed       	ldi	r24, 0xD0	; 208
   16294:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   16298:	84 e8       	ldi	r24, 0x84	; 132
   1629a:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1629e:	80 91 74 00 	lds	r24, 0x0074
   162a2:	87 ff       	sbrs	r24, 7
   162a4:	fc cf       	rjmp	.-8      	; 0x1629e <_rtc+0x2e>
		if(TW_STATUS != TW_MT_SLA_ACK)
   162a6:	80 91 71 00 	lds	r24, 0x0071
   162aa:	88 7f       	andi	r24, 0xF8	; 248
   162ac:	88 31       	cpi	r24, 0x18	; 24
   162ae:	09 f0       	breq	.+2      	; 0x162b2 <_rtc+0x42>
   162b0:	9f c0       	rjmp	.+318    	; 0x163f0 <_rtc+0x180>
			return 1;

		TWDR = __addr;
   162b2:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   162b6:	84 e8       	ldi	r24, 0x84	; 132
   162b8:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   162bc:	80 91 74 00 	lds	r24, 0x0074
   162c0:	87 ff       	sbrs	r24, 7
   162c2:	fc cf       	rjmp	.-8      	; 0x162bc <_rtc+0x4c>
		if(TW_STATUS != TW_MT_DATA_ACK)
   162c4:	80 91 71 00 	lds	r24, 0x0071
   162c8:	88 7f       	andi	r24, 0xF8	; 248
   162ca:	88 32       	cpi	r24, 0x28	; 40
   162cc:	09 f0       	breq	.+2      	; 0x162d0 <_rtc+0x60>
   162ce:	90 c0       	rjmp	.+288    	; 0x163f0 <_rtc+0x180>
   162d0:	9b 01       	movw	r18, r22
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
			TWCR = _BV(TWINT) | _BV(TWEN);
   162d2:	94 e8       	ldi	r25, 0x84	; 132
   162d4:	14 c0       	rjmp	.+40     	; 0x162fe <_rtc+0x8e>
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
   162d6:	fa 01       	movw	r30, r20
   162d8:	e8 0f       	add	r30, r24
   162da:	f1 1d       	adc	r31, r1
   162dc:	80 81       	ld	r24, Z
   162de:	80 93 73 00 	sts	0x0073, r24
			TWCR = _BV(TWINT) | _BV(TWEN);
   162e2:	90 93 74 00 	sts	0x0074, r25
			_rtc_response;
   162e6:	80 91 74 00 	lds	r24, 0x0074
   162ea:	87 ff       	sbrs	r24, 7
   162ec:	fc cf       	rjmp	.-8      	; 0x162e6 <_rtc+0x76>
			if(TW_STATUS == TW_MT_DATA_NACK)
   162ee:	80 91 71 00 	lds	r24, 0x0071
   162f2:	88 7f       	andi	r24, 0xF8	; 248
   162f4:	80 33       	cpi	r24, 0x30	; 48
   162f6:	09 f4       	brne	.+2      	; 0x162fa <_rtc+0x8a>
   162f8:	7b c0       	rjmp	.+246    	; 0x163f0 <_rtc+0x180>
		TWCR = _BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
   162fa:	21 50       	subi	r18, 0x01	; 1
   162fc:	30 40       	sbci	r19, 0x00	; 0
   162fe:	86 2f       	mov	r24, r22
   16300:	82 1b       	sub	r24, r18
   16302:	12 16       	cp	r1, r18
   16304:	13 06       	cpc	r1, r19
   16306:	3c f3       	brlt	.-50     	; 0x162d6 <_rtc+0x66>
   16308:	6e c0       	rjmp	.+220    	; 0x163e6 <_rtc+0x176>
		}

		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
	}
	else{
		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   1630a:	84 ea       	ldi	r24, 0xA4	; 164
   1630c:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16310:	80 91 74 00 	lds	r24, 0x0074
   16314:	87 ff       	sbrs	r24, 7
   16316:	fc cf       	rjmp	.-8      	; 0x16310 <_rtc+0xa0>
		if(TW_STATUS != TW_START)
   16318:	80 91 71 00 	lds	r24, 0x0071
   1631c:	88 7f       	andi	r24, 0xF8	; 248
   1631e:	88 30       	cpi	r24, 0x08	; 8
   16320:	09 f0       	breq	.+2      	; 0x16324 <_rtc+0xb4>
   16322:	66 c0       	rjmp	.+204    	; 0x163f0 <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   16324:	80 ed       	ldi	r24, 0xD0	; 208
   16326:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   1632a:	84 e8       	ldi	r24, 0x84	; 132
   1632c:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16330:	80 91 74 00 	lds	r24, 0x0074
   16334:	87 ff       	sbrs	r24, 7
   16336:	fc cf       	rjmp	.-8      	; 0x16330 <_rtc+0xc0>
		if(TW_STATUS != TW_MT_SLA_ACK)
   16338:	80 91 71 00 	lds	r24, 0x0071
   1633c:	88 7f       	andi	r24, 0xF8	; 248
   1633e:	88 31       	cpi	r24, 0x18	; 24
   16340:	09 f0       	breq	.+2      	; 0x16344 <_rtc+0xd4>
   16342:	56 c0       	rjmp	.+172    	; 0x163f0 <_rtc+0x180>
			return 1;

		TWDR = __addr;
   16344:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   16348:	84 e8       	ldi	r24, 0x84	; 132
   1634a:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1634e:	80 91 74 00 	lds	r24, 0x0074
   16352:	87 ff       	sbrs	r24, 7
   16354:	fc cf       	rjmp	.-8      	; 0x1634e <_rtc+0xde>
		if(TW_STATUS != TW_MT_DATA_ACK)
   16356:	80 91 71 00 	lds	r24, 0x0071
   1635a:	88 7f       	andi	r24, 0xF8	; 248
   1635c:	88 32       	cpi	r24, 0x28	; 40
   1635e:	09 f0       	breq	.+2      	; 0x16362 <_rtc+0xf2>
   16360:	47 c0       	rjmp	.+142    	; 0x163f0 <_rtc+0x180>
			return 1;

		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   16362:	84 ea       	ldi	r24, 0xA4	; 164
   16364:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16368:	80 91 74 00 	lds	r24, 0x0074
   1636c:	87 ff       	sbrs	r24, 7
   1636e:	fc cf       	rjmp	.-8      	; 0x16368 <_rtc+0xf8>
		if(TW_STATUS != TW_REP_START)
   16370:	80 91 71 00 	lds	r24, 0x0071
   16374:	88 7f       	andi	r24, 0xF8	; 248
   16376:	80 31       	cpi	r24, 0x10	; 16
   16378:	d9 f5       	brne	.+118    	; 0x163f0 <_rtc+0x180>
			return 1;

		TWDR = _DS1307R;
   1637a:	81 ed       	ldi	r24, 0xD1	; 209
   1637c:	80 93 73 00 	sts	0x0073, r24
		TWCR =_BV(TWINT) | _BV(TWEN);
   16380:	84 e8       	ldi	r24, 0x84	; 132
   16382:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16386:	80 91 74 00 	lds	r24, 0x0074
   1638a:	87 ff       	sbrs	r24, 7
   1638c:	fc cf       	rjmp	.-8      	; 0x16386 <_rtc+0x116>
		if(TW_STATUS != TW_MR_SLA_ACK)
   1638e:	80 91 71 00 	lds	r24, 0x0071
   16392:	88 7f       	andi	r24, 0xF8	; 248
   16394:	80 34       	cpi	r24, 0x40	; 64
   16396:	61 f5       	brne	.+88     	; 0x163f0 <_rtc+0x180>
   16398:	24 ec       	ldi	r18, 0xC4	; 196
   1639a:	30 e0       	ldi	r19, 0x00	; 0
   1639c:	90 e0       	ldi	r25, 0x00	; 0
   1639e:	20 c0       	rjmp	.+64     	; 0x163e0 <_rtc+0x170>
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
			if(__len == 1)
   163a0:	61 30       	cpi	r22, 0x01	; 1
   163a2:	71 05       	cpc	r23, r1
   163a4:	11 f4       	brne	.+4      	; 0x163aa <_rtc+0x13a>
   163a6:	24 e8       	ldi	r18, 0x84	; 132
   163a8:	30 e0       	ldi	r19, 0x00	; 0
				__twcr = _BV(TWINT) | _BV(TWEN);
			TWCR = __twcr;
   163aa:	20 93 74 00 	sts	0x0074, r18
			_rtc_response;
   163ae:	80 91 74 00 	lds	r24, 0x0074
   163b2:	87 ff       	sbrs	r24, 7
   163b4:	fc cf       	rjmp	.-8      	; 0x163ae <_rtc+0x13e>
			if(TW_STATUS == TW_MR_DATA_NACK)
   163b6:	80 91 71 00 	lds	r24, 0x0071
   163ba:	88 7f       	andi	r24, 0xF8	; 248
   163bc:	88 35       	cpi	r24, 0x58	; 88
   163be:	11 f4       	brne	.+4      	; 0x163c4 <_rtc+0x154>
   163c0:	60 e0       	ldi	r22, 0x00	; 0
   163c2:	70 e0       	ldi	r23, 0x00	; 0
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
   163c4:	80 91 71 00 	lds	r24, 0x0071
   163c8:	88 7f       	andi	r24, 0xF8	; 248
   163ca:	80 35       	cpi	r24, 0x50	; 80
   163cc:	39 f4       	brne	.+14     	; 0x163dc <_rtc+0x16c>
				__datetime[__i++] = TWDR;
   163ce:	80 91 73 00 	lds	r24, 0x0073
   163d2:	fa 01       	movw	r30, r20
   163d4:	e9 0f       	add	r30, r25
   163d6:	f1 1d       	adc	r31, r1
   163d8:	80 83       	st	Z, r24
   163da:	9f 5f       	subi	r25, 0xFF	; 255
		TWCR =_BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MR_SLA_ACK)
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
   163dc:	61 50       	subi	r22, 0x01	; 1
   163de:	70 40       	sbci	r23, 0x00	; 0
   163e0:	16 16       	cp	r1, r22
   163e2:	17 06       	cpc	r1, r23
   163e4:	ec f2       	brlt	.-70     	; 0x163a0 <_rtc+0x130>
			if(TW_STATUS == TW_MR_DATA_NACK)
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
				__datetime[__i++] = TWDR;
		}
		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
   163e6:	84 e9       	ldi	r24, 0x94	; 148
   163e8:	80 93 74 00 	sts	0x0074, r24
   163ec:	80 e0       	ldi	r24, 0x00	; 0
   163ee:	08 95       	ret
   163f0:	81 e0       	ldi	r24, 0x01	; 1
	}

    return 0;
}
   163f2:	08 95       	ret

000163f4 <_datetime>:

void _datetime(unsigned char __mode, char* __date, char* __time){
   163f4:	ef 92       	push	r14
   163f6:	ff 92       	push	r15
   163f8:	0f 93       	push	r16
   163fa:	1f 93       	push	r17
   163fc:	df 93       	push	r29
   163fe:	cf 93       	push	r28
   16400:	cd b7       	in	r28, 0x3d	; 61
   16402:	de b7       	in	r29, 0x3e	; 62
   16404:	64 97       	sbiw	r28, 0x14	; 20
   16406:	0f b6       	in	r0, 0x3f	; 63
   16408:	f8 94       	cli
   1640a:	de bf       	out	0x3e, r29	; 62
   1640c:	0f be       	out	0x3f, r0	; 63
   1640e:	cd bf       	out	0x3d, r28	; 61
   16410:	28 2f       	mov	r18, r24
   16412:	8b 01       	movw	r16, r22
   16414:	7a 01       	movw	r14, r20
   16416:	ae 01       	movw	r20, r28
   16418:	4f 5f       	subi	r20, 0xFF	; 255
   1641a:	5f 4f       	sbci	r21, 0xFF	; 255
	char	__datetime[20];

	if(__mode){
   1641c:	88 23       	and	r24, r24
   1641e:	99 f1       	breq	.+102    	; 0x16486 <_datetime+0x92>
		__datetime[4] = (((__date[0] - 0x30) & 0x0F) << 4) + ((__date[1] - 0x30) & 0x0F);
   16420:	fb 01       	movw	r30, r22
   16422:	90 81       	ld	r25, Z
   16424:	92 95       	swap	r25
   16426:	90 7f       	andi	r25, 0xF0	; 240
   16428:	81 81       	ldd	r24, Z+1	; 0x01
   1642a:	8f 70       	andi	r24, 0x0F	; 15
   1642c:	98 0f       	add	r25, r24
   1642e:	9d 83       	std	Y+5, r25	; 0x05
		__datetime[5] = (((__date[3] - 0x30) & 0x0F) << 4) + ((__date[4] - 0x30) & 0x0F);
   16430:	93 81       	ldd	r25, Z+3	; 0x03
   16432:	92 95       	swap	r25
   16434:	90 7f       	andi	r25, 0xF0	; 240
   16436:	84 81       	ldd	r24, Z+4	; 0x04
   16438:	8f 70       	andi	r24, 0x0F	; 15
   1643a:	98 0f       	add	r25, r24
   1643c:	9e 83       	std	Y+6, r25	; 0x06
		__datetime[6] = (((__date[6] - 0x30) & 0x0F) << 4) + ((__date[7] - 0x30) & 0x0F);
   1643e:	96 81       	ldd	r25, Z+6	; 0x06
   16440:	92 95       	swap	r25
   16442:	90 7f       	andi	r25, 0xF0	; 240
   16444:	87 81       	ldd	r24, Z+7	; 0x07
   16446:	8f 70       	andi	r24, 0x0F	; 15
   16448:	98 0f       	add	r25, r24
   1644a:	9f 83       	std	Y+7, r25	; 0x07

		__datetime[2] = (((__time[0] - 0x30) & 0x0F) << 4) + ((__time[1] - 0x30) & 0x0F);
   1644c:	f7 01       	movw	r30, r14
   1644e:	90 81       	ld	r25, Z
   16450:	92 95       	swap	r25
   16452:	90 7f       	andi	r25, 0xF0	; 240
   16454:	81 81       	ldd	r24, Z+1	; 0x01
   16456:	8f 70       	andi	r24, 0x0F	; 15
   16458:	98 0f       	add	r25, r24
   1645a:	9b 83       	std	Y+3, r25	; 0x03
		__datetime[1] = (((__time[3] - 0x30) & 0x0F) << 4) + ((__time[4] - 0x30) & 0x0F);
   1645c:	93 81       	ldd	r25, Z+3	; 0x03
   1645e:	92 95       	swap	r25
   16460:	90 7f       	andi	r25, 0xF0	; 240
   16462:	84 81       	ldd	r24, Z+4	; 0x04
   16464:	8f 70       	andi	r24, 0x0F	; 15
   16466:	98 0f       	add	r25, r24
   16468:	9a 83       	std	Y+2, r25	; 0x02
		__datetime[0] = (((__time[6] - 0x30) & 0x0F) << 4) + ((__time[7] - 0x30) & 0x0F);
   1646a:	96 81       	ldd	r25, Z+6	; 0x06
   1646c:	92 95       	swap	r25
   1646e:	90 7f       	andi	r25, 0xF0	; 240
   16470:	87 81       	ldd	r24, Z+7	; 0x07
   16472:	8f 70       	andi	r24, 0x0F	; 15
   16474:	98 0f       	add	r25, r24
   16476:	99 83       	std	Y+1, r25	; 0x01
		_rtc(0, 8, __datetime, __mode);
   16478:	80 e0       	ldi	r24, 0x00	; 0
   1647a:	90 e0       	ldi	r25, 0x00	; 0
   1647c:	68 e0       	ldi	r22, 0x08	; 8
   1647e:	70 e0       	ldi	r23, 0x00	; 0
   16480:	0e 94 38 b1 	call	0x16270	; 0x16270 <_rtc>
   16484:	4a c0       	rjmp	.+148    	; 0x1651a <_datetime+0x126>
	}
	else
		if(_rtc(0, 8, __datetime, __mode) != 1){
   16486:	80 e0       	ldi	r24, 0x00	; 0
   16488:	90 e0       	ldi	r25, 0x00	; 0
   1648a:	68 e0       	ldi	r22, 0x08	; 8
   1648c:	70 e0       	ldi	r23, 0x00	; 0
   1648e:	20 e0       	ldi	r18, 0x00	; 0
   16490:	0e 94 38 b1 	call	0x16270	; 0x16270 <_rtc>
   16494:	81 30       	cpi	r24, 0x01	; 1
   16496:	09 f4       	brne	.+2      	; 0x1649a <_datetime+0xa6>
   16498:	40 c0       	rjmp	.+128    	; 0x1651a <_datetime+0x126>
			__date[0] = (__datetime[4] >> 4) + 0x30;
   1649a:	9d 81       	ldd	r25, Y+5	; 0x05
   1649c:	89 2f       	mov	r24, r25
   1649e:	82 95       	swap	r24
   164a0:	8f 70       	andi	r24, 0x0F	; 15
   164a2:	80 5d       	subi	r24, 0xD0	; 208
   164a4:	f8 01       	movw	r30, r16
   164a6:	80 83       	st	Z, r24
			__date[1] = (__datetime[4] & 0x0F) + 0x30;
   164a8:	9f 70       	andi	r25, 0x0F	; 15
   164aa:	90 5d       	subi	r25, 0xD0	; 208
   164ac:	91 83       	std	Z+1, r25	; 0x01
			__date[2] = '/';
   164ae:	2f e2       	ldi	r18, 0x2F	; 47
   164b0:	22 83       	std	Z+2, r18	; 0x02
			__date[3] = (__datetime[5] >> 4) + 0x30;
   164b2:	9e 81       	ldd	r25, Y+6	; 0x06
   164b4:	89 2f       	mov	r24, r25
   164b6:	82 95       	swap	r24
   164b8:	8f 70       	andi	r24, 0x0F	; 15
   164ba:	80 5d       	subi	r24, 0xD0	; 208
   164bc:	83 83       	std	Z+3, r24	; 0x03
			__date[4] = (__datetime[5] & 0x0F) + 0x30;
   164be:	9f 70       	andi	r25, 0x0F	; 15
   164c0:	90 5d       	subi	r25, 0xD0	; 208
   164c2:	94 83       	std	Z+4, r25	; 0x04
			__date[5] = '/';
   164c4:	25 83       	std	Z+5, r18	; 0x05
			__date[6] = (__datetime[6] >> 4) + 0x30;
   164c6:	9f 81       	ldd	r25, Y+7	; 0x07
   164c8:	89 2f       	mov	r24, r25
   164ca:	82 95       	swap	r24
   164cc:	8f 70       	andi	r24, 0x0F	; 15
   164ce:	80 5d       	subi	r24, 0xD0	; 208
   164d0:	86 83       	std	Z+6, r24	; 0x06
			__date[7] = (__datetime[6] & 0x0F) + 0x30;
   164d2:	9f 70       	andi	r25, 0x0F	; 15
   164d4:	90 5d       	subi	r25, 0xD0	; 208
   164d6:	97 83       	std	Z+7, r25	; 0x07
			__date[8] = '\0';
   164d8:	10 86       	std	Z+8, r1	; 0x08

			__time[0] = (__datetime[2] >> 4) + 0x30;
   164da:	9b 81       	ldd	r25, Y+3	; 0x03
   164dc:	89 2f       	mov	r24, r25
   164de:	82 95       	swap	r24
   164e0:	8f 70       	andi	r24, 0x0F	; 15
   164e2:	80 5d       	subi	r24, 0xD0	; 208
   164e4:	f7 01       	movw	r30, r14
   164e6:	80 83       	st	Z, r24
			__time[1] = (__datetime[2] & 0x0F) + 0x30;
   164e8:	9f 70       	andi	r25, 0x0F	; 15
   164ea:	90 5d       	subi	r25, 0xD0	; 208
   164ec:	91 83       	std	Z+1, r25	; 0x01
			__time[2] = ':';
   164ee:	2a e3       	ldi	r18, 0x3A	; 58
   164f0:	22 83       	std	Z+2, r18	; 0x02
			__time[3] = (__datetime[1] >> 4) + 0x30;
   164f2:	9a 81       	ldd	r25, Y+2	; 0x02
   164f4:	89 2f       	mov	r24, r25
   164f6:	82 95       	swap	r24
   164f8:	8f 70       	andi	r24, 0x0F	; 15
   164fa:	80 5d       	subi	r24, 0xD0	; 208
   164fc:	83 83       	std	Z+3, r24	; 0x03
			__time[4] = (__datetime[1] & 0x0F) + 0x30;
   164fe:	9f 70       	andi	r25, 0x0F	; 15
   16500:	90 5d       	subi	r25, 0xD0	; 208
   16502:	94 83       	std	Z+4, r25	; 0x04
			__time[5] = ':';
   16504:	25 83       	std	Z+5, r18	; 0x05
			__time[6] = (__datetime[0] >> 4) + 0x30;
   16506:	99 81       	ldd	r25, Y+1	; 0x01
   16508:	89 2f       	mov	r24, r25
   1650a:	82 95       	swap	r24
   1650c:	8f 70       	andi	r24, 0x0F	; 15
   1650e:	80 5d       	subi	r24, 0xD0	; 208
   16510:	86 83       	std	Z+6, r24	; 0x06
			__time[7] = (__datetime[0] & 0x0F) + 0x30;
   16512:	9f 70       	andi	r25, 0x0F	; 15
   16514:	90 5d       	subi	r25, 0xD0	; 208
   16516:	97 83       	std	Z+7, r25	; 0x07
			__time[8] = '\0';
   16518:	10 86       	std	Z+8, r1	; 0x08
		}
}
   1651a:	64 96       	adiw	r28, 0x14	; 20
   1651c:	0f b6       	in	r0, 0x3f	; 63
   1651e:	f8 94       	cli
   16520:	de bf       	out	0x3e, r29	; 62
   16522:	0f be       	out	0x3f, r0	; 63
   16524:	cd bf       	out	0x3d, r28	; 61
   16526:	cf 91       	pop	r28
   16528:	df 91       	pop	r29
   1652a:	1f 91       	pop	r17
   1652c:	0f 91       	pop	r16
   1652e:	ff 90       	pop	r15
   16530:	ef 90       	pop	r14
   16532:	08 95       	ret

00016534 <_day>:

unsigned char _day(void){
   16534:	df 93       	push	r29
   16536:	cf 93       	push	r28
   16538:	cd b7       	in	r28, 0x3d	; 61
   1653a:	de b7       	in	r29, 0x3e	; 62
   1653c:	64 97       	sbiw	r28, 0x14	; 20
   1653e:	0f b6       	in	r0, 0x3f	; 63
   16540:	f8 94       	cli
   16542:	de bf       	out	0x3e, r29	; 62
   16544:	0f be       	out	0x3f, r0	; 63
   16546:	cd bf       	out	0x3d, r28	; 61
	char	__datetime[20];

	if(_rtc(0, 8, __datetime, 0) != 1)
   16548:	80 e0       	ldi	r24, 0x00	; 0
   1654a:	90 e0       	ldi	r25, 0x00	; 0
   1654c:	68 e0       	ldi	r22, 0x08	; 8
   1654e:	70 e0       	ldi	r23, 0x00	; 0
   16550:	ae 01       	movw	r20, r28
   16552:	4f 5f       	subi	r20, 0xFF	; 255
   16554:	5f 4f       	sbci	r21, 0xFF	; 255
   16556:	20 e0       	ldi	r18, 0x00	; 0
   16558:	0e 94 38 b1 	call	0x16270	; 0x16270 <_rtc>
   1655c:	81 30       	cpi	r24, 0x01	; 1
   1655e:	11 f4       	brne	.+4      	; 0x16564 <_day+0x30>
   16560:	80 e0       	ldi	r24, 0x00	; 0
   16562:	02 c0       	rjmp	.+4      	; 0x16568 <_day+0x34>
		return __datetime[3] & 0x0F;
   16564:	8c 81       	ldd	r24, Y+4	; 0x04
   16566:	8f 70       	andi	r24, 0x0F	; 15
	return 0;
   16568:	64 96       	adiw	r28, 0x14	; 20
   1656a:	0f b6       	in	r0, 0x3f	; 63
   1656c:	f8 94       	cli
   1656e:	de bf       	out	0x3e, r29	; 62
   16570:	0f be       	out	0x3f, r0	; 63
   16572:	cd bf       	out	0x3d, r28	; 61
   16574:	cf 91       	pop	r28
   16576:	df 91       	pop	r29
   16578:	08 95       	ret

0001657a <_uart_baudrate>:
	}

	_uart_baudrate(__com, __baudrate);
}

void _uart_baudrate(unsigned char __com, unsigned long __baudrate){
   1657a:	1f 93       	push	r17
   1657c:	18 2f       	mov	r17, r24
   1657e:	9a 01       	movw	r18, r20
   16580:	ab 01       	movw	r20, r22
	unsigned long __br;

	__br = (unsigned long)((_CPU_DEFAULT + (__baudrate * 8)) / (__baudrate * 16) - 1);
   16582:	ca 01       	movw	r24, r20
   16584:	b9 01       	movw	r22, r18
   16586:	60 50       	subi	r22, 0x00	; 0
   16588:	70 4e       	sbci	r23, 0xE0	; 224
   1658a:	83 4e       	sbci	r24, 0xE3	; 227
   1658c:	9f 4f       	sbci	r25, 0xFF	; 255
   1658e:	f3 e0       	ldi	r31, 0x03	; 3
   16590:	66 0f       	add	r22, r22
   16592:	77 1f       	adc	r23, r23
   16594:	88 1f       	adc	r24, r24
   16596:	99 1f       	adc	r25, r25
   16598:	fa 95       	dec	r31
   1659a:	d1 f7       	brne	.-12     	; 0x16590 <_uart_baudrate+0x16>
   1659c:	e4 e0       	ldi	r30, 0x04	; 4
   1659e:	22 0f       	add	r18, r18
   165a0:	33 1f       	adc	r19, r19
   165a2:	44 1f       	adc	r20, r20
   165a4:	55 1f       	adc	r21, r21
   165a6:	ea 95       	dec	r30
   165a8:	d1 f7       	brne	.-12     	; 0x1659e <_uart_baudrate+0x24>
   165aa:	0e 94 e3 b7 	call	0x16fc6	; 0x16fc6 <__udivmodsi4>
   165ae:	21 50       	subi	r18, 0x01	; 1
   165b0:	30 40       	sbci	r19, 0x00	; 0
   165b2:	40 40       	sbci	r20, 0x00	; 0
   165b4:	50 40       	sbci	r21, 0x00	; 0
   165b6:	bb 27       	eor	r27, r27
   165b8:	a5 2f       	mov	r26, r21
   165ba:	94 2f       	mov	r25, r20
   165bc:	83 2f       	mov	r24, r19

	if(__com){
   165be:	11 23       	and	r17, r17
   165c0:	29 f0       	breq	.+10     	; 0x165cc <_uart_baudrate+0x52>
		UBRR1L = __br;
   165c2:	20 93 99 00 	sts	0x0099, r18
		UBRR1H = __br >> 8;
   165c6:	80 93 98 00 	sts	0x0098, r24
   165ca:	03 c0       	rjmp	.+6      	; 0x165d2 <_uart_baudrate+0x58>
	}
	else{
		UBRR0L = __br;
   165cc:	29 b9       	out	0x09, r18	; 9
		UBRR0H = __br >> 8;
   165ce:	80 93 90 00 	sts	0x0090, r24
	}
}
   165d2:	1f 91       	pop	r17
   165d4:	08 95       	ret

000165d6 <_uart_init>:
#include <util/delay.h>
#include <string.h>

#include "UART.h"

void _uart_init(unsigned char __com, unsigned long __baudrate){
   165d6:	98 2f       	mov	r25, r24
	if(__com){
   165d8:	88 23       	and	r24, r24
   165da:	39 f0       	breq	.+14     	; 0x165ea <_uart_init+0x14>
		UCSR1B = _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1);
   165dc:	88 e9       	ldi	r24, 0x98	; 152
   165de:	80 93 9a 00 	sts	0x009A, r24
		UCSR1C = _BV(UCSZ11) | _BV(UCSZ10);
   165e2:	86 e0       	ldi	r24, 0x06	; 6
   165e4:	80 93 9d 00 	sts	0x009D, r24
   165e8:	05 c0       	rjmp	.+10     	; 0x165f4 <_uart_init+0x1e>
	}
	else{
		UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
   165ea:	88 e9       	ldi	r24, 0x98	; 152
   165ec:	8a b9       	out	0x0a, r24	; 10
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
   165ee:	86 e0       	ldi	r24, 0x06	; 6
   165f0:	80 93 95 00 	sts	0x0095, r24
	}

	_uart_baudrate(__com, __baudrate);
   165f4:	89 2f       	mov	r24, r25
   165f6:	0e 94 bd b2 	call	0x1657a	; 0x1657a <_uart_baudrate>
}
   165fa:	08 95       	ret

000165fc <_uart>:
		UBRR0H = __br >> 8;
	}
}

unsigned char _uart(unsigned char __com, unsigned char __dir, unsigned char __chr){
	if(__com){
   165fc:	88 23       	and	r24, r24
   165fe:	81 f0       	breq	.+32     	; 0x16620 <_uart+0x24>
		if(__dir){
   16600:	66 23       	and	r22, r22
   16602:	39 f0       	breq	.+14     	; 0x16612 <_uart+0x16>
			loop_until_bit_is_set(UCSR1A, UDRE1);
   16604:	80 91 9b 00 	lds	r24, 0x009B
   16608:	85 ff       	sbrs	r24, 5
   1660a:	fc cf       	rjmp	.-8      	; 0x16604 <_uart+0x8>
			UDR1 = __chr;
   1660c:	40 93 9c 00 	sts	0x009C, r20
   16610:	0c c0       	rjmp	.+24     	; 0x1662a <_uart+0x2e>
		}
		else{
			loop_until_bit_is_set(UCSR1A, RXC);
   16612:	80 91 9b 00 	lds	r24, 0x009B
   16616:	87 ff       	sbrs	r24, 7
   16618:	fc cf       	rjmp	.-8      	; 0x16612 <_uart+0x16>
			return UDR1;
   1661a:	80 91 9c 00 	lds	r24, 0x009C
   1661e:	08 95       	ret
		}
	}
	else{
		if(__dir){
   16620:	66 23       	and	r22, r22
   16622:	29 f0       	breq	.+10     	; 0x1662e <_uart+0x32>
			loop_until_bit_is_set(UCSR0A, UDRE0);
   16624:	5d 9b       	sbis	0x0b, 5	; 11
   16626:	fe cf       	rjmp	.-4      	; 0x16624 <_uart+0x28>
			UDR0 = __chr;
   16628:	4c b9       	out	0x0c, r20	; 12
   1662a:	81 e0       	ldi	r24, 0x01	; 1
   1662c:	08 95       	ret
		}
		else{
			loop_until_bit_is_set(UCSR0A,  RXC);
   1662e:	5f 9b       	sbis	0x0b, 7	; 11
   16630:	fe cf       	rjmp	.-4      	; 0x1662e <_uart+0x32>
			return UDR0;
   16632:	8c b1       	in	r24, 0x0c	; 12
		}

	}

	return 1;
}
   16634:	08 95       	ret

00016636 <_uart_print>:

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
   16636:	0f 93       	push	r16
   16638:	1f 93       	push	r17
   1663a:	cf 93       	push	r28
   1663c:	df 93       	push	r29
   1663e:	18 2f       	mov	r17, r24
   16640:	06 2f       	mov	r16, r22
   16642:	ea 01       	movw	r28, r20
	if(strlen(__str)>0)
   16644:	88 81       	ld	r24, Y
   16646:	88 23       	and	r24, r24
   16648:	31 f4       	brne	.+12     	; 0x16656 <_uart_print+0x20>
   1664a:	08 c0       	rjmp	.+16     	; 0x1665c <_uart_print+0x26>
		while(*__str) _uart(__com, 1, *__str++);
   1664c:	21 96       	adiw	r28, 0x01	; 1
   1664e:	81 2f       	mov	r24, r17
   16650:	61 e0       	ldi	r22, 0x01	; 1
   16652:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
   16656:	48 81       	ld	r20, Y
   16658:	44 23       	and	r20, r20
   1665a:	c1 f7       	brne	.-16     	; 0x1664c <_uart_print+0x16>

	if(__ret){
   1665c:	00 23       	and	r16, r16
   1665e:	51 f0       	breq	.+20     	; 0x16674 <_uart_print+0x3e>
		_uart(__com, 1, 0x0D);
   16660:	81 2f       	mov	r24, r17
   16662:	61 e0       	ldi	r22, 0x01	; 1
   16664:	4d e0       	ldi	r20, 0x0D	; 13
   16666:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
		_uart(__com, 1, 0x0A);
   1666a:	81 2f       	mov	r24, r17
   1666c:	61 e0       	ldi	r22, 0x01	; 1
   1666e:	4a e0       	ldi	r20, 0x0A	; 10
   16670:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
   16674:	82 ee       	ldi	r24, 0xE2	; 226
   16676:	94 e0       	ldi	r25, 0x04	; 4
   16678:	01 97       	sbiw	r24, 0x01	; 1
   1667a:	f1 f7       	brne	.-4      	; 0x16678 <_uart_print+0x42>
	}
	_delay_ms(5);
}
   1667c:	df 91       	pop	r29
   1667e:	cf 91       	pop	r28
   16680:	1f 91       	pop	r17
   16682:	0f 91       	pop	r16
   16684:	08 95       	ret

00016686 <_uart_printf>:

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
   16686:	0f 93       	push	r16
   16688:	1f 93       	push	r17
   1668a:	cf 93       	push	r28
   1668c:	df 93       	push	r29
   1668e:	18 2f       	mov	r17, r24
   16690:	06 2f       	mov	r16, r22
   16692:	ea 01       	movw	r28, r20
   16694:	07 c0       	rjmp	.+14     	; 0x166a4 <_uart_printf+0x1e>
	while(pgm_read_byte(&(*__str)))
		_uart(__com, 1, pgm_read_byte(&(*__str++)));
   16696:	21 96       	adiw	r28, 0x01	; 1
   16698:	f9 01       	movw	r30, r18
   1669a:	44 91       	lpm	r20, Z+
   1669c:	81 2f       	mov	r24, r17
   1669e:	61 e0       	ldi	r22, 0x01	; 1
   166a0:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
   166a4:	9e 01       	movw	r18, r28
	}
	_delay_ms(5);
}

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
	while(pgm_read_byte(&(*__str)))
   166a6:	fe 01       	movw	r30, r28
   166a8:	84 91       	lpm	r24, Z+
   166aa:	88 23       	and	r24, r24
   166ac:	a1 f7       	brne	.-24     	; 0x16696 <_uart_printf+0x10>
		_uart(__com, 1, pgm_read_byte(&(*__str++)));

	if(__ret){
   166ae:	00 23       	and	r16, r16
   166b0:	51 f0       	breq	.+20     	; 0x166c6 <_uart_printf+0x40>
		_uart(__com, 1, 0x0D);
   166b2:	81 2f       	mov	r24, r17
   166b4:	61 e0       	ldi	r22, 0x01	; 1
   166b6:	4d e0       	ldi	r20, 0x0D	; 13
   166b8:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
		_uart(__com, 1, 0x0A);
   166bc:	81 2f       	mov	r24, r17
   166be:	61 e0       	ldi	r22, 0x01	; 1
   166c0:	4a e0       	ldi	r20, 0x0A	; 10
   166c2:	0e 94 fe b2 	call	0x165fc	; 0x165fc <_uart>
   166c6:	86 ea       	ldi	r24, 0xA6	; 166
   166c8:	9e e0       	ldi	r25, 0x0E	; 14
   166ca:	01 97       	sbiw	r24, 0x01	; 1
   166cc:	f1 f7       	brne	.-4      	; 0x166ca <_uart_printf+0x44>
	}
	_delay_ms(15);
}
   166ce:	df 91       	pop	r29
   166d0:	cf 91       	pop	r28
   166d2:	1f 91       	pop	r17
   166d4:	0f 91       	pop	r16
   166d6:	08 95       	ret

000166d8 <Int2Str>:

void Int2Str(char* __string, unsigned long __value){
   166d8:	6f 92       	push	r6
   166da:	7f 92       	push	r7
   166dc:	8f 92       	push	r8
   166de:	9f 92       	push	r9
   166e0:	af 92       	push	r10
   166e2:	bf 92       	push	r11
   166e4:	cf 92       	push	r12
   166e6:	df 92       	push	r13
   166e8:	ef 92       	push	r14
   166ea:	ff 92       	push	r15
   166ec:	0f 93       	push	r16
   166ee:	1f 93       	push	r17
   166f0:	cf 93       	push	r28
   166f2:	df 93       	push	r29
   166f4:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
   166f6:	41 15       	cp	r20, r1
   166f8:	51 05       	cpc	r21, r1
   166fa:	61 05       	cpc	r22, r1
   166fc:	71 05       	cpc	r23, r1
   166fe:	21 f4       	brne	.+8      	; 0x16708 <Int2Str+0x30>
		__string[0] = '0';
   16700:	80 e3       	ldi	r24, 0x30	; 48
   16702:	88 83       	st	Y, r24
		__string[1] = '\0';
   16704:	19 82       	std	Y+1, r1	; 0x01
   16706:	48 c0       	rjmp	.+144    	; 0x16798 <Int2Str+0xc0>
		return;
   16708:	4a 01       	movw	r8, r20
   1670a:	5b 01       	movw	r10, r22
   1670c:	10 e0       	ldi	r17, 0x00	; 0
   1670e:	00 e0       	ldi	r16, 0x00	; 0
   16710:	77 24       	eor	r7, r7
   16712:	c1 2c       	mov	r12, r1
   16714:	ba ec       	ldi	r27, 0xCA	; 202
   16716:	db 2e       	mov	r13, r27
   16718:	ba e9       	ldi	r27, 0x9A	; 154
   1671a:	eb 2e       	mov	r14, r27
   1671c:	bb e3       	ldi	r27, 0x3B	; 59
   1671e:	fb 2e       	mov	r15, r27
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
   16720:	a0 e3       	ldi	r26, 0x30	; 48
   16722:	6a 2e       	mov	r6, r26
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
   16724:	8c 14       	cp	r8, r12
   16726:	9d 04       	cpc	r9, r13
   16728:	ae 04       	cpc	r10, r14
   1672a:	bf 04       	cpc	r11, r15
   1672c:	d0 f0       	brcs	.+52     	; 0x16762 <Int2Str+0x8a>
			__tmp = (int)(__num / __devider);
   1672e:	c5 01       	movw	r24, r10
   16730:	b4 01       	movw	r22, r8
   16732:	a7 01       	movw	r20, r14
   16734:	96 01       	movw	r18, r12
   16736:	0e 94 e3 b7 	call	0x16fc6	; 0x16fc6 <__udivmodsi4>
   1673a:	12 2f       	mov	r17, r18
			__num = __num % __devider;
   1673c:	c5 01       	movw	r24, r10
   1673e:	b4 01       	movw	r22, r8
   16740:	a7 01       	movw	r20, r14
   16742:	96 01       	movw	r18, r12
   16744:	0e 94 e3 b7 	call	0x16fc6	; 0x16fc6 <__udivmodsi4>
   16748:	ac 01       	movw	r20, r24
   1674a:	cb 01       	movw	r24, r22
   1674c:	da 01       	movw	r26, r20
   1674e:	4c 01       	movw	r8, r24
   16750:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
   16752:	fe 01       	movw	r30, r28
   16754:	e0 0f       	add	r30, r16
   16756:	f1 1d       	adc	r31, r1
   16758:	10 5d       	subi	r17, 0xD0	; 208
   1675a:	10 83       	st	Z, r17
   1675c:	0f 5f       	subi	r16, 0xFF	; 255
   1675e:	11 e0       	ldi	r17, 0x01	; 1
   16760:	07 c0       	rjmp	.+14     	; 0x16770 <Int2Str+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
   16762:	11 23       	and	r17, r17
   16764:	29 f0       	breq	.+10     	; 0x16770 <Int2Str+0x98>
				__string[__i++] = 0x30;
   16766:	fe 01       	movw	r30, r28
   16768:	e0 0f       	add	r30, r16
   1676a:	f1 1d       	adc	r31, r1
   1676c:	60 82       	st	Z, r6
   1676e:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
   16770:	73 94       	inc	r7
   16772:	8a e0       	ldi	r24, 0x0A	; 10
   16774:	78 16       	cp	r7, r24
   16776:	69 f0       	breq	.+26     	; 0x16792 <Int2Str+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
   16778:	c7 01       	movw	r24, r14
   1677a:	b6 01       	movw	r22, r12
   1677c:	2a e0       	ldi	r18, 0x0A	; 10
   1677e:	30 e0       	ldi	r19, 0x00	; 0
   16780:	40 e0       	ldi	r20, 0x00	; 0
   16782:	50 e0       	ldi	r21, 0x00	; 0
   16784:	0e 94 e3 b7 	call	0x16fc6	; 0x16fc6 <__udivmodsi4>
   16788:	c9 01       	movw	r24, r18
   1678a:	da 01       	movw	r26, r20
   1678c:	6c 01       	movw	r12, r24
   1678e:	7d 01       	movw	r14, r26
   16790:	c9 cf       	rjmp	.-110    	; 0x16724 <Int2Str+0x4c>
	}
	__string[__i] = '\0';
   16792:	c0 0f       	add	r28, r16
   16794:	d1 1d       	adc	r29, r1
   16796:	18 82       	st	Y, r1
}
   16798:	df 91       	pop	r29
   1679a:	cf 91       	pop	r28
   1679c:	1f 91       	pop	r17
   1679e:	0f 91       	pop	r16
   167a0:	ff 90       	pop	r15
   167a2:	ef 90       	pop	r14
   167a4:	df 90       	pop	r13
   167a6:	cf 90       	pop	r12
   167a8:	bf 90       	pop	r11
   167aa:	af 90       	pop	r10
   167ac:	9f 90       	pop	r9
   167ae:	8f 90       	pop	r8
   167b0:	7f 90       	pop	r7
   167b2:	6f 90       	pop	r6
   167b4:	08 95       	ret

000167b6 <Str2Int>:

unsigned long Str2Int(char* __string){
   167b6:	6f 92       	push	r6
   167b8:	7f 92       	push	r7
   167ba:	8f 92       	push	r8
   167bc:	9f 92       	push	r9
   167be:	af 92       	push	r10
   167c0:	bf 92       	push	r11
   167c2:	cf 92       	push	r12
   167c4:	df 92       	push	r13
   167c6:	ef 92       	push	r14
   167c8:	ff 92       	push	r15
   167ca:	0f 93       	push	r16
   167cc:	1f 93       	push	r17
   167ce:	cf 93       	push	r28
   167d0:	df 93       	push	r29
   167d2:	ec 01       	movw	r28, r24
	unsigned char	__i, __len;
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);
   167d4:	dc 01       	movw	r26, r24
   167d6:	0d 90       	ld	r0, X+
   167d8:	00 20       	and	r0, r0
   167da:	e9 f7       	brne	.-6      	; 0x167d6 <Str2Int+0x20>
   167dc:	11 97       	sbiw	r26, 0x01	; 1
   167de:	7a 2e       	mov	r7, r26
   167e0:	78 1a       	sub	r7, r24

	if(__len > 0 && __len < 11){
   167e2:	87 2d       	mov	r24, r7
   167e4:	81 50       	subi	r24, 0x01	; 1
   167e6:	8a 30       	cpi	r24, 0x0A	; 10
   167e8:	08 f0       	brcs	.+2      	; 0x167ec <Str2Int+0x36>
   167ea:	64 c0       	rjmp	.+200    	; 0x168b4 <Str2Int+0xfe>
   167ec:	4e 01       	movw	r8, r28
   167ee:	fe 01       	movw	r30, r28
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}

unsigned long Str2Int(char* __string){
   167f0:	6c 2e       	mov	r6, r28
   167f2:	05 c0       	rjmp	.+10     	; 0x167fe <Str2Int+0x48>

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
   167f4:	81 91       	ld	r24, Z+
   167f6:	80 53       	subi	r24, 0x30	; 48
   167f8:	8a 30       	cpi	r24, 0x0A	; 10
   167fa:	08 f0       	brcs	.+2      	; 0x167fe <Str2Int+0x48>
   167fc:	5b c0       	rjmp	.+182    	; 0x168b4 <Str2Int+0xfe>
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
   167fe:	8e 2f       	mov	r24, r30
   16800:	86 19       	sub	r24, r6
   16802:	87 15       	cp	r24, r7
   16804:	b8 f3       	brcs	.-18     	; 0x167f4 <Str2Int+0x3e>
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
				return 0;
		if(__len == 10){
   16806:	8a e0       	ldi	r24, 0x0A	; 10
   16808:	78 16       	cp	r7, r24
   1680a:	f9 f4       	brne	.+62     	; 0x1684a <Str2Int+0x94>
			if(__string[0] < 0x30 || __string[0] > 0x32)
   1680c:	98 81       	ld	r25, Y
   1680e:	89 2f       	mov	r24, r25
   16810:	80 53       	subi	r24, 0x30	; 48
   16812:	83 30       	cpi	r24, 0x03	; 3
   16814:	08 f0       	brcs	.+2      	; 0x16818 <Str2Int+0x62>
   16816:	4e c0       	rjmp	.+156    	; 0x168b4 <Str2Int+0xfe>
				return 0;
			if(__string[0] == 0x32){
   16818:	92 33       	cpi	r25, 0x32	; 50
   1681a:	b9 f4       	brne	.+46     	; 0x1684a <Str2Int+0x94>
   1681c:	fe 01       	movw	r30, r28
   1681e:	91 e0       	ldi	r25, 0x01	; 1
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
   16820:	81 81       	ldd	r24, Z+1	; 0x01
   16822:	80 33       	cpi	r24, 0x30	; 48
   16824:	09 f0       	breq	.+2      	; 0x16828 <Str2Int+0x72>
   16826:	46 c0       	rjmp	.+140    	; 0x168b4 <Str2Int+0xfe>
				return 0;
		if(__len == 10){
			if(__string[0] < 0x30 || __string[0] > 0x32)
				return 0;
			if(__string[0] == 0x32){
				for(__i = 1; __i < __len; __i++)
   16828:	9f 5f       	subi	r25, 0xFF	; 255
   1682a:	31 96       	adiw	r30, 0x01	; 1
   1682c:	9a 30       	cpi	r25, 0x0A	; 10
   1682e:	c1 f7       	brne	.-16     	; 0x16820 <Str2Int+0x6a>
   16830:	0c c0       	rjmp	.+24     	; 0x1684a <Str2Int+0x94>
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
   16832:	c6 01       	movw	r24, r12
   16834:	b5 01       	movw	r22, r10
   16836:	2a e0       	ldi	r18, 0x0A	; 10
   16838:	30 e0       	ldi	r19, 0x00	; 0
   1683a:	40 e0       	ldi	r20, 0x00	; 0
   1683c:	50 e0       	ldi	r21, 0x00	; 0
   1683e:	0e 94 84 b7 	call	0x16f08	; 0x16f08 <__mulsi3>
   16842:	5b 01       	movw	r10, r22
   16844:	6c 01       	movw	r12, r24
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
   16846:	1f 5f       	subi	r17, 0xFF	; 255
   16848:	09 c0       	rjmp	.+18     	; 0x1685c <Str2Int+0xa6>
   1684a:	10 e0       	ldi	r17, 0x00	; 0
   1684c:	01 e0       	ldi	r16, 0x01	; 1
   1684e:	a0 2e       	mov	r10, r16
   16850:	b1 2c       	mov	r11, r1
   16852:	c1 2c       	mov	r12, r1
   16854:	d1 2c       	mov	r13, r1
   16856:	c7 2d       	mov	r28, r7
   16858:	d0 e0       	ldi	r29, 0x00	; 0
   1685a:	21 97       	sbiw	r28, 0x01	; 1
   1685c:	81 2f       	mov	r24, r17
   1685e:	90 e0       	ldi	r25, 0x00	; 0
   16860:	8c 17       	cp	r24, r28
   16862:	9d 07       	cpc	r25, r29
   16864:	34 f3       	brlt	.-52     	; 0x16832 <Str2Int+0x7c>
   16866:	ee 24       	eor	r14, r14
   16868:	ff 24       	eor	r15, r15
   1686a:	87 01       	movw	r16, r14
   1686c:	1e c0       	rjmp	.+60     	; 0x168aa <Str2Int+0xf4>
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
   1686e:	f4 01       	movw	r30, r8
   16870:	21 91       	ld	r18, Z+
   16872:	4f 01       	movw	r8, r30
   16874:	30 e0       	ldi	r19, 0x00	; 0
   16876:	20 53       	subi	r18, 0x30	; 48
   16878:	30 40       	sbci	r19, 0x00	; 0
   1687a:	44 27       	eor	r20, r20
   1687c:	37 fd       	sbrc	r19, 7
   1687e:	40 95       	com	r20
   16880:	54 2f       	mov	r21, r20
   16882:	c6 01       	movw	r24, r12
   16884:	b5 01       	movw	r22, r10
   16886:	0e 94 84 b7 	call	0x16f08	; 0x16f08 <__mulsi3>
   1688a:	e6 0e       	add	r14, r22
   1688c:	f7 1e       	adc	r15, r23
   1688e:	08 1f       	adc	r16, r24
   16890:	19 1f       	adc	r17, r25
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
   16892:	c6 01       	movw	r24, r12
   16894:	b5 01       	movw	r22, r10
   16896:	2a e0       	ldi	r18, 0x0A	; 10
   16898:	30 e0       	ldi	r19, 0x00	; 0
   1689a:	40 e0       	ldi	r20, 0x00	; 0
   1689c:	50 e0       	ldi	r21, 0x00	; 0
   1689e:	0e 94 e3 b7 	call	0x16fc6	; 0x16fc6 <__udivmodsi4>
   168a2:	c9 01       	movw	r24, r18
   168a4:	da 01       	movw	r26, r20
   168a6:	5c 01       	movw	r10, r24
   168a8:	6d 01       	movw	r12, r26
   168aa:	88 2d       	mov	r24, r8
   168ac:	86 19       	sub	r24, r6
   168ae:	87 15       	cp	r24, r7
   168b0:	f0 f2       	brcs	.-68     	; 0x1686e <Str2Int+0xb8>
   168b2:	03 c0       	rjmp	.+6      	; 0x168ba <Str2Int+0x104>
   168b4:	ee 24       	eor	r14, r14
   168b6:	ff 24       	eor	r15, r15
   168b8:	87 01       	movw	r16, r14
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
	}
	return __retval;
}
   168ba:	b7 01       	movw	r22, r14
   168bc:	c8 01       	movw	r24, r16
   168be:	df 91       	pop	r29
   168c0:	cf 91       	pop	r28
   168c2:	1f 91       	pop	r17
   168c4:	0f 91       	pop	r16
   168c6:	ff 90       	pop	r15
   168c8:	ef 90       	pop	r14
   168ca:	df 90       	pop	r13
   168cc:	cf 90       	pop	r12
   168ce:	bf 90       	pop	r11
   168d0:	af 90       	pop	r10
   168d2:	9f 90       	pop	r9
   168d4:	8f 90       	pop	r8
   168d6:	7f 90       	pop	r7
   168d8:	6f 90       	pop	r6
   168da:	08 95       	ret

000168dc <atoi>:
   168dc:	fc 01       	movw	r30, r24
   168de:	88 27       	eor	r24, r24
   168e0:	99 27       	eor	r25, r25
   168e2:	e8 94       	clt
   168e4:	21 91       	ld	r18, Z+
   168e6:	20 32       	cpi	r18, 0x20	; 32
   168e8:	e9 f3       	breq	.-6      	; 0x168e4 <atoi+0x8>
   168ea:	29 30       	cpi	r18, 0x09	; 9
   168ec:	10 f0       	brcs	.+4      	; 0x168f2 <atoi+0x16>
   168ee:	2e 30       	cpi	r18, 0x0E	; 14
   168f0:	c8 f3       	brcs	.-14     	; 0x168e4 <atoi+0x8>
   168f2:	2b 32       	cpi	r18, 0x2B	; 43
   168f4:	41 f0       	breq	.+16     	; 0x16906 <atoi+0x2a>
   168f6:	2d 32       	cpi	r18, 0x2D	; 45
   168f8:	39 f4       	brne	.+14     	; 0x16908 <atoi+0x2c>
   168fa:	68 94       	set
   168fc:	04 c0       	rjmp	.+8      	; 0x16906 <atoi+0x2a>
   168fe:	0e 94 db b4 	call	0x169b6	; 0x169b6 <__mulhi_const_10>
   16902:	82 0f       	add	r24, r18
   16904:	91 1d       	adc	r25, r1
   16906:	21 91       	ld	r18, Z+
   16908:	20 53       	subi	r18, 0x30	; 48
   1690a:	2a 30       	cpi	r18, 0x0A	; 10
   1690c:	c0 f3       	brcs	.-16     	; 0x168fe <atoi+0x22>
   1690e:	1e f4       	brtc	.+6      	; 0x16916 <atoi+0x3a>
   16910:	90 95       	com	r25
   16912:	81 95       	neg	r24
   16914:	9f 4f       	sbci	r25, 0xFF	; 255
   16916:	08 95       	ret

00016918 <strcpy_P>:
   16918:	fb 01       	movw	r30, r22
   1691a:	dc 01       	movw	r26, r24
   1691c:	05 90       	lpm	r0, Z+
   1691e:	0d 92       	st	X+, r0
   16920:	00 20       	and	r0, r0
   16922:	e1 f7       	brne	.-8      	; 0x1691c <strcpy_P+0x4>
   16924:	08 95       	ret

00016926 <strcmp>:
   16926:	fb 01       	movw	r30, r22
   16928:	dc 01       	movw	r26, r24
   1692a:	8d 91       	ld	r24, X+
   1692c:	01 90       	ld	r0, Z+
   1692e:	80 19       	sub	r24, r0
   16930:	01 10       	cpse	r0, r1
   16932:	d9 f3       	breq	.-10     	; 0x1692a <strcmp+0x4>
   16934:	99 0b       	sbc	r25, r25
   16936:	08 95       	ret

00016938 <strcpy>:
   16938:	fb 01       	movw	r30, r22
   1693a:	dc 01       	movw	r26, r24
   1693c:	01 90       	ld	r0, Z+
   1693e:	0d 92       	st	X+, r0
   16940:	00 20       	and	r0, r0
   16942:	e1 f7       	brne	.-8      	; 0x1693c <strcpy+0x4>
   16944:	08 95       	ret

00016946 <__eerd_block>:
   16946:	a0 e0       	ldi	r26, 0x00	; 0
   16948:	b0 e0       	ldi	r27, 0x00	; 0
   1694a:	e9 ea       	ldi	r30, 0xA9	; 169
   1694c:	f4 eb       	ldi	r31, 0xB4	; 180
   1694e:	0c 94 0f b8 	jmp	0x1701e	; 0x1701e <__prologue_saves__+0x14>
   16952:	7c 01       	movw	r14, r24
   16954:	eb 01       	movw	r28, r22
   16956:	8a 01       	movw	r16, r20
   16958:	69 01       	movw	r12, r18
   1695a:	09 c0       	rjmp	.+18     	; 0x1696e <__eerd_block+0x28>
   1695c:	ce 01       	movw	r24, r28
   1695e:	21 96       	adiw	r28, 0x01	; 1
   16960:	f6 01       	movw	r30, r12
   16962:	09 95       	icall
   16964:	f7 01       	movw	r30, r14
   16966:	81 93       	st	Z+, r24
   16968:	7f 01       	movw	r14, r30
   1696a:	01 50       	subi	r16, 0x01	; 1
   1696c:	10 40       	sbci	r17, 0x00	; 0
   1696e:	01 15       	cp	r16, r1
   16970:	11 05       	cpc	r17, r1
   16972:	a1 f7       	brne	.-24     	; 0x1695c <__eerd_block+0x16>
   16974:	cd b7       	in	r28, 0x3d	; 61
   16976:	de b7       	in	r29, 0x3e	; 62
   16978:	e8 e0       	ldi	r30, 0x08	; 8
   1697a:	0c 94 2b b8 	jmp	0x17056	; 0x17056 <__epilogue_restores__+0x14>

0001697e <__eewr_block>:
   1697e:	a0 e0       	ldi	r26, 0x00	; 0
   16980:	b0 e0       	ldi	r27, 0x00	; 0
   16982:	e5 ec       	ldi	r30, 0xC5	; 197
   16984:	f4 eb       	ldi	r31, 0xB4	; 180
   16986:	0c 94 0f b8 	jmp	0x1701e	; 0x1701e <__prologue_saves__+0x14>
   1698a:	ec 01       	movw	r28, r24
   1698c:	7b 01       	movw	r14, r22
   1698e:	8a 01       	movw	r16, r20
   16990:	69 01       	movw	r12, r18
   16992:	09 c0       	rjmp	.+18     	; 0x169a6 <__eewr_block+0x28>
   16994:	ce 01       	movw	r24, r28
   16996:	21 96       	adiw	r28, 0x01	; 1
   16998:	f7 01       	movw	r30, r14
   1699a:	61 91       	ld	r22, Z+
   1699c:	7f 01       	movw	r14, r30
   1699e:	f6 01       	movw	r30, r12
   169a0:	09 95       	icall
   169a2:	01 50       	subi	r16, 0x01	; 1
   169a4:	10 40       	sbci	r17, 0x00	; 0
   169a6:	01 15       	cp	r16, r1
   169a8:	11 05       	cpc	r17, r1
   169aa:	a1 f7       	brne	.-24     	; 0x16994 <__eewr_block+0x16>
   169ac:	cd b7       	in	r28, 0x3d	; 61
   169ae:	de b7       	in	r29, 0x3e	; 62
   169b0:	e8 e0       	ldi	r30, 0x08	; 8
   169b2:	0c 94 2b b8 	jmp	0x17056	; 0x17056 <__epilogue_restores__+0x14>

000169b6 <__mulhi_const_10>:
   169b6:	7a e0       	ldi	r23, 0x0A	; 10
   169b8:	97 9f       	mul	r25, r23
   169ba:	90 2d       	mov	r25, r0
   169bc:	87 9f       	mul	r24, r23
   169be:	80 2d       	mov	r24, r0
   169c0:	91 0d       	add	r25, r1
   169c2:	11 24       	eor	r1, r1
   169c4:	08 95       	ret

000169c6 <sprintf_P>:
   169c6:	ae e0       	ldi	r26, 0x0E	; 14
   169c8:	b0 e0       	ldi	r27, 0x00	; 0
   169ca:	e9 ee       	ldi	r30, 0xE9	; 233
   169cc:	f4 eb       	ldi	r31, 0xB4	; 180
   169ce:	0c 94 13 b8 	jmp	0x17026	; 0x17026 <__prologue_saves__+0x1c>
   169d2:	0d 89       	ldd	r16, Y+21	; 0x15
   169d4:	1e 89       	ldd	r17, Y+22	; 0x16
   169d6:	8e e0       	ldi	r24, 0x0E	; 14
   169d8:	8c 83       	std	Y+4, r24	; 0x04
   169da:	1a 83       	std	Y+2, r17	; 0x02
   169dc:	09 83       	std	Y+1, r16	; 0x01
   169de:	8f ef       	ldi	r24, 0xFF	; 255
   169e0:	9f e7       	ldi	r25, 0x7F	; 127
   169e2:	9e 83       	std	Y+6, r25	; 0x06
   169e4:	8d 83       	std	Y+5, r24	; 0x05
   169e6:	9e 01       	movw	r18, r28
   169e8:	27 5e       	subi	r18, 0xE7	; 231
   169ea:	3f 4f       	sbci	r19, 0xFF	; 255
   169ec:	ce 01       	movw	r24, r28
   169ee:	01 96       	adiw	r24, 0x01	; 1
   169f0:	6f 89       	ldd	r22, Y+23	; 0x17
   169f2:	78 8d       	ldd	r23, Y+24	; 0x18
   169f4:	a9 01       	movw	r20, r18
   169f6:	0e 94 07 b5 	call	0x16a0e	; 0x16a0e <vfprintf>
   169fa:	2f 81       	ldd	r18, Y+7	; 0x07
   169fc:	38 85       	ldd	r19, Y+8	; 0x08
   169fe:	02 0f       	add	r16, r18
   16a00:	13 1f       	adc	r17, r19
   16a02:	f8 01       	movw	r30, r16
   16a04:	10 82       	st	Z, r1
   16a06:	2e 96       	adiw	r28, 0x0e	; 14
   16a08:	e4 e0       	ldi	r30, 0x04	; 4
   16a0a:	0c 94 2f b8 	jmp	0x1705e	; 0x1705e <__epilogue_restores__+0x1c>

00016a0e <vfprintf>:
   16a0e:	ab e0       	ldi	r26, 0x0B	; 11
   16a10:	b0 e0       	ldi	r27, 0x00	; 0
   16a12:	ed e0       	ldi	r30, 0x0D	; 13
   16a14:	f5 eb       	ldi	r31, 0xB5	; 181
   16a16:	0c 94 05 b8 	jmp	0x1700a	; 0x1700a <__prologue_saves__>
   16a1a:	3c 01       	movw	r6, r24
   16a1c:	2b 01       	movw	r4, r22
   16a1e:	5a 01       	movw	r10, r20
   16a20:	fc 01       	movw	r30, r24
   16a22:	17 82       	std	Z+7, r1	; 0x07
   16a24:	16 82       	std	Z+6, r1	; 0x06
   16a26:	83 81       	ldd	r24, Z+3	; 0x03
   16a28:	81 fd       	sbrc	r24, 1
   16a2a:	03 c0       	rjmp	.+6      	; 0x16a32 <vfprintf+0x24>
   16a2c:	6f ef       	ldi	r22, 0xFF	; 255
   16a2e:	7f ef       	ldi	r23, 0xFF	; 255
   16a30:	c6 c1       	rjmp	.+908    	; 0x16dbe <vfprintf+0x3b0>
   16a32:	9a e0       	ldi	r25, 0x0A	; 10
   16a34:	89 2e       	mov	r8, r25
   16a36:	1e 01       	movw	r2, r28
   16a38:	08 94       	sec
   16a3a:	21 1c       	adc	r2, r1
   16a3c:	31 1c       	adc	r3, r1
   16a3e:	f3 01       	movw	r30, r6
   16a40:	23 81       	ldd	r18, Z+3	; 0x03
   16a42:	f2 01       	movw	r30, r4
   16a44:	23 fd       	sbrc	r18, 3
   16a46:	85 91       	lpm	r24, Z+
   16a48:	23 ff       	sbrs	r18, 3
   16a4a:	81 91       	ld	r24, Z+
   16a4c:	2f 01       	movw	r4, r30
   16a4e:	88 23       	and	r24, r24
   16a50:	09 f4       	brne	.+2      	; 0x16a54 <vfprintf+0x46>
   16a52:	b2 c1       	rjmp	.+868    	; 0x16db8 <vfprintf+0x3aa>
   16a54:	85 32       	cpi	r24, 0x25	; 37
   16a56:	39 f4       	brne	.+14     	; 0x16a66 <vfprintf+0x58>
   16a58:	23 fd       	sbrc	r18, 3
   16a5a:	85 91       	lpm	r24, Z+
   16a5c:	23 ff       	sbrs	r18, 3
   16a5e:	81 91       	ld	r24, Z+
   16a60:	2f 01       	movw	r4, r30
   16a62:	85 32       	cpi	r24, 0x25	; 37
   16a64:	29 f4       	brne	.+10     	; 0x16a70 <vfprintf+0x62>
   16a66:	90 e0       	ldi	r25, 0x00	; 0
   16a68:	b3 01       	movw	r22, r6
   16a6a:	0e 94 fa b6 	call	0x16df4	; 0x16df4 <fputc>
   16a6e:	e7 cf       	rjmp	.-50     	; 0x16a3e <vfprintf+0x30>
   16a70:	98 2f       	mov	r25, r24
   16a72:	ff 24       	eor	r15, r15
   16a74:	ee 24       	eor	r14, r14
   16a76:	99 24       	eor	r9, r9
   16a78:	ff e1       	ldi	r31, 0x1F	; 31
   16a7a:	ff 15       	cp	r31, r15
   16a7c:	d0 f0       	brcs	.+52     	; 0x16ab2 <vfprintf+0xa4>
   16a7e:	9b 32       	cpi	r25, 0x2B	; 43
   16a80:	69 f0       	breq	.+26     	; 0x16a9c <vfprintf+0x8e>
   16a82:	9c 32       	cpi	r25, 0x2C	; 44
   16a84:	28 f4       	brcc	.+10     	; 0x16a90 <vfprintf+0x82>
   16a86:	90 32       	cpi	r25, 0x20	; 32
   16a88:	59 f0       	breq	.+22     	; 0x16aa0 <vfprintf+0x92>
   16a8a:	93 32       	cpi	r25, 0x23	; 35
   16a8c:	91 f4       	brne	.+36     	; 0x16ab2 <vfprintf+0xa4>
   16a8e:	0e c0       	rjmp	.+28     	; 0x16aac <vfprintf+0x9e>
   16a90:	9d 32       	cpi	r25, 0x2D	; 45
   16a92:	49 f0       	breq	.+18     	; 0x16aa6 <vfprintf+0x98>
   16a94:	90 33       	cpi	r25, 0x30	; 48
   16a96:	69 f4       	brne	.+26     	; 0x16ab2 <vfprintf+0xa4>
   16a98:	41 e0       	ldi	r20, 0x01	; 1
   16a9a:	24 c0       	rjmp	.+72     	; 0x16ae4 <vfprintf+0xd6>
   16a9c:	52 e0       	ldi	r21, 0x02	; 2
   16a9e:	f5 2a       	or	r15, r21
   16aa0:	84 e0       	ldi	r24, 0x04	; 4
   16aa2:	f8 2a       	or	r15, r24
   16aa4:	28 c0       	rjmp	.+80     	; 0x16af6 <vfprintf+0xe8>
   16aa6:	98 e0       	ldi	r25, 0x08	; 8
   16aa8:	f9 2a       	or	r15, r25
   16aaa:	25 c0       	rjmp	.+74     	; 0x16af6 <vfprintf+0xe8>
   16aac:	e0 e1       	ldi	r30, 0x10	; 16
   16aae:	fe 2a       	or	r15, r30
   16ab0:	22 c0       	rjmp	.+68     	; 0x16af6 <vfprintf+0xe8>
   16ab2:	f7 fc       	sbrc	r15, 7
   16ab4:	29 c0       	rjmp	.+82     	; 0x16b08 <vfprintf+0xfa>
   16ab6:	89 2f       	mov	r24, r25
   16ab8:	80 53       	subi	r24, 0x30	; 48
   16aba:	8a 30       	cpi	r24, 0x0A	; 10
   16abc:	70 f4       	brcc	.+28     	; 0x16ada <vfprintf+0xcc>
   16abe:	f6 fe       	sbrs	r15, 6
   16ac0:	05 c0       	rjmp	.+10     	; 0x16acc <vfprintf+0xbe>
   16ac2:	98 9c       	mul	r9, r8
   16ac4:	90 2c       	mov	r9, r0
   16ac6:	11 24       	eor	r1, r1
   16ac8:	98 0e       	add	r9, r24
   16aca:	15 c0       	rjmp	.+42     	; 0x16af6 <vfprintf+0xe8>
   16acc:	e8 9c       	mul	r14, r8
   16ace:	e0 2c       	mov	r14, r0
   16ad0:	11 24       	eor	r1, r1
   16ad2:	e8 0e       	add	r14, r24
   16ad4:	f0 e2       	ldi	r31, 0x20	; 32
   16ad6:	ff 2a       	or	r15, r31
   16ad8:	0e c0       	rjmp	.+28     	; 0x16af6 <vfprintf+0xe8>
   16ada:	9e 32       	cpi	r25, 0x2E	; 46
   16adc:	29 f4       	brne	.+10     	; 0x16ae8 <vfprintf+0xda>
   16ade:	f6 fc       	sbrc	r15, 6
   16ae0:	6b c1       	rjmp	.+726    	; 0x16db8 <vfprintf+0x3aa>
   16ae2:	40 e4       	ldi	r20, 0x40	; 64
   16ae4:	f4 2a       	or	r15, r20
   16ae6:	07 c0       	rjmp	.+14     	; 0x16af6 <vfprintf+0xe8>
   16ae8:	9c 36       	cpi	r25, 0x6C	; 108
   16aea:	19 f4       	brne	.+6      	; 0x16af2 <vfprintf+0xe4>
   16aec:	50 e8       	ldi	r21, 0x80	; 128
   16aee:	f5 2a       	or	r15, r21
   16af0:	02 c0       	rjmp	.+4      	; 0x16af6 <vfprintf+0xe8>
   16af2:	98 36       	cpi	r25, 0x68	; 104
   16af4:	49 f4       	brne	.+18     	; 0x16b08 <vfprintf+0xfa>
   16af6:	f2 01       	movw	r30, r4
   16af8:	23 fd       	sbrc	r18, 3
   16afa:	95 91       	lpm	r25, Z+
   16afc:	23 ff       	sbrs	r18, 3
   16afe:	91 91       	ld	r25, Z+
   16b00:	2f 01       	movw	r4, r30
   16b02:	99 23       	and	r25, r25
   16b04:	09 f0       	breq	.+2      	; 0x16b08 <vfprintf+0xfa>
   16b06:	b8 cf       	rjmp	.-144    	; 0x16a78 <vfprintf+0x6a>
   16b08:	89 2f       	mov	r24, r25
   16b0a:	85 54       	subi	r24, 0x45	; 69
   16b0c:	83 30       	cpi	r24, 0x03	; 3
   16b0e:	18 f0       	brcs	.+6      	; 0x16b16 <vfprintf+0x108>
   16b10:	80 52       	subi	r24, 0x20	; 32
   16b12:	83 30       	cpi	r24, 0x03	; 3
   16b14:	38 f4       	brcc	.+14     	; 0x16b24 <vfprintf+0x116>
   16b16:	44 e0       	ldi	r20, 0x04	; 4
   16b18:	50 e0       	ldi	r21, 0x00	; 0
   16b1a:	a4 0e       	add	r10, r20
   16b1c:	b5 1e       	adc	r11, r21
   16b1e:	5f e3       	ldi	r21, 0x3F	; 63
   16b20:	59 83       	std	Y+1, r21	; 0x01
   16b22:	0f c0       	rjmp	.+30     	; 0x16b42 <vfprintf+0x134>
   16b24:	93 36       	cpi	r25, 0x63	; 99
   16b26:	31 f0       	breq	.+12     	; 0x16b34 <vfprintf+0x126>
   16b28:	93 37       	cpi	r25, 0x73	; 115
   16b2a:	79 f0       	breq	.+30     	; 0x16b4a <vfprintf+0x13c>
   16b2c:	93 35       	cpi	r25, 0x53	; 83
   16b2e:	09 f0       	breq	.+2      	; 0x16b32 <vfprintf+0x124>
   16b30:	56 c0       	rjmp	.+172    	; 0x16bde <vfprintf+0x1d0>
   16b32:	20 c0       	rjmp	.+64     	; 0x16b74 <vfprintf+0x166>
   16b34:	f5 01       	movw	r30, r10
   16b36:	80 81       	ld	r24, Z
   16b38:	89 83       	std	Y+1, r24	; 0x01
   16b3a:	42 e0       	ldi	r20, 0x02	; 2
   16b3c:	50 e0       	ldi	r21, 0x00	; 0
   16b3e:	a4 0e       	add	r10, r20
   16b40:	b5 1e       	adc	r11, r21
   16b42:	61 01       	movw	r12, r2
   16b44:	01 e0       	ldi	r16, 0x01	; 1
   16b46:	10 e0       	ldi	r17, 0x00	; 0
   16b48:	12 c0       	rjmp	.+36     	; 0x16b6e <vfprintf+0x160>
   16b4a:	f5 01       	movw	r30, r10
   16b4c:	c0 80       	ld	r12, Z
   16b4e:	d1 80       	ldd	r13, Z+1	; 0x01
   16b50:	f6 fc       	sbrc	r15, 6
   16b52:	03 c0       	rjmp	.+6      	; 0x16b5a <vfprintf+0x14c>
   16b54:	6f ef       	ldi	r22, 0xFF	; 255
   16b56:	7f ef       	ldi	r23, 0xFF	; 255
   16b58:	02 c0       	rjmp	.+4      	; 0x16b5e <vfprintf+0x150>
   16b5a:	69 2d       	mov	r22, r9
   16b5c:	70 e0       	ldi	r23, 0x00	; 0
   16b5e:	42 e0       	ldi	r20, 0x02	; 2
   16b60:	50 e0       	ldi	r21, 0x00	; 0
   16b62:	a4 0e       	add	r10, r20
   16b64:	b5 1e       	adc	r11, r21
   16b66:	c6 01       	movw	r24, r12
   16b68:	0e 94 ef b6 	call	0x16dde	; 0x16dde <strnlen>
   16b6c:	8c 01       	movw	r16, r24
   16b6e:	5f e7       	ldi	r21, 0x7F	; 127
   16b70:	f5 22       	and	r15, r21
   16b72:	14 c0       	rjmp	.+40     	; 0x16b9c <vfprintf+0x18e>
   16b74:	f5 01       	movw	r30, r10
   16b76:	c0 80       	ld	r12, Z
   16b78:	d1 80       	ldd	r13, Z+1	; 0x01
   16b7a:	f6 fc       	sbrc	r15, 6
   16b7c:	03 c0       	rjmp	.+6      	; 0x16b84 <vfprintf+0x176>
   16b7e:	6f ef       	ldi	r22, 0xFF	; 255
   16b80:	7f ef       	ldi	r23, 0xFF	; 255
   16b82:	02 c0       	rjmp	.+4      	; 0x16b88 <vfprintf+0x17a>
   16b84:	69 2d       	mov	r22, r9
   16b86:	70 e0       	ldi	r23, 0x00	; 0
   16b88:	42 e0       	ldi	r20, 0x02	; 2
   16b8a:	50 e0       	ldi	r21, 0x00	; 0
   16b8c:	a4 0e       	add	r10, r20
   16b8e:	b5 1e       	adc	r11, r21
   16b90:	c6 01       	movw	r24, r12
   16b92:	0e 94 e4 b6 	call	0x16dc8	; 0x16dc8 <strnlen_P>
   16b96:	8c 01       	movw	r16, r24
   16b98:	50 e8       	ldi	r21, 0x80	; 128
   16b9a:	f5 2a       	or	r15, r21
   16b9c:	f3 fe       	sbrs	r15, 3
   16b9e:	07 c0       	rjmp	.+14     	; 0x16bae <vfprintf+0x1a0>
   16ba0:	1a c0       	rjmp	.+52     	; 0x16bd6 <vfprintf+0x1c8>
   16ba2:	80 e2       	ldi	r24, 0x20	; 32
   16ba4:	90 e0       	ldi	r25, 0x00	; 0
   16ba6:	b3 01       	movw	r22, r6
   16ba8:	0e 94 fa b6 	call	0x16df4	; 0x16df4 <fputc>
   16bac:	ea 94       	dec	r14
   16bae:	8e 2d       	mov	r24, r14
   16bb0:	90 e0       	ldi	r25, 0x00	; 0
   16bb2:	08 17       	cp	r16, r24
   16bb4:	19 07       	cpc	r17, r25
   16bb6:	a8 f3       	brcs	.-22     	; 0x16ba2 <vfprintf+0x194>
   16bb8:	0e c0       	rjmp	.+28     	; 0x16bd6 <vfprintf+0x1c8>
   16bba:	f6 01       	movw	r30, r12
   16bbc:	f7 fc       	sbrc	r15, 7
   16bbe:	85 91       	lpm	r24, Z+
   16bc0:	f7 fe       	sbrs	r15, 7
   16bc2:	81 91       	ld	r24, Z+
   16bc4:	6f 01       	movw	r12, r30
   16bc6:	90 e0       	ldi	r25, 0x00	; 0
   16bc8:	b3 01       	movw	r22, r6
   16bca:	0e 94 fa b6 	call	0x16df4	; 0x16df4 <fputc>
   16bce:	e1 10       	cpse	r14, r1
   16bd0:	ea 94       	dec	r14
   16bd2:	01 50       	subi	r16, 0x01	; 1
   16bd4:	10 40       	sbci	r17, 0x00	; 0
   16bd6:	01 15       	cp	r16, r1
   16bd8:	11 05       	cpc	r17, r1
   16bda:	79 f7       	brne	.-34     	; 0x16bba <vfprintf+0x1ac>
   16bdc:	ea c0       	rjmp	.+468    	; 0x16db2 <vfprintf+0x3a4>
   16bde:	94 36       	cpi	r25, 0x64	; 100
   16be0:	11 f0       	breq	.+4      	; 0x16be6 <vfprintf+0x1d8>
   16be2:	99 36       	cpi	r25, 0x69	; 105
   16be4:	69 f5       	brne	.+90     	; 0x16c40 <vfprintf+0x232>
   16be6:	f7 fe       	sbrs	r15, 7
   16be8:	08 c0       	rjmp	.+16     	; 0x16bfa <vfprintf+0x1ec>
   16bea:	f5 01       	movw	r30, r10
   16bec:	20 81       	ld	r18, Z
   16bee:	31 81       	ldd	r19, Z+1	; 0x01
   16bf0:	42 81       	ldd	r20, Z+2	; 0x02
   16bf2:	53 81       	ldd	r21, Z+3	; 0x03
   16bf4:	84 e0       	ldi	r24, 0x04	; 4
   16bf6:	90 e0       	ldi	r25, 0x00	; 0
   16bf8:	0a c0       	rjmp	.+20     	; 0x16c0e <vfprintf+0x200>
   16bfa:	f5 01       	movw	r30, r10
   16bfc:	80 81       	ld	r24, Z
   16bfe:	91 81       	ldd	r25, Z+1	; 0x01
   16c00:	9c 01       	movw	r18, r24
   16c02:	44 27       	eor	r20, r20
   16c04:	37 fd       	sbrc	r19, 7
   16c06:	40 95       	com	r20
   16c08:	54 2f       	mov	r21, r20
   16c0a:	82 e0       	ldi	r24, 0x02	; 2
   16c0c:	90 e0       	ldi	r25, 0x00	; 0
   16c0e:	a8 0e       	add	r10, r24
   16c10:	b9 1e       	adc	r11, r25
   16c12:	9f e6       	ldi	r25, 0x6F	; 111
   16c14:	f9 22       	and	r15, r25
   16c16:	57 ff       	sbrs	r21, 7
   16c18:	09 c0       	rjmp	.+18     	; 0x16c2c <vfprintf+0x21e>
   16c1a:	50 95       	com	r21
   16c1c:	40 95       	com	r20
   16c1e:	30 95       	com	r19
   16c20:	21 95       	neg	r18
   16c22:	3f 4f       	sbci	r19, 0xFF	; 255
   16c24:	4f 4f       	sbci	r20, 0xFF	; 255
   16c26:	5f 4f       	sbci	r21, 0xFF	; 255
   16c28:	e0 e8       	ldi	r30, 0x80	; 128
   16c2a:	fe 2a       	or	r15, r30
   16c2c:	ca 01       	movw	r24, r20
   16c2e:	b9 01       	movw	r22, r18
   16c30:	a1 01       	movw	r20, r2
   16c32:	2a e0       	ldi	r18, 0x0A	; 10
   16c34:	30 e0       	ldi	r19, 0x00	; 0
   16c36:	0e 94 26 b7 	call	0x16e4c	; 0x16e4c <__ultoa_invert>
   16c3a:	d8 2e       	mov	r13, r24
   16c3c:	d2 18       	sub	r13, r2
   16c3e:	40 c0       	rjmp	.+128    	; 0x16cc0 <vfprintf+0x2b2>
   16c40:	95 37       	cpi	r25, 0x75	; 117
   16c42:	29 f4       	brne	.+10     	; 0x16c4e <vfprintf+0x240>
   16c44:	1f 2d       	mov	r17, r15
   16c46:	1f 7e       	andi	r17, 0xEF	; 239
   16c48:	2a e0       	ldi	r18, 0x0A	; 10
   16c4a:	30 e0       	ldi	r19, 0x00	; 0
   16c4c:	1d c0       	rjmp	.+58     	; 0x16c88 <vfprintf+0x27a>
   16c4e:	1f 2d       	mov	r17, r15
   16c50:	19 7f       	andi	r17, 0xF9	; 249
   16c52:	9f 36       	cpi	r25, 0x6F	; 111
   16c54:	61 f0       	breq	.+24     	; 0x16c6e <vfprintf+0x260>
   16c56:	90 37       	cpi	r25, 0x70	; 112
   16c58:	20 f4       	brcc	.+8      	; 0x16c62 <vfprintf+0x254>
   16c5a:	98 35       	cpi	r25, 0x58	; 88
   16c5c:	09 f0       	breq	.+2      	; 0x16c60 <vfprintf+0x252>
   16c5e:	ac c0       	rjmp	.+344    	; 0x16db8 <vfprintf+0x3aa>
   16c60:	0f c0       	rjmp	.+30     	; 0x16c80 <vfprintf+0x272>
   16c62:	90 37       	cpi	r25, 0x70	; 112
   16c64:	39 f0       	breq	.+14     	; 0x16c74 <vfprintf+0x266>
   16c66:	98 37       	cpi	r25, 0x78	; 120
   16c68:	09 f0       	breq	.+2      	; 0x16c6c <vfprintf+0x25e>
   16c6a:	a6 c0       	rjmp	.+332    	; 0x16db8 <vfprintf+0x3aa>
   16c6c:	04 c0       	rjmp	.+8      	; 0x16c76 <vfprintf+0x268>
   16c6e:	28 e0       	ldi	r18, 0x08	; 8
   16c70:	30 e0       	ldi	r19, 0x00	; 0
   16c72:	0a c0       	rjmp	.+20     	; 0x16c88 <vfprintf+0x27a>
   16c74:	10 61       	ori	r17, 0x10	; 16
   16c76:	14 fd       	sbrc	r17, 4
   16c78:	14 60       	ori	r17, 0x04	; 4
   16c7a:	20 e1       	ldi	r18, 0x10	; 16
   16c7c:	30 e0       	ldi	r19, 0x00	; 0
   16c7e:	04 c0       	rjmp	.+8      	; 0x16c88 <vfprintf+0x27a>
   16c80:	14 fd       	sbrc	r17, 4
   16c82:	16 60       	ori	r17, 0x06	; 6
   16c84:	20 e1       	ldi	r18, 0x10	; 16
   16c86:	32 e0       	ldi	r19, 0x02	; 2
   16c88:	17 ff       	sbrs	r17, 7
   16c8a:	08 c0       	rjmp	.+16     	; 0x16c9c <vfprintf+0x28e>
   16c8c:	f5 01       	movw	r30, r10
   16c8e:	60 81       	ld	r22, Z
   16c90:	71 81       	ldd	r23, Z+1	; 0x01
   16c92:	82 81       	ldd	r24, Z+2	; 0x02
   16c94:	93 81       	ldd	r25, Z+3	; 0x03
   16c96:	44 e0       	ldi	r20, 0x04	; 4
   16c98:	50 e0       	ldi	r21, 0x00	; 0
   16c9a:	08 c0       	rjmp	.+16     	; 0x16cac <vfprintf+0x29e>
   16c9c:	f5 01       	movw	r30, r10
   16c9e:	80 81       	ld	r24, Z
   16ca0:	91 81       	ldd	r25, Z+1	; 0x01
   16ca2:	bc 01       	movw	r22, r24
   16ca4:	80 e0       	ldi	r24, 0x00	; 0
   16ca6:	90 e0       	ldi	r25, 0x00	; 0
   16ca8:	42 e0       	ldi	r20, 0x02	; 2
   16caa:	50 e0       	ldi	r21, 0x00	; 0
   16cac:	a4 0e       	add	r10, r20
   16cae:	b5 1e       	adc	r11, r21
   16cb0:	a1 01       	movw	r20, r2
   16cb2:	0e 94 26 b7 	call	0x16e4c	; 0x16e4c <__ultoa_invert>
   16cb6:	d8 2e       	mov	r13, r24
   16cb8:	d2 18       	sub	r13, r2
   16cba:	8f e7       	ldi	r24, 0x7F	; 127
   16cbc:	f8 2e       	mov	r15, r24
   16cbe:	f1 22       	and	r15, r17
   16cc0:	f6 fe       	sbrs	r15, 6
   16cc2:	0b c0       	rjmp	.+22     	; 0x16cda <vfprintf+0x2cc>
   16cc4:	5e ef       	ldi	r21, 0xFE	; 254
   16cc6:	f5 22       	and	r15, r21
   16cc8:	d9 14       	cp	r13, r9
   16cca:	38 f4       	brcc	.+14     	; 0x16cda <vfprintf+0x2cc>
   16ccc:	f4 fe       	sbrs	r15, 4
   16cce:	07 c0       	rjmp	.+14     	; 0x16cde <vfprintf+0x2d0>
   16cd0:	f2 fc       	sbrc	r15, 2
   16cd2:	05 c0       	rjmp	.+10     	; 0x16cde <vfprintf+0x2d0>
   16cd4:	8f ee       	ldi	r24, 0xEF	; 239
   16cd6:	f8 22       	and	r15, r24
   16cd8:	02 c0       	rjmp	.+4      	; 0x16cde <vfprintf+0x2d0>
   16cda:	1d 2d       	mov	r17, r13
   16cdc:	01 c0       	rjmp	.+2      	; 0x16ce0 <vfprintf+0x2d2>
   16cde:	19 2d       	mov	r17, r9
   16ce0:	f4 fe       	sbrs	r15, 4
   16ce2:	0d c0       	rjmp	.+26     	; 0x16cfe <vfprintf+0x2f0>
   16ce4:	fe 01       	movw	r30, r28
   16ce6:	ed 0d       	add	r30, r13
   16ce8:	f1 1d       	adc	r31, r1
   16cea:	80 81       	ld	r24, Z
   16cec:	80 33       	cpi	r24, 0x30	; 48
   16cee:	19 f4       	brne	.+6      	; 0x16cf6 <vfprintf+0x2e8>
   16cf0:	99 ee       	ldi	r25, 0xE9	; 233
   16cf2:	f9 22       	and	r15, r25
   16cf4:	08 c0       	rjmp	.+16     	; 0x16d06 <vfprintf+0x2f8>
   16cf6:	1f 5f       	subi	r17, 0xFF	; 255
   16cf8:	f2 fe       	sbrs	r15, 2
   16cfa:	05 c0       	rjmp	.+10     	; 0x16d06 <vfprintf+0x2f8>
   16cfc:	03 c0       	rjmp	.+6      	; 0x16d04 <vfprintf+0x2f6>
   16cfe:	8f 2d       	mov	r24, r15
   16d00:	86 78       	andi	r24, 0x86	; 134
   16d02:	09 f0       	breq	.+2      	; 0x16d06 <vfprintf+0x2f8>
   16d04:	1f 5f       	subi	r17, 0xFF	; 255
   16d06:	0f 2d       	mov	r16, r15
   16d08:	f3 fc       	sbrc	r15, 3
   16d0a:	14 c0       	rjmp	.+40     	; 0x16d34 <vfprintf+0x326>
   16d0c:	f0 fe       	sbrs	r15, 0
   16d0e:	0f c0       	rjmp	.+30     	; 0x16d2e <vfprintf+0x320>
   16d10:	1e 15       	cp	r17, r14
   16d12:	10 f0       	brcs	.+4      	; 0x16d18 <vfprintf+0x30a>
   16d14:	9d 2c       	mov	r9, r13
   16d16:	0b c0       	rjmp	.+22     	; 0x16d2e <vfprintf+0x320>
   16d18:	9d 2c       	mov	r9, r13
   16d1a:	9e 0c       	add	r9, r14
   16d1c:	91 1a       	sub	r9, r17
   16d1e:	1e 2d       	mov	r17, r14
   16d20:	06 c0       	rjmp	.+12     	; 0x16d2e <vfprintf+0x320>
   16d22:	80 e2       	ldi	r24, 0x20	; 32
   16d24:	90 e0       	ldi	r25, 0x00	; 0
   16d26:	b3 01       	movw	r22, r6
   16d28:	0e 94 fa b6 	call	0x16df4	; 0x16df4 <fputc>
   16d2c:	1f 5f       	subi	r17, 0xFF	; 255
   16d2e:	1e 15       	cp	r17, r14
   16d30:	c0 f3       	brcs	.-16     	; 0x16d22 <vfprintf+0x314>
   16d32:	04 c0       	rjmp	.+8      	; 0x16d3c <vfprintf+0x32e>
   16d34:	1e 15       	cp	r17, r14
   16d36:	10 f4       	brcc	.+4      	; 0x16d3c <vfprintf+0x32e>
   16d38:	e1 1a       	sub	r14, r17
   16d3a:	01 c0       	rjmp	.+2      	; 0x16d3e <vfprintf+0x330>
   16d3c:	ee 24       	eor	r14, r14
   16d3e:	04 ff       	sbrs	r16, 4
   16d40:	0f c0       	rjmp	.+30     	; 0x16d60 <vfprintf+0x352>
   16d42:	80 e3       	ldi	r24, 0x30	; 48
   16d44:	90 e0       	ldi	r25, 0x00	; 0
   16d46:	b3 01       	movw	r22, r6
   16d48:	0e 94 fa b6 	call	0x16df4	; 0x16df4 <fputc>
   16d4c:	02 ff       	sbrs	r16, 2
   16d4e:	1d c0       	rjmp	.+58     	; 0x16d8a <vfprintf+0x37c>
   16d50:	01 fd       	sbrc	r16, 1
   16d52:	03 c0       	rjmp	.+6      	; 0x16d5a <vfprintf+0x34c>
   16d54:	88 e7       	ldi	r24, 0x78	; 120
   16d56:	90 e0       	ldi	r25, 0x00	; 0
   16d58:	0e c0       	rjmp	.+28     	; 0x16d76 <vfprintf+0x368>
   16d5a:	88 e5       	ldi	r24, 0x58	; 88
   16d5c:	90 e0       	ldi	r25, 0x00	; 0
   16d5e:	0b c0       	rjmp	.+22     	; 0x16d76 <vfprintf+0x368>
   16d60:	80 2f       	mov	r24, r16
   16d62:	86 78       	andi	r24, 0x86	; 134
   16d64:	91 f0       	breq	.+36     	; 0x16d8a <vfprintf+0x37c>
   16d66:	01 ff       	sbrs	r16, 1
   16d68:	02 c0       	rjmp	.+4      	; 0x16d6e <vfprintf+0x360>
   16d6a:	8b e2       	ldi	r24, 0x2B	; 43
   16d6c:	01 c0       	rjmp	.+2      	; 0x16d70 <vfprintf+0x362>
   16d6e:	80 e2       	ldi	r24, 0x20	; 32
   16d70:	f7 fc       	sbrc	r15, 7
   16d72:	8d e2       	ldi	r24, 0x2D	; 45
   16d74:	90 e0       	ldi	r25, 0x00	; 0
   16d76:	b3 01       	movw	r22, r6
   16d78:	0e 94 fa b6 	call	0x16df4	; 0x16df4 <fputc>
   16d7c:	06 c0       	rjmp	.+12     	; 0x16d8a <vfprintf+0x37c>
   16d7e:	80 e3       	ldi	r24, 0x30	; 48
   16d80:	90 e0       	ldi	r25, 0x00	; 0
   16d82:	b3 01       	movw	r22, r6
   16d84:	0e 94 fa b6 	call	0x16df4	; 0x16df4 <fputc>
   16d88:	9a 94       	dec	r9
   16d8a:	d9 14       	cp	r13, r9
   16d8c:	c0 f3       	brcs	.-16     	; 0x16d7e <vfprintf+0x370>
   16d8e:	da 94       	dec	r13
   16d90:	f1 01       	movw	r30, r2
   16d92:	ed 0d       	add	r30, r13
   16d94:	f1 1d       	adc	r31, r1
   16d96:	80 81       	ld	r24, Z
   16d98:	90 e0       	ldi	r25, 0x00	; 0
   16d9a:	b3 01       	movw	r22, r6
   16d9c:	0e 94 fa b6 	call	0x16df4	; 0x16df4 <fputc>
   16da0:	dd 20       	and	r13, r13
   16da2:	a9 f7       	brne	.-22     	; 0x16d8e <vfprintf+0x380>
   16da4:	06 c0       	rjmp	.+12     	; 0x16db2 <vfprintf+0x3a4>
   16da6:	80 e2       	ldi	r24, 0x20	; 32
   16da8:	90 e0       	ldi	r25, 0x00	; 0
   16daa:	b3 01       	movw	r22, r6
   16dac:	0e 94 fa b6 	call	0x16df4	; 0x16df4 <fputc>
   16db0:	ea 94       	dec	r14
   16db2:	ee 20       	and	r14, r14
   16db4:	c1 f7       	brne	.-16     	; 0x16da6 <vfprintf+0x398>
   16db6:	43 ce       	rjmp	.-890    	; 0x16a3e <vfprintf+0x30>
   16db8:	f3 01       	movw	r30, r6
   16dba:	66 81       	ldd	r22, Z+6	; 0x06
   16dbc:	77 81       	ldd	r23, Z+7	; 0x07
   16dbe:	cb 01       	movw	r24, r22
   16dc0:	2b 96       	adiw	r28, 0x0b	; 11
   16dc2:	e2 e1       	ldi	r30, 0x12	; 18
   16dc4:	0c 94 21 b8 	jmp	0x17042	; 0x17042 <__epilogue_restores__>

00016dc8 <strnlen_P>:
   16dc8:	fc 01       	movw	r30, r24
   16dca:	05 90       	lpm	r0, Z+
   16dcc:	61 50       	subi	r22, 0x01	; 1
   16dce:	70 40       	sbci	r23, 0x00	; 0
   16dd0:	01 10       	cpse	r0, r1
   16dd2:	d8 f7       	brcc	.-10     	; 0x16dca <strnlen_P+0x2>
   16dd4:	80 95       	com	r24
   16dd6:	90 95       	com	r25
   16dd8:	8e 0f       	add	r24, r30
   16dda:	9f 1f       	adc	r25, r31
   16ddc:	08 95       	ret

00016dde <strnlen>:
   16dde:	fc 01       	movw	r30, r24
   16de0:	61 50       	subi	r22, 0x01	; 1
   16de2:	70 40       	sbci	r23, 0x00	; 0
   16de4:	01 90       	ld	r0, Z+
   16de6:	01 10       	cpse	r0, r1
   16de8:	d8 f7       	brcc	.-10     	; 0x16de0 <strnlen+0x2>
   16dea:	80 95       	com	r24
   16dec:	90 95       	com	r25
   16dee:	8e 0f       	add	r24, r30
   16df0:	9f 1f       	adc	r25, r31
   16df2:	08 95       	ret

00016df4 <fputc>:
   16df4:	0f 93       	push	r16
   16df6:	1f 93       	push	r17
   16df8:	cf 93       	push	r28
   16dfa:	df 93       	push	r29
   16dfc:	8c 01       	movw	r16, r24
   16dfe:	eb 01       	movw	r28, r22
   16e00:	8b 81       	ldd	r24, Y+3	; 0x03
   16e02:	81 ff       	sbrs	r24, 1
   16e04:	1b c0       	rjmp	.+54     	; 0x16e3c <fputc+0x48>
   16e06:	82 ff       	sbrs	r24, 2
   16e08:	0d c0       	rjmp	.+26     	; 0x16e24 <fputc+0x30>
   16e0a:	2e 81       	ldd	r18, Y+6	; 0x06
   16e0c:	3f 81       	ldd	r19, Y+7	; 0x07
   16e0e:	8c 81       	ldd	r24, Y+4	; 0x04
   16e10:	9d 81       	ldd	r25, Y+5	; 0x05
   16e12:	28 17       	cp	r18, r24
   16e14:	39 07       	cpc	r19, r25
   16e16:	64 f4       	brge	.+24     	; 0x16e30 <fputc+0x3c>
   16e18:	e8 81       	ld	r30, Y
   16e1a:	f9 81       	ldd	r31, Y+1	; 0x01
   16e1c:	01 93       	st	Z+, r16
   16e1e:	f9 83       	std	Y+1, r31	; 0x01
   16e20:	e8 83       	st	Y, r30
   16e22:	06 c0       	rjmp	.+12     	; 0x16e30 <fputc+0x3c>
   16e24:	e8 85       	ldd	r30, Y+8	; 0x08
   16e26:	f9 85       	ldd	r31, Y+9	; 0x09
   16e28:	80 2f       	mov	r24, r16
   16e2a:	09 95       	icall
   16e2c:	89 2b       	or	r24, r25
   16e2e:	31 f4       	brne	.+12     	; 0x16e3c <fputc+0x48>
   16e30:	8e 81       	ldd	r24, Y+6	; 0x06
   16e32:	9f 81       	ldd	r25, Y+7	; 0x07
   16e34:	01 96       	adiw	r24, 0x01	; 1
   16e36:	9f 83       	std	Y+7, r25	; 0x07
   16e38:	8e 83       	std	Y+6, r24	; 0x06
   16e3a:	02 c0       	rjmp	.+4      	; 0x16e40 <fputc+0x4c>
   16e3c:	0f ef       	ldi	r16, 0xFF	; 255
   16e3e:	1f ef       	ldi	r17, 0xFF	; 255
   16e40:	c8 01       	movw	r24, r16
   16e42:	df 91       	pop	r29
   16e44:	cf 91       	pop	r28
   16e46:	1f 91       	pop	r17
   16e48:	0f 91       	pop	r16
   16e4a:	08 95       	ret

00016e4c <__ultoa_invert>:
   16e4c:	fa 01       	movw	r30, r20
   16e4e:	aa 27       	eor	r26, r26
   16e50:	28 30       	cpi	r18, 0x08	; 8
   16e52:	51 f1       	breq	.+84     	; 0x16ea8 <__ultoa_invert+0x5c>
   16e54:	20 31       	cpi	r18, 0x10	; 16
   16e56:	81 f1       	breq	.+96     	; 0x16eb8 <__ultoa_invert+0x6c>
   16e58:	e8 94       	clt
   16e5a:	6f 93       	push	r22
   16e5c:	6e 7f       	andi	r22, 0xFE	; 254
   16e5e:	6e 5f       	subi	r22, 0xFE	; 254
   16e60:	7f 4f       	sbci	r23, 0xFF	; 255
   16e62:	8f 4f       	sbci	r24, 0xFF	; 255
   16e64:	9f 4f       	sbci	r25, 0xFF	; 255
   16e66:	af 4f       	sbci	r26, 0xFF	; 255
   16e68:	b1 e0       	ldi	r27, 0x01	; 1
   16e6a:	3e d0       	rcall	.+124    	; 0x16ee8 <__ultoa_invert+0x9c>
   16e6c:	b4 e0       	ldi	r27, 0x04	; 4
   16e6e:	3c d0       	rcall	.+120    	; 0x16ee8 <__ultoa_invert+0x9c>
   16e70:	67 0f       	add	r22, r23
   16e72:	78 1f       	adc	r23, r24
   16e74:	89 1f       	adc	r24, r25
   16e76:	9a 1f       	adc	r25, r26
   16e78:	a1 1d       	adc	r26, r1
   16e7a:	68 0f       	add	r22, r24
   16e7c:	79 1f       	adc	r23, r25
   16e7e:	8a 1f       	adc	r24, r26
   16e80:	91 1d       	adc	r25, r1
   16e82:	a1 1d       	adc	r26, r1
   16e84:	6a 0f       	add	r22, r26
   16e86:	71 1d       	adc	r23, r1
   16e88:	81 1d       	adc	r24, r1
   16e8a:	91 1d       	adc	r25, r1
   16e8c:	a1 1d       	adc	r26, r1
   16e8e:	20 d0       	rcall	.+64     	; 0x16ed0 <__ultoa_invert+0x84>
   16e90:	09 f4       	brne	.+2      	; 0x16e94 <__ultoa_invert+0x48>
   16e92:	68 94       	set
   16e94:	3f 91       	pop	r19
   16e96:	2a e0       	ldi	r18, 0x0A	; 10
   16e98:	26 9f       	mul	r18, r22
   16e9a:	11 24       	eor	r1, r1
   16e9c:	30 19       	sub	r19, r0
   16e9e:	30 5d       	subi	r19, 0xD0	; 208
   16ea0:	31 93       	st	Z+, r19
   16ea2:	de f6       	brtc	.-74     	; 0x16e5a <__ultoa_invert+0xe>
   16ea4:	cf 01       	movw	r24, r30
   16ea6:	08 95       	ret
   16ea8:	46 2f       	mov	r20, r22
   16eaa:	47 70       	andi	r20, 0x07	; 7
   16eac:	40 5d       	subi	r20, 0xD0	; 208
   16eae:	41 93       	st	Z+, r20
   16eb0:	b3 e0       	ldi	r27, 0x03	; 3
   16eb2:	0f d0       	rcall	.+30     	; 0x16ed2 <__ultoa_invert+0x86>
   16eb4:	c9 f7       	brne	.-14     	; 0x16ea8 <__ultoa_invert+0x5c>
   16eb6:	f6 cf       	rjmp	.-20     	; 0x16ea4 <__ultoa_invert+0x58>
   16eb8:	46 2f       	mov	r20, r22
   16eba:	4f 70       	andi	r20, 0x0F	; 15
   16ebc:	40 5d       	subi	r20, 0xD0	; 208
   16ebe:	4a 33       	cpi	r20, 0x3A	; 58
   16ec0:	18 f0       	brcs	.+6      	; 0x16ec8 <__ultoa_invert+0x7c>
   16ec2:	49 5d       	subi	r20, 0xD9	; 217
   16ec4:	31 fd       	sbrc	r19, 1
   16ec6:	40 52       	subi	r20, 0x20	; 32
   16ec8:	41 93       	st	Z+, r20
   16eca:	02 d0       	rcall	.+4      	; 0x16ed0 <__ultoa_invert+0x84>
   16ecc:	a9 f7       	brne	.-22     	; 0x16eb8 <__ultoa_invert+0x6c>
   16ece:	ea cf       	rjmp	.-44     	; 0x16ea4 <__ultoa_invert+0x58>
   16ed0:	b4 e0       	ldi	r27, 0x04	; 4
   16ed2:	a6 95       	lsr	r26
   16ed4:	97 95       	ror	r25
   16ed6:	87 95       	ror	r24
   16ed8:	77 95       	ror	r23
   16eda:	67 95       	ror	r22
   16edc:	ba 95       	dec	r27
   16ede:	c9 f7       	brne	.-14     	; 0x16ed2 <__ultoa_invert+0x86>
   16ee0:	00 97       	sbiw	r24, 0x00	; 0
   16ee2:	61 05       	cpc	r22, r1
   16ee4:	71 05       	cpc	r23, r1
   16ee6:	08 95       	ret
   16ee8:	9b 01       	movw	r18, r22
   16eea:	ac 01       	movw	r20, r24
   16eec:	0a 2e       	mov	r0, r26
   16eee:	06 94       	lsr	r0
   16ef0:	57 95       	ror	r21
   16ef2:	47 95       	ror	r20
   16ef4:	37 95       	ror	r19
   16ef6:	27 95       	ror	r18
   16ef8:	ba 95       	dec	r27
   16efa:	c9 f7       	brne	.-14     	; 0x16eee <__ultoa_invert+0xa2>
   16efc:	62 0f       	add	r22, r18
   16efe:	73 1f       	adc	r23, r19
   16f00:	84 1f       	adc	r24, r20
   16f02:	95 1f       	adc	r25, r21
   16f04:	a0 1d       	adc	r26, r0
   16f06:	08 95       	ret

00016f08 <__mulsi3>:
   16f08:	62 9f       	mul	r22, r18
   16f0a:	d0 01       	movw	r26, r0
   16f0c:	73 9f       	mul	r23, r19
   16f0e:	f0 01       	movw	r30, r0
   16f10:	82 9f       	mul	r24, r18
   16f12:	e0 0d       	add	r30, r0
   16f14:	f1 1d       	adc	r31, r1
   16f16:	64 9f       	mul	r22, r20
   16f18:	e0 0d       	add	r30, r0
   16f1a:	f1 1d       	adc	r31, r1
   16f1c:	92 9f       	mul	r25, r18
   16f1e:	f0 0d       	add	r31, r0
   16f20:	83 9f       	mul	r24, r19
   16f22:	f0 0d       	add	r31, r0
   16f24:	74 9f       	mul	r23, r20
   16f26:	f0 0d       	add	r31, r0
   16f28:	65 9f       	mul	r22, r21
   16f2a:	f0 0d       	add	r31, r0
   16f2c:	99 27       	eor	r25, r25
   16f2e:	72 9f       	mul	r23, r18
   16f30:	b0 0d       	add	r27, r0
   16f32:	e1 1d       	adc	r30, r1
   16f34:	f9 1f       	adc	r31, r25
   16f36:	63 9f       	mul	r22, r19
   16f38:	b0 0d       	add	r27, r0
   16f3a:	e1 1d       	adc	r30, r1
   16f3c:	f9 1f       	adc	r31, r25
   16f3e:	bd 01       	movw	r22, r26
   16f40:	cf 01       	movw	r24, r30
   16f42:	11 24       	eor	r1, r1
   16f44:	08 95       	ret

00016f46 <__udivmodqi4>:
   16f46:	99 1b       	sub	r25, r25
   16f48:	79 e0       	ldi	r23, 0x09	; 9
   16f4a:	04 c0       	rjmp	.+8      	; 0x16f54 <__udivmodqi4_ep>

00016f4c <__udivmodqi4_loop>:
   16f4c:	99 1f       	adc	r25, r25
   16f4e:	96 17       	cp	r25, r22
   16f50:	08 f0       	brcs	.+2      	; 0x16f54 <__udivmodqi4_ep>
   16f52:	96 1b       	sub	r25, r22

00016f54 <__udivmodqi4_ep>:
   16f54:	88 1f       	adc	r24, r24
   16f56:	7a 95       	dec	r23
   16f58:	c9 f7       	brne	.-14     	; 0x16f4c <__udivmodqi4_loop>
   16f5a:	80 95       	com	r24
   16f5c:	08 95       	ret

00016f5e <__divmodqi4>:
   16f5e:	87 fb       	bst	r24, 7
   16f60:	08 2e       	mov	r0, r24
   16f62:	06 26       	eor	r0, r22
   16f64:	87 fd       	sbrc	r24, 7
   16f66:	81 95       	neg	r24
   16f68:	67 fd       	sbrc	r22, 7
   16f6a:	61 95       	neg	r22
   16f6c:	ec df       	rcall	.-40     	; 0x16f46 <__udivmodqi4>
   16f6e:	0e f4       	brtc	.+2      	; 0x16f72 <__divmodqi4_1>
   16f70:	91 95       	neg	r25

00016f72 <__divmodqi4_1>:
   16f72:	07 fc       	sbrc	r0, 7
   16f74:	81 95       	neg	r24

00016f76 <__divmodqi4_exit>:
   16f76:	08 95       	ret

00016f78 <__udivmodhi4>:
   16f78:	aa 1b       	sub	r26, r26
   16f7a:	bb 1b       	sub	r27, r27
   16f7c:	51 e1       	ldi	r21, 0x11	; 17
   16f7e:	07 c0       	rjmp	.+14     	; 0x16f8e <__udivmodhi4_ep>

00016f80 <__udivmodhi4_loop>:
   16f80:	aa 1f       	adc	r26, r26
   16f82:	bb 1f       	adc	r27, r27
   16f84:	a6 17       	cp	r26, r22
   16f86:	b7 07       	cpc	r27, r23
   16f88:	10 f0       	brcs	.+4      	; 0x16f8e <__udivmodhi4_ep>
   16f8a:	a6 1b       	sub	r26, r22
   16f8c:	b7 0b       	sbc	r27, r23

00016f8e <__udivmodhi4_ep>:
   16f8e:	88 1f       	adc	r24, r24
   16f90:	99 1f       	adc	r25, r25
   16f92:	5a 95       	dec	r21
   16f94:	a9 f7       	brne	.-22     	; 0x16f80 <__udivmodhi4_loop>
   16f96:	80 95       	com	r24
   16f98:	90 95       	com	r25
   16f9a:	bc 01       	movw	r22, r24
   16f9c:	cd 01       	movw	r24, r26
   16f9e:	08 95       	ret

00016fa0 <__divmodhi4>:
   16fa0:	97 fb       	bst	r25, 7
   16fa2:	09 2e       	mov	r0, r25
   16fa4:	07 26       	eor	r0, r23
   16fa6:	0a d0       	rcall	.+20     	; 0x16fbc <__divmodhi4_neg1>
   16fa8:	77 fd       	sbrc	r23, 7
   16faa:	04 d0       	rcall	.+8      	; 0x16fb4 <__divmodhi4_neg2>
   16fac:	e5 df       	rcall	.-54     	; 0x16f78 <__udivmodhi4>
   16fae:	06 d0       	rcall	.+12     	; 0x16fbc <__divmodhi4_neg1>
   16fb0:	00 20       	and	r0, r0
   16fb2:	1a f4       	brpl	.+6      	; 0x16fba <__divmodhi4_exit>

00016fb4 <__divmodhi4_neg2>:
   16fb4:	70 95       	com	r23
   16fb6:	61 95       	neg	r22
   16fb8:	7f 4f       	sbci	r23, 0xFF	; 255

00016fba <__divmodhi4_exit>:
   16fba:	08 95       	ret

00016fbc <__divmodhi4_neg1>:
   16fbc:	f6 f7       	brtc	.-4      	; 0x16fba <__divmodhi4_exit>
   16fbe:	90 95       	com	r25
   16fc0:	81 95       	neg	r24
   16fc2:	9f 4f       	sbci	r25, 0xFF	; 255
   16fc4:	08 95       	ret

00016fc6 <__udivmodsi4>:
   16fc6:	a1 e2       	ldi	r26, 0x21	; 33
   16fc8:	1a 2e       	mov	r1, r26
   16fca:	aa 1b       	sub	r26, r26
   16fcc:	bb 1b       	sub	r27, r27
   16fce:	fd 01       	movw	r30, r26
   16fd0:	0d c0       	rjmp	.+26     	; 0x16fec <__udivmodsi4_ep>

00016fd2 <__udivmodsi4_loop>:
   16fd2:	aa 1f       	adc	r26, r26
   16fd4:	bb 1f       	adc	r27, r27
   16fd6:	ee 1f       	adc	r30, r30
   16fd8:	ff 1f       	adc	r31, r31
   16fda:	a2 17       	cp	r26, r18
   16fdc:	b3 07       	cpc	r27, r19
   16fde:	e4 07       	cpc	r30, r20
   16fe0:	f5 07       	cpc	r31, r21
   16fe2:	20 f0       	brcs	.+8      	; 0x16fec <__udivmodsi4_ep>
   16fe4:	a2 1b       	sub	r26, r18
   16fe6:	b3 0b       	sbc	r27, r19
   16fe8:	e4 0b       	sbc	r30, r20
   16fea:	f5 0b       	sbc	r31, r21

00016fec <__udivmodsi4_ep>:
   16fec:	66 1f       	adc	r22, r22
   16fee:	77 1f       	adc	r23, r23
   16ff0:	88 1f       	adc	r24, r24
   16ff2:	99 1f       	adc	r25, r25
   16ff4:	1a 94       	dec	r1
   16ff6:	69 f7       	brne	.-38     	; 0x16fd2 <__udivmodsi4_loop>
   16ff8:	60 95       	com	r22
   16ffa:	70 95       	com	r23
   16ffc:	80 95       	com	r24
   16ffe:	90 95       	com	r25
   17000:	9b 01       	movw	r18, r22
   17002:	ac 01       	movw	r20, r24
   17004:	bd 01       	movw	r22, r26
   17006:	cf 01       	movw	r24, r30
   17008:	08 95       	ret

0001700a <__prologue_saves__>:
   1700a:	2f 92       	push	r2
   1700c:	3f 92       	push	r3
   1700e:	4f 92       	push	r4
   17010:	5f 92       	push	r5
   17012:	6f 92       	push	r6
   17014:	7f 92       	push	r7
   17016:	8f 92       	push	r8
   17018:	9f 92       	push	r9
   1701a:	af 92       	push	r10
   1701c:	bf 92       	push	r11
   1701e:	cf 92       	push	r12
   17020:	df 92       	push	r13
   17022:	ef 92       	push	r14
   17024:	ff 92       	push	r15
   17026:	0f 93       	push	r16
   17028:	1f 93       	push	r17
   1702a:	cf 93       	push	r28
   1702c:	df 93       	push	r29
   1702e:	cd b7       	in	r28, 0x3d	; 61
   17030:	de b7       	in	r29, 0x3e	; 62
   17032:	ca 1b       	sub	r28, r26
   17034:	db 0b       	sbc	r29, r27
   17036:	0f b6       	in	r0, 0x3f	; 63
   17038:	f8 94       	cli
   1703a:	de bf       	out	0x3e, r29	; 62
   1703c:	0f be       	out	0x3f, r0	; 63
   1703e:	cd bf       	out	0x3d, r28	; 61
   17040:	09 94       	ijmp

00017042 <__epilogue_restores__>:
   17042:	2a 88       	ldd	r2, Y+18	; 0x12
   17044:	39 88       	ldd	r3, Y+17	; 0x11
   17046:	48 88       	ldd	r4, Y+16	; 0x10
   17048:	5f 84       	ldd	r5, Y+15	; 0x0f
   1704a:	6e 84       	ldd	r6, Y+14	; 0x0e
   1704c:	7d 84       	ldd	r7, Y+13	; 0x0d
   1704e:	8c 84       	ldd	r8, Y+12	; 0x0c
   17050:	9b 84       	ldd	r9, Y+11	; 0x0b
   17052:	aa 84       	ldd	r10, Y+10	; 0x0a
   17054:	b9 84       	ldd	r11, Y+9	; 0x09
   17056:	c8 84       	ldd	r12, Y+8	; 0x08
   17058:	df 80       	ldd	r13, Y+7	; 0x07
   1705a:	ee 80       	ldd	r14, Y+6	; 0x06
   1705c:	fd 80       	ldd	r15, Y+5	; 0x05
   1705e:	0c 81       	ldd	r16, Y+4	; 0x04
   17060:	1b 81       	ldd	r17, Y+3	; 0x03
   17062:	aa 81       	ldd	r26, Y+2	; 0x02
   17064:	b9 81       	ldd	r27, Y+1	; 0x01
   17066:	ce 0f       	add	r28, r30
   17068:	d1 1d       	adc	r29, r1
   1706a:	0f b6       	in	r0, 0x3f	; 63
   1706c:	f8 94       	cli
   1706e:	de bf       	out	0x3e, r29	; 62
   17070:	0f be       	out	0x3f, r0	; 63
   17072:	cd bf       	out	0x3d, r28	; 61
   17074:	ed 01       	movw	r28, r26
   17076:	08 95       	ret

00017078 <_exit>:
   17078:	f8 94       	cli

0001707a <__stop_program>:
   1707a:	ff cf       	rjmp	.-2      	; 0x1707a <__stop_program>
