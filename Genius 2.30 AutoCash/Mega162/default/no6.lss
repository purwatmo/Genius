
no6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800100  00003df4  00003ea8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003df4  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000329  0080010e  0080010e  00003eb6  2**0
                  ALLOC
  3 .eeprom       0000001e  00810000  00810000  00003eb6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000060  00000000  00000000  00003ed4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00000beb  00000000  00000000  00003f34  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000041c3  00000000  00000000  00004b1f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000005af  00000000  00000000  00008ce2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000319a  00000000  00000000  00009291  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000510  00000000  00000000  0000c42c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000196a  00000000  00000000  0000c93c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000251e  00000000  00000000  0000e2a6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000420  00000000  00000000  000107c4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__ctors_end>
       4:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
       8:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
       c:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      10:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      14:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      18:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      1c:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      20:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      24:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      28:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      2c:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      30:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      34:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      38:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      3c:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      40:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      44:	0c 94 70 01 	jmp	0x2e0	; 0x2e0 <__vector_17>
      48:	0c 94 59 1a 	jmp	0x34b2	; 0x34b2 <__vector_18>
      4c:	0c 94 ac 07 	jmp	0xf58	; 0xf58 <__vector_19>
      50:	0c 94 7c 07 	jmp	0xef8	; 0xef8 <__vector_20>
      54:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      58:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      5c:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      60:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      64:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      68:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      6c:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__bad_interrupt>
      70:	56 0e       	add	r5, r22
      72:	a9 0e       	add	r10, r25
      74:	cc 0e       	add	r12, r28
      76:	f9 0e       	add	r15, r25
      78:	ff 0e       	add	r15, r31
      7a:	0a 0f       	add	r16, r26
      7c:	1f 0f       	add	r17, r31
      7e:	5f 0f       	add	r21, r31
      80:	eb 0f       	add	r30, r27
      82:	61 10       	cpse	r6, r1
      84:	8a 10       	cpse	r8, r10
      86:	2f 10       	cpse	r2, r15
      88:	f2 0f       	add	r31, r18
      8a:	ff 0f       	add	r31, r31
      8c:	37 10       	cpse	r3, r7
      8e:	44 10       	cpse	r4, r4
      90:	46 11       	cpse	r20, r6
      92:	90 10       	cpse	r9, r0
      94:	9d 10       	cpse	r9, r13
      96:	c2 10       	cpse	r12, r2
      98:	46 11       	cpse	r20, r6
      9a:	6f 10       	cpse	r6, r15
      9c:	c4 10       	cpse	r12, r4
      9e:	86 0f       	add	r24, r22
      a0:	94 0f       	add	r25, r20
      a2:	7b 10       	cpse	r7, r11
      a4:	e4 10       	cpse	r14, r4
      a6:	f7 10       	cpse	r15, r7
      a8:	fd 10       	cpse	r15, r13
      aa:	0a 11       	cpse	r16, r10
      ac:	2e 11       	cpse	r18, r14
      ae:	30 11       	cpse	r19, r0
      b0:	3c 11       	cpse	r19, r12
      b2:	bd 11       	cpse	r27, r13
      b4:	0d 12       	cpse	r0, r29
      b6:	47 12       	cpse	r4, r23
      b8:	56 12       	cpse	r5, r22
      ba:	8e 12       	cpse	r8, r30
      bc:	a4 12       	cpse	r10, r20
      be:	b6 12       	cpse	r11, r22
      c0:	c4 12       	cpse	r12, r20
      c2:	02 15       	cp	r16, r2
      c4:	bc 13       	cpse	r27, r28
      c6:	ce 13       	cpse	r28, r30
      c8:	f6 13       	cpse	r31, r22
      ca:	02 14       	cp	r0, r2
      cc:	0e 14       	cp	r0, r14
      ce:	5b 13       	cpse	r21, r27
      d0:	6d 13       	cpse	r22, r29
      d2:	8b 13       	cpse	r24, r27
      d4:	97 13       	cpse	r25, r23
      d6:	1f 14       	cp	r1, r15
      d8:	33 14       	cp	r3, r3
      da:	72 14       	cp	r7, r2
      dc:	7f 14       	cp	r7, r15
      de:	81 14       	cp	r8, r1
      e0:	88 14       	cp	r8, r8
      e2:	92 14       	cp	r9, r2
      e4:	9f 14       	cp	r9, r15
      e6:	a5 14       	cp	r10, r5
      e8:	b4 14       	cp	r11, r4
      ea:	05 17       	cp	r16, r21
      ec:	21 17       	cp	r18, r17
      ee:	44 1a       	sub	r4, r20
      f0:	1d 18       	sub	r1, r13
      f2:	94 17       	cp	r25, r20
      f4:	be 17       	cp	r27, r30
      f6:	44 1a       	sub	r4, r20
      f8:	44 1a       	sub	r4, r20
      fa:	4a 18       	sub	r4, r10
      fc:	8a 18       	sub	r8, r10
      fe:	44 1a       	sub	r4, r20
     100:	44 1a       	sub	r4, r20
     102:	b5 18       	sub	r11, r5
     104:	44 1a       	sub	r4, r20
     106:	98 19       	sub	r25, r8
     108:	9d 19       	sub	r25, r13
     10a:	a2 19       	sub	r26, r2
     10c:	44 1a       	sub	r4, r20
     10e:	44 1a       	sub	r4, r20
     110:	bb 18       	sub	r11, r11
     112:	f0 18       	sub	r15, r0
     114:	1a 19       	sub	r17, r10
     116:	44 19       	sub	r20, r4
     118:	6e 19       	sub	r22, r14
     11a:	44 1a       	sub	r4, r20
     11c:	44 1a       	sub	r4, r20
     11e:	ab 19       	sub	r26, r11
     120:	4b 17       	cp	r20, r27
     122:	e5 19       	sub	r30, r5
     124:	0a 1a       	sub	r0, r26
     126:	3e 1a       	sub	r3, r30
     128:	42 1a       	sub	r4, r18

0000012a <__c.3520>:
     12a:	49 6e 69 74 69 61 6c 69 7a 65 64 00                 Initialized.

00000136 <__c.3158>:
     136:	25 64 00                                            %d.

00000139 <__c.3153>:
     139:	25 73 25 73 00                                      %s%s.

0000013e <__c.3151>:
     13e:	30 32 25 2e 32 64 00                                02%.2d.

00000145 <__c.3121>:
     145:	25 64 00                                            %d.

00000148 <__c.3116>:
     148:	30 31 25 2e 32 64 25 2e 31 64 25 2e 31 64 25 73     01%.2d%.1d%.1d%s
     158:	25 73 25 73 00                                      %s%s.

0000015d <__c.2970>:
     15d:	54 78 50 75 6d 70 49 44 3a 25 64 00                 TxPumpID:%d.

00000169 <__c.2964>:
     169:	50 6f 6f 6c 52 65 73 74 61 72 74 65 64 00           PoolRestarted.

00000177 <__c.2962>:
     177:	47 50 6f 6f 6c 3a 25 64 00                          GPool:%d.

00000180 <__c.2871>:
     180:	54 78 50 75 6d 70 49 44 3a 25 64 00                 TxPumpID:%d.

0000018c <__c.2817>:
     18c:	54 78 50 75 6d 70 49 44 3a 25 64 00                 TxPumpID:%d.

00000198 <__c.2812>:
     198:	50 6f 6f 6c 52 65 73 74 61 72 74 65 64 00           PoolRestarted.

000001a6 <__c.2810>:
     1a6:	57 50 6f 6f 6c 3a 25 64 00                          WPool:%d.

000001af <__c.2435>:
     1af:	53 43 5f 43 4c 45 41 52 5f 50 55 4d 50 49 44 3a     SC_CLEAR_PUMPID:
     1bf:	5b 25 2e 32 58 5d 00                                [%.2X].

000001c6 <__c.2432>:
     1c6:	53 43 5f 53 45 54 5f 50 55 4d 50 49 44 3a 5b 25     SC_SET_PUMPID:[%
     1d6:	2e 32 58 5d 00                                      .2X].

000001db <__c.2429>:
     1db:	50 6f 6f 6c 54 72 79 53 65 6e 64 3a 25 64 00        PoolTrySend:%d.

000001ea <__c.2423>:
     1ea:	44 65 6c 61 79 4e 65 78 74 50 75 6d 70 3a 25 64     DelayNextPump:%d
	...

000001fb <__c.2420>:
     1fb:	50 6f 6f 6c 54 69 6d 65 6f 75 74 3a 25 64 00        PoolTimeout:%d.

0000020a <__c.2417>:
     20a:	50 6f 6f 6c 54 72 79 53 65 6e 64 3a 25 64 00        PoolTrySend:%d.

00000219 <__c.2414>:
     219:	4d 61 78 50 75 6d 70 3a 25 64 00                    MaxPump:%d.

00000224 <__c.2411>:
     224:	4e 6f 50 75 6d 70 43 6f 75 6e 74 3a 25 64 00        NoPumpCount:%d.

00000233 <__c.2407>:
     233:	50 75 6d 70 55 6e 4c 6f 63 6b 3a 25 64 00           PumpUnLock:%d.

00000241 <__c.2401>:
     241:	50 75 6d 70 4c 6f 63 6b 3a 25 64 00                 PumpLock:%d.

0000024d <__c.2395>:
     24d:	52 65 71 54 72 61 6e 73 3a 25 64 00                 ReqTrans:%d.

00000259 <__c.2389>:
     259:	43 4f 4d 3a 25 64 2c 25 69 00                       COM:%d,%i.

00000263 <__c.2383>:
     263:	50 55 4d 50 41 4c 4c 00                             PUMPALL.

0000026b <__c.2381>:
     26b:	53 43 5f 54 4f 54 41 4c 49 5a 45 52 00              SC_TOTALIZER.

00000278 <__c.2378>:
     278:	53 43 5f 53 45 54 5f 50 55 4d 50 5f 54 59 50 45     SC_SET_PUMP_TYPE
	...

00000289 <__c.2376>:
     289:	50 75 6d 70 3a 25 64 00                             Pump:%d.

00000291 <__c.2373>:
     291:	53 74 61 6e 64 61 6c 6f 6e 65 00                    Standalone.

0000029c <__c.2369>:
     29c:	53 6c 61 76 65 00                                   Slave.

000002a2 <__ctors_end>:
     2a2:	11 24       	eor	r1, r1
     2a4:	1f be       	out	0x3f, r1	; 63
     2a6:	cf ef       	ldi	r28, 0xFF	; 255
     2a8:	d4 e0       	ldi	r29, 0x04	; 4
     2aa:	de bf       	out	0x3e, r29	; 62
     2ac:	cd bf       	out	0x3d, r28	; 61

000002ae <__do_copy_data>:
     2ae:	11 e0       	ldi	r17, 0x01	; 1
     2b0:	a0 e0       	ldi	r26, 0x00	; 0
     2b2:	b1 e0       	ldi	r27, 0x01	; 1
     2b4:	e4 ef       	ldi	r30, 0xF4	; 244
     2b6:	fd e3       	ldi	r31, 0x3D	; 61
     2b8:	02 c0       	rjmp	.+4      	; 0x2be <.do_copy_data_start>

000002ba <.do_copy_data_loop>:
     2ba:	05 90       	lpm	r0, Z+
     2bc:	0d 92       	st	X+, r0

000002be <.do_copy_data_start>:
     2be:	ae 30       	cpi	r26, 0x0E	; 14
     2c0:	b1 07       	cpc	r27, r17
     2c2:	d9 f7       	brne	.-10     	; 0x2ba <.do_copy_data_loop>

000002c4 <__do_clear_bss>:
     2c4:	14 e0       	ldi	r17, 0x04	; 4
     2c6:	ae e0       	ldi	r26, 0x0E	; 14
     2c8:	b1 e0       	ldi	r27, 0x01	; 1
     2ca:	01 c0       	rjmp	.+2      	; 0x2ce <.do_clear_bss_start>

000002cc <.do_clear_bss_loop>:
     2cc:	1d 92       	st	X+, r1

000002ce <.do_clear_bss_start>:
     2ce:	a7 33       	cpi	r26, 0x37	; 55
     2d0:	b1 07       	cpc	r27, r17
     2d2:	e1 f7       	brne	.-8      	; 0x2cc <.do_clear_bss_loop>
     2d4:	0e 94 9d 16 	call	0x2d3a	; 0x2d3a <main>
     2d8:	0c 94 f8 1e 	jmp	0x3df0	; 0x3df0 <_exit>

000002dc <__bad_interrupt>:
     2dc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000002e0 <__vector_17>:

char SequencePool=0;//LivePooling Detection
char TimWatchSequence,SequenceTimeout;
char PumpTransDigit=6,PumpTotalDigit=8;

ISR(TIMER0_OVF_vect) {
     2e0:	1f 92       	push	r1
     2e2:	0f 92       	push	r0
     2e4:	0f b6       	in	r0, 0x3f	; 63
     2e6:	0f 92       	push	r0
     2e8:	11 24       	eor	r1, r1
     2ea:	2f 93       	push	r18
     2ec:	3f 93       	push	r19
     2ee:	5f 93       	push	r21
     2f0:	6f 93       	push	r22
     2f2:	7f 93       	push	r23
     2f4:	8f 93       	push	r24
     2f6:	9f 93       	push	r25
     2f8:	af 93       	push	r26
     2fa:	bf 93       	push	r27
    //TCNT1H=0xFD;//Ov:10ms
	//TCNT1L=0xC0;
    static char TimerExp=0;	     
    TimerExp++;
     2fc:	80 91 3a 01 	lds	r24, 0x013A
     300:	8f 5f       	subi	r24, 0xFF	; 255
     302:	80 93 3a 01 	sts	0x013A, r24
	if ((TimerExp%BlinkRate)==0){
     306:	60 91 11 04 	lds	r22, 0x0411
     30a:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <__udivmodqi4>
     30e:	99 23       	and	r25, r25
     310:	21 f4       	brne	.+8      	; 0x31a <__vector_17+0x3a>
		PORTE ^= 0x04;
     312:	87 b1       	in	r24, 0x07	; 7
     314:	94 e0       	ldi	r25, 0x04	; 4
     316:	89 27       	eor	r24, r25
     318:	87 b9       	out	0x07, r24	; 7
	}
	TimExp++;
     31a:	20 91 1f 01 	lds	r18, 0x011F
     31e:	30 91 20 01 	lds	r19, 0x0120
     322:	2f 5f       	subi	r18, 0xFF	; 255
     324:	3f 4f       	sbci	r19, 0xFF	; 255
     326:	30 93 20 01 	sts	0x0120, r19
     32a:	20 93 1f 01 	sts	0x011F, r18
	if ((TimExp%2)==0) TimSend++;
     32e:	20 fd       	sbrc	r18, 0
     330:	09 c0       	rjmp	.+18     	; 0x344 <__vector_17+0x64>
     332:	80 91 23 04 	lds	r24, 0x0423
     336:	90 91 24 04 	lds	r25, 0x0424
     33a:	01 96       	adiw	r24, 0x01	; 1
     33c:	90 93 24 04 	sts	0x0424, r25
     340:	80 93 23 04 	sts	0x0423, r24
	if ((TimExp%100)==0) TimWatchSequence++;
     344:	c9 01       	movw	r24, r18
     346:	64 e6       	ldi	r22, 0x64	; 100
     348:	70 e0       	ldi	r23, 0x00	; 0
     34a:	0e 94 8b 1e 	call	0x3d16	; 0x3d16 <__udivmodhi4>
     34e:	89 2b       	or	r24, r25
     350:	29 f4       	brne	.+10     	; 0x35c <__vector_17+0x7c>
     352:	80 91 de 02 	lds	r24, 0x02DE
     356:	8f 5f       	subi	r24, 0xFF	; 255
     358:	80 93 de 02 	sts	0x02DE, r24
	TimReceive++;
     35c:	80 91 0f 04 	lds	r24, 0x040F
     360:	90 91 10 04 	lds	r25, 0x0410
     364:	01 96       	adiw	r24, 0x01	; 1
     366:	90 93 10 04 	sts	0x0410, r25
     36a:	80 93 0f 04 	sts	0x040F, r24
	TimDelayNextPump++;
     36e:	80 91 21 01 	lds	r24, 0x0121
     372:	90 91 22 01 	lds	r25, 0x0122
     376:	01 96       	adiw	r24, 0x01	; 1
     378:	90 93 22 01 	sts	0x0122, r25
     37c:	80 93 21 01 	sts	0x0121, r24
}
     380:	bf 91       	pop	r27
     382:	af 91       	pop	r26
     384:	9f 91       	pop	r25
     386:	8f 91       	pop	r24
     388:	7f 91       	pop	r23
     38a:	6f 91       	pop	r22
     38c:	5f 91       	pop	r21
     38e:	3f 91       	pop	r19
     390:	2f 91       	pop	r18
     392:	0f 90       	pop	r0
     394:	0f be       	out	0x3f, r0	; 63
     396:	0f 90       	pop	r0
     398:	1f 90       	pop	r1
     39a:	18 95       	reti

0000039c <DoNothing>:
	}
}

void DoNothing(){

}
     39c:	08 95       	ret

0000039e <InitMem>:

void InitMem(){
     //IFType=IT_SLAVE;
}
     39e:	08 95       	ret

000003a0 <GetBaudrate>:

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
     3a0:	82 30       	cpi	r24, 0x02	; 2
     3a2:	59 f0       	breq	.+22     	; 0x3ba <GetBaudrate+0x1a>
     3a4:	82 30       	cpi	r24, 0x02	; 2
     3a6:	18 f0       	brcs	.+6      	; 0x3ae <GetBaudrate+0xe>
     3a8:	83 30       	cpi	r24, 0x03	; 3
     3aa:	21 f4       	brne	.+8      	; 0x3b4 <GetBaudrate+0x14>
     3ac:	09 c0       	rjmp	.+18     	; 0x3c0 <GetBaudrate+0x20>
     3ae:	20 e8       	ldi	r18, 0x80	; 128
     3b0:	35 e2       	ldi	r19, 0x25	; 37
     3b2:	08 c0       	rjmp	.+16     	; 0x3c4 <GetBaudrate+0x24>
     3b4:	20 e0       	ldi	r18, 0x00	; 0
     3b6:	30 e0       	ldi	r19, 0x00	; 0
     3b8:	05 c0       	rjmp	.+10     	; 0x3c4 <GetBaudrate+0x24>
     3ba:	20 e0       	ldi	r18, 0x00	; 0
     3bc:	3b e4       	ldi	r19, 0x4B	; 75
     3be:	02 c0       	rjmp	.+4      	; 0x3c4 <GetBaudrate+0x24>
	 case br9600: 
	      Result=9600;
	      break;
	 case br19200:
	      Result=19200;
	      break;
     3c0:	2b e9       	ldi	r18, 0x9B	; 155
     3c2:	36 e1       	ldi	r19, 0x16	; 22
	 case br5787:
	      Result=5787;
     	  break;	 
	 }
   return Result;
}
     3c4:	c9 01       	movw	r24, r18
     3c6:	08 95       	ret

000003c8 <GetIFType>:
char GetIFType(){
char Result=IT_NONE;
     

return Result;
}
     3c8:	80 e0       	ldi	r24, 0x00	; 0
     3ca:	08 95       	ret

000003cc <SystemComLevel>:
}



void SystemComLevel(char ComLevel){
	 sbi(PORTA,0);  // rs232 off
     3cc:	d8 9a       	sbi	0x1b, 0	; 27
	 sbi(PORTA,3);  // rs485 off
     3ce:	db 9a       	sbi	0x1b, 3	; 27
	 switch(ComLevel){
     3d0:	88 23       	and	r24, r24
     3d2:	21 f0       	breq	.+8      	; 0x3dc <SystemComLevel+0x10>
     3d4:	81 30       	cpi	r24, 0x01	; 1
     3d6:	19 f4       	brne	.+6      	; 0x3de <SystemComLevel+0x12>
	 case CL_485:
		  //sbi(PORTA,0);  // rs232 off
		  cbi(PORTA,3);  // rs485 on	 
     3d8:	db 98       	cbi	0x1b, 3	; 27
     3da:	08 95       	ret
	      break;
     case CL_232:
		  cbi(PORTA,0);  // rs232 on
     3dc:	d8 98       	cbi	0x1b, 0	; 27
     3de:	08 95       	ret

000003e0 <StatePrintf>:
	System485(DIR_RX);//ReceiveMode
}

void StatePrintf(char *strState){
     //TerminalSendf(1,strState);
}
     3e0:	08 95       	ret

000003e2 <systemAntiFreeze>:
//15694 95.8% -> 14746 90.0%

void systemAntiFreeze(){
static char zSequence=0;

	if (IFType==IT_STANDALONE){
     3e2:	80 91 00 01 	lds	r24, 0x0100
     3e6:	82 30       	cpi	r24, 0x02	; 2
     3e8:	a9 f4       	brne	.+42     	; 0x414 <systemAntiFreeze+0x32>
	    if (SequencePool>zSequence){
     3ea:	20 91 26 01 	lds	r18, 0x0126
     3ee:	80 91 35 01 	lds	r24, 0x0135
     3f2:	82 17       	cp	r24, r18
     3f4:	10 f4       	brcc	.+4      	; 0x3fa <systemAntiFreeze+0x18>
		    TimWatchSequence=0;
     3f6:	10 92 de 02 	sts	0x02DE, r1
		}
        if (TimWatchSequence>SequenceTimeout){
     3fa:	90 91 de 02 	lds	r25, 0x02DE
     3fe:	80 91 36 04 	lds	r24, 0x0436
     402:	89 17       	cp	r24, r25
     404:	28 f4       	brcc	.+10     	; 0x410 <systemAntiFreeze+0x2e>
		    TimWatchSequence=0; 
     406:	10 92 de 02 	sts	0x02DE, r1
		    //SendAcknoledge(SC_FREEZE,SequenceTimeout);
		    IsRestartPooling=True;
     40a:	81 e0       	ldi	r24, 0x01	; 1
     40c:	80 93 03 01 	sts	0x0103, r24
		}
		zSequence=SequencePool;
     410:	20 93 35 01 	sts	0x0135, r18
     414:	08 95       	ret

00000416 <CRC_Wayne>:

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
     416:	70 e0       	ldi	r23, 0x00	; 0
     418:	68 27       	eor	r22, r24
     41a:	79 27       	eor	r23, r25
     41c:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
     41e:	41 e0       	ldi	r20, 0x01	; 1
     420:	50 ea       	ldi	r21, 0xA0	; 160
     422:	cb 01       	movw	r24, r22
     424:	96 95       	lsr	r25
     426:	87 95       	ror	r24
     428:	60 ff       	sbrs	r22, 0
     42a:	04 c0       	rjmp	.+8      	; 0x434 <CRC_Wayne+0x1e>
     42c:	bc 01       	movw	r22, r24
     42e:	64 27       	eor	r22, r20
     430:	75 27       	eor	r23, r21
     432:	01 c0       	rjmp	.+2      	; 0x436 <CRC_Wayne+0x20>
        else xCRC= (xCRC>> 1);
     434:	bc 01       	movw	r22, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
     436:	2f 5f       	subi	r18, 0xFF	; 255
     438:	28 30       	cpi	r18, 0x08	; 8
     43a:	99 f7       	brne	.-26     	; 0x422 <CRC_Wayne+0xc>
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
        else xCRC= (xCRC>> 1);
    }
    return xCRC;
}
     43c:	cb 01       	movw	r24, r22
     43e:	08 95       	ret

00000440 <sys_delay>:

void sys_delay(unsigned int dV){
}
     440:	08 95       	ret

00000442 <System485>:

void System485(char Dir){//DIR_TX, DIR_RX	 
     switch(Dir){
     442:	81 30       	cpi	r24, 0x01	; 1
     444:	19 f0       	breq	.+6      	; 0x44c <System485+0xa>
     446:	82 30       	cpi	r24, 0x02	; 2
     448:	71 f4       	brne	.+28     	; 0x466 <System485+0x24>
     44a:	07 c0       	rjmp	.+14     	; 0x45a <System485+0x18>
	 case DIR_TX:
	      sbi(PORTB,1);
     44c:	c1 9a       	sbi	0x18, 1	; 24
		  sbi(DDRB,1);
     44e:	b9 9a       	sbi	0x17, 1	; 23
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     450:	84 ec       	ldi	r24, 0xC4	; 196
     452:	99 e0       	ldi	r25, 0x09	; 9
     454:	01 97       	sbiw	r24, 0x01	; 1
     456:	f1 f7       	brne	.-4      	; 0x454 <System485+0x12>
     458:	08 95       	ret
		  _delay_ms(10);
	      break;
	 case DIR_RX:
          _delay_ms(7);
		  sbi(DDRB,1);
     45a:	86 ed       	ldi	r24, 0xD6	; 214
     45c:	96 e0       	ldi	r25, 0x06	; 6
     45e:	01 97       	sbiw	r24, 0x01	; 1
     460:	f1 f7       	brne	.-4      	; 0x45e <System485+0x1c>
     462:	b9 9a       	sbi	0x17, 1	; 23
		  cbi(PORTB,1);		  
     464:	c1 98       	cbi	0x18, 1	; 24
     466:	08 95       	ret

00000468 <WayneTestSend>:
	 _uart(0,1,xData);
	 System485(DIR_RX);//ReceiveMode
}

void WayneTestSend(){
}
     468:	08 95       	ret

0000046a <ExtractValue>:
     case CMD_REQ_GLOBAL_STATUS_2:
  	      break;
	 }	 
}

void ExtractValue(char *Source,char FirstPos,char nCount,char*Dest){//WayneRxBuffer,13,16-13,strVolume);
     46a:	fc 01       	movw	r30, r24
     46c:	e6 0f       	add	r30, r22
     46e:	f1 1d       	adc	r31, r1
     470:	d9 01       	movw	r26, r18
     472:	90 e0       	ldi	r25, 0x00	; 0
     474:	0d c0       	rjmp	.+26     	; 0x490 <ExtractValue+0x26>
     char i;
	 for(i=0;i<nCount;i++){
	     Dest[2*i]=(Source[FirstPos+i]>>4)+'0';
     476:	80 81       	ld	r24, Z
     478:	82 95       	swap	r24
     47a:	8f 70       	andi	r24, 0x0F	; 15
     47c:	80 5d       	subi	r24, 0xD0	; 208
     47e:	8c 93       	st	X, r24
	     Dest[(2*i)+1]=(Source[FirstPos+i]&0x0F)+'0';	 
     480:	81 91       	ld	r24, Z+
     482:	8f 70       	andi	r24, 0x0F	; 15
     484:	80 5d       	subi	r24, 0xD0	; 208
     486:	11 96       	adiw	r26, 0x01	; 1
     488:	8c 93       	st	X, r24
     48a:	11 97       	sbiw	r26, 0x01	; 1
	 }	 
}

void ExtractValue(char *Source,char FirstPos,char nCount,char*Dest){//WayneRxBuffer,13,16-13,strVolume);
     char i;
	 for(i=0;i<nCount;i++){
     48c:	9f 5f       	subi	r25, 0xFF	; 255
     48e:	12 96       	adiw	r26, 0x02	; 2
     490:	94 17       	cp	r25, r20
     492:	88 f3       	brcs	.-30     	; 0x476 <ExtractValue+0xc>
	     Dest[2*i]=(Source[FirstPos+i]>>4)+'0';
	     Dest[(2*i)+1]=(Source[FirstPos+i]&0x0F)+'0';	 
	 }Dest[2*nCount]=0;
     494:	e4 2f       	mov	r30, r20
     496:	f0 e0       	ldi	r31, 0x00	; 0
     498:	ee 0f       	add	r30, r30
     49a:	ff 1f       	adc	r31, r31
     49c:	e2 0f       	add	r30, r18
     49e:	f3 1f       	adc	r31, r19
     4a0:	10 82       	st	Z, r1
}
     4a2:	08 95       	ret

000004a4 <InitPumpData>:
}

void InitPumpData(){
char i;
char strSerial[20];
     if (StandaloneType==ST_GILBARCO){
     4a4:	80 91 01 01 	lds	r24, 0x0101
     4a8:	81 30       	cpi	r24, 0x01	; 1
     4aa:	01 f5       	brne	.+64     	; 0x4ec <InitPumpData+0x48>
     4ac:	80 e0       	ldi	r24, 0x00	; 0
     4ae:	90 e0       	ldi	r25, 0x00	; 0
	     for(i=0;i<16;i++){
		     IsRequestTransInfo[i]=False;
			 IsRequestTotalizerInfo[i]=False;
			 zPumpStatus[i]=PUMP_NONE;
     4b0:	2e e0       	ldi	r18, 0x0E	; 14
void InitPumpData(){
char i;
char strSerial[20];
     if (StandaloneType==ST_GILBARCO){
	     for(i=0;i<16;i++){
		     IsRequestTransInfo[i]=False;
     4b2:	fc 01       	movw	r30, r24
     4b4:	e6 57       	subi	r30, 0x76	; 118
     4b6:	fd 4f       	sbci	r31, 0xFD	; 253
     4b8:	10 82       	st	Z, r1
			 IsRequestTotalizerInfo[i]=False;
     4ba:	fc 01       	movw	r30, r24
     4bc:	ed 5e       	subi	r30, 0xED	; 237
     4be:	fb 4f       	sbci	r31, 0xFB	; 251
     4c0:	10 82       	st	Z, r1
			 zPumpStatus[i]=PUMP_NONE;
     4c2:	fc 01       	movw	r30, r24
     4c4:	e5 56       	subi	r30, 0x65	; 101
     4c6:	fd 4f       	sbci	r31, 0xFD	; 253
     4c8:	20 83       	st	Z, r18
			 PumpStatus[i]=PUMP_NONE;
     4ca:	fc 01       	movw	r30, r24
     4cc:	eb 54       	subi	r30, 0x4B	; 75
     4ce:	fc 4f       	sbci	r31, 0xFC	; 252
     4d0:	20 83       	st	Z, r18
			 NoPumpCount[i]=0;
     4d2:	fc 01       	movw	r30, r24
     4d4:	eb 5d       	subi	r30, 0xDB	; 219
     4d6:	fb 4f       	sbci	r31, 0xFB	; 251
     4d8:	10 82       	st	Z, r1
			 PumpLock[i]=False;
     4da:	fc 01       	movw	r30, r24
     4dc:	e4 53       	subi	r30, 0x34	; 52
     4de:	fd 4f       	sbci	r31, 0xFD	; 253
     4e0:	10 82       	st	Z, r1
     4e2:	01 96       	adiw	r24, 0x01	; 1

void InitPumpData(){
char i;
char strSerial[20];
     if (StandaloneType==ST_GILBARCO){
	     for(i=0;i<16;i++){
     4e4:	80 31       	cpi	r24, 0x10	; 16
     4e6:	91 05       	cpc	r25, r1
     4e8:	21 f7       	brne	.-56     	; 0x4b2 <InitPumpData+0xe>
     4ea:	08 95       	ret
			 zPumpStatus[i]=PUMP_NONE;
			 PumpStatus[i]=PUMP_NONE;
			 NoPumpCount[i]=0;
			 PumpLock[i]=False;
		 }
     }else if (StandaloneType==ST_WAYNE_DART){
     4ec:	80 91 01 01 	lds	r24, 0x0101
     4f0:	82 30       	cpi	r24, 0x02	; 2
     4f2:	f1 f4       	brne	.+60     	; 0x530 <__stack+0x31>
     4f4:	80 e0       	ldi	r24, 0x00	; 0
     4f6:	90 e0       	ldi	r25, 0x00	; 0
	     for(i=0;i<16;i++){
		     IsRequestTransInfo[i]=False;
     4f8:	fc 01       	movw	r30, r24
     4fa:	e6 57       	subi	r30, 0x76	; 118
     4fc:	fd 4f       	sbci	r31, 0xFD	; 253
     4fe:	10 82       	st	Z, r1
			 IsRequestTotalizerInfo[i]=False;
     500:	fc 01       	movw	r30, r24
     502:	ed 5e       	subi	r30, 0xED	; 237
     504:	fb 4f       	sbci	r31, 0xFB	; 251
     506:	10 82       	st	Z, r1
			 zPumpStatus[i]=PW_NONE;
     508:	fc 01       	movw	r30, r24
     50a:	e5 56       	subi	r30, 0x65	; 101
     50c:	fd 4f       	sbci	r31, 0xFD	; 253
     50e:	10 82       	st	Z, r1
			 PumpStatus[i]=PW_NONE;
     510:	fc 01       	movw	r30, r24
     512:	eb 54       	subi	r30, 0x4B	; 75
     514:	fc 4f       	sbci	r31, 0xFC	; 252
     516:	10 82       	st	Z, r1
			 NoPumpCount[i]=0;
     518:	fc 01       	movw	r30, r24
     51a:	eb 5d       	subi	r30, 0xDB	; 219
     51c:	fb 4f       	sbci	r31, 0xFB	; 251
     51e:	10 82       	st	Z, r1
			 PumpLock[i]=False;
     520:	fc 01       	movw	r30, r24
     522:	e4 53       	subi	r30, 0x34	; 52
     524:	fd 4f       	sbci	r31, 0xFD	; 253
     526:	10 82       	st	Z, r1
     528:	01 96       	adiw	r24, 0x01	; 1
			 PumpStatus[i]=PUMP_NONE;
			 NoPumpCount[i]=0;
			 PumpLock[i]=False;
		 }
     }else if (StandaloneType==ST_WAYNE_DART){
	     for(i=0;i<16;i++){
     52a:	80 31       	cpi	r24, 0x10	; 16
     52c:	91 05       	cpc	r25, r1
     52e:	21 f7       	brne	.-56     	; 0x4f8 <InitPumpData+0x54>
     530:	08 95       	ret

00000532 <uart_init>:
     UBRR0H=0;
     UBRR0L=158;// baud 5787
     UCSR0C=(1<<URSEL0) | (1<<UPM01) | (1<<UCSZ01) | (1<<UCSZ00); // UPM01 untuk set even parity
     sei();
	 */
}
     532:	08 95       	ret

00000534 <InitSystemTimer>:

void InitSystemTimer(){
	TCCR0 |= (1 << CS02) | (1 << CS00);
     534:	83 b7       	in	r24, 0x33	; 51
     536:	85 60       	ori	r24, 0x05	; 5
     538:	83 bf       	out	0x33, r24	; 51
	TIMSK |= _BV(TOIE0);
     53a:	89 b7       	in	r24, 0x39	; 57
     53c:	82 60       	ori	r24, 0x02	; 2
     53e:	89 bf       	out	0x39, r24	; 57
}
     540:	08 95       	ret

00000542 <GetPumpID>:

char GetPumpID(char data){
     char xPumpID=0;
	 xPumpID=(data&0x0F);
	 return xPumpID;
}
     542:	8f 70       	andi	r24, 0x0F	; 15
     544:	08 95       	ret

00000546 <GetResponse>:

char GetResponse(char data){
     char Response=0;
	 Response=((data&0xF0)>>4);
	 return Response;
}
     546:	82 95       	swap	r24
     548:	8f 70       	andi	r24, 0x0F	; 15
     54a:	08 95       	ret

0000054c <ShiftArray>:
	 //_delay_ms(10);
}

void ShiftArray(char *strShifted, unsigned int nCount){

}
     54c:	08 95       	ret

0000054e <systemServiceSPI>:

void systemServiceSPI(){
}
     54e:	08 95       	ret

00000550 <SaveTransactionData>:
	    strSource[i]=strResult[i];
	    strSource[i+1]=0;
	 }
}

void SaveTransactionData(char data){
     550:	28 2f       	mov	r18, r24
     static char SavePipeline=spNone;
	 static char IdxData=0;
	 switch(SavePipeline){
     552:	80 91 2b 01 	lds	r24, 0x012B
     556:	86 30       	cpi	r24, 0x06	; 6
     558:	41 f1       	breq	.+80     	; 0x5aa <SaveTransactionData+0x5a>
     55a:	87 30       	cpi	r24, 0x07	; 7
     55c:	30 f4       	brcc	.+12     	; 0x56a <SaveTransactionData+0x1a>
     55e:	84 30       	cpi	r24, 0x04	; 4
     560:	51 f0       	breq	.+20     	; 0x576 <SaveTransactionData+0x26>
     562:	85 30       	cpi	r24, 0x05	; 5
     564:	09 f0       	breq	.+2      	; 0x568 <SaveTransactionData+0x18>
     566:	56 c0       	rjmp	.+172    	; 0x614 <SaveTransactionData+0xc4>
     568:	17 c0       	rjmp	.+46     	; 0x598 <SaveTransactionData+0x48>
     56a:	87 30       	cpi	r24, 0x07	; 7
     56c:	79 f1       	breq	.+94     	; 0x5cc <SaveTransactionData+0x7c>
     56e:	8a 30       	cpi	r24, 0x0A	; 10
     570:	09 f0       	breq	.+2      	; 0x574 <SaveTransactionData+0x24>
     572:	50 c0       	rjmp	.+160    	; 0x614 <SaveTransactionData+0xc4>
     574:	3b c0       	rjmp	.+118    	; 0x5ec <SaveTransactionData+0x9c>
     case spPumpIdentifier:
	      if (IdxData==1)rxPumpId=FilterBCD(data);
     576:	90 91 2a 01 	lds	r25, 0x012A
     57a:	91 30       	cpi	r25, 0x01	; 1
     57c:	29 f4       	brne	.+10     	; 0x588 <SaveTransactionData+0x38>
     57e:	82 2f       	mov	r24, r18
     580:	8f 70       	andi	r24, 0x0F	; 15
     582:	80 93 3b 01 	sts	0x013B, r24
     586:	43 c0       	rjmp	.+134    	; 0x60e <SaveTransactionData+0xbe>
		  else
	      if (IdxData==2)NozzleId=FilterBCD(data);
     588:	92 30       	cpi	r25, 0x02	; 2
     58a:	09 f0       	breq	.+2      	; 0x58e <SaveTransactionData+0x3e>
     58c:	40 c0       	rjmp	.+128    	; 0x60e <SaveTransactionData+0xbe>
     58e:	82 2f       	mov	r24, r18
     590:	8f 70       	andi	r24, 0x0F	; 15
     592:	80 93 e0 02 	sts	0x02E0, r24
     596:	3b c0       	rjmp	.+118    	; 0x60e <SaveTransactionData+0xbe>
          IdxData++;
      	  break;
     case spProductGrade:
	      if (IdxData==0)GradeId=FilterBCD(data);
     598:	90 91 2a 01 	lds	r25, 0x012A
     59c:	99 23       	and	r25, r25
     59e:	b9 f5       	brne	.+110    	; 0x60e <SaveTransactionData+0xbe>
     5a0:	82 2f       	mov	r24, r18
     5a2:	8f 70       	andi	r24, 0x0F	; 15
     5a4:	80 93 f6 02 	sts	0x02F6, r24
     5a8:	32 c0       	rjmp	.+100    	; 0x60e <SaveTransactionData+0xbe>
		  IdxData++;
      	  break;
     case spProductPrice:	       
          if (data!=0xF9){		      
     5aa:	29 3f       	cpi	r18, 0xF9	; 249
     5ac:	09 f4       	brne	.+2      	; 0x5b0 <SaveTransactionData+0x60>
     5ae:	40 c0       	rjmp	.+128    	; 0x630 <SaveTransactionData+0xe0>
		      strUnitPrice[IdxData]=BCD2Char(FilterBCD(data));
     5b0:	90 91 2a 01 	lds	r25, 0x012A
     5b4:	e9 2f       	mov	r30, r25
     5b6:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     5b8:	82 2f       	mov	r24, r18
     5ba:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     5bc:	8a 30       	cpi	r24, 0x0A	; 10
     5be:	10 f0       	brcs	.+4      	; 0x5c4 <SaveTransactionData+0x74>
     5c0:	80 e3       	ldi	r24, 0x30	; 48
     5c2:	01 c0       	rjmp	.+2      	; 0x5c6 <SaveTransactionData+0x76>
	     Result='0'+data;
     5c4:	80 5d       	subi	r24, 0xD0	; 208
	      if (IdxData==0)GradeId=FilterBCD(data);
		  IdxData++;
      	  break;
     case spProductPrice:	       
          if (data!=0xF9){		      
		      strUnitPrice[IdxData]=BCD2Char(FilterBCD(data));
     5c6:	e4 55       	subi	r30, 0x54	; 84
     5c8:	fd 4f       	sbci	r31, 0xFD	; 253
     5ca:	1f c0       	rjmp	.+62     	; 0x60a <SaveTransactionData+0xba>
              strUnitPrice[IdxData+1]=0;
	          IdxData++;
			  }
	  	  break;
     case spProductVolume:
          if (data!=0xFA){//Maks 7 Digit 0000123
     5cc:	2a 3f       	cpi	r18, 0xFA	; 250
     5ce:	91 f1       	breq	.+100    	; 0x634 <SaveTransactionData+0xe4>
              strVolume[IdxData]=BCD2Char(FilterBCD(data));
     5d0:	90 91 2a 01 	lds	r25, 0x012A
     5d4:	e9 2f       	mov	r30, r25
     5d6:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     5d8:	82 2f       	mov	r24, r18
     5da:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     5dc:	8a 30       	cpi	r24, 0x0A	; 10
     5de:	10 f0       	brcs	.+4      	; 0x5e4 <SaveTransactionData+0x94>
     5e0:	80 e3       	ldi	r24, 0x30	; 48
     5e2:	01 c0       	rjmp	.+2      	; 0x5e6 <SaveTransactionData+0x96>
	     Result='0'+data;
     5e4:	80 5d       	subi	r24, 0xD0	; 208
	          IdxData++;
			  }
	  	  break;
     case spProductVolume:
          if (data!=0xFA){//Maks 7 Digit 0000123
              strVolume[IdxData]=BCD2Char(FilterBCD(data));
     5e6:	e9 5a       	subi	r30, 0xA9	; 169
     5e8:	fd 4f       	sbci	r31, 0xFD	; 253
     5ea:	0f c0       	rjmp	.+30     	; 0x60a <SaveTransactionData+0xba>
              strVolume[IdxData+1]=0;
	          IdxData++;
		      }
	  	  break;
     case spProductMoney:
          if (data!=0xFB){
     5ec:	2b 3f       	cpi	r18, 0xFB	; 251
     5ee:	f1 f0       	breq	.+60     	; 0x62c <SaveTransactionData+0xdc>
              strAmount[IdxData]=BCD2Char(FilterBCD(data));
     5f0:	90 91 2a 01 	lds	r25, 0x012A
     5f4:	e9 2f       	mov	r30, r25
     5f6:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     5f8:	82 2f       	mov	r24, r18
     5fa:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     5fc:	8a 30       	cpi	r24, 0x0A	; 10
     5fe:	10 f0       	brcs	.+4      	; 0x604 <SaveTransactionData+0xb4>
     600:	80 e3       	ldi	r24, 0x30	; 48
     602:	01 c0       	rjmp	.+2      	; 0x606 <SaveTransactionData+0xb6>
	     Result='0'+data;
     604:	80 5d       	subi	r24, 0xD0	; 208
	          IdxData++;
		      }
	  	  break;
     case spProductMoney:
          if (data!=0xFB){
              strAmount[IdxData]=BCD2Char(FilterBCD(data));
     606:	e5 55       	subi	r30, 0x55	; 85
     608:	fc 4f       	sbci	r31, 0xFC	; 252
     60a:	80 83       	st	Z, r24
              strAmount[IdxData+1]=0;
     60c:	11 82       	std	Z+1, r1	; 0x01
              IdxData++;
     60e:	9f 5f       	subi	r25, 0xFF	; 255
     610:	90 93 2a 01 	sts	0x012A, r25
     case spLRC:
	  	  break;	 
	 }

	 //Pipeline detection
	 if (data==0xF8){
     614:	28 3f       	cpi	r18, 0xF8	; 248
     616:	11 f4       	brne	.+4      	; 0x61c <SaveTransactionData+0xcc>
	     SavePipeline=spPumpIdentifier;
     618:	84 e0       	ldi	r24, 0x04	; 4
     61a:	0f c0       	rjmp	.+30     	; 0x63a <SaveTransactionData+0xea>
		 IdxData=0;
	 }else if (data==0xF6){
     61c:	26 3f       	cpi	r18, 0xF6	; 246
     61e:	11 f4       	brne	.+4      	; 0x624 <SaveTransactionData+0xd4>
	     SavePipeline=spProductGrade;
     620:	85 e0       	ldi	r24, 0x05	; 5
     622:	0b c0       	rjmp	.+22     	; 0x63a <SaveTransactionData+0xea>
		 IdxData=0;
	 }else if (data==0xF7){
     624:	27 3f       	cpi	r18, 0xF7	; 247
     626:	11 f4       	brne	.+4      	; 0x62c <SaveTransactionData+0xdc>
	     SavePipeline=spProductPrice;
     628:	86 e0       	ldi	r24, 0x06	; 6
     62a:	07 c0       	rjmp	.+14     	; 0x63a <SaveTransactionData+0xea>
		 IdxData=0;
	 }else if (data==0xF9){
     62c:	29 3f       	cpi	r18, 0xF9	; 249
     62e:	11 f4       	brne	.+4      	; 0x634 <SaveTransactionData+0xe4>
	     SavePipeline=spProductVolume;
     630:	87 e0       	ldi	r24, 0x07	; 7
     632:	03 c0       	rjmp	.+6      	; 0x63a <SaveTransactionData+0xea>
		 IdxData=0;
	 }else if (data==0xFA){
     634:	2a 3f       	cpi	r18, 0xFA	; 250
     636:	31 f4       	brne	.+12     	; 0x644 <SaveTransactionData+0xf4>
	     SavePipeline=spProductMoney;
     638:	8a e0       	ldi	r24, 0x0A	; 10
     63a:	80 93 2b 01 	sts	0x012B, r24
		 IdxData=0;
     63e:	10 92 2a 01 	sts	0x012A, r1
     642:	08 95       	ret
	 }else if (data==0xFB){
     644:	2b 3f       	cpi	r18, 0xFB	; 251
     646:	49 f4       	brne	.+18     	; 0x65a <SaveTransactionData+0x10a>
	     PumpTransDigit=IdxData;
     648:	80 91 2a 01 	lds	r24, 0x012A
     64c:	80 93 0b 01 	sts	0x010B, r24
	     SavePipeline=spLRC;
     650:	8b e0       	ldi	r24, 0x0B	; 11
     652:	80 93 2b 01 	sts	0x012B, r24
		 IdxData=0;
     656:	10 92 2a 01 	sts	0x012A, r1
     65a:	08 95       	ret

0000065c <SaveTotalizerData>:
	 }
}

void SaveTotalizerData(char data){
     65c:	28 2f       	mov	r18, r24
     static char SavePipeline=spNone;
	 static char IdxData=0;

	 switch(SavePipeline){
     65e:	80 91 29 01 	lds	r24, 0x0129
     662:	82 30       	cpi	r24, 0x02	; 2
     664:	b9 f0       	breq	.+46     	; 0x694 <SaveTotalizerData+0x38>
     666:	83 30       	cpi	r24, 0x03	; 3
     668:	09 f4       	brne	.+2      	; 0x66c <SaveTotalizerData+0x10>
     66a:	4a c0       	rjmp	.+148    	; 0x700 <SaveTotalizerData+0xa4>
     66c:	81 30       	cpi	r24, 0x01	; 1
     66e:	09 f0       	breq	.+2      	; 0x672 <SaveTotalizerData+0x16>
     670:	7e c0       	rjmp	.+252    	; 0x76e <SaveTotalizerData+0x112>
	 case spTotalizerGrade:
	      if (IdxData==0){
     672:	90 91 28 01 	lds	r25, 0x0128
     676:	99 23       	and	r25, r25
     678:	49 f4       	brne	.+18     	; 0x68c <SaveTotalizerData+0x30>
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     67a:	82 2f       	mov	r24, r18
     67c:	8f 70       	andi	r24, 0x0F	; 15
	 static char IdxData=0;

	 switch(SavePipeline){
	 case spTotalizerGrade:
	      if (IdxData==0){
		      TGradeId=FilterBCD(data);
     67e:	80 93 dc 02 	sts	0x02DC, r24
			  //_uart(1,1,BCD2Char(TGradeId));
			  if (TGradeId>=5)TGradeId=5;
     682:	85 30       	cpi	r24, 0x05	; 5
     684:	18 f0       	brcs	.+6      	; 0x68c <SaveTotalizerData+0x30>
     686:	85 e0       	ldi	r24, 0x05	; 5
     688:	80 93 dc 02 	sts	0x02DC, r24
			  }
          IdxData++; 
     68c:	9f 5f       	subi	r25, 0xFF	; 255
     68e:	90 93 28 01 	sts	0x0128, r25
     692:	6d c0       	rjmp	.+218    	; 0x76e <SaveTotalizerData+0x112>
	      break;
	 case spTotalizerVolume:
          if ((data&0xF0)==0xE0){
     694:	82 2f       	mov	r24, r18
     696:	80 7f       	andi	r24, 0xF0	; 240
     698:	80 3e       	cpi	r24, 0xE0	; 224
     69a:	09 f0       	breq	.+2      	; 0x69e <SaveTotalizerData+0x42>
     69c:	68 c0       	rjmp	.+208    	; 0x76e <SaveTotalizerData+0x112>
		      PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData]=BCD2Char(FilterBCD(data));
     69e:	50 91 dc 02 	lds	r21, 0x02DC
     6a2:	30 91 28 01 	lds	r19, 0x0128
     6a6:	63 2f       	mov	r22, r19
     6a8:	70 e0       	ldi	r23, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     6aa:	82 2f       	mov	r24, r18
     6ac:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     6ae:	8a 30       	cpi	r24, 0x0A	; 10
     6b0:	10 f0       	brcs	.+4      	; 0x6b6 <SaveTotalizerData+0x5a>
     6b2:	40 e3       	ldi	r20, 0x30	; 48
     6b4:	02 c0       	rjmp	.+4      	; 0x6ba <SaveTotalizerData+0x5e>
	     Result='0'+data;
     6b6:	48 2f       	mov	r20, r24
     6b8:	40 5d       	subi	r20, 0xD0	; 208
			  }
          IdxData++; 
	      break;
	 case spTotalizerVolume:
          if ((data&0xF0)==0xE0){
		      PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData]=BCD2Char(FilterBCD(data));
     6ba:	85 2f       	mov	r24, r21
     6bc:	90 e0       	ldi	r25, 0x00	; 0
     6be:	fc 01       	movw	r30, r24
     6c0:	b5 e0       	ldi	r27, 0x05	; 5
     6c2:	ee 0f       	add	r30, r30
     6c4:	ff 1f       	adc	r31, r31
     6c6:	ba 95       	dec	r27
     6c8:	e1 f7       	brne	.-8      	; 0x6c2 <SaveTotalizerData+0x66>
     6ca:	88 0f       	add	r24, r24
     6cc:	99 1f       	adc	r25, r25
     6ce:	e8 1b       	sub	r30, r24
     6d0:	f9 0b       	sbc	r31, r25
     6d2:	e6 0f       	add	r30, r22
     6d4:	f7 1f       	adc	r31, r23
     6d6:	e9 50       	subi	r30, 0x09	; 9
     6d8:	fd 4f       	sbci	r31, 0xFD	; 253
     6da:	40 83       	st	Z, r20
			  //_uart(1,1,PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData]);

		      PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData+1]=0;
     6dc:	85 2f       	mov	r24, r21
     6de:	90 e0       	ldi	r25, 0x00	; 0
     6e0:	fc 01       	movw	r30, r24
     6e2:	55 e0       	ldi	r21, 0x05	; 5
     6e4:	ee 0f       	add	r30, r30
     6e6:	ff 1f       	adc	r31, r31
     6e8:	5a 95       	dec	r21
     6ea:	e1 f7       	brne	.-8      	; 0x6e4 <SaveTotalizerData+0x88>
     6ec:	88 0f       	add	r24, r24
     6ee:	99 1f       	adc	r25, r25
     6f0:	e8 1b       	sub	r30, r24
     6f2:	f9 0b       	sbc	r31, r25
     6f4:	e9 50       	subi	r30, 0x09	; 9
     6f6:	fd 4f       	sbci	r31, 0xFD	; 253
     6f8:	e6 0f       	add	r30, r22
     6fa:	f7 1f       	adc	r31, r23
     6fc:	11 82       	std	Z+1, r1	; 0x01
     6fe:	34 c0       	rjmp	.+104    	; 0x768 <SaveTotalizerData+0x10c>
		      //TVolume[TGradeId][IdxData+1]=0;
		      IdxData++;
		  }
	      break;
	 case spTotalizerMoney:
          if ((data&0xF0)==0xE0){
     700:	82 2f       	mov	r24, r18
     702:	80 7f       	andi	r24, 0xF0	; 240
     704:	80 3e       	cpi	r24, 0xE0	; 224
     706:	99 f5       	brne	.+102    	; 0x76e <SaveTotalizerData+0x112>
	          //TMoney[TGradeId][IdxData]=BCD2Char(FilterBCD(data));
		      //TMoney[TGradeId][IdxData+1]=0;
		      PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData]=BCD2Char(FilterBCD(data));
     708:	70 91 dc 02 	lds	r23, 0x02DC
     70c:	30 91 28 01 	lds	r19, 0x0128
     710:	43 2f       	mov	r20, r19
     712:	50 e0       	ldi	r21, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     714:	82 2f       	mov	r24, r18
     716:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     718:	8a 30       	cpi	r24, 0x0A	; 10
     71a:	10 f0       	brcs	.+4      	; 0x720 <SaveTotalizerData+0xc4>
     71c:	60 e3       	ldi	r22, 0x30	; 48
     71e:	02 c0       	rjmp	.+4      	; 0x724 <SaveTotalizerData+0xc8>
	     Result='0'+data;
     720:	68 2f       	mov	r22, r24
     722:	60 5d       	subi	r22, 0xD0	; 208
	      break;
	 case spTotalizerMoney:
          if ((data&0xF0)==0xE0){
	          //TMoney[TGradeId][IdxData]=BCD2Char(FilterBCD(data));
		      //TMoney[TGradeId][IdxData+1]=0;
		      PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData]=BCD2Char(FilterBCD(data));
     724:	87 2f       	mov	r24, r23
     726:	90 e0       	ldi	r25, 0x00	; 0
     728:	fc 01       	movw	r30, r24
     72a:	b5 e0       	ldi	r27, 0x05	; 5
     72c:	ee 0f       	add	r30, r30
     72e:	ff 1f       	adc	r31, r31
     730:	ba 95       	dec	r27
     732:	e1 f7       	brne	.-8      	; 0x72c <SaveTotalizerData+0xd0>
     734:	88 0f       	add	r24, r24
     736:	99 1f       	adc	r25, r25
     738:	e8 1b       	sub	r30, r24
     73a:	f9 0b       	sbc	r31, r25
     73c:	e9 50       	subi	r30, 0x09	; 9
     73e:	fd 4f       	sbci	r31, 0xFD	; 253
     740:	e4 0f       	add	r30, r20
     742:	f5 1f       	adc	r31, r21
     744:	67 87       	std	Z+15, r22	; 0x0f
			  //_uart(1,1,PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData]);
		      PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData+1]=0;
     746:	87 2f       	mov	r24, r23
     748:	90 e0       	ldi	r25, 0x00	; 0
     74a:	fc 01       	movw	r30, r24
     74c:	75 e0       	ldi	r23, 0x05	; 5
     74e:	ee 0f       	add	r30, r30
     750:	ff 1f       	adc	r31, r31
     752:	7a 95       	dec	r23
     754:	e1 f7       	brne	.-8      	; 0x74e <SaveTotalizerData+0xf2>
     756:	88 0f       	add	r24, r24
     758:	99 1f       	adc	r25, r25
     75a:	e8 1b       	sub	r30, r24
     75c:	f9 0b       	sbc	r31, r25
     75e:	e9 50       	subi	r30, 0x09	; 9
     760:	fd 4f       	sbci	r31, 0xFD	; 253
     762:	e4 0f       	add	r30, r20
     764:	f5 1f       	adc	r31, r21
     766:	10 8a       	std	Z+16, r1	; 0x10
  		      IdxData++;
     768:	3f 5f       	subi	r19, 0xFF	; 255
     76a:	30 93 28 01 	sts	0x0128, r19
          }
	      break;		  
	 }	 
	//Grade Data Next Select 
	if (data==0xF6){
     76e:	26 3f       	cpi	r18, 0xF6	; 246
     770:	21 f4       	brne	.+8      	; 0x77a <SaveTotalizerData+0x11e>
	    IdxData=0;
     772:	10 92 28 01 	sts	0x0128, r1
	    SavePipeline=spTotalizerGrade;
     776:	81 e0       	ldi	r24, 0x01	; 1
     778:	13 c0       	rjmp	.+38     	; 0x7a0 <SaveTotalizerData+0x144>
		//_uart(1,1,0x0D);
		}
    else
	if (data==0xF9){
     77a:	29 3f       	cpi	r18, 0xF9	; 249
     77c:	11 f4       	brne	.+4      	; 0x782 <SaveTotalizerData+0x126>
	    SavePipeline=spTotalizerVolume;
     77e:	82 e0       	ldi	r24, 0x02	; 2
     780:	07 c0       	rjmp	.+14     	; 0x790 <SaveTotalizerData+0x134>
		IdxData=0;
		//_uart(1,1,0x0D);
		//_uart(1,1,'V');
		}
	else
	if (data==0xFA){
     782:	2a 3f       	cpi	r18, 0xFA	; 250
     784:	51 f4       	brne	.+20     	; 0x79a <SaveTotalizerData+0x13e>
	    PumpTotalDigit=IdxData;
     786:	80 91 28 01 	lds	r24, 0x0128
     78a:	80 93 0c 01 	sts	0x010C, r24
	    SavePipeline=spTotalizerMoney;
     78e:	83 e0       	ldi	r24, 0x03	; 3
     790:	80 93 29 01 	sts	0x0129, r24
		IdxData=0;
     794:	10 92 28 01 	sts	0x0128, r1
     798:	08 95       	ret
		//_uart(1,1,0x0D);
		//_uart(1,1,'M');
		}
    else
	if (data==0xF4)SavePipeline=spTotalizerPPU1;
     79a:	24 3f       	cpi	r18, 0xF4	; 244
     79c:	21 f4       	brne	.+8      	; 0x7a6 <SaveTotalizerData+0x14a>
     79e:	88 e0       	ldi	r24, 0x08	; 8
     7a0:	80 93 29 01 	sts	0x0129, r24
     7a4:	08 95       	ret
	else
	if (data==0xF5)SavePipeline=spTotalizerPPU2;
     7a6:	25 3f       	cpi	r18, 0xF5	; 245
     7a8:	19 f4       	brne	.+6      	; 0x7b0 <SaveTotalizerData+0x154>
     7aa:	89 e0       	ldi	r24, 0x09	; 9
     7ac:	80 93 29 01 	sts	0x0129, r24
     7b0:	08 95       	ret

000007b2 <OnReceive1>:
            strRFID[8]=0;
     sprintf_P(strSerial,PSTR("RFID:%s"),strRFID);
     _uart_print(1,0,strSerial);
	 }
	 */
}
     7b2:	08 95       	ret

000007b4 <UpdateMoney>:

void UpdateMoney(char *Dest, char *Src , unsigned int Length){
     7b4:	cf 93       	push	r28
     7b6:	df 93       	push	r29
     7b8:	ec 01       	movw	r28, r24
     7ba:	20 e0       	ldi	r18, 0x00	; 0
     7bc:	0b c0       	rjmp	.+22     	; 0x7d4 <UpdateMoney+0x20>
     unsigned char i;
	 for(i=0;i<Length;i++){
	     Dest[i]=Src[Length-i];
     7be:	fe 01       	movw	r30, r28
     7c0:	e8 0f       	add	r30, r24
     7c2:	f9 1f       	adc	r31, r25
     7c4:	da 01       	movw	r26, r20
     7c6:	a8 1b       	sub	r26, r24
     7c8:	b9 0b       	sbc	r27, r25
     7ca:	a6 0f       	add	r26, r22
     7cc:	b7 1f       	adc	r27, r23
     7ce:	8c 91       	ld	r24, X
     7d0:	80 83       	st	Z, r24
	 */
}

void UpdateMoney(char *Dest, char *Src , unsigned int Length){
     unsigned char i;
	 for(i=0;i<Length;i++){
     7d2:	2f 5f       	subi	r18, 0xFF	; 255
     7d4:	82 2f       	mov	r24, r18
     7d6:	90 e0       	ldi	r25, 0x00	; 0
     7d8:	84 17       	cp	r24, r20
     7da:	95 07       	cpc	r25, r21
     7dc:	80 f3       	brcs	.-32     	; 0x7be <UpdateMoney+0xa>
	     Dest[i]=Src[Length-i];
	 }
	 Dest[Length]=0;
     7de:	c4 0f       	add	r28, r20
     7e0:	d5 1f       	adc	r29, r21
     7e2:	18 82       	st	Y, r1
}
     7e4:	df 91       	pop	r29
     7e6:	cf 91       	pop	r28
     7e8:	08 95       	ret

000007ea <FilterBCD>:

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
	 return Result;
}
     7ea:	8f 70       	andi	r24, 0x0F	; 15
     7ec:	08 95       	ret

000007ee <BCD2Char>:

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     7ee:	8a 30       	cpi	r24, 0x0A	; 10
     7f0:	10 f0       	brcs	.+4      	; 0x7f6 <BCD2Char+0x8>
     7f2:	80 e3       	ldi	r24, 0x30	; 48
     7f4:	08 95       	ret
	     Result='0'+data;
     7f6:	80 5d       	subi	r24, 0xD0	; 208
     else Result='0';
	 return Result;
}
     7f8:	08 95       	ret

000007fa <ShiftData>:

void ShiftData(char data){//data [0]..[10]
     7fa:	98 2f       	mov	r25, r24
     7fc:	ed e0       	ldi	r30, 0x0D	; 13
     7fe:	f4 e0       	ldi	r31, 0x04	; 4
     char i;
	 for(i=11;i>0;i--){//0..10
	    zDataBuffer[i]=zDataBuffer[i-1];
     800:	80 81       	ld	r24, Z
     802:	81 83       	std	Z+1, r24	; 0x01
     804:	31 97       	sbiw	r30, 0x01	; 1
	 return Result;
}

void ShiftData(char data){//data [0]..[10]
     char i;
	 for(i=11;i>0;i--){//0..10
     806:	84 e0       	ldi	r24, 0x04	; 4
     808:	e2 30       	cpi	r30, 0x02	; 2
     80a:	f8 07       	cpc	r31, r24
     80c:	c9 f7       	brne	.-14     	; 0x800 <ShiftData+0x6>
	    zDataBuffer[i]=zDataBuffer[i-1];
	 }
	 zDataBuffer[0]=data;
     80e:	91 83       	std	Z+1, r25	; 0x01
}
     810:	08 95       	ret

00000812 <SetReceiveLine>:

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
     812:	80 93 04 01 	sts	0x0104, r24
}
     816:	08 95       	ret

00000818 <GetReceiveLine>:

char GetReceiveLine(){
     return stReceiveCom0;
}
     818:	80 91 04 01 	lds	r24, 0x0104
     81c:	08 95       	ret

0000081e <StrPosCopy>:



void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	eb 01       	movw	r28, r22
     824:	da 01       	movw	r26, r20
     826:	a8 0f       	add	r26, r24
     828:	b9 1f       	adc	r27, r25
     82a:	40 e0       	ldi	r20, 0x00	; 0
     82c:	50 e0       	ldi	r21, 0x00	; 0
     82e:	07 c0       	rjmp	.+14     	; 0x83e <StrPosCopy+0x20>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
     830:	fe 01       	movw	r30, r28
     832:	e4 0f       	add	r30, r20
     834:	f5 1f       	adc	r31, r21
     836:	8d 91       	ld	r24, X+
     838:	80 83       	st	Z, r24



void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
     83a:	4f 5f       	subi	r20, 0xFF	; 255
     83c:	5f 4f       	sbci	r21, 0xFF	; 255
     83e:	42 17       	cp	r20, r18
     840:	53 07       	cpc	r21, r19
     842:	b0 f3       	brcs	.-20     	; 0x830 <StrPosCopy+0x12>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
     844:	c2 0f       	add	r28, r18
     846:	d3 1f       	adc	r29, r19
     848:	18 82       	st	Y, r1
}
     84a:	df 91       	pop	r29
     84c:	cf 91       	pop	r28
     84e:	08 95       	ret

00000850 <CharPosCopy>:

char CharPosCopy(char *Source, unsigned int IdxSource){
     850:	fb 01       	movw	r30, r22
     852:	e8 0f       	add	r30, r24
     854:	f9 1f       	adc	r31, r25
     char Result;
          Result=Source[IdxSource];
	 return Result;
}
     856:	80 81       	ld	r24, Z
     858:	08 95       	ret

0000085a <HexToChar>:
	 }
}

char HexToChar(char xHex){
char Result='0';
     if (xHex<10) Result='0'+xHex;
     85a:	8a 30       	cpi	r24, 0x0A	; 10
     85c:	10 f4       	brcc	.+4      	; 0x862 <HexToChar+0x8>
     85e:	80 5d       	subi	r24, 0xD0	; 208
     860:	08 95       	ret
	 else 
	 if (xHex<16) Result='A'+(xHex-10); 
     862:	80 31       	cpi	r24, 0x10	; 16
     864:	10 f0       	brcs	.+4      	; 0x86a <HexToChar+0x10>
     866:	80 e3       	ldi	r24, 0x30	; 48
     868:	08 95       	ret
     86a:	89 5c       	subi	r24, 0xC9	; 201
	 else Result='0';
     return Result;
}
     86c:	08 95       	ret

0000086e <StrPosCopyReverse>:

//Copy Reverse Filtered BCD String
void StrPosCopyReverse(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     86e:	cf 93       	push	r28
     870:	df 93       	push	r29
     872:	eb 01       	movw	r28, r22
     874:	da 01       	movw	r26, r20
     876:	a8 0f       	add	r26, r24
     878:	b9 1f       	adc	r27, r25
     87a:	40 e0       	ldi	r20, 0x00	; 0
     87c:	50 e0       	ldi	r21, 0x00	; 0
     87e:	0e c0       	rjmp	.+28     	; 0x89c <StrPosCopyReverse+0x2e>
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     880:	8c 91       	ld	r24, X
     882:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     884:	8a 30       	cpi	r24, 0x0A	; 10
     886:	10 f0       	brcs	.+4      	; 0x88c <StrPosCopyReverse+0x1e>
     888:	80 e3       	ldi	r24, 0x30	; 48
     88a:	01 c0       	rjmp	.+2      	; 0x88e <StrPosCopyReverse+0x20>
	     Result='0'+data;
     88c:	80 5d       	subi	r24, 0xD0	; 208

//Copy Reverse Filtered BCD String
void StrPosCopyReverse(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     unsigned int i;
	 for (i=0;i<Length;i++){
	      Dest[i]=BCD2Char(FilterBCD(Source[IdxSource-i]));
     88e:	fe 01       	movw	r30, r28
     890:	e4 0f       	add	r30, r20
     892:	f5 1f       	adc	r31, r21
     894:	80 83       	st	Z, r24
}

//Copy Reverse Filtered BCD String
void StrPosCopyReverse(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     unsigned int i;
	 for (i=0;i<Length;i++){
     896:	4f 5f       	subi	r20, 0xFF	; 255
     898:	5f 4f       	sbci	r21, 0xFF	; 255
     89a:	11 97       	sbiw	r26, 0x01	; 1
     89c:	42 17       	cp	r20, r18
     89e:	53 07       	cpc	r21, r19
     8a0:	78 f3       	brcs	.-34     	; 0x880 <StrPosCopyReverse+0x12>
	      Dest[i]=BCD2Char(FilterBCD(Source[IdxSource-i]));
	 }Dest[Length]=0;
     8a2:	c2 0f       	add	r28, r18
     8a4:	d3 1f       	adc	r29, r19
     8a6:	18 82       	st	Y, r1
}
     8a8:	df 91       	pop	r29
     8aa:	cf 91       	pop	r28
     8ac:	08 95       	ret

000008ae <uartGilbarco>:
void StartupInfo(){
    _uart_printf(1,1,PSTR("Initialized"));
}

void uartGilbarco(){
}
     8ae:	08 95       	ret

000008b0 <FillChar>:

void FillChar(char *strMemory, unsigned int Length,char data){
     8b0:	20 e0       	ldi	r18, 0x00	; 0
     8b2:	30 e0       	ldi	r19, 0x00	; 0
     8b4:	06 c0       	rjmp	.+12     	; 0x8c2 <FillChar+0x12>
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
     8b6:	fc 01       	movw	r30, r24
     8b8:	e2 0f       	add	r30, r18
     8ba:	f3 1f       	adc	r31, r19
     8bc:	40 83       	st	Z, r20
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
     8be:	2f 5f       	subi	r18, 0xFF	; 255
     8c0:	3f 4f       	sbci	r19, 0xFF	; 255
     8c2:	26 17       	cp	r18, r22
     8c4:	37 07       	cpc	r19, r23
     8c6:	b8 f3       	brcs	.-18     	; 0x8b6 <FillChar+0x6>
	     strMemory[i]=data;
	 }
}
     8c8:	08 95       	ret

000008ca <StartupInfo>:
	 }Dest[Length]=0;
}


void StartupInfo(){
    _uart_printf(1,1,PSTR("Initialized"));
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	61 e0       	ldi	r22, 0x01	; 1
     8ce:	4a e2       	ldi	r20, 0x2A	; 42
     8d0:	51 e0       	ldi	r21, 0x01	; 1
     8d2:	0e 94 b5 1b 	call	0x376a	; 0x376a <_uart_printf>
}
     8d6:	08 95       	ret

000008d8 <AddZeroLead>:
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}

void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     8d8:	bf 92       	push	r11
     8da:	cf 92       	push	r12
     8dc:	df 92       	push	r13
     8de:	ef 92       	push	r14
     8e0:	ff 92       	push	r15
     8e2:	0f 93       	push	r16
     8e4:	1f 93       	push	r17
     8e6:	df 93       	push	r29
     8e8:	cf 93       	push	r28
     8ea:	cd b7       	in	r28, 0x3d	; 61
     8ec:	de b7       	in	r29, 0x3e	; 62
     8ee:	64 97       	sbiw	r28, 0x14	; 20
     8f0:	0f b6       	in	r0, 0x3f	; 63
     8f2:	f8 94       	cli
     8f4:	de bf       	out	0x3e, r29	; 62
     8f6:	0f be       	out	0x3f, r0	; 63
     8f8:	cd bf       	out	0x3d, r28	; 61
     8fa:	8c 01       	movw	r16, r24
     char i,Length,strAdded[20];
     Length=strlen(String);
     8fc:	fc 01       	movw	r30, r24
     8fe:	01 90       	ld	r0, Z+
     900:	00 20       	and	r0, r0
     902:	e9 f7       	brne	.-6      	; 0x8fe <AddZeroLead+0x26>
     904:	31 97       	sbiw	r30, 0x01	; 1
     906:	2e 2f       	mov	r18, r30
     908:	28 1b       	sub	r18, r24

	 if (Size>Length){
     90a:	26 17       	cp	r18, r22
     90c:	e0 f5       	brcc	.+120    	; 0x986 <AddZeroLead+0xae>
     90e:	7e 01       	movw	r14, r28
     910:	08 94       	sec
     912:	e1 1c       	adc	r14, r1
     914:	f1 1c       	adc	r15, r1
     916:	f7 01       	movw	r30, r14
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}

void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     918:	be 2c       	mov	r11, r14
     char i,Length,strAdded[20];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
     91a:	90 e3       	ldi	r25, 0x30	; 48
     91c:	01 c0       	rjmp	.+2      	; 0x920 <AddZeroLead+0x48>
     91e:	91 93       	st	Z+, r25
void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     char i,Length,strAdded[20];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
     920:	8e 2f       	mov	r24, r30
     922:	8b 19       	sub	r24, r11
     924:	86 17       	cp	r24, r22
     926:	d8 f3       	brcs	.-10     	; 0x91e <AddZeroLead+0x46>
	         strAdded[i]='0';
	     }strAdded[Size]=0;
     928:	46 2f       	mov	r20, r22
     92a:	50 e0       	ldi	r21, 0x00	; 0
     92c:	ce 01       	movw	r24, r28
     92e:	01 96       	adiw	r24, 0x01	; 1
     930:	fc 01       	movw	r30, r24
     932:	e4 0f       	add	r30, r20
     934:	f5 1f       	adc	r31, r21
     936:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
     938:	76 2f       	mov	r23, r22
     93a:	72 1b       	sub	r23, r18
     93c:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
     93e:	30 e0       	ldi	r19, 0x00	; 0
     940:	24 1b       	sub	r18, r20
     942:	35 0b       	sbc	r19, r21
     944:	0c c0       	rjmp	.+24     	; 0x95e <AddZeroLead+0x86>
     946:	e7 2f       	mov	r30, r23
     948:	f0 e0       	ldi	r31, 0x00	; 0
     94a:	d6 01       	movw	r26, r12
     94c:	ae 0f       	add	r26, r30
     94e:	bf 1f       	adc	r27, r31
     950:	e0 0f       	add	r30, r16
     952:	f1 1f       	adc	r31, r17
     954:	e2 0f       	add	r30, r18
     956:	f3 1f       	adc	r31, r19
     958:	80 81       	ld	r24, Z
     95a:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
     95c:	7f 5f       	subi	r23, 0xFF	; 255
     95e:	76 17       	cp	r23, r22
     960:	90 f3       	brcs	.-28     	; 0x946 <AddZeroLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
     962:	4c 0d       	add	r20, r12
     964:	5d 1d       	adc	r21, r13
     966:	da 01       	movw	r26, r20
     968:	1c 92       	st	X, r1
     96a:	f8 01       	movw	r30, r16
     96c:	04 c0       	rjmp	.+8      	; 0x976 <AddZeroLead+0x9e>
	     //Zeroed
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
     96e:	d7 01       	movw	r26, r14
     970:	8d 91       	ld	r24, X+
     972:	7d 01       	movw	r14, r26
     974:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Zeroed
         for(i=0;i<Size;i++){
     976:	8e 2d       	mov	r24, r14
     978:	8b 19       	sub	r24, r11
     97a:	86 17       	cp	r24, r22
     97c:	c0 f3       	brcs	.-16     	; 0x96e <AddZeroLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
     97e:	06 0f       	add	r16, r22
     980:	11 1d       	adc	r17, r1
     982:	f8 01       	movw	r30, r16
     984:	10 82       	st	Z, r1
	 }
}
     986:	64 96       	adiw	r28, 0x14	; 20
     988:	0f b6       	in	r0, 0x3f	; 63
     98a:	f8 94       	cli
     98c:	de bf       	out	0x3e, r29	; 62
     98e:	0f be       	out	0x3f, r0	; 63
     990:	cd bf       	out	0x3d, r28	; 61
     992:	cf 91       	pop	r28
     994:	df 91       	pop	r29
     996:	1f 91       	pop	r17
     998:	0f 91       	pop	r16
     99a:	ff 90       	pop	r15
     99c:	ef 90       	pop	r14
     99e:	df 90       	pop	r13
     9a0:	cf 90       	pop	r12
     9a2:	bf 90       	pop	r11
     9a4:	08 95       	ret

000009a6 <RemZeroLead>:
     char Result;
          Result=Source[IdxSource];
	 return Result;
}

void RemZeroLead(char *Zeroed){//Remove Zero Character 00001004 000050000 0 
     9a6:	cf 93       	push	r28
     9a8:	df 93       	push	r29
     9aa:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
     9ac:	fc 01       	movw	r30, r24
     9ae:	01 90       	ld	r0, Z+
     9b0:	00 20       	and	r0, r0
     9b2:	e9 f7       	brne	.-6      	; 0x9ae <RemZeroLead+0x8>
     9b4:	31 97       	sbiw	r30, 0x01	; 1
     9b6:	e8 1b       	sub	r30, r24
  if ((Length>1)&&(Zeroed[0]=='0')){
     9b8:	e2 30       	cpi	r30, 0x02	; 2
     9ba:	d0 f1       	brcs	.+116    	; 0xa30 <RemZeroLead+0x8a>
     9bc:	88 81       	ld	r24, Y
     9be:	80 33       	cpi	r24, 0x30	; 48
     9c0:	b9 f5       	brne	.+110    	; 0xa30 <RemZeroLead+0x8a>
     9c2:	4c 2f       	mov	r20, r28
     9c4:	de 01       	movw	r26, r28
     9c6:	90 e0       	ldi	r25, 0x00	; 0
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
	         if ((Zeroed[i]=='0')&&(Zeroed[i+1]=='0')&&(IsFound==False)) ZeroPos++;
     9c8:	8c 91       	ld	r24, X
     9ca:	80 33       	cpi	r24, 0x30	; 48
     9cc:	69 f4       	brne	.+26     	; 0x9e8 <RemZeroLead+0x42>
     9ce:	11 96       	adiw	r26, 0x01	; 1
     9d0:	8c 91       	ld	r24, X
     9d2:	11 97       	sbiw	r26, 0x01	; 1
     9d4:	80 33       	cpi	r24, 0x30	; 48
     9d6:	11 f4       	brne	.+4      	; 0x9dc <RemZeroLead+0x36>
     9d8:	9f 5f       	subi	r25, 0xFF	; 255
     9da:	06 c0       	rjmp	.+12     	; 0x9e8 <RemZeroLead+0x42>
             if ((Zeroed[i]=='0')&&(Zeroed[i+1]!='0')){
			     if ((Zeroed[i+1]=='.')||(Zeroed[i+1]==','))ZeroPos--;
     9dc:	8e 32       	cpi	r24, 0x2E	; 46
     9de:	11 f0       	breq	.+4      	; 0x9e4 <RemZeroLead+0x3e>
     9e0:	8c 32       	cpi	r24, 0x2C	; 44
     9e2:	41 f4       	brne	.+16     	; 0x9f4 <RemZeroLead+0x4e>
     9e4:	91 50       	subi	r25, 0x01	; 1
     9e6:	06 c0       	rjmp	.+12     	; 0x9f4 <RemZeroLead+0x4e>
     9e8:	11 96       	adiw	r26, 0x01	; 1
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
  if ((Length>1)&&(Zeroed[0]=='0')){
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
     9ea:	8a 2f       	mov	r24, r26
     9ec:	84 1b       	sub	r24, r20
     9ee:	8e 17       	cp	r24, r30
     9f0:	58 f3       	brcs	.-42     	; 0x9c8 <RemZeroLead+0x22>
     9f2:	01 c0       	rjmp	.+2      	; 0x9f6 <RemZeroLead+0x50>
		         IsFound=True;
			     break;			  
			     }
	      }

		  if (IsFound==True)ZeroPos++;
     9f4:	9f 5f       	subi	r25, 0xFF	; 255
		  if (ZeroPos>=Length)ZeroPos=Length-1;
     9f6:	9e 17       	cp	r25, r30
     9f8:	10 f0       	brcs	.+4      	; 0x9fe <RemZeroLead+0x58>
     9fa:	9e 2f       	mov	r25, r30
     9fc:	91 50       	subi	r25, 0x01	; 1
     9fe:	40 e0       	ldi	r20, 0x00	; 0
          for(i=0;i<(Length-ZeroPos);i++){
     a00:	89 2f       	mov	r24, r25
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	2e 2f       	mov	r18, r30
     a06:	30 e0       	ldi	r19, 0x00	; 0
     a08:	28 1b       	sub	r18, r24
     a0a:	39 0b       	sbc	r19, r25
	          Zeroed[i]=Zeroed[i+ZeroPos];
     a0c:	be 01       	movw	r22, r28
     a0e:	68 0f       	add	r22, r24
     a10:	79 1f       	adc	r23, r25
     a12:	09 c0       	rjmp	.+18     	; 0xa26 <RemZeroLead+0x80>
     a14:	fe 01       	movw	r30, r28
     a16:	ea 0f       	add	r30, r26
     a18:	fb 1f       	adc	r31, r27
     a1a:	a6 0f       	add	r26, r22
     a1c:	b7 1f       	adc	r27, r23
     a1e:	8c 91       	ld	r24, X
     a20:	80 83       	st	Z, r24
		      Zeroed[i+1]=0;
     a22:	11 82       	std	Z+1, r1	; 0x01
			     }
	      }

		  if (IsFound==True)ZeroPos++;
		  if (ZeroPos>=Length)ZeroPos=Length-1;
          for(i=0;i<(Length-ZeroPos);i++){
     a24:	4f 5f       	subi	r20, 0xFF	; 255
     a26:	a4 2f       	mov	r26, r20
     a28:	b0 e0       	ldi	r27, 0x00	; 0
     a2a:	a2 17       	cp	r26, r18
     a2c:	b3 07       	cpc	r27, r19
     a2e:	94 f3       	brlt	.-28     	; 0xa14 <RemZeroLead+0x6e>
	          Zeroed[i]=Zeroed[i+ZeroPos];
		      Zeroed[i+1]=0;
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}
     a30:	df 91       	pop	r29
     a32:	cf 91       	pop	r28
     a34:	08 95       	ret

00000a36 <WayneOnReceive>:
	     Dest[2*i]=(Source[FirstPos+i]>>4)+'0';
	     Dest[(2*i)+1]=(Source[FirstPos+i]&0x0F)+'0';	 
	 }Dest[2*nCount]=0;
}

void WayneOnReceive(char WayneDataIn){
     a36:	0f 93       	push	r16
     a38:	1f 93       	push	r17
     static unsigned int tCRC=0xFFFF;
     char i,strSend[40],rxNozzleID=0;
     static char zReceive=wrWaitSTX;
     static rcvBuffer[11];

		WayneRxBuffer[rxBufferLength]=WayneDataIn;// 03 FA
     a3a:	90 91 15 01 	lds	r25, 0x0115
     a3e:	e9 2f       	mov	r30, r25
     a40:	f0 e0       	ldi	r31, 0x00	; 0
     a42:	e3 5c       	subi	r30, 0xC3	; 195
     a44:	fe 4f       	sbci	r31, 0xFE	; 254
     a46:	80 83       	st	Z, r24
		if (rxBufferLength<70)
     a48:	96 34       	cpi	r25, 0x46	; 70
     a4a:	18 f4       	brcc	.+6      	; 0xa52 <WayneOnReceive+0x1c>
		    rxBufferLength++;
     a4c:	9f 5f       	subi	r25, 0xFF	; 255
     a4e:	90 93 15 01 	sts	0x0115, r25
        

		if ((WayneRxBuffer[rxBufferLength-2]==0x03)&&(WayneDataIn==0xFA)){
     a52:	20 91 15 01 	lds	r18, 0x0115
     a56:	e2 2f       	mov	r30, r18
     a58:	f0 e0       	ldi	r31, 0x00	; 0
     a5a:	e3 5c       	subi	r30, 0xC3	; 195
     a5c:	fe 4f       	sbci	r31, 0xFE	; 254
     a5e:	32 97       	sbiw	r30, 0x02	; 2
     a60:	90 81       	ld	r25, Z
     a62:	32 96       	adiw	r30, 0x02	; 2
     a64:	93 30       	cpi	r25, 0x03	; 3
     a66:	09 f0       	breq	.+2      	; 0xa6a <WayneOnReceive+0x34>
     a68:	a3 c0       	rjmp	.+326    	; 0xbb0 <WayneOnReceive+0x17a>
     a6a:	8a 3f       	cpi	r24, 0xFA	; 250
     a6c:	09 f0       	breq	.+2      	; 0xa70 <WayneOnReceive+0x3a>
     a6e:	ab c0       	rjmp	.+342    	; 0xbc6 <WayneOnReceive+0x190>
			WayneRxSequence=WayneRxBuffer[1]&0x0F;
     a70:	80 91 3e 01 	lds	r24, 0x013E
     a74:	8f 70       	andi	r24, 0x0F	; 15
     a76:	80 93 18 01 	sts	0x0118, r24
			//Message Identification
			MsgID[0]=WayneRxBuffer[2];
     a7a:	00 91 3f 01 	lds	r16, 0x013F
     a7e:	00 93 33 01 	sts	0x0133, r16
			MsgID[1]=WayneRxBuffer[3];
     a82:	90 91 40 01 	lds	r25, 0x0140
     a86:	90 93 34 01 	sts	0x0134, r25
			  0 51 3E 01 01 00 03 04 00 46 00 
			  1 02 02 08 00 00 01 54 00 00 70 
			  2 84 03 04 00 46 00 02 09 05 00 
			  3 00 02 00 00 53 66 03 FA 
			*/
            MsgInfo=MI_UNKNOWN;
     a8a:	87 e0       	ldi	r24, 0x07	; 7
     a8c:	80 93 19 01 	sts	0x0119, r24
            if ((MsgID[0]==0x06)&&(MsgID[1]==0x1F)&&(rxBufferLength>=57)){
     a90:	06 30       	cpi	r16, 0x06	; 6
     a92:	71 f5       	brne	.+92     	; 0xaf0 <WayneOnReceive+0xba>
     a94:	9f 31       	cpi	r25, 0x1F	; 31
     a96:	09 f0       	breq	.+2      	; 0xa9a <WayneOnReceive+0x64>
     a98:	89 c0       	rjmp	.+274    	; 0xbac <WayneOnReceive+0x176>
     a9a:	29 33       	cpi	r18, 0x39	; 57
     a9c:	08 f4       	brcc	.+2      	; 0xaa0 <WayneOnReceive+0x6a>
     a9e:	86 c0       	rjmp	.+268    	; 0xbac <WayneOnReceive+0x176>
			     MsgInfo=MI_TOTALIZER;
     aa0:	88 e0       	ldi	r24, 0x08	; 8
     aa2:	80 93 19 01 	sts	0x0119, r24
			     rxNozzleID=(WayneRxBuffer[37]&0x0F);
				 ExtractValue(WayneRxBuffer,38,5,PumpTotalizer.TotalGrade[rxNozzleID-1].strVolume);		
     aa6:	00 91 62 01 	lds	r16, 0x0162
     aaa:	0f 70       	andi	r16, 0x0F	; 15
     aac:	10 e0       	ldi	r17, 0x00	; 0
     aae:	c8 01       	movw	r24, r16
     ab0:	01 97       	sbiw	r24, 0x01	; 1
     ab2:	9c 01       	movw	r18, r24
     ab4:	55 e0       	ldi	r21, 0x05	; 5
     ab6:	22 0f       	add	r18, r18
     ab8:	33 1f       	adc	r19, r19
     aba:	5a 95       	dec	r21
     abc:	e1 f7       	brne	.-8      	; 0xab6 <WayneOnReceive+0x80>
     abe:	88 0f       	add	r24, r24
     ac0:	99 1f       	adc	r25, r25
     ac2:	28 1b       	sub	r18, r24
     ac4:	39 0b       	sbc	r19, r25
     ac6:	29 50       	subi	r18, 0x09	; 9
     ac8:	3d 4f       	sbci	r19, 0xFD	; 253
     aca:	8d e3       	ldi	r24, 0x3D	; 61
     acc:	91 e0       	ldi	r25, 0x01	; 1
     ace:	66 e2       	ldi	r22, 0x26	; 38
     ad0:	45 e0       	ldi	r20, 0x05	; 5
     ad2:	0e 94 35 02 	call	0x46a	; 0x46a <ExtractValue>
				 RemZeroLead(PumpTotalizer.TotalGrade[rxNozzleID].strVolume);
     ad6:	c8 01       	movw	r24, r16
     ad8:	35 e0       	ldi	r19, 0x05	; 5
     ada:	88 0f       	add	r24, r24
     adc:	99 1f       	adc	r25, r25
     ade:	3a 95       	dec	r19
     ae0:	e1 f7       	brne	.-8      	; 0xada <WayneOnReceive+0xa4>
     ae2:	00 0f       	add	r16, r16
     ae4:	11 1f       	adc	r17, r17
     ae6:	80 1b       	sub	r24, r16
     ae8:	91 0b       	sbc	r25, r17
     aea:	89 50       	subi	r24, 0x09	; 9
     aec:	9d 4f       	sbci	r25, 0xFD	; 253
     aee:	38 c0       	rjmp	.+112    	; 0xb60 <WayneOnReceive+0x12a>
			     sprintf_P(strSend,PSTR("Totalizer%d:[V:%s]"),rxNozzleID,PumpTotalizer.TotalGrade[rxNozzleID].strVolume);
			     _uart_print(1,1,strSend);
				 #endif

			}
            if ((MsgID[0]==0x01)&&(MsgID[1]==0x01)&&(rxBufferLength>=38)){//Last Transaction
     af0:	01 30       	cpi	r16, 0x01	; 1
     af2:	a9 f4       	brne	.+42     	; 0xb1e <WayneOnReceive+0xe8>
     af4:	91 30       	cpi	r25, 0x01	; 1
     af6:	09 f0       	breq	.+2      	; 0xafa <WayneOnReceive+0xc4>
     af8:	59 c0       	rjmp	.+178    	; 0xbac <WayneOnReceive+0x176>
     afa:	26 32       	cpi	r18, 0x26	; 38
     afc:	08 f4       	brcc	.+2      	; 0xb00 <WayneOnReceive+0xca>
     afe:	56 c0       	rjmp	.+172    	; 0xbac <WayneOnReceive+0x176>
			     //Vol:13-16 Amount:17-20
				 MsgInfo=MI_LAST_TRANSACTION;
     b00:	86 e0       	ldi	r24, 0x06	; 6
     b02:	80 93 19 01 	sts	0x0119, r24
				 ExtractValue(WayneRxBuffer,13,4,strVolume);
     b06:	8d e3       	ldi	r24, 0x3D	; 61
     b08:	91 e0       	ldi	r25, 0x01	; 1
     b0a:	6d e0       	ldi	r22, 0x0D	; 13
     b0c:	44 e0       	ldi	r20, 0x04	; 4
     b0e:	27 e5       	ldi	r18, 0x57	; 87
     b10:	32 e0       	ldi	r19, 0x02	; 2
     b12:	0e 94 35 02 	call	0x46a	; 0x46a <ExtractValue>
				 ExtractValue(WayneRxBuffer,17,4,strAmount);
     b16:	8d e3       	ldi	r24, 0x3D	; 61
     b18:	91 e0       	ldi	r25, 0x01	; 1
     b1a:	61 e1       	ldi	r22, 0x11	; 17
     b1c:	16 c0       	rjmp	.+44     	; 0xb4a <WayneOnReceive+0x114>
			     _uart_print(1,1,strSend);
				 #endif

			}   // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18
			    //51 34 02 08 00 00 01 88 00 00 84 60 01 01 05 38 4E 03 FA 
			if ((MsgID[0]==0x02)&&(MsgID[1]==0x08)&&(rxBufferLength>=19)){//Last Transaction
     b1e:	02 30       	cpi	r16, 0x02	; 2
     b20:	11 f5       	brne	.+68     	; 0xb66 <WayneOnReceive+0x130>
     b22:	98 30       	cpi	r25, 0x08	; 8
     b24:	09 f0       	breq	.+2      	; 0xb28 <WayneOnReceive+0xf2>
     b26:	42 c0       	rjmp	.+132    	; 0xbac <WayneOnReceive+0x176>
     b28:	23 31       	cpi	r18, 0x13	; 19
     b2a:	08 f4       	brcc	.+2      	; 0xb2e <WayneOnReceive+0xf8>
     b2c:	3f c0       	rjmp	.+126    	; 0xbac <WayneOnReceive+0x176>
			     //Vol:13-16 Amount:17-20
				 MsgInfo=MI_LAST_TRANSACTION;
     b2e:	86 e0       	ldi	r24, 0x06	; 6
     b30:	80 93 19 01 	sts	0x0119, r24
				 ExtractValue(WayneRxBuffer,4,4,strVolume);
     b34:	8d e3       	ldi	r24, 0x3D	; 61
     b36:	91 e0       	ldi	r25, 0x01	; 1
     b38:	64 e0       	ldi	r22, 0x04	; 4
     b3a:	44 e0       	ldi	r20, 0x04	; 4
     b3c:	27 e5       	ldi	r18, 0x57	; 87
     b3e:	32 e0       	ldi	r19, 0x02	; 2
     b40:	0e 94 35 02 	call	0x46a	; 0x46a <ExtractValue>
				 ExtractValue(WayneRxBuffer,8,4,strAmount);
     b44:	8d e3       	ldi	r24, 0x3D	; 61
     b46:	91 e0       	ldi	r25, 0x01	; 1
     b48:	68 e0       	ldi	r22, 0x08	; 8
     b4a:	44 e0       	ldi	r20, 0x04	; 4
     b4c:	2b ea       	ldi	r18, 0xAB	; 171
     b4e:	33 e0       	ldi	r19, 0x03	; 3
     b50:	0e 94 35 02 	call	0x46a	; 0x46a <ExtractValue>
				 RemZeroLead(strVolume);
     b54:	87 e5       	ldi	r24, 0x57	; 87
     b56:	92 e0       	ldi	r25, 0x02	; 2
     b58:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <RemZeroLead>
				 RemZeroLead(strAmount);
     b5c:	8b ea       	ldi	r24, 0xAB	; 171
     b5e:	93 e0       	ldi	r25, 0x03	; 3
     b60:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <RemZeroLead>
     b64:	23 c0       	rjmp	.+70     	; 0xbac <WayneOnReceive+0x176>
			     sprintf_P(strSend,PSTR("Trans:[V:%s][A:%s]"),strVolume,strAmount);
			     _uart_print(1,1,strSend);
				 #endif
			}			

            if ((MsgID[0]==0x03)&&(MsgID[1]==0x04)){//PriceNozzleInfo
     b66:	03 30       	cpi	r16, 0x03	; 3
     b68:	09 f5       	brne	.+66     	; 0xbac <WayneOnReceive+0x176>
     b6a:	94 30       	cpi	r25, 0x04	; 4
     b6c:	f9 f4       	brne	.+62     	; 0xbac <WayneOnReceive+0x176>
			     if ((WayneRxBuffer[7]>>4)==0x01){
     b6e:	80 91 44 01 	lds	r24, 0x0144
     b72:	82 95       	swap	r24
     b74:	8f 70       	andi	r24, 0x0F	; 15
     b76:	81 30       	cpi	r24, 0x01	; 1
     b78:	21 f4       	brne	.+8      	; 0xb82 <WayneOnReceive+0x14c>
				      MsgInfo=MI_NOZZLE_UP;
     b7a:	82 e0       	ldi	r24, 0x02	; 2
     b7c:	80 93 19 01 	sts	0x0119, r24
     b80:	10 c0       	rjmp	.+32     	; 0xba2 <WayneOnReceive+0x16c>
					  #ifdef DEBUG_WAYNE_RECEIVE 
					  _uart_printf(1,1,PSTR("-WR_MESSAGE Nozzle Up-"));
					  #endif
					  }
                 else
			     if ((WayneRxBuffer[7]>>4)==0x00){
     b82:	88 23       	and	r24, r24
     b84:	71 f4       	brne	.+28     	; 0xba2 <WayneOnReceive+0x16c>
				      //Price
					  ExtractValue(WayneRxBuffer,4,3,strUnitPrice);
     b86:	8d e3       	ldi	r24, 0x3D	; 61
     b88:	91 e0       	ldi	r25, 0x01	; 1
     b8a:	64 e0       	ldi	r22, 0x04	; 4
     b8c:	43 e0       	ldi	r20, 0x03	; 3
     b8e:	2c ea       	ldi	r18, 0xAC	; 172
     b90:	32 e0       	ldi	r19, 0x02	; 2
     b92:	0e 94 35 02 	call	0x46a	; 0x46a <ExtractValue>
					  RemZeroLead(strUnitPrice);
     b96:	8c ea       	ldi	r24, 0xAC	; 172
     b98:	92 e0       	ldi	r25, 0x02	; 2
     b9a:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <RemZeroLead>
					  #ifdef DEBUG_WAYNE_RECEIVE
			          sprintf_P(strSend,PSTR("Price%s"),strUnitPrice);
			          _uart_print(1,1,strSend);
					  #endif
				      MsgInfo=MI_NOZZLE_DOWN;
     b9e:	00 93 19 01 	sts	0x0119, r16
					  #ifdef DEBUG_WAYNE_RECEIVE 
					  _uart_printf(1,1,PSTR("-WR_MESSAGE Nozzle Down-"));
					  #endif
					  }
            ActiveNozzle=WayneRxBuffer[7]&0x0F;
     ba2:	80 91 44 01 	lds	r24, 0x0144
     ba6:	8f 70       	andi	r24, 0x0F	; 15
     ba8:	80 93 1c 01 	sts	0x011C, r24
            }
        WayneReply=WR_MESSAGE;
     bac:	84 e0       	ldi	r24, 0x04	; 4
     bae:	07 c0       	rjmp	.+14     	; 0xbbe <WayneOnReceive+0x188>
		rxBufferLength=0;	
		}else
		if ((WayneRxBuffer[rxBufferLength-2]==0x70)&&(WayneRxBuffer[rxBufferLength-1]==0xFA)){
     bb0:	90 37       	cpi	r25, 0x70	; 112
     bb2:	49 f4       	brne	.+18     	; 0xbc6 <WayneOnReceive+0x190>
     bb4:	31 97       	sbiw	r30, 0x01	; 1
     bb6:	80 81       	ld	r24, Z
     bb8:	8a 3f       	cpi	r24, 0xFA	; 250
     bba:	29 f4       	brne	.+10     	; 0xbc6 <WayneOnReceive+0x190>
		
		    #ifdef DEBUG_WAYNE_RECEIVE 
			_uart_printf(1,1,PSTR("-WR_READY-"));
			#endif
		    WayneReply=WR_READY;
     bbc:	81 e0       	ldi	r24, 0x01	; 1
     bbe:	80 93 1a 01 	sts	0x011A, r24
		    rxBufferLength=0;
     bc2:	10 92 15 01 	sts	0x0115, r1
		}
		if (((WayneRxBuffer[rxBufferLength-3]&0xF0)==0x50)&&(WayneRxBuffer[rxBufferLength-1]==0xFA)){
     bc6:	80 91 15 01 	lds	r24, 0x0115
     bca:	a8 2f       	mov	r26, r24
     bcc:	b0 e0       	ldi	r27, 0x00	; 0
     bce:	a3 5c       	subi	r26, 0xC3	; 195
     bd0:	be 4f       	sbci	r27, 0xFE	; 254
     bd2:	13 97       	sbiw	r26, 0x03	; 3
     bd4:	8c 91       	ld	r24, X
     bd6:	13 96       	adiw	r26, 0x03	; 3
     bd8:	80 7f       	andi	r24, 0xF0	; 240
     bda:	80 35       	cpi	r24, 0x50	; 80
     bdc:	c1 f4       	brne	.+48     	; 0xc0e <WayneOnReceive+0x1d8>
     bde:	fd 01       	movw	r30, r26
     be0:	31 97       	sbiw	r30, 0x01	; 1
     be2:	80 81       	ld	r24, Z
     be4:	8a 3f       	cpi	r24, 0xFA	; 250
     be6:	99 f4       	brne	.+38     	; 0xc0e <WayneOnReceive+0x1d8>
              if ((WayneRxBuffer[rxBufferLength-2]&0xF0)==0xC0){
     be8:	fd 01       	movw	r30, r26
     bea:	32 97       	sbiw	r30, 0x02	; 2
     bec:	80 81       	ld	r24, Z
     bee:	90 e0       	ldi	r25, 0x00	; 0
     bf0:	80 7f       	andi	r24, 0xF0	; 240
     bf2:	90 70       	andi	r25, 0x00	; 0
     bf4:	80 3c       	cpi	r24, 0xC0	; 192
     bf6:	91 05       	cpc	r25, r1
     bf8:	11 f4       	brne	.+4      	; 0xbfe <WayneOnReceive+0x1c8>
		         #ifdef DEBUG_WAYNE_RECEIVE 
				 _uart_printf(1,1,PSTR("-WR_ACK-"));
				 #endif
		         WayneReply=WR_ACK;
     bfa:	82 e0       	ldi	r24, 0x02	; 2
     bfc:	04 c0       	rjmp	.+8      	; 0xc06 <WayneOnReceive+0x1d0>
			 }else if ((WayneRxBuffer[rxBufferLength-2]&0xF0)==0x50){
     bfe:	80 35       	cpi	r24, 0x50	; 80
     c00:	91 05       	cpc	r25, r1
     c02:	19 f4       	brne	.+6      	; 0xc0a <WayneOnReceive+0x1d4>
		         #ifdef DEBUG_WAYNE_RECEIVE 
				 _uart_printf(1,1,PSTR("-WR_NACK-"));
				 #endif
		         WayneReply=WR_NACK;
     c04:	83 e0       	ldi	r24, 0x03	; 3
     c06:	80 93 1a 01 	sts	0x011A, r24
			 }
             rxBufferLength=0;
     c0a:	10 92 15 01 	sts	0x0115, r1
		}
}
     c0e:	1f 91       	pop	r17
     c10:	0f 91       	pop	r16
     c12:	08 95       	ret

00000c14 <StrReverse>:
}

void systemServiceSPI(){
}

void StrReverse(char *strSource){// 0054->4500
     c14:	df 93       	push	r29
     c16:	cf 93       	push	r28
     c18:	cd b7       	in	r28, 0x3d	; 61
     c1a:	de b7       	in	r29, 0x3e	; 62
     c1c:	64 97       	sbiw	r28, 0x14	; 20
     c1e:	0f b6       	in	r0, 0x3f	; 63
     c20:	f8 94       	cli
     c22:	de bf       	out	0x3e, r29	; 62
     c24:	0f be       	out	0x3f, r0	; 63
     c26:	cd bf       	out	0x3d, r28	; 61
     c28:	ac 01       	movw	r20, r24
     char i,Length,strResult[20];
	 Length=strlen(strSource);
     c2a:	fc 01       	movw	r30, r24
     c2c:	01 90       	ld	r0, Z+
     c2e:	00 20       	and	r0, r0
     c30:	e9 f7       	brne	.-6      	; 0xc2c <StrReverse+0x18>
     c32:	31 97       	sbiw	r30, 0x01	; 1
     c34:	2e 2f       	mov	r18, r30
     c36:	28 1b       	sub	r18, r24
     c38:	a2 2f       	mov	r26, r18
     c3a:	b0 e0       	ldi	r27, 0x00	; 0
     c3c:	11 97       	sbiw	r26, 0x01	; 1
     c3e:	a8 0f       	add	r26, r24
     c40:	b9 1f       	adc	r27, r25
     c42:	be 01       	movw	r22, r28
     c44:	6f 5f       	subi	r22, 0xFF	; 255
     c46:	7f 4f       	sbci	r23, 0xFF	; 255
     c48:	fb 01       	movw	r30, r22
     c4a:	03 c0       	rjmp	.+6      	; 0xc52 <StrReverse+0x3e>
	 for(i=0;i<Length;i++){
	    strResult[i]=strSource[Length-i-1];
     c4c:	8c 91       	ld	r24, X
     c4e:	81 93       	st	Z+, r24
     c50:	11 97       	sbiw	r26, 0x01	; 1
}

void StrReverse(char *strSource){// 0054->4500
     char i,Length,strResult[20];
	 Length=strlen(strSource);
	 for(i=0;i<Length;i++){
     c52:	8e 2f       	mov	r24, r30
     c54:	86 1b       	sub	r24, r22
     c56:	82 17       	cp	r24, r18
     c58:	c8 f3       	brcs	.-14     	; 0xc4c <StrReverse+0x38>
	    strResult[i]=strSource[Length-i-1];
	 }strResult[Length]=0;
     c5a:	ce 01       	movw	r24, r28
     c5c:	01 96       	adiw	r24, 0x01	; 1
     c5e:	fc 01       	movw	r30, r24
     c60:	e2 0f       	add	r30, r18
     c62:	f1 1d       	adc	r31, r1
     c64:	10 82       	st	Z, r1
     c66:	60 e0       	ldi	r22, 0x00	; 0
	 //CopyResult
	 for(i=0;i<strlen(strResult);i++){
     c68:	9c 01       	movw	r18, r24
     c6a:	09 c0       	rjmp	.+18     	; 0xc7e <StrReverse+0x6a>
	    strSource[i]=strResult[i];
     c6c:	fa 01       	movw	r30, r20
     c6e:	ea 0f       	add	r30, r26
     c70:	fb 1f       	adc	r31, r27
     c72:	a2 0f       	add	r26, r18
     c74:	b3 1f       	adc	r27, r19
     c76:	8c 91       	ld	r24, X
     c78:	80 83       	st	Z, r24
	    strSource[i+1]=0;
     c7a:	11 82       	std	Z+1, r1	; 0x01
	 Length=strlen(strSource);
	 for(i=0;i<Length;i++){
	    strResult[i]=strSource[Length-i-1];
	 }strResult[Length]=0;
	 //CopyResult
	 for(i=0;i<strlen(strResult);i++){
     c7c:	6f 5f       	subi	r22, 0xFF	; 255
     c7e:	a6 2f       	mov	r26, r22
     c80:	b0 e0       	ldi	r27, 0x00	; 0
     c82:	f9 01       	movw	r30, r18
     c84:	01 90       	ld	r0, Z+
     c86:	00 20       	and	r0, r0
     c88:	e9 f7       	brne	.-6      	; 0xc84 <StrReverse+0x70>
     c8a:	31 97       	sbiw	r30, 0x01	; 1
     c8c:	e2 1b       	sub	r30, r18
     c8e:	f3 0b       	sbc	r31, r19
     c90:	ae 17       	cp	r26, r30
     c92:	bf 07       	cpc	r27, r31
     c94:	58 f3       	brcs	.-42     	; 0xc6c <StrReverse+0x58>
	    strSource[i]=strResult[i];
	    strSource[i+1]=0;
	 }
}
     c96:	64 96       	adiw	r28, 0x14	; 20
     c98:	0f b6       	in	r0, 0x3f	; 63
     c9a:	f8 94       	cli
     c9c:	de bf       	out	0x3e, r29	; 62
     c9e:	0f be       	out	0x3f, r0	; 63
     ca0:	cd bf       	out	0x3d, r28	; 61
     ca2:	cf 91       	pop	r28
     ca4:	df 91       	pop	r29
     ca6:	08 95       	ret

00000ca8 <GilbarcoOnReceive>:
	else
	if (data==0xF5)SavePipeline=spTotalizerPPU2;
	
}

void GilbarcoOnReceive(char data){
     ca8:	1f 93       	push	r17
     caa:	cf 93       	push	r28
     cac:	df 93       	push	r29
     cae:	18 2f       	mov	r17, r24
     cb0:	ed e0       	ldi	r30, 0x0D	; 13
     cb2:	f4 e0       	ldi	r31, 0x04	; 4
}

void ShiftData(char data){//data [0]..[10]
     char i;
	 for(i=11;i>0;i--){//0..10
	    zDataBuffer[i]=zDataBuffer[i-1];
     cb4:	80 81       	ld	r24, Z
     cb6:	81 83       	std	Z+1, r24	; 0x01
     cb8:	31 97       	sbiw	r30, 0x01	; 1
	 return Result;
}

void ShiftData(char data){//data [0]..[10]
     char i;
	 for(i=11;i>0;i--){//0..10
     cba:	84 e0       	ldi	r24, 0x04	; 4
     cbc:	e2 30       	cpi	r30, 0x02	; 2
     cbe:	f8 07       	cpc	r31, r24
     cc0:	c9 f7       	brne	.-14     	; 0xcb4 <GilbarcoOnReceive+0xc>
	    zDataBuffer[i]=zDataBuffer[i-1];
	 }
	 zDataBuffer[0]=data;
     cc2:	11 83       	std	Z+1, r17	; 0x01
void GilbarcoOnReceive(char data){
char strSend[30],chrData,i;
static char iReceive=0;
    ShiftData(data);
	 
    switch(stReceiveCom0){
     cc4:	90 91 04 01 	lds	r25, 0x0104
     cc8:	93 30       	cpi	r25, 0x03	; 3
     cca:	d1 f1       	breq	.+116    	; 0xd40 <GilbarcoOnReceive+0x98>
     ccc:	94 30       	cpi	r25, 0x04	; 4
     cce:	30 f4       	brcc	.+12     	; 0xcdc <GilbarcoOnReceive+0x34>
     cd0:	91 30       	cpi	r25, 0x01	; 1
     cd2:	69 f0       	breq	.+26     	; 0xcee <GilbarcoOnReceive+0x46>
     cd4:	92 30       	cpi	r25, 0x02	; 2
     cd6:	09 f0       	breq	.+2      	; 0xcda <GilbarcoOnReceive+0x32>
     cd8:	9f c0       	rjmp	.+318    	; 0xe18 <GilbarcoOnReceive+0x170>
     cda:	14 c0       	rjmp	.+40     	; 0xd04 <GilbarcoOnReceive+0x5c>
     cdc:	95 30       	cpi	r25, 0x05	; 5
     cde:	09 f4       	brne	.+2      	; 0xce2 <GilbarcoOnReceive+0x3a>
     ce0:	47 c0       	rjmp	.+142    	; 0xd70 <GilbarcoOnReceive+0xc8>
     ce2:	95 30       	cpi	r25, 0x05	; 5
     ce4:	c0 f1       	brcs	.+112    	; 0xd56 <GilbarcoOnReceive+0xae>
     ce6:	96 30       	cpi	r25, 0x06	; 6
     ce8:	09 f0       	breq	.+2      	; 0xcec <GilbarcoOnReceive+0x44>
     cea:	96 c0       	rjmp	.+300    	; 0xe18 <GilbarcoOnReceive+0x170>
     cec:	78 c0       	rjmp	.+240    	; 0xdde <GilbarcoOnReceive+0x136>
	case rcIdle:
	     CMDResponse=GetResponse(data);
     cee:	81 2f       	mov	r24, r17
     cf0:	82 95       	swap	r24
     cf2:	8f 70       	andi	r24, 0x0F	; 15
     cf4:	80 93 8d 01 	sts	0x018D, r24
		 PumpID=GetPumpID(data);
     cf8:	1f 70       	andi	r17, 0x0F	; 15
     cfa:	10 93 0e 01 	sts	0x010E, r17
		 IsStatusReceived=True;
     cfe:	90 93 0f 01 	sts	0x010F, r25
     d02:	8a c0       	rjmp	.+276    	; 0xe18 <GilbarcoOnReceive+0x170>

	     break;	
	case rcRealTimeMoney:	     
	     strCurrentMoney[Com0ReceiveCount]=BCD2Char(FilterBCD(data));
     d04:	90 91 23 01 	lds	r25, 0x0123
     d08:	e9 2f       	mov	r30, r25
     d0a:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     d0c:	81 2f       	mov	r24, r17
     d0e:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     d10:	8a 30       	cpi	r24, 0x0A	; 10
     d12:	10 f0       	brcs	.+4      	; 0xd18 <GilbarcoOnReceive+0x70>
     d14:	80 e3       	ldi	r24, 0x30	; 48
     d16:	01 c0       	rjmp	.+2      	; 0xd1a <GilbarcoOnReceive+0x72>
	     Result='0'+data;
     d18:	80 5d       	subi	r24, 0xD0	; 208
		 PumpID=GetPumpID(data);
		 IsStatusReceived=True;

	     break;	
	case rcRealTimeMoney:	     
	     strCurrentMoney[Com0ReceiveCount]=BCD2Char(FilterBCD(data));
     d1a:	e8 58       	subi	r30, 0x88	; 136
     d1c:	fd 4f       	sbci	r31, 0xFD	; 253
     d1e:	80 83       	st	Z, r24
	     strCurrentMoney[Com0ReceiveCount+1]=0;
     d20:	11 82       	std	Z+1, r1	; 0x01
		 TimReceive=0;
     d22:	10 92 10 04 	sts	0x0410, r1
     d26:	10 92 0f 04 	sts	0x040F, r1
		 Com0ReceiveCount++;
     d2a:	89 2f       	mov	r24, r25
     d2c:	8f 5f       	subi	r24, 0xFF	; 255
     d2e:	80 93 23 01 	sts	0x0123, r24
	     if ((Com0ReceiveCount>6)||(TimReceive>MSG_TRANSACTION_TIMEOUT))
     d32:	87 30       	cpi	r24, 0x07	; 7
     d34:	08 f4       	brcc	.+2      	; 0xd38 <GilbarcoOnReceive+0x90>
     d36:	70 c0       	rjmp	.+224    	; 0xe18 <GilbarcoOnReceive+0x170>
		     IsMoneyReceived=True;
     d38:	81 e0       	ldi	r24, 0x01	; 1
     d3a:	80 93 10 01 	sts	0x0110, r24
     d3e:	6c c0       	rjmp	.+216    	; 0xe18 <GilbarcoOnReceive+0x170>
	     break;	
    case rcInitTransaction://<STX>
	     if (data==0xFF){
     d40:	1f 3f       	cpi	r17, 0xFF	; 255
     d42:	09 f0       	breq	.+2      	; 0xd46 <GilbarcoOnReceive+0x9e>
     d44:	69 c0       	rjmp	.+210    	; 0xe18 <GilbarcoOnReceive+0x170>
		    iReceive=0;
     d46:	10 92 27 01 	sts	0x0127, r1
			TimReceive=0;
     d4a:	10 92 10 04 	sts	0x0410, r1
     d4e:	10 92 0f 04 	sts	0x040F, r1
		    stReceiveCom0=rcSaveTransactionMessage;
     d52:	86 e0       	ldi	r24, 0x06	; 6
     d54:	0a c0       	rjmp	.+20     	; 0xd6a <GilbarcoOnReceive+0xc2>
		 }
	     break;
    case rcInitTotalizer://<STX>
	     if (data==0xFF){
     d56:	1f 3f       	cpi	r17, 0xFF	; 255
     d58:	09 f0       	breq	.+2      	; 0xd5c <GilbarcoOnReceive+0xb4>
     d5a:	5e c0       	rjmp	.+188    	; 0xe18 <GilbarcoOnReceive+0x170>
		    iReceive=0;
     d5c:	10 92 27 01 	sts	0x0127, r1
			TimReceive=0;
     d60:	10 92 10 04 	sts	0x0410, r1
     d64:	10 92 0f 04 	sts	0x040F, r1
		    stReceiveCom0=rcSaveTotalizerMessage;
     d68:	85 e0       	ldi	r24, 0x05	; 5
     d6a:	80 93 04 01 	sts	0x0104, r24
     d6e:	54 c0       	rjmp	.+168    	; 0xe18 <GilbarcoOnReceive+0x170>
		 }
	     break;
    case rcSaveTotalizerMessage:
	     //_uart(1,1,data);
	     SaveTotalizerData(data);
     d70:	81 2f       	mov	r24, r17
     d72:	0e 94 2e 03 	call	0x65c	; 0x65c <SaveTotalizerData>
	     if ((data==0xF0)||(TimReceive>MSG_TRANSACTION_TIMEOUT)){//Proses
     d76:	10 3f       	cpi	r17, 0xF0	; 240
     d78:	41 f0       	breq	.+16     	; 0xd8a <GilbarcoOnReceive+0xe2>
     d7a:	80 91 0f 04 	lds	r24, 0x040F
     d7e:	90 91 10 04 	lds	r25, 0x0410
     d82:	89 3c       	cpi	r24, 0xC9	; 201
     d84:	91 05       	cpc	r25, r1
     d86:	08 f4       	brcc	.+2      	; 0xd8a <GilbarcoOnReceive+0xe2>
     d88:	47 c0       	rjmp	.+142    	; 0xe18 <GilbarcoOnReceive+0x170>
     d8a:	c0 e0       	ldi	r28, 0x00	; 0
     d8c:	d0 e0       	ldi	r29, 0x00	; 0
             //ReverseData
			 //_uart_printf(1,1,PSTR("Totalizer: "));
			 for (i=0;i<6;i++){
			 	  StrReverse(PumpTotalizer.TotalGrade[i].strMoney);
     d8e:	9e 01       	movw	r18, r28
     d90:	ce 01       	movw	r24, r28
     d92:	f5 e0       	ldi	r31, 0x05	; 5
     d94:	88 0f       	add	r24, r24
     d96:	99 1f       	adc	r25, r25
     d98:	fa 95       	dec	r31
     d9a:	e1 f7       	brne	.-8      	; 0xd94 <GilbarcoOnReceive+0xec>
     d9c:	22 0f       	add	r18, r18
     d9e:	33 1f       	adc	r19, r19
     da0:	82 1b       	sub	r24, r18
     da2:	93 0b       	sbc	r25, r19
     da4:	8a 5f       	subi	r24, 0xFA	; 250
     da6:	9c 4f       	sbci	r25, 0xFC	; 252
     da8:	0e 94 0a 06 	call	0xc14	; 0xc14 <StrReverse>
				  StrReverse(PumpTotalizer.TotalGrade[i].strVolume);
     dac:	9e 01       	movw	r18, r28
     dae:	ce 01       	movw	r24, r28
     db0:	75 e0       	ldi	r23, 0x05	; 5
     db2:	88 0f       	add	r24, r24
     db4:	99 1f       	adc	r25, r25
     db6:	7a 95       	dec	r23
     db8:	e1 f7       	brne	.-8      	; 0xdb2 <GilbarcoOnReceive+0x10a>
     dba:	22 0f       	add	r18, r18
     dbc:	33 1f       	adc	r19, r19
     dbe:	82 1b       	sub	r24, r18
     dc0:	93 0b       	sbc	r25, r19
     dc2:	89 50       	subi	r24, 0x09	; 9
     dc4:	9d 4f       	sbci	r25, 0xFD	; 253
     dc6:	0e 94 0a 06 	call	0xc14	; 0xc14 <StrReverse>
     dca:	21 96       	adiw	r28, 0x01	; 1
	     //_uart(1,1,data);
	     SaveTotalizerData(data);
	     if ((data==0xF0)||(TimReceive>MSG_TRANSACTION_TIMEOUT)){//Proses
             //ReverseData
			 //_uart_printf(1,1,PSTR("Totalizer: "));
			 for (i=0;i<6;i++){
     dcc:	c6 30       	cpi	r28, 0x06	; 6
     dce:	d1 05       	cpc	r29, r1
     dd0:	f1 f6       	brne	.-68     	; 0xd8e <GilbarcoOnReceive+0xe6>
			 	  StrReverse(PumpTotalizer.TotalGrade[i].strMoney);
				  StrReverse(PumpTotalizer.TotalGrade[i].strVolume);
				  //_uart_print(1,1,PumpTotalizer.TotalGrade[i].strMoney);
				  //_uart_print(1,1,PumpTotalizer.TotalGrade[i].strVolume);
             }
		     stReceiveCom0=rcIdle;
     dd2:	81 e0       	ldi	r24, 0x01	; 1
     dd4:	80 93 04 01 	sts	0x0104, r24
			 IsTotalizer=True;
     dd8:	80 93 12 01 	sts	0x0112, r24
     ddc:	1d c0       	rjmp	.+58     	; 0xe18 <GilbarcoOnReceive+0x170>
			 }		 
         break;	
    case rcSaveTransactionMessage:
	     //_uart(1,1,data);
	     SaveTransactionData(data);
     dde:	81 2f       	mov	r24, r17
     de0:	0e 94 a8 02 	call	0x550	; 0x550 <SaveTransactionData>
	     if ((data==0xF0)||(TimReceive>MSG_TRANSACTION_TIMEOUT)){//Proses
     de4:	10 3f       	cpi	r17, 0xF0	; 240
     de6:	39 f0       	breq	.+14     	; 0xdf6 <GilbarcoOnReceive+0x14e>
     de8:	80 91 0f 04 	lds	r24, 0x040F
     dec:	90 91 10 04 	lds	r25, 0x0410
     df0:	89 3c       	cpi	r24, 0xC9	; 201
     df2:	91 05       	cpc	r25, r1
     df4:	88 f0       	brcs	.+34     	; 0xe18 <GilbarcoOnReceive+0x170>
			  StrReverse(strUnitPrice);
     df6:	8c ea       	ldi	r24, 0xAC	; 172
     df8:	92 e0       	ldi	r25, 0x02	; 2
     dfa:	0e 94 0a 06 	call	0xc14	; 0xc14 <StrReverse>
			  StrReverse(strVolume);
     dfe:	87 e5       	ldi	r24, 0x57	; 87
     e00:	92 e0       	ldi	r25, 0x02	; 2
     e02:	0e 94 0a 06 	call	0xc14	; 0xc14 <StrReverse>
			  StrReverse(strAmount);
     e06:	8b ea       	ldi	r24, 0xAB	; 171
     e08:	93 e0       	ldi	r25, 0x03	; 3
     e0a:	0e 94 0a 06 	call	0xc14	; 0xc14 <StrReverse>

			  //sprintf_P(strSend,PSTR("%s"),strAmount);
			  //_uart_print(1,1,strSend);

              stReceiveCom0=rcIdle;
     e0e:	81 e0       	ldi	r24, 0x01	; 1
     e10:	80 93 04 01 	sts	0x0104, r24
			  IsTransaction=True;
     e14:	80 93 11 01 	sts	0x0111, r24
			 }
	     break;
	}
}
     e18:	df 91       	pop	r29
     e1a:	cf 91       	pop	r28
     e1c:	1f 91       	pop	r17
     e1e:	08 95       	ret

00000e20 <SendSPI>:
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     e20:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
	 //_delay_ms(10);
}
     e24:	08 95       	ret

00000e26 <SendStrSPI>:
	 SendSPI(0x06);//ETX
	 SendSPI(0x60);//ETX
	 systemSlave();
}

void SendStrSPI(char *strSendSPI){
     e26:	ff 92       	push	r15
     e28:	0f 93       	push	r16
     e2a:	1f 93       	push	r17
     e2c:	cf 93       	push	r28
     e2e:	df 93       	push	r29
     e30:	8c 01       	movw	r16, r24
     e32:	ff 24       	eor	r15, r15
     e34:	06 c0       	rjmp	.+12     	; 0xe42 <SendStrSPI+0x1c>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     e36:	c0 0f       	add	r28, r16
     e38:	d1 1f       	adc	r29, r17
     e3a:	88 81       	ld	r24, Y
     e3c:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
	 systemSlave();
}

void SendStrSPI(char *strSendSPI){
char i;
     for(i=0;i<strlen(strSendSPI);i++){
     e40:	f3 94       	inc	r15
     e42:	cf 2d       	mov	r28, r15
     e44:	d0 e0       	ldi	r29, 0x00	; 0
     e46:	f8 01       	movw	r30, r16
     e48:	01 90       	ld	r0, Z+
     e4a:	00 20       	and	r0, r0
     e4c:	e9 f7       	brne	.-6      	; 0xe48 <SendStrSPI+0x22>
     e4e:	31 97       	sbiw	r30, 0x01	; 1
     e50:	e0 1b       	sub	r30, r16
     e52:	f1 0b       	sbc	r31, r17
     e54:	ce 17       	cp	r28, r30
     e56:	df 07       	cpc	r29, r31
     e58:	70 f3       	brcs	.-36     	; 0xe36 <SendStrSPI+0x10>
	    SendSPI(strSendSPI[i]);
        //_uart(1,1,strSendSPI[i]);
	 } 
}
     e5a:	df 91       	pop	r29
     e5c:	cf 91       	pop	r28
     e5e:	1f 91       	pop	r17
     e60:	0f 91       	pop	r16
     e62:	ff 90       	pop	r15
     e64:	08 95       	ret

00000e66 <systemSlave>:
	//_delay_ms(10);
}


void systemSlave(){
	_spi_init(0, 1);         //SPI Slave
     e66:	80 e0       	ldi	r24, 0x00	; 0
     e68:	61 e0       	ldi	r22, 0x01	; 1
     e6a:	0e 94 8a 1a 	call	0x3514	; 0x3514 <_spi_init>
	sbi(DDRB,6);sbi(PORTB,6);//MISO Output
     e6e:	be 9a       	sbi	0x17, 6	; 23
     e70:	c6 9a       	sbi	0x18, 6	; 24
    cbi(DDRB,5);sbi(PORTB,5);//MOSI Input
     e72:	bd 98       	cbi	0x17, 5	; 23
     e74:	c5 9a       	sbi	0x18, 5	; 24
	cbi(DDRB,7);sbi(PORTB,7);//SCK  Input
     e76:	bf 98       	cbi	0x17, 7	; 23
     e78:	c7 9a       	sbi	0x18, 7	; 24
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
     e7a:	8a 9a       	sbi	0x11, 2	; 17
     e7c:	92 9a       	sbi	0x12, 2	; 18
	//_delay_ms(10);
}
     e7e:	08 95       	ret

00000e80 <systemMaster>:
     _uart(0,1,DataSend);
     //_uart(1,1,DataSend);
}

void systemMaster(){
    _spi_init(1, 0);         //SPI Master
     e80:	81 e0       	ldi	r24, 0x01	; 1
     e82:	60 e0       	ldi	r22, 0x00	; 0
     e84:	0e 94 8a 1a 	call	0x3514	; 0x3514 <_spi_init>
	cbi(DDRB,6);sbi(PORTB,6);//MISO Input
     e88:	be 98       	cbi	0x17, 6	; 23
     e8a:	c6 9a       	sbi	0x18, 6	; 24
    sbi(DDRB,4);sbi(DDRB,5); //MOSI Output
     e8c:	bc 9a       	sbi	0x17, 4	; 23
     e8e:	bd 9a       	sbi	0x17, 5	; 23
	sbi(DDRB,7);sbi(PORTB,7);//SCK  Output    
     e90:	bf 9a       	sbi	0x17, 7	; 23
     e92:	c7 9a       	sbi	0x18, 7	; 24
	sbi(DDRD,2);cbi(PORTD,2);//128-SS LOW
     e94:	8a 9a       	sbi	0x11, 2	; 17
     e96:	92 98       	cbi	0x12, 2	; 18
	//_delay_ms(10);
}
     e98:	08 95       	ret

00000e9a <SendPumpStatusFlow>:
			 PumpLock[i]=False;
		 }
     }    	 
}

void SendPumpStatusFlow(char xPumpID,char xPumpStatus){//
     e9a:	0f 93       	push	r16
     e9c:	1f 93       	push	r17
     e9e:	08 2f       	mov	r16, r24
     ea0:	16 2f       	mov	r17, r22
	 #ifdef DEBUG_PUMP_STATUS_FLOW 
	  sprintf_P(strSend,PSTR("P:%d,S:%d"),xPumpID,xPumpStatus);
	 _uart_print(1,1,strSend);
	 #endif

	 systemMaster();
     ea2:	0e 94 40 07 	call	0xe80	; 0xe80 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     ea6:	87 e0       	ldi	r24, 0x07	; 7
     ea8:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
	 systemMaster();
     SendSPI(0x07);//STX
     SendSPI(tmpStatus);//xIDPump
	 SendSPI(0x08);//ETX

	 systemSlave();
     eac:	1f 70       	andi	r17, 0x0F	; 15
     eae:	02 95       	swap	r16
     eb0:	00 7f       	andi	r16, 0xF0	; 240
     eb2:	80 2f       	mov	r24, r16
     eb4:	81 2b       	or	r24, r17
     eb6:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
     eba:	88 e0       	ldi	r24, 0x08	; 8
     ebc:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
     ec0:	0e 94 33 07 	call	0xe66	; 0xe66 <systemSlave>
}
     ec4:	1f 91       	pop	r17
     ec6:	0f 91       	pop	r16
     ec8:	08 95       	ret

00000eca <SendCommandAcknoledge>:
       //AcknoledgeCommand
       SendCommandAcknoledge(slaveCmd,slaveMsg);
	 }//EndIf	 
}

void SendCommandAcknoledge(char AckCommand,char AckData){
     eca:	0f 93       	push	r16
     ecc:	1f 93       	push	r17
     ece:	18 2f       	mov	r17, r24
     ed0:	06 2f       	mov	r16, r22
	 systemMaster();
     ed2:	0e 94 40 07 	call	0xe80	; 0xe80 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     ed6:	89 e0       	ldi	r24, 0x09	; 9
     ed8:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
	 systemMaster();
	 SendSPI(0x09);
	 SendSPI(AckCommand);
	 SendSPI(AckData);
	 SendSPI(0x0A);
	 systemSlave();
     edc:	81 2f       	mov	r24, r17
     ede:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
     ee2:	80 2f       	mov	r24, r16
     ee4:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
     ee8:	8a e0       	ldi	r24, 0x0A	; 10
     eea:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
     eee:	0e 94 33 07 	call	0xe66	; 0xe66 <systemSlave>
}
     ef2:	1f 91       	pop	r17
     ef4:	0f 91       	pop	r16
     ef6:	08 95       	ret

00000ef8 <__vector_20>:
		 }
     }
	 */		 
}

ISR(USART1_RXC_vect){
     ef8:	1f 92       	push	r1
     efa:	0f 92       	push	r0
     efc:	0f b6       	in	r0, 0x3f	; 63
     efe:	0f 92       	push	r0
     f00:	11 24       	eor	r1, r1
     f02:	1f 93       	push	r17
     f04:	2f 93       	push	r18
     f06:	3f 93       	push	r19
     f08:	4f 93       	push	r20
     f0a:	5f 93       	push	r21
     f0c:	6f 93       	push	r22
     f0e:	7f 93       	push	r23
     f10:	8f 93       	push	r24
     f12:	9f 93       	push	r25
     f14:	af 93       	push	r26
     f16:	bf 93       	push	r27
     f18:	ef 93       	push	r30
     f1a:	ff 93       	push	r31
	char dataRX1;
    dataRX1=UDR1;
     f1c:	13 b1       	in	r17, 0x03	; 3


   if (IFType==IT_SLAVE){
     f1e:	80 91 00 01 	lds	r24, 0x0100
     f22:	81 30       	cpi	r24, 0x01	; 1
     f24:	39 f4       	brne	.+14     	; 0xf34 <__vector_20+0x3c>
	   systemMaster();
     f26:	0e 94 40 07 	call	0xe80	; 0xe80 <systemMaster>
	   _spi(dataRX1);
     f2a:	81 2f       	mov	r24, r17
     f2c:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
	   systemSlave();
     f30:	0e 94 33 07 	call	0xe66	; 0xe66 <systemSlave>
	   }
	   
	//_uart(1,1,dataRX1);
	//OnReceive1(dataRX1);
}
     f34:	ff 91       	pop	r31
     f36:	ef 91       	pop	r30
     f38:	bf 91       	pop	r27
     f3a:	af 91       	pop	r26
     f3c:	9f 91       	pop	r25
     f3e:	8f 91       	pop	r24
     f40:	7f 91       	pop	r23
     f42:	6f 91       	pop	r22
     f44:	5f 91       	pop	r21
     f46:	4f 91       	pop	r20
     f48:	3f 91       	pop	r19
     f4a:	2f 91       	pop	r18
     f4c:	1f 91       	pop	r17
     f4e:	0f 90       	pop	r0
     f50:	0f be       	out	0x3f, r0	; 63
     f52:	0f 90       	pop	r0
     f54:	1f 90       	pop	r1
     f56:	18 95       	reti

00000f58 <__vector_19>:
	if ((TimExp%100)==0) TimWatchSequence++;
	TimReceive++;
	TimDelayNextPump++;
}

ISR(USART0_RXC_vect){
     f58:	1f 92       	push	r1
     f5a:	0f 92       	push	r0
     f5c:	0f b6       	in	r0, 0x3f	; 63
     f5e:	0f 92       	push	r0
     f60:	11 24       	eor	r1, r1
     f62:	1f 93       	push	r17
     f64:	2f 93       	push	r18
     f66:	3f 93       	push	r19
     f68:	4f 93       	push	r20
     f6a:	5f 93       	push	r21
     f6c:	6f 93       	push	r22
     f6e:	7f 93       	push	r23
     f70:	8f 93       	push	r24
     f72:	9f 93       	push	r25
     f74:	af 93       	push	r26
     f76:	bf 93       	push	r27
     f78:	ef 93       	push	r30
     f7a:	ff 93       	push	r31
    char dataRX0;
	char strSend[20];
	dataRX0=UDR0;
     f7c:	1c b1       	in	r17, 0x0c	; 12
    //_uart(1,1,dataRX0);
    //15702 15588 15694
	switch(IFType){
     f7e:	80 91 00 01 	lds	r24, 0x0100
     f82:	81 30       	cpi	r24, 0x01	; 1
     f84:	19 f0       	breq	.+6      	; 0xf8c <__vector_19+0x34>
     f86:	82 30       	cpi	r24, 0x02	; 2
     f88:	b9 f4       	brne	.+46     	; 0xfb8 <__vector_19+0x60>
     f8a:	08 c0       	rjmp	.+16     	; 0xf9c <__vector_19+0x44>
	case IT_SLAVE:
	     systemMaster();
     f8c:	0e 94 40 07 	call	0xe80	; 0xe80 <systemMaster>
	     _spi(dataRX0);
     f90:	81 2f       	mov	r24, r17
     f92:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
	     systemSlave();
     f96:	0e 94 33 07 	call	0xe66	; 0xe66 <systemSlave>
     f9a:	0e c0       	rjmp	.+28     	; 0xfb8 <__vector_19+0x60>
	     break;
    case IT_STANDALONE:
	     switch(StandaloneType){
     f9c:	80 91 01 01 	lds	r24, 0x0101
     fa0:	81 30       	cpi	r24, 0x01	; 1
     fa2:	19 f0       	breq	.+6      	; 0xfaa <__vector_19+0x52>
     fa4:	82 30       	cpi	r24, 0x02	; 2
     fa6:	41 f4       	brne	.+16     	; 0xfb8 <__vector_19+0x60>
     fa8:	04 c0       	rjmp	.+8      	; 0xfb2 <__vector_19+0x5a>
		 case ST_GILBARCO:
		      GilbarcoOnReceive(dataRX0);	
     faa:	81 2f       	mov	r24, r17
     fac:	0e 94 54 06 	call	0xca8	; 0xca8 <GilbarcoOnReceive>
     fb0:	03 c0       	rjmp	.+6      	; 0xfb8 <__vector_19+0x60>
			  break;
		 case ST_WAYNE_DART:
		      WayneOnReceive(dataRX0);	              
     fb2:	81 2f       	mov	r24, r17
     fb4:	0e 94 1b 05 	call	0xa36	; 0xa36 <WayneOnReceive>
			  //_uart_print(1,1,strSend);
			  break;
		 }
     }
	 */		 
}
     fb8:	ff 91       	pop	r31
     fba:	ef 91       	pop	r30
     fbc:	bf 91       	pop	r27
     fbe:	af 91       	pop	r26
     fc0:	9f 91       	pop	r25
     fc2:	8f 91       	pop	r24
     fc4:	7f 91       	pop	r23
     fc6:	6f 91       	pop	r22
     fc8:	5f 91       	pop	r21
     fca:	4f 91       	pop	r20
     fcc:	3f 91       	pop	r19
     fce:	2f 91       	pop	r18
     fd0:	1f 91       	pop	r17
     fd2:	0f 90       	pop	r0
     fd4:	0f be       	out	0x3f, r0	; 63
     fd6:	0f 90       	pop	r0
     fd8:	1f 90       	pop	r1
     fda:	18 95       	reti

00000fdc <PumpCommand>:
}

void PumpCommand(char IDPump, char Command){
     char DataSend;
	 DataSend=((Command<<4)|(IDPump&0x0F));
     _uart(0,1,DataSend);
     fdc:	62 95       	swap	r22
     fde:	60 7f       	andi	r22, 0xF0	; 240
     fe0:	48 2f       	mov	r20, r24
     fe2:	4f 70       	andi	r20, 0x0F	; 15
     fe4:	46 2b       	or	r20, r22
     fe6:	80 e0       	ldi	r24, 0x00	; 0
     fe8:	61 e0       	ldi	r22, 0x01	; 1
     fea:	0e 94 76 1b 	call	0x36ec	; 0x36ec <_uart>
     //_uart(1,1,DataSend);
}
     fee:	08 95       	ret

00000ff0 <WayneSendChar>:
	      break;	 
	 }
}

//enum eLineStatus{LS_NONE,LS_RX,LS_TX};
void WayneSendChar(char xData){
     ff0:	1f 93       	push	r17
     ff2:	18 2f       	mov	r17, r24
     System485(DIR_TX);//TransmitMode
     ff4:	81 e0       	ldi	r24, 0x01	; 1
     ff6:	0e 94 21 02 	call	0x442	; 0x442 <System485>
	 _uart(0,1,xData);
     ffa:	80 e0       	ldi	r24, 0x00	; 0
     ffc:	61 e0       	ldi	r22, 0x01	; 1
     ffe:	41 2f       	mov	r20, r17
    1000:	0e 94 76 1b 	call	0x36ec	; 0x36ec <_uart>
	 System485(DIR_RX);//ReceiveMode
    1004:	82 e0       	ldi	r24, 0x02	; 2
    1006:	0e 94 21 02 	call	0x442	; 0x442 <System485>
}
    100a:	1f 91       	pop	r17
    100c:	08 95       	ret

0000100e <FWayneSendBuffer>:

void WayneTestSend(){
}

void FWayneSendBuffer(char *Buffer, char nLength){
    100e:	0f 93       	push	r16
    1010:	1f 93       	push	r17
    1012:	cf 93       	push	r28
    1014:	df 93       	push	r29
    1016:	06 2f       	mov	r16, r22
    1018:	ec 01       	movw	r28, r24
    101a:	10 e0       	ldi	r17, 0x00	; 0
    101c:	04 c0       	rjmp	.+8      	; 0x1026 <FWayneSendBuffer+0x18>
char i;
     for(i=0;i<nLength;i++){
	     WayneSendChar(Buffer[i]);
    101e:	89 91       	ld	r24, Y+
    1020:	0e 94 f8 07 	call	0xff0	; 0xff0 <WayneSendChar>
void WayneTestSend(){
}

void FWayneSendBuffer(char *Buffer, char nLength){
char i;
     for(i=0;i<nLength;i++){
    1024:	1f 5f       	subi	r17, 0xFF	; 255
    1026:	10 17       	cp	r17, r16
    1028:	d0 f3       	brcs	.-12     	; 0x101e <FWayneSendBuffer+0x10>
	     WayneSendChar(Buffer[i]);
	 }
}
    102a:	df 91       	pop	r29
    102c:	cf 91       	pop	r28
    102e:	1f 91       	pop	r17
    1030:	0f 91       	pop	r16
    1032:	08 95       	ret

00001034 <FWayneSendCommand>:

void FWayneSendCommand(char Command, char SequenceCmd, char xPumpID, char NozzleID){
    1034:	0f 93       	push	r16
    1036:	1f 93       	push	r17
    1038:	df 93       	push	r29
    103a:	cf 93       	push	r28
    103c:	cd b7       	in	r28, 0x3d	; 61
    103e:	de b7       	in	r29, 0x3e	; 62
    1040:	6e 97       	sbiw	r28, 0x1e	; 30
    1042:	0f b6       	in	r0, 0x3f	; 63
    1044:	f8 94       	cli
    1046:	de bf       	out	0x3e, r29	; 62
    1048:	0f be       	out	0x3f, r0	; 63
    104a:	cd bf       	out	0x3d, r28	; 61
char STX_ID,SEQ,MSG_ID[2],NOZZLE_ID,VALUE[6];
int tCRC16;
char strSend[30];
char CmdBuffer[30];
     
	 rxBufferLength=0;
    104c:	10 92 15 01 	sts	0x0115, r1
     switch(Command){
    1050:	8a 30       	cpi	r24, 0x0A	; 10
    1052:	49 f1       	breq	.+82     	; 0x10a6 <FWayneSendCommand+0x72>
    1054:	8b 30       	cpi	r24, 0x0B	; 11
    1056:	40 f4       	brcc	.+16     	; 0x1068 <FWayneSendCommand+0x34>
    1058:	85 30       	cpi	r24, 0x05	; 5
    105a:	09 f4       	brne	.+2      	; 0x105e <FWayneSendCommand+0x2a>
    105c:	75 c2       	rjmp	.+1258   	; 0x1548 <FWayneSendCommand+0x514>
    105e:	87 30       	cpi	r24, 0x07	; 7
    1060:	b1 f0       	breq	.+44     	; 0x108e <FWayneSendCommand+0x5a>
    1062:	88 23       	and	r24, r24
    1064:	71 f0       	breq	.+28     	; 0x1082 <FWayneSendCommand+0x4e>
    1066:	e1 c3       	rjmp	.+1986   	; 0x182a <FWayneSendCommand+0x7f6>
    1068:	8c 30       	cpi	r24, 0x0C	; 12
    106a:	09 f4       	brne	.+2      	; 0x106e <FWayneSendCommand+0x3a>
    106c:	f8 c0       	rjmp	.+496    	; 0x125e <FWayneSendCommand+0x22a>
    106e:	8c 30       	cpi	r24, 0x0C	; 12
    1070:	08 f4       	brcc	.+2      	; 0x1074 <FWayneSendCommand+0x40>
    1072:	87 c0       	rjmp	.+270    	; 0x1182 <FWayneSendCommand+0x14e>
    1074:	8d 30       	cpi	r24, 0x0D	; 13
    1076:	09 f4       	brne	.+2      	; 0x107a <FWayneSendCommand+0x46>
    1078:	ab c1       	rjmp	.+854    	; 0x13d0 <FWayneSendCommand+0x39c>
    107a:	8e 30       	cpi	r24, 0x0E	; 14
    107c:	09 f0       	breq	.+2      	; 0x1080 <FWayneSendCommand+0x4c>
    107e:	d5 c3       	rjmp	.+1962   	; 0x182a <FWayneSendCommand+0x7f6>
    1080:	de c2       	rjmp	.+1468   	; 0x163e <FWayneSendCommand+0x60a>
	      STX_ID=0x50|(0x0F&(xPumpID));
		  WayneSendChar(STX_ID);
	      WayneSendChar(0x20);
	      WayneSendChar(0xFA);
		  */
		  CmdBuffer[0]=0x50|(0x0F&(xPumpID));
    1082:	4f 70       	andi	r20, 0x0F	; 15
    1084:	40 65       	ori	r20, 0x50	; 80
    1086:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x20;
    1088:	80 e2       	ldi	r24, 0x20	; 32
    108a:	8a 83       	std	Y+2, r24	; 0x02
    108c:	06 c0       	rjmp	.+12     	; 0x109a <FWayneSendCommand+0x66>
	      WayneSendChar(SEQ);
	      WayneSendChar(0xFA);
		  */
		  //sprintf_P(strSend,PSTR("[%.2X %.2X %.2X ]"),STX_ID,SEQ,0xFA);
          //_uart_print(1,1,strSend);
		  CmdBuffer[0]=0x50|(0x0F&(xPumpID));
    108e:	4f 70       	andi	r20, 0x0F	; 15
    1090:	40 65       	ori	r20, 0x50	; 80
    1092:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0xC0|(0x0F&SequenceCmd);
    1094:	6f 70       	andi	r22, 0x0F	; 15
    1096:	60 6c       	ori	r22, 0xC0	; 192
    1098:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0xFA;
    109a:	8a ef       	ldi	r24, 0xFA	; 250
    109c:	8b 83       	std	Y+3, r24	; 0x03
		  FWayneSendBuffer(CmdBuffer,3);
    109e:	ce 01       	movw	r24, r28
    10a0:	01 96       	adiw	r24, 0x01	; 1
    10a2:	63 e0       	ldi	r22, 0x03	; 3
    10a4:	c0 c3       	rjmp	.+1920   	; 0x1826 <FWayneSendCommand+0x7f2>
	      break;
     case CMD_AUTH_1://[51 31 01 01 05 63 63 03 FA]//Auth1 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    10a6:	4f 70       	andi	r20, 0x0F	; 15
    10a8:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    10aa:	84 2f       	mov	r24, r20
    10ac:	90 e0       	ldi	r25, 0x00	; 0
    10ae:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    10b0:	e1 e0       	ldi	r30, 0x01	; 1
    10b2:	f0 ea       	ldi	r31, 0xA0	; 160
    10b4:	9c 01       	movw	r18, r24
    10b6:	36 95       	lsr	r19
    10b8:	27 95       	ror	r18
    10ba:	80 ff       	sbrs	r24, 0
    10bc:	04 c0       	rjmp	.+8      	; 0x10c6 <FWayneSendCommand+0x92>
    10be:	c9 01       	movw	r24, r18
    10c0:	8e 27       	eor	r24, r30
    10c2:	9f 27       	eor	r25, r31
    10c4:	01 c0       	rjmp	.+2      	; 0x10c8 <FWayneSendCommand+0x94>
        else xCRC= (xCRC>> 1);
    10c6:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    10c8:	5f 5f       	subi	r21, 0xFF	; 255
    10ca:	58 30       	cpi	r21, 0x08	; 8
    10cc:	99 f7       	brne	.-26     	; 0x10b4 <FWayneSendCommand+0x80>
		  FWayneSendBuffer(CmdBuffer,3);
	      break;
     case CMD_AUTH_1://[51 31 01 01 05 63 63 03 FA]//Auth1 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    10ce:	6f 70       	andi	r22, 0x0F	; 15
    10d0:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    10d2:	26 2f       	mov	r18, r22
    10d4:	30 e0       	ldi	r19, 0x00	; 0
    10d6:	28 27       	eor	r18, r24
    10d8:	39 27       	eor	r19, r25
    10da:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    10dc:	e1 e0       	ldi	r30, 0x01	; 1
    10de:	f0 ea       	ldi	r31, 0xA0	; 160
    10e0:	c9 01       	movw	r24, r18
    10e2:	96 95       	lsr	r25
    10e4:	87 95       	ror	r24
    10e6:	20 ff       	sbrs	r18, 0
    10e8:	04 c0       	rjmp	.+8      	; 0x10f2 <FWayneSendCommand+0xbe>
    10ea:	9c 01       	movw	r18, r24
    10ec:	2e 27       	eor	r18, r30
    10ee:	3f 27       	eor	r19, r31
    10f0:	01 c0       	rjmp	.+2      	; 0x10f4 <FWayneSendCommand+0xc0>
        else xCRC= (xCRC>> 1);
    10f2:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    10f4:	5f 5f       	subi	r21, 0xFF	; 255
    10f6:	58 30       	cpi	r21, 0x08	; 8
    10f8:	99 f7       	brne	.-26     	; 0x10e0 <FWayneSendCommand+0xac>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    10fa:	81 e0       	ldi	r24, 0x01	; 1
    10fc:	90 e0       	ldi	r25, 0x00	; 0
    10fe:	82 27       	eor	r24, r18
    1100:	93 27       	eor	r25, r19
    1102:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1104:	e1 e0       	ldi	r30, 0x01	; 1
    1106:	f0 ea       	ldi	r31, 0xA0	; 160
    1108:	9c 01       	movw	r18, r24
    110a:	36 95       	lsr	r19
    110c:	27 95       	ror	r18
    110e:	80 ff       	sbrs	r24, 0
    1110:	04 c0       	rjmp	.+8      	; 0x111a <FWayneSendCommand+0xe6>
    1112:	c9 01       	movw	r24, r18
    1114:	8e 27       	eor	r24, r30
    1116:	9f 27       	eor	r25, r31
    1118:	01 c0       	rjmp	.+2      	; 0x111c <FWayneSendCommand+0xe8>
        else xCRC= (xCRC>> 1);
    111a:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    111c:	5f 5f       	subi	r21, 0xFF	; 255
    111e:	58 30       	cpi	r21, 0x08	; 8
    1120:	99 f7       	brne	.-26     	; 0x1108 <FWayneSendCommand+0xd4>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1122:	21 e0       	ldi	r18, 0x01	; 1
    1124:	30 e0       	ldi	r19, 0x00	; 0
    1126:	28 27       	eor	r18, r24
    1128:	39 27       	eor	r19, r25
    112a:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    112c:	e1 e0       	ldi	r30, 0x01	; 1
    112e:	f0 ea       	ldi	r31, 0xA0	; 160
    1130:	c9 01       	movw	r24, r18
    1132:	96 95       	lsr	r25
    1134:	87 95       	ror	r24
    1136:	20 ff       	sbrs	r18, 0
    1138:	04 c0       	rjmp	.+8      	; 0x1142 <FWayneSendCommand+0x10e>
    113a:	9c 01       	movw	r18, r24
    113c:	2e 27       	eor	r18, r30
    113e:	3f 27       	eor	r19, r31
    1140:	01 c0       	rjmp	.+2      	; 0x1144 <FWayneSendCommand+0x110>
        else xCRC= (xCRC>> 1);
    1142:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1144:	5f 5f       	subi	r21, 0xFF	; 255
    1146:	58 30       	cpi	r21, 0x08	; 8
    1148:	99 f7       	brne	.-26     	; 0x1130 <FWayneSendCommand+0xfc>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    114a:	e5 e0       	ldi	r30, 0x05	; 5
    114c:	f0 e0       	ldi	r31, 0x00	; 0
    114e:	e2 27       	eor	r30, r18
    1150:	f3 27       	eor	r31, r19
    1152:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1154:	a1 e0       	ldi	r26, 0x01	; 1
    1156:	b0 ea       	ldi	r27, 0xA0	; 160
    1158:	cf 01       	movw	r24, r30
    115a:	96 95       	lsr	r25
    115c:	87 95       	ror	r24
    115e:	e0 ff       	sbrs	r30, 0
    1160:	04 c0       	rjmp	.+8      	; 0x116a <FWayneSendCommand+0x136>
    1162:	fc 01       	movw	r30, r24
    1164:	ea 27       	eor	r30, r26
    1166:	fb 27       	eor	r31, r27
    1168:	01 c0       	rjmp	.+2      	; 0x116c <FWayneSendCommand+0x138>
        else xCRC= (xCRC>> 1);
    116a:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    116c:	2f 5f       	subi	r18, 0xFF	; 255
    116e:	28 30       	cpi	r18, 0x08	; 8
    1170:	99 f7       	brne	.-26     	; 0x1158 <FWayneSendCommand+0x124>
		  CmdBuffer[2]=0xFA;
		  FWayneSendBuffer(CmdBuffer,3);
	      break;
     case CMD_AUTH_1://[51 31 01 01 05 63 63 03 FA]//Auth1 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1172:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    1174:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    1176:	81 e0       	ldi	r24, 0x01	; 1
    1178:	8b 83       	std	Y+3, r24	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    117a:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=0x05;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    117c:	85 e0       	ldi	r24, 0x05	; 5
    117e:	8d 83       	std	Y+5, r24	; 0x05
    1180:	68 c0       	rjmp	.+208    	; 0x1252 <FWayneSendCommand+0x21e>
		  CmdBuffer[8]=0xFA;
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_2://[51 32 01 01 00 A3 24 03 FA]//Auth2 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1182:	4f 70       	andi	r20, 0x0F	; 15
    1184:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1186:	24 2f       	mov	r18, r20
    1188:	30 e0       	ldi	r19, 0x00	; 0
    118a:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    118c:	e1 e0       	ldi	r30, 0x01	; 1
    118e:	f0 ea       	ldi	r31, 0xA0	; 160
    1190:	c9 01       	movw	r24, r18
    1192:	96 95       	lsr	r25
    1194:	87 95       	ror	r24
    1196:	20 ff       	sbrs	r18, 0
    1198:	04 c0       	rjmp	.+8      	; 0x11a2 <FWayneSendCommand+0x16e>
    119a:	9c 01       	movw	r18, r24
    119c:	2e 27       	eor	r18, r30
    119e:	3f 27       	eor	r19, r31
    11a0:	01 c0       	rjmp	.+2      	; 0x11a4 <FWayneSendCommand+0x170>
        else xCRC= (xCRC>> 1);
    11a2:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    11a4:	5f 5f       	subi	r21, 0xFF	; 255
    11a6:	58 30       	cpi	r21, 0x08	; 8
    11a8:	99 f7       	brne	.-26     	; 0x1190 <FWayneSendCommand+0x15c>
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_2://[51 32 01 01 00 A3 24 03 FA]//Auth2 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    11aa:	6f 70       	andi	r22, 0x0F	; 15
    11ac:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    11ae:	86 2f       	mov	r24, r22
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	82 27       	eor	r24, r18
    11b4:	93 27       	eor	r25, r19
    11b6:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    11b8:	e1 e0       	ldi	r30, 0x01	; 1
    11ba:	f0 ea       	ldi	r31, 0xA0	; 160
    11bc:	9c 01       	movw	r18, r24
    11be:	36 95       	lsr	r19
    11c0:	27 95       	ror	r18
    11c2:	80 ff       	sbrs	r24, 0
    11c4:	04 c0       	rjmp	.+8      	; 0x11ce <FWayneSendCommand+0x19a>
    11c6:	c9 01       	movw	r24, r18
    11c8:	8e 27       	eor	r24, r30
    11ca:	9f 27       	eor	r25, r31
    11cc:	01 c0       	rjmp	.+2      	; 0x11d0 <FWayneSendCommand+0x19c>
        else xCRC= (xCRC>> 1);
    11ce:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    11d0:	5f 5f       	subi	r21, 0xFF	; 255
    11d2:	58 30       	cpi	r21, 0x08	; 8
    11d4:	99 f7       	brne	.-26     	; 0x11bc <FWayneSendCommand+0x188>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    11d6:	21 e0       	ldi	r18, 0x01	; 1
    11d8:	30 e0       	ldi	r19, 0x00	; 0
    11da:	28 27       	eor	r18, r24
    11dc:	39 27       	eor	r19, r25
    11de:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    11e0:	e1 e0       	ldi	r30, 0x01	; 1
    11e2:	f0 ea       	ldi	r31, 0xA0	; 160
    11e4:	c9 01       	movw	r24, r18
    11e6:	96 95       	lsr	r25
    11e8:	87 95       	ror	r24
    11ea:	20 ff       	sbrs	r18, 0
    11ec:	04 c0       	rjmp	.+8      	; 0x11f6 <FWayneSendCommand+0x1c2>
    11ee:	9c 01       	movw	r18, r24
    11f0:	2e 27       	eor	r18, r30
    11f2:	3f 27       	eor	r19, r31
    11f4:	01 c0       	rjmp	.+2      	; 0x11f8 <FWayneSendCommand+0x1c4>
        else xCRC= (xCRC>> 1);
    11f6:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    11f8:	5f 5f       	subi	r21, 0xFF	; 255
    11fa:	58 30       	cpi	r21, 0x08	; 8
    11fc:	99 f7       	brne	.-26     	; 0x11e4 <FWayneSendCommand+0x1b0>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    11fe:	e1 e0       	ldi	r30, 0x01	; 1
    1200:	f0 e0       	ldi	r31, 0x00	; 0
    1202:	e2 27       	eor	r30, r18
    1204:	f3 27       	eor	r31, r19
    1206:	80 e0       	ldi	r24, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1208:	a1 e0       	ldi	r26, 0x01	; 1
    120a:	b0 ea       	ldi	r27, 0xA0	; 160
    120c:	9f 01       	movw	r18, r30
    120e:	36 95       	lsr	r19
    1210:	27 95       	ror	r18
    1212:	e0 ff       	sbrs	r30, 0
    1214:	04 c0       	rjmp	.+8      	; 0x121e <FWayneSendCommand+0x1ea>
    1216:	f9 01       	movw	r30, r18
    1218:	ea 27       	eor	r30, r26
    121a:	fb 27       	eor	r31, r27
    121c:	01 c0       	rjmp	.+2      	; 0x1220 <FWayneSendCommand+0x1ec>
        else xCRC= (xCRC>> 1);
    121e:	f9 01       	movw	r30, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1220:	8f 5f       	subi	r24, 0xFF	; 255
    1222:	88 30       	cpi	r24, 0x08	; 8
    1224:	99 f7       	brne	.-26     	; 0x120c <FWayneSendCommand+0x1d8>
    1226:	80 e0       	ldi	r24, 0x00	; 0
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1228:	a1 e0       	ldi	r26, 0x01	; 1
    122a:	b0 ea       	ldi	r27, 0xA0	; 160
    122c:	9f 01       	movw	r18, r30
    122e:	36 95       	lsr	r19
    1230:	27 95       	ror	r18
    1232:	e0 ff       	sbrs	r30, 0
    1234:	04 c0       	rjmp	.+8      	; 0x123e <FWayneSendCommand+0x20a>
    1236:	f9 01       	movw	r30, r18
    1238:	ea 27       	eor	r30, r26
    123a:	fb 27       	eor	r31, r27
    123c:	01 c0       	rjmp	.+2      	; 0x1240 <FWayneSendCommand+0x20c>
        else xCRC= (xCRC>> 1);
    123e:	f9 01       	movw	r30, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1240:	8f 5f       	subi	r24, 0xFF	; 255
    1242:	88 30       	cpi	r24, 0x08	; 8
    1244:	99 f7       	brne	.-26     	; 0x122c <FWayneSendCommand+0x1f8>
		  CmdBuffer[8]=0xFA;
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_2://[51 32 01 01 00 A3 24 03 FA]//Auth2 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1246:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    1248:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    124a:	81 e0       	ldi	r24, 0x01	; 1
    124c:	8b 83       	std	Y+3, r24	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    124e:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=0x00;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1250:	1d 82       	std	Y+5, r1	; 0x05
		  CmdBuffer[5]=tCRC16;
    1252:	ee 83       	std	Y+6, r30	; 0x06
		  CmdBuffer[6]=tCRC16>>8;
    1254:	8f 2f       	mov	r24, r31
    1256:	99 27       	eor	r25, r25
    1258:	87 fd       	sbrc	r24, 7
    125a:	9a 95       	dec	r25
    125c:	e7 c1       	rjmp	.+974    	; 0x162c <FWayneSendCommand+0x5f8>
		  CmdBuffer[8]=0xFA;
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_3://Preset Auth Max Volume
          tCRC16=0;//[51 33 04 04 99 99 99 99 63 3E 03 FA]//Auth3 ->12
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    125e:	4f 70       	andi	r20, 0x0F	; 15
    1260:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1262:	84 2f       	mov	r24, r20
    1264:	90 e0       	ldi	r25, 0x00	; 0
    1266:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1268:	e1 e0       	ldi	r30, 0x01	; 1
    126a:	f0 ea       	ldi	r31, 0xA0	; 160
    126c:	9c 01       	movw	r18, r24
    126e:	36 95       	lsr	r19
    1270:	27 95       	ror	r18
    1272:	80 ff       	sbrs	r24, 0
    1274:	04 c0       	rjmp	.+8      	; 0x127e <FWayneSendCommand+0x24a>
    1276:	c9 01       	movw	r24, r18
    1278:	8e 27       	eor	r24, r30
    127a:	9f 27       	eor	r25, r31
    127c:	01 c0       	rjmp	.+2      	; 0x1280 <FWayneSendCommand+0x24c>
        else xCRC= (xCRC>> 1);
    127e:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1280:	5f 5f       	subi	r21, 0xFF	; 255
    1282:	58 30       	cpi	r21, 0x08	; 8
    1284:	99 f7       	brne	.-26     	; 0x126c <FWayneSendCommand+0x238>
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_3://Preset Auth Max Volume
          tCRC16=0;//[51 33 04 04 99 99 99 99 63 3E 03 FA]//Auth3 ->12
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    1286:	6f 70       	andi	r22, 0x0F	; 15
    1288:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    128a:	26 2f       	mov	r18, r22
    128c:	30 e0       	ldi	r19, 0x00	; 0
    128e:	28 27       	eor	r18, r24
    1290:	39 27       	eor	r19, r25
    1292:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1294:	e1 e0       	ldi	r30, 0x01	; 1
    1296:	f0 ea       	ldi	r31, 0xA0	; 160
    1298:	c9 01       	movw	r24, r18
    129a:	96 95       	lsr	r25
    129c:	87 95       	ror	r24
    129e:	20 ff       	sbrs	r18, 0
    12a0:	04 c0       	rjmp	.+8      	; 0x12aa <FWayneSendCommand+0x276>
    12a2:	9c 01       	movw	r18, r24
    12a4:	2e 27       	eor	r18, r30
    12a6:	3f 27       	eor	r19, r31
    12a8:	01 c0       	rjmp	.+2      	; 0x12ac <FWayneSendCommand+0x278>
        else xCRC= (xCRC>> 1);
    12aa:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    12ac:	5f 5f       	subi	r21, 0xFF	; 255
    12ae:	58 30       	cpi	r21, 0x08	; 8
    12b0:	99 f7       	brne	.-26     	; 0x1298 <FWayneSendCommand+0x264>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    12b2:	84 e0       	ldi	r24, 0x04	; 4
    12b4:	90 e0       	ldi	r25, 0x00	; 0
    12b6:	82 27       	eor	r24, r18
    12b8:	93 27       	eor	r25, r19
    12ba:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    12bc:	e1 e0       	ldi	r30, 0x01	; 1
    12be:	f0 ea       	ldi	r31, 0xA0	; 160
    12c0:	9c 01       	movw	r18, r24
    12c2:	36 95       	lsr	r19
    12c4:	27 95       	ror	r18
    12c6:	80 ff       	sbrs	r24, 0
    12c8:	04 c0       	rjmp	.+8      	; 0x12d2 <FWayneSendCommand+0x29e>
    12ca:	c9 01       	movw	r24, r18
    12cc:	8e 27       	eor	r24, r30
    12ce:	9f 27       	eor	r25, r31
    12d0:	01 c0       	rjmp	.+2      	; 0x12d4 <FWayneSendCommand+0x2a0>
        else xCRC= (xCRC>> 1);
    12d2:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    12d4:	5f 5f       	subi	r21, 0xFF	; 255
    12d6:	58 30       	cpi	r21, 0x08	; 8
    12d8:	99 f7       	brne	.-26     	; 0x12c0 <FWayneSendCommand+0x28c>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    12da:	e4 e0       	ldi	r30, 0x04	; 4
    12dc:	f0 e0       	ldi	r31, 0x00	; 0
    12de:	e8 27       	eor	r30, r24
    12e0:	f9 27       	eor	r31, r25
    12e2:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    12e4:	a1 e0       	ldi	r26, 0x01	; 1
    12e6:	b0 ea       	ldi	r27, 0xA0	; 160
    12e8:	cf 01       	movw	r24, r30
    12ea:	96 95       	lsr	r25
    12ec:	87 95       	ror	r24
    12ee:	e0 ff       	sbrs	r30, 0
    12f0:	04 c0       	rjmp	.+8      	; 0x12fa <FWayneSendCommand+0x2c6>
    12f2:	fc 01       	movw	r30, r24
    12f4:	ea 27       	eor	r30, r26
    12f6:	fb 27       	eor	r31, r27
    12f8:	01 c0       	rjmp	.+2      	; 0x12fc <FWayneSendCommand+0x2c8>
        else xCRC= (xCRC>> 1);
    12fa:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    12fc:	2f 5f       	subi	r18, 0xFF	; 255
    12fe:	28 30       	cpi	r18, 0x08	; 8
    1300:	99 f7       	brne	.-26     	; 0x12e8 <FWayneSendCommand+0x2b4>
          tCRC16=0;//[51 33 04 04 99 99 99 99 63 3E 03 FA]//Auth3 ->12
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1302:	00 91 07 01 	lds	r16, 0x0107

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1306:	20 2f       	mov	r18, r16
    1308:	30 e0       	ldi	r19, 0x00	; 0
    130a:	2e 27       	eor	r18, r30
    130c:	3f 27       	eor	r19, r31
    130e:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1310:	e1 e0       	ldi	r30, 0x01	; 1
    1312:	f0 ea       	ldi	r31, 0xA0	; 160
    1314:	c9 01       	movw	r24, r18
    1316:	96 95       	lsr	r25
    1318:	87 95       	ror	r24
    131a:	20 ff       	sbrs	r18, 0
    131c:	04 c0       	rjmp	.+8      	; 0x1326 <FWayneSendCommand+0x2f2>
    131e:	9c 01       	movw	r18, r24
    1320:	2e 27       	eor	r18, r30
    1322:	3f 27       	eor	r19, r31
    1324:	01 c0       	rjmp	.+2      	; 0x1328 <FWayneSendCommand+0x2f4>
        else xCRC= (xCRC>> 1);
    1326:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1328:	5f 5f       	subi	r21, 0xFF	; 255
    132a:	58 30       	cpi	r21, 0x08	; 8
    132c:	99 f7       	brne	.-26     	; 0x1314 <FWayneSendCommand+0x2e0>
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
		  CmdBuffer[5]=MaxAuthVolume[1];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    132e:	10 91 08 01 	lds	r17, 0x0108

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1332:	81 2f       	mov	r24, r17
    1334:	90 e0       	ldi	r25, 0x00	; 0
    1336:	82 27       	eor	r24, r18
    1338:	93 27       	eor	r25, r19
    133a:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    133c:	e1 e0       	ldi	r30, 0x01	; 1
    133e:	f0 ea       	ldi	r31, 0xA0	; 160
    1340:	9c 01       	movw	r18, r24
    1342:	36 95       	lsr	r19
    1344:	27 95       	ror	r18
    1346:	80 ff       	sbrs	r24, 0
    1348:	04 c0       	rjmp	.+8      	; 0x1352 <FWayneSendCommand+0x31e>
    134a:	c9 01       	movw	r24, r18
    134c:	8e 27       	eor	r24, r30
    134e:	9f 27       	eor	r25, r31
    1350:	01 c0       	rjmp	.+2      	; 0x1354 <FWayneSendCommand+0x320>
        else xCRC= (xCRC>> 1);
    1352:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1354:	5f 5f       	subi	r21, 0xFF	; 255
    1356:	58 30       	cpi	r21, 0x08	; 8
    1358:	99 f7       	brne	.-26     	; 0x1340 <FWayneSendCommand+0x30c>
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
		  CmdBuffer[5]=MaxAuthVolume[1];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
		  CmdBuffer[6]=MaxAuthVolume[2];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    135a:	70 91 09 01 	lds	r23, 0x0109

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    135e:	27 2f       	mov	r18, r23
    1360:	30 e0       	ldi	r19, 0x00	; 0
    1362:	28 27       	eor	r18, r24
    1364:	39 27       	eor	r19, r25
    1366:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1368:	e1 e0       	ldi	r30, 0x01	; 1
    136a:	f0 ea       	ldi	r31, 0xA0	; 160
    136c:	c9 01       	movw	r24, r18
    136e:	96 95       	lsr	r25
    1370:	87 95       	ror	r24
    1372:	20 ff       	sbrs	r18, 0
    1374:	04 c0       	rjmp	.+8      	; 0x137e <FWayneSendCommand+0x34a>
    1376:	9c 01       	movw	r18, r24
    1378:	2e 27       	eor	r18, r30
    137a:	3f 27       	eor	r19, r31
    137c:	01 c0       	rjmp	.+2      	; 0x1380 <FWayneSendCommand+0x34c>
        else xCRC= (xCRC>> 1);
    137e:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1380:	5f 5f       	subi	r21, 0xFF	; 255
    1382:	58 30       	cpi	r21, 0x08	; 8
    1384:	99 f7       	brne	.-26     	; 0x136c <FWayneSendCommand+0x338>
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
		  CmdBuffer[5]=MaxAuthVolume[1];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
		  CmdBuffer[6]=MaxAuthVolume[2];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
		  CmdBuffer[7]=MaxAuthVolume[3];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    1386:	50 91 0a 01 	lds	r21, 0x010A

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    138a:	e5 2f       	mov	r30, r21
    138c:	f0 e0       	ldi	r31, 0x00	; 0
    138e:	e2 27       	eor	r30, r18
    1390:	f3 27       	eor	r31, r19
    1392:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1394:	a1 e0       	ldi	r26, 0x01	; 1
    1396:	b0 ea       	ldi	r27, 0xA0	; 160
    1398:	cf 01       	movw	r24, r30
    139a:	96 95       	lsr	r25
    139c:	87 95       	ror	r24
    139e:	e0 ff       	sbrs	r30, 0
    13a0:	04 c0       	rjmp	.+8      	; 0x13aa <FWayneSendCommand+0x376>
    13a2:	fc 01       	movw	r30, r24
    13a4:	ea 27       	eor	r30, r26
    13a6:	fb 27       	eor	r31, r27
    13a8:	01 c0       	rjmp	.+2      	; 0x13ac <FWayneSendCommand+0x378>
        else xCRC= (xCRC>> 1);
    13aa:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    13ac:	2f 5f       	subi	r18, 0xFF	; 255
    13ae:	28 30       	cpi	r18, 0x08	; 8
    13b0:	99 f7       	brne	.-26     	; 0x1398 <FWayneSendCommand+0x364>
		  CmdBuffer[8]=0xFA;
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_3://Preset Auth Max Volume
          tCRC16=0;//[51 33 04 04 99 99 99 99 63 3E 03 FA]//Auth3 ->12
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    13b2:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    13b4:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    13b6:	84 e0       	ldi	r24, 0x04	; 4
    13b8:	8b 83       	std	Y+3, r24	; 0x03
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    13ba:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    13bc:	0d 83       	std	Y+5, r16	; 0x05
		  CmdBuffer[5]=MaxAuthVolume[1];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    13be:	1e 83       	std	Y+6, r17	; 0x06
		  CmdBuffer[6]=MaxAuthVolume[2];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    13c0:	7f 83       	std	Y+7, r23	; 0x07
		  CmdBuffer[7]=MaxAuthVolume[3];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    13c2:	58 87       	std	Y+8, r21	; 0x08
		  CmdBuffer[8]=tCRC16;
    13c4:	e9 87       	std	Y+9, r30	; 0x09
		  CmdBuffer[9]=tCRC16>>8;
    13c6:	8f 2f       	mov	r24, r31
    13c8:	99 27       	eor	r25, r25
    13ca:	87 fd       	sbrc	r24, 7
    13cc:	9a 95       	dec	r25
    13ce:	b3 c0       	rjmp	.+358    	; 0x1536 <FWayneSendCommand+0x502>
	 [51 34 02 01 01 01 01 06 5C BF 03 FA]//Auth4 Nozzle1
     [51 34 02 01 02 01 01 06 5C FB 03 FA]//Auth4 Nozzle2

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    13d0:	4f 70       	andi	r20, 0x0F	; 15
    13d2:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    13d4:	84 2f       	mov	r24, r20
    13d6:	90 e0       	ldi	r25, 0x00	; 0
    13d8:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    13da:	a1 e0       	ldi	r26, 0x01	; 1
    13dc:	b0 ea       	ldi	r27, 0xA0	; 160
    13de:	fc 01       	movw	r30, r24
    13e0:	f6 95       	lsr	r31
    13e2:	e7 95       	ror	r30
    13e4:	80 ff       	sbrs	r24, 0
    13e6:	04 c0       	rjmp	.+8      	; 0x13f0 <FWayneSendCommand+0x3bc>
    13e8:	cf 01       	movw	r24, r30
    13ea:	8a 27       	eor	r24, r26
    13ec:	9b 27       	eor	r25, r27
    13ee:	01 c0       	rjmp	.+2      	; 0x13f2 <FWayneSendCommand+0x3be>
        else xCRC= (xCRC>> 1);
    13f0:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    13f2:	3f 5f       	subi	r19, 0xFF	; 255
    13f4:	38 30       	cpi	r19, 0x08	; 8
    13f6:	99 f7       	brne	.-26     	; 0x13de <FWayneSendCommand+0x3aa>
     [51 34 02 01 02 01 01 06 5C FB 03 FA]//Auth4 Nozzle2

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    13f8:	6f 70       	andi	r22, 0x0F	; 15
    13fa:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    13fc:	e6 2f       	mov	r30, r22
    13fe:	f0 e0       	ldi	r31, 0x00	; 0
    1400:	e8 27       	eor	r30, r24
    1402:	f9 27       	eor	r31, r25
    1404:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1406:	a1 e0       	ldi	r26, 0x01	; 1
    1408:	b0 ea       	ldi	r27, 0xA0	; 160
    140a:	cf 01       	movw	r24, r30
    140c:	96 95       	lsr	r25
    140e:	87 95       	ror	r24
    1410:	e0 ff       	sbrs	r30, 0
    1412:	04 c0       	rjmp	.+8      	; 0x141c <FWayneSendCommand+0x3e8>
    1414:	fc 01       	movw	r30, r24
    1416:	ea 27       	eor	r30, r26
    1418:	fb 27       	eor	r31, r27
    141a:	01 c0       	rjmp	.+2      	; 0x141e <FWayneSendCommand+0x3ea>
        else xCRC= (xCRC>> 1);
    141c:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    141e:	3f 5f       	subi	r19, 0xFF	; 255
    1420:	38 30       	cpi	r19, 0x08	; 8
    1422:	99 f7       	brne	.-26     	; 0x140a <FWayneSendCommand+0x3d6>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1424:	82 e0       	ldi	r24, 0x02	; 2
    1426:	90 e0       	ldi	r25, 0x00	; 0
    1428:	8e 27       	eor	r24, r30
    142a:	9f 27       	eor	r25, r31
    142c:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    142e:	a1 e0       	ldi	r26, 0x01	; 1
    1430:	b0 ea       	ldi	r27, 0xA0	; 160
    1432:	fc 01       	movw	r30, r24
    1434:	f6 95       	lsr	r31
    1436:	e7 95       	ror	r30
    1438:	80 ff       	sbrs	r24, 0
    143a:	04 c0       	rjmp	.+8      	; 0x1444 <FWayneSendCommand+0x410>
    143c:	cf 01       	movw	r24, r30
    143e:	8a 27       	eor	r24, r26
    1440:	9b 27       	eor	r25, r27
    1442:	01 c0       	rjmp	.+2      	; 0x1446 <FWayneSendCommand+0x412>
        else xCRC= (xCRC>> 1);
    1444:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1446:	3f 5f       	subi	r19, 0xFF	; 255
    1448:	38 30       	cpi	r19, 0x08	; 8
    144a:	99 f7       	brne	.-26     	; 0x1432 <FWayneSendCommand+0x3fe>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    144c:	a1 e0       	ldi	r26, 0x01	; 1
    144e:	b0 e0       	ldi	r27, 0x00	; 0
    1450:	a8 27       	eor	r26, r24
    1452:	b9 27       	eor	r27, r25
    1454:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1456:	e1 e0       	ldi	r30, 0x01	; 1
    1458:	f0 ea       	ldi	r31, 0xA0	; 160
    145a:	cd 01       	movw	r24, r26
    145c:	96 95       	lsr	r25
    145e:	87 95       	ror	r24
    1460:	a0 ff       	sbrs	r26, 0
    1462:	04 c0       	rjmp	.+8      	; 0x146c <FWayneSendCommand+0x438>
    1464:	dc 01       	movw	r26, r24
    1466:	ae 27       	eor	r26, r30
    1468:	bf 27       	eor	r27, r31
    146a:	01 c0       	rjmp	.+2      	; 0x146e <FWayneSendCommand+0x43a>
        else xCRC= (xCRC>> 1);
    146c:	dc 01       	movw	r26, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    146e:	3f 5f       	subi	r19, 0xFF	; 255
    1470:	38 30       	cpi	r19, 0x08	; 8
    1472:	99 f7       	brne	.-26     	; 0x145a <FWayneSendCommand+0x426>
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x02;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=(NozzleID&0x0F);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1474:	2f 70       	andi	r18, 0x0F	; 15

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1476:	e2 2f       	mov	r30, r18
    1478:	f0 e0       	ldi	r31, 0x00	; 0
    147a:	ea 27       	eor	r30, r26
    147c:	fb 27       	eor	r31, r27
    147e:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1480:	a1 e0       	ldi	r26, 0x01	; 1
    1482:	b0 ea       	ldi	r27, 0xA0	; 160
    1484:	cf 01       	movw	r24, r30
    1486:	96 95       	lsr	r25
    1488:	87 95       	ror	r24
    148a:	e0 ff       	sbrs	r30, 0
    148c:	04 c0       	rjmp	.+8      	; 0x1496 <FWayneSendCommand+0x462>
    148e:	fc 01       	movw	r30, r24
    1490:	ea 27       	eor	r30, r26
    1492:	fb 27       	eor	r31, r27
    1494:	01 c0       	rjmp	.+2      	; 0x1498 <FWayneSendCommand+0x464>
        else xCRC= (xCRC>> 1);
    1496:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1498:	3f 5f       	subi	r19, 0xFF	; 255
    149a:	38 30       	cpi	r19, 0x08	; 8
    149c:	99 f7       	brne	.-26     	; 0x1484 <FWayneSendCommand+0x450>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    149e:	81 e0       	ldi	r24, 0x01	; 1
    14a0:	90 e0       	ldi	r25, 0x00	; 0
    14a2:	8e 27       	eor	r24, r30
    14a4:	9f 27       	eor	r25, r31
    14a6:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    14a8:	a1 e0       	ldi	r26, 0x01	; 1
    14aa:	b0 ea       	ldi	r27, 0xA0	; 160
    14ac:	fc 01       	movw	r30, r24
    14ae:	f6 95       	lsr	r31
    14b0:	e7 95       	ror	r30
    14b2:	80 ff       	sbrs	r24, 0
    14b4:	04 c0       	rjmp	.+8      	; 0x14be <FWayneSendCommand+0x48a>
    14b6:	cf 01       	movw	r24, r30
    14b8:	8a 27       	eor	r24, r26
    14ba:	9b 27       	eor	r25, r27
    14bc:	01 c0       	rjmp	.+2      	; 0x14c0 <FWayneSendCommand+0x48c>
        else xCRC= (xCRC>> 1);
    14be:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    14c0:	3f 5f       	subi	r19, 0xFF	; 255
    14c2:	38 30       	cpi	r19, 0x08	; 8
    14c4:	99 f7       	brne	.-26     	; 0x14ac <FWayneSendCommand+0x478>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    14c6:	e1 e0       	ldi	r30, 0x01	; 1
    14c8:	f0 e0       	ldi	r31, 0x00	; 0
    14ca:	e8 27       	eor	r30, r24
    14cc:	f9 27       	eor	r31, r25
    14ce:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    14d0:	a1 e0       	ldi	r26, 0x01	; 1
    14d2:	b0 ea       	ldi	r27, 0xA0	; 160
    14d4:	cf 01       	movw	r24, r30
    14d6:	96 95       	lsr	r25
    14d8:	87 95       	ror	r24
    14da:	e0 ff       	sbrs	r30, 0
    14dc:	04 c0       	rjmp	.+8      	; 0x14e6 <FWayneSendCommand+0x4b2>
    14de:	fc 01       	movw	r30, r24
    14e0:	ea 27       	eor	r30, r26
    14e2:	fb 27       	eor	r31, r27
    14e4:	01 c0       	rjmp	.+2      	; 0x14e8 <FWayneSendCommand+0x4b4>
        else xCRC= (xCRC>> 1);
    14e6:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    14e8:	3f 5f       	subi	r19, 0xFF	; 255
    14ea:	38 30       	cpi	r19, 0x08	; 8
    14ec:	99 f7       	brne	.-26     	; 0x14d4 <FWayneSendCommand+0x4a0>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    14ee:	a6 e0       	ldi	r26, 0x06	; 6
    14f0:	b0 e0       	ldi	r27, 0x00	; 0
    14f2:	ae 27       	eor	r26, r30
    14f4:	bf 27       	eor	r27, r31
    14f6:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    14f8:	e1 e0       	ldi	r30, 0x01	; 1
    14fa:	f0 ea       	ldi	r31, 0xA0	; 160
    14fc:	cd 01       	movw	r24, r26
    14fe:	96 95       	lsr	r25
    1500:	87 95       	ror	r24
    1502:	a0 ff       	sbrs	r26, 0
    1504:	04 c0       	rjmp	.+8      	; 0x150e <FWayneSendCommand+0x4da>
    1506:	dc 01       	movw	r26, r24
    1508:	ae 27       	eor	r26, r30
    150a:	bf 27       	eor	r27, r31
    150c:	01 c0       	rjmp	.+2      	; 0x1510 <FWayneSendCommand+0x4dc>
        else xCRC= (xCRC>> 1);
    150e:	dc 01       	movw	r26, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1510:	3f 5f       	subi	r19, 0xFF	; 255
    1512:	38 30       	cpi	r19, 0x08	; 8
    1514:	99 f7       	brne	.-26     	; 0x14fc <FWayneSendCommand+0x4c8>
	 [51 34 02 01 01 01 01 06 5C BF 03 FA]//Auth4 Nozzle1
     [51 34 02 01 02 01 01 06 5C FB 03 FA]//Auth4 Nozzle2

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1516:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    1518:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x02;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    151a:	82 e0       	ldi	r24, 0x02	; 2
    151c:	8b 83       	std	Y+3, r24	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    151e:	81 e0       	ldi	r24, 0x01	; 1
    1520:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=(NozzleID&0x0F);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1522:	2d 83       	std	Y+5, r18	; 0x05
		  CmdBuffer[5]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    1524:	8e 83       	std	Y+6, r24	; 0x06
		  CmdBuffer[6]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    1526:	8f 83       	std	Y+7, r24	; 0x07
		  CmdBuffer[7]=0x06;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    1528:	86 e0       	ldi	r24, 0x06	; 6
    152a:	88 87       	std	Y+8, r24	; 0x08
		  CmdBuffer[8]=tCRC16;
    152c:	a9 87       	std	Y+9, r26	; 0x09
		  CmdBuffer[9]=tCRC16>>8;
    152e:	8b 2f       	mov	r24, r27
    1530:	99 27       	eor	r25, r25
    1532:	87 fd       	sbrc	r24, 7
    1534:	9a 95       	dec	r25
    1536:	8a 87       	std	Y+10, r24	; 0x0a
		  CmdBuffer[10]=0x03;
    1538:	83 e0       	ldi	r24, 0x03	; 3
    153a:	8b 87       	std	Y+11, r24	; 0x0b
		  CmdBuffer[11]=0xFA;
    153c:	8a ef       	ldi	r24, 0xFA	; 250
    153e:	8c 87       	std	Y+12, r24	; 0x0c
          FWayneSendBuffer(CmdBuffer,12);
    1540:	ce 01       	movw	r24, r28
    1542:	01 96       	adiw	r24, 0x01	; 1
    1544:	6c e0       	ldi	r22, 0x0C	; 12
    1546:	6f c1       	rjmp	.+734    	; 0x1826 <FWayneSendCommand+0x7f2>
	      break;     
     case CMD_TOTALIZER://[51] [37] [08 01] [02] [F2 2B] [03 FA] 
          tCRC16=0;     //[51   30   08 01   01   B3 5E   03 FA] //Total N1
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1548:	4f 70       	andi	r20, 0x0F	; 15
    154a:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    154c:	84 2f       	mov	r24, r20
    154e:	90 e0       	ldi	r25, 0x00	; 0
    1550:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1552:	a1 e0       	ldi	r26, 0x01	; 1
    1554:	b0 ea       	ldi	r27, 0xA0	; 160
    1556:	fc 01       	movw	r30, r24
    1558:	f6 95       	lsr	r31
    155a:	e7 95       	ror	r30
    155c:	80 ff       	sbrs	r24, 0
    155e:	04 c0       	rjmp	.+8      	; 0x1568 <FWayneSendCommand+0x534>
    1560:	cf 01       	movw	r24, r30
    1562:	8a 27       	eor	r24, r26
    1564:	9b 27       	eor	r25, r27
    1566:	01 c0       	rjmp	.+2      	; 0x156a <FWayneSendCommand+0x536>
        else xCRC= (xCRC>> 1);
    1568:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    156a:	3f 5f       	subi	r19, 0xFF	; 255
    156c:	38 30       	cpi	r19, 0x08	; 8
    156e:	99 f7       	brne	.-26     	; 0x1556 <FWayneSendCommand+0x522>
          FWayneSendBuffer(CmdBuffer,12);
	      break;     
     case CMD_TOTALIZER://[51] [37] [08 01] [02] [F2 2B] [03 FA] 
          tCRC16=0;     //[51   30   08 01   01   B3 5E   03 FA] //Total N1
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    1570:	6f 70       	andi	r22, 0x0F	; 15
    1572:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1574:	e6 2f       	mov	r30, r22
    1576:	f0 e0       	ldi	r31, 0x00	; 0
    1578:	e8 27       	eor	r30, r24
    157a:	f9 27       	eor	r31, r25
    157c:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    157e:	a1 e0       	ldi	r26, 0x01	; 1
    1580:	b0 ea       	ldi	r27, 0xA0	; 160
    1582:	cf 01       	movw	r24, r30
    1584:	96 95       	lsr	r25
    1586:	87 95       	ror	r24
    1588:	e0 ff       	sbrs	r30, 0
    158a:	04 c0       	rjmp	.+8      	; 0x1594 <FWayneSendCommand+0x560>
    158c:	fc 01       	movw	r30, r24
    158e:	ea 27       	eor	r30, r26
    1590:	fb 27       	eor	r31, r27
    1592:	01 c0       	rjmp	.+2      	; 0x1596 <FWayneSendCommand+0x562>
        else xCRC= (xCRC>> 1);
    1594:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1596:	3f 5f       	subi	r19, 0xFF	; 255
    1598:	38 30       	cpi	r19, 0x08	; 8
    159a:	99 f7       	brne	.-26     	; 0x1582 <FWayneSendCommand+0x54e>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    159c:	88 e0       	ldi	r24, 0x08	; 8
    159e:	90 e0       	ldi	r25, 0x00	; 0
    15a0:	8e 27       	eor	r24, r30
    15a2:	9f 27       	eor	r25, r31
    15a4:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    15a6:	a1 e0       	ldi	r26, 0x01	; 1
    15a8:	b0 ea       	ldi	r27, 0xA0	; 160
    15aa:	fc 01       	movw	r30, r24
    15ac:	f6 95       	lsr	r31
    15ae:	e7 95       	ror	r30
    15b0:	80 ff       	sbrs	r24, 0
    15b2:	04 c0       	rjmp	.+8      	; 0x15bc <FWayneSendCommand+0x588>
    15b4:	cf 01       	movw	r24, r30
    15b6:	8a 27       	eor	r24, r26
    15b8:	9b 27       	eor	r25, r27
    15ba:	01 c0       	rjmp	.+2      	; 0x15be <FWayneSendCommand+0x58a>
        else xCRC= (xCRC>> 1);
    15bc:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    15be:	3f 5f       	subi	r19, 0xFF	; 255
    15c0:	38 30       	cpi	r19, 0x08	; 8
    15c2:	99 f7       	brne	.-26     	; 0x15aa <FWayneSendCommand+0x576>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    15c4:	e1 e0       	ldi	r30, 0x01	; 1
    15c6:	f0 e0       	ldi	r31, 0x00	; 0
    15c8:	e8 27       	eor	r30, r24
    15ca:	f9 27       	eor	r31, r25
    15cc:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    15ce:	a1 e0       	ldi	r26, 0x01	; 1
    15d0:	b0 ea       	ldi	r27, 0xA0	; 160
    15d2:	cf 01       	movw	r24, r30
    15d4:	96 95       	lsr	r25
    15d6:	87 95       	ror	r24
    15d8:	e0 ff       	sbrs	r30, 0
    15da:	04 c0       	rjmp	.+8      	; 0x15e4 <FWayneSendCommand+0x5b0>
    15dc:	fc 01       	movw	r30, r24
    15de:	ea 27       	eor	r30, r26
    15e0:	fb 27       	eor	r31, r27
    15e2:	01 c0       	rjmp	.+2      	; 0x15e6 <FWayneSendCommand+0x5b2>
        else xCRC= (xCRC>> 1);
    15e4:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    15e6:	3f 5f       	subi	r19, 0xFF	; 255
    15e8:	38 30       	cpi	r19, 0x08	; 8
    15ea:	99 f7       	brne	.-26     	; 0x15d2 <FWayneSendCommand+0x59e>
          tCRC16=0;     //[51   30   08 01   01   B3 5E   03 FA] //Total N1
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x08;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=(NozzleID&0x0F);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    15ec:	2f 70       	andi	r18, 0x0F	; 15

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    15ee:	a2 2f       	mov	r26, r18
    15f0:	b0 e0       	ldi	r27, 0x00	; 0
    15f2:	ae 27       	eor	r26, r30
    15f4:	bf 27       	eor	r27, r31
    15f6:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    15f8:	e1 e0       	ldi	r30, 0x01	; 1
    15fa:	f0 ea       	ldi	r31, 0xA0	; 160
    15fc:	cd 01       	movw	r24, r26
    15fe:	96 95       	lsr	r25
    1600:	87 95       	ror	r24
    1602:	a0 ff       	sbrs	r26, 0
    1604:	04 c0       	rjmp	.+8      	; 0x160e <FWayneSendCommand+0x5da>
    1606:	dc 01       	movw	r26, r24
    1608:	ae 27       	eor	r26, r30
    160a:	bf 27       	eor	r27, r31
    160c:	01 c0       	rjmp	.+2      	; 0x1610 <FWayneSendCommand+0x5dc>
        else xCRC= (xCRC>> 1);
    160e:	dc 01       	movw	r26, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1610:	3f 5f       	subi	r19, 0xFF	; 255
    1612:	38 30       	cpi	r19, 0x08	; 8
    1614:	99 f7       	brne	.-26     	; 0x15fc <FWayneSendCommand+0x5c8>
		  CmdBuffer[11]=0xFA;
          FWayneSendBuffer(CmdBuffer,12);
	      break;     
     case CMD_TOTALIZER://[51] [37] [08 01] [02] [F2 2B] [03 FA] 
          tCRC16=0;     //[51   30   08 01   01   B3 5E   03 FA] //Total N1
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1616:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    1618:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x08;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    161a:	3b 83       	std	Y+3, r19	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    161c:	81 e0       	ldi	r24, 0x01	; 1
    161e:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=(NozzleID&0x0F);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1620:	2d 83       	std	Y+5, r18	; 0x05
		  CmdBuffer[5]=tCRC16;
    1622:	ae 83       	std	Y+6, r26	; 0x06
		  CmdBuffer[6]=tCRC16>>8;
    1624:	8b 2f       	mov	r24, r27
    1626:	99 27       	eor	r25, r25
    1628:	87 fd       	sbrc	r24, 7
    162a:	9a 95       	dec	r25
    162c:	8f 83       	std	Y+7, r24	; 0x07
		  CmdBuffer[7]=0x03;
    162e:	83 e0       	ldi	r24, 0x03	; 3
    1630:	88 87       	std	Y+8, r24	; 0x08
		  CmdBuffer[8]=0xFA;
    1632:	8a ef       	ldi	r24, 0xFA	; 250
    1634:	89 87       	std	Y+9, r24	; 0x09
          FWayneSendBuffer(CmdBuffer,9);
    1636:	ce 01       	movw	r24, r28
    1638:	01 96       	adiw	r24, 0x01	; 1
    163a:	69 e0       	ldi	r22, 0x09	; 9
    163c:	f4 c0       	rjmp	.+488    	; 0x1826 <FWayneSendCommand+0x7f2>
	 /*
  	   [51 30 [01 01] 00 01 01 04 01 01 03 E4 2E [03 FA] //Get Last Status

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    163e:	4f 70       	andi	r20, 0x0F	; 15
    1640:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1642:	84 2f       	mov	r24, r20
    1644:	90 e0       	ldi	r25, 0x00	; 0
    1646:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1648:	e1 e0       	ldi	r30, 0x01	; 1
    164a:	f0 ea       	ldi	r31, 0xA0	; 160
    164c:	9c 01       	movw	r18, r24
    164e:	36 95       	lsr	r19
    1650:	27 95       	ror	r18
    1652:	80 ff       	sbrs	r24, 0
    1654:	04 c0       	rjmp	.+8      	; 0x165e <FWayneSendCommand+0x62a>
    1656:	c9 01       	movw	r24, r18
    1658:	8e 27       	eor	r24, r30
    165a:	9f 27       	eor	r25, r31
    165c:	01 c0       	rjmp	.+2      	; 0x1660 <FWayneSendCommand+0x62c>
        else xCRC= (xCRC>> 1);
    165e:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1660:	5f 5f       	subi	r21, 0xFF	; 255
    1662:	58 30       	cpi	r21, 0x08	; 8
    1664:	99 f7       	brne	.-26     	; 0x164c <FWayneSendCommand+0x618>
  	   [51 30 [01 01] 00 01 01 04 01 01 03 E4 2E [03 FA] //Get Last Status

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    1666:	6f 70       	andi	r22, 0x0F	; 15
    1668:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    166a:	26 2f       	mov	r18, r22
    166c:	30 e0       	ldi	r19, 0x00	; 0
    166e:	28 27       	eor	r18, r24
    1670:	39 27       	eor	r19, r25
    1672:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1674:	e1 e0       	ldi	r30, 0x01	; 1
    1676:	f0 ea       	ldi	r31, 0xA0	; 160
    1678:	c9 01       	movw	r24, r18
    167a:	96 95       	lsr	r25
    167c:	87 95       	ror	r24
    167e:	20 ff       	sbrs	r18, 0
    1680:	04 c0       	rjmp	.+8      	; 0x168a <FWayneSendCommand+0x656>
    1682:	9c 01       	movw	r18, r24
    1684:	2e 27       	eor	r18, r30
    1686:	3f 27       	eor	r19, r31
    1688:	01 c0       	rjmp	.+2      	; 0x168c <FWayneSendCommand+0x658>
        else xCRC= (xCRC>> 1);
    168a:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    168c:	5f 5f       	subi	r21, 0xFF	; 255
    168e:	58 30       	cpi	r21, 0x08	; 8
    1690:	99 f7       	brne	.-26     	; 0x1678 <FWayneSendCommand+0x644>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1692:	81 e0       	ldi	r24, 0x01	; 1
    1694:	90 e0       	ldi	r25, 0x00	; 0
    1696:	82 27       	eor	r24, r18
    1698:	93 27       	eor	r25, r19
    169a:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    169c:	e1 e0       	ldi	r30, 0x01	; 1
    169e:	f0 ea       	ldi	r31, 0xA0	; 160
    16a0:	9c 01       	movw	r18, r24
    16a2:	36 95       	lsr	r19
    16a4:	27 95       	ror	r18
    16a6:	80 ff       	sbrs	r24, 0
    16a8:	04 c0       	rjmp	.+8      	; 0x16b2 <FWayneSendCommand+0x67e>
    16aa:	c9 01       	movw	r24, r18
    16ac:	8e 27       	eor	r24, r30
    16ae:	9f 27       	eor	r25, r31
    16b0:	01 c0       	rjmp	.+2      	; 0x16b4 <FWayneSendCommand+0x680>
        else xCRC= (xCRC>> 1);
    16b2:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    16b4:	5f 5f       	subi	r21, 0xFF	; 255
    16b6:	58 30       	cpi	r21, 0x08	; 8
    16b8:	99 f7       	brne	.-26     	; 0x16a0 <FWayneSendCommand+0x66c>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    16ba:	21 e0       	ldi	r18, 0x01	; 1
    16bc:	30 e0       	ldi	r19, 0x00	; 0
    16be:	28 27       	eor	r18, r24
    16c0:	39 27       	eor	r19, r25
    16c2:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    16c4:	e1 e0       	ldi	r30, 0x01	; 1
    16c6:	f0 ea       	ldi	r31, 0xA0	; 160
    16c8:	c9 01       	movw	r24, r18
    16ca:	96 95       	lsr	r25
    16cc:	87 95       	ror	r24
    16ce:	20 ff       	sbrs	r18, 0
    16d0:	04 c0       	rjmp	.+8      	; 0x16da <FWayneSendCommand+0x6a6>
    16d2:	9c 01       	movw	r18, r24
    16d4:	2e 27       	eor	r18, r30
    16d6:	3f 27       	eor	r19, r31
    16d8:	01 c0       	rjmp	.+2      	; 0x16dc <FWayneSendCommand+0x6a8>
        else xCRC= (xCRC>> 1);
    16da:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    16dc:	5f 5f       	subi	r21, 0xFF	; 255
    16de:	58 30       	cpi	r21, 0x08	; 8
    16e0:	99 f7       	brne	.-26     	; 0x16c8 <FWayneSendCommand+0x694>
    16e2:	50 e0       	ldi	r21, 0x00	; 0
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    16e4:	e1 e0       	ldi	r30, 0x01	; 1
    16e6:	f0 ea       	ldi	r31, 0xA0	; 160
    16e8:	c9 01       	movw	r24, r18
    16ea:	96 95       	lsr	r25
    16ec:	87 95       	ror	r24
    16ee:	20 ff       	sbrs	r18, 0
    16f0:	04 c0       	rjmp	.+8      	; 0x16fa <FWayneSendCommand+0x6c6>
    16f2:	9c 01       	movw	r18, r24
    16f4:	2e 27       	eor	r18, r30
    16f6:	3f 27       	eor	r19, r31
    16f8:	01 c0       	rjmp	.+2      	; 0x16fc <FWayneSendCommand+0x6c8>
        else xCRC= (xCRC>> 1);
    16fa:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    16fc:	5f 5f       	subi	r21, 0xFF	; 255
    16fe:	58 30       	cpi	r21, 0x08	; 8
    1700:	99 f7       	brne	.-26     	; 0x16e8 <FWayneSendCommand+0x6b4>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1702:	81 e0       	ldi	r24, 0x01	; 1
    1704:	90 e0       	ldi	r25, 0x00	; 0
    1706:	82 27       	eor	r24, r18
    1708:	93 27       	eor	r25, r19
    170a:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    170c:	e1 e0       	ldi	r30, 0x01	; 1
    170e:	f0 ea       	ldi	r31, 0xA0	; 160
    1710:	9c 01       	movw	r18, r24
    1712:	36 95       	lsr	r19
    1714:	27 95       	ror	r18
    1716:	80 ff       	sbrs	r24, 0
    1718:	04 c0       	rjmp	.+8      	; 0x1722 <FWayneSendCommand+0x6ee>
    171a:	c9 01       	movw	r24, r18
    171c:	8e 27       	eor	r24, r30
    171e:	9f 27       	eor	r25, r31
    1720:	01 c0       	rjmp	.+2      	; 0x1724 <FWayneSendCommand+0x6f0>
        else xCRC= (xCRC>> 1);
    1722:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1724:	5f 5f       	subi	r21, 0xFF	; 255
    1726:	58 30       	cpi	r21, 0x08	; 8
    1728:	99 f7       	brne	.-26     	; 0x1710 <FWayneSendCommand+0x6dc>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    172a:	21 e0       	ldi	r18, 0x01	; 1
    172c:	30 e0       	ldi	r19, 0x00	; 0
    172e:	28 27       	eor	r18, r24
    1730:	39 27       	eor	r19, r25
    1732:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1734:	e1 e0       	ldi	r30, 0x01	; 1
    1736:	f0 ea       	ldi	r31, 0xA0	; 160
    1738:	c9 01       	movw	r24, r18
    173a:	96 95       	lsr	r25
    173c:	87 95       	ror	r24
    173e:	20 ff       	sbrs	r18, 0
    1740:	04 c0       	rjmp	.+8      	; 0x174a <FWayneSendCommand+0x716>
    1742:	9c 01       	movw	r18, r24
    1744:	2e 27       	eor	r18, r30
    1746:	3f 27       	eor	r19, r31
    1748:	01 c0       	rjmp	.+2      	; 0x174c <FWayneSendCommand+0x718>
        else xCRC= (xCRC>> 1);
    174a:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    174c:	5f 5f       	subi	r21, 0xFF	; 255
    174e:	58 30       	cpi	r21, 0x08	; 8
    1750:	99 f7       	brne	.-26     	; 0x1738 <FWayneSendCommand+0x704>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1752:	84 e0       	ldi	r24, 0x04	; 4
    1754:	90 e0       	ldi	r25, 0x00	; 0
    1756:	82 27       	eor	r24, r18
    1758:	93 27       	eor	r25, r19
    175a:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    175c:	e1 e0       	ldi	r30, 0x01	; 1
    175e:	f0 ea       	ldi	r31, 0xA0	; 160
    1760:	9c 01       	movw	r18, r24
    1762:	36 95       	lsr	r19
    1764:	27 95       	ror	r18
    1766:	80 ff       	sbrs	r24, 0
    1768:	04 c0       	rjmp	.+8      	; 0x1772 <FWayneSendCommand+0x73e>
    176a:	c9 01       	movw	r24, r18
    176c:	8e 27       	eor	r24, r30
    176e:	9f 27       	eor	r25, r31
    1770:	01 c0       	rjmp	.+2      	; 0x1774 <FWayneSendCommand+0x740>
        else xCRC= (xCRC>> 1);
    1772:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1774:	5f 5f       	subi	r21, 0xFF	; 255
    1776:	58 30       	cpi	r21, 0x08	; 8
    1778:	99 f7       	brne	.-26     	; 0x1760 <FWayneSendCommand+0x72c>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    177a:	21 e0       	ldi	r18, 0x01	; 1
    177c:	30 e0       	ldi	r19, 0x00	; 0
    177e:	28 27       	eor	r18, r24
    1780:	39 27       	eor	r19, r25
    1782:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1784:	e1 e0       	ldi	r30, 0x01	; 1
    1786:	f0 ea       	ldi	r31, 0xA0	; 160
    1788:	c9 01       	movw	r24, r18
    178a:	96 95       	lsr	r25
    178c:	87 95       	ror	r24
    178e:	20 ff       	sbrs	r18, 0
    1790:	04 c0       	rjmp	.+8      	; 0x179a <FWayneSendCommand+0x766>
    1792:	9c 01       	movw	r18, r24
    1794:	2e 27       	eor	r18, r30
    1796:	3f 27       	eor	r19, r31
    1798:	01 c0       	rjmp	.+2      	; 0x179c <FWayneSendCommand+0x768>
        else xCRC= (xCRC>> 1);
    179a:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    179c:	5f 5f       	subi	r21, 0xFF	; 255
    179e:	58 30       	cpi	r21, 0x08	; 8
    17a0:	99 f7       	brne	.-26     	; 0x1788 <FWayneSendCommand+0x754>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    17a2:	81 e0       	ldi	r24, 0x01	; 1
    17a4:	90 e0       	ldi	r25, 0x00	; 0
    17a6:	82 27       	eor	r24, r18
    17a8:	93 27       	eor	r25, r19
    17aa:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    17ac:	e1 e0       	ldi	r30, 0x01	; 1
    17ae:	f0 ea       	ldi	r31, 0xA0	; 160
    17b0:	9c 01       	movw	r18, r24
    17b2:	36 95       	lsr	r19
    17b4:	27 95       	ror	r18
    17b6:	80 ff       	sbrs	r24, 0
    17b8:	04 c0       	rjmp	.+8      	; 0x17c2 <FWayneSendCommand+0x78e>
    17ba:	c9 01       	movw	r24, r18
    17bc:	8e 27       	eor	r24, r30
    17be:	9f 27       	eor	r25, r31
    17c0:	01 c0       	rjmp	.+2      	; 0x17c4 <FWayneSendCommand+0x790>
        else xCRC= (xCRC>> 1);
    17c2:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    17c4:	5f 5f       	subi	r21, 0xFF	; 255
    17c6:	58 30       	cpi	r21, 0x08	; 8
    17c8:	99 f7       	brne	.-26     	; 0x17b0 <FWayneSendCommand+0x77c>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    17ca:	e3 e0       	ldi	r30, 0x03	; 3
    17cc:	f0 e0       	ldi	r31, 0x00	; 0
    17ce:	e8 27       	eor	r30, r24
    17d0:	f9 27       	eor	r31, r25
    17d2:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    17d4:	a1 e0       	ldi	r26, 0x01	; 1
    17d6:	b0 ea       	ldi	r27, 0xA0	; 160
    17d8:	cf 01       	movw	r24, r30
    17da:	96 95       	lsr	r25
    17dc:	87 95       	ror	r24
    17de:	e0 ff       	sbrs	r30, 0
    17e0:	04 c0       	rjmp	.+8      	; 0x17ea <FWayneSendCommand+0x7b6>
    17e2:	fc 01       	movw	r30, r24
    17e4:	ea 27       	eor	r30, r26
    17e6:	fb 27       	eor	r31, r27
    17e8:	01 c0       	rjmp	.+2      	; 0x17ec <FWayneSendCommand+0x7b8>
        else xCRC= (xCRC>> 1);
    17ea:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    17ec:	2f 5f       	subi	r18, 0xFF	; 255
    17ee:	28 30       	cpi	r18, 0x08	; 8
    17f0:	99 f7       	brne	.-26     	; 0x17d8 <FWayneSendCommand+0x7a4>
	 /*
  	   [51 30 [01 01] 00 01 01 04 01 01 03 E4 2E [03 FA] //Get Last Status

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    17f2:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    17f4:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    17f6:	91 e0       	ldi	r25, 0x01	; 1
    17f8:	9b 83       	std	Y+3, r25	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    17fa:	9c 83       	std	Y+4, r25	; 0x04
		  CmdBuffer[4]=0x00;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    17fc:	1d 82       	std	Y+5, r1	; 0x05
		  CmdBuffer[5]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    17fe:	9e 83       	std	Y+6, r25	; 0x06
		  CmdBuffer[6]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    1800:	9f 83       	std	Y+7, r25	; 0x07
		  CmdBuffer[7]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    1802:	84 e0       	ldi	r24, 0x04	; 4
    1804:	88 87       	std	Y+8, r24	; 0x08
		  CmdBuffer[8]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[8]);
    1806:	99 87       	std	Y+9, r25	; 0x09
		  CmdBuffer[9]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[9]);
    1808:	9a 87       	std	Y+10, r25	; 0x0a
		  CmdBuffer[10]=0x03;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[10]);
    180a:	23 e0       	ldi	r18, 0x03	; 3
    180c:	2b 87       	std	Y+11, r18	; 0x0b
		  CmdBuffer[11]=tCRC16;
    180e:	ec 87       	std	Y+12, r30	; 0x0c
		  CmdBuffer[12]=tCRC16>>8;
    1810:	8f 2f       	mov	r24, r31
    1812:	99 27       	eor	r25, r25
    1814:	87 fd       	sbrc	r24, 7
    1816:	9a 95       	dec	r25
    1818:	8d 87       	std	Y+13, r24	; 0x0d
		  CmdBuffer[13]=0x03;
    181a:	2e 87       	std	Y+14, r18	; 0x0e
		  CmdBuffer[14]=0xFA;
    181c:	8a ef       	ldi	r24, 0xFA	; 250
    181e:	8f 87       	std	Y+15, r24	; 0x0f
          FWayneSendBuffer(CmdBuffer,15);
    1820:	ce 01       	movw	r24, r28
    1822:	01 96       	adiw	r24, 0x01	; 1
    1824:	6f e0       	ldi	r22, 0x0F	; 15
    1826:	0e 94 07 08 	call	0x100e	; 0x100e <FWayneSendBuffer>
	      break;
     case CMD_REQ_GLOBAL_STATUS_2:
  	      break;
	 }	 
}
    182a:	6e 96       	adiw	r28, 0x1e	; 30
    182c:	0f b6       	in	r0, 0x3f	; 63
    182e:	f8 94       	cli
    1830:	de bf       	out	0x3e, r29	; 62
    1832:	0f be       	out	0x3f, r0	; 63
    1834:	cd bf       	out	0x3d, r28	; 61
    1836:	cf 91       	pop	r28
    1838:	df 91       	pop	r29
    183a:	1f 91       	pop	r17
    183c:	0f 91       	pop	r16
    183e:	08 95       	ret

00001840 <TerminalSendf>:
	 SendSPI(AckData);
	 SendSPI(0x0A);
	 systemSlave();
}

void TerminalSendf(char Com,char *strSendf){
    1840:	1f 93       	push	r17
    1842:	cf 93       	push	r28
    1844:	df 93       	push	r29
    1846:	18 2f       	mov	r17, r24
    1848:	eb 01       	movw	r28, r22
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    184a:	e1 99       	sbic	0x1c, 1	; 28
    184c:	fe cf       	rjmp	.-4      	; 0x184a <TerminalSendf+0xa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    184e:	84 e0       	ldi	r24, 0x04	; 4
    1850:	90 e0       	ldi	r25, 0x00	; 0
    1852:	9f bb       	out	0x1f, r25	; 31
    1854:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1856:	e0 9a       	sbi	0x1c, 0	; 28
    1858:	8d b3       	in	r24, 0x1d	; 29
   if (eeprom_read_byte(&DefTerminalDebug)){
    185a:	88 23       	and	r24, r24
    185c:	41 f4       	brne	.+16     	; 0x186e <TerminalSendf+0x2e>
    185e:	0c c0       	rjmp	.+24     	; 0x1878 <TerminalSendf+0x38>
       while(pgm_read_byte(&(*strSendf)))
	         _uart(Com, 1, pgm_read_byte(&(*strSendf++)));
    1860:	21 96       	adiw	r28, 0x01	; 1
    1862:	f9 01       	movw	r30, r18
    1864:	44 91       	lpm	r20, Z+
    1866:	81 2f       	mov	r24, r17
    1868:	61 e0       	ldi	r22, 0x01	; 1
    186a:	0e 94 76 1b 	call	0x36ec	; 0x36ec <_uart>
    186e:	9e 01       	movw	r18, r28
	 systemSlave();
}

void TerminalSendf(char Com,char *strSendf){
   if (eeprom_read_byte(&DefTerminalDebug)){
       while(pgm_read_byte(&(*strSendf)))
    1870:	fe 01       	movw	r30, r28
    1872:	84 91       	lpm	r24, Z+
    1874:	88 23       	and	r24, r24
    1876:	a1 f7       	brne	.-24     	; 0x1860 <TerminalSendf+0x20>
	         _uart(Com, 1, pgm_read_byte(&(*strSendf++)));
	}
}
    1878:	df 91       	pop	r29
    187a:	cf 91       	pop	r28
    187c:	1f 91       	pop	r17
    187e:	08 95       	ret

00001880 <SendTotalizerFlow>:
	    SendSPI(strSendSPI[i]);
        //_uart(1,1,strSendSPI[i]);
	 } 
}

void SendTotalizerFlow(char xPumpID){
    1880:	4f 92       	push	r4
    1882:	5f 92       	push	r5
    1884:	6f 92       	push	r6
    1886:	7f 92       	push	r7
    1888:	8f 92       	push	r8
    188a:	9f 92       	push	r9
    188c:	af 92       	push	r10
    188e:	bf 92       	push	r11
    1890:	cf 92       	push	r12
    1892:	df 92       	push	r13
    1894:	ef 92       	push	r14
    1896:	ff 92       	push	r15
    1898:	0f 93       	push	r16
    189a:	1f 93       	push	r17
    189c:	df 93       	push	r29
    189e:	cf 93       	push	r28
    18a0:	cd b7       	in	r28, 0x3d	; 61
    18a2:	de b7       	in	r29, 0x3e	; 62
    18a4:	a8 97       	sbiw	r28, 0x28	; 40
    18a6:	0f b6       	in	r0, 0x3f	; 63
    18a8:	f8 94       	cli
    18aa:	de bf       	out	0x3e, r29	; 62
    18ac:	0f be       	out	0x3f, r0	; 63
    18ae:	cd bf       	out	0x3d, r28	; 61
char i,xPump,strSend[40];
char strVol[10],strMon[10];
	 //                           [0x50,0x05]  02     01    0000000  0000000  0000000  0000000  0000200  0000000  0000200  0000000  0000000  0000000 [0x06,0x60] = 4+8*2*6=76
	 //Sending FlowSPI_Protocol     <STX>   [MsgID][PumpID][Volume1][Amount1][Volume2][Amount2][Volume3][Amount3][Volume4][Amount4][Volume5][Amount5][Volume6][Amount6]<ETX>
	 if (xPumpID>=16)xPump=16;
    18b0:	80 31       	cpi	r24, 0x10	; 16
    18b2:	10 f4       	brcc	.+4      	; 0x18b8 <SendTotalizerFlow+0x38>
    18b4:	f8 2e       	mov	r15, r24
    18b6:	02 c0       	rjmp	.+4      	; 0x18bc <SendTotalizerFlow+0x3c>
    18b8:	00 e1       	ldi	r16, 0x10	; 16
    18ba:	f0 2e       	mov	r15, r16
	 else xPump=xPumpID;
                                                
	 systemMaster();
    18bc:	0e 94 40 07 	call	0xe80	; 0xe80 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    18c0:	85 e0       	ldi	r24, 0x05	; 5
    18c2:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    18c6:	80 e5       	ldi	r24, 0x50	; 80
    18c8:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
    18cc:	2e 01       	movw	r4, r28
    18ce:	08 94       	sec
    18d0:	41 1c       	adc	r4, r1
    18d2:	51 1c       	adc	r5, r1
    18d4:	52 01       	movw	r10, r4
    18d6:	ce 01       	movw	r24, r28
    18d8:	89 96       	adiw	r24, 0x29	; 41
	     strMemory[i]=data;
    18da:	d5 01       	movw	r26, r10
    18dc:	1d 92       	st	X+, r1
    18de:	5d 01       	movw	r10, r26
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    18e0:	a8 17       	cp	r26, r24
    18e2:	b9 07       	cpc	r27, r25
    18e4:	d1 f7       	brne	.-12     	; 0x18da <SendTotalizerFlow+0x5a>
	 systemMaster();
	 SendSPI(0x05);//STX
	 SendSPI(0x50);//STX
	 FillChar(strSend,sizeof(strSend),0);
	
	 sprintf_P(strSend,PSTR("02%.2d"),xPump);
    18e6:	00 d0       	rcall	.+0      	; 0x18e8 <SendTotalizerFlow+0x68>
    18e8:	00 d0       	rcall	.+0      	; 0x18ea <SendTotalizerFlow+0x6a>
    18ea:	00 d0       	rcall	.+0      	; 0x18ec <SendTotalizerFlow+0x6c>
    18ec:	ed b7       	in	r30, 0x3d	; 61
    18ee:	fe b7       	in	r31, 0x3e	; 62
    18f0:	31 96       	adiw	r30, 0x01	; 1
    18f2:	8e 01       	movw	r16, r28
    18f4:	0f 5f       	subi	r16, 0xFF	; 255
    18f6:	1f 4f       	sbci	r17, 0xFF	; 255
    18f8:	ad b7       	in	r26, 0x3d	; 61
    18fa:	be b7       	in	r27, 0x3e	; 62
    18fc:	12 96       	adiw	r26, 0x02	; 2
    18fe:	1c 93       	st	X, r17
    1900:	0e 93       	st	-X, r16
    1902:	11 97       	sbiw	r26, 0x01	; 1
    1904:	8e e3       	ldi	r24, 0x3E	; 62
    1906:	91 e0       	ldi	r25, 0x01	; 1
    1908:	93 83       	std	Z+3, r25	; 0x03
    190a:	82 83       	std	Z+2, r24	; 0x02
    190c:	f4 82       	std	Z+4, r15	; 0x04
    190e:	15 82       	std	Z+5, r1	; 0x05
    1910:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
     SendStrSPI(strSend);
    1914:	ed b7       	in	r30, 0x3d	; 61
    1916:	fe b7       	in	r31, 0x3e	; 62
    1918:	36 96       	adiw	r30, 0x06	; 6
    191a:	0f b6       	in	r0, 0x3f	; 63
    191c:	f8 94       	cli
    191e:	fe bf       	out	0x3e, r31	; 62
    1920:	0f be       	out	0x3f, r0	; 63
    1922:	ed bf       	out	0x3d, r30	; 61
    1924:	c8 01       	movw	r24, r16
    1926:	0e 94 13 07 	call	0xe26	; 0xe26 <SendStrSPI>
    192a:	ee 24       	eor	r14, r14
    192c:	ff 24       	eor	r15, r15
     for (i=0;i<6;i++){
	      //FixingData V:[00000000] M:[00000000]
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strMoney,12);
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strVolume,12);
		  FillChar(strSend,sizeof(strSend),0);
		  sprintf_P(strSend,PSTR("%s%s"),PumpTotalizer.TotalGrade[i].strVolume,PumpTotalizer.TotalGrade[i].strMoney);
    192e:	90 2e       	mov	r9, r16
    1930:	81 2e       	mov	r8, r17
    1932:	19 e3       	ldi	r17, 0x39	; 57
    1934:	61 2e       	mov	r6, r17
    1936:	11 e0       	ldi	r17, 0x01	; 1
    1938:	71 2e       	mov	r7, r17
	 sprintf_P(strSend,PSTR("02%.2d"),xPump);
     SendStrSPI(strSend);

     for (i=0;i<6;i++){
	      //FixingData V:[00000000] M:[00000000]
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strMoney,12);
    193a:	c7 01       	movw	r24, r14
    193c:	67 01       	movw	r12, r14
    193e:	b5 e0       	ldi	r27, 0x05	; 5
    1940:	cc 0c       	add	r12, r12
    1942:	dd 1c       	adc	r13, r13
    1944:	ba 95       	dec	r27
    1946:	e1 f7       	brne	.-8      	; 0x1940 <SendTotalizerFlow+0xc0>
    1948:	88 0f       	add	r24, r24
    194a:	99 1f       	adc	r25, r25
    194c:	c8 1a       	sub	r12, r24
    194e:	d9 0a       	sbc	r13, r25
    1950:	86 e0       	ldi	r24, 0x06	; 6
    1952:	93 e0       	ldi	r25, 0x03	; 3
    1954:	c8 0e       	add	r12, r24
    1956:	d9 1e       	adc	r13, r25
    1958:	c6 01       	movw	r24, r12
    195a:	6c e0       	ldi	r22, 0x0C	; 12
    195c:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <AddZeroLead>
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strVolume,12);
    1960:	c7 01       	movw	r24, r14
    1962:	87 01       	movw	r16, r14
    1964:	f5 e0       	ldi	r31, 0x05	; 5
    1966:	00 0f       	add	r16, r16
    1968:	11 1f       	adc	r17, r17
    196a:	fa 95       	dec	r31
    196c:	e1 f7       	brne	.-8      	; 0x1966 <SendTotalizerFlow+0xe6>
    196e:	88 0f       	add	r24, r24
    1970:	99 1f       	adc	r25, r25
    1972:	08 1b       	sub	r16, r24
    1974:	19 0b       	sbc	r17, r25
    1976:	09 50       	subi	r16, 0x09	; 9
    1978:	1d 4f       	sbci	r17, 0xFD	; 253
    197a:	c8 01       	movw	r24, r16
    197c:	6c e0       	ldi	r22, 0x0C	; 12
    197e:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <AddZeroLead>
    1982:	f2 01       	movw	r30, r4
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    1984:	11 92       	st	Z+, r1
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    1986:	ea 15       	cp	r30, r10
    1988:	fb 05       	cpc	r31, r11
    198a:	e1 f7       	brne	.-8      	; 0x1984 <SendTotalizerFlow+0x104>
     for (i=0;i<6;i++){
	      //FixingData V:[00000000] M:[00000000]
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strMoney,12);
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strVolume,12);
		  FillChar(strSend,sizeof(strSend),0);
		  sprintf_P(strSend,PSTR("%s%s"),PumpTotalizer.TotalGrade[i].strVolume,PumpTotalizer.TotalGrade[i].strMoney);
    198c:	ad b7       	in	r26, 0x3d	; 61
    198e:	be b7       	in	r27, 0x3e	; 62
    1990:	18 97       	sbiw	r26, 0x08	; 8
    1992:	0f b6       	in	r0, 0x3f	; 63
    1994:	f8 94       	cli
    1996:	be bf       	out	0x3e, r27	; 62
    1998:	0f be       	out	0x3f, r0	; 63
    199a:	ad bf       	out	0x3d, r26	; 61
    199c:	ed b7       	in	r30, 0x3d	; 61
    199e:	fe b7       	in	r31, 0x3e	; 62
    19a0:	31 96       	adiw	r30, 0x01	; 1
    19a2:	11 96       	adiw	r26, 0x01	; 1
    19a4:	9c 92       	st	X, r9
    19a6:	11 97       	sbiw	r26, 0x01	; 1
    19a8:	12 96       	adiw	r26, 0x02	; 2
    19aa:	8c 92       	st	X, r8
    19ac:	73 82       	std	Z+3, r7	; 0x03
    19ae:	62 82       	std	Z+2, r6	; 0x02
    19b0:	15 83       	std	Z+5, r17	; 0x05
    19b2:	04 83       	std	Z+4, r16	; 0x04
    19b4:	d7 82       	std	Z+7, r13	; 0x07
    19b6:	c6 82       	std	Z+6, r12	; 0x06
    19b8:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
          SendStrSPI(strSend);
    19bc:	ed b7       	in	r30, 0x3d	; 61
    19be:	fe b7       	in	r31, 0x3e	; 62
    19c0:	38 96       	adiw	r30, 0x08	; 8
    19c2:	0f b6       	in	r0, 0x3f	; 63
    19c4:	f8 94       	cli
    19c6:	fe bf       	out	0x3e, r31	; 62
    19c8:	0f be       	out	0x3f, r0	; 63
    19ca:	ed bf       	out	0x3d, r30	; 61
    19cc:	89 2d       	mov	r24, r9
    19ce:	98 2d       	mov	r25, r8
    19d0:	0e 94 13 07 	call	0xe26	; 0xe26 <SendStrSPI>
    19d4:	08 94       	sec
    19d6:	e1 1c       	adc	r14, r1
    19d8:	f1 1c       	adc	r15, r1
	 FillChar(strSend,sizeof(strSend),0);
	
	 sprintf_P(strSend,PSTR("02%.2d"),xPump);
     SendStrSPI(strSend);

     for (i=0;i<6;i++){
    19da:	f6 e0       	ldi	r31, 0x06	; 6
    19dc:	ef 16       	cp	r14, r31
    19de:	f1 04       	cpc	r15, r1
    19e0:	09 f0       	breq	.+2      	; 0x19e4 <SendTotalizerFlow+0x164>
    19e2:	ab cf       	rjmp	.-170    	; 0x193a <SendTotalizerFlow+0xba>
		  #ifdef DEBUG_TOTAL_FLOW 
		  _uart_print(1,1,strSend);
		  #endif
	 }
	 //TotalizerDigit
	 sprintf_P(strSend,PSTR("%d"),PumpTotalDigit);
    19e4:	00 d0       	rcall	.+0      	; 0x19e6 <SendTotalizerFlow+0x166>
    19e6:	00 d0       	rcall	.+0      	; 0x19e8 <SendTotalizerFlow+0x168>
    19e8:	00 d0       	rcall	.+0      	; 0x19ea <SendTotalizerFlow+0x16a>
    19ea:	ed b7       	in	r30, 0x3d	; 61
    19ec:	fe b7       	in	r31, 0x3e	; 62
    19ee:	31 96       	adiw	r30, 0x01	; 1
    19f0:	ad b7       	in	r26, 0x3d	; 61
    19f2:	be b7       	in	r27, 0x3e	; 62
    19f4:	11 96       	adiw	r26, 0x01	; 1
    19f6:	9c 92       	st	X, r9
    19f8:	11 97       	sbiw	r26, 0x01	; 1
    19fa:	12 96       	adiw	r26, 0x02	; 2
    19fc:	8c 92       	st	X, r8
    19fe:	86 e3       	ldi	r24, 0x36	; 54
    1a00:	91 e0       	ldi	r25, 0x01	; 1
    1a02:	93 83       	std	Z+3, r25	; 0x03
    1a04:	82 83       	std	Z+2, r24	; 0x02
    1a06:	80 91 0c 01 	lds	r24, 0x010C
    1a0a:	84 83       	std	Z+4, r24	; 0x04
    1a0c:	15 82       	std	Z+5, r1	; 0x05
    1a0e:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
     SendStrSPI(strSend);
    1a12:	ed b7       	in	r30, 0x3d	; 61
    1a14:	fe b7       	in	r31, 0x3e	; 62
    1a16:	36 96       	adiw	r30, 0x06	; 6
    1a18:	0f b6       	in	r0, 0x3f	; 63
    1a1a:	f8 94       	cli
    1a1c:	fe bf       	out	0x3e, r31	; 62
    1a1e:	0f be       	out	0x3f, r0	; 63
    1a20:	ed bf       	out	0x3d, r30	; 61
    1a22:	89 2d       	mov	r24, r9
    1a24:	98 2d       	mov	r25, r8
    1a26:	0e 94 13 07 	call	0xe26	; 0xe26 <SendStrSPI>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    1a2a:	86 e0       	ldi	r24, 0x06	; 6
    1a2c:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
	 sprintf_P(strSend,PSTR("%d"),PumpTotalDigit);
     SendStrSPI(strSend);

	 SendSPI(0x06);//ETX
	 SendSPI(0x60);//ETX
	 systemSlave();
    1a30:	80 e6       	ldi	r24, 0x60	; 96
    1a32:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
    1a36:	0e 94 33 07 	call	0xe66	; 0xe66 <systemSlave>
    1a3a:	8a ef       	ldi	r24, 0xFA	; 250
    1a3c:	90 e0       	ldi	r25, 0x00	; 0
    1a3e:	01 97       	sbiw	r24, 0x01	; 1
    1a40:	f1 f7       	brne	.-4      	; 0x1a3e <SendTotalizerFlow+0x1be>
	 _delay_ms(1);//DelayProses
}
    1a42:	a8 96       	adiw	r28, 0x28	; 40
    1a44:	0f b6       	in	r0, 0x3f	; 63
    1a46:	f8 94       	cli
    1a48:	de bf       	out	0x3e, r29	; 62
    1a4a:	0f be       	out	0x3f, r0	; 63
    1a4c:	cd bf       	out	0x3d, r28	; 61
    1a4e:	cf 91       	pop	r28
    1a50:	df 91       	pop	r29
    1a52:	1f 91       	pop	r17
    1a54:	0f 91       	pop	r16
    1a56:	ff 90       	pop	r15
    1a58:	ef 90       	pop	r14
    1a5a:	df 90       	pop	r13
    1a5c:	cf 90       	pop	r12
    1a5e:	bf 90       	pop	r11
    1a60:	af 90       	pop	r10
    1a62:	9f 90       	pop	r9
    1a64:	8f 90       	pop	r8
    1a66:	7f 90       	pop	r7
    1a68:	6f 90       	pop	r6
    1a6a:	5f 90       	pop	r5
    1a6c:	4f 90       	pop	r4
    1a6e:	08 95       	ret

00001a70 <SendTransFlow>:
	 SendSPI(0x08);//ETX

	 systemSlave();
}

void SendTransFlow(char xPumpID, char rxPumpId,char xNozzleID,char xProductID, char *sUnitPrice, char *sVolume,char * sAmount,char TransDigit){
    1a70:	6f 92       	push	r6
    1a72:	7f 92       	push	r7
    1a74:	8f 92       	push	r8
    1a76:	9f 92       	push	r9
    1a78:	af 92       	push	r10
    1a7a:	bf 92       	push	r11
    1a7c:	cf 92       	push	r12
    1a7e:	df 92       	push	r13
    1a80:	ef 92       	push	r14
    1a82:	ff 92       	push	r15
    1a84:	0f 93       	push	r16
    1a86:	1f 93       	push	r17
    1a88:	df 93       	push	r29
    1a8a:	cf 93       	push	r28
    1a8c:	cd b7       	in	r28, 0x3d	; 61
    1a8e:	de b7       	in	r29, 0x3e	; 62
    1a90:	6e 97       	sbiw	r28, 0x1e	; 30
    1a92:	0f b6       	in	r0, 0x3f	; 63
    1a94:	f8 94       	cli
    1a96:	de bf       	out	0x3e, r29	; 62
    1a98:	0f be       	out	0x3f, r0	; 63
    1a9a:	cd bf       	out	0x3d, r28	; 61
    1a9c:	68 2e       	mov	r6, r24
    1a9e:	b4 2e       	mov	r11, r20
    1aa0:	72 2e       	mov	r7, r18
    1aa2:	48 01       	movw	r8, r16
     char i,xNozzle,xPrd,xPump,strSend[30];

	                         //  [0x50,0x05]  01       01       1        3       004500   00000200  00000000 [0x06,0x60] = 24
	 //Sending FlowSPI_Protocol     <STX>   [MsgID][PumpID][Nozzle][ProductID][UnitPrice][Volume][Amount] <ETX>
	 AddZeroLead(sUnitPrice,6);//         Wyne    01 02 2 0 004600 00000254 00011684
    1aa4:	c8 01       	movw	r24, r16
    1aa6:	66 e0       	ldi	r22, 0x06	; 6
    1aa8:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <AddZeroLead>
     AddZeroLead(sVolume,8);
    1aac:	c7 01       	movw	r24, r14
    1aae:	68 e0       	ldi	r22, 0x08	; 8
    1ab0:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <AddZeroLead>
     AddZeroLead(sAmount,8);
    1ab4:	c6 01       	movw	r24, r12
    1ab6:	68 e0       	ldi	r22, 0x08	; 8
    1ab8:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <AddZeroLead>
	 
	 if (xNozzleID>=4)xNozzle=4;
    1abc:	83 e0       	ldi	r24, 0x03	; 3
    1abe:	8b 15       	cp	r24, r11
    1ac0:	10 f0       	brcs	.+4      	; 0x1ac6 <SendTransFlow+0x56>
    1ac2:	4b 2d       	mov	r20, r11
    1ac4:	01 c0       	rjmp	.+2      	; 0x1ac8 <SendTransFlow+0x58>
    1ac6:	44 e0       	ldi	r20, 0x04	; 4
	 else xNozzle=xNozzleID;
	 
	 if (xProductID>=4)xPrd=4;
    1ac8:	93 e0       	ldi	r25, 0x03	; 3
    1aca:	97 15       	cp	r25, r7
    1acc:	10 f0       	brcs	.+4      	; 0x1ad2 <SendTransFlow+0x62>
    1ace:	27 2d       	mov	r18, r7
    1ad0:	01 c0       	rjmp	.+2      	; 0x1ad4 <SendTransFlow+0x64>
    1ad2:	24 e0       	ldi	r18, 0x04	; 4
	 else xPrd=xProductID;

	 if (xPumpID>=16)xPump=16;
    1ad4:	af e0       	ldi	r26, 0x0F	; 15
    1ad6:	a6 15       	cp	r26, r6
    1ad8:	10 f0       	brcs	.+4      	; 0x1ade <SendTransFlow+0x6e>
    1ada:	36 2d       	mov	r19, r6
    1adc:	01 c0       	rjmp	.+2      	; 0x1ae0 <SendTransFlow+0x70>
    1ade:	30 e1       	ldi	r19, 0x10	; 16
	 else xPump=xPumpID;

	 sprintf_P(strSend,PSTR("01%.2d%.1d%.1d%s%s%s"),xPump,xNozzle,xPrd,sUnitPrice,sVolume,sAmount);
    1ae0:	8d b7       	in	r24, 0x3d	; 61
    1ae2:	9e b7       	in	r25, 0x3e	; 62
    1ae4:	40 97       	sbiw	r24, 0x10	; 16
    1ae6:	0f b6       	in	r0, 0x3f	; 63
    1ae8:	f8 94       	cli
    1aea:	9e bf       	out	0x3e, r25	; 62
    1aec:	0f be       	out	0x3f, r0	; 63
    1aee:	8d bf       	out	0x3d, r24	; 61
    1af0:	ed b7       	in	r30, 0x3d	; 61
    1af2:	fe b7       	in	r31, 0x3e	; 62
    1af4:	31 96       	adiw	r30, 0x01	; 1
    1af6:	8e 01       	movw	r16, r28
    1af8:	0f 5f       	subi	r16, 0xFF	; 255
    1afa:	1f 4f       	sbci	r17, 0xFF	; 255
    1afc:	ad b7       	in	r26, 0x3d	; 61
    1afe:	be b7       	in	r27, 0x3e	; 62
    1b00:	12 96       	adiw	r26, 0x02	; 2
    1b02:	1c 93       	st	X, r17
    1b04:	0e 93       	st	-X, r16
    1b06:	11 97       	sbiw	r26, 0x01	; 1
    1b08:	88 e4       	ldi	r24, 0x48	; 72
    1b0a:	91 e0       	ldi	r25, 0x01	; 1
    1b0c:	93 83       	std	Z+3, r25	; 0x03
    1b0e:	82 83       	std	Z+2, r24	; 0x02
    1b10:	34 83       	std	Z+4, r19	; 0x04
    1b12:	15 82       	std	Z+5, r1	; 0x05
    1b14:	46 83       	std	Z+6, r20	; 0x06
    1b16:	17 82       	std	Z+7, r1	; 0x07
    1b18:	20 87       	std	Z+8, r18	; 0x08
    1b1a:	11 86       	std	Z+9, r1	; 0x09
    1b1c:	93 86       	std	Z+11, r9	; 0x0b
    1b1e:	82 86       	std	Z+10, r8	; 0x0a
    1b20:	f5 86       	std	Z+13, r15	; 0x0d
    1b22:	e4 86       	std	Z+12, r14	; 0x0c
    1b24:	d7 86       	std	Z+15, r13	; 0x0f
    1b26:	c6 86       	std	Z+14, r12	; 0x0e
    1b28:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
	 systemMaster();
    1b2c:	8d b7       	in	r24, 0x3d	; 61
    1b2e:	9e b7       	in	r25, 0x3e	; 62
    1b30:	40 96       	adiw	r24, 0x10	; 16
    1b32:	0f b6       	in	r0, 0x3f	; 63
    1b34:	f8 94       	cli
    1b36:	9e bf       	out	0x3e, r25	; 62
    1b38:	0f be       	out	0x3f, r0	; 63
    1b3a:	8d bf       	out	0x3d, r24	; 61
    1b3c:	0e 94 40 07 	call	0xe80	; 0xe80 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    1b40:	85 e0       	ldi	r24, 0x05	; 5
    1b42:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>

	 sprintf_P(strSend,PSTR("01%.2d%.1d%.1d%s%s%s"),xPump,xNozzle,xPrd,sUnitPrice,sVolume,sAmount);
	 systemMaster();
	 SendSPI(0x05);//STX
	 SendSPI(0x50);//STX
	 for(i=0;i<strlen(strSend);i++){
    1b46:	80 e5       	ldi	r24, 0x50	; 80
    1b48:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
    1b4c:	ff 24       	eor	r15, r15
    1b4e:	06 c0       	rjmp	.+12     	; 0x1b5c <SendTransFlow+0xec>
    1b50:	a0 0f       	add	r26, r16
    1b52:	b1 1f       	adc	r27, r17
    1b54:	8c 91       	ld	r24, X
    1b56:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
    1b5a:	f3 94       	inc	r15
    1b5c:	f8 01       	movw	r30, r16
    1b5e:	01 90       	ld	r0, Z+
    1b60:	00 20       	and	r0, r0
    1b62:	e9 f7       	brne	.-6      	; 0x1b5e <SendTransFlow+0xee>
    1b64:	31 97       	sbiw	r30, 0x01	; 1
    1b66:	e0 1b       	sub	r30, r16
    1b68:	f1 0b       	sbc	r31, r17
    1b6a:	af 2d       	mov	r26, r15
    1b6c:	b0 e0       	ldi	r27, 0x00	; 0
    1b6e:	ae 17       	cp	r26, r30
    1b70:	bf 07       	cpc	r27, r31
    1b72:	70 f3       	brcs	.-36     	; 0x1b50 <SendTransFlow+0xe0>
		 #ifdef DEBUG_TRANS_FLOW 
		 _uart(1,1,strSend[i]);
		 #endif
	 }
	 //TransDigit
	 sprintf_P(strSend,PSTR("%d"),TransDigit);
    1b74:	00 d0       	rcall	.+0      	; 0x1b76 <SendTransFlow+0x106>
    1b76:	00 d0       	rcall	.+0      	; 0x1b78 <SendTransFlow+0x108>
    1b78:	00 d0       	rcall	.+0      	; 0x1b7a <SendTransFlow+0x10a>
    1b7a:	ed b7       	in	r30, 0x3d	; 61
    1b7c:	fe b7       	in	r31, 0x3e	; 62
    1b7e:	31 96       	adiw	r30, 0x01	; 1
    1b80:	ad b7       	in	r26, 0x3d	; 61
    1b82:	be b7       	in	r27, 0x3e	; 62
    1b84:	12 96       	adiw	r26, 0x02	; 2
    1b86:	1c 93       	st	X, r17
    1b88:	0e 93       	st	-X, r16
    1b8a:	11 97       	sbiw	r26, 0x01	; 1
    1b8c:	85 e4       	ldi	r24, 0x45	; 69
    1b8e:	91 e0       	ldi	r25, 0x01	; 1
    1b90:	93 83       	std	Z+3, r25	; 0x03
    1b92:	82 83       	std	Z+2, r24	; 0x02
    1b94:	a4 82       	std	Z+4, r10	; 0x04
    1b96:	15 82       	std	Z+5, r1	; 0x05
    1b98:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
     SendStrSPI(strSend);
    1b9c:	8d b7       	in	r24, 0x3d	; 61
    1b9e:	9e b7       	in	r25, 0x3e	; 62
    1ba0:	06 96       	adiw	r24, 0x06	; 6
    1ba2:	0f b6       	in	r0, 0x3f	; 63
    1ba4:	f8 94       	cli
    1ba6:	9e bf       	out	0x3e, r25	; 62
    1ba8:	0f be       	out	0x3f, r0	; 63
    1baa:	8d bf       	out	0x3d, r24	; 61
    1bac:	c8 01       	movw	r24, r16
    1bae:	0e 94 13 07 	call	0xe26	; 0xe26 <SendStrSPI>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    1bb2:	86 e0       	ldi	r24, 0x06	; 6
    1bb4:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
	 sprintf_P(strSend,PSTR("%d"),TransDigit);
     SendStrSPI(strSend);

	 SendSPI(0x06);//ETX
	 SendSPI(0x60);//ETX
	 systemSlave();
    1bb8:	80 e6       	ldi	r24, 0x60	; 96
    1bba:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_spi>
    1bbe:	0e 94 33 07 	call	0xe66	; 0xe66 <systemSlave>
}
    1bc2:	6e 96       	adiw	r28, 0x1e	; 30
    1bc4:	0f b6       	in	r0, 0x3f	; 63
    1bc6:	f8 94       	cli
    1bc8:	de bf       	out	0x3e, r29	; 62
    1bca:	0f be       	out	0x3f, r0	; 63
    1bcc:	cd bf       	out	0x3d, r28	; 61
    1bce:	cf 91       	pop	r28
    1bd0:	df 91       	pop	r29
    1bd2:	1f 91       	pop	r17
    1bd4:	0f 91       	pop	r16
    1bd6:	ff 90       	pop	r15
    1bd8:	ef 90       	pop	r14
    1bda:	df 90       	pop	r13
    1bdc:	cf 90       	pop	r12
    1bde:	bf 90       	pop	r11
    1be0:	af 90       	pop	r10
    1be2:	9f 90       	pop	r9
    1be4:	8f 90       	pop	r8
    1be6:	7f 90       	pop	r7
    1be8:	6f 90       	pop	r6
    1bea:	08 95       	ret

00001bec <FPoolingPump>:
		  //stPoolingPump=pwInitPumpAddr;
	      break;
	 }
}

void FPoolingPump(){//DefPoolTimeout,DefDelayNextPump
    1bec:	af 92       	push	r10
    1bee:	cf 92       	push	r12
    1bf0:	df 92       	push	r13
    1bf2:	ef 92       	push	r14
    1bf4:	ff 92       	push	r15
    1bf6:	0f 93       	push	r16
    1bf8:	1f 93       	push	r17
    1bfa:	df 93       	push	r29
    1bfc:	cf 93       	push	r28
    1bfe:	cd b7       	in	r28, 0x3d	; 61
    1c00:	de b7       	in	r29, 0x3e	; 62
    1c02:	64 97       	sbiw	r28, 0x14	; 20
    1c04:	0f b6       	in	r0, 0x3f	; 63
    1c06:	f8 94       	cli
    1c08:	de bf       	out	0x3e, r29	; 62
    1c0a:	0f be       	out	0x3f, r0	; 63
    1c0c:	cd bf       	out	0x3d, r28	; 61
//static char txPumpID=0,StatusPump,iSend,nSend,PumpAddr=1,nNoPump,ScanPumpMax,IsNoPump=True,TPoolTimeout,TDelayNextPump;
       char CurrentAmount[15];
	   char strSend[20];

     //Monitoring
	 if (zPooling!=stPoolingPump){
    1c0e:	20 91 2c 01 	lds	r18, 0x012C
    1c12:	80 91 2d 01 	lds	r24, 0x012D
    1c16:	82 17       	cp	r24, r18
    1c18:	31 f1       	breq	.+76     	; 0x1c66 <FPoolingPump+0x7a>
	     zPooling=stPoolingPump;
    1c1a:	20 93 2d 01 	sts	0x012D, r18
		 #ifdef DEBUG_GILBARCO_POOLING
         sprintf_P(strSend,PSTR("GPool:%d"),stPoolingPump);
    1c1e:	00 d0       	rcall	.+0      	; 0x1c20 <FPoolingPump+0x34>
    1c20:	00 d0       	rcall	.+0      	; 0x1c22 <FPoolingPump+0x36>
    1c22:	00 d0       	rcall	.+0      	; 0x1c24 <FPoolingPump+0x38>
    1c24:	ed b7       	in	r30, 0x3d	; 61
    1c26:	fe b7       	in	r31, 0x3e	; 62
    1c28:	31 96       	adiw	r30, 0x01	; 1
    1c2a:	8e 01       	movw	r16, r28
    1c2c:	0f 5f       	subi	r16, 0xFF	; 255
    1c2e:	1f 4f       	sbci	r17, 0xFF	; 255
    1c30:	ad b7       	in	r26, 0x3d	; 61
    1c32:	be b7       	in	r27, 0x3e	; 62
    1c34:	12 96       	adiw	r26, 0x02	; 2
    1c36:	1c 93       	st	X, r17
    1c38:	0e 93       	st	-X, r16
    1c3a:	11 97       	sbiw	r26, 0x01	; 1
    1c3c:	87 e7       	ldi	r24, 0x77	; 119
    1c3e:	91 e0       	ldi	r25, 0x01	; 1
    1c40:	93 83       	std	Z+3, r25	; 0x03
    1c42:	82 83       	std	Z+2, r24	; 0x02
    1c44:	24 83       	std	Z+4, r18	; 0x04
    1c46:	15 82       	std	Z+5, r1	; 0x05
    1c48:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
	 	 _uart_print(1,1,strSend);
    1c4c:	8d b7       	in	r24, 0x3d	; 61
    1c4e:	9e b7       	in	r25, 0x3e	; 62
    1c50:	06 96       	adiw	r24, 0x06	; 6
    1c52:	0f b6       	in	r0, 0x3f	; 63
    1c54:	f8 94       	cli
    1c56:	9e bf       	out	0x3e, r25	; 62
    1c58:	0f be       	out	0x3f, r0	; 63
    1c5a:	8d bf       	out	0x3d, r24	; 61
    1c5c:	81 e0       	ldi	r24, 0x01	; 1
    1c5e:	61 e0       	ldi	r22, 0x01	; 1
    1c60:	a8 01       	movw	r20, r16
    1c62:	0e 94 8d 1b 	call	0x371a	; 0x371a <_uart_print>
		 #endif
	 }
     
	 if (IsRestartPooling==True){
    1c66:	80 91 03 01 	lds	r24, 0x0103
    1c6a:	81 30       	cpi	r24, 0x01	; 1
    1c6c:	79 f4       	brne	.+30     	; 0x1c8c <FPoolingPump+0xa0>
	     IsRestartPooling=False;
    1c6e:	10 92 03 01 	sts	0x0103, r1
		 SendCommandAcknoledge(SC_POOL_RESTARTED,stPoolingPump);
    1c72:	8a e1       	ldi	r24, 0x1A	; 26
    1c74:	60 91 2c 01 	lds	r22, 0x012C
    1c78:	0e 94 65 07 	call	0xeca	; 0xeca <SendCommandAcknoledge>
		 _uart_printf(1,1,PSTR("PoolRestarted"));
    1c7c:	81 e0       	ldi	r24, 0x01	; 1
    1c7e:	61 e0       	ldi	r22, 0x01	; 1
    1c80:	49 e6       	ldi	r20, 0x69	; 105
    1c82:	51 e0       	ldi	r21, 0x01	; 1
    1c84:	0e 94 b5 1b 	call	0x376a	; 0x376a <_uart_printf>
	     stPoolingPump=ppInit;
    1c88:	10 92 2c 01 	sts	0x012C, r1
	 }
	 switch(stPoolingPump){
    1c8c:	80 91 2c 01 	lds	r24, 0x012C
    1c90:	e8 2f       	mov	r30, r24
    1c92:	f0 e0       	ldi	r31, 0x00	; 0
    1c94:	e1 32       	cpi	r30, 0x21	; 33
    1c96:	f1 05       	cpc	r31, r1
    1c98:	08 f0       	brcs	.+2      	; 0x1c9c <FPoolingPump+0xb0>
    1c9a:	ff c2       	rjmp	.+1534   	; 0x229a <FPoolingPump+0x6ae>
    1c9c:	e8 5c       	subi	r30, 0xC8	; 200
    1c9e:	ff 4f       	sbci	r31, 0xFF	; 255
    1ca0:	ee 0f       	add	r30, r30
    1ca2:	ff 1f       	adc	r31, r31
    1ca4:	05 90       	lpm	r0, Z+
    1ca6:	f4 91       	lpm	r31, Z+
    1ca8:	e0 2d       	mov	r30, r0
    1caa:	09 94       	ijmp
	 case ppInit:
	      //StatePrintf(PSTR("1"));
	      //txPumpID=1;
		  iPoolingID=0;
    1cac:	10 92 16 01 	sts	0x0116, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1cb0:	e1 99       	sbic	0x1c, 1	; 28
    1cb2:	fe cf       	rjmp	.-4      	; 0x1cb0 <FPoolingPump+0xc4>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1cb4:	8d e0       	ldi	r24, 0x0D	; 13
    1cb6:	90 e0       	ldi	r25, 0x00	; 0
    1cb8:	9f bb       	out	0x1f, r25	; 31
    1cba:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1cbc:	e0 9a       	sbi	0x1c, 0	; 28
    1cbe:	8d b3       	in	r24, 0x1d	; 29
		  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    1cc0:	80 93 17 01 	sts	0x0117, r24

		  iSend=0;
    1cc4:	10 92 f9 03 	sts	0x03F9, r1
		  TimSend=0;          
    1cc8:	10 92 24 04 	sts	0x0424, r1
    1ccc:	10 92 23 04 	sts	0x0423, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1cd0:	e1 99       	sbic	0x1c, 1	; 28
    1cd2:	fe cf       	rjmp	.-4      	; 0x1cd0 <FPoolingPump+0xe4>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1cd4:	88 e0       	ldi	r24, 0x08	; 8
    1cd6:	90 e0       	ldi	r25, 0x00	; 0
    1cd8:	9f bb       	out	0x1f, r25	; 31
    1cda:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1cdc:	e0 9a       	sbi	0x1c, 0	; 28
    1cde:	8d b3       	in	r24, 0x1d	; 29
		  nNoPump=eeprom_read_byte(&DefNoPumpCountMax);
    1ce0:	80 93 35 04 	sts	0x0435, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1ce4:	e1 99       	sbic	0x1c, 1	; 28
    1ce6:	fe cf       	rjmp	.-4      	; 0x1ce4 <FPoolingPump+0xf8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1ce8:	87 e0       	ldi	r24, 0x07	; 7
    1cea:	90 e0       	ldi	r25, 0x00	; 0
    1cec:	9f bb       	out	0x1f, r25	; 31
    1cee:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1cf0:	e0 9a       	sbi	0x1c, 0	; 28
    1cf2:	8d b3       	in	r24, 0x1d	; 29
		  ScanPumpMax=eeprom_read_byte(&DefMaxPumpPooling);
    1cf4:	80 93 61 02 	sts	0x0261, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1cf8:	e1 99       	sbic	0x1c, 1	; 28
    1cfa:	fe cf       	rjmp	.-4      	; 0x1cf8 <FPoolingPump+0x10c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1cfc:	89 e0       	ldi	r24, 0x09	; 9
    1cfe:	90 e0       	ldi	r25, 0x00	; 0
    1d00:	9f bb       	out	0x1f, r25	; 31
    1d02:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1d04:	e0 9a       	sbi	0x1c, 0	; 28
    1d06:	8d b3       	in	r24, 0x1d	; 29
		  nSend=eeprom_read_byte(&DefSendCount);
    1d08:	80 93 77 02 	sts	0x0277, r24
		  if (IsStopPoolSequence!=True)
    1d0c:	80 91 13 01 	lds	r24, 0x0113
    1d10:	81 30       	cpi	r24, 0x01	; 1
    1d12:	29 f0       	breq	.+10     	; 0x1d1e <FPoolingPump+0x132>
              SendCommandAcknoledge(SC_LIVE_SEQUENCE,SequencePool);
    1d14:	89 e1       	ldi	r24, 0x19	; 25
    1d16:	60 91 26 01 	lds	r22, 0x0126
    1d1a:	0e 94 65 07 	call	0xeca	; 0xeca <SendCommandAcknoledge>
          SequencePool++;
    1d1e:	80 91 26 01 	lds	r24, 0x0126
    1d22:	8f 5f       	subi	r24, 0xFF	; 255
    1d24:	80 93 26 01 	sts	0x0126, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1d28:	e1 99       	sbic	0x1c, 1	; 28
    1d2a:	fe cf       	rjmp	.-4      	; 0x1d28 <FPoolingPump+0x13c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1d2c:	8a e0       	ldi	r24, 0x0A	; 10
    1d2e:	90 e0       	ldi	r25, 0x00	; 0
    1d30:	9f bb       	out	0x1f, r25	; 31
    1d32:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1d34:	e0 9a       	sbi	0x1c, 0	; 28
    1d36:	8d b3       	in	r24, 0x1d	; 29
		  TPoolTimeout=eeprom_read_byte(&DefPoolTimeout);
    1d38:	80 93 b6 02 	sts	0x02B6, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1d3c:	e1 99       	sbic	0x1c, 1	; 28
    1d3e:	fe cf       	rjmp	.-4      	; 0x1d3c <FPoolingPump+0x150>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1d40:	8b e0       	ldi	r24, 0x0B	; 11
    1d42:	90 e0       	ldi	r25, 0x00	; 0
    1d44:	9f bb       	out	0x1f, r25	; 31
    1d46:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1d48:	e0 9a       	sbi	0x1c, 0	; 28
    1d4a:	8d b3       	in	r24, 0x1d	; 29
		  TDelayNextPump=eeprom_read_byte(&DefDelayNextPump);		  
    1d4c:	80 93 3c 01 	sts	0x013C, r24
    1d50:	1e c0       	rjmp	.+60     	; 0x1d8e <FPoolingPump+0x1a2>
		  stPoolingPump=ppGetStatus;
	      break;
     case ppNextPump:
          iPoolingID++;
    1d52:	90 91 16 01 	lds	r25, 0x0116
    1d56:	9f 5f       	subi	r25, 0xFF	; 255
    1d58:	90 93 16 01 	sts	0x0116, r25
	      if (iPoolingID<ScanPumpMax){
    1d5c:	80 91 61 02 	lds	r24, 0x0261
    1d60:	98 17       	cp	r25, r24
    1d62:	b8 f4       	brcc	.+46     	; 0x1d92 <FPoolingPump+0x1a6>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1d64:	e1 99       	sbic	0x1c, 1	; 28
    1d66:	fe cf       	rjmp	.-4      	; 0x1d64 <FPoolingPump+0x178>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1d68:	89 2f       	mov	r24, r25
    1d6a:	90 e0       	ldi	r25, 0x00	; 0
    1d6c:	83 5f       	subi	r24, 0xF3	; 243
    1d6e:	9f 4f       	sbci	r25, 0xFF	; 255
    1d70:	9f bb       	out	0x1f, r25	; 31
    1d72:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1d74:	e0 9a       	sbi	0x1c, 0	; 28
    1d76:	8d b3       	in	r24, 0x1d	; 29
			  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    1d78:	80 93 17 01 	sts	0x0117, r24
			  if (txPumpID>0){			      
    1d7c:	88 23       	and	r24, r24
    1d7e:	09 f4       	brne	.+2      	; 0x1d82 <FPoolingPump+0x196>
    1d80:	34 c2       	rjmp	.+1128   	; 0x21ea <FPoolingPump+0x5fe>
			      iSend=0;TimSend=0;
    1d82:	10 92 f9 03 	sts	0x03F9, r1
    1d86:	10 92 24 04 	sts	0x0424, r1
    1d8a:	10 92 23 04 	sts	0x0423, r1
			      stPoolingPump=ppGetStatus;
    1d8e:	82 e0       	ldi	r24, 0x02	; 2
    1d90:	82 c2       	rjmp	.+1284   	; 0x2296 <FPoolingPump+0x6aa>
			   }else stPoolingPump=ppNextPump;
		  }else stPoolingPump=ppInit;
    1d92:	10 92 2c 01 	sts	0x012C, r1
    1d96:	81 c2       	rjmp	.+1282   	; 0x229a <FPoolingPump+0x6ae>
	      break;
     case ppGetStatus:

          #ifdef DEBUG_PUMPID
           sprintf_P(strSend,PSTR("TxPumpID:%d"),txPumpID);
    1d98:	00 d0       	rcall	.+0      	; 0x1d9a <FPoolingPump+0x1ae>
    1d9a:	00 d0       	rcall	.+0      	; 0x1d9c <FPoolingPump+0x1b0>
    1d9c:	00 d0       	rcall	.+0      	; 0x1d9e <FPoolingPump+0x1b2>
    1d9e:	ed b7       	in	r30, 0x3d	; 61
    1da0:	fe b7       	in	r31, 0x3e	; 62
    1da2:	31 96       	adiw	r30, 0x01	; 1
    1da4:	8e 01       	movw	r16, r28
    1da6:	0f 5f       	subi	r16, 0xFF	; 255
    1da8:	1f 4f       	sbci	r17, 0xFF	; 255
    1daa:	ad b7       	in	r26, 0x3d	; 61
    1dac:	be b7       	in	r27, 0x3e	; 62
    1dae:	12 96       	adiw	r26, 0x02	; 2
    1db0:	1c 93       	st	X, r17
    1db2:	0e 93       	st	-X, r16
    1db4:	11 97       	sbiw	r26, 0x01	; 1
    1db6:	8d e5       	ldi	r24, 0x5D	; 93
    1db8:	91 e0       	ldi	r25, 0x01	; 1
    1dba:	93 83       	std	Z+3, r25	; 0x03
    1dbc:	82 83       	std	Z+2, r24	; 0x02
    1dbe:	80 91 17 01 	lds	r24, 0x0117
    1dc2:	84 83       	std	Z+4, r24	; 0x04
    1dc4:	15 82       	std	Z+5, r1	; 0x05
    1dc6:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
	 	   _uart_print(1,1,strSend);
    1dca:	8d b7       	in	r24, 0x3d	; 61
    1dcc:	9e b7       	in	r25, 0x3e	; 62
    1dce:	06 96       	adiw	r24, 0x06	; 6
    1dd0:	0f b6       	in	r0, 0x3f	; 63
    1dd2:	f8 94       	cli
    1dd4:	9e bf       	out	0x3e, r25	; 62
    1dd6:	0f be       	out	0x3f, r0	; 63
    1dd8:	8d bf       	out	0x3d, r24	; 61
    1dda:	81 e0       	ldi	r24, 0x01	; 1
    1ddc:	61 e0       	ldi	r22, 0x01	; 1
    1dde:	a8 01       	movw	r20, r16
    1de0:	0e 94 8d 1b 	call	0x371a	; 0x371a <_uart_print>
		  #endif

          //StatePrintf(PSTR("3"));
	      IsStatusReceived=False;
    1de4:	10 92 0f 01 	sts	0x010F, r1
		  IsNoPump=False;
    1de8:	10 92 06 01 	sts	0x0106, r1
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    1dec:	81 e0       	ldi	r24, 0x01	; 1
    1dee:	80 93 04 01 	sts	0x0104, r24
		  IsNoPump=False;
		  SetReceiveLine(rcIdle);
		  stPoolingPump=ppWaitIdle;
     case ppWaitIdle:
          //StatePrintf(PSTR("4"));
	      if (GetReceiveLine()==rcIdle)
    1df2:	80 91 04 01 	lds	r24, 0x0104
    1df6:	81 30       	cpi	r24, 0x01	; 1
    1df8:	51 f6       	brne	.-108    	; 0x1d8e <FPoolingPump+0x1a2>
		      stPoolingPump=ppSendStatusRequest;
    1dfa:	84 e0       	ldi	r24, 0x04	; 4
    1dfc:	4c c2       	rjmp	.+1176   	; 0x2296 <FPoolingPump+0x6aa>
          else stPoolingPump=ppGetStatus;
	      break;
     case ppSendStatusRequest:
          //StatePrintf(PSTR("5"));
	      PumpCommand(txPumpID,CMD_STATUS);
    1dfe:	80 91 17 01 	lds	r24, 0x0117
    1e02:	60 e0       	ldi	r22, 0x00	; 0
    1e04:	0e 94 ee 07 	call	0xfdc	; 0xfdc <PumpCommand>
		  TimSend=0;
    1e08:	10 92 24 04 	sts	0x0424, r1
    1e0c:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=ppWaitReplyStatus;
    1e10:	86 e0       	ldi	r24, 0x06	; 6
    1e12:	41 c2       	rjmp	.+1154   	; 0x2296 <FPoolingPump+0x6aa>
	      break;
     case ppNoPump:
          NoPumpCount[txPumpID&0x0F]++;
    1e14:	80 91 17 01 	lds	r24, 0x0117
    1e18:	e8 2f       	mov	r30, r24
    1e1a:	f0 e0       	ldi	r31, 0x00	; 0
    1e1c:	ef 70       	andi	r30, 0x0F	; 15
    1e1e:	f0 70       	andi	r31, 0x00	; 0
    1e20:	eb 5d       	subi	r30, 0xDB	; 219
    1e22:	fb 4f       	sbci	r31, 0xFB	; 251
    1e24:	80 81       	ld	r24, Z
    1e26:	8f 5f       	subi	r24, 0xFF	; 255
    1e28:	80 83       	st	Z, r24
		  if (NoPumpCount[txPumpID&0x0F]>nNoPump){
    1e2a:	90 91 35 04 	lds	r25, 0x0435
    1e2e:	98 17       	cp	r25, r24
    1e30:	08 f0       	brcs	.+2      	; 0x1e34 <FPoolingPump+0x248>
    1e32:	cf c0       	rjmp	.+414    	; 0x1fd2 <FPoolingPump+0x3e6>
		      NoPumpCount[txPumpID&0x0F]=0;
    1e34:	10 82       	st	Z, r1
	          IsNoPump=True;
    1e36:	81 e0       	ldi	r24, 0x01	; 1
    1e38:	80 93 06 01 	sts	0x0106, r24
    1e3c:	0c c1       	rjmp	.+536    	; 0x2056 <FPoolingPump+0x46a>
			  }
          else stPoolingPump=ppInitDelayNextPump;
	      break;
     case ppWaitReplyStatus:	      
          //StatePrintf(PSTR("7"));
          if (TimSend>TPoolTimeout){//TPoolTimeout
    1e3e:	80 91 b6 02 	lds	r24, 0x02B6
    1e42:	90 e0       	ldi	r25, 0x00	; 0
    1e44:	20 91 23 04 	lds	r18, 0x0423
    1e48:	30 91 24 04 	lds	r19, 0x0424
    1e4c:	82 17       	cp	r24, r18
    1e4e:	93 07       	cpc	r25, r19
    1e50:	80 f4       	brcc	.+32     	; 0x1e72 <FPoolingPump+0x286>
		      iSend++;
    1e52:	80 91 f9 03 	lds	r24, 0x03F9
    1e56:	8f 5f       	subi	r24, 0xFF	; 255
    1e58:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppGetStatus;
    1e5c:	90 91 77 02 	lds	r25, 0x0277
    1e60:	89 17       	cp	r24, r25
    1e62:	10 f4       	brcc	.+4      	; 0x1e68 <FPoolingPump+0x27c>
    1e64:	82 e0       	ldi	r24, 0x02	; 2
    1e66:	03 c0       	rjmp	.+6      	; 0x1e6e <FPoolingPump+0x282>
			  else
		      if (iSend>nSend)stPoolingPump=ppNoPump;//Pump Not Available
    1e68:	98 17       	cp	r25, r24
    1e6a:	18 f4       	brcc	.+6      	; 0x1e72 <FPoolingPump+0x286>
    1e6c:	85 e0       	ldi	r24, 0x05	; 5
    1e6e:	80 93 2c 01 	sts	0x012C, r24
		  }
          if (IsStatusReceived==True){
    1e72:	80 91 0f 01 	lds	r24, 0x010F
    1e76:	81 30       	cpi	r24, 0x01	; 1
    1e78:	09 f0       	breq	.+2      	; 0x1e7c <FPoolingPump+0x290>
    1e7a:	0f c2       	rjmp	.+1054   	; 0x229a <FPoolingPump+0x6ae>
		      if ((txPumpID&0x0F)==PumpID){
    1e7c:	40 91 0e 01 	lds	r20, 0x010E
    1e80:	80 91 17 01 	lds	r24, 0x0117
    1e84:	90 e0       	ldi	r25, 0x00	; 0
    1e86:	8f 70       	andi	r24, 0x0F	; 15
    1e88:	90 70       	andi	r25, 0x00	; 0
    1e8a:	24 2f       	mov	r18, r20
    1e8c:	30 e0       	ldi	r19, 0x00	; 0
    1e8e:	82 17       	cp	r24, r18
    1e90:	93 07       	cpc	r25, r19
    1e92:	11 f4       	brne	.+4      	; 0x1e98 <FPoolingPump+0x2ac>
			      stPoolingPump=ppUpdatePumpStatus;
    1e94:	87 e0       	ldi	r24, 0x07	; 7
    1e96:	01 c0       	rjmp	.+2      	; 0x1e9a <FPoolingPump+0x2ae>
			  }else stPoolingPump=ppDifferentPumpID;
    1e98:	89 e0       	ldi	r24, 0x09	; 9
    1e9a:	80 93 2c 01 	sts	0x012C, r24

			  if ((CMDResponse==0x0F)&&(PumpID==0x0F)&&(iSend<nSend)){
    1e9e:	80 91 8d 01 	lds	r24, 0x018D
    1ea2:	8f 30       	cpi	r24, 0x0F	; 15
    1ea4:	09 f0       	breq	.+2      	; 0x1ea8 <FPoolingPump+0x2bc>
    1ea6:	f9 c1       	rjmp	.+1010   	; 0x229a <FPoolingPump+0x6ae>
    1ea8:	4f 30       	cpi	r20, 0x0F	; 15
    1eaa:	09 f0       	breq	.+2      	; 0x1eae <FPoolingPump+0x2c2>
    1eac:	f6 c1       	rjmp	.+1004   	; 0x229a <FPoolingPump+0x6ae>
    1eae:	90 91 f9 03 	lds	r25, 0x03F9
    1eb2:	80 91 77 02 	lds	r24, 0x0277
    1eb6:	98 17       	cp	r25, r24
    1eb8:	08 f0       	brcs	.+2      	; 0x1ebc <FPoolingPump+0x2d0>
    1eba:	ef c1       	rjmp	.+990    	; 0x229a <FPoolingPump+0x6ae>
    1ebc:	68 cf       	rjmp	.-304    	; 0x1d8e <FPoolingPump+0x1a2>
          stPoolingPump=ppNoPump;
	      break;
		                     //PumpStatus[1..0]= FEDCBA98 76543210
     case ppUpdatePumpStatus://                = 
          //StatePrintf(PSTR("9"));
	      PumpAddr=(txPumpID&0x0F);
    1ebe:	90 91 17 01 	lds	r25, 0x0117
    1ec2:	9f 70       	andi	r25, 0x0F	; 15
    1ec4:	90 93 05 01 	sts	0x0105, r25
		  if (IsNoPump==False)PumpStatus[PumpAddr]=CMDResponse;
    1ec8:	80 91 06 01 	lds	r24, 0x0106
    1ecc:	88 23       	and	r24, r24
    1ece:	39 f4       	brne	.+14     	; 0x1ede <FPoolingPump+0x2f2>
    1ed0:	e9 2f       	mov	r30, r25
    1ed2:	f0 e0       	ldi	r31, 0x00	; 0
    1ed4:	eb 54       	subi	r30, 0x4B	; 75
    1ed6:	fc 4f       	sbci	r31, 0xFC	; 252
    1ed8:	80 91 8d 01 	lds	r24, 0x018D
    1edc:	07 c0       	rjmp	.+14     	; 0x1eec <FPoolingPump+0x300>
		  else 
		  if (IsNoPump==True)PumpStatus[PumpAddr]=PUMP_NONE;
    1ede:	81 30       	cpi	r24, 0x01	; 1
    1ee0:	31 f4       	brne	.+12     	; 0x1eee <FPoolingPump+0x302>
    1ee2:	e9 2f       	mov	r30, r25
    1ee4:	f0 e0       	ldi	r31, 0x00	; 0
    1ee6:	eb 54       	subi	r30, 0x4B	; 75
    1ee8:	fc 4f       	sbci	r31, 0xFC	; 252
    1eea:	8e e0       	ldi	r24, 0x0E	; 14
    1eec:	80 83       	st	Z, r24
          
		  //SendIfUpdated
		  if (PumpStatus[PumpAddr]!=zPumpStatus[PumpAddr]){
    1eee:	89 2f       	mov	r24, r25
    1ef0:	90 e0       	ldi	r25, 0x00	; 0
    1ef2:	fc 01       	movw	r30, r24
    1ef4:	eb 54       	subi	r30, 0x4B	; 75
    1ef6:	fc 4f       	sbci	r31, 0xFC	; 252
    1ef8:	20 81       	ld	r18, Z
    1efa:	fc 01       	movw	r30, r24
    1efc:	e5 56       	subi	r30, 0x65	; 101
    1efe:	fd 4f       	sbci	r31, 0xFD	; 253
    1f00:	80 81       	ld	r24, Z
    1f02:	28 17       	cp	r18, r24
    1f04:	79 f0       	breq	.+30     	; 0x1f24 <FPoolingPump+0x338>
		      zPumpStatus[PumpAddr]=PumpStatus[PumpAddr];
    1f06:	20 83       	st	Z, r18
		      stPoolingPump=ppSendPumpStatus;
    1f08:	87 e1       	ldi	r24, 0x17	; 23
    1f0a:	c5 c1       	rjmp	.+906    	; 0x2296 <FPoolingPump+0x6aa>
		  }else stPoolingPump=ppScanResponse;
          break;
     case ppSendPumpStatus://UpdatePumpStatusToMaster;
          //StatePrintf(PSTR("10"));
	      PumpAddr=(txPumpID&0x0F);
    1f0c:	80 91 17 01 	lds	r24, 0x0117
    1f10:	e8 2f       	mov	r30, r24
    1f12:	ef 70       	andi	r30, 0x0F	; 15
    1f14:	e0 93 05 01 	sts	0x0105, r30
	      SendPumpStatusFlow(txPumpID,PumpStatus[PumpAddr]);
    1f18:	f0 e0       	ldi	r31, 0x00	; 0
    1f1a:	eb 54       	subi	r30, 0x4B	; 75
    1f1c:	fc 4f       	sbci	r31, 0xFC	; 252
    1f1e:	60 81       	ld	r22, Z
    1f20:	0e 94 4d 07 	call	0xe9a	; 0xe9a <SendPumpStatusFlow>
	      stPoolingPump=ppScanResponse;
    1f24:	88 e1       	ldi	r24, 0x18	; 24
    1f26:	b7 c1       	rjmp	.+878    	; 0x2296 <FPoolingPump+0x6aa>
	      break;
     case ppScanResponse:
          //StatePrintf(PSTR("11"));
		  PumpAddr=(txPumpID&0x0F);
    1f28:	80 91 17 01 	lds	r24, 0x0117
    1f2c:	8f 70       	andi	r24, 0x0F	; 15
    1f2e:	80 93 05 01 	sts	0x0105, r24
		  switch(CMDResponse){
    1f32:	90 91 8d 01 	lds	r25, 0x018D
    1f36:	98 30       	cpi	r25, 0x08	; 8
    1f38:	09 f4       	brne	.+2      	; 0x1f3c <FPoolingPump+0x350>
    1f3a:	41 c0       	rjmp	.+130    	; 0x1fbe <FPoolingPump+0x3d2>
    1f3c:	99 30       	cpi	r25, 0x09	; 9
    1f3e:	28 f4       	brcc	.+10     	; 0x1f4a <FPoolingPump+0x35e>
    1f40:	96 30       	cpi	r25, 0x06	; 6
    1f42:	41 f0       	breq	.+16     	; 0x1f54 <FPoolingPump+0x368>
    1f44:	97 30       	cpi	r25, 0x07	; 7
    1f46:	d9 f5       	brne	.+118    	; 0x1fbe <FPoolingPump+0x3d2>
    1f48:	16 c0       	rjmp	.+44     	; 0x1f76 <FPoolingPump+0x38a>
    1f4a:	99 30       	cpi	r25, 0x09	; 9
    1f4c:	79 f1       	breq	.+94     	; 0x1fac <FPoolingPump+0x3c0>
    1f4e:	9b 30       	cpi	r25, 0x0B	; 11
    1f50:	b1 f5       	brne	.+108    	; 0x1fbe <FPoolingPump+0x3d2>
    1f52:	23 c0       	rjmp	.+70     	; 0x1f9a <FPoolingPump+0x3ae>
		  case PUMP_OFF:               
		       if (IsRequestTransInfo[PumpAddr]==True)
    1f54:	a8 2f       	mov	r26, r24
    1f56:	b0 e0       	ldi	r27, 0x00	; 0
    1f58:	fd 01       	movw	r30, r26
    1f5a:	e6 57       	subi	r30, 0x76	; 118
    1f5c:	fd 4f       	sbci	r31, 0xFD	; 253
    1f5e:	80 81       	ld	r24, Z
    1f60:	81 30       	cpi	r24, 0x01	; 1
    1f62:	11 f1       	breq	.+68     	; 0x1fa8 <FPoolingPump+0x3bc>
			       stPoolingPump=ppRequestTransData;
               else 
		       if (IsRequestTotalizerInfo[PumpAddr]==True){
    1f64:	ad 5e       	subi	r26, 0xED	; 237
    1f66:	bb 4f       	sbci	r27, 0xFB	; 251
    1f68:	8c 91       	ld	r24, X
    1f6a:	81 30       	cpi	r24, 0x01	; 1
    1f6c:	11 f4       	brne	.+4      	; 0x1f72 <FPoolingPump+0x386>
			        stPoolingPump=ppRequestTotalizerData;
    1f6e:	8b e1       	ldi	r24, 0x1B	; 27
    1f70:	27 c0       	rjmp	.+78     	; 0x1fc0 <FPoolingPump+0x3d4>
				}	
               else stPoolingPump=ppNextPump;
    1f72:	81 e0       	ldi	r24, 0x01	; 1
    1f74:	25 c0       	rjmp	.+74     	; 0x1fc0 <FPoolingPump+0x3d4>
		       break;
          case PUMP_CALL:
 			   if (PumpLock[PumpAddr]==False){
    1f76:	28 2f       	mov	r18, r24
    1f78:	30 e0       	ldi	r19, 0x00	; 0
    1f7a:	f9 01       	movw	r30, r18
    1f7c:	e4 53       	subi	r30, 0x34	; 52
    1f7e:	fd 4f       	sbci	r31, 0xFD	; 253
    1f80:	80 81       	ld	r24, Z
    1f82:	88 23       	and	r24, r24
    1f84:	f9 f4       	brne	.+62     	; 0x1fc4 <FPoolingPump+0x3d8>
			   	   if (IsRequestTransInfo[PumpAddr]==False) 
    1f86:	f9 01       	movw	r30, r18
    1f88:	e6 57       	subi	r30, 0x76	; 118
    1f8a:	fd 4f       	sbci	r31, 0xFD	; 253
    1f8c:	80 81       	ld	r24, Z
    1f8e:	88 23       	and	r24, r24
    1f90:	11 f4       	brne	.+4      	; 0x1f96 <FPoolingPump+0x3aa>
				       IsRequestTransInfo[PumpAddr]=True;
    1f92:	81 e0       	ldi	r24, 0x01	; 1
    1f94:	80 83       	st	Z, r24
			       stPoolingPump=ppReplyAuth;               
    1f96:	88 e0       	ldi	r24, 0x08	; 8
    1f98:	13 c0       	rjmp	.+38     	; 0x1fc0 <FPoolingPump+0x3d4>
			   } 
		       break;
		  case PUMP_FEOT:
		       if (IsRequestTransInfo[PumpAddr]==True)
    1f9a:	e8 2f       	mov	r30, r24
    1f9c:	f0 e0       	ldi	r31, 0x00	; 0
    1f9e:	e6 57       	subi	r30, 0x76	; 118
    1fa0:	fd 4f       	sbci	r31, 0xFD	; 253
    1fa2:	80 81       	ld	r24, Z
    1fa4:	81 30       	cpi	r24, 0x01	; 1
    1fa6:	59 f4       	brne	.+22     	; 0x1fbe <FPoolingPump+0x3d2>
			       stPoolingPump=ppRequestTransData;
    1fa8:	8a e0       	ldi	r24, 0x0A	; 10
    1faa:	0a c0       	rjmp	.+20     	; 0x1fc0 <FPoolingPump+0x3d4>
               else stPoolingPump=ppInitDelayNextPump;
		       break;
		  case PUMP_BUSY:
               if (IsRequestTransInfo[PumpAddr]==False)
    1fac:	e8 2f       	mov	r30, r24
    1fae:	f0 e0       	ldi	r31, 0x00	; 0
    1fb0:	e6 57       	subi	r30, 0x76	; 118
    1fb2:	fd 4f       	sbci	r31, 0xFD	; 253
    1fb4:	80 81       	ld	r24, Z
    1fb6:	88 23       	and	r24, r24
    1fb8:	11 f4       	brne	.+4      	; 0x1fbe <FPoolingPump+0x3d2>
			       IsRequestTransInfo[PumpAddr]=True;
    1fba:	81 e0       	ldi	r24, 0x01	; 1
    1fbc:	80 83       	st	Z, r24
		       break;
		  case PUMP_AUTH:
               stPoolingPump=ppInitDelayNextPump;
		       break;		  
          default:
               stPoolingPump=ppInitDelayNextPump;
    1fbe:	84 e1       	ldi	r24, 0x14	; 20
    1fc0:	80 93 2c 01 	sts	0x012C, r24
		       break;
		  }
		  //Existing Pump
		  if (IsNoPump==True){
    1fc4:	80 91 06 01 	lds	r24, 0x0106
    1fc8:	81 30       	cpi	r24, 0x01	; 1
    1fca:	09 f0       	breq	.+2      	; 0x1fce <FPoolingPump+0x3e2>
    1fcc:	66 c1       	rjmp	.+716    	; 0x229a <FPoolingPump+0x6ae>
		      IsNoPump=False;
    1fce:	10 92 06 01 	sts	0x0106, r1
			  stPoolingPump=ppInitDelayNextPump;
    1fd2:	84 e1       	ldi	r24, 0x14	; 20
    1fd4:	60 c1       	rjmp	.+704    	; 0x2296 <FPoolingPump+0x6aa>
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    1fd6:	81 e0       	ldi	r24, 0x01	; 1
    1fd8:	80 93 04 01 	sts	0x0104, r24
	      break;
     case ppReplyAuth:
          //StatePrintf(PSTR("11"));
	      SetReceiveLine(rcIdle);
	      if (GetReceiveLine()==rcIdle){
			  iSend=0;
    1fdc:	10 92 f9 03 	sts	0x03F9, r1
		      stPoolingPump=ppSendAuthorize;
    1fe0:	8c e0       	ldi	r24, 0x0C	; 12
    1fe2:	59 c1       	rjmp	.+690    	; 0x2296 <FPoolingPump+0x6aa>
			  }
		  else stPoolingPump=ppReplyAuth;
	      break;
     case ppSendAuthorize:
          //StatePrintf(PSTR("12"));
	      TimSend=0;
    1fe4:	10 92 24 04 	sts	0x0424, r1
    1fe8:	10 92 23 04 	sts	0x0423, r1
		  IsStatusReceived=False;
    1fec:	10 92 0f 01 	sts	0x010F, r1
	      PumpCommand(txPumpID,CMD_AUTHORIZE);
    1ff0:	80 91 17 01 	lds	r24, 0x0117
    1ff4:	61 e0       	ldi	r22, 0x01	; 1
    1ff6:	0e 94 ee 07 	call	0xfdc	; 0xfdc <PumpCommand>
		  stPoolingPump=ppWaitAuthorized;
    1ffa:	8d e0       	ldi	r24, 0x0D	; 13
    1ffc:	4c c1       	rjmp	.+664    	; 0x2296 <FPoolingPump+0x6aa>
	      break;
     case ppWaitAuthorized:
          //StatePrintf(PSTR("13"));
	      if (TimSend>TPoolTimeout){
    1ffe:	80 91 b6 02 	lds	r24, 0x02B6
    2002:	90 e0       	ldi	r25, 0x00	; 0
    2004:	20 91 23 04 	lds	r18, 0x0423
    2008:	30 91 24 04 	lds	r19, 0x0424
    200c:	82 17       	cp	r24, r18
    200e:	93 07       	cpc	r25, r19
    2010:	80 f4       	brcc	.+32     	; 0x2032 <FPoolingPump+0x446>
		  	  iSend++;
    2012:	80 91 f9 03 	lds	r24, 0x03F9
    2016:	8f 5f       	subi	r24, 0xFF	; 255
    2018:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppSendAuthorize;
    201c:	90 91 77 02 	lds	r25, 0x0277
    2020:	89 17       	cp	r24, r25
    2022:	10 f4       	brcc	.+4      	; 0x2028 <FPoolingPump+0x43c>
    2024:	8c e0       	ldi	r24, 0x0C	; 12
    2026:	03 c0       	rjmp	.+6      	; 0x202e <FPoolingPump+0x442>
			  else
		      if (iSend>nSend)stPoolingPump=ppNoPump;//Pump Not Available
    2028:	98 17       	cp	r25, r24
    202a:	18 f4       	brcc	.+6      	; 0x2032 <FPoolingPump+0x446>
    202c:	85 e0       	ldi	r24, 0x05	; 5
    202e:	80 93 2c 01 	sts	0x012C, r24
		  }
	      if (IsStatusReceived==True){
    2032:	80 91 0f 01 	lds	r24, 0x010F
    2036:	81 30       	cpi	r24, 0x01	; 1
    2038:	09 f0       	breq	.+2      	; 0x203c <FPoolingPump+0x450>
    203a:	2f c1       	rjmp	.+606    	; 0x229a <FPoolingPump+0x6ae>
		      IsStatusReceived=False;
    203c:	10 92 0f 01 	sts	0x010F, r1
			  //Authorized
		      if ((txPumpID&0x0F)==PumpID)stPoolingPump=ppUpdatePumpStatus;
    2040:	20 91 17 01 	lds	r18, 0x0117
    2044:	30 e0       	ldi	r19, 0x00	; 0
    2046:	2f 70       	andi	r18, 0x0F	; 15
    2048:	30 70       	andi	r19, 0x00	; 0
    204a:	80 91 0e 01 	lds	r24, 0x010E
    204e:	90 e0       	ldi	r25, 0x00	; 0
    2050:	28 17       	cp	r18, r24
    2052:	39 07       	cpc	r19, r25
    2054:	11 f4       	brne	.+4      	; 0x205a <FPoolingPump+0x46e>
    2056:	87 e0       	ldi	r24, 0x07	; 7
    2058:	1e c1       	rjmp	.+572    	; 0x2296 <FPoolingPump+0x6aa>
			  else stPoolingPump=ppDifferentPumpID;
    205a:	89 e0       	ldi	r24, 0x09	; 9
    205c:	1c c1       	rjmp	.+568    	; 0x2296 <FPoolingPump+0x6aa>
		  }
	      break;
     case ppRequestRealTimeMoney:
          //StatePrintf(PSTR("14"));
		  Com0ReceiveCount=0;
    205e:	10 92 23 01 	sts	0x0123, r1
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    2062:	82 e0       	ldi	r24, 0x02	; 2
    2064:	80 93 04 01 	sts	0x0104, r24
     case ppRequestRealTimeMoney:
          //StatePrintf(PSTR("14"));
		  Com0ReceiveCount=0;
	      SetReceiveLine(rcRealTimeMoney);
	      if (GetReceiveLine()==rcRealTimeMoney){
			  iSend=0;
    2068:	10 92 f9 03 	sts	0x03F9, r1
    206c:	25 c0       	rjmp	.+74     	; 0x20b8 <FPoolingPump+0x4cc>
			  }
		  else stPoolingPump=ppRequestRealTimeMoney;
	      break;
     case ppSendMoneyReq:
          //StatePrintf(PSTR("15"));
	 	  TimSend=0;
    206e:	10 92 24 04 	sts	0x0424, r1
    2072:	10 92 23 04 	sts	0x0423, r1
	      IsMoneyReceived=False;
    2076:	10 92 10 01 	sts	0x0110, r1
	      PumpCommand(txPumpID,CMD_REALTIME_MONEY);
    207a:	80 91 17 01 	lds	r24, 0x0117
    207e:	66 e0       	ldi	r22, 0x06	; 6
    2080:	0e 94 ee 07 	call	0xfdc	; 0xfdc <PumpCommand>
		  stPoolingPump=ppWaitMoneyReq;
    2084:	8f e0       	ldi	r24, 0x0F	; 15
    2086:	07 c1       	rjmp	.+526    	; 0x2296 <FPoolingPump+0x6aa>
	      break;
     case ppWaitMoneyReq:
          //StatePrintf(PSTR("16"));
	      if (IsMoneyReceived==False){
    2088:	80 91 10 01 	lds	r24, 0x0110
    208c:	88 23       	and	r24, r24
    208e:	d9 f4       	brne	.+54     	; 0x20c6 <FPoolingPump+0x4da>
		  	  if (TimSend>TPoolTimeout){
    2090:	80 91 b6 02 	lds	r24, 0x02B6
    2094:	90 e0       	ldi	r25, 0x00	; 0
    2096:	20 91 23 04 	lds	r18, 0x0423
    209a:	30 91 24 04 	lds	r19, 0x0424
    209e:	82 17       	cp	r24, r18
    20a0:	93 07       	cpc	r25, r19
    20a2:	08 f0       	brcs	.+2      	; 0x20a6 <FPoolingPump+0x4ba>
    20a4:	fa c0       	rjmp	.+500    	; 0x229a <FPoolingPump+0x6ae>
			      iSend++;
    20a6:	80 91 f9 03 	lds	r24, 0x03F9
    20aa:	8f 5f       	subi	r24, 0xFF	; 255
    20ac:	80 93 f9 03 	sts	0x03F9, r24
		          if (iSend<nSend)stPoolingPump=ppSendMoneyReq;
    20b0:	90 91 77 02 	lds	r25, 0x0277
    20b4:	89 17       	cp	r24, r25
    20b6:	10 f4       	brcc	.+4      	; 0x20bc <FPoolingPump+0x4d0>
    20b8:	8e e0       	ldi	r24, 0x0E	; 14
    20ba:	ed c0       	rjmp	.+474    	; 0x2296 <FPoolingPump+0x6aa>
			      else
		          if (iSend>nSend)stPoolingPump=ppNoPump;//Pump Not Available
    20bc:	98 17       	cp	r25, r24
    20be:	08 f0       	brcs	.+2      	; 0x20c2 <FPoolingPump+0x4d6>
    20c0:	ec c0       	rjmp	.+472    	; 0x229a <FPoolingPump+0x6ae>
    20c2:	85 e0       	ldi	r24, 0x05	; 5
    20c4:	e8 c0       	rjmp	.+464    	; 0x2296 <FPoolingPump+0x6aa>
			  }
		  }else
	      if (IsMoneyReceived==True){
    20c6:	81 30       	cpi	r24, 0x01	; 1
    20c8:	09 f0       	breq	.+2      	; 0x20cc <FPoolingPump+0x4e0>
    20ca:	e7 c0       	rjmp	.+462    	; 0x229a <FPoolingPump+0x6ae>
		      IsMoneyReceived=False;
    20cc:	10 92 10 01 	sts	0x0110, r1
			  PumpAddr=(txPumpID&0x0F);
    20d0:	80 91 17 01 	lds	r24, 0x0117
    20d4:	8f 70       	andi	r24, 0x0F	; 15
    20d6:	80 93 05 01 	sts	0x0105, r24
			  //SendCurrentMoney(txPumpID,strCurrentMoney);
			  stPoolingPump=ppMoneyRequestCompleted;
    20da:	80 e1       	ldi	r24, 0x10	; 16
    20dc:	dc c0       	rjmp	.+440    	; 0x2296 <FPoolingPump+0x6aa>
	      TimDelayNextPump=0;
		  stPoolingPump=ppDelayNextPump;
	      break;
     case ppDelayNextPump:
          //StatePrintf(PSTR("18"));
	      if (TimDelayNextPump>=TDelayNextPump)
    20de:	80 91 3c 01 	lds	r24, 0x013C
    20e2:	90 e0       	ldi	r25, 0x00	; 0
    20e4:	20 91 21 01 	lds	r18, 0x0121
    20e8:	30 91 22 01 	lds	r19, 0x0122
    20ec:	28 17       	cp	r18, r24
    20ee:	39 07       	cpc	r19, r25
    20f0:	08 f4       	brcc	.+2      	; 0x20f4 <FPoolingPump+0x508>
    20f2:	d3 c0       	rjmp	.+422    	; 0x229a <FPoolingPump+0x6ae>
    20f4:	7a c0       	rjmp	.+244    	; 0x21ea <FPoolingPump+0x5fe>
		      stPoolingPump=ppNextPump;	      
	      break;
     case ppIsRequestTransInfo:
          PumpAddr=(txPumpID&0x0F);
    20f6:	e0 91 17 01 	lds	r30, 0x0117
    20fa:	ef 70       	andi	r30, 0x0F	; 15
    20fc:	e0 93 05 01 	sts	0x0105, r30
	      if (IsRequestTransInfo[PumpAddr]!=False){
    2100:	f0 e0       	ldi	r31, 0x00	; 0
    2102:	e6 57       	subi	r30, 0x76	; 118
    2104:	fd 4f       	sbci	r31, 0xFD	; 253
    2106:	80 81       	ld	r24, Z
    2108:	88 23       	and	r24, r24
    210a:	11 f0       	breq	.+4      	; 0x2110 <FPoolingPump+0x524>
		      stPoolingPump=ppRequestTransData;		  
    210c:	8a e0       	ldi	r24, 0x0A	; 10
    210e:	c3 c0       	rjmp	.+390    	; 0x2296 <FPoolingPump+0x6aa>
		  }else{
		  stPoolingPump=ppIsRequestTotalizerInfo;
    2110:	8a e1       	ldi	r24, 0x1A	; 26
    2112:	c1 c0       	rjmp	.+386    	; 0x2296 <FPoolingPump+0x6aa>
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    2114:	83 e0       	ldi	r24, 0x03	; 3
    2116:	80 93 04 01 	sts	0x0104, r24
	      break;
     case ppRequestTransData:
          //StatePrintf(PSTR("19"));
	      SetReceiveLine(rcInitTransaction);
	      if (GetReceiveLine()==rcInitTransaction){
			  iSend=0;
    211a:	10 92 f9 03 	sts	0x03F9, r1
    211e:	30 c0       	rjmp	.+96     	; 0x2180 <FPoolingPump+0x594>
			  }
		  else stPoolingPump=ppRequestTransData;
	      break;
     case ppSendTransReq:
          //StatePrintf(PSTR("20"));
	 	  TimSend=0;
    2120:	10 92 24 04 	sts	0x0424, r1
    2124:	10 92 23 04 	sts	0x0423, r1
	      IsTransaction=False;
    2128:	10 92 11 01 	sts	0x0111, r1
	      PumpCommand(txPumpID,CMD_TRANSACTION_DATA);		  
    212c:	80 91 17 01 	lds	r24, 0x0117
    2130:	64 e0       	ldi	r22, 0x04	; 4
    2132:	0e 94 ee 07 	call	0xfdc	; 0xfdc <PumpCommand>
		  stPoolingPump=ppWaitTransReq;
    2136:	82 e1       	ldi	r24, 0x12	; 18
    2138:	ae c0       	rjmp	.+348    	; 0x2296 <FPoolingPump+0x6aa>
	      break;
	 case ppWaitTransReq:
          //StatePrintf(PSTR("21"));
		  if (IsTransaction==True){
    213a:	80 91 11 01 	lds	r24, 0x0111
    213e:	81 30       	cpi	r24, 0x01	; 1
    2140:	41 f4       	brne	.+16     	; 0x2152 <FPoolingPump+0x566>
		      PumpAddr=(txPumpID&0x0F);
    2142:	80 91 17 01 	lds	r24, 0x0117
    2146:	8f 70       	andi	r24, 0x0F	; 15
    2148:	80 93 05 01 	sts	0x0105, r24
		      stPoolingPump=ppTransRequestCompleted;
    214c:	83 e1       	ldi	r24, 0x13	; 19
    214e:	80 93 2c 01 	sts	0x012C, r24
			  }
		  if (TimSend>(TPoolTimeout*2)){
    2152:	80 91 b6 02 	lds	r24, 0x02B6
    2156:	90 e0       	ldi	r25, 0x00	; 0
    2158:	88 0f       	add	r24, r24
    215a:	99 1f       	adc	r25, r25
    215c:	20 91 23 04 	lds	r18, 0x0423
    2160:	30 91 24 04 	lds	r19, 0x0424
    2164:	82 17       	cp	r24, r18
    2166:	93 07       	cpc	r25, r19
    2168:	08 f0       	brcs	.+2      	; 0x216c <FPoolingPump+0x580>
    216a:	97 c0       	rjmp	.+302    	; 0x229a <FPoolingPump+0x6ae>
		  	  iSend++;
    216c:	80 91 f9 03 	lds	r24, 0x03F9
    2170:	8f 5f       	subi	r24, 0xFF	; 255
    2172:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppSendTransReq;
    2176:	90 91 77 02 	lds	r25, 0x0277
    217a:	89 17       	cp	r24, r25
    217c:	08 f0       	brcs	.+2      	; 0x2180 <FPoolingPump+0x594>
    217e:	6b c0       	rjmp	.+214    	; 0x2256 <FPoolingPump+0x66a>
    2180:	81 e1       	ldi	r24, 0x11	; 17
    2182:	89 c0       	rjmp	.+274    	; 0x2296 <FPoolingPump+0x6aa>
		      if (iSend>nSend)stPoolingPump=ppDelayNextPump;	      
		  }
	      break;
	 case ppTransRequestCompleted:
          //StatePrintf(PSTR("21"));
		  stPoolingPump=ppSendTransInfo;
    2184:	86 e1       	ldi	r24, 0x16	; 22
    2186:	87 c0       	rjmp	.+270    	; 0x2296 <FPoolingPump+0x6aa>
	      break;
     case ppSendTransInfo:
	      PumpAddr=(txPumpID&0x0F);	      
    2188:	80 91 17 01 	lds	r24, 0x0117
    218c:	98 2f       	mov	r25, r24
    218e:	9f 70       	andi	r25, 0x0F	; 15
    2190:	90 93 05 01 	sts	0x0105, r25
		  SendTransFlow(txPumpID,rxPumpId,NozzleId,GradeId,strUnitPrice,strVolume,strAmount,PumpTransDigit);
    2194:	60 91 3b 01 	lds	r22, 0x013B
    2198:	40 91 e0 02 	lds	r20, 0x02E0
    219c:	20 91 f6 02 	lds	r18, 0x02F6
    21a0:	0c ea       	ldi	r16, 0xAC	; 172
    21a2:	12 e0       	ldi	r17, 0x02	; 2
    21a4:	37 e5       	ldi	r19, 0x57	; 87
    21a6:	e3 2e       	mov	r14, r19
    21a8:	32 e0       	ldi	r19, 0x02	; 2
    21aa:	f3 2e       	mov	r15, r19
    21ac:	9b ea       	ldi	r25, 0xAB	; 171
    21ae:	c9 2e       	mov	r12, r25
    21b0:	93 e0       	ldi	r25, 0x03	; 3
    21b2:	d9 2e       	mov	r13, r25
    21b4:	a0 90 0b 01 	lds	r10, 0x010B
    21b8:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <SendTransFlow>
		  IsRequestTransInfo[PumpAddr]=False;
    21bc:	e0 91 05 01 	lds	r30, 0x0105
    21c0:	f0 e0       	ldi	r31, 0x00	; 0
    21c2:	e6 57       	subi	r30, 0x76	; 118
    21c4:	fd 4f       	sbci	r31, 0xFD	; 253
    21c6:	61 c0       	rjmp	.+194    	; 0x228a <FPoolingPump+0x69e>
	      TimDelayNextPump=0;		  
		  stPoolingPump=ppDelayNextPump;
	      break;     
     case ppIsRequestTotalizerInfo:
          //StatePrintf(PSTR("23"));
	      PumpAddr=(txPumpID&0x0F);
    21c8:	e0 91 17 01 	lds	r30, 0x0117
    21cc:	ef 70       	andi	r30, 0x0F	; 15
    21ce:	e0 93 05 01 	sts	0x0105, r30
	      if (IsRequestTotalizerInfo[PumpAddr]==True){
    21d2:	f0 e0       	ldi	r31, 0x00	; 0
    21d4:	ed 5e       	subi	r30, 0xED	; 237
    21d6:	fb 4f       	sbci	r31, 0xFB	; 251
    21d8:	80 81       	ld	r24, Z
    21da:	81 30       	cpi	r24, 0x01	; 1
    21dc:	11 f4       	brne	.+4      	; 0x21e2 <FPoolingPump+0x5f6>
		      stPoolingPump=ppRequestTotalizerData;		  
    21de:	8b e1       	ldi	r24, 0x1B	; 27
    21e0:	5a c0       	rjmp	.+180    	; 0x2296 <FPoolingPump+0x6aa>
		  }else{
		  TimDelayNextPump=0; 
    21e2:	10 92 22 01 	sts	0x0122, r1
    21e6:	10 92 21 01 	sts	0x0121, r1
		  stPoolingPump=ppNextPump;
    21ea:	81 e0       	ldi	r24, 0x01	; 1
    21ec:	54 c0       	rjmp	.+168    	; 0x2296 <FPoolingPump+0x6aa>
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    21ee:	84 e0       	ldi	r24, 0x04	; 4
    21f0:	80 93 04 01 	sts	0x0104, r24

     case ppRequestTotalizerData:
          //StatePrintf(PSTR("24"));
	      SetReceiveLine(rcInitTotalizer);
	      if (GetReceiveLine()==rcInitTotalizer){
			  iSend=0;
    21f4:	10 92 f9 03 	sts	0x03F9, r1
    21f8:	2c c0       	rjmp	.+88     	; 0x2252 <FPoolingPump+0x666>
			  }
		  else stPoolingPump=ppRequestTotalizerData;
	      break;
     case ppSendTotalizerReq:
          //StatePrintf(PSTR("25"));
	 	  TimSend=0;
    21fa:	10 92 24 04 	sts	0x0424, r1
    21fe:	10 92 23 04 	sts	0x0423, r1
	      IsTotalizer=False;
    2202:	10 92 12 01 	sts	0x0112, r1
	      PumpCommand(txPumpID,CMD_TOTALIZER);
    2206:	80 91 17 01 	lds	r24, 0x0117
    220a:	65 e0       	ldi	r22, 0x05	; 5
    220c:	0e 94 ee 07 	call	0xfdc	; 0xfdc <PumpCommand>
		  stPoolingPump=ppWaitTotalizerReq;
    2210:	8d e1       	ldi	r24, 0x1D	; 29
    2212:	41 c0       	rjmp	.+130    	; 0x2296 <FPoolingPump+0x6aa>
	      break;
	 case ppWaitTotalizerReq:
          //StatePrintf(PSTR("26"));
		  if (IsTotalizer==True){
    2214:	80 91 12 01 	lds	r24, 0x0112
    2218:	81 30       	cpi	r24, 0x01	; 1
    221a:	29 f4       	brne	.+10     	; 0x2226 <FPoolingPump+0x63a>
		  	  IsTotalizer=False;
    221c:	10 92 12 01 	sts	0x0112, r1
			  stPoolingPump=ppTotalizerRequestCompleted;
    2220:	8e e1       	ldi	r24, 0x1E	; 30
    2222:	80 93 2c 01 	sts	0x012C, r24
		  }
          //if (TimSend>WAIT_TOTALIZER_TIMEOUT){
		  //    stPoolingPump=ppDelayNextPump;
		  //}
		  if (TimSend>(TPoolTimeout*5)){
    2226:	80 91 b6 02 	lds	r24, 0x02B6
    222a:	25 e0       	ldi	r18, 0x05	; 5
    222c:	82 9f       	mul	r24, r18
    222e:	c0 01       	movw	r24, r0
    2230:	11 24       	eor	r1, r1
    2232:	20 91 23 04 	lds	r18, 0x0423
    2236:	30 91 24 04 	lds	r19, 0x0424
    223a:	82 17       	cp	r24, r18
    223c:	93 07       	cpc	r25, r19
    223e:	68 f5       	brcc	.+90     	; 0x229a <FPoolingPump+0x6ae>
		  	  iSend++;
    2240:	80 91 f9 03 	lds	r24, 0x03F9
    2244:	8f 5f       	subi	r24, 0xFF	; 255
    2246:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppSendTotalizerReq;
    224a:	90 91 77 02 	lds	r25, 0x0277
    224e:	89 17       	cp	r24, r25
    2250:	10 f4       	brcc	.+4      	; 0x2256 <FPoolingPump+0x66a>
    2252:	8c e1       	ldi	r24, 0x1C	; 28
    2254:	20 c0       	rjmp	.+64     	; 0x2296 <FPoolingPump+0x6aa>
			  else
		      if (iSend>nSend)stPoolingPump=ppDelayNextPump;	      
    2256:	98 17       	cp	r25, r24
    2258:	00 f5       	brcc	.+64     	; 0x229a <FPoolingPump+0x6ae>
    225a:	1c c0       	rjmp	.+56     	; 0x2294 <FPoolingPump+0x6a8>
		  }
	      break;
	 case ppTotalizerRequestCompleted:
          //StatePrintf(PSTR("27"));																																																																																																																																		
		  stPoolingPump=ppSendTotalizerInfo;
    225c:	8f e1       	ldi	r24, 0x1F	; 31
    225e:	1b c0       	rjmp	.+54     	; 0x2296 <FPoolingPump+0x6aa>
	      break;
     case ppSendTotalizerInfo:
          //StatePrintf(PSTR("28"));
	      PumpAddr=(txPumpID&0x0F);
    2260:	80 91 17 01 	lds	r24, 0x0117
    2264:	98 2f       	mov	r25, r24
    2266:	9f 70       	andi	r25, 0x0F	; 15
    2268:	90 93 05 01 	sts	0x0105, r25
		  SendTotalizerFlow(txPumpID);
    226c:	0e 94 40 0c 	call	0x1880	; 0x1880 <SendTotalizerFlow>
		  IsTotalizerACK=False;
    2270:	10 92 14 01 	sts	0x0114, r1
		  //IsRequestTotalizerInfo[PumpAddr]=False;
	      //TimDelayNextPump=0;
		  stPoolingPump=ppWaitTotalizerACK;
    2274:	80 e2       	ldi	r24, 0x20	; 32
    2276:	0f c0       	rjmp	.+30     	; 0x2296 <FPoolingPump+0x6aa>
	      break;
     case ppWaitTotalizerACK:
	      if (IsTotalizerACK==True){//SC_TOTALIZER_ACK
    2278:	80 91 14 01 	lds	r24, 0x0114
    227c:	81 30       	cpi	r24, 0x01	; 1
    227e:	69 f4       	brne	.+26     	; 0x229a <FPoolingPump+0x6ae>
              IsRequestTotalizerInfo[PumpAddr]=False;
    2280:	e0 91 05 01 	lds	r30, 0x0105
    2284:	f0 e0       	ldi	r31, 0x00	; 0
    2286:	ed 5e       	subi	r30, 0xED	; 237
    2288:	fb 4f       	sbci	r31, 0xFB	; 251
    228a:	10 82       	st	Z, r1
	          TimDelayNextPump=0;
    228c:	10 92 22 01 	sts	0x0122, r1
    2290:	10 92 21 01 	sts	0x0121, r1
		      stPoolingPump=ppDelayNextPump;               
    2294:	85 e1       	ldi	r24, 0x15	; 21
    2296:	80 93 2c 01 	sts	0x012C, r24
		  }
	      break;
	 }
}
    229a:	64 96       	adiw	r28, 0x14	; 20
    229c:	0f b6       	in	r0, 0x3f	; 63
    229e:	f8 94       	cli
    22a0:	de bf       	out	0x3e, r29	; 62
    22a2:	0f be       	out	0x3f, r0	; 63
    22a4:	cd bf       	out	0x3d, r28	; 61
    22a6:	cf 91       	pop	r28
    22a8:	df 91       	pop	r29
    22aa:	1f 91       	pop	r17
    22ac:	0f 91       	pop	r16
    22ae:	ff 90       	pop	r15
    22b0:	ef 90       	pop	r14
    22b2:	df 90       	pop	r13
    22b4:	cf 90       	pop	r12
    22b6:	af 90       	pop	r10
    22b8:	08 95       	ret

000022ba <FPoolingPump2>:
			 }
             rxBufferLength=0;
		}
}

void FPoolingPump2(){
    22ba:	af 92       	push	r10
    22bc:	cf 92       	push	r12
    22be:	df 92       	push	r13
    22c0:	ef 92       	push	r14
    22c2:	ff 92       	push	r15
    22c4:	0f 93       	push	r16
    22c6:	1f 93       	push	r17
    22c8:	df 93       	push	r29
    22ca:	cf 93       	push	r28
    22cc:	cd b7       	in	r28, 0x3d	; 61
    22ce:	de b7       	in	r29, 0x3e	; 62
    22d0:	6e 97       	sbiw	r28, 0x1e	; 30
    22d2:	0f b6       	in	r0, 0x3f	; 63
    22d4:	f8 94       	cli
    22d6:	de bf       	out	0x3e, r29	; 62
    22d8:	0f be       	out	0x3f, r0	; 63
    22da:	cd bf       	out	0x3d, r28	; 61
     static char zPooling,stPoolingPump=pwInit,nPoolTotalizer=0,IsTotalizerBusy=False,iAuthCmd=0;
	 char strSend[30];

	 //Monitoring
	 if (zPooling!=stPoolingPump){
    22dc:	20 91 31 01 	lds	r18, 0x0131
    22e0:	80 91 32 01 	lds	r24, 0x0132
    22e4:	82 17       	cp	r24, r18
    22e6:	31 f1       	breq	.+76     	; 0x2334 <FPoolingPump2+0x7a>
	     zPooling=stPoolingPump;
    22e8:	20 93 32 01 	sts	0x0132, r18
		 #ifdef DEBUG_WAYNE_POOLING
         sprintf_P(strSend,PSTR("WPool:%d"),stPoolingPump);
    22ec:	00 d0       	rcall	.+0      	; 0x22ee <FPoolingPump2+0x34>
    22ee:	00 d0       	rcall	.+0      	; 0x22f0 <FPoolingPump2+0x36>
    22f0:	00 d0       	rcall	.+0      	; 0x22f2 <FPoolingPump2+0x38>
    22f2:	ed b7       	in	r30, 0x3d	; 61
    22f4:	fe b7       	in	r31, 0x3e	; 62
    22f6:	31 96       	adiw	r30, 0x01	; 1
    22f8:	8e 01       	movw	r16, r28
    22fa:	0f 5f       	subi	r16, 0xFF	; 255
    22fc:	1f 4f       	sbci	r17, 0xFF	; 255
    22fe:	ad b7       	in	r26, 0x3d	; 61
    2300:	be b7       	in	r27, 0x3e	; 62
    2302:	12 96       	adiw	r26, 0x02	; 2
    2304:	1c 93       	st	X, r17
    2306:	0e 93       	st	-X, r16
    2308:	11 97       	sbiw	r26, 0x01	; 1
    230a:	86 ea       	ldi	r24, 0xA6	; 166
    230c:	91 e0       	ldi	r25, 0x01	; 1
    230e:	93 83       	std	Z+3, r25	; 0x03
    2310:	82 83       	std	Z+2, r24	; 0x02
    2312:	24 83       	std	Z+4, r18	; 0x04
    2314:	15 82       	std	Z+5, r1	; 0x05
    2316:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
	 	 _uart_print(1,1,strSend);
    231a:	8d b7       	in	r24, 0x3d	; 61
    231c:	9e b7       	in	r25, 0x3e	; 62
    231e:	06 96       	adiw	r24, 0x06	; 6
    2320:	0f b6       	in	r0, 0x3f	; 63
    2322:	f8 94       	cli
    2324:	9e bf       	out	0x3e, r25	; 62
    2326:	0f be       	out	0x3f, r0	; 63
    2328:	8d bf       	out	0x3d, r24	; 61
    232a:	81 e0       	ldi	r24, 0x01	; 1
    232c:	61 e0       	ldi	r22, 0x01	; 1
    232e:	a8 01       	movw	r20, r16
    2330:	0e 94 8d 1b 	call	0x371a	; 0x371a <_uart_print>
		 #endif
	 }
     //Restarting
	 if (IsRestartPooling==True){
    2334:	80 91 03 01 	lds	r24, 0x0103
    2338:	81 30       	cpi	r24, 0x01	; 1
    233a:	79 f4       	brne	.+30     	; 0x235a <FPoolingPump2+0xa0>
	     IsRestartPooling=False;
    233c:	10 92 03 01 	sts	0x0103, r1
		 SendCommandAcknoledge(SC_POOL_RESTARTED,stPoolingPump);
    2340:	8a e1       	ldi	r24, 0x1A	; 26
    2342:	60 91 31 01 	lds	r22, 0x0131
    2346:	0e 94 65 07 	call	0xeca	; 0xeca <SendCommandAcknoledge>
		 _uart_printf(1,1,PSTR("PoolRestarted"));
    234a:	81 e0       	ldi	r24, 0x01	; 1
    234c:	61 e0       	ldi	r22, 0x01	; 1
    234e:	48 e9       	ldi	r20, 0x98	; 152
    2350:	51 e0       	ldi	r21, 0x01	; 1
    2352:	0e 94 b5 1b 	call	0x376a	; 0x376a <_uart_printf>
	     stPoolingPump=pwInit;
    2356:	10 92 31 01 	sts	0x0131, r1
	 }
	 switch(stPoolingPump){
    235a:	80 91 31 01 	lds	r24, 0x0131
    235e:	e8 2f       	mov	r30, r24
    2360:	f0 e0       	ldi	r31, 0x00	; 0
    2362:	ec 31       	cpi	r30, 0x1C	; 28
    2364:	f1 05       	cpc	r31, r1
    2366:	08 f0       	brcs	.+2      	; 0x236a <FPoolingPump2+0xb0>
    2368:	4d c3       	rjmp	.+1690   	; 0x2a04 <FPoolingPump2+0x74a>
    236a:	e7 5a       	subi	r30, 0xA7	; 167
    236c:	ff 4f       	sbci	r31, 0xFF	; 255
    236e:	ee 0f       	add	r30, r30
    2370:	ff 1f       	adc	r31, r31
    2372:	05 90       	lpm	r0, Z+
    2374:	f4 91       	lpm	r31, Z+
    2376:	e0 2d       	mov	r30, r0
    2378:	09 94       	ijmp
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    237a:	e1 99       	sbic	0x1c, 1	; 28
    237c:	fe cf       	rjmp	.-4      	; 0x237a <FPoolingPump2+0xc0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    237e:	88 e0       	ldi	r24, 0x08	; 8
    2380:	90 e0       	ldi	r25, 0x00	; 0
    2382:	9f bb       	out	0x1f, r25	; 31
    2384:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2386:	e0 9a       	sbi	0x1c, 0	; 28
    2388:	8d b3       	in	r24, 0x1d	; 29
	 case pwInit:
		  nNoPump=eeprom_read_byte(&DefNoPumpCountMax);
    238a:	80 93 35 04 	sts	0x0435, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    238e:	e1 99       	sbic	0x1c, 1	; 28
    2390:	fe cf       	rjmp	.-4      	; 0x238e <FPoolingPump2+0xd4>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2392:	87 e0       	ldi	r24, 0x07	; 7
    2394:	90 e0       	ldi	r25, 0x00	; 0
    2396:	9f bb       	out	0x1f, r25	; 31
    2398:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    239a:	e0 9a       	sbi	0x1c, 0	; 28
    239c:	8d b3       	in	r24, 0x1d	; 29
		  ScanPumpMax=eeprom_read_byte(&DefMaxPumpPooling);
    239e:	80 93 61 02 	sts	0x0261, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    23a2:	e1 99       	sbic	0x1c, 1	; 28
    23a4:	fe cf       	rjmp	.-4      	; 0x23a2 <FPoolingPump2+0xe8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    23a6:	89 e0       	ldi	r24, 0x09	; 9
    23a8:	90 e0       	ldi	r25, 0x00	; 0
    23aa:	9f bb       	out	0x1f, r25	; 31
    23ac:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    23ae:	e0 9a       	sbi	0x1c, 0	; 28
    23b0:	8d b3       	in	r24, 0x1d	; 29
		  nSend=eeprom_read_byte(&DefSendCount);
    23b2:	80 93 77 02 	sts	0x0277, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    23b6:	e1 99       	sbic	0x1c, 1	; 28
    23b8:	fe cf       	rjmp	.-4      	; 0x23b6 <FPoolingPump2+0xfc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    23ba:	8d e1       	ldi	r24, 0x1D	; 29
    23bc:	90 e0       	ldi	r25, 0x00	; 0
    23be:	9f bb       	out	0x1f, r25	; 31
    23c0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    23c2:	e0 9a       	sbi	0x1c, 0	; 28
    23c4:	8d b3       	in	r24, 0x1d	; 29
		  nPoolTotalizer=eeprom_read_byte(&DefNozzleCount);
    23c6:	80 93 30 01 	sts	0x0130, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    23ca:	e1 99       	sbic	0x1c, 1	; 28
    23cc:	fe cf       	rjmp	.-4      	; 0x23ca <FPoolingPump2+0x110>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    23ce:	8a e0       	ldi	r24, 0x0A	; 10
    23d0:	90 e0       	ldi	r25, 0x00	; 0
    23d2:	9f bb       	out	0x1f, r25	; 31
    23d4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    23d6:	e0 9a       	sbi	0x1c, 0	; 28
    23d8:	8d b3       	in	r24, 0x1d	; 29
		  TPoolTimeout=eeprom_read_byte(&DefPoolTimeout);
    23da:	80 93 b6 02 	sts	0x02B6, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    23de:	e1 99       	sbic	0x1c, 1	; 28
    23e0:	fe cf       	rjmp	.-4      	; 0x23de <FPoolingPump2+0x124>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    23e2:	8b e0       	ldi	r24, 0x0B	; 11
    23e4:	90 e0       	ldi	r25, 0x00	; 0
    23e6:	9f bb       	out	0x1f, r25	; 31
    23e8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    23ea:	e0 9a       	sbi	0x1c, 0	; 28
    23ec:	8d b3       	in	r24, 0x1d	; 29
		  TDelayNextPump=eeprom_read_byte(&DefDelayNextPump);
    23ee:	80 93 3c 01 	sts	0x013C, r24
		  
		  if (IsStopPoolSequence!=True)
    23f2:	80 91 13 01 	lds	r24, 0x0113
    23f6:	81 30       	cpi	r24, 0x01	; 1
    23f8:	29 f0       	breq	.+10     	; 0x2404 <FPoolingPump2+0x14a>
		      SendCommandAcknoledge(SC_LIVE_SEQUENCE,SequencePool);
    23fa:	89 e1       	ldi	r24, 0x19	; 25
    23fc:	60 91 26 01 	lds	r22, 0x0126
    2400:	0e 94 65 07 	call	0xeca	; 0xeca <SendCommandAcknoledge>
		  SequencePool++;
    2404:	80 91 26 01 	lds	r24, 0x0126
    2408:	8f 5f       	subi	r24, 0xFF	; 255
    240a:	80 93 26 01 	sts	0x0126, r24
		  iPoolingID=0;		  
    240e:	10 92 16 01 	sts	0x0116, r1
		  IsTotalizerBusy=False;
    2412:	10 92 2f 01 	sts	0x012F, r1
		  stPoolingPump=pwInitPumpAddr;
    2416:	81 e0       	ldi	r24, 0x01	; 1
    2418:	a4 c2       	rjmp	.+1352   	; 0x2962 <FPoolingPump2+0x6a8>
		  break;
     case pwInitPumpAddr:
		  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    241a:	80 91 16 01 	lds	r24, 0x0116
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    241e:	e1 99       	sbic	0x1c, 1	; 28
    2420:	fe cf       	rjmp	.-4      	; 0x241e <FPoolingPump2+0x164>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2422:	90 e0       	ldi	r25, 0x00	; 0
    2424:	83 5f       	subi	r24, 0xF3	; 243
    2426:	9f 4f       	sbci	r25, 0xFF	; 255
    2428:	9f bb       	out	0x1f, r25	; 31
    242a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    242c:	e0 9a       	sbi	0x1c, 0	; 28
    242e:	2d b3       	in	r18, 0x1d	; 29
          txPumpID=txPumpID-1; 
    2430:	21 50       	subi	r18, 0x01	; 1
    2432:	20 93 17 01 	sts	0x0117, r18

          #ifdef DEBUG_PUMPID
	       sprintf_P(strSend,PSTR("TxPumpID:%d"),txPumpID);
    2436:	00 d0       	rcall	.+0      	; 0x2438 <FPoolingPump2+0x17e>
    2438:	00 d0       	rcall	.+0      	; 0x243a <FPoolingPump2+0x180>
    243a:	00 d0       	rcall	.+0      	; 0x243c <FPoolingPump2+0x182>
    243c:	ed b7       	in	r30, 0x3d	; 61
    243e:	fe b7       	in	r31, 0x3e	; 62
    2440:	31 96       	adiw	r30, 0x01	; 1
    2442:	8e 01       	movw	r16, r28
    2444:	0f 5f       	subi	r16, 0xFF	; 255
    2446:	1f 4f       	sbci	r17, 0xFF	; 255
    2448:	ad b7       	in	r26, 0x3d	; 61
    244a:	be b7       	in	r27, 0x3e	; 62
    244c:	12 96       	adiw	r26, 0x02	; 2
    244e:	1c 93       	st	X, r17
    2450:	0e 93       	st	-X, r16
    2452:	11 97       	sbiw	r26, 0x01	; 1
    2454:	8c e8       	ldi	r24, 0x8C	; 140
    2456:	91 e0       	ldi	r25, 0x01	; 1
    2458:	93 83       	std	Z+3, r25	; 0x03
    245a:	82 83       	std	Z+2, r24	; 0x02
    245c:	24 83       	std	Z+4, r18	; 0x04
    245e:	15 82       	std	Z+5, r1	; 0x05
    2460:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
		   _uart_print(1,1,strSend);
    2464:	8d b7       	in	r24, 0x3d	; 61
    2466:	9e b7       	in	r25, 0x3e	; 62
    2468:	06 96       	adiw	r24, 0x06	; 6
    246a:	0f b6       	in	r0, 0x3f	; 63
    246c:	f8 94       	cli
    246e:	9e bf       	out	0x3e, r25	; 62
    2470:	0f be       	out	0x3f, r0	; 63
    2472:	8d bf       	out	0x3d, r24	; 61
    2474:	81 e0       	ldi	r24, 0x01	; 1
    2476:	61 e0       	ldi	r22, 0x01	; 1
    2478:	a8 01       	movw	r20, r16
    247a:	0e 94 8d 1b 	call	0x371a	; 0x371a <_uart_print>
		  #endif

		  //txPumpID=2-1; 
		  //SendCommandAcknoledge(SC_LIVE_SEQUENCE,SequencePool);
		  SequencePool++;
    247e:	80 91 26 01 	lds	r24, 0x0126
    2482:	8f 5f       	subi	r24, 0xFF	; 255
    2484:	80 93 26 01 	sts	0x0126, r24
          iSend=0;		  
    2488:	10 92 f9 03 	sts	0x03F9, r1
    248c:	12 c1       	rjmp	.+548    	; 0x26b2 <FPoolingPump2+0x3f8>
	      stPoolingPump=pwScanStatus;
          break;	 
     case pwScanStatus:
	      WayneReply=WR_NONE;
    248e:	10 92 1a 01 	sts	0x011A, r1
	      FWayneSendCommand(CMD_STATUS,0,txPumpID,0);
    2492:	80 e0       	ldi	r24, 0x00	; 0
    2494:	60 e0       	ldi	r22, 0x00	; 0
    2496:	40 91 17 01 	lds	r20, 0x0117
    249a:	20 e0       	ldi	r18, 0x00	; 0
    249c:	0e 94 1a 08 	call	0x1034	; 0x1034 <FWayneSendCommand>
		  TimSend=0;
    24a0:	10 92 24 04 	sts	0x0424, r1
    24a4:	10 92 23 04 	sts	0x0423, r1
		  stPoolingPump=pwWaitScanReply;
    24a8:	83 e0       	ldi	r24, 0x03	; 3
    24aa:	5b c2       	rjmp	.+1206   	; 0x2962 <FPoolingPump2+0x6a8>
	      break;
     case pwWaitScanReply:
	      //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    24ac:	80 91 b6 02 	lds	r24, 0x02B6
    24b0:	90 e0       	ldi	r25, 0x00	; 0
    24b2:	20 91 23 04 	lds	r18, 0x0423
    24b6:	30 91 24 04 	lds	r19, 0x0424
    24ba:	82 17       	cp	r24, r18
    24bc:	93 07       	cpc	r25, r19
    24be:	70 f4       	brcc	.+28     	; 0x24dc <FPoolingPump2+0x222>
		      iSend++;
    24c0:	80 91 f9 03 	lds	r24, 0x03F9
    24c4:	8f 5f       	subi	r24, 0xFF	; 255
    24c6:	80 93 f9 03 	sts	0x03F9, r24
			  if (iSend<nSend)stPoolingPump=pwScanStatus;//Retry
    24ca:	90 91 77 02 	lds	r25, 0x0277
    24ce:	89 17       	cp	r24, r25
    24d0:	10 f4       	brcc	.+4      	; 0x24d6 <FPoolingPump2+0x21c>
    24d2:	82 e0       	ldi	r24, 0x02	; 2
    24d4:	01 c0       	rjmp	.+2      	; 0x24d8 <FPoolingPump2+0x21e>
			  else
			  if (iSend>=nSend)stPoolingPump=pwNoPump;//Pump Not Available
    24d6:	84 e0       	ldi	r24, 0x04	; 4
    24d8:	80 93 31 01 	sts	0x0131, r24
		  }		  
	      
		  switch(WayneReply){
    24dc:	80 91 1a 01 	lds	r24, 0x011A
    24e0:	81 30       	cpi	r24, 0x01	; 1
    24e2:	21 f0       	breq	.+8      	; 0x24ec <FPoolingPump2+0x232>
    24e4:	84 30       	cpi	r24, 0x04	; 4
    24e6:	09 f0       	breq	.+2      	; 0x24ea <FPoolingPump2+0x230>
    24e8:	8d c2       	rjmp	.+1306   	; 0x2a04 <FPoolingPump2+0x74a>
    24ea:	16 c0       	rjmp	.+44     	; 0x2518 <FPoolingPump2+0x25e>
		  case WR_READY:
			   if ((PumpStatus[txPumpID]==PW_NONE)||(PumpStatus[txPumpID]==PW_DISCONNECT)){
    24ec:	80 91 17 01 	lds	r24, 0x0117
    24f0:	a8 2f       	mov	r26, r24
    24f2:	b0 e0       	ldi	r27, 0x00	; 0
    24f4:	fd 01       	movw	r30, r26
    24f6:	eb 54       	subi	r30, 0x4B	; 75
    24f8:	fc 4f       	sbci	r31, 0xFC	; 252
    24fa:	e0 81       	ld	r30, Z
    24fc:	ee 23       	and	r30, r30
    24fe:	19 f0       	breq	.+6      	; 0x2506 <FPoolingPump2+0x24c>
    2500:	ee 30       	cpi	r30, 0x0E	; 14
    2502:	09 f0       	breq	.+2      	; 0x2506 <FPoolingPump2+0x24c>
    2504:	1a c2       	rjmp	.+1076   	; 0x293a <FPoolingPump2+0x680>
			        IsRequestTransInfo[txPumpID]=False;
    2506:	a6 57       	subi	r26, 0x76	; 118
    2508:	bd 4f       	sbci	r27, 0xFD	; 253
    250a:	1c 92       	st	X, r1
			        PumpStatus[txPumpID]=PW_ONLINE;
    250c:	e0 91 17 01 	lds	r30, 0x0117
    2510:	f0 e0       	ldi	r31, 0x00	; 0
    2512:	eb 54       	subi	r30, 0x4B	; 75
    2514:	fc 4f       	sbci	r31, 0xFC	; 252
    2516:	0f c2       	rjmp	.+1054   	; 0x2936 <FPoolingPump2+0x67c>
				  }
               //_uart_printf(1,1,PSTR("WR_READY"));
               stPoolingPump=pwUpdatePumpStatus;
		       break;
          case WR_MESSAGE:
		       stPoolingPump=pwReplyACK;
    2518:	87 e1       	ldi	r24, 0x17	; 23
    251a:	23 c2       	rjmp	.+1094   	; 0x2962 <FPoolingPump2+0x6a8>
		       break;
		  }
	      break;
	 case pwNoPump:
	      NoPumpCount[txPumpID&0x0F]++;
    251c:	80 91 17 01 	lds	r24, 0x0117
    2520:	a8 2f       	mov	r26, r24
    2522:	b0 e0       	ldi	r27, 0x00	; 0
    2524:	fd 01       	movw	r30, r26
    2526:	ef 70       	andi	r30, 0x0F	; 15
    2528:	f0 70       	andi	r31, 0x00	; 0
    252a:	eb 5d       	subi	r30, 0xDB	; 219
    252c:	fb 4f       	sbci	r31, 0xFB	; 251
    252e:	80 81       	ld	r24, Z
    2530:	8f 5f       	subi	r24, 0xFF	; 255
    2532:	80 83       	st	Z, r24
		  if (NoPumpCount[txPumpID&0x0F]>nNoPump){
    2534:	90 91 35 04 	lds	r25, 0x0435
    2538:	98 17       	cp	r25, r24
    253a:	08 f0       	brcs	.+2      	; 0x253e <FPoolingPump2+0x284>
    253c:	7e c1       	rjmp	.+764    	; 0x283a <FPoolingPump2+0x580>
		      NoPumpCount[txPumpID&0x0F]=0;
    253e:	10 82       	st	Z, r1
	          PumpStatus[txPumpID]=PW_DISCONNECT;
    2540:	ab 54       	subi	r26, 0x4B	; 75
    2542:	bc 4f       	sbci	r27, 0xFC	; 252
    2544:	8e e0       	ldi	r24, 0x0E	; 14
    2546:	4f c0       	rjmp	.+158    	; 0x25e6 <FPoolingPump2+0x32c>
              stPoolingPump=pwUpdatePumpStatus;
			  }
          else stPoolingPump=pwInitDelayNextPump;
	      break;
     case pwUpdatePumpStatus:
	      PumpAddr=txPumpID;
    2548:	80 91 17 01 	lds	r24, 0x0117
    254c:	80 93 05 01 	sts	0x0105, r24
	 	  if (PumpStatus[PumpAddr]!=zPumpStatus[PumpAddr]){
    2550:	90 e0       	ldi	r25, 0x00	; 0
    2552:	fc 01       	movw	r30, r24
    2554:	eb 54       	subi	r30, 0x4B	; 75
    2556:	fc 4f       	sbci	r31, 0xFC	; 252
    2558:	e0 81       	ld	r30, Z
    255a:	dc 01       	movw	r26, r24
    255c:	a5 56       	subi	r26, 0x65	; 101
    255e:	bd 4f       	sbci	r27, 0xFD	; 253
    2560:	8c 91       	ld	r24, X
    2562:	e8 17       	cp	r30, r24
    2564:	79 f0       	breq	.+30     	; 0x2584 <FPoolingPump2+0x2ca>
		      zPumpStatus[PumpAddr]=PumpStatus[PumpAddr];
    2566:	ec 93       	st	X, r30
		      stPoolingPump=pwSendPumpStatus;
    2568:	86 e0       	ldi	r24, 0x06	; 6
    256a:	fb c1       	rjmp	.+1014   	; 0x2962 <FPoolingPump2+0x6a8>
		  }else stPoolingPump=pwNextAction;
	      break;
     case pwSendPumpStatus:
          PumpAddr=txPumpID;
    256c:	80 91 17 01 	lds	r24, 0x0117
    2570:	80 93 05 01 	sts	0x0105, r24
	      SendPumpStatusFlow(txPumpID+1,PumpStatus[PumpAddr]);
    2574:	e8 2f       	mov	r30, r24
    2576:	f0 e0       	ldi	r31, 0x00	; 0
    2578:	eb 54       	subi	r30, 0x4B	; 75
    257a:	fc 4f       	sbci	r31, 0xFC	; 252
    257c:	8f 5f       	subi	r24, 0xFF	; 255
    257e:	60 81       	ld	r22, Z
    2580:	0e 94 4d 07 	call	0xe9a	; 0xe9a <SendPumpStatusFlow>
		  //sprintf_P(strSend,PSTR("WR:%d MI:%d"),WayneReply,MsgInfo);
		  //_uart_print(1,1,strSend);
	      stPoolingPump=pwNextAction;
    2584:	87 e0       	ldi	r24, 0x07	; 7
    2586:	ed c1       	rjmp	.+986    	; 0x2962 <FPoolingPump2+0x6a8>
	      break;
     case pwNextAction:
	      //Switch Action Based Pump State
		  PumpAddr=txPumpID;
    2588:	80 91 17 01 	lds	r24, 0x0117
    258c:	80 93 05 01 	sts	0x0105, r24
		  switch(PumpStatus[PumpAddr]){
    2590:	e8 2f       	mov	r30, r24
    2592:	f0 e0       	ldi	r31, 0x00	; 0
    2594:	df 01       	movw	r26, r30
    2596:	ab 54       	subi	r26, 0x4B	; 75
    2598:	bc 4f       	sbci	r27, 0xFC	; 252
    259a:	8c 91       	ld	r24, X
    259c:	87 30       	cpi	r24, 0x07	; 7
    259e:	09 f4       	brne	.+2      	; 0x25a2 <FPoolingPump2+0x2e8>
    25a0:	72 c0       	rjmp	.+228    	; 0x2686 <FPoolingPump2+0x3cc>
    25a2:	88 30       	cpi	r24, 0x08	; 8
    25a4:	20 f4       	brcc	.+8      	; 0x25ae <FPoolingPump2+0x2f4>
    25a6:	86 30       	cpi	r24, 0x06	; 6
    25a8:	09 f0       	breq	.+2      	; 0x25ac <FPoolingPump2+0x2f2>
    25aa:	2c c2       	rjmp	.+1112   	; 0x2a04 <FPoolingPump2+0x74a>
    25ac:	1e c0       	rjmp	.+60     	; 0x25ea <FPoolingPump2+0x330>
    25ae:	89 30       	cpi	r24, 0x09	; 9
    25b0:	09 f4       	brne	.+2      	; 0x25b4 <FPoolingPump2+0x2fa>
    25b2:	6c c0       	rjmp	.+216    	; 0x268c <FPoolingPump2+0x3d2>
    25b4:	8e 30       	cpi	r24, 0x0E	; 14
    25b6:	09 f0       	breq	.+2      	; 0x25ba <FPoolingPump2+0x300>
    25b8:	25 c2       	rjmp	.+1098   	; 0x2a04 <FPoolingPump2+0x74a>
		  case PW_DISCONNECT:
		       switch(WayneReply){
    25ba:	80 91 1a 01 	lds	r24, 0x011A
    25be:	88 23       	and	r24, r24
    25c0:	09 f4       	brne	.+2      	; 0x25c4 <FPoolingPump2+0x30a>
    25c2:	3b c1       	rjmp	.+630    	; 0x283a <FPoolingPump2+0x580>
    25c4:	84 30       	cpi	r24, 0x04	; 4
    25c6:	09 f0       	breq	.+2      	; 0x25ca <FPoolingPump2+0x310>
    25c8:	1d c2       	rjmp	.+1082   	; 0x2a04 <FPoolingPump2+0x74a>
			   case WR_MESSAGE:
			        switch(MsgInfo){
    25ca:	80 91 19 01 	lds	r24, 0x0119
    25ce:	83 30       	cpi	r24, 0x03	; 3
    25d0:	29 f0       	breq	.+10     	; 0x25dc <FPoolingPump2+0x322>
    25d2:	88 30       	cpi	r24, 0x08	; 8
    25d4:	39 f0       	breq	.+14     	; 0x25e4 <FPoolingPump2+0x32a>
    25d6:	82 30       	cpi	r24, 0x02	; 2
    25d8:	29 f4       	brne	.+10     	; 0x25e4 <FPoolingPump2+0x32a>
    25da:	37 c0       	rjmp	.+110    	; 0x264a <FPoolingPump2+0x390>
					case MI_NOZZLE_DOWN:
						 IsRequestTransInfo[txPumpID]=True;
    25dc:	e6 57       	subi	r30, 0x76	; 118
    25de:	fd 4f       	sbci	r31, 0xFD	; 253
    25e0:	81 e0       	ldi	r24, 0x01	; 1
    25e2:	80 83       	st	Z, r24
					     break;
					case MI_TOTALIZER:
                         PumpStatus[txPumpID]=PW_ONLINE; 
					     break;
                    default:
					     PumpStatus[txPumpID]=PW_ONLINE;
    25e4:	86 e0       	ldi	r24, 0x06	; 6
    25e6:	8c 93       	st	X, r24
    25e8:	a8 c1       	rjmp	.+848    	; 0x293a <FPoolingPump2+0x680>
			   }
		       break;
          case PW_ONLINE:
		       //sprintf_P(strSend,PSTR("ONLine:%d"),WayneReply);
			   //_uart_print(1,1,strSend);
		       switch(WayneReply){
    25ea:	80 91 1a 01 	lds	r24, 0x011A
    25ee:	81 30       	cpi	r24, 0x01	; 1
    25f0:	21 f0       	breq	.+8      	; 0x25fa <FPoolingPump2+0x340>
    25f2:	84 30       	cpi	r24, 0x04	; 4
    25f4:	09 f0       	breq	.+2      	; 0x25f8 <FPoolingPump2+0x33e>
    25f6:	06 c2       	rjmp	.+1036   	; 0x2a04 <FPoolingPump2+0x74a>
    25f8:	18 c0       	rjmp	.+48     	; 0x262a <FPoolingPump2+0x370>
			   case WR_READY:
			        if (IsRequestTransInfo[txPumpID]==True){
    25fa:	e6 57       	subi	r30, 0x76	; 118
    25fc:	fd 4f       	sbci	r31, 0xFD	; 253
    25fe:	80 81       	ld	r24, Z
    2600:	81 30       	cpi	r24, 0x01	; 1
    2602:	29 f4       	brne	.+10     	; 0x260e <FPoolingPump2+0x354>
					    iSend=0;
    2604:	10 92 f9 03 	sts	0x03F9, r1
					    stPoolingPump=pwSendTransactionRequest;
    2608:	8e e0       	ldi	r24, 0x0E	; 14
    260a:	80 93 31 01 	sts	0x0131, r24
					}if (IsRequestTotalizerInfo[txPumpID]==True){
    260e:	e0 91 17 01 	lds	r30, 0x0117
    2612:	f0 e0       	ldi	r31, 0x00	; 0
    2614:	ed 5e       	subi	r30, 0xED	; 237
    2616:	fb 4f       	sbci	r31, 0xFB	; 251
    2618:	e0 81       	ld	r30, Z
    261a:	e1 30       	cpi	r30, 0x01	; 1
    261c:	09 f0       	breq	.+2      	; 0x2620 <FPoolingPump2+0x366>
    261e:	0d c1       	rjmp	.+538    	; 0x283a <FPoolingPump2+0x580>
					    iSend=0;
    2620:	10 92 f9 03 	sts	0x03F9, r1
						ActiveNozzle=1;
    2624:	e0 93 1c 01 	sts	0x011C, r30
    2628:	eb c0       	rjmp	.+470    	; 0x2800 <FPoolingPump2+0x546>
						stPoolingPump=pwSendTotalizerRequest;
					}else stPoolingPump=pwInitDelayNextPump;

			        break;
			   case WR_MESSAGE:
			        switch(MsgInfo){
    262a:	80 91 19 01 	lds	r24, 0x0119
    262e:	83 30       	cpi	r24, 0x03	; 3
    2630:	c9 f0       	breq	.+50     	; 0x2664 <FPoolingPump2+0x3aa>
    2632:	84 30       	cpi	r24, 0x04	; 4
    2634:	20 f4       	brcc	.+8      	; 0x263e <FPoolingPump2+0x384>
    2636:	82 30       	cpi	r24, 0x02	; 2
    2638:	09 f0       	breq	.+2      	; 0x263c <FPoolingPump2+0x382>
    263a:	e4 c1       	rjmp	.+968    	; 0x2a04 <FPoolingPump2+0x74a>
    263c:	06 c0       	rjmp	.+12     	; 0x264a <FPoolingPump2+0x390>
    263e:	86 30       	cpi	r24, 0x06	; 6
    2640:	49 f0       	breq	.+18     	; 0x2654 <FPoolingPump2+0x39a>
    2642:	88 30       	cpi	r24, 0x08	; 8
    2644:	09 f0       	breq	.+2      	; 0x2648 <FPoolingPump2+0x38e>
    2646:	de c1       	rjmp	.+956    	; 0x2a04 <FPoolingPump2+0x74a>
    2648:	12 c0       	rjmp	.+36     	; 0x266e <FPoolingPump2+0x3b4>
					case MI_NOZZLE_UP:
					     PumpStatus[PumpAddr]=PW_CALL;
    264a:	87 e0       	ldi	r24, 0x07	; 7
    264c:	8c 93       	st	X, r24
						 iAuthCmd=0;
    264e:	10 92 2e 01 	sts	0x012E, r1
    2652:	73 c1       	rjmp	.+742    	; 0x293a <FPoolingPump2+0x680>
						 stPoolingPump=pwUpdatePumpStatus;
					     break;
					case MI_LAST_TRANSACTION:
                         if (IsRequestTransInfo[txPumpID]==True)
    2654:	e6 57       	subi	r30, 0x76	; 118
    2656:	fd 4f       	sbci	r31, 0xFD	; 253
    2658:	80 81       	ld	r24, Z
    265a:	81 30       	cpi	r24, 0x01	; 1
    265c:	09 f0       	breq	.+2      	; 0x2660 <FPoolingPump2+0x3a6>
    265e:	ed c0       	rjmp	.+474    	; 0x283a <FPoolingPump2+0x580>
						     stPoolingPump=pwSendTransMessage;
    2660:	81 e1       	ldi	r24, 0x11	; 17
    2662:	7f c1       	rjmp	.+766    	; 0x2962 <FPoolingPump2+0x6a8>
                         else stPoolingPump=pwInitDelayNextPump;
					     break;
					case MI_NOZZLE_DOWN:
                         IsRequestTransInfo[txPumpID]=True;
    2664:	e6 57       	subi	r30, 0x76	; 118
    2666:	fd 4f       	sbci	r31, 0xFD	; 253
    2668:	81 e0       	ldi	r24, 0x01	; 1
    266a:	80 83       	st	Z, r24
    266c:	e6 c0       	rjmp	.+460    	; 0x283a <FPoolingPump2+0x580>
						 stPoolingPump=pwInitDelayNextPump;
					     break;
                    case MI_TOTALIZER:
					     if (ActiveNozzle<4){
    266e:	80 91 1c 01 	lds	r24, 0x011C
    2672:	84 30       	cpi	r24, 0x04	; 4
    2674:	30 f4       	brcc	.+12     	; 0x2682 <FPoolingPump2+0x3c8>
						     iSend=0;
    2676:	10 92 f9 03 	sts	0x03F9, r1
						     ActiveNozzle++;
    267a:	8f 5f       	subi	r24, 0xFF	; 255
    267c:	80 93 1c 01 	sts	0x011C, r24
    2680:	bf c0       	rjmp	.+382    	; 0x2800 <FPoolingPump2+0x546>
						     stPoolingPump=pwSendTotalizerRequest;
						 }else stPoolingPump=pwSendTotalizerInfo;
    2682:	8c e0       	ldi	r24, 0x0C	; 12
    2684:	6e c1       	rjmp	.+732    	; 0x2962 <FPoolingPump2+0x6a8>
			   case WR_NACK:
			        break;
			   }
		       break;
          case PW_CALL:
		       iSend=0; 
    2686:	10 92 f9 03 	sts	0x03F9, r1
    268a:	35 c1       	rjmp	.+618    	; 0x28f6 <FPoolingPump2+0x63c>
			   stPoolingPump=pwSendAuthorizeCommand;               			   
		       break;
           
          case PW_AUTHORIZED:
               if (WayneReply==WR_READY){
    268c:	80 91 1a 01 	lds	r24, 0x011A
    2690:	81 30       	cpi	r24, 0x01	; 1
    2692:	09 f4       	brne	.+2      	; 0x2696 <FPoolingPump2+0x3dc>
    2694:	d2 c0       	rjmp	.+420    	; 0x283a <FPoolingPump2+0x580>
			           stPoolingPump=pwInitDelayNextPump;
			   }else if (WayneReply==WR_MESSAGE){
    2696:	80 91 1a 01 	lds	r24, 0x011A
    269a:	84 30       	cpi	r24, 0x04	; 4
    269c:	09 f0       	breq	.+2      	; 0x26a0 <FPoolingPump2+0x3e6>
    269e:	b2 c1       	rjmp	.+868    	; 0x2a04 <FPoolingPump2+0x74a>
			       if (MsgInfo==MI_NOZZLE_DOWN){
    26a0:	80 91 19 01 	lds	r24, 0x0119
    26a4:	83 30       	cpi	r24, 0x03	; 3
    26a6:	29 f4       	brne	.+10     	; 0x26b2 <FPoolingPump2+0x3f8>
				       PumpStatus[PumpAddr]=PW_ONLINE;
    26a8:	86 e0       	ldi	r24, 0x06	; 6
    26aa:	8c 93       	st	X, r24
					   iSend=0;
    26ac:	10 92 f9 03 	sts	0x03F9, r1
    26b0:	3c c0       	rjmp	.+120    	; 0x272a <FPoolingPump2+0x470>
					   stPoolingPump=pwSendTransactionRequest;
				   }else stPoolingPump=pwScanStatus;
    26b2:	82 e0       	ldi	r24, 0x02	; 2
    26b4:	56 c1       	rjmp	.+684    	; 0x2962 <FPoolingPump2+0x6a8>
	      break;
     //Request last Transaction
	 case pwSendTransactionRequest:	 
	      //sprintf_P(strSend,PSTR("Last Transcation"));
		  //_uart_print(1,1,strSend);
		  FWayneSendCommand(CMD_TRANSACTION,CommandSeqID[txPumpID],txPumpID,ActiveNozzle);          
    26b6:	40 91 17 01 	lds	r20, 0x0117
    26ba:	e4 2f       	mov	r30, r20
    26bc:	f0 e0       	ldi	r31, 0x00	; 0
    26be:	ee 57       	subi	r30, 0x7E	; 126
    26c0:	fd 4f       	sbci	r31, 0xFD	; 253
    26c2:	8e e0       	ldi	r24, 0x0E	; 14
    26c4:	60 81       	ld	r22, Z
    26c6:	20 91 1c 01 	lds	r18, 0x011C
    26ca:	0e 94 1a 08 	call	0x1034	; 0x1034 <FWayneSendCommand>
		  TimSend=0;
    26ce:	10 92 24 04 	sts	0x0424, r1
    26d2:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=pwWaitTransACK;
    26d6:	8f e0       	ldi	r24, 0x0F	; 15
    26d8:	44 c1       	rjmp	.+648    	; 0x2962 <FPoolingPump2+0x6a8>
	      break;
     case pwWaitTransACK:
	 	  //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    26da:	80 91 b6 02 	lds	r24, 0x02B6
    26de:	90 e0       	ldi	r25, 0x00	; 0
    26e0:	20 91 23 04 	lds	r18, 0x0423
    26e4:	30 91 24 04 	lds	r19, 0x0424
    26e8:	82 17       	cp	r24, r18
    26ea:	93 07       	cpc	r25, r19
    26ec:	18 f4       	brcc	.+6      	; 0x26f4 <FPoolingPump2+0x43a>
		      stPoolingPump=pwRetrySendTransRequest;
    26ee:	80 e1       	ldi	r24, 0x10	; 16
    26f0:	80 93 31 01 	sts	0x0131, r24
		  }
          //Acknowledge
	      if (WayneReply==WR_ACK){
    26f4:	90 91 1a 01 	lds	r25, 0x011A
    26f8:	92 30       	cpi	r25, 0x02	; 2
    26fa:	09 f4       	brne	.+2      	; 0x26fe <FPoolingPump2+0x444>
    26fc:	60 c0       	rjmp	.+192    	; 0x27be <FPoolingPump2+0x504>
		      CommandSeqID[txPumpID]++;
			  //stPoolingPump=pwSendTransMessage;
			  stPoolingPump=pwScanStatus;
		  }else if (WayneReply==WR_NACK){
    26fe:	80 91 1a 01 	lds	r24, 0x011A
    2702:	83 30       	cpi	r24, 0x03	; 3
    2704:	09 f0       	breq	.+2      	; 0x2708 <FPoolingPump2+0x44e>
    2706:	7e c1       	rjmp	.+764    	; 0x2a04 <FPoolingPump2+0x74a>
		      CommandSeqID[txPumpID]=0;
    2708:	e0 91 17 01 	lds	r30, 0x0117
    270c:	f0 e0       	ldi	r31, 0x00	; 0
    270e:	ee 57       	subi	r30, 0x7E	; 126
    2710:	fd 4f       	sbci	r31, 0xFD	; 253
    2712:	10 82       	st	Z, r1
    2714:	0a c0       	rjmp	.+20     	; 0x272a <FPoolingPump2+0x470>
              stPoolingPump=pwSendTransactionRequest;
		  }
	      break;
     case pwRetrySendTransRequest:
	      iSend++;
    2716:	80 91 f9 03 	lds	r24, 0x03F9
    271a:	8f 5f       	subi	r24, 0xFF	; 255
    271c:	80 93 f9 03 	sts	0x03F9, r24
		  if (iSend<nSend)stPoolingPump=pwSendTransactionRequest;
    2720:	90 91 77 02 	lds	r25, 0x0277
    2724:	89 17       	cp	r24, r25
    2726:	08 f0       	brcs	.+2      	; 0x272a <FPoolingPump2+0x470>
    2728:	e8 c0       	rjmp	.+464    	; 0x28fa <FPoolingPump2+0x640>
    272a:	8e e0       	ldi	r24, 0x0E	; 14
    272c:	1a c1       	rjmp	.+564    	; 0x2962 <FPoolingPump2+0x6a8>
		  else
		  if (iSend>=nSend)stPoolingPump=pwNoPump;
	      break;

     case pwSendTransMessage:
          rxPumpId=txPumpID;
    272e:	60 91 17 01 	lds	r22, 0x0117
    2732:	60 93 3b 01 	sts	0x013B, r22
		  NozzleId=ActiveNozzle;
    2736:	20 91 1c 01 	lds	r18, 0x011C
    273a:	20 93 e0 02 	sts	0x02E0, r18
		  GradeId=ActiveNozzle;
    273e:	20 93 f6 02 	sts	0x02F6, r18
		  PumpTransDigit=6;
    2742:	86 e0       	ldi	r24, 0x06	; 6
    2744:	80 93 0b 01 	sts	0x010B, r24
	      SendTransFlow(txPumpID+1,rxPumpId+1,NozzleId,GradeId,strUnitPrice,strVolume,strAmount,PumpTransDigit);
    2748:	6f 5f       	subi	r22, 0xFF	; 255
    274a:	86 2f       	mov	r24, r22
    274c:	42 2f       	mov	r20, r18
    274e:	0c ea       	ldi	r16, 0xAC	; 172
    2750:	12 e0       	ldi	r17, 0x02	; 2
    2752:	e7 e5       	ldi	r30, 0x57	; 87
    2754:	ee 2e       	mov	r14, r30
    2756:	e2 e0       	ldi	r30, 0x02	; 2
    2758:	fe 2e       	mov	r15, r30
    275a:	7b ea       	ldi	r23, 0xAB	; 171
    275c:	c7 2e       	mov	r12, r23
    275e:	73 e0       	ldi	r23, 0x03	; 3
    2760:	d7 2e       	mov	r13, r23
    2762:	56 e0       	ldi	r21, 0x06	; 6
    2764:	a5 2e       	mov	r10, r21
    2766:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <SendTransFlow>
		  IsRequestTransInfo[txPumpID]=False;
    276a:	e0 91 17 01 	lds	r30, 0x0117
    276e:	f0 e0       	ldi	r31, 0x00	; 0
    2770:	e6 57       	subi	r30, 0x76	; 118
    2772:	fd 4f       	sbci	r31, 0xFD	; 253
    2774:	10 82       	st	Z, r1
    2776:	61 c0       	rjmp	.+194    	; 0x283a <FPoolingPump2+0x580>
		  //IsRequestTotalizerInfo[txPumpID]=True;
          stPoolingPump=pwInitDelayNextPump;
	      break; 
	 //Totalizer
	 case pwSendTotalizerRequest:
	      FWayneSendCommand(CMD_TOTALIZER,CommandSeqID[txPumpID],txPumpID,ActiveNozzle);          
    2778:	40 91 17 01 	lds	r20, 0x0117
    277c:	e4 2f       	mov	r30, r20
    277e:	f0 e0       	ldi	r31, 0x00	; 0
    2780:	ee 57       	subi	r30, 0x7E	; 126
    2782:	fd 4f       	sbci	r31, 0xFD	; 253
    2784:	85 e0       	ldi	r24, 0x05	; 5
    2786:	60 81       	ld	r22, Z
    2788:	20 91 1c 01 	lds	r18, 0x011C
    278c:	0e 94 1a 08 	call	0x1034	; 0x1034 <FWayneSendCommand>
		  TimSend=0;
    2790:	10 92 24 04 	sts	0x0424, r1
    2794:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=pwWaitTotalizerACK;
    2798:	8a e0       	ldi	r24, 0x0A	; 10
    279a:	e3 c0       	rjmp	.+454    	; 0x2962 <FPoolingPump2+0x6a8>
	      break;
     case pwWaitTotalizerACK:
	       //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    279c:	80 91 b6 02 	lds	r24, 0x02B6
    27a0:	90 e0       	ldi	r25, 0x00	; 0
    27a2:	20 91 23 04 	lds	r18, 0x0423
    27a6:	30 91 24 04 	lds	r19, 0x0424
    27aa:	82 17       	cp	r24, r18
    27ac:	93 07       	cpc	r25, r19
    27ae:	18 f4       	brcc	.+6      	; 0x27b6 <FPoolingPump2+0x4fc>
		      stPoolingPump=pwRetrySendTotalizerRequest;
    27b0:	8b e0       	ldi	r24, 0x0B	; 11
    27b2:	80 93 31 01 	sts	0x0131, r24
		  }
          //Acknowledge
	      if (WayneReply==WR_ACK){
    27b6:	90 91 1a 01 	lds	r25, 0x011A
    27ba:	92 30       	cpi	r25, 0x02	; 2
    27bc:	59 f4       	brne	.+22     	; 0x27d4 <FPoolingPump2+0x51a>
		      CommandSeqID[txPumpID]++;
    27be:	e0 91 17 01 	lds	r30, 0x0117
    27c2:	f0 e0       	ldi	r31, 0x00	; 0
    27c4:	ee 57       	subi	r30, 0x7E	; 126
    27c6:	fd 4f       	sbci	r31, 0xFD	; 253
    27c8:	80 81       	ld	r24, Z
    27ca:	8f 5f       	subi	r24, 0xFF	; 255
    27cc:	80 83       	st	Z, r24
			  stPoolingPump=pwScanStatus;
    27ce:	90 93 31 01 	sts	0x0131, r25
    27d2:	18 c1       	rjmp	.+560    	; 0x2a04 <FPoolingPump2+0x74a>
		  }else if (WayneReply==WR_NACK){
    27d4:	80 91 1a 01 	lds	r24, 0x011A
    27d8:	83 30       	cpi	r24, 0x03	; 3
    27da:	09 f0       	breq	.+2      	; 0x27de <FPoolingPump2+0x524>
    27dc:	13 c1       	rjmp	.+550    	; 0x2a04 <FPoolingPump2+0x74a>
		      CommandSeqID[txPumpID]=0;
    27de:	e0 91 17 01 	lds	r30, 0x0117
    27e2:	f0 e0       	ldi	r31, 0x00	; 0
    27e4:	ee 57       	subi	r30, 0x7E	; 126
    27e6:	fd 4f       	sbci	r31, 0xFD	; 253
    27e8:	10 82       	st	Z, r1
    27ea:	0a c0       	rjmp	.+20     	; 0x2800 <FPoolingPump2+0x546>
              stPoolingPump=pwSendTotalizerRequest;
		  }
	      break;
     case pwRetrySendTotalizerRequest:
	      iSend++;
    27ec:	80 91 f9 03 	lds	r24, 0x03F9
    27f0:	8f 5f       	subi	r24, 0xFF	; 255
    27f2:	80 93 f9 03 	sts	0x03F9, r24
		  if (iSend<nSend)stPoolingPump=pwSendTotalizerRequest;
    27f6:	90 91 77 02 	lds	r25, 0x0277
    27fa:	89 17       	cp	r24, r25
    27fc:	08 f0       	brcs	.+2      	; 0x2800 <FPoolingPump2+0x546>
    27fe:	7d c0       	rjmp	.+250    	; 0x28fa <FPoolingPump2+0x640>
    2800:	89 e0       	ldi	r24, 0x09	; 9
    2802:	af c0       	rjmp	.+350    	; 0x2962 <FPoolingPump2+0x6a8>
		  else
		  if (iSend>=nSend)stPoolingPump=pwNoPump;
	      break;
     case pwSendTotalizerInfo:
	      PumpTotalDigit=10;
    2804:	8a e0       	ldi	r24, 0x0A	; 10
    2806:	80 93 0c 01 	sts	0x010C, r24
	      SendTotalizerFlow(txPumpID+1);
    280a:	80 91 17 01 	lds	r24, 0x0117
    280e:	8f 5f       	subi	r24, 0xFF	; 255
    2810:	0e 94 40 0c 	call	0x1880	; 0x1880 <SendTotalizerFlow>
		  IsTotalizerACK=False;//True;//
    2814:	10 92 14 01 	sts	0x0114, r1
		  stPoolingPump=pwWaitTotalizerInfoACK;
    2818:	8d e0       	ldi	r24, 0x0D	; 13
    281a:	a3 c0       	rjmp	.+326    	; 0x2962 <FPoolingPump2+0x6a8>
	      break;
     case pwWaitTotalizerInfoACK:
	      if (IsTotalizerACK==True){//SC_TOTALIZER_ACK
    281c:	80 91 14 01 	lds	r24, 0x0114
    2820:	81 30       	cpi	r24, 0x01	; 1
    2822:	09 f0       	breq	.+2      	; 0x2826 <FPoolingPump2+0x56c>
    2824:	ef c0       	rjmp	.+478    	; 0x2a04 <FPoolingPump2+0x74a>
              IsRequestTotalizerInfo[PumpAddr]=False;
    2826:	e0 91 05 01 	lds	r30, 0x0105
    282a:	f0 e0       	ldi	r31, 0x00	; 0
    282c:	ed 5e       	subi	r30, 0xED	; 237
    282e:	fb 4f       	sbci	r31, 0xFB	; 251
    2830:	10 82       	st	Z, r1
	          TimDelayNextPump=0;
    2832:	10 92 22 01 	sts	0x0122, r1
    2836:	10 92 21 01 	sts	0x0121, r1
		      stPoolingPump=pwInitDelayNextPump;
    283a:	89 e1       	ldi	r24, 0x19	; 25
    283c:	92 c0       	rjmp	.+292    	; 0x2962 <FPoolingPump2+0x6a8>
     case pwSendAuthorizeCommand:
	      #ifdef DEBUG_WAYNE_STATE 
		  sprintf_P(strSend,PSTR("Authorize%d"),iAuthCmd+1);
		  _uart_print(1,1,strSend);
		  #endif
		  FWayneSendCommand((CMD_AUTH_1+iAuthCmd),CommandSeqID[txPumpID],txPumpID,ActiveNozzle);          
    283e:	40 91 17 01 	lds	r20, 0x0117
    2842:	80 91 2e 01 	lds	r24, 0x012E
    2846:	e4 2f       	mov	r30, r20
    2848:	f0 e0       	ldi	r31, 0x00	; 0
    284a:	ee 57       	subi	r30, 0x7E	; 126
    284c:	fd 4f       	sbci	r31, 0xFD	; 253
    284e:	86 5f       	subi	r24, 0xF6	; 246
    2850:	60 81       	ld	r22, Z
    2852:	20 91 1c 01 	lds	r18, 0x011C
    2856:	0e 94 1a 08 	call	0x1034	; 0x1034 <FWayneSendCommand>
		  TimSend=0;
    285a:	10 92 24 04 	sts	0x0424, r1
    285e:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=pwWaitAuthACK;
    2862:	83 e1       	ldi	r24, 0x13	; 19
    2864:	7e c0       	rjmp	.+252    	; 0x2962 <FPoolingPump2+0x6a8>
	      break;
     case pwWaitAuthACK:
	 	  //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    2866:	80 91 b6 02 	lds	r24, 0x02B6
    286a:	90 e0       	ldi	r25, 0x00	; 0
    286c:	20 91 23 04 	lds	r18, 0x0423
    2870:	30 91 24 04 	lds	r19, 0x0424
    2874:	82 17       	cp	r24, r18
    2876:	93 07       	cpc	r25, r19
    2878:	18 f4       	brcc	.+6      	; 0x2880 <FPoolingPump2+0x5c6>
		      stPoolingPump=pwRetrySendAuthorizeCommand;
    287a:	84 e1       	ldi	r24, 0x14	; 20
    287c:	80 93 31 01 	sts	0x0131, r24
		  }		  
	      //Acknowledge
	      if (WayneReply==WR_ACK){
    2880:	20 91 1a 01 	lds	r18, 0x011A
    2884:	22 30       	cpi	r18, 0x02	; 2
    2886:	09 f5       	brne	.+66     	; 0x28ca <FPoolingPump2+0x610>
		      iAuthCmd++;
    2888:	80 91 2e 01 	lds	r24, 0x012E
    288c:	8f 5f       	subi	r24, 0xFF	; 255
    288e:	80 93 2e 01 	sts	0x012E, r24
    2892:	90 91 17 01 	lds	r25, 0x0117
			  if (iAuthCmd>=4){//Complete ACK
    2896:	84 30       	cpi	r24, 0x04	; 4
    2898:	80 f0       	brcs	.+32     	; 0x28ba <FPoolingPump2+0x600>
			      PumpStatus[PumpAddr]=PW_AUTHORIZED;
    289a:	e0 91 05 01 	lds	r30, 0x0105
    289e:	f0 e0       	ldi	r31, 0x00	; 0
    28a0:	eb 54       	subi	r30, 0x4B	; 75
    28a2:	fc 4f       	sbci	r31, 0xFC	; 252
    28a4:	89 e0       	ldi	r24, 0x09	; 9
    28a6:	80 83       	st	Z, r24
				  IsRequestTransInfo[txPumpID]=True;
    28a8:	e9 2f       	mov	r30, r25
    28aa:	f0 e0       	ldi	r31, 0x00	; 0
    28ac:	e6 57       	subi	r30, 0x76	; 118
    28ae:	fd 4f       	sbci	r31, 0xFD	; 253
    28b0:	81 e0       	ldi	r24, 0x01	; 1
    28b2:	80 83       	st	Z, r24
			      stPoolingPump=pwScanStatus;
    28b4:	20 93 31 01 	sts	0x0131, r18
    28b8:	a5 c0       	rjmp	.+330    	; 0x2a04 <FPoolingPump2+0x74a>
			  }else {
			   CommandSeqID[txPumpID]++;
    28ba:	e9 2f       	mov	r30, r25
    28bc:	f0 e0       	ldi	r31, 0x00	; 0
    28be:	ee 57       	subi	r30, 0x7E	; 126
    28c0:	fd 4f       	sbci	r31, 0xFD	; 253
    28c2:	80 81       	ld	r24, Z
    28c4:	8f 5f       	subi	r24, 0xFF	; 255
    28c6:	80 83       	st	Z, r24
    28c8:	16 c0       	rjmp	.+44     	; 0x28f6 <FPoolingPump2+0x63c>
			   stPoolingPump=pwSendAuthorizeCommand;
			   }
		  }else if (WayneReply==WR_NACK){
    28ca:	80 91 1a 01 	lds	r24, 0x011A
    28ce:	83 30       	cpi	r24, 0x03	; 3
    28d0:	09 f0       	breq	.+2      	; 0x28d4 <FPoolingPump2+0x61a>
    28d2:	98 c0       	rjmp	.+304    	; 0x2a04 <FPoolingPump2+0x74a>
		      CommandSeqID[txPumpID]=0;
    28d4:	e0 91 17 01 	lds	r30, 0x0117
    28d8:	f0 e0       	ldi	r31, 0x00	; 0
    28da:	ee 57       	subi	r30, 0x7E	; 126
    28dc:	fd 4f       	sbci	r31, 0xFD	; 253
    28de:	10 82       	st	Z, r1
              stPoolingPump=pwRetrySendAuthorizeCommand;
    28e0:	84 e1       	ldi	r24, 0x14	; 20
    28e2:	3f c0       	rjmp	.+126    	; 0x2962 <FPoolingPump2+0x6a8>
		  }
	      break;
     case pwRetrySendAuthorizeCommand:
	      iSend++;
    28e4:	80 91 f9 03 	lds	r24, 0x03F9
    28e8:	8f 5f       	subi	r24, 0xFF	; 255
    28ea:	80 93 f9 03 	sts	0x03F9, r24
		  if (iSend<nSend)stPoolingPump=pwSendAuthorizeCommand;
    28ee:	90 91 77 02 	lds	r25, 0x0277
    28f2:	89 17       	cp	r24, r25
    28f4:	10 f4       	brcc	.+4      	; 0x28fa <FPoolingPump2+0x640>
    28f6:	82 e1       	ldi	r24, 0x12	; 18
    28f8:	34 c0       	rjmp	.+104    	; 0x2962 <FPoolingPump2+0x6a8>
		  else
		  if (iSend>=nSend)stPoolingPump=pwNoPump;
    28fa:	84 e0       	ldi	r24, 0x04	; 4
    28fc:	32 c0       	rjmp	.+100    	; 0x2962 <FPoolingPump2+0x6a8>
	 case pwSendGeneralStatus:
	      
	      break;
	 //Price Config	  
	 case pwSendPriceConfig:
	      stPoolingPump=pwWaitACK; 
    28fe:	86 e1       	ldi	r24, 0x16	; 22
    2900:	30 c0       	rjmp	.+96     	; 0x2962 <FPoolingPump2+0x6a8>
	      break;
	 case pwWaitACK:
	      PumpStatus[PumpAddr]=PW_PRICE_UPDATED;
    2902:	e0 91 05 01 	lds	r30, 0x0105
    2906:	f0 e0       	ldi	r31, 0x00	; 0
    2908:	eb 54       	subi	r30, 0x4B	; 75
    290a:	fc 4f       	sbci	r31, 0xFC	; 252
    290c:	8f e0       	ldi	r24, 0x0F	; 15
    290e:	14 c0       	rjmp	.+40     	; 0x2938 <FPoolingPump2+0x67e>
		  stPoolingPump=pwUpdatePumpStatus;
          break;	 
	 //Acknowledge--------------
	 case pwReplyACK:
	      FWayneSendCommand(CMD_ACK,WayneRxSequence,txPumpID,0);
    2910:	87 e0       	ldi	r24, 0x07	; 7
    2912:	60 91 18 01 	lds	r22, 0x0118
    2916:	40 91 17 01 	lds	r20, 0x0117
    291a:	20 e0       	ldi	r18, 0x00	; 0
    291c:	0e 94 1a 08 	call	0x1034	; 0x1034 <FWayneSendCommand>
		  stPoolingPump=pwScanMessage;
    2920:	88 e1       	ldi	r24, 0x18	; 24
    2922:	1f c0       	rjmp	.+62     	; 0x2962 <FPoolingPump2+0x6a8>
	      break;	 
	 case pwScanMessage:
	      if (PumpStatus[txPumpID]==PW_NONE){
    2924:	80 91 17 01 	lds	r24, 0x0117
    2928:	e8 2f       	mov	r30, r24
    292a:	f0 e0       	ldi	r31, 0x00	; 0
    292c:	eb 54       	subi	r30, 0x4B	; 75
    292e:	fc 4f       	sbci	r31, 0xFC	; 252
    2930:	80 81       	ld	r24, Z
    2932:	88 23       	and	r24, r24
    2934:	11 f4       	brne	.+4      	; 0x293a <FPoolingPump2+0x680>
			  PumpStatus[txPumpID]=PW_ONLINE;
    2936:	86 e0       	ldi	r24, 0x06	; 6
    2938:	80 83       	st	Z, r24
		  }		  
	      stPoolingPump=pwUpdatePumpStatus;
    293a:	85 e0       	ldi	r24, 0x05	; 5
    293c:	12 c0       	rjmp	.+36     	; 0x2962 <FPoolingPump2+0x6a8>
	      break;		  
		  		 		  
     //Next Pump----------------
     case pwInitDelayNextPump:
	      TimDelayNextPump=0;
    293e:	10 92 22 01 	sts	0x0122, r1
    2942:	10 92 21 01 	sts	0x0121, r1
          stPoolingPump=pwDelayNextPump;
    2946:	8a e1       	ldi	r24, 0x1A	; 26
    2948:	0c c0       	rjmp	.+24     	; 0x2962 <FPoolingPump2+0x6a8>
	      break;
     case pwDelayNextPump:
	      if (TimDelayNextPump>=TDelayNextPump)//20
    294a:	80 91 3c 01 	lds	r24, 0x013C
    294e:	90 e0       	ldi	r25, 0x00	; 0
    2950:	20 91 21 01 	lds	r18, 0x0121
    2954:	30 91 22 01 	lds	r19, 0x0122
    2958:	28 17       	cp	r18, r24
    295a:	39 07       	cpc	r19, r25
    295c:	08 f4       	brcc	.+2      	; 0x2960 <FPoolingPump2+0x6a6>
    295e:	52 c0       	rjmp	.+164    	; 0x2a04 <FPoolingPump2+0x74a>
		      stPoolingPump=pwNextPump;
    2960:	8b e1       	ldi	r24, 0x1B	; 27
    2962:	80 93 31 01 	sts	0x0131, r24
    2966:	4e c0       	rjmp	.+156    	; 0x2a04 <FPoolingPump2+0x74a>
	      break;
     case pwNextPump:	      
          iPoolingID++;
    2968:	90 91 16 01 	lds	r25, 0x0116
    296c:	9f 5f       	subi	r25, 0xFF	; 255
    296e:	90 93 16 01 	sts	0x0116, r25
	      if (iPoolingID<ScanPumpMax){
    2972:	80 91 61 02 	lds	r24, 0x0261
    2976:	98 17       	cp	r25, r24
    2978:	e8 f4       	brcc	.+58     	; 0x29b4 <FPoolingPump2+0x6fa>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    297a:	e1 99       	sbic	0x1c, 1	; 28
    297c:	fe cf       	rjmp	.-4      	; 0x297a <FPoolingPump2+0x6c0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    297e:	89 2f       	mov	r24, r25
    2980:	90 e0       	ldi	r25, 0x00	; 0
    2982:	83 5f       	subi	r24, 0xF3	; 243
    2984:	9f 4f       	sbci	r25, 0xFF	; 255
    2986:	9f bb       	out	0x1f, r25	; 31
    2988:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    298a:	e0 9a       	sbi	0x1c, 0	; 28
    298c:	8d b3       	in	r24, 0x1d	; 29
			  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    298e:	80 93 17 01 	sts	0x0117, r24
			  if (txPumpID>0){
    2992:	88 23       	and	r24, r24
    2994:	59 f0       	breq	.+22     	; 0x29ac <FPoolingPump2+0x6f2>
			      txPumpID=txPumpID-1;
    2996:	81 50       	subi	r24, 0x01	; 1
    2998:	80 93 17 01 	sts	0x0117, r24
			      iSend=0;TimSend=0;
    299c:	10 92 f9 03 	sts	0x03F9, r1
    29a0:	10 92 24 04 	sts	0x0424, r1
    29a4:	10 92 23 04 	sts	0x0423, r1
			      stPoolingPump=pwScanStatus;
    29a8:	82 e0       	ldi	r24, 0x02	; 2
    29aa:	01 c0       	rjmp	.+2      	; 0x29ae <FPoolingPump2+0x6f4>
			   }else stPoolingPump=pwNextPump;
    29ac:	8b e1       	ldi	r24, 0x1B	; 27
    29ae:	80 93 31 01 	sts	0x0131, r24
    29b2:	02 c0       	rjmp	.+4      	; 0x29b8 <FPoolingPump2+0x6fe>
		  } else stPoolingPump=pwInit;//pwInitPumpAddr;
    29b4:	10 92 31 01 	sts	0x0131, r1

          #ifdef DEBUG_PUMPID
	       sprintf_P(strSend,PSTR("TxPumpID:%d"),txPumpID);
    29b8:	00 d0       	rcall	.+0      	; 0x29ba <FPoolingPump2+0x700>
    29ba:	00 d0       	rcall	.+0      	; 0x29bc <FPoolingPump2+0x702>
    29bc:	00 d0       	rcall	.+0      	; 0x29be <FPoolingPump2+0x704>
    29be:	ed b7       	in	r30, 0x3d	; 61
    29c0:	fe b7       	in	r31, 0x3e	; 62
    29c2:	31 96       	adiw	r30, 0x01	; 1
    29c4:	8e 01       	movw	r16, r28
    29c6:	0f 5f       	subi	r16, 0xFF	; 255
    29c8:	1f 4f       	sbci	r17, 0xFF	; 255
    29ca:	ad b7       	in	r26, 0x3d	; 61
    29cc:	be b7       	in	r27, 0x3e	; 62
    29ce:	12 96       	adiw	r26, 0x02	; 2
    29d0:	1c 93       	st	X, r17
    29d2:	0e 93       	st	-X, r16
    29d4:	11 97       	sbiw	r26, 0x01	; 1
    29d6:	80 e8       	ldi	r24, 0x80	; 128
    29d8:	91 e0       	ldi	r25, 0x01	; 1
    29da:	93 83       	std	Z+3, r25	; 0x03
    29dc:	82 83       	std	Z+2, r24	; 0x02
    29de:	80 91 17 01 	lds	r24, 0x0117
    29e2:	84 83       	std	Z+4, r24	; 0x04
    29e4:	15 82       	std	Z+5, r1	; 0x05
    29e6:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
		   _uart_print(1,1,strSend);
    29ea:	8d b7       	in	r24, 0x3d	; 61
    29ec:	9e b7       	in	r25, 0x3e	; 62
    29ee:	06 96       	adiw	r24, 0x06	; 6
    29f0:	0f b6       	in	r0, 0x3f	; 63
    29f2:	f8 94       	cli
    29f4:	9e bf       	out	0x3e, r25	; 62
    29f6:	0f be       	out	0x3f, r0	; 63
    29f8:	8d bf       	out	0x3d, r24	; 61
    29fa:	81 e0       	ldi	r24, 0x01	; 1
    29fc:	61 e0       	ldi	r22, 0x01	; 1
    29fe:	a8 01       	movw	r20, r16
    2a00:	0e 94 8d 1b 	call	0x371a	; 0x371a <_uart_print>
		  #endif
		  
		  //stPoolingPump=pwInitPumpAddr;
	      break;
	 }
}
    2a04:	6e 96       	adiw	r28, 0x1e	; 30
    2a06:	0f b6       	in	r0, 0x3f	; 63
    2a08:	f8 94       	cli
    2a0a:	de bf       	out	0x3e, r29	; 62
    2a0c:	0f be       	out	0x3f, r0	; 63
    2a0e:	cd bf       	out	0x3d, r28	; 61
    2a10:	cf 91       	pop	r28
    2a12:	df 91       	pop	r29
    2a14:	1f 91       	pop	r17
    2a16:	0f 91       	pop	r16
    2a18:	ff 90       	pop	r15
    2a1a:	ef 90       	pop	r14
    2a1c:	df 90       	pop	r13
    2a1e:	cf 90       	pop	r12
    2a20:	af 90       	pop	r10
    2a22:	08 95       	ret

00002a24 <TerminalSend>:
       while(pgm_read_byte(&(*strSendf)))
	         _uart(Com, 1, pgm_read_byte(&(*strSendf++)));
	}
}

void TerminalSend(char Com,char *strSend){
    2a24:	28 2f       	mov	r18, r24
    2a26:	ab 01       	movw	r20, r22
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2a28:	e1 99       	sbic	0x1c, 1	; 28
    2a2a:	fe cf       	rjmp	.-4      	; 0x2a28 <TerminalSend+0x4>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2a2c:	84 e0       	ldi	r24, 0x04	; 4
    2a2e:	90 e0       	ldi	r25, 0x00	; 0
    2a30:	9f bb       	out	0x1f, r25	; 31
    2a32:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2a34:	e0 9a       	sbi	0x1c, 0	; 28
    2a36:	8d b3       	in	r24, 0x1d	; 29
   if (eeprom_read_byte(&DefTerminalDebug)){
    2a38:	88 23       	and	r24, r24
    2a3a:	21 f0       	breq	.+8      	; 0x2a44 <TerminalSend+0x20>
       _uart_print(Com,1,strSend);
    2a3c:	82 2f       	mov	r24, r18
    2a3e:	61 e0       	ldi	r22, 0x01	; 1
    2a40:	0e 94 8d 1b 	call	0x371a	; 0x371a <_uart_print>
    2a44:	08 95       	ret

00002a46 <SystemSetDispenser>:
	 //_uart_init(1,9600);	
}

//enum eBaudRateValue{brNone,br9600,br19200,br5787};

void SystemSetDispenser(char TDispenserBrand){
    2a46:	ef 92       	push	r14
    2a48:	0f 93       	push	r16
     unsigned int brValue;

	 switch(TDispenserBrand){
    2a4a:	81 30       	cpi	r24, 0x01	; 1
    2a4c:	99 f1       	breq	.+102    	; 0x2ab4 <SystemSetDispenser+0x6e>
    2a4e:	81 30       	cpi	r24, 0x01	; 1
    2a50:	38 f0       	brcs	.+14     	; 0x2a60 <SystemSetDispenser+0x1a>
    2a52:	82 30       	cpi	r24, 0x02	; 2
    2a54:	09 f4       	brne	.+2      	; 0x2a58 <SystemSetDispenser+0x12>
    2a56:	5c c0       	rjmp	.+184    	; 0x2b10 <SystemSetDispenser+0xca>
    2a58:	83 30       	cpi	r24, 0x03	; 3
    2a5a:	09 f0       	breq	.+2      	; 0x2a5e <SystemSetDispenser+0x18>
    2a5c:	b8 c0       	rjmp	.+368    	; 0x2bce <SystemSetDispenser+0x188>
    2a5e:	86 c0       	rjmp	.+268    	; 0x2b6c <SystemSetDispenser+0x126>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2a60:	e1 99       	sbic	0x1c, 1	; 28
    2a62:	fe cf       	rjmp	.-4      	; 0x2a60 <SystemSetDispenser+0x1a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2a64:	85 e0       	ldi	r24, 0x05	; 5
    2a66:	90 e0       	ldi	r25, 0x00	; 0
    2a68:	9f bb       	out	0x1f, r25	; 31
    2a6a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2a6c:	e0 9a       	sbi	0x1c, 0	; 28
    2a6e:	8d b3       	in	r24, 0x1d	; 29
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2a70:	82 30       	cpi	r24, 0x02	; 2
    2a72:	59 f0       	breq	.+22     	; 0x2a8a <SystemSetDispenser+0x44>
    2a74:	82 30       	cpi	r24, 0x02	; 2
    2a76:	18 f0       	brcs	.+6      	; 0x2a7e <SystemSetDispenser+0x38>
    2a78:	83 30       	cpi	r24, 0x03	; 3
    2a7a:	21 f4       	brne	.+8      	; 0x2a84 <SystemSetDispenser+0x3e>
    2a7c:	09 c0       	rjmp	.+18     	; 0x2a90 <SystemSetDispenser+0x4a>
    2a7e:	80 e8       	ldi	r24, 0x80	; 128
    2a80:	95 e2       	ldi	r25, 0x25	; 37
    2a82:	08 c0       	rjmp	.+16     	; 0x2a94 <SystemSetDispenser+0x4e>
    2a84:	80 e0       	ldi	r24, 0x00	; 0
    2a86:	90 e0       	ldi	r25, 0x00	; 0
    2a88:	05 c0       	rjmp	.+10     	; 0x2a94 <SystemSetDispenser+0x4e>
    2a8a:	80 e0       	ldi	r24, 0x00	; 0
    2a8c:	9b e4       	ldi	r25, 0x4B	; 75
    2a8e:	02 c0       	rjmp	.+4      	; 0x2a94 <SystemSetDispenser+0x4e>
    2a90:	8b e9       	ldi	r24, 0x9B	; 155
    2a92:	96 e1       	ldi	r25, 0x16	; 22
void SystemSetDispenser(char TDispenserBrand){
     unsigned int brValue;

	 switch(TDispenserBrand){
	 case ST_NONE:
	      _uart_setting(0,GetBaudrate(eeprom_read_byte(&DefBaudrate[0])),8,P_NONE,1);
    2a94:	ac 01       	movw	r20, r24
    2a96:	66 27       	eor	r22, r22
    2a98:	57 fd       	sbrc	r21, 7
    2a9a:	60 95       	com	r22
    2a9c:	76 2f       	mov	r23, r22
    2a9e:	80 e0       	ldi	r24, 0x00	; 0
    2aa0:	28 e0       	ldi	r18, 0x08	; 8
    2aa2:	00 e0       	ldi	r16, 0x00	; 0
    2aa4:	ee 24       	eor	r14, r14
    2aa6:	e3 94       	inc	r14
    2aa8:	0e 94 b5 1a 	call	0x356a	; 0x356a <_uart_setting>
          SystemComLevel(CL_232);
    2aac:	80 e0       	ldi	r24, 0x00	; 0
    2aae:	0e 94 e6 01 	call	0x3cc	; 0x3cc <SystemComLevel>
    2ab2:	8d c0       	rjmp	.+282    	; 0x2bce <SystemSetDispenser+0x188>
	      break;
	 case ST_GILBARCO:
	      SystemComLevel(CL_232);
    2ab4:	80 e0       	ldi	r24, 0x00	; 0
    2ab6:	0e 94 e6 01 	call	0x3cc	; 0x3cc <SystemComLevel>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2aba:	e1 99       	sbic	0x1c, 1	; 28
    2abc:	fe cf       	rjmp	.-4      	; 0x2aba <SystemSetDispenser+0x74>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2abe:	25 e0       	ldi	r18, 0x05	; 5
    2ac0:	30 e0       	ldi	r19, 0x00	; 0
    2ac2:	3f bb       	out	0x1f, r19	; 31
    2ac4:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    2ac6:	83 e0       	ldi	r24, 0x03	; 3
    2ac8:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    2aca:	0f b6       	in	r0, 0x3f	; 63
    2acc:	f8 94       	cli
    2ace:	e2 9a       	sbi	0x1c, 2	; 28
    2ad0:	e1 9a       	sbi	0x1c, 1	; 28
    2ad2:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2ad4:	e1 99       	sbic	0x1c, 1	; 28
    2ad6:	fe cf       	rjmp	.-4      	; 0x2ad4 <SystemSetDispenser+0x8e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2ad8:	3f bb       	out	0x1f, r19	; 31
    2ada:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2adc:	e0 9a       	sbi	0x1c, 0	; 28
    2ade:	8d b3       	in	r24, 0x1d	; 29
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2ae0:	82 30       	cpi	r24, 0x02	; 2
    2ae2:	59 f0       	breq	.+22     	; 0x2afa <SystemSetDispenser+0xb4>
    2ae4:	82 30       	cpi	r24, 0x02	; 2
    2ae6:	18 f0       	brcs	.+6      	; 0x2aee <SystemSetDispenser+0xa8>
    2ae8:	83 30       	cpi	r24, 0x03	; 3
    2aea:	21 f4       	brne	.+8      	; 0x2af4 <SystemSetDispenser+0xae>
    2aec:	09 c0       	rjmp	.+18     	; 0x2b00 <SystemSetDispenser+0xba>
    2aee:	40 e8       	ldi	r20, 0x80	; 128
    2af0:	55 e2       	ldi	r21, 0x25	; 37
    2af2:	08 c0       	rjmp	.+16     	; 0x2b04 <SystemSetDispenser+0xbe>
    2af4:	40 e0       	ldi	r20, 0x00	; 0
    2af6:	50 e0       	ldi	r21, 0x00	; 0
    2af8:	05 c0       	rjmp	.+10     	; 0x2b04 <SystemSetDispenser+0xbe>
    2afa:	40 e0       	ldi	r20, 0x00	; 0
    2afc:	5b e4       	ldi	r21, 0x4B	; 75
    2afe:	02 c0       	rjmp	.+4      	; 0x2b04 <SystemSetDispenser+0xbe>
    2b00:	4b e9       	ldi	r20, 0x9B	; 155
    2b02:	56 e1       	ldi	r21, 0x16	; 22
	      break;
	 case ST_GILBARCO:
	      SystemComLevel(CL_232);
		  eeprom_write_byte(&DefBaudrate[0],br5787);
		  brValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[0]));
	      _uart_setting(0,brValue,8,P_NONE,1);
    2b04:	60 e0       	ldi	r22, 0x00	; 0
    2b06:	70 e0       	ldi	r23, 0x00	; 0
    2b08:	80 e0       	ldi	r24, 0x00	; 0
    2b0a:	28 e0       	ldi	r18, 0x08	; 8
    2b0c:	00 e0       	ldi	r16, 0x00	; 0
    2b0e:	5b c0       	rjmp	.+182    	; 0x2bc6 <SystemSetDispenser+0x180>
	      break;
	 case ST_WAYNE_DART:		       
	 	  SystemComLevel(CL_485);
    2b10:	81 e0       	ldi	r24, 0x01	; 1
    2b12:	0e 94 e6 01 	call	0x3cc	; 0x3cc <SystemComLevel>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2b16:	e1 99       	sbic	0x1c, 1	; 28
    2b18:	fe cf       	rjmp	.-4      	; 0x2b16 <SystemSetDispenser+0xd0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2b1a:	25 e0       	ldi	r18, 0x05	; 5
    2b1c:	30 e0       	ldi	r19, 0x00	; 0
    2b1e:	3f bb       	out	0x1f, r19	; 31
    2b20:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    2b22:	81 e0       	ldi	r24, 0x01	; 1
    2b24:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    2b26:	0f b6       	in	r0, 0x3f	; 63
    2b28:	f8 94       	cli
    2b2a:	e2 9a       	sbi	0x1c, 2	; 28
    2b2c:	e1 9a       	sbi	0x1c, 1	; 28
    2b2e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2b30:	e1 99       	sbic	0x1c, 1	; 28
    2b32:	fe cf       	rjmp	.-4      	; 0x2b30 <SystemSetDispenser+0xea>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2b34:	3f bb       	out	0x1f, r19	; 31
    2b36:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2b38:	e0 9a       	sbi	0x1c, 0	; 28
    2b3a:	8d b3       	in	r24, 0x1d	; 29
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2b3c:	82 30       	cpi	r24, 0x02	; 2
    2b3e:	59 f0       	breq	.+22     	; 0x2b56 <SystemSetDispenser+0x110>
    2b40:	82 30       	cpi	r24, 0x02	; 2
    2b42:	18 f0       	brcs	.+6      	; 0x2b4a <SystemSetDispenser+0x104>
    2b44:	83 30       	cpi	r24, 0x03	; 3
    2b46:	21 f4       	brne	.+8      	; 0x2b50 <SystemSetDispenser+0x10a>
    2b48:	09 c0       	rjmp	.+18     	; 0x2b5c <SystemSetDispenser+0x116>
    2b4a:	40 e8       	ldi	r20, 0x80	; 128
    2b4c:	55 e2       	ldi	r21, 0x25	; 37
    2b4e:	08 c0       	rjmp	.+16     	; 0x2b60 <SystemSetDispenser+0x11a>
    2b50:	40 e0       	ldi	r20, 0x00	; 0
    2b52:	50 e0       	ldi	r21, 0x00	; 0
    2b54:	05 c0       	rjmp	.+10     	; 0x2b60 <SystemSetDispenser+0x11a>
    2b56:	40 e0       	ldi	r20, 0x00	; 0
    2b58:	5b e4       	ldi	r21, 0x4B	; 75
    2b5a:	02 c0       	rjmp	.+4      	; 0x2b60 <SystemSetDispenser+0x11a>
    2b5c:	4b e9       	ldi	r20, 0x9B	; 155
    2b5e:	56 e1       	ldi	r21, 0x16	; 22
	      break;
	 case ST_WAYNE_DART:		       
	 	  SystemComLevel(CL_485);
          eeprom_write_byte(&DefBaudrate[0],br9600);
		  brValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[0]));
	      _uart_setting(0,brValue,8,P_ODD,1);
    2b60:	60 e0       	ldi	r22, 0x00	; 0
    2b62:	70 e0       	ldi	r23, 0x00	; 0
    2b64:	80 e0       	ldi	r24, 0x00	; 0
    2b66:	28 e0       	ldi	r18, 0x08	; 8
    2b68:	01 e0       	ldi	r16, 0x01	; 1
    2b6a:	2d c0       	rjmp	.+90     	; 0x2bc6 <SystemSetDispenser+0x180>
	      break;
	 case ST_TATSUNO:
	 	  SystemComLevel(CL_485);
    2b6c:	81 e0       	ldi	r24, 0x01	; 1
    2b6e:	0e 94 e6 01 	call	0x3cc	; 0x3cc <SystemComLevel>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2b72:	e1 99       	sbic	0x1c, 1	; 28
    2b74:	fe cf       	rjmp	.-4      	; 0x2b72 <SystemSetDispenser+0x12c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2b76:	25 e0       	ldi	r18, 0x05	; 5
    2b78:	30 e0       	ldi	r19, 0x00	; 0
    2b7a:	3f bb       	out	0x1f, r19	; 31
    2b7c:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    2b7e:	81 e0       	ldi	r24, 0x01	; 1
    2b80:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    2b82:	0f b6       	in	r0, 0x3f	; 63
    2b84:	f8 94       	cli
    2b86:	e2 9a       	sbi	0x1c, 2	; 28
    2b88:	e1 9a       	sbi	0x1c, 1	; 28
    2b8a:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2b8c:	e1 99       	sbic	0x1c, 1	; 28
    2b8e:	fe cf       	rjmp	.-4      	; 0x2b8c <SystemSetDispenser+0x146>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2b90:	3f bb       	out	0x1f, r19	; 31
    2b92:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2b94:	e0 9a       	sbi	0x1c, 0	; 28
    2b96:	8d b3       	in	r24, 0x1d	; 29
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2b98:	82 30       	cpi	r24, 0x02	; 2
    2b9a:	59 f0       	breq	.+22     	; 0x2bb2 <SystemSetDispenser+0x16c>
    2b9c:	82 30       	cpi	r24, 0x02	; 2
    2b9e:	18 f0       	brcs	.+6      	; 0x2ba6 <SystemSetDispenser+0x160>
    2ba0:	83 30       	cpi	r24, 0x03	; 3
    2ba2:	21 f4       	brne	.+8      	; 0x2bac <SystemSetDispenser+0x166>
    2ba4:	09 c0       	rjmp	.+18     	; 0x2bb8 <SystemSetDispenser+0x172>
    2ba6:	40 e8       	ldi	r20, 0x80	; 128
    2ba8:	55 e2       	ldi	r21, 0x25	; 37
    2baa:	08 c0       	rjmp	.+16     	; 0x2bbc <SystemSetDispenser+0x176>
    2bac:	40 e0       	ldi	r20, 0x00	; 0
    2bae:	50 e0       	ldi	r21, 0x00	; 0
    2bb0:	05 c0       	rjmp	.+10     	; 0x2bbc <SystemSetDispenser+0x176>
    2bb2:	40 e0       	ldi	r20, 0x00	; 0
    2bb4:	5b e4       	ldi	r21, 0x4B	; 75
    2bb6:	02 c0       	rjmp	.+4      	; 0x2bbc <SystemSetDispenser+0x176>
    2bb8:	4b e9       	ldi	r20, 0x9B	; 155
    2bba:	56 e1       	ldi	r21, 0x16	; 22
	      break;
	 case ST_TATSUNO:
	 	  SystemComLevel(CL_485);
          eeprom_write_byte(&DefBaudrate[0],br9600);
		  brValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[0]));
	      _uart_setting(0,brValue,8,P_EVEN,1);
    2bbc:	60 e0       	ldi	r22, 0x00	; 0
    2bbe:	70 e0       	ldi	r23, 0x00	; 0
    2bc0:	80 e0       	ldi	r24, 0x00	; 0
    2bc2:	28 e0       	ldi	r18, 0x08	; 8
    2bc4:	02 e0       	ldi	r16, 0x02	; 2
    2bc6:	ee 24       	eor	r14, r14
    2bc8:	e3 94       	inc	r14
    2bca:	0e 94 b5 1a 	call	0x356a	; 0x356a <_uart_setting>
	      break;
	 case ST_LG:
	      break;			  
	 }
	 InitPumpData();
    2bce:	0e 94 52 02 	call	0x4a4	; 0x4a4 <InitPumpData>
}
    2bd2:	0f 91       	pop	r16
    2bd4:	ef 90       	pop	r14
    2bd6:	08 95       	ret

00002bd8 <SystemSetSlave>:
     

return Result;
}

void SystemSetSlave(){
    2bd8:	ef 92       	push	r14
    2bda:	0f 93       	push	r16
     SystemComLevel(CL_232);
    2bdc:	80 e0       	ldi	r24, 0x00	; 0
    2bde:	0e 94 e6 01 	call	0x3cc	; 0x3cc <SystemComLevel>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2be2:	e1 99       	sbic	0x1c, 1	; 28
    2be4:	fe cf       	rjmp	.-4      	; 0x2be2 <SystemSetSlave+0xa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2be6:	86 e0       	ldi	r24, 0x06	; 6
    2be8:	90 e0       	ldi	r25, 0x00	; 0
    2bea:	9f bb       	out	0x1f, r25	; 31
    2bec:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2bee:	e0 9a       	sbi	0x1c, 0	; 28
    2bf0:	8d b3       	in	r24, 0x1d	; 29
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2bf2:	82 30       	cpi	r24, 0x02	; 2
    2bf4:	59 f0       	breq	.+22     	; 0x2c0c <SystemSetSlave+0x34>
    2bf6:	82 30       	cpi	r24, 0x02	; 2
    2bf8:	18 f0       	brcs	.+6      	; 0x2c00 <SystemSetSlave+0x28>
    2bfa:	83 30       	cpi	r24, 0x03	; 3
    2bfc:	21 f4       	brne	.+8      	; 0x2c06 <SystemSetSlave+0x2e>
    2bfe:	09 c0       	rjmp	.+18     	; 0x2c12 <SystemSetSlave+0x3a>
    2c00:	80 e8       	ldi	r24, 0x80	; 128
    2c02:	95 e2       	ldi	r25, 0x25	; 37
    2c04:	08 c0       	rjmp	.+16     	; 0x2c16 <SystemSetSlave+0x3e>
    2c06:	80 e0       	ldi	r24, 0x00	; 0
    2c08:	90 e0       	ldi	r25, 0x00	; 0
    2c0a:	05 c0       	rjmp	.+10     	; 0x2c16 <SystemSetSlave+0x3e>
    2c0c:	80 e0       	ldi	r24, 0x00	; 0
    2c0e:	9b e4       	ldi	r25, 0x4B	; 75
    2c10:	02 c0       	rjmp	.+4      	; 0x2c16 <SystemSetSlave+0x3e>
    2c12:	8b e9       	ldi	r24, 0x9B	; 155
    2c14:	96 e1       	ldi	r25, 0x16	; 22
return Result;
}

void SystemSetSlave(){
     SystemComLevel(CL_232);
     _uart_setting(1,GetBaudrate(eeprom_read_byte(&DefBaudrate[1])),8,P_NONE,1);
    2c16:	ac 01       	movw	r20, r24
    2c18:	66 27       	eor	r22, r22
    2c1a:	57 fd       	sbrc	r21, 7
    2c1c:	60 95       	com	r22
    2c1e:	76 2f       	mov	r23, r22
    2c20:	81 e0       	ldi	r24, 0x01	; 1
    2c22:	28 e0       	ldi	r18, 0x08	; 8
    2c24:	00 e0       	ldi	r16, 0x00	; 0
    2c26:	ee 24       	eor	r14, r14
    2c28:	e3 94       	inc	r14
    2c2a:	0e 94 b5 1a 	call	0x356a	; 0x356a <_uart_setting>
	 //_uart_init(0,9600);	
	 //_uart_init(1,9600);	
}
    2c2e:	0f 91       	pop	r16
    2c30:	ef 90       	pop	r14
    2c32:	08 95       	ret

00002c34 <SystemInit>:
	      break;	 
	 }
}

void SystemInit(){
	PORTA=0xFF;	DDRA=0xFF;
    2c34:	9f ef       	ldi	r25, 0xFF	; 255
    2c36:	9b bb       	out	0x1b, r25	; 27
    2c38:	9a bb       	out	0x1a, r25	; 26
	PORTE=0xFF;	DDRE=0xFF;
    2c3a:	97 b9       	out	0x07, r25	; 7
    2c3c:	96 b9       	out	0x06, r25	; 6
	DDRB= 0b01001111;//SPI Slave Input Pin-->SCK,MOSI
    2c3e:	8f e4       	ldi	r24, 0x4F	; 79
    2c40:	87 bb       	out	0x17, r24	; 23
	PORTB=0b11111111;
    2c42:	98 bb       	out	0x18, r25	; 24
	DDRD=0x00;PORTD=0b11111111;
    2c44:	11 ba       	out	0x11, r1	; 17
    2c46:	92 bb       	out	0x12, r25	; 18
	//Slave 128_SS_High
    sbi(DDRD,2);sbi(PORTD,2);
    2c48:	8a 9a       	sbi	0x11, 2	; 17
    2c4a:	92 9a       	sbi	0x12, 2	; 18
	_spi_init(0,1);
    2c4c:	80 e0       	ldi	r24, 0x00	; 0
    2c4e:	61 e0       	ldi	r22, 0x01	; 1
    2c50:	0e 94 8a 1a 	call	0x3514	; 0x3514 <_spi_init>
     sei();
	 */
}

void InitSystemTimer(){
	TCCR0 |= (1 << CS02) | (1 << CS00);
    2c54:	83 b7       	in	r24, 0x33	; 51
    2c56:	85 60       	ori	r24, 0x05	; 5
    2c58:	83 bf       	out	0x33, r24	; 51
	TIMSK |= _BV(TOIE0);
    2c5a:	89 b7       	in	r24, 0x39	; 57
    2c5c:	82 60       	ori	r24, 0x02	; 2
    2c5e:	89 bf       	out	0x39, r24	; 57
	DDRD=0x00;PORTD=0b11111111;
	//Slave 128_SS_High
    sbi(DDRD,2);sbi(PORTD,2);
	_spi_init(0,1);
	InitSystemTimer();
	sei();
    2c60:	78 94       	sei
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2c62:	e1 99       	sbic	0x1c, 1	; 28
    2c64:	fe cf       	rjmp	.-4      	; 0x2c62 <SystemInit+0x2e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2c66:	86 e0       	ldi	r24, 0x06	; 6
    2c68:	90 e0       	ldi	r25, 0x00	; 0
    2c6a:	9f bb       	out	0x1f, r25	; 31
    2c6c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2c6e:	e0 9a       	sbi	0x1c, 0	; 28
    2c70:	8d b3       	in	r24, 0x1d	; 29
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2c72:	82 30       	cpi	r24, 0x02	; 2
    2c74:	59 f0       	breq	.+22     	; 0x2c8c <SystemInit+0x58>
    2c76:	82 30       	cpi	r24, 0x02	; 2
    2c78:	18 f0       	brcs	.+6      	; 0x2c80 <SystemInit+0x4c>
    2c7a:	83 30       	cpi	r24, 0x03	; 3
    2c7c:	21 f4       	brne	.+8      	; 0x2c86 <SystemInit+0x52>
    2c7e:	09 c0       	rjmp	.+18     	; 0x2c92 <SystemInit+0x5e>
    2c80:	80 e8       	ldi	r24, 0x80	; 128
    2c82:	95 e2       	ldi	r25, 0x25	; 37
    2c84:	08 c0       	rjmp	.+16     	; 0x2c96 <SystemInit+0x62>
    2c86:	80 e0       	ldi	r24, 0x00	; 0
    2c88:	90 e0       	ldi	r25, 0x00	; 0
    2c8a:	05 c0       	rjmp	.+10     	; 0x2c96 <SystemInit+0x62>
    2c8c:	80 e0       	ldi	r24, 0x00	; 0
    2c8e:	9b e4       	ldi	r25, 0x4B	; 75
    2c90:	02 c0       	rjmp	.+4      	; 0x2c96 <SystemInit+0x62>
    2c92:	8b e9       	ldi	r24, 0x9B	; 155
    2c94:	96 e1       	ldi	r25, 0x16	; 22
	//Slave 128_SS_High
    sbi(DDRD,2);sbi(PORTD,2);
	_spi_init(0,1);
	InitSystemTimer();
	sei();
	_uart_init(1,GetBaudrate(eeprom_read_byte(&DefBaudrate[1])));
    2c96:	ac 01       	movw	r20, r24
    2c98:	66 27       	eor	r22, r22
    2c9a:	57 fd       	sbrc	r21, 7
    2c9c:	60 95       	com	r22
    2c9e:	76 2f       	mov	r23, r22
    2ca0:	81 e0       	ldi	r24, 0x01	; 1
    2ca2:	0e 94 4a 1b 	call	0x3694	; 0x3694 <_uart_init>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2ca6:	e1 99       	sbic	0x1c, 1	; 28
    2ca8:	fe cf       	rjmp	.-4      	; 0x2ca6 <SystemInit+0x72>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2caa:	80 e0       	ldi	r24, 0x00	; 0
    2cac:	90 e0       	ldi	r25, 0x00	; 0
    2cae:	9f bb       	out	0x1f, r25	; 31
    2cb0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2cb2:	e0 9a       	sbi	0x1c, 0	; 28
    2cb4:	8d b3       	in	r24, 0x1d	; 29
    IFType=eeprom_read_byte(&DefIFType);
    2cb6:	80 93 00 01 	sts	0x0100, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2cba:	e1 99       	sbic	0x1c, 1	; 28
    2cbc:	fe cf       	rjmp	.-4      	; 0x2cba <SystemInit+0x86>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2cbe:	8c e0       	ldi	r24, 0x0C	; 12
    2cc0:	90 e0       	ldi	r25, 0x00	; 0
    2cc2:	9f bb       	out	0x1f, r25	; 31
    2cc4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2cc6:	e0 9a       	sbi	0x1c, 0	; 28
    2cc8:	8d b3       	in	r24, 0x1d	; 29
    SequenceTimeout=eeprom_read_byte(&DefSequenceTimeout);
    2cca:	80 93 36 04 	sts	0x0436, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2cce:	e1 99       	sbic	0x1c, 1	; 28
    2cd0:	fe cf       	rjmp	.-4      	; 0x2cce <SystemInit+0x9a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2cd2:	83 e0       	ldi	r24, 0x03	; 3
    2cd4:	90 e0       	ldi	r25, 0x00	; 0
    2cd6:	9f bb       	out	0x1f, r25	; 31
    2cd8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2cda:	e0 9a       	sbi	0x1c, 0	; 28
    2cdc:	8d b3       	in	r24, 0x1d	; 29
	MaxPumpScanned=eeprom_read_byte(&DefPumpMaxCount);		
    2cde:	80 93 25 01 	sts	0x0125, r24

	switch(IFType){
    2ce2:	80 91 00 01 	lds	r24, 0x0100
    2ce6:	81 30       	cpi	r24, 0x01	; 1
    2ce8:	19 f0       	breq	.+6      	; 0x2cf0 <SystemInit+0xbc>
    2cea:	82 30       	cpi	r24, 0x02	; 2
    2cec:	c1 f4       	brne	.+48     	; 0x2d1e <SystemInit+0xea>
    2cee:	06 c0       	rjmp	.+12     	; 0x2cfc <SystemInit+0xc8>
	case IT_SLAVE:
	     BlinkRate=20;
    2cf0:	84 e1       	ldi	r24, 0x14	; 20
    2cf2:	80 93 11 04 	sts	0x0411, r24
	     SystemSetSlave();
    2cf6:	0e 94 ec 15 	call	0x2bd8	; 0x2bd8 <SystemSetSlave>
    2cfa:	11 c0       	rjmp	.+34     	; 0x2d1e <SystemInit+0xea>
	     break;
	case IT_STANDALONE:
	     BlinkRate=5;
    2cfc:	85 e0       	ldi	r24, 0x05	; 5
    2cfe:	80 93 11 04 	sts	0x0411, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2d02:	e1 99       	sbic	0x1c, 1	; 28
    2d04:	fe cf       	rjmp	.-4      	; 0x2d02 <SystemInit+0xce>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2d06:	81 e0       	ldi	r24, 0x01	; 1
    2d08:	90 e0       	ldi	r25, 0x00	; 0
    2d0a:	9f bb       	out	0x1f, r25	; 31
    2d0c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2d0e:	e0 9a       	sbi	0x1c, 0	; 28
    2d10:	8d b3       	in	r24, 0x1d	; 29
		 StandaloneType=eeprom_read_byte(&DefStandaloneType);
    2d12:	80 93 01 01 	sts	0x0101, r24
         SystemSetDispenser(StandaloneType);
    2d16:	80 91 01 01 	lds	r24, 0x0101
    2d1a:	0e 94 23 15 	call	0x2a46	; 0x2a46 <SystemSetDispenser>
	     break;	
	}
	InitPumpData();
    2d1e:	0e 94 52 02 	call	0x4a4	; 0x4a4 <InitPumpData>
	IsStopPoolSequence=False;
    2d22:	10 92 13 01 	sts	0x0113, r1
	 }Dest[Length]=0;
}


void StartupInfo(){
    _uart_printf(1,1,PSTR("Initialized"));
    2d26:	81 e0       	ldi	r24, 0x01	; 1
    2d28:	61 e0       	ldi	r22, 0x01	; 1
    2d2a:	4a e2       	ldi	r20, 0x2A	; 42
    2d2c:	51 e0       	ldi	r21, 0x01	; 1
    2d2e:	0e 94 b5 1b 	call	0x376a	; 0x376a <_uart_printf>
	     break;	
	}
	InitPumpData();
	IsStopPoolSequence=False;
	StartupInfo();
	System485(DIR_RX);//ReceiveMode
    2d32:	82 e0       	ldi	r24, 0x02	; 2
    2d34:	0e 94 21 02 	call	0x442	; 0x442 <System485>
}
    2d38:	08 95       	ret

00002d3a <main>:
	 if (IFType==IT_SLAVE)//EDC Line Protocol
	    _uart(0,1,dataSPI);
	 ScanStandaloneFlow(dataSPI);	 
}

void main (){
    2d3a:	1f 93       	push	r17
	SystemInit();
    2d3c:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <SystemInit>
		    TimWatchSequence=0;
		}
        if (TimWatchSequence>SequenceTimeout){
		    TimWatchSequence=0; 
		    //SendAcknoledge(SC_FREEZE,SequenceTimeout);
		    IsRestartPooling=True;
    2d40:	11 e0       	ldi	r17, 0x01	; 1

void systemAntiFreeze(){
static char zSequence=0;

	if (IFType==IT_STANDALONE){
	    if (SequencePool>zSequence){
    2d42:	30 91 26 01 	lds	r19, 0x0126
		    TimWatchSequence=0;
		}
        if (TimWatchSequence>SequenceTimeout){
    2d46:	40 91 36 04 	lds	r20, 0x0436
    2d4a:	20 91 de 02 	lds	r18, 0x02DE
    2d4e:	90 91 35 01 	lds	r25, 0x0135
	SystemInit();

   // SystemComLevel(CL_232);
	//_uart_init(1,19200);
	while(1){	   
	   switch(IFType){
    2d52:	80 91 00 01 	lds	r24, 0x0100
    2d56:	82 30       	cpi	r24, 0x02	; 2
    2d58:	e1 f7       	brne	.-8      	; 0x2d52 <main+0x18>
//15694 95.8% -> 14746 90.0%

void systemAntiFreeze(){
static char zSequence=0;

	if (IFType==IT_STANDALONE){
    2d5a:	80 91 00 01 	lds	r24, 0x0100
    2d5e:	82 30       	cpi	r24, 0x02	; 2
    2d60:	41 f4       	brne	.+16     	; 0x2d72 <main+0x38>
	    if (SequencePool>zSequence){
    2d62:	93 17       	cp	r25, r19
    2d64:	20 f0       	brcs	.+8      	; 0x2d6e <main+0x34>
		    TimWatchSequence=0;
		}
        if (TimWatchSequence>SequenceTimeout){
    2d66:	42 17       	cp	r20, r18
    2d68:	18 f4       	brcc	.+6      	; 0x2d70 <main+0x36>
		    TimWatchSequence=0; 
		    //SendAcknoledge(SC_FREEZE,SequenceTimeout);
		    IsRestartPooling=True;
    2d6a:	10 93 03 01 	sts	0x0103, r17
    2d6e:	20 e0       	ldi	r18, 0x00	; 0
    2d70:	93 2f       	mov	r25, r19
	   switch(IFType){
	   case IT_SLAVE:
	        break;
	   case IT_STANDALONE:
	        systemAntiFreeze();//15714 15724			
			switch(StandaloneType){
    2d72:	80 91 01 01 	lds	r24, 0x0101
    2d76:	81 30       	cpi	r24, 0x01	; 1
    2d78:	19 f0       	breq	.+6      	; 0x2d80 <main+0x46>
    2d7a:	82 30       	cpi	r24, 0x02	; 2
    2d7c:	51 f7       	brne	.-44     	; 0x2d52 <main+0x18>
    2d7e:	07 c0       	rjmp	.+14     	; 0x2d8e <main+0x54>
    2d80:	20 93 de 02 	sts	0x02DE, r18
    2d84:	90 93 35 01 	sts	0x0135, r25
			case ST_GILBARCO:
			     FPoolingPump();
    2d88:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <FPoolingPump>
    2d8c:	da cf       	rjmp	.-76     	; 0x2d42 <main+0x8>
			     break;
    2d8e:	20 93 de 02 	sts	0x02DE, r18
    2d92:	90 93 35 01 	sts	0x0135, r25
            case ST_WAYNE_DART:
                 FPoolingPump2(); 
    2d96:	0e 94 5d 11 	call	0x22ba	; 0x22ba <FPoolingPump2>
    2d9a:	d3 cf       	rjmp	.-90     	; 0x2d42 <main+0x8>

00002d9c <ScanStandaloneFlow>:
     	  break;	 
	 }
   return Result;
}

void ScanStandaloneFlow(char xData){//<STX>[CMD][MSG]<ETX>: 0x05 0x06
    2d9c:	9f 92       	push	r9
    2d9e:	af 92       	push	r10
    2da0:	bf 92       	push	r11
    2da2:	cf 92       	push	r12
    2da4:	df 92       	push	r13
    2da6:	ef 92       	push	r14
    2da8:	ff 92       	push	r15
    2daa:	0f 93       	push	r16
    2dac:	df 93       	push	r29
    2dae:	cf 93       	push	r28
    2db0:	cd b7       	in	r28, 0x3d	; 61
    2db2:	de b7       	in	r29, 0x3e	; 62
    2db4:	64 97       	sbiw	r28, 0x14	; 20
    2db6:	0f b6       	in	r0, 0x3f	; 63
    2db8:	f8 94       	cli
    2dba:	de bf       	out	0x3e, r29	; 62
    2dbc:	0f be       	out	0x3f, r0	; 63
    2dbe:	cd bf       	out	0x3d, r28	; 61
     char slaveCmd,slaveMsg;        //            0x02:STANDALONE  		 0x00:NONE 0x01:GILBARCO 0x02:TATSUNO 0x03:LG 0x04:WYNE
     char ComPort,ComBaud,i;          //          0x03:DIAGNOSTIC
	 unsigned int brValue;
	 char strSend[20];
     slaveCmd=0;slaveMsg=0;         //            0x04:Totalizer
	 zFlowData[3]=zFlowData[2];     //            0x05:Baudrate
    2dc0:	90 91 38 01 	lds	r25, 0x0138
    2dc4:	90 93 39 01 	sts	0x0139, r25
	 zFlowData[2]=zFlowData[1];     //            0x06:DebugTerminal:-->dtOn/dtOff
    2dc8:	90 90 37 01 	lds	r9, 0x0137
    2dcc:	90 92 38 01 	sts	0x0138, r9
	 zFlowData[1]=zFlowData[0];
    2dd0:	00 91 36 01 	lds	r16, 0x0136
    2dd4:	00 93 37 01 	sts	0x0137, r16
	 zFlowData[0]=xData;
    2dd8:	80 93 36 01 	sts	0x0136, r24
	 //Scan SatndaloneMode Switch Command
	 if((zFlowData[0]==0x06)&(zFlowData[3]==0x05)){
    2ddc:	86 30       	cpi	r24, 0x06	; 6
    2dde:	09 f0       	breq	.+2      	; 0x2de2 <ScanStandaloneFlow+0x46>
    2de0:	57 c3       	rjmp	.+1710   	; 0x3490 <ScanStandaloneFlow+0x6f4>
    2de2:	95 30       	cpi	r25, 0x05	; 5
    2de4:	09 f0       	breq	.+2      	; 0x2de8 <ScanStandaloneFlow+0x4c>
    2de6:	54 c3       	rjmp	.+1704   	; 0x3490 <ScanStandaloneFlow+0x6f4>
         slaveCmd=zFlowData[2];
         slaveMsg=zFlowData[1];
    2de8:	c0 2e       	mov	r12, r16

		 switch(slaveCmd){
    2dea:	89 2d       	mov	r24, r9
    2dec:	90 e0       	ldi	r25, 0x00	; 0
    2dee:	fc 01       	movw	r30, r24
    2df0:	31 97       	sbiw	r30, 0x01	; 1
    2df2:	e0 32       	cpi	r30, 0x20	; 32
    2df4:	f1 05       	cpc	r31, r1
    2df6:	08 f0       	brcs	.+2      	; 0x2dfa <ScanStandaloneFlow+0x5e>
    2df8:	47 c3       	rjmp	.+1678   	; 0x3488 <ScanStandaloneFlow+0x6ec>
    2dfa:	eb 58       	subi	r30, 0x8B	; 139
    2dfc:	ff 4f       	sbci	r31, 0xFF	; 255
    2dfe:	ee 0f       	add	r30, r30
    2e00:	ff 1f       	adc	r31, r31
    2e02:	05 90       	lpm	r0, Z+
    2e04:	f4 91       	lpm	r31, Z+
    2e06:	e0 2d       	mov	r30, r0
    2e08:	09 94       	ijmp
		 case SC_SLAVE:		      
		      IFType=IT_SLAVE;
    2e0a:	81 e0       	ldi	r24, 0x01	; 1
    2e0c:	80 93 00 01 	sts	0x0100, r24
			  BlinkRate=20;
    2e10:	84 e1       	ldi	r24, 0x14	; 20
    2e12:	80 93 11 04 	sts	0x0411, r24
			  eeprom_write_byte(&DefIFType,IFType);
    2e16:	20 91 00 01 	lds	r18, 0x0100
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2e1a:	e1 99       	sbic	0x1c, 1	; 28
    2e1c:	fe cf       	rjmp	.-4      	; 0x2e1a <ScanStandaloneFlow+0x7e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2e1e:	80 e0       	ldi	r24, 0x00	; 0
    2e20:	90 e0       	ldi	r25, 0x00	; 0
    2e22:	9f bb       	out	0x1f, r25	; 31
    2e24:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2e26:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    2e28:	0f b6       	in	r0, 0x3f	; 63
    2e2a:	f8 94       	cli
    2e2c:	e2 9a       	sbi	0x1c, 2	; 28
    2e2e:	e1 9a       	sbi	0x1c, 1	; 28
    2e30:	0f be       	out	0x3f, r0	; 63
			  #ifdef DEBUG_CMD_TERM 
			  TerminalSendf(1,PSTR("Slave"));		
    2e32:	81 e0       	ldi	r24, 0x01	; 1
    2e34:	6c e9       	ldi	r22, 0x9C	; 156
    2e36:	72 e0       	ldi	r23, 0x02	; 2
    2e38:	0e 94 20 0c 	call	0x1840	; 0x1840 <TerminalSendf>
			  #endif
			  SystemSetSlave();			  		 
    2e3c:	0e 94 ec 15 	call	0x2bd8	; 0x2bd8 <SystemSetSlave>
    2e40:	23 c3       	rjmp	.+1606   	; 0x3488 <ScanStandaloneFlow+0x6ec>
		      break;
         case SC_STANDALONE:
		      InitPumpData();		      
    2e42:	0e 94 52 02 	call	0x4a4	; 0x4a4 <InitPumpData>
		      IFType=IT_STANDALONE;
    2e46:	82 e0       	ldi	r24, 0x02	; 2
    2e48:	80 93 00 01 	sts	0x0100, r24
			  BlinkRate=5;
    2e4c:	85 e0       	ldi	r24, 0x05	; 5
    2e4e:	80 93 11 04 	sts	0x0411, r24
			  eeprom_write_byte(&DefIFType,IFType);
    2e52:	20 91 00 01 	lds	r18, 0x0100
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2e56:	e1 99       	sbic	0x1c, 1	; 28
    2e58:	fe cf       	rjmp	.-4      	; 0x2e56 <ScanStandaloneFlow+0xba>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2e5a:	80 e0       	ldi	r24, 0x00	; 0
    2e5c:	90 e0       	ldi	r25, 0x00	; 0
    2e5e:	9f bb       	out	0x1f, r25	; 31
    2e60:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2e62:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    2e64:	0f b6       	in	r0, 0x3f	; 63
    2e66:	f8 94       	cli
    2e68:	e2 9a       	sbi	0x1c, 2	; 28
    2e6a:	e1 9a       	sbi	0x1c, 1	; 28
    2e6c:	0f be       	out	0x3f, r0	; 63
			  #ifdef DEBUG_CMD_TERM 
			  TerminalSendf(1,PSTR("Standalone"));
    2e6e:	81 e0       	ldi	r24, 0x01	; 1
    2e70:	61 e9       	ldi	r22, 0x91	; 145
    2e72:	72 e0       	ldi	r23, 0x02	; 2
    2e74:	0e 94 20 0c 	call	0x1840	; 0x1840 <TerminalSendf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2e78:	e1 99       	sbic	0x1c, 1	; 28
    2e7a:	fe cf       	rjmp	.-4      	; 0x2e78 <ScanStandaloneFlow+0xdc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2e7c:	81 e0       	ldi	r24, 0x01	; 1
    2e7e:	90 e0       	ldi	r25, 0x00	; 0
    2e80:	9f bb       	out	0x1f, r25	; 31
    2e82:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2e84:	e0 9a       	sbi	0x1c, 0	; 28
    2e86:	8d b3       	in	r24, 0x1d	; 29
			  #endif
			  StandaloneType=eeprom_read_byte(&DefStandaloneType);
    2e88:	80 93 01 01 	sts	0x0101, r24
              //StandaloneType=ST_WAYNE_DART;
              SystemSetDispenser(StandaloneType);
    2e8c:	80 91 01 01 	lds	r24, 0x0101
    2e90:	0e 94 23 15 	call	0x2a46	; 0x2a46 <SystemSetDispenser>
    2e94:	a1 c1       	rjmp	.+834    	; 0x31d8 <ScanStandaloneFlow+0x43c>
			  //_uart_init(0,GetBaudrate(eeprom_read_byte(&DefBaudrate[0])));
			  //if (slaveMsg<=0x04)StandaloneType=slaveMsg;

		      break;
         case SC_SET_PUMP_TYPE:
		      IFType=IT_STANDALONE;
    2e96:	82 e0       	ldi	r24, 0x02	; 2
    2e98:	80 93 00 01 	sts	0x0100, r24
			  BlinkRate=5;
    2e9c:	85 e0       	ldi	r24, 0x05	; 5
    2e9e:	80 93 11 04 	sts	0x0411, r24
              StandaloneType=slaveMsg;
    2ea2:	00 93 01 01 	sts	0x0101, r16
		      eeprom_write_byte(&DefStandaloneType,StandaloneType);			  		      
    2ea6:	20 91 01 01 	lds	r18, 0x0101
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2eaa:	e1 99       	sbic	0x1c, 1	; 28
    2eac:	fe cf       	rjmp	.-4      	; 0x2eaa <ScanStandaloneFlow+0x10e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2eae:	81 e0       	ldi	r24, 0x01	; 1
    2eb0:	90 e0       	ldi	r25, 0x00	; 0
    2eb2:	9f bb       	out	0x1f, r25	; 31
    2eb4:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2eb6:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    2eb8:	0f b6       	in	r0, 0x3f	; 63
    2eba:	f8 94       	cli
    2ebc:	e2 9a       	sbi	0x1c, 2	; 28
    2ebe:	e1 9a       	sbi	0x1c, 1	; 28
    2ec0:	0f be       	out	0x3f, r0	; 63
			  sprintf_P(strSend,PSTR("Pump:%d"),StandaloneType);
    2ec2:	20 91 01 01 	lds	r18, 0x0101
    2ec6:	00 d0       	rcall	.+0      	; 0x2ec8 <ScanStandaloneFlow+0x12c>
    2ec8:	00 d0       	rcall	.+0      	; 0x2eca <ScanStandaloneFlow+0x12e>
    2eca:	00 d0       	rcall	.+0      	; 0x2ecc <ScanStandaloneFlow+0x130>
    2ecc:	ed b7       	in	r30, 0x3d	; 61
    2ece:	fe b7       	in	r31, 0x3e	; 62
    2ed0:	31 96       	adiw	r30, 0x01	; 1
    2ed2:	7e 01       	movw	r14, r28
    2ed4:	08 94       	sec
    2ed6:	e1 1c       	adc	r14, r1
    2ed8:	f1 1c       	adc	r15, r1
    2eda:	ad b7       	in	r26, 0x3d	; 61
    2edc:	be b7       	in	r27, 0x3e	; 62
    2ede:	12 96       	adiw	r26, 0x02	; 2
    2ee0:	fc 92       	st	X, r15
    2ee2:	ee 92       	st	-X, r14
    2ee4:	11 97       	sbiw	r26, 0x01	; 1
    2ee6:	89 e8       	ldi	r24, 0x89	; 137
    2ee8:	92 e0       	ldi	r25, 0x02	; 2
    2eea:	93 83       	std	Z+3, r25	; 0x03
    2eec:	82 83       	std	Z+2, r24	; 0x02
    2eee:	24 83       	std	Z+4, r18	; 0x04
    2ef0:	15 82       	std	Z+5, r1	; 0x05
    2ef2:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
              SystemSetDispenser(StandaloneType);
    2ef6:	80 91 01 01 	lds	r24, 0x0101
    2efa:	2d b7       	in	r18, 0x3d	; 61
    2efc:	3e b7       	in	r19, 0x3e	; 62
    2efe:	2a 5f       	subi	r18, 0xFA	; 250
    2f00:	3f 4f       	sbci	r19, 0xFF	; 255
    2f02:	0f b6       	in	r0, 0x3f	; 63
    2f04:	f8 94       	cli
    2f06:	3e bf       	out	0x3e, r19	; 62
    2f08:	0f be       	out	0x3f, r0	; 63
    2f0a:	2d bf       	out	0x3d, r18	; 61
    2f0c:	0e 94 23 15 	call	0x2a46	; 0x2a46 <SystemSetDispenser>
			  #ifdef DEBUG_CMD_TERM 
			  _uart_printf(1,1,PSTR("SC_SET_PUMP_TYPE"));
    2f10:	81 e0       	ldi	r24, 0x01	; 1
    2f12:	61 e0       	ldi	r22, 0x01	; 1
    2f14:	48 e7       	ldi	r20, 0x78	; 120
    2f16:	52 e0       	ldi	r21, 0x02	; 2
    2f18:	0e 94 b5 1b 	call	0x376a	; 0x376a <_uart_printf>
			  _uart_print(1,1,strSend);
    2f1c:	81 e0       	ldi	r24, 0x01	; 1
    2f1e:	61 e0       	ldi	r22, 0x01	; 1
    2f20:	a7 01       	movw	r20, r14
    2f22:	0e 94 8d 1b 	call	0x371a	; 0x371a <_uart_print>
    2f26:	58 c1       	rjmp	.+688    	; 0x31d8 <ScanStandaloneFlow+0x43c>
			  #endif
			  IsRestartPooling=True;
		      break;
         case SC_TOTALIZER:
		      #ifdef DEBUG_CMD_TERM 
		      _uart_printf(1,1,PSTR("SC_TOTALIZER"));
    2f28:	81 e0       	ldi	r24, 0x01	; 1
    2f2a:	61 e0       	ldi	r22, 0x01	; 1
    2f2c:	4b e6       	ldi	r20, 0x6B	; 107
    2f2e:	52 e0       	ldi	r21, 0x02	; 2
    2f30:	0e 94 b5 1b 	call	0x376a	; 0x376a <_uart_printf>
			  #endif
		      if ((slaveMsg>=1)&&(slaveMsg<=16)){
    2f34:	80 2f       	mov	r24, r16
    2f36:	81 50       	subi	r24, 0x01	; 1
    2f38:	80 31       	cpi	r24, 0x10	; 16
    2f3a:	48 f4       	brcc	.+18     	; 0x2f4e <ScanStandaloneFlow+0x1b2>
		           IsRequestTotalizerInfo[(slaveMsg&0x0F)]=True;
    2f3c:	e0 2f       	mov	r30, r16
    2f3e:	f0 e0       	ldi	r31, 0x00	; 0
    2f40:	ef 70       	andi	r30, 0x0F	; 15
    2f42:	f0 70       	andi	r31, 0x00	; 0
    2f44:	ed 5e       	subi	r30, 0xED	; 237
    2f46:	fb 4f       	sbci	r31, 0xFB	; 251
    2f48:	81 e0       	ldi	r24, 0x01	; 1
    2f4a:	80 83       	st	Z, r24
    2f4c:	9d c2       	rjmp	.+1338   	; 0x3488 <ScanStandaloneFlow+0x6ec>
				  }
			  else if (slaveMsg==PUMP_ALL){
    2f4e:	02 31       	cpi	r16, 0x12	; 18
    2f50:	09 f0       	breq	.+2      	; 0x2f54 <ScanStandaloneFlow+0x1b8>
    2f52:	9a c2       	rjmp	.+1332   	; 0x3488 <ScanStandaloneFlow+0x6ec>
		           #ifdef DEBUG_CMD_TERM 
				   _uart_printf(1,1,PSTR("PUMPALL"));
    2f54:	81 e0       	ldi	r24, 0x01	; 1
    2f56:	61 e0       	ldi	r22, 0x01	; 1
    2f58:	43 e6       	ldi	r20, 0x63	; 99
    2f5a:	52 e0       	ldi	r21, 0x02	; 2
    2f5c:	0e 94 b5 1b 	call	0x376a	; 0x376a <_uart_printf>
    2f60:	81 e0       	ldi	r24, 0x01	; 1
    2f62:	90 e0       	ldi	r25, 0x00	; 0
				   #endif
				   for (i=1;i<=16;i++)IsRequestTotalizerInfo[(i&0x0F)]=True;
    2f64:	21 e0       	ldi	r18, 0x01	; 1
    2f66:	fc 01       	movw	r30, r24
    2f68:	ef 70       	andi	r30, 0x0F	; 15
    2f6a:	f0 70       	andi	r31, 0x00	; 0
    2f6c:	ed 5e       	subi	r30, 0xED	; 237
    2f6e:	fb 4f       	sbci	r31, 0xFB	; 251
    2f70:	20 83       	st	Z, r18
    2f72:	01 96       	adiw	r24, 0x01	; 1
    2f74:	81 31       	cpi	r24, 0x11	; 17
    2f76:	91 05       	cpc	r25, r1
    2f78:	b1 f7       	brne	.-20     	; 0x2f66 <ScanStandaloneFlow+0x1ca>
    2f7a:	86 c2       	rjmp	.+1292   	; 0x3488 <ScanStandaloneFlow+0x6ec>
				  }				  	     
		      break; 
         case SC_BAUDRATE:
		      ComPort=(slaveMsg>>4)-3;//3..4
    2f7c:	d0 2e       	mov	r13, r16
    2f7e:	d2 94       	swap	r13
    2f80:	8f e0       	ldi	r24, 0x0F	; 15
    2f82:	d8 22       	and	r13, r24
    2f84:	3d ef       	ldi	r19, 0xFD	; 253
    2f86:	d3 0e       	add	r13, r19
			  ComBaud=(slaveMsg&0x0F);//0,1,2,3
    2f88:	e0 2f       	mov	r30, r16
    2f8a:	ef 70       	andi	r30, 0x0F	; 15
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2f8c:	e2 30       	cpi	r30, 0x02	; 2
    2f8e:	61 f0       	breq	.+24     	; 0x2fa8 <ScanStandaloneFlow+0x20c>
    2f90:	e2 30       	cpi	r30, 0x02	; 2
    2f92:	28 f0       	brcs	.+10     	; 0x2f9e <ScanStandaloneFlow+0x202>
    2f94:	e3 30       	cpi	r30, 0x03	; 3
    2f96:	61 f0       	breq	.+24     	; 0x2fb0 <ScanStandaloneFlow+0x214>
    2f98:	ee 24       	eor	r14, r14
    2f9a:	ff 24       	eor	r15, r15
    2f9c:	0d c0       	rjmp	.+26     	; 0x2fb8 <ScanStandaloneFlow+0x21c>
    2f9e:	b0 e8       	ldi	r27, 0x80	; 128
    2fa0:	eb 2e       	mov	r14, r27
    2fa2:	b5 e2       	ldi	r27, 0x25	; 37
    2fa4:	fb 2e       	mov	r15, r27
    2fa6:	08 c0       	rjmp	.+16     	; 0x2fb8 <ScanStandaloneFlow+0x21c>
    2fa8:	e1 2c       	mov	r14, r1
    2faa:	ab e4       	ldi	r26, 0x4B	; 75
    2fac:	fa 2e       	mov	r15, r26
    2fae:	04 c0       	rjmp	.+8      	; 0x2fb8 <ScanStandaloneFlow+0x21c>
    2fb0:	fb e9       	ldi	r31, 0x9B	; 155
    2fb2:	ef 2e       	mov	r14, r31
    2fb4:	f6 e1       	ldi	r31, 0x16	; 22
    2fb6:	ff 2e       	mov	r15, r31
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2fb8:	e1 99       	sbic	0x1c, 1	; 28
    2fba:	fe cf       	rjmp	.-4      	; 0x2fb8 <ScanStandaloneFlow+0x21c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2fbc:	8d 2d       	mov	r24, r13
    2fbe:	90 e0       	ldi	r25, 0x00	; 0
    2fc0:	8b 5f       	subi	r24, 0xFB	; 251
    2fc2:	9f 4f       	sbci	r25, 0xFF	; 255
    2fc4:	9f bb       	out	0x1f, r25	; 31
    2fc6:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2fc8:	ed bb       	out	0x1d, r30	; 29

    __asm__ __volatile__ (
    2fca:	0f b6       	in	r0, 0x3f	; 63
    2fcc:	f8 94       	cli
    2fce:	e2 9a       	sbi	0x1c, 2	; 28
    2fd0:	e1 9a       	sbi	0x1c, 1	; 28
    2fd2:	0f be       	out	0x3f, r0	; 63
		      ComPort=(slaveMsg>>4)-3;//3..4
			  ComBaud=(slaveMsg&0x0F);//0,1,2,3
			  brValue=GetBaudrate(ComBaud);
			  eeprom_write_byte(&DefBaudrate[ComPort],ComBaud);
			  #ifdef DEBUG_CMD_TERM 
 			  sprintf_P(strSend,PSTR("COM:%d,%i"),ComPort,brValue);
    2fd4:	8d b7       	in	r24, 0x3d	; 61
    2fd6:	9e b7       	in	r25, 0x3e	; 62
    2fd8:	08 97       	sbiw	r24, 0x08	; 8
    2fda:	0f b6       	in	r0, 0x3f	; 63
    2fdc:	f8 94       	cli
    2fde:	9e bf       	out	0x3e, r25	; 62
    2fe0:	0f be       	out	0x3f, r0	; 63
    2fe2:	8d bf       	out	0x3d, r24	; 61
    2fe4:	ed b7       	in	r30, 0x3d	; 61
    2fe6:	fe b7       	in	r31, 0x3e	; 62
    2fe8:	31 96       	adiw	r30, 0x01	; 1
    2fea:	5e 01       	movw	r10, r28
    2fec:	08 94       	sec
    2fee:	a1 1c       	adc	r10, r1
    2ff0:	b1 1c       	adc	r11, r1
    2ff2:	ad b7       	in	r26, 0x3d	; 61
    2ff4:	be b7       	in	r27, 0x3e	; 62
    2ff6:	12 96       	adiw	r26, 0x02	; 2
    2ff8:	bc 92       	st	X, r11
    2ffa:	ae 92       	st	-X, r10
    2ffc:	11 97       	sbiw	r26, 0x01	; 1
    2ffe:	89 e5       	ldi	r24, 0x59	; 89
    3000:	92 e0       	ldi	r25, 0x02	; 2
    3002:	93 83       	std	Z+3, r25	; 0x03
    3004:	82 83       	std	Z+2, r24	; 0x02
    3006:	d4 82       	std	Z+4, r13	; 0x04
    3008:	15 82       	std	Z+5, r1	; 0x05
    300a:	f7 82       	std	Z+7, r15	; 0x07
    300c:	e6 82       	std	Z+6, r14	; 0x06
    300e:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
			  TerminalSend(1,strSend);
    3012:	2d b7       	in	r18, 0x3d	; 61
    3014:	3e b7       	in	r19, 0x3e	; 62
    3016:	28 5f       	subi	r18, 0xF8	; 248
    3018:	3f 4f       	sbci	r19, 0xFF	; 255
    301a:	0f b6       	in	r0, 0x3f	; 63
    301c:	f8 94       	cli
    301e:	3e bf       	out	0x3e, r19	; 62
    3020:	0f be       	out	0x3f, r0	; 63
    3022:	2d bf       	out	0x3d, r18	; 61
    3024:	81 e0       	ldi	r24, 0x01	; 1
    3026:	b5 01       	movw	r22, r10
    3028:	0e 94 12 15 	call	0x2a24	; 0x2a24 <TerminalSend>
			  #endif
			  _uart_init(ComPort,brValue);
    302c:	a7 01       	movw	r20, r14
    302e:	60 e0       	ldi	r22, 0x00	; 0
    3030:	70 e0       	ldi	r23, 0x00	; 0
    3032:	8d 2d       	mov	r24, r13
    3034:	0e 94 4a 1b 	call	0x3694	; 0x3694 <_uart_init>
    3038:	27 c2       	rjmp	.+1102   	; 0x3488 <ScanStandaloneFlow+0x6ec>
		      break;
		 case SC_TRANSACTION:
		          if (slaveMsg<=16)IsRequestTotalizerInfo[slaveMsg&0x0F]=True;
    303a:	01 31       	cpi	r16, 0x11	; 17
    303c:	48 f4       	brcc	.+18     	; 0x3050 <ScanStandaloneFlow+0x2b4>
    303e:	e0 2f       	mov	r30, r16
    3040:	f0 e0       	ldi	r31, 0x00	; 0
    3042:	ef 70       	andi	r30, 0x0F	; 15
    3044:	f0 70       	andi	r31, 0x00	; 0
    3046:	ed 5e       	subi	r30, 0xED	; 237
    3048:	fb 4f       	sbci	r31, 0xFB	; 251
    304a:	81 e0       	ldi	r24, 0x01	; 1
    304c:	80 83       	st	Z, r24
    304e:	0f c0       	rjmp	.+30     	; 0x306e <ScanStandaloneFlow+0x2d2>
				  else 
				  if (slaveMsg==PUMP_ALL){
    3050:	02 31       	cpi	r16, 0x12	; 18
    3052:	69 f4       	brne	.+26     	; 0x306e <ScanStandaloneFlow+0x2d2>
    3054:	81 e0       	ldi	r24, 0x01	; 1
    3056:	90 e0       	ldi	r25, 0x00	; 0
				      for(i=1;i<=16;i++){
					      IsRequestTotalizerInfo[i&0x0F]=True;
    3058:	21 e0       	ldi	r18, 0x01	; 1
    305a:	fc 01       	movw	r30, r24
    305c:	ef 70       	andi	r30, 0x0F	; 15
    305e:	f0 70       	andi	r31, 0x00	; 0
    3060:	ed 5e       	subi	r30, 0xED	; 237
    3062:	fb 4f       	sbci	r31, 0xFB	; 251
    3064:	20 83       	st	Z, r18
    3066:	01 96       	adiw	r24, 0x01	; 1
		      break;
		 case SC_TRANSACTION:
		          if (slaveMsg<=16)IsRequestTotalizerInfo[slaveMsg&0x0F]=True;
				  else 
				  if (slaveMsg==PUMP_ALL){
				      for(i=1;i<=16;i++){
    3068:	81 31       	cpi	r24, 0x11	; 17
    306a:	91 05       	cpc	r25, r1
    306c:	b1 f7       	brne	.-20     	; 0x305a <ScanStandaloneFlow+0x2be>
					      IsRequestTotalizerInfo[i&0x0F]=True;
					  }  
				  }
              #ifdef DEBUG_CMD_TERM 
				 sprintf_P(strSend,PSTR("ReqTrans:%d"),slaveMsg);
    306e:	00 d0       	rcall	.+0      	; 0x3070 <ScanStandaloneFlow+0x2d4>
    3070:	00 d0       	rcall	.+0      	; 0x3072 <ScanStandaloneFlow+0x2d6>
    3072:	00 d0       	rcall	.+0      	; 0x3074 <ScanStandaloneFlow+0x2d8>
    3074:	ed b7       	in	r30, 0x3d	; 61
    3076:	fe b7       	in	r31, 0x3e	; 62
    3078:	31 96       	adiw	r30, 0x01	; 1
    307a:	7e 01       	movw	r14, r28
    307c:	08 94       	sec
    307e:	e1 1c       	adc	r14, r1
    3080:	f1 1c       	adc	r15, r1
    3082:	ad b7       	in	r26, 0x3d	; 61
    3084:	be b7       	in	r27, 0x3e	; 62
    3086:	12 96       	adiw	r26, 0x02	; 2
    3088:	fc 92       	st	X, r15
    308a:	ee 92       	st	-X, r14
    308c:	11 97       	sbiw	r26, 0x01	; 1
    308e:	8d e4       	ldi	r24, 0x4D	; 77
    3090:	92 e0       	ldi	r25, 0x02	; 2
    3092:	2c c0       	rjmp	.+88     	; 0x30ec <ScanStandaloneFlow+0x350>
				 TerminalSend(1,strSend);
              #endif
		      break;     
         case SC_PUMP_LOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=True;
    3094:	01 31       	cpi	r16, 0x11	; 17
    3096:	48 f4       	brcc	.+18     	; 0x30aa <ScanStandaloneFlow+0x30e>
    3098:	e0 2f       	mov	r30, r16
    309a:	f0 e0       	ldi	r31, 0x00	; 0
    309c:	ef 70       	andi	r30, 0x0F	; 15
    309e:	f0 70       	andi	r31, 0x00	; 0
    30a0:	e4 53       	subi	r30, 0x34	; 52
    30a2:	fd 4f       	sbci	r31, 0xFD	; 253
    30a4:	81 e0       	ldi	r24, 0x01	; 1
    30a6:	80 83       	st	Z, r24
    30a8:	0f c0       	rjmp	.+30     	; 0x30c8 <ScanStandaloneFlow+0x32c>
				  else 
				  if (slaveMsg==PUMP_ALL){
    30aa:	02 31       	cpi	r16, 0x12	; 18
    30ac:	69 f4       	brne	.+26     	; 0x30c8 <ScanStandaloneFlow+0x32c>
    30ae:	81 e0       	ldi	r24, 0x01	; 1
    30b0:	90 e0       	ldi	r25, 0x00	; 0
				      for(i=1;i<=16;i++){
					      PumpLock[i&0x0F]=True;
    30b2:	21 e0       	ldi	r18, 0x01	; 1
    30b4:	fc 01       	movw	r30, r24
    30b6:	ef 70       	andi	r30, 0x0F	; 15
    30b8:	f0 70       	andi	r31, 0x00	; 0
    30ba:	e4 53       	subi	r30, 0x34	; 52
    30bc:	fd 4f       	sbci	r31, 0xFD	; 253
    30be:	20 83       	st	Z, r18
    30c0:	01 96       	adiw	r24, 0x01	; 1
		      break;     
         case SC_PUMP_LOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=True;
				  else 
				  if (slaveMsg==PUMP_ALL){
				      for(i=1;i<=16;i++){
    30c2:	81 31       	cpi	r24, 0x11	; 17
    30c4:	91 05       	cpc	r25, r1
    30c6:	b1 f7       	brne	.-20     	; 0x30b4 <ScanStandaloneFlow+0x318>
					      PumpLock[i&0x0F]=True;
					  }  
				  }
               #ifdef DEBUG_CMD_TERM 
				 sprintf_P(strSend,PSTR("PumpLock:%d"),slaveMsg);
    30c8:	00 d0       	rcall	.+0      	; 0x30ca <ScanStandaloneFlow+0x32e>
    30ca:	00 d0       	rcall	.+0      	; 0x30cc <ScanStandaloneFlow+0x330>
    30cc:	00 d0       	rcall	.+0      	; 0x30ce <ScanStandaloneFlow+0x332>
    30ce:	ed b7       	in	r30, 0x3d	; 61
    30d0:	fe b7       	in	r31, 0x3e	; 62
    30d2:	31 96       	adiw	r30, 0x01	; 1
    30d4:	7e 01       	movw	r14, r28
    30d6:	08 94       	sec
    30d8:	e1 1c       	adc	r14, r1
    30da:	f1 1c       	adc	r15, r1
    30dc:	ad b7       	in	r26, 0x3d	; 61
    30de:	be b7       	in	r27, 0x3e	; 62
    30e0:	12 96       	adiw	r26, 0x02	; 2
    30e2:	fc 92       	st	X, r15
    30e4:	ee 92       	st	-X, r14
    30e6:	11 97       	sbiw	r26, 0x01	; 1
    30e8:	81 e4       	ldi	r24, 0x41	; 65
    30ea:	92 e0       	ldi	r25, 0x02	; 2
    30ec:	93 83       	std	Z+3, r25	; 0x03
    30ee:	82 83       	std	Z+2, r24	; 0x02
    30f0:	04 83       	std	Z+4, r16	; 0x04
    30f2:	15 82       	std	Z+5, r1	; 0x05
    30f4:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
				 TerminalSend(1,strSend);
    30f8:	2d b7       	in	r18, 0x3d	; 61
    30fa:	3e b7       	in	r19, 0x3e	; 62
    30fc:	2a 5f       	subi	r18, 0xFA	; 250
    30fe:	3f 4f       	sbci	r19, 0xFF	; 255
    3100:	0f b6       	in	r0, 0x3f	; 63
    3102:	f8 94       	cli
    3104:	3e bf       	out	0x3e, r19	; 62
    3106:	0f be       	out	0x3f, r0	; 63
    3108:	2d bf       	out	0x3d, r18	; 61
    310a:	81 e0       	ldi	r24, 0x01	; 1
    310c:	b7 01       	movw	r22, r14
    310e:	0e 94 12 15 	call	0x2a24	; 0x2a24 <TerminalSend>
    3112:	ba c1       	rjmp	.+884    	; 0x3488 <ScanStandaloneFlow+0x6ec>
              #endif
		      break;
         case SC_PUMP_UNLOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=False;
    3114:	01 31       	cpi	r16, 0x11	; 17
    3116:	40 f4       	brcc	.+16     	; 0x3128 <ScanStandaloneFlow+0x38c>
    3118:	e0 2f       	mov	r30, r16
    311a:	f0 e0       	ldi	r31, 0x00	; 0
    311c:	ef 70       	andi	r30, 0x0F	; 15
    311e:	f0 70       	andi	r31, 0x00	; 0
    3120:	e4 53       	subi	r30, 0x34	; 52
    3122:	fd 4f       	sbci	r31, 0xFD	; 253
    3124:	10 82       	st	Z, r1
    3126:	0e c0       	rjmp	.+28     	; 0x3144 <ScanStandaloneFlow+0x3a8>
			   	  else 
			   	  if (slaveMsg==PUMP_ALL){
    3128:	02 31       	cpi	r16, 0x12	; 18
    312a:	61 f4       	brne	.+24     	; 0x3144 <ScanStandaloneFlow+0x3a8>
    312c:	81 e0       	ldi	r24, 0x01	; 1
    312e:	90 e0       	ldi	r25, 0x00	; 0
			   	      for(i=1;i<=16;i++){
			   		      PumpLock[i&0x0F]=False;
    3130:	fc 01       	movw	r30, r24
    3132:	ef 70       	andi	r30, 0x0F	; 15
    3134:	f0 70       	andi	r31, 0x00	; 0
    3136:	e4 53       	subi	r30, 0x34	; 52
    3138:	fd 4f       	sbci	r31, 0xFD	; 253
    313a:	10 82       	st	Z, r1
    313c:	01 96       	adiw	r24, 0x01	; 1
		      break;
         case SC_PUMP_UNLOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=False;
			   	  else 
			   	  if (slaveMsg==PUMP_ALL){
			   	      for(i=1;i<=16;i++){
    313e:	81 31       	cpi	r24, 0x11	; 17
    3140:	91 05       	cpc	r25, r1
    3142:	b1 f7       	brne	.-20     	; 0x3130 <ScanStandaloneFlow+0x394>
			   		      PumpLock[i&0x0F]=False;
			   		  }  
			   	  }
               #ifdef DEBUG_CMD_TERM 
			   	 sprintf_P(strSend,PSTR("PumpUnLock:%d"),slaveMsg);
    3144:	00 d0       	rcall	.+0      	; 0x3146 <ScanStandaloneFlow+0x3aa>
    3146:	00 d0       	rcall	.+0      	; 0x3148 <ScanStandaloneFlow+0x3ac>
    3148:	00 d0       	rcall	.+0      	; 0x314a <ScanStandaloneFlow+0x3ae>
    314a:	ed b7       	in	r30, 0x3d	; 61
    314c:	fe b7       	in	r31, 0x3e	; 62
    314e:	31 96       	adiw	r30, 0x01	; 1
    3150:	7e 01       	movw	r14, r28
    3152:	08 94       	sec
    3154:	e1 1c       	adc	r14, r1
    3156:	f1 1c       	adc	r15, r1
    3158:	ad b7       	in	r26, 0x3d	; 61
    315a:	be b7       	in	r27, 0x3e	; 62
    315c:	12 96       	adiw	r26, 0x02	; 2
    315e:	fc 92       	st	X, r15
    3160:	ee 92       	st	-X, r14
    3162:	11 97       	sbiw	r26, 0x01	; 1
    3164:	83 e3       	ldi	r24, 0x33	; 51
    3166:	92 e0       	ldi	r25, 0x02	; 2
    3168:	c1 cf       	rjmp	.-126    	; 0x30ec <ScanStandaloneFlow+0x350>
				 TerminalSend(1,strSend);			 
               #endif
		       break;
          case SC_TOTALIZER_ACK:
		       IsTotalizerACK=True;
    316a:	81 e0       	ldi	r24, 0x01	; 1
    316c:	80 93 14 01 	sts	0x0114, r24
			   PumpAck=slaveMsg;
    3170:	00 93 df 02 	sts	0x02DF, r16
    3174:	89 c1       	rjmp	.+786    	; 0x3488 <ScanStandaloneFlow+0x6ec>
		       break;
		  case SC_SET_POOLING_NO_PUMP_COUNT:
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("NoPumpCount:%d"),slaveMsg);
    3176:	00 d0       	rcall	.+0      	; 0x3178 <ScanStandaloneFlow+0x3dc>
    3178:	00 d0       	rcall	.+0      	; 0x317a <ScanStandaloneFlow+0x3de>
    317a:	00 d0       	rcall	.+0      	; 0x317c <ScanStandaloneFlow+0x3e0>
    317c:	ed b7       	in	r30, 0x3d	; 61
    317e:	fe b7       	in	r31, 0x3e	; 62
    3180:	31 96       	adiw	r30, 0x01	; 1
    3182:	7e 01       	movw	r14, r28
    3184:	08 94       	sec
    3186:	e1 1c       	adc	r14, r1
    3188:	f1 1c       	adc	r15, r1
    318a:	ad b7       	in	r26, 0x3d	; 61
    318c:	be b7       	in	r27, 0x3e	; 62
    318e:	12 96       	adiw	r26, 0x02	; 2
    3190:	fc 92       	st	X, r15
    3192:	ee 92       	st	-X, r14
    3194:	11 97       	sbiw	r26, 0x01	; 1
    3196:	84 e2       	ldi	r24, 0x24	; 36
    3198:	92 e0       	ldi	r25, 0x02	; 2
    319a:	93 83       	std	Z+3, r25	; 0x03
    319c:	82 83       	std	Z+2, r24	; 0x02
    319e:	04 83       	std	Z+4, r16	; 0x04
    31a0:	15 82       	std	Z+5, r1	; 0x05
    31a2:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
			   TerminalSend(1,strSend);			 
    31a6:	2d b7       	in	r18, 0x3d	; 61
    31a8:	3e b7       	in	r19, 0x3e	; 62
    31aa:	2a 5f       	subi	r18, 0xFA	; 250
    31ac:	3f 4f       	sbci	r19, 0xFF	; 255
    31ae:	0f b6       	in	r0, 0x3f	; 63
    31b0:	f8 94       	cli
    31b2:	3e bf       	out	0x3e, r19	; 62
    31b4:	0f be       	out	0x3f, r0	; 63
    31b6:	2d bf       	out	0x3d, r18	; 61
    31b8:	81 e0       	ldi	r24, 0x01	; 1
    31ba:	b7 01       	movw	r22, r14
    31bc:	0e 94 12 15 	call	0x2a24	; 0x2a24 <TerminalSend>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    31c0:	e1 99       	sbic	0x1c, 1	; 28
    31c2:	fe cf       	rjmp	.-4      	; 0x31c0 <ScanStandaloneFlow+0x424>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    31c4:	88 e0       	ldi	r24, 0x08	; 8
    31c6:	90 e0       	ldi	r25, 0x00	; 0
    31c8:	9f bb       	out	0x1f, r25	; 31
    31ca:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    31cc:	0d bb       	out	0x1d, r16	; 29

    __asm__ __volatile__ (
    31ce:	0f b6       	in	r0, 0x3f	; 63
    31d0:	f8 94       	cli
    31d2:	e2 9a       	sbi	0x1c, 2	; 28
    31d4:	e1 9a       	sbi	0x1c, 1	; 28
    31d6:	0f be       	out	0x3f, r0	; 63
			   #endif
		       eeprom_write_byte(&DefNoPumpCountMax,slaveMsg);
			   IsRestartPooling=True;
    31d8:	81 e0       	ldi	r24, 0x01	; 1
    31da:	80 93 03 01 	sts	0x0103, r24
    31de:	54 c1       	rjmp	.+680    	; 0x3488 <ScanStandaloneFlow+0x6ec>
		       break;
		  case SC_SET_POOLING_MAX_PUMP:
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("MaxPump:%d"),slaveMsg);
    31e0:	00 d0       	rcall	.+0      	; 0x31e2 <ScanStandaloneFlow+0x446>
    31e2:	00 d0       	rcall	.+0      	; 0x31e4 <ScanStandaloneFlow+0x448>
    31e4:	00 d0       	rcall	.+0      	; 0x31e6 <ScanStandaloneFlow+0x44a>
    31e6:	ed b7       	in	r30, 0x3d	; 61
    31e8:	fe b7       	in	r31, 0x3e	; 62
    31ea:	31 96       	adiw	r30, 0x01	; 1
    31ec:	7e 01       	movw	r14, r28
    31ee:	08 94       	sec
    31f0:	e1 1c       	adc	r14, r1
    31f2:	f1 1c       	adc	r15, r1
    31f4:	ad b7       	in	r26, 0x3d	; 61
    31f6:	be b7       	in	r27, 0x3e	; 62
    31f8:	12 96       	adiw	r26, 0x02	; 2
    31fa:	fc 92       	st	X, r15
    31fc:	ee 92       	st	-X, r14
    31fe:	11 97       	sbiw	r26, 0x01	; 1
    3200:	89 e1       	ldi	r24, 0x19	; 25
    3202:	92 e0       	ldi	r25, 0x02	; 2
    3204:	93 83       	std	Z+3, r25	; 0x03
    3206:	82 83       	std	Z+2, r24	; 0x02
    3208:	04 83       	std	Z+4, r16	; 0x04
    320a:	15 82       	std	Z+5, r1	; 0x05
    320c:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
			   TerminalSend(1,strSend);			 
    3210:	2d b7       	in	r18, 0x3d	; 61
    3212:	3e b7       	in	r19, 0x3e	; 62
    3214:	2a 5f       	subi	r18, 0xFA	; 250
    3216:	3f 4f       	sbci	r19, 0xFF	; 255
    3218:	0f b6       	in	r0, 0x3f	; 63
    321a:	f8 94       	cli
    321c:	3e bf       	out	0x3e, r19	; 62
    321e:	0f be       	out	0x3f, r0	; 63
    3220:	2d bf       	out	0x3d, r18	; 61
    3222:	81 e0       	ldi	r24, 0x01	; 1
    3224:	b7 01       	movw	r22, r14
    3226:	0e 94 12 15 	call	0x2a24	; 0x2a24 <TerminalSend>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    322a:	e1 99       	sbic	0x1c, 1	; 28
    322c:	fe cf       	rjmp	.-4      	; 0x322a <ScanStandaloneFlow+0x48e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    322e:	87 e0       	ldi	r24, 0x07	; 7
    3230:	90 e0       	ldi	r25, 0x00	; 0
    3232:	ca cf       	rjmp	.-108    	; 0x31c8 <ScanStandaloneFlow+0x42c>
		       eeprom_write_byte(&DefMaxPumpPooling,slaveMsg);
			   IsRestartPooling=True;
		       break;
		  case SC_SET_POOLING_SEND:		      
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("PoolTrySend:%d"),slaveMsg);
    3234:	00 d0       	rcall	.+0      	; 0x3236 <ScanStandaloneFlow+0x49a>
    3236:	00 d0       	rcall	.+0      	; 0x3238 <ScanStandaloneFlow+0x49c>
    3238:	00 d0       	rcall	.+0      	; 0x323a <ScanStandaloneFlow+0x49e>
    323a:	ed b7       	in	r30, 0x3d	; 61
    323c:	fe b7       	in	r31, 0x3e	; 62
    323e:	31 96       	adiw	r30, 0x01	; 1
    3240:	7e 01       	movw	r14, r28
    3242:	08 94       	sec
    3244:	e1 1c       	adc	r14, r1
    3246:	f1 1c       	adc	r15, r1
    3248:	ad b7       	in	r26, 0x3d	; 61
    324a:	be b7       	in	r27, 0x3e	; 62
    324c:	12 96       	adiw	r26, 0x02	; 2
    324e:	fc 92       	st	X, r15
    3250:	ee 92       	st	-X, r14
    3252:	11 97       	sbiw	r26, 0x01	; 1
    3254:	8a e0       	ldi	r24, 0x0A	; 10
    3256:	92 e0       	ldi	r25, 0x02	; 2
    3258:	93 83       	std	Z+3, r25	; 0x03
    325a:	82 83       	std	Z+2, r24	; 0x02
    325c:	04 83       	std	Z+4, r16	; 0x04
    325e:	15 82       	std	Z+5, r1	; 0x05
    3260:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
			   TerminalSend(1,strSend);			 		        
    3264:	2d b7       	in	r18, 0x3d	; 61
    3266:	3e b7       	in	r19, 0x3e	; 62
    3268:	2a 5f       	subi	r18, 0xFA	; 250
    326a:	3f 4f       	sbci	r19, 0xFF	; 255
    326c:	0f b6       	in	r0, 0x3f	; 63
    326e:	f8 94       	cli
    3270:	3e bf       	out	0x3e, r19	; 62
    3272:	0f be       	out	0x3f, r0	; 63
    3274:	2d bf       	out	0x3d, r18	; 61
    3276:	81 e0       	ldi	r24, 0x01	; 1
    3278:	b7 01       	movw	r22, r14
    327a:	0e 94 12 15 	call	0x2a24	; 0x2a24 <TerminalSend>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    327e:	e1 99       	sbic	0x1c, 1	; 28
    3280:	fe cf       	rjmp	.-4      	; 0x327e <ScanStandaloneFlow+0x4e2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3282:	89 e0       	ldi	r24, 0x09	; 9
    3284:	90 e0       	ldi	r25, 0x00	; 0
    3286:	a0 cf       	rjmp	.-192    	; 0x31c8 <ScanStandaloneFlow+0x42c>
		       eeprom_write_byte(&DefSendCount,slaveMsg);
			   IsRestartPooling=True;
		       break;
          case SC_SET_POOLING_TIMEOUT:
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("PoolTimeout:%d"),slaveMsg);
    3288:	00 d0       	rcall	.+0      	; 0x328a <ScanStandaloneFlow+0x4ee>
    328a:	00 d0       	rcall	.+0      	; 0x328c <ScanStandaloneFlow+0x4f0>
    328c:	00 d0       	rcall	.+0      	; 0x328e <ScanStandaloneFlow+0x4f2>
    328e:	ed b7       	in	r30, 0x3d	; 61
    3290:	fe b7       	in	r31, 0x3e	; 62
    3292:	31 96       	adiw	r30, 0x01	; 1
    3294:	7e 01       	movw	r14, r28
    3296:	08 94       	sec
    3298:	e1 1c       	adc	r14, r1
    329a:	f1 1c       	adc	r15, r1
    329c:	ad b7       	in	r26, 0x3d	; 61
    329e:	be b7       	in	r27, 0x3e	; 62
    32a0:	12 96       	adiw	r26, 0x02	; 2
    32a2:	fc 92       	st	X, r15
    32a4:	ee 92       	st	-X, r14
    32a6:	11 97       	sbiw	r26, 0x01	; 1
    32a8:	8b ef       	ldi	r24, 0xFB	; 251
    32aa:	91 e0       	ldi	r25, 0x01	; 1
    32ac:	93 83       	std	Z+3, r25	; 0x03
    32ae:	82 83       	std	Z+2, r24	; 0x02
    32b0:	04 83       	std	Z+4, r16	; 0x04
    32b2:	15 82       	std	Z+5, r1	; 0x05
    32b4:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
			   TerminalSend(1,strSend);			 
    32b8:	2d b7       	in	r18, 0x3d	; 61
    32ba:	3e b7       	in	r19, 0x3e	; 62
    32bc:	2a 5f       	subi	r18, 0xFA	; 250
    32be:	3f 4f       	sbci	r19, 0xFF	; 255
    32c0:	0f b6       	in	r0, 0x3f	; 63
    32c2:	f8 94       	cli
    32c4:	3e bf       	out	0x3e, r19	; 62
    32c6:	0f be       	out	0x3f, r0	; 63
    32c8:	2d bf       	out	0x3d, r18	; 61
    32ca:	81 e0       	ldi	r24, 0x01	; 1
    32cc:	b7 01       	movw	r22, r14
    32ce:	0e 94 12 15 	call	0x2a24	; 0x2a24 <TerminalSend>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    32d2:	e1 99       	sbic	0x1c, 1	; 28
    32d4:	fe cf       	rjmp	.-4      	; 0x32d2 <ScanStandaloneFlow+0x536>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    32d6:	8a e0       	ldi	r24, 0x0A	; 10
    32d8:	90 e0       	ldi	r25, 0x00	; 0
    32da:	76 cf       	rjmp	.-276    	; 0x31c8 <ScanStandaloneFlow+0x42c>
		       eeprom_write_byte(&DefPoolTimeout,slaveMsg);
			   IsRestartPooling=True;
		       break;
          case SC_SET_POOLING_DELAY_NEXT_PUMP:
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("DelayNextPump:%d"),slaveMsg);
    32dc:	00 d0       	rcall	.+0      	; 0x32de <ScanStandaloneFlow+0x542>
    32de:	00 d0       	rcall	.+0      	; 0x32e0 <ScanStandaloneFlow+0x544>
    32e0:	00 d0       	rcall	.+0      	; 0x32e2 <ScanStandaloneFlow+0x546>
    32e2:	ed b7       	in	r30, 0x3d	; 61
    32e4:	fe b7       	in	r31, 0x3e	; 62
    32e6:	31 96       	adiw	r30, 0x01	; 1
    32e8:	7e 01       	movw	r14, r28
    32ea:	08 94       	sec
    32ec:	e1 1c       	adc	r14, r1
    32ee:	f1 1c       	adc	r15, r1
    32f0:	ad b7       	in	r26, 0x3d	; 61
    32f2:	be b7       	in	r27, 0x3e	; 62
    32f4:	12 96       	adiw	r26, 0x02	; 2
    32f6:	fc 92       	st	X, r15
    32f8:	ee 92       	st	-X, r14
    32fa:	11 97       	sbiw	r26, 0x01	; 1
    32fc:	8a ee       	ldi	r24, 0xEA	; 234
    32fe:	91 e0       	ldi	r25, 0x01	; 1
    3300:	93 83       	std	Z+3, r25	; 0x03
    3302:	82 83       	std	Z+2, r24	; 0x02
    3304:	04 83       	std	Z+4, r16	; 0x04
    3306:	15 82       	std	Z+5, r1	; 0x05
    3308:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
			   TerminalSend(1,strSend);			 
    330c:	2d b7       	in	r18, 0x3d	; 61
    330e:	3e b7       	in	r19, 0x3e	; 62
    3310:	2a 5f       	subi	r18, 0xFA	; 250
    3312:	3f 4f       	sbci	r19, 0xFF	; 255
    3314:	0f b6       	in	r0, 0x3f	; 63
    3316:	f8 94       	cli
    3318:	3e bf       	out	0x3e, r19	; 62
    331a:	0f be       	out	0x3f, r0	; 63
    331c:	2d bf       	out	0x3d, r18	; 61
    331e:	81 e0       	ldi	r24, 0x01	; 1
    3320:	b7 01       	movw	r22, r14
    3322:	0e 94 12 15 	call	0x2a24	; 0x2a24 <TerminalSend>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3326:	e1 99       	sbic	0x1c, 1	; 28
    3328:	fe cf       	rjmp	.-4      	; 0x3326 <ScanStandaloneFlow+0x58a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    332a:	8b e0       	ldi	r24, 0x0B	; 11
    332c:	90 e0       	ldi	r25, 0x00	; 0
    332e:	4c cf       	rjmp	.-360    	; 0x31c8 <ScanStandaloneFlow+0x42c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3330:	e1 99       	sbic	0x1c, 1	; 28
    3332:	fe cf       	rjmp	.-4      	; 0x3330 <ScanStandaloneFlow+0x594>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3334:	88 e0       	ldi	r24, 0x08	; 8
    3336:	90 e0       	ldi	r25, 0x00	; 0
    3338:	09 c0       	rjmp	.+18     	; 0x334c <ScanStandaloneFlow+0x5b0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    333a:	e1 99       	sbic	0x1c, 1	; 28
    333c:	fe cf       	rjmp	.-4      	; 0x333a <ScanStandaloneFlow+0x59e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    333e:	87 e0       	ldi	r24, 0x07	; 7
    3340:	90 e0       	ldi	r25, 0x00	; 0
    3342:	04 c0       	rjmp	.+8      	; 0x334c <ScanStandaloneFlow+0x5b0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3344:	e1 99       	sbic	0x1c, 1	; 28
    3346:	fe cf       	rjmp	.-4      	; 0x3344 <ScanStandaloneFlow+0x5a8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3348:	89 e0       	ldi	r24, 0x09	; 9
    334a:	90 e0       	ldi	r25, 0x00	; 0
    334c:	9f bb       	out	0x1f, r25	; 31
    334e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3350:	e0 9a       	sbi	0x1c, 0	; 28
    3352:	cd b2       	in	r12, 0x1d	; 29
    3354:	99 c0       	rjmp	.+306    	; 0x3488 <ScanStandaloneFlow+0x6ec>
		  case SC_GET_POOLING_SEND:		            
		       slaveMsg=eeprom_read_byte(&DefSendCount);
		       break;		 
          case SC_SEQUENCE_TIMEOUT:
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("PoolTrySend:%d"),slaveMsg);
    3356:	00 d0       	rcall	.+0      	; 0x3358 <ScanStandaloneFlow+0x5bc>
    3358:	00 d0       	rcall	.+0      	; 0x335a <ScanStandaloneFlow+0x5be>
    335a:	00 d0       	rcall	.+0      	; 0x335c <ScanStandaloneFlow+0x5c0>
    335c:	ed b7       	in	r30, 0x3d	; 61
    335e:	fe b7       	in	r31, 0x3e	; 62
    3360:	31 96       	adiw	r30, 0x01	; 1
    3362:	7e 01       	movw	r14, r28
    3364:	08 94       	sec
    3366:	e1 1c       	adc	r14, r1
    3368:	f1 1c       	adc	r15, r1
    336a:	ad b7       	in	r26, 0x3d	; 61
    336c:	be b7       	in	r27, 0x3e	; 62
    336e:	12 96       	adiw	r26, 0x02	; 2
    3370:	fc 92       	st	X, r15
    3372:	ee 92       	st	-X, r14
    3374:	11 97       	sbiw	r26, 0x01	; 1
    3376:	8b ed       	ldi	r24, 0xDB	; 219
    3378:	91 e0       	ldi	r25, 0x01	; 1
    337a:	93 83       	std	Z+3, r25	; 0x03
    337c:	82 83       	std	Z+2, r24	; 0x02
    337e:	04 83       	std	Z+4, r16	; 0x04
    3380:	15 82       	std	Z+5, r1	; 0x05
    3382:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
			   TerminalSend(1,strSend);			 		        
    3386:	2d b7       	in	r18, 0x3d	; 61
    3388:	3e b7       	in	r19, 0x3e	; 62
    338a:	2a 5f       	subi	r18, 0xFA	; 250
    338c:	3f 4f       	sbci	r19, 0xFF	; 255
    338e:	0f b6       	in	r0, 0x3f	; 63
    3390:	f8 94       	cli
    3392:	3e bf       	out	0x3e, r19	; 62
    3394:	0f be       	out	0x3f, r0	; 63
    3396:	2d bf       	out	0x3d, r18	; 61
    3398:	81 e0       	ldi	r24, 0x01	; 1
    339a:	b7 01       	movw	r22, r14
    339c:	0e 94 12 15 	call	0x2a24	; 0x2a24 <TerminalSend>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    33a0:	e1 99       	sbic	0x1c, 1	; 28
    33a2:	fe cf       	rjmp	.-4      	; 0x33a0 <ScanStandaloneFlow+0x604>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    33a4:	8c e0       	ldi	r24, 0x0C	; 12
    33a6:	90 e0       	ldi	r25, 0x00	; 0
    33a8:	9f bb       	out	0x1f, r25	; 31
    33aa:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    33ac:	0d bb       	out	0x1d, r16	; 29

    __asm__ __volatile__ (
    33ae:	0f b6       	in	r0, 0x3f	; 63
    33b0:	f8 94       	cli
    33b2:	e2 9a       	sbi	0x1c, 2	; 28
    33b4:	e1 9a       	sbi	0x1c, 1	; 28
    33b6:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    33b8:	e1 99       	sbic	0x1c, 1	; 28
    33ba:	fe cf       	rjmp	.-4      	; 0x33b8 <ScanStandaloneFlow+0x61c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    33bc:	9f bb       	out	0x1f, r25	; 31
    33be:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    33c0:	e0 9a       	sbi	0x1c, 0	; 28
    33c2:	8d b3       	in	r24, 0x1d	; 29
			   #endif
		       eeprom_write_byte(&DefSequenceTimeout,slaveMsg);
			   SequenceTimeout=eeprom_read_byte(&DefSequenceTimeout);
    33c4:	80 93 36 04 	sts	0x0436, r24
    33c8:	07 cf       	rjmp	.-498    	; 0x31d8 <ScanStandaloneFlow+0x43c>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    33ca:	e1 99       	sbic	0x1c, 1	; 28
    33cc:	fe cf       	rjmp	.-4      	; 0x33ca <ScanStandaloneFlow+0x62e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    33ce:	80 2f       	mov	r24, r16
    33d0:	82 95       	swap	r24
    33d2:	8f 70       	andi	r24, 0x0F	; 15
    33d4:	90 e0       	ldi	r25, 0x00	; 0
    33d6:	83 5f       	subi	r24, 0xF3	; 243
    33d8:	9f 4f       	sbci	r25, 0xFF	; 255
    33da:	9f bb       	out	0x1f, r25	; 31
    33dc:	8e bb       	out	0x1e, r24	; 30
			   IsRestartPooling=True;		       
		       break;
          case SC_SET_PUMPID:
		       eeprom_write_byte(&DefPumpID[slaveMsg>>4],(slaveMsg&0x0F));		       
    33de:	80 2f       	mov	r24, r16
    33e0:	8f 70       	andi	r24, 0x0F	; 15
#endif
    EEDR = __value;
    33e2:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    33e4:	0f b6       	in	r0, 0x3f	; 63
    33e6:	f8 94       	cli
    33e8:	e2 9a       	sbi	0x1c, 2	; 28
    33ea:	e1 9a       	sbi	0x1c, 1	; 28
    33ec:	0f be       	out	0x3f, r0	; 63
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("SC_SET_PUMPID:[%.2X]"),slaveMsg);
    33ee:	00 d0       	rcall	.+0      	; 0x33f0 <ScanStandaloneFlow+0x654>
    33f0:	00 d0       	rcall	.+0      	; 0x33f2 <ScanStandaloneFlow+0x656>
    33f2:	00 d0       	rcall	.+0      	; 0x33f4 <ScanStandaloneFlow+0x658>
    33f4:	ed b7       	in	r30, 0x3d	; 61
    33f6:	fe b7       	in	r31, 0x3e	; 62
    33f8:	31 96       	adiw	r30, 0x01	; 1
    33fa:	7e 01       	movw	r14, r28
    33fc:	08 94       	sec
    33fe:	e1 1c       	adc	r14, r1
    3400:	f1 1c       	adc	r15, r1
    3402:	ad b7       	in	r26, 0x3d	; 61
    3404:	be b7       	in	r27, 0x3e	; 62
    3406:	12 96       	adiw	r26, 0x02	; 2
    3408:	fc 92       	st	X, r15
    340a:	ee 92       	st	-X, r14
    340c:	11 97       	sbiw	r26, 0x01	; 1
    340e:	86 ec       	ldi	r24, 0xC6	; 198
    3410:	91 e0       	ldi	r25, 0x01	; 1
    3412:	20 c0       	rjmp	.+64     	; 0x3454 <ScanStandaloneFlow+0x6b8>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3414:	e1 99       	sbic	0x1c, 1	; 28
    3416:	fe cf       	rjmp	.-4      	; 0x3414 <ScanStandaloneFlow+0x678>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3418:	80 2f       	mov	r24, r16
    341a:	90 e0       	ldi	r25, 0x00	; 0
    341c:	83 5f       	subi	r24, 0xF3	; 243
    341e:	9f 4f       	sbci	r25, 0xFF	; 255
    3420:	9f bb       	out	0x1f, r25	; 31
    3422:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3424:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3426:	0f b6       	in	r0, 0x3f	; 63
    3428:	f8 94       	cli
    342a:	e2 9a       	sbi	0x1c, 2	; 28
    342c:	e1 9a       	sbi	0x1c, 1	; 28
    342e:	0f be       	out	0x3f, r0	; 63
               IsRestartPooling=True;
               break; 
		  case SC_CLEAR_PUMPID:
               eeprom_write_byte(&DefPumpID[slaveMsg],0);
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("SC_CLEAR_PUMPID:[%.2X]"),slaveMsg);
    3430:	00 d0       	rcall	.+0      	; 0x3432 <ScanStandaloneFlow+0x696>
    3432:	00 d0       	rcall	.+0      	; 0x3434 <ScanStandaloneFlow+0x698>
    3434:	00 d0       	rcall	.+0      	; 0x3436 <ScanStandaloneFlow+0x69a>
    3436:	ed b7       	in	r30, 0x3d	; 61
    3438:	fe b7       	in	r31, 0x3e	; 62
    343a:	31 96       	adiw	r30, 0x01	; 1
    343c:	7e 01       	movw	r14, r28
    343e:	08 94       	sec
    3440:	e1 1c       	adc	r14, r1
    3442:	f1 1c       	adc	r15, r1
    3444:	ad b7       	in	r26, 0x3d	; 61
    3446:	be b7       	in	r27, 0x3e	; 62
    3448:	12 96       	adiw	r26, 0x02	; 2
    344a:	fc 92       	st	X, r15
    344c:	ee 92       	st	-X, r14
    344e:	11 97       	sbiw	r26, 0x01	; 1
    3450:	8f ea       	ldi	r24, 0xAF	; 175
    3452:	91 e0       	ldi	r25, 0x01	; 1
    3454:	93 83       	std	Z+3, r25	; 0x03
    3456:	82 83       	std	Z+2, r24	; 0x02
    3458:	04 83       	std	Z+4, r16	; 0x04
    345a:	15 82       	std	Z+5, r1	; 0x05
    345c:	0e 94 de 1b 	call	0x37bc	; 0x37bc <sprintf_P>
			   TerminalSend(1,strSend);			 		        
    3460:	2d b7       	in	r18, 0x3d	; 61
    3462:	3e b7       	in	r19, 0x3e	; 62
    3464:	2a 5f       	subi	r18, 0xFA	; 250
    3466:	3f 4f       	sbci	r19, 0xFF	; 255
    3468:	0f b6       	in	r0, 0x3f	; 63
    346a:	f8 94       	cli
    346c:	3e bf       	out	0x3e, r19	; 62
    346e:	0f be       	out	0x3f, r0	; 63
    3470:	2d bf       	out	0x3d, r18	; 61
    3472:	81 e0       	ldi	r24, 0x01	; 1
    3474:	b7 01       	movw	r22, r14
    3476:	0e 94 12 15 	call	0x2a24	; 0x2a24 <TerminalSend>
    347a:	ae ce       	rjmp	.-676    	; 0x31d8 <ScanStandaloneFlow+0x43c>
			   #endif
               IsRestartPooling=True;
		       break;
          case SC_STOP_POOL_SEQUENCE:
		       IsStopPoolSequence=True;
    347c:	81 e0       	ldi	r24, 0x01	; 1
    347e:	80 93 13 01 	sts	0x0113, r24
    3482:	02 c0       	rjmp	.+4      	; 0x3488 <ScanStandaloneFlow+0x6ec>
		       break; 
          case SC_START_POOL_SEQUENCE:
		       IsStopPoolSequence=False;
    3484:	10 92 13 01 	sts	0x0113, r1
		       break; 
		 }
       //AcknoledgeCommand
       SendCommandAcknoledge(slaveCmd,slaveMsg);
    3488:	89 2d       	mov	r24, r9
    348a:	6c 2d       	mov	r22, r12
    348c:	0e 94 65 07 	call	0xeca	; 0xeca <SendCommandAcknoledge>
	 }//EndIf	 
}
    3490:	64 96       	adiw	r28, 0x14	; 20
    3492:	0f b6       	in	r0, 0x3f	; 63
    3494:	f8 94       	cli
    3496:	de bf       	out	0x3e, r29	; 62
    3498:	0f be       	out	0x3f, r0	; 63
    349a:	cd bf       	out	0x3d, r28	; 61
    349c:	cf 91       	pop	r28
    349e:	df 91       	pop	r29
    34a0:	0f 91       	pop	r16
    34a2:	ff 90       	pop	r15
    34a4:	ef 90       	pop	r14
    34a6:	df 90       	pop	r13
    34a8:	cf 90       	pop	r12
    34aa:	bf 90       	pop	r11
    34ac:	af 90       	pop	r10
    34ae:	9f 90       	pop	r9
    34b0:	08 95       	ret

000034b2 <__vector_18>:
	   
	//_uart(1,1,dataRX1);
	//OnReceive1(dataRX1);
}

ISR(SPI_STC_vect){
    34b2:	1f 92       	push	r1
    34b4:	0f 92       	push	r0
    34b6:	0f b6       	in	r0, 0x3f	; 63
    34b8:	0f 92       	push	r0
    34ba:	11 24       	eor	r1, r1
    34bc:	1f 93       	push	r17
    34be:	2f 93       	push	r18
    34c0:	3f 93       	push	r19
    34c2:	4f 93       	push	r20
    34c4:	5f 93       	push	r21
    34c6:	6f 93       	push	r22
    34c8:	7f 93       	push	r23
    34ca:	8f 93       	push	r24
    34cc:	9f 93       	push	r25
    34ce:	af 93       	push	r26
    34d0:	bf 93       	push	r27
    34d2:	ef 93       	push	r30
    34d4:	ff 93       	push	r31
char dataSPI;
     dataSPI=SPDR;
    34d6:	1f b1       	in	r17, 0x0f	; 15
          ScanStandaloneFlow(dataSPI);
	      break;
	 }
	 */
	 
	 if (IFType==IT_SLAVE)//EDC Line Protocol
    34d8:	80 91 00 01 	lds	r24, 0x0100
    34dc:	81 30       	cpi	r24, 0x01	; 1
    34de:	29 f4       	brne	.+10     	; 0x34ea <__vector_18+0x38>
	    _uart(0,1,dataSPI);
    34e0:	80 e0       	ldi	r24, 0x00	; 0
    34e2:	61 e0       	ldi	r22, 0x01	; 1
    34e4:	41 2f       	mov	r20, r17
    34e6:	0e 94 76 1b 	call	0x36ec	; 0x36ec <_uart>
	 ScanStandaloneFlow(dataSPI);	 
    34ea:	81 2f       	mov	r24, r17
    34ec:	0e 94 ce 16 	call	0x2d9c	; 0x2d9c <ScanStandaloneFlow>
}
    34f0:	ff 91       	pop	r31
    34f2:	ef 91       	pop	r30
    34f4:	bf 91       	pop	r27
    34f6:	af 91       	pop	r26
    34f8:	9f 91       	pop	r25
    34fa:	8f 91       	pop	r24
    34fc:	7f 91       	pop	r23
    34fe:	6f 91       	pop	r22
    3500:	5f 91       	pop	r21
    3502:	4f 91       	pop	r20
    3504:	3f 91       	pop	r19
    3506:	2f 91       	pop	r18
    3508:	1f 91       	pop	r17
    350a:	0f 90       	pop	r0
    350c:	0f be       	out	0x3f, r0	; 63
    350e:	0f 90       	pop	r0
    3510:	1f 90       	pop	r1
    3512:	18 95       	reti

00003514 <_spi_init>:
enum SPI_TYPE{SLAVE,MASTER};
enum SPI_MODE{POOLING,INTERUPT};


void _spi_init(unsigned char __mode, unsigned char __interrupt){
	if(__mode){
    3514:	88 23       	and	r24, r24
    3516:	41 f0       	breq	.+16     	; 0x3528 <_spi_init+0x14>
		_SPI_DDR = (1 << _SPI_MOSI) | (1 << _SPI_SCK);
    3518:	80 ea       	ldi	r24, 0xA0	; 160
    351a:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
    351c:	66 23       	and	r22, r22
    351e:	11 f0       	breq	.+4      	; 0x3524 <_spi_init+0x10>
			SPCR = (1 << SPIE) | (1 << SPE) | (1 << MSTR) | (1 << SPR1);
    3520:	82 ed       	ldi	r24, 0xD2	; 210
    3522:	0a c0       	rjmp	.+20     	; 0x3538 <_spi_init+0x24>
		else
			SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1);
    3524:	82 e5       	ldi	r24, 0x52	; 82
    3526:	08 c0       	rjmp	.+16     	; 0x3538 <_spi_init+0x24>
	}
	else{

		_SPI_DDR = (1 << _SPI_MISO);
    3528:	80 e4       	ldi	r24, 0x40	; 64
    352a:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
    352c:	66 23       	and	r22, r22
    352e:	21 f0       	breq	.+8      	; 0x3538 <_spi_init+0x24>
			{SPCR = (1 << SPIE) | (1 << SPE);sei();}
    3530:	80 ec       	ldi	r24, 0xC0	; 192
    3532:	8d b9       	out	0x0d, r24	; 13
    3534:	78 94       	sei
    3536:	08 95       	ret
		else
			SPCR = (1 << SPE);
    3538:	8d b9       	out	0x0d, r24	; 13
    353a:	08 95       	ret

0000353c <_spi_enable>:
			
	}
}

void _spi_enable(unsigned char __status, unsigned char __select){
	if(__status){
    353c:	88 23       	and	r24, r24
    353e:	31 f0       	breq	.+12     	; 0x354c <_spi_enable+0x10>
		if(__select)
    3540:	66 23       	and	r22, r22
    3542:	11 f0       	breq	.+4      	; 0x3548 <_spi_enable+0xc>
			cbi(_MMC_PORT, _MMC_PIN);
    3544:	3b 98       	cbi	0x07, 3	; 7
    3546:	08 95       	ret
		else
			cbi(_SLAVE_PORT, _SLAVE_PIN);
    3548:	92 98       	cbi	0x12, 2	; 18
    354a:	08 95       	ret
	}
	else{
		if(__select)
    354c:	66 23       	and	r22, r22
    354e:	11 f0       	breq	.+4      	; 0x3554 <_spi_enable+0x18>
			sbi(_MMC_PORT, _MMC_PIN);
    3550:	3b 9a       	sbi	0x07, 3	; 7
    3552:	08 95       	ret
		else
			sbi(_SLAVE_PORT, _SLAVE_PIN);
    3554:	92 9a       	sbi	0x12, 2	; 18
    3556:	08 95       	ret

00003558 <_spi>:
	}
}

unsigned char _spi(unsigned char __data){   
	SPDR = __data;
    3558:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
    355a:	77 9b       	sbis	0x0e, 7	; 14
    355c:	fe cf       	rjmp	.-4      	; 0x355a <_spi+0x2>
	return SPDR;
    355e:	8f b1       	in	r24, 0x0f	; 15
}
    3560:	08 95       	ret

00003562 <_spi_rx>:

unsigned char _spi_rx(unsigned char __select){
//	return 1;
}
    3562:	08 95       	ret

00003564 <_spi_tx>:

unsigned char _spi_tx(unsigned char __command, unsigned char __select, char *__message){
//	_spi_enable(_SPI_ENABLE, __select);
//	_spi_enable(_SPI_DISABLE, __select);
//	return 0;
}
    3564:	08 95       	ret

00003566 <_spi_interrupt>:

unsigned char _spi_interrupt(void){
	//return 0;
}
    3566:	08 95       	ret

00003568 <_spi_command>:
	}

	__command[__i++] = 0x7D;
	__command[__i++] = '\0';
	*/
}
    3568:	08 95       	ret

0000356a <_uart_setting>:

#include "UART.h"

//_uart_setting(0,GetBaudrate(eeprom_read_byte(&DefBaudrate[0])),8,P_EVEN,1);

void _uart_setting(char Port,unsigned long Baudrate,char DataSet,char ParitySet, char StopBitSet){
    356a:	af 92       	push	r10
    356c:	bf 92       	push	r11
    356e:	cf 92       	push	r12
    3570:	df 92       	push	r13
    3572:	ef 92       	push	r14
    3574:	ff 92       	push	r15
    3576:	0f 93       	push	r16
    3578:	1f 93       	push	r17
    357a:	f8 2e       	mov	r15, r24
    357c:	5a 01       	movw	r10, r20
    357e:	6b 01       	movw	r12, r22
    3580:	12 2f       	mov	r17, r18
unsigned long BaudrateValue;
     char RegB,RegC;
	 BaudrateValue= (unsigned long)((_CPU_DEFAULT + (Baudrate* 8)) / (Baudrate* 16) - 1);
    3582:	cb 01       	movw	r24, r22
    3584:	ba 01       	movw	r22, r20
    3586:	60 50       	subi	r22, 0x00	; 0
    3588:	70 4e       	sbci	r23, 0xE0	; 224
    358a:	83 4e       	sbci	r24, 0xE3	; 227
    358c:	9f 4f       	sbci	r25, 0xFF	; 255
    358e:	33 e0       	ldi	r19, 0x03	; 3
    3590:	66 0f       	add	r22, r22
    3592:	77 1f       	adc	r23, r23
    3594:	88 1f       	adc	r24, r24
    3596:	99 1f       	adc	r25, r25
    3598:	3a 95       	dec	r19
    359a:	d1 f7       	brne	.-12     	; 0x3590 <_uart_setting+0x26>
    359c:	24 e0       	ldi	r18, 0x04	; 4
    359e:	aa 0c       	add	r10, r10
    35a0:	bb 1c       	adc	r11, r11
    35a2:	cc 1c       	adc	r12, r12
    35a4:	dd 1c       	adc	r13, r13
    35a6:	2a 95       	dec	r18
    35a8:	d1 f7       	brne	.-12     	; 0x359e <_uart_setting+0x34>
    35aa:	a6 01       	movw	r20, r12
    35ac:	95 01       	movw	r18, r10
    35ae:	0e 94 9f 1e 	call	0x3d3e	; 0x3d3e <__udivmodsi4>
    35b2:	21 50       	subi	r18, 0x01	; 1
    35b4:	30 40       	sbci	r19, 0x00	; 0
    35b6:	40 40       	sbci	r20, 0x00	; 0
    35b8:	50 40       	sbci	r21, 0x00	; 0
     RegB=0;RegC=0;
	 RegB = (1<<RXCIE0) | (1<<RXEN0) | (1<<TXEN0);
     RegC = (1<<URSEL0);
   
     //ParitySet
	 switch(ParitySet){
    35ba:	01 30       	cpi	r16, 0x01	; 1
    35bc:	31 f0       	breq	.+12     	; 0x35ca <_uart_setting+0x60>
    35be:	02 30       	cpi	r16, 0x02	; 2
    35c0:	11 f4       	brne	.+4      	; 0x35c6 <_uart_setting+0x5c>
    35c2:	60 ea       	ldi	r22, 0xA0	; 160
    35c4:	03 c0       	rjmp	.+6      	; 0x35cc <_uart_setting+0x62>
    35c6:	60 e8       	ldi	r22, 0x80	; 128
    35c8:	01 c0       	rjmp	.+2      	; 0x35cc <_uart_setting+0x62>
    35ca:	60 eb       	ldi	r22, 0xB0	; 176
     case P_ODD:
	      RegC=RegC|(1<<UPM00)|(1<<UPM01);
	      break;	 
	 }
     //StopBit
      if (StopBitSet==2)
    35cc:	82 e0       	ldi	r24, 0x02	; 2
    35ce:	e8 16       	cp	r14, r24
    35d0:	09 f4       	brne	.+2      	; 0x35d4 <_uart_setting+0x6a>
	      RegC=RegC|(1<<USBS0);
    35d2:	68 60       	ori	r22, 0x08	; 8

		  //DataSet
		  switch (DataSet){
    35d4:	17 30       	cpi	r17, 0x07	; 7
    35d6:	61 f0       	breq	.+24     	; 0x35f0 <_uart_setting+0x86>
    35d8:	18 30       	cpi	r17, 0x08	; 8
    35da:	18 f4       	brcc	.+6      	; 0x35e2 <_uart_setting+0x78>
    35dc:	16 30       	cpi	r17, 0x06	; 6
    35de:	59 f4       	brne	.+22     	; 0x35f6 <_uart_setting+0x8c>
    35e0:	05 c0       	rjmp	.+10     	; 0x35ec <_uart_setting+0x82>
    35e2:	18 30       	cpi	r17, 0x08	; 8
    35e4:	39 f0       	breq	.+14     	; 0x35f4 <_uart_setting+0x8a>
    35e6:	19 30       	cpi	r17, 0x09	; 9
    35e8:	31 f4       	brne	.+12     	; 0x35f6 <_uart_setting+0x8c>
    35ea:	07 c0       	rjmp	.+14     	; 0x35fa <_uart_setting+0x90>
		  case 5:
		       break;
		  case 6:
		       RegC=RegC|(1<<UCSZ00);
    35ec:	62 60       	ori	r22, 0x02	; 2
    35ee:	03 c0       	rjmp	.+6      	; 0x35f6 <_uart_setting+0x8c>
		       break;
		  case 7:
		       RegC=RegC|(1<<UCSZ01);
    35f0:	64 60       	ori	r22, 0x04	; 4
    35f2:	01 c0       	rjmp	.+2      	; 0x35f6 <_uart_setting+0x8c>
		       break;
		  case 8:
		       RegC=RegC|(1<<UCSZ00)|(1<<UCSZ01);
    35f4:	66 60       	ori	r22, 0x06	; 6
    35f6:	78 e9       	ldi	r23, 0x98	; 152
    35f8:	02 c0       	rjmp	.+4      	; 0x35fe <_uart_setting+0x94>
		       break;
		  case 9:
               RegB=RegB| (1<<UCSZ02);
		       RegC=RegC| (1<<UCSZ00)|(1<<UCSZ01);
    35fa:	66 60       	ori	r22, 0x06	; 6
    35fc:	7c e9       	ldi	r23, 0x9C	; 156
		       break;
		  }

	 switch (Port){
    35fe:	ff 20       	and	r15, r15
    3600:	21 f0       	breq	.+8      	; 0x360a <_uart_setting+0xa0>
    3602:	81 e0       	ldi	r24, 0x01	; 1
    3604:	f8 16       	cp	r15, r24
    3606:	91 f4       	brne	.+36     	; 0x362c <_uart_setting+0xc2>
    3608:	09 c0       	rjmp	.+18     	; 0x361c <_uart_setting+0xb2>
	 case 0:		  
		  //Write
		  //Register

	      //BaudrateSetting
          UBRR0H=BaudrateValue>>8;
    360a:	bb 27       	eor	r27, r27
    360c:	a5 2f       	mov	r26, r21
    360e:	94 2f       	mov	r25, r20
    3610:	83 2f       	mov	r24, r19
    3612:	80 bd       	out	0x20, r24	; 32
		  UBRR0L=BaudrateValue;		
    3614:	29 b9       	out	0x09, r18	; 9
		  //Register
		  UCSR0B=RegB; 
    3616:	7a b9       	out	0x0a, r23	; 10
		  UCSR0C=RegC; 
    3618:	60 bd       	out	0x20, r22	; 32
    361a:	08 c0       	rjmp	.+16     	; 0x362c <_uart_setting+0xc2>
	      break;
     case 1:
		  //Write
		  //BaudrateSetting
          UBRR1H=BaudrateValue>>8;
    361c:	bb 27       	eor	r27, r27
    361e:	a5 2f       	mov	r26, r21
    3620:	94 2f       	mov	r25, r20
    3622:	83 2f       	mov	r24, r19
    3624:	8c bf       	out	0x3c, r24	; 60
		  UBRR1L=BaudrateValue;		
    3626:	20 b9       	out	0x00, r18	; 0

		  //Register
		  UCSR1B=RegB; 
    3628:	71 b9       	out	0x01, r23	; 1
		  UCSR1C=RegC;
    362a:	6c bf       	out	0x3c, r22	; 60
	      break;
	 }  
}
    362c:	1f 91       	pop	r17
    362e:	0f 91       	pop	r16
    3630:	ff 90       	pop	r15
    3632:	ef 90       	pop	r14
    3634:	df 90       	pop	r13
    3636:	cf 90       	pop	r12
    3638:	bf 90       	pop	r11
    363a:	af 90       	pop	r10
    363c:	08 95       	ret

0000363e <_uart_baudrate>:
	    UCSR0C=(1<<URSEL0) | (1<<UPM01) | (1<<UCSZ01) | (1<<UCSZ00); // UPM01 untuk set even parity
	    UBRR0H=0;UBRR0L=158;// baud 5787       
	}
}

void _uart_baudrate(unsigned char __com, unsigned long __baudrate){
    363e:	1f 93       	push	r17
    3640:	18 2f       	mov	r17, r24
    3642:	9a 01       	movw	r18, r20
    3644:	ab 01       	movw	r20, r22
	unsigned long __br;

	__br = (unsigned long)((_CPU_DEFAULT + (__baudrate * 8)) / (__baudrate * 16) - 1);
    3646:	ca 01       	movw	r24, r20
    3648:	b9 01       	movw	r22, r18
    364a:	60 50       	subi	r22, 0x00	; 0
    364c:	70 4e       	sbci	r23, 0xE0	; 224
    364e:	83 4e       	sbci	r24, 0xE3	; 227
    3650:	9f 4f       	sbci	r25, 0xFF	; 255
    3652:	f3 e0       	ldi	r31, 0x03	; 3
    3654:	66 0f       	add	r22, r22
    3656:	77 1f       	adc	r23, r23
    3658:	88 1f       	adc	r24, r24
    365a:	99 1f       	adc	r25, r25
    365c:	fa 95       	dec	r31
    365e:	d1 f7       	brne	.-12     	; 0x3654 <_uart_baudrate+0x16>
    3660:	e4 e0       	ldi	r30, 0x04	; 4
    3662:	22 0f       	add	r18, r18
    3664:	33 1f       	adc	r19, r19
    3666:	44 1f       	adc	r20, r20
    3668:	55 1f       	adc	r21, r21
    366a:	ea 95       	dec	r30
    366c:	d1 f7       	brne	.-12     	; 0x3662 <_uart_baudrate+0x24>
    366e:	0e 94 9f 1e 	call	0x3d3e	; 0x3d3e <__udivmodsi4>
    3672:	21 50       	subi	r18, 0x01	; 1
    3674:	30 40       	sbci	r19, 0x00	; 0
    3676:	40 40       	sbci	r20, 0x00	; 0
    3678:	50 40       	sbci	r21, 0x00	; 0
    367a:	bb 27       	eor	r27, r27
    367c:	a5 2f       	mov	r26, r21
    367e:	94 2f       	mov	r25, r20
    3680:	83 2f       	mov	r24, r19

	if(__com){
    3682:	11 23       	and	r17, r17
    3684:	19 f0       	breq	.+6      	; 0x368c <_uart_baudrate+0x4e>
		UBRR1L = __br;
    3686:	20 b9       	out	0x00, r18	; 0
		UBRR1H = __br >> 8;
    3688:	8c bf       	out	0x3c, r24	; 60
    368a:	02 c0       	rjmp	.+4      	; 0x3690 <_uart_baudrate+0x52>
	}
	else{
		UBRR0L = __br;
    368c:	29 b9       	out	0x09, r18	; 9
		UBRR0H = __br >> 8;
    368e:	80 bd       	out	0x20, r24	; 32
	}
}
    3690:	1f 91       	pop	r17
    3692:	08 95       	ret

00003694 <_uart_init>:
		  UCSR1C=RegC;
	      break;
	 }  
}

void _uart_init(unsigned char __com, unsigned long __baudrate){
    3694:	ef 92       	push	r14
    3696:	ff 92       	push	r15
    3698:	0f 93       	push	r16
    369a:	1f 93       	push	r17
    369c:	98 2f       	mov	r25, r24
    369e:	7a 01       	movw	r14, r20
    36a0:	8b 01       	movw	r16, r22
	if(__com){
    36a2:	88 23       	and	r24, r24
    36a4:	29 f0       	breq	.+10     	; 0x36b0 <_uart_init+0x1c>
		UCSR1B = _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1);
    36a6:	88 e9       	ldi	r24, 0x98	; 152
    36a8:	81 b9       	out	0x01, r24	; 1
		UCSR1C = _BV(UCSZ11) | _BV(UCSZ10);
    36aa:	86 e0       	ldi	r24, 0x06	; 6
    36ac:	8c bf       	out	0x3c, r24	; 60
    36ae:	04 c0       	rjmp	.+8      	; 0x36b8 <_uart_init+0x24>
	}
	else{
		UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
    36b0:	88 e9       	ldi	r24, 0x98	; 152
    36b2:	8a b9       	out	0x0a, r24	; 10
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
    36b4:	86 e0       	ldi	r24, 0x06	; 6
    36b6:	80 bd       	out	0x20, r24	; 32
	}
    

	_uart_baudrate(__com, __baudrate);
    36b8:	89 2f       	mov	r24, r25
    36ba:	b8 01       	movw	r22, r16
    36bc:	a7 01       	movw	r20, r14
    36be:	0e 94 1f 1b 	call	0x363e	; 0x363e <_uart_baudrate>

	if (__baudrate==5787){
    36c2:	8b e9       	ldi	r24, 0x9B	; 155
    36c4:	e8 16       	cp	r14, r24
    36c6:	86 e1       	ldi	r24, 0x16	; 22
    36c8:	f8 06       	cpc	r15, r24
    36ca:	80 e0       	ldi	r24, 0x00	; 0
    36cc:	08 07       	cpc	r16, r24
    36ce:	80 e0       	ldi	r24, 0x00	; 0
    36d0:	18 07       	cpc	r17, r24
    36d2:	39 f4       	brne	.+14     	; 0x36e2 <_uart_init+0x4e>
	    UCSR0B=_BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
    36d4:	88 e9       	ldi	r24, 0x98	; 152
    36d6:	8a b9       	out	0x0a, r24	; 10
	    UCSR0C=(1<<URSEL0) | (1<<UPM01) | (1<<UCSZ01) | (1<<UCSZ00); // UPM01 untuk set even parity
    36d8:	86 ea       	ldi	r24, 0xA6	; 166
    36da:	80 bd       	out	0x20, r24	; 32
	    UBRR0H=0;UBRR0L=158;// baud 5787       
    36dc:	10 bc       	out	0x20, r1	; 32
    36de:	8e e9       	ldi	r24, 0x9E	; 158
    36e0:	89 b9       	out	0x09, r24	; 9
	}
}
    36e2:	1f 91       	pop	r17
    36e4:	0f 91       	pop	r16
    36e6:	ff 90       	pop	r15
    36e8:	ef 90       	pop	r14
    36ea:	08 95       	ret

000036ec <_uart>:
		UBRR0H = __br >> 8;
	}
}

unsigned char _uart(unsigned char __com, unsigned char __dir, unsigned char __chr){
	if(__com){
    36ec:	88 23       	and	r24, r24
    36ee:	51 f0       	breq	.+20     	; 0x3704 <_uart+0x18>
		if(__dir){
    36f0:	66 23       	and	r22, r22
    36f2:	21 f0       	breq	.+8      	; 0x36fc <_uart+0x10>
			loop_until_bit_is_set(UCSR1A, UDRE1);
    36f4:	15 9b       	sbis	0x02, 5	; 2
    36f6:	fe cf       	rjmp	.-4      	; 0x36f4 <_uart+0x8>
			UDR1 = __chr;
    36f8:	43 b9       	out	0x03, r20	; 3
    36fa:	09 c0       	rjmp	.+18     	; 0x370e <_uart+0x22>
		}
		else{
			loop_until_bit_is_set(UCSR1A, RXC1);
    36fc:	17 9b       	sbis	0x02, 7	; 2
    36fe:	fe cf       	rjmp	.-4      	; 0x36fc <_uart+0x10>
			return UDR1;
    3700:	83 b1       	in	r24, 0x03	; 3
    3702:	08 95       	ret
		}
	}
	else{
		if(__dir){
    3704:	66 23       	and	r22, r22
    3706:	29 f0       	breq	.+10     	; 0x3712 <_uart+0x26>
			loop_until_bit_is_set(UCSR0A, UDRE0);
    3708:	5d 9b       	sbis	0x0b, 5	; 11
    370a:	fe cf       	rjmp	.-4      	; 0x3708 <_uart+0x1c>
			UDR0 = __chr;
    370c:	4c b9       	out	0x0c, r20	; 12
    370e:	81 e0       	ldi	r24, 0x01	; 1
    3710:	08 95       	ret
		}
		else{
			loop_until_bit_is_set(UCSR0A,  RXC0);
    3712:	5f 9b       	sbis	0x0b, 7	; 11
    3714:	fe cf       	rjmp	.-4      	; 0x3712 <_uart+0x26>
			return UDR0;
    3716:	8c b1       	in	r24, 0x0c	; 12
		}

	}

	return 1;
}
    3718:	08 95       	ret

0000371a <_uart_print>:

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
    371a:	0f 93       	push	r16
    371c:	1f 93       	push	r17
    371e:	cf 93       	push	r28
    3720:	df 93       	push	r29
    3722:	18 2f       	mov	r17, r24
    3724:	06 2f       	mov	r16, r22
    3726:	ea 01       	movw	r28, r20
	if(strlen(__str)>0)
    3728:	88 81       	ld	r24, Y
    372a:	88 23       	and	r24, r24
    372c:	31 f4       	brne	.+12     	; 0x373a <_uart_print+0x20>
    372e:	08 c0       	rjmp	.+16     	; 0x3740 <_uart_print+0x26>
		while(*__str) _uart(__com, 1, *__str++);
    3730:	21 96       	adiw	r28, 0x01	; 1
    3732:	81 2f       	mov	r24, r17
    3734:	61 e0       	ldi	r22, 0x01	; 1
    3736:	0e 94 76 1b 	call	0x36ec	; 0x36ec <_uart>
    373a:	48 81       	ld	r20, Y
    373c:	44 23       	and	r20, r20
    373e:	c1 f7       	brne	.-16     	; 0x3730 <_uart_print+0x16>

	if(__ret){
    3740:	00 23       	and	r16, r16
    3742:	51 f0       	breq	.+20     	; 0x3758 <_uart_print+0x3e>
		_uart(__com, 1, 0x0D);
    3744:	81 2f       	mov	r24, r17
    3746:	61 e0       	ldi	r22, 0x01	; 1
    3748:	4d e0       	ldi	r20, 0x0D	; 13
    374a:	0e 94 76 1b 	call	0x36ec	; 0x36ec <_uart>
		_uart(__com, 1, 0x0A);
    374e:	81 2f       	mov	r24, r17
    3750:	61 e0       	ldi	r22, 0x01	; 1
    3752:	4a e0       	ldi	r20, 0x0A	; 10
    3754:	0e 94 76 1b 	call	0x36ec	; 0x36ec <_uart>
    3758:	82 ee       	ldi	r24, 0xE2	; 226
    375a:	94 e0       	ldi	r25, 0x04	; 4
    375c:	01 97       	sbiw	r24, 0x01	; 1
    375e:	f1 f7       	brne	.-4      	; 0x375c <_uart_print+0x42>
	}
	_delay_ms(5);
}
    3760:	df 91       	pop	r29
    3762:	cf 91       	pop	r28
    3764:	1f 91       	pop	r17
    3766:	0f 91       	pop	r16
    3768:	08 95       	ret

0000376a <_uart_printf>:

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
    376a:	0f 93       	push	r16
    376c:	1f 93       	push	r17
    376e:	cf 93       	push	r28
    3770:	df 93       	push	r29
    3772:	18 2f       	mov	r17, r24
    3774:	06 2f       	mov	r16, r22
    3776:	ea 01       	movw	r28, r20
    3778:	07 c0       	rjmp	.+14     	; 0x3788 <_uart_printf+0x1e>
	while(pgm_read_byte(&(*__str)))
		_uart(__com, 1, pgm_read_byte(&(*__str++)));
    377a:	21 96       	adiw	r28, 0x01	; 1
    377c:	f9 01       	movw	r30, r18
    377e:	44 91       	lpm	r20, Z+
    3780:	81 2f       	mov	r24, r17
    3782:	61 e0       	ldi	r22, 0x01	; 1
    3784:	0e 94 76 1b 	call	0x36ec	; 0x36ec <_uart>
    3788:	9e 01       	movw	r18, r28
	}
	_delay_ms(5);
}

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
	while(pgm_read_byte(&(*__str)))
    378a:	fe 01       	movw	r30, r28
    378c:	84 91       	lpm	r24, Z+
    378e:	88 23       	and	r24, r24
    3790:	a1 f7       	brne	.-24     	; 0x377a <_uart_printf+0x10>
		_uart(__com, 1, pgm_read_byte(&(*__str++)));

	if(__ret){
    3792:	00 23       	and	r16, r16
    3794:	51 f0       	breq	.+20     	; 0x37aa <_uart_printf+0x40>
		_uart(__com, 1, 0x0D);
    3796:	81 2f       	mov	r24, r17
    3798:	61 e0       	ldi	r22, 0x01	; 1
    379a:	4d e0       	ldi	r20, 0x0D	; 13
    379c:	0e 94 76 1b 	call	0x36ec	; 0x36ec <_uart>
		_uart(__com, 1, 0x0A);
    37a0:	81 2f       	mov	r24, r17
    37a2:	61 e0       	ldi	r22, 0x01	; 1
    37a4:	4a e0       	ldi	r20, 0x0A	; 10
    37a6:	0e 94 76 1b 	call	0x36ec	; 0x36ec <_uart>
    37aa:	86 ea       	ldi	r24, 0xA6	; 166
    37ac:	9e e0       	ldi	r25, 0x0E	; 14
    37ae:	01 97       	sbiw	r24, 0x01	; 1
    37b0:	f1 f7       	brne	.-4      	; 0x37ae <_uart_printf+0x44>
	}
	_delay_ms(15);
}
    37b2:	df 91       	pop	r29
    37b4:	cf 91       	pop	r28
    37b6:	1f 91       	pop	r17
    37b8:	0f 91       	pop	r16
    37ba:	08 95       	ret

000037bc <sprintf_P>:
    37bc:	ae e0       	ldi	r26, 0x0E	; 14
    37be:	b0 e0       	ldi	r27, 0x00	; 0
    37c0:	e4 ee       	ldi	r30, 0xE4	; 228
    37c2:	fb e1       	ldi	r31, 0x1B	; 27
    37c4:	0c 94 cf 1e 	jmp	0x3d9e	; 0x3d9e <__prologue_saves__+0x1c>
    37c8:	0d 89       	ldd	r16, Y+21	; 0x15
    37ca:	1e 89       	ldd	r17, Y+22	; 0x16
    37cc:	8e e0       	ldi	r24, 0x0E	; 14
    37ce:	8c 83       	std	Y+4, r24	; 0x04
    37d0:	1a 83       	std	Y+2, r17	; 0x02
    37d2:	09 83       	std	Y+1, r16	; 0x01
    37d4:	8f ef       	ldi	r24, 0xFF	; 255
    37d6:	9f e7       	ldi	r25, 0x7F	; 127
    37d8:	9e 83       	std	Y+6, r25	; 0x06
    37da:	8d 83       	std	Y+5, r24	; 0x05
    37dc:	9e 01       	movw	r18, r28
    37de:	27 5e       	subi	r18, 0xE7	; 231
    37e0:	3f 4f       	sbci	r19, 0xFF	; 255
    37e2:	ce 01       	movw	r24, r28
    37e4:	01 96       	adiw	r24, 0x01	; 1
    37e6:	6f 89       	ldd	r22, Y+23	; 0x17
    37e8:	78 8d       	ldd	r23, Y+24	; 0x18
    37ea:	a9 01       	movw	r20, r18
    37ec:	0e 94 02 1c 	call	0x3804	; 0x3804 <vfprintf>
    37f0:	2f 81       	ldd	r18, Y+7	; 0x07
    37f2:	38 85       	ldd	r19, Y+8	; 0x08
    37f4:	02 0f       	add	r16, r18
    37f6:	13 1f       	adc	r17, r19
    37f8:	f8 01       	movw	r30, r16
    37fa:	10 82       	st	Z, r1
    37fc:	2e 96       	adiw	r28, 0x0e	; 14
    37fe:	e4 e0       	ldi	r30, 0x04	; 4
    3800:	0c 94 eb 1e 	jmp	0x3dd6	; 0x3dd6 <__epilogue_restores__+0x1c>

00003804 <vfprintf>:
    3804:	ab e0       	ldi	r26, 0x0B	; 11
    3806:	b0 e0       	ldi	r27, 0x00	; 0
    3808:	e8 e0       	ldi	r30, 0x08	; 8
    380a:	fc e1       	ldi	r31, 0x1C	; 28
    380c:	0c 94 c1 1e 	jmp	0x3d82	; 0x3d82 <__prologue_saves__>
    3810:	3c 01       	movw	r6, r24
    3812:	2b 01       	movw	r4, r22
    3814:	5a 01       	movw	r10, r20
    3816:	fc 01       	movw	r30, r24
    3818:	17 82       	std	Z+7, r1	; 0x07
    381a:	16 82       	std	Z+6, r1	; 0x06
    381c:	83 81       	ldd	r24, Z+3	; 0x03
    381e:	81 fd       	sbrc	r24, 1
    3820:	03 c0       	rjmp	.+6      	; 0x3828 <vfprintf+0x24>
    3822:	6f ef       	ldi	r22, 0xFF	; 255
    3824:	7f ef       	ldi	r23, 0xFF	; 255
    3826:	c6 c1       	rjmp	.+908    	; 0x3bb4 <vfprintf+0x3b0>
    3828:	9a e0       	ldi	r25, 0x0A	; 10
    382a:	89 2e       	mov	r8, r25
    382c:	1e 01       	movw	r2, r28
    382e:	08 94       	sec
    3830:	21 1c       	adc	r2, r1
    3832:	31 1c       	adc	r3, r1
    3834:	f3 01       	movw	r30, r6
    3836:	23 81       	ldd	r18, Z+3	; 0x03
    3838:	f2 01       	movw	r30, r4
    383a:	23 fd       	sbrc	r18, 3
    383c:	85 91       	lpm	r24, Z+
    383e:	23 ff       	sbrs	r18, 3
    3840:	81 91       	ld	r24, Z+
    3842:	2f 01       	movw	r4, r30
    3844:	88 23       	and	r24, r24
    3846:	09 f4       	brne	.+2      	; 0x384a <vfprintf+0x46>
    3848:	b2 c1       	rjmp	.+868    	; 0x3bae <vfprintf+0x3aa>
    384a:	85 32       	cpi	r24, 0x25	; 37
    384c:	39 f4       	brne	.+14     	; 0x385c <vfprintf+0x58>
    384e:	23 fd       	sbrc	r18, 3
    3850:	85 91       	lpm	r24, Z+
    3852:	23 ff       	sbrs	r18, 3
    3854:	81 91       	ld	r24, Z+
    3856:	2f 01       	movw	r4, r30
    3858:	85 32       	cpi	r24, 0x25	; 37
    385a:	29 f4       	brne	.+10     	; 0x3866 <vfprintf+0x62>
    385c:	90 e0       	ldi	r25, 0x00	; 0
    385e:	b3 01       	movw	r22, r6
    3860:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <fputc>
    3864:	e7 cf       	rjmp	.-50     	; 0x3834 <vfprintf+0x30>
    3866:	98 2f       	mov	r25, r24
    3868:	ff 24       	eor	r15, r15
    386a:	ee 24       	eor	r14, r14
    386c:	99 24       	eor	r9, r9
    386e:	ff e1       	ldi	r31, 0x1F	; 31
    3870:	ff 15       	cp	r31, r15
    3872:	d0 f0       	brcs	.+52     	; 0x38a8 <vfprintf+0xa4>
    3874:	9b 32       	cpi	r25, 0x2B	; 43
    3876:	69 f0       	breq	.+26     	; 0x3892 <vfprintf+0x8e>
    3878:	9c 32       	cpi	r25, 0x2C	; 44
    387a:	28 f4       	brcc	.+10     	; 0x3886 <vfprintf+0x82>
    387c:	90 32       	cpi	r25, 0x20	; 32
    387e:	59 f0       	breq	.+22     	; 0x3896 <vfprintf+0x92>
    3880:	93 32       	cpi	r25, 0x23	; 35
    3882:	91 f4       	brne	.+36     	; 0x38a8 <vfprintf+0xa4>
    3884:	0e c0       	rjmp	.+28     	; 0x38a2 <vfprintf+0x9e>
    3886:	9d 32       	cpi	r25, 0x2D	; 45
    3888:	49 f0       	breq	.+18     	; 0x389c <vfprintf+0x98>
    388a:	90 33       	cpi	r25, 0x30	; 48
    388c:	69 f4       	brne	.+26     	; 0x38a8 <vfprintf+0xa4>
    388e:	41 e0       	ldi	r20, 0x01	; 1
    3890:	24 c0       	rjmp	.+72     	; 0x38da <vfprintf+0xd6>
    3892:	52 e0       	ldi	r21, 0x02	; 2
    3894:	f5 2a       	or	r15, r21
    3896:	84 e0       	ldi	r24, 0x04	; 4
    3898:	f8 2a       	or	r15, r24
    389a:	28 c0       	rjmp	.+80     	; 0x38ec <vfprintf+0xe8>
    389c:	98 e0       	ldi	r25, 0x08	; 8
    389e:	f9 2a       	or	r15, r25
    38a0:	25 c0       	rjmp	.+74     	; 0x38ec <vfprintf+0xe8>
    38a2:	e0 e1       	ldi	r30, 0x10	; 16
    38a4:	fe 2a       	or	r15, r30
    38a6:	22 c0       	rjmp	.+68     	; 0x38ec <vfprintf+0xe8>
    38a8:	f7 fc       	sbrc	r15, 7
    38aa:	29 c0       	rjmp	.+82     	; 0x38fe <vfprintf+0xfa>
    38ac:	89 2f       	mov	r24, r25
    38ae:	80 53       	subi	r24, 0x30	; 48
    38b0:	8a 30       	cpi	r24, 0x0A	; 10
    38b2:	70 f4       	brcc	.+28     	; 0x38d0 <vfprintf+0xcc>
    38b4:	f6 fe       	sbrs	r15, 6
    38b6:	05 c0       	rjmp	.+10     	; 0x38c2 <vfprintf+0xbe>
    38b8:	98 9c       	mul	r9, r8
    38ba:	90 2c       	mov	r9, r0
    38bc:	11 24       	eor	r1, r1
    38be:	98 0e       	add	r9, r24
    38c0:	15 c0       	rjmp	.+42     	; 0x38ec <vfprintf+0xe8>
    38c2:	e8 9c       	mul	r14, r8
    38c4:	e0 2c       	mov	r14, r0
    38c6:	11 24       	eor	r1, r1
    38c8:	e8 0e       	add	r14, r24
    38ca:	f0 e2       	ldi	r31, 0x20	; 32
    38cc:	ff 2a       	or	r15, r31
    38ce:	0e c0       	rjmp	.+28     	; 0x38ec <vfprintf+0xe8>
    38d0:	9e 32       	cpi	r25, 0x2E	; 46
    38d2:	29 f4       	brne	.+10     	; 0x38de <vfprintf+0xda>
    38d4:	f6 fc       	sbrc	r15, 6
    38d6:	6b c1       	rjmp	.+726    	; 0x3bae <vfprintf+0x3aa>
    38d8:	40 e4       	ldi	r20, 0x40	; 64
    38da:	f4 2a       	or	r15, r20
    38dc:	07 c0       	rjmp	.+14     	; 0x38ec <vfprintf+0xe8>
    38de:	9c 36       	cpi	r25, 0x6C	; 108
    38e0:	19 f4       	brne	.+6      	; 0x38e8 <vfprintf+0xe4>
    38e2:	50 e8       	ldi	r21, 0x80	; 128
    38e4:	f5 2a       	or	r15, r21
    38e6:	02 c0       	rjmp	.+4      	; 0x38ec <vfprintf+0xe8>
    38e8:	98 36       	cpi	r25, 0x68	; 104
    38ea:	49 f4       	brne	.+18     	; 0x38fe <vfprintf+0xfa>
    38ec:	f2 01       	movw	r30, r4
    38ee:	23 fd       	sbrc	r18, 3
    38f0:	95 91       	lpm	r25, Z+
    38f2:	23 ff       	sbrs	r18, 3
    38f4:	91 91       	ld	r25, Z+
    38f6:	2f 01       	movw	r4, r30
    38f8:	99 23       	and	r25, r25
    38fa:	09 f0       	breq	.+2      	; 0x38fe <vfprintf+0xfa>
    38fc:	b8 cf       	rjmp	.-144    	; 0x386e <vfprintf+0x6a>
    38fe:	89 2f       	mov	r24, r25
    3900:	85 54       	subi	r24, 0x45	; 69
    3902:	83 30       	cpi	r24, 0x03	; 3
    3904:	18 f0       	brcs	.+6      	; 0x390c <vfprintf+0x108>
    3906:	80 52       	subi	r24, 0x20	; 32
    3908:	83 30       	cpi	r24, 0x03	; 3
    390a:	38 f4       	brcc	.+14     	; 0x391a <vfprintf+0x116>
    390c:	44 e0       	ldi	r20, 0x04	; 4
    390e:	50 e0       	ldi	r21, 0x00	; 0
    3910:	a4 0e       	add	r10, r20
    3912:	b5 1e       	adc	r11, r21
    3914:	5f e3       	ldi	r21, 0x3F	; 63
    3916:	59 83       	std	Y+1, r21	; 0x01
    3918:	0f c0       	rjmp	.+30     	; 0x3938 <vfprintf+0x134>
    391a:	93 36       	cpi	r25, 0x63	; 99
    391c:	31 f0       	breq	.+12     	; 0x392a <vfprintf+0x126>
    391e:	93 37       	cpi	r25, 0x73	; 115
    3920:	79 f0       	breq	.+30     	; 0x3940 <vfprintf+0x13c>
    3922:	93 35       	cpi	r25, 0x53	; 83
    3924:	09 f0       	breq	.+2      	; 0x3928 <vfprintf+0x124>
    3926:	56 c0       	rjmp	.+172    	; 0x39d4 <vfprintf+0x1d0>
    3928:	20 c0       	rjmp	.+64     	; 0x396a <vfprintf+0x166>
    392a:	f5 01       	movw	r30, r10
    392c:	80 81       	ld	r24, Z
    392e:	89 83       	std	Y+1, r24	; 0x01
    3930:	42 e0       	ldi	r20, 0x02	; 2
    3932:	50 e0       	ldi	r21, 0x00	; 0
    3934:	a4 0e       	add	r10, r20
    3936:	b5 1e       	adc	r11, r21
    3938:	61 01       	movw	r12, r2
    393a:	01 e0       	ldi	r16, 0x01	; 1
    393c:	10 e0       	ldi	r17, 0x00	; 0
    393e:	12 c0       	rjmp	.+36     	; 0x3964 <vfprintf+0x160>
    3940:	f5 01       	movw	r30, r10
    3942:	c0 80       	ld	r12, Z
    3944:	d1 80       	ldd	r13, Z+1	; 0x01
    3946:	f6 fc       	sbrc	r15, 6
    3948:	03 c0       	rjmp	.+6      	; 0x3950 <vfprintf+0x14c>
    394a:	6f ef       	ldi	r22, 0xFF	; 255
    394c:	7f ef       	ldi	r23, 0xFF	; 255
    394e:	02 c0       	rjmp	.+4      	; 0x3954 <vfprintf+0x150>
    3950:	69 2d       	mov	r22, r9
    3952:	70 e0       	ldi	r23, 0x00	; 0
    3954:	42 e0       	ldi	r20, 0x02	; 2
    3956:	50 e0       	ldi	r21, 0x00	; 0
    3958:	a4 0e       	add	r10, r20
    395a:	b5 1e       	adc	r11, r21
    395c:	c6 01       	movw	r24, r12
    395e:	0e 94 ea 1d 	call	0x3bd4	; 0x3bd4 <strnlen>
    3962:	8c 01       	movw	r16, r24
    3964:	5f e7       	ldi	r21, 0x7F	; 127
    3966:	f5 22       	and	r15, r21
    3968:	14 c0       	rjmp	.+40     	; 0x3992 <vfprintf+0x18e>
    396a:	f5 01       	movw	r30, r10
    396c:	c0 80       	ld	r12, Z
    396e:	d1 80       	ldd	r13, Z+1	; 0x01
    3970:	f6 fc       	sbrc	r15, 6
    3972:	03 c0       	rjmp	.+6      	; 0x397a <vfprintf+0x176>
    3974:	6f ef       	ldi	r22, 0xFF	; 255
    3976:	7f ef       	ldi	r23, 0xFF	; 255
    3978:	02 c0       	rjmp	.+4      	; 0x397e <vfprintf+0x17a>
    397a:	69 2d       	mov	r22, r9
    397c:	70 e0       	ldi	r23, 0x00	; 0
    397e:	42 e0       	ldi	r20, 0x02	; 2
    3980:	50 e0       	ldi	r21, 0x00	; 0
    3982:	a4 0e       	add	r10, r20
    3984:	b5 1e       	adc	r11, r21
    3986:	c6 01       	movw	r24, r12
    3988:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <strnlen_P>
    398c:	8c 01       	movw	r16, r24
    398e:	50 e8       	ldi	r21, 0x80	; 128
    3990:	f5 2a       	or	r15, r21
    3992:	f3 fe       	sbrs	r15, 3
    3994:	07 c0       	rjmp	.+14     	; 0x39a4 <vfprintf+0x1a0>
    3996:	1a c0       	rjmp	.+52     	; 0x39cc <vfprintf+0x1c8>
    3998:	80 e2       	ldi	r24, 0x20	; 32
    399a:	90 e0       	ldi	r25, 0x00	; 0
    399c:	b3 01       	movw	r22, r6
    399e:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <fputc>
    39a2:	ea 94       	dec	r14
    39a4:	8e 2d       	mov	r24, r14
    39a6:	90 e0       	ldi	r25, 0x00	; 0
    39a8:	08 17       	cp	r16, r24
    39aa:	19 07       	cpc	r17, r25
    39ac:	a8 f3       	brcs	.-22     	; 0x3998 <vfprintf+0x194>
    39ae:	0e c0       	rjmp	.+28     	; 0x39cc <vfprintf+0x1c8>
    39b0:	f6 01       	movw	r30, r12
    39b2:	f7 fc       	sbrc	r15, 7
    39b4:	85 91       	lpm	r24, Z+
    39b6:	f7 fe       	sbrs	r15, 7
    39b8:	81 91       	ld	r24, Z+
    39ba:	6f 01       	movw	r12, r30
    39bc:	90 e0       	ldi	r25, 0x00	; 0
    39be:	b3 01       	movw	r22, r6
    39c0:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <fputc>
    39c4:	e1 10       	cpse	r14, r1
    39c6:	ea 94       	dec	r14
    39c8:	01 50       	subi	r16, 0x01	; 1
    39ca:	10 40       	sbci	r17, 0x00	; 0
    39cc:	01 15       	cp	r16, r1
    39ce:	11 05       	cpc	r17, r1
    39d0:	79 f7       	brne	.-34     	; 0x39b0 <vfprintf+0x1ac>
    39d2:	ea c0       	rjmp	.+468    	; 0x3ba8 <vfprintf+0x3a4>
    39d4:	94 36       	cpi	r25, 0x64	; 100
    39d6:	11 f0       	breq	.+4      	; 0x39dc <vfprintf+0x1d8>
    39d8:	99 36       	cpi	r25, 0x69	; 105
    39da:	69 f5       	brne	.+90     	; 0x3a36 <vfprintf+0x232>
    39dc:	f7 fe       	sbrs	r15, 7
    39de:	08 c0       	rjmp	.+16     	; 0x39f0 <vfprintf+0x1ec>
    39e0:	f5 01       	movw	r30, r10
    39e2:	20 81       	ld	r18, Z
    39e4:	31 81       	ldd	r19, Z+1	; 0x01
    39e6:	42 81       	ldd	r20, Z+2	; 0x02
    39e8:	53 81       	ldd	r21, Z+3	; 0x03
    39ea:	84 e0       	ldi	r24, 0x04	; 4
    39ec:	90 e0       	ldi	r25, 0x00	; 0
    39ee:	0a c0       	rjmp	.+20     	; 0x3a04 <vfprintf+0x200>
    39f0:	f5 01       	movw	r30, r10
    39f2:	80 81       	ld	r24, Z
    39f4:	91 81       	ldd	r25, Z+1	; 0x01
    39f6:	9c 01       	movw	r18, r24
    39f8:	44 27       	eor	r20, r20
    39fa:	37 fd       	sbrc	r19, 7
    39fc:	40 95       	com	r20
    39fe:	54 2f       	mov	r21, r20
    3a00:	82 e0       	ldi	r24, 0x02	; 2
    3a02:	90 e0       	ldi	r25, 0x00	; 0
    3a04:	a8 0e       	add	r10, r24
    3a06:	b9 1e       	adc	r11, r25
    3a08:	9f e6       	ldi	r25, 0x6F	; 111
    3a0a:	f9 22       	and	r15, r25
    3a0c:	57 ff       	sbrs	r21, 7
    3a0e:	09 c0       	rjmp	.+18     	; 0x3a22 <vfprintf+0x21e>
    3a10:	50 95       	com	r21
    3a12:	40 95       	com	r20
    3a14:	30 95       	com	r19
    3a16:	21 95       	neg	r18
    3a18:	3f 4f       	sbci	r19, 0xFF	; 255
    3a1a:	4f 4f       	sbci	r20, 0xFF	; 255
    3a1c:	5f 4f       	sbci	r21, 0xFF	; 255
    3a1e:	e0 e8       	ldi	r30, 0x80	; 128
    3a20:	fe 2a       	or	r15, r30
    3a22:	ca 01       	movw	r24, r20
    3a24:	b9 01       	movw	r22, r18
    3a26:	a1 01       	movw	r20, r2
    3a28:	2a e0       	ldi	r18, 0x0A	; 10
    3a2a:	30 e0       	ldi	r19, 0x00	; 0
    3a2c:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <__ultoa_invert>
    3a30:	d8 2e       	mov	r13, r24
    3a32:	d2 18       	sub	r13, r2
    3a34:	40 c0       	rjmp	.+128    	; 0x3ab6 <vfprintf+0x2b2>
    3a36:	95 37       	cpi	r25, 0x75	; 117
    3a38:	29 f4       	brne	.+10     	; 0x3a44 <vfprintf+0x240>
    3a3a:	1f 2d       	mov	r17, r15
    3a3c:	1f 7e       	andi	r17, 0xEF	; 239
    3a3e:	2a e0       	ldi	r18, 0x0A	; 10
    3a40:	30 e0       	ldi	r19, 0x00	; 0
    3a42:	1d c0       	rjmp	.+58     	; 0x3a7e <vfprintf+0x27a>
    3a44:	1f 2d       	mov	r17, r15
    3a46:	19 7f       	andi	r17, 0xF9	; 249
    3a48:	9f 36       	cpi	r25, 0x6F	; 111
    3a4a:	61 f0       	breq	.+24     	; 0x3a64 <vfprintf+0x260>
    3a4c:	90 37       	cpi	r25, 0x70	; 112
    3a4e:	20 f4       	brcc	.+8      	; 0x3a58 <vfprintf+0x254>
    3a50:	98 35       	cpi	r25, 0x58	; 88
    3a52:	09 f0       	breq	.+2      	; 0x3a56 <vfprintf+0x252>
    3a54:	ac c0       	rjmp	.+344    	; 0x3bae <vfprintf+0x3aa>
    3a56:	0f c0       	rjmp	.+30     	; 0x3a76 <vfprintf+0x272>
    3a58:	90 37       	cpi	r25, 0x70	; 112
    3a5a:	39 f0       	breq	.+14     	; 0x3a6a <vfprintf+0x266>
    3a5c:	98 37       	cpi	r25, 0x78	; 120
    3a5e:	09 f0       	breq	.+2      	; 0x3a62 <vfprintf+0x25e>
    3a60:	a6 c0       	rjmp	.+332    	; 0x3bae <vfprintf+0x3aa>
    3a62:	04 c0       	rjmp	.+8      	; 0x3a6c <vfprintf+0x268>
    3a64:	28 e0       	ldi	r18, 0x08	; 8
    3a66:	30 e0       	ldi	r19, 0x00	; 0
    3a68:	0a c0       	rjmp	.+20     	; 0x3a7e <vfprintf+0x27a>
    3a6a:	10 61       	ori	r17, 0x10	; 16
    3a6c:	14 fd       	sbrc	r17, 4
    3a6e:	14 60       	ori	r17, 0x04	; 4
    3a70:	20 e1       	ldi	r18, 0x10	; 16
    3a72:	30 e0       	ldi	r19, 0x00	; 0
    3a74:	04 c0       	rjmp	.+8      	; 0x3a7e <vfprintf+0x27a>
    3a76:	14 fd       	sbrc	r17, 4
    3a78:	16 60       	ori	r17, 0x06	; 6
    3a7a:	20 e1       	ldi	r18, 0x10	; 16
    3a7c:	32 e0       	ldi	r19, 0x02	; 2
    3a7e:	17 ff       	sbrs	r17, 7
    3a80:	08 c0       	rjmp	.+16     	; 0x3a92 <vfprintf+0x28e>
    3a82:	f5 01       	movw	r30, r10
    3a84:	60 81       	ld	r22, Z
    3a86:	71 81       	ldd	r23, Z+1	; 0x01
    3a88:	82 81       	ldd	r24, Z+2	; 0x02
    3a8a:	93 81       	ldd	r25, Z+3	; 0x03
    3a8c:	44 e0       	ldi	r20, 0x04	; 4
    3a8e:	50 e0       	ldi	r21, 0x00	; 0
    3a90:	08 c0       	rjmp	.+16     	; 0x3aa2 <vfprintf+0x29e>
    3a92:	f5 01       	movw	r30, r10
    3a94:	80 81       	ld	r24, Z
    3a96:	91 81       	ldd	r25, Z+1	; 0x01
    3a98:	bc 01       	movw	r22, r24
    3a9a:	80 e0       	ldi	r24, 0x00	; 0
    3a9c:	90 e0       	ldi	r25, 0x00	; 0
    3a9e:	42 e0       	ldi	r20, 0x02	; 2
    3aa0:	50 e0       	ldi	r21, 0x00	; 0
    3aa2:	a4 0e       	add	r10, r20
    3aa4:	b5 1e       	adc	r11, r21
    3aa6:	a1 01       	movw	r20, r2
    3aa8:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <__ultoa_invert>
    3aac:	d8 2e       	mov	r13, r24
    3aae:	d2 18       	sub	r13, r2
    3ab0:	8f e7       	ldi	r24, 0x7F	; 127
    3ab2:	f8 2e       	mov	r15, r24
    3ab4:	f1 22       	and	r15, r17
    3ab6:	f6 fe       	sbrs	r15, 6
    3ab8:	0b c0       	rjmp	.+22     	; 0x3ad0 <vfprintf+0x2cc>
    3aba:	5e ef       	ldi	r21, 0xFE	; 254
    3abc:	f5 22       	and	r15, r21
    3abe:	d9 14       	cp	r13, r9
    3ac0:	38 f4       	brcc	.+14     	; 0x3ad0 <vfprintf+0x2cc>
    3ac2:	f4 fe       	sbrs	r15, 4
    3ac4:	07 c0       	rjmp	.+14     	; 0x3ad4 <vfprintf+0x2d0>
    3ac6:	f2 fc       	sbrc	r15, 2
    3ac8:	05 c0       	rjmp	.+10     	; 0x3ad4 <vfprintf+0x2d0>
    3aca:	8f ee       	ldi	r24, 0xEF	; 239
    3acc:	f8 22       	and	r15, r24
    3ace:	02 c0       	rjmp	.+4      	; 0x3ad4 <vfprintf+0x2d0>
    3ad0:	1d 2d       	mov	r17, r13
    3ad2:	01 c0       	rjmp	.+2      	; 0x3ad6 <vfprintf+0x2d2>
    3ad4:	19 2d       	mov	r17, r9
    3ad6:	f4 fe       	sbrs	r15, 4
    3ad8:	0d c0       	rjmp	.+26     	; 0x3af4 <vfprintf+0x2f0>
    3ada:	fe 01       	movw	r30, r28
    3adc:	ed 0d       	add	r30, r13
    3ade:	f1 1d       	adc	r31, r1
    3ae0:	80 81       	ld	r24, Z
    3ae2:	80 33       	cpi	r24, 0x30	; 48
    3ae4:	19 f4       	brne	.+6      	; 0x3aec <vfprintf+0x2e8>
    3ae6:	99 ee       	ldi	r25, 0xE9	; 233
    3ae8:	f9 22       	and	r15, r25
    3aea:	08 c0       	rjmp	.+16     	; 0x3afc <vfprintf+0x2f8>
    3aec:	1f 5f       	subi	r17, 0xFF	; 255
    3aee:	f2 fe       	sbrs	r15, 2
    3af0:	05 c0       	rjmp	.+10     	; 0x3afc <vfprintf+0x2f8>
    3af2:	03 c0       	rjmp	.+6      	; 0x3afa <vfprintf+0x2f6>
    3af4:	8f 2d       	mov	r24, r15
    3af6:	86 78       	andi	r24, 0x86	; 134
    3af8:	09 f0       	breq	.+2      	; 0x3afc <vfprintf+0x2f8>
    3afa:	1f 5f       	subi	r17, 0xFF	; 255
    3afc:	0f 2d       	mov	r16, r15
    3afe:	f3 fc       	sbrc	r15, 3
    3b00:	14 c0       	rjmp	.+40     	; 0x3b2a <vfprintf+0x326>
    3b02:	f0 fe       	sbrs	r15, 0
    3b04:	0f c0       	rjmp	.+30     	; 0x3b24 <vfprintf+0x320>
    3b06:	1e 15       	cp	r17, r14
    3b08:	10 f0       	brcs	.+4      	; 0x3b0e <vfprintf+0x30a>
    3b0a:	9d 2c       	mov	r9, r13
    3b0c:	0b c0       	rjmp	.+22     	; 0x3b24 <vfprintf+0x320>
    3b0e:	9d 2c       	mov	r9, r13
    3b10:	9e 0c       	add	r9, r14
    3b12:	91 1a       	sub	r9, r17
    3b14:	1e 2d       	mov	r17, r14
    3b16:	06 c0       	rjmp	.+12     	; 0x3b24 <vfprintf+0x320>
    3b18:	80 e2       	ldi	r24, 0x20	; 32
    3b1a:	90 e0       	ldi	r25, 0x00	; 0
    3b1c:	b3 01       	movw	r22, r6
    3b1e:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <fputc>
    3b22:	1f 5f       	subi	r17, 0xFF	; 255
    3b24:	1e 15       	cp	r17, r14
    3b26:	c0 f3       	brcs	.-16     	; 0x3b18 <vfprintf+0x314>
    3b28:	04 c0       	rjmp	.+8      	; 0x3b32 <vfprintf+0x32e>
    3b2a:	1e 15       	cp	r17, r14
    3b2c:	10 f4       	brcc	.+4      	; 0x3b32 <vfprintf+0x32e>
    3b2e:	e1 1a       	sub	r14, r17
    3b30:	01 c0       	rjmp	.+2      	; 0x3b34 <vfprintf+0x330>
    3b32:	ee 24       	eor	r14, r14
    3b34:	04 ff       	sbrs	r16, 4
    3b36:	0f c0       	rjmp	.+30     	; 0x3b56 <vfprintf+0x352>
    3b38:	80 e3       	ldi	r24, 0x30	; 48
    3b3a:	90 e0       	ldi	r25, 0x00	; 0
    3b3c:	b3 01       	movw	r22, r6
    3b3e:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <fputc>
    3b42:	02 ff       	sbrs	r16, 2
    3b44:	1d c0       	rjmp	.+58     	; 0x3b80 <vfprintf+0x37c>
    3b46:	01 fd       	sbrc	r16, 1
    3b48:	03 c0       	rjmp	.+6      	; 0x3b50 <vfprintf+0x34c>
    3b4a:	88 e7       	ldi	r24, 0x78	; 120
    3b4c:	90 e0       	ldi	r25, 0x00	; 0
    3b4e:	0e c0       	rjmp	.+28     	; 0x3b6c <vfprintf+0x368>
    3b50:	88 e5       	ldi	r24, 0x58	; 88
    3b52:	90 e0       	ldi	r25, 0x00	; 0
    3b54:	0b c0       	rjmp	.+22     	; 0x3b6c <vfprintf+0x368>
    3b56:	80 2f       	mov	r24, r16
    3b58:	86 78       	andi	r24, 0x86	; 134
    3b5a:	91 f0       	breq	.+36     	; 0x3b80 <vfprintf+0x37c>
    3b5c:	01 ff       	sbrs	r16, 1
    3b5e:	02 c0       	rjmp	.+4      	; 0x3b64 <vfprintf+0x360>
    3b60:	8b e2       	ldi	r24, 0x2B	; 43
    3b62:	01 c0       	rjmp	.+2      	; 0x3b66 <vfprintf+0x362>
    3b64:	80 e2       	ldi	r24, 0x20	; 32
    3b66:	f7 fc       	sbrc	r15, 7
    3b68:	8d e2       	ldi	r24, 0x2D	; 45
    3b6a:	90 e0       	ldi	r25, 0x00	; 0
    3b6c:	b3 01       	movw	r22, r6
    3b6e:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <fputc>
    3b72:	06 c0       	rjmp	.+12     	; 0x3b80 <vfprintf+0x37c>
    3b74:	80 e3       	ldi	r24, 0x30	; 48
    3b76:	90 e0       	ldi	r25, 0x00	; 0
    3b78:	b3 01       	movw	r22, r6
    3b7a:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <fputc>
    3b7e:	9a 94       	dec	r9
    3b80:	d9 14       	cp	r13, r9
    3b82:	c0 f3       	brcs	.-16     	; 0x3b74 <vfprintf+0x370>
    3b84:	da 94       	dec	r13
    3b86:	f1 01       	movw	r30, r2
    3b88:	ed 0d       	add	r30, r13
    3b8a:	f1 1d       	adc	r31, r1
    3b8c:	80 81       	ld	r24, Z
    3b8e:	90 e0       	ldi	r25, 0x00	; 0
    3b90:	b3 01       	movw	r22, r6
    3b92:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <fputc>
    3b96:	dd 20       	and	r13, r13
    3b98:	a9 f7       	brne	.-22     	; 0x3b84 <vfprintf+0x380>
    3b9a:	06 c0       	rjmp	.+12     	; 0x3ba8 <vfprintf+0x3a4>
    3b9c:	80 e2       	ldi	r24, 0x20	; 32
    3b9e:	90 e0       	ldi	r25, 0x00	; 0
    3ba0:	b3 01       	movw	r22, r6
    3ba2:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <fputc>
    3ba6:	ea 94       	dec	r14
    3ba8:	ee 20       	and	r14, r14
    3baa:	c1 f7       	brne	.-16     	; 0x3b9c <vfprintf+0x398>
    3bac:	43 ce       	rjmp	.-890    	; 0x3834 <vfprintf+0x30>
    3bae:	f3 01       	movw	r30, r6
    3bb0:	66 81       	ldd	r22, Z+6	; 0x06
    3bb2:	77 81       	ldd	r23, Z+7	; 0x07
    3bb4:	cb 01       	movw	r24, r22
    3bb6:	2b 96       	adiw	r28, 0x0b	; 11
    3bb8:	e2 e1       	ldi	r30, 0x12	; 18
    3bba:	0c 94 dd 1e 	jmp	0x3dba	; 0x3dba <__epilogue_restores__>

00003bbe <strnlen_P>:
    3bbe:	fc 01       	movw	r30, r24
    3bc0:	05 90       	lpm	r0, Z+
    3bc2:	61 50       	subi	r22, 0x01	; 1
    3bc4:	70 40       	sbci	r23, 0x00	; 0
    3bc6:	01 10       	cpse	r0, r1
    3bc8:	d8 f7       	brcc	.-10     	; 0x3bc0 <strnlen_P+0x2>
    3bca:	80 95       	com	r24
    3bcc:	90 95       	com	r25
    3bce:	8e 0f       	add	r24, r30
    3bd0:	9f 1f       	adc	r25, r31
    3bd2:	08 95       	ret

00003bd4 <strnlen>:
    3bd4:	fc 01       	movw	r30, r24
    3bd6:	61 50       	subi	r22, 0x01	; 1
    3bd8:	70 40       	sbci	r23, 0x00	; 0
    3bda:	01 90       	ld	r0, Z+
    3bdc:	01 10       	cpse	r0, r1
    3bde:	d8 f7       	brcc	.-10     	; 0x3bd6 <strnlen+0x2>
    3be0:	80 95       	com	r24
    3be2:	90 95       	com	r25
    3be4:	8e 0f       	add	r24, r30
    3be6:	9f 1f       	adc	r25, r31
    3be8:	08 95       	ret

00003bea <fputc>:
    3bea:	0f 93       	push	r16
    3bec:	1f 93       	push	r17
    3bee:	cf 93       	push	r28
    3bf0:	df 93       	push	r29
    3bf2:	8c 01       	movw	r16, r24
    3bf4:	eb 01       	movw	r28, r22
    3bf6:	8b 81       	ldd	r24, Y+3	; 0x03
    3bf8:	81 ff       	sbrs	r24, 1
    3bfa:	1b c0       	rjmp	.+54     	; 0x3c32 <fputc+0x48>
    3bfc:	82 ff       	sbrs	r24, 2
    3bfe:	0d c0       	rjmp	.+26     	; 0x3c1a <fputc+0x30>
    3c00:	2e 81       	ldd	r18, Y+6	; 0x06
    3c02:	3f 81       	ldd	r19, Y+7	; 0x07
    3c04:	8c 81       	ldd	r24, Y+4	; 0x04
    3c06:	9d 81       	ldd	r25, Y+5	; 0x05
    3c08:	28 17       	cp	r18, r24
    3c0a:	39 07       	cpc	r19, r25
    3c0c:	64 f4       	brge	.+24     	; 0x3c26 <fputc+0x3c>
    3c0e:	e8 81       	ld	r30, Y
    3c10:	f9 81       	ldd	r31, Y+1	; 0x01
    3c12:	01 93       	st	Z+, r16
    3c14:	f9 83       	std	Y+1, r31	; 0x01
    3c16:	e8 83       	st	Y, r30
    3c18:	06 c0       	rjmp	.+12     	; 0x3c26 <fputc+0x3c>
    3c1a:	e8 85       	ldd	r30, Y+8	; 0x08
    3c1c:	f9 85       	ldd	r31, Y+9	; 0x09
    3c1e:	80 2f       	mov	r24, r16
    3c20:	09 95       	icall
    3c22:	89 2b       	or	r24, r25
    3c24:	31 f4       	brne	.+12     	; 0x3c32 <fputc+0x48>
    3c26:	8e 81       	ldd	r24, Y+6	; 0x06
    3c28:	9f 81       	ldd	r25, Y+7	; 0x07
    3c2a:	01 96       	adiw	r24, 0x01	; 1
    3c2c:	9f 83       	std	Y+7, r25	; 0x07
    3c2e:	8e 83       	std	Y+6, r24	; 0x06
    3c30:	02 c0       	rjmp	.+4      	; 0x3c36 <fputc+0x4c>
    3c32:	0f ef       	ldi	r16, 0xFF	; 255
    3c34:	1f ef       	ldi	r17, 0xFF	; 255
    3c36:	c8 01       	movw	r24, r16
    3c38:	df 91       	pop	r29
    3c3a:	cf 91       	pop	r28
    3c3c:	1f 91       	pop	r17
    3c3e:	0f 91       	pop	r16
    3c40:	08 95       	ret

00003c42 <__ultoa_invert>:
    3c42:	fa 01       	movw	r30, r20
    3c44:	aa 27       	eor	r26, r26
    3c46:	28 30       	cpi	r18, 0x08	; 8
    3c48:	51 f1       	breq	.+84     	; 0x3c9e <__ultoa_invert+0x5c>
    3c4a:	20 31       	cpi	r18, 0x10	; 16
    3c4c:	81 f1       	breq	.+96     	; 0x3cae <__ultoa_invert+0x6c>
    3c4e:	e8 94       	clt
    3c50:	6f 93       	push	r22
    3c52:	6e 7f       	andi	r22, 0xFE	; 254
    3c54:	6e 5f       	subi	r22, 0xFE	; 254
    3c56:	7f 4f       	sbci	r23, 0xFF	; 255
    3c58:	8f 4f       	sbci	r24, 0xFF	; 255
    3c5a:	9f 4f       	sbci	r25, 0xFF	; 255
    3c5c:	af 4f       	sbci	r26, 0xFF	; 255
    3c5e:	b1 e0       	ldi	r27, 0x01	; 1
    3c60:	3e d0       	rcall	.+124    	; 0x3cde <__ultoa_invert+0x9c>
    3c62:	b4 e0       	ldi	r27, 0x04	; 4
    3c64:	3c d0       	rcall	.+120    	; 0x3cde <__ultoa_invert+0x9c>
    3c66:	67 0f       	add	r22, r23
    3c68:	78 1f       	adc	r23, r24
    3c6a:	89 1f       	adc	r24, r25
    3c6c:	9a 1f       	adc	r25, r26
    3c6e:	a1 1d       	adc	r26, r1
    3c70:	68 0f       	add	r22, r24
    3c72:	79 1f       	adc	r23, r25
    3c74:	8a 1f       	adc	r24, r26
    3c76:	91 1d       	adc	r25, r1
    3c78:	a1 1d       	adc	r26, r1
    3c7a:	6a 0f       	add	r22, r26
    3c7c:	71 1d       	adc	r23, r1
    3c7e:	81 1d       	adc	r24, r1
    3c80:	91 1d       	adc	r25, r1
    3c82:	a1 1d       	adc	r26, r1
    3c84:	20 d0       	rcall	.+64     	; 0x3cc6 <__ultoa_invert+0x84>
    3c86:	09 f4       	brne	.+2      	; 0x3c8a <__ultoa_invert+0x48>
    3c88:	68 94       	set
    3c8a:	3f 91       	pop	r19
    3c8c:	2a e0       	ldi	r18, 0x0A	; 10
    3c8e:	26 9f       	mul	r18, r22
    3c90:	11 24       	eor	r1, r1
    3c92:	30 19       	sub	r19, r0
    3c94:	30 5d       	subi	r19, 0xD0	; 208
    3c96:	31 93       	st	Z+, r19
    3c98:	de f6       	brtc	.-74     	; 0x3c50 <__ultoa_invert+0xe>
    3c9a:	cf 01       	movw	r24, r30
    3c9c:	08 95       	ret
    3c9e:	46 2f       	mov	r20, r22
    3ca0:	47 70       	andi	r20, 0x07	; 7
    3ca2:	40 5d       	subi	r20, 0xD0	; 208
    3ca4:	41 93       	st	Z+, r20
    3ca6:	b3 e0       	ldi	r27, 0x03	; 3
    3ca8:	0f d0       	rcall	.+30     	; 0x3cc8 <__ultoa_invert+0x86>
    3caa:	c9 f7       	brne	.-14     	; 0x3c9e <__ultoa_invert+0x5c>
    3cac:	f6 cf       	rjmp	.-20     	; 0x3c9a <__ultoa_invert+0x58>
    3cae:	46 2f       	mov	r20, r22
    3cb0:	4f 70       	andi	r20, 0x0F	; 15
    3cb2:	40 5d       	subi	r20, 0xD0	; 208
    3cb4:	4a 33       	cpi	r20, 0x3A	; 58
    3cb6:	18 f0       	brcs	.+6      	; 0x3cbe <__ultoa_invert+0x7c>
    3cb8:	49 5d       	subi	r20, 0xD9	; 217
    3cba:	31 fd       	sbrc	r19, 1
    3cbc:	40 52       	subi	r20, 0x20	; 32
    3cbe:	41 93       	st	Z+, r20
    3cc0:	02 d0       	rcall	.+4      	; 0x3cc6 <__ultoa_invert+0x84>
    3cc2:	a9 f7       	brne	.-22     	; 0x3cae <__ultoa_invert+0x6c>
    3cc4:	ea cf       	rjmp	.-44     	; 0x3c9a <__ultoa_invert+0x58>
    3cc6:	b4 e0       	ldi	r27, 0x04	; 4
    3cc8:	a6 95       	lsr	r26
    3cca:	97 95       	ror	r25
    3ccc:	87 95       	ror	r24
    3cce:	77 95       	ror	r23
    3cd0:	67 95       	ror	r22
    3cd2:	ba 95       	dec	r27
    3cd4:	c9 f7       	brne	.-14     	; 0x3cc8 <__ultoa_invert+0x86>
    3cd6:	00 97       	sbiw	r24, 0x00	; 0
    3cd8:	61 05       	cpc	r22, r1
    3cda:	71 05       	cpc	r23, r1
    3cdc:	08 95       	ret
    3cde:	9b 01       	movw	r18, r22
    3ce0:	ac 01       	movw	r20, r24
    3ce2:	0a 2e       	mov	r0, r26
    3ce4:	06 94       	lsr	r0
    3ce6:	57 95       	ror	r21
    3ce8:	47 95       	ror	r20
    3cea:	37 95       	ror	r19
    3cec:	27 95       	ror	r18
    3cee:	ba 95       	dec	r27
    3cf0:	c9 f7       	brne	.-14     	; 0x3ce4 <__ultoa_invert+0xa2>
    3cf2:	62 0f       	add	r22, r18
    3cf4:	73 1f       	adc	r23, r19
    3cf6:	84 1f       	adc	r24, r20
    3cf8:	95 1f       	adc	r25, r21
    3cfa:	a0 1d       	adc	r26, r0
    3cfc:	08 95       	ret

00003cfe <__udivmodqi4>:
    3cfe:	99 1b       	sub	r25, r25
    3d00:	79 e0       	ldi	r23, 0x09	; 9
    3d02:	04 c0       	rjmp	.+8      	; 0x3d0c <__udivmodqi4_ep>

00003d04 <__udivmodqi4_loop>:
    3d04:	99 1f       	adc	r25, r25
    3d06:	96 17       	cp	r25, r22
    3d08:	08 f0       	brcs	.+2      	; 0x3d0c <__udivmodqi4_ep>
    3d0a:	96 1b       	sub	r25, r22

00003d0c <__udivmodqi4_ep>:
    3d0c:	88 1f       	adc	r24, r24
    3d0e:	7a 95       	dec	r23
    3d10:	c9 f7       	brne	.-14     	; 0x3d04 <__udivmodqi4_loop>
    3d12:	80 95       	com	r24
    3d14:	08 95       	ret

00003d16 <__udivmodhi4>:
    3d16:	aa 1b       	sub	r26, r26
    3d18:	bb 1b       	sub	r27, r27
    3d1a:	51 e1       	ldi	r21, 0x11	; 17
    3d1c:	07 c0       	rjmp	.+14     	; 0x3d2c <__udivmodhi4_ep>

00003d1e <__udivmodhi4_loop>:
    3d1e:	aa 1f       	adc	r26, r26
    3d20:	bb 1f       	adc	r27, r27
    3d22:	a6 17       	cp	r26, r22
    3d24:	b7 07       	cpc	r27, r23
    3d26:	10 f0       	brcs	.+4      	; 0x3d2c <__udivmodhi4_ep>
    3d28:	a6 1b       	sub	r26, r22
    3d2a:	b7 0b       	sbc	r27, r23

00003d2c <__udivmodhi4_ep>:
    3d2c:	88 1f       	adc	r24, r24
    3d2e:	99 1f       	adc	r25, r25
    3d30:	5a 95       	dec	r21
    3d32:	a9 f7       	brne	.-22     	; 0x3d1e <__udivmodhi4_loop>
    3d34:	80 95       	com	r24
    3d36:	90 95       	com	r25
    3d38:	bc 01       	movw	r22, r24
    3d3a:	cd 01       	movw	r24, r26
    3d3c:	08 95       	ret

00003d3e <__udivmodsi4>:
    3d3e:	a1 e2       	ldi	r26, 0x21	; 33
    3d40:	1a 2e       	mov	r1, r26
    3d42:	aa 1b       	sub	r26, r26
    3d44:	bb 1b       	sub	r27, r27
    3d46:	fd 01       	movw	r30, r26
    3d48:	0d c0       	rjmp	.+26     	; 0x3d64 <__udivmodsi4_ep>

00003d4a <__udivmodsi4_loop>:
    3d4a:	aa 1f       	adc	r26, r26
    3d4c:	bb 1f       	adc	r27, r27
    3d4e:	ee 1f       	adc	r30, r30
    3d50:	ff 1f       	adc	r31, r31
    3d52:	a2 17       	cp	r26, r18
    3d54:	b3 07       	cpc	r27, r19
    3d56:	e4 07       	cpc	r30, r20
    3d58:	f5 07       	cpc	r31, r21
    3d5a:	20 f0       	brcs	.+8      	; 0x3d64 <__udivmodsi4_ep>
    3d5c:	a2 1b       	sub	r26, r18
    3d5e:	b3 0b       	sbc	r27, r19
    3d60:	e4 0b       	sbc	r30, r20
    3d62:	f5 0b       	sbc	r31, r21

00003d64 <__udivmodsi4_ep>:
    3d64:	66 1f       	adc	r22, r22
    3d66:	77 1f       	adc	r23, r23
    3d68:	88 1f       	adc	r24, r24
    3d6a:	99 1f       	adc	r25, r25
    3d6c:	1a 94       	dec	r1
    3d6e:	69 f7       	brne	.-38     	; 0x3d4a <__udivmodsi4_loop>
    3d70:	60 95       	com	r22
    3d72:	70 95       	com	r23
    3d74:	80 95       	com	r24
    3d76:	90 95       	com	r25
    3d78:	9b 01       	movw	r18, r22
    3d7a:	ac 01       	movw	r20, r24
    3d7c:	bd 01       	movw	r22, r26
    3d7e:	cf 01       	movw	r24, r30
    3d80:	08 95       	ret

00003d82 <__prologue_saves__>:
    3d82:	2f 92       	push	r2
    3d84:	3f 92       	push	r3
    3d86:	4f 92       	push	r4
    3d88:	5f 92       	push	r5
    3d8a:	6f 92       	push	r6
    3d8c:	7f 92       	push	r7
    3d8e:	8f 92       	push	r8
    3d90:	9f 92       	push	r9
    3d92:	af 92       	push	r10
    3d94:	bf 92       	push	r11
    3d96:	cf 92       	push	r12
    3d98:	df 92       	push	r13
    3d9a:	ef 92       	push	r14
    3d9c:	ff 92       	push	r15
    3d9e:	0f 93       	push	r16
    3da0:	1f 93       	push	r17
    3da2:	cf 93       	push	r28
    3da4:	df 93       	push	r29
    3da6:	cd b7       	in	r28, 0x3d	; 61
    3da8:	de b7       	in	r29, 0x3e	; 62
    3daa:	ca 1b       	sub	r28, r26
    3dac:	db 0b       	sbc	r29, r27
    3dae:	0f b6       	in	r0, 0x3f	; 63
    3db0:	f8 94       	cli
    3db2:	de bf       	out	0x3e, r29	; 62
    3db4:	0f be       	out	0x3f, r0	; 63
    3db6:	cd bf       	out	0x3d, r28	; 61
    3db8:	09 94       	ijmp

00003dba <__epilogue_restores__>:
    3dba:	2a 88       	ldd	r2, Y+18	; 0x12
    3dbc:	39 88       	ldd	r3, Y+17	; 0x11
    3dbe:	48 88       	ldd	r4, Y+16	; 0x10
    3dc0:	5f 84       	ldd	r5, Y+15	; 0x0f
    3dc2:	6e 84       	ldd	r6, Y+14	; 0x0e
    3dc4:	7d 84       	ldd	r7, Y+13	; 0x0d
    3dc6:	8c 84       	ldd	r8, Y+12	; 0x0c
    3dc8:	9b 84       	ldd	r9, Y+11	; 0x0b
    3dca:	aa 84       	ldd	r10, Y+10	; 0x0a
    3dcc:	b9 84       	ldd	r11, Y+9	; 0x09
    3dce:	c8 84       	ldd	r12, Y+8	; 0x08
    3dd0:	df 80       	ldd	r13, Y+7	; 0x07
    3dd2:	ee 80       	ldd	r14, Y+6	; 0x06
    3dd4:	fd 80       	ldd	r15, Y+5	; 0x05
    3dd6:	0c 81       	ldd	r16, Y+4	; 0x04
    3dd8:	1b 81       	ldd	r17, Y+3	; 0x03
    3dda:	aa 81       	ldd	r26, Y+2	; 0x02
    3ddc:	b9 81       	ldd	r27, Y+1	; 0x01
    3dde:	ce 0f       	add	r28, r30
    3de0:	d1 1d       	adc	r29, r1
    3de2:	0f b6       	in	r0, 0x3f	; 63
    3de4:	f8 94       	cli
    3de6:	de bf       	out	0x3e, r29	; 62
    3de8:	0f be       	out	0x3f, r0	; 63
    3dea:	cd bf       	out	0x3d, r28	; 61
    3dec:	ed 01       	movw	r28, r26
    3dee:	08 95       	ret

00003df0 <_exit>:
    3df0:	f8 94       	cli

00003df2 <__stop_program>:
    3df2:	ff cf       	rjmp	.-2      	; 0x3df2 <__stop_program>
